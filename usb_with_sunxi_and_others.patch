diff --git a/drivers/Makefile b/drivers/Makefile
index 95952c8..d18aab6 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -74,9 +74,11 @@ obj-$(CONFIG_USB_OTG_UTILS)	+= usb/
 obj-$(CONFIG_USB)		+= usb/
 obj-$(CONFIG_PCI)		+= usb/
 obj-$(CONFIG_USB_GADGET)	+= usb/
+obj-$(CONFIG_USB_SW_SUNXI_USB) += usb/sunxi_usb/
 obj-$(CONFIG_SERIO)		+= input/serio/
 obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
 obj-y				+= i2c/ media/
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 76316a3..5c5caf9 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -17,6 +17,9 @@ config USB_ARCH_HAS_OHCI
 	default y if MFD_TC6393XB
 	default y if ARCH_W90X900
 	default y if ARCH_DAVINCI_DA8XX
+	default y if ARCH_SUN4I
+	default y if ARCH_SUN5I
+	default y if ARCH_SUN7I
 	default y if ARCH_CNS3XXX
 	default y if PLAT_SPEAR
 	default y if ARCH_EXYNOS
@@ -39,6 +42,9 @@ config USB_ARCH_HAS_EHCI
 	default y if ARCH_AT91
 	default y if ARCH_MXC
 	default y if ARCH_OMAP3
+	default y if ARCH_SUN4I
+	default y if ARCH_SUN5I
+	default y if ARCH_SUN7I
 	default y if ARCH_CNS3XXX
 	default y if ARCH_VT8500
 	default y if PLAT_SPEAR
@@ -95,7 +101,7 @@ config USB
 	  traditional PC serial port.  The bus supplies power to peripherals
 	  and allows for hot swapping.  Up to 127 USB peripherals can be
 	  connected to a single USB host in a tree structure.
-	  
+
 	  The USB host is the root of the tree, the peripherals are the
 	  leaves and the inner nodes are special USB devices called hubs.
 	  Most PCs now have USB host ports, used to connect peripherals
@@ -183,4 +189,6 @@ source "drivers/usb/gadget/Kconfig"
 
 source "drivers/usb/otg/Kconfig"
 
+source "drivers/usb/sunxi_usb/Kconfig"
+
 endif # USB_SUPPORT
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 2633f75..8bd50b6 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -494,6 +494,20 @@ config USB_CI13XXX_MSM
 	  dynamically linked module called "ci13xxx_msm" and force all
 	  gadget drivers to also be dynamically linked.
 
+config USB_SW_SUNXI_UDC0_SELECT
+	tristate "SoftWinner SUNXI USB Peripheral Controller"
+	depends on USB_SW_SUNXI_USB_MANAGER
+	select USB_GADGET_DUALSPEED
+	select USB_GADGET_SELECTED
+	select USB_SW_SUNXI_UDC0
+	help
+	   SUNXI USB device/OTG controller driver
+
+	   Note: This is a dummy menu item which selects the real driver. Due
+	   to Kconfig limitation in this kernel version it needs to be tristate
+	   as the other driver options. Even if selected to build as module,
+	   this driver will be built in to kernel image.
+
 #
 # LAST -- dummy/emulated controller
 #
@@ -527,6 +541,14 @@ config USB_DUMMY_HCD
 
 endchoice
 
+#
+# Workaround current module building limitation of sunxi USB
+#
+config USB_SW_SUNXI_UDC0
+	bool
+	depends on USB_SW_SUNXI_USB_MANAGER
+
+
 # Selected by UDC drivers that support high-speed operation.
 config USB_GADGET_DUALSPEED
 	bool
@@ -846,6 +868,15 @@ config USB_G_PRINTER
 	  For more information, see Documentation/usb/gadget_printer.txt
 	  which includes sample code for accessing the device file.
 
+config USB_G_ANDROID
+	boolean "Android Composite Gadget"
+	help
+	  The Android Composite Gadget supports multiple USB
+	  functions: adb, acm, mass storage, mtp, accessory
+	  and rndis.
+	  Each function can be configured and enabled/disabled
+	  dynamically from userspace through a sysfs interface.
+
 config USB_CDC_COMPOSITE
 	tristate "CDC Composite Device (Ethernet and ACM)"
 	depends on NET
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index b7f6eef..b91866a6 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -52,6 +52,7 @@ g_nokia-y			:= nokia.o
 g_webcam-y			:= webcam.o
 g_ncm-y				:= ncm.o
 g_acm_ms-y			:= acm_ms.o
+g_android-y			:= android.o
 
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_AUDIO)		+= g_audio.o
@@ -71,3 +72,4 @@ obj-$(CONFIG_USB_G_NOKIA)	+= g_nokia.o
 obj-$(CONFIG_USB_G_WEBCAM)	+= g_webcam.o
 obj-$(CONFIG_USB_G_NCM)		+= g_ncm.o
 obj-$(CONFIG_USB_G_ACM_MS)	+= g_acm_ms.o
+obj-$(CONFIG_USB_G_ANDROID)	+= g_android.o
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
new file mode 100644
index 0000000..4672921
--- /dev/null
+++ b/drivers/usb/gadget/android.c
@@ -0,0 +1,1700 @@
+/*
+ * Gadget Driver for Android
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *         Benoit Goby <benoit@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+
+#include "gadget_chips.h"
+
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#include "usbstring.c"
+#include "config.c"
+#include "epautoconf.c"
+#include "composite.c"
+
+#include "f_fs.c"
+#include "f_audio_source.c"
+#include "f_mass_storage.c"
+#include "u_serial.c"
+#include "f_acm.c"
+#include "f_adb.c"
+#include "f_mtp.c"
+#include "f_accessory.c"
+#define USB_ETH_RNDIS y
+#include "f_rndis.c"
+#include "rndis.c"
+#include "u_ether.c"
+
+MODULE_AUTHOR("Mike Lockwood");
+MODULE_DESCRIPTION("Android Composite USB Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static const char longname[] = "Gadget Android";
+
+/* Default vendor and product IDs, overridden by userspace */
+#define VENDOR_ID		0x18D1
+#define PRODUCT_ID		0x0001
+
+struct android_usb_function {
+	char *name;
+	void *config;
+
+	struct device *dev;
+	char *dev_name;
+	struct device_attribute **attributes;
+
+	/* for android_dev.enabled_functions */
+	struct list_head enabled_list;
+
+	/* Optional: initialization during gadget bind */
+	int (*init)(struct android_usb_function *, struct usb_composite_dev *);
+	/* Optional: cleanup during gadget unbind */
+	void (*cleanup)(struct android_usb_function *);
+	/* Optional: called when the function is added the list of
+	 *		enabled functions */
+	void (*enable)(struct android_usb_function *);
+	/* Optional: called when it is removed */
+	void (*disable)(struct android_usb_function *);
+
+	int (*bind_config)(struct android_usb_function *,
+			   struct usb_configuration *);
+
+	/* Optional: called when the configuration is removed */
+	void (*unbind_config)(struct android_usb_function *,
+			      struct usb_configuration *);
+	/* Optional: handle ctrl requests before the device is configured */
+	int (*ctrlrequest)(struct android_usb_function *,
+					struct usb_composite_dev *,
+					const struct usb_ctrlrequest *);
+};
+
+struct android_dev {
+	struct android_usb_function **functions;
+	struct list_head enabled_functions;
+	struct usb_composite_dev *cdev;
+	struct device *dev;
+
+	bool enabled;
+	int disable_depth;
+	struct mutex mutex;
+	bool connected;
+	bool sw_connected;
+	struct work_struct work;
+	char ffs_aliases[256];
+};
+
+static struct class *android_class;
+static struct android_dev *_android_dev;
+static int android_bind_config(struct usb_configuration *c);
+static void android_unbind_config(struct usb_configuration *c);
+
+/* string IDs are assigned dynamically */
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
+
+static char manufacturer_string[256];
+static char product_string[256];
+static char serial_string[256];
+
+/* String Table */
+static struct usb_string strings_dev[] = {
+	[STRING_MANUFACTURER_IDX].s = manufacturer_string,
+	[STRING_PRODUCT_IDX].s = product_string,
+	[STRING_SERIAL_IDX].s = serial_string,
+	{  }			/* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength              = sizeof(device_desc),
+	.bDescriptorType      = USB_DT_DEVICE,
+	.bcdUSB               = __constant_cpu_to_le16(0x0200),
+	.bDeviceClass         = USB_CLASS_PER_INTERFACE,
+	.idVendor             = __constant_cpu_to_le16(VENDOR_ID),
+	.idProduct            = __constant_cpu_to_le16(PRODUCT_ID),
+	.bcdDevice            = __constant_cpu_to_le16(0xffff),
+	.bNumConfigurations   = 1,
+};
+
+static struct usb_configuration android_config_driver = {
+	.label		= "android",
+	.unbind		= android_unbind_config,
+	.bConfigurationValue = 1,
+	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+	.bMaxPower	= 0xFA, /* 500ma */
+};
+
+static void android_work(struct work_struct *data)
+{
+	struct android_dev *dev = container_of(data, struct android_dev, work);
+	struct usb_composite_dev *cdev = dev->cdev;
+	char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };
+	char *connected[2]    = { "USB_STATE=CONNECTED", NULL };
+	char *configured[2]   = { "USB_STATE=CONFIGURED", NULL };
+	char **uevent_envp = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		uevent_envp = configured;
+	else if (dev->connected != dev->sw_connected)
+		uevent_envp = dev->connected ? connected : disconnected;
+	dev->sw_connected = dev->connected;
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	if (uevent_envp) {
+		kobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, uevent_envp);
+		pr_info("%s: sent uevent %s\n", __func__, uevent_envp[0]);
+	} else {
+		pr_info("%s: did not send uevent (%d %d %p)\n", __func__,
+			 dev->connected, dev->sw_connected, cdev->config);
+	}
+}
+
+static void android_enable(struct android_dev *dev)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+
+	if (WARN_ON(!dev->disable_depth))
+		return;
+
+	if (--dev->disable_depth == 0) {
+		usb_add_config(cdev, &android_config_driver,
+					android_bind_config);
+		usb_gadget_connect(cdev->gadget);
+	}
+}
+
+static void android_disable(struct android_dev *dev)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+
+	if (dev->disable_depth++ == 0) {
+		usb_gadget_disconnect(cdev->gadget);
+		/* Cancel pending control requests */
+		usb_ep_dequeue(cdev->gadget->ep0, cdev->req);
+		usb_remove_config(cdev, &android_config_driver);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+#include <plat/sys_config.h>
+
+static s32 get_msc_config(struct android_usb_config *config)
+{
+    s32 ret = 0;
+
+    //----------------------------------------
+    //  usb_feature
+    //----------------------------------------
+
+    /* vendor_id */
+    ret = script_parser_fetch("usb_feature", "vendor_id", (int *)&(config->vendor_id), 64);
+	if(ret != 0){
+	    printk("ERR: get usb_feature vendor_id failed\n");
+	}
+
+    /* mass_storage_id */
+    ret = script_parser_fetch("usb_feature", "mass_storage_id", (int *)&(config->mass_storage_id), 64);
+	if(ret != 0){
+	    printk("ERR: get usb_feature mass_storage_id failed\n");
+	}
+
+    /* adb_id */
+    ret = script_parser_fetch("usb_feature", "adb_id", (int *)&(config->adb_id), 64);
+	if(ret != 0){
+	    printk("ERR: get usb_feature adb_id failed\n");
+	}
+
+	/* manufacturer_name */
+    ret = script_parser_fetch("usb_feature", "manufacturer_name", (int *)config->usb_manufacturer_name, 64);
+	if(ret != 0){
+	    printk("ERR: get usb_feature manufacturer_name failed\n");
+	}
+
+	/* product_name */
+    ret = script_parser_fetch("usb_feature", "product_name", (int *)config->usb_product_name, 64);
+	if(ret != 0){
+	    printk("ERR: get usb_feature product_name failed\n");
+	}
+
+	/* serial_number */
+    ret = script_parser_fetch("usb_feature", "serial_number", (int *)config->usb_serial_number, 64);
+	if(ret != 0){
+	    printk("ERR: get usb_feature serial_number failed\n");
+	}
+
+    //----------------------------------------
+    //  msc_feature
+    //----------------------------------------
+
+	/* vendor_name */
+    ret = script_parser_fetch("msc_feature", "vendor_name", (int *)config->msc_vendor_name, 64);
+	if(ret != 0){
+	    printk("ERR: get msc_feature vendor_name failed\n");
+	}
+
+	/* product_name */
+    ret = script_parser_fetch("msc_feature", "product_name", (int *)config->msc_product_name, 64);
+	if(ret != 0){
+	    printk("ERR: get msc_feature product_name failed\n");
+	}
+
+	/* release */
+    ret = script_parser_fetch("msc_feature", "release", (int *)&(config->msc_release), 64);
+	if(ret != 0){
+	    printk("ERR: get msc_feature release failed\n");
+	}
+
+	/* luns */
+    ret = script_parser_fetch("msc_feature", "luns", (int *)&(config->luns), 64);
+	if(ret != 0){
+	    printk("ERR: get msc_feature luns failed\n");
+	}
+
+    return 0;
+}
+
+static void print_msc_config(struct android_usb_config *config)
+{
+    printk("------print_msc_config-----\n");
+    printk("vendor_id             = 0x%x\n", config->vendor_id);
+    printk("mass_storage_id       = 0x%x\n", config->mass_storage_id);
+    printk("adb_id                = 0x%x\n", config->adb_id);
+
+    printk("usb_manufacturer_name = %s\n", config->usb_manufacturer_name);
+    printk("usb_product_name      = %s\n", config->usb_product_name);
+    printk("usb_serial_number     = %s\n", config->usb_serial_number);
+
+    printk("msc_vendor_name       = %s\n", config->msc_vendor_name);
+    printk("msc_product_name      = %s\n", config->msc_product_name);
+    printk("msc_release           = %d\n", config->msc_release);
+    printk("luns                  = %d\n", config->luns);
+    printk("---------------------------\n");
+}
+
+static struct android_usb_config g_android_usb_config;
+
+static s32 modify_device_data(void)
+{
+    struct android_usb_config *config = &g_android_usb_config;
+
+    memset(config, 0, sizeof(struct android_usb_config));
+
+    get_msc_config(config);
+
+    print_msc_config(config);
+
+    return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+/* Supported functions initialization */
+
+struct functionfs_config {
+	bool opened;
+	bool enabled;
+	struct ffs_data *data;
+};
+
+static int ffs_function_init(struct android_usb_function *f,
+			     struct usb_composite_dev *cdev)
+{
+	f->config = kzalloc(sizeof(struct functionfs_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+
+	return functionfs_init();
+}
+
+static void ffs_function_cleanup(struct android_usb_function *f)
+{
+	functionfs_cleanup();
+	kfree(f->config);
+}
+
+static void ffs_function_enable(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = f->config;
+
+	config->enabled = true;
+
+	/* Disable the gadget until the function is ready */
+	if (!config->opened)
+		android_disable(dev);
+}
+
+static void ffs_function_disable(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = f->config;
+
+	config->enabled = false;
+
+	/* Balance the disable that was called in closed_callback */
+	if (!config->opened)
+		android_enable(dev);
+}
+
+static int ffs_function_bind_config(struct android_usb_function *f,
+				    struct usb_configuration *c)
+{
+	struct functionfs_config *config = f->config;
+	return functionfs_bind_config(c->cdev, c, config->data);
+}
+
+static ssize_t
+ffs_aliases_show(struct device *pdev, struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = _android_dev;
+	int ret;
+
+	mutex_lock(&dev->mutex);
+	ret = sprintf(buf, "%s\n", dev->ffs_aliases);
+	mutex_unlock(&dev->mutex);
+
+	return ret;
+}
+
+static ssize_t
+ffs_aliases_store(struct device *pdev, struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct android_dev *dev = _android_dev;
+	char buff[256];
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->enabled) {
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
+	}
+
+	strlcpy(buff, buf, sizeof(buff));
+	strlcpy(dev->ffs_aliases, strim(buff), sizeof(dev->ffs_aliases));
+
+	mutex_unlock(&dev->mutex);
+
+	return size;
+}
+
+static DEVICE_ATTR(aliases, S_IRUGO | S_IWUSR, ffs_aliases_show,
+					       ffs_aliases_store);
+static struct device_attribute *ffs_function_attributes[] = {
+	&dev_attr_aliases,
+	NULL
+};
+
+static struct android_usb_function ffs_function = {
+	.name		= "ffs",
+	.init		= ffs_function_init,
+	.enable		= ffs_function_enable,
+	.disable	= ffs_function_disable,
+	.cleanup	= ffs_function_cleanup,
+	.bind_config	= ffs_function_bind_config,
+	.attributes	= ffs_function_attributes,
+};
+
+static int functionfs_ready_callback(struct ffs_data *ffs)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = ffs_function.config;
+	int ret = 0;
+
+	mutex_lock(&dev->mutex);
+
+	ret = functionfs_bind(ffs, dev->cdev);
+	if (ret)
+		goto err;
+
+	config->data = ffs;
+	config->opened = true;
+
+	if (config->enabled)
+		android_enable(dev);
+
+err:
+	mutex_unlock(&dev->mutex);
+	return ret;
+}
+
+static void functionfs_closed_callback(struct ffs_data *ffs)
+{
+	struct android_dev *dev = _android_dev;
+	struct functionfs_config *config = ffs_function.config;
+
+	mutex_lock(&dev->mutex);
+
+	if (config->enabled)
+		android_disable(dev);
+
+	config->opened = false;
+	config->data = NULL;
+
+	functionfs_unbind(ffs);
+
+	mutex_unlock(&dev->mutex);
+}
+
+static int functionfs_check_dev_callback(const char *dev_name)
+{
+	return 0;
+}
+
+
+struct adb_data {
+	bool opened;
+	bool enabled;
+};
+
+static int
+adb_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	f->config = kzalloc(sizeof(struct adb_data), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+
+	return adb_setup();
+}
+
+static void adb_function_cleanup(struct android_usb_function *f)
+{
+	adb_cleanup();
+	kfree(f->config);
+}
+
+static int
+adb_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return adb_bind_config(c);
+}
+
+static void adb_android_function_enable(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+	struct adb_data *data = f->config;
+
+	data->enabled = true;
+
+	/* Disable the gadget until adbd is ready */
+	if (!data->opened)
+		android_disable(dev);
+}
+
+static void adb_android_function_disable(struct android_usb_function *f)
+{
+	struct android_dev *dev = _android_dev;
+	struct adb_data *data = f->config;
+
+	data->enabled = false;
+
+	/* Balance the disable that was called in closed_callback */
+	if (!data->opened)
+		android_enable(dev);
+}
+
+static struct android_usb_function adb_function = {
+	.name		= "adb",
+	.enable		= adb_android_function_enable,
+	.disable	= adb_android_function_disable,
+	.init		= adb_function_init,
+	.cleanup	= adb_function_cleanup,
+	.bind_config	= adb_function_bind_config,
+};
+
+static void adb_ready_callback(void)
+{
+	struct android_dev *dev = _android_dev;
+	struct adb_data *data = adb_function.config;
+
+	mutex_lock(&dev->mutex);
+
+	data->opened = true;
+
+	if (data->enabled)
+		android_enable(dev);
+
+	mutex_unlock(&dev->mutex);
+}
+
+static void adb_closed_callback(void)
+{
+	struct android_dev *dev = _android_dev;
+	struct adb_data *data = adb_function.config;
+
+	mutex_lock(&dev->mutex);
+
+	data->opened = false;
+
+	if (data->enabled)
+		android_disable(dev);
+
+	mutex_unlock(&dev->mutex);
+}
+
+
+#define MAX_ACM_INSTANCES 4
+struct acm_function_config {
+	int instances;
+};
+
+static int
+acm_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	f->config = kzalloc(sizeof(struct acm_function_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+
+	return gserial_setup(cdev->gadget, MAX_ACM_INSTANCES);
+}
+
+static void acm_function_cleanup(struct android_usb_function *f)
+{
+	gserial_cleanup();
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+acm_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	int i;
+	int ret = 0;
+	struct acm_function_config *config = f->config;
+
+	for (i = 0; i < config->instances; i++) {
+		ret = acm_bind_config(c, i);
+		if (ret) {
+			pr_err("Could not bind acm%u config\n", i);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static ssize_t acm_instances_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+	return sprintf(buf, "%d\n", config->instances);
+}
+
+static ssize_t acm_instances_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct acm_function_config *config = f->config;
+	int value;
+
+	sscanf(buf, "%d", &value);
+	if (value > MAX_ACM_INSTANCES)
+		value = MAX_ACM_INSTANCES;
+	config->instances = value;
+	return size;
+}
+
+static DEVICE_ATTR(instances, S_IRUGO | S_IWUSR, acm_instances_show,
+						 acm_instances_store);
+static struct device_attribute *acm_function_attributes[] = {
+	&dev_attr_instances,
+	NULL
+};
+
+static struct android_usb_function acm_function = {
+	.name		= "acm",
+	.init		= acm_function_init,
+	.cleanup	= acm_function_cleanup,
+	.bind_config	= acm_function_bind_config,
+	.attributes	= acm_function_attributes,
+};
+
+
+static int
+mtp_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	return mtp_setup();
+}
+
+static void mtp_function_cleanup(struct android_usb_function *f)
+{
+	mtp_cleanup();
+}
+
+static int
+mtp_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return mtp_bind_config(c, false);
+}
+
+static int
+ptp_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	/* nothing to do - initialization is handled by mtp_function_init */
+	return 0;
+}
+
+static void ptp_function_cleanup(struct android_usb_function *f)
+{
+	/* nothing to do - cleanup is handled by mtp_function_cleanup */
+}
+
+static int
+ptp_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	return mtp_bind_config(c, true);
+}
+
+static int mtp_function_ctrlrequest(struct android_usb_function *f,
+					struct usb_composite_dev *cdev,
+					const struct usb_ctrlrequest *c)
+{
+	return mtp_ctrlrequest(cdev, c);
+}
+
+static struct android_usb_function mtp_function = {
+	.name		= "mtp",
+	.init		= mtp_function_init,
+	.cleanup	= mtp_function_cleanup,
+	.bind_config	= mtp_function_bind_config,
+	.ctrlrequest	= mtp_function_ctrlrequest,
+};
+
+/* PTP function is same as MTP with slightly different interface descriptor */
+static struct android_usb_function ptp_function = {
+	.name		= "ptp",
+	.init		= ptp_function_init,
+	.cleanup	= ptp_function_cleanup,
+	.bind_config	= ptp_function_bind_config,
+};
+
+
+struct rndis_function_config {
+	u8      ethaddr[ETH_ALEN];
+	u32     vendorID;
+	char	manufacturer[256];
+	/* "Wireless" RNDIS; auto-detected by Windows */
+	bool	wceis;
+};
+
+static int
+rndis_function_init(struct android_usb_function *f,
+		struct usb_composite_dev *cdev)
+{
+	f->config = kzalloc(sizeof(struct rndis_function_config), GFP_KERNEL);
+	if (!f->config)
+		return -ENOMEM;
+	return 0;
+}
+
+static void rndis_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int
+rndis_function_bind_config(struct android_usb_function *f,
+		struct usb_configuration *c)
+{
+	int ret;
+	struct rndis_function_config *rndis = f->config;
+
+	if (!rndis) {
+		pr_err("%s: rndis_pdata\n", __func__);
+		return -1;
+	}
+
+	pr_info("%s MAC: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__,
+		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
+		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
+
+	ret = gether_setup_name(c->cdev->gadget, rndis->ethaddr, "rndis");
+	if (ret) {
+		pr_err("%s: gether_setup failed\n", __func__);
+		return ret;
+	}
+
+	if (rndis->wceis) {
+		/* "Wireless" RNDIS; auto-detected by Windows */
+		rndis_iad_descriptor.bFunctionClass =
+						USB_CLASS_WIRELESS_CONTROLLER;
+		rndis_iad_descriptor.bFunctionSubClass = 0x01;
+		rndis_iad_descriptor.bFunctionProtocol = 0x03;
+		rndis_control_intf.bInterfaceClass =
+						USB_CLASS_WIRELESS_CONTROLLER;
+		rndis_control_intf.bInterfaceSubClass =	 0x01;
+		rndis_control_intf.bInterfaceProtocol =	 0x03;
+	}
+
+	return rndis_bind_config_vendor(c, rndis->ethaddr, rndis->vendorID,
+					   rndis->manufacturer);
+}
+
+static void rndis_function_unbind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	gether_cleanup();
+}
+
+static ssize_t rndis_manufacturer_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	return sprintf(buf, "%s\n", config->manufacturer);
+}
+
+static ssize_t rndis_manufacturer_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+
+	if (size >= sizeof(config->manufacturer))
+		return -EINVAL;
+	if (sscanf(buf, "%s", config->manufacturer) == 1)
+		return size;
+	return -1;
+}
+
+static DEVICE_ATTR(manufacturer, S_IRUGO | S_IWUSR, rndis_manufacturer_show,
+						    rndis_manufacturer_store);
+
+static ssize_t rndis_wceis_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	return sprintf(buf, "%d\n", config->wceis);
+}
+
+static ssize_t rndis_wceis_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	int value;
+
+	if (sscanf(buf, "%d", &value) == 1) {
+		config->wceis = value;
+		return size;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(wceis, S_IRUGO | S_IWUSR, rndis_wceis_show,
+					     rndis_wceis_store);
+
+static ssize_t rndis_ethaddr_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *rndis = f->config;
+	return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		rndis->ethaddr[0], rndis->ethaddr[1], rndis->ethaddr[2],
+		rndis->ethaddr[3], rndis->ethaddr[4], rndis->ethaddr[5]);
+}
+
+static ssize_t rndis_ethaddr_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *rndis = f->config;
+
+	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		    (int *)&rndis->ethaddr[0], (int *)&rndis->ethaddr[1],
+		    (int *)&rndis->ethaddr[2], (int *)&rndis->ethaddr[3],
+		    (int *)&rndis->ethaddr[4], (int *)&rndis->ethaddr[5]) == 6)
+		return size;
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(ethaddr, S_IRUGO | S_IWUSR, rndis_ethaddr_show,
+					       rndis_ethaddr_store);
+
+static ssize_t rndis_vendorID_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	return sprintf(buf, "%04x\n", config->vendorID);
+}
+
+static ssize_t rndis_vendorID_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct rndis_function_config *config = f->config;
+	int value;
+
+	if (sscanf(buf, "%04x", &value) == 1) {
+		config->vendorID = value;
+		return size;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(vendorID, S_IRUGO | S_IWUSR, rndis_vendorID_show,
+						rndis_vendorID_store);
+
+static struct device_attribute *rndis_function_attributes[] = {
+	&dev_attr_manufacturer,
+	&dev_attr_wceis,
+	&dev_attr_ethaddr,
+	&dev_attr_vendorID,
+	NULL
+};
+
+static struct android_usb_function rndis_function = {
+	.name		= "rndis",
+	.init		= rndis_function_init,
+	.cleanup	= rndis_function_cleanup,
+	.bind_config	= rndis_function_bind_config,
+	.unbind_config	= rndis_function_unbind_config,
+	.attributes	= rndis_function_attributes,
+};
+
+
+struct mass_storage_function_config {
+	struct fsg_config fsg;
+	struct fsg_common *common;
+};
+
+static int mass_storage_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	struct mass_storage_function_config *config;
+	struct fsg_common *common;
+	int err;
+	int i = 0;
+
+	config = kzalloc(sizeof(struct mass_storage_function_config),
+								GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+
+    if(g_android_usb_config.luns <= FSG_MAX_LUNS){
+        config->fsg.nluns = g_android_usb_config.luns;
+    }else{
+        printk("err: g_android_usb_config.luns is too big, (%d, 8)\n", g_android_usb_config.luns);
+    }
+
+    for(i = 0; i < config->fsg.nluns; i++){
+        config->fsg.luns[i].removable   = 1;
+        config->fsg.luns[i].ro          = 0;
+        config->fsg.luns[i].cdrom       = 0;
+        config->fsg.luns[i].nofua       = 0;
+    }
+
+	common = fsg_common_init(NULL, cdev, &config->fsg);
+	if (IS_ERR(common)) {
+		kfree(config);
+		return PTR_ERR(common);
+	}
+
+    for(i = 0; i < config->fsg.nluns; i++){
+        char name[32];
+
+        memset(name, 0, 32);
+
+        snprintf(name, 5, "lun%d\n", i);
+
+        printk("lun name: %s\n", name);
+
+        err = sysfs_create_link(&f->dev->kobj,
+                    &common->luns[i].dev.kobj,
+                    name);
+        if (err) {
+            kfree(config);
+            return err;
+        }
+    }
+
+	config->common = common;
+	f->config = config;
+	return 0;
+}
+
+static void mass_storage_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+	f->config = NULL;
+}
+
+static int mass_storage_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct mass_storage_function_config *config = f->config;
+	return fsg_bind_config(c->cdev, c, config->common);
+}
+
+static ssize_t mass_storage_inquiry_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+	return sprintf(buf, "%s\n", config->common->inquiry_string);
+}
+
+static ssize_t mass_storage_inquiry_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct mass_storage_function_config *config = f->config;
+	if (size >= sizeof(config->common->inquiry_string))
+		return -EINVAL;
+	if (sscanf(buf, "%s", config->common->inquiry_string) != 1)
+		return -EINVAL;
+	return size;
+}
+
+static DEVICE_ATTR(inquiry_string, S_IRUGO | S_IWUSR,
+					mass_storage_inquiry_show,
+					mass_storage_inquiry_store);
+
+static struct device_attribute *mass_storage_function_attributes[] = {
+	&dev_attr_inquiry_string,
+	NULL
+};
+
+static struct android_usb_function mass_storage_function = {
+	.name		= "mass_storage",
+	.init		= mass_storage_function_init,
+	.cleanup	= mass_storage_function_cleanup,
+	.bind_config	= mass_storage_function_bind_config,
+	.attributes	= mass_storage_function_attributes,
+};
+
+
+static int accessory_function_init(struct android_usb_function *f,
+					struct usb_composite_dev *cdev)
+{
+	return acc_setup();
+}
+
+static void accessory_function_cleanup(struct android_usb_function *f)
+{
+	acc_cleanup();
+}
+
+static int accessory_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	return acc_bind_config(c);
+}
+
+static int accessory_function_ctrlrequest(struct android_usb_function *f,
+						struct usb_composite_dev *cdev,
+						const struct usb_ctrlrequest *c)
+{
+	return acc_ctrlrequest(cdev, c);
+}
+
+static struct android_usb_function accessory_function = {
+	.name		= "accessory",
+	.init		= accessory_function_init,
+	.cleanup	= accessory_function_cleanup,
+	.bind_config	= accessory_function_bind_config,
+	.ctrlrequest	= accessory_function_ctrlrequest,
+};
+
+static int audio_source_function_init(struct android_usb_function *f,
+			struct usb_composite_dev *cdev)
+{
+	struct audio_source_config *config;
+
+	config = kzalloc(sizeof(struct audio_source_config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	config->card = -1;
+	config->device = -1;
+	f->config = config;
+	return 0;
+}
+
+static void audio_source_function_cleanup(struct android_usb_function *f)
+{
+	kfree(f->config);
+}
+
+static int audio_source_function_bind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct audio_source_config *config = f->config;
+
+	return audio_source_bind_config(c, config);
+}
+
+static void audio_source_function_unbind_config(struct android_usb_function *f,
+						struct usb_configuration *c)
+{
+	struct audio_source_config *config = f->config;
+
+	config->card = -1;
+	config->device = -1;
+}
+
+static ssize_t audio_source_pcm_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct android_usb_function *f = dev_get_drvdata(dev);
+	struct audio_source_config *config = f->config;
+
+	/* print PCM card and device numbers */
+	return sprintf(buf, "%d %d\n", config->card, config->device);
+}
+
+static DEVICE_ATTR(pcm, S_IRUGO | S_IWUSR, audio_source_pcm_show, NULL);
+
+static struct device_attribute *audio_source_function_attributes[] = {
+	&dev_attr_pcm,
+	NULL
+};
+
+static struct android_usb_function audio_source_function = {
+	.name		= "audio_source",
+	.init		= audio_source_function_init,
+	.cleanup	= audio_source_function_cleanup,
+	.bind_config	= audio_source_function_bind_config,
+	.unbind_config	= audio_source_function_unbind_config,
+	.attributes	= audio_source_function_attributes,
+};
+
+static struct android_usb_function *supported_functions[] = {
+	&ffs_function,
+	&adb_function,
+	&acm_function,
+	&mtp_function,
+	&ptp_function,
+	&rndis_function,
+	&mass_storage_function,
+	&accessory_function,
+	&audio_source_function,
+	NULL
+};
+
+
+static int android_init_functions(struct android_usb_function **functions,
+				  struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct android_usb_function *f;
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+	int err;
+	int index = 0;
+
+	for (; (f = *functions++); index++) {
+		f->dev_name = kasprintf(GFP_KERNEL, "f_%s", f->name);
+		f->dev = device_create(android_class, dev->dev,
+				MKDEV(0, index), f, f->dev_name);
+		if (IS_ERR(f->dev)) {
+			pr_err("%s: Failed to create dev %s", __func__,
+							f->dev_name);
+			err = PTR_ERR(f->dev);
+			goto err_create;
+		}
+
+		if (f->init) {
+			err = f->init(f, cdev);
+			if (err) {
+				pr_err("%s: Failed to init %s", __func__,
+								f->name);
+				goto err_out;
+			}
+		}
+
+		attrs = f->attributes;
+		if (attrs) {
+			while ((attr = *attrs++) && !err)
+				err = device_create_file(f->dev, attr);
+		}
+		if (err) {
+			pr_err("%s: Failed to create function %s attributes",
+					__func__, f->name);
+			goto err_out;
+		}
+	}
+	return 0;
+
+err_out:
+	device_destroy(android_class, f->dev->devt);
+err_create:
+	kfree(f->dev_name);
+	return err;
+}
+
+static void android_cleanup_functions(struct android_usb_function **functions)
+{
+	struct android_usb_function *f;
+
+	while (*functions) {
+		f = *functions++;
+
+		if (f->dev) {
+			device_destroy(android_class, f->dev->devt);
+			kfree(f->dev_name);
+		}
+
+		if (f->cleanup)
+			f->cleanup(f);
+	}
+}
+
+static int
+android_bind_enabled_functions(struct android_dev *dev,
+			       struct usb_configuration *c)
+{
+	struct android_usb_function *f;
+	int ret;
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		ret = f->bind_config(f, c);
+		if (ret) {
+			pr_err("%s: %s failed", __func__, f->name);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static void
+android_unbind_enabled_functions(struct android_dev *dev,
+			       struct usb_configuration *c)
+{
+	struct android_usb_function *f;
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		if (f->unbind_config)
+			f->unbind_config(f, c);
+	}
+}
+
+static int android_enable_function(struct android_dev *dev, char *name)
+{
+	struct android_usb_function **functions = dev->functions;
+	struct android_usb_function *f;
+	while ((f = *functions++)) {
+		if (!strcmp(name, f->name)) {
+			list_add_tail(&f->enabled_list,
+						&dev->enabled_functions);
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+/*-------------------------------------------------------------------------*/
+/* /sys/class/android_usb/android%d/ interface */
+
+static ssize_t
+functions_show(struct device *pdev, struct device_attribute *attr, char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	struct android_usb_function *f;
+	char *buff = buf;
+
+	mutex_lock(&dev->mutex);
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list)
+		buff += sprintf(buff, "%s,", f->name);
+
+	mutex_unlock(&dev->mutex);
+
+	if (buff != buf)
+		*(buff-1) = '\n';
+	return buff - buf;
+}
+
+static ssize_t
+functions_store(struct device *pdev, struct device_attribute *attr,
+			       const char *buff, size_t size)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	char *name;
+	char buf[256], *b;
+	char aliases[256], *a;
+	int err;
+	int is_ffs;
+	int ffs_enabled = 0;
+
+	mutex_lock(&dev->mutex);
+
+	if (dev->enabled) {
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
+	}
+
+	INIT_LIST_HEAD(&dev->enabled_functions);
+
+	strlcpy(buf, buff, sizeof(buf));
+	b = strim(buf);
+
+	while (b) {
+		name = strsep(&b, ",");
+		if (!name)
+			continue;
+
+		is_ffs = 0;
+		strlcpy(aliases, dev->ffs_aliases, sizeof(aliases));
+		a = aliases;
+
+		while (a) {
+			char *alias = strsep(&a, ",");
+			if (alias && !strcmp(name, alias)) {
+				is_ffs = 1;
+				break;
+			}
+		}
+
+		if (is_ffs) {
+			if (ffs_enabled)
+				continue;
+			err = android_enable_function(dev, "ffs");
+			if (err)
+				pr_err("android_usb: Cannot enable ffs (%d)",
+									err);
+			else
+				ffs_enabled = 1;
+			continue;
+		}
+
+		err = android_enable_function(dev, name);
+		if (err)
+			pr_err("android_usb: Cannot enable '%s' (%d)",
+							   name, err);
+	}
+
+	mutex_unlock(&dev->mutex);
+
+	return size;
+}
+
+static ssize_t enable_show(struct device *pdev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	return sprintf(buf, "%d\n", dev->enabled);
+}
+
+static ssize_t enable_store(struct device *pdev, struct device_attribute *attr,
+			    const char *buff, size_t size)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct android_usb_function *f;
+	int enabled = 0;
+
+
+	if (!cdev)
+		return -ENODEV;
+
+	mutex_lock(&dev->mutex);
+
+	sscanf(buff, "%d", &enabled);
+	if (enabled && !dev->enabled) {
+		/*
+		 * Update values in composite driver's copy of
+		 * device descriptor.
+		 */
+		cdev->desc.idVendor = device_desc.idVendor;
+		cdev->desc.idProduct = device_desc.idProduct;
+		cdev->desc.bcdDevice = device_desc.bcdDevice;
+		cdev->desc.bDeviceClass = device_desc.bDeviceClass;
+		cdev->desc.bDeviceSubClass = device_desc.bDeviceSubClass;
+		cdev->desc.bDeviceProtocol = device_desc.bDeviceProtocol;
+		list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+			if (f->enable)
+				f->enable(f);
+		}
+		android_enable(dev);
+		dev->enabled = true;
+	} else if (!enabled && dev->enabled) {
+		android_disable(dev);
+		list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+			if (f->disable)
+				f->disable(f);
+		}
+		dev->enabled = false;
+	} else {
+		pr_err("android_usb: already %s\n",
+				dev->enabled ? "enabled" : "disabled");
+	}
+
+	mutex_unlock(&dev->mutex);
+	return size;
+}
+
+static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct android_dev *dev = dev_get_drvdata(pdev);
+	struct usb_composite_dev *cdev = dev->cdev;
+	char *state = "DISCONNECTED";
+	unsigned long flags;
+
+	if (!cdev)
+		goto out;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		state = "CONFIGURED";
+	else if (dev->connected)
+		state = "CONNECTED";
+	spin_unlock_irqrestore(&cdev->lock, flags);
+out:
+	return sprintf(buf, "%s\n", state);
+}
+
+#define DESCRIPTOR_ATTR(field, format_string)				\
+static ssize_t								\
+field ## _show(struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	return sprintf(buf, format_string, device_desc.field);		\
+}									\
+static ssize_t								\
+field ## _store(struct device *dev, struct device_attribute *attr,	\
+		const char *buf, size_t size)				\
+{									\
+	int value;							\
+	if (sscanf(buf, format_string, &value) == 1) {			\
+		device_desc.field = value;				\
+		return size;						\
+	}								\
+	return -1;							\
+}									\
+static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
+
+#define DESCRIPTOR_STRING_ATTR(field, buffer)				\
+static ssize_t								\
+field ## _show(struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
+{									\
+	return sprintf(buf, "%s", buffer);				\
+}									\
+static ssize_t								\
+field ## _store(struct device *dev, struct device_attribute *attr,	\
+		const char *buf, size_t size)				\
+{									\
+	if (size >= sizeof(buffer))					\
+		return -EINVAL;						\
+	return strlcpy(buffer, buf, sizeof(buffer));			\
+}									\
+static DEVICE_ATTR(field, S_IRUGO | S_IWUSR, field ## _show, field ## _store);
+
+
+DESCRIPTOR_ATTR(idVendor, "%04x\n")
+DESCRIPTOR_ATTR(idProduct, "%04x\n")
+DESCRIPTOR_ATTR(bcdDevice, "%04x\n")
+DESCRIPTOR_ATTR(bDeviceClass, "%d\n")
+DESCRIPTOR_ATTR(bDeviceSubClass, "%d\n")
+DESCRIPTOR_ATTR(bDeviceProtocol, "%d\n")
+DESCRIPTOR_STRING_ATTR(iManufacturer, manufacturer_string)
+DESCRIPTOR_STRING_ATTR(iProduct, product_string)
+DESCRIPTOR_STRING_ATTR(iSerial, serial_string)
+
+static DEVICE_ATTR(functions, S_IRUGO | S_IWUSR, functions_show,
+						 functions_store);
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, enable_show, enable_store);
+static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
+
+static struct device_attribute *android_usb_attributes[] = {
+	&dev_attr_idVendor,
+	&dev_attr_idProduct,
+	&dev_attr_bcdDevice,
+	&dev_attr_bDeviceClass,
+	&dev_attr_bDeviceSubClass,
+	&dev_attr_bDeviceProtocol,
+	&dev_attr_iManufacturer,
+	&dev_attr_iProduct,
+	&dev_attr_iSerial,
+	&dev_attr_functions,
+	&dev_attr_enable,
+	&dev_attr_state,
+	NULL
+};
+
+/*-------------------------------------------------------------------------*/
+/* Composite driver */
+
+static int android_bind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+	int ret = 0;
+
+	ret = android_bind_enabled_functions(dev, c);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void android_unbind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+
+	android_unbind_enabled_functions(dev, c);
+}
+
+static int android_bind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct usb_gadget	*gadget = cdev->gadget;
+	int			gcnum, id, ret;
+
+	/*
+	 * Start disconnected. Userspace will connect the gadget once
+	 * it is done configuring the functions.
+	 */
+	usb_gadget_disconnect(gadget);
+
+	ret = android_init_functions(dev->functions, cdev);
+	if (ret)
+		return ret;
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_MANUFACTURER_IDX].id = id;
+	device_desc.iManufacturer = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_PRODUCT_IDX].id = id;
+	device_desc.iProduct = id;
+
+	/* Default strings - should be updated by userspace */
+	strncpy(manufacturer_string, "Android", sizeof(manufacturer_string)-1);
+	strncpy(product_string, "Android", sizeof(product_string) - 1);
+	strncpy(serial_string, "0123456789ABCDEF", sizeof(serial_string) - 1);
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_SERIAL_IDX].id = id;
+	device_desc.iSerialNumber = id;
+
+	gcnum = usb_gadget_controller_number(gadget);
+	if (gcnum >= 0)
+		device_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);
+	else {
+		pr_warning("%s: controller '%s' not recognized\n",
+			longname, gadget->name);
+		device_desc.bcdDevice = __constant_cpu_to_le16(0x9999);
+	}
+
+	usb_gadget_set_selfpowered(gadget);
+	dev->cdev = cdev;
+
+	return 0;
+}
+
+static int android_usb_unbind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+
+	cancel_work_sync(&dev->work);
+	android_cleanup_functions(dev->functions);
+	return 0;
+}
+
+static struct usb_composite_driver android_usb_driver = {
+	.name		= "android_usb",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.unbind		= android_usb_unbind,
+	.max_speed	= USB_SPEED_HIGH,
+};
+
+static int
+android_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *c)
+{
+	struct android_dev		*dev = _android_dev;
+	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
+	struct usb_request		*req = cdev->req;
+	struct android_usb_function	*f;
+	int value = -EOPNOTSUPP;
+	unsigned long flags;
+
+	req->zero = 0;
+	req->complete = composite_setup_complete;
+	req->length = 0;
+	gadget->ep0->driver_data = cdev;
+
+	list_for_each_entry(f, &dev->enabled_functions, enabled_list) {
+		if (f->ctrlrequest) {
+			value = f->ctrlrequest(f, cdev, c);
+			if (value >= 0)
+				break;
+		}
+	}
+
+	/* Special case the accessory function.
+	 * It needs to handle control requests before it is enabled.
+	 */
+	if (value < 0)
+		value = acc_ctrlrequest(cdev, c);
+
+	if (value < 0)
+		value = composite_setup(gadget, c);
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (!dev->connected) {
+		dev->connected = 1;
+		schedule_work(&dev->work);
+	} else if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
+						cdev->config) {
+		schedule_work(&dev->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	return value;
+}
+
+static void android_disconnect(struct usb_gadget *gadget)
+{
+	struct android_dev *dev = _android_dev;
+	struct usb_composite_dev *cdev = get_gadget_data(gadget);
+	unsigned long flags;
+
+	composite_disconnect(gadget);
+	/* accessory HID support can be active while the
+	   accessory function is not actually enabled,
+	   so we need to inform it when we are disconnected.
+	 */
+	acc_disconnect();
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	dev->connected = 0;
+	schedule_work(&dev->work);
+	spin_unlock_irqrestore(&cdev->lock, flags);
+}
+
+static int android_create_device(struct android_dev *dev)
+{
+	struct device_attribute **attrs = android_usb_attributes;
+	struct device_attribute *attr;
+	int err;
+
+	dev->dev = device_create(android_class, NULL,
+					MKDEV(0, 0), NULL, "android0");
+	if (IS_ERR(dev->dev))
+		return PTR_ERR(dev->dev);
+
+	dev_set_drvdata(dev->dev, dev);
+
+	while ((attr = *attrs++)) {
+		err = device_create_file(dev->dev, attr);
+		if (err) {
+			device_destroy(android_class, dev->dev->devt);
+			return err;
+		}
+	}
+	return 0;
+}
+
+
+static int __init init(void)
+{
+	struct android_dev *dev;
+	int err;
+
+    modify_device_data();
+
+	android_class = class_create(THIS_MODULE, "android_usb");
+	if (IS_ERR(android_class))
+		return PTR_ERR(android_class);
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->disable_depth = 1;
+	dev->functions = supported_functions;
+	INIT_LIST_HEAD(&dev->enabled_functions);
+	INIT_WORK(&dev->work, android_work);
+	mutex_init(&dev->mutex);
+
+	err = android_create_device(dev);
+	if (err) {
+		class_destroy(android_class);
+		kfree(dev);
+		return err;
+	}
+
+	_android_dev = dev;
+
+	/* Override composite driver functions */
+	composite_driver.setup = android_setup;
+	composite_driver.disconnect = android_disconnect;
+
+	return usb_composite_probe(&android_usb_driver, android_bind);
+}
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&android_usb_driver);
+	class_destroy(android_class);
+	kfree(_android_dev);
+	_android_dev = NULL;
+}
+module_exit(cleanup);
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index baaebf2..c4f72d8 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -734,6 +734,7 @@ int usb_add_config(struct usb_composite_dev *cdev,
 
 	INIT_LIST_HEAD(&config->functions);
 	config->next_interface_id = 0;
+	memset(config->interface, 0, sizeof(config->interface));
 
 	status = bind(config);
 	if (status < 0) {
@@ -774,6 +775,55 @@ done:
 	return status;
 }
 
+static int unbind_config(struct usb_composite_dev *cdev,
+			      struct usb_configuration *config)
+{
+	while (!list_empty(&config->functions)) {
+		struct usb_function		*f;
+
+		f = list_first_entry(&config->functions,
+				struct usb_function, list);
+		list_del(&f->list);
+		if (f->unbind) {
+			DBG(cdev, "unbind function '%s'/%p\n", f->name, f);
+			f->unbind(config, f);
+			/* may free memory for "f" */
+		}
+	}
+	if (config->unbind) {
+		DBG(cdev, "unbind config '%s'/%p\n", config->label, config);
+		config->unbind(config);
+			/* may free memory for "c" */
+	}
+	return 0;
+}
+
+/**
+ * usb_remove_config() - remove a configuration from a device.
+ * @cdev: wraps the USB gadget
+ * @config: the configuration
+ *
+ * Drivers must call usb_gadget_disconnect before calling this function
+ * to disconnect the device from the host and make sure the host will not
+ * try to enumerate the device while we are changing the config list.
+ */
+int usb_remove_config(struct usb_composite_dev *cdev,
+		      struct usb_configuration *config)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+
+	if (cdev->config == config)
+		reset_config(cdev);
+
+	list_del(&config->list);
+
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	return unbind_config(cdev, config);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* We support strings in multiple languages ... string descriptor zero
@@ -1328,28 +1378,10 @@ composite_unbind(struct usb_gadget *gadget)
 
 	while (!list_empty(&cdev->configs)) {
 		struct usb_configuration	*c;
-
 		c = list_first_entry(&cdev->configs,
 				struct usb_configuration, list);
-		while (!list_empty(&c->functions)) {
-			struct usb_function		*f;
-
-			f = list_first_entry(&c->functions,
-					struct usb_function, list);
-			list_del(&f->list);
-			if (f->unbind) {
-				DBG(cdev, "unbind function '%s'/%p\n",
-						f->name, f);
-				f->unbind(c, f);
-				/* may free memory for "f" */
-			}
-		}
 		list_del(&c->list);
-		if (c->unbind) {
-			DBG(cdev, "unbind config '%s'/%p\n", c->label, c);
-			c->unbind(c);
-			/* may free memory for "c" */
-		}
+		unbind_config(cdev, c);
 	}
 	if (composite->unbind)
 		composite->unbind(cdev);
@@ -1641,3 +1673,4 @@ void usb_composite_setup_continue(struct usb_composite_dev *cdev)
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 
+
diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 51f3d42..8c6705c 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -64,8 +64,11 @@ ep_matches (
 	int		num_req_streams = 0;
 
 	/* endpoint already claimed? */
-	if (NULL != ep->driver_data)
+	if (NULL != ep->driver_data) {
+	    printk("%s, wrn: endpoint already claimed, ep(0x%p, 0x%p, %s)\n", __func__,
+	           ep, ep->driver_data, ep->name);
 		return 0;
+	}
 
 	/* only support ep0 for portable CONTROL traffic */
 	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
@@ -87,14 +90,28 @@ ep_matches (
 				/* bulk endpoints handle interrupt transfers,
 				 * except the toggle-quirky iso-synch kind
 				 */
-				if ('s' == tmp[2])	// == "-iso"
+				if ('s' == tmp[2]){	// == "-iso"
+				    printk("-iso\n");
 					return 0;
+				}
+
 				/* for now, avoid PXA "interrupt-in";
 				 * it's documented as never using DATA1.
 				 */
-				if (gadget_is_pxa (gadget)
-						&& 'i' == tmp [1])
+				if (gadget_is_pxa (gadget) && 'i' == tmp [1]){
+				    printk("11111\n");
 					return 0;
+				}
+
+
+#if 0
+                /* softwinner otg support -int */
+			    if(gadget_is_softwinner_otg(gadget) && 'n' != tmp [2]){
+			        printk("3333333\n");
+			        return 0;
+			    }
+#endif
+
 				break;
 			case USB_ENDPOINT_XFER_BULK:
 				if ('b' != tmp[1])	// != "-bulk"
diff --git a/drivers/usb/gadget/f_accessory.c b/drivers/usb/gadget/f_accessory.c
new file mode 100644
index 0000000..a244265
--- /dev/null
+++ b/drivers/usb/gadget/f_accessory.c
@@ -0,0 +1,1180 @@
+/*
+ * Gadget Function Driver for Android USB accessories
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+
+#include <linux/types.h>
+#include <linux/file.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include <linux/hid.h>
+#include <linux/hiddev.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/f_accessory.h>
+
+#define BULK_BUFFER_SIZE    16384
+#define ACC_STRING_SIZE     256
+
+#define PROTOCOL_VERSION    2
+
+/* String IDs */
+#define INTERFACE_STRING_INDEX	0
+
+/* number of tx and rx requests to allocate */
+#define TX_REQ_MAX 4
+#define RX_REQ_MAX 2
+
+struct acc_hid_dev {
+	struct list_head	list;
+	struct hid_device *hid;
+	struct acc_dev *dev;
+	/* accessory defined ID */
+	int id;
+	/* HID report descriptor */
+	u8 *report_desc;
+	/* length of HID report descriptor */
+	int report_desc_len;
+	/* number of bytes of report_desc we have received so far */
+	int report_desc_offset;
+};
+
+struct acc_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+
+	struct usb_ep *ep_in;
+	struct usb_ep *ep_out;
+
+	/* set to 1 when we connect */
+	int online:1;
+	/* Set to 1 when we disconnect.
+	 * Not cleared until our file is closed.
+	 */
+	int disconnected:1;
+
+	/* strings sent by the host */
+	char manufacturer[ACC_STRING_SIZE];
+	char model[ACC_STRING_SIZE];
+	char description[ACC_STRING_SIZE];
+	char version[ACC_STRING_SIZE];
+	char uri[ACC_STRING_SIZE];
+	char serial[ACC_STRING_SIZE];
+
+	/* for acc_complete_set_string */
+	int string_index;
+
+	/* set to 1 if we have a pending start request */
+	int start_requested;
+
+	int audio_mode;
+
+	/* synchronize access to our device file */
+	atomic_t open_excl;
+
+	struct list_head tx_idle;
+
+	wait_queue_head_t read_wq;
+	wait_queue_head_t write_wq;
+	struct usb_request *rx_req[RX_REQ_MAX];
+	int rx_done;
+
+	/* delayed work for handling ACCESSORY_START */
+	struct delayed_work start_work;
+
+	/* worker for registering and unregistering hid devices */
+	struct work_struct hid_work;
+
+	/* list of active HID devices */
+	struct list_head	hid_list;
+
+	/* list of new HID devices to register */
+	struct list_head	new_hid_list;
+
+	/* list of dead HID devices to unregister */
+	struct list_head	dead_hid_list;
+};
+
+static struct usb_interface_descriptor acc_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bInterfaceNumber       = 0,
+	.bNumEndpoints          = 2,
+	.bInterfaceClass        = USB_CLASS_VENDOR_SPEC,
+	.bInterfaceSubClass     = USB_SUBCLASS_VENDOR_SPEC,
+	.bInterfaceProtocol     = 0,
+};
+
+static struct usb_endpoint_descriptor acc_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor acc_highspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor acc_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor acc_fullspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_descriptor_header *fs_acc_descs[] = {
+	(struct usb_descriptor_header *) &acc_interface_desc,
+	(struct usb_descriptor_header *) &acc_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &acc_fullspeed_out_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_acc_descs[] = {
+	(struct usb_descriptor_header *) &acc_interface_desc,
+	(struct usb_descriptor_header *) &acc_highspeed_in_desc,
+	(struct usb_descriptor_header *) &acc_highspeed_out_desc,
+	NULL,
+};
+
+static struct usb_string acc_string_defs[] = {
+	[INTERFACE_STRING_INDEX].s	= "Android Accessory Interface",
+	{  },	/* end of list */
+};
+
+static struct usb_gadget_strings acc_string_table = {
+	.language		= 0x0409,	/* en-US */
+	.strings		= acc_string_defs,
+};
+
+static struct usb_gadget_strings *acc_strings[] = {
+	&acc_string_table,
+	NULL,
+};
+
+/* temporary variable used between acc_open() and acc_gadget_bind() */
+static struct acc_dev *_acc_dev;
+
+static inline struct acc_dev *func_to_dev(struct usb_function *f)
+{
+	return container_of(f, struct acc_dev, function);
+}
+
+static struct usb_request *acc_request_new(struct usb_ep *ep, int buffer_size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void acc_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+/* add a request to the tail of a list */
+static void req_put(struct acc_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct usb_request *req_get(struct acc_dev *dev, struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void acc_set_disconnected(struct acc_dev *dev)
+{
+	dev->online = 0;
+	dev->disconnected = 1;
+}
+
+static void acc_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct acc_dev *dev = _acc_dev;
+
+	if (req->status != 0)
+		acc_set_disconnected(dev);
+
+	req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static void acc_complete_out(struct usb_ep *ep, struct usb_request *req)
+{
+	struct acc_dev *dev = _acc_dev;
+
+	dev->rx_done = 1;
+	if (req->status != 0)
+		acc_set_disconnected(dev);
+
+	wake_up(&dev->read_wq);
+}
+
+static void acc_complete_set_string(struct usb_ep *ep, struct usb_request *req)
+{
+	struct acc_dev	*dev = ep->driver_data;
+	char *string_dest = NULL;
+	int length = req->actual;
+
+	if (req->status != 0) {
+		pr_err("acc_complete_set_string, err %d\n", req->status);
+		return;
+	}
+
+	switch (dev->string_index) {
+	case ACCESSORY_STRING_MANUFACTURER:
+		string_dest = dev->manufacturer;
+		break;
+	case ACCESSORY_STRING_MODEL:
+		string_dest = dev->model;
+		break;
+	case ACCESSORY_STRING_DESCRIPTION:
+		string_dest = dev->description;
+		break;
+	case ACCESSORY_STRING_VERSION:
+		string_dest = dev->version;
+		break;
+	case ACCESSORY_STRING_URI:
+		string_dest = dev->uri;
+		break;
+	case ACCESSORY_STRING_SERIAL:
+		string_dest = dev->serial;
+		break;
+	}
+	if (string_dest) {
+		unsigned long flags;
+
+		if (length >= ACC_STRING_SIZE)
+			length = ACC_STRING_SIZE - 1;
+
+		spin_lock_irqsave(&dev->lock, flags);
+		memcpy(string_dest, req->buf, length);
+		/* ensure zero termination */
+		string_dest[length] = 0;
+		spin_unlock_irqrestore(&dev->lock, flags);
+	} else {
+		pr_err("unknown accessory string index %d\n",
+			dev->string_index);
+	}
+}
+
+static void acc_complete_set_hid_report_desc(struct usb_ep *ep,
+		struct usb_request *req)
+{
+	struct acc_hid_dev *hid = req->context;
+	struct acc_dev *dev = hid->dev;
+	int length = req->actual;
+
+	if (req->status != 0) {
+		pr_err("acc_complete_set_hid_report_desc, err %d\n",
+			req->status);
+		return;
+	}
+
+	memcpy(hid->report_desc + hid->report_desc_offset, req->buf, length);
+	hid->report_desc_offset += length;
+	if (hid->report_desc_offset == hid->report_desc_len) {
+		/* After we have received the entire report descriptor
+		 * we schedule work to initialize the HID device
+		 */
+		schedule_work(&dev->hid_work);
+	}
+}
+
+static void acc_complete_send_hid_event(struct usb_ep *ep,
+		struct usb_request *req)
+{
+	struct acc_hid_dev *hid = req->context;
+	int length = req->actual;
+
+	if (req->status != 0) {
+		pr_err("acc_complete_send_hid_event, err %d\n", req->status);
+		return;
+	}
+
+	hid_report_raw_event(hid->hid, HID_INPUT_REPORT, req->buf, length, 1);
+}
+
+static int acc_hid_parse(struct hid_device *hid)
+{
+	struct acc_hid_dev *hdev = hid->driver_data;
+
+	hid_parse_report(hid, hdev->report_desc, hdev->report_desc_len);
+	return 0;
+}
+
+static int acc_hid_start(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void acc_hid_stop(struct hid_device *hid)
+{
+}
+
+static int acc_hid_open(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void acc_hid_close(struct hid_device *hid)
+{
+}
+
+static struct hid_ll_driver acc_hid_ll_driver = {
+	.parse = acc_hid_parse,
+	.start = acc_hid_start,
+	.stop = acc_hid_stop,
+	.open = acc_hid_open,
+	.close = acc_hid_close,
+};
+
+static struct acc_hid_dev *acc_hid_new(struct acc_dev *dev,
+		int id, int desc_len)
+{
+	struct acc_hid_dev *hdev;
+
+	hdev = kzalloc(sizeof(*hdev), GFP_ATOMIC);
+	if (!hdev)
+		return NULL;
+	hdev->report_desc = kzalloc(desc_len, GFP_ATOMIC);
+	if (!hdev->report_desc) {
+		kfree(hdev);
+		return NULL;
+	}
+	hdev->dev = dev;
+	hdev->id = id;
+	hdev->report_desc_len = desc_len;
+
+	return hdev;
+}
+
+static struct acc_hid_dev *acc_hid_get(struct list_head *list, int id)
+{
+	struct acc_hid_dev *hid;
+
+	list_for_each_entry(hid, list, list) {
+		if (hid->id == id)
+			return hid;
+	}
+	return NULL;
+}
+
+static int acc_register_hid(struct acc_dev *dev, int id, int desc_length)
+{
+	struct acc_hid_dev *hid;
+	unsigned long flags;
+
+	/* report descriptor length must be > 0 */
+	if (desc_length <= 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	/* replace HID if one already exists with this ID */
+	hid = acc_hid_get(&dev->hid_list, id);
+	if (!hid)
+		hid = acc_hid_get(&dev->new_hid_list, id);
+	if (hid)
+		list_move(&hid->list, &dev->dead_hid_list);
+
+	hid = acc_hid_new(dev, id, desc_length);
+	if (!hid) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -ENOMEM;
+	}
+
+	list_add(&hid->list, &dev->new_hid_list);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	/* schedule work to register the HID device */
+	schedule_work(&dev->hid_work);
+	return 0;
+}
+
+static int acc_unregister_hid(struct acc_dev *dev, int id)
+{
+	struct acc_hid_dev *hid;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	hid = acc_hid_get(&dev->hid_list, id);
+	if (!hid)
+		hid = acc_hid_get(&dev->new_hid_list, id);
+	if (!hid) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -EINVAL;
+	}
+
+	list_move(&hid->list, &dev->dead_hid_list);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	schedule_work(&dev->hid_work);
+	return 0;
+}
+
+static int create_bulk_endpoints(struct acc_dev *dev,
+				struct usb_endpoint_descriptor *in_desc,
+				struct usb_endpoint_descriptor *out_desc)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	DBG(cdev, "create_bulk_endpoints dev: %p\n", dev);
+
+	ep = usb_ep_autoconfig(cdev->gadget, in_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_in failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for ep_in got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for ep_out got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for ep_out got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	/* now allocate requests for our endpoints */
+	for (i = 0; i < TX_REQ_MAX; i++) {
+		req = acc_request_new(dev->ep_in, BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = acc_complete_in;
+		req_put(dev, &dev->tx_idle, req);
+	}
+	for (i = 0; i < RX_REQ_MAX; i++) {
+		req = acc_request_new(dev->ep_out, BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = acc_complete_out;
+		dev->rx_req[i] = req;
+	}
+
+	return 0;
+
+fail:
+	pr_err("acc_bind() could not allocate requests\n");
+	while ((req = req_get(dev, &dev->tx_idle)))
+		acc_request_free(req, dev->ep_in);
+	for (i = 0; i < RX_REQ_MAX; i++)
+		acc_request_free(dev->rx_req[i], dev->ep_out);
+	return -1;
+}
+
+static ssize_t acc_read(struct file *fp, char __user *buf,
+	size_t count, loff_t *pos)
+{
+	struct acc_dev *dev = fp->private_data;
+	struct usb_request *req;
+	int r = count, xfer;
+	int ret = 0;
+
+	pr_debug("acc_read(%d)\n", count);
+
+	if (dev->disconnected)
+		return -ENODEV;
+
+	if (count > BULK_BUFFER_SIZE)
+		count = BULK_BUFFER_SIZE;
+
+	/* we will block until we're online */
+	pr_debug("acc_read: waiting for online\n");
+	ret = wait_event_interruptible(dev->read_wq, dev->online);
+	if (ret < 0) {
+		r = ret;
+		goto done;
+	}
+
+requeue_req:
+	/* queue a request */
+	req = dev->rx_req[0];
+	req->length = count;
+	dev->rx_done = 0;
+	ret = usb_ep_queue(dev->ep_out, req, GFP_KERNEL);
+	if (ret < 0) {
+		r = -EIO;
+		goto done;
+	} else {
+		pr_debug("rx %p queue\n", req);
+	}
+
+	/* wait for a request to complete */
+	ret = wait_event_interruptible(dev->read_wq, dev->rx_done);
+	if (ret < 0) {
+		r = ret;
+		usb_ep_dequeue(dev->ep_out, req);
+		goto done;
+	}
+	if (dev->online) {
+		/* If we got a 0-len packet, throw it back and try again. */
+		if (req->actual == 0)
+			goto requeue_req;
+
+		pr_debug("rx %p %d\n", req, req->actual);
+		xfer = (req->actual < count) ? req->actual : count;
+		r = xfer;
+		if (copy_to_user(buf, req->buf, xfer))
+			r = -EFAULT;
+	} else
+		r = -EIO;
+
+done:
+	pr_debug("acc_read returning %d\n", r);
+	return r;
+}
+
+static ssize_t acc_write(struct file *fp, const char __user *buf,
+	size_t count, loff_t *pos)
+{
+	struct acc_dev *dev = fp->private_data;
+	struct usb_request *req = 0;
+	int r = count, xfer;
+	int ret;
+
+	pr_debug("acc_write(%d)\n", count);
+
+	if (!dev->online || dev->disconnected)
+		return -ENODEV;
+
+	while (count > 0) {
+		if (!dev->online) {
+			pr_debug("acc_write dev->error\n");
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+			((req = req_get(dev, &dev->tx_idle)) || !dev->online));
+		if (!req) {
+			r = ret;
+			break;
+		}
+
+		if (count > BULK_BUFFER_SIZE)
+			xfer = BULK_BUFFER_SIZE;
+		else
+			xfer = count;
+		if (copy_from_user(req->buf, buf, xfer)) {
+			r = -EFAULT;
+			break;
+		}
+
+		req->length = xfer;
+		ret = usb_ep_queue(dev->ep_in, req, GFP_KERNEL);
+		if (ret < 0) {
+			pr_debug("acc_write: xfer error %d\n", ret);
+			r = -EIO;
+			break;
+		}
+
+		buf += xfer;
+		count -= xfer;
+
+		/* zero this so we don't try to free it on error exit */
+		req = 0;
+	}
+
+	if (req)
+		req_put(dev, &dev->tx_idle, req);
+
+	pr_debug("acc_write returning %d\n", r);
+	return r;
+}
+
+static long acc_ioctl(struct file *fp, unsigned code, unsigned long value)
+{
+	struct acc_dev *dev = fp->private_data;
+	char *src = NULL;
+	int ret;
+
+	switch (code) {
+	case ACCESSORY_GET_STRING_MANUFACTURER:
+		src = dev->manufacturer;
+		break;
+	case ACCESSORY_GET_STRING_MODEL:
+		src = dev->model;
+		break;
+	case ACCESSORY_GET_STRING_DESCRIPTION:
+		src = dev->description;
+		break;
+	case ACCESSORY_GET_STRING_VERSION:
+		src = dev->version;
+		break;
+	case ACCESSORY_GET_STRING_URI:
+		src = dev->uri;
+		break;
+	case ACCESSORY_GET_STRING_SERIAL:
+		src = dev->serial;
+		break;
+	case ACCESSORY_IS_START_REQUESTED:
+		return dev->start_requested;
+	case ACCESSORY_GET_AUDIO_MODE:
+		return dev->audio_mode;
+	}
+	if (!src)
+		return -EINVAL;
+
+	ret = strlen(src) + 1;
+	if (copy_to_user((void __user *)value, src, ret))
+		ret = -EFAULT;
+	return ret;
+}
+
+static int acc_open(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "acc_open\n");
+	if (atomic_xchg(&_acc_dev->open_excl, 1))
+		return -EBUSY;
+
+	_acc_dev->disconnected = 0;
+	fp->private_data = _acc_dev;
+	return 0;
+}
+
+static int acc_release(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "acc_release\n");
+
+	WARN_ON(!atomic_xchg(&_acc_dev->open_excl, 0));
+	_acc_dev->disconnected = 0;
+	return 0;
+}
+
+/* file operations for /dev/usb_accessory */
+static const struct file_operations acc_fops = {
+	.owner = THIS_MODULE,
+	.read = acc_read,
+	.write = acc_write,
+	.unlocked_ioctl = acc_ioctl,
+	.open = acc_open,
+	.release = acc_release,
+};
+
+static int acc_hid_probe(struct hid_device *hdev,
+		const struct hid_device_id *id)
+{
+	int ret;
+
+	ret = hid_parse(hdev);
+	if (ret)
+		return ret;
+	return hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+}
+
+static struct miscdevice acc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "usb_accessory",
+	.fops = &acc_fops,
+};
+
+static const struct hid_device_id acc_hid_table[] = {
+	{ HID_USB_DEVICE(HID_ANY_ID, HID_ANY_ID) },
+	{ }
+};
+
+static struct hid_driver acc_hid_driver = {
+	.name = "USB accessory",
+	.id_table = acc_hid_table,
+	.probe = acc_hid_probe,
+};
+
+static int acc_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl)
+{
+	struct acc_dev	*dev = _acc_dev;
+	int	value = -EOPNOTSUPP;
+	struct acc_hid_dev *hid;
+	int offset;
+	u8 b_requestType = ctrl->bRequestType;
+	u8 b_request = ctrl->bRequest;
+	u16	w_index = le16_to_cpu(ctrl->wIndex);
+	u16	w_value = le16_to_cpu(ctrl->wValue);
+	u16	w_length = le16_to_cpu(ctrl->wLength);
+	unsigned long flags;
+
+/*
+	printk(KERN_INFO "acc_ctrlrequest "
+			"%02x.%02x v%04x i%04x l%u\n",
+			b_requestType, b_request,
+			w_value, w_index, w_length);
+*/
+
+	if (b_requestType == (USB_DIR_OUT | USB_TYPE_VENDOR)) {
+		if (b_request == ACCESSORY_START) {
+			dev->start_requested = 1;
+			schedule_delayed_work(
+				&dev->start_work, msecs_to_jiffies(10));
+			value = 0;
+		} else if (b_request == ACCESSORY_SEND_STRING) {
+			dev->string_index = w_index;
+			cdev->gadget->ep0->driver_data = dev;
+			cdev->req->complete = acc_complete_set_string;
+			value = w_length;
+		} else if (b_request == ACCESSORY_SET_AUDIO_MODE &&
+				w_index == 0 && w_length == 0) {
+			dev->audio_mode = w_value;
+			value = 0;
+		} else if (b_request == ACCESSORY_REGISTER_HID) {
+			value = acc_register_hid(dev, w_value, w_index);
+		} else if (b_request == ACCESSORY_UNREGISTER_HID) {
+			value = acc_unregister_hid(dev, w_value);
+		} else if (b_request == ACCESSORY_SET_HID_REPORT_DESC) {
+			spin_lock_irqsave(&dev->lock, flags);
+			hid = acc_hid_get(&dev->new_hid_list, w_value);
+			spin_unlock_irqrestore(&dev->lock, flags);
+			if (!hid) {
+				value = -EINVAL;
+				goto err;
+			}
+			offset = w_index;
+			if (offset != hid->report_desc_offset
+				|| offset + w_length > hid->report_desc_len) {
+				value = -EINVAL;
+				goto err;
+			}
+			cdev->req->context = hid;
+			cdev->req->complete = acc_complete_set_hid_report_desc;
+			value = w_length;
+		} else if (b_request == ACCESSORY_SEND_HID_EVENT) {
+			spin_lock_irqsave(&dev->lock, flags);
+			hid = acc_hid_get(&dev->hid_list, w_value);
+			spin_unlock_irqrestore(&dev->lock, flags);
+			if (!hid) {
+				value = -EINVAL;
+				goto err;
+			}
+			cdev->req->context = hid;
+			cdev->req->complete = acc_complete_send_hid_event;
+			value = w_length;
+		}
+	} else if (b_requestType == (USB_DIR_IN | USB_TYPE_VENDOR)) {
+		if (b_request == ACCESSORY_GET_PROTOCOL) {
+			*((u16 *)cdev->req->buf) = PROTOCOL_VERSION;
+			value = sizeof(u16);
+
+			/* clear any string left over from a previous session */
+			memset(dev->manufacturer, 0, sizeof(dev->manufacturer));
+			memset(dev->model, 0, sizeof(dev->model));
+			memset(dev->description, 0, sizeof(dev->description));
+			memset(dev->version, 0, sizeof(dev->version));
+			memset(dev->uri, 0, sizeof(dev->uri));
+			memset(dev->serial, 0, sizeof(dev->serial));
+			dev->start_requested = 0;
+			dev->audio_mode = 0;
+		}
+	}
+
+	if (value >= 0) {
+		cdev->req->zero = 0;
+		cdev->req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (value < 0)
+			ERROR(cdev, "%s setup response queue error\n",
+				__func__);
+	}
+
+err:
+	if (value == -EOPNOTSUPP)
+		VDBG(cdev,
+			"unknown class-specific control req "
+			"%02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+	return value;
+}
+
+static int
+acc_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct acc_dev	*dev = func_to_dev(f);
+	int			id;
+	int			ret;
+
+	DBG(cdev, "acc_function_bind dev: %p\n", dev);
+
+	ret = hid_register_driver(&acc_hid_driver);
+	if (ret)
+		return ret;
+
+	dev->start_requested = 0;
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	acc_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = create_bulk_endpoints(dev, &acc_fullspeed_in_desc,
+			&acc_fullspeed_out_desc);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		acc_highspeed_in_desc.bEndpointAddress =
+			acc_fullspeed_in_desc.bEndpointAddress;
+		acc_highspeed_out_desc.bEndpointAddress =
+			acc_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name, dev->ep_out->name);
+	return 0;
+}
+
+static void
+kill_all_hid_devices(struct acc_dev *dev)
+{
+	struct acc_hid_dev *hid;
+	struct list_head *entry, *temp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_for_each_safe(entry, temp, &dev->hid_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		list_del(&hid->list);
+		list_add(&hid->list, &dev->dead_hid_list);
+	}
+	list_for_each_safe(entry, temp, &dev->new_hid_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		list_del(&hid->list);
+		list_add(&hid->list, &dev->dead_hid_list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	schedule_work(&dev->hid_work);
+}
+
+static void
+acc_hid_unbind(struct acc_dev *dev)
+{
+	hid_unregister_driver(&acc_hid_driver);
+	kill_all_hid_devices(dev);
+}
+
+static void
+acc_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct acc_dev	*dev = func_to_dev(f);
+	struct usb_request *req;
+	int i;
+
+	while ((req = req_get(dev, &dev->tx_idle)))
+		acc_request_free(req, dev->ep_in);
+	for (i = 0; i < RX_REQ_MAX; i++)
+		acc_request_free(dev->rx_req[i], dev->ep_out);
+
+	acc_hid_unbind(dev);
+}
+
+static void acc_start_work(struct work_struct *data)
+{
+	char *envp[2] = { "ACCESSORY=START", NULL };
+	kobject_uevent_env(&acc_device.this_device->kobj, KOBJ_CHANGE, envp);
+}
+
+static int acc_hid_init(struct acc_hid_dev *hdev)
+{
+	struct hid_device *hid;
+	int ret;
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid))
+		return PTR_ERR(hid);
+
+	hid->ll_driver = &acc_hid_ll_driver;
+	hid->dev.parent = acc_device.this_device;
+
+	hid->bus = BUS_USB;
+	hid->vendor = HID_ANY_ID;
+	hid->product = HID_ANY_ID;
+	hid->driver_data = hdev;
+	ret = hid_add_device(hid);
+	if (ret) {
+		pr_err("can't add hid device: %d\n", ret);
+		hid_destroy_device(hid);
+		return ret;
+	}
+
+	hdev->hid = hid;
+	return 0;
+}
+
+static void acc_hid_delete(struct acc_hid_dev *hid)
+{
+	kfree(hid->report_desc);
+	kfree(hid);
+}
+
+static void acc_hid_work(struct work_struct *data)
+{
+	struct acc_dev *dev = _acc_dev;
+	struct list_head	*entry, *temp;
+	struct acc_hid_dev *hid;
+	struct list_head	new_list, dead_list;
+	unsigned long flags;
+
+	INIT_LIST_HEAD(&new_list);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* copy hids that are ready for initialization to new_list */
+	list_for_each_safe(entry, temp, &dev->new_hid_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		if (hid->report_desc_offset == hid->report_desc_len)
+			list_move(&hid->list, &new_list);
+	}
+
+	if (list_empty(&dev->dead_hid_list)) {
+		INIT_LIST_HEAD(&dead_list);
+	} else {
+		/* move all of dev->dead_hid_list to dead_list */
+		dead_list.prev = dev->dead_hid_list.prev;
+		dead_list.next = dev->dead_hid_list.next;
+		dead_list.next->prev = &dead_list;
+		dead_list.prev->next = &dead_list;
+		INIT_LIST_HEAD(&dev->dead_hid_list);
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	/* register new HID devices */
+	list_for_each_safe(entry, temp, &new_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		if (acc_hid_init(hid)) {
+			pr_err("can't add HID device %p\n", hid);
+			acc_hid_delete(hid);
+		} else {
+			spin_lock_irqsave(&dev->lock, flags);
+			list_move(&hid->list, &dev->hid_list);
+			spin_unlock_irqrestore(&dev->lock, flags);
+		}
+	}
+
+	/* remove dead HID devices */
+	list_for_each_safe(entry, temp, &dead_list) {
+		hid = list_entry(entry, struct acc_hid_dev, list);
+		list_del(&hid->list);
+		if (hid->hid)
+			hid_destroy_device(hid->hid);
+		acc_hid_delete(hid);
+	}
+}
+
+static int acc_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct acc_dev	*dev = func_to_dev(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	DBG(cdev, "acc_function_set_alt intf: %d alt: %d\n", intf, alt);
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_in);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_in);
+	if (ret)
+		return ret;
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_out);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_out);
+	if (ret) {
+		usb_ep_disable(dev->ep_in);
+		return ret;
+	}
+
+	dev->online = 1;
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+	return 0;
+}
+
+static void acc_function_disable(struct usb_function *f)
+{
+	struct acc_dev	*dev = func_to_dev(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	DBG(cdev, "acc_function_disable\n");
+	acc_set_disconnected(dev);
+	usb_ep_disable(dev->ep_in);
+	usb_ep_disable(dev->ep_out);
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+
+	VDBG(cdev, "%s disabled\n", dev->function.name);
+}
+
+static int acc_bind_config(struct usb_configuration *c)
+{
+	struct acc_dev *dev = _acc_dev;
+	int ret;
+
+	printk(KERN_INFO "acc_bind_config\n");
+
+	/* allocate a string ID for our interface */
+	if (acc_string_defs[INTERFACE_STRING_INDEX].id == 0) {
+		ret = usb_string_id(c->cdev);
+		if (ret < 0)
+			return ret;
+		acc_string_defs[INTERFACE_STRING_INDEX].id = ret;
+		acc_interface_desc.iInterface = ret;
+	}
+
+	dev->cdev = c->cdev;
+	dev->function.name = "accessory";
+	dev->function.strings = acc_strings,
+	dev->function.descriptors = fs_acc_descs;
+	dev->function.hs_descriptors = hs_acc_descs;
+	dev->function.bind = acc_function_bind;
+	dev->function.unbind = acc_function_unbind;
+	dev->function.set_alt = acc_function_set_alt;
+	dev->function.disable = acc_function_disable;
+
+	return usb_add_function(c, &dev->function);
+}
+
+static int acc_setup(void)
+{
+	struct acc_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+	init_waitqueue_head(&dev->read_wq);
+	init_waitqueue_head(&dev->write_wq);
+	atomic_set(&dev->open_excl, 0);
+	INIT_LIST_HEAD(&dev->tx_idle);
+	INIT_LIST_HEAD(&dev->hid_list);
+	INIT_LIST_HEAD(&dev->new_hid_list);
+	INIT_LIST_HEAD(&dev->dead_hid_list);
+	INIT_DELAYED_WORK(&dev->start_work, acc_start_work);
+	INIT_WORK(&dev->hid_work, acc_hid_work);
+
+	/* _acc_dev must be set before calling usb_gadget_register_driver */
+	_acc_dev = dev;
+
+	ret = misc_register(&acc_device);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(dev);
+	pr_err("USB accessory gadget driver failed to initialize\n");
+	return ret;
+}
+
+static void acc_disconnect(void)
+{
+	/* unregister all HID devices if USB is disconnected */
+	kill_all_hid_devices(_acc_dev);
+}
+
+static void acc_cleanup(void)
+{
+	misc_deregister(&acc_device);
+	kfree(_acc_dev);
+	_acc_dev = NULL;
+}
diff --git a/drivers/usb/gadget/f_adb.c b/drivers/usb/gadget/f_adb.c
new file mode 100644
index 0000000..1629ffb
--- /dev/null
+++ b/drivers/usb/gadget/f_adb.c
@@ -0,0 +1,619 @@
+/*
+ * Gadget Driver for Android ADB
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#define ADB_BULK_BUFFER_SIZE           4096
+
+/* number of tx requests to allocate */
+#define TX_REQ_MAX 4
+
+static const char adb_shortname[] = "android_adb";
+
+struct adb_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+
+	struct usb_ep *ep_in;
+	struct usb_ep *ep_out;
+
+	int online;
+	int error;
+
+	atomic_t read_excl;
+	atomic_t write_excl;
+	atomic_t open_excl;
+
+	struct list_head tx_idle;
+
+	wait_queue_head_t read_wq;
+	wait_queue_head_t write_wq;
+	struct usb_request *rx_req;
+	int rx_done;
+};
+
+static struct usb_interface_descriptor adb_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bInterfaceNumber       = 0,
+	.bNumEndpoints          = 2,
+	.bInterfaceClass        = 0xFF,
+	.bInterfaceSubClass     = 0x42,
+	.bInterfaceProtocol     = 1,
+};
+
+static struct usb_endpoint_descriptor adb_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor adb_highspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor adb_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor adb_fullspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_descriptor_header *fs_adb_descs[] = {
+	(struct usb_descriptor_header *) &adb_interface_desc,
+	(struct usb_descriptor_header *) &adb_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &adb_fullspeed_out_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_adb_descs[] = {
+	(struct usb_descriptor_header *) &adb_interface_desc,
+	(struct usb_descriptor_header *) &adb_highspeed_in_desc,
+	(struct usb_descriptor_header *) &adb_highspeed_out_desc,
+	NULL,
+};
+
+static void adb_ready_callback(void);
+static void adb_closed_callback(void);
+
+/* temporary variable used between adb_open() and adb_gadget_bind() */
+static struct adb_dev *_adb_dev;
+
+static inline struct adb_dev *func_to_adb(struct usb_function *f)
+{
+	return container_of(f, struct adb_dev, function);
+}
+
+
+static struct usb_request *adb_request_new(struct usb_ep *ep, int buffer_size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void adb_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+static inline int adb_lock(atomic_t *excl)
+{
+	if (atomic_inc_return(excl) == 1) {
+		return 0;
+	} else {
+		atomic_dec(excl);
+		return -1;
+	}
+}
+
+static inline void adb_unlock(atomic_t *excl)
+{
+	atomic_dec(excl);
+}
+
+/* add a request to the tail of a list */
+void adb_req_put(struct adb_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+struct usb_request *adb_req_get(struct adb_dev *dev, struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void adb_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	if (req->status != 0)
+		dev->error = 1;
+
+	adb_req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static void adb_complete_out(struct usb_ep *ep, struct usb_request *req)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	dev->rx_done = 1;
+	if (req->status != 0 && req->status != -ECONNRESET)
+		dev->error = 1;
+
+	wake_up(&dev->read_wq);
+}
+
+static int adb_create_bulk_endpoints(struct adb_dev *dev,
+				struct usb_endpoint_descriptor *in_desc,
+				struct usb_endpoint_descriptor *out_desc)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	DBG(cdev, "create_bulk_endpoints dev: %p\n", dev);
+
+	ep = usb_ep_autoconfig(cdev->gadget, in_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_in failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for ep_in got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for adb ep_out got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	/* now allocate requests for our endpoints */
+	req = adb_request_new(dev->ep_out, ADB_BULK_BUFFER_SIZE);
+	if (!req)
+		goto fail;
+	req->complete = adb_complete_out;
+	dev->rx_req = req;
+
+	for (i = 0; i < TX_REQ_MAX; i++) {
+		req = adb_request_new(dev->ep_in, ADB_BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = adb_complete_in;
+		adb_req_put(dev, &dev->tx_idle, req);
+	}
+
+	return 0;
+
+fail:
+	printk(KERN_ERR "adb_bind() could not allocate requests\n");
+	return -1;
+}
+
+static ssize_t adb_read(struct file *fp, char __user *buf,
+				size_t count, loff_t *pos)
+{
+	struct adb_dev *dev = fp->private_data;
+	struct usb_request *req;
+	int r = count, xfer;
+	int ret;
+
+	pr_debug("adb_read(%d)\n", count);
+	if (!_adb_dev)
+		return -ENODEV;
+
+	if (count > ADB_BULK_BUFFER_SIZE)
+		return -EINVAL;
+
+	if (adb_lock(&dev->read_excl))
+		return -EBUSY;
+
+	/* we will block until we're online */
+	while (!(dev->online || dev->error)) {
+		pr_debug("adb_read: waiting for online state\n");
+		ret = wait_event_interruptible(dev->read_wq,
+				(dev->online || dev->error));
+		if (ret < 0) {
+			adb_unlock(&dev->read_excl);
+			return ret;
+		}
+	}
+	if (dev->error) {
+		r = -EIO;
+		goto done;
+	}
+
+requeue_req:
+	/* queue a request */
+	req = dev->rx_req;
+	req->length = count;
+	dev->rx_done = 0;
+	ret = usb_ep_queue(dev->ep_out, req, GFP_ATOMIC);
+	if (ret < 0) {
+		pr_debug("adb_read: failed to queue req %p (%d)\n", req, ret);
+		r = -EIO;
+		dev->error = 1;
+		goto done;
+	} else {
+		pr_debug("rx %p queue\n", req);
+	}
+
+	/* wait for a request to complete */
+	ret = wait_event_interruptible(dev->read_wq, dev->rx_done);
+	if (ret < 0) {
+		if (ret != -ERESTARTSYS)
+			dev->error = 1;
+		r = ret;
+		usb_ep_dequeue(dev->ep_out, req);
+		goto done;
+	}
+	if (!dev->error) {
+		/* If we got a 0-len packet, throw it back and try again. */
+		if (req->actual == 0)
+			goto requeue_req;
+
+		pr_debug("rx %p %d\n", req, req->actual);
+		xfer = (req->actual < count) ? req->actual : count;
+		if (copy_to_user(buf, req->buf, xfer))
+			r = -EFAULT;
+
+	} else
+		r = -EIO;
+
+done:
+	adb_unlock(&dev->read_excl);
+	pr_debug("adb_read returning %d\n", r);
+	return r;
+}
+
+static ssize_t adb_write(struct file *fp, const char __user *buf,
+				 size_t count, loff_t *pos)
+{
+	struct adb_dev *dev = fp->private_data;
+	struct usb_request *req = 0;
+	int r = count, xfer;
+	int ret;
+
+	if (!_adb_dev)
+		return -ENODEV;
+	pr_debug("adb_write(%d)\n", count);
+
+	if (adb_lock(&dev->write_excl))
+		return -EBUSY;
+
+	while (count > 0) {
+		if (dev->error) {
+			pr_debug("adb_write dev->error\n");
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+			(req = adb_req_get(dev, &dev->tx_idle)) || dev->error);
+
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+
+		if (req != 0) {
+			if (count > ADB_BULK_BUFFER_SIZE)
+				xfer = ADB_BULK_BUFFER_SIZE;
+			else
+				xfer = count;
+			if (copy_from_user(req->buf, buf, xfer)) {
+				r = -EFAULT;
+				break;
+			}
+
+			req->length = xfer;
+			ret = usb_ep_queue(dev->ep_in, req, GFP_ATOMIC);
+			if (ret < 0) {
+				pr_debug("adb_write: xfer error %d\n", ret);
+				dev->error = 1;
+				r = -EIO;
+				break;
+			}
+
+			buf += xfer;
+			count -= xfer;
+
+			/* zero this so we don't try to free it on error exit */
+			req = 0;
+		}
+	}
+
+	if (req)
+		adb_req_put(dev, &dev->tx_idle, req);
+
+	adb_unlock(&dev->write_excl);
+	pr_debug("adb_write returning %d\n", r);
+	return r;
+}
+
+static int adb_open(struct inode *ip, struct file *fp)
+{
+	pr_info("adb_open\n");
+	if (!_adb_dev)
+		return -ENODEV;
+
+	if (adb_lock(&_adb_dev->open_excl))
+		return -EBUSY;
+
+	fp->private_data = _adb_dev;
+
+	/* clear the error latch */
+	_adb_dev->error = 0;
+
+	adb_ready_callback();
+
+	return 0;
+}
+
+static int adb_release(struct inode *ip, struct file *fp)
+{
+	pr_info("adb_release\n");
+
+	adb_closed_callback();
+
+	adb_unlock(&_adb_dev->open_excl);
+	return 0;
+}
+
+/* file operations for ADB device /dev/android_adb */
+static const struct file_operations adb_fops = {
+	.owner = THIS_MODULE,
+	.read = adb_read,
+	.write = adb_write,
+	.open = adb_open,
+	.release = adb_release,
+};
+
+static struct miscdevice adb_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = adb_shortname,
+	.fops = &adb_fops,
+};
+
+
+
+
+static int
+adb_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct adb_dev	*dev = func_to_adb(f);
+	int			id;
+	int			ret;
+
+	dev->cdev = cdev;
+	DBG(cdev, "adb_function_bind dev: %p\n", dev);
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	adb_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = adb_create_bulk_endpoints(dev, &adb_fullspeed_in_desc,
+			&adb_fullspeed_out_desc);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		adb_highspeed_in_desc.bEndpointAddress =
+			adb_fullspeed_in_desc.bEndpointAddress;
+		adb_highspeed_out_desc.bEndpointAddress =
+			adb_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name, dev->ep_out->name);
+	return 0;
+}
+
+static void
+adb_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct adb_dev	*dev = func_to_adb(f);
+	struct usb_request *req;
+
+
+	dev->online = 0;
+	dev->error = 1;
+
+	wake_up(&dev->read_wq);
+
+	adb_request_free(dev->rx_req, dev->ep_out);
+	while ((req = adb_req_get(dev, &dev->tx_idle)))
+		adb_request_free(req, dev->ep_in);
+}
+
+static int adb_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct adb_dev	*dev = func_to_adb(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	DBG(cdev, "adb_function_set_alt intf: %d alt: %d\n", intf, alt);
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_in);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_in);
+	if (ret)
+		return ret;
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_out);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_out);
+	if (ret) {
+		usb_ep_disable(dev->ep_in);
+		return ret;
+	}
+	dev->online = 1;
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+	return 0;
+}
+
+static void adb_function_disable(struct usb_function *f)
+{
+	struct adb_dev	*dev = func_to_adb(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	DBG(cdev, "adb_function_disable cdev %p\n", cdev);
+	dev->online = 0;
+	dev->error = 1;
+	usb_ep_disable(dev->ep_in);
+	usb_ep_disable(dev->ep_out);
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+
+	VDBG(cdev, "%s disabled\n", dev->function.name);
+}
+
+static int adb_bind_config(struct usb_configuration *c)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	printk(KERN_INFO "adb_bind_config\n");
+
+	dev->cdev = c->cdev;
+	dev->function.name = "adb";
+	dev->function.descriptors = fs_adb_descs;
+	dev->function.hs_descriptors = hs_adb_descs;
+	dev->function.bind = adb_function_bind;
+	dev->function.unbind = adb_function_unbind;
+	dev->function.set_alt = adb_function_set_alt;
+	dev->function.disable = adb_function_disable;
+
+	return usb_add_function(c, &dev->function);
+}
+
+static int adb_setup(void)
+{
+	struct adb_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+
+	init_waitqueue_head(&dev->read_wq);
+	init_waitqueue_head(&dev->write_wq);
+
+	atomic_set(&dev->open_excl, 0);
+	atomic_set(&dev->read_excl, 0);
+	atomic_set(&dev->write_excl, 0);
+
+	INIT_LIST_HEAD(&dev->tx_idle);
+
+	_adb_dev = dev;
+
+	ret = misc_register(&adb_device);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(dev);
+	printk(KERN_ERR "adb gadget driver failed to initialize\n");
+	return ret;
+}
+
+static void adb_cleanup(void)
+{
+	misc_deregister(&adb_device);
+
+	kfree(_adb_dev);
+	_adb_dev = NULL;
+}
diff --git a/drivers/usb/gadget/f_audio_source.c b/drivers/usb/gadget/f_audio_source.c
new file mode 100644
index 0000000..c757409
--- /dev/null
+++ b/drivers/usb/gadget/f_audio_source.c
@@ -0,0 +1,828 @@
+/*
+ * Gadget Function Driver for USB audio source device
+ *
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/usb/audio.h>
+#include <linux/wait.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+
+#define SAMPLE_RATE 44100
+#define FRAMES_PER_MSEC (SAMPLE_RATE / 1000)
+
+#define IN_EP_MAX_PACKET_SIZE 384
+
+/* Number of requests to allocate */
+#define IN_EP_REQ_COUNT 4
+
+#define AUDIO_AC_INTERFACE	0
+#define AUDIO_AS_INTERFACE	1
+#define AUDIO_NUM_INTERFACES	2
+
+/* B.3.1  Standard AC Interface Descriptor */
+static struct usb_interface_descriptor ac_interface_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bNumEndpoints =	0,
+	.bInterfaceClass =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOCONTROL,
+};
+
+DECLARE_UAC_AC_HEADER_DESCRIPTOR(2);
+
+#define UAC_DT_AC_HEADER_LENGTH	UAC_DT_AC_HEADER_SIZE(AUDIO_NUM_INTERFACES)
+/* 1 input terminal, 1 output terminal and 1 feature unit */
+#define UAC_DT_TOTAL_LENGTH (UAC_DT_AC_HEADER_LENGTH \
+	+ UAC_DT_INPUT_TERMINAL_SIZE + UAC_DT_OUTPUT_TERMINAL_SIZE \
+	+ UAC_DT_FEATURE_UNIT_SIZE(0))
+/* B.3.2  Class-Specific AC Interface Descriptor */
+static struct uac1_ac_header_descriptor_2 ac_header_desc = {
+	.bLength =		UAC_DT_AC_HEADER_LENGTH,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_HEADER,
+	.bcdADC =		__constant_cpu_to_le16(0x0100),
+	.wTotalLength =		__constant_cpu_to_le16(UAC_DT_TOTAL_LENGTH),
+	.bInCollection =	AUDIO_NUM_INTERFACES,
+	.baInterfaceNr = {
+		[0] =		AUDIO_AC_INTERFACE,
+		[1] =		AUDIO_AS_INTERFACE,
+	}
+};
+
+#define INPUT_TERMINAL_ID	1
+static struct uac_input_terminal_descriptor input_terminal_desc = {
+	.bLength =		UAC_DT_INPUT_TERMINAL_SIZE,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_INPUT_TERMINAL,
+	.bTerminalID =		INPUT_TERMINAL_ID,
+	.wTerminalType =	UAC_INPUT_TERMINAL_MICROPHONE,
+	.bAssocTerminal =	0,
+	.wChannelConfig =	0x3,
+};
+
+DECLARE_UAC_FEATURE_UNIT_DESCRIPTOR(0);
+
+#define FEATURE_UNIT_ID		2
+static struct uac_feature_unit_descriptor_0 feature_unit_desc = {
+	.bLength		= UAC_DT_FEATURE_UNIT_SIZE(0),
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= UAC_FEATURE_UNIT,
+	.bUnitID		= FEATURE_UNIT_ID,
+	.bSourceID		= INPUT_TERMINAL_ID,
+	.bControlSize		= 2,
+};
+
+#define OUTPUT_TERMINAL_ID	3
+static struct uac1_output_terminal_descriptor output_terminal_desc = {
+	.bLength		= UAC_DT_OUTPUT_TERMINAL_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= UAC_OUTPUT_TERMINAL,
+	.bTerminalID		= OUTPUT_TERMINAL_ID,
+	.wTerminalType		= UAC_TERMINAL_STREAMING,
+	.bAssocTerminal		= FEATURE_UNIT_ID,
+	.bSourceID		= FEATURE_UNIT_ID,
+};
+
+/* B.4.1  Standard AS Interface Descriptor */
+static struct usb_interface_descriptor as_interface_alt_0_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bAlternateSetting =	0,
+	.bNumEndpoints =	0,
+	.bInterfaceClass =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOSTREAMING,
+};
+
+static struct usb_interface_descriptor as_interface_alt_1_desc = {
+	.bLength =		USB_DT_INTERFACE_SIZE,
+	.bDescriptorType =	USB_DT_INTERFACE,
+	.bAlternateSetting =	1,
+	.bNumEndpoints =	1,
+	.bInterfaceClass =	USB_CLASS_AUDIO,
+	.bInterfaceSubClass =	USB_SUBCLASS_AUDIOSTREAMING,
+};
+
+/* B.4.2  Class-Specific AS Interface Descriptor */
+static struct uac1_as_header_descriptor as_header_desc = {
+	.bLength =		UAC_DT_AS_HEADER_SIZE,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_AS_GENERAL,
+	.bTerminalLink =	INPUT_TERMINAL_ID,
+	.bDelay =		1,
+	.wFormatTag =		UAC_FORMAT_TYPE_I_PCM,
+};
+
+DECLARE_UAC_FORMAT_TYPE_I_DISCRETE_DESC(1);
+
+static struct uac_format_type_i_discrete_descriptor_1 as_type_i_desc = {
+	.bLength =		UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(1),
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype =	UAC_FORMAT_TYPE,
+	.bFormatType =		UAC_FORMAT_TYPE_I,
+	.bSubframeSize =	2,
+	.bBitResolution =	16,
+	.bSamFreqType =		1,
+};
+
+/* Standard ISO IN Endpoint Descriptor for highspeed */
+static struct usb_endpoint_descriptor hs_as_in_ep_desc  = {
+	.bLength =		USB_DT_ENDPOINT_AUDIO_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_SYNC_SYNC
+				| USB_ENDPOINT_XFER_ISOC,
+	.wMaxPacketSize =	__constant_cpu_to_le16(IN_EP_MAX_PACKET_SIZE),
+	.bInterval =		4, /* poll 1 per millisecond */
+};
+
+/* Standard ISO IN Endpoint Descriptor for highspeed */
+static struct usb_endpoint_descriptor fs_as_in_ep_desc  = {
+	.bLength =		USB_DT_ENDPOINT_AUDIO_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_SYNC_SYNC
+				| USB_ENDPOINT_XFER_ISOC,
+	.wMaxPacketSize =	__constant_cpu_to_le16(IN_EP_MAX_PACKET_SIZE),
+	.bInterval =		1, /* poll 1 per millisecond */
+};
+
+/* Class-specific AS ISO OUT Endpoint Descriptor */
+static struct uac_iso_endpoint_descriptor as_iso_in_desc = {
+	.bLength =		UAC_ISO_ENDPOINT_DESC_SIZE,
+	.bDescriptorType =	USB_DT_CS_ENDPOINT,
+	.bDescriptorSubtype =	UAC_EP_GENERAL,
+	.bmAttributes =		1,
+	.bLockDelayUnits =	1,
+	.wLockDelay =		__constant_cpu_to_le16(1),
+};
+
+static struct usb_descriptor_header *hs_audio_desc[] = {
+	(struct usb_descriptor_header *)&ac_interface_desc,
+	(struct usb_descriptor_header *)&ac_header_desc,
+
+	(struct usb_descriptor_header *)&input_terminal_desc,
+	(struct usb_descriptor_header *)&output_terminal_desc,
+	(struct usb_descriptor_header *)&feature_unit_desc,
+
+	(struct usb_descriptor_header *)&as_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&as_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&as_header_desc,
+
+	(struct usb_descriptor_header *)&as_type_i_desc,
+
+	(struct usb_descriptor_header *)&hs_as_in_ep_desc,
+	(struct usb_descriptor_header *)&as_iso_in_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *fs_audio_desc[] = {
+	(struct usb_descriptor_header *)&ac_interface_desc,
+	(struct usb_descriptor_header *)&ac_header_desc,
+
+	(struct usb_descriptor_header *)&input_terminal_desc,
+	(struct usb_descriptor_header *)&output_terminal_desc,
+	(struct usb_descriptor_header *)&feature_unit_desc,
+
+	(struct usb_descriptor_header *)&as_interface_alt_0_desc,
+	(struct usb_descriptor_header *)&as_interface_alt_1_desc,
+	(struct usb_descriptor_header *)&as_header_desc,
+
+	(struct usb_descriptor_header *)&as_type_i_desc,
+
+	(struct usb_descriptor_header *)&fs_as_in_ep_desc,
+	(struct usb_descriptor_header *)&as_iso_in_desc,
+	NULL,
+};
+
+static struct snd_pcm_hardware audio_hw_info = {
+	.info =			SNDRV_PCM_INFO_MMAP |
+				SNDRV_PCM_INFO_MMAP_VALID |
+				SNDRV_PCM_INFO_BATCH |
+				SNDRV_PCM_INFO_INTERLEAVED |
+				SNDRV_PCM_INFO_BLOCK_TRANSFER,
+
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.rate_min		= SAMPLE_RATE,
+	.rate_max		= SAMPLE_RATE,
+
+	.buffer_bytes_max =	1024 * 1024,
+	.period_bytes_min =	64,
+	.period_bytes_max =	512 * 1024,
+	.periods_min =		2,
+	.periods_max =		1024,
+};
+
+/*-------------------------------------------------------------------------*/
+
+struct audio_source_config {
+	int	card;
+	int	device;
+};
+
+struct audio_dev {
+	struct usb_function		func;
+	struct snd_card			*card;
+	struct snd_pcm			*pcm;
+	struct snd_pcm_substream *substream;
+
+	struct list_head		idle_reqs;
+	struct usb_ep			*in_ep;
+
+	spinlock_t			lock;
+
+	/* beginning, end and current position in our buffer */
+	void				*buffer_start;
+	void				*buffer_end;
+	void				*buffer_pos;
+
+	/* byte size of a "period" */
+	unsigned int			period;
+	/* bytes sent since last call to snd_pcm_period_elapsed */
+	unsigned int			period_offset;
+	/* time we started playing */
+	ktime_t				start_time;
+	/* number of frames sent since start_time */
+	s64				frames_sent;
+};
+
+static inline struct audio_dev *func_to_audio(struct usb_function *f)
+{
+	return container_of(f, struct audio_dev, func);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_request *audio_request_new(struct usb_ep *ep, int buffer_size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+	req->length = buffer_size;
+	return req;
+}
+
+static void audio_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+static void audio_req_put(struct audio_dev *audio, struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&audio->lock, flags);
+	list_add_tail(&req->list, &audio->idle_reqs);
+	spin_unlock_irqrestore(&audio->lock, flags);
+}
+
+static struct usb_request *audio_req_get(struct audio_dev *audio)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&audio->lock, flags);
+	if (list_empty(&audio->idle_reqs)) {
+		req = 0;
+	} else {
+		req = list_first_entry(&audio->idle_reqs, struct usb_request,
+				list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&audio->lock, flags);
+	return req;
+}
+
+/* send the appropriate number of packets to match our bitrate */
+static void audio_send(struct audio_dev *audio)
+{
+	struct snd_pcm_runtime *runtime;
+	struct usb_request *req;
+	int length, length1, length2, ret;
+	s64 msecs;
+	s64 frames;
+	ktime_t now;
+
+	/* audio->substream will be null if we have been closed */
+	if (!audio->substream)
+		return;
+	/* audio->buffer_pos will be null if we have been stopped */
+	if (!audio->buffer_pos)
+		return;
+
+	runtime = audio->substream->runtime;
+
+	/* compute number of frames to send */
+	now = ktime_get();
+	msecs = ktime_to_ns(now) - ktime_to_ns(audio->start_time);
+	do_div(msecs, 1000000);
+	frames = msecs * SAMPLE_RATE;
+	do_div(frames, 1000);
+
+	/* Readjust our frames_sent if we fall too far behind.
+	 * If we get too far behind it is better to drop some frames than
+	 * to keep sending data too fast in an attempt to catch up.
+	 */
+	if (frames - audio->frames_sent > 10 * FRAMES_PER_MSEC)
+		audio->frames_sent = frames - FRAMES_PER_MSEC;
+
+	frames -= audio->frames_sent;
+
+	/* We need to send something to keep the pipeline going */
+	if (frames <= 0)
+		frames = FRAMES_PER_MSEC;
+
+	while (frames > 0) {
+		req = audio_req_get(audio);
+		if (!req)
+			break;
+
+		length = frames_to_bytes(runtime, frames);
+		if (length > IN_EP_MAX_PACKET_SIZE)
+			length = IN_EP_MAX_PACKET_SIZE;
+
+		if (audio->buffer_pos + length > audio->buffer_end)
+			length1 = audio->buffer_end - audio->buffer_pos;
+		else
+			length1 = length;
+		memcpy(req->buf, audio->buffer_pos, length1);
+		if (length1 < length) {
+			/* Wrap around and copy remaining length
+			 * at beginning of buffer.
+			 */
+			length2 = length - length1;
+			memcpy(req->buf + length1, audio->buffer_start,
+					length2);
+			audio->buffer_pos = audio->buffer_start + length2;
+		} else {
+			audio->buffer_pos += length1;
+			if (audio->buffer_pos >= audio->buffer_end)
+				audio->buffer_pos = audio->buffer_start;
+		}
+
+		req->length = length;
+		ret = usb_ep_queue(audio->in_ep, req, GFP_ATOMIC);
+		if (ret < 0) {
+			pr_err("usb_ep_queue failed ret: %d\n", ret);
+			audio_req_put(audio, req);
+			break;
+		}
+
+		frames -= bytes_to_frames(runtime, length);
+		audio->frames_sent += bytes_to_frames(runtime, length);
+	}
+}
+
+static void audio_control_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	/* nothing to do here */
+}
+
+static void audio_data_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct audio_dev *audio = req->context;
+
+	pr_debug("audio_data_complete req->status %d req->actual %d\n",
+		req->status, req->actual);
+
+	audio_req_put(audio, req);
+
+	if (!audio->buffer_start || req->status)
+		return;
+
+	audio->period_offset += req->actual;
+	if (audio->period_offset >= audio->period) {
+		snd_pcm_period_elapsed(audio->substream);
+		audio->period_offset = 0;
+	}
+	audio_send(audio);
+}
+
+static int audio_set_endpoint_req(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	int value = -EOPNOTSUPP;
+	u16 ep = le16_to_cpu(ctrl->wIndex);
+	u16 len = le16_to_cpu(ctrl->wLength);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+
+	pr_debug("bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",
+			ctrl->bRequest, w_value, len, ep);
+
+	switch (ctrl->bRequest) {
+	case UAC_SET_CUR:
+	case UAC_SET_MIN:
+	case UAC_SET_MAX:
+	case UAC_SET_RES:
+		value = len;
+		break;
+	default:
+		break;
+	}
+
+	return value;
+}
+
+static int audio_get_endpoint_req(struct usb_function *f,
+		const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int value = -EOPNOTSUPP;
+	u8 ep = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);
+	u16 len = le16_to_cpu(ctrl->wLength);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+	u8 *buf = cdev->req->buf;
+
+	pr_debug("bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",
+			ctrl->bRequest, w_value, len, ep);
+
+	if (w_value == UAC_EP_CS_ATTR_SAMPLE_RATE << 8) {
+		switch (ctrl->bRequest) {
+		case UAC_GET_CUR:
+		case UAC_GET_MIN:
+		case UAC_GET_MAX:
+		case UAC_GET_RES:
+			/* return our sample rate */
+			buf[0] = (u8)SAMPLE_RATE;
+			buf[1] = (u8)(SAMPLE_RATE >> 8);
+			buf[2] = (u8)(SAMPLE_RATE >> 16);
+			value = 3;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return value;
+}
+
+static int
+audio_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
+{
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_request *req = cdev->req;
+	int value = -EOPNOTSUPP;
+	u16 w_index = le16_to_cpu(ctrl->wIndex);
+	u16 w_value = le16_to_cpu(ctrl->wValue);
+	u16 w_length = le16_to_cpu(ctrl->wLength);
+
+	/* composite driver infrastructure handles everything; interface
+	 * activation uses set_alt().
+	 */
+	switch (ctrl->bRequestType) {
+	case USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:
+		value = audio_set_endpoint_req(f, ctrl);
+		break;
+
+	case USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:
+		value = audio_get_endpoint_req(f, ctrl);
+		break;
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		pr_debug("audio req%02x.%02x v%04x i%04x l%d\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+		req->zero = 0;
+		req->length = value;
+		req->complete = audio_control_complete;
+		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+		if (value < 0)
+			pr_err("audio response on err %d\n", value);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static int audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
+{
+	struct audio_dev *audio = func_to_audio(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	pr_debug("audio_set_alt intf %d, alt %d\n", intf, alt);
+
+	ret = config_ep_by_speed(cdev->gadget, f, audio->in_ep);
+	if (ret)
+		return ret;
+
+	usb_ep_enable(audio->in_ep);
+	return 0;
+}
+
+static void audio_disable(struct usb_function *f)
+{
+	struct audio_dev	*audio = func_to_audio(f);
+
+	pr_debug("audio_disable\n");
+	usb_ep_disable(audio->in_ep);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void audio_build_desc(struct audio_dev *audio)
+{
+	u8 *sam_freq;
+	int rate;
+
+	/* Set channel numbers */
+	input_terminal_desc.bNrChannels = 2;
+	as_type_i_desc.bNrChannels = 2;
+
+	/* Set sample rates */
+	rate = SAMPLE_RATE;
+	sam_freq = as_type_i_desc.tSamFreq[0];
+	memcpy(sam_freq, &rate, 3);
+}
+
+/* audio function driver setup/binding */
+static int
+audio_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct audio_dev *audio = func_to_audio(f);
+	int status;
+	struct usb_ep *ep;
+	struct usb_request *req;
+	int i;
+
+	audio_build_desc(audio);
+
+	/* allocate instance-specific interface IDs, and patch descriptors */
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	ac_interface_desc.bInterfaceNumber = status;
+
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	as_interface_alt_0_desc.bInterfaceNumber = status;
+	as_interface_alt_1_desc.bInterfaceNumber = status;
+
+	status = -ENODEV;
+
+	/* allocate our endpoint */
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_as_in_ep_desc);
+	if (!ep)
+		goto fail;
+	audio->in_ep = ep;
+	ep->driver_data = audio; /* claim */
+
+	if (gadget_is_dualspeed(c->cdev->gadget))
+		hs_as_in_ep_desc.bEndpointAddress =
+			fs_as_in_ep_desc.bEndpointAddress;
+
+	f->descriptors = fs_audio_desc;
+	f->hs_descriptors = hs_audio_desc;
+
+	for (i = 0, status = 0; i < IN_EP_REQ_COUNT && status == 0; i++) {
+		req = audio_request_new(ep, IN_EP_MAX_PACKET_SIZE);
+		if (req) {
+			req->context = audio;
+			req->complete = audio_data_complete;
+			audio_req_put(audio, req);
+		} else
+			status = -ENOMEM;
+	}
+
+fail:
+	return status;
+}
+
+static void
+audio_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct audio_dev *audio = func_to_audio(f);
+	struct usb_request *req;
+
+	while ((req = audio_req_get(audio)))
+		audio_request_free(req, audio->in_ep);
+
+	snd_card_free_when_closed(audio->card);
+	audio->card = NULL;
+	audio->pcm = NULL;
+	audio->substream = NULL;
+	audio->in_ep = NULL;
+}
+
+static void audio_pcm_playback_start(struct audio_dev *audio)
+{
+	audio->start_time = ktime_get();
+	audio->frames_sent = 0;
+	audio_send(audio);
+}
+
+static void audio_pcm_playback_stop(struct audio_dev *audio)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&audio->lock, flags);
+	audio->buffer_start = 0;
+	audio->buffer_end = 0;
+	audio->buffer_pos = 0;
+	spin_unlock_irqrestore(&audio->lock, flags);
+}
+
+static int audio_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct audio_dev *audio = substream->private_data;
+
+	runtime->private_data = audio;
+	runtime->hw = audio_hw_info;
+	snd_pcm_limit_hw_rates(runtime);
+	runtime->hw.channels_max = 2;
+
+	audio->substream = substream;
+	return 0;
+}
+
+static int audio_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct audio_dev *audio = substream->private_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&audio->lock, flags);
+	audio->substream = NULL;
+	spin_unlock_irqrestore(&audio->lock, flags);
+
+	return 0;
+}
+
+static int audio_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	unsigned int channels = params_channels(params);
+	unsigned int rate = params_rate(params);
+
+	if (rate != SAMPLE_RATE)
+		return -EINVAL;
+	if (channels != 2)
+		return -EINVAL;
+
+	return snd_pcm_lib_alloc_vmalloc_buffer(substream,
+		params_buffer_bytes(params));
+}
+
+static int audio_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int audio_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct audio_dev *audio = runtime->private_data;
+
+	audio->period = snd_pcm_lib_period_bytes(substream);
+	audio->period_offset = 0;
+	audio->buffer_start = runtime->dma_area;
+	audio->buffer_end = audio->buffer_start
+		+ snd_pcm_lib_buffer_bytes(substream);
+	audio->buffer_pos = audio->buffer_start;
+
+	return 0;
+}
+
+static snd_pcm_uframes_t audio_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct audio_dev *audio = runtime->private_data;
+	ssize_t bytes = audio->buffer_pos - audio->buffer_start;
+
+	/* return offset of next frame to fill in our buffer */
+	return bytes_to_frames(runtime, bytes);
+}
+
+static int audio_pcm_playback_trigger(struct snd_pcm_substream *substream,
+					int cmd)
+{
+	struct audio_dev *audio = substream->runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		audio_pcm_playback_start(audio);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		audio_pcm_playback_stop(audio);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static struct audio_dev _audio_dev = {
+	.func = {
+		.name = "audio_source",
+		.bind = audio_bind,
+		.unbind = audio_unbind,
+		.set_alt = audio_set_alt,
+		.setup = audio_setup,
+		.disable = audio_disable,
+	},
+	.lock = __SPIN_LOCK_UNLOCKED(_audio_dev.lock),
+	.idle_reqs = LIST_HEAD_INIT(_audio_dev.idle_reqs),
+};
+
+static struct snd_pcm_ops audio_playback_ops = {
+	.open		= audio_pcm_open,
+	.close		= audio_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= audio_pcm_hw_params,
+	.hw_free	= audio_pcm_hw_free,
+	.prepare	= audio_pcm_prepare,
+	.trigger	= audio_pcm_playback_trigger,
+	.pointer	= audio_pcm_pointer,
+};
+
+int audio_source_bind_config(struct usb_configuration *c,
+		struct audio_source_config *config)
+{
+	struct audio_dev *audio;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	int err;
+
+	config->card = -1;
+	config->device = -1;
+
+	audio = &_audio_dev;
+
+	err = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			THIS_MODULE, 0, &card);
+	if (err)
+		return err;
+
+	snd_card_set_dev(card, &c->cdev->gadget->dev);
+
+	err = snd_pcm_new(card, "USB audio source", 0, 1, 0, &pcm);
+	if (err)
+		goto pcm_fail;
+	pcm->private_data = audio;
+	pcm->info_flags = 0;
+	audio->pcm = pcm;
+
+	strlcpy(pcm->name, "USB gadget audio", sizeof(pcm->name));
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &audio_playback_ops);
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+				NULL, 0, 64 * 1024);
+
+	strlcpy(card->driver, "audio_source", sizeof(card->driver));
+	strlcpy(card->shortname, card->driver, sizeof(card->shortname));
+	strlcpy(card->longname, "USB accessory audio source",
+		sizeof(card->longname));
+
+	err = snd_card_register(card);
+	if (err)
+		goto register_fail;
+
+	err = usb_add_function(c, &audio->func);
+	if (err)
+		goto add_fail;
+
+	config->card = pcm->card->number;
+	config->device = pcm->device;
+	audio->card = card;
+	return 0;
+
+add_fail:
+register_fail:
+pcm_fail:
+	snd_card_free(audio->card);
+	return err;
+}
diff --git a/drivers/usb/gadget/f_fs.c b/drivers/usb/gadget/f_fs.c
index f52cb1a..32842d3 100644
--- a/drivers/usb/gadget/f_fs.c
+++ b/drivers/usb/gadget/f_fs.c
@@ -1473,8 +1473,22 @@ static int functionfs_bind_config(struct usb_composite_dev *cdev,
 
 static void ffs_func_free(struct ffs_function *func)
 {
+	struct ffs_ep *ep         = func->eps;
+	unsigned count            = func->ffs->eps_count;
+	unsigned long flags;
+
 	ENTER();
 
+	/* cleanup after autoconfig */
+	spin_lock_irqsave(&func->ffs->eps_lock, flags);
+	do {
+		if (ep->ep && ep->req)
+			usb_ep_free_request(ep->ep, ep->req);
+		ep->req = NULL;
+		++ep;
+	} while (--count);
+	spin_unlock_irqrestore(&func->ffs->eps_lock, flags);
+
 	ffs_data_put(func->ffs);
 
 	kfree(func->eps);
@@ -1519,7 +1533,12 @@ static int ffs_func_eps_enable(struct ffs_function *func)
 	spin_lock_irqsave(&func->ffs->eps_lock, flags);
 	do {
 		struct usb_endpoint_descriptor *ds;
-		ds = ep->descs[ep->descs[1] ? 1 : 0];
+		int desc_idx = ffs->gadget->speed == USB_SPEED_HIGH ? 1 : 0;
+		ds = ep->descs[desc_idx];
+		if (!ds) {
+			ret = -EINVAL;
+			break;
+		}
 
 		ep->ep->driver_data = ep;
 		ep->ep->desc = ds;
diff --git a/drivers/usb/gadget/f_mtp.c b/drivers/usb/gadget/f_mtp.c
new file mode 100644
index 0000000..1638977
--- /dev/null
+++ b/drivers/usb/gadget/f_mtp.c
@@ -0,0 +1,1283 @@
+/*
+ * Gadget Function Driver for MTP
+ *
+ * Copyright (C) 2010 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+
+#include <linux/types.h>
+#include <linux/file.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include <linux/usb.h>
+#include <linux/usb_usual.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/f_mtp.h>
+
+#define MTP_BULK_BUFFER_SIZE       16384
+#define INTR_BUFFER_SIZE           28
+
+/* String IDs */
+#define INTERFACE_STRING_INDEX	0
+
+/* values for mtp_dev.state */
+#define STATE_OFFLINE               0   /* initial state, disconnected */
+#define STATE_READY                 1   /* ready for userspace calls */
+#define STATE_BUSY                  2   /* processing userspace calls */
+#define STATE_CANCELED              3   /* transaction canceled by host */
+#define STATE_ERROR                 4   /* error from completion routine */
+
+/* number of tx and rx requests to allocate */
+#define TX_REQ_MAX 4
+#define RX_REQ_MAX 2
+#define INTR_REQ_MAX 5
+
+/* ID for Microsoft MTP OS String */
+#define MTP_OS_STRING_ID   0xEE
+
+/* MTP class reqeusts */
+#define MTP_REQ_CANCEL              0x64
+#define MTP_REQ_GET_EXT_EVENT_DATA  0x65
+#define MTP_REQ_RESET               0x66
+#define MTP_REQ_GET_DEVICE_STATUS   0x67
+
+/* constants for device status */
+#define MTP_RESPONSE_OK             0x2001
+#define MTP_RESPONSE_DEVICE_BUSY    0x2019
+
+static const char mtp_shortname[] = "mtp_usb";
+
+struct mtp_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+
+	struct usb_ep *ep_in;
+	struct usb_ep *ep_out;
+	struct usb_ep *ep_intr;
+
+	int state;
+
+	/* synchronize access to our device file */
+	atomic_t open_excl;
+	/* to enforce only one ioctl at a time */
+	atomic_t ioctl_excl;
+
+	struct list_head tx_idle;
+	struct list_head intr_idle;
+
+	wait_queue_head_t read_wq;
+	wait_queue_head_t write_wq;
+	wait_queue_head_t intr_wq;
+	struct usb_request *rx_req[RX_REQ_MAX];
+	int rx_done;
+
+	/* for processing MTP_SEND_FILE, MTP_RECEIVE_FILE and
+	 * MTP_SEND_FILE_WITH_HEADER ioctls on a work queue
+	 */
+	struct workqueue_struct *wq;
+	struct work_struct send_file_work;
+	struct work_struct receive_file_work;
+	struct file *xfer_file;
+	loff_t xfer_file_offset;
+	int64_t xfer_file_length;
+	unsigned xfer_send_header;
+	uint16_t xfer_command;
+	uint32_t xfer_transaction_id;
+	int xfer_result;
+};
+
+static struct usb_interface_descriptor mtp_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bInterfaceNumber       = 0,
+	.bNumEndpoints          = 3,
+	.bInterfaceClass        = USB_CLASS_VENDOR_SPEC,
+	.bInterfaceSubClass     = USB_SUBCLASS_VENDOR_SPEC,
+	.bInterfaceProtocol     = 0,
+};
+
+static struct usb_interface_descriptor ptp_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bInterfaceNumber       = 0,
+	.bNumEndpoints          = 3,
+	.bInterfaceClass        = USB_CLASS_STILL_IMAGE,
+	.bInterfaceSubClass     = 1,
+	.bInterfaceProtocol     = 1,
+};
+
+static struct usb_endpoint_descriptor mtp_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor mtp_highspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor mtp_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor mtp_fullspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor mtp_intr_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize         = __constant_cpu_to_le16(INTR_BUFFER_SIZE),
+	.bInterval              = 6,
+};
+
+static struct usb_descriptor_header *fs_mtp_descs[] = {
+	(struct usb_descriptor_header *) &mtp_interface_desc,
+	(struct usb_descriptor_header *) &mtp_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &mtp_fullspeed_out_desc,
+	(struct usb_descriptor_header *) &mtp_intr_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_mtp_descs[] = {
+	(struct usb_descriptor_header *) &mtp_interface_desc,
+	(struct usb_descriptor_header *) &mtp_highspeed_in_desc,
+	(struct usb_descriptor_header *) &mtp_highspeed_out_desc,
+	(struct usb_descriptor_header *) &mtp_intr_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *fs_ptp_descs[] = {
+	(struct usb_descriptor_header *) &ptp_interface_desc,
+	(struct usb_descriptor_header *) &mtp_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &mtp_fullspeed_out_desc,
+	(struct usb_descriptor_header *) &mtp_intr_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_ptp_descs[] = {
+	(struct usb_descriptor_header *) &ptp_interface_desc,
+	(struct usb_descriptor_header *) &mtp_highspeed_in_desc,
+	(struct usb_descriptor_header *) &mtp_highspeed_out_desc,
+	(struct usb_descriptor_header *) &mtp_intr_desc,
+	NULL,
+};
+
+static struct usb_string mtp_string_defs[] = {
+	/* Naming interface "MTP" so libmtp will recognize us */
+	[INTERFACE_STRING_INDEX].s	= "MTP",
+	{  },	/* end of list */
+};
+
+static struct usb_gadget_strings mtp_string_table = {
+	.language		= 0x0409,	/* en-US */
+	.strings		= mtp_string_defs,
+};
+
+static struct usb_gadget_strings *mtp_strings[] = {
+	&mtp_string_table,
+	NULL,
+};
+
+/* Microsoft MTP OS String */
+static u8 mtp_os_string[] = {
+	18, /* sizeof(mtp_os_string) */
+	USB_DT_STRING,
+	/* Signature field: "MSFT100" */
+	'M', 0, 'S', 0, 'F', 0, 'T', 0, '1', 0, '0', 0, '0', 0,
+	/* vendor code */
+	1,
+	/* padding */
+	0
+};
+
+/* Microsoft Extended Configuration Descriptor Header Section */
+struct mtp_ext_config_desc_header {
+	__le32	dwLength;
+	__u16	bcdVersion;
+	__le16	wIndex;
+	__u8	bCount;
+	__u8	reserved[7];
+};
+
+/* Microsoft Extended Configuration Descriptor Function Section */
+struct mtp_ext_config_desc_function {
+	__u8	bFirstInterfaceNumber;
+	__u8	bInterfaceCount;
+	__u8	compatibleID[8];
+	__u8	subCompatibleID[8];
+	__u8	reserved[6];
+};
+
+/* MTP Extended Configuration Descriptor */
+struct {
+	struct mtp_ext_config_desc_header	header;
+	struct mtp_ext_config_desc_function    function;
+} mtp_ext_config_desc = {
+	.header = {
+		.dwLength = __constant_cpu_to_le32(sizeof(mtp_ext_config_desc)),
+		.bcdVersion = __constant_cpu_to_le16(0x0100),
+		.wIndex = __constant_cpu_to_le16(4),
+		.bCount = __constant_cpu_to_le16(1),
+	},
+	.function = {
+		.bFirstInterfaceNumber = 0,
+		.bInterfaceCount = 1,
+		.compatibleID = { 'M', 'T', 'P' },
+	},
+};
+
+struct mtp_device_status {
+	__le16	wLength;
+	__le16	wCode;
+};
+
+/* temporary variable used between mtp_open() and mtp_gadget_bind() */
+static struct mtp_dev *_mtp_dev;
+
+static inline struct mtp_dev *func_to_mtp(struct usb_function *f)
+{
+	return container_of(f, struct mtp_dev, function);
+}
+
+static struct usb_request *mtp_request_new(struct usb_ep *ep, int buffer_size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void mtp_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+static inline int mtp_lock(atomic_t *excl)
+{
+	if (atomic_inc_return(excl) == 1) {
+		return 0;
+	} else {
+		atomic_dec(excl);
+		return -1;
+	}
+}
+
+static inline void mtp_unlock(atomic_t *excl)
+{
+	atomic_dec(excl);
+}
+
+/* add a request to the tail of a list */
+static void mtp_req_put(struct mtp_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct usb_request
+*mtp_req_get(struct mtp_dev *dev, struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void mtp_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct mtp_dev *dev = _mtp_dev;
+
+	if (req->status != 0)
+		dev->state = STATE_ERROR;
+
+	mtp_req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static void mtp_complete_out(struct usb_ep *ep, struct usb_request *req)
+{
+	struct mtp_dev *dev = _mtp_dev;
+
+	dev->rx_done = 1;
+	if (req->status != 0)
+		dev->state = STATE_ERROR;
+
+	wake_up(&dev->read_wq);
+}
+
+static void mtp_complete_intr(struct usb_ep *ep, struct usb_request *req)
+{
+	struct mtp_dev *dev = _mtp_dev;
+
+	if (req->status != 0)
+		dev->state = STATE_ERROR;
+
+	mtp_req_put(dev, &dev->intr_idle, req);
+
+	wake_up(&dev->intr_wq);
+}
+
+static int mtp_create_bulk_endpoints(struct mtp_dev *dev,
+				struct usb_endpoint_descriptor *in_desc,
+				struct usb_endpoint_descriptor *out_desc,
+				struct usb_endpoint_descriptor *intr_desc)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	DBG(cdev, "create_bulk_endpoints dev: %p\n", dev);
+
+	ep = usb_ep_autoconfig(cdev->gadget, in_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_in failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for ep_in got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for mtp ep_out got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for mtp ep_out got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	ep = usb_ep_autoconfig(cdev->gadget, intr_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_intr failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for mtp ep_intr got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_intr = ep;
+
+	/* now allocate requests for our endpoints */
+	for (i = 0; i < TX_REQ_MAX; i++) {
+		req = mtp_request_new(dev->ep_in, MTP_BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = mtp_complete_in;
+		mtp_req_put(dev, &dev->tx_idle, req);
+	}
+	for (i = 0; i < RX_REQ_MAX; i++) {
+		req = mtp_request_new(dev->ep_out, MTP_BULK_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = mtp_complete_out;
+		dev->rx_req[i] = req;
+	}
+	for (i = 0; i < INTR_REQ_MAX; i++) {
+		req = mtp_request_new(dev->ep_intr, INTR_BUFFER_SIZE);
+		if (!req)
+			goto fail;
+		req->complete = mtp_complete_intr;
+		mtp_req_put(dev, &dev->intr_idle, req);
+	}
+
+	return 0;
+
+fail:
+	printk(KERN_ERR "mtp_bind() could not allocate requests\n");
+	return -1;
+}
+
+static ssize_t mtp_read(struct file *fp, char __user *buf,
+	size_t count, loff_t *pos)
+{
+	struct mtp_dev *dev = fp->private_data;
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	int r = count, xfer;
+	int ret = 0;
+
+	DBG(cdev, "mtp_read(%d)\n", count);
+
+	if (count > MTP_BULK_BUFFER_SIZE)
+		return -EINVAL;
+
+	/* we will block until we're online */
+	DBG(cdev, "mtp_read: waiting for online state\n");
+	ret = wait_event_interruptible(dev->read_wq,
+		dev->state != STATE_OFFLINE);
+	if (ret < 0) {
+		r = ret;
+		goto done;
+	}
+	spin_lock_irq(&dev->lock);
+	if (dev->state == STATE_CANCELED) {
+		/* report cancelation to userspace */
+		dev->state = STATE_READY;
+		spin_unlock_irq(&dev->lock);
+		return -ECANCELED;
+	}
+	dev->state = STATE_BUSY;
+	spin_unlock_irq(&dev->lock);
+
+requeue_req:
+	/* queue a request */
+	req = dev->rx_req[0];
+	req->length = count;
+	dev->rx_done = 0;
+	ret = usb_ep_queue(dev->ep_out, req, GFP_KERNEL);
+	if (ret < 0) {
+		r = -EIO;
+		goto done;
+	} else {
+		DBG(cdev, "rx %p queue\n", req);
+	}
+
+	/* wait for a request to complete */
+	ret = wait_event_interruptible(dev->read_wq, dev->rx_done);
+	if (ret < 0) {
+		r = ret;
+		usb_ep_dequeue(dev->ep_out, req);
+		goto done;
+	}
+	if (dev->state == STATE_BUSY) {
+		/* If we got a 0-len packet, throw it back and try again. */
+		if (req->actual == 0)
+			goto requeue_req;
+
+		DBG(cdev, "rx %p %d\n", req, req->actual);
+		xfer = (req->actual < count) ? req->actual : count;
+		r = xfer;
+		if (copy_to_user(buf, req->buf, xfer))
+			r = -EFAULT;
+	} else
+		r = -EIO;
+
+done:
+	spin_lock_irq(&dev->lock);
+	if (dev->state == STATE_CANCELED)
+		r = -ECANCELED;
+	else if (dev->state != STATE_OFFLINE)
+		dev->state = STATE_READY;
+	spin_unlock_irq(&dev->lock);
+
+	DBG(cdev, "mtp_read returning %d\n", r);
+	return r;
+}
+
+static ssize_t mtp_write(struct file *fp, const char __user *buf,
+	size_t count, loff_t *pos)
+{
+	struct mtp_dev *dev = fp->private_data;
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req = 0;
+	int r = count, xfer;
+	int sendZLP = 0;
+	int ret;
+
+	DBG(cdev, "mtp_write(%d)\n", count);
+
+	spin_lock_irq(&dev->lock);
+	if (dev->state == STATE_CANCELED) {
+		/* report cancelation to userspace */
+		dev->state = STATE_READY;
+		spin_unlock_irq(&dev->lock);
+		return -ECANCELED;
+	}
+	if (dev->state == STATE_OFFLINE) {
+		spin_unlock_irq(&dev->lock);
+		return -ENODEV;
+	}
+	dev->state = STATE_BUSY;
+	spin_unlock_irq(&dev->lock);
+
+	/* we need to send a zero length packet to signal the end of transfer
+	 * if the transfer size is aligned to a packet boundary.
+	 */
+	if ((count & (dev->ep_in->maxpacket - 1)) == 0)
+		sendZLP = 1;
+
+	while (count > 0 || sendZLP) {
+		/* so we exit after sending ZLP */
+		if (count == 0)
+			sendZLP = 0;
+
+		if (dev->state != STATE_BUSY) {
+			DBG(cdev, "mtp_write dev->error\n");
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+			((req = mtp_req_get(dev, &dev->tx_idle))
+				|| dev->state != STATE_BUSY));
+		if (!req) {
+			r = ret;
+			break;
+		}
+
+		if (count > MTP_BULK_BUFFER_SIZE)
+			xfer = MTP_BULK_BUFFER_SIZE;
+		else
+			xfer = count;
+		if (xfer && copy_from_user(req->buf, buf, xfer)) {
+			r = -EFAULT;
+			break;
+		}
+
+		req->length = xfer;
+		ret = usb_ep_queue(dev->ep_in, req, GFP_KERNEL);
+		if (ret < 0) {
+			DBG(cdev, "mtp_write: xfer error %d\n", ret);
+			r = -EIO;
+			break;
+		}
+
+		buf += xfer;
+		count -= xfer;
+
+		/* zero this so we don't try to free it on error exit */
+		req = 0;
+	}
+
+	if (req)
+		mtp_req_put(dev, &dev->tx_idle, req);
+
+	spin_lock_irq(&dev->lock);
+	if (dev->state == STATE_CANCELED)
+		r = -ECANCELED;
+	else if (dev->state != STATE_OFFLINE)
+		dev->state = STATE_READY;
+	spin_unlock_irq(&dev->lock);
+
+	DBG(cdev, "mtp_write returning %d\n", r);
+	return r;
+}
+
+/* read from a local file and write to USB */
+static void send_file_work(struct work_struct *data)
+{
+	struct mtp_dev *dev = container_of(data, struct mtp_dev,
+						send_file_work);
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req = 0;
+	struct mtp_data_header *header;
+	struct file *filp;
+	loff_t offset;
+	int64_t count;
+	int xfer, ret, hdr_size;
+	int r = 0;
+	int sendZLP = 0;
+
+	/* read our parameters */
+	smp_rmb();
+	filp = dev->xfer_file;
+	offset = dev->xfer_file_offset;
+	count = dev->xfer_file_length;
+
+	DBG(cdev, "send_file_work(%lld %lld)\n", offset, count);
+
+	if (dev->xfer_send_header) {
+		hdr_size = sizeof(struct mtp_data_header);
+		count += hdr_size;
+	} else {
+		hdr_size = 0;
+	}
+
+	/* we need to send a zero length packet to signal the end of transfer
+	 * if the transfer size is aligned to a packet boundary.
+	 */
+	if ((count & (dev->ep_in->maxpacket - 1)) == 0)
+		sendZLP = 1;
+
+	while (count > 0 || sendZLP) {
+		/* so we exit after sending ZLP */
+		if (count == 0)
+			sendZLP = 0;
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+			(req = mtp_req_get(dev, &dev->tx_idle))
+			|| dev->state != STATE_BUSY);
+		if (dev->state == STATE_CANCELED) {
+			r = -ECANCELED;
+			break;
+		}
+		if (!req) {
+			r = ret;
+			break;
+		}
+
+		if (count > MTP_BULK_BUFFER_SIZE)
+			xfer = MTP_BULK_BUFFER_SIZE;
+		else
+			xfer = count;
+
+		if (hdr_size) {
+			/* prepend MTP data header */
+			header = (struct mtp_data_header *)req->buf;
+			header->length = __cpu_to_le32(count);
+			header->type = __cpu_to_le16(2); /* data packet */
+			header->command = __cpu_to_le16(dev->xfer_command);
+			header->transaction_id =
+					__cpu_to_le32(dev->xfer_transaction_id);
+		}
+
+		ret = vfs_read(filp, req->buf + hdr_size, xfer - hdr_size,
+								&offset);
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+		xfer = ret + hdr_size;
+		hdr_size = 0;
+
+		req->length = xfer;
+		ret = usb_ep_queue(dev->ep_in, req, GFP_KERNEL);
+		if (ret < 0) {
+			DBG(cdev, "send_file_work: xfer error %d\n", ret);
+			dev->state = STATE_ERROR;
+			r = -EIO;
+			break;
+		}
+
+		count -= xfer;
+
+		/* zero this so we don't try to free it on error exit */
+		req = 0;
+	}
+
+	if (req)
+		mtp_req_put(dev, &dev->tx_idle, req);
+
+	DBG(cdev, "send_file_work returning %d\n", r);
+	/* write the result */
+	dev->xfer_result = r;
+	smp_wmb();
+}
+
+/* read from USB and write to a local file */
+static void receive_file_work(struct work_struct *data)
+{
+	struct mtp_dev *dev = container_of(data, struct mtp_dev,
+						receive_file_work);
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *read_req = NULL, *write_req = NULL;
+	struct file *filp;
+	loff_t offset;
+	int64_t count;
+	int ret, cur_buf = 0;
+	int r = 0;
+
+	/* read our parameters */
+	smp_rmb();
+	filp = dev->xfer_file;
+	offset = dev->xfer_file_offset;
+	count = dev->xfer_file_length;
+
+	DBG(cdev, "receive_file_work(%lld)\n", count);
+
+	while (count > 0 || write_req) {
+		if (count > 0) {
+			/* queue a request */
+			read_req = dev->rx_req[cur_buf];
+			cur_buf = (cur_buf + 1) % RX_REQ_MAX;
+
+			read_req->length = (count > MTP_BULK_BUFFER_SIZE
+					? MTP_BULK_BUFFER_SIZE : count);
+			dev->rx_done = 0;
+			ret = usb_ep_queue(dev->ep_out, read_req, GFP_KERNEL);
+			if (ret < 0) {
+				r = -EIO;
+				dev->state = STATE_ERROR;
+				break;
+			}
+		}
+
+		if (write_req) {
+			DBG(cdev, "rx %p %d\n", write_req, write_req->actual);
+			ret = vfs_write(filp, write_req->buf, write_req->actual,
+				&offset);
+			DBG(cdev, "vfs_write %d\n", ret);
+			if (ret != write_req->actual) {
+				r = -EIO;
+				dev->state = STATE_ERROR;
+				break;
+			}
+			write_req = NULL;
+		}
+
+		if (read_req) {
+			/* wait for our last read to complete */
+			ret = wait_event_interruptible(dev->read_wq,
+				dev->rx_done || dev->state != STATE_BUSY);
+			if (dev->state == STATE_CANCELED) {
+				r = -ECANCELED;
+				if (!dev->rx_done)
+					usb_ep_dequeue(dev->ep_out, read_req);
+				break;
+			}
+			/* if xfer_file_length is 0xFFFFFFFF, then we read until
+			 * we get a zero length packet
+			 */
+			if (count != 0xFFFFFFFF)
+				count -= read_req->actual;
+			if (read_req->actual < read_req->length) {
+				/*
+				 * short packet is used to signal EOF for
+				 * sizes > 4 gig
+				 */
+				DBG(cdev, "got short packet\n");
+				count = 0;
+			}
+
+			write_req = read_req;
+			read_req = NULL;
+		}
+	}
+
+	DBG(cdev, "receive_file_work returning %d\n", r);
+	/* write the result */
+	dev->xfer_result = r;
+	smp_wmb();
+}
+
+static int mtp_send_event(struct mtp_dev *dev, struct mtp_event *event)
+{
+	struct usb_request *req = NULL;
+	int ret;
+	int length = event->length;
+
+	DBG(dev->cdev, "mtp_send_event(%d)\n", event->length);
+
+	if (length < 0 || length > INTR_BUFFER_SIZE)
+		return -EINVAL;
+	if (dev->state == STATE_OFFLINE)
+		return -ENODEV;
+
+	ret = wait_event_interruptible_timeout(dev->intr_wq,
+			(req = mtp_req_get(dev, &dev->intr_idle)),
+			msecs_to_jiffies(1000));
+	if (!req)
+		return -ETIME;
+
+	if (copy_from_user(req->buf, (void __user *)event->data, length)) {
+		mtp_req_put(dev, &dev->intr_idle, req);
+		return -EFAULT;
+	}
+	req->length = length;
+	ret = usb_ep_queue(dev->ep_intr, req, GFP_KERNEL);
+	if (ret)
+		mtp_req_put(dev, &dev->intr_idle, req);
+
+	return ret;
+}
+
+static long mtp_ioctl(struct file *fp, unsigned code, unsigned long value)
+{
+	struct mtp_dev *dev = fp->private_data;
+	struct file *filp = NULL;
+	int ret = -EINVAL;
+
+	if (mtp_lock(&dev->ioctl_excl))
+		return -EBUSY;
+
+	switch (code) {
+	case MTP_SEND_FILE:
+	case MTP_RECEIVE_FILE:
+	case MTP_SEND_FILE_WITH_HEADER:
+	{
+		struct mtp_file_range	mfr;
+		struct work_struct *work;
+
+		spin_lock_irq(&dev->lock);
+		if (dev->state == STATE_CANCELED) {
+			/* report cancelation to userspace */
+			dev->state = STATE_READY;
+			spin_unlock_irq(&dev->lock);
+			ret = -ECANCELED;
+			goto out;
+		}
+		if (dev->state == STATE_OFFLINE) {
+			spin_unlock_irq(&dev->lock);
+			ret = -ENODEV;
+			goto out;
+		}
+		dev->state = STATE_BUSY;
+		spin_unlock_irq(&dev->lock);
+
+		if (copy_from_user(&mfr, (void __user *)value, sizeof(mfr))) {
+			ret = -EFAULT;
+			goto fail;
+		}
+		/* hold a reference to the file while we are working with it */
+		filp = fget(mfr.fd);
+		if (!filp) {
+			ret = -EBADF;
+			goto fail;
+		}
+
+		/* write the parameters */
+		dev->xfer_file = filp;
+		dev->xfer_file_offset = mfr.offset;
+		dev->xfer_file_length = mfr.length;
+		smp_wmb();
+
+		if (code == MTP_SEND_FILE_WITH_HEADER) {
+			work = &dev->send_file_work;
+			dev->xfer_send_header = 1;
+			dev->xfer_command = mfr.command;
+			dev->xfer_transaction_id = mfr.transaction_id;
+		} else if (code == MTP_SEND_FILE) {
+			work = &dev->send_file_work;
+			dev->xfer_send_header = 0;
+		} else {
+			work = &dev->receive_file_work;
+		}
+
+		/* We do the file transfer on a work queue so it will run
+		 * in kernel context, which is necessary for vfs_read and
+		 * vfs_write to use our buffers in the kernel address space.
+		 */
+		queue_work(dev->wq, work);
+		/* wait for operation to complete */
+		flush_workqueue(dev->wq);
+		fput(filp);
+
+		/* read the result */
+		smp_rmb();
+		ret = dev->xfer_result;
+		break;
+	}
+	case MTP_SEND_EVENT:
+	{
+		struct mtp_event	event;
+		/* return here so we don't change dev->state below,
+		 * which would interfere with bulk transfer state.
+		 */
+		if (copy_from_user(&event, (void __user *)value, sizeof(event)))
+			ret = -EFAULT;
+		else
+			ret = mtp_send_event(dev, &event);
+		goto out;
+	}
+	}
+
+fail:
+	spin_lock_irq(&dev->lock);
+	if (dev->state == STATE_CANCELED)
+		ret = -ECANCELED;
+	else if (dev->state != STATE_OFFLINE)
+		dev->state = STATE_READY;
+	spin_unlock_irq(&dev->lock);
+out:
+	mtp_unlock(&dev->ioctl_excl);
+	DBG(dev->cdev, "ioctl returning %d\n", ret);
+	return ret;
+}
+
+static int mtp_open(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "mtp_open\n");
+	if (mtp_lock(&_mtp_dev->open_excl))
+		return -EBUSY;
+
+	/* clear any error condition */
+	if (_mtp_dev->state != STATE_OFFLINE)
+		_mtp_dev->state = STATE_READY;
+
+	fp->private_data = _mtp_dev;
+	return 0;
+}
+
+static int mtp_release(struct inode *ip, struct file *fp)
+{
+	printk(KERN_INFO "mtp_release\n");
+
+	mtp_unlock(&_mtp_dev->open_excl);
+	return 0;
+}
+
+/* file operations for /dev/mtp_usb */
+static const struct file_operations mtp_fops = {
+	.owner = THIS_MODULE,
+	.read = mtp_read,
+	.write = mtp_write,
+	.unlocked_ioctl = mtp_ioctl,
+	.open = mtp_open,
+	.release = mtp_release,
+};
+
+static struct miscdevice mtp_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = mtp_shortname,
+	.fops = &mtp_fops,
+};
+
+static int mtp_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl)
+{
+	struct mtp_dev *dev = _mtp_dev;
+	int	value = -EOPNOTSUPP;
+	u16	w_index = le16_to_cpu(ctrl->wIndex);
+	u16	w_value = le16_to_cpu(ctrl->wValue);
+	u16	w_length = le16_to_cpu(ctrl->wLength);
+	unsigned long	flags;
+
+	VDBG(cdev, "mtp_ctrlrequest "
+			"%02x.%02x v%04x i%04x l%u\n",
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+
+	/* Handle MTP OS string */
+	if (ctrl->bRequestType ==
+			(USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE)
+			&& ctrl->bRequest == USB_REQ_GET_DESCRIPTOR
+			&& (w_value >> 8) == USB_DT_STRING
+			&& (w_value & 0xFF) == MTP_OS_STRING_ID) {
+		value = (w_length < sizeof(mtp_os_string)
+				? w_length : sizeof(mtp_os_string));
+		memcpy(cdev->req->buf, mtp_os_string, value);
+	} else if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR) {
+		/* Handle MTP OS descriptor */
+		DBG(cdev, "vendor request: %d index: %d value: %d length: %d\n",
+			ctrl->bRequest, w_index, w_value, w_length);
+
+		if (ctrl->bRequest == 1
+				&& (ctrl->bRequestType & USB_DIR_IN)
+				&& (w_index == 4 || w_index == 5)) {
+			value = (w_length < sizeof(mtp_ext_config_desc) ?
+					w_length : sizeof(mtp_ext_config_desc));
+			memcpy(cdev->req->buf, &mtp_ext_config_desc, value);
+		}
+	} else if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS) {
+		DBG(cdev, "class request: %d index: %d value: %d length: %d\n",
+			ctrl->bRequest, w_index, w_value, w_length);
+
+		if (ctrl->bRequest == MTP_REQ_CANCEL && w_index == 0
+				&& w_value == 0) {
+			DBG(cdev, "MTP_REQ_CANCEL\n");
+
+			spin_lock_irqsave(&dev->lock, flags);
+			if (dev->state == STATE_BUSY) {
+				dev->state = STATE_CANCELED;
+				wake_up(&dev->read_wq);
+				wake_up(&dev->write_wq);
+			}
+			spin_unlock_irqrestore(&dev->lock, flags);
+
+			/* We need to queue a request to read the remaining
+			 *  bytes, but we don't actually need to look at
+			 * the contents.
+			 */
+			value = w_length;
+		} else if (ctrl->bRequest == MTP_REQ_GET_DEVICE_STATUS
+				&& w_index == 0 && w_value == 0) {
+			struct mtp_device_status *status = cdev->req->buf;
+			status->wLength =
+				__constant_cpu_to_le16(sizeof(*status));
+
+			DBG(cdev, "MTP_REQ_GET_DEVICE_STATUS\n");
+			spin_lock_irqsave(&dev->lock, flags);
+			/* device status is "busy" until we report
+			 * the cancelation to userspace
+			 */
+			if (dev->state == STATE_CANCELED)
+				status->wCode =
+					__cpu_to_le16(MTP_RESPONSE_DEVICE_BUSY);
+			else
+				status->wCode =
+					__cpu_to_le16(MTP_RESPONSE_OK);
+			spin_unlock_irqrestore(&dev->lock, flags);
+			value = sizeof(*status);
+		}
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		int rc;
+		cdev->req->zero = value < w_length;
+		cdev->req->length = value;
+		rc = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (rc < 0)
+			ERROR(cdev, "%s: response queue error\n", __func__);
+	}
+	return value;
+}
+
+static int
+mtp_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct mtp_dev	*dev = func_to_mtp(f);
+	int			id;
+	int			ret;
+
+	dev->cdev = cdev;
+	DBG(cdev, "mtp_function_bind dev: %p\n", dev);
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	mtp_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = mtp_create_bulk_endpoints(dev, &mtp_fullspeed_in_desc,
+			&mtp_fullspeed_out_desc, &mtp_intr_desc);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		mtp_highspeed_in_desc.bEndpointAddress =
+			mtp_fullspeed_in_desc.bEndpointAddress;
+		mtp_highspeed_out_desc.bEndpointAddress =
+			mtp_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	DBG(cdev, "%s speed %s: IN/%s, OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name, dev->ep_out->name);
+	return 0;
+}
+
+static void
+mtp_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct mtp_dev	*dev = func_to_mtp(f);
+	struct usb_request *req;
+	int i;
+
+	while ((req = mtp_req_get(dev, &dev->tx_idle)))
+		mtp_request_free(req, dev->ep_in);
+	for (i = 0; i < RX_REQ_MAX; i++)
+		mtp_request_free(dev->rx_req[i], dev->ep_out);
+	while ((req = mtp_req_get(dev, &dev->intr_idle)))
+		mtp_request_free(req, dev->ep_intr);
+	dev->state = STATE_OFFLINE;
+}
+
+static int mtp_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct mtp_dev	*dev = func_to_mtp(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	DBG(cdev, "mtp_function_set_alt intf: %d alt: %d\n", intf, alt);
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_in);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_in);
+	if (ret)
+		return ret;
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_out);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_out);
+	if (ret) {
+		usb_ep_disable(dev->ep_in);
+		return ret;
+	}
+
+	ret = config_ep_by_speed(cdev->gadget, f, dev->ep_intr);
+	if (ret)
+		return ret;
+
+	ret = usb_ep_enable(dev->ep_intr);
+	if (ret) {
+		usb_ep_disable(dev->ep_out);
+		usb_ep_disable(dev->ep_in);
+		return ret;
+	}
+	dev->state = STATE_READY;
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+	return 0;
+}
+
+static void mtp_function_disable(struct usb_function *f)
+{
+	struct mtp_dev	*dev = func_to_mtp(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	DBG(cdev, "mtp_function_disable\n");
+	dev->state = STATE_OFFLINE;
+	usb_ep_disable(dev->ep_in);
+	usb_ep_disable(dev->ep_out);
+	usb_ep_disable(dev->ep_intr);
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+
+	VDBG(cdev, "%s disabled\n", dev->function.name);
+}
+
+static int mtp_bind_config(struct usb_configuration *c, bool ptp_config)
+{
+	struct mtp_dev *dev = _mtp_dev;
+	int ret = 0;
+
+	printk(KERN_INFO "mtp_bind_config\n");
+
+	/* allocate a string ID for our interface */
+	if (mtp_string_defs[INTERFACE_STRING_INDEX].id == 0) {
+		ret = usb_string_id(c->cdev);
+		if (ret < 0)
+			return ret;
+		mtp_string_defs[INTERFACE_STRING_INDEX].id = ret;
+		mtp_interface_desc.iInterface = ret;
+	}
+
+	dev->cdev = c->cdev;
+	dev->function.name = "mtp";
+	dev->function.strings = mtp_strings;
+	if (ptp_config) {
+		dev->function.descriptors = fs_ptp_descs;
+		dev->function.hs_descriptors = hs_ptp_descs;
+	} else {
+		dev->function.descriptors = fs_mtp_descs;
+		dev->function.hs_descriptors = hs_mtp_descs;
+	}
+	dev->function.bind = mtp_function_bind;
+	dev->function.unbind = mtp_function_unbind;
+	dev->function.set_alt = mtp_function_set_alt;
+	dev->function.disable = mtp_function_disable;
+
+	return usb_add_function(c, &dev->function);
+}
+
+static int mtp_setup(void)
+{
+	struct mtp_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+	init_waitqueue_head(&dev->read_wq);
+	init_waitqueue_head(&dev->write_wq);
+	init_waitqueue_head(&dev->intr_wq);
+	atomic_set(&dev->open_excl, 0);
+	atomic_set(&dev->ioctl_excl, 0);
+	INIT_LIST_HEAD(&dev->tx_idle);
+	INIT_LIST_HEAD(&dev->intr_idle);
+
+	dev->wq = create_singlethread_workqueue("f_mtp");
+	if (!dev->wq) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+	INIT_WORK(&dev->send_file_work, send_file_work);
+	INIT_WORK(&dev->receive_file_work, receive_file_work);
+
+	_mtp_dev = dev;
+
+	ret = misc_register(&mtp_device);
+	if (ret)
+		goto err2;
+
+	return 0;
+
+err2:
+	destroy_workqueue(dev->wq);
+err1:
+	_mtp_dev = NULL;
+	kfree(dev);
+	printk(KERN_ERR "mtp gadget driver failed to initialize\n");
+	return ret;
+}
+
+static void mtp_cleanup(void)
+{
+	struct mtp_dev *dev = _mtp_dev;
+
+	if (!dev)
+		return;
+
+	misc_deregister(&mtp_device);
+	destroy_workqueue(dev->wq);
+	_mtp_dev = NULL;
+	kfree(dev);
+}
diff --git a/drivers/usb/gadget/f_rndis.c b/drivers/usb/gadget/f_rndis.c
index 345f838..9d26ef0 100644
--- a/drivers/usb/gadget/f_rndis.c
+++ b/drivers/usb/gadget/f_rndis.c
@@ -71,6 +71,8 @@ struct f_rndis {
 	struct gether			port;
 	u8				ctrl_id, data_id;
 	u8				ethaddr[ETH_ALEN];
+	u32				vendorID;
+	const char			*manufacturer;
 	int				config;
 
 	struct usb_ep			*notify;
@@ -768,12 +770,10 @@ rndis_bind(struct usb_configuration *c, struct usb_function *f)
 	rndis_set_param_medium(rndis->config, NDIS_MEDIUM_802_3, 0);
 	rndis_set_host_mac(rndis->config, rndis->ethaddr);
 
-#if 0
-// FIXME
-	if (rndis_set_param_vendor(rndis->config, vendorID,
-				manufacturer))
-		goto fail0;
-#endif
+	if (rndis->manufacturer && rndis->vendorID &&
+			rndis_set_param_vendor(rndis->config, rndis->vendorID,
+					       rndis->manufacturer))
+		goto fail;
 
 	/* NOTE:  all that is done without knowing or caring about
 	 * the network link ... which is unavailable to this code
@@ -855,20 +855,27 @@ static inline bool can_support_rndis(struct usb_configuration *c)
 int
 rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN])
 {
+	return rndis_bind_config_vendor(c, ethaddr, 0, NULL);
+}
+
+int
+rndis_bind_config_vendor(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
+				u32 vendorID, const char *manufacturer)
+{
 	struct f_rndis	*rndis;
 	int		status;
 
 	if (!can_support_rndis(c) || !ethaddr)
 		return -EINVAL;
 
+	/* setup RNDIS itself */
+	status = rndis_init();
+	if (status < 0)
+		return status;
+
 	/* maybe allocate device-global string IDs */
 	if (rndis_string_defs[0].id == 0) {
 
-		/* ... and setup RNDIS itself */
-		status = rndis_init();
-		if (status < 0)
-			return status;
-
 		/* control interface label */
 		status = usb_string_id(c->cdev);
 		if (status < 0)
@@ -898,6 +905,8 @@ rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN])
 		goto fail;
 
 	memcpy(rndis->ethaddr, ethaddr, ETH_ALEN);
+	rndis->vendorID = vendorID;
+	rndis->manufacturer = manufacturer;
 
 	/* RNDIS activates when the host changes this filter */
 	rndis->port.cdc_filter = 0;
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index a896d73..cc8ea1c 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -3568,6 +3568,9 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 
 	/* Tell the thread to start working */
 	wake_up_process(fsg->thread_task);
+
+	usb_gadget_connect(gadget);
+
 	return 0;
 
 autoconf_fail:
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index a8855d0..8383782 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -50,6 +50,7 @@
 #define gadget_is_s3c2410(g)		(!strcmp("s3c2410_udc", (g)->name))
 #define gadget_is_s3c_hsotg(g)		(!strcmp("s3c-hsotg", (g)->name))
 #define gadget_is_s3c_hsudc(g)		(!strcmp("s3c-hsudc", (g)->name))
+#define gadget_is_softwinner_otg(g)	(!strcmp("sw_usb_udc", (g)->name))
 
 /**
  * usb_gadget_controller_number - support bcdDevice id convention
@@ -118,7 +119,8 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x31;
 	else if (gadget_is_dwc3(gadget))
 		return 0x32;
-
+	else if (gadget_is_softwinner_otg(gadget))
+		return 0x33;
 	return -ENOENT;
 }
 
diff --git a/drivers/usb/gadget/rndis.c b/drivers/usb/gadget/rndis.c
index 73a934a..0cb2121 100644
--- a/drivers/usb/gadget/rndis.c
+++ b/drivers/usb/gadget/rndis.c
@@ -1146,11 +1146,15 @@ static struct proc_dir_entry *rndis_connect_state [RNDIS_MAX_CONFIGS];
 
 #endif /* CONFIG_USB_GADGET_DEBUG_FILES */
 
+static bool rndis_initialized;
 
 int rndis_init(void)
 {
 	u8 i;
 
+	if (rndis_initialized)
+		return 0;
+
 	for (i = 0; i < RNDIS_MAX_CONFIGS; i++) {
 #ifdef	CONFIG_USB_GADGET_DEBUG_FILES
 		char name [20];
@@ -1177,6 +1181,7 @@ int rndis_init(void)
 		INIT_LIST_HEAD(&(rndis_per_dev_params[i].resp_queue));
 	}
 
+	rndis_initialized = true;
 	return 0;
 }
 
@@ -1185,7 +1190,13 @@ void rndis_exit(void)
 #ifdef CONFIG_USB_GADGET_DEBUG_FILES
 	u8 i;
 	char name[20];
+#endif
 
+	if (!rndis_initialized)
+		return;
+	rndis_initialized = false;
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
 	for (i = 0; i < RNDIS_MAX_CONFIGS; i++) {
 		sprintf(name, NAME_TEMPLATE, i);
 		remove_proc_entry(name, NULL);
diff --git a/drivers/usb/gadget/storage_common.c b/drivers/usb/gadget/storage_common.c
index 8081ca3..b3ef00a 100644
--- a/drivers/usb/gadget/storage_common.c
+++ b/drivers/usb/gadget/storage_common.c
@@ -712,7 +712,10 @@ static int fsg_lun_open(struct fsg_lun *curlun, const char *filename)
 	curlun->filp = filp;
 	curlun->file_length = size;
 	curlun->num_sectors = num_sectors;
+
 	LDBG(curlun, "open backing file: %s\n", filename);
+	printk("usb open backing file: %s, 0x%p\n", filename, curlun);
+
 	rc = 0;
 
 out:
@@ -725,6 +728,9 @@ static void fsg_lun_close(struct fsg_lun *curlun)
 {
 	if (curlun->filp) {
 		LDBG(curlun, "close backing file\n");
+
+        printk("usb close backing file: 0x%p\n", curlun);
+
 		fput(curlun->filp);
 		curlun->filp = NULL;
 	}
@@ -874,6 +880,7 @@ static ssize_t fsg_store_file(struct device *dev, struct device_attribute *attr,
 
 	if (curlun->prevent_medium_removal && fsg_lun_is_open(curlun)) {
 		LDBG(curlun, "eject attempt prevented\n");
+		printk("media is prevented, can not eject\n");
 		return -EBUSY;				/* "Door is locked" */
 	}
 
diff --git a/drivers/usb/gadget/sw_usb_platform.h b/drivers/usb/gadget/sw_usb_platform.h
new file mode 100644
index 0000000..6ebb0af
--- /dev/null
+++ b/drivers/usb/gadget/sw_usb_platform.h
@@ -0,0 +1,103 @@
+/*
+ * drivers/usb/gadget/sw_usb_platform.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+*************************************************************************************
+*                         			    Linux
+*					           USB Device Controller Driver
+*
+*				        (c) Copyright 2006-2010, All winners Co,Ld.
+*							       All Rights Reserved
+*
+* File Name 	: sw_usb_platform.h
+*
+* Author 		: javen
+*
+* Description 	: USB 
+*
+* Notes         :
+*
+* History 		:
+*      <author>    		<time>       	<version >    		<desc>
+*       javen     	  2011-3-13            1.0          create this file
+*
+*************************************************************************************
+*/
+#ifndef  __SW_USB_PLATFORM_H__
+#define  __SW_USB_PLATFORM_H__
+
+//---------------------------------------------------------------
+//  USB
+//---------------------------------------------------------------
+/* ID, ID,  */
+#if 0
+#define  SW_USB_VENDOR_ID               0x1F3A
+
+#define  SW_USB_UMS_PRODUCT_ID          0x1000  /* USB Mass Storage             */
+#define  SW_USB_ADB_PRODUCT_ID          0x1001  /* USB Android Debug Bridge     */
+#define  SW_USB_ACM_PRODUCT_ID          0x1002  /* USB Abstract Control Model   */
+#define  SW_USB_MTP_PRODUCT_ID          0x1003  /* USB Media Transfer Protocol  */
+#define  SW_USB_RNDIS_PRODUCT_ID        0x1004  /* USB RNDIS ethernet           */
+#define  SW_USB_VERSION                 100
+#else
+#define  SW_USB_VENDOR_ID               0x18D1
+
+#define  SW_USB_UMS_PRODUCT_ID          0x0001  /* USB Mass Storage             */
+#define  SW_USB_ADB_PRODUCT_ID          0x0002  /* USB Android Debug Bridge     */
+#define  SW_USB_ACM_PRODUCT_ID          0x0003  /* USB Abstract Control Model   */
+#define  SW_USB_MTP_PRODUCT_ID          0x0004  /* USB Media Transfer Protocol  */
+#define  SW_USB_RNDIS_PRODUCT_ID        0x0005  /* USB RNDIS ethernet           */
+#define  SW_USB_VERSION                 100
+#endif
+
+//---------------------------------------------------------------
+//  Android USB device descriptor
+//---------------------------------------------------------------
+
+/* , ,  */
+#define  SW_USB_MANUFACTURER_NAME           "USB Developer"
+#define  SW_USB_PRODUCT_NAME                "Android"
+#define  SW_USB_SERIAL_NUMBER               "20080411"
+
+//---------------------------------------------------------------
+//  usb_mass_storage
+//---------------------------------------------------------------
+/* , ,  */
+#define  SW_USB_MASS_STORAGE_VENDOR_NAME    "USB 2.0"
+#define  SW_USB_MASS_STORAGE_PRODUCT_NAME   "USB Flash Driver"
+#define  SW_USB_MASS_STORAGE_RELEASE        100
+
+/*  PCU */
+#define  SW_USB_NLUNS               3
+
+//---------------------------------------------------------------
+//  USB ethernet
+//---------------------------------------------------------------
+
+
+//---------------------------------------------------------------
+//  USB Abstract Control Model
+//---------------------------------------------------------------
+#define  SW_USB_ACM_NUM_INST        1
+
+#endif   //__SW_USB_PLATFORM_H__
+
diff --git a/drivers/usb/gadget/u_ether.c b/drivers/usb/gadget/u_ether.c
index 9a2a1ae..dd2615a 100644
--- a/drivers/usb/gadget/u_ether.c
+++ b/drivers/usb/gadget/u_ether.c
@@ -764,6 +764,26 @@ static struct device_type gadget_type = {
  */
 int gether_setup(struct usb_gadget *g, u8 ethaddr[ETH_ALEN])
 {
+	return gether_setup_name(g, ethaddr, "usb");
+}
+
+/**
+ * gether_setup_name - initialize one ethernet-over-usb link
+ * @g: gadget to associated with these links
+ * @ethaddr: NULL, or a buffer in which the ethernet address of the
+ *	host side of the link is recorded
+ * @netname: name for network device (for example, "usb")
+ * Context: may sleep
+ *
+ * This sets up the single network link that may be exported by a
+ * gadget driver using this framework.  The link layer addresses are
+ * set up using module parameters.
+ *
+ * Returns negative errno, or zero on success
+ */
+int gether_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
+		const char *netname)
+{
 	struct eth_dev		*dev;
 	struct net_device	*net;
 	int			status;
@@ -786,7 +806,7 @@ int gether_setup(struct usb_gadget *g, u8 ethaddr[ETH_ALEN])
 
 	/* network device setup */
 	dev->net = net;
-	strcpy(net->name, "usb%d");
+	snprintf(net->name, sizeof(net->name), "%s%%d", netname);
 
 	if (get_ether_addr(dev_addr, net->dev_addr))
 		dev_warn(&g->dev,
diff --git a/drivers/usb/gadget/u_ether.h b/drivers/usb/gadget/u_ether.h
index 8012357..37431f5 100644
--- a/drivers/usb/gadget/u_ether.h
+++ b/drivers/usb/gadget/u_ether.h
@@ -73,6 +73,9 @@ struct gether {
 /* netdev setup/teardown as directed by the gadget driver */
 int gether_setup(struct usb_gadget *g, u8 ethaddr[ETH_ALEN]);
 void gether_cleanup(void);
+/* variant of gether_setup that allows customizing network device name */
+int gether_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
+		const char *netname);
 
 /* connect/disconnect is handled by individual functions */
 struct net_device *gether_connect(struct gether *);
@@ -100,6 +103,8 @@ int eem_bind_config(struct usb_configuration *c);
 #ifdef USB_ETH_RNDIS
 
 int rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN]);
+int rndis_bind_config_vendor(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
+				u32 vendorID, const char *manufacturer);
 
 #else
 
@@ -109,6 +114,13 @@ rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN])
 	return 0;
 }
 
+static inline int
+rndis_bind_config_vendor(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
+				u32 vendorID, const char *manufacturer)
+{
+	return 0;
+}
+
 #endif
 
 #endif /* __U_ETHER_H */
diff --git a/drivers/usb/gadget/u_serial.c b/drivers/usb/gadget/u_serial.c
index 6c23938..380a87f 100644
--- a/drivers/usb/gadget/u_serial.c
+++ b/drivers/usb/gadget/u_serial.c
@@ -1025,7 +1025,7 @@ static const struct tty_operations gs_tty_ops = {
 
 static struct tty_driver *gs_tty_driver;
 
-static int __init
+static int
 gs_port_alloc(unsigned port_num, struct usb_cdc_line_coding *coding)
 {
 	struct gs_port	*port;
@@ -1071,7 +1071,7 @@ gs_port_alloc(unsigned port_num, struct usb_cdc_line_coding *coding)
  *
  * Returns negative errno or zero.
  */
-int __init gserial_setup(struct usb_gadget *g, unsigned count)
+int gserial_setup(struct usb_gadget *g, unsigned count)
 {
 	unsigned			i;
 	struct usb_cdc_line_coding	coding;
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index f788eb8..85513a1 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -524,7 +524,7 @@ config USB_SL811_HCD
 	help
 	  The SL811HS is a single-port USB controller that supports either
 	  host side or peripheral side roles.  Enable this option if your
-	  board has this chip, and you want to use it as a host controller. 
+	  board has this chip, and you want to use it as a host controller.
 	  If unsure, say N.
 
 	  To compile this driver as a module, choose M here: the
@@ -638,3 +638,31 @@ config USB_OCTEON_OHCI
 config USB_OCTEON2_COMMON
 	bool
 	default y if USB_OCTEON_EHCI || USB_OCTEON_OHCI
+
+config USB_SUNXI_EHCI
+	bool "Allwinner sunXi EHCI support"
+	depends on USB && (ARCH_SUN4I || ARCH_SUN5I || ARCH_SUN7I) && USB_EHCI_HCD
+	default y
+	help
+	  Enable support for Allwinner's EHCI controller (USB 2.0).
+
+config USB_SUNXI_OHCI
+	bool "Allwinner sunXi OHCI support"
+	depends on USB && (ARCH_SUN4I || ARCH_SUN5I || ARCH_SUN7I) && USB_OHCI_HCD
+	default USB_SUNXI_EHCI
+	help
+	  Enable support for Allwinner's OHCI controller (USB 1.1).
+
+config USB_SUNXI_COMMON
+	bool
+	depends on (USB_SUNXI_EHCI || USB_SUNXI_OHCI)
+	default y if (USB_SUNXI_EHCI || USB_SUNXI_OHCI)
+	help
+	  Enable support for common routines for Allwinner's USB host
+	  controller (USB1 and USB2 for sun4i, and USB1 for sun5i).
+
+config USB_SW_SUNXI_HCD0
+	boolean "SoftWinner SUNXI USB Host Controller0 (OTG)"
+	depends on USB && USB_SW_SUNXI_USB_MANAGER
+	help
+	    SoftWinner SUNXI USB2.0 Host Controller0, OTG port.
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 0982bcc..db32eca 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -41,3 +41,4 @@ obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_MIPS_ALCHEMY)	+= alchemy-common.o
+obj-$(CONFIG_USB_SUNXI_COMMON)	+= sw_hci_sunxi.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index bb73df6..63b83ba 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -913,6 +913,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		unsigned	i = HCS_N_PORTS (ehci->hcs_params);
 		u32		ppcd = 0;
 
+        printk("ehci_irq: port change detect\n");
+
 		/* kick root hub later */
 		pcd_status = status;
 
@@ -1320,6 +1322,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_atmel_driver
 #endif
 
+#ifdef CONFIG_USB_SUNXI_EHCI
+#include "ehci-sunxi.c"
+#define	PLATFORM_DRIVER		sw_ehci_hcd_driver
+#endif
+
 #ifdef CONFIG_USB_OCTEON_EHCI
 #include "ehci-octeon.c"
 #define PLATFORM_DRIVER		ehci_octeon_driver
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 3cb52a9..a2704c8 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -1089,6 +1089,8 @@ static void __maybe_unused ehci_relinquish_port(struct usb_hcd *hcd,
 	if (ehci_is_TDI(ehci))
 		return;
 	set_owner(ehci, --portnum, PORT_OWNER);
+
+	printk("The port change to OHCI now!\n");
 }
 
 static int __maybe_unused ehci_port_handed_over(struct usb_hcd *hcd,
diff --git a/drivers/usb/host/ehci-sunxi.c b/drivers/usb/host/ehci-sunxi.c
new file mode 100644
index 0000000..be96f81
--- /dev/null
+++ b/drivers/usb/host/ehci-sunxi.c
@@ -0,0 +1,479 @@
+/*
+ * drivers/usb/host/ehci-sunxi.c: SoftWinner EHCI Driver
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * Author: javen
+ * History (author, date, version, notes):
+ *	yangnaitian	2011-5-24	1.0	create this file
+ *	javen		2011-6-26	1.1	add suspend and resume
+ *	javen		2011-7-18	1.2	
+ *						(Clock switch and power switch
+ *						is moved out from the driver)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+
+#include <plat/sys_config.h>
+#include <linux/clk.h>
+
+#include  <mach/clock.h>
+#include "sw_hci_sunxi.h"
+
+#define SW_EHCI_NAME "sw-ehci"
+
+static struct sw_hci_hcd *g_sw_ehci[3];
+static u32 ehci_first_probe[3] = { 1, 1, 1 };
+
+static void sw_start_ehci(struct sw_hci_hcd *sw_ehci)
+{
+	sw_ehci->open_clock(sw_ehci, 0);
+	sw_ehci->usb_passby(sw_ehci, 1);
+	sw_ehci->port_configure(sw_ehci, 1 /*enable*/);
+	sw_ehci->set_power(sw_ehci, 1);
+
+	return;
+}
+
+static void sw_stop_ehci(struct sw_hci_hcd *sw_ehci)
+{
+	sw_ehci->set_power(sw_ehci, 0);
+	sw_ehci->port_configure(sw_ehci, 0 /*disable*/);
+	sw_ehci->usb_passby(sw_ehci, 0);
+	sw_ehci->close_clock(sw_ehci, 0);
+
+	return;
+}
+
+static int sw_ehci_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int ret;
+
+	ret = ehci_setup(hcd);
+	if (ret)
+		return ret;
+
+	/* TODO: is following ok for sunxi? Only very few ehci drivers seem to
+	 * disable watchdog. */
+	ehci->need_io_watchdog = 0;
+
+	return ret;
+}
+
+static const struct hc_driver sw_ehci_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "SW USB2.0 'Enhanced' Host Controller (EHCI) Driver",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = sw_ehci_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * dma fixes
+	 */
+	.map_urb_for_dma = sunxi_hcd_map_urb_for_dma,
+	.unmap_urb_for_dma = sunxi_hcd_unmap_urb_for_dma,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+};
+
+static int sw_ehci_hcd_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	struct sw_hci_hcd *sw_ehci = NULL;
+
+	if (pdev == NULL)
+		return -EINVAL;
+
+	hcd = platform_get_drvdata(pdev);
+	if (hcd == NULL)
+		return -ENODATA;
+
+	sw_ehci = pdev->dev.platform_data;
+	if (sw_ehci == NULL)
+		return -ENODATA;
+
+	pr_debug("[%s%d]: remove, pdev->name: %s, pdev->id: %d, sw_ehci:"
+		" 0x%p\n", SW_EHCI_NAME, sw_ehci->usbc_no, pdev->name, pdev->id,
+		sw_ehci);
+
+	usb_remove_hcd(hcd);
+
+	iounmap(hcd->regs);
+
+	usb_put_hcd(hcd);
+
+	sw_stop_ehci(sw_ehci);
+	sw_ehci->probe = 0;
+
+	sw_ehci->hcd = NULL;
+
+	if (sw_ehci->host_init_state)
+		g_sw_ehci[sw_ehci->usbc_no] = NULL;
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+int sw_usb_disable_ehci(__u32 usbc_no)
+{
+	struct sw_hci_hcd *sw_ehci = NULL;
+
+	if (usbc_no != 1 && usbc_no != 2)
+		return -EINVAL;
+
+	sw_ehci = g_sw_ehci[usbc_no];
+	if (sw_ehci == NULL)
+		return -EFAULT;
+
+	if (sw_ehci->host_init_state)
+		return -ENOSYS;
+
+	if (sw_ehci->probe == 0)
+		return -ENOSYS;
+
+	sw_ehci->probe = 0;
+	pr_info("[%s]: disable ehci\n", sw_ehci->hci_name);
+	sw_ehci_hcd_remove(sw_ehci->pdev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_disable_ehci);
+
+static int sw_ehci_hcd_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	struct ehci_hcd *ehci = NULL;
+	struct sw_hci_hcd *sw_ehci = NULL;
+	struct resource *res;
+	int irq;
+	int ret = 0;
+
+	if (pdev == NULL)
+		return -EINVAL;
+
+	sw_ehci = pdev->dev.platform_data;
+	if (!sw_ehci)
+		return -ENODATA;
+
+	sw_ehci->pdev = pdev;
+	g_sw_ehci[sw_ehci->usbc_no] = sw_ehci;
+
+	pr_debug("[%s%d]: probe, pdev->name: %s, pdev->id: %d,"
+		" sw_ehci: 0x%p\n",
+		SW_EHCI_NAME, sw_ehci->usbc_no, pdev->name, pdev->id, sw_ehci);
+
+	/* get io resource */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		pr_err("%s: failed to get io memory\n", __func__);
+		ret = -ENOMEM;
+		goto err_get_iomem;
+	}
+
+	/* creat a usb_hcd for the ehci controller */
+	hcd = usb_create_hcd(&sw_ehci_hc_driver, &pdev->dev, SW_EHCI_NAME);
+	if (!hcd) {
+		pr_err("%s: failed to create hcd\n", __func__);
+		ret = -ENOMEM;
+		goto err_create_hcd;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+	hcd->regs = ioremap(res->start, resource_size(res));
+	if (!hcd->regs) {
+		pr_err("%s: failed to ioremap\n", __func__);
+		ret = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	sw_ehci->hcd = hcd;
+
+	irq = platform_get_irq(pdev, 0);
+	if (!irq) {
+		pr_err("%s: failed to get irq\n", __func__);
+		ret =  -ENODEV;
+		goto err_get_irq;
+	}
+
+	/* ehci start to work */
+	sw_start_ehci(sw_ehci);
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (ret != 0) {
+		pr_err("%s: failed to add hcd, rc=%d\n", __func__, ret);
+		goto err_add_hcd;
+	}
+
+	platform_set_drvdata(pdev, hcd);
+
+	pr_debug("[%s]: probe, clock: SW_VA_CCM_AHBMOD_OFFSET(0x%x), SW_VA_CCM_USBCLK_OFFSET(0x%x);"
+	     " usb: 0x800(0x%x), dram:(0x%x, 0x%x)\n",
+	     sw_ehci->hci_name, (u32) readl(SW_VA_CCM_IO_BASE + SW_VA_CCM_AHBMOD_OFFSET),
+	     (u32) readl(SW_VA_CCM_IO_BASE + SW_VA_CCM_USBCLK_OFFSET),
+	     (u32) readl(sw_ehci->usb_vbase + 0x800),
+	     (u32) readl(SW_VA_DRAM_IO_BASE + SW_SDRAM_REG_HPCR_USB1),
+	     (u32) readl(SW_VA_DRAM_IO_BASE + SW_SDRAM_REG_HPCR_USB2));
+
+	sw_ehci->probe = 1;
+
+	/* Disable ehci, when driver probe */
+	if (sw_ehci->host_init_state == 0) {
+		if (ehci_first_probe[sw_ehci->usbc_no]) {
+			sw_usb_disable_ehci(sw_ehci->usbc_no);
+			ehci_first_probe[sw_ehci->usbc_no]--;
+		}
+	}
+
+	return 0;
+
+err_add_hcd:
+err_get_irq:
+	iounmap(hcd->regs);
+err_ioremap:
+	usb_put_hcd(hcd);
+err_get_iomem:
+err_create_hcd:
+	sw_ehci->hcd = NULL;
+	g_sw_ehci[sw_ehci->usbc_no] = NULL;
+	return ret;
+}
+
+int sw_usb_enable_ehci(__u32 usbc_no)
+{
+	struct sw_hci_hcd *sw_ehci = NULL;
+
+	if (usbc_no != 1 && usbc_no != 2)
+		return -EINVAL;
+
+	sw_ehci = g_sw_ehci[usbc_no];
+	if (sw_ehci == NULL)
+		return -EFAULT;
+
+	if (sw_ehci->host_init_state)
+		return -ENOSYS;
+
+	if (sw_ehci->probe == 1) /* already enabled */
+		return 0;
+
+	sw_ehci->probe = 1;
+	pr_info("[%s]: enable ehci\n", sw_ehci->hci_name);
+	sw_ehci_hcd_probe(sw_ehci->pdev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_enable_ehci);
+
+void sw_ehci_hcd_shutdown(struct platform_device *pdev)
+{
+	struct sw_hci_hcd *sw_ehci = NULL;
+
+	if (pdev == NULL)
+		return;
+
+	sw_ehci = pdev->dev.platform_data;
+	if (sw_ehci == NULL)
+		return;
+
+	if (sw_ehci->probe == 0)
+		return;
+
+	pr_info("[%s]: shutdown start\n", sw_ehci->hci_name);
+	usb_hcd_platform_shutdown(pdev);
+	sw_stop_ehci(sw_ehci);
+	pr_info("[%s]: shutdown end\n", sw_ehci->hci_name);
+
+	return;
+}
+
+#ifdef CONFIG_PM
+static int sw_ehci_hcd_suspend(struct device *dev)
+{
+	struct sw_hci_hcd *sw_ehci = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct ehci_hcd *ehci = NULL;
+	unsigned long flags = 0;
+
+	if (dev == NULL)
+		return 0;
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL)
+		return 0;
+
+	sw_ehci = dev->platform_data;
+	if (sw_ehci == NULL)
+		return 0;
+
+	if (sw_ehci->probe == 0)
+		return 0;
+
+	ehci = hcd_to_ehci(hcd);
+	if (ehci == NULL)
+		return 0;
+
+	pr_info("[%s]: suspend\n", sw_ehci->hci_name);
+
+	spin_lock_irqsave(&ehci->lock, flags);
+	ehci_prepare_ports_for_controller_suspend(ehci, device_may_wakeup(dev));
+	ehci_writel(ehci, 0, &ehci->regs->intr_enable);
+	(void)ehci_readl(ehci, &ehci->regs->intr_enable);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	sw_stop_ehci(sw_ehci);
+	spin_unlock_irqrestore(&ehci->lock, flags);
+
+	return 0;
+}
+
+static int sw_ehci_hcd_resume(struct device *dev)
+{
+	struct sw_hci_hcd *sw_ehci = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct ehci_hcd *ehci = NULL;
+
+	if (dev == NULL)
+		return 0;
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL)
+		return 0;
+
+	sw_ehci = dev->platform_data;
+	if (sw_ehci == NULL)
+		return 0;
+
+	if (sw_ehci->probe == 0)
+		return 0;
+
+	ehci = hcd_to_ehci(hcd);
+	if (ehci == NULL)
+		return 0;
+
+	pr_info("[%s]: resume\n", sw_ehci->hci_name);
+	sw_start_ehci(sw_ehci);
+
+	/* Mark hardware accessible again as we are out of D3 state by now */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	if (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF) {
+		int mask = INTR_MASK;
+
+		ehci_prepare_ports_for_controller_resume(ehci);
+
+		if (!hcd->self.root_hub->do_remote_wakeup)
+			mask &= ~STS_PCD;
+
+		ehci_writel(ehci, mask, &ehci->regs->intr_enable);
+		ehci_readl(ehci, &ehci->regs->intr_enable);
+
+		return 0;
+	}
+
+	pr_info("[%s]: hci lost power, restarting\n", sw_ehci->hci_name);
+	usb_root_hub_lost_power(hcd->self.root_hub);
+
+	/* Else reset, to cope with power loss or flush-to-storage
+	 * style "resume" having let BIOS kick in during reboot.
+	 */
+	(void) ehci_halt(ehci);
+	(void) ehci_reset(ehci);
+
+	/* emptying the schedule aborts any urbs */
+	spin_lock_irq(&ehci->lock);
+	if (ehci->reclaim)
+		end_unlink_async(ehci);
+	ehci_work(ehci);
+	spin_unlock_irq(&ehci->lock);
+
+	ehci_writel(ehci, ehci->command, &ehci->regs->command);
+	ehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);
+	ehci_readl(ehci, &ehci->regs->command);	/* unblock posted writes */
+
+	/* here we "know" root ports should always stay powered */
+	ehci_port_power(ehci, 1);
+
+	hcd->state = HC_STATE_SUSPENDED;
+
+	return 0;
+}
+
+static const struct dev_pm_ops aw_ehci_pmops = {
+	.suspend = sw_ehci_hcd_suspend,
+	.resume = sw_ehci_hcd_resume,
+};
+
+#define SW_EHCI_PMOPS (&aw_ehci_pmops)
+#else
+#define SW_EHCI_PMOPS NULL
+#endif
+
+static struct platform_driver sw_ehci_hcd_driver = {
+	.probe = sw_ehci_hcd_probe,
+	.remove = sw_ehci_hcd_remove,
+	.shutdown = sw_ehci_hcd_shutdown,
+	.driver = {
+		.name = SW_EHCI_NAME,
+		.owner = THIS_MODULE,
+		.pm = SW_EHCI_PMOPS,
+	},
+};
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 235171f..1e88beb 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1,4 +1,26 @@
 /*
+ * drivers/usb/host/ohci-hcd.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
  * Open Host Controller Interface (OHCI) driver for USB.
  *
  * Maintainer: Alan Stern <stern@rowland.harvard.edu>
@@ -45,6 +67,9 @@
 #include <asm/unaligned.h>
 #include <asm/byteorder.h>
 
+#ifdef CONFIG_ARCH_SUN4I
+#include <mach/system.h>
+#endif
 
 #define DRIVER_AUTHOR "Roman Weissgaerber, David Brownell"
 #define DRIVER_DESC "USB 1.1 'Open' Host Controller (OHCI) Driver"
@@ -756,6 +781,27 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	 */
 	ints = ohci_readl(ohci, &regs->intrstatus);
 
+#ifdef CONFIG_ARCH_SUN4I
+{
+	enum sw_ic_ver ic_version = sw_get_ic_ver();
+    if (ic_version == SUNXI_VER_A10A || ic_version == SUNXI_VER_A10B) {
+        __u32 HcRhPortStatus = ohci_readl(ohci, &regs->roothub.portstatus[0]);
+
+        if((HcRhPortStatus & RH_PS_CSC) && (ints & OHCI_INTR_RHSC)){
+            printk("ohci_irq: connect status change\n");
+        }
+
+        /* clear all irq */
+        ohci_writel(ohci, ints, &regs->intrstatus);
+
+        /* clear port status */
+        ohci_writel(ohci, HcRhPortStatus, &regs->roothub.portstatus[0]);
+
+        return IRQ_HANDLED;
+    }
+}
+#endif
+
 	/* Check for an all 1's result which is a typical consequence
 	 * of dead, unclocked, or unplugged (CardBus...) devices
 	 */
@@ -1100,6 +1146,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER	ohci_hcd_jz4740_driver
 #endif
 
+#ifdef CONFIG_USB_SUNXI_OHCI
+#include "ohci-sunxi.c"
+#define	PLATFORM_DRIVER		sw_ohci_hcd_driver
+#endif
+
 #ifdef CONFIG_USB_OCTEON_OHCI
 #include "ohci-octeon.c"
 #define PLATFORM_DRIVER		ohci_octeon_driver
diff --git a/drivers/usb/host/ohci-sunxi.c b/drivers/usb/host/ohci-sunxi.c
new file mode 100644
index 0000000..7f5d3cb
--- /dev/null
+++ b/drivers/usb/host/ohci-sunxi.c
@@ -0,0 +1,442 @@
+/*
+ * drivers/usb/host/ohci-sunxi.c: SoftWinner OHCI Driver
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * Author: javen
+ * History (author, date, version, notes):
+ *	yangnaitian	2011-5-24	1.0	create this file
+ *	javen		2011-6-26	1.1	add suspend and resume
+ *	javen		2011-7-18	1.2	
+ *						(Clock switch and power switch
+ *						is moved out from the driver)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/signal.h>
+
+#include <linux/time.h>
+#include <linux/timer.h>
+
+#include <plat/sys_config.h>
+#include <linux/clk.h>
+
+#include  <mach/clock.h>
+#include "sw_hci_sunxi.h"
+
+#define SW_OHCI_NAME "sw-ohci"
+
+static struct sw_hci_hcd *g_sw_ohci[3];
+static u32 ohci_first_probe[3] = { 1, 1, 1 };
+
+static void sw_start_ohc(struct sw_hci_hcd *sw_ohci)
+{
+	sw_ohci->open_clock(sw_ohci, 1);
+	sw_ohci->port_configure(sw_ohci, 1);
+	sw_ohci->usb_passby(sw_ohci, 1);
+	sw_ohci->set_power(sw_ohci, 1);
+
+	return;
+}
+
+static void sw_stop_ohc(struct sw_hci_hcd *sw_ohci)
+{
+	sw_ohci->set_power(sw_ohci, 0);
+	sw_ohci->usb_passby(sw_ohci, 0);
+	sw_ohci->port_configure(sw_ohci, 0);
+	sw_ohci->close_clock(sw_ohci, 1);
+
+	return;
+}
+
+static int __devinit sw_ohci_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run(ohci)) < 0) {
+		pr_err("%s: cannot start %s, rc=%d", __func__,
+			hcd->self.bus_name, ret);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct hc_driver sw_ohci_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "SW USB2.0 'Open' Host Controller (OHCI) Driver",
+	.hcd_priv_size = sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ohci_irq,
+	.flags = HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start = sw_ohci_start,
+	.stop = ohci_stop,
+	.shutdown = ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ohci_urb_enqueue,
+	.urb_dequeue = ohci_urb_dequeue,
+	.endpoint_disable = ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ohci_get_frame,
+
+	/*
+	 * dma fixes
+	 */
+	.map_urb_for_dma = sunxi_hcd_map_urb_for_dma,
+	.unmap_urb_for_dma = sunxi_hcd_unmap_urb_for_dma,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ohci_hub_status_data,
+	.hub_control = ohci_hub_control,
+
+#ifdef	CONFIG_PM
+	.bus_suspend = ohci_bus_suspend,
+	.bus_resume = ohci_bus_resume,
+#endif
+	.start_port_reset = ohci_start_port_reset,
+};
+
+static int sw_ohci_hcd_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	struct sw_hci_hcd *sw_ohci = NULL;
+
+	if (pdev == NULL)
+		return -EINVAL;
+
+	hcd = platform_get_drvdata(pdev);
+	if (hcd == NULL)
+		return -ENODATA;
+
+	sw_ohci = pdev->dev.platform_data;
+	if (sw_ohci == NULL)
+		return -ENODATA;
+
+	pr_debug("[%s%d]: remove, pdev->name: %s, pdev->id: %d, sw_ohci:"
+		" 0x%p\n", SW_OHCI_NAME, sw_ohci->usbc_no, pdev->name, pdev->id,
+		sw_ohci);
+
+	usb_remove_hcd(hcd);
+
+	sw_stop_ohc(sw_ohci);
+	sw_ohci->probe = 0;
+
+	iounmap(hcd->regs);
+
+	usb_put_hcd(hcd);
+
+	sw_ohci->hcd = NULL;
+
+	if (sw_ohci->host_init_state)
+		g_sw_ohci[sw_ohci->usbc_no] = NULL;
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+int sw_usb_disable_ohci(__u32 usbc_no)
+{
+	struct sw_hci_hcd *sw_ohci = NULL;
+
+	if (usbc_no != 1 && usbc_no != 2)
+		return -EINVAL;
+
+	sw_ohci = g_sw_ohci[usbc_no];
+	if (sw_ohci == NULL)
+		return -EFAULT;
+
+	if (sw_ohci->host_init_state)
+		return -ENOSYS;
+
+	if (sw_ohci->probe == 0)
+		return -ENOSYS;
+
+	sw_ohci->probe = 0;
+	pr_info("[%s]: disable ohci\n", sw_ohci->hci_name);
+	sw_ohci_hcd_remove(sw_ohci->pdev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_disable_ohci);
+
+static int sw_ohci_hcd_probe(struct platform_device *pdev)
+{
+	int ret;
+	int irq;
+	struct resource *res;
+	struct usb_hcd *hcd = NULL;
+	struct sw_hci_hcd *sw_ohci = NULL;
+
+	if (pdev == NULL)
+		return -EINVAL;
+
+	sw_ohci = pdev->dev.platform_data;
+	if (!sw_ohci)
+		return -ENODATA;
+
+	sw_ohci->pdev = pdev;
+	g_sw_ohci[sw_ohci->usbc_no] = sw_ohci;
+
+	pr_debug("[%s%d]: probe, pdev->name: %s, pdev->id: %d, sw_ohci: 0x%p\n",
+		SW_OHCI_NAME, sw_ohci->usbc_no, pdev->name, pdev->id, sw_ohci);
+
+	/* get io resource */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		pr_err("%s: failed to get io memory\n", __func__);
+		ret = -ENOMEM;
+		goto err_get_iomem;
+	}
+
+	/*creat a usb_hcd for the ohci controller */
+	hcd = usb_create_hcd(&sw_ohci_hc_driver, &pdev->dev, SW_OHCI_NAME);
+	if (!hcd) {
+		pr_err("%s: failed to create hcd\n", __func__);
+		ret = -ENOMEM;
+		goto err_create_hcd;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+	hcd->regs = ioremap(res->start, resource_size(res));
+	if (!hcd->regs) {
+		pr_err("%s: failed to ioremap\n", __func__);
+		ret = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	sw_ohci->hcd = hcd;
+
+	/* ochi start to work */
+	sw_start_ohc(sw_ohci);
+
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	irq = platform_get_irq(pdev, 0);
+	if (!irq) {
+		pr_err("%s: failed to get irq\n", __func__);
+		ret =  -ENODEV;
+		goto err_get_irq;
+	}
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (ret != 0) {
+		pr_err("%s: failed to add hcd, rc=%d\n", __func__, ret);
+		goto err_add_hcd;
+	}
+
+	platform_set_drvdata(pdev, hcd);
+
+	pr_debug("[%s]: probe, clock: SW_VA_CCM_AHBMOD_OFFSET(0x%x), SW_VA_CCM_USBCLK_OFFSET(0x%x);"
+	     " usb: SW_USB_PMU_IRQ_ENABLE(0x%x), dram:(0x%x, 0x%x)\n",
+	     sw_ohci->hci_name, (u32) readl(SW_VA_CCM_IO_BASE + SW_VA_CCM_AHBMOD_OFFSET),
+	     (u32) readl(SW_VA_CCM_IO_BASE + SW_VA_CCM_USBCLK_OFFSET),
+	     (u32) readl(sw_ohci->usb_vbase + SW_USB_PMU_IRQ_ENABLE),
+	     (u32) readl(SW_VA_DRAM_IO_BASE + SW_SDRAM_REG_HPCR_USB1),
+	     (u32) readl(SW_VA_DRAM_IO_BASE + SW_SDRAM_REG_HPCR_USB2));
+
+	sw_ohci->probe = 1;
+
+	/* Disable ohci, when driver probe */
+	if (sw_ohci->host_init_state == 0) {
+		if (ohci_first_probe[sw_ohci->usbc_no]) {
+			sw_usb_disable_ohci(sw_ohci->usbc_no);
+			ohci_first_probe[sw_ohci->usbc_no]--;
+		}
+	}
+
+	return 0;
+
+err_add_hcd:
+err_get_irq:
+	iounmap(hcd->regs);
+err_ioremap:
+	usb_put_hcd(hcd);
+err_get_iomem:
+err_create_hcd:
+	sw_ohci->hcd = NULL;
+	g_sw_ohci[sw_ohci->usbc_no] = NULL;
+	return ret;
+}
+
+int sw_usb_enable_ohci(__u32 usbc_no)
+{
+	struct sw_hci_hcd *sw_ohci = NULL;
+
+	if (usbc_no != 1 && usbc_no != 2)
+		return -EINVAL;
+
+	sw_ohci = g_sw_ohci[usbc_no];
+	if (sw_ohci == NULL)
+		return -EFAULT;
+
+	if (sw_ohci->host_init_state)
+		return -ENOSYS;
+
+	if (sw_ohci->probe == 1) /* already enabled */
+		return 0;
+
+	sw_ohci->probe = 1;
+	pr_info("[%s]: enable ohci\n", sw_ohci->hci_name);
+	sw_ohci_hcd_probe(sw_ohci->pdev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_enable_ohci);
+
+void sw_ohci_hcd_shutdown(struct platform_device *pdev)
+{
+	struct sw_hci_hcd *sw_ohci = NULL;
+
+	if (pdev == NULL)
+		return;
+
+	sw_ohci = pdev->dev.platform_data;
+	if (sw_ohci == NULL)
+		return;
+
+	if (sw_ohci->probe == 0)
+		return;
+
+	pr_info("[%s]: shutdown start\n", sw_ohci->hci_name);
+	usb_hcd_platform_shutdown(pdev);
+	sw_stop_ohc(sw_ohci);
+	pr_info("[%s]: shutdown end\n", sw_ohci->hci_name);
+
+	return;
+}
+
+#ifdef CONFIG_PM
+static int sw_ohci_hcd_suspend(struct device *dev)
+{
+	struct sw_hci_hcd *sw_ohci = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct ohci_hcd *ohci = NULL;
+	unsigned long flags = 0;
+	int rc = 0;
+
+	if (dev == NULL)
+		return 0;
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL)
+		return 0;
+
+	sw_ohci = dev->platform_data;
+	if (sw_ohci == NULL)
+		return 0;
+
+	if (sw_ohci->probe == 0)
+		return 0;
+
+	ohci = hcd_to_ohci(hcd);
+	if (ohci == NULL)
+		return 0;
+
+	pr_info("[%s]: suspend\n", sw_ohci->hci_name);
+
+	/* Root hub was already suspended. Disable irq emission and
+	 * mark HW unaccessible, bail out if RH has been resumed. Use
+	 * the spinlock to properly synchronize with possible pending
+	 * RH suspend or resume activity.
+	 *
+	 * This is still racy as hcd->state is manipulated outside of
+	 * any locks =P But that will be a different fix.
+	 */
+	spin_lock_irqsave(&ohci->lock, flags);
+	ohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
+	(void)ohci_readl(ohci, &ohci->regs->intrdisable);
+
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	spin_unlock_irqrestore(&ohci->lock, flags);
+
+	sw_stop_ohc(sw_ohci);
+
+	return rc;
+}
+
+static int sw_ohci_hcd_resume(struct device *dev)
+{
+	struct sw_hci_hcd *sw_ohci = NULL;
+	struct usb_hcd *hcd = NULL;
+
+	if (dev == NULL)
+		return 0;
+
+	hcd = dev_get_drvdata(dev);
+	if (hcd == NULL)
+		return 0;
+
+	sw_ohci = dev->platform_data;
+	if (sw_ohci == NULL)
+		return 0;
+
+	if (sw_ohci->probe == 0)
+		return 0;
+
+	pr_info("[%s]: resume\n", sw_ohci->hci_name);
+	sw_start_ohc(sw_ohci);
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	ohci_finish_controller_resume(hcd);
+
+	return 0;
+}
+
+static const struct dev_pm_ops sw_ohci_pmops = {
+	.suspend = sw_ohci_hcd_suspend,
+	.resume = sw_ohci_hcd_resume,
+};
+#define SW_OHCI_PMOPS  (&sw_ohci_pmops)
+#else
+#define SW_OHCI_PMOPS NULL
+#endif
+
+static struct platform_driver sw_ohci_hcd_driver = {
+	.probe = sw_ohci_hcd_probe,
+	.remove = sw_ohci_hcd_remove,
+	.shutdown = sw_ohci_hcd_shutdown,
+	.driver = {
+		.name = SW_OHCI_NAME,
+		.owner = THIS_MODULE,
+		.pm = SW_OHCI_PMOPS,
+	},
+};
diff --git a/drivers/usb/host/sw_hci_sunxi.c b/drivers/usb/host/sw_hci_sunxi.c
new file mode 100644
index 0000000..f40c5ba
--- /dev/null
+++ b/drivers/usb/host/sw_hci_sunxi.c
@@ -0,0 +1,814 @@
+/*
+ * drivers/usb/host/sw_hci_sunxi.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * Author: javen
+ * History:
+ *    <author>          <time>          <version>               <desc>
+ *    yangnaitian      2011-5-24            1.0          create this file
+ *    javen            2011-7-18            1.1          
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+#include <mach/clock.h>
+#include <plat/system.h>
+#include <plat/sys_config.h>
+
+#include "sw_hci_sunxi.h"
+
+#define SUNXI_USB_DMA_ALIGN ARCH_DMA_MINALIGN
+
+static char *usbc_name[3] = { "usbc0", "usbc1", "usbc2" };
+static char *usbc_ahb_ehci_name[3] = { "", "ahb_ehci0", "ahb_ehci1" };
+static char *usbc_ahb_ohci_name[3] = { "", "ahb_ohci0", "ahb_ohci1" };
+static char *usbc_phy_gate_name[3] = { "usb_phy", "usb_phy", "usb_phy" };
+static char *ohci_phy_gate_name[3] = { "", "usb_ohci0", "usb_ohci1" };
+static char *usbc_phy_reset_name[3] = { "usb_phy0", "usb_phy1", "usb_phy2" };
+
+static u32 usbc_base[3] = {
+	SW_VA_USB0_IO_BASE, SW_VA_USB1_IO_BASE, SW_VA_USB2_IO_BASE
+};
+
+static u32 usb1_set_vbus_cnt;
+static u32 usb2_set_vbus_cnt;
+
+static void dbg_clocks(struct sw_hci_hcd *sw_hci)
+{
+	DMSG_DEBUG("[%s]: clock info, SW_VA_CCM_AHBMOD_OFFSET(0x%x), SW_VA_CCM_USBCLK_OFFSET(0x%x)\n",
+		   sw_hci->hci_name,
+		   (u32) readl(SW_VA_CCM_IO_BASE + SW_VA_CCM_AHBMOD_OFFSET),
+		   (u32) readl(SW_VA_CCM_IO_BASE + SW_VA_CCM_USBCLK_OFFSET));
+}
+
+static s32 get_usb_cfg(struct sw_hci_hcd *sw_hci)
+{
+	__s32 ret = 0;
+
+	/* usbc enable */
+	ret = script_parser_fetch(usbc_name[sw_hci->usbc_no], "usb_used",
+				  (int *)&sw_hci->used, 64);
+	if (ret != 0) {
+		DMSG_PANIC("ERR: get usbc2 enable failed\n");
+		/*return -1;*/
+	}
+
+	/* request gpio */
+	ret = script_parser_fetch(usbc_name[sw_hci->usbc_no],
+				  "usb_drv_vbus_gpio",
+				  (int *)&sw_hci->drv_vbus_gpio_set, 64);
+	if (ret != 0) {
+		DMSG_PANIC("ERR: get usbc%d(%s) id failed\n", sw_hci->usbc_no,
+			   usbc_name[sw_hci->usbc_no]);
+		return -1;
+	}
+
+	/* host_init_state */
+	ret = script_parser_fetch(usbc_name[sw_hci->usbc_no],
+				  "usb_host_init_state",
+				  (int *)&(sw_hci->host_init_state), 64);
+	if (ret != 0) {
+		DMSG_PANIC("ERR: script_parser_fetch host_init_state failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static s32 clock_init(struct sw_hci_hcd *sw_hci, u32 ohci)
+{
+	if (ohci) {		/* ohci */
+		sw_hci->sie_clk =
+		    clk_get(NULL, usbc_ahb_ohci_name[sw_hci->usbc_no]);
+		if (IS_ERR(sw_hci->sie_clk)) {
+			DMSG_PANIC("ERR: get ohci%d abh clk failed.\n",
+				   (sw_hci->usbc_no));
+			goto failed;
+		}
+
+		sw_hci->ohci_gate =
+		    clk_get(NULL, ohci_phy_gate_name[sw_hci->usbc_no]);
+		if (IS_ERR(sw_hci->ohci_gate)) {
+			DMSG_PANIC("ERR: get ohci%d gate clk failed.\n",
+				   (sw_hci->usbc_no));
+			goto failed;
+		}
+	} else {		/* ehci */
+		sw_hci->sie_clk =
+		    clk_get(NULL, usbc_ahb_ehci_name[sw_hci->usbc_no]);
+		if (IS_ERR(sw_hci->sie_clk)) {
+			DMSG_PANIC("ERR: get ehci%d abh clk failed.\n",
+				   (sw_hci->usbc_no));
+			goto failed;
+		}
+	}
+
+	sw_hci->phy_gate = clk_get(NULL, usbc_phy_gate_name[sw_hci->usbc_no]);
+	if (IS_ERR(sw_hci->phy_gate)) {
+		DMSG_PANIC("ERR: get usb%d phy_gate failed.\n",
+			   sw_hci->usbc_no);
+		goto failed;
+	}
+
+	sw_hci->phy_reset = clk_get(NULL, usbc_phy_reset_name[sw_hci->usbc_no]);
+	if (IS_ERR(sw_hci->phy_reset)) {
+		DMSG_PANIC("ERR: get usb%d phy_reset failed.\n",
+			   sw_hci->usbc_no);
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+	if (sw_hci->sie_clk) {
+		clk_put(sw_hci->sie_clk);
+		sw_hci->sie_clk = NULL;
+	}
+
+	if (sw_hci->phy_gate) {
+		clk_put(sw_hci->phy_gate);
+		sw_hci->phy_gate = NULL;
+	}
+
+	if (sw_hci->phy_reset) {
+		clk_put(sw_hci->phy_reset);
+		sw_hci->phy_reset = NULL;
+	}
+
+	if (sw_hci->ohci_gate) {
+		clk_put(sw_hci->ohci_gate);
+		sw_hci->ohci_gate = NULL;
+	}
+
+	return -1;
+}
+
+static s32 clock_exit(struct sw_hci_hcd *sw_hci, u32 ohci)
+{
+	if (sw_hci->ohci_gate) {
+		clk_put(sw_hci->ohci_gate);
+		sw_hci->ohci_gate = NULL;
+	}
+
+	if (sw_hci->sie_clk) {
+		clk_put(sw_hci->sie_clk);
+		sw_hci->sie_clk = NULL;
+	}
+
+	if (sw_hci->phy_gate) {
+		clk_put(sw_hci->phy_gate);
+		sw_hci->phy_gate = NULL;
+	}
+
+	if (sw_hci->phy_reset) {
+		clk_put(sw_hci->phy_reset);
+		sw_hci->phy_reset = NULL;
+	}
+
+	return 0;
+}
+
+static int open_clock(struct sw_hci_hcd *sw_hci, u32 ohci)
+{
+	DMSG_INFO("[%s]: open clock\n", sw_hci->hci_name);
+
+	if (sw_hci->sie_clk && sw_hci->phy_gate
+	    && sw_hci->phy_reset && !sw_hci->clk_is_open) {
+		sw_hci->clk_is_open = 1;
+
+		clk_enable(sw_hci->phy_gate);
+		clk_enable(sw_hci->phy_reset);
+		clk_reset(sw_hci->phy_reset, 0);
+
+		if (ohci && sw_hci->ohci_gate)
+			clk_enable(sw_hci->ohci_gate);
+
+		mdelay(10);
+
+		clk_enable(sw_hci->sie_clk);
+	} else {
+		DMSG_PANIC
+		    ("[%s]: wrn: open clock failed, (0x%p, 0x%p, 0x%p, %d, 0x%p)\n",
+		     sw_hci->hci_name, sw_hci->sie_clk, sw_hci->phy_gate,
+		     sw_hci->phy_reset, sw_hci->clk_is_open, sw_hci->ohci_gate);
+	}
+
+	dbg_clocks(sw_hci);
+
+	return 0;
+}
+
+static int close_clock(struct sw_hci_hcd *sw_hci, u32 ohci)
+{
+	DMSG_INFO("[%s]: close clock\n", sw_hci->hci_name);
+
+	if (sw_hci->sie_clk && sw_hci->phy_gate
+	    && sw_hci->phy_reset && sw_hci->clk_is_open) {
+
+		sw_hci->clk_is_open = 0;
+
+		if (ohci && sw_hci->ohci_gate)
+			clk_disable(sw_hci->ohci_gate);
+
+		clk_reset(sw_hci->phy_reset, 1);
+		clk_disable(sw_hci->phy_reset);
+		clk_disable(sw_hci->phy_gate);
+
+		clk_disable(sw_hci->sie_clk);
+	} else {
+		DMSG_PANIC
+		    ("[%s]: wrn: open clock failed, (0x%p, 0x%p, 0x%p, %d, 0x%p)\n",
+		     sw_hci->hci_name, sw_hci->sie_clk, sw_hci->phy_gate,
+		     sw_hci->phy_reset, sw_hci->clk_is_open, sw_hci->ohci_gate);
+	}
+
+	dbg_clocks(sw_hci);
+
+	return 0;
+}
+
+static void usb_passby(struct sw_hci_hcd *sw_hci, u32 enable)
+{
+	unsigned long reg_value = 0;
+	unsigned long bits = 0;
+	static DEFINE_SPINLOCK(lock);
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&lock, flags);
+
+	bits =	BIT(10) | /* AHB Master interface INCR8 enable */
+			BIT(9)  | /* AHB Master interface burst type INCR4 enable */
+			BIT(8)  | /* AHB Master interface INCRX align enable */
+			BIT(0);   /* ULPI bypass enable */
+
+	reg_value = readl(sw_hci->usb_vbase + SW_USB_PMU_IRQ_ENABLE);
+
+	if (enable)
+		reg_value |= bits;
+	else
+		reg_value &= ~bits;
+
+	writel(reg_value, sw_hci->usb_vbase + SW_USB_PMU_IRQ_ENABLE);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	return;
+}
+
+static void hci_port_configure(struct sw_hci_hcd *sw_hci, u32 enable)
+{
+	unsigned long reg_value = 0;
+	u32 usbc_sdram_hpcr = 0;
+	void __iomem *addr = NULL;
+
+	if (sw_hci->usbc_no == 1) {
+		usbc_sdram_hpcr = SW_SDRAM_REG_HPCR_USB1;
+	} else if (sw_hci->usbc_no == 2) {
+		usbc_sdram_hpcr = SW_SDRAM_REG_HPCR_USB2;
+	} else {
+		DMSG_PANIC("EER: unkown usbc_no(%d)\n", sw_hci->usbc_no);
+		return;
+	}
+
+	addr = (void __iomem*) SW_VA_DRAM_IO_BASE + usbc_sdram_hpcr;
+
+	reg_value = readl(addr);
+	if (enable)
+		reg_value |= BIT(SW_SDRAM_BP_HPCR_ACCESS_EN);
+	else
+		reg_value &= ~BIT(SW_SDRAM_BP_HPCR_ACCESS_EN);
+
+	writel(reg_value, addr);
+
+	return;
+}
+
+static u32 alloc_pin(user_gpio_set_t *gpio_list)
+{
+	u32 pin_handle = 0;
+
+	pin_handle = sunxi_gpio_request_array(gpio_list, 1);
+	if (pin_handle == 0) {
+		DMSG_PANIC("ERR: gpio_request failed\n");
+		return 0;
+	}
+
+	/* set config, ouput */
+	gpio_set_one_pin_io_status(pin_handle, 1, NULL);
+
+	/* reserved is pull down */
+	gpio_set_one_pin_pull(pin_handle, 2, NULL);
+
+	return pin_handle;
+}
+
+static void free_pin(u32 pin_handle)
+{
+	if (pin_handle)
+		gpio_release(pin_handle, 0);
+
+	return;
+}
+
+static void __sw_set_vbus(struct sw_hci_hcd *sw_hci, int is_on)
+{
+	u32 on_off = 0;
+
+	DMSG_INFO("[%s]: Set USB Power %s\n", sw_hci->hci_name,
+		  (is_on ? "ON" : "OFF"));
+
+	/* set power flag */
+	sw_hci->power_flag = is_on;
+
+	/* set power */
+	if (sw_hci->drv_vbus_gpio_set.data == 0)
+		on_off = is_on ? 1 : 0;
+	else
+		on_off = is_on ? 0 : 1;
+
+	gpio_write_one_pin_value(sw_hci->drv_vbus_Handle, on_off, NULL);
+
+	return;
+}
+
+static void sw_set_vbus(struct sw_hci_hcd *sw_hci, int is_on)
+{
+	DMSG_DEBUG("[%s]: sw_set_vbus cnt %d\n",
+		   sw_hci->hci_name,
+		   (sw_hci->usbc_no ==
+		    1) ? usb1_set_vbus_cnt : usb2_set_vbus_cnt);
+
+	if (sw_hci->usbc_no == 1) {
+		if (is_on && usb1_set_vbus_cnt == 0)
+			__sw_set_vbus(sw_hci, is_on);	/* power on */
+		else if (!is_on && usb1_set_vbus_cnt == 1)
+			__sw_set_vbus(sw_hci, is_on);	/* power off */
+
+		if (is_on)
+			usb1_set_vbus_cnt++;
+		else
+			usb1_set_vbus_cnt--;
+	} else {
+		if (is_on && usb2_set_vbus_cnt == 0)
+			__sw_set_vbus(sw_hci, is_on);	/* power on */
+		else if (!is_on && usb2_set_vbus_cnt == 1)
+			__sw_set_vbus(sw_hci, is_on);	/* power off */
+
+		if (is_on)
+			usb2_set_vbus_cnt++;
+		else
+			usb2_set_vbus_cnt--;
+	}
+
+	return;
+}
+
+struct temp_buffer {
+	void *kmalloc_ptr;
+	void *old_buffer;
+	u8 data[];
+};
+
+static void *alloc_temp_buffer(size_t size, gfp_t mem_flags)
+{
+	struct temp_buffer *temp, *kmalloc_ptr;
+	size_t kmalloc_size;
+
+	kmalloc_size = size + sizeof(struct temp_buffer) +
+			SUNXI_USB_DMA_ALIGN - 1;
+
+	kmalloc_ptr = kmalloc(kmalloc_size, mem_flags);
+	if (!kmalloc_ptr)
+		return NULL;
+
+	/* Position our struct temp_buffer such that data is aligned.
+	 *
+	 * Note: kmalloc_ptr is type 'struct temp_buffer *' and PTR_ALIGN
+	 * returns pointer with the same type 'struct temp_buffer *'.
+	 */
+	temp = PTR_ALIGN(kmalloc_ptr + 1, SUNXI_USB_DMA_ALIGN) - 1;
+
+	temp->kmalloc_ptr = kmalloc_ptr;
+	return temp;
+}
+
+static void sunxi_hcd_free_temp_buffer(struct urb *urb)
+{
+	enum dma_data_direction dir;
+	struct temp_buffer *temp;
+
+	if (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))
+		return;
+
+	dir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+
+	temp = container_of(urb->transfer_buffer, struct temp_buffer, data);
+
+	if (dir == DMA_FROM_DEVICE)
+		memcpy(temp->old_buffer, temp->data,
+		       urb->transfer_buffer_length);
+
+	urb->transfer_buffer = temp->old_buffer;
+	kfree(temp->kmalloc_ptr);
+
+	urb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;
+}
+
+static int sunxi_hcd_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)
+{
+	enum dma_data_direction dir;
+	struct temp_buffer *temp;
+
+	if (urb->num_sgs)
+		return 0;
+	if (urb->sg)
+		return 0;
+	if (urb->transfer_buffer_length == 0)
+		return 0;
+	if (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)
+		return 0;
+
+	/* sunxi hardware requires transfer buffers to be DMA aligned */
+	if (!((uintptr_t)urb->transfer_buffer & (SUNXI_USB_DMA_ALIGN - 1)))
+		return 0;
+
+	/* Allocate a buffer with enough padding for alignment */
+	temp = alloc_temp_buffer(urb->transfer_buffer_length, mem_flags);
+	if (!temp)
+		return -ENOMEM;
+
+	dir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
+
+	temp->old_buffer = urb->transfer_buffer;
+	if (dir == DMA_TO_DEVICE)
+		memcpy(temp->data, urb->transfer_buffer,
+		       urb->transfer_buffer_length);
+	urb->transfer_buffer = temp->data;
+
+	urb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;
+
+	return 0;
+}
+
+static void sunxi_hcd_free_temp_setup(struct urb *urb)
+{
+	struct temp_buffer *temp;
+
+	if (!(urb->transfer_flags & URB_ALIGNED_TEMP_SETUP))
+		return;
+
+	temp = container_of((void *)urb->setup_packet, struct temp_buffer,
+			    data);
+
+	urb->setup_packet = temp->old_buffer;
+	kfree(temp->kmalloc_ptr);
+
+	urb->transfer_flags &= ~URB_ALIGNED_TEMP_SETUP;
+}
+
+static int sunxi_hcd_alloc_temp_setup(struct urb *urb, gfp_t mem_flags)
+{
+	struct temp_buffer *temp;
+
+	if (!usb_endpoint_xfer_control(&urb->ep->desc))
+		return 0;
+
+	/* sunxi hardware requires setup packet to be DMA aligned */
+	if (!((uintptr_t)urb->setup_packet & (SUNXI_USB_DMA_ALIGN - 1)))
+		return 0;
+
+	/* Allocate a buffer with enough padding for alignment */
+	temp = alloc_temp_buffer(sizeof(struct usb_ctrlrequest), mem_flags);
+	if (!temp)
+		return -ENOMEM;
+
+	temp->old_buffer = urb->setup_packet;
+	memcpy(temp->data, urb->setup_packet, sizeof(struct usb_ctrlrequest));
+	urb->setup_packet = temp->data;
+
+	urb->transfer_flags |= URB_ALIGNED_TEMP_SETUP;
+
+	return 0;
+}
+
+int sunxi_hcd_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
+				     gfp_t mem_flags)
+{
+	int ret;
+
+	ret = sunxi_hcd_alloc_temp_buffer(urb, mem_flags);
+	if (ret)
+		return ret;
+
+	ret = sunxi_hcd_alloc_temp_setup(urb, mem_flags);
+	if (ret) {
+		sunxi_hcd_free_temp_buffer(urb);
+		return ret;
+	}
+
+	ret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);
+	if (ret) {
+		sunxi_hcd_free_temp_setup(urb);
+		sunxi_hcd_free_temp_buffer(urb);
+		return ret;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sunxi_hcd_map_urb_for_dma);
+
+void sunxi_hcd_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)
+{
+	usb_hcd_unmap_urb_for_dma(hcd, urb);
+	sunxi_hcd_free_temp_setup(urb);
+	sunxi_hcd_free_temp_buffer(urb);
+}
+EXPORT_SYMBOL_GPL(sunxi_hcd_unmap_urb_for_dma);
+
+/*
+ *---------------------------------------------------------------
+ * EHCI
+ *---------------------------------------------------------------
+ */
+
+#define  SW_EHCI_NAME		"sw-ehci"
+static const char ehci_name[] = SW_EHCI_NAME;
+
+static struct sw_hci_hcd sw_ehci1;
+static struct sw_hci_hcd sw_ehci2;
+
+static u64 sw_ehci_dmamask = DMA_BIT_MASK(32);
+
+static struct resource sw_ehci1_resources[] = {
+		DEFINE_RES_MEM(SW_PA_USB1_IO_BASE + SW_USB_EHCI_BASE_OFFSET, SW_USB_EHCI_LEN),
+		DEFINE_RES_IRQ(SW_INT_IRQNO_USB1)
+};
+
+static struct resource sw_ehci2_resources[] = {
+		DEFINE_RES_MEM(SW_PA_USB2_IO_BASE + SW_USB_EHCI_BASE_OFFSET, SW_USB_EHCI_LEN),
+		DEFINE_RES_IRQ(SW_INT_IRQNO_USB2)
+};
+
+static struct platform_device sw_usb_ehci_device[] = {
+	[0] = {
+	       .name = ehci_name,
+	       .id = 1,
+	       .dev = {
+		       .dma_mask = &sw_ehci_dmamask,
+		       .coherent_dma_mask = DMA_BIT_MASK(32),
+		       .platform_data = &sw_ehci1,
+		       },
+	       .resource = sw_ehci1_resources,
+	       .num_resources = ARRAY_SIZE(sw_ehci1_resources),
+	       },
+
+	[1] = {
+	       .name = ehci_name,
+	       .id = 2,
+	       .dev = {
+		       .dma_mask = &sw_ehci_dmamask,
+		       .coherent_dma_mask = DMA_BIT_MASK(32),
+		       .platform_data = &sw_ehci2,
+		       },
+	       .resource = sw_ehci2_resources,
+	       .num_resources = ARRAY_SIZE(sw_ehci2_resources),
+	       },
+};
+
+/*
+ *---------------------------------------------------------------
+ * OHCI
+ *---------------------------------------------------------------
+ */
+
+#define  SW_OHCI_NAME		"sw-ohci"
+static const char ohci_name[] = SW_OHCI_NAME;
+
+static struct sw_hci_hcd sw_ohci1;
+static struct sw_hci_hcd sw_ohci2;
+
+static u64 sw_ohci_dmamask = DMA_BIT_MASK(32);
+
+static struct resource sw_ohci1_resources[] = {
+		DEFINE_RES_MEM(SW_PA_USB1_IO_BASE + SW_USB_OHCI_BASE_OFFSET, SW_USB_OHCI_LEN),
+		DEFINE_RES_IRQ(SW_INT_IRQNO_USB3)
+};
+
+static struct resource sw_ohci2_resources[] = {
+		DEFINE_RES_MEM(SW_PA_USB2_IO_BASE + SW_USB_OHCI_BASE_OFFSET, SW_USB_OHCI_LEN),
+		DEFINE_RES_IRQ(SW_INT_IRQNO_USB4)
+};
+
+static struct platform_device sw_usb_ohci_device[] = {
+	[0] = {
+	       .name = ohci_name,
+	       .id = 1,
+	       .dev = {
+		       .dma_mask = &sw_ohci_dmamask,
+		       .coherent_dma_mask = DMA_BIT_MASK(32),
+		       .platform_data = &sw_ohci1,
+		       },
+	       .resource = sw_ohci1_resources,
+	       .num_resources = ARRAY_SIZE(sw_ohci1_resources),
+	       },
+	[1] = {
+	       .name = ohci_name,
+	       .id = 2,
+	       .dev = {
+		       .dma_mask = &sw_ohci_dmamask,
+		       .coherent_dma_mask = DMA_BIT_MASK(32),
+		       .platform_data = &sw_ohci2,
+		       },
+	       .resource = sw_ohci2_resources,
+	       .num_resources = ARRAY_SIZE(sw_ohci2_resources),
+	       },
+};
+
+static void print_sw_hci(struct sw_hci_hcd *sw_hci)
+{
+	DMSG_DEBUG("\n------%s config------\n", sw_hci->hci_name);
+	DMSG_DEBUG("hci_name             = %s\n", sw_hci->hci_name);
+	DMSG_DEBUG("usbc_no              = %d\n", sw_hci->usbc_no);
+
+	DMSG_DEBUG("usb_vbase            = 0x%p\n", sw_hci->usb_vbase);
+
+	DMSG_DEBUG("used                 = %d\n", sw_hci->used);
+	DMSG_DEBUG("host_init_state      = %d\n", sw_hci->host_init_state);
+
+	DMSG_DEBUG("gpio_name            = %s\n",
+		   sw_hci->drv_vbus_gpio_set.gpio_name);
+	DMSG_DEBUG("port                 = %d\n",
+		   sw_hci->drv_vbus_gpio_set.port);
+	DMSG_DEBUG("port_num             = %d\n",
+		   sw_hci->drv_vbus_gpio_set.port_num);
+	DMSG_DEBUG("mul_sel              = %d\n",
+		   sw_hci->drv_vbus_gpio_set.mul_sel);
+	DMSG_DEBUG("pull                 = %d\n",
+		   sw_hci->drv_vbus_gpio_set.pull);
+	DMSG_DEBUG("drv_level            = %d\n",
+		   sw_hci->drv_vbus_gpio_set.drv_level);
+	DMSG_DEBUG("data                 = %d\n",
+		   sw_hci->drv_vbus_gpio_set.data);
+
+	dbg_clocks(sw_hci);
+
+	DMSG_DEBUG("\n--------------------------\n");
+
+	return;
+}
+
+static int init_sw_hci(struct sw_hci_hcd *sw_hci, u32 usbc_no, u32 ohci,
+		       const char *hci_name)
+{
+	s32 ret = 0;
+	u32 drv_vbus_Handle = 0;
+
+	memset(sw_hci, 0, sizeof(struct sw_hci_hcd));
+
+	sw_hci->usbc_no = usbc_no;
+
+	sprintf(sw_hci->hci_name, "%s%d", hci_name, sw_hci->usbc_no);
+
+	sw_hci->usb_vbase = (void __iomem *)usbc_base[sw_hci->usbc_no];
+
+	get_usb_cfg(sw_hci);
+
+	drv_vbus_Handle = alloc_pin(&sw_hci->drv_vbus_gpio_set);
+	if (drv_vbus_Handle == 0) {
+		DMSG_PANIC("ERR: alloc_pin failed\n");
+		goto failed1;
+	}
+	sw_hci->drv_vbus_Handle = drv_vbus_Handle;
+
+	sw_hci->open_clock = open_clock;
+	sw_hci->close_clock = close_clock;
+	sw_hci->set_power = sw_set_vbus;
+	sw_hci->usb_passby = usb_passby;
+	sw_hci->port_configure = hci_port_configure;
+
+	ret = clock_init(sw_hci, ohci);
+	if (ret != 0) {
+		DMSG_PANIC("ERR: clock_init failed\n");
+		goto failed1;
+	}
+
+	print_sw_hci(sw_hci);
+
+	return 0;
+
+failed1:
+	return -1;
+}
+
+static int __init sw_hci_sunxi_init(void)
+{
+/* XXX Should be rewtitten with checks if CONFIG_USB_EHCI_HCD or CONFIG_USB_OHCI_HCD
+       are actually defined. Original code assumes that EHCI is always on.
+*/
+	if (sunxi_is_sun5i()) {
+		/*
+		 * The sun5i has only one usb controller and thus uses
+		 * IRQNO_USB2 for its ohci controller.
+		 */
+		sw_ohci1_resources[1].start = SW_INT_IRQNO_USB2;
+		sw_ohci1_resources[1].end   = SW_INT_IRQNO_USB2;
+	}
+
+	init_sw_hci(&sw_ehci1, 1, 0, ehci_name);
+	init_sw_hci(&sw_ohci1, 1, 1, ohci_name);
+
+	if (sunxi_is_sun4i() || sunxi_is_sun7i()) {
+		/* A13 has only one *HCI USB controller */
+		init_sw_hci(&sw_ehci2, 2, 0, ehci_name);
+		init_sw_hci(&sw_ohci2, 2, 1, ohci_name);
+	} else {
+		sw_ehci2.used = 0;
+	}
+
+/* XXX '.used' flag is for USB port, not for EHCI or OHCI. So it can be checked this way */
+	if (sw_ehci1.used) {
+		platform_device_register(&sw_usb_ehci_device[0]);
+		platform_device_register(&sw_usb_ohci_device[0]);
+	} else {
+/*      DMSG_PANIC("ERR: usb%d %s is disabled in script.bin\n", sw_ehci1.usbc_no, sw_ehci1.hci_name); */
+	}
+
+	if (sw_ehci2.used) {
+		platform_device_register(&sw_usb_ehci_device[1]);
+		platform_device_register(&sw_usb_ohci_device[1]);
+	} else {
+/*      DMSG_PANIC("ERR: usb%d %s is disabled in script.bin\n", sw_ehci2.usbc_no, sw_ehci2.hci_name); */
+	}
+
+	return 0;
+}
+
+static void __exit sw_hci_sunxi_exit(void)
+{
+/* XXX '.used' flag is for USB port, not for EHCI or OHCI. So it can be checked this way */
+	if (sw_ehci1.used) {
+		platform_device_unregister(&sw_usb_ehci_device[0]);
+		platform_device_unregister(&sw_usb_ohci_device[0]);
+
+		clock_exit(&sw_ehci1, 0);
+		clock_exit(&sw_ohci1, 1);
+
+		free_pin(sw_ehci1.drv_vbus_Handle);
+	}
+
+	if (sw_ehci2.used) {
+		platform_device_unregister(&sw_usb_ehci_device[1]);
+		platform_device_unregister(&sw_usb_ohci_device[1]);
+
+		clock_exit(&sw_ehci2, 0);
+		clock_exit(&sw_ohci2, 1);
+
+		free_pin(sw_ehci2.drv_vbus_Handle);
+	}
+
+	return;
+}
+
+module_init(sw_hci_sunxi_init);
+module_exit(sw_hci_sunxi_exit);
diff --git a/drivers/usb/host/sw_hci_sunxi.h b/drivers/usb/host/sw_hci_sunxi.h
new file mode 100644
index 0000000..d91e786
--- /dev/null
+++ b/drivers/usb/host/sw_hci_sunxi.h
@@ -0,0 +1,125 @@
+/*
+ * drivers/usb/host/sw_hci_sunxi.h: header file for SUNXI HCI HCD
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * Author: yangnaitian
+ * History (author, date, version, notes):
+ *	yangnaitian	2011-5-24	1.0	create this file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_HCI_SUNXI_H__
+#define __SW_HCI_SUNXI_H__
+
+#include <mach/irqs.h>
+
+#define  DMSG_PRINT(stuff...)	printk(stuff)
+#define  DMSG_ERR(...) \
+	(DMSG_PRINT("WRN:L%d(%s):", __LINE__, __FILE__), \
+	DMSG_PRINT(__VA_ARGS__))
+
+#if 0
+#define DMSG_DEBUG	DMSG_PRINT
+#else
+#define DMSG_DEBUG(...)
+#endif
+
+#if 1
+#define DMSG_INFO	DMSG_PRINT
+#else
+#define DMSG_INFO(...)
+#endif
+
+#if	1
+#define DMSG_PANIC	DMSG_ERR
+#else
+#define DMSG_PANIC(...)
+#endif
+
+#define SW_VA_CCM_USBCLK_OFFSET			0xcc
+#define SW_VA_CCM_AHBMOD_OFFSET			0x60
+
+#define SW_USB1_BASE		0x01c14000
+#define SW_USB2_BASE		0x01c1c000
+
+#define SW_USB_EHCI_BASE_OFFSET	0x00
+#define SW_USB_OHCI_BASE_OFFSET	0x400
+#define SW_USB_EHCI_LEN			0x100
+#define SW_USB_OHCI_LEN			0x100
+#define SW_USB_PMU_IRQ_ENABLE	0x800
+
+/* ABH Gating Reg0 */
+#define SW_CCMU_BP_AHB_GATING_USBC2		2
+#define SW_CCMU_BP_AHB_GATING_USBC1		1
+
+/* usb clock reg */
+#define SW_CCMU_BP_USB_CLK_GATING_USBPHY	8
+#define SW_CCMU_BP_USB_CLK_GATING_OHCI1		7
+#define SW_CCMU_BP_USB_CLK_GATING_OHCI0		6
+#define SW_CCMU_BP_USB_CLK_48M_SEL		4
+#define SW_CCMU_BP_USB_CLK_USBPHY2_RST		2
+#define SW_CCMU_BP_USB_CLK_USBPHY1_RST		1
+#define SW_CCMU_BP_USB_CLK_USBPHY0_RST		0
+
+#define SW_SDRAM_REG_HPCR_USB1	(0x250 + ((1 << 2) * 4))
+#define SW_SDRAM_REG_HPCR_USB2	(0x250 + ((1 << 2) * 5))
+
+/* HPCR */
+#define SW_SDRAM_BP_HPCR_READ_CNT_EN		31
+#define SW_SDRAM_BP_HPCR_RWRITE_CNT_EN		30
+#define SW_SDRAM_BP_HPCR_COMMAND_NUM		8
+#define SW_SDRAM_BP_HPCR_WAIT_STATE		4
+#define SW_SDRAM_BP_HPCR_PRIORITY_LEVEL		2
+#define SW_SDRAM_BP_HPCR_ACCESS_EN		0
+
+struct sw_hci_hcd {
+	__u32 usbc_no; /* usb controller number */
+	char hci_name[32]; /* hci name */
+
+	void __iomem *usb_vbase; /* USB base address */
+
+	struct platform_device *pdev;
+	struct usb_hcd *hcd;
+
+	struct clk *sie_clk; /* SIE clock handle */
+	struct clk *phy_gate; /* PHY clock handle */
+	struct clk *phy_reset; /* PHY reset handle */
+	struct clk *ohci_gate; /* ohci clock handle */
+	__u32 clk_is_open; /* is usb clock open */
+
+	u32 drv_vbus_Handle;
+	user_gpio_set_t drv_vbus_gpio_set;
+	__u32 power_flag; /* flag. */
+	__u32 used; /* flag. */
+	__u32 probe; /*  */
+	__u32 host_init_state; /* usb 0 : . 1 : */
+				/* 0 not initialized, 1 otherwise */
+
+	int (*open_clock) (struct sw_hci_hcd *sw_hci, u32 ohci);
+	int (*close_clock) (struct sw_hci_hcd *sw_hci, u32 ohci);
+	void (*set_power) (struct sw_hci_hcd *sw_hci, int is_on);
+	void (*port_configure) (struct sw_hci_hcd *sw_hci, u32 enable);
+	void (*usb_passby) (struct sw_hci_hcd *sw_hci, u32 enable);
+};
+
+extern int sunxi_hcd_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
+				     gfp_t mem_flags);
+extern void sunxi_hcd_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb);
+
+#endif /* __SW_HCI_SUNXI_H__ */
diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index f70cab3..c430c65 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -5,7 +5,7 @@
 
 # (M)HDRC = (Multipoint) Highspeed Dual-Role Controller
 config USB_MUSB_HDRC
-	tristate 'Inventra Highspeed Dual Role Controller (TI, ADI, ...)'
+	tristate 'Inventra Highspeed Dual Role Controller (TI, ADI, AW, ...)'
 	depends on USB && USB_GADGET
 	select NOP_USB_XCEIV if (ARCH_DAVINCI || MACH_OMAP3EVM || BLACKFIN)
 	select TWL4030_USB if MACH_OMAP_3430SDP
@@ -25,6 +25,8 @@ config USB_MUSB_HDRC
 	  Analog Devices parts using this IP include Blackfin BF54x,
 	  BF525 and BF527.
 
+	  Allwinner parts using this IP include SUN4I, SUN5I and SUN7I.
+
 	  If you do not know what this is, please say N.
 
 	  To compile this driver as a module, choose M here; the
@@ -62,6 +64,11 @@ config USB_MUSB_UX500
 	tristate "U8500 and U5500"
 	depends on (ARCH_U8500 && AB8500_USB)
 
+config USB_MUSB_SUNXI
+	tristate "Allwinner SUN4I/SUN5I/SUN7I"
+	select NOP_USB_XCEIV
+	depends on (ARCH_SUN4I || ARCH_SUN5I || ARCH_SUN7I)
+
 endchoice
 
 choice
@@ -70,7 +77,7 @@ choice
 	default USB_INVENTRA_DMA if USB_MUSB_OMAP2PLUS || USB_MUSB_BLACKFIN
 	default USB_TI_CPPI_DMA if USB_MUSB_DAVINCI
 	default USB_TUSB_OMAP_DMA if USB_MUSB_TUSB6010
-	default MUSB_PIO_ONLY if USB_MUSB_TUSB6010 || USB_MUSB_DA8XX || USB_MUSB_AM35X
+	default MUSB_PIO_ONLY if USB_MUSB_TUSB6010 || USB_MUSB_DA8XX || USB_MUSB_AM35X || USB_MUSB_SUNXI
 	help
 	  Unfortunately, only one option can be enabled here. Ideally one
 	  should be able to build all these drivers into one kernel to
diff --git a/drivers/usb/musb/Makefile b/drivers/usb/musb/Makefile
index 88bfb9d..2ff5f2f 100644
--- a/drivers/usb/musb/Makefile
+++ b/drivers/usb/musb/Makefile
@@ -18,6 +18,9 @@ obj-$(CONFIG_USB_MUSB_DAVINCI)			+= davinci.o
 obj-$(CONFIG_USB_MUSB_DA8XX)			+= da8xx.o
 obj-$(CONFIG_USB_MUSB_BLACKFIN)			+= blackfin.o
 obj-$(CONFIG_USB_MUSB_UX500)			+= ux500.o
+obj-$(CONFIG_USB_MUSB_SUNXI)			+= sunxi_musb.o
+
+sunxi_musb-y := sunxi.o sunxi_musb_plat.o
 
 # the kconfig must guarantee that only one of the
 # possible I/O schemes will be enabled at a time ...
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index a2b4008..ad77a00 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -130,7 +130,8 @@ static inline struct musb *dev_to_musb(struct device *dev)
 
 /*-------------------------------------------------------------------------*/
 
-#ifndef CONFIG_BLACKFIN
+#if !defined(CONFIG_BLACKFIN) && !(defined(CONFIG_USB_MUSB_SUNXI) || \
+				   defined(CONFIG_USB_MUSB_SUNXI_MODULE))
 static int musb_ulpi_read(struct usb_phy *phy, u32 offset)
 {
 	void __iomem *addr = phy->io_priv;
diff --git a/drivers/usb/musb/musb_regs.h b/drivers/usb/musb/musb_regs.h
index 03f2655..3e1d586 100644
--- a/drivers/usb/musb/musb_regs.h
+++ b/drivers/usb/musb/musb_regs.h
@@ -216,6 +216,8 @@
 
 #ifndef CONFIG_BLACKFIN
 
+#if !(defined(CONFIG_USB_MUSB_SUNXI) || defined(CONFIG_USB_MUSB_SUNXI_MODULE))
+
 /*
  * Common USB registers
  */
@@ -453,6 +455,281 @@ static inline u8  musb_read_txhubport(void __iomem *mbase, u8 epnum)
 	return musb_readb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_TXHUBPORT));
 }
 
+#else /* CONFIG_USB_MUSB_SUNXI || CONFIG_USB_MUSB_SUNXI_MODULE */
+
+/*
+ * register offsets from the Allwinner driver
+ */
+
+#define USBC_REG_o_FADDR	0x0098
+#define USBC_REG_o_PCTL		0x0040
+#define USBC_REG_o_INTTx	0x0044
+#define USBC_REG_o_INTRx	0x0046
+#define USBC_REG_o_INTTxE	0x0048
+#define USBC_REG_o_INTRxE	0x004A
+#define USBC_REG_o_INTUSB	0x004C
+#define USBC_REG_o_INTUSBE	0x0050
+#define USBC_REG_o_FRNUM	0x0054
+#define USBC_REG_o_EPIND	0x0042
+#define USBC_REG_o_TMCTL	0x007C
+
+#define USBC_REG_o_DEVCTL	0x0041
+#define USBC_REG_o_TXFIFOSZ	0x0090
+#define USBC_REG_o_RXFIFOSZ	0x0094
+#define USBC_REG_o_TXFIFOAD	0x0092
+#define USBC_REG_o_RXFIFOAD	0x0096
+
+#define USBC_REG_o_EPINFO	0x0078
+#define USBC_REG_o_RAMINFO	0x0079
+#define USBC_REG_o_LINKINFO	0x007A
+#define USBC_REG_o_VPLEN	0x007B
+#define USBC_REG_o_HSEOF	0x007C
+#define USBC_REG_o_FSEOF	0x007D
+#define USBC_REG_o_LSEOF	0x007E
+
+#define USBC_REG_o_TXMAXP	0x0080
+#define USBC_REG_o_CSR0		0x0082
+#define USBC_REG_o_TXCSR	0x0082
+#define USBC_REG_o_RXMAXP	0x0084
+#define USBC_REG_o_RXCSR	0x0086
+#define USBC_REG_o_COUNT0	0x0088
+#define USBC_REG_o_RXCOUNT	0x0088
+#define USBC_REG_o_EP0TYPE	0x008C
+#define USBC_REG_o_TXTYPE	0x008C
+#define USBC_REG_o_NAKLIMIT0	0x008D
+#define USBC_REG_o_TXINTERVAL	0x008D
+#define USBC_REG_o_RXTYPE	0x008E
+#define USBC_REG_o_RXINTERVAL	0x008F
+#define USBC_REG_o_CONFIGDATA	0x00c0
+
+#define USBC_REG_o_TXFADDRx	0x0098
+#define USBC_REG_o_TXHADDRx	0x009A
+#define USBC_REG_o_TXHPORTx	0x009B
+#define USBC_REG_o_RXFADDRx	0x009C
+#define USBC_REG_o_RXHADDRx	0x009E
+#define USBC_REG_o_RXHPORTx	0x009F
+
+/*
+ * Common USB registers
+ */
+
+#define MUSB_FADDR		USBC_REG_o_FADDR
+#define MUSB_POWER		USBC_REG_o_PCTL
+
+#define MUSB_INTRTX		USBC_REG_o_INTTx
+#define MUSB_INTRRX		USBC_REG_o_INTRx
+#define MUSB_INTRTXE		USBC_REG_o_INTTxE
+#define MUSB_INTRRXE		USBC_REG_o_INTRxE
+#define MUSB_INTRUSB		USBC_REG_o_INTUSB
+#define MUSB_INTRUSBE		USBC_REG_o_INTUSBE
+#define MUSB_FRAME		USBC_REG_o_FRNUM
+#define MUSB_INDEX		USBC_REG_o_EPIND
+#define MUSB_TESTMODE		USBC_REG_o_TMCTL
+
+/* Get offset for a given FIFO from musb->mregs */
+#define MUSB_FIFO_OFFSET(epnum)	(0x00 + ((epnum) * 4))
+
+/*
+ * Additional Control Registers
+ */
+
+#define MUSB_DEVCTL		USBC_REG_o_DEVCTL
+
+/* These are always controlled through the INDEX register */
+#define MUSB_TXFIFOSZ		USBC_REG_o_TXFIFOSZ
+#define MUSB_RXFIFOSZ		USBC_REG_o_RXFIFOSZ
+#define MUSB_TXFIFOADD		USBC_REG_o_TXFIFOAD
+#define MUSB_RXFIFOADD		USBC_REG_o_RXFIFOAD
+
+#define MUSB_EPINFO		USBC_REG_o_EPINFO
+#define MUSB_RAMINFO		USBC_REG_o_RAMINFO
+#define MUSB_LINKINFO		USBC_REG_o_LINKINFO
+#define MUSB_VPLEN		USBC_REG_o_VPLEN
+#define MUSB_HS_EOF1		USBC_REG_o_HSEOF
+#define MUSB_FS_EOF1		USBC_REG_o_FSEOF
+#define MUSB_LS_EOF1		USBC_REG_o_LSEOF
+
+/* Offsets to endpoint registers */
+#define MUSB_TXMAXP		USBC_REG_o_TXMAXP
+#define MUSB_TXCSR		USBC_REG_o_TXCSR
+#define MUSB_CSR0		USBC_REG_o_CSR0
+#define MUSB_RXMAXP		USBC_REG_o_RXMAXP
+#define MUSB_RXCSR		USBC_REG_o_RXCSR
+#define MUSB_RXCOUNT		USBC_REG_o_RXCOUNT
+#define MUSB_COUNT0		USBC_REG_o_COUNT0
+#define MUSB_TXTYPE		USBC_REG_o_TXTYPE
+#define MUSB_TYPE0		USBC_REG_o_EP0TYPE
+#define MUSB_TXINTERVAL		USBC_REG_o_TXINTERVAL
+#define MUSB_NAKLIMIT0		USBC_REG_o_NAKLIMIT0
+#define MUSB_RXTYPE		USBC_REG_o_RXTYPE
+#define MUSB_RXINTERVAL		USBC_REG_o_RXINTERVAL
+
+#define MUSB_CONFIGDATA		USBC_REG_o_CONFIGDATA
+#define MUSB_FIFOSIZE		USBC_REG_o_TXFIFOSZ
+
+/* Offsets to endpoint registers in indexed model (using INDEX register) */
+#define MUSB_INDEXED_OFFSET(_epnum, _offset) (_offset)
+
+#define MUSB_TXCSR_MODE		0x2000
+
+/* "bus control"/target registers, for host side multipoint (external hubs) */
+#define MUSB_TXFUNCADDR		USBC_REG_o_TXFADDRx
+#define MUSB_TXHUBADDR		USBC_REG_o_TXHADDRx
+#define MUSB_TXHUBPORT		USBC_REG_o_TXHPORTx
+
+#define MUSB_RXFUNCADDR		USBC_REG_o_RXFADDRx
+#define MUSB_RXHUBADDR		USBC_REG_o_RXHADDRx
+#define MUSB_RXHUBPORT		USBC_REG_o_RXHPORTx
+
+/* Endpoint is selected with MUSB_INDEX. */
+#define MUSB_BUSCTL_OFFSET(_epnum, _offset) (_offset)
+
+static inline void musb_write_txfifosz(void __iomem *mbase, u8 c_size)
+{
+	musb_writeb(mbase, MUSB_TXFIFOSZ, c_size);
+}
+
+static inline void musb_write_txfifoadd(void __iomem *mbase, u16 c_off)
+{
+	musb_writew(mbase, MUSB_TXFIFOADD, c_off);
+}
+
+static inline void musb_write_rxfifosz(void __iomem *mbase, u8 c_size)
+{
+	musb_writeb(mbase, MUSB_RXFIFOSZ, c_size);
+}
+
+static inline void  musb_write_rxfifoadd(void __iomem *mbase, u16 c_off)
+{
+	musb_writew(mbase, MUSB_RXFIFOADD, c_off);
+}
+
+static inline void musb_write_ulpi_buscontrol(void __iomem *mbase, u8 val)
+{
+}
+
+static inline u8 musb_read_txfifosz(void __iomem *mbase)
+{
+	return musb_readb(mbase, MUSB_TXFIFOSZ);
+}
+
+static inline u16 musb_read_txfifoadd(void __iomem *mbase)
+{
+	return musb_readw(mbase, MUSB_TXFIFOADD);
+}
+
+static inline u8 musb_read_rxfifosz(void __iomem *mbase)
+{
+	return musb_readb(mbase, MUSB_RXFIFOSZ);
+}
+
+static inline u16  musb_read_rxfifoadd(void __iomem *mbase)
+{
+	return musb_readw(mbase, MUSB_RXFIFOADD);
+}
+
+static inline u8 musb_read_ulpi_buscontrol(void __iomem *mbase)
+{
+	return 0;
+}
+
+static inline u8 musb_read_configdata(void __iomem *mbase)
+{
+	musb_writeb(mbase, MUSB_INDEX, 0);
+	return musb_readb(mbase, MUSB_CONFIGDATA);
+}
+
+static inline u16 musb_read_hwvers(void __iomem *mbase)
+{
+	/* Unknown version */
+	return 0;
+}
+
+static inline void __iomem *musb_read_target_reg_base(u8 i, void __iomem *mbase)
+{
+	return MUSB_BUSCTL_OFFSET(i, 0) + mbase;
+}
+
+static inline void musb_write_rxfunaddr(void __iomem *ep_target_regs,
+		u8 qh_addr_reg)
+{
+	musb_writeb(ep_target_regs, MUSB_RXFUNCADDR, qh_addr_reg);
+}
+
+static inline void musb_write_rxhubaddr(void __iomem *ep_target_regs,
+		u8 qh_h_addr_reg)
+{
+	musb_writeb(ep_target_regs, MUSB_RXHUBADDR, qh_h_addr_reg);
+}
+
+static inline void musb_write_rxhubport(void __iomem *ep_target_regs,
+		u8 qh_h_port_reg)
+{
+	musb_writeb(ep_target_regs, MUSB_RXHUBPORT, qh_h_port_reg);
+}
+
+static inline void musb_write_txfunaddr(void __iomem *mbase, u8 epnum,
+		u8 qh_addr_reg)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	musb_writeb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_TXFUNCADDR),
+		    qh_addr_reg);
+}
+
+static inline void musb_write_txhubaddr(void __iomem *mbase, u8 epnum,
+		u8 qh_addr_reg)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	musb_writeb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_TXHUBADDR),
+		    qh_addr_reg);
+}
+
+static inline void musb_write_txhubport(void __iomem *mbase, u8 epnum,
+		u8 qh_h_port_reg)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	musb_writeb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_TXHUBPORT),
+		    qh_h_port_reg);
+}
+
+static inline u8 musb_read_rxfunaddr(void __iomem *mbase, u8 epnum)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	return musb_readb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_RXFUNCADDR));
+}
+
+static inline u8 musb_read_rxhubaddr(void __iomem *mbase, u8 epnum)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	return musb_readb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_RXHUBADDR));
+}
+
+static inline u8 musb_read_rxhubport(void __iomem *mbase, u8 epnum)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	return musb_readb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_RXHUBPORT));
+}
+
+static inline u8  musb_read_txfunaddr(void __iomem *mbase, u8 epnum)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	return musb_readb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_TXFUNCADDR));
+}
+
+static inline u8  musb_read_txhubaddr(void __iomem *mbase, u8 epnum)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	return musb_readb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_TXHUBADDR));
+}
+
+static inline u8  musb_read_txhubport(void __iomem *mbase, u8 epnum)
+{
+	WARN_ON(musb_readb(mbase, MUSB_INDEX) != epnum);
+	return musb_readb(mbase, MUSB_BUSCTL_OFFSET(epnum, MUSB_TXHUBPORT));
+}
+
+#endif /* CONFIG_USB_MUSB_SUNXI || CONFIG_USB_MUSB_SUNXI_MODULE */
+
 #else /* CONFIG_BLACKFIN */
 
 #define USB_BASE		USB_FADDR
diff --git a/drivers/usb/musb/sunxi.c b/drivers/usb/musb/sunxi.c
new file mode 100644
index 0000000..e272a49
--- /dev/null
+++ b/drivers/usb/musb/sunxi.c
@@ -0,0 +1,898 @@
+/*
+ * Allwinner SUNXI "glue layer"
+ *
+ * Copyright  2013 Jussi Kivilinna <jussi.kivilinna@iki.fi>
+ *
+ * Based on the sw_usb "Allwinner OTG Dual Role Controller" code.
+ *  Copyright 2007-2012 (C) Allwinner Technology Co., Ltd.
+ *  javen <javen@allwinnertech.com>
+ *
+ * Based on the DA8xx "glue layer" code.
+ *  Copyright (c) 2008-2009 MontaVista Software, Inc. <source@mvista.com>
+ *  Copyright (C) 2005-2006 by Texas Instruments
+ *
+ * This file is part of the Inventra Controller Driver for Linux.
+ *
+ * The Inventra Controller Driver for Linux is free software; you
+ * can redistribute it and/or modify it under the terms of the GNU
+ * General Public License version 2 as published by the Free Software
+ * Foundation.
+ *
+ */
+#define DEBUG 1
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <mach/clock.h>
+#include <plat/system.h>
+
+#include "sunxi_musb_plat.h"
+#include "musb_core.h"
+
+#define SUNXI_MUSB_DRIVER_NAME "sunxi_musb"
+
+struct sunxi_musb_clock {
+	struct clk	*sie_clk;		/* SIE clock handle	*/
+	struct clk	*phy_clk;		/* PHY gate		*/
+	struct clk	*phy0_clk;		/* PHY reset		*/
+};
+
+struct sunxi_musb_glue {
+	struct device		*dev;
+	struct platform_device	*musb;
+	struct sunxi_musb_clock	clk;
+
+	int vbus_on;
+	int exiting;
+
+	struct sunxi_musb_board_priv *board_priv;
+};
+
+static inline struct sunxi_musb_glue *musb_to_glue(struct musb *musb)
+{
+	struct device *sunxi_musb_dev = musb->controller->parent;
+	struct sunxi_musb_glue *glue = dev_get_drvdata(sunxi_musb_dev);
+
+	return glue;
+}
+
+static inline struct sunxi_musb_board_data *musb_to_board(struct musb *musb)
+{
+	struct device *dev = musb->controller;
+	struct musb_hdrc_platform_data *plat = dev->platform_data;
+	struct sunxi_musb_board_data *data = plat->board_data;
+
+	return data;
+}
+
+/******************************************************************************
+ ******************************************************************************
+ * From the Allwinner driver
+ ******************************************************************************
+ ******************************************************************************/
+
+/******************************************************************************
+ * From include/sunxi_usb_bsp.h
+ ******************************************************************************/
+
+/* reg offsets */
+#define  USBC_REG_o_ISCR	0x0400
+#define  USBC_REG_o_PHYCTL	0x0404
+#define  USBC_REG_o_PHYBIST	0x0408
+#define  USBC_REG_o_PHYTUNE	0x040c
+
+#define  USBC_REG_o_VEND0	0x0043
+
+/* Interface Status and Control */
+#define  USBC_BP_ISCR_VBUS_VALID_FROM_DATA	30
+#define  USBC_BP_ISCR_VBUS_VALID_FROM_VBUS	29
+#define  USBC_BP_ISCR_EXT_ID_STATUS		28
+#define  USBC_BP_ISCR_EXT_DM_STATUS		27
+#define  USBC_BP_ISCR_EXT_DP_STATUS		26
+#define  USBC_BP_ISCR_MERGED_VBUS_STATUS	25
+#define  USBC_BP_ISCR_MERGED_ID_STATUS		24
+
+#define  USBC_BP_ISCR_ID_PULLUP_EN		17
+#define  USBC_BP_ISCR_DPDM_PULLUP_EN		16
+#define  USBC_BP_ISCR_FORCE_ID			14
+#define  USBC_BP_ISCR_FORCE_VBUS_VALID		12
+#define  USBC_BP_ISCR_VBUS_VALID_SRC		10
+
+#define  USBC_BP_ISCR_HOSC_EN			7
+#define  USBC_BP_ISCR_VBUS_CHANGE_DETECT	6
+#define  USBC_BP_ISCR_ID_CHANGE_DETECT		5
+#define  USBC_BP_ISCR_DPDM_CHANGE_DETECT	4
+#define  USBC_BP_ISCR_IRQ_ENABLE		3
+#define  USBC_BP_ISCR_VBUS_CHANGE_DETECT_EN	2
+#define  USBC_BP_ISCR_ID_CHANGE_DETECT_EN	1
+#define  USBC_BP_ISCR_DPDM_CHANGE_DETECT_EN	0
+
+/* usb id type */
+#define  USBC_ID_TYPE_DISABLE		0
+#define  USBC_ID_TYPE_HOST		1
+#define  USBC_ID_TYPE_DEVICE		2
+
+/* usb vbus valid type */
+#define  USBC_VBUS_TYPE_DISABLE		0
+#define  USBC_VBUS_TYPE_LOW		1
+#define  USBC_VBUS_TYPE_HIGH		2
+
+/* usb io type */
+#define  USBC_IO_TYPE_PIO		0
+#define  USBC_IO_TYPE_DMA		1
+
+/* usb ep type */
+#define  USBC_EP_TYPE_IDLE		0
+#define  USBC_EP_TYPE_EP0		1
+#define  USBC_EP_TYPE_TX		2
+#define  USBC_EP_TYPE_RX		3
+
+/* vendor0 */
+#define  USBC_BP_VEND0_DRQ_SEL		1
+#define  USBC_BP_VEND0_BUS_SEL		0
+
+/******************************************************************************
+ * From usbc/usbc.c
+ ******************************************************************************/
+
+static u32 __USBC_WakeUp_ClearChangeDetect(u32 reg_val)
+{
+	u32 temp = reg_val;
+
+	temp &= ~(1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT);
+	temp &= ~(1 << USBC_BP_ISCR_ID_CHANGE_DETECT);
+	temp &= ~(1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT);
+
+	return temp;
+}
+
+void USBC_EnableIdPullUp(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val |= (1 << USBC_BP_ISCR_ID_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+void USBC_DisableIdPullUp(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val &= ~(1 << USBC_BP_ISCR_ID_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+static void USBC_EnableDpDmPullUp(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val |= (1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+static void USBC_DisableDpDmPullUp(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val &= ~(1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+static void __USBC_ForceIdDisable(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+static void __USBC_ForceIdToLow(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val |= (0x02 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+static void __USBC_ForceIdToHigh(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val |= (0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+/* force id to (id_type) */
+static void USBC_ForceId(__iomem void *base, u32 id_type)
+{
+	pr_debug("%s(): id_type %s\n", __func__,
+		id_type == USBC_ID_TYPE_HOST ? "host" :
+		(id_type == USBC_ID_TYPE_DEVICE ? "device" : "disable"));
+
+	switch (id_type) {
+	case USBC_ID_TYPE_HOST:
+		__USBC_ForceIdToLow(base);
+		break;
+
+	case USBC_ID_TYPE_DEVICE:
+		__USBC_ForceIdToHigh(base);
+		break;
+
+	default:
+		__USBC_ForceIdDisable(base);
+		break;
+	}
+}
+
+static void __USBC_ForceVbusValidDisable(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+static void __USBC_ForceVbusValidToLow(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val |= (0x02 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+static void __USBC_ForceVbusValidToHigh(__iomem void *base)
+{
+	u32 reg_val;
+
+	reg_val = musb_readl(base, USBC_REG_o_ISCR);
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val |= (0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	musb_writel(base, USBC_REG_o_ISCR, reg_val);
+}
+
+/* force vbus valid to (id_type) */
+static void USBC_ForceVbusValid(__iomem void *base, u32 vbus_type)
+{
+	pr_debug("%s(): vbus_type %s\n", __func__,
+		vbus_type == USBC_VBUS_TYPE_LOW ? "low" :
+		(vbus_type == USBC_VBUS_TYPE_HIGH ? "high" : "disable"));
+
+	switch (vbus_type) {
+	case USBC_VBUS_TYPE_LOW:
+		__USBC_ForceVbusValidToLow(base);
+		break;
+
+	case USBC_VBUS_TYPE_HIGH:
+		__USBC_ForceVbusValidToHigh(base);
+		break;
+
+	default:
+		__USBC_ForceVbusValidDisable(base);
+		break;
+	}
+}
+
+static void USBC_SelectBus(__iomem void *base, __u32 io_type, __u32 ep_type,
+			   __u32 ep_index)
+{
+	u32 reg_val = 0;
+
+	reg_val = musb_readb(base, USBC_REG_o_VEND0);
+
+	if (io_type == USBC_IO_TYPE_DMA) {
+		if (ep_type == USBC_EP_TYPE_TX) {
+			/* drq_sel */
+			reg_val |= ((ep_index - 1) << 1) <<
+					USBC_BP_VEND0_DRQ_SEL;
+			/* io_dma */
+			reg_val |= 1 << USBC_BP_VEND0_BUS_SEL;
+		} else {
+			reg_val |= ((ep_index << 1) - 1) <<
+					USBC_BP_VEND0_DRQ_SEL;
+			reg_val |= 1 << USBC_BP_VEND0_BUS_SEL;
+		}
+	} else {
+		/* Clear drq_sel, select pio */
+		reg_val &= 0x00;
+	}
+
+	musb_writeb(base, USBC_REG_o_VEND0, reg_val);
+}
+
+/******************************************************************************
+ * From usbc/usbc_phy.c
+ ******************************************************************************/
+
+static u32 USBC_Phy_TpWrite(__iomem void *base, u32 usbc_no, u32 addr, u32 data,
+			    u32 len)
+{
+	u32 temp = 0, dtmp = 0;
+	u32 j = 0;
+
+	dtmp = data;
+	for (j = 0; j < len; j++) {
+		/* set the bit address to be write */
+		temp = musb_readl(base, USBC_REG_o_PHYCTL);
+		temp &= ~(0xff << 8);
+		temp |= ((addr + j) << 8);
+		musb_writel(base, USBC_REG_o_PHYCTL, temp);
+
+		temp = musb_readb(base, USBC_REG_o_PHYCTL);
+		temp &= ~(0x1 << 7);
+		temp |= (dtmp & 0x1) << 7;
+		temp &= ~(0x1 << (usbc_no << 1));
+		musb_writeb(base, USBC_REG_o_PHYCTL, temp);
+
+		temp = musb_readb(base, USBC_REG_o_PHYCTL);
+		temp |= (0x1 << (usbc_no << 1));
+		musb_writeb(base, USBC_REG_o_PHYCTL, temp);
+
+		temp = musb_readb(base, USBC_REG_o_PHYCTL);
+		temp &= ~(0x1 << (usbc_no << 1));
+		musb_writeb(base, USBC_REG_o_PHYCTL, temp);
+		dtmp >>= 1;
+	}
+
+	return data;
+}
+
+static u32 USBC_Phy_Write(__iomem void *base, u32 usbc_no, u32 addr, u32 data,
+			  u32 len)
+{
+	return USBC_Phy_TpWrite(base, usbc_no, addr, data, len);
+}
+
+static void UsbPhyInit(__iomem void *base, u32 usbc_no)
+{
+	pr_debug("%s():\n", __func__);
+
+	/* NOTE: comments google-translated. */
+
+	/* Regulation 45 ohms */
+	if (usbc_no == 0)
+		USBC_Phy_Write(base, usbc_no, 0x0c, 0x01, 1);
+
+	/* Adjust the magnitude and rate of USB0 PHY */
+	USBC_Phy_Write(base, usbc_no, 0x20, 0x14, 5);
+
+	/* Adjust the disconnect threshold */
+	if (sunxi_is_sun5i())
+		USBC_Phy_Write(base, usbc_no, 0x2a, 2, 2);
+	else
+		USBC_Phy_Write(base, usbc_no, 0x2a, 3, 2);
+
+	return;
+}
+
+/******************************************************************************
+ * From hcd/hcd0/sw_hcd0.c
+ ******************************************************************************/
+
+static s32 usb_clock_init(struct sunxi_musb_glue *glue)
+{
+	int err = 0;
+	struct sunxi_musb_clock *sw_hcd_io = &glue->clk;
+
+	pr_debug("%s():\n", __func__);
+
+	sw_hcd_io->sie_clk = NULL;
+	sw_hcd_io->phy_clk = NULL;
+	sw_hcd_io->phy0_clk = NULL;
+
+	sw_hcd_io->sie_clk = clk_get(NULL, "ahb_usb0");
+	if (IS_ERR(sw_hcd_io->sie_clk)) {
+		dev_err(glue->dev, "get usb sie clk failed.\n");
+		err = PTR_ERR(sw_hcd_io->sie_clk);
+		goto failed;
+	}
+
+	sw_hcd_io->phy_clk = clk_get(NULL, "usb_phy");
+	if (IS_ERR(sw_hcd_io->phy_clk)) {
+		dev_err(glue->dev, "get usb phy clk failed.\n");
+		err = PTR_ERR(sw_hcd_io->phy_clk);
+		goto failed;
+	}
+
+	sw_hcd_io->phy0_clk = clk_get(NULL, "usb_phy0");
+	if (IS_ERR(sw_hcd_io->phy0_clk)) {
+		dev_err(glue->dev, "get usb phy0 clk failed.\n");
+		err = PTR_ERR(sw_hcd_io->phy0_clk);
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+	if (sw_hcd_io->sie_clk) {
+		clk_put(sw_hcd_io->sie_clk);
+		sw_hcd_io->sie_clk = NULL;
+	}
+
+	if (sw_hcd_io->phy_clk) {
+		clk_put(sw_hcd_io->phy_clk);
+		sw_hcd_io->phy_clk = NULL;
+	}
+
+	if (sw_hcd_io->phy0_clk) {
+		clk_put(sw_hcd_io->phy0_clk);
+		sw_hcd_io->phy0_clk = NULL;
+	}
+
+	return err;
+}
+
+static s32 usb_clock_exit(struct sunxi_musb_glue *glue)
+{
+	struct sunxi_musb_clock *sw_hcd_io = &glue->clk;
+
+	pr_debug("%s():\n", __func__);
+
+	if (sw_hcd_io->sie_clk) {
+		clk_put(sw_hcd_io->sie_clk);
+		sw_hcd_io->sie_clk = NULL;
+	}
+
+	if (sw_hcd_io->phy_clk) {
+		clk_put(sw_hcd_io->phy_clk);
+		sw_hcd_io->phy_clk = NULL;
+	}
+
+	if (sw_hcd_io->phy0_clk) {
+		clk_put(sw_hcd_io->phy0_clk);
+		sw_hcd_io->phy0_clk = NULL;
+	}
+
+	return 0;
+}
+
+static s32 open_usb_clock(struct sunxi_musb_glue *glue)
+{
+	struct sunxi_musb_clock *sw_hcd_io = &glue->clk;
+	int ret;
+
+	pr_debug("%s():\n", __func__);
+
+	ret = clk_enable(sw_hcd_io->sie_clk);
+	if (ret < 0) {
+		dev_err(glue->dev, "could not enable sie_clk\n");
+		return ret;
+	}
+
+	mdelay(10);
+
+	ret = clk_enable(sw_hcd_io->phy_clk);
+	if (ret < 0) {
+		dev_err(glue->dev, "could not enable phy_clk\n");
+		return ret;
+	}
+
+	ret = clk_enable(sw_hcd_io->phy0_clk);
+	if (ret < 0) {
+		dev_err(glue->dev, "could not enable pky0_clk\n");
+		return ret;
+	}
+
+	clk_reset(sw_hcd_io->phy0_clk, 0);
+	mdelay(10);
+
+	return 0;
+}
+
+static s32 close_usb_clock(struct sunxi_musb_glue *glue)
+{
+	struct sunxi_musb_clock *sw_hcd_io = &glue->clk;
+
+	pr_debug("%s():\n", __func__);
+
+	clk_reset(sw_hcd_io->phy0_clk, 1);
+	clk_disable(sw_hcd_io->phy0_clk);
+	clk_disable(sw_hcd_io->phy_clk);
+	clk_disable(sw_hcd_io->sie_clk);
+
+	return 0;
+}
+
+static void sw_hcd_board_set_vbus(struct musb *musb, int is_on)
+{
+	struct sunxi_musb_glue *glue = musb_to_glue(musb);
+	struct sunxi_musb_board_data *board = musb_to_board(musb);
+	u32 val;
+
+	dev_info(glue->dev, "is_on = %d\n", is_on);
+
+	if (is_on) {
+		if (!glue->vbus_on) {
+			/* set gpio data */
+			if (board->set_phy_power(glue->board_priv, 1) < 0)
+				return;
+
+			glue->vbus_on = 1;
+
+			dev_info(glue->dev, "Set USB Power On\n");
+		}
+
+		/* start session */
+		val = musb_readw(musb->mregs, MUSB_DEVCTL);
+		val &= ~MUSB_DEVCTL_SESSION;
+		musb_writew(musb->mregs, MUSB_DEVCTL, val);
+		val |= MUSB_DEVCTL_SESSION;
+		musb_writew(musb->mregs, MUSB_DEVCTL, val);
+
+		USBC_ForceId(musb->mregs, USBC_ID_TYPE_HOST);
+		USBC_ForceVbusValid(musb->mregs, USBC_VBUS_TYPE_HIGH);
+	} else {
+		if (glue->vbus_on) {
+			/* set gpio data */
+			if (board->set_phy_power(glue->board_priv, 0) < 0)
+				return;
+
+			glue->vbus_on = 0;
+
+			dev_info(glue->dev, "Set USB Power Off\n");
+		}
+
+		/* end session */
+		val = musb_readw(musb->mregs, MUSB_DEVCTL);
+		val &= ~MUSB_DEVCTL_SESSION;
+		musb_writew(musb->mregs, MUSB_DEVCTL, val);
+
+		USBC_ForceId(musb->mregs, USBC_ID_TYPE_DEVICE);
+		USBC_ForceVbusValid(musb->mregs, USBC_VBUS_TYPE_HIGH);
+	}
+
+	return;
+}
+
+/******************************************************************************
+ * MUSB Glue code
+ ******************************************************************************/
+
+static void sunxi_musb_set_vbus(struct musb *musb, int on)
+{
+	pr_debug("%s(): on = %d, otg_state = %s\n", __func__, on,
+	       otg_state_string(musb->xceiv->state));
+
+	sw_hcd_board_set_vbus(musb, on);
+}
+
+static irqreturn_t sunxi_musb_interrupt(int irq, void *__hci)
+{
+	struct musb		*musb = __hci;
+	irqreturn_t		retval = IRQ_NONE;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	/* read and flush interrupts */
+	musb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);
+	if (musb->int_usb)
+		musb_writeb(musb->mregs, MUSB_INTRUSB, musb->int_usb);
+	musb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);
+	if (musb->int_tx)
+		musb_writew(musb->mregs, MUSB_INTRTX, musb->int_tx);
+	musb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);
+	if (musb->int_rx)
+		musb_writew(musb->mregs, MUSB_INTRRX, musb->int_rx);
+
+	if (musb->int_usb || musb->int_tx || musb->int_rx)
+		retval |= musb_interrupt(musb);
+
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return retval;
+}
+
+static void sunxi_musb_enable(struct musb *musb)
+{
+	pr_debug("%s():\n", __func__);
+
+	/* select PIO mode */
+	USBC_SelectBus(musb->mregs, USBC_IO_TYPE_PIO, 0, 0);
+
+	if (is_host_enabled(musb)) {
+		/* port power on */
+		sw_hcd_board_set_vbus(musb, 1);
+	}
+}
+
+static void sunxi_musb_disable(struct musb *musb)
+{
+	pr_debug("%s():\n", __func__);
+}
+
+static void sunxi_musb_try_idle(struct musb *musb, unsigned long timeout)
+{
+	/* TODO */
+}
+
+static int sunxi_musb_vbus_status(struct musb *musb)
+{
+	/* TODO? */
+	return 0;
+}
+
+static int sunxi_musb_set_mode(struct musb *musb, u8 musb_mode)
+{
+	pr_debug("%s(): musb_mode %d\n", __func__, musb_mode);
+
+	switch (musb_mode) {
+	case MUSB_HOST:
+		USBC_ForceId(musb->mregs, USBC_ID_TYPE_HOST);
+		USBC_ForceVbusValid(musb->mregs, USBC_VBUS_TYPE_HIGH);
+		sw_hcd_board_set_vbus(musb, 1);
+		break;
+
+	case MUSB_PERIPHERAL:
+		USBC_ForceId(musb->mregs, USBC_ID_TYPE_DEVICE);
+		USBC_ForceVbusValid(musb->mregs, USBC_VBUS_TYPE_DISABLE);
+		sw_hcd_board_set_vbus(musb, 0);
+		break;
+
+	case MUSB_OTG:
+	default:
+		USBC_ForceId(musb->mregs, USBC_ID_TYPE_DISABLE);
+		USBC_ForceVbusValid(musb->mregs, USBC_VBUS_TYPE_DISABLE);
+		/* set vbus? */
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_musb_init(struct musb *musb)
+{
+	struct sunxi_musb_glue *glue = musb_to_glue(musb);
+	struct sunxi_musb_board_data *board = musb_to_board(musb);
+	int ret = -ENODEV;
+
+	pr_debug("%s():\n", __func__);
+
+	glue->exiting = 0;
+
+	musb->isr = sunxi_musb_interrupt;
+
+	usb_nop_xceiv_register();
+	musb->xceiv = usb_get_transceiver();
+	if (!musb->xceiv)
+		goto err0;
+
+	ret = usb_clock_init(glue);
+	if (ret < 0) {
+		dev_err(musb->controller, "failed to get clock\n");
+		goto err1;
+	}
+
+	ret = open_usb_clock(glue);
+	if (ret < 0) {
+		dev_err(musb->controller, "failed to enable clocks\n");
+		goto err2;
+	}
+
+	glue->vbus_on = 0;
+
+	/* moved here from open_usb_clock */
+	UsbPhyInit(musb->mregs, 0);
+
+	/* config drv_vbus pin */
+	glue->board_priv = board->init(glue->dev);
+	if (IS_ERR_OR_NULL(glue->board_priv)) {
+		ret = PTR_ERR(glue->board_priv);
+		glue->board_priv = NULL;
+		goto err3;
+	}
+
+	USBC_EnableDpDmPullUp(musb->mregs);
+	USBC_EnableIdPullUp(musb->mregs);
+
+	if (is_host_enabled(musb) && !is_otg_enabled(musb)) {
+		USBC_ForceId(musb->mregs, USBC_ID_TYPE_HOST);
+		USBC_ForceVbusValid(musb->mregs, USBC_VBUS_TYPE_HIGH);
+	} else if (is_peripheral_enabled(musb) && !is_otg_enabled(musb)) {
+		USBC_ForceId(musb->mregs, USBC_ID_TYPE_DEVICE);
+		USBC_ForceVbusValid(musb->mregs, USBC_VBUS_TYPE_HIGH);
+	} else {
+		USBC_ForceId(musb->mregs, USBC_ID_TYPE_DISABLE);
+		USBC_ForceVbusValid(musb->mregs, USBC_VBUS_TYPE_DISABLE);
+	}
+
+	return 0;
+
+/*err4:*/
+	board->exit(glue->board_priv);
+err3:
+	close_usb_clock(glue);
+err2:
+	usb_clock_exit(glue);
+err1:
+	usb_put_transceiver(musb->xceiv);
+err0:
+	usb_nop_xceiv_unregister();
+
+	return ret;
+}
+
+static int sunxi_musb_exit(struct musb *musb)
+{
+	struct sunxi_musb_glue *glue = musb_to_glue(musb);
+	struct sunxi_musb_board_data *board = musb_to_board(musb);
+	unsigned long flags;
+
+	pr_debug("%s():\n", __func__);
+
+	spin_lock_irqsave(&musb->lock, flags);
+	glue->exiting = 1;
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	USBC_DisableDpDmPullUp(musb->mregs);
+	USBC_DisableIdPullUp(musb->mregs);
+
+	sw_hcd_board_set_vbus(musb, 0);
+
+	board->exit(glue->board_priv);
+	close_usb_clock(glue);
+	usb_clock_exit(glue);
+	usb_put_transceiver(musb->xceiv);
+	usb_nop_xceiv_unregister();
+
+	glue->vbus_on = 0;
+
+	return 0;
+}
+
+static const struct musb_platform_ops sunxi_musb_ops = {
+	.init		= sunxi_musb_init,
+	.exit		= sunxi_musb_exit,
+
+	.enable		= sunxi_musb_enable,
+	.disable	= sunxi_musb_disable,
+
+	.set_vbus	= sunxi_musb_set_vbus,
+	.vbus_status	= sunxi_musb_vbus_status,
+
+	.set_mode	= sunxi_musb_set_mode,
+	.try_idle	= sunxi_musb_try_idle,
+};
+
+static int __devinit sunxi_musb_probe(struct platform_device *pdev)
+{
+	struct musb_hdrc_platform_data	*pdata = pdev->dev.platform_data;
+	struct platform_device		*musb;
+	struct sunxi_musb_glue		*glue;
+	int				ret = -ENOMEM;
+
+	pr_debug("%s():\n", __func__);
+
+	glue = kzalloc(sizeof(*glue), GFP_KERNEL);
+	if (!glue) {
+		dev_err(&pdev->dev, "failed to allocate glue context\n");
+		goto err0;
+	}
+
+	musb = platform_device_alloc("musb-hdrc", -1);
+	if (!musb) {
+		dev_err(&pdev->dev, "failed to allocate musb device\n");
+		goto err1;
+	}
+
+	glue->dev			= &pdev->dev;
+	glue->musb			= musb;
+
+	musb->dev.parent		= &pdev->dev;
+	musb->dev.dma_mask		= pdev->dev.dma_mask;
+	musb->dev.coherent_dma_mask	= pdev->dev.coherent_dma_mask;
+
+	pdata->platform_ops		= &sunxi_musb_ops;
+
+	platform_set_drvdata(pdev, glue);
+
+	ret = platform_device_add_resources(musb, pdev->resource,
+					    pdev->num_resources);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add resources\n");
+		goto err2;
+	}
+
+	ret = platform_device_add_data(musb, pdata, sizeof(*pdata));
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add platform_data\n");
+		goto err2;
+	}
+
+	ret = platform_device_add(musb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register musb device\n");
+		goto err2;
+	}
+
+	return 0;
+
+err2:
+	platform_device_put(musb);
+
+err1:
+	kfree(glue);
+
+err0:
+	return ret;
+}
+
+static int __devexit sunxi_musb_remove(struct platform_device *pdev)
+{
+	struct sunxi_musb_glue *glue = platform_get_drvdata(pdev);
+
+	pr_debug("%s():\n", __func__);
+
+	platform_device_del(glue->musb);
+	platform_device_put(glue->musb);
+	kfree(glue);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_musb_driver = {
+	.probe		= sunxi_musb_probe,
+	.remove		= __devexit_p(sunxi_musb_remove),
+	.driver		= {
+		.name	= SUNXI_MUSB_DRIVER_NAME,
+	},
+};
+
+MODULE_DESCRIPTION("SUNXI MUSB Glue Layer");
+MODULE_AUTHOR("Jussi Kivilinna <jussi.kivilinna@iki.fi>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" SUNXI_MUSB_DRIVER_NAME);
+
+static int __init sunxi_musb_drvinit(void)
+{
+	int ret;
+
+	pr_debug("%s():\n", __func__);
+
+	ret = platform_driver_register(&sunxi_musb_driver);
+	if (ret < 0)
+		return ret;
+
+	ret = register_musb_device();
+	if (ret < 0)
+		goto err0;
+
+	return 0;
+err0:
+	platform_driver_unregister(&sunxi_musb_driver);
+	return ret;
+}
+module_init(sunxi_musb_drvinit);
+
+static void __exit sunxi_musb_drvexit(void)
+{
+	pr_debug("%s():\n", __func__);
+
+	unregister_musb_device();
+	platform_driver_unregister(&sunxi_musb_driver);
+}
+module_exit(sunxi_musb_drvexit);
diff --git a/drivers/usb/musb/sunxi_musb_plat.c b/drivers/usb/musb/sunxi_musb_plat.c
new file mode 100644
index 0000000..18b340a
--- /dev/null
+++ b/drivers/usb/musb/sunxi_musb_plat.c
@@ -0,0 +1,340 @@
+/*
+ * Allwinner SUNXI MUSB platform setup
+ *
+ * Copyright  2013 Jussi Kivilinna <jussi.kivilinna@iki.fi>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#define DEBUG 1
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/usb/musb.h>
+
+#include <plat/sys_config.h>
+#include <mach/platform.h>
+#include <mach/clock.h>
+#include <mach/irqs.h>
+
+#include "../../power/axp_power/axp-gpio.h"
+#include "sunxi_musb_plat.h"
+
+struct sunxi_musb_gpio {
+	unsigned int	Drv_vbus_Handle;
+	user_gpio_set_t	drv_vbus_gpio_set;
+};
+
+struct sunxi_musb_board_priv {
+	struct device *dev;
+	struct sunxi_musb_gpio gpio;
+};
+
+static s32 pin_init(struct sunxi_musb_board_priv *priv)
+{
+	struct sunxi_musb_gpio *sw_hcd_io = &priv->gpio;
+	s32 ret = 0;
+
+	pr_debug("%s():\n", __func__);
+
+	/* request gpio */
+	ret = script_parser_fetch("usbc0", "usb_drv_vbus_gpio",
+				  (int *)&sw_hcd_io->drv_vbus_gpio_set, 64);
+	if (ret != 0)
+		dev_warn(priv->dev, "get usbc0(drv vbus) id failed\n");
+
+	if (!sw_hcd_io->drv_vbus_gpio_set.port) {
+		dev_err(priv->dev, "usbc0(drv vbus) is invalid\n");
+		sw_hcd_io->Drv_vbus_Handle = 0;
+		return 0;
+	}
+
+	if (sw_hcd_io->drv_vbus_gpio_set.port == 0xffff) { /* power */
+		if (sw_hcd_io->drv_vbus_gpio_set.mul_sel == 0 ||
+				sw_hcd_io->drv_vbus_gpio_set.mul_sel == 1) {
+			axp_gpio_set_io(sw_hcd_io->drv_vbus_gpio_set.port_num,
+					sw_hcd_io->drv_vbus_gpio_set.mul_sel);
+			axp_gpio_set_value(
+					sw_hcd_io->drv_vbus_gpio_set.port_num,
+					!sw_hcd_io->drv_vbus_gpio_set.data);
+
+			return 100 + sw_hcd_io->drv_vbus_gpio_set.port_num;
+		} else {
+			dev_err(priv->dev, "unknown gpio mul_sel(%d)\n",
+				sw_hcd_io->drv_vbus_gpio_set.mul_sel);
+			return 0;
+		}
+	} else {  /* axp */
+		sw_hcd_io->Drv_vbus_Handle = sunxi_gpio_request_array(
+				&sw_hcd_io->drv_vbus_gpio_set, 1);
+		if (sw_hcd_io->Drv_vbus_Handle == 0) {
+			dev_err(priv->dev, "gpio_request failed\n");
+			return -1;
+		}
+
+		/* set config, ouput */
+		gpio_set_one_pin_io_status(sw_hcd_io->Drv_vbus_Handle,
+					   !sw_hcd_io->drv_vbus_gpio_set.data,
+					   NULL);
+
+		/* reserved is pull down */
+		gpio_set_one_pin_pull(sw_hcd_io->Drv_vbus_Handle, 2, NULL);
+	}
+
+	return 0;
+}
+
+static s32 pin_exit(struct sunxi_musb_board_priv *priv)
+{
+	struct sunxi_musb_gpio *sw_hcd_io = &priv->gpio;
+
+	pr_debug("%s():\n", __func__);
+
+	if (sw_hcd_io->Drv_vbus_Handle) {
+		if (sw_hcd_io->drv_vbus_gpio_set.port == 0xffff) { /* power */
+			axp_gpio_set_io(sw_hcd_io->drv_vbus_gpio_set.port_num,
+					sw_hcd_io->drv_vbus_gpio_set.mul_sel);
+			axp_gpio_set_value(
+					sw_hcd_io->drv_vbus_gpio_set.port_num,
+					sw_hcd_io->drv_vbus_gpio_set.data);
+		} else {
+			gpio_release(sw_hcd_io->Drv_vbus_Handle, 0);
+		}
+	}
+
+	sw_hcd_io->Drv_vbus_Handle = 0;
+
+	return 0;
+}
+
+static int sunxi_musb_board_priv_set_phy_power(
+				struct sunxi_musb_board_priv *priv, int is_on)
+{
+	struct sunxi_musb_gpio *sw_hcd_io = &priv->gpio;
+	int on_off;
+
+	pr_debug("%s():\n", __func__);
+
+	if (sw_hcd_io->Drv_vbus_Handle == 0) {
+		dev_info(priv->dev, "wrn: sw_hcd_io->drv_vbus_Handle is null\n");
+		return -EIO;
+	}
+
+	/* set power */
+	on_off = !!is_on;
+	if (sw_hcd_io->drv_vbus_gpio_set.data != 0)
+		on_off = !on_off; /* inverse */
+
+	if (sw_hcd_io->drv_vbus_gpio_set.port == 0xffff)
+		axp_gpio_set_value(sw_hcd_io->drv_vbus_gpio_set.port_num,
+				   on_off);
+	else
+		gpio_write_one_pin_value(sw_hcd_io->Drv_vbus_Handle, on_off,
+					 NULL);
+
+	return 0;
+}
+
+static void USBC_ConfigFIFO_Base(void)
+{
+	static DEFINE_SPINLOCK(lock);
+	unsigned long flags = 0;
+	u32 reg_value;
+
+	/* config usb fifo, 8kb mode */
+	spin_lock_irqsave(&lock, flags);
+
+	reg_value = __raw_readl((void __iomem *)SW_VA_SRAM_IO_BASE + 0x04);
+	reg_value &= ~(0x03 << 0);
+	reg_value |= (1 << 0);
+	__raw_writel(reg_value, (void __iomem *)SW_VA_SRAM_IO_BASE + 0x04);
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static struct sunxi_musb_board_priv *sunxi_musb_board_priv_init(
+							struct device *dev)
+{
+	struct sunxi_musb_board_priv *priv;
+	int ret;
+
+	pr_debug("%s():\n", __func__);
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return ERR_PTR(-ENOMEM);
+
+	priv->dev = dev;
+
+	USBC_ConfigFIFO_Base();
+
+	ret = pin_init(priv);
+	if (ret < 0) {
+		dev_err(priv->dev, "pin_init failed\n");
+		kfree(priv);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return priv;
+}
+
+static void sunxi_musb_board_priv_exit(struct sunxi_musb_board_priv *priv)
+{
+	pr_debug("%s():\n", __func__);
+
+	pin_exit(priv);
+	kfree(priv);
+}
+
+static struct resource sunxi_musb_resources[] = {
+	DEFINE_RES_MEM_NAMED(SW_PA_USB0_IO_BASE, 0x1000, "sunxi_musb0-mem"),
+	DEFINE_RES_IRQ_NAMED(SW_INT_IRQNO_USB0, "mc")
+};
+
+/* Can support a maximum ep number, ep0 ~ 5 */
+#define USBC_MAX_EP_NUM		6
+
+static struct musb_fifo_cfg sunxi_musb_mode_cfg[] = {
+	{ .hw_ep_num =  1, .style = FIFO_TX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  1, .style = FIFO_RX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  2, .style = FIFO_TX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  2, .style = FIFO_RX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  3, .style = FIFO_TX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  3, .style = FIFO_RX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  4, .style = FIFO_TX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  4, .style = FIFO_RX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  5, .style = FIFO_TX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+	{ .hw_ep_num =  5, .style = FIFO_RX, .maxpacket = 512,
+		.mode = BUF_SINGLE, },
+};
+
+static struct musb_hdrc_config sunxi_musb_config = {
+	.multipoint	= 1,
+	.dyn_fifo	= 1,
+	.soft_con	= 1,
+	.dma		= 0,
+
+	.num_eps	= USBC_MAX_EP_NUM,
+	.ram_bits	= 11,
+
+	.fifo_cfg	= sunxi_musb_mode_cfg,
+	.fifo_cfg_size	= ARRAY_SIZE(sunxi_musb_mode_cfg),
+};
+
+static struct sunxi_musb_board_data sunxi_musb_board_data = {
+	.init		= sunxi_musb_board_priv_init,
+	.exit		= sunxi_musb_board_priv_exit,
+	.set_phy_power	= sunxi_musb_board_priv_set_phy_power,
+};
+
+/* For testing peripheral mode, set this '1'. */
+#define MUSB_SUNXI_FORCE_PERIPHERAL 0
+
+static struct musb_hdrc_platform_data sunxi_musb_plat = {
+#if (defined(CONFIG_USB_GADGET_MUSB_HDRC) || \
+	defined(CONFIG_USB_GADGET_MUSB_HDRC_MODULE)) && \
+		MUSB_SUNXI_FORCE_PERIPHERAL
+	.mode		= MUSB_PERIPHERAL,
+#else
+	.mode		= MUSB_HOST,
+#endif
+	.config		= &sunxi_musb_config,
+	.board_data	= &sunxi_musb_board_data,
+};
+
+static struct platform_device sunxi_musb_device = {
+	.name	= "sunxi_musb",
+	.id	= -1,
+
+	.dev = {
+		.platform_data = &sunxi_musb_plat,
+	},
+
+	.resource = sunxi_musb_resources,
+	.num_resources = ARRAY_SIZE(sunxi_musb_resources),
+};
+
+#if defined(CONFIG_USB_GADGET_MUSB_HDRC) || \
+	defined(CONFIG_USB_GADGET_MUSB_HDRC_MODULE)
+static void do_fex_setup(struct musb_hdrc_platform_data *plat)
+{
+	int ret;
+	int enabled = 1;
+	int usb_port_type = 1;
+	int usb_detect_type = 0;
+
+	/* usbc enabled */
+	ret = script_parser_fetch("usbc0", "usb_used", &enabled, 64);
+	if (ret != 0) {
+		pr_debug("couldn't fetch config '%s':'%s'.\n",
+			 "usbc0", "usb_used");
+		enabled = 1;
+	}
+
+	/* usbc port type */
+	ret = script_parser_fetch("usbc0", "usb_port_type", &usb_port_type, 64);
+	if (ret != 0) {
+		pr_debug("couldn't fetch config '%s':'%s'.\n",
+			 "usbc0", "usb_port_type");
+		usb_port_type = 1;
+	}
+
+	/* usbc detect type */
+	ret = script_parser_fetch("usbc0", "usb_detect_type", &usb_detect_type,
+				  64);
+	if (ret != 0) {
+		pr_debug("couldn't fetch config '%s':'%s'.\n",
+			 "usbc0", "usb_detect_type");
+		usb_detect_type = 0;
+	}
+
+	pr_debug("usbc0 config: enabled=%d, port_type=%d, detect_type=%d\n",
+		enabled, usb_port_type, usb_detect_type);
+
+#if MUSB_SUNXI_FORCE_PERIPHERAL
+	plat->mode = MUSB_PERIPHERAL;
+#else
+	plat->mode = MUSB_HOST;
+	if (usb_port_type == 2 && usb_detect_type == 1) {
+		/* OTG is not yet supported */
+		plat->mode = /*MUSB_OTG*/ MUSB_PERIPHERAL;
+	} else if (usb_port_type == 0) {
+		plat->mode = MUSB_PERIPHERAL;
+	}
+#endif
+}
+#else
+static void do_fex_setup(struct musb_hdrc_platform_data *plat)
+{
+}
+#endif
+
+int register_musb_device(void)
+{
+	do_fex_setup(&sunxi_musb_plat);
+
+	return platform_device_register(&sunxi_musb_device);
+}
+
+void unregister_musb_device(void)
+{
+	platform_device_unregister(&sunxi_musb_device);
+}
diff --git a/drivers/usb/musb/sunxi_musb_plat.h b/drivers/usb/musb/sunxi_musb_plat.h
new file mode 100644
index 0000000..85b63b2
--- /dev/null
+++ b/drivers/usb/musb/sunxi_musb_plat.h
@@ -0,0 +1,29 @@
+/*
+ * Allwinner SUNXI MUSB platform setup
+ *
+ * Copyright  2013 Jussi Kivilinna <jussi.kivilinna@iki.fi>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __ASM_ARCH_SUNXI_PLAT_MUSB_H
+#define __ASM_ARCH_SUNXI_PLAT_MUSB_H
+
+#include <linux/platform_device.h>
+
+struct sunxi_musb_board_priv;
+
+struct sunxi_musb_board_data {
+	struct sunxi_musb_board_priv *(*init)(struct device *dev);
+	void (*exit)(struct sunxi_musb_board_priv *priv);
+	int (*set_phy_power)(struct sunxi_musb_board_priv *priv, int on);
+};
+
+extern int register_musb_device(void);
+extern void unregister_musb_device(void);
+
+#endif
diff --git a/drivers/usb/otg/Kconfig b/drivers/usb/otg/Kconfig
index 5c87db0..c2902a8 100644
--- a/drivers/usb/otg/Kconfig
+++ b/drivers/usb/otg/Kconfig
@@ -12,6 +12,14 @@ config USB_OTG_UTILS
 	  Select this to make sure the build includes objects from
 	  the OTG infrastructure directory.
 
+config USB_OTG_WAKELOCK
+	bool "Hold a wakelock when USB connected"
+	depends on WAKELOCK
+	select USB_OTG_UTILS
+	help
+	  Select this to automatically hold a wakelock when USB is
+	  connected, preventing suspend.
+
 if USB || USB_GADGET
 
 #
diff --git a/drivers/usb/otg/Makefile b/drivers/usb/otg/Makefile
index 41aa509..638d040 100644
--- a/drivers/usb/otg/Makefile
+++ b/drivers/usb/otg/Makefile
@@ -7,6 +7,7 @@ ccflags-$(CONFIG_USB_GADGET_DEBUG)	+= -DDEBUG
 
 # infrastructure
 obj-$(CONFIG_USB_OTG_UTILS)	+= otg.o
+obj-$(CONFIG_USB_OTG_WAKELOCK)	+= otg-wakelock.o
 
 # transceiver drivers
 obj-$(CONFIG_USB_GPIO_VBUS)	+= gpio_vbus.o
diff --git a/drivers/usb/otg/otg-wakelock.c b/drivers/usb/otg/otg-wakelock.c
new file mode 100644
index 0000000..e17e272
--- /dev/null
+++ b/drivers/usb/otg/otg-wakelock.c
@@ -0,0 +1,170 @@
+/*
+ * otg-wakelock.c
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/wakelock.h>
+#include <linux/spinlock.h>
+#include <linux/usb/otg.h>
+
+#define TEMPORARY_HOLD_TIME	2000
+
+static bool enabled = true;
+static struct usb_phy *otgwl_xceiv;
+static struct notifier_block otgwl_nb;
+
+/*
+ * otgwl_spinlock is held while the VBUS lock is grabbed or dropped and the
+ * held field is updated to match.
+ */
+
+static DEFINE_SPINLOCK(otgwl_spinlock);
+
+/*
+ * Only one lock, but since these 3 fields are associated with each other...
+ */
+
+struct otgwl_lock {
+	char name[40];
+	struct wake_lock wakelock;
+	bool held;
+};
+
+/*
+ * VBUS present lock.  Also used as a timed lock on charger
+ * connect/disconnect and USB host disconnect, to allow the system
+ * to react to the change in power.
+ */
+
+static struct otgwl_lock vbus_lock;
+
+static void otgwl_hold(struct otgwl_lock *lock)
+{
+	if (!lock->held) {
+		wake_lock(&lock->wakelock);
+		lock->held = true;
+	}
+}
+
+static void otgwl_temporary_hold(struct otgwl_lock *lock)
+{
+	wake_lock_timeout(&lock->wakelock,
+			  msecs_to_jiffies(TEMPORARY_HOLD_TIME));
+	lock->held = false;
+}
+
+static void otgwl_drop(struct otgwl_lock *lock)
+{
+	if (lock->held) {
+		wake_unlock(&lock->wakelock);
+		lock->held = false;
+	}
+}
+
+static void otgwl_handle_event(unsigned long event)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&otgwl_spinlock, irqflags);
+
+	if (!enabled) {
+		otgwl_drop(&vbus_lock);
+		spin_unlock_irqrestore(&otgwl_spinlock, irqflags);
+		return;
+	}
+
+	switch (event) {
+	case USB_EVENT_VBUS:
+	case USB_EVENT_ENUMERATED:
+		otgwl_hold(&vbus_lock);
+		break;
+
+	case USB_EVENT_NONE:
+	case USB_EVENT_ID:
+	case USB_EVENT_CHARGER:
+		otgwl_temporary_hold(&vbus_lock);
+		break;
+
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&otgwl_spinlock, irqflags);
+}
+
+static int otgwl_otg_notifications(struct notifier_block *nb,
+				   unsigned long event, void *unused)
+{
+	otgwl_handle_event(event);
+	return NOTIFY_OK;
+}
+
+static int set_enabled(const char *val, const struct kernel_param *kp)
+{
+	int rv = param_set_bool(val, kp);
+
+	if (rv)
+		return rv;
+
+	if (otgwl_xceiv)
+		otgwl_handle_event(otgwl_xceiv->last_event);
+
+	return 0;
+}
+
+static struct kernel_param_ops enabled_param_ops = {
+	.set = set_enabled,
+	.get = param_get_bool,
+};
+
+module_param_cb(enabled, &enabled_param_ops, &enabled, 0644);
+MODULE_PARM_DESC(enabled, "enable wakelock when VBUS present");
+
+static int __init otg_wakelock_init(void)
+{
+	int ret;
+
+	otgwl_xceiv = usb_get_transceiver();
+
+	if (!otgwl_xceiv) {
+		pr_err("%s: No USB transceiver found\n", __func__);
+		return -ENODEV;
+	}
+
+	snprintf(vbus_lock.name, sizeof(vbus_lock.name), "vbus-%s",
+		 dev_name(otgwl_xceiv->dev));
+	wake_lock_init(&vbus_lock.wakelock, WAKE_LOCK_SUSPEND,
+		       vbus_lock.name);
+
+	otgwl_nb.notifier_call = otgwl_otg_notifications;
+	ret = usb_register_notifier(otgwl_xceiv, &otgwl_nb);
+
+	if (ret) {
+		pr_err("%s: usb_register_notifier on transceiver %s"
+		       " failed\n", __func__,
+		       dev_name(otgwl_xceiv->dev));
+		otgwl_xceiv = NULL;
+		wake_lock_destroy(&vbus_lock.wakelock);
+		return ret;
+	}
+
+	otgwl_handle_event(otgwl_xceiv->last_event);
+	return ret;
+}
+
+late_initcall(otg_wakelock_init);
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 78c4774..58a2c65 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -84,6 +84,15 @@ static void option_instat_callback(struct urb *urb);
 #define HUAWEI_PRODUCT_K4505			0x1464
 #define HUAWEI_PRODUCT_K3765			0x1465
 #define HUAWEI_PRODUCT_K4605			0x14C6
+#define HUAWEI_PRODUCT_K5005			0x14C8
+#define HUAWEI_PRODUCT_K3770			0x14C9
+#define HUAWEI_PRODUCT_K3771			0x14CA
+#define HUAWEI_PRODUCT_K4510			0x14CB
+#define HUAWEI_PRODUCT_K4511			0x14CC
+#define HUAWEI_PRODUCT_ETS1220			0x1803
+#define HUAWEI_PRODUCT_E353			0x1506
+#define HUAWEI_PRODUCT_E173S			0x1C05
+#define HUAWEI_PRODUCT_ET128			0x1D09
 
 #define QUANTA_VENDOR_ID			0x0408
 #define QUANTA_PRODUCT_Q101			0xEA02
@@ -231,6 +240,7 @@ static void option_instat_callback(struct urb *urb);
 #define BANDRICH_PRODUCT_1012			0x1012
 
 #define QUALCOMM_VENDOR_ID			0x05C6
+#define QUALCOMM_ASB_C820			0x00a0	//ASB use QUALCOMM ic dongle
 
 #define CMOTECH_VENDOR_ID			0x16d8
 #define CMOTECH_PRODUCT_6008			0x6008
@@ -257,6 +267,10 @@ static void option_instat_callback(struct urb *urb);
 #define ZTE_PRODUCT_AD3812			0xffeb
 #define ZTE_PRODUCT_MC2716			0xffed
 
+/* ZTE PRODUCTS -- alternate vendor ID */
+#define ZTE_VENDOR_ID2				0x1d6b
+#define ZTE_PRODUCT_MF_330			0x0002
+
 #define BENQ_VENDOR_ID				0x04a5
 #define BENQ_PRODUCT_H10			0x4068
 
@@ -287,6 +301,7 @@ static void option_instat_callback(struct urb *urb);
 
 /* ALCATEL PRODUCTS */
 #define ALCATEL_VENDOR_ID			0x1bbb
+#define ALCATEL_PRODUCT_X060S			0x0000
 #define ALCATEL_PRODUCT_X060S_X200		0x0000
 #define ALCATEL_PRODUCT_X220_X500D		0x0017
 #define ALCATEL_PRODUCT_L100V			0x011e
@@ -448,6 +463,32 @@ static void option_instat_callback(struct urb *urb);
 #define CELLIENT_VENDOR_ID			0x2692
 #define CELLIENT_PRODUCT_MEN200			0x9005
 
+/* Vtion Information Technology (Fujian) */
+#define VTION_VENDOR_ID			0x1E89
+#define VTION_PRODUCT_E1916		0x1E16 //evdo ???
+
+/* PuChuang WCDMA */
+#define PUCHUANG_VENDOR_ID			0x20A6
+#define PUCHUANG_PRODUCT_E003		0x1105 //wcdma
+
+/* JIN YU SHI KONG Communication,evdo */
+#define SRT_VENDOR_ID			0x1D09
+#define SRT_PRODUCT_SRTE800		0xAEF4 // evdo
+
+/* A100 ???,evdo */
+#define AXX_VENDOR_ID			0x21F5
+#define AXXT_PRODUCT_XXX		0x2008 // evdo
+
+/*shangshai ASB products*/
+#define ASB_VENDOR_ID			0x04cc
+#define ASB_PRODUCT_T920		0x226e
+#define ASB_PRODUCT_TU930			0x225a
+
+/*TechFaith products*/
+#define TechFaith_VENDOR_ID		0x1d09
+#define TechFaith_PRODUCT_HSDPA		0x1010
+#define TechFaith_PRODUCT_SRTE800	0xAEF4
+
 /* Hyundai Petatel Inc. products */
 #define PETATEL_VENDOR_ID			0x1ff4
 #define PETATEL_PRODUCT_NP10T			0x600e
@@ -703,7 +744,6 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x7B) },
 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x7C) },
 
-
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V640) },
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V620) },
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V740) },
@@ -813,6 +853,7 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0004, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0005, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0006, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0008, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0009, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x000a, 0xff, 0xff, 0xff) },
@@ -1242,6 +1283,7 @@ static const struct usb_device_id option_ids[] = {
   	},
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, ZOOM_PRODUCT_4597) },
 	{ USB_DEVICE(HAIER_VENDOR_ID, HAIER_PRODUCT_CE100) },
+	{ USB_DEVICE(VTION_VENDOR_ID, 0x1a20) },
 	/* Pirelli  */
 	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_C100_1)},
 	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_C100_2)},
@@ -1346,6 +1388,15 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_4COM2, 0xff, 0x02, 0x01) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_4COM2, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE(CELLIENT_VENDOR_ID, CELLIENT_PRODUCT_MEN200) },
+	{ USB_DEVICE(AXX_VENDOR_ID,   AXXT_PRODUCT_XXX)   },
+	{ USB_DEVICE(SRT_VENDOR_ID,   SRT_PRODUCT_SRTE800)},
+	{ USB_DEVICE(PUCHUANG_VENDOR_ID,PUCHUANG_PRODUCT_E003)},
+	{ USB_DEVICE(VTION_VENDOR_ID,   VTION_PRODUCT_E1916)   },
+	{ USB_DEVICE(QUALCOMM_VENDOR_ID,   QUALCOMM_ASB_C820)},
+	{ USB_DEVICE(ASB_VENDOR_ID, ASB_PRODUCT_T920) }, /*ASB T920 */
+	{ USB_DEVICE(ASB_VENDOR_ID, ASB_PRODUCT_TU930) }, /*ASB TU930 */
+	{ USB_DEVICE(TechFaith_VENDOR_ID,TechFaith_PRODUCT_HSDPA) },/*TechFaith WCDMA product*/
+	{ USB_DEVICE(TechFaith_VENDOR_ID,TechFaith_PRODUCT_SRTE800) },/*TechFaith WCDMA product*/	
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T) },
 	{ USB_DEVICE(TPLINK_VENDOR_ID, TPLINK_PRODUCT_MA180),
 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
@@ -1464,6 +1515,10 @@ static int option_probe(struct usb_serial *serial,
 		serial->interface->cur_altsetting->desc.bInterfaceClass != USB_CLASS_CDC_DATA)
 		return -ENODEV;
 
+	if (serial->dev->descriptor.idVendor == HUAWEI_VENDOR_ID) {
+		usb_enable_autosuspend(serial->dev);
+	}
+
 	data = serial->private = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
diff --git a/drivers/usb/storage/initializers.c b/drivers/usb/storage/initializers.c
index 105d900..657c986 100644
--- a/drivers/usb/storage/initializers.c
+++ b/drivers/usb/storage/initializers.c
@@ -95,6 +95,7 @@ int usb_stor_ucr61s2b_init(struct us_data *us)
 /* This places the HUAWEI E220 devices in multi-port mode */
 int usb_stor_huawei_e220_init(struct us_data *us)
 {
+#if 0
 	int result;
 
 	result = usb_stor_control_msg(us, us->send_ctrl_pipe,
@@ -103,4 +104,65 @@ int usb_stor_huawei_e220_init(struct us_data *us)
 				      0x01, 0x0, NULL, 0x0, 1000);
 	US_DEBUGP("Huawei mode set result is %d\n", result);
 	return 0;
+#else
+	printk("====usb_stor_huawei_e220_init===>\n");
+	return -ENODEV;
+#endif
+
+}
+
+//AC560--ZTE--	0x19d20026->0x19d20094	before convert to modem,don't report disk dev
+int usb_stor_ZTE_AC580_init(struct us_data *us) // PID = 0x0026
+{
+#if 0	
+	int result = 0;
+	int act_len = 0;
+
+	result = usb_stor_control_msg(us, us->send_ctrl_pipe,USB_REQ_CLEAR_FEATURE,
+		USB_TYPE_STANDARD | USB_RECIP_ENDPOINT,0x0, 0x89, NULL, 0x0, 1000);
+
+	US_DEBUGP("usb_stor_control_msg performing result is %d\n", result);
+	printk("====AC580/AC560===>usb_stor_control_msg performing result is %d\n", result);
+
+	result = usb_stor_control_msg(us, us->send_ctrl_pipe,USB_REQ_CLEAR_FEATURE,
+		USB_TYPE_STANDARD | USB_RECIP_ENDPOINT,0x0, 0x9, NULL, 0x0, 1000);
+
+	US_DEBUGP("usb_stor_control_msg performing result is %d\n", result);
+	printk("====AC580/AC560===>usb_stor_control_msg performing result is %d\n", result);
+	return (result ? 0 : -ENODEV);
+#else
+	return -ENODEV;
+#endif
+}
+
+//AC560--ZTE--	0x19d20026->0x19d20094	before convert to modem,don't report disk dev
+int usb_stor_ZTE_AC580_init2(struct us_data *us) // PID = 0x0026
+{
+	return -ENODEV;
+}
+
+int usb_stor_ASB_init(struct us_data *us)
+{
+	return -ENODEV;
+}
+
+int usb_stor_TechFaith_init(struct us_data *us)
+{
+	usb_stor_port_reset(us);
+	return -ENODEV;
+}
+
+int usb_stor_Shichuangxing_init(struct us_data *us)
+{
+	printk("====usb_stor_Shichuangxing_init===>\n");
+	return -ENODEV;
+}
+
+int usb_stor_wangxun_init(struct us_data *us)
+{
+	
+	printk("====usb_stor_wangxun_init===>\n");
+	usb_stor_port_reset(us);	
+	return -ENODEV;
+	
 }
diff --git a/drivers/usb/storage/initializers.h b/drivers/usb/storage/initializers.h
index 529327f..fa90a23 100644
--- a/drivers/usb/storage/initializers.h
+++ b/drivers/usb/storage/initializers.h
@@ -48,3 +48,10 @@ int usb_stor_ucr61s2b_init(struct us_data *us);
 
 /* This places the HUAWEI E220 devices in multi-port mode */
 int usb_stor_huawei_e220_init(struct us_data *us);
+
+int usb_stor_ZTE_AC580_init(struct us_data *us);
+int usb_stor_ZTE_AC580_init2(struct us_data *us);
+int usb_stor_ASB_init(struct us_data *us);
+int usb_stor_TechFaith_init(struct us_data *us);
+int usb_stor_Shichuangxing_init(struct us_data *us);
+int usb_stor_wangxun_init(struct us_data *us);
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 8ee632c..70bf4f7 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -768,6 +768,12 @@ UNUSUAL_DEV( 0x05ac, 0x120a, 0x0000, 0x9999,
  * Ignore driver CD mode and force into modem mode by default.
  */
 
+UNUSUAL_DEV(  0x05c6, 0x1000, 0x0000, 0x0000,
+		"HUAWEI MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
+		0),
+
 /* Globetrotter HSDPA; mass storage shows up as Qualcomm for vendor */
 UNUSUAL_DEV(  0x05c6, 0x1000, 0x0000, 0x9999,
 		"Option N.V.",
@@ -1852,6 +1858,183 @@ UNUSUAL_DEV(  0x12d1, 0x143F, 0x0000, 0x0000,
 		"Mass Storage",
 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
 		0),
+UNUSUAL_DEV(  0x12d1, 0x1446, 0x0000, 0x0000,
+		"HUAWEI MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
+		0),
+UNUSUAL_DEV(  0x12d1, 0x14ac, 0x0000, 0x0000,
+		"HUAWEI MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
+		0),
+UNUSUAL_DEV(  0x12d1, 0x1505, 0x0000, 0x0000,
+		"HUAWEI MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
+		0),
+UNUSUAL_DEV(  0x12d1, 0x1506, 0x0000, 0x0000,
+		"HUAWEI MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
+		0),
+UNUSUAL_DEV(  0x12d1, 0x1d09, 0x0100, 0x0100,
+		"HUAWEI MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
+		0),
+
+UNUSUAL_DEV(  0x12d1, 0x1da1, 0x0100, 0x0100,
+		"HUAWEI MOBILE-TD",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
+		0),
+
+
+UNUSUAL_DEV(  0x05c6, 0x6000, 0x0000, 0x0000,
+		"HUAWEI MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
+		0),
+//MU350--ZTE--	0x19D20003->0x19D20003	don't report disk device
+UNUSUAL_DEV(0x19D2,0x0003,0x0100,0x0100,
+		"ZTE MOBILE-TD",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init,
+		0),
+
+
+//A355--ZTE--	0x19D20120->0x19D20079	don't report disk device
+UNUSUAL_DEV(0x19D2,0x0120,0x0204  ,0x0204  ,
+		"ZTE MOBILE-TD",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_ZTE_AC580_init,
+		0),
+
+//A355--ZTE--	0x19D20120->0x19D20079	don't report disk device
+UNUSUAL_DEV(0x19D2,0x0079,0x0100  ,0x0100  ,
+		"ZTE MOBILE-TD",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_ZTE_AC580_init,
+		0),
+
+//TU930--GaoKeZhongtian--	0x04cc225a->0x04cc225a	don't report disk device
+UNUSUAL_DEV(0x04cc,0x225a,0x100,0x100,
+		"GaoKeZhongtian MOBILE-TD",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_ZTE_AC580_init,
+		0),
+
+//AC560--ZTE--	0x19d20026->0x19d20094	don't report disk device
+UNUSUAL_DEV(0x19D2,0x0026,0x0000,0x0000,
+		"ZTE MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init,
+		0),
+
+//MF626/MF633/MF110--ZTE--	0x19d22000->0x19d20031	don't report disk device
+UNUSUAL_DEV(0x19D2,0x0031,0x0000,0x0000,
+		"ZTE MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init2,
+		0),
+
+//AC560--ZTE--	0x19d20026->0x19d20094	don't report disk device
+UNUSUAL_DEV(0x19D2,0x0094,0x0000,0x0000,
+		"ZTE MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init2,
+		0),
+
+//AC560--ZTE--	0x19d20026->0x19d20152	don't report disk device
+UNUSUAL_DEV(0x19D2,0x0152,0x0000,0x0000,
+		"ZTE MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init2,
+		0),
+
+//MF626/MF633/MF110--ZTE--	0x19d22000->0x19d20031	don't report disk device
+UNUSUAL_DEV(0x19D2,0x2000,0x0000,0x0000,
+		"ZTE MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init,
+		0),
+
+//MF637U--ZTE--	don't report disk device
+UNUSUAL_DEV(0x19D2,0xf006,0x0000,0x0000,
+		"ZTE MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init2,
+		0),
+
+//MF637U--ZTE--	 ->0x19d2fff1	don't report disk device
+UNUSUAL_DEV(0x19D2,0xfff1,0x0000,0x0000,
+		"ZTE MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init2,
+		0),
+
+//AC2736/AC2746	don't report disk device
+UNUSUAL_DEV(0x19D2,0xfff5,0x0000,0x0000,
+		"ZTE MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ZTE_AC580_init2,
+		0),
+
+//shanghai ASB T920--ASB--don't report disk device
+UNUSUAL_DEV(0x04cc,0x226e,0x0100,0x0100,
+		"ASB MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_ASB_init,
+		0),
+
+//shanghai ASB C820--ASB--don't report disk device
+UNUSUAL_DEV(0x05c6,0x0010,0x00,0x00,
+		"ASB MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_ASB_init,
+		0),
+
+//shanghai ASB C820--ASB--don't report disk device
+UNUSUAL_DEV(0x05c6,0x00a0,0x00,0x00,
+		"ASB MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_ASB_init,
+		0),
+
+//TechFaith--don't report disk device
+UNUSUAL_DEV(0x1d09,0x1010,0x0,0x0,
+		"TechFaith MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_TechFaith_init,
+		0),
+//TechFaith--don't report disk device
+UNUSUAL_DEV(0x1d09,0x1000,0x0,0x0,
+		"TechFaith MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_TechFaith_init,
+		0),
+
+//wangxun--don't report disk device
+UNUSUAL_DEV(0x1e89,0x1e16,0x0,0x0,
+		"wangxun MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_wangxun_init,
+		0),
+
+//TechFaith--don't report disk device
+UNUSUAL_DEV(0x1e89,0x1a20,0x0,0x0,
+		"Shichuangxing MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_TechFaith_init,
+		0),
+
+//TechFaith--don't report disk device
+UNUSUAL_DEV(0x1e89,0xf000,0x0,0x0,
+		"Shichuangxing MOBILE",
+		"Mass Storage",
+		USB_SC_DEVICE,USB_PR_DEVICE,usb_stor_Shichuangxing_init,
+		0),
 
 /* Reported by Vilius Bilinkevicius <vilisas AT xxx DOT lt) */
 UNUSUAL_DEV(  0x132b, 0x000b, 0x0001, 0x0001,
diff --git a/drivers/usb/sunxi_usb/Kconfig b/drivers/usb/sunxi_usb/Kconfig
new file mode 100644
index 0000000..013441e
--- /dev/null
+++ b/drivers/usb/sunxi_usb/Kconfig
@@ -0,0 +1,71 @@
+#
+# softwinner SUNXI USB2.0 Dual Role Controller Driver.
+#
+
+#---------------------------------------------
+#-
+#- config USB2.0 Dual Role Controller.
+#-
+#---------------------------------------------
+menuconfig USB_SW_SUNXI_USB
+    boolean "SUNXI USB2.0 Dual Role Controller support"
+    depends on (ARCH_SUN4I || ARCH_SUN5I || ARCH_SUN7I) && USB_MUSB_SUNXI=n
+    help
+        SUNXI USB2.0 Dual Role Controller
+
+config USB_SW_SUNXI_USB_MANAGER
+    boolean "SUNXI USB2.0 Manager"
+    depends on USB_SW_SUNXI_USB
+    help
+        manager all usb controller.
+
+#---------------------------------------------
+#-
+#- usb0 mode select.
+#-
+#---------------------------------------------
+choice
+
+    prompt "USB0 Controller support"
+    depends on (USB_SW_SUNXI_USB && USB_SW_SUNXI_USB_MANAGER)
+    help
+        usb0 Controller mode select. choice "device only", then usb0 can only use for device.
+        choice "host only", then usb0 can only use for host. choice "OTG", then usb0 can only
+        use device and host.
+
+        For "device only" and "OTG" modes, you need CONFIG_USB_SW_SUNXI_UDC0, "SoftWinner
+        SUNXI USB Peripheral Controller", enabled under USB gadget config.
+
+config USB_SW_SUNXI_USB0_HOST_ONLY
+    boolean "host only support"
+    select USB_SW_SUNXI_HCD0
+    help
+        usb0 can only use for host.
+
+config USB_SW_SUNXI_USB0_OTG
+    boolean "otg support"
+    depends on USB_SW_SUNXI_UDC0
+    select USB_SW_SUNXI_HCD0
+    help
+        usb0 can only use for device and host.
+
+config USB_SW_SUNXI_USB0_DEVICE_ONLY
+    boolean "device only support"
+    depends on USB_SW_SUNXI_UDC0
+    help
+        usb0 can only use for device.
+
+config USB_SW_SUNXI_USB0_NULL
+    boolean "usb manager not support"
+    help
+        usb0 do not monitor hardware, then driver insmod should by application.
+
+
+
+endchoice
+
+config USB_SW_SUNXI_USB_DEBUG
+    tristate "SUNXI USB driver debug message"
+    depends on USB_SW_SUNXI_USB
+    help
+        SUNXI USB driver debug message.
diff --git a/drivers/usb/sunxi_usb/Makefile b/drivers/usb/sunxi_usb/Makefile
new file mode 100644
index 0000000..2cf7dd9
--- /dev/null
+++ b/drivers/usb/sunxi_usb/Makefile
@@ -0,0 +1,33 @@
+#
+# Makefile for SUNXI USB2.0 Dual Role Controller Driver.
+#
+
+sw_usbc-objs := usbc/usbc.o \
+                usbc/usbc_dev.o \
+                usbc/usbc_host.o \
+                usbc/usbc_phy.o \
+                misc/sw_usb_debug.o \
+                manager/usb_manager.o \
+                manager/usbc0_platform.o \
+                manager/usb_hcd_servers.o \
+                hcd/core/sw_hcd_core.o \
+                hcd/core/sw_hcd_host.o \
+                hcd/core/sw_hcd_virt_hub.o \
+                hcd/core/sw_hcd_debug.o \
+                hcd/core/sw_hcd_dma.o
+
+ifeq ($(CONFIG_USB_SW_SUNXI_USB0_OTG),y)
+	sw_usbc-objs += manager/usb_hw_scan.o manager/usb_msg_center.o
+endif
+
+obj-$(CONFIG_USB_SW_SUNXI_USB_MANAGER) += sw_usbc.o
+
+sw_usb_hcd0-objs := hcd/hcd0/sw_hcd0.o
+obj-$(CONFIG_USB_SW_SUNXI_HCD0) += sw_usb_hcd0.o
+
+sw_usb_udc-objs :=  udc/sw_udc.o \
+                    udc/sw_udc_board.o \
+                    udc/sw_udc_debug.o \
+                    udc/sw_udc_dma.o
+obj-$(CONFIG_USB_SW_SUNXI_UDC0) += sw_usb_udc.o
+
diff --git a/drivers/usb/sunxi_usb/hcd/core/sw_hcd_core.c b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_core.c
new file mode 100644
index 0000000..f8a8366
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_core.c
@@ -0,0 +1,1190 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/core/sw_hcd_core.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kobject.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include  "../include/sw_hcd_config.h"
+#include  "../include/sw_hcd_core.h"
+#include  "../include/sw_hcd_dma.h"
+
+/* for high speed test mode; see USB 2.0 spec 7.1.20 */
+static const u8 sw_hcd_test_packet[53] = {
+	/* implicit SYNC then DATA0 to start */
+
+	/* JKJKJKJK x9 */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* JJKKJJKK x8 */
+	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+	/* JJJJKKKK x8 */
+	0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,
+	/* JJJJJJJKKKKKKK x8 */
+	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	/* JJJJJJJK x8 */
+	0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd,
+	/* JKKKKKKK x10, JK */
+	0xfc, 0x7e, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0x7e
+
+	/* implicit CRC16 then EOP to end */
+};
+
+/*
+ * Interrupt Service Routine to record USB "global" interrupts.
+ * Since these do not happen often and signify things of
+ * paramount importance, it seems OK to check them individually;
+ * the order of the tests is specified in the manual
+ *
+ * @param sw_hcd instance pointer
+ * @param int_usb register contents
+ * @param devctl
+ * @param power
+ */
+
+#define STAGE0_MASK ((1 << USBC_BP_INTUSB_RESUME) \
+                    | (1 << USBC_BP_INTUSB_SESSION_REQ) \
+            		| (1 << USBC_BP_INTUSB_VBUS_ERROR) \
+            		| (1 << USBC_BP_INTUSB_CONNECT) \
+            		| (1 << USBC_BP_INTUSB_RESET) \
+            		| (1 << USBC_BP_INTUSB_SOF))
+
+/*
+*******************************************************************************
+*                     sw_hcd_write_fifo
+*
+* Description:
+*    Load an endpoint's FIFO
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_write_fifo(struct sw_hcd_hw_ep *hw_ep, u16 len, const u8 *src)
+{
+	void __iomem *fifo = hw_ep->fifo;
+	__u32 old_ep_index = 0;
+
+	prefetch((u8 *)src);
+
+	DMSG_DBG_HCD("sw_hcd_write_fifo: %cX ep%d fifo %p count %d buf %p\n",
+			     'T', hw_ep->epnum, fifo, len, src);
+
+	old_ep_index = USBC_GetActiveEp(hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_SelectActiveEp(hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, hw_ep->epnum);
+
+	/* we can't assume unaligned reads work */
+	if (likely((0x01 & (unsigned long) src) == 0)) {
+		u16	index = 0;
+
+		/* best case is 32bit-aligned source address */
+		if ((0x02 & (unsigned long) src) == 0) {
+			if (len >= 4) {
+				sw_hcd_writesl(fifo, src + index, len >> 2);
+				index += len & ~0x03;
+			}
+
+			if (len & 0x02) {
+				USBC_Writew(*(u16 *)&src[index], fifo);
+				index += 2;
+			}
+		} else {
+			if (len >= 2) {
+				sw_hcd_writesw(fifo, src + index, len >> 1);
+				index += len & ~0x01;
+			}
+		}
+
+		if (len & 0x01) {
+			USBC_Writeb(src[index], fifo);
+		}
+	} else  {
+		/* byte aligned */
+		sw_hcd_writesb(fifo, src, len);
+	}
+
+	USBC_SelectActiveEp(hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, old_ep_index);
+
+	return;
+}
+EXPORT_SYMBOL(sw_hcd_write_fifo);
+
+/*
+*******************************************************************************
+*                     sw_hcd_read_fifo
+*
+* Description:
+*    Unload an endpoint's FIFO
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_read_fifo(struct sw_hcd_hw_ep *hw_ep, u16 len, u8 *dst)
+{
+	void __iomem *fifo = hw_ep->fifo;
+	__u32 old_ep_index = 0;
+
+	DMSG_DBG_HCD("sw_hcd_read_fifo: %cX ep%d fifo %p count %d buf %p\n",
+			    'R', hw_ep->epnum, fifo, len, dst);
+
+	old_ep_index = USBC_GetActiveEp(hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_SelectActiveEp(hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, hw_ep->epnum);
+
+	/* we can't assume unaligned writes work */
+	if (likely((0x01 & (unsigned long) dst) == 0)) {
+		u16	index = 0;
+
+		/* best case is 32bit-aligned destination address */
+		if ((0x02 & (unsigned long) dst) == 0) {
+			if (len >= 4) {
+				sw_hcd_readsl(fifo, dst, len >> 2);
+				index = len & ~0x03;
+			}
+			if (len & 0x02) {
+				*(u16 *)&dst[index] = USBC_Readw(fifo);
+				index += 2;
+			}
+		} else {
+			if (len >= 2) {
+				sw_hcd_readsw(fifo, dst, len >> 1);
+				index = len & ~0x01;
+			}
+		}
+
+		if(len & 0x01){
+			dst[index] = USBC_Readb(fifo);
+		}
+	} else  {
+		/* byte aligned */
+		sw_hcd_readsb(fifo, dst, len);
+	}
+
+	USBC_SelectActiveEp(hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, old_ep_index);
+
+	return;
+}
+EXPORT_SYMBOL(sw_hcd_read_fifo);
+
+/*
+*******************************************************************************
+*                     sw_hcd_load_testpacket
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_load_testpacket(struct sw_hcd *sw_hcd)
+{
+	void __iomem *usbc_base = sw_hcd->endpoints[0].regs;
+
+	sw_hcd_ep_select(sw_hcd->mregs, 0);
+
+	sw_hcd_write_fifo(sw_hcd->control_ep, sizeof(sw_hcd_test_packet), sw_hcd_test_packet);
+
+	USBC_Writew(USBC_BP_CSR0_H_TxPkRdy, USBC_REG_CSR0(usbc_base));
+
+	return;
+}
+EXPORT_SYMBOL(sw_hcd_load_testpacket);
+
+/*
+*******************************************************************************
+*                     sw_hcd_start
+*
+* Description:
+*    Program the to start (enable interrupts, dma, etc.).
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_start(struct sw_hcd *sw_hcd)
+{
+	void __iomem    *usbc_base  = NULL;
+	u8              devctl      = 0;
+
+    /* check argment */
+    if(sw_hcd == NULL){
+        DMSG_PANIC("ERR: invalid argment\n");
+	    return ;
+    }
+
+    sw_hcd->is_active = 0;
+
+	if(!sw_hcd->enable){
+		DMSG_INFO("wrn: hcd is not enable, need not start hcd\n");
+		return;
+	}
+
+    /* initialize parameter */
+    usbc_base = sw_hcd->mregs;
+
+    DMSG_DBG_HCD("sw_hcd_start: devctl = 0x%x, epmask = 0x%x\n",
+		         USBC_Readb(USBC_REG_DEVCTL(usbc_base)), sw_hcd->epmask);
+
+	/*  Set INT enable registers, enable interrupts */
+	USBC_Writew(sw_hcd->epmask, USBC_REG_INTTxE(usbc_base));
+	USBC_Writew((sw_hcd->epmask & 0xfe), USBC_REG_INTRxE(usbc_base));
+	USBC_Writeb(0xff, USBC_REG_INTUSBE(usbc_base));
+
+    USBC_Writeb(0x00, USBC_REG_TMCTL(usbc_base));
+
+	/* put into basic highspeed mode and start session */
+    USBC_Writeb((1 << USBC_BP_POWER_H_HIGH_SPEED_EN), USBC_REG_PCTL(usbc_base));
+
+    devctl = USBC_Readb(USBC_REG_DEVCTL(usbc_base));
+	devctl &= ~(1 << USBC_BP_DEVCTL_SESSION);
+	USBC_Writeb(devctl, USBC_REG_DEVCTL(usbc_base));
+
+	USBC_SelectBus(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_IO_TYPE_PIO, 0, 0);
+
+	/* assume ID pin is hard-wired to ground */
+	sw_hcd_platform_enable(sw_hcd);
+
+	/* port power on */
+	sw_hcd_set_vbus(sw_hcd, 1);
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_start);
+
+/*
+*******************************************************************************
+*                     sw_hcd_generic_disable
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_generic_disable(struct sw_hcd *sw_hcd)
+{
+	void __iomem    *usbc_base  = sw_hcd->mregs;
+
+	/* disable interrupts */
+	USBC_Writeb(0x00, USBC_REG_INTUSBE(usbc_base));
+	USBC_Writew(0x00, USBC_REG_INTTxE(usbc_base));
+	USBC_Writew(0x00, USBC_REG_INTRxE(usbc_base));
+
+	/* off */
+	USBC_Writew(0x00, USBC_REG_DEVCTL(usbc_base));
+
+	/*  flush pending interrupts */
+	USBC_Writeb(0xff, USBC_REG_INTUSB(usbc_base));
+	USBC_Writew(0x3f, USBC_REG_INTTx(usbc_base));
+	USBC_Writew(0x3f, USBC_REG_INTRx(usbc_base));
+
+	return;
+}
+EXPORT_SYMBOL(sw_hcd_generic_disable);
+
+/*
+*******************************************************************************
+*                     sw_hcd_stop
+*
+* Description:
+*    Make the stop (disable interrupts, etc.);
+* reversible by sw_hcd_start called on gadget driver unregister
+* with controller locked, irqs blocked
+* acts as a NOP unless some role activated the hardware
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_stop(struct sw_hcd *sw_hcd)
+{
+	if(!sw_hcd->enable){
+		DMSG_INFO("wrn: hcd is not enable, need not stop hcd\n");
+		return;
+	}
+
+	/* stop IRQs, timers, ... */
+	sw_hcd_platform_disable(sw_hcd);
+	sw_hcd_generic_disable(sw_hcd);
+
+	DMSG_INFO("sw_hcd_stop: sw_hcd disabled\n");
+
+	/* FIXME
+	 *  - mark host and/or peripheral drivers unusable/inactive
+	 *  - disable DMA (and enable it in sw_hcd Start)
+	 *  - make sure we can sw_hcd_start() after sw_hcd_stop(); with
+	 *    OTG mode, gadget driver module rmmod/modprobe cycles that
+	 *  - ...
+	 */
+	sw_hcd_platform_try_idle(sw_hcd, 0);
+
+	return;
+}
+EXPORT_SYMBOL(sw_hcd_stop);
+
+/*
+*******************************************************************************
+*                     sw_hcd_platform_try_idle
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_platform_try_idle(struct sw_hcd *sw_hcd, unsigned long timeout)
+{
+
+}
+EXPORT_SYMBOL(sw_hcd_platform_try_idle);
+
+/*
+*******************************************************************************
+*                     sw_hcd_platform_enable
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_platform_enable(struct sw_hcd *sw_hcd)
+{
+
+}
+EXPORT_SYMBOL(sw_hcd_platform_enable);
+
+/*
+*******************************************************************************
+*                     sw_hcd_platform_disable
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_platform_disable(struct sw_hcd *sw_hcd)
+{
+
+}
+EXPORT_SYMBOL(sw_hcd_platform_disable);
+
+/*
+*******************************************************************************
+*                     sw_hcd_platform_set_mode
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_platform_set_mode(struct sw_hcd *sw_hcd, u8 sw_hcd_mode)
+{
+	DMSG_PANIC("ERR: sw_hcd_platform_set_mode not support\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_hcd_platform_set_mode);
+
+/*
+*******************************************************************************
+*                     sw_hcd_platform_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_platform_init(struct sw_hcd *sw_hcd)
+{
+	USBC_EnhanceSignal(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_EnableDpDmPullUp(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+    USBC_EnableIdPullUp(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_ForceId(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_ID_TYPE_HOST);
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_hcd_platform_init);
+
+/*
+*******************************************************************************
+*                     sw_hcd_platform_suspend
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_platform_suspend(struct sw_hcd *sw_hcd)
+{
+	DMSG_PANIC("ERR: sw_hcd_platform_suspend not support\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_hcd_platform_suspend);
+
+/*
+*******************************************************************************
+*                     sw_hcd_platform_resume
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_platform_resume(struct sw_hcd *sw_hcd)
+{
+	DMSG_PANIC("ERR: sw_hcd_platform_resume not support\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_hcd_platform_resume);
+
+/*
+*******************************************************************************
+*                     sw_hcd_platform_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_platform_exit(struct sw_hcd *sw_hcd)
+{
+	USBC_DisableDpDmPullUp(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+    USBC_DisableIdPullUp(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_ForceId(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_ID_TYPE_DISABLE);
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_hcd_platform_exit);
+
+/* "modprobe ... use_dma=0" etc */
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_completion
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_dma_completion(struct sw_hcd *sw_hcd, u8 epnum, u8 transmit)
+{
+	u8	devctl = USBC_Readb(USBC_REG_DEVCTL(sw_hcd->mregs));
+
+	/* called with controller lock already held */
+
+	if (!epnum) {
+        DMSG_PANIC("ERR: sw_hcd_dma_completion, not support ep0\n");
+	} else {
+		/* endpoints 1..15 */
+		if (transmit) {
+			if (devctl & (1 << USBC_BP_DEVCTL_HOST_MODE)) {
+				if (is_host_capable()) {
+					sw_hcd_host_tx(sw_hcd, epnum);
+				}
+			}
+		} else {
+			/* receive */
+			if (devctl & (1 << USBC_BP_DEVCTL_HOST_MODE)) {
+				if (is_host_capable()) {
+					sw_hcd_host_rx(sw_hcd, epnum);
+				}
+			}
+		}
+	}
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_dma_completion);
+/*
+*******************************************************************************
+*                     sw_hcd_soft_disconnect
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_soft_disconnect(struct sw_hcd *sw_hcd)
+{
+	DMSG_INFO("-------sw_hcd%d_soft_disconnect---------\n", sw_hcd->usbc_no);
+
+	usb_hcd_resume_root_hub(sw_hcd_to_hcd(sw_hcd));
+	sw_hcd_root_disconnect(sw_hcd);
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_stage0_irq
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static irqreturn_t sw_hcd_stage0_irq(struct sw_hcd *sw_hcd, u8 int_usb, u8 devctl, u8 power)
+{
+	irqreturn_t handled = IRQ_NONE;
+	void __iomem *usbc_base = sw_hcd->mregs;
+
+	DMSG_DBG_HCD("sw_hcd_stage0_irq: Power=%02x, DevCtl=%02x, int_usb=0x%x\n", power, devctl, int_usb);
+
+	if(int_usb & (1 << USBC_BP_INTUSB_SOF)){
+		//DMSG_INFO("\n\n------------IRQ SOF-------------\n\n");
+
+		USBC_INT_ClearMiscPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_SOF));
+
+		USBC_INT_DisableUsbMiscUint(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_SOF));
+	}
+
+	/* in host mode, the peripheral may issue remote wakeup.
+	 * in peripheral mode, the host may resume the link.
+	 * spurious RESUME irqs happen too, paired with SUSPEND.
+	 */
+	if (int_usb & (1 << USBC_BP_INTUSB_RESUME)) {
+		DMSG_INFO("\n------------IRQ RESUME-------------\n\n");
+
+		USBC_INT_ClearMiscPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_RESUME));
+
+		handled = IRQ_HANDLED;
+
+		if (devctl & (1 << USBC_BP_DEVCTL_HOST_MODE)) {
+			if (power & (1 << USBC_BP_POWER_H_SUSPEND)) {
+				/* spurious */
+				sw_hcd->int_usb &= ~(1 << USBC_BP_INTUSBE_EN_SUSPEND);
+
+				DMSG_INFO("sw_hcd_stage0_irq, Spurious SUSPENDM\n");
+
+				//break;
+			}
+
+			power &= ~(1 << USBC_BP_POWER_H_SUSPEND);
+			power |= (1 << USBC_BP_POWER_H_RESUME);
+			USBC_Writeb(power, USBC_REG_PCTL(usbc_base));
+
+			sw_hcd->port1_status |= (USB_PORT_STAT_C_SUSPEND << 16) | SW_HCD_PORT_STAT_RESUME;
+			sw_hcd->rh_timer = jiffies + msecs_to_jiffies(20);
+			sw_hcd->is_active = 1;
+			usb_hcd_resume_root_hub(sw_hcd_to_hcd(sw_hcd));
+		} else {
+				usb_hcd_resume_root_hub(sw_hcd_to_hcd(sw_hcd));
+		}
+    }
+
+	/* see manual for the order of the tests */
+	if (int_usb & (1 << USBC_BP_INTUSB_SESSION_REQ)) {
+		DMSG_INFO("\n------------IRQ SESSION_REQ-------------\n\n");
+
+		USBC_INT_ClearMiscPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_SESSION_REQ));
+
+        /* power down */
+        devctl = USBC_Readb(USBC_REG_DEVCTL(usbc_base));
+    	devctl &= ~(1 << USBC_BP_DEVCTL_SESSION);
+    	USBC_Writeb(devctl, USBC_REG_DEVCTL(usbc_base));
+
+        USBC_ForceVbusValid(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_VBUS_TYPE_LOW);
+
+        sw_hcd_set_vbus(sw_hcd, 0);
+
+        /* delay */
+        mdelay(100);
+
+        /* power on */
+        devctl = USBC_Readb(USBC_REG_DEVCTL(usbc_base));
+    	devctl |= (1 << USBC_BP_DEVCTL_SESSION);
+    	USBC_Writeb(devctl, USBC_REG_DEVCTL(usbc_base));
+
+        USBC_ForceVbusValid(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_VBUS_TYPE_HIGH);
+
+        sw_hcd_set_vbus(sw_hcd, 1);
+
+		sw_hcd->ep0_stage = SW_HCD_EP0_START;
+
+		handled = IRQ_HANDLED;
+	}
+
+	if (int_usb & (1 << USBC_BP_INTUSB_VBUS_ERROR)) {
+		int	ignore = 0;
+
+		DMSG_INFO("\n------------IRQ VBUS_ERROR-------------\n\n");
+
+		USBC_INT_ClearMiscPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_VBUS_ERROR));
+
+        /* recovery is dicey once we've gotten past the
+		 * initial stages of enumeration, but if VBUS
+		 * stayed ok at the other end of the link, and
+		 * another reset is due (at least for high speed,
+		 * to redo the chirp etc), it might work OK...
+		 */
+		if (sw_hcd->vbuserr_retry) {
+			sw_hcd->vbuserr_retry--;
+			ignore  = 1;
+
+			devctl |= (1 << USBC_BP_DEVCTL_SESSION);
+			USBC_Writeb(devctl, USBC_REG_DEVCTL(usbc_base));
+		} else {
+			sw_hcd->port1_status |= (1 << USB_PORT_FEAT_OVER_CURRENT)
+				               | (1 << USB_PORT_FEAT_C_OVER_CURRENT);
+		}
+
+        /* go through A_WAIT_VFALL then start a new session */
+		if (!ignore){
+			sw_hcd_set_vbus(sw_hcd, 0);
+			sw_hcd->ep0_stage = SW_HCD_EP0_START;
+		}
+
+		handled = IRQ_HANDLED;
+    }
+
+	if (int_usb & (1 << USBC_BP_INTUSB_CONNECT)) {
+		struct usb_hcd *hcd = sw_hcd_to_hcd(sw_hcd);
+
+		DMSG_INFO("\n------------IRQ CONNECT-------------\n\n");
+		set_hcd0_connect_status(1);
+		USBC_INT_ClearMiscPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_CONNECT));
+
+		handled = IRQ_HANDLED;
+		sw_hcd->is_active = 1;
+
+		sw_hcd->ep0_stage = SW_HCD_EP0_START;
+
+        sw_hcd->port1_status &= ~(USB_PORT_STAT_LOW_SPEED
+        					|USB_PORT_STAT_HIGH_SPEED
+        					|USB_PORT_STAT_ENABLE
+        					);
+		sw_hcd->port1_status |= USB_PORT_STAT_CONNECTION
+					        |(USB_PORT_STAT_C_CONNECTION << 16);
+
+        /* high vs full speed is just a guess until after reset */
+		if (devctl & (1 << USBC_BP_DEVCTL_LS_DEV)){
+			sw_hcd->port1_status |= USB_PORT_STAT_LOW_SPEED;
+		}
+
+		if(hcd->status_urb){
+			usb_hcd_poll_rh_status(hcd);
+		}else{
+			usb_hcd_resume_root_hub(hcd);
+		}
+
+		SW_HCD_HST_MODE(sw_hcd);
+    }
+
+	/* mentor saves a bit: bus reset and babble share the same irq.
+	 * only host sees babble; only peripheral sees bus reset.
+	 */
+	if (int_usb & (1 << USBC_BP_INTUSB_RESET)) {
+	    DMSG_INFO("\n------------IRQ Reset or Babble-------------\n\n");
+
+		USBC_INT_ClearMiscPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_RESET));
+
+        //babbledisconnect
+		USBC_Host_SetFunctionAddress_Deafult(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX, 0);
+		{
+		    u32 i = 1;
+
+			for( i = 1 ; i <= 5; i++){
+				USBC_Host_SetFunctionAddress_Deafult(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX, i);
+				USBC_Host_SetFunctionAddress_Deafult(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_RX, i);
+			}
+		}
+
+		/* , hub,  */
+		USBC_INT_ClearMiscPendingAll(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+		USBC_INT_ClearEpPendingAll(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX);
+		USBC_INT_ClearEpPendingAll(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+        /* power down */
+        devctl = USBC_Readb(USBC_REG_DEVCTL(usbc_base));
+    	devctl &= ~(1 << USBC_BP_DEVCTL_SESSION);
+    	USBC_Writeb(devctl, USBC_REG_DEVCTL(usbc_base));
+
+        USBC_ForceVbusValid(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_VBUS_TYPE_LOW);
+
+        sw_hcd_set_vbus(sw_hcd, 0);
+
+        /* delay */
+        mdelay(100);
+
+        /* power on */
+        devctl = USBC_Readb(USBC_REG_DEVCTL(usbc_base));
+    	devctl |= (1 << USBC_BP_DEVCTL_SESSION);
+    	USBC_Writeb(devctl, USBC_REG_DEVCTL(usbc_base));
+
+        USBC_ForceVbusValid(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_VBUS_TYPE_HIGH);
+
+        sw_hcd_set_vbus(sw_hcd, 1);
+
+        /* disconnect */
+		sw_hcd->ep0_stage = SW_HCD_EP0_START;
+		usb_hcd_resume_root_hub(sw_hcd_to_hcd(sw_hcd));
+		sw_hcd_root_disconnect(sw_hcd);
+
+	    handled = IRQ_HANDLED;
+    }
+
+    schedule_work(&sw_hcd->irq_work);
+
+	return handled;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_stage2_irq
+*
+* Description:
+*    Interrupt Service Routine to record USB "global" interrupts.
+* Since these do not happen often and signify things of
+* paramount importance, it seems OK to check them individually;
+* the order of the tests is specified in the manual
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static irqreturn_t sw_hcd_stage2_irq(struct sw_hcd *sw_hcd,
+                                   u8 int_usb,
+                                   u8 devctl,
+                                   u8 power)
+{
+	irqreturn_t handled = IRQ_NONE;
+
+	if ((int_usb & (1 << USBC_BP_INTUSB_DISCONNECT)) && !sw_hcd->ignore_disconnect) {
+		DMSG_INFO("\n------------IRQ DISCONNECT-------------\n\n");
+		set_hcd0_connect_status(0);
+		USBC_INT_ClearMiscPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_DISCONNECT));
+
+		handled = IRQ_HANDLED;
+
+		usb_hcd_resume_root_hub(sw_hcd_to_hcd(sw_hcd));
+		sw_hcd_root_disconnect(sw_hcd);
+
+        schedule_work(&sw_hcd->irq_work);
+    }
+
+	if (int_usb & (1 << USBC_BP_INTUSB_SUSPEND)) {
+		DMSG_INFO("\n------------IRQ SUSPEND-------------\n\n");
+
+		USBC_INT_ClearMiscPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, (1 << USBC_BP_INTUSB_SUSPEND));
+
+		handled = IRQ_HANDLED;
+
+        /* "should not happen" */
+        sw_hcd->is_active = 0;
+
+        schedule_work(&sw_hcd->irq_work);
+    }
+
+    return handled;
+}
+
+
+/*
+*******************************************************************************
+*                     sw_hcd_interrupt
+*
+* Description:
+*    handle all the irqs defined by the sw_hcd core. for now we expect:  other
+* irq sources //(phy, dma, etc) will be handled first, sw_hcd->int_* values
+* will be assigned, and the irq will already have been acked.
+*
+* called in irq context with spinlock held, irqs blocked
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static irqreturn_t sw_hcd_interrupt(struct sw_hcd *sw_hcd)
+{
+	irqreturn_t     retval      = IRQ_NONE;
+	u8              devctl      = 0;
+	u8              power       = 0;
+	int             ep_num      = 0;
+	u32             reg         = 0;
+	void __iomem    *usbc_base  = NULL;
+
+    /* check argment */
+    if(sw_hcd == NULL){
+        DMSG_PANIC("ERR: invalid argment\n");
+	    return IRQ_NONE;
+    }
+
+    /* initialize parameter */
+    usbc_base   = sw_hcd->mregs;
+
+	devctl = USBC_Readb(USBC_REG_DEVCTL(usbc_base));
+	power  = USBC_Readb(USBC_REG_PCTL(usbc_base));
+
+	DMSG_DBG_HCD("irq: (0x%x, 0x%x, 0x%x)\n", sw_hcd->int_usb, sw_hcd->int_tx, sw_hcd->int_rx);
+
+	/* the core can interrupt us for multiple reasons; docs have
+	 * a generic interrupt flowchart to follow
+	 */
+	if (sw_hcd->int_usb & STAGE0_MASK){
+		retval |= sw_hcd_stage0_irq(sw_hcd, sw_hcd->int_usb, devctl, power);
+    }
+
+	/* "stage 1" is handling endpoint irqs */
+
+	/* handle endpoint 0 first */
+	if (sw_hcd->int_tx & 1) {
+		USBC_INT_ClearEpPending(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX, 0);
+
+		retval |= sw_hcd_h_ep0_irq(sw_hcd);
+	}
+
+	/* RX on endpoints 1-15 */
+	reg = sw_hcd->int_rx >> 1;
+	ep_num = 1;
+	while (reg) {
+		if (reg & 1) {
+			USBC_INT_ClearEpPending(sw_hcd->sw_hcd_io->usb_bsp_hdle,
+				                    USBC_EP_TYPE_RX,
+				                    ep_num);
+
+			/* sw_hcd_ep_select(sw_hcd->mregs, ep_num); */
+			/* REVISIT just retval = ep->rx_irq(...) */
+			retval = IRQ_HANDLED;
+			if (devctl & (1 << USBC_BP_DEVCTL_HOST_MODE)) {
+				if (is_host_capable()){
+					sw_hcd_host_rx(sw_hcd, ep_num);
+				}
+			}
+		}
+
+		reg >>= 1;
+		ep_num++;
+	}
+
+	/* TX on endpoints 1-15 */
+	reg = sw_hcd->int_tx >> 1;
+	ep_num = 1;
+	while (reg) {
+		if (reg & 1) {
+			USBC_INT_ClearEpPending(sw_hcd->sw_hcd_io->usb_bsp_hdle,
+		                    		USBC_EP_TYPE_TX,
+		                    		ep_num);
+
+			/* sw_hcd_ep_select(sw_hcd->mregs, ep_num); */
+			/* REVISIT just retval |= ep->tx_irq(...) */
+			retval = IRQ_HANDLED;
+			if (devctl & (1 << USBC_BP_DEVCTL_HOST_MODE)) {
+				if (is_host_capable()) {
+					sw_hcd_host_tx(sw_hcd, ep_num);
+				}
+			}
+		}
+
+		reg >>= 1;
+		ep_num++;
+	}
+
+	/* finish handling "global" interrupts after handling fifos */
+	if(sw_hcd->int_usb){
+		retval |= sw_hcd_stage2_irq(sw_hcd, sw_hcd->int_usb, devctl, power);
+	}
+
+	return retval;
+}
+
+/*
+*******************************************************************************
+*                     clear_all_irq
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void clear_all_irq(struct sw_hcd *sw_hcd)
+{
+    USBC_INT_ClearEpPendingAll(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX);
+    USBC_INT_ClearEpPendingAll(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_RX);
+    USBC_INT_ClearMiscPendingAll(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+}
+
+/*
+*******************************************************************************
+*                     generic_interrupt
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+irqreturn_t generic_interrupt(int irq, void *__hci)
+{
+	unsigned long   flags       = 0;
+	irqreturn_t     retval      = IRQ_NONE;
+	struct sw_hcd     *sw_hcd       = NULL;
+	void __iomem    *usbc_base  = NULL;
+
+    /* check argment */
+    if(__hci == NULL){
+        DMSG_PANIC("ERR: invalid argment\n");
+	    return IRQ_NONE;
+    }
+
+    /* initialize parameter */
+    sw_hcd        = (struct sw_hcd *)__hci;
+    usbc_base   = sw_hcd->mregs;
+
+	/* host role must be active */
+	if (!sw_hcd->enable){
+	    DMSG_PANIC("ERR: usb generic_interrupt, host is not enable\n");
+		clear_all_irq(sw_hcd);
+		return IRQ_NONE;
+    }
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+
+	sw_hcd->int_usb = USBC_Readb(USBC_REG_INTUSB(usbc_base));
+	sw_hcd->int_tx  = USBC_Readb(USBC_REG_INTTx(usbc_base));
+	sw_hcd->int_rx  = USBC_Readb(USBC_REG_INTRx(usbc_base));
+
+	if (sw_hcd->int_usb || sw_hcd->int_tx || sw_hcd->int_rx){
+		retval = sw_hcd_interrupt(sw_hcd);
+	}
+
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	/* REVISIT we sometimes get spurious IRQs on g_ep0
+	 * not clear why...
+	 */
+	if (retval != IRQ_HANDLED){
+		DMSG_INFO("spurious?\n");
+    }
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(generic_interrupt);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/usb/sunxi_usb/hcd/core/sw_hcd_debug.c b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_debug.c
new file mode 100644
index 0000000..4b4ec0d
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_debug.c
@@ -0,0 +1,160 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/core/sw_hcd_debug.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include  "../include/sw_hcd_config.h"
+#include  "../include/sw_hcd_debug.h"
+
+/*
+*******************************************************************************
+*                     print_sw_hcd_config
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void print_sw_hcd_config(struct sw_hcd_config *config, char *str)
+{
+#ifdef SW_HCD_DEBUG
+
+    DMSG_INFO("\n");
+    DMSG_INFO("------------------------------%s--------------------------\n", str);
+
+    DMSG_INFO("multipoint       = %d\n", config->multipoint);
+    DMSG_INFO("dyn_fifo         = %d\n", config->dyn_fifo);
+    DMSG_INFO("soft_con         = %d\n", config->soft_con);
+    DMSG_INFO("utm_16           = %d\n", config->utm_16);
+    DMSG_INFO("big_endian       = %d\n", config->big_endian);
+    DMSG_INFO("mult_bulk_tx     = %d\n", config->mult_bulk_tx);
+    DMSG_INFO("mult_bulk_rx     = %d\n", config->mult_bulk_rx);
+    DMSG_INFO("high_iso_tx      = %d\n", config->high_iso_tx);
+    DMSG_INFO("high_iso_rx      = %d\n", config->high_iso_rx);
+    DMSG_INFO("dma              = %d\n", config->dma);
+    DMSG_INFO("vendor_req       = %d\n", config->vendor_req);
+    DMSG_INFO("num_eps          = %d\n", config->num_eps);
+    DMSG_INFO("dma_channels     = %d\n", config->dma_channels);
+    DMSG_INFO("dyn_fifo_size    = %d\n", config->dyn_fifo_size);
+    DMSG_INFO("vendor_ctrl      = %d\n", config->vendor_ctrl);
+    DMSG_INFO("vendor_stat      = %d\n", config->vendor_stat);
+    DMSG_INFO("dma_req_chan     = %d\n", config->dma_req_chan);
+    DMSG_INFO("ram_size         = %d\n", config->ram_size);
+
+    DMSG_INFO("eps_bits->name   = %s\n", config->eps_bits->name);
+    DMSG_INFO("eps_bits->bits   = %d\n", config->eps_bits->bits);
+
+    DMSG_INFO("\n");
+
+	return;
+#endif
+}
+
+/*
+*******************************************************************************
+*                     print_sw_hcd_config
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void print_sw_hcd_list(struct list_head *list_head, char *str)
+{
+#ifdef SW_HCD_DEBUG
+
+	struct list_head *list_now = NULL;
+	struct list_head *list_next = NULL;
+
+	if(list_head == NULL){
+		DMSG_PANIC("ERR: invalid argment\n");
+		return;
+	}
+
+	if(list_empty(list_head) || list_head->next == NULL){
+		DMSG_PANIC("ERR: list is empty\n");
+		return;
+	}
+
+	list_now = list_head->next;
+
+	while(list_now != list_head){
+		list_next = list_now->next;
+
+		DMSG_INFO("[%s]: list_now = 0x%p, next = 0x%p, prev = 0x%p, list_head = 0x%p\n",
+			      str, list_now, list_now->next, list_now->prev, list_head);
+
+		list_now = list_next;
+	}
+
+	return;
+#endif
+}
+
+/*
+*******************************************************************************
+*                     print_urb_list
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void print_urb_list(struct usb_host_endpoint *hep, char *str)
+{
+	struct urb *urb_temp = NULL;
+
+	list_for_each_entry (urb_temp, &hep->urb_list,  urb_list) {
+		DMSG_INFO("[%s]: urb_temp(0x%p, %d, %d, %d)\n",
+			      str,
+			      urb_temp, urb_temp->transfer_buffer_length,
+			      urb_temp->actual_length, urb_temp->status);
+	}
+}
+
diff --git a/drivers/usb/sunxi_usb/hcd/core/sw_hcd_dma.c b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_dma.c
new file mode 100644
index 0000000..6ebc732
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_dma.c
@@ -0,0 +1,537 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/core/sw_hcd_dma.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include  "../include/sw_hcd_core.h"
+#include  "../include/sw_hcd_dma.h"
+#include <asm/cacheflush.h>
+
+#ifdef SW_HCD_DMA
+
+extern void sw_hcd_dma_completion(struct sw_hcd *sw_hcd, u8 epnum, u8 transmit);
+
+static void hcd_CleanFlushDCacheRegion(void *adr, __u32 bytes)
+{
+	__cpuc_flush_dcache_area(adr, bytes + (1 << 5) * 2 - 2);
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_switch_bus_to_dma
+*
+* Description:
+*     USB  DMA
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_switch_bus_to_dma(struct sw_hcd_qh *qh, u32 is_in)
+{
+	DMSG_DBG_DMA("sw_hcd_switch_bus_to_dma\n");
+
+	if(is_in){ /* ep in, rx */
+		USBC_SelectBus(qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle,
+			           USBC_IO_TYPE_DMA,
+			           USBC_EP_TYPE_RX,
+			           qh->hw_ep->epnum);
+	}else{  /* ep out, tx */
+		USBC_SelectBus(qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle,
+					   USBC_IO_TYPE_DMA,
+					   USBC_EP_TYPE_TX,
+					   qh->hw_ep->epnum);
+	}
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_switch_bus_to_dma);
+
+/*
+*******************************************************************************
+*                     sw_hcd_switch_bus_to_pio
+*
+* Description:
+*     USB  PIO
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_switch_bus_to_pio(struct sw_hcd_qh *qh, __u32 is_in)
+{
+	DMSG_DBG_DMA("sw_hcd_switch_bus_to_pio\n");
+
+	USBC_SelectBus(qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_IO_TYPE_PIO, 0, 0);
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_switch_bus_to_pio);
+
+/*
+*******************************************************************************
+*                     sw_hcd_enable_dma_channel_irq
+*
+* Description:
+*     DMA channel 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_enable_dma_channel_irq(struct sw_hcd_qh *qh)
+{
+	DMSG_DBG_DMA("sw_hcd_enable_dma_channel_irq\n");
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_enable_dma_channel_irq);
+
+/*
+*******************************************************************************
+*                     sw_hcd_disable_dma_channel_irq
+*
+* Description:
+*     DMA channel 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_disable_dma_channel_irq(struct sw_hcd_qh *qh)
+{
+	DMSG_DBG_DMA("sw_hcd_disable_dma_channel_irq\n");
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_disable_dma_channel_irq);
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_set_config
+*
+* Description:
+*     DMA
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_dma_set_config(struct sw_hcd_qh *qh, __u32 buff_addr, __u32 len)
+{
+	struct dma_hw_conf dma_config;
+
+	__u32 is_in				= 0;
+	__u32 packet_size		= 0;
+	__u32 usbc_no          	= 0;
+	__u32 usbc_base 		= 0;
+	__u32 usb_cmt_blk_cnt  	= 0;
+	__u32 dram_cmt_blk_cnt 	= 0;
+	__u32 fifo_addr 	   	= 0;
+
+	memset(&dma_config, 0, sizeof(struct dma_hw_conf));
+
+	is_in = is_direction_in(qh);
+	packet_size = qh->maxpacket;
+
+	usb_cmt_blk_cnt  = (((packet_size >> 2) - 1) << 8) | 0x0f;
+	dram_cmt_blk_cnt = (((packet_size >> 2) - 1) << 8);
+
+	usbc_base = USBC0_BASE;
+	fifo_addr = USBC_REG_EPFIFOx(usbc_base, qh->hw_ep->epnum);
+
+	DMSG_DBG_DMA("\nsw_hcd_dma_set_config, fifo_addr(0x%x, 0x%p), buff_addr = 0x%x\n",
+		      fifo_addr, qh->hw_ep->fifo, buff_addr);
+
+	if(is_in){ /* ep in, rx*/
+		usbc_no = DRQ_TYPE_USB0;
+
+		dma_config.drqsrc_type	= usbc_no;
+		dma_config.drqdst_type	= D_DRQDST_SDRAM;
+		if((u32)buff_addr & 0x03){
+			dma_config.xfer_type = DMAXFER_D_SBYTE_S_BWORD;
+		}else{
+			dma_config.xfer_type = DMAXFER_D_BWORD_S_BWORD;
+		}
+		dma_config.address_type	= DMAADDRT_D_LN_S_IO;
+		dma_config.dir			= 1;
+		dma_config.hf_irq		= SW_DMA_IRQ_FULL;
+		dma_config.reload		= 0;
+		dma_config.from			= fifo_addr;
+		dma_config.to			= 0;
+		dma_config.cmbk			= usb_cmt_blk_cnt | (dram_cmt_blk_cnt << 16);
+	}else{ /* ep out, tx*/
+		usbc_no = DRQ_TYPE_USB0;
+
+		dma_config.drqsrc_type	= D_DRQSRC_SDRAM;
+		dma_config.drqdst_type	= usbc_no;
+		if((u32)buff_addr & 0x03){
+			dma_config.xfer_type = DMAXFER_D_BWORD_S_SBYTE;
+		}else{
+			dma_config.xfer_type = DMAXFER_D_BWORD_S_BWORD;
+		}
+		dma_config.address_type	= DMAADDRT_D_IO_S_LN;
+		dma_config.dir			= 2;
+		dma_config.hf_irq		= SW_DMA_IRQ_FULL;
+		dma_config.reload		= 0;
+		dma_config.from			= 0;
+		dma_config.to			= fifo_addr;
+		dma_config.cmbk			= (usb_cmt_blk_cnt << 16) | dram_cmt_blk_cnt;
+	}
+
+	sw_dma_config(qh->hw_ep->sw_hcd->sw_hcd_dma.dma_hdle, &dma_config);
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_dma_set_config);
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_start
+*
+* Description:
+*     DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_dma_start(struct sw_hcd_qh *qh, __u32 fifo, __u32 buffer, __u32 len)
+{
+	DMSG_DBG_DMA("sw_hcd_dma_start, ep(%d, %d), fifo = 0x%x, buffer = (0x%x, 0x%x), len = 0x%x\n",
+		      	qh->epnum, qh->hw_ep->epnum,
+		      	fifo, buffer, (u32)phys_to_virt(buffer), len);
+
+	qh->dma_working = 1;
+
+	hcd_CleanFlushDCacheRegion((void *)buffer, len);
+	sw_hcd_switch_bus_to_dma(qh, is_direction_in(qh));
+
+	sw_dma_enqueue(qh->hw_ep->sw_hcd->sw_hcd_dma.dma_hdle, (void *)qh, (dma_addr_t)phys_to_virt(buffer), len);
+	sw_dma_ctrl(qh->hw_ep->sw_hcd->sw_hcd_dma.dma_hdle, SW_DMAOP_START);
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_dma_start);
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_stop
+*
+* Description:
+*     DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_dma_stop(struct sw_hcd_qh *qh)
+{
+	DMSG_DBG_DMA("sw_hcd_dma_stop\n");
+
+	sw_dma_ctrl(qh->hw_ep->sw_hcd->sw_hcd_dma.dma_hdle, SW_DMAOP_STOP);
+
+	sw_hcd_switch_bus_to_pio(qh, is_direction_in(qh));
+	qh->dma_working = 0;
+	qh->dma_transfer_len = 0;
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_dma_stop);
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_transmit_length
+*
+* Description:
+*     DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+#if 1
+static __u32 sw_hcd_dma_left_length(struct sw_hcd_qh *qh, __u32 is_in, __u32 buffer_addr)
+{
+    dma_addr_t src = 0;
+    dma_addr_t dst = 0;
+	__u32 dma_buffer = 0;
+	__u32 left_len = 0;
+
+	sw_dma_getcurposition(qh->hw_ep->sw_hcd->sw_hcd_dma.dma_hdle, &src, &dst);
+	if(is_in){
+		dma_buffer = (__u32)dst;
+	}else{
+		dma_buffer = (__u32)src;
+	}
+
+	left_len = buffer_addr - dma_buffer;
+
+	DMSG_DBG_DMA("dma transfer lenght, buffer_addr(0x%x), dma_buffer(0x%x), left_len(%d), want(%d)\n",
+		      buffer_addr, dma_buffer, left_len, qh->dma_transfer_len);
+
+    return left_len;
+}
+
+__u32 sw_hcd_dma_transmit_length(struct sw_hcd_qh *qh, __u32 is_in, __u32 buffer_addr)
+{
+	DMSG_DBG_DMA("sw_hcd_dma_transmit_length: qh(0x%p, %d, %d), is_in(%d), buffer_addr(0x%x)\n",
+		         qh, qh->dma_transfer_len, qh->dma_working,
+		         is_in, buffer_addr);
+
+	if(qh->dma_transfer_len){
+		return (qh->dma_transfer_len - sw_hcd_dma_left_length(qh, is_in, buffer_addr));
+	}else{
+		return qh->dma_transfer_len;
+	}
+}
+
+#else
+__u32 sw_hcd_dma_transmit_length(struct sw_hcd_qh *qh, __u32 is_in, __u32 buffer_addr)
+{
+	DMSG_DBG_DMA("sw_hcd_dma_transmit_length: dma_transfer_len = %d\n", qh->dma_transfer_len);
+
+	return qh->dma_transfer_len;
+}
+#endif
+
+EXPORT_SYMBOL(sw_hcd_dma_transmit_length);
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_probe
+*
+* Description:
+*    DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_dma_callback(struct sw_dma_chan * ch, void *buf, int size, enum sw_dma_buffresult result)
+{
+	struct sw_hcd_qh *qh = (struct sw_hcd_qh *)buf;
+
+	DMSG_DBG_DMA("sw_hcd_dma_callback, epnum(%d, %d), qh(0x%p), length(%d)\n\n",
+		  		qh->epnum, qh->hw_ep->epnum, qh, size);
+
+	if(qh){
+		qh->dma_working = 0;
+		qh->dma_transfer_len = size;
+
+		sw_hcd_switch_bus_to_pio(qh, is_direction_in(qh));
+		sw_hcd_dma_completion(qh->hw_ep->sw_hcd, qh->hw_ep->epnum, !is_direction_in(qh));
+	}else{
+		DMSG_PANIC("ERR: sw_hcd_dma_callback, dma is remove, but dma irq is happened, (0x%x, 0x%p)\n",
+			       qh->hw_ep->sw_hcd->sw_hcd_dma.dma_hdle, qh);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_probe
+*
+* Description:
+*    DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__u32 sw_hcd_dma_is_busy(struct sw_hcd_qh *qh)
+{
+	return qh->dma_working;
+}
+EXPORT_SYMBOL(sw_hcd_dma_is_busy);
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_probe
+*
+* Description:
+*    DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 sw_hcd_dma_probe(struct sw_hcd *sw_hcd)
+{
+	__u32 dma_channel = 0;
+
+	DMSG_DBG_DMA("sw_hcd_dma_probe\n");
+
+    /* request dma */
+	strcpy(sw_hcd->sw_hcd_dma.name, sw_hcd->driver_name);
+	strcat(sw_hcd->sw_hcd_dma.name, "_DMA");
+	sw_hcd->sw_hcd_dma.dma_client.name = sw_hcd->sw_hcd_dma.name;
+
+	dma_channel = DMACH_DUSB0;
+
+	sw_hcd->sw_hcd_dma.dma_hdle = sw_dma_request(dma_channel, &(sw_hcd->sw_hcd_dma.dma_client), NULL);
+	if(sw_hcd->sw_hcd_dma.dma_hdle < 0){
+		DMSG_PANIC("ERR: sw_dma_request failed\n");
+		return -1;
+	}
+
+	DMSG_INFO("sw_hcd_dma_probe: dma_hdle = 0x%x\n", sw_hcd->sw_hcd_dma.dma_hdle);
+
+	/* set callback */
+	sw_dma_set_buffdone_fn(sw_hcd->sw_hcd_dma.dma_hdle, sw_hcd_dma_callback);
+
+    return 0;
+}
+EXPORT_SYMBOL(sw_hcd_dma_probe);
+
+/*
+*******************************************************************************
+*                     sw_hcd_dma_remove
+*
+* Description:
+*    DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 sw_hcd_dma_remove(struct sw_hcd *sw_hcd)
+{
+	__u32 dma_channel = 0;
+
+	DMSG_INFO("sw_hcd_dma_remove\n");
+
+	if(sw_hcd->sw_hcd_dma.dma_hdle >= 0){
+		dma_channel = DMACH_DUSB0;
+		sw_dma_free(dma_channel, &(sw_hcd->sw_hcd_dma.dma_client));
+		sw_hcd->sw_hcd_dma.dma_hdle = -1;
+	}else{
+		DMSG_PANIC("ERR: sw_hcd_dma_remove, sw_hcd->sw_hcd_dma.dma_hdle is null\n");
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_hcd_dma_remove);
+
+
+
+
+#else
+void sw_hcd_switch_bus_to_dma(struct sw_hcd_qh *qh, u32 is_in){}
+void sw_hcd_switch_bus_to_pio(struct sw_hcd_qh *qh, __u32 is_in){}
+
+void sw_hcd_dma_set_config(struct sw_hcd_qh *qh, __u32 buff_addr, __u32 len){}
+__u32 sw_hcd_dma_is_busy(struct sw_hcd_qh *qh){return 0;}
+
+void sw_hcd_dma_start(struct sw_hcd_qh *qh, __u32 fifo, __u32 buffer, __u32 len){}
+void sw_hcd_dma_stop(struct sw_hcd_qh *qh){}
+__u32 sw_hcd_dma_transmit_length(struct sw_hcd_qh *qh, __u32 is_in, __u32 buffer_addr){return 0;}
+
+__s32 sw_hcd_dma_probe(struct sw_hcd *sw_hcd){return 0;}
+__s32 sw_hcd_dma_remove(struct sw_hcd *sw_hcd){return 0;}
+
+#endif
diff --git a/drivers/usb/sunxi_usb/hcd/core/sw_hcd_host.c b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_host.c
new file mode 100644
index 0000000..45e3ad9
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_host.c
@@ -0,0 +1,3475 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/core/sw_hcd_host.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/list.h>
+
+#include  "../include/sw_hcd_config.h"
+#include  "../include/sw_hcd_core.h"
+#include  "../include/sw_hcd_virt_hub.h"
+#include  "../include/sw_hcd_host.h"
+#include  "../include/sw_hcd_dma.h"
+
+/*
+ * NOTE on endpoint usage:
+ *
+ * CONTROL transfers all go through ep0.  BULK ones go through dedicated IN
+ * and OUT endpoints ... hardware is dedicated for those "async" queue(s).
+ * (Yes, bulk _could_ use more of the endpoints than that, and would even
+ * benefit from it.)
+ *
+ * INTERUPPT and ISOCHRONOUS transfers are scheduled to the other endpoints.
+ * So far that scheduling is both dumb and optimistic:  the endpoint will be
+ * "claimed" until its software queue is no longer refilled.  No multiplexing
+ * of transfers between endpoints, or anything clever.
+ */
+static void sw_hcd_ep_program(struct sw_hcd *sw_hcd,
+                            u8 epnum,
+                            struct urb *urb,
+                            int is_out,
+                            u8 *buf,
+                            u32 offset,
+                            u32 len);
+
+#if 0
+/*
+*******************************************************************************
+*                     sw_hcd_h_ep0_flush_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    ep : input.  ep 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_h_ep0_flush_fifo(struct sw_hcd_hw_ep *ep)
+{
+	void __iomem *usbc_base = NULL;
+	u16 csr = 0;
+	int retries = 5;
+
+	if(ep == NULL){
+		DMSG_PANIC("ERR: invalid argment\n");
+		return;
+	}
+
+	usbc_base = ep->regs;
+
+	/* scrub any data left in the fifo */
+	do {
+	    csr = USBC_Readw(USBC_REG_CSR0(usbc_base));
+	    if(!(csr & ((1 << USBC_BP_CSR0_H_TxPkRdy) | (1 << USBC_BP_CSR0_H_RxPkRdy)))){
+	        break;
+	    }
+
+	    USBC_REG_set_bit_w(USBC_BP_CSR0_H_FlushFIFO, USBC_REG_CSR0(usbc_base));
+
+	    csr = USBC_Readw(USBC_REG_CSR0(usbc_base));
+	    udelay(10);
+    }while (--retries);
+
+    if(retries == 0){
+        DMSG_PANIC("ERR: Could not flush host TX%d fifo: csr: %04x\n", ep->epnum, csr);
+    }
+
+    /* and reset for the next transfer */
+    USBC_Writew(0x00, USBC_REG_CSR0(usbc_base));
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_tx_flush_fifo
+*
+* Description:
+*    Clear TX fifo. Needed to avoid BABBLE errors.
+*
+* Parameters:
+*    ep : input.  ep 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_h_tx_flush_fifo(struct sw_hcd_hw_ep *ep)
+{
+    void __iomem  *usbc_base = ep->regs;
+	u16  csr     = 0;
+	u16  lastcsr = 0;
+	int  retries = 1000;
+
+	/*  fifo  fifo */
+	csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+	while (csr & (1 << USBC_BP_TXCSR_H_FIFO_NOT_EMPTY)) {
+	    if (csr != lastcsr){
+		    DMSG_PANIC("WRN: Host TX FIFONOTEMPTY csr: %02x\n", csr);
+		}
+
+		lastcsr = csr;
+
+		csr |= (1 << USBC_BP_TXCSR_H_FLUSH_FIFO);
+		USBC_Writew(csr, USBC_REG_TXCSR(usbc_base));
+
+		csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+		if(retries-- < 1){
+		    DMSG_PANIC("ERR: Could not flush host TX%d fifo: csr: %04x\n", ep->epnum, csr);
+		    return ;
+		}
+
+		mdelay(1);
+	}
+
+    return ;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_rx_flush_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    hw_ep  :  input.   ep 
+*    csr    :  input.  rx
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static u16 sw_hcd_h_rx_flush_fifo(struct sw_hcd_hw_ep *hw_ep, u16 csr)
+{
+    void __iomem  *usbc_base = hw_ep->regs;
+
+    /* we don't want fifo to fill itself again;
+	 * ignore dma (various models),
+	 * leave toggle alone (may not have been saved yet)
+	 */
+	csr |= (1 << USBC_BP_RXCSR_H_FLUSH_FIFO) | (1 << USBC_BP_RXCSR_H_RX_PKT_READY);
+	csr &= ~(1 << USBC_BP_RXCSR_H_REQ_PACKET);
+	csr &= ~(1 << USBC_BP_RXCSR_H_AUTO_REQ);
+	csr &= ~(1 << USBC_BP_RXCSR_H_AUTO_CLEAR);
+
+	/* write 2x to allow double buffering */
+	USBC_Writew(csr, USBC_REG_RXCSR(usbc_base));
+	USBC_Writew(csr, USBC_REG_RXCSR(usbc_base));
+
+	/* flush writebuffer */
+    return USBC_Readw(USBC_REG_RXCSR(usbc_base));
+}
+#else
+/*
+*******************************************************************************
+*                     sw_hcd_h_ep0_flush_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    ep : input.  ep 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_h_ep0_flush_fifo(struct sw_hcd_hw_ep *ep)
+{
+	void __iomem *usbc_base = NULL;
+	u16 csr = 0;
+	int retries = 5;
+	__u8 old_ep_index = 0;
+
+	if(ep == NULL){
+		DMSG_PANIC("ERR: invalid argment\n");
+		return;
+	}
+
+	usbc_base = ep->regs;
+
+	old_ep_index = USBC_GetActiveEp(ep->sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_SelectActiveEp(ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, ep->epnum);
+
+	/* scrub any data left in the fifo */
+	do {
+	    csr = USBC_Readw(USBC_REG_CSR0(usbc_base));
+	    if(!(csr & ((1 << USBC_BP_CSR0_H_TxPkRdy) | (1 << USBC_BP_CSR0_H_RxPkRdy)))){
+	        break;
+	    }
+
+	    USBC_Host_FlushFifo(ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_EP0);
+
+	    csr = USBC_Readw(USBC_REG_CSR0(usbc_base));
+	    udelay(10);
+    }while (--retries);
+
+    if(retries == 0){
+        DMSG_PANIC("ERR: Could not flush host TX%d fifo: csr: %04x\n", ep->epnum, csr);
+    }
+
+    /* and reset for the next transfer */
+    USBC_Writew(0x00, USBC_REG_CSR0(usbc_base));
+
+	USBC_SelectActiveEp(ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, old_ep_index);
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_tx_flush_fifo
+*
+* Description:
+*    Clear TX fifo. Needed to avoid BABBLE errors.
+*
+* Parameters:
+*    ep : input.  ep 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_h_tx_flush_fifo(struct sw_hcd_hw_ep *ep)
+{
+    void __iomem  *usbc_base = ep->regs;
+	u16  csr     = 0;
+	u16  lastcsr = 0;
+	int  retries = 1000;
+
+	/*  fifo  fifo */
+	csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+	while (csr & (1 << USBC_BP_TXCSR_H_FIFO_NOT_EMPTY)) {
+	    if (csr != lastcsr){
+		    DMSG_PANIC("WRN: Host TX FIFONOTEMPTY csr: %02x, %02x\n", csr, lastcsr);
+		}
+
+		lastcsr = csr;
+
+		csr |= (1 << USBC_BP_TXCSR_H_FLUSH_FIFO);
+		csr &= ~(1 << USBC_BP_TXCSR_D_TX_READY);
+		USBC_Writew(csr, USBC_REG_TXCSR(usbc_base));
+
+		csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+		if(retries-- < 1){
+		    DMSG_PANIC("ERR: Could not flush host TX%d fifo: csr: %04x\n", ep->epnum, csr);
+		    return ;
+		}
+
+		mdelay(1);
+	}
+
+    return ;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_rx_flush_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    hw_ep  :  input.   ep 
+*    csr    :  input.  rx
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static u16 sw_hcd_h_rx_flush_fifo(struct sw_hcd_hw_ep *hw_ep, u16 csr)
+{
+    void __iomem  *usbc_base = hw_ep->regs;
+
+    /* we don't want fifo to fill itself again;
+	 * ignore dma (various models),
+	 * leave toggle alone (may not have been saved yet)
+	 */
+	csr |= (1 << USBC_BP_RXCSR_H_FLUSH_FIFO);
+	csr &= ~(1 << USBC_BP_RXCSR_H_REQ_PACKET);
+	csr &= ~(1 << USBC_BP_RXCSR_H_AUTO_REQ);
+	csr &= ~(1 << USBC_BP_RXCSR_H_AUTO_CLEAR);
+	csr &= ~(1 << USBC_BP_RXCSR_H_RX_PKT_READY);
+
+	/* write 2x to allow double buffering */
+	USBC_Writew(csr, USBC_REG_RXCSR(usbc_base));
+	USBC_Writew(csr, USBC_REG_RXCSR(usbc_base));
+
+	/* flush writebuffer */
+    return USBC_Readw(USBC_REG_RXCSR(usbc_base));
+}
+#endif
+/*
+*******************************************************************************
+*                     sw_hcd_h_tx_start
+*
+* Description:
+*     Start transmit. Caller is responsible for locking shared resources.
+* sw_hcd must be locked.
+*
+* Parameters:
+*    ep : input.  ep 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static inline void sw_hcd_h_tx_start(struct sw_hcd_hw_ep *ep)
+{
+    void __iomem	*usbc_base 		= ep->regs;
+	u16				txcsr			= 0;
+	__u16			old_ep_index 	= 0;
+
+	old_ep_index = USBC_GetActiveEp(ep->sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_SelectActiveEp(ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, ep->epnum);
+
+	/* NOTE: no locks here; caller should lock and select EP */
+	if (ep->epnum) {
+	    txcsr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+	    txcsr |= (1 << USBC_BP_TXCSR_H_TX_READY) | USBC_TXCSR_H_WZC_BITS;
+	    USBC_Writew(txcsr, USBC_REG_TXCSR(usbc_base));
+	} else {
+		txcsr = (1 << USBC_BP_CSR0_H_SetupPkt) | (1 << USBC_BP_CSR0_H_TxPkRdy);
+		USBC_Writew(txcsr, USBC_REG_CSR0(usbc_base));
+	}
+
+	USBC_SelectActiveEp(ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, old_ep_index);
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_clean_dma_status
+*
+* Description:
+*    epDMA, DMA
+*
+* Parameters:
+*    qh  :  input.
+*
+* Return value:
+*    void
+*
+* note:
+*    called with controller irqlocked
+*
+*******************************************************************************
+*/
+static void sw_hcd_clean_ep_dma_status(struct sw_hcd_qh *qh)
+{
+	struct sw_hcd_hw_ep   *hw_ep = NULL;
+    u8  	old_ep_index 	= 0;
+	__hdle 	usb_bsp_hdle 	= 0;
+	__u32 	is_in 			= 0;
+
+	hw_ep        = qh->hw_ep;
+	usb_bsp_hdle = qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle;
+	is_in        = is_direction_in(qh);
+
+	old_ep_index = USBC_GetActiveEp(usb_bsp_hdle);
+	USBC_SelectActiveEp(usb_bsp_hdle, hw_ep->epnum);
+
+	if(is_in){ /* ep in, rx*/
+		/* clear ep dma status */
+	    USBC_Host_ClearEpDma(usb_bsp_hdle, USBC_EP_TYPE_RX);
+		USBC_Host_ClearRqPktCount(usb_bsp_hdle, hw_ep->epnum);
+		USBC_Host_StopInToken(usb_bsp_hdle, USBC_EP_TYPE_RX);
+	}else{ /* ep out, tx*/
+		/* clear ep dma status */
+		USBC_Host_ClearEpDma(usb_bsp_hdle, USBC_EP_TYPE_TX);
+	}
+
+	USBC_SelectActiveEp(usb_bsp_hdle, old_ep_index);
+
+	sw_hcd_switch_bus_to_pio(qh, is_in);
+
+	return;
+}
+
+/*
+*******************************************************************************
+*              sw_hcd_clean_ep_dma_status_and_flush_fifo
+*
+* Description:
+*    epDMA, DMA
+*
+* Parameters:
+*    qh  :  input.
+*
+* Return value:
+*    void
+*
+* note:
+*    called with controller irqlocked
+*
+*******************************************************************************
+*/
+void sw_hcd_clean_ep_dma_status_and_flush_fifo(struct sw_hcd_qh *qh)
+{
+	struct sw_hcd_hw_ep   *hw_ep = NULL;
+    u8  	old_ep_index 	= 0;
+	__hdle 	usb_bsp_hdle 	= 0;
+	__u32 	is_in 			= 0;
+	__u16 	csr 			= 0;
+
+	hw_ep        = qh->hw_ep;
+	usb_bsp_hdle = qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle;
+	is_in        = is_direction_in(qh);
+
+	old_ep_index = USBC_GetActiveEp(usb_bsp_hdle);
+	USBC_SelectActiveEp(usb_bsp_hdle, hw_ep->epnum);
+
+	if(is_in){ /* ep in, rx*/
+		/* clear ep dma status */
+	    USBC_Host_ClearEpDma(usb_bsp_hdle, USBC_EP_TYPE_RX);
+		USBC_Host_ClearRqPktCount(usb_bsp_hdle, hw_ep->epnum);
+		USBC_Host_StopInToken(usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+        /* flush fifo */
+		csr = USBC_Readw( USBC_REG_RXCSR(hw_ep->regs));
+		sw_hcd_h_rx_flush_fifo(hw_ep, csr);
+	}else{ /* ep out, tx*/
+		/* clear ep dma status */
+		USBC_Host_ClearEpDma(usb_bsp_hdle, USBC_EP_TYPE_TX);
+
+        /* flush fifo */
+		csr = USBC_Readw( USBC_REG_TXCSR(hw_ep->regs));
+		csr |= USBC_TXCSR_H_WZC_BITS;
+		USBC_Writew(csr, USBC_REG_TXCSR(hw_ep->regs));
+
+		sw_hcd_h_tx_flush_fifo(hw_ep);
+	}
+
+	USBC_SelectActiveEp(usb_bsp_hdle, old_ep_index);
+
+	sw_hcd_switch_bus_to_pio(qh, is_in);
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_tx_dma_start
+*
+* Description:
+*    void
+*
+* Parameters:
+*    ep : input.  ep 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static inline void sw_hcd_h_tx_dma_start(struct sw_hcd_hw_ep *ep, struct sw_hcd_qh *qh)
+{
+    void __iomem 	*usbc_base 		= ep->regs;
+	u8				txcsr 			= 0;
+	u16 			old_ep_index 	= 0;
+
+	old_ep_index = USBC_GetActiveEp(qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_SelectActiveEp(qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, qh->hw_ep->epnum);
+
+	/* 8, clear timeout, stall error */
+	txcsr = USBC_Readb(USBC_REG_TXCSR(usbc_base));
+	txcsr |= USBC_TXCSR_H_WZC_BITS;
+	USBC_Writeb(txcsr, USBC_REG_TXCSR(usbc_base));
+
+	/* NOTE: no locks here; caller should lock and select EP */
+	txcsr = USBC_Readb(USBC_REG_TXCSR(usbc_base) + 1);
+	txcsr |= (1 << USBC_BP_TXCSR_H_DMA_REQ_EN) >> 8;
+	USBC_Writeb(txcsr, (USBC_REG_TXCSR(usbc_base) + 1));
+
+	DMSG_DBG_DMA("TXCSR = 0x%x\n", USBC_Readw(USBC_REG_TXCSR(usbc_base)));
+
+	USBC_SelectActiveEp(qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle, old_ep_index);
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_tx_dma_program
+*
+* Description:
+*    void
+*
+* Parameters:
+*    dma    :  input.
+*    hw_ep  :  input.
+*    qh     :  input.
+*    urb    :  input.
+*    offset :  input.
+*    length :  input.
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static bool sw_hcd_tx_dma_program(struct sw_hcd_hw_ep *hw_ep,
+                                struct sw_hcd_qh *qh,
+                                struct urb *urb,
+                                u32 offset,
+                                u32 length)
+{
+	void __iomem	*usbc_base  	= NULL;
+	u16				pkt_size    	= 0;
+	u8				ep_csr     		= 0;
+	u16       		old_ep_index 	= 0;
+	__hdle          usb_bsp_hdle	= 0;
+
+    /* check argment */
+    if(hw_ep == NULL || qh == NULL || urb == NULL){
+        DMSG_PANIC("ERR: invalid argment, hw_ep=0x%p, qh=0x%p, urb=0x%p\n",
+			       hw_ep, qh, urb);
+	    return false;
+    }
+
+    /* initialize parameter */
+    usbc_base   = hw_ep->regs;
+    pkt_size    = qh->maxpacket;
+    qh->segsize = length;
+	usb_bsp_hdle = qh->hw_ep->sw_hcd->sw_hcd_io->usb_bsp_hdle;
+
+	/* config tx_csr */
+	old_ep_index = USBC_GetActiveEp(usb_bsp_hdle);
+	USBC_SelectActiveEp(usb_bsp_hdle, hw_ep->epnum);
+
+	/* auto_set, tx_mode, dma_tx_en, mode1 */
+    ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base) + 1);
+	ep_csr |= (1 << USBC_BP_TXCSR_H_AUTOSET) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_H_MODE) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_H_DMA_REQ_MODE) >> 8;
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base) + 1));
+
+	USBC_SelectActiveEp(usb_bsp_hdle, old_ep_index);
+
+    /* config dma */
+    sw_hcd_dma_set_config(qh, (urb->transfer_dma + offset), length);
+	sw_hcd_dma_start(qh, (u32)hw_ep->fifo, (urb->transfer_dma + offset), length);
+
+	return true;
+}
+
+
+/*
+*******************************************************************************
+*                     sw_hcd_start_urb
+*
+* Description:
+*     Start the URB at the front of an endpoint's queue
+* end must be claimed from the caller.
+*
+* Context: controller locked, irqs blocked
+*
+* Parameters:
+*    sw_hcd   :  input.  USB
+*    is_in  :  input.  flag.  in ep
+*    qh     :  output. ep 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_start_urb(struct sw_hcd *sw_hcd, int is_in, struct sw_hcd_qh *qh)
+{
+	u16                 frame       = 0;
+	u32                 len         = 0;
+	void __iomem        *usbc_base  = NULL;
+	struct urb          *urb        = NULL;
+	void                *buf        = NULL;
+	u32                 offset      = 0;
+	struct sw_hcd_hw_ep   *hw_ep      = NULL;
+	unsigned            pipe        = 0;
+	u8                  address     = 0;
+	int                 epnum       = 0;
+
+	/* check argment */
+	if(sw_hcd == NULL || qh == NULL){
+	    DMSG_PANIC("ERR: invalid argment, sw_hcd=0x%p, qh=0x%p\n", sw_hcd, qh);
+	    return;
+	}
+
+	/* initalize parameter */
+	usbc_base   = sw_hcd->mregs;
+	urb         = next_urb(qh);
+	if(urb == NULL){
+		DMSG_WRN("ERR: sw_hcd_start_urb, urb is NULL\n");
+		return;
+	}
+
+	buf         = urb->transfer_buffer;
+	hw_ep       = qh->hw_ep;
+	pipe        = urb->pipe;
+	address     = usb_pipedevice(pipe);
+	epnum       = hw_ep->epnum;
+
+	/* initialize software qh state */
+	qh->offset  = 0;
+	qh->segsize = 0;
+
+	DMSG_DBG_HCD("start_urb: ep%d%s, qh(0x%p, 0x%x, 0x%x), urb(0x%p, 0x%p, %d, %d)\n",
+		      epnum, (is_in ? "rx" : "tx"),
+		      qh, qh->epnum, qh->type,
+		      urb, urb->transfer_buffer, urb->transfer_buffer_length, urb->actual_length);
+
+	/* gather right source of data */
+	switch (qh->type) {
+	    case USB_ENDPOINT_XFER_CONTROL:
+	    {
+    		/* control transfers always start with SETUP */
+    		is_in = 0;
+    		hw_ep->out_qh = qh;
+    		sw_hcd->ep0_stage = SW_HCD_EP0_START;
+    		buf = urb->setup_packet;
+    		len = 8;
+	    }
+	    break;
+
+	    case USB_ENDPOINT_XFER_ISOC:
+	    {
+    		qh->iso_idx = 0;
+    		qh->frame = 0;
+    		offset = urb->iso_frame_desc[0].offset;
+    		len = urb->iso_frame_desc[0].length;
+	    }
+		break;
+
+	    default:  /* bulk, interrupt */
+    		/* actual_length may be nonzero on retry paths */
+    		buf = urb->transfer_buffer + urb->actual_length;
+    		len = urb->transfer_buffer_length - urb->actual_length;
+	}
+
+	DMSG_DBG_HCD("sw_hcd_start_urb: qh 0x%p urb %p dev%d ep%d%s%s, epnum %d, %p/%d\n",
+				qh, urb, address, qh->epnum,
+				is_in ? "in" : "out",
+				({char *s; switch (qh->type) {
+				case USB_ENDPOINT_XFER_CONTROL:	s = ""; break;
+				case USB_ENDPOINT_XFER_BULK:	s = "-bulk"; break;
+				case USB_ENDPOINT_XFER_ISOC:	s = "-iso"; break;
+				default:			s = "-intr"; break;
+				}; s; }),
+				epnum, buf + offset, len);
+
+	/* Configure endpoint */
+	if(is_in || hw_ep->is_shared_fifo){
+		hw_ep->in_qh = qh;
+	}else{
+	    hw_ep->out_qh = qh;
+	}
+
+	sw_hcd_ep_program(sw_hcd, epnum, urb, !is_in, buf, offset, len);
+
+	/* transmit may have more work: start it when it is time */
+	if (is_in){
+		DMSG_WRN("ERR: transmit may have more work: start it when it is time\n");
+		return;
+    }
+
+    /* determine if the time is right for a periodic transfer */
+	switch (qh->type) {
+    	case USB_ENDPOINT_XFER_ISOC:
+    	case USB_ENDPOINT_XFER_INT:
+    	{
+    	    DMSG_DBG_HCD("check whether there's still time for periodic Tx\n");
+
+    	    frame = USBC_Readw(USBC_REG_FRNUM(usbc_base));
+
+    	    /* FIXME this doesn't implement that scheduling policy ...
+    		 * or handle framecounter wrapping
+    		 */
+    	    if ((urb->transfer_flags & URB_ISO_ASAP)
+				|| (frame >= urb->start_frame)) {
+    			/* REVISIT the SOF irq handler shouldn't duplicate
+    			 * this code; and we don't init urb->start_frame...
+    			 */
+    			qh->frame = 0;
+    			goto start;
+    		} else {
+    			qh->frame = urb->start_frame;
+
+    			/* enable SOF interrupt so we can count down */
+    			DMSG_DBG_HCD("SOF for %d\n", epnum);
+
+    			USBC_Writeb(0xff, USBC_REG_INTUSBE(usbc_base));
+    		}
+    	}
+		break;
+
+        default:
+start:
+    		if(is_sw_hcd_dma_capable(sw_hcd->usbc_no, len, qh->maxpacket, epnum)){
+	    		DMSG_DBG_HCD("Start TX%d %s\n", epnum, "dma");
+
+    			sw_hcd_h_tx_dma_start(hw_ep, qh);
+    		}else{
+	    		DMSG_DBG_HCD("Start TX%d %s\n", epnum, "pio");
+
+    			sw_hcd_h_tx_start(hw_ep);
+    		}
+    }
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     __sw_hcd_giveback
+*
+* Description:
+*    caller owns controller lock, irqs are blocked.
+*
+* Parameters:
+*    sw_hcd   :  input.  USB 
+*    urb    :  input.  USB 
+*    status :  input.  urb 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void
+__sw_hcd_giveback(struct sw_hcd *sw_hcd, struct urb *urb, int status)
+__releases(sw_hcd->lock)
+__acquires(sw_hcd->lock)
+{
+    if(sw_hcd == NULL || urb == NULL){
+        DMSG_PANIC("ERR: __sw_hcd_giveback, invalid argment, sw_hcd=0x%p, urb=0x%p\n",
+			       sw_hcd, urb);
+        return;
+    }
+
+    DMSG_DBG_HCD("g: urb(0x%p, %pF, %d, %d, %d), dev(%d), ep%d%s\n",
+                urb, urb->complete, status,
+                urb->actual_length, urb->transfer_buffer_length,
+                usb_pipedevice(urb->pipe),
+                usb_pipeendpoint(urb->pipe),
+                usb_pipein(urb->pipe) ? "in" : "out"
+                );
+
+    usb_hcd_unlink_urb_from_ep(sw_hcd_to_hcd(sw_hcd), urb);
+
+	spin_unlock(&sw_hcd->lock);
+	usb_hcd_giveback_urb(sw_hcd_to_hcd(sw_hcd), urb, status);
+	spin_lock(&sw_hcd->lock);
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_save_toggle
+*
+* Description:
+*    for bulk/interrupt endpoints only
+*
+* Parameters:
+*    ep     :  output.  ep 
+*    is_in  :  input.  flag.  in ep
+*    urb    :  input.  USB 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static inline void sw_hcd_save_toggle(struct sw_hcd_hw_ep *ep, int is_in, struct urb *urb)
+{
+	struct usb_device	*udev       = NULL;
+	u16			        csr         = 0;
+	void __iomem		*usbc_base  = NULL;
+	struct sw_hcd_qh		*qh         = NULL;
+
+	/* check argment */
+	if(ep == NULL || urb == NULL){
+	    DMSG_PANIC("ERR: invaild argment\n");
+	    return;
+	}
+
+	/* initialize parameter */
+	udev = urb->dev;
+	usbc_base = ep->regs;
+
+	/* FIXME:  the current Mentor DMA code seems to have
+	 * problems getting toggle correct.
+	 */
+	if (is_in || ep->is_shared_fifo){
+		qh = ep->in_qh;
+	}else{
+		qh = ep->out_qh;
+    }
+
+    if (!is_in) {
+        csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+		usb_settoggle(udev, qh->epnum, 1, ((csr & (1 << USBC_BP_TXCSR_H_DATA_TOGGLE)) ? 1 : 0));
+	} else {
+		csr = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+		usb_settoggle(udev, qh->epnum, 0, ((csr & (1 << USBC_BP_RXCSR_H_DATA_TOGGLE)) ? 1 : 0));
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_giveback
+*
+* Description:
+*    caller owns controller lock, irqs are blocked.
+*
+* Parameters:
+*    qh     :  input. ep 
+*    urb    :  input.  USB 
+*    status :  input.  urb 
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static struct sw_hcd_qh *sw_hcd_giveback(struct sw_hcd_qh *qh, struct urb *urb, int status)
+{
+    struct sw_hcd_hw_ep	*ep     = NULL;
+	struct sw_hcd		    *sw_hcd   = NULL;
+	int			        is_in   = 0;
+	int			        ready   = 0;
+
+	/* check argment */
+	if(qh == NULL || urb == NULL){
+	    DMSG_PANIC("ERR: invalid argment, qh=0x%p, urb=0x%p\n", qh, urb);
+	    return NULL;
+	}
+
+	DMSG_DBG_HCD("sw_hcd_giveback: qh(0x%p, 0x%x, 0x%x), urb(0x%p, %d, %d), status(0x%x, 0x%x)\n",
+		      qh, qh->epnum, qh->type,
+		      urb, urb->transfer_buffer_length, urb->actual_length,
+		      urb->status, status);
+
+	/* initialize parameter */
+	ep    = qh->hw_ep;
+	sw_hcd  = ep->sw_hcd;
+	is_in = usb_pipein(urb->pipe);
+	ready = qh->is_ready;
+
+	/* save toggle eagerly, for paranoia */
+	switch (qh->type) {
+    	case USB_ENDPOINT_XFER_BULK:
+    	case USB_ENDPOINT_XFER_INT:
+    		sw_hcd_save_toggle(ep, is_in, urb);
+        break;
+
+    	case USB_ENDPOINT_XFER_ISOC:
+    		if(status == 0 && urb->error_count){
+    			status = -EXDEV;
+    		}
+        break;
+
+        default:
+            DMSG_WRN("wrn: unkown ep type(%d)\n", qh->type);
+			break;
+	}
+
+	qh->is_ready = 0;
+	__sw_hcd_giveback(sw_hcd, urb, status);
+	qh->is_ready = ready;
+
+	/* reclaim resources (and bandwidth) ASAP; deschedule it, and
+	 * invalidate qh as soon as list_empty(&hep->urb_list)
+	 */
+	if (list_empty(&qh->hep->urb_list)) {
+		struct list_head *head = NULL;
+
+		if (is_in){
+			ep->rx_reinit = 1;
+		}else{
+		    ep->tx_reinit = 1;
+		}
+
+		/* clobber old pointers to this qh */
+		if (is_in || ep->is_shared_fifo) {
+			ep->in_qh = NULL;
+		}else{
+			ep->out_qh = NULL;
+		}
+
+		qh->hep->hcpriv = NULL;
+
+        switch (qh->type) {
+    		case USB_ENDPOINT_XFER_CONTROL:
+    		case USB_ENDPOINT_XFER_BULK:
+    		    /* fifo policy for these lists, except that NAKing
+    			 * should rotate a qh to the end (for fairness).
+    			 */
+    		    if (qh->mux == 1) {
+    				head = qh->ring.prev;
+    				list_del(&qh->ring);
+    				kfree(qh);
+    				qh = first_qh(head);
+    			}else{
+    				kfree(qh);
+    				qh = NULL;
+    			}
+    		break;
+
+    		case USB_ENDPOINT_XFER_ISOC:
+		    case USB_ENDPOINT_XFER_INT:
+    			/* this is where periodic bandwidth should be
+    			 * de-allocated if it's tracked and allocated;
+    			 * and where we'd update the schedule tree...
+    			 */
+    			kfree(qh);
+    			qh = NULL;
+			break;
+        }
+    }
+
+	return qh;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_advance_schedule
+*
+* Description:
+*    void
+*
+* Parameters:
+*    sw_hcd   :  input.  USB
+*    urb    :  input.  USB 
+*    hw_ep  :  input.   ep 
+*    is_in  :  input.  flag.  in ep
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_advance_schedule(struct sw_hcd *sw_hcd,
+                                  struct urb *urb,
+                                  struct sw_hcd_hw_ep *hw_ep,
+                                  int is_in)
+{
+    struct sw_hcd_qh *qh = NULL;
+
+    /* check argment */
+    if(sw_hcd == NULL || urb == NULL || hw_ep == NULL){
+        DMSG_PANIC("ERR: invalid argment, sw_hcd=0x%p, urb=0x%p, hw_ep=0x%p\n",
+			       sw_hcd, urb, hw_ep);
+	    return ;
+    }
+
+	if (is_in || hw_ep->is_shared_fifo){
+		qh = hw_ep->in_qh;
+	}else{
+		qh = hw_ep->out_qh;
+    }
+
+    if (urb->status == -EINPROGRESS){
+		qh = sw_hcd_giveback(qh, urb, 0);
+	}else{
+		qh = sw_hcd_giveback(qh, urb, urb->status);
+	}
+
+    if (qh != NULL) {
+		if(qh->is_ready){
+			DMSG_DBG_HCD("... next ep%d %cX urb %p\n",
+					hw_ep->epnum, (is_in ? 'R' : 'T'), next_urb(qh));
+			sw_hcd_start_urb(sw_hcd, is_in, qh);
+		}else{
+			DMSG_WRN("WRN: qh is not ready\n");
+		}
+	}
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_host_packet_rx
+*
+* Description:
+*    void
+*
+* Parameters:
+*    sw_hcd       :  input.  USB
+*    urb        :  input.  USB 
+*    epnum      :  input.  ep index
+*    iso_err    :  input.  flag. is iso error?
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static bool sw_hcd_host_packet_rx(struct sw_hcd *sw_hcd, struct urb *urb, u8 epnum, u8 iso_err)
+{
+    u16			        rx_count    = 0;
+	u8			        *buf        = NULL;
+	u16			        csr         = 0;
+	bool			    done        = false;
+	u32			        length      = 0;
+	int			        do_flush    = 0;
+	struct sw_hcd_hw_ep	*hw_ep      = NULL;
+	void __iomem		*usbc_base  = NULL;
+	struct sw_hcd_qh		*qh         = NULL;
+	int			        pipe        = 0;
+	void			    *buffer     = NULL;
+
+    /* check argment */
+    if(sw_hcd == NULL || urb == NULL){
+        DMSG_PANIC("ERR: invalid argment, sw_hcd=0x%p, urb=0x%p\n", sw_hcd, urb);
+	    return false;
+    }
+
+    /* initialize parameter */
+    done        = false;
+    hw_ep       = sw_hcd->endpoints + epnum;
+    usbc_base   = hw_ep->regs;
+    qh          = hw_ep->in_qh;
+    pipe        = urb->pipe;
+    buffer      = urb->transfer_buffer;
+
+    /* sw_hcd_ep_select(usbc_base, epnum); */
+    rx_count = USBC_Readw(USBC_REG_RXCOUNT(usbc_base));
+
+    DMSG_DBG_HCD("RX%d count %d, buffer %p len %d/%d\n", epnum, rx_count,
+			urb->transfer_buffer, qh->offset,
+			urb->transfer_buffer_length);
+
+    /* unload FIFO */
+    if (usb_pipeisoc(pipe)) {
+		int status = 0;
+		struct usb_iso_packet_descriptor *d = NULL;
+
+		if (iso_err) {
+			status = -EILSEQ;
+			urb->error_count++;
+		}
+
+		d = urb->iso_frame_desc + qh->iso_idx;
+		buf = buffer + d->offset;
+		length = d->length;
+		if (rx_count > length) {
+			if (status == 0) {
+				status = -EOVERFLOW;
+				urb->error_count++;
+			}
+
+			DMSG_DBG_HCD("** OVERFLOW %d into %d\n", rx_count, length);
+
+			do_flush = 1;
+		} else{
+		    length = rx_count;
+		}
+
+		urb->actual_length += length;
+		d->actual_length = length;
+		d->status = status;
+
+		/* see if we are done */
+		done = (++qh->iso_idx >= urb->number_of_packets);
+	} else {
+		/* non-isoch */
+		buf = buffer + qh->offset;
+		length = urb->transfer_buffer_length - qh->offset;
+		if (rx_count > length) {
+			if (urb->status == -EINPROGRESS){
+				urb->status = -EOVERFLOW;
+			}
+
+			DMSG_DBG_HCD("** OVERFLOW %d into %d\n", rx_count, length);
+
+			do_flush = 1;
+		} else{
+			length = rx_count;
+		}
+
+		urb->actual_length += length;
+		qh->offset += length;
+
+		/* see if we are done */
+		done = (urb->actual_length == urb->transfer_buffer_length)
+			|| (rx_count < qh->maxpacket)
+			|| (urb->status != -EINPROGRESS);
+		if (done && (urb->status == -EINPROGRESS)
+				&& (urb->transfer_flags & URB_SHORT_NOT_OK)
+				&& (urb->actual_length
+					< urb->transfer_buffer_length)){
+			urb->status = -EREMOTEIO;
+		}
+	}
+
+	sw_hcd_read_fifo(hw_ep, length, buf);
+
+	csr = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+	csr |= USBC_RXCSR_H_WZC_BITS;
+    if (unlikely(do_flush)){
+		sw_hcd_h_rx_flush_fifo(hw_ep, csr);
+	}else{
+	    /* REVISIT this assumes AUTOCLEAR is never set */
+	    csr &= ~((1 << USBC_BP_RXCSR_H_RX_PKT_READY) | (1 << USBC_BP_RXCSR_H_REQ_PACKET));
+
+	    if(!done){
+	        csr |= (1 << USBC_BP_RXCSR_H_REQ_PACKET);
+	    }
+
+	    USBC_Writew(csr, USBC_REG_RXCSR(usbc_base));
+	}
+
+    return done;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_rx_reinit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    sw_hcd	:  input.  USB
+*    qh    	:  input.  ep 
+*    ep     :  input.   ep 
+*
+* Return value:
+*    void
+*
+* note:
+*    we don't always need to reinit a given side of an endpoint...
+* when we do, use tx/rx reinit routine and then construct a new CSR
+* to address data toggle, NYET, and DMA or PIO.
+*
+*    it's possible that driver bugs (especially for DMA) or aborting a
+* transfer might have left the endpoint busier than it should be.
+* the busy/not-empty tests are basically paranoia.
+*
+*
+*******************************************************************************
+*/
+static void sw_hcd_rx_reinit(struct sw_hcd *sw_hcd, struct sw_hcd_qh *qh, struct sw_hcd_hw_ep *ep)
+{
+	u16	csr = 0;
+	void __iomem *usbc_base  = NULL;
+
+    /* check argment */
+    if(sw_hcd == NULL || qh == NULL || ep == NULL){
+        DMSG_PANIC("ERR: invalid argment, sw_hcd=0x%p, qh=0x%p, ep=0x%p\n",
+			       sw_hcd, qh, ep);
+	    return ;
+    }
+
+    /* initialize parameter */
+    usbc_base = ep->regs;
+
+	/* NOTE:  we know the "rx" fifo reinit never triggers for ep0.
+	 * That always uses tx_reinit since ep0 repurposes TX register
+	 * offsets; the initial SETUP packet is also a kind of OUT.
+	 */
+
+    /* if programmed for Tx, put it in RX mode */
+	if (ep->is_shared_fifo) {
+		csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+		if (csr & (1 << USBC_BP_TXCSR_H_MODE)) {
+			sw_hcd_h_tx_flush_fifo(ep);
+
+			csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+			csr |= (1 << USBC_BP_TXCSR_H_FORCE_DATA_TOGGLE);
+			USBC_Writew(csr, USBC_REG_TXCSR(usbc_base));
+		}
+
+		/*
+		 * Clear the MODE bit (and everything else) to enable Rx.
+		 * NOTE: we mustn't clear the DMAMODE bit before DMAENAB.
+		 */
+		csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+		if (csr & (1 << USBC_BP_TXCSR_H_DMA_REQ_MODE)){
+		    USBC_Writew(USBC_BP_TXCSR_H_DMA_REQ_MODE, USBC_REG_TXCSR(usbc_base));
+		}
+
+		USBC_Writew(0, USBC_REG_TXCSR(usbc_base));
+
+	    /* scrub all previous state, clearing toggle */
+	} else {
+		csr = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+		if (csr & (1 << USBC_BP_RXCSR_H_RX_PKT_READY)){
+			DMSG_PANIC("WRN: rx%d, packet/%d ready?\n", ep->epnum, USBC_Readw(USBC_REG_RXCOUNT(usbc_base)));
+		}
+
+		sw_hcd_h_rx_flush_fifo(ep, (1 << USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE));
+	}
+
+    /* target addr and (for multipoint) hub addr/port */
+	if (sw_hcd->is_multipoint) {
+		sw_hcd_write_rxfunaddr(ep->target_regs, qh->addr_reg);
+		sw_hcd_write_rxhubaddr(ep->target_regs, qh->h_addr_reg);
+		sw_hcd_write_rxhubport(ep->target_regs, qh->h_port_reg);
+	} else{
+	    USBC_Writeb(qh->addr_reg, USBC_REG_FADDR(usbc_base));
+    }
+
+    /* protocol/endpoint, interval/NAKlimit, i/o size */
+    USBC_Writeb(qh->type_reg, USBC_REG_RXTYPE(usbc_base));
+    USBC_Writeb(qh->intv_reg, USBC_REG_RXINTERVAL(usbc_base));
+
+    /* NOTE: bulk combining rewrites high bits of maxpacket */
+    USBC_Writew(qh->maxpacket, USBC_REG_RXMAXP(usbc_base));
+
+    ep->rx_reinit = 0;
+
+    return;
+}
+
+
+/*
+*******************************************************************************
+*                     sw_hcd_ep_program
+*
+* Description:
+*     Program an HDRC endpoint as per the given URB
+* Context: irqs blocked, controller lock held
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_ep_program(struct sw_hcd *sw_hcd,
+                            u8 epnum,
+                            struct urb *urb,
+                            int is_out,
+                            u8 *buf,
+                            u32 offset,
+                            u32 len)
+{
+	void __iomem            *usbc_base      = NULL;
+	struct sw_hcd_hw_ep   	*hw_ep          = NULL;
+	struct sw_hcd_qh      	*qh             = NULL;
+	u16                     packet_sz       = 0;
+	u16               		old_ep_index    = 0;
+
+    /* check argment */
+    if(sw_hcd == NULL || urb == NULL){
+        DMSG_PANIC("ERR: invalid argment, sw_hcd=0x%p, urb=0x%p\n", sw_hcd, urb);
+	    return ;
+    }
+
+    /* initialize parameter */
+    usbc_base = sw_hcd->mregs;
+    hw_ep = sw_hcd->endpoints + epnum;
+
+    if (!is_out || hw_ep->is_shared_fifo){
+		qh = hw_ep->in_qh;
+	}else{
+		qh = hw_ep->out_qh;
+    }
+
+    packet_sz = qh->maxpacket;
+
+	DMSG_DBG_HCD("sw_hcd_ep_program: %s hw%d urb %p spd%d dev%d ep%d%s "
+				"h_addr%02x h_port%02x bytes %d\n",
+    			is_out ? "-->" : "<--",
+    			epnum, urb, urb->dev->speed,
+    			qh->addr_reg, qh->epnum, is_out ? "out" : "in",
+    			qh->h_addr_reg, qh->h_port_reg,
+    			len);
+
+    old_ep_index = USBC_GetActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+    sw_hcd_ep_select(usbc_base, epnum);
+
+	/* make sure we clear DMAEnab, autoSet bits from previous run */
+
+	/* OUT/transmit/EP0 or IN/receive? */
+	if (is_out) {   /* tx */
+		u16	csr = 0;
+		u16	int_txe = 0;
+		u16	load_count = 0;
+
+        csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+
+		/* disable interrupt in case we flush */
+        int_txe = USBC_Readw(USBC_REG_INTTxE(usbc_base));
+        USBC_Writew(int_txe & ~(1 << epnum), USBC_REG_INTTxE(usbc_base));
+
+		/* general endpoint setup */
+		if(epnum){
+			/* flush all old state, set default */
+			sw_hcd_h_tx_flush_fifo(hw_ep);
+
+			/*
+			 * We must not clear the DMAMODE bit before or in
+			 * the same cycle with the DMAENAB bit, so we clear
+			 * the latter first...
+			 */
+			csr &= ~((1 << USBC_BP_TXCSR_H_NAK_TIMEOUT)
+					| (1 << USBC_BP_TXCSR_H_AUTOSET)
+					| (1 << USBC_BP_TXCSR_H_DMA_REQ_EN)
+					| (1 << USBC_BP_TXCSR_H_FORCE_DATA_TOGGLE)
+					| (1 << USBC_BP_TXCSR_H_TX_STALL)
+					| (1 << USBC_BP_TXCSR_H_ERROR)
+					| (1 << USBC_BP_TXCSR_H_TX_READY)
+					);
+			csr |= (1 << USBC_BP_TXCSR_H_MODE);
+
+            if (usb_gettoggle(urb->dev, qh->epnum, 1)){
+				csr |= (1 << USBC_BP_TXCSR_H_DATA_TOGGLE_WR_EN)
+					| (1 << USBC_BP_TXCSR_H_DATA_TOGGLE);
+			}else{
+				csr |= (1 << USBC_BP_TXCSR_H_CLEAR_DATA_TOGGLE);
+            }
+
+            USBC_Writew(csr, USBC_REG_TXCSR(usbc_base));
+
+            /* REVISIT may need to clear FLUSHFIFO ... */
+            csr &= ~(1 << USBC_BP_TXCSR_H_DMA_REQ_MODE);
+			USBC_Writew(csr, USBC_REG_TXCSR(usbc_base));
+
+			csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+        }else{
+            /* endpoint 0: just flush */
+			sw_hcd_h_ep0_flush_fifo(hw_ep);
+        }
+
+		/* target addr and (for multipoint) hub addr/port */
+		if (sw_hcd->is_multipoint) {
+			sw_hcd_write_txfunaddr(usbc_base, epnum, qh->addr_reg);
+			sw_hcd_write_txhubaddr(usbc_base, epnum, qh->h_addr_reg);
+			sw_hcd_write_txhubport(usbc_base, epnum, qh->h_port_reg);
+
+            /* FIXME if !epnum, do the same for RX ... */
+		}else{
+			USBC_Writeb(qh->addr_reg, USBC_REG_FADDR(usbc_base));
+        }
+
+		/* protocol/endpoint/interval/NAKlimit */
+		if (epnum) {
+		    USBC_Writeb(qh->type_reg, USBC_REG_TXTYPE(usbc_base));
+
+			if (can_bulk_split(sw_hcd, qh->type)){
+			    u32 tx_pkt_size = packet_sz | (((hw_ep->max_packet_sz_tx / packet_sz) - 1) << USBC_BP_TXMAXP_PACKET_COUNT);
+
+			    USBC_Writew(tx_pkt_size, USBC_REG_TXMAXP(usbc_base));
+			}else{
+				USBC_Writew(packet_sz, USBC_REG_TXMAXP(usbc_base));
+			}
+
+			USBC_Writeb(qh->intv_reg, USBC_REG_TXINTERVAL(usbc_base));
+		} else {
+		    USBC_Writeb(qh->intv_reg, USBC_REG_NAKLIMIT0(usbc_base));
+
+			if (sw_hcd->is_multipoint){
+			    USBC_Writeb(qh->type_reg, USBC_REG_EP0TYPE(usbc_base));
+            }
+		}
+
+		if (can_bulk_split(sw_hcd, qh->type)){
+			load_count = min((u32) hw_ep->max_packet_sz_tx, len);
+		}else{
+			load_count = min((u32) packet_sz, len);
+        }
+
+        /* dma transmit */
+        if (is_sw_hcd_dma_capable(sw_hcd->usbc_no, len, packet_sz, epnum)){
+			if(sw_hcd_tx_dma_program(hw_ep, qh, urb, offset, len)){
+				load_count = 0;
+			}
+        }
+
+        if (load_count) {
+			/* PIO to load FIFO */
+			qh->segsize = load_count;
+			sw_hcd_write_fifo(hw_ep, load_count, buf);
+		}
+
+        /* re-enable interrupt */
+        USBC_Writew(int_txe, USBC_REG_INTTxE(usbc_base));
+
+    }else{  /* IN/receive */    /* rx */
+		u16	csr = 0;
+
+		if (hw_ep->rx_reinit) {
+			sw_hcd_rx_reinit(sw_hcd, qh, hw_ep);
+
+			/* init new state: toggle and NYET, maybe DMA later */
+			if (usb_gettoggle(urb->dev, qh->epnum, 0)){
+				csr = (1 << USBC_BP_RXCSR_H_DATA_TOGGLE_WR_EN)
+					| (1 << USBC_BP_RXCSR_H_DATA_TOGGLE);
+			}else{
+				csr = 0;
+			}
+
+			if (qh->type == USB_ENDPOINT_XFER_INT){
+				csr |= (1 << USBC_BP_RXCSR_H_DISNYET);
+            }
+		} else {
+			csr = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+
+			if (csr & ((1 << USBC_BP_RXCSR_H_RX_PKT_READY)
+					| (1 << USBC_BP_RXCSR_H_DMA_REQ_EN)
+					| (1 << USBC_BP_RXCSR_H_REQ_PACKET))){
+				DMSG_PANIC("ERR: broken !rx_reinit, ep%d csr %04x\n", hw_ep->epnum, csr);
+			}
+
+			/* scrub any stale state, leaving toggle alone */
+			csr &= (1 << USBC_BP_RXCSR_H_DISNYET);
+		}
+
+        /* kick things off */
+		if(is_sw_hcd_dma_capable(sw_hcd->usbc_no, len, packet_sz, epnum)){
+			qh->segsize = len;
+
+			/* AUTOREQ is in a DMA register */
+			USBC_Writew(csr, USBC_REG_RXCSR(usbc_base));
+
+			csr = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+
+			csr |= (1 << USBC_BP_RXCSR_H_AUTO_CLEAR);
+			csr |= (1 << USBC_BP_RXCSR_H_AUTO_REQ);
+			csr |= (1 << USBC_BP_RXCSR_H_DMA_REQ_MODE);
+
+			USBC_Host_ConfigRqPktCount(sw_hcd->sw_hcd_io->usb_bsp_hdle, qh->hw_ep->epnum, (len / qh->maxpacket));
+
+		    /* config dma */
+		    sw_hcd_dma_set_config(qh, (urb->transfer_dma + offset), len);
+
+			sw_hcd_dma_start(qh, (u32)hw_ep->fifo, (urb->transfer_dma + offset), len);
+
+			csr |= (1 << USBC_BP_RXCSR_H_DMA_REQ_EN);
+		}
+
+        csr |= (1 << USBC_BP_RXCSR_H_REQ_PACKET);
+
+		DMSG_DBG_DMA("1RXCSR%d := %04x\n", epnum, csr);
+
+		USBC_Writew(csr, USBC_REG_RXCSR(usbc_base));
+		csr = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+    }
+
+    sw_hcd_ep_select(usbc_base, old_ep_index);
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_ep0_continue
+*
+* Description:
+*    Service the default endpoint (ep0) as host.
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    Return true until it's time to start the status stage.
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static bool sw_hcd_h_ep0_continue(struct sw_hcd *sw_hcd, u16 len, struct urb *urb)
+{
+	bool                    more        = false;
+	u8                      *fifo_dest  = NULL;
+	u16                     fifo_count  = 0;
+	struct sw_hcd_hw_ep    	*hw_ep      = NULL;
+	struct sw_hcd_qh       	*qh         = NULL;
+	struct usb_ctrlrequest  *request    = NULL;
+
+    /* check argment */
+    if(sw_hcd == NULL || urb == NULL){
+        DMSG_PANIC("ERR: invalid argment, sw_hcd=0x%p, urb=0x%p\n", sw_hcd, urb);
+	    return false;
+    }
+
+    /* initialize parameter */
+    hw_ep = sw_hcd->control_ep;
+    qh = hw_ep->in_qh;
+
+    switch (sw_hcd->ep0_stage) {
+	    case SW_HCD_EP0_IN:
+        {
+    		fifo_dest  = urb->transfer_buffer + urb->actual_length;
+    		fifo_count = min_t(size_t, len, urb->transfer_buffer_length - urb->actual_length);
+    		if (fifo_count < len){
+    			urb->status = -EOVERFLOW;
+            }
+
+    		sw_hcd_read_fifo(hw_ep, fifo_count, fifo_dest);
+
+    		urb->actual_length += fifo_count;
+    		if (len < qh->maxpacket) {
+    			/* always terminate on short read; it's
+    			 * rarely reported as an error.
+    			 */
+    			USBC_Host_ReadDataStatus(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+    		} else if (urb->actual_length < urb->transfer_buffer_length){
+    			more = true;
+    			USBC_Host_ReadDataStatus(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_EP0, 0);
+    		}
+		}
+		break;
+
+	    case SW_HCD_EP0_START:
+    		request = (struct usb_ctrlrequest *) urb->setup_packet;
+
+    		if (!request->wLength) {
+    			DMSG_DBG_HCD("start no-DATA\n");
+
+    			break;
+    		} else if (request->bRequestType & USB_DIR_IN) {
+    			DMSG_DBG_HCD("start IN-DATA\n");
+
+    			sw_hcd->ep0_stage = SW_HCD_EP0_IN;
+    			more = true;
+    			break;
+    		} else {
+    			DMSG_DBG_HCD("start OUT-DATA\n");
+
+    			sw_hcd->ep0_stage = SW_HCD_EP0_OUT;
+    			more = true;
+    		}
+		/* FALLTHROUGH */
+	    case SW_HCD_EP0_OUT:
+    		fifo_count = min_t(size_t, qh->maxpacket, urb->transfer_buffer_length - urb->actual_length);
+
+			DMSG_DBG_HCD("Sending %d byte to ep0 fifo, urb(0x%p, %d, %d)\n",
+						fifo_count,
+						urb, urb->transfer_buffer_length, urb->actual_length);
+
+    		if (fifo_count) {
+    			fifo_dest = (u8 *) (urb->transfer_buffer + urb->actual_length);
+
+    			sw_hcd_write_fifo(hw_ep, fifo_count, fifo_dest);
+
+    			urb->actual_length += fifo_count;
+    			more = true;
+    		}
+		break;
+
+    	default:
+    		DMSG_PANIC("ERR: bogus ep0 stage %d\n", sw_hcd->ep0_stage);
+    		break;
+    }
+
+    return more;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_ep0_irq
+*
+* Description:
+*    Handle default endpoint interrupt as host. Only called in IRQ time
+* from sw_hcd_interrupt().
+*
+* Parameters:
+*    sw_hcd   :  input.  USB 
+*
+* Return value:
+*    void
+*
+* note:
+*    called with controller irqlocked
+*
+*******************************************************************************
+*/
+irqreturn_t sw_hcd_h_ep0_irq(struct sw_hcd *sw_hcd)
+{
+	struct urb          *urb        = NULL;
+	u16                 csr         = 0;
+	u16                 len         = 0;
+	int                 status      = 0;
+	void __iomem        *usbc_base  = NULL;
+	struct sw_hcd_hw_ep *hw_ep  	= NULL;
+	struct sw_hcd_qh	*qh    		= NULL;
+	bool                complete    = false;
+	irqreturn_t         retval      = IRQ_NONE;
+
+    /* check argment */
+    if(sw_hcd == NULL ){
+        DMSG_PANIC("ERR: invalid argment\n");
+	    return IRQ_HANDLED;
+    }
+
+    /* initialize parameter */
+    usbc_base   = sw_hcd->mregs;
+    hw_ep       = sw_hcd->control_ep;
+    qh          = hw_ep->in_qh;
+
+	DMSG_DBG_HCD("sw_hcd_h_ep0_irq:qh = 0x%p, in_qh = 0x%p, out_qh = 0x%p\n", qh, hw_ep->in_qh, hw_ep->out_qh);
+
+	/* ep0 only has one queue, "in" */
+	urb = next_urb(qh);
+	if(urb == NULL){
+		DMSG_PANIC("ERR: sw_hcd_h_ep0_irq, urb is NULL\n");
+		return IRQ_HANDLED;
+	}
+
+	sw_hcd_ep_select(usbc_base, 0);
+    csr = USBC_Readw(USBC_REG_CSR0(usbc_base));
+
+    if(csr & (1 << USBC_BP_CSR0_H_RxPkRdy)){
+        len = USBC_Readw(USBC_REG_COUNT0(usbc_base));
+    }else{
+        len = 0;
+    }
+
+	DMSG_DBG_HCD("sw_hcd_h_ep0_irq: csr0 %04x, qh %p, count %d, urb(0x%p, %d, %d), stage %d\n",
+		       csr, qh, len, urb, urb->transfer_buffer_length, urb->actual_length, sw_hcd->ep0_stage);
+
+	/* if we just did status stage, we are done */
+	if (SW_HCD_EP0_STATUS == sw_hcd->ep0_stage) {
+		retval = IRQ_HANDLED;
+		complete = true;
+	}
+
+	/* prepare status */
+	if (csr & (1 << USBC_BP_CSR0_H_RxStall)) {
+		DMSG_PANIC("ERR: sw_hcd_h_ep0_irq, STALLING ENDPOINT\n");
+		USBC_Host_ClearEpStall(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_EP0);
+
+		status = -EPIPE;
+	} else if (csr & (1 << USBC_BP_CSR0_H_Error)) {
+		DMSG_PANIC("ERR: sw_hcd_h_ep0_irq, no response, csr0 %04x\n", csr);
+		USBC_Host_ClearEpError(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_EP0);
+
+		status = -EPROTO;
+	} else if (csr & (1 << USBC_BP_CSR0_H_NAK_Timeout)) {
+		DMSG_PANIC("ERR: sw_hcd_h_ep0_irq, control NAK timeout\n");
+
+		USBC_Writew(0x00, USBC_REG_CSR0(usbc_base));
+		USBC_Writeb(0x00, USBC_REG_NAKLIMIT0(usbc_base));
+
+		retval = IRQ_HANDLED;
+	}
+
+	if (status) {
+		DMSG_PANIC("ERR: sw_hcd_h_ep0_irq, ep aborting\n");
+
+		retval = IRQ_HANDLED;
+		if (urb){
+			urb->status = status;
+		}
+
+		complete = true;
+
+		/* use the proper sequence to abort the transfer */
+		if (csr & (1 << USBC_BP_CSR0_H_ReqPkt)) {
+			csr &= ~(1 << USBC_BP_CSR0_H_ReqPkt);
+
+			USBC_Writew(csr, USBC_REG_CSR0(usbc_base));
+
+			csr &= ~(1 << USBC_BP_CSR0_H_NAK_Timeout);
+			USBC_Writew(csr, USBC_REG_CSR0(usbc_base));
+		} else {
+			sw_hcd_h_ep0_flush_fifo(hw_ep);
+		}
+
+		USBC_Writeb(0x00, USBC_REG_NAKLIMIT0(usbc_base));
+
+		/* clear it */
+		USBC_Writew(0x00, USBC_REG_CSR0(usbc_base));
+	}
+
+	if (unlikely(!urb)) {
+		/* stop endpoint since we have no place for its data, this
+		 * SHOULD NEVER HAPPEN! */
+		DMSG_PANIC("ERR: sw_hcd_h_ep0_irq, no URB for ep 0\n");
+
+		sw_hcd_h_ep0_flush_fifo(hw_ep);
+
+		goto done;
+	}
+
+	if (!complete) {
+		/* call common logic and prepare response */
+		if (sw_hcd_h_ep0_continue(sw_hcd, len, urb)) {
+			/* more packets required */
+			csr = (SW_HCD_EP0_IN == sw_hcd->ep0_stage)
+				?  (1 << USBC_BP_CSR0_H_ReqPkt) : (1 << USBC_BP_CSR0_H_TxPkRdy);
+		} else {
+			/* data transfer complete; perform status phase */
+			if (usb_pipeout(urb->pipe) || !urb->transfer_buffer_length){
+				csr = (1 << USBC_BP_CSR0_H_StatusPkt)
+					| (1 << USBC_BP_CSR0_H_ReqPkt);
+			}else{
+				csr = (1 << USBC_BP_CSR0_H_StatusPkt)
+					| (1 << USBC_BP_CSR0_H_TxPkRdy);
+            }
+
+			/* flag status stage */
+			sw_hcd->ep0_stage = SW_HCD_EP0_STATUS;
+		}
+
+		USBC_Writew(csr, USBC_REG_CSR0(usbc_base));
+
+		retval = IRQ_HANDLED;
+	}else{
+		sw_hcd->ep0_stage = SW_HCD_EP0_IDLE;
+		USBC_Writew(0x00, USBC_REG_CSR0(usbc_base));
+    }
+
+	/* call completion handler if done */
+	if(complete){
+		sw_hcd_advance_schedule(sw_hcd, urb, hw_ep, 1);
+	}
+
+done:
+	return retval;
+}
+EXPORT_SYMBOL(sw_hcd_h_ep0_irq);
+
+/*
+*******************************************************************************
+*                     sw_hcd_host_tx
+*
+* Description:
+*    Service a Tx-Available or dma completion irq for the endpoint
+*
+* Parameters:
+*    sw_hcd   :  input.  USB 
+*    epnum  :  input.  ep index
+*
+* Return value:
+*    void
+*
+* note:
+*   Host side TX (OUT) using Mentor DMA works as follows:
+*	submit_urb ->
+*		- if queue was empty, Program Endpoint
+*		- ... which starts DMA to fifo in mode 1 or 0
+*
+*   DMA Isr (transfer complete) -> TxAvail()
+*		- Stop DMA (~DmaEnab)	(<--- Alert ... currently happens
+*					only in sw_hcd_cleanup_urb)
+*		- TxPktRdy has to be set in mode 0 or for
+*			short packets in mode 1.
+*
+*******************************************************************************
+*/
+void sw_hcd_host_tx(struct sw_hcd *sw_hcd, u8 epnum)
+{
+	int                 pipe        = 0;
+	bool                done        = false;
+	u16                 tx_csr      = 0;
+	size_t              length      = 0;
+	size_t              offset      = 0;
+	struct urb          *urb        = NULL;
+	struct sw_hcd_hw_ep	*hw_ep      = NULL;
+	struct sw_hcd_qh  	*qh         = NULL;
+	u32			        status      = 0;
+	void __iomem		*usbc_base  = NULL;
+
+    /* check argment */
+    if(sw_hcd == NULL){
+        DMSG_PANIC("ERR: invalid argment\n");
+	    return ;
+    }
+
+    /* initialize parameter */
+    hw_ep 		= sw_hcd->endpoints + epnum;
+    qh 			= hw_ep->is_shared_fifo ? hw_ep->in_qh : hw_ep->out_qh;
+    usbc_base 	= sw_hcd->mregs;
+
+	urb = next_urb(qh);
+	if(urb == NULL){
+		DMSG_PANIC("ERR: sw_hcd_host_tx, urb is NULL\n");
+		return ;
+	}
+
+	sw_hcd_ep_select(usbc_base, epnum);
+
+	tx_csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+
+	/* with CPPI, DMA sometimes triggers "extra" irqs */
+	if (!urb) {
+		DMSG_PANIC("ERR: sw_hcd_host_tx, extra TX%d ready, csr %04x\n", epnum, tx_csr);
+		return;
+	}
+
+	pipe = urb->pipe;
+
+	DMSG_DBG_HCD("rx: ep(0x%p, %d, 0x%x), qh(0x%p, 0x%x, 0x%x), urb(0x%p, 0x%p, %d, %d), dma(0x%x, 0x%x, 0x%x)\n",
+		      hw_ep, hw_ep->epnum, USBC_Readw(USBC_REG_TXCSR(usbc_base)),
+		      qh, qh->epnum, qh->type,
+		      urb, urb->transfer_buffer, urb->transfer_buffer_length, urb->actual_length);
+
+	/* check for errors */
+	if (tx_csr & (1 << USBC_BP_TXCSR_H_TX_STALL)) {
+		/* dma was disabled, fifo flushed */
+		DMSG_PANIC("ERR: sw_hcd_host_tx, TX end %d stall\n", epnum);
+
+		/* stall; record URB status */
+		status = -EPIPE;
+
+	} else if (tx_csr & (1 << USBC_BP_TXCSR_H_ERROR)) {
+		/* (NON-ISO) dma was disabled, fifo flushed */
+		DMSG_PANIC("ERR: sw_hcd_host_tx, TX 3strikes on ep=%d\n", epnum);
+
+		status = -ETIMEDOUT;
+
+	} else if (tx_csr & (1 << USBC_BP_TXCSR_H_NAK_TIMEOUT)) {
+		DMSG_PANIC("ERR: sw_hcd_host_tx, TX end=%d device not responding\n", epnum);
+
+		/* NOTE:  this code path would be a good place to PAUSE a
+		 * transfer, if there's some other (nonperiodic) tx urb
+		 * that could use this fifo.  (dma complicates it...)
+		 * That's already done for bulk RX transfers.
+		 *
+		 * if (bulk && qh->ring.next != &sw_hcd->out_bulk), then
+		 * we have a candidate... NAKing is *NOT* an error
+		 */
+		sw_hcd_ep_select(usbc_base, epnum);
+
+		USBC_Writew((USBC_TXCSR_H_WZC_BITS | USBC_BP_TXCSR_H_TX_READY), USBC_REG_TXCSR(usbc_base));
+
+		return;
+	}
+
+	if (status) {
+		/* dma is working */
+		if(sw_hcd_dma_is_busy(qh)){
+			DMSG_PANIC("ERR: tx ep error during dma phase\n");
+
+			/* stop dma */
+			sw_hcd_dma_stop(qh);
+			sw_hcd_clean_ep_dma_status_and_flush_fifo(qh);
+		}
+
+		/* do the proper sequence to abort the transfer in the
+		 * usb core; the dma engine should already be stopped.
+		 */
+		sw_hcd_h_tx_flush_fifo(hw_ep);
+		tx_csr &= ~((1 << USBC_BP_TXCSR_H_AUTOSET)
+				| (1 << USBC_BP_TXCSR_H_DMA_REQ_EN)
+				| (1 << USBC_BP_TXCSR_H_ERROR)
+				| (1 << USBC_BP_TXCSR_H_TX_STALL)
+				| (1 << USBC_BP_TXCSR_H_NAK_TIMEOUT)
+				);
+
+		sw_hcd_ep_select(usbc_base, epnum);
+
+		USBC_Writew(tx_csr, USBC_REG_TXCSR(usbc_base));
+		/* REVISIT may need to clear FLUSHFIFO ... */
+		USBC_Writew(tx_csr, USBC_REG_TXCSR(usbc_base));
+
+		USBC_Writew(0x00, USBC_REG_TXINTERVAL(usbc_base));
+
+		done = true;
+	}
+
+	if (is_sw_hcd_dma_capable(sw_hcd->usbc_no, qh->segsize, qh->maxpacket, epnum)
+		&& !status) {
+		/* dmaUSBFIFO,
+		 * TX_READY
+		 *
+		 * , dma, callback, return
+		 */
+		if (tx_csr & ((1 << USBC_BP_TXCSR_H_FIFO_NOT_EMPTY) | (1 << USBC_BP_TXCSR_H_TX_READY))) {
+			__u32 cmt = 0xfff;
+
+			while(cmt && (tx_csr & ((1 << USBC_BP_TXCSR_H_FIFO_NOT_EMPTY) | (1 << USBC_BP_TXCSR_H_TX_READY)))){
+				tx_csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+				cmt--;
+			}
+
+			if(cmt == 0){
+				DMSG_ERR("ERR: TX ep dma transmit timeout, tx_csr(0x%x), ep(%d), len(%d)\n",
+					     tx_csr, hw_ep->epnum, urb->transfer_buffer_length);
+			}
+		}
+
+		/*
+		 * DMA has completed.  But if we're using DMA mode 1 (multi
+		 * packet DMA), we need a terminal TXPKTRDY interrupt before
+		 * we can consider this transfer completed, lest we trash
+		 * its last packet when writing the next URB's data.  So we
+		 * switch back to mode 0 to get that interrupt; we'll come
+		 * back here once it happens.
+		 */
+		USBC_Host_ClearEpDma(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX);
+
+		/*
+		 * There is no guarantee that we'll get an interrupt
+		 * after clearing DMAMODE as we might have done this
+		 * too late (after TXPKTRDY was cleared by controller).
+		 * Re-read TXCSR as we have spoiled its previous value.
+		 */
+		tx_csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+
+		/*
+		 * We may get here from a DMA completion or TXPKTRDY interrupt.
+		 * In any case, we must check the FIFO status here and bail out
+		 * only if the FIFO still has data -- that should prevent the
+		 * "missed" TXPKTRDY interrupts and deal with double-buffered
+		 * FIFO mode too...
+		 */
+		if (tx_csr & ((1 << USBC_BP_TXCSR_H_FIFO_NOT_EMPTY) | (1 << USBC_BP_TXCSR_H_TX_READY))) {
+			DMSG_ERR("ERR: sw_hcd_host_tx, DMA complete but packet still in FIFO, "
+					 "CSR(%04x), RP_Count(%d), qh(0x%p), urb(0x%p, %d, %d)\n",
+				  	 tx_csr, USBC_Readw(USBC_REG_RPCOUNTx(usbc_base, hw_ep->epnum)),
+				  	 qh, urb, urb->transfer_buffer_length, urb->actual_length);
+
+			return;
+		}
+	}
+
+	if (!status
+		|| is_sw_hcd_dma_capable(sw_hcd->usbc_no, qh->segsize, qh->maxpacket, epnum)
+		|| usb_pipeisoc(pipe)) {
+		length = qh->segsize;
+		qh->offset += length;
+
+		if (usb_pipeisoc(pipe)) {
+			struct usb_iso_packet_descriptor *d = NULL;
+
+			d = urb->iso_frame_desc + qh->iso_idx;
+			d->actual_length = length;
+			d->status = status;
+			if (++qh->iso_idx >= urb->number_of_packets) {
+				done = true;
+			} else {
+				d++;
+				offset = d->offset;
+				length = d->length;
+			}
+		} else if (is_sw_hcd_dma_capable(sw_hcd->usbc_no, qh->segsize, qh->maxpacket, epnum)) {
+			done = true;
+		} else {
+			/* see if we need to send more data, or ZLP */
+			if (qh->segsize < qh->maxpacket)
+				done = true;
+			else if (qh->offset == urb->transfer_buffer_length
+					&& !(urb->transfer_flags & URB_ZERO_PACKET))
+				done = true;
+			if (!done) {
+				offset = qh->offset;
+				length = urb->transfer_buffer_length - offset;
+			}
+		}
+	}
+
+	/* urb->status != -EINPROGRESS means request has been faulted,
+	 * so we must abort this transfer after cleanup
+	 */
+	if (urb->status != -EINPROGRESS) {
+		done = true;
+
+		if (status == 0){
+		    status = urb->status;
+		}
+	}
+
+	if (done) {
+		/* set status */
+		urb->status = status;
+		urb->actual_length = qh->offset;
+		sw_hcd_advance_schedule(sw_hcd, urb, hw_ep, USB_DIR_OUT);
+
+		return;
+	} else	if (usb_pipeisoc(pipe) && is_sw_hcd_dma_capable(sw_hcd->usbc_no, qh->segsize, qh->maxpacket, epnum)) {
+		if (sw_hcd_tx_dma_program(hw_ep, qh, urb, offset, length)){
+		    return;
+		}
+	} else	if (tx_csr & (1 << USBC_BP_TXCSR_H_DMA_REQ_EN)) {
+		DMSG_PANIC("ERR: sw_hcd_host_tx, not complete, but DMA enabled?\n");
+
+		return;
+	}
+
+	/*
+	 * PIO: start next packet in this URB.
+	 *
+	 * REVISIT: some docs say that when hw_ep->tx_double_buffered,
+	 * (and presumably, FIFO is not half-full) we should write *two*
+	 * packets before updating TXCSR; other docs disagree...
+	 */
+	if (length > qh->maxpacket){
+		length = qh->maxpacket;
+	}
+
+	sw_hcd_write_fifo(hw_ep, length, urb->transfer_buffer + offset);
+	qh->segsize = length;
+
+	sw_hcd_ep_select(usbc_base, epnum);
+	USBC_Writew(USBC_TXCSR_H_WZC_BITS | (1 << USBC_BP_TXCSR_H_TX_READY), USBC_REG_TXCSR(usbc_base));
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_host_tx);
+
+/* Host side RX (IN) using Mentor DMA works as follows:
+	submit_urb ->
+		- if queue was empty, ProgramEndpoint
+		- first IN token is sent out (by setting ReqPkt)
+	LinuxIsr -> RxReady()
+	/\	=> first packet is received
+	|	- Set in mode 0 (DmaEnab, ~ReqPkt)
+	|		-> DMA Isr (transfer complete) -> RxReady()
+	|		    - Ack receive (~RxPktRdy), turn off DMA (~DmaEnab)
+	|		    - if urb not complete, send next IN token (ReqPkt)
+	|			   |		else complete urb.
+	|			   |
+	---------------------------
+ *
+ * Nuances of mode 1:
+ *	For short packets, no ack (+RxPktRdy) is sent automatically
+ *	(even if AutoClear is ON)
+ *	For full packets, ack (~RxPktRdy) and next IN token (+ReqPkt) is sent
+ *	automatically => major problem, as collecting the next packet becomes
+ *	difficult. Hence mode 1 is not used.
+ *
+ * REVISIT
+ *	All we care about at this driver level is that
+ *       (a) all URBs terminate with REQPKT cleared and fifo(s) empty;
+ *       (b) termination conditions are: short RX, or buffer full;
+ *       (c) fault modes include
+ *           - iff URB_SHORT_NOT_OK, short RX status is -EREMOTEIO.
+ *             (and that endpoint's dma queue stops immediately)
+ *           - overflow (full, PLUS more bytes in the terminal packet)
+ *
+ *	So for example, usb-storage sets URB_SHORT_NOT_OK, and would
+ *	thus be a great candidate for using mode 1 ... for all but the
+ *	last packet of one URB's transfer.
+ */
+
+/*
+*******************************************************************************
+*                     sw_hcd_bulk_rx_nak_timeout
+*
+* Description:
+*    Schedule next QH from sw_hcd->in_bulk and move the current qh to
+* the end; avoids starvation for other endpoints.
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_bulk_rx_nak_timeout(struct sw_hcd *sw_hcd, struct sw_hcd_hw_ep *ep)
+{
+	struct urb          *urb        = NULL;
+	void __iomem        *usbc_base  = NULL;
+	struct sw_hcd_qh    *cur_qh     = NULL;
+    struct sw_hcd_qh    *next_qh    = NULL;
+	u16                 rx_csr      = 0;
+
+    /* check argment */
+    if(sw_hcd == NULL || ep == NULL){
+        DMSG_PANIC("ERR: invalid argment, sw_hcd=0x%p, ep=0x%p\n", sw_hcd, ep);
+	    return ;
+    }
+
+    /* initialize parameter */
+    usbc_base = sw_hcd->mregs;
+
+	sw_hcd_ep_select(usbc_base, ep->epnum);
+
+	/* clear nak timeout bit */
+	rx_csr = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+	rx_csr |= USBC_RXCSR_H_WZC_BITS;
+	rx_csr &= ~(1 << USBC_BP_RXCSR_H_DATA_ERR);
+	USBC_Writew(rx_csr, USBC_REG_RXCSR(usbc_base));
+
+	cur_qh = first_qh(&sw_hcd->in_bulk);
+	if (cur_qh) {
+		urb = next_urb(cur_qh);
+		if(urb == NULL){
+			DMSG_PANIC("ERR: sw_hcd_bulk_rx_nak_timeout, urb is NULL\n");
+			return ;
+		}
+
+		if (sw_hcd_dma_is_busy(cur_qh)) {
+			urb->actual_length += sw_hcd_dma_transmit_length(cur_qh, is_direction_in(cur_qh), (urb->transfer_dma + urb->actual_length));
+		}
+		sw_hcd_save_toggle(ep, 1, urb);
+
+		/* move cur_qh to end of queue */
+		list_move_tail(&cur_qh->ring, &sw_hcd->in_bulk);
+
+		/* get the next qh from sw_hcd->in_bulk */
+		next_qh = first_qh(&sw_hcd->in_bulk);
+
+		/* set rx_reinit and schedule the next qh */
+		ep->rx_reinit = 1;
+		sw_hcd_start_urb(sw_hcd, 1, next_qh);
+	}
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_host_rx
+*
+* Description:
+*    Service an RX interrupt for the given IN endpoint; docs cover bulk, iso,
+* and high-bandwidth IN transfer cases.
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_host_rx(struct sw_hcd *sw_hcd, u8 epnum)
+{
+	struct urb          *urb        = NULL;
+	struct sw_hcd_hw_ep	*hw_ep      = NULL;
+	struct sw_hcd_qh   	*qh         = NULL;
+	size_t              xfer_len    = 0;
+	void __iomem        *usbc_base  = NULL;
+	int                 pipe        = 0;
+	u16                 rx_csr      = 0;
+	u16                 val         = 0;
+	bool                iso_err     = false;
+	bool                done        = false;
+	u32                 status      = 0;
+	u32 				dma_exceptional = 0;
+
+    /* check argment */
+    if(sw_hcd == NULL){
+        DMSG_PANIC("ERR: invalid argment\n");
+	    return ;
+    }
+
+    /* initialize parameter */
+    hw_ep       = sw_hcd->endpoints + epnum;
+    qh          = hw_ep->in_qh;
+    usbc_base   = sw_hcd->mregs;
+
+	sw_hcd_ep_select(usbc_base, epnum);
+
+	urb = next_urb(qh);
+	if(urb == NULL){
+		DMSG_PANIC("ERR: sw_hcd_host_rx, urb is NULL\n");
+		return ;
+	}
+
+	status      = 0;
+	xfer_len    = 0;
+
+	rx_csr = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+	val = rx_csr;
+
+	if (unlikely(!urb)) {
+		/* REVISIT -- THIS SHOULD NEVER HAPPEN ... but, at least
+		 * usbtest #11 (unlinks) triggers it regularly, sometimes
+		 * with fifo full.  (Only with DMA??)
+		 */
+		DMSG_PANIC("ERR: sw_hcd_host_rx, BOGUS RX%d ready, csr %04x, count %d\n",
+		           epnum, val, USBC_Readw(USBC_REG_RXCOUNT(usbc_base)));
+
+		sw_hcd_h_rx_flush_fifo(hw_ep, (1 << USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE));
+
+		return;
+	}
+
+	pipe = urb->pipe;
+
+	DMSG_DBG_HCD("rx: ep(0x%p, %d, 0x%x, %d), qh(0x%p, 0x%x, 0x%x), urb(0x%p, 0x%p, %d, %d), dma(0x%x, 0x%x, 0x%x)\n",
+		      hw_ep, hw_ep->epnum, USBC_Readw(USBC_REG_RXCSR(usbc_base)), USBC_Readw(USBC_REG_RXCOUNT(usbc_base)),
+		      qh, qh->epnum, qh->type,
+		      urb, urb->transfer_buffer, urb->transfer_buffer_length, urb->actual_length);
+
+	/* check for errors, concurrent stall & unlink is not really
+	 * handled yet! */
+	if (rx_csr & (1 << USBC_BP_RXCSR_H_RX_STALL)) {
+		DMSG_PANIC("ERR: sw_hcd_host_rx, RX end %d STALL(0x%x)\n", epnum, rx_csr);
+		USBC_Host_ClearEpStall(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+		/* stall; record URB status */
+		status = -EPIPE;
+	}else if (rx_csr & (1 << USBC_BP_RXCSR_H_ERROR)){
+		DMSG_PANIC("ERR: sw_hcd_host_rx, end %d RX proto error(0x%x)\n", epnum, rx_csr);
+
+		USBC_Host_ClearEpError(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+        /* if the device is usb hub, then the hub may be disconnect */
+		if(qh->type == USB_ENDPOINT_XFER_INT){
+			status = -ECONNRESET;
+		}else{
+			status = -EPROTO;
+		}
+
+		USBC_Writeb(0x00, USBC_REG_RXINTERVAL(usbc_base));
+	}else if (rx_csr & (1 << USBC_BP_RXCSR_H_DATA_ERR)){
+		if (USB_ENDPOINT_XFER_ISOC != qh->type) {
+			DMSG_PANIC("ERR: sw_hcd_host_rx, RX end %d NAK timeout(0x%x)\n", epnum, rx_csr);
+
+			/* NOTE: NAKing is *NOT* an error, so we want to
+			 * continue.  Except ... if there's a request for
+			 * another QH, use that instead of starving it.
+			 *
+			 * Devices like Ethernet and serial adapters keep
+			 * reads posted at all times, which will starve
+			 * other devices without this logic.
+			 */
+			if (usb_pipebulk(urb->pipe)
+					&& qh->mux == 1
+					&& !list_is_singular(&sw_hcd->in_bulk)) {
+				sw_hcd_bulk_rx_nak_timeout(sw_hcd, hw_ep);
+
+				return;
+			}
+
+			sw_hcd_ep_select(usbc_base, epnum);
+			rx_csr |= USBC_RXCSR_H_WZC_BITS;
+			rx_csr &= ~(1 << USBC_BP_RXCSR_H_DATA_ERR);
+			USBC_Writew(rx_csr, USBC_REG_RXCSR(usbc_base));
+
+			goto finish;
+		} else {
+			DMSG_PANIC("ERR: sw_hcd_host_rx, RX end %d ISO data error(0x%x)\n", epnum, rx_csr);
+
+			/* packet error reported later */
+			iso_err = true;
+		}
+	}
+
+	/* faults abort the transfer */
+	if (status) {
+		/* clean up dma and collect transfer count */
+		if(sw_hcd_dma_is_busy(qh)){
+			DMSG_PANIC("ERR: rx ep error during dma phase\n");
+
+			/* stop dma */
+			sw_hcd_dma_stop(qh);
+			sw_hcd_clean_ep_dma_status_and_flush_fifo(qh);
+			xfer_len = sw_hcd_dma_transmit_length(qh, is_direction_in(qh), (urb->transfer_dma + urb->actual_length));
+		}
+
+		sw_hcd_h_rx_flush_fifo(hw_ep, 1 << USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE);
+
+		USBC_Writeb(0x00, USBC_REG_RXINTERVAL(usbc_base));
+
+		done = true;
+
+		goto finish;
+	}
+
+	/* thorough shutdown for now ... given more precise fault handling
+	 * and better queueing support, we might keep a DMA pipeline going
+	 * while processing this irq for earlier completions.
+	 */
+
+	/* FIXME this is _way_ too much in-line logic for Mentor DMA */
+	if (rx_csr & (1 << USBC_BP_RXCSR_H_REQ_PACKET))  {
+		/* REVISIT this happened for a while on some short reads...
+		 * the cleanup still needs investigation... looks bad...
+		 * and also duplicates dma cleanup code above ... plus,
+		 * shouldn't this be the "half full" double buffer case?
+		 */
+		if(sw_hcd_dma_is_busy(qh)){
+			DMSG_PANIC("ERR: rx ep error during dma phase\n");
+
+			/* stop dma */
+			sw_hcd_dma_stop(qh);
+			sw_hcd_clean_ep_dma_status_and_flush_fifo(qh);
+			xfer_len = sw_hcd_dma_transmit_length(qh, is_direction_in(qh), (urb->transfer_dma + urb->actual_length));
+
+			done = true;
+		}
+
+		DMSG_DBG_HCD("sw_hcd_host_rx, epnum, = %d, RXCSR = 0x%x, len = %d\n",
+			      epnum, rx_csr, xfer_len);
+
+		rx_csr &= ~(1 << USBC_BP_RXCSR_H_REQ_PACKET);
+
+		sw_hcd_ep_select(usbc_base, epnum);
+		USBC_Writew((USBC_RXCSR_H_WZC_BITS | rx_csr), USBC_REG_RXCSR(usbc_base));
+	}
+
+	if (is_sw_hcd_dma_capable(sw_hcd->usbc_no, qh->segsize, qh->maxpacket, epnum) && (rx_csr & (1 << USBC_BP_RXCSR_H_DMA_REQ_EN))) {
+		/* during dma, if usb receive short packet, then rx irq come */
+
+		/* DMA */
+		xfer_len = sw_hcd_dma_transmit_length(qh, is_direction_in(qh), (urb->transfer_dma + urb->actual_length));
+
+		/* DMA */
+		if(sw_hcd_dma_is_busy(qh)){
+			DMSG_WRN("WRN: during dma phase, rx irq come\n");
+			sw_hcd_dma_stop(qh);
+			dma_exceptional = 1;
+		}
+
+		/* clear dma status */
+		if (usb_pipeisoc(pipe)) {
+			struct usb_iso_packet_descriptor *d = NULL;
+
+			d = urb->iso_frame_desc + qh->iso_idx;
+			d->actual_length = xfer_len;
+
+			/* even if there was an error, we did the dma
+			 * for iso_frame_desc->length
+			 */
+			if (d->status != EILSEQ && d->status != -EOVERFLOW){
+				d->status = 0;
+            }
+
+			if (++qh->iso_idx >= urb->number_of_packets){
+				done = true;
+			}else{
+				done = false;
+			}
+		}else {
+			if((urb->actual_length + xfer_len) >= urb->transfer_buffer_length){  /* urb buffer is full */
+				done = 1;
+			}else if(USBC_Host_IsReadDataReady(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_RX)){  /* short packet */
+				if(dma_exceptional){ /* receive short packet */
+					urb->actual_length += xfer_len;
+					qh->offset += xfer_len;
+					done = sw_hcd_host_packet_rx(sw_hcd, urb, epnum, iso_err);
+				}else{
+					DMSG_PANIC("ERR: have more packet\n");
+					done = 0;
+				}
+			}else{
+				DMSG_PANIC("ERR: unkow rx irq come\n");
+				done = 1;
+			}
+		}
+
+		sw_hcd_clean_ep_dma_status(qh);
+    }else if (urb->status == -EINPROGRESS){
+		/* if no errors, be sure a packet is ready for unloading */
+		if (unlikely(!(rx_csr & (1 << USBC_BP_RXCSR_H_RX_PKT_READY)))) {
+			status = -EPROTO;
+
+			DMSG_PANIC("ERR: sw_hcd_host_rx, Rx interrupt with no errors or packet!\n");
+
+			/* FIXME this is another "SHOULD NEVER HAPPEN" */
+
+            /* SCRUB (RX) */
+			/* do the proper sequence to abort the transfer */
+			sw_hcd_ep_select(usbc_base, epnum);
+
+			val &= ~(1 << USBC_BP_RXCSR_H_REQ_PACKET);
+			USBC_Writew(val, USBC_REG_RXCSR(usbc_base));
+
+			goto finish;
+		}
+
+		/* we are expecting IN packets */
+		if (is_sw_hcd_dma_capable(sw_hcd->usbc_no, qh->segsize, qh->maxpacket, epnum)) {
+			u16 rx_count = 0;
+			int length = 0, desired_mode = 0;
+			dma_addr_t buf = 0;
+
+			rx_count = USBC_Readw(USBC_REG_RXCOUNT(usbc_base));
+
+			DMSG_DBG_DMA("ERR: sw_hcd_host_rx, RX%d count %d, buffer 0x%x len %d/%d\n",
+    					epnum, rx_count,
+    					urb->transfer_dma + urb->actual_length,
+    					qh->offset,
+    					urb->transfer_buffer_length);
+
+			if (usb_pipeisoc(pipe)) {
+				int status = 0;
+				struct usb_iso_packet_descriptor *d = NULL;
+
+				d = urb->iso_frame_desc + qh->iso_idx;
+
+				if (iso_err) {
+					status = -EILSEQ;
+					urb->error_count++;
+				}
+
+				if (rx_count > d->length) {
+					if (status == 0) {
+						status = -EOVERFLOW;
+						urb->error_count++;
+					}
+
+					DMSG_DBG_HCD("ERR: sw_hcd_host_rx, OVERFLOW %d into %d\n", rx_count, d->length);
+
+					length = d->length;
+				} else{
+					length = rx_count;
+				}
+
+				d->status = status;
+				buf = urb->transfer_dma + d->offset;
+			} else {
+				length = rx_count;
+				buf = urb->transfer_dma + urb->actual_length;
+			}
+
+			desired_mode = 0;
+
+			/* because of the issue below, mode 1 will
+			 * only rarely behave with correct semantics.
+			 */
+			if ((urb->transfer_flags & URB_SHORT_NOT_OK)
+				&& ((urb->transfer_buffer_length - urb->actual_length) > qh->maxpacket)){
+				desired_mode = 1;
+			}
+
+			if (rx_count < hw_ep->max_packet_sz_rx) {
+				length = rx_count;
+				desired_mode = 0;
+			} else {
+				length = urb->transfer_buffer_length;
+			}
+
+            /* Disadvantage of using mode 1:
+             *	It's basically usable only for mass storage class; essentially all
+             *	other protocols also terminate transfers on short packets.
+             *
+             * Details:
+             *	An extra IN token is sent at the end of the transfer (due to AUTOREQ)
+             *	If you try to use mode 1 for (transfer_buffer_length - 512), and try
+             *	to use the extra IN token to grab the last packet using mode 0, then
+             *	the problem is that you cannot be sure when the device will send the
+             *	last packet and RxPktRdy set. Sometimes the packet is recd too soon
+             *	such that it gets lost when RxCSR is re-set at the end of the mode 1
+             *	transfer, while sometimes it is recd just a little late so that if you
+             *	try to configure for mode 0 soon after the mode 1 transfer is
+             *	completed, you will find rxcount 0. Okay, so you might think why not
+             *	wait for an interrupt when the pkt is recd. Well, you won't get any!
+             */
+
+			val = USBC_Readw(USBC_REG_RXCSR(usbc_base));
+			val &= ~(1 << USBC_BP_RXCSR_H_REQ_PACKET);
+
+			if (desired_mode == 0){
+				val &= ~(1 << USBC_BP_RXCSR_H_AUTO_REQ);
+			}else{
+				val |= (1 << USBC_BP_RXCSR_H_AUTO_REQ);
+			}
+
+			val |= (1 << USBC_BP_RXCSR_H_AUTO_CLEAR) | (1 << USBC_BP_RXCSR_H_DMA_REQ_EN);
+			val |= USBC_RXCSR_H_WZC_BITS;
+			USBC_Writew(val, USBC_REG_RXCSR(usbc_base));
+
+			USBC_Host_ConfigRqPktCount(sw_hcd->sw_hcd_io->usb_bsp_hdle, qh->hw_ep->epnum, (length / qh->maxpacket));
+
+			/* REVISIT if when actual_length != 0,
+			 * transfer_buffer_length needs to be
+			 * adjusted first...
+			 */
+		    sw_hcd_dma_set_config(qh, buf, length);
+			sw_hcd_dma_start(qh, (u32)hw_ep->fifo, buf, length);
+
+ 			DMSG_DBG_DMA("RXCSR%d := %04x\n", epnum, val);
+       }
+
+        if (!is_sw_hcd_dma_capable(sw_hcd->usbc_no, qh->segsize, qh->maxpacket, epnum)) {
+			done = sw_hcd_host_packet_rx(sw_hcd, urb, epnum, iso_err);
+			DMSG_DBG_HCD("ERR: sw_hcd_host_rx, read %spacket\n", done ? "last " : "");
+		}
+    }
+
+finish:
+	if(!dma_exceptional){
+		urb->actual_length += xfer_len;
+		qh->offset += xfer_len;
+	}
+
+	if (done) {
+		if (urb->status == -EINPROGRESS){
+			urb->status = status;
+		}
+
+		sw_hcd_advance_schedule(sw_hcd, urb, hw_ep, USB_DIR_IN);
+	}
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_host_rx);
+
+/*
+*******************************************************************************
+*                     sw_hcd_schedule
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    schedule nodes correspond to peripheral endpoints, like an OHCI QH.
+* the software schedule associates multiple such nodes with a given
+* host side hardware endpoint + direction; scheduling may activate
+* that hardware endpoint.
+*
+*******************************************************************************
+*/
+static int sw_hcd_schedule(struct sw_hcd *sw_hcd,
+                         struct sw_hcd_qh *qh,
+                         int is_in)
+{
+	int                 idle        = 0;
+	int                 best_diff   = 0;
+	int                 best_end    = 0;
+	int                 epnum       = 0;
+	struct sw_hcd_hw_ep   *hw_ep      = NULL;
+	struct list_head    *head       = NULL;
+
+	/* use fixed hardware for control and bulk */
+	if (qh->type == USB_ENDPOINT_XFER_CONTROL) {
+		head  = &sw_hcd->control;
+		hw_ep = sw_hcd->control_ep;
+
+		goto success;
+	}
+
+	/* else, periodic transfers get muxed to other endpoints */
+
+	/*
+	 * We know this qh hasn't been scheduled, so all we need to do
+	 * is choose which hardware endpoint to put it on ...
+	 *
+	 * REVISIT what we really want here is a regular schedule tree
+	 * like e.g. OHCI uses.
+	 */
+	best_diff = 4096;
+	best_end = -1;
+
+	for (epnum = 1, hw_ep = sw_hcd->endpoints + 1;
+		 epnum < sw_hcd->nr_endpoints;
+		 epnum++, hw_ep++) {
+		int	diff = 0;
+
+		DMSG_DBG_HCD("epnum = %d, nr_endpoints = %d, hw_ep->in_qh = 0x%p, hw_ep->out_qh = 0x%p\n",
+			      epnum, sw_hcd->nr_endpoints, hw_ep->in_qh, hw_ep->out_qh);
+
+		if(is_in || hw_ep->is_shared_fifo){
+			if (hw_ep->in_qh  != NULL){
+				DMSG_WRN("hw_ep->in_qh = 0x%p, epnum = %d, sw_hcd->nr_endpoints = %d\n",
+		                  hw_ep->in_qh, epnum, sw_hcd->nr_endpoints);
+				continue;
+			}
+		}else if(hw_ep->out_qh != NULL){
+			DMSG_WRN("hw_ep->out_qh = 0x%p, epnum = %d, sw_hcd->nr_endpoints = %d\n",
+		             hw_ep->out_qh, epnum, sw_hcd->nr_endpoints);
+			continue;
+		}
+
+		if (hw_ep == sw_hcd->bulk_ep){
+			DMSG_WRN("hw_ep == sw_hcd->bulk_ep, epnum = %d, sw_hcd->nr_endpoints = %d\n",
+		                  epnum, sw_hcd->nr_endpoints);
+			continue;
+		}
+
+		if (is_in){
+			diff = hw_ep->max_packet_sz_rx - qh->maxpacket;
+		}else{
+			diff = hw_ep->max_packet_sz_tx - qh->maxpacket;
+		}
+
+        /* find the least diff */
+		if (diff >= 0 && best_diff > diff) {
+			best_diff = diff;
+			best_end = epnum;
+		}
+	}
+
+	DMSG_DBG_HCD("best_end = %d, qh->type = %d\n", best_end, qh->type);
+
+	/* use bulk reserved ep1 if no other ep is free */
+	if (best_end < 0 && qh->type == USB_ENDPOINT_XFER_BULK) {
+		DMSG_WRN("wrn: no other ep is free, must use ep1\n");
+
+		hw_ep = sw_hcd->bulk_ep;
+		if (is_in){
+			head = &sw_hcd->in_bulk;
+		}else{
+			head = &sw_hcd->out_bulk;
+        }
+
+		/* Enable bulk RX NAK timeout scheme when bulk requests are
+		 * multiplexed.  This scheme doen't work in high speed to full
+		 * speed scenario as NAK interrupts are not coming from a
+		 * full speed device connected to a high speed device.
+		 * NAK timeout interval is 8 (128 uframe or 16ms) for HS and
+		 * 4 (8 frame or 8ms) for FS device.
+		 */
+/*
+		if (is_in && qh->dev){
+			qh->intv_reg = (USB_SPEED_HIGH == qh->dev->speed) ? 8 : 4;
+        }
+*/
+
+		goto success;
+	} else if (best_end < 0) {
+	    DMSG_PANIC("ERR: sw_hcd_schedule, best_end\n");
+
+		return -ENOSPC;
+	}
+
+	idle = 1;
+	qh->mux = 0;
+	hw_ep = sw_hcd->endpoints + best_end;
+
+success:
+	if (head) {
+		idle = list_empty(head);
+		list_add_tail(&qh->ring, head);
+		qh->mux = 1;
+	}
+
+	qh->hw_ep = hw_ep;
+	qh->hep->hcpriv = qh;
+	if(idle){
+		sw_hcd_start_urb(sw_hcd, is_in, qh);
+	}
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_urb_enqueue
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)
+{
+	unsigned long                   flags       = 0;
+	struct sw_hcd                  	*sw_hcd   	= NULL;
+	struct usb_host_endpoint        *hep        = NULL;
+	struct sw_hcd_qh               	*qh         = NULL;
+	struct sw_hcd_qh               	*qh_temp    = NULL;
+	struct usb_endpoint_descriptor  *epd        = NULL;
+	int                             ret         = 0;
+	unsigned                        type_reg    = 0;
+	unsigned                        interval    = 0;
+
+    /* check argment */
+    if(hcd == NULL || urb == NULL){
+        DMSG_PANIC("ERR: invalid argment, sw_hcd=0x%p, ep=0x%p\n", hcd, urb);
+	    return -ENODEV;
+    }
+
+    /* initialize parameter */
+    sw_hcd = hcd_to_sw_hcd(hcd);
+    hep  = urb->ep;
+    epd  = &hep->desc;
+
+	/* host role must be active */
+	if (!is_host_active(sw_hcd) || !sw_hcd->is_active){
+	    DMSG_PANIC("ERR: sw_hcd_urb_enqueue, host is not active\n");
+		return -ENODEV;
+    }
+
+	/* avoid all allocations within spinlocks */
+	qh_temp = kzalloc(sizeof *qh_temp, mem_flags);
+	if (!qh_temp) {
+		DMSG_PANIC("ERR: kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+
+	ret = usb_hcd_link_urb_to_ep(hcd, urb);
+	qh = ret ? NULL : hep->hcpriv;
+	if(qh){
+		urb->hcpriv = qh;
+	}
+
+	/* DMA mapping was already done, if needed, and this urb is on
+	 * hep->urb_list now ... so we're done, unless hep wasn't yet
+	 * scheduled onto a live qh.
+	 *
+	 * REVISIT best to keep hep->hcpriv valid until the endpoint gets
+	 * disabled, testing for empty qh->ring and avoiding qh setup costs
+	 * except for the first urb queued after a config change.
+	 */
+
+	/* when urb had disposed by sw_hcd_giveback, urb will callback by usb core.
+	 * program not leave sw_hcd_giveback, than new urb is coming, while the qh is busy,
+	 * so we must return it.
+	 *
+	 * the urb will be done by sw_hcd_advance_schedule ---> sw_hcd_start_urb
+	 */
+	if (qh || ret){
+	    DMSG_WRN("ERR: sw_hcd_urb_enqueue, qh(0x%p) is not null, ret(%d)\n", qh, ret);
+
+		if(qh){
+	    	DMSG_WRN("ERR: sw_hcd_urb_enqueue, qh(0x%p, %d, %d) is not null\n",
+				       qh, qh->epnum, qh->type);
+		}
+
+		kfree(qh_temp);
+		qh_temp = NULL;
+
+		spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+		return ret;
+    }
+
+	/* Allocate and initialize qh, minimizing the work done each time
+	 * hw_ep gets reprogrammed, or with irqs blocked.  Then schedule it.
+	 *
+	 * REVISIT consider a dedicated qh kmem_cache, so it's harder
+	 * for bugs in other kernel code to break this driver...
+	 */
+	qh = qh_temp;
+	memset(qh, 0, sizeof(struct sw_hcd_qh));
+
+	qh->hep = hep;
+	qh->dev = urb->dev;
+	INIT_LIST_HEAD(&qh->ring);
+	qh->is_ready = 1;
+
+	qh->maxpacket = le16_to_cpu(epd->wMaxPacketSize);
+
+	/* no high bandwidth support yet */
+	if (qh->maxpacket & ~0x7ff) {
+	    DMSG_PANIC("ERR: sw_hcd_urb_enqueue, ep packet is too big, maxpacket = %d\n", qh->maxpacket);
+		ret = -EMSGSIZE;
+		goto done;
+	}
+
+	qh->epnum = usb_endpoint_num(epd);
+	qh->type = usb_endpoint_type(epd);
+
+	/* NOTE: urb->dev->devnum is wrong during SET_ADDRESS */
+	qh->addr_reg = (u8) usb_pipedevice(urb->pipe);
+
+	/* precompute rxtype/txtype/type0 register */
+	type_reg = (qh->type << 4) | qh->epnum;
+	switch (urb->dev->speed) {
+    	case USB_SPEED_LOW:
+    		type_reg |= 0xc0;
+    	break;
+
+    	case USB_SPEED_FULL:
+    		type_reg |= 0x80;
+    	break;
+
+    	default:
+    		type_reg |= 0x40;
+	}
+	qh->type_reg = type_reg;
+
+	/* Precompute RXINTERVAL/TXINTERVAL register */
+	switch (qh->type) {
+	    case USB_ENDPOINT_XFER_INT:
+    		/*
+    		 * Full/low speeds use the  linear encoding,
+    		 * high speed uses the logarithmic encoding.
+    		 */
+    		if (urb->dev->speed <= USB_SPEED_FULL) {
+    			interval = max_t(u8, epd->bInterval, 1);
+    			break;
+    		}
+		/* FALLTHROUGH */
+	    case USB_ENDPOINT_XFER_ISOC:
+    		/* ISO always uses logarithmic encoding */
+    		interval = min_t(u8, epd->bInterval, 16);
+		break;
+
+    	default:
+    		/* REVISIT we actually want to use NAK limits, hinting to the
+    		 * transfer scheduling logic to try some other qh, e.g. try
+    		 * for 2 msec first:
+    		 *
+    		 * interval = (USB_SPEED_HIGH == urb->dev->speed) ? 16 : 2;
+    		 *
+    		 * The downside of disabling this is that transfer scheduling
+    		 * gets VERY unfair for nonperiodic transfers; a misbehaving
+    		 * peripheral could make that hurt.  That's perfectly normal
+    		 * for reads from network or serial adapters ... so we have
+    		 * partial NAKlimit support for bulk RX.
+    		 *
+    		 * The upside of disabling it is simpler transfer scheduling.
+    		 */
+    		interval = 0;
+	}
+	qh->intv_reg = interval;
+
+	/* precompute addressing for external hub/tt ports */
+	if (sw_hcd->is_multipoint) {
+		struct usb_device *parent = urb->dev->parent;
+
+		if (parent != hcd->self.root_hub) {
+			qh->h_addr_reg = (u8) parent->devnum;
+
+			/* set up tt info if needed */
+			if (urb->dev->tt) {
+				qh->h_port_reg = (u8) urb->dev->ttport;
+				if (urb->dev->tt->hub){
+					qh->h_addr_reg = (u8) urb->dev->tt->hub->devnum;
+				}
+
+				if (urb->dev->tt->multi){
+					qh->h_addr_reg |= 0x80;
+				}
+			}
+		}
+	}
+
+	DMSG_DBG_HCD("\nq: qh(0x%p, 0x%x, 0x%x), urb(0x%p, 0x%p, %d, %d), dma(0x%x, 0x%x, 0x%x)\n",
+		      qh, qh->epnum, qh->type,
+		      urb, urb->transfer_buffer, urb->transfer_buffer_length, urb->actual_length,
+		      urb->transfer_dma, urb->setup_dma, urb->transfer_flags);
+	DMSG_DBG_HCD("q: qh(0x%p, %d, %d, %d), addr(0x%x, 0x%x, 0x%x, 0x%x, 0x%x), urb(0x%p, %d, %d, %d)\n",
+		      qh, qh->epnum, qh->maxpacket, qh->type,
+		      qh->type_reg, qh->intv_reg, qh->addr_reg, qh->h_addr_reg, qh->h_port_reg,
+		      urb, urb->transfer_buffer_length, urb->ep->desc.bEndpointAddress, urb->ep->desc.wMaxPacketSize);
+
+	/* invariant: hep->hcpriv is null OR the qh that's already scheduled.
+	 * until we get real dma queues (with an entry for each urb/buffer),
+	 * we only have work to do in the former case.
+	 */
+	if (hep->hcpriv) {
+		DMSG_PANIC("ERR: some concurrent activity submitted another urb to hep\n");
+
+		kfree(qh);
+		qh = NULL;
+		ret = 0;
+	}else{
+		ret = sw_hcd_schedule(sw_hcd, qh, epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK);
+    }
+
+    if (ret == 0) {
+		urb->hcpriv = qh;
+	}else{
+		DMSG_PANIC("ERR: sw_hcd_schedule failed\n");
+	}
+
+
+done:
+	if (ret != 0) {
+		usb_hcd_unlink_urb_from_ep(hcd, urb);
+		kfree(qh);
+		qh = NULL;
+	}
+
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(sw_hcd_urb_enqueue);
+
+/*
+*******************************************************************************
+*                     sw_hcd_cleanup_urb
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    abort a transfer that's at the head of a hardware queue.
+* called with controller locked, irqs blocked
+* that hardware queue advances to the next transfer, unless prevented
+*
+*******************************************************************************
+*/
+static int sw_hcd_cleanup_urb(struct urb *urb, struct sw_hcd_qh *qh, int is_in)
+{
+	struct sw_hcd_hw_ep   *ep         = NULL;
+//	void __iomem        *epio       = NULL;
+	unsigned            hw_end      = 0;
+	void __iomem        *usbc_base  = NULL;
+	u16                 csr         = 0;
+	int                 status      = 0;
+
+    /* check argment */
+    if(urb == NULL || qh == NULL){
+        DMSG_PANIC("ERR: invalid argment, urb=0x%p, qh=0x%p\n", urb, qh);
+	    return -1;
+    }
+
+    /* initialize parameter */
+    ep = qh->hw_ep;
+    hw_end = ep->epnum;
+    usbc_base = ep->sw_hcd->mregs;
+
+	DMSG_INFO("sw_hcd_cleanup_urb: qh(0x%p,0x%x,0x%x), urb(0x%p,%d,%d), ep(0x%p,%d,0x%p,0x%p)\n",
+		      qh, qh->epnum, qh->type,
+		      urb, urb->transfer_buffer_length, urb->actual_length,
+		      ep, ep->epnum, ep->in_qh, ep->out_qh);
+
+	sw_hcd_ep_select(usbc_base, hw_end);
+
+	if (is_sw_hcd_dma_capable(ep->sw_hcd->usbc_no, urb->transfer_buffer_length, qh->maxpacket, ep->epnum)) {
+		DMSG_DBG_HCD("HCD: sw_hcd_cleanup_urb, abort %cX%d DMA for urb %p --> %d\n",
+                (is_in ? 'R' : 'T'), ep->epnum, urb, status);
+
+		/* stop dma */
+		sw_hcd_dma_stop(qh);
+		sw_hcd_clean_ep_dma_status_and_flush_fifo(qh);
+		urb->actual_length += sw_hcd_dma_transmit_length(qh, is_direction_in(qh), urb->transfer_dma);
+	}
+
+	/* turn off DMA requests, discard state, stop polling ... */
+	if (is_in) {
+		/* giveback saves bulk toggle */
+		csr = sw_hcd_h_rx_flush_fifo(ep, 0);
+
+		/* REVISIT we still get an irq; should likely clear the
+		 * endpoint's irq status here to avoid bogus irqs.
+		 * clearing that status is platform-specific...
+		 */
+	} else if (ep->epnum) {
+		sw_hcd_h_tx_flush_fifo(ep);
+
+		csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+		csr &= ~((1 << USBC_BP_TXCSR_H_AUTOSET)
+			| (1 << USBC_BP_TXCSR_H_DMA_REQ_EN)
+			| (1 << USBC_BP_TXCSR_H_TX_STALL)
+			| (1 << USBC_BP_TXCSR_H_NAK_TIMEOUT)
+			| (1 << USBC_BP_TXCSR_H_ERROR)
+			| (1 << USBC_BP_TXCSR_H_TX_READY));
+		USBC_Writew(csr, USBC_REG_TXCSR(usbc_base));
+		/* REVISIT may need to clear FLUSHFIFO ... */
+		USBC_Writew(csr, USBC_REG_TXCSR(usbc_base));
+
+		/* flush cpu writebuffer */
+		csr = USBC_Readw(USBC_REG_TXCSR(usbc_base));
+	} else  {
+		sw_hcd_h_ep0_flush_fifo(ep);
+	}
+
+	if (status == 0){
+		sw_hcd_advance_schedule(ep->sw_hcd, urb, ep, is_in);
+	}
+
+	return status;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_urb_dequeue
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct sw_hcd     	*sw_hcd	= NULL;
+	struct sw_hcd_qh   	*qh     = NULL;
+	struct list_head    *sched  = NULL;
+	unsigned long       flags   = 0;
+	int                 ret     = 0;
+
+    /* check argment */
+    if(hcd == NULL || urb == NULL){
+        DMSG_PANIC("ERR: invalid argment, hcd=0x%p, urb=0x%p\n", hcd, urb);
+	    return -1;
+    }
+
+    /* initialize parameter */
+    sw_hcd = hcd_to_sw_hcd(hcd);
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+
+	DMSG_INFO("[sw_hcd]: sw_hcd_urb_dequeue, sw_hcd(%p, 0x%d, 0x%x),"
+		      "urb(%p, %d, %d), dev = %d, ep = %d, dir = %s\n",
+		      		sw_hcd, sw_hcd->ep0_stage, sw_hcd->epmask,
+		         	urb, urb->transfer_buffer_length, urb->actual_length,
+        			usb_pipedevice(urb->pipe),
+        			usb_pipeendpoint(urb->pipe),
+        			usb_pipein(urb->pipe) ? "in" : "out");
+
+	ret = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (ret){
+		DMSG_PANIC("ERR: usb_hcd_check_unlink_urb faield\n");
+		goto done;
+    }
+
+	qh = urb->hcpriv;
+	if (!qh){
+		DMSG_PANIC("ERR: urb->hcpriv is null\n");
+		goto done;
+    }
+
+	/* Any URB not actively programmed into endpoint hardware can be
+	 * immediately given back; that's any URB not at the head of an
+	 * endpoint queue, unless someday we get real DMA queues.  And even
+	 * if it's at the head, it might not be known to the hardware...
+	 *
+	 * Otherwise abort current transfer, pending dma, etc.; urb->status
+	 * has already been updated.  This is a synchronous abort; it'd be
+	 * OK to hold off until after some IRQ, though.
+	 */
+	if(!qh->is_ready || urb->urb_list.prev != &qh->hep->urb_list){
+		DMSG_PANIC("WRN: urb is not valid\n");
+		ret = -EINPROGRESS;
+    }else{
+		switch (qh->type) {
+		    case USB_ENDPOINT_XFER_CONTROL:
+			    sched = &sw_hcd->control;
+			break;
+
+		    case USB_ENDPOINT_XFER_BULK:
+			if (qh->mux == 1) {
+				if (usb_pipein(urb->pipe)){
+					sched = &sw_hcd->in_bulk;
+				}else{
+					sched = &sw_hcd->out_bulk;
+				}
+			}
+            break;
+
+    		default:
+    		    DMSG_PANIC("ERR: not support type(%d)\n", qh->type);
+
+    			/* REVISIT when we get a schedule tree, periodic
+    			 * transfers won't always be at the head of a
+    			 * singleton queue...
+    			 */
+    			sched = NULL;
+
+    			break;
+		}
+	}
+
+	/* NOTE:  qh is invalid unless !list_empty(&hep->urb_list) */
+	if (ret < 0 || (sched && qh != first_qh(sched))) {
+		int	ready = qh->is_ready;
+
+		ret = 0;
+		qh->is_ready = 0;
+		__sw_hcd_giveback(sw_hcd, urb, 0);
+		qh->is_ready = ready;
+
+		/* If nothing else (usually sw_hcd_giveback) is using it
+		 * and its URB list has emptied, recycle this qh.
+		 */
+		if (ready && list_empty(&qh->hep->urb_list)) {
+			qh->hep->hcpriv = NULL;
+			list_del(&qh->ring);
+			kfree(qh);
+		}
+	} else {
+		ret = sw_hcd_cleanup_urb(urb, qh, urb->pipe & USB_DIR_IN);
+	}
+
+done:
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(sw_hcd_urb_dequeue);
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_disable
+*
+* Description:
+*    disable an endpoint
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_h_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)
+{
+	u8                  epnum   = 0;
+	unsigned long		flags   = 0;
+	struct sw_hcd         *sw_hcd   = NULL;
+	u8                  is_in   = 0;
+	struct sw_hcd_qh      *qh     = NULL;
+	struct urb          *urb    = NULL;
+	struct list_head    *sched  = NULL;
+
+    /* check argment */
+    if(hcd == NULL || hep == NULL){
+        DMSG_PANIC("ERR: invalid argment, hcd=0x%p, hep=0x%p\n", hcd, hep);
+	    return ;
+    }
+
+    /* initialize parameter */
+    epnum = hep->desc.bEndpointAddress;
+    sw_hcd = hcd_to_sw_hcd(hcd);
+    is_in = epnum & USB_DIR_IN;
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+
+	DMSG_INFO("[sw_hcd]: sw_hcd_h_disable, epnum = %x\n", epnum);
+
+	qh = hep->hcpriv;
+	if (qh == NULL){
+		goto exit;
+    }
+
+	switch (qh->type) {
+	    case USB_ENDPOINT_XFER_CONTROL:
+		    sched = &sw_hcd->control;
+		break;
+
+	    case USB_ENDPOINT_XFER_BULK:
+    		if (qh->mux == 1) {
+    			if (is_in)
+    				sched = &sw_hcd->in_bulk;
+    			else
+    				sched = &sw_hcd->out_bulk;
+
+    		}
+		break;
+
+    	default:
+    	    DMSG_PANIC("ERR: not support type(%d)\n", qh->type);
+
+    		/* REVISIT when we get a schedule tree, periodic transfers
+    		 * won't always be at the head of a singleton queue...
+    		 */
+    		sched = NULL;
+    		break;
+	}
+
+	/* NOTE:  qh is invalid unless !list_empty(&hep->urb_list) */
+
+	/* kick first urb off the hardware, if needed */
+	qh->is_ready = 0;
+	if (!sched || qh == first_qh(sched)) {
+		urb = next_urb(qh);
+		if(urb == NULL){
+			DMSG_PANIC("ERR: sw_hcd_h_disable, urb is NULL\n");
+			return ;
+		}
+
+		/* make software (then hardware) stop ASAP */
+		if (!urb->unlinked){
+			urb->status = -ESHUTDOWN;
+		}
+
+		/* cleanup */
+		sw_hcd_cleanup_urb(urb, qh, urb->pipe & USB_DIR_IN);
+
+		/* Then nuke all the others ... and advance the
+		 * queue on hw_ep (e.g. bulk ring) when we're done.
+		 */
+		while (!list_empty(&hep->urb_list)) {
+			urb = next_urb(qh);
+			if(urb == NULL){
+				DMSG_PANIC("ERR: sw_hcd_h_disable, urb is NULL\n");
+				return ;
+			}
+
+			urb->status = -ESHUTDOWN;
+			sw_hcd_advance_schedule(sw_hcd, urb, qh->hw_ep, is_in);
+		}
+	} else {
+		/* Just empty the queue; the hardware is busy with
+		 * other transfers, and since !qh->is_ready nothing
+		 * will activate any of these as it advances.
+		 */
+		while (!list_empty(&hep->urb_list)){
+			__sw_hcd_giveback(sw_hcd, next_urb(qh), -ESHUTDOWN);
+		}
+
+		hep->hcpriv = NULL;
+		list_del(&qh->ring);
+		kfree(qh);
+	}
+
+exit:
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+    return;
+}
+EXPORT_SYMBOL(sw_hcd_h_disable);
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_get_frame_number
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_h_get_frame_number(struct usb_hcd *hcd)
+{
+	struct sw_hcd	*sw_hcd = hcd_to_sw_hcd(hcd);
+
+	return USBC_Readw(USBC_REG_FRNUM(sw_hcd->mregs));
+}
+EXPORT_SYMBOL(sw_hcd_h_get_frame_number);
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_start
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_h_start(struct usb_hcd *hcd)
+{
+	struct sw_hcd	*sw_hcd = hcd_to_sw_hcd(hcd);
+
+	/* NOTE: sw_hcd_start() is called when the hub driver turns
+	 * on port power, or when (OTG) peripheral starts.
+	 */
+	hcd->state = HC_STATE_RUNNING;
+	sw_hcd->port1_status = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_hcd_h_start);
+
+/*
+*******************************************************************************
+*                     sw_hcd_h_stop
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_h_stop(struct usb_hcd *hcd)
+{
+	sw_hcd_stop(hcd_to_sw_hcd(hcd));
+	hcd->state = HC_STATE_HALT;
+}
+EXPORT_SYMBOL(sw_hcd_h_stop);
+
+/*
+*******************************************************************************
+*                     sw_hcd_bus_suspend
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+#if 0
+int sw_hcd_bus_suspend(struct usb_hcd *hcd)
+{
+	struct sw_hcd	*sw_hcd = hcd_to_sw_hcd(hcd);
+
+	if (is_host_active(sw_hcd) && sw_hcd->is_active) {
+		DMSG_PANIC("ERR: sw_hcd_bus_suspend, trying to suspend as host is_active=%i\n",
+			       sw_hcd->is_active);
+
+		return -EBUSY;
+	}else{
+		return 0;
+	}
+
+	return 0;
+}
+#else
+int sw_hcd_bus_suspend(struct usb_hcd *hcd)
+{
+	return 0;
+}
+#endif
+EXPORT_SYMBOL(sw_hcd_bus_suspend);
+/*
+*******************************************************************************
+*                     sw_hcd_bus_resume
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_bus_resume(struct usb_hcd *hcd)
+{
+	/* resuming child port does the work */
+	return 0;
+}
+EXPORT_SYMBOL(sw_hcd_bus_resume);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/usb/sunxi_usb/hcd/core/sw_hcd_virt_hub.c b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_virt_hub.c
new file mode 100644
index 0000000..14f45a5
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/core/sw_hcd_virt_hub.c
@@ -0,0 +1,667 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/core/sw_hcd_virt_hub.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+
+#include <asm/unaligned.h>
+
+#include  "../include/sw_hcd_config.h"
+#include  "../include/sw_hcd_core.h"
+#include  "../include/sw_hcd_virt_hub.h"
+
+/*
+*******************************************************************************
+*                     sw_hcd_port_suspend_ex
+*
+* Description:
+*    only suspend USB port
+*
+* Parameters:
+*    sw_hcd        :  input.  USB
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_port_suspend_ex(struct sw_hcd *sw_hcd)
+{
+    /* if peripheral connect, suspend the device */
+    if (sw_hcd->is_active) {
+    	/* suspend usb port */
+    	USBC_Host_SuspendPort(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+
+    	/* delay for 1000ms */
+    	mdelay(1000);
+    }
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_port_resume_ex
+*
+* Description:
+*    only resume USB port
+*
+* Parameters:
+*    sw_hcd        :  input.  USB
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_port_resume_ex(struct sw_hcd *sw_hcd)
+{
+	/* resume port */
+	USBC_Host_RusumePort(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	mdelay(500);
+	USBC_Host_ClearRusumePortFlag(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_port_reset_ex
+*
+* Description:
+*    only reset USB port
+*
+* Parameters:
+*    sw_hcd        :  input.  USB
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_port_reset_ex(struct sw_hcd *sw_hcd)
+{
+	/* resume port */
+	sw_hcd_port_resume_ex(sw_hcd);
+
+	/* reset port */
+	USBC_Host_ResetPort(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	mdelay(50);
+	USBC_Host_ClearResetPortFlag(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	mdelay(500);
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_port_suspend
+*
+* Description:
+*    suspend USB port
+*
+* Parameters:
+*    sw_hcd        :  input.  USB
+*    do_suspend  :  input.  flag. is suspend USB port or not?
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_port_suspend(struct sw_hcd *sw_hcd, bool do_suspend)
+{
+    u8 power = 0;
+	void __iomem *usbc_base = sw_hcd->mregs;
+
+	if (!is_host_active(sw_hcd)){
+	    DMSG_PANIC("ERR: usb host is not active\n");
+	    return;
+	}
+
+	/* NOTE:  this doesn't necessarily put PHY into low power mode,
+	 * turning off its clock; that's a function of PHY integration and
+	 * sw_hcd_POWER_ENSUSPEND.  PHY may need a clock (sigh) to detect
+	 * SE0 changing to connect (J) or wakeup (K) states.
+	 */
+    power = USBC_Readb(USBC_REG_PCTL(usbc_base));
+	if (do_suspend) {
+		int retries = 10000;
+
+		DMSG_INFO("[sw_hcd]: suspend port.\n");
+
+        power &= ~(1 << USBC_BP_POWER_H_RESUME);
+		power |= (1 << USBC_BP_POWER_H_SUSPEND);
+		USBC_Writeb(power, USBC_REG_PCTL(usbc_base));
+
+		/* Needed for OPT A tests */
+		power = USBC_Readb(USBC_REG_PCTL(usbc_base));
+		while (power & (1 << USBC_BP_POWER_H_SUSPEND)) {
+			power = USBC_Readb(USBC_REG_PCTL(usbc_base));
+			if (retries-- < 1)
+				break;
+		}
+
+	    DMSG_DBG_HCD("DBG: Root port suspended, power %02x\n", power);
+
+		sw_hcd->port1_status |= USB_PORT_STAT_SUSPEND;
+    }else if (power & (1 << USBC_BP_POWER_H_SUSPEND)){
+		DMSG_INFO("[sw_hcd]: suspend portend, resume port.\n");
+
+        power &= ~(1 << USBC_BP_POWER_H_SUSPEND);
+		power |= (1 << USBC_BP_POWER_H_RESUME);
+		USBC_Writeb(power, USBC_REG_PCTL(usbc_base));
+
+		DMSG_DBG_HCD("DBG: Root port resuming, power %02x\n", power);
+
+		/* later, GetPortStatus will stop RESUME signaling */
+		sw_hcd->port1_status |= SW_HCD_PORT_STAT_RESUME;
+		sw_hcd->rh_timer = jiffies + msecs_to_jiffies(20);
+    }else{
+        DMSG_PANIC("WRN: sw_hcd_port_suspend nothing to do\n");
+    }
+
+    return ;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_port_reset
+*
+* Description:
+*    reset USB port
+*
+* Parameters:
+*    sw_hcd       :  input.  USB
+*    do_reset   :  input.  flag. is reset USB port or not?
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_port_reset(struct sw_hcd *sw_hcd, bool do_reset)
+{
+    u8 power = 0;
+	void __iomem *usbc_base = sw_hcd->mregs;
+
+	if (!is_host_active(sw_hcd)){
+	    DMSG_PANIC("ERR: usb host is not active\n");
+	    return;
+	}
+
+	/* NOTE:  caller guarantees it will turn off the reset when
+	 * the appropriate amount of time has passed
+	 */
+	power = USBC_Readb(USBC_REG_PCTL(usbc_base));
+	if (do_reset) {
+        DMSG_INFO("[sw_hcd]: reset port. \n");
+
+		/*
+		 * If RESUME is set, we must make sure it stays minimum 20 ms.
+		 * Then we must clear RESUME and wait a bit to let sw_hcd start
+		 * generating SOFs. If we don't do this, OPT HS A 6.8 tests
+		 * fail with "Error! Did not receive an SOF before suspend
+		 * detected".
+		 */
+		if (power & (1 << USBC_BP_POWER_H_RESUME)) {
+			while (time_before(jiffies, sw_hcd->rh_timer)){
+			    msleep(1);
+			}
+
+            power &= ~(1 << USBC_BP_POWER_H_RESUME);
+			USBC_Writeb(power, USBC_REG_PCTL(usbc_base));
+			msleep(1);
+		}
+
+		sw_hcd->ignore_disconnect = true;
+		power &= 0xf0;
+		power |= (1 << USBC_BP_POWER_H_RESET);
+        USBC_Writeb(power, USBC_REG_PCTL(usbc_base));
+
+        sw_hcd->port1_status |= USB_PORT_STAT_RESET;
+		sw_hcd->port1_status &= ~USB_PORT_STAT_ENABLE;
+		sw_hcd->rh_timer = jiffies + msecs_to_jiffies(50);
+
+		USBC_Host_SetFunctionAddress_Deafult(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX, 0);
+
+		//set address ep0
+		{
+		    __u32 i = 1;
+			__u8 old_ep_index = 0;
+
+			old_ep_index = USBC_GetActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+
+			USBC_SelectActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle, 0);
+			USBC_Host_SetFunctionAddress_Deafult(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX, 0);
+
+			for( i = 1 ; i <= 5; i++){
+				USBC_SelectActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle, i);
+				USBC_Host_SetFunctionAddress_Deafult(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_TX, i);
+				USBC_Host_SetFunctionAddress_Deafult(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_EP_TYPE_RX, i);
+			}
+
+			USBC_SelectActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle, old_ep_index);
+		}
+    }else{
+        DMSG_INFO("[sw_hcd]: reset port stopped.\n");
+
+        UsbPhyEndReset(0);
+
+        power &= ~(1 << USBC_BP_POWER_H_RESET);
+        USBC_Writeb(power, USBC_REG_PCTL(usbc_base));
+
+        sw_hcd->ignore_disconnect = false;
+
+        power = USBC_Readb(USBC_REG_PCTL(usbc_base));
+        if(power & (1 << USBC_BP_POWER_H_HIGH_SPEED_FLAG)){
+            DMSG_DBG_HCD("high-speed device connected\n");
+			sw_hcd->port1_status |= USB_PORT_STAT_HIGH_SPEED;
+        }
+
+        sw_hcd->port1_status &= ~USB_PORT_STAT_RESET;
+		sw_hcd->port1_status |= USB_PORT_STAT_ENABLE
+					| (USB_PORT_STAT_C_RESET << 16)
+					| (USB_PORT_STAT_C_ENABLE << 16);
+		usb_hcd_poll_rh_status(sw_hcd_to_hcd(sw_hcd));
+
+		sw_hcd->vbuserr_retry = VBUSERR_RETRY_COUNT;
+    }
+
+    return ;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_root_disconnect
+*
+* Description:
+*    
+*
+* Parameters:
+*    sw_hcd       :  input.  USB
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_hcd_root_disconnect(struct sw_hcd *sw_hcd)
+{
+	sw_hcd->port1_status = (1 << USB_PORT_FEAT_POWER)
+	                      | (1 << USB_PORT_FEAT_C_CONNECTION);
+
+	usb_hcd_poll_rh_status(sw_hcd_to_hcd(sw_hcd));
+	sw_hcd->is_active = 0;
+
+	return;
+}
+EXPORT_SYMBOL(sw_hcd_root_disconnect);
+
+/*
+*******************************************************************************
+*                     sw_hcd_hub_status_data
+*
+* Description:
+*     Caller may or may not hold sw_hcd->lock
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct sw_hcd	*sw_hcd = hcd_to_sw_hcd(hcd);
+	int retval = 0;
+
+	/* called in_irq() via usb_hcd_poll_rh_status() */
+	if (sw_hcd->port1_status & 0xffff0000) {
+		*buf = 0x02;
+		retval = 1;
+	}
+
+    return retval;
+}
+EXPORT_SYMBOL(sw_hcd_hub_status_data);
+
+/*
+*******************************************************************************
+*                     sw_hcd_hub_control
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_hcd_hub_control(struct usb_hcd	*hcd,
+                     u16 typeReq,
+                     u16 wValue,
+                     u16 wIndex,
+                     char *buf,
+                     u16 wLength)
+{
+	struct sw_hcd	*sw_hcd = hcd_to_sw_hcd(hcd);
+	u32 temp = 0;
+	int retval = 0;
+	unsigned long flags = 0;
+	void __iomem *usbc_base = sw_hcd->mregs;
+
+    if(hcd == NULL){
+        DMSG_PANIC("ERR: invalid argment\n");
+
+        return -ESHUTDOWN;
+    }
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+
+    if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags))) {
+		spin_unlock_irqrestore(&sw_hcd->lock, flags);
+		return -ESHUTDOWN;
+	}
+
+    DMSG_DBG_HCD("sw_hcd_hub_control: typeReq = %x, wValue = 0x%x, wIndex = 0x%x\n",
+		       typeReq, wValue, wIndex);
+
+	/* hub features:  always zero, setting is a NOP
+	 * port features: reported, sometimes updated when host is active
+	 * no indicators
+	 */
+	switch (typeReq) {
+        case ClearHubFeature:
+    	case SetHubFeature:
+    		switch (wValue) {
+        		case C_HUB_OVER_CURRENT:
+        		case C_HUB_LOCAL_POWER:
+        			break;
+
+        		default:
+        			goto error;
+    		}
+        break;
+
+    	case ClearPortFeature:
+    		if ((wIndex & 0xff) != 1){
+    		    goto error;
+    		}
+
+    		switch (wValue) {
+        		case USB_PORT_FEAT_ENABLE:
+        	    break;
+
+    		    case USB_PORT_FEAT_SUSPEND:
+    			    sw_hcd_port_suspend(sw_hcd, false);
+    			break;
+
+    		    case USB_PORT_FEAT_POWER:
+					/* fixme */
+				    sw_hcd_set_vbus(sw_hcd, 0);
+    			break;
+
+        		case USB_PORT_FEAT_C_CONNECTION:
+        		case USB_PORT_FEAT_C_ENABLE:
+        		case USB_PORT_FEAT_C_OVER_CURRENT:
+        		case USB_PORT_FEAT_C_RESET:
+        		case USB_PORT_FEAT_C_SUSPEND:
+    			break;
+
+        		default:
+        			goto error;
+    		}
+
+    		DMSG_DBG_HCD("DBG: clear feature %d\n", wValue);
+    		sw_hcd->port1_status &= ~(1 << wValue);
+        break;
+
+    	case GetHubDescriptor:
+        {
+    		struct usb_hub_descriptor *desc = (void *)buf;
+
+    		desc->bDescLength = 9;
+    		desc->bDescriptorType = 0x29;
+    		desc->bNbrPorts = 1;
+    		desc->wHubCharacteristics = cpu_to_le16(
+    				  0x0001	/* per-port power switching */
+    				| 0x0010	/* no overcurrent reporting */
+    				);
+    		desc->bPwrOn2PwrGood = 5;	/* msec/2 */
+    		desc->bHubContrCurrent = 0;
+
+    		/* workaround bogus struct definition */
+    		desc->u.hs.DeviceRemovable[0] = 0x02;	/* port 1 */
+    		desc->u.hs.DeviceRemovable[1] = 0xff;
+        }
+		break;
+
+	    case GetHubStatus:
+		    temp = 0;
+		    *(__le32 *) buf = cpu_to_le32(temp);
+		break;
+
+	    case GetPortStatus:
+	    {
+    		if (wIndex != 1){
+    		    DMSG_PANIC("ERR: GetPortStatus parameter wIndex is not 1.\n");
+    		    goto error;
+    		}
+
+    		/* finish RESET signaling? */
+    		if ((sw_hcd->port1_status & USB_PORT_STAT_RESET)
+    				&& time_after_eq(jiffies, sw_hcd->rh_timer)){
+    			sw_hcd_port_reset(sw_hcd, false);
+    		}
+
+    		/* finish RESUME signaling? */
+    		if ((sw_hcd->port1_status & SW_HCD_PORT_STAT_RESUME)
+    				&& time_after_eq(jiffies, sw_hcd->rh_timer)) {
+    			u8 power = 0;
+
+    			power = USBC_Readb(USBC_REG_PCTL(usbc_base));
+				power &= ~(1 << USBC_BP_POWER_H_RESUME);
+    			USBC_Writeb(power, USBC_REG_PCTL(usbc_base));
+
+    			DMSG_DBG_HCD("DBG: root port resume stopped, power %02x\n", power);
+
+    			/* ISSUE:  DaVinci (RTL 1.300) disconnects after
+    			 * resume of high speed peripherals (but not full
+    			 * speed ones).
+    			 */
+
+    			sw_hcd->is_active = 1;
+    			sw_hcd->port1_status &= ~(USB_PORT_STAT_SUSPEND
+    					| SW_HCD_PORT_STAT_RESUME);
+    			sw_hcd->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
+
+    			usb_hcd_poll_rh_status(sw_hcd_to_hcd(sw_hcd));
+    		}
+
+    		put_unaligned(cpu_to_le32(sw_hcd->port1_status
+    					& ~SW_HCD_PORT_STAT_RESUME),
+    				(__le32 *) buf);
+
+    		/* port change status is more interesting */
+    		DMSG_DBG_HCD("DBG: port status %08x\n", sw_hcd->port1_status);
+    	}
+		break;
+
+	    case SetPortFeature:
+	    {
+    		if ((wIndex & 0xff) != 1){
+    		    goto error;
+    		}
+
+    		switch (wValue) {
+    		    case USB_PORT_FEAT_POWER:
+        			/* NOTE: this controller has a strange state machine
+        			 * that involves "requesting sessions" according to
+        			 * magic side effects from incompletely-described
+        			 * rules about startup...
+        			 *
+        			 * This call is what really starts the host mode; be
+        			 * very careful about side effects if you reorder any
+        			 * initialization logic, e.g. for OTG, or change any
+        			 * logic relating to VBUS power-up.
+        			 */
+
+        			sw_hcd_start(sw_hcd);
+
+    			break;
+
+    		    case USB_PORT_FEAT_RESET:
+    			    sw_hcd_port_reset(sw_hcd, true);
+    			break;
+
+    		    case USB_PORT_FEAT_SUSPEND:
+    			    sw_hcd_port_suspend(sw_hcd, true);
+    			break;
+
+    		    case USB_PORT_FEAT_TEST:
+    		    {
+    			    if (unlikely(is_host_active(sw_hcd))){
+    			        DMSG_PANIC("ERR: usb host is not active\n");
+    				    goto error;
+    				}
+
+    			    wIndex >>= 8;
+        			switch (wIndex) {
+            			case 1:
+            				DMSG_DBG_HCD("TEST_J\n");
+            				temp =  1 << USBC_BP_TMCTL_TEST_J;
+        				break;
+
+            			case 2:
+            				DMSG_DBG_HCD("TEST_K\n");
+            				temp = 1 << USBC_BP_TMCTL_TEST_K;
+        				break;
+
+            			case 3:
+            				DMSG_DBG_HCD("TEST_SE0_NAK\n");
+            				temp = 1 << USBC_BP_TMCTL_TEST_SE0_NAK;
+        				break;
+
+            			case 4:
+            				DMSG_DBG_HCD("TEST_PACKET\n");
+            				temp = 1 << USBC_BP_TMCTL_TEST_PACKET;
+            				sw_hcd_load_testpacket(sw_hcd);
+        				break;
+
+            			case 5:
+            				DMSG_DBG_HCD("TEST_FORCE_ENABLE\n");
+            				temp = (1 << USBC_BP_TMCTL_FORCE_HOST)
+            					| (1 << USBC_BP_TMCTL_FORCE_HS);
+
+            			    USBC_REG_set_bit_b(USBC_BP_DEVCTL_SESSION, USBC_REG_DEVCTL(usbc_base));
+        				break;
+
+            			case 6:
+            				DMSG_DBG_HCD("TEST_FIFO_ACCESS\n");
+            				temp = 1 << USBC_BP_TMCTL_FIFO_ACCESS;
+        				break;
+
+        			    default:
+        				    DMSG_PANIC("ERR: unkown SetPortFeature USB_PORT_FEAT_TEST wIndex(%d)\n", wIndex);
+    			            goto error;
+        			}
+
+    			    USBC_Writeb(temp, USBC_REG_TMCTL(usbc_base));
+    			}
+    			break;
+
+    		    default:{
+    		        DMSG_PANIC("ERR: unkown SetPortFeature wValue(%d)\n", wValue);
+    			    goto error;
+    			}
+    		}
+
+    		DMSG_DBG_HCD("DBG: set feature %d\n", wValue);
+    		sw_hcd->port1_status |= 1 << wValue;
+	    }
+		break;
+
+	default:
+error:
+		DMSG_PANIC("ERR: protocol stall on error\n");
+
+		/* "protocol stall" on error */
+		retval = -EPIPE;
+	}
+
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+    return retval;
+}
+EXPORT_SYMBOL(sw_hcd_hub_control);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/drivers/usb/sunxi_usb/hcd/hcd0/sw_hcd0.c b/drivers/usb/sunxi_usb/hcd/hcd0/sw_hcd0.c
new file mode 100644
index 0000000..846a01f
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/hcd0/sw_hcd0.c
@@ -0,0 +1,2501 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/hcd0/sw_hcd0.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kobject.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include "../../../../power/axp_power/axp-gpio.h"
+
+#include  <mach/clock.h>
+#include  "../include/sw_hcd_config.h"
+#include  "../include/sw_hcd_core.h"
+#include  "../include/sw_hcd_dma.h"
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+
+#define  DRIVER_AUTHOR      "Javen"
+#define  DRIVER_DESC        "sw_hcd Host Controller Driver"
+#define  sw_hcd_VERSION       "1.0"
+
+#define DRIVER_INFO DRIVER_DESC ", v" sw_hcd_VERSION
+
+#define SW_HCD_DRIVER_NAME    "sw_hcd_host0"
+static const char sw_hcd_driver_name[] = SW_HCD_DRIVER_NAME;
+
+MODULE_DESCRIPTION(DRIVER_INFO);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" SW_HCD_DRIVER_NAME);
+
+enum fifo_style { FIFO_RXTX = 0, FIFO_TX, FIFO_RX } __attribute__ ((packed));
+enum buf_mode { BUF_SINGLE = 0, BUF_DOUBLE } __attribute__ ((packed));
+
+struct fifo_cfg {
+	u8		hw_ep_num;
+	enum fifo_style	style;
+	enum buf_mode	mode;
+	u16		maxpacket;
+};
+
+/*
+ * tables defining fifo_mode values.  define more if you like.
+ * for host side, make sure both halves of ep1 are set up.
+ */
+static struct fifo_cfg mode_4_cfg[] = {
+	{ .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  2, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  3, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  3, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  4, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  4, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  5, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+	{ .hw_ep_num =  5, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_SINGLE, },
+};
+
+static struct fifo_cfg ep0_cfg = {
+	.style = FIFO_RXTX, .maxpacket = 64,
+};
+
+static sw_hcd_io_t g_sw_hcd_io;
+static __u32 usbc_no = 0;
+
+#ifdef  CONFIG_USB_SW_SUNXI_USB0_OTG
+static struct platform_device *g_hcd0_pdev = NULL;
+#endif
+
+static struct sw_hcd_context_registers sw_hcd_context;
+static struct sw_hcd *g_sw_hcd0 = NULL;
+
+
+//---------------------------------------------------------------
+//  
+//---------------------------------------------------------------
+
+#define  sw_hcd_BOARD_DRV_VBUS_GPIO	(AW_GPB(16))  /* PIOB16 */
+
+#define res_size(_r) (((_r)->end - (_r)->start) + 1)
+
+static void sw_hcd_save_context(struct sw_hcd *sw_hcd);
+static void sw_hcd_restore_context(struct sw_hcd *sw_hcd);
+
+#if 1
+static s32 usb_clock_init(sw_hcd_io_t *sw_hcd_io)
+{
+	sw_hcd_io->sie_clk = clk_get(NULL, "ahb_usb0");
+	if (IS_ERR(sw_hcd_io->sie_clk)){
+		DMSG_PANIC("ERR: get usb sie clk failed.\n");
+		goto failed;
+	}
+
+	sw_hcd_io->phy_clk = clk_get(NULL, "usb_phy");
+	if (IS_ERR(sw_hcd_io->phy_clk)){
+		DMSG_PANIC("ERR: get usb phy clk failed.\n");
+		goto failed;
+	}
+
+	sw_hcd_io->phy0_clk = clk_get(NULL, "usb_phy0");
+	if (IS_ERR(sw_hcd_io->phy0_clk)){
+		DMSG_PANIC("ERR: get usb phy0 clk failed.\n");
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+	if(sw_hcd_io->sie_clk){
+		clk_put(sw_hcd_io->sie_clk);
+		sw_hcd_io->sie_clk = NULL;
+	}
+
+	if(sw_hcd_io->phy_clk){
+		clk_put(sw_hcd_io->phy_clk);
+		sw_hcd_io->phy_clk = NULL;
+	}
+
+	if(sw_hcd_io->phy0_clk){
+		clk_put(sw_hcd_io->phy0_clk);
+		sw_hcd_io->phy0_clk = NULL;
+	}
+
+	return -1;
+}
+
+static s32 usb_clock_exit(sw_hcd_io_t *sw_hcd_io)
+{
+	if(sw_hcd_io->sie_clk){
+		clk_put(sw_hcd_io->sie_clk);
+		sw_hcd_io->sie_clk = NULL;
+	}
+
+	if(sw_hcd_io->phy_clk){
+		clk_put(sw_hcd_io->phy_clk);
+		sw_hcd_io->phy_clk = NULL;
+	}
+
+	if(sw_hcd_io->phy0_clk){
+		clk_put(sw_hcd_io->phy0_clk);
+		sw_hcd_io->phy0_clk = NULL;
+	}
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     open_usb_clock
+*
+* Description:
+*
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static s32 open_usb_clock(sw_hcd_io_t *sw_hcd_io)
+{
+ 	DMSG_INFO_HCD0("open_usb_clock\n");
+
+	if(sw_hcd_io->sie_clk && sw_hcd_io->phy_clk && sw_hcd_io->phy0_clk && !sw_hcd_io->clk_is_open){
+	   	clk_enable(sw_hcd_io->sie_clk);
+		mdelay(10);
+
+	    clk_enable(sw_hcd_io->phy_clk);
+	    clk_enable(sw_hcd_io->phy0_clk);
+		clk_reset(sw_hcd_io->phy0_clk, 0);
+		mdelay(10);
+
+		sw_hcd_io->clk_is_open = 1;
+	}else{
+		DMSG_INFO("ERR: open usb clock failed, (0x%p, 0x%p, 0x%p, %d)\n",
+			      sw_hcd_io->sie_clk, sw_hcd_io->phy_clk, sw_hcd_io->phy0_clk, sw_hcd_io->clk_is_open);
+	}
+
+	UsbPhyInit(0);
+
+#if 0
+	DMSG_INFO("[hcd0]: open, 0x60(0x%x), 0xcc(0x%x)\n",
+		      (u32)USBC_Readl(SW_VA_CCM_IO_BASE + 0x60),
+		      (u32)USBC_Readl(SW_VA_CCM_IO_BASE + 0xcc));
+#endif
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     close_usb_clock
+*
+* Description:
+*
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static s32 close_usb_clock(sw_hcd_io_t *sw_hcd_io)
+{
+ 	DMSG_INFO_HCD0("close_usb_clock\n");
+
+	if(sw_hcd_io->sie_clk && sw_hcd_io->phy_clk && sw_hcd_io->phy0_clk && sw_hcd_io->clk_is_open){
+		clk_reset(sw_hcd_io->phy0_clk, 1);
+	    clk_disable(sw_hcd_io->phy0_clk);
+	    clk_disable(sw_hcd_io->phy_clk);
+	    clk_disable(sw_hcd_io->sie_clk);
+		sw_hcd_io->clk_is_open = 0;
+	}else{
+		DMSG_INFO("ERR: close usb clock failed, (0x%p, 0x%p, 0x%p, %d)\n",
+			      sw_hcd_io->sie_clk, sw_hcd_io->phy_clk, sw_hcd_io->phy0_clk, sw_hcd_io->clk_is_open);
+	}
+
+#if 0
+	DMSG_INFO("[hcd0]: close, 0x60(0x%x), 0xcc(0x%x)\n",
+		      (u32)USBC_Readl(SW_VA_CCM_IO_BASE + 0x60),
+		      (u32)USBC_Readl(SW_VA_CCM_IO_BASE + 0xcc));
+#endif
+
+	return 0;
+}
+
+#else
+
+static s32 usb_clock_init(sw_hcd_io_t *sw_hcd_io)
+{
+	return 0;
+}
+
+static s32 usb_clock_exit(sw_hcd_io_t *sw_hcd_io)
+{
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     open_usb_clock
+*
+* Description:
+*
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static u32  open_usb_clock(sw_hcd_io_t *sw_hcd_io)
+{
+	u32 reg_value = 0;
+	u32 ccmu_base = SW_VA_CCM_IO_BASE;
+
+ 	DMSG_INFO_HCD0("[%s]: open_usb_clock\n", sw_hcd_driver_name);
+
+	//Gating AHB clock for USB_phy0
+	reg_value = USBC_Readl(ccmu_base + 0x60);
+	reg_value |= (1 << 0);	            /* AHB clock gate usb0 */
+	USBC_Writel(reg_value, (ccmu_base + 0x60));
+
+	//delay to wati SIE stable
+	reg_value = 10000;
+	while(reg_value--);
+
+	//Enable module clock for USB phy0
+	reg_value = USBC_Readl(ccmu_base + 0xcc);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value |= (1 << 9);
+#endif
+	reg_value |= (1 << 8);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value |= (1 << 6);
+	reg_value |= (1 << 1);
+#endif
+	reg_value |= (1 << 0);          //disable reset
+	USBC_Writel(reg_value, (ccmu_base + 0xcc));
+
+	//delay some time
+	reg_value = 10000;
+	while(reg_value--);
+
+	sw_hcd_io->clk_is_open = 1;
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     close_usb_clock
+*
+* Description:
+*
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static u32 close_usb_clock(sw_hcd_io_t *sw_hcd_io)
+{
+#if defined(CONFIG_ARCH_SUN4I)
+	u32 reg_value = 0;
+	u32 ccmu_base = SW_VA_CCM_IO_BASE;
+
+ 	DMSG_INFO_HCD0("[%s]: close_usb_clock\n", sw_hcd_driver_name);
+
+	//Gating AHB clock for USB_phy0
+	reg_value = USBC_Readl(ccmu_base + 0x60);
+	reg_value &= ~(1 << 0);	            /* AHB clock gate usb0 */
+	USBC_Writel(reg_value, (ccmu_base + 0x60));
+
+	//sie
+	reg_value = 10000;
+	while(reg_value--);
+
+	//Enable module clock for USB phy0
+	reg_value = USBC_Readl(ccmu_base + 0xcc);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value &= ~(1 << 9);
+#endif
+	reg_value &= ~(1 << 8);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value &= ~(1 << 6);
+	reg_value &= ~(1 << 1);
+#endif
+	reg_value &= ~(1 << 0);          //disable reset
+	USBC_Writel(reg_value, (ccmu_base + 0xcc));
+
+	//
+	reg_value = 10000;
+	while(reg_value--);
+
+	sw_hcd_io->clk_is_open = 0;
+
+#endif
+	return 0;
+}
+
+#endif
+
+/*
+*******************************************************************************
+*                     pin_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 pin_init(sw_hcd_io_t *sw_hcd_io)
+{
+	__s32 ret = 0;
+
+	/* request gpio */
+	ret = script_parser_fetch("usbc0", "usb_drv_vbus_gpio", (int *)&sw_hcd_io->drv_vbus_gpio_set, 64);
+	if(ret != 0){
+		DMSG_PANIC("ERR: get usbc0(drv vbus) id failed\n");
+	}
+
+	if (!sw_hcd_io->drv_vbus_gpio_set.port) {
+		DMSG_PANIC("ERR: usbc0(drv vbus) is invalid\n");
+		sw_hcd_io->Drv_vbus_Handle = 0;
+		return 0;
+	}
+
+	if (sw_hcd_io->drv_vbus_gpio_set.port == 0xffff) {    /* power */
+		if (sw_hcd_io->drv_vbus_gpio_set.mul_sel == 0 ||
+				sw_hcd_io->drv_vbus_gpio_set.mul_sel == 1) {
+			axp_gpio_set_io(sw_hcd_io->drv_vbus_gpio_set.port_num,
+					sw_hcd_io->drv_vbus_gpio_set.mul_sel);
+			axp_gpio_set_value(
+					sw_hcd_io->drv_vbus_gpio_set.port_num,
+					!sw_hcd_io->drv_vbus_gpio_set.data);
+
+			return 100 + sw_hcd_io->drv_vbus_gpio_set.port_num;
+		} else {
+			DMSG_PANIC("ERR: unkown gpio mul_sel(%d)\n",
+					sw_hcd_io->drv_vbus_gpio_set.mul_sel);
+			return 0;
+		}
+	} else {  /* axp */
+		sw_hcd_io->Drv_vbus_Handle = sunxi_gpio_request_array(
+				&sw_hcd_io->drv_vbus_gpio_set, 1);
+	if(sw_hcd_io->Drv_vbus_Handle == 0){
+		DMSG_PANIC("ERR: gpio_request failed\n");
+		return -1;
+	}
+
+	/* set config, ouput */
+	gpio_set_one_pin_io_status(sw_hcd_io->Drv_vbus_Handle,
+				   !sw_hcd_io->drv_vbus_gpio_set.data, NULL);
+
+	/* reserved is pull down */
+	gpio_set_one_pin_pull(sw_hcd_io->Drv_vbus_Handle, 2, NULL);
+	}
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     pin_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 pin_exit(sw_hcd_io_t *sw_hcd_io)
+{
+	if (sw_hcd_io->Drv_vbus_Handle) {
+		if (sw_hcd_io->drv_vbus_gpio_set.port == 0xffff) { /* power */
+			axp_gpio_set_io(sw_hcd_io->drv_vbus_gpio_set.port_num,
+					sw_hcd_io->drv_vbus_gpio_set.mul_sel);
+			axp_gpio_set_value(
+					sw_hcd_io->drv_vbus_gpio_set.port_num,
+					sw_hcd_io->drv_vbus_gpio_set.data);
+		} else {
+	gpio_release(sw_hcd_io->Drv_vbus_Handle, 0);
+		}
+	}
+	sw_hcd_io->Drv_vbus_Handle = 0;
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_board_set_vbus
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int hcd0_set_vbus_cnt = 1;
+static int hcd0_enable = 1;
+
+static void sw_hcd_board_set_vbus(struct sw_hcd *sw_hcd, int is_on)
+{
+    u32 on_off = 0;
+	sw_hcd_io_t *hcd_io = sw_hcd->sw_hcd_io;
+
+	/*
+	sw_hcd : host driver insmod
+		(device connected to otg & otg perform as host hcd0)
+	hcd0_enable : battery capacity allow power supply on hcd0
+	*/
+
+	if (is_on)
+		hcd0_set_vbus_cnt++;
+	else
+		hcd0_set_vbus_cnt--;
+	DMSG_INFO("is_on = %d, hcd0_set_vbus_cnt = %d\n",
+			is_on, hcd0_set_vbus_cnt);
+
+	if (!sw_hcd)
+		return;
+
+	if (sw_hcd->sw_hcd_io->Drv_vbus_Handle == 0) {
+		DMSG_INFO("wrn: sw_hcd_io->drv_vbus_Handle is null\n");
+		return;
+	}
+
+    /* set power */
+    if(sw_hcd->sw_hcd_io->drv_vbus_gpio_set.data == 0){
+        on_off = is_on ? 1 : 0;
+    }else{
+        on_off = is_on ? 0 : 1;
+    }
+
+	if (is_on && hcd0_set_vbus_cnt == 1) {
+		DMSG_INFO("[%s]: Set USB Power On\n", sw_hcd->driver_name);
+		if (sw_hcd->sw_hcd_io->drv_vbus_gpio_set.port == 0xffff)
+			axp_gpio_set_value(hcd_io->drv_vbus_gpio_set.port_num,
+					on_off);
+		else
+			gpio_write_one_pin_value(hcd_io->Drv_vbus_Handle,
+					on_off, NULL);
+	/* set gpio data */
+		USBC_Host_StartSession(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+		USBC_ForceVbusValid(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_VBUS_TYPE_HIGH);
+	} else if (!is_on && hcd0_set_vbus_cnt == 0) {
+		DMSG_INFO("[%s]: Set USB Power Off\n", sw_hcd->driver_name);
+		if (sw_hcd->sw_hcd_io->drv_vbus_gpio_set.port == 0xffff)
+			axp_gpio_set_value(hcd_io->drv_vbus_gpio_set.port_num,
+					on_off);
+		else
+			gpio_write_one_pin_value(hcd_io->Drv_vbus_Handle,
+					on_off, NULL);
+
+		set_hcd0_connect_status(0);
+		USBC_Host_EndSession(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+		USBC_ForceVbusValid(sw_hcd->sw_hcd_io->usb_bsp_hdle, USBC_VBUS_TYPE_DISABLE);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_bsp_init
+*
+* Description:
+*    initialize usb bsp
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 sw_hcd_bsp_init(__u32 usbc_no, sw_hcd_io_t *sw_hcd_io)
+{
+    memset(&sw_hcd_io->usbc, 0, sizeof(bsp_usbc_t));
+
+	sw_hcd_io->usbc.usbc_info[usbc_no].num  = usbc_no;
+	sw_hcd_io->usbc.usbc_info[usbc_no].base = (u32)sw_hcd_io->usb_vbase;
+	sw_hcd_io->usbc.sram_base = (u32)sw_hcd_io->sram_vbase;
+
+//	USBC_init(&sw_hcd_io->usbc);
+	sw_hcd_io->usb_bsp_hdle = USBC_open_otg(usbc_no);
+	if(sw_hcd_io->usb_bsp_hdle == 0){
+		DMSG_PANIC("ERR: sw_hcd_init: USBC_open_otg failed\n");
+		return -1;
+	}
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_bsp_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 sw_hcd_bsp_exit(__u32 usbc_no, sw_hcd_io_t *sw_hcd_io)
+{
+	USBC_close_otg(sw_hcd_io->usb_bsp_hdle);
+	sw_hcd_io->usb_bsp_hdle = 0;
+
+//	USBC_exit(&sw_hcd_io->usbc);
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_io_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 sw_hcd_io_init(__u32 usbc_no, struct platform_device *pdev, sw_hcd_io_t *sw_hcd_io)
+{
+	__s32 ret = 0;
+	spinlock_t lock;
+	unsigned long flags = 0;
+
+	sw_hcd_io->usb_vbase  = (void __iomem *)SW_VA_USB0_IO_BASE;
+	sw_hcd_io->sram_vbase = (void __iomem *)SW_VA_SRAM_IO_BASE;
+
+//	DMSG_INFO_HCD0("[usb host]: usb_vbase    = 0x%x\n", (u32)sw_hcd_io->usb_vbase);
+//	DMSG_INFO_HCD0("[usb host]: sram_vbase   = 0x%x\n", (u32)sw_hcd_io->sram_vbase);
+
+    /* open usb lock */
+	ret = usb_clock_init(sw_hcd_io);
+	if(ret != 0){
+		DMSG_PANIC("ERR: usb_clock_init failed\n");
+		ret = -ENOMEM;
+		goto io_failed;
+	}
+
+	open_usb_clock(sw_hcd_io);
+
+    /* initialize usb bsp */
+	sw_hcd_bsp_init(usbc_no, sw_hcd_io);
+
+	/* config usb fifo */
+	spin_lock_init(&lock);
+	spin_lock_irqsave(&lock, flags);
+	USBC_ConfigFIFO_Base(sw_hcd_io->usb_bsp_hdle, (u32)sw_hcd_io->sram_vbase, USBC_FIFO_MODE_8K);
+	spin_unlock_irqrestore(&lock, flags);
+
+	/* config drv_vbus pin */
+	ret = pin_init(sw_hcd_io);
+	if(ret != 0){
+		DMSG_PANIC("ERR: pin_init failed\n");
+		ret = -ENOMEM;
+		goto io_failed1;
+	}
+
+	/* get usb_host_init_state */
+	ret = script_parser_fetch(SET_USB0, KEY_USB_HOST_INIT_STATE, (int *)&(sw_hcd_io->host_init_state), 64);
+	if(ret != 0){
+		DMSG_PANIC("ERR: script_parser_fetch host_init_state failed\n");
+		ret = -ENOMEM;
+		goto io_failed2;
+	}
+
+	DMSG_INFO("[sw_hcd0]: host_init_state = %d\n", sw_hcd_io->host_init_state);
+
+	return 0;
+
+io_failed2:
+	pin_exit(sw_hcd_io);
+
+io_failed1:
+	sw_hcd_bsp_exit(usbc_no, sw_hcd_io);
+	close_usb_clock(sw_hcd_io);
+	usb_clock_exit(sw_hcd_io);
+
+io_failed:
+	sw_hcd_io->usb_vbase = 0;
+	sw_hcd_io->sram_vbase = 0;
+
+	return ret;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 sw_hcd_io_exit(__u32 usbc_no, struct platform_device *pdev, sw_hcd_io_t *sw_hcd_io)
+{
+	sw_hcd_bsp_exit(usbc_no, sw_hcd_io);
+
+	/* config drv_vbus pin */
+	pin_exit(sw_hcd_io);
+
+	close_usb_clock(sw_hcd_io);
+
+	usb_clock_exit(sw_hcd_io);
+
+	sw_hcd_io->usb_vbase = 0;
+	sw_hcd_io->sram_vbase = 0;
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_shutdown
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_shutdown(struct platform_device *pdev)
+{
+    struct sw_hcd 	*sw_hcd = NULL;
+    unsigned long   flags = 0;
+
+    if(pdev == NULL){
+        DMSG_INFO("err: Invalid argment\n");
+    	return ;
+    }
+
+    sw_hcd = dev_to_sw_hcd(&pdev->dev);
+    if(sw_hcd == NULL){
+        DMSG_INFO("err: sw_hcd is null\n");
+    	return ;
+    }
+
+    if(!sw_hcd->enable){
+    	DMSG_INFO("wrn: hcd is disable, need not shutdown\n");
+    	return ;
+    }
+
+    DMSG_INFO_HCD0("sw_hcd shutdown start\n");
+
+    spin_lock_irqsave(&sw_hcd->lock, flags);
+    sw_hcd_platform_disable(sw_hcd);
+    sw_hcd_generic_disable(sw_hcd);
+    spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+    sw_hcd_port_suspend_ex(sw_hcd);
+    sw_hcd_set_vbus(sw_hcd, 0);
+    close_usb_clock(&g_sw_hcd_io);
+
+    DMSG_INFO_HCD0("Set aside some time to AXP\n");
+
+    /* Set aside some time to AXP */
+    mdelay(100);
+
+    DMSG_INFO_HCD0("sw_hcd shutdown end\n");
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     fifo_setup
+*
+* Description:
+*    configure a fifo; for non-shared endpoints, this may be called
+* once for a tx fifo and once for an rx fifo.
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    returns negative errno or offset for next fifo.
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int fifo_setup(struct sw_hcd *sw_hcd,
+                     struct sw_hcd_hw_ep *hw_ep,
+                     const struct fifo_cfg *cfg,
+                     u16 offset)
+{
+	void __iomem    *usbc_base  	= NULL;
+	u16             maxpacket   	= 0;
+    u32 			ep_fifo_size 	= 0;
+    u16				old_ep_index 	= 0;
+	u32             is_double_fifo 	= 0;
+
+    /* check argment */
+    if(sw_hcd == NULL || hw_ep == NULL || cfg == NULL){
+        DMSG_PANIC("ERR: invalid argment\n");
+	    return -1;
+    }
+
+    /* initialize parameter */
+    usbc_base = sw_hcd->mregs;
+    maxpacket = cfg->maxpacket;
+
+	/* expect hw_ep has already been zero-initialized */
+	if (cfg->mode == BUF_DOUBLE) {
+		ep_fifo_size = offset + (maxpacket << 1);
+		is_double_fifo = 1;
+	} else {
+		ep_fifo_size = offset + maxpacket;
+	}
+
+	if (ep_fifo_size > sw_hcd->config->ram_size){
+	    DMSG_PANIC("ERR: fifo_setup, free is not enough, ep_fifo_size = %d, ram_size = %d\n",
+			       ep_fifo_size, sw_hcd->config->ram_size);
+		return -EMSGSIZE;
+	}
+
+	DMSG_DBG_HCD("hw_ep->epnum   = 0x%x\n", hw_ep->epnum);
+	DMSG_DBG_HCD("is_double_fifo = 0x%x\n", is_double_fifo);
+	DMSG_DBG_HCD("ep_fifo_size   = 0x%x\n", ep_fifo_size);
+	DMSG_DBG_HCD("hw_ep->fifo    = 0x%x\n", (u32)hw_ep->fifo);
+	DMSG_DBG_HCD("maxpacket      = 0x%x\n", maxpacket);
+
+	/* configure the FIFO */
+	old_ep_index = USBC_GetActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle);
+	USBC_SelectActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle, hw_ep->epnum);
+
+    /* EP0 reserved endpoint for control, bidirectional;
+	 * EP1 reserved for bulk, two unidirection halves.
+	 */
+	if (hw_ep->epnum == 1){
+		sw_hcd->bulk_ep = hw_ep;
+	}
+
+	/* REVISIT error check:  be sure ep0 can both rx and tx ... */
+	switch (cfg->style) {
+	    case FIFO_TX:
+	    {
+			USBC_ConfigFifo(sw_hcd->sw_hcd_io->usb_bsp_hdle,
+				            USBC_EP_TYPE_TX,
+				            is_double_fifo,
+				            maxpacket,
+				            offset);
+
+    		hw_ep->tx_double_buffered = is_double_fifo;
+    		hw_ep->max_packet_sz_tx = maxpacket;
+	    }
+		break;
+
+	    case FIFO_RX:
+	    {
+			USBC_ConfigFifo(sw_hcd->sw_hcd_io->usb_bsp_hdle,
+				            USBC_EP_TYPE_RX,
+				            is_double_fifo,
+				            maxpacket,
+				            offset);
+
+    		hw_ep->rx_double_buffered = is_double_fifo;
+    		hw_ep->max_packet_sz_rx = maxpacket;
+	    }
+		break;
+
+	    case FIFO_RXTX:
+	    {
+			if(hw_ep->epnum == 0){
+				USBC_ConfigFifo(sw_hcd->sw_hcd_io->usb_bsp_hdle,
+					            USBC_EP_TYPE_EP0,
+					            is_double_fifo,
+					            maxpacket,
+					            offset);
+
+		   		hw_ep->tx_double_buffered = 0;
+				hw_ep->rx_double_buffered = 0;
+
+		    	hw_ep->max_packet_sz_tx = maxpacket;
+				hw_ep->max_packet_sz_rx = maxpacket;
+			}else{
+				DMSG_PANIC("ERR: fifo_setup, FIFO_RXTX not support\n");
+			}
+
+    		hw_ep->is_shared_fifo = true;
+	    }
+		break;
+	}
+
+	/* NOTE rx and tx endpoint irqs aren't managed separately,
+	 * which happens to be ok
+	 */
+	sw_hcd->epmask |= (1 << hw_ep->epnum);
+
+	return ep_fifo_size;
+}
+
+/*
+*******************************************************************************
+*                     ep_config_from_table
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int ep_config_from_table(struct sw_hcd *sw_hcd)
+{
+	const struct fifo_cfg	*cfg    = NULL;
+	unsigned                i       = 0;
+	unsigned                n       = 0;
+	int                     offset  = 0;
+	struct sw_hcd_hw_ep    	*hw_ep  = sw_hcd->endpoints;
+
+    cfg = mode_4_cfg;
+    n = ARRAY_SIZE(mode_4_cfg);
+
+    /* assert(offset > 0) */
+    offset = fifo_setup(sw_hcd, hw_ep, &ep0_cfg, 0);
+
+	for (i = 0; i < n; i++) {
+		u8 epn = cfg->hw_ep_num;
+
+		DMSG_DBG_HCD("i=%d, cfg->hw_ep_num = 0x%x\n", i, cfg->hw_ep_num);
+
+		if (epn >= sw_hcd->config->num_eps) {
+			DMSG_PANIC("ERR: %s: invalid ep%d, max ep is ep%d\n",
+				       sw_hcd_driver_name, epn, sw_hcd->config->num_eps);
+			return -EINVAL;
+		}
+
+		offset = fifo_setup(sw_hcd, hw_ep + epn, cfg++, offset);
+		if (offset < 0) {
+			DMSG_PANIC("ERR: %s: mem overrun, ep %d\n", sw_hcd_driver_name, epn);
+			return -EINVAL;
+		}
+
+		epn++;
+		sw_hcd->nr_endpoints = max(epn, sw_hcd->nr_endpoints);
+	}
+
+	DMSG_DBG_HCD("ep_config_from_table: %s: %d/%d max ep, %d/%d memory\n",
+                 sw_hcd_driver_name,
+			     n + 1, sw_hcd->config->num_eps * 2 - 1,
+			     offset, sw_hcd->config->ram_size);
+
+	if (!sw_hcd->bulk_ep) {
+		DMSG_PANIC("ERR: %s: missing bulk\n", sw_hcd_driver_name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     ep_config_from_hw
+*
+* Description:
+*    ep_config_from_hw - when sw_hcd_C_DYNFIFO_DEF is false
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int ep_config_from_hw(struct sw_hcd *sw_hcd)
+{
+	u8                  epnum       = 0;
+	struct sw_hcd_hw_ep   *hw_ep      = NULL;
+	void                *usbc_base  = sw_hcd->mregs;
+	int                 ret         = 0;
+
+	/* FIXME pick up ep0 maxpacket size */
+
+	for (epnum = 1; epnum < sw_hcd->config->num_eps; epnum++) {
+		sw_hcd_ep_select(usbc_base, epnum);
+		hw_ep = sw_hcd->endpoints + epnum;
+
+		ret = sw_hcd_read_fifosize(sw_hcd, hw_ep, epnum);
+		if (ret < 0){
+			break;
+		}
+
+		/* FIXME set up hw_ep->{rx,tx}_double_buffered */
+
+		/* pick an RX/TX endpoint for bulk */
+		if (hw_ep->max_packet_sz_tx < 512
+				|| hw_ep->max_packet_sz_rx < 512)
+			continue;
+
+		/* REVISIT:  this algorithm is lazy, we should at least
+		 * try to pick a double buffered endpoint.
+		 */
+		if (sw_hcd->bulk_ep)
+			continue;
+		sw_hcd->bulk_ep = hw_ep;
+	}
+
+	if (!sw_hcd->bulk_ep) {
+		DMSG_PANIC("ERR: %s: missing bulk\n", sw_hcd_driver_name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+enum { SW_HCD_CONTROLLER_MHDRC, SW_HCD_CONTROLLER_HDRC, };
+
+/*
+*******************************************************************************
+*                     sw_hcd_core_init
+*
+* Description:
+*    Initialize USB hardware subsystem;
+* configure endpoints, or take their config from silicon
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_hcd_core_init(u16 sw_hcd_type, struct sw_hcd *sw_hcd)
+{
+	u8              reg         = 0;
+	char            aInfo[128];
+	void __iomem    *usbc_base  = sw_hcd->mregs;
+	int             status      = 0;
+	int             i           = 0;
+
+	memset(aInfo, 0, sizeof(aInfo));
+
+	/* log core options (read using indexed model) */
+	sw_hcd_ep_select(usbc_base, 0);
+	reg = sw_hcd_read_configdata(usbc_base);
+
+	strcpy(aInfo, (reg & (1 << USBC_BP_CONFIGDATA_UTMI_DATAWIDTH)) ?
+		      "UTMI-16" : "UTMI-8");
+
+	if (reg & (1 << USBC_BP_CONFIGDATA_DYNFIFO_SIZING)){
+		strcat(aInfo, ", dyn FIFOs");
+	}
+
+	if (reg & (1 << USBC_BP_CONFIGDATA_MPRXE)) {
+		strcat(aInfo, ", bulk combine");
+
+		sw_hcd->bulk_combine = true;
+	}
+
+	if (reg & (1 << USBC_BP_CONFIGDATA_MPTXE)) {
+		strcat(aInfo, ", bulk split");
+
+		sw_hcd->bulk_split = true;
+	}
+
+	if (reg & (1 << USBC_BP_CONFIGDATA_HBRXE)) {
+		strcat(aInfo, ", HB-ISO Rx");
+		strcat(aInfo, " (X)");		/* no driver support */
+	}
+
+	if (reg & (1 << USBC_BP_CONFIGDATA_HBTXE)) {
+		strcat(aInfo, ", HB-ISO Tx");
+		strcat(aInfo, " (X)");		/* no driver support */
+	}
+
+	if (reg & (1 << USBC_BP_CONFIGDATA_SOFTCONE)){
+		strcat(aInfo, ", SoftConn");
+	}
+
+	DMSG_INFO_HCD0("%s: ConfigData=0x%02x (%s)\n", sw_hcd_driver_name,
+		       reg, aInfo);
+
+	if (SW_HCD_CONTROLLER_MHDRC == sw_hcd_type) {
+		sw_hcd->is_multipoint = 1;
+	} else {
+	    sw_hcd->is_multipoint = 0;
+		DMSG_INFO_HCD0("%s: kernel must blacklist external hubs\n", sw_hcd_driver_name);
+	}
+
+	/* configure ep0 */
+	sw_hcd_configure_ep0(sw_hcd);
+
+	/* discover endpoint configuration */
+	sw_hcd->nr_endpoints = 1;
+	sw_hcd->epmask = 1;
+
+	if (reg & (1 << USBC_BP_CONFIGDATA_DYNFIFO_SIZING)) {
+		if(sw_hcd->config->dyn_fifo){
+			status = ep_config_from_table(sw_hcd);
+		}else{
+			DMSG_PANIC("ERR: reconfigure software for Dynamic FIFOs\n");
+			status = -ENODEV;
+		}
+	} else {
+		if(!sw_hcd->config->dyn_fifo){
+			status = ep_config_from_hw(sw_hcd);
+		}else{
+			DMSG_PANIC("ERR: reconfigure software for static FIFOs\n");
+			return -ENODEV;
+		}
+	}
+
+	if (status < 0){
+	    DMSG_PANIC("ERR: sw_hcd_core_init, config failed\n");
+		return status;
+    }
+
+	/* finish init, and print endpoint config */
+	for (i = 0; i < sw_hcd->nr_endpoints; i++) {
+		struct sw_hcd_hw_ep *hw_ep = sw_hcd->endpoints + i;
+
+        hw_ep->fifo         = (void __iomem *)USBC_REG_EPFIFOx(usbc_base, i);
+        hw_ep->regs         = usbc_base;
+        hw_ep->target_regs  = sw_hcd_read_target_reg_base(i, usbc_base);
+		hw_ep->rx_reinit    = 1;
+		hw_ep->tx_reinit    = 1;
+
+/*
+		if (hw_ep->max_packet_sz_tx) {
+			DMSG_INFO_HCD0("%s: hw_ep %d%s, %smax %d\n",
+        				sw_hcd_driver_name, i,
+        				(hw_ep->is_shared_fifo ? "shared" : "tx"),
+        				(hw_ep->tx_double_buffered ? "doublebuffer, " : ""),
+        				hw_ep->max_packet_sz_tx);
+		}
+
+        if (hw_ep->max_packet_sz_rx && !hw_ep->is_shared_fifo) {
+			DMSG_INFO_HCD0("%s: hw_ep %d%s, %smax %d\n",
+        				sw_hcd_driver_name, i,
+        				"rx",
+        				(hw_ep->rx_double_buffered ? "doublebuffer, " : ""),
+        				hw_ep->max_packet_sz_rx);
+		}
+
+        if (!(hw_ep->max_packet_sz_tx || hw_ep->max_packet_sz_rx)){
+			DMSG_INFO_HCD0("hw_ep %d not configured\n", i);
+        }
+*/
+    }
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_irq_work
+*
+* Description:
+*    Only used to provide driver mode change events
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_irq_work(struct work_struct *data)
+{
+	struct sw_hcd *sw_hcd = container_of(data, struct sw_hcd, irq_work);
+
+	sysfs_notify(&sw_hcd->controller->kobj, NULL, "mode");
+
+	return;
+}
+
+static const struct hc_driver sw_hcd_hc_driver = {
+	.description		= "sw_hcd-hcd",
+	.product_desc		= "sw_hcd host driver",
+	.hcd_priv_size		= sizeof(struct sw_hcd),
+	.flags			= HCD_USB2 | HCD_MEMORY,
+
+	/* not using irq handler or reset hooks from usbcore, since
+	 * those must be shared with peripheral code for OTG configs
+	 */
+
+	.start              = sw_hcd_h_start,
+	.stop               = sw_hcd_h_stop,
+
+	.get_frame_number	= sw_hcd_h_get_frame_number,
+
+	.urb_enqueue		= sw_hcd_urb_enqueue,
+	.urb_dequeue		= sw_hcd_urb_dequeue,
+	.endpoint_disable	= sw_hcd_h_disable,
+
+	.hub_status_data	= sw_hcd_hub_status_data,
+	.hub_control		= sw_hcd_hub_control,
+	.bus_suspend		= sw_hcd_bus_suspend,
+	.bus_resume		    = sw_hcd_bus_resume,
+};
+
+/*
+*******************************************************************************
+*                     allocate_instance
+*
+* Description:
+*    Init struct sw_hcd
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static struct sw_hcd *allocate_instance(struct device *dev,
+                                             struct sw_hcd_config *config,
+                                             void __iomem *mbase)
+{
+	struct sw_hcd         *sw_hcd = NULL;
+	struct sw_hcd_hw_ep   *ep = NULL;
+	int                 epnum = 0;
+	struct usb_hcd      *hcd = NULL;
+
+	hcd = usb_create_hcd(&sw_hcd_hc_driver, dev, dev_name(dev));
+	if (!hcd){
+	    DMSG_PANIC("ERR: usb_create_hcd failed\n");
+		return NULL;
+	}
+
+	/* usbcore sets dev->driver_data to hcd, and sometimes uses that... */
+	sw_hcd = hcd_to_sw_hcd(hcd);
+	if(sw_hcd == NULL){
+		DMSG_PANIC("ERR: hcd_to_sw_hcd failed\n");
+		return NULL;
+	}
+
+	memset(sw_hcd, 0, sizeof(struct sw_hcd));
+
+	INIT_LIST_HEAD(&sw_hcd->control);
+	INIT_LIST_HEAD(&sw_hcd->in_bulk);
+	INIT_LIST_HEAD(&sw_hcd->out_bulk);
+
+	hcd->has_tt		  = 1;
+    hcd->uses_new_polling   = 1;
+	sw_hcd->vbuserr_retry     = VBUSERR_RETRY_COUNT;
+    sw_hcd->mregs             = mbase;
+	sw_hcd->ctrl_base         = mbase;
+	sw_hcd->nIrq              = -ENODEV;
+	sw_hcd->config            = config;
+
+#ifndef  CONFIG_USB_SW_SUNXI_USB0_OTG
+	g_sw_hcd0 = sw_hcd;
+	sw_hcd->enable = 1;
+#else
+    if(sw_hcd->config->port_info->port_type == USB_PORT_TYPE_HOST){
+        g_sw_hcd0 = sw_hcd;
+    	sw_hcd->enable = 1;
+    }
+#endif
+
+	strcpy(sw_hcd->driver_name, sw_hcd_driver_name);
+
+	for (epnum = 0, ep = sw_hcd->endpoints;
+			epnum < sw_hcd->config->num_eps;
+			epnum++, ep++) {
+		ep->sw_hcd = sw_hcd;
+		ep->epnum = epnum;
+	}
+
+	sw_hcd->controller = dev;
+	sw_hcd->sw_hcd_io    = &g_sw_hcd_io;
+	sw_hcd->usbc_no	 = usbc_no;
+
+	return sw_hcd;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_free
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_hcd_free(struct sw_hcd *sw_hcd)
+{
+    void __iomem    *usbc_base  = sw_hcd->mregs;
+
+	/* this has multiple entry modes. it handles fault cleanup after
+	 * probe(), where things may be partially set up, as well as rmmod
+	 * cleanup after everything's been de-activated.
+	 */
+    if (sw_hcd->nIrq >= 0) {
+		if (sw_hcd->irq_wake) {
+			disable_irq_wake(sw_hcd->nIrq);
+		}
+
+		free_irq(sw_hcd->nIrq, sw_hcd);
+	}
+
+	if (is_hcd_support_dma(sw_hcd->usbc_no)) {
+		sw_hcd_dma_remove(sw_hcd);
+	}
+
+	USBC_Writeb(0x00, USBC_REG_DEVCTL(usbc_base));
+	sw_hcd_platform_exit(sw_hcd);
+	USBC_Writeb(0x00, USBC_REG_DEVCTL(usbc_base));
+
+    usb_put_hcd(sw_hcd_to_hcd(sw_hcd));
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     hcd0_generic_interrupt
+*
+* Description:
+*    Perform generic per-controller initialization.
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static irqreturn_t hcd0_generic_interrupt(int irq, void *__hci)
+{
+	DMSG_DBG_HCD("irq: %s\n", sw_hcd_driver_name);
+
+	return generic_interrupt(irq, __hci);
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_init_controller
+*
+* Description:
+*    Perform generic per-controller initialization.
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_hcd_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
+{
+	int                        	status  = 0;
+	struct sw_hcd              	*sw_hcd	= 0;
+	struct sw_hcd_platform_data	*plat   = dev->platform_data;
+
+	/* The driver might handle more features than the board; OK.
+	 * Fail when the board needs a feature that's not enabled.
+	 */
+	if (!plat) {
+		DMSG_PANIC("ERR: no platform_data?\n");
+		return -ENODEV;
+	}
+
+    switch (plat->mode) {
+	    case SW_HCD_HOST:
+            DMSG_INFO_HCD0("platform is usb host\n");
+		break;
+
+    	default:
+    		DMSG_PANIC("ERR: unkown platform mode(%d)\n", plat->mode);
+    		return -EINVAL;
+	}
+
+	/* allocate */
+	sw_hcd = allocate_instance(dev, plat->config, ctrl);
+	if (!sw_hcd){
+	    DMSG_PANIC("ERR: allocate_instance failed\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&sw_hcd->lock);
+	sw_hcd->board_mode        = plat->mode;
+	sw_hcd->board_set_power   = plat->set_power;
+	sw_hcd->set_clock         = plat->set_clock;
+	sw_hcd->min_power         = plat->min_power;
+	sw_hcd->board_set_vbus    = sw_hcd_board_set_vbus;
+
+	/* assume vbus is off */
+
+	/* platform adjusts sw_hcd->mregs and sw_hcd->isr if needed,
+	 * and activates clocks
+	 */
+	sw_hcd->isr = hcd0_generic_interrupt;
+	status = sw_hcd_platform_init(sw_hcd);
+	if (status < 0){
+	    DMSG_PANIC("ERR: sw_hcd_platform_init failed\n");
+		goto fail;
+	}
+
+	if (!sw_hcd->isr) {
+	    DMSG_PANIC("ERR: sw_hcd->isr is null\n");
+		status = -ENODEV;
+		goto fail2;
+	}
+
+    if (is_hcd_support_dma(sw_hcd->usbc_no)) {
+		status = sw_hcd_dma_probe(sw_hcd);
+		if (status < 0){
+		    DMSG_PANIC("ERR: sw_hcd_dma_probe failed\n");
+			goto fail2;
+		}
+	}
+
+	/* be sure interrupts are disabled before connecting ISR */
+	sw_hcd_platform_disable(sw_hcd);
+	sw_hcd_generic_disable(sw_hcd);
+
+	/* setup sw_hcd parts of the core (especially endpoints) */
+	status = sw_hcd_core_init(plat->config->multipoint ? SW_HCD_CONTROLLER_MHDRC : SW_HCD_CONTROLLER_HDRC, sw_hcd);
+	if (status < 0){
+	    DMSG_PANIC("ERR: sw_hcd_core_init failed\n");
+		goto fail2;
+	}
+
+	/* Init IRQ workqueue before request_irq */
+	INIT_WORK(&sw_hcd->irq_work, sw_hcd_irq_work);
+
+	/* attach to the IRQ */
+	if (request_irq(nIrq, sw_hcd->isr, 0, dev_name(dev), sw_hcd)) {
+		DMSG_PANIC("ERR: request_irq %d failed!\n", nIrq);
+		status = -ENODEV;
+		goto fail2;
+	}
+
+	sw_hcd->nIrq = nIrq;
+
+    /* FIXME this handles wakeup irqs wrong */
+	if (enable_irq_wake(nIrq) == 0) {
+		sw_hcd->irq_wake = 1;
+		device_init_wakeup(dev, 1);
+	} else {
+		sw_hcd->irq_wake = 0;
+	}
+
+	DMSG_INFO_HCD0("sw_hcd_init_controller: %s: USB %s mode controller at %p using %s, IRQ %d\n",
+        			sw_hcd_driver_name,
+        			"Host",
+        			ctrl,
+        			is_hcd_support_dma(sw_hcd->usbc_no) ? "DMA" : "PIO",
+        			sw_hcd->nIrq);
+
+	/* host side needs more setup, except for no-host modes */
+	if (sw_hcd->board_mode != SW_HCD_PERIPHERAL) {
+		struct usb_hcd	*hcd = sw_hcd_to_hcd(sw_hcd);
+
+		hcd->power_budget = 2 * (plat->power ? : 250);
+	}
+
+	/* For the host-only role, we can activate right away.
+	 * (We expect the ID pin to be forcibly grounded!!)
+	 * Otherwise, wait till the gadget driver hooks up.
+	 */
+	if (is_host_enabled(sw_hcd)) {
+		SW_HCD_HST_MODE(sw_hcd);
+
+		status = usb_add_hcd(sw_hcd_to_hcd(sw_hcd), -1, 0);
+		if (status){
+		    DMSG_PANIC("ERR: usb_add_hcd failed\n");
+		    goto fail;
+		}
+    }
+
+    return 0;
+
+fail2:
+	if (is_hcd_support_dma(sw_hcd->usbc_no)) {
+		sw_hcd_dma_remove(sw_hcd);
+	}
+
+	sw_hcd_platform_exit(sw_hcd);
+
+fail:
+	DMSG_PANIC("ERR: sw_hcd_init_controller failed with status %d\n", status);
+
+	device_init_wakeup(dev, 0);
+	sw_hcd_free(sw_hcd);
+
+	return status;
+}
+
+#ifdef CONFIG_USB_SW_SUNXI_USB0_OTG
+/*
+*******************************************************************************
+*                     sw_usb_host0_enable
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_usb_host0_enable(void)
+{
+	struct platform_device 	*pdev 	= NULL;
+	struct device   		*dev  	= NULL;
+	struct sw_hcd 			*sw_hcd	= NULL;
+	unsigned long   		flags 	= 0;
+
+	DMSG_INFO_HCD0("sw_usb_host0_enable start\n");
+
+	pdev = g_hcd0_pdev;
+	if(pdev == NULL){
+		DMSG_PANIC("ERR: pdev is null\n");
+		return -1;
+	}
+
+	dev = &pdev->dev;
+	if(dev == NULL){
+		DMSG_PANIC("ERR: dev is null\n");
+		return -1;
+	}
+
+	sw_hcd = dev_to_sw_hcd(&pdev->dev);
+	if(sw_hcd == NULL){
+		DMSG_PANIC("ERR: sw_hcd is null\n");
+		return -1;
+	}
+
+	g_sw_hcd0 = sw_hcd;
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd->enable = 1;
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	/* request usb irq */
+	INIT_WORK(&sw_hcd->irq_work, sw_hcd_irq_work);
+
+	if (request_irq(sw_hcd->nIrq, sw_hcd->isr, 0, dev_name(dev), sw_hcd)) {
+		DMSG_PANIC("ERR: request_irq %d failed!\n", sw_hcd->nIrq);
+		return -1;
+	}
+
+	sw_hcd_soft_disconnect(sw_hcd);
+	sw_hcd_io_init(usbc_no, pdev, &g_sw_hcd_io);
+
+	/* enable usb controller */
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd_platform_init(sw_hcd);
+	sw_hcd_restore_context(sw_hcd);
+	sw_hcd_start(sw_hcd);
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	DMSG_INFO_HCD0("sw_usb_host0_enable end\n");
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_host0_enable);
+
+/*
+*******************************************************************************
+*                     sw_usb_host0_disable
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_usb_host0_disable(void)
+{
+	struct platform_device 	*pdev 	= NULL;
+	struct sw_hcd 			*sw_hcd	= NULL;
+	unsigned long   		flags 	= 0;
+
+	DMSG_INFO_HCD0("sw_usb_host0_disable start\n");
+
+	pdev = g_hcd0_pdev;
+	if(pdev == NULL){
+		DMSG_PANIC("ERR: pdev is null\n");
+		return -1;
+	}
+
+	sw_hcd = dev_to_sw_hcd(&pdev->dev);
+	if(sw_hcd == NULL){
+		DMSG_PANIC("ERR: sw_hcd is null\n");
+		return -1;
+	}
+
+	if(sw_hcd->suspend){
+	    DMSG_PANIC("wrn: sw_hcd is suspend, can not disable\n");
+		return -EBUSY;
+	}
+
+	/* nuke all urb and disconnect */
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd_soft_disconnect(sw_hcd);
+	sw_hcd_port_suspend_ex(sw_hcd);
+	sw_hcd_set_vbus(sw_hcd, 0);
+	sw_hcd_stop(sw_hcd);
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	/* release usb irq */
+	if (sw_hcd->nIrq >= 0) {
+		if (sw_hcd->irq_wake) {
+			disable_irq_wake(sw_hcd->nIrq);
+		}
+
+		free_irq(sw_hcd->nIrq, sw_hcd);
+	}
+
+	/* disable usb controller */
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd_save_context(sw_hcd);
+	sw_hcd_platform_exit(sw_hcd);
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	sw_hcd_io_exit(usbc_no, pdev, &g_sw_hcd_io);
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd->enable = 0;
+	g_sw_hcd0 = NULL;
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	DMSG_INFO_HCD0("sw_usb_host0_disable end\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_host0_disable);
+
+/*
+*******************************************************************************
+*                     sw_hcd_probe_otg
+*
+* Description:
+*    all implementations (PCI bridge to FPGA, VLYNQ, etc) should just
+* bridge to a platform device; this driver then suffices.
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_hcd_probe_otg(struct platform_device *pdev)
+{
+	struct device   *dev    = &pdev->dev;
+	int             irq     = SW_INT_IRQNO_USB0; //platform_get_irq(pdev, 0);
+	__s32 			ret 	= 0;
+	__s32 			status	= 0;
+
+	if (irq == 0){
+	    DMSG_PANIC("ERR: platform_get_irq failed\n");
+		return -ENODEV;
+	}
+
+	g_hcd0_pdev = pdev;
+	usbc_no = 0;
+
+    memset(&g_sw_hcd_io, 0, sizeof(sw_hcd_io_t));
+	ret = sw_hcd_io_init(usbc_no, pdev, &g_sw_hcd_io);
+	if(ret != 0){
+		DMSG_PANIC("ERR: sw_hcd_io_init failed\n");
+		status = -ENODEV;
+		goto end;
+	}
+
+	ret = sw_hcd_init_controller(dev, irq, g_sw_hcd_io.usb_vbase);
+	if(ret != 0){
+		DMSG_PANIC("ERR: sw_hcd_init_controller failed\n");
+		status = -ENODEV;
+		goto end;
+	}
+
+	ret = sw_usb_host0_disable();
+	if(ret != 0){
+		DMSG_PANIC("ERR: sw_usb_host0_disable failed\n");
+		status = -ENODEV;
+		goto end;
+	}
+
+end:
+    return status;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_remove_otg
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_hcd_remove_otg(struct platform_device *pdev)
+{
+	struct sw_hcd *sw_hcd = dev_to_sw_hcd(&pdev->dev);
+
+    sw_hcd_shutdown(pdev);
+    if (sw_hcd->board_mode == SW_HCD_HOST){
+		usb_remove_hcd(sw_hcd_to_hcd(sw_hcd));
+	}
+
+    sw_hcd_free(sw_hcd);
+	device_init_wakeup(&pdev->dev, 0);
+
+	pdev->dev.dma_mask = 0;
+
+	sw_hcd_io_exit(usbc_no, pdev, &g_sw_hcd_io);
+	g_hcd0_pdev = NULL;
+	usbc_no = 0;
+
+	return 0;
+}
+#endif
+
+/*
+*******************************************************************************
+*                     sw_hcd_probe_host_only
+*
+* Description:
+*    all implementations (PCI bridge to FPGA, VLYNQ, etc) should just
+* bridge to a platform device; this driver then suffices.
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_hcd_probe_host_only(struct platform_device *pdev)
+{
+	struct device   *dev        = &pdev->dev;
+	int             irq         = SW_INT_IRQNO_USB0; //platform_get_irq(pdev, 0);
+	__s32 			ret 		= 0;
+
+	if (irq == 0){
+	    DMSG_PANIC("ERR: platform_get_irq failed\n");
+		return -ENODEV;
+	}
+
+	usbc_no = 0;
+
+    memset(&g_sw_hcd_io, 0, sizeof(sw_hcd_io_t));
+	ret = sw_hcd_io_init(usbc_no, pdev, &g_sw_hcd_io);
+	if(ret != 0){
+		DMSG_PANIC("ERR: sw_hcd_io_init failed\n");
+		return -ENODEV;
+	}
+
+	ret = sw_hcd_init_controller(dev, irq, g_sw_hcd_io.usb_vbase);
+	if(ret != 0){
+		DMSG_PANIC("ERR: sw_hcd_init_controller failed\n");
+		return -ENODEV;
+	}
+
+	if (g_sw_hcd_io.host_init_state) {
+		USBC_Host_StartSession(g_sw_hcd_io.usb_bsp_hdle);
+		USBC_ForceVbusValid(g_sw_hcd_io.usb_bsp_hdle,
+				    USBC_VBUS_TYPE_HIGH);
+	} else {
+		sw_usb_disable_hcd0();
+	}
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_remove_host_only
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_hcd_remove_host_only(struct platform_device *pdev)
+{
+	struct sw_hcd     *sw_hcd = dev_to_sw_hcd(&pdev->dev);
+
+    sw_hcd_shutdown(pdev);
+    if (sw_hcd->board_mode == SW_HCD_HOST){
+		usb_remove_hcd(sw_hcd_to_hcd(sw_hcd));
+	}
+
+	sw_hcd->enable = 0;
+	g_sw_hcd0 = NULL;
+
+    sw_hcd_free(sw_hcd);
+	device_init_wakeup(&pdev->dev, 0);
+
+	pdev->dev.dma_mask = 0;
+
+	sw_hcd_io_exit(usbc_no, pdev, &g_sw_hcd_io);
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_probe
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int __init sw_hcd_probe(struct platform_device *pdev)
+{
+#ifdef  CONFIG_USB_SW_SUNXI_USB0_OTG
+	struct sw_hcd_platform_data	*pdata = pdev->dev.platform_data;
+
+    switch(pdata->config->port_info->port_type){
+        case USB_PORT_TYPE_HOST:
+            return sw_hcd_probe_host_only(pdev);
+        //break;
+
+        case USB_PORT_TYPE_OTG:
+            return sw_hcd_probe_otg(pdev);
+        //break;
+
+        default:
+            DMSG_PANIC("ERR: unkown port_type(%d)\n", pdata->config->port_info->port_type);
+    }
+
+    return 0;
+#else
+    return sw_hcd_probe_host_only(pdev);
+#endif
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_remove
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int __devexit sw_hcd_remove(struct platform_device *pdev)
+{
+#ifdef  CONFIG_USB_SW_SUNXI_USB0_OTG
+	struct sw_hcd_platform_data	*pdata = pdev->dev.platform_data;
+
+    switch(pdata->config->port_info->port_type){
+        case USB_PORT_TYPE_HOST:
+            return sw_hcd_remove_host_only(pdev);
+        //break;
+
+        case USB_PORT_TYPE_OTG:
+            return sw_hcd_remove_otg(pdev);
+        //break;
+
+        default:
+            DMSG_PANIC("ERR: unkown port_type(%d)\n", pdata->config->port_info->port_type);
+    }
+
+    return 0;
+#else
+    return sw_hcd_remove_host_only(pdev);
+#endif
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_save_context
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    only save ep status regs
+*
+*******************************************************************************
+*/
+static void sw_hcd_save_context(struct sw_hcd *sw_hcd)
+{
+	int i = 0;
+	void __iomem *sw_hcd_base = sw_hcd->mregs;
+
+	/* Common Register */
+	for(i = 0; i < SW_HCD_C_NUM_EPS; i++){
+		USBC_SelectActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle, i);
+
+		if(i == 0){
+			sw_hcd_context.ep_reg[i].USB_CSR0 = USBC_Readl(USBC_REG_EX_USB_CSR0(sw_hcd_base));
+		}else{
+			sw_hcd_context.ep_reg[i].USB_TXCSR = USBC_Readl(USBC_REG_EX_USB_TXCSR(sw_hcd_base));
+			sw_hcd_context.ep_reg[i].USB_RXCSR	= USBC_Readl(USBC_REG_EX_USB_RXCSR(sw_hcd_base));
+		}
+
+		if(i == 0){
+			sw_hcd_context.ep_reg[i].USB_ATTR0 = USBC_Readl(USBC_REG_EX_USB_ATTR0(sw_hcd_base));
+		}else{
+			sw_hcd_context.ep_reg[i].USB_EPATTR = USBC_Readl(USBC_REG_EX_USB_EPATTR(sw_hcd_base));
+			sw_hcd_context.ep_reg[i].USB_TXFIFO	= USBC_Readl(USBC_REG_EX_USB_TXFIFO(sw_hcd_base));
+			sw_hcd_context.ep_reg[i].USB_RXFIFO	= USBC_Readl(USBC_REG_EX_USB_RXFIFO(sw_hcd_base));
+		}
+
+		sw_hcd_context.ep_reg[i].USB_TXFADDR	= USBC_Readl(USBC_REG_EX_USB_TXFADDR(sw_hcd_base));
+		if(i != 0){
+			sw_hcd_context.ep_reg[i].USB_RXFADDR	= USBC_Readl(USBC_REG_EX_USB_RXFADDR(sw_hcd_base));
+		}
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_save_context
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    only save ep status regs
+*
+*******************************************************************************
+*/
+static void sw_hcd_restore_context(struct sw_hcd *sw_hcd)
+{
+	int i = 0;
+	void __iomem *sw_hcd_base = sw_hcd->mregs;
+
+	/* Common Register */
+	for(i = 0; i < SW_HCD_C_NUM_EPS; i++){
+		USBC_SelectActiveEp(sw_hcd->sw_hcd_io->usb_bsp_hdle, i);
+
+		if(i == 0){
+			USBC_Writel(sw_hcd_context.ep_reg[i].USB_CSR0, USBC_REG_EX_USB_CSR0(sw_hcd_base));
+		}else{
+			USBC_Writel(sw_hcd_context.ep_reg[i].USB_TXCSR, USBC_REG_EX_USB_TXCSR(sw_hcd_base));
+			USBC_Writel(sw_hcd_context.ep_reg[i].USB_RXCSR, USBC_REG_EX_USB_RXCSR(sw_hcd_base));
+		}
+
+		if(i == 0){
+			USBC_Writel(sw_hcd_context.ep_reg[i].USB_ATTR0, USBC_REG_EX_USB_ATTR0(sw_hcd_base));
+		}else{
+			USBC_Writel(sw_hcd_context.ep_reg[i].USB_EPATTR, USBC_REG_EX_USB_EPATTR(sw_hcd_base));
+			USBC_Writel(sw_hcd_context.ep_reg[i].USB_TXFIFO, USBC_REG_EX_USB_TXFIFO(sw_hcd_base));
+			USBC_Writel(sw_hcd_context.ep_reg[i].USB_RXFIFO, USBC_REG_EX_USB_RXFIFO(sw_hcd_base));
+		}
+
+		USBC_Writel(sw_hcd_context.ep_reg[i].USB_TXFADDR, USBC_REG_EX_USB_TXFADDR(sw_hcd_base));
+		if(i != 0){
+			USBC_Writel(sw_hcd_context.ep_reg[i].USB_RXFADDR, USBC_REG_EX_USB_RXFADDR(sw_hcd_base));
+		}
+	}
+
+	return ;
+}
+
+/*
+*******************************************************************************
+*                     sw_usb_disable_hcd0
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_usb_disable_hcd0(void)
+{
+#ifdef  CONFIG_USB_SW_SUNXI_USB0_HOST
+	struct device *dev = NULL;
+	struct platform_device *pdev = NULL;
+	unsigned long flags = 0;
+	struct sw_hcd *sw_hcd = NULL;
+
+	DMSG_INFO("sw_usb_disable_hcd0 start, clk_is_open = %d\n",
+		      		sw_hcd->sw_hcd_io->clk_is_open);
+
+	if(!g_sw_hcd0){
+		DMSG_PANIC("WRN: hcd is disable, g_sw_hcd0 is null\n");
+		return 0;
+	}
+
+	dev    = g_sw_hcd0->controller;
+	pdev   = to_platform_device(dev);
+	sw_hcd = dev_to_sw_hcd(&pdev->dev);
+
+	if(sw_hcd == NULL){
+		DMSG_PANIC("ERR: sw_hcd is null\n");
+		return 0;
+	}
+
+#ifndef  CONFIG_USB_SW_SUNXI_USB0_HOST
+	if(sw_hcd->config->port_info->port_type != USB_PORT_TYPE_HOST
+	  || sw_hcd->config->port_info->host_init_state){
+        DMSG_PANIC("ERR: only host mode support sw_usb_disable_hcd, (%d, %d)\n",
+                   sw_hcd->config->port_info->port_type,
+                   sw_hcd->config->port_info->host_init_state);
+		return 0;
+	}
+#endif
+
+	if(!sw_hcd->enable){
+		DMSG_PANIC("WRN: hcd is disable, can not enter to disable again\n");
+		return 0;
+	}
+
+	if(!sw_hcd->sw_hcd_io->clk_is_open){
+		DMSG_PANIC("ERR: sw_usb_disable_hcd0, usb clock is close, can't close again\n");
+		return 0;
+	}
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd_port_suspend_ex(sw_hcd);
+	sw_hcd_stop(sw_hcd);
+	sw_hcd_set_vbus(sw_hcd, 0);
+	sw_hcd_save_context(sw_hcd);
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	close_usb_clock(sw_hcd->sw_hcd_io);
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd_soft_disconnect(sw_hcd);
+	sw_hcd->enable = 0;
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	DMSG_INFO("sw_usb_disable_hcd0 end\n");
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_disable_hcd0);
+
+/*
+*******************************************************************************
+*                     sw_usb_enable_hcd0
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_usb_enable_hcd0(void)
+{
+#ifdef  CONFIG_USB_SW_SUNXI_USB0_HOST
+	struct device *dev = NULL;
+	struct platform_device *pdev = NULL;
+	unsigned long	flags = 0;
+	struct sw_hcd	*sw_hcd = NULL;
+
+	DMSG_INFO("sw_usb_enable_hcd0 start, clk_is_open = %d\n",
+		      		sw_hcd->sw_hcd_io->clk_is_open);
+
+	if(!g_sw_hcd0){
+		DMSG_PANIC("WRN: g_sw_hcd0 is null\n");
+		return 0;
+	}
+
+	dev    = g_sw_hcd0->controller;
+	pdev   = to_platform_device(dev);
+	sw_hcd = dev_to_sw_hcd(&pdev->dev);
+
+	if(sw_hcd == NULL){
+		DMSG_PANIC("ERR: sw_hcd is null\n");
+		return 0;
+	}
+
+#ifndef  CONFIG_USB_SW_SUNXI_USB0_HOST
+	if(sw_hcd->config->port_info->port_type != USB_PORT_TYPE_HOST
+	  || sw_hcd->config->port_info->host_init_state){
+        DMSG_PANIC("ERR: only host mode support sw_usb_enable_hcd, (%d, %d)\n",
+                   sw_hcd->config->port_info->port_type,
+                   sw_hcd->config->port_info->host_init_state);
+		return 0;
+	}
+#endif
+
+	if(sw_hcd->enable == 1){
+		DMSG_PANIC("WRN: hcd is already enable, can not enable again\n");
+		return 0;
+	}
+
+	if(sw_hcd->sw_hcd_io->clk_is_open){
+		DMSG_PANIC("ERR: sw_usb_enable_hcd0, usb clock is open, can't open again\n");
+		return 0;
+	}
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd->enable = 1;
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	open_usb_clock(sw_hcd->sw_hcd_io);
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd_restore_context(sw_hcd);
+	sw_hcd_start(sw_hcd);
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	DMSG_INFO("sw_usb_enable_hcd0 end\n");
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_enable_hcd0);
+
+/*
+*******************************************************************************
+*                     sw_hcd_suspend
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_hcd_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	unsigned long	flags = 0;
+	struct sw_hcd	*sw_hcd = dev_to_sw_hcd(&pdev->dev);
+
+	DMSG_INFO_HCD0("sw_hcd_suspend start\n");
+
+	if(!sw_hcd->enable){
+		DMSG_INFO("wrn: hcd is disable, need not enter to suspend\n");
+		return 0;
+	}
+
+	if(!sw_hcd->sw_hcd_io->clk_is_open){
+		DMSG_INFO("wrn: sw_hcd_suspend, usb clock is close, can't close again\n");
+		return 0;
+	}
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd->suspend = 1;
+	sw_hcd_port_suspend_ex(sw_hcd);
+	sw_hcd_stop(sw_hcd);
+	sw_hcd_set_vbus(sw_hcd, 0);
+	sw_hcd_save_context(sw_hcd);
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	close_usb_clock(sw_hcd->sw_hcd_io);
+
+	DMSG_INFO_HCD0("sw_hcd_suspend end\n");
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_hcd_resume_early
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_hcd_resume(struct device *dev)
+{	struct platform_device *pdev = to_platform_device(dev);
+	unsigned long	flags = 0;
+	struct sw_hcd	*sw_hcd = dev_to_sw_hcd(&pdev->dev);
+
+	DMSG_INFO_HCD0("sw_hcd_resume start\n");
+
+	if(!sw_hcd->enable){
+		DMSG_INFO("wrn: hcd is disable, need not resume\n");
+		return 0;
+	}
+
+	if(sw_hcd->sw_hcd_io->clk_is_open){
+		DMSG_INFO("wrn: sw_hcd_suspend, usb clock is open, can't open again\n");
+		return 0;
+	}
+
+	sw_hcd_soft_disconnect(sw_hcd);
+	open_usb_clock(sw_hcd->sw_hcd_io);
+
+	spin_lock_irqsave(&sw_hcd->lock, flags);
+	sw_hcd_restore_context(sw_hcd);
+	sw_hcd_start(sw_hcd);
+	sw_hcd->suspend = 0;
+	spin_unlock_irqrestore(&sw_hcd->lock, flags);
+
+	DMSG_INFO_HCD0("sw_hcd_resume_early end\n");
+
+	return 0;
+}
+
+static const struct dev_pm_ops sw_hcd_dev_pm_ops = {
+	.suspend		= sw_hcd_suspend,
+	.resume     	= sw_hcd_resume,
+};
+
+static struct platform_driver sw_hcd_driver = {
+	.driver = {
+		.name		= (char *)sw_hcd_driver_name,
+		.bus		= &platform_bus_type,
+		.owner		= THIS_MODULE,
+		.pm			= &sw_hcd_dev_pm_ops,
+	},
+
+	.remove		    = __devexit_p(sw_hcd_remove),
+	.shutdown	    = sw_hcd_shutdown,
+};
+
+/*
+*******************************************************************************
+*                     sw_hcd_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int __init sw_hcd_init(void)
+{
+	DMSG_INFO_HCD0("usb host driver initialize........\n");
+#ifdef CONFIG_USB_PORT_POWER_MANAGEMENT
+	hcd0_set_vbus_cnt--;
+	hcd0_enable--;
+#endif
+    if (usb_disabled()){
+        DMSG_PANIC("ERR: usb disabled\n");
+		return 0;
+	}
+
+    return platform_driver_probe(&sw_hcd_driver, sw_hcd_probe);
+}
+
+/* make us init after usbcore and i2c (transceivers, regulators, etc)
+ * and before usb gadget and host-side drivers start to register
+ */
+//module_init(sw_hcd_init);
+fs_initcall(sw_hcd_init);
+
+/*
+*******************************************************************************
+*                     sw_hcd_cleanup
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void __exit sw_hcd_cleanup(void)
+{
+	platform_driver_unregister(&sw_hcd_driver);
+
+	DMSG_INFO_HCD0("usb host driver exit........\n");
+}
+
+module_exit(sw_hcd_cleanup);
+
+
+int hcd0_set_vbus(int is_on)
+{
+	struct sw_hcd *sw_hcd = g_sw_hcd0;
+
+	if (is_on)
+		hcd0_enable = 1;
+	else
+		hcd0_enable = 0;
+
+	sw_hcd_board_set_vbus(sw_hcd, is_on);
+
+	return 0;
+}
+EXPORT_SYMBOL(hcd0_set_vbus);
+
+int hcd0_get_vbus_status(void)
+{
+	return hcd0_enable;
+}
+EXPORT_SYMBOL(hcd0_get_vbus_status);
+
+static int hcd0_connect_status;
+
+void set_hcd0_connect_status(int status)
+{
+	hcd0_connect_status = status;
+	return;
+}
+EXPORT_SYMBOL(set_hcd0_connect_status);
+
+int get_hcd0_connect_status(void)
+{
+	return hcd0_connect_status;
+}
+EXPORT_SYMBOL(get_hcd0_connect_status);
diff --git a/drivers/usb/sunxi_usb/hcd/include/sw_hcd_board.h b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_board.h
new file mode 100644
index 0000000..948aced
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_board.h
@@ -0,0 +1,67 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/include/sw_hcd_board.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_BOARD_H__
+#define  __SW_HCD_BOARD_H__
+
+#include <plat/sys_config.h>
+
+#define  USB_SRAMC_BASE	            0x01c00000
+#define  USB_CLOCK_BASE				0x01C20000
+#define  USB_PIO_BASE	            0x01c20800
+
+/* i/o  */
+typedef struct sw_hcd_io{
+	struct resource	*usb_base_res;   	/* USB  resources 		*/
+	struct resource	*usb_base_req;   	/* USB  resources 		*/
+	void __iomem	*usb_vbase;			/* USB  base address 	*/
+
+	struct resource	*sram_base_res;   	/* SRAM resources 		*/
+	struct resource	*sram_base_req;   	/* SRAM resources 		*/
+	void __iomem	*sram_vbase;		/* SRAM base address 	*/
+
+	struct resource	*clock_base_res;   	/* clock resources 		*/
+	struct resource	*clock_base_req;   	/* clock resources 		*/
+	void __iomem	*clock_vbase;		/* clock base address 	*/
+
+	struct resource	*pio_base_res;   	/* pio resources 		*/
+	struct resource	*pio_base_req;   	/* pio resources 		*/
+	void __iomem	*pio_vbase;			/* pio base address 	*/
+
+	bsp_usbc_t usbc;					/* usb bsp config 		*/
+	__hdle usb_bsp_hdle;				/* usb bsp handle 		*/
+
+	__u32 clk_is_open;					/* is usb clock open? 	*/
+	struct clk	*sie_clk;				/* SIE clock handle 	*/
+	struct clk	*phy_clk;				/* PHY gate 			*/
+	struct clk	*phy0_clk;				/* PHY reset 			*/
+
+	unsigned Drv_vbus_Handle;
+	user_gpio_set_t drv_vbus_gpio_set;
+	__u32 host_init_state;				/* usb 0 : . 1 :  */
+	__u32 usb_enable;
+}sw_hcd_io_t;
+
+#endif   //__SW_HCD_BOARD_H__
+
+
diff --git a/drivers/usb/sunxi_usb/hcd/include/sw_hcd_config.h b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_config.h
new file mode 100644
index 0000000..737494e
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_config.h
@@ -0,0 +1,48 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/include/sw_hcd_config.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_CONFIG_H__
+#define  __SW_HCD_CONFIG_H__
+
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+
+#include  "../../include/sw_usb_config.h"
+#include  "sw_hcd_debug.h"
+
+//-------------------------------------------------------
+//
+//-------------------------------------------------------
+//#define        XUSB_DEBUG    /*  */
+
+/* xusb hcd  */
+#if	0
+    #define DMSG_DBG_HCD     			DMSG_PRINT
+#else
+    #define DMSG_DBG_HCD(...)
+#endif
+
+#endif   //__SW_HCD_CONFIG_H__
+
diff --git a/drivers/usb/sunxi_usb/hcd/include/sw_hcd_core.h b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_core.h
new file mode 100644
index 0000000..721e4e7
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_core.h
@@ -0,0 +1,345 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/include/sw_hcd_core.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_CORE_H__
+#define  __SW_HCD_CORE_H__
+
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+
+#ifdef SW_HCD_DMA
+#include <plat/dma.h>
+#include <linux/dma-mapping.h>
+#endif
+
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+
+#include  "sw_hcd_config.h"
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+struct sw_hcd;
+struct sw_hcd_hw_ep;
+
+#include  "sw_hcd_regs_i.h"
+
+#include  "sw_hcd_board.h"
+#include  "sw_hcd_host.h"
+#include  "sw_hcd_virt_hub.h"
+#include  "sw_hcd_dma.h"
+
+
+
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+
+#define is_host_active(m)		((m)->is_host)
+
+
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+
+#define	is_host_capable()			(1)
+#define SW_HCD_C_NUM_EPS      		USBC_MAX_EP_NUM
+#define	is_host_enabled(sw_usb)		is_host_capable()
+
+/* host side ep0 states */
+enum sw_hcd_h_ep0_state {
+	SW_HCD_EP0_IDLE,
+	SW_HCD_EP0_START,			/* expect ack of setup */
+	SW_HCD_EP0_IN,			/* expect IN DATA */
+	SW_HCD_EP0_OUT,			/* expect ack of OUT DATA */
+	SW_HCD_EP0_STATUS,		/* expect ack of STATUS */
+}__attribute__ ((packed));
+
+
+/*
+ * struct sw_hcd_hw_ep - endpoint hardware (bidirectional)
+ *
+ * Ordered slightly for better cacheline locality.
+ */
+typedef struct sw_hcd_hw_ep{
+	struct sw_hcd *sw_hcd;              /* ep                     */
+	void __iomem *fifo;             /* fifo                   */
+	void __iomem *regs;             /* USB                */
+
+	u8 epnum;      	                /* index in sw_hcd->endpoints[]   */
+
+	/* hardware configuration, possibly dynamic */
+	bool is_shared_fifo;            /*  fifo                */
+	bool tx_double_buffered;        /* Flag. fifo?          */
+	bool rx_double_buffered;        /* Flag. fifo?          */
+	u16 max_packet_sz_tx;           /*                    */
+	u16 max_packet_sz_rx;           /*                    */
+
+	void __iomem *target_regs;      /* hub        */
+
+	/* currently scheduled peripheral endpoint */
+	struct sw_hcd_qh *in_qh;          /*  in ep         */
+	struct sw_hcd_qh *out_qh;         /*  out ep        */
+
+	u8 rx_reinit;                   /* flag.          */
+	u8 tx_reinit;                   /* flag.          */
+}sw_hcd_hw_ep_t;
+
+
+/*
+ * struct sw_hcd - Driver instance data.
+ */
+typedef struct sw_hcd{
+    /* device lock */
+	spinlock_t lock;                    /*        */
+	irqreturn_t (*isr)(int, void *);    /*  */
+	struct work_struct irq_work;        /*  */
+
+	char driver_name[32];
+	__u32 usbc_no;
+
+/* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
+#define SW_HCD_PORT_STAT_RESUME	(1 << 31)
+	u32 port1_status;                   /*  hub   */
+	unsigned long rh_timer;             /* root hub delay */
+
+	enum sw_hcd_h_ep0_state ep0_stage;    /* ep0            */
+
+	/* bulk traffic normally dedicates endpoint hardware, and each
+	 * direction has its own ring of host side endpoints.
+	 * we try to progress the transfer at the head of each endpoint's
+	 * queue until it completes or NAKs too much; then we try the next
+	 * endpoint.
+	 */
+	struct sw_hcd_hw_ep *bulk_ep;
+
+	struct list_head control;	        /* of sw_hcd_qh           */
+	struct list_head in_bulk;	        /* of sw_hcd_qh           */
+	struct list_head out_bulk;	        /* of sw_hcd_qh           */
+
+    /* called with IRQs blocked; ON/nonzero implies starting a session,
+	 * and waiting at least a_wait_vrise_tmout.
+	 */
+	void (*board_set_vbus)(struct sw_hcd *, int is_on);
+
+#ifdef SW_HCD_DMA
+	sw_hcd_dma_t sw_hcd_dma;
+#endif
+
+	struct device *controller;          /*  */
+	void __iomem *ctrl_base;            /* USB        */
+	void __iomem *mregs;                /* USB        */
+
+	/* passed down from chip/board specific irq handlers */
+	u8 int_usb;                         /* USB              */
+	u16 int_rx;                         /* rx               */
+	u16 int_tx;                         /* tx               */
+
+	int nIrq;                           /*                */
+	unsigned irq_wake:1;                /* flag.    */
+
+	struct sw_hcd_hw_ep endpoints[SW_HCD_C_NUM_EPS];    /* sw_hcd  ep  */
+#define control_ep endpoints
+
+#define VBUSERR_RETRY_COUNT	3
+	u16 vbuserr_retry;                  /* vbus error host retry  */
+	u16 epmask;                         /* epbitn = 1,  epn   */
+	u8 nr_endpoints;                    /*  ep                    */
+
+	u8 board_mode;		                /* enum sw_hcd_mode                   */
+
+	int (*board_set_power)(int state);
+	int (*set_clock)(struct clk *clk, int is_active);
+
+	u8 min_power;	                    /* vbus for periph, in mA/2         */
+
+	bool is_host;                       /* flag.  host        */
+	int a_wait_bcon;	                /* VBUS timeout in msecs            */
+	unsigned long idle_timeout;	        /* Next timeout in jiffies          */
+
+	/* active means connected and not suspended */
+	unsigned is_active:1;
+
+	unsigned is_multipoint:1;           /* flag. is multiple transaction ep? */
+	unsigned ignore_disconnect:1;	    /* during bus resets                */
+
+	unsigned bulk_split:1;
+#define	can_bulk_split(sw_usb, type)       (((type) == USB_ENDPOINT_XFER_BULK) && (sw_usb)->bulk_split)
+
+	unsigned bulk_combine:1;
+#define	can_bulk_combine(sw_usb, type)     (((type) == USB_ENDPOINT_XFER_BULK) && (sw_usb)->bulk_combine)
+
+	struct sw_hcd_config	*config;        /* sw_hcd                   */
+
+	sw_hcd_io_t	*sw_hcd_io;
+	u32 enable;
+	u32 suspend;
+}sw_hcd_t;
+
+struct sw_hcd_ep_reg{
+	__u32 USB_CSR0;
+	__u32 USB_TXCSR;
+	__u32 USB_RXCSR;
+	__u32 USB_COUNT0;
+	__u32 USB_RXCOUNT;
+	__u32 USB_ATTR0;
+	__u32 USB_EPATTR;
+	__u32 USB_TXFIFO;
+	__u32 USB_RXFIFO;
+	__u32 USB_FADDR;
+	__u32 USB_TXFADDR;
+	__u32 USB_RXFADDR;
+};
+
+struct sw_hcd_context_registers {
+	/* FIFO Entry for Endpoints */
+	__u32 USB_EPFIFO0;
+	__u32 USB_EPFIFO1;
+	__u32 USB_EPFIFO2;
+	__u32 USB_EPFIFO3;
+	__u32 USB_EPFIFO4;
+	__u32 USB_EPFIFO5;
+
+	/* Common Register */
+	__u32 USB_GCS;
+	__u32 USB_EPINTF;
+	__u32 USB_EPINTE;
+	__u32 USB_BUSINTF;
+	__u32 USB_BUSINTE;
+	__u32 USB_FNUM;
+	__u32 USB_TESTC;
+
+	/* Endpoint Index Register */
+	struct sw_hcd_ep_reg ep_reg[SW_HCD_C_NUM_EPS];
+
+	/* Configuration Register */
+	__u32 USB_CONFIGINFO;
+	__u32 USB_LINKTIM;
+	__u32 USB_OTGTIM;
+
+	/* PHY and Interface Control and Status Register */
+	__u32 USB_ISCR;
+	__u32 USB_PHYCTL;
+	__u32 USB_PHYBIST;
+};
+
+//---------------------------------------------------------------
+//
+//---------------------------------------------------------------
+
+static inline struct sw_hcd *dev_to_sw_hcd(struct device *dev)
+{
+	/* usbcore insists dev->driver_data is a "struct hcd *" */
+	return hcd_to_sw_hcd(dev_get_drvdata(dev));
+}
+
+
+/* vbus  */
+static inline void sw_hcd_set_vbus(struct sw_hcd *sw_hcd, int is_on)
+{
+	if(sw_hcd->board_set_vbus){
+		sw_hcd->board_set_vbus(sw_hcd, is_on);
+	}
+}
+
+/* Read the size of the fifo */
+static inline int sw_hcd_read_fifosize(struct sw_hcd *sw_hcd, struct sw_hcd_hw_ep *hw_ep, u8 epnum)
+{
+	void *xbase = sw_hcd->mregs;
+	u8 reg = 0;
+
+	/* read from core using indexed model */
+	reg = USBC_Readb(USBC_REG_TXFIFOSZ(xbase));
+	/* 0's returned when no more endpoints */
+	if (!reg){
+	    return -ENODEV;
+	}
+	hw_ep->max_packet_sz_tx = 1 << (reg & 0x0f);
+
+	sw_hcd->nr_endpoints++;
+	sw_hcd->epmask |= (1 << epnum);
+
+	/* read from core using indexed model */
+	reg = USBC_Readb(USBC_REG_RXFIFOSZ(xbase));
+	/* 0's returned when no more endpoints */
+	if (!reg){
+	    return -ENODEV;
+	}
+	/* shared TX/RX FIFO? */
+	if ((reg & 0xf0) == 0xf0) {
+		hw_ep->max_packet_sz_rx = hw_ep->max_packet_sz_tx;
+		hw_ep->is_shared_fifo = true;
+		return 0;
+	} else {
+		hw_ep->max_packet_sz_rx = 1 << ((reg & 0xf0) >> 4);
+		hw_ep->is_shared_fifo = false;
+	}
+
+	return 0;
+}
+
+/*  ep0 */
+static inline void sw_hcd_configure_ep0(struct sw_hcd *sw_hcd)
+{
+	sw_hcd->endpoints[0].max_packet_sz_tx = USBC_EP0_FIFOSIZE;
+	sw_hcd->endpoints[0].max_packet_sz_rx = USBC_EP0_FIFOSIZE;
+	sw_hcd->endpoints[0].is_shared_fifo = true;
+}
+
+#define  SW_HCD_HST_MODE(sw_hcd) 	{ (sw_hcd)->is_host = true; }
+#define  is_direction_in(qh)		(qh->hep->desc.bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+void sw_hcd_write_fifo(struct sw_hcd_hw_ep *hw_ep, u16 len, const u8 *src);
+void sw_hcd_read_fifo(struct sw_hcd_hw_ep *hw_ep, u16 len, u8 *dst);
+void sw_hcd_load_testpacket(struct sw_hcd *sw_hcd);
+void sw_hcd_generic_disable(struct sw_hcd *sw_hcd);
+
+irqreturn_t generic_interrupt(int irq, void *__hci);
+
+void sw_hcd_soft_disconnect(struct sw_hcd *sw_hcd);
+void sw_hcd_start(struct sw_hcd *sw_hcd);
+void sw_hcd_stop(struct sw_hcd *sw_hcd);
+
+
+void sw_hcd_platform_try_idle(struct sw_hcd *sw_hcd, unsigned long timeout);
+void sw_hcd_platform_enable(struct sw_hcd *sw_hcd);
+void sw_hcd_platform_disable(struct sw_hcd *sw_hcd);
+int sw_hcd_platform_set_mode(struct sw_hcd *sw_hcd, u8 sw_hcd_mode);
+int sw_hcd_platform_init(struct sw_hcd *sw_hcd);
+int sw_hcd_platform_exit(struct sw_hcd *sw_hcd);
+int sw_hcd_platform_suspend(struct sw_hcd *sw_hcd);
+int sw_hcd_platform_resume(struct sw_hcd *sw_hcd);
+
+#endif   //__SW_HCD_CORE_H__
+
diff --git a/drivers/usb/sunxi_usb/hcd/include/sw_hcd_debug.h b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_debug.h
new file mode 100644
index 0000000..74821e9
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_debug.h
@@ -0,0 +1,34 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/include/sw_hcd_debug.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_DEBUG_H__
+#define  __SW_HCD_DEBUG_H__
+
+#include  "sw_hcd_core.h"
+
+void print_sw_hcd_config(struct sw_hcd_config *config, char *str);
+void print_sw_hcd_list(struct list_head *list_head, char *str);
+void print_urb_list(struct usb_host_endpoint *hep, char *str);
+
+#endif   //__SW_HCD_DEBUG_H__
+
diff --git a/drivers/usb/sunxi_usb/hcd/include/sw_hcd_dma.h b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_dma.h
new file mode 100644
index 0000000..b29e582
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_dma.h
@@ -0,0 +1,71 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/include/sw_hcd_dma.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_DMA_H__
+#define  __SW_HCD_DMA_H__
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+#ifdef SW_HCD_DMA
+#define  is_hcd_support_dma(usbc_no)    (usbc_no == 0)
+#else
+#define  is_hcd_support_dma(usbc_no)    0
+#endif
+
+/* DMA: 1  2DMA 3ep0 */
+#define  is_sw_hcd_dma_capable(usbc_no, len, maxpacket, epnum)	(is_hcd_support_dma(usbc_no) \
+        	                                             		 && (len > maxpacket) \
+        	                                             		 && epnum)
+
+#ifdef SW_HCD_DMA
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+typedef struct sw_hcd_dma{
+	char name[32];
+	struct sw_dma_client dma_client;
+
+	int dma_hdle;	/* dma  */
+}sw_hcd_dma_t;
+#endif
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+void sw_hcd_switch_bus_to_dma(struct sw_hcd_qh *qh, u32 is_in);
+void sw_hcd_switch_bus_to_pio(struct sw_hcd_qh *qh, __u32 is_in);
+
+void sw_hcd_dma_set_config(struct sw_hcd_qh *qh, __u32 buff_addr, __u32 len);
+__u32 sw_hcd_dma_is_busy(struct sw_hcd_qh *qh);
+
+void sw_hcd_dma_start(struct sw_hcd_qh *qh, __u32 fifo, __u32 buffer, __u32 len);
+void sw_hcd_dma_stop(struct sw_hcd_qh *qh);
+__u32 sw_hcd_dma_transmit_length(struct sw_hcd_qh *qh, __u32 is_in, __u32 buffer_addr);
+
+__s32 sw_hcd_dma_probe(struct sw_hcd *sw_hcd);
+__s32 sw_hcd_dma_remove(struct sw_hcd *sw_hcd);
+
+#endif   //__SW_HCD_DMA_H__
+
+
diff --git a/drivers/usb/sunxi_usb/hcd/include/sw_hcd_host.h b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_host.h
new file mode 100644
index 0000000..531a0de
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_host.h
@@ -0,0 +1,124 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/include/sw_hcd_host.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_HOST_H__
+#define  __SW_HCD_HOST_H__
+
+/*  struct usb_hcd  struct sw_hcd  */
+static inline struct usb_hcd *sw_hcd_to_hcd(struct sw_hcd *sw_hcd)
+{
+	return container_of((void *) sw_hcd, struct usb_hcd, hcd_priv);
+}
+
+/*  struct sw_hcd  struct usb_hcd  */
+static inline struct sw_hcd *hcd_to_sw_hcd(struct usb_hcd *hcd)
+{
+	return (struct sw_hcd *) (hcd->hcd_priv);
+}
+
+/* stored in "usb_host_endpoint.hcpriv" for scheduled endpoints */
+typedef struct sw_hcd_qh{
+	struct usb_host_endpoint *hep;  /* usbcore info                 */
+	struct usb_device  *dev;        /* usb device                   */
+	struct sw_hcd_hw_ep  *hw_ep;		/* current binding              */
+
+	struct list_head  ring;		    /* of sw_hcd_qh                   */
+	struct sw_hcd_qh *next;	        /* for periodic tree            */
+	u8  mux;		                /* qh multiplexed to hw_ep      */
+	unsigned  offset;		        /* in urb->transfer_buffer      */
+	unsigned  segsize;	            /* current xfer fragment        */
+
+	u8  type_reg;	                /* {rx,tx} type register        */
+	u8  intv_reg;	                /* {rx,tx} interval register    */
+	u8  addr_reg;	                /* device address register      */
+	u8  h_addr_reg;	                /* hub address register         */
+	u8  h_port_reg;	                /* hub port register            */
+
+	u8  is_ready;	                /* safe to modify hw_ep         */
+	u8  type;		                /* ep type XFERTYPE_*           */
+	u8  epnum;                      /* target ep index. ep */
+	u16  maxpacket;                 /* max packet size              */
+	u16  frame;		                /* for periodic schedule        */
+	unsigned  iso_idx;	            /* in urb->iso_frame_desc[]     */
+
+	u32 dma_working;				/* flag. dma working flag 		*/
+	u32 dma_transfer_len;			/* flag. dma transfer length 	*/
+}sw_hcd_qh_t;
+
+/* map from control or bulk queue head to the first qh on that ring */
+static inline struct sw_hcd_qh *first_qh(struct list_head *q)
+{
+	if(q == NULL){
+	    DMSG_WRN("ERR: invalid argment\n");
+	    return NULL;
+	}
+
+	if (list_empty(q)){
+	    DMSG_WRN("ERR: invalid argment\n");
+	    return NULL;
+	}
+
+	return list_entry(q->next, struct sw_hcd_qh, ring);
+}
+
+/* get next urb */
+static inline struct urb *next_urb(struct sw_hcd_qh *qh)
+{
+	struct list_head *queue;
+
+	if (!qh){
+	    DMSG_WRN("ERR: invalid argment\n");
+	    return NULL;
+	}
+
+	queue = &qh->hep->urb_list;
+	if (list_empty(queue) || queue->next == NULL){
+	    DMSG_WRN("ERR: list is empty, queue->next = 0x%p\n", queue->next);
+		return NULL;
+	}
+
+	return list_entry(queue->next, struct urb, urb_list);
+}
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+irqreturn_t sw_hcd_h_ep0_irq(struct sw_hcd *sw_hcd);
+
+int sw_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags);
+int sw_hcd_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);
+void sw_hcd_h_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep);
+
+int sw_hcd_h_start(struct usb_hcd *hcd);
+void sw_hcd_h_stop(struct usb_hcd *hcd);
+
+int sw_hcd_h_get_frame_number(struct usb_hcd *hcd);
+int sw_hcd_bus_suspend(struct usb_hcd *hcd);
+int sw_hcd_bus_resume(struct usb_hcd *hcd);
+
+void sw_hcd_host_rx(struct sw_hcd *sw_hcd, u8 epnum);
+void sw_hcd_host_tx(struct sw_hcd *sw_hcd, u8 epnum);
+
+
+#endif   //__SW_HCD_HOST_H__
+
diff --git a/drivers/usb/sunxi_usb/hcd/include/sw_hcd_regs_i.h b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_regs_i.h
new file mode 100644
index 0000000..1774d30
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_regs_i.h
@@ -0,0 +1,119 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/include/sw_hcd_regs_i.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_REGS_I_H__
+#define  __SW_HCD_REGS_I_H__
+
+#include <linux/io.h>
+#include "sw_hcd_config.h"
+
+#define sw_hcd_ep_select(usbc_base, epnum)    USBC_Writeb(epnum, USBC_REG_EPIND(usbc_base))
+
+
+static inline void sw_hcd_readsl(const void __iomem *addr, void *buf, int len)
+	{ insl((unsigned long)addr, buf, len); }
+static inline void sw_hcd_readsw(const void __iomem *addr, void *buf, int len)
+	{ insw((unsigned long)addr, buf, len); }
+static inline void sw_hcd_readsb(const void __iomem *addr, void *buf, int len)
+	{ insb((unsigned long)addr, buf, len); }
+
+static inline void sw_hcd_writesl(const void __iomem *addr, const void *buf, int len)
+	{ outsl((unsigned long)addr, buf, len); }
+static inline void sw_hcd_writesw(const void __iomem *addr, const void *buf, int len)
+	{ outsw((unsigned long)addr, buf, len); }
+static inline void sw_hcd_writesb(const void __iomem *addr, const void *buf, int len)
+	{ outsb((unsigned long)addr, buf, len); }
+
+
+
+/* "bus control"/target registers, for host side multipoint (external hubs) */
+#define USBC_REG_OFFSET_TXFUNCADDR		0x00
+#define USBC_REG_OFFSET_TXHUBADDR		0x02
+#define USBC_REG_OFFSET_TXHUBPORT		0x03
+
+#define USBC_REG_OFFSET_RXFUNCADDR		0x04
+#define USBC_REG_OFFSET_RXHUBADDR		0x06
+#define USBC_REG_OFFSET_RXHUBPORT		0x07
+
+static inline void sw_hcd_write_txfifosz(void __iomem *usbc_base, u8 c_size)
+{
+	USBC_Writeb(c_size, USBC_REG_TXFIFOSZ(usbc_base));
+}
+
+static inline void sw_hcd_write_txfifoadd(void __iomem *usbc_base, u16 c_off)
+{
+	USBC_Writeb(c_off, USBC_REG_TXFIFOAD(usbc_base));
+}
+
+static inline void sw_hcd_write_rxfifosz(void __iomem *usbc_base, u8 c_size)
+{
+	USBC_Writeb(c_size, USBC_REG_RXFIFOSZ(usbc_base));
+}
+
+static inline void  sw_hcd_write_rxfifoadd(void __iomem *usbc_base, u16 c_off)
+{
+	USBC_Writeb(c_off, USBC_REG_RXFIFOAD(usbc_base));
+}
+
+static inline u8 sw_hcd_read_configdata(void __iomem *usbc_base)
+{
+	return USBC_Readb(USBC_REG_CONFIGDATA(usbc_base));
+}
+
+static inline void __iomem *sw_hcd_read_target_reg_base(u8 i, void __iomem *usbc_base)
+{
+	return USBC_REG_TXFADDRx(usbc_base, i);
+}
+
+static inline void sw_hcd_write_rxfunaddr(void __iomem *ep_target_regs, u8 qh_addr_reg)
+{
+	USBC_Writeb(qh_addr_reg, (ep_target_regs + USBC_REG_OFFSET_RXFUNCADDR));
+}
+
+static inline void sw_hcd_write_rxhubaddr(void __iomem *ep_target_regs, u8 qh_h_addr_reg)
+{
+	USBC_Writeb(qh_h_addr_reg, (ep_target_regs + USBC_REG_OFFSET_RXHUBADDR));
+}
+
+static inline void sw_hcd_write_rxhubport(void __iomem *ep_target_regs, u8 qh_h_port_reg)
+{
+	USBC_Writeb(qh_h_port_reg, (ep_target_regs + USBC_REG_OFFSET_RXHUBPORT));
+}
+
+static inline void  sw_hcd_write_txfunaddr(void __iomem *usbc_base, u8 epnum, u8 qh_addr_reg)
+{
+    USBC_Writeb(qh_addr_reg, USBC_REG_TXFADDRx(usbc_base, epnum));
+}
+
+static inline void  sw_hcd_write_txhubaddr(void __iomem *usbc_base, u8 epnum, u8 qh_h_addr_reg)
+{
+	USBC_Writeb(qh_h_addr_reg, USBC_REG_TXHADDRx(usbc_base, epnum));
+}
+
+static inline void  sw_hcd_write_txhubport(void __iomem *usbc_base, u8 epnum, u8 qh_h_port_reg)
+{
+	USBC_Writeb(qh_h_port_reg, USBC_REG_TXHPORTx(usbc_base, epnum));
+}
+
+#endif   //__SW_HCD_REGS_I_H__
+
diff --git a/drivers/usb/sunxi_usb/hcd/include/sw_hcd_virt_hub.h b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_virt_hub.h
new file mode 100644
index 0000000..3ab3389
--- /dev/null
+++ b/drivers/usb/sunxi_usb/hcd/include/sw_hcd_virt_hub.h
@@ -0,0 +1,41 @@
+/*
+ * drivers/usb/sunxi_usb/hcd/include/sw_hcd_virt_hub.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_VIRT_HUB_H__
+#define  __SW_HCD_VIRT_HUB_H__
+
+void sw_hcd_root_disconnect(struct sw_hcd *sw_hcd);
+int sw_hcd_hub_status_data(struct usb_hcd *hcd, char *buf);
+int sw_hcd_hub_control(struct usb_hcd *hcd,
+                     u16 typeReq,
+                     u16 wValue,
+                     u16 wIndex,
+                     char *buf,
+                     u16 wLength);
+
+void sw_hcd_port_suspend_ex(struct sw_hcd *sw_hcd);
+void sw_hcd_port_resume_ex(struct sw_hcd *sw_hcd);
+void sw_hcd_port_reset_ex(struct sw_hcd *sw_hcd);
+
+#endif   //__SW_HCD_VIRT_HUB_H__
+
diff --git a/drivers/usb/sunxi_usb/include/sunxi_sys_reg.h b/drivers/usb/sunxi_usb/include/sunxi_sys_reg.h
new file mode 100644
index 0000000..04ee21f
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_sys_reg.h
@@ -0,0 +1,32 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_sys_reg.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SUNXI_SYS_REG_H__
+#define  __SUNXI_SYS_REG_H__
+
+
+#define  SRAMC_BASE	            0x01c00000
+
+
+#endif   //__SUNXI_SYS_REG_H__
+
diff --git a/drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h b/drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h
new file mode 100644
index 0000000..71a0ffc
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h
@@ -0,0 +1,830 @@
+/*
+ * drivers/usb/sunxi_usb/include/sunxi_usb_bsp.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SUNXI_USB_BSP_H__
+#define  __SUNXI_USB_BSP_H__
+
+//-----------------------------------------------------------------------
+//   , 8bit, 16bit, 32bit
+//-----------------------------------------------------------------------
+
+#define  USBC_Readb(reg)	                    (*(volatile unsigned char *)(reg))
+#define  USBC_Readw(reg)	                    (*(volatile unsigned short *)(reg))
+#define  USBC_Readl(reg)	                    (*(volatile unsigned long *)(reg))
+
+#define  USBC_Writeb(value, reg)                (*(volatile unsigned char *)(reg) = (value))
+#define  USBC_Writew(value, reg)	            (*(volatile unsigned short *)(reg) = (value))
+#define  USBC_Writel(value, reg)	            (*(volatile unsigned long *)(reg) = (value))
+
+#define  USBC_REG_test_bit_b(bp, reg)         	(USBC_Readb(reg) & (1 << (bp)))
+#define  USBC_REG_test_bit_w(bp, reg)   	    (USBC_Readw(reg) & (1 << (bp)))
+#define  USBC_REG_test_bit_l(bp, reg)   	    (USBC_Readl(reg) & (1 << (bp)))
+
+#define  USBC_REG_set_bit_b(bp, reg) 			(USBC_Writeb((USBC_Readb(reg) | (1 << (bp))) , (reg)))
+#define  USBC_REG_set_bit_w(bp, reg) 	 		(USBC_Writew((USBC_Readw(reg) | (1 << (bp))) , (reg)))
+#define  USBC_REG_set_bit_l(bp, reg) 	 		(USBC_Writel((USBC_Readl(reg) | (1 << (bp))) , (reg)))
+
+#define  USBC_REG_clear_bit_b(bp, reg)	 	 	(USBC_Writeb((USBC_Readb(reg) & (~ (1 << (bp)))) , (reg)))
+#define  USBC_REG_clear_bit_w(bp, reg)	 	 	(USBC_Writew((USBC_Readw(reg) & (~ (1 << (bp)))) , (reg)))
+#define  USBC_REG_clear_bit_l(bp, reg)	 	 	(USBC_Writel((USBC_Readl(reg) & (~ (1 << (bp)))) , (reg)))
+
+//---------------------------------------------------------------
+//   reg base
+//---------------------------------------------------------------
+#define  USBC0_BASE                 0x01c13000
+#define  USBC1_BASE                 0x01c14000
+#define  USBC2_BASE                 0x01c1E000
+
+//-----------------------------------------------------------------------
+//   reg offset
+//-----------------------------------------------------------------------
+
+#define  USBC_REG_o_FADDR		    0x0098
+#define  USBC_REG_o_PCTL		    0x0040
+#define  USBC_REG_o_INTTx		    0x0044
+#define  USBC_REG_o_INTRx		    0x0046
+#define  USBC_REG_o_INTTxE		    0x0048
+#define  USBC_REG_o_INTRxE		    0x004A
+#define  USBC_REG_o_INTUSB		    0x004C
+#define  USBC_REG_o_INTUSBE         0x0050
+#define  USBC_REG_o_FRNUM		    0x0054
+#define  USBC_REG_o_EPIND		    0x0042
+#define  USBC_REG_o_TMCTL		    0x007C
+
+#define  USBC_REG_o_TXMAXP		    0x0080
+#define  USBC_REG_o_CSR0		    0x0082
+#define  USBC_REG_o_TXCSR		    0x0082
+#define  USBC_REG_o_RXMAXP		    0x0084
+#define  USBC_REG_o_RXCSR		    0x0086
+#define  USBC_REG_o_COUNT0		    0x0088
+#define  USBC_REG_o_RXCOUNT		    0x0088
+#define  USBC_REG_o_EP0TYPE		    0x008C
+#define  USBC_REG_o_TXTYPE		    0x008C
+#define  USBC_REG_o_NAKLIMIT0	    0x008D
+#define  USBC_REG_o_TXINTERVAL      0x008D
+#define  USBC_REG_o_RXTYPE		    0x008E
+#define  USBC_REG_o_RXINTERVAL	    0x008F
+
+#define  USBC_REG_o_CONFIGDATA		0x00c0   //
+
+#define  USBC_REG_o_EPFIFO0		    0x0000
+#define  USBC_REG_o_EPFIFO1		    0x0004
+#define  USBC_REG_o_EPFIFO2		    0x0008
+#define  USBC_REG_o_EPFIFO3		    0x000C
+#define  USBC_REG_o_EPFIFO4		    0x0010
+#define  USBC_REG_o_EPFIFO5		    0x0014
+#define  USBC_REG_o_EPFIFOx(n)	    (0x0000 + (n<<2))
+
+#define  USBC_REG_o_DEVCTL		    0x0041
+
+#define  USBC_REG_o_TXFIFOSZ	    0x0090
+#define  USBC_REG_o_RXFIFOSZ	    0x0094
+#define  USBC_REG_o_TXFIFOAD	    0x0092
+#define  USBC_REG_o_RXFIFOAD	    0x0096
+
+#define  USBC_REG_o_VEND0		    0x0043
+#define  USBC_REG_o_VEND1		    0x007D
+#define  USBC_REG_o_VEND3		    0x007E
+
+//#define  USBC_REG_o_PHYCTL		0x006C
+#define  USBC_REG_o_EPINFO		    0x0078
+#define  USBC_REG_o_RAMINFO		    0x0079
+#define  USBC_REG_o_LINKINFO	    0x007A
+#define  USBC_REG_o_VPLEN		    0x007B
+#define  USBC_REG_o_HSEOF		    0x007C
+#define  USBC_REG_o_FSEOF		    0x007D
+#define  USBC_REG_o_LSEOF		    0x007E
+
+//new
+#define  USBC_REG_o_FADDR0          0x0098
+#define  USBC_REG_o_HADDR0          0x009A
+#define  USBC_REG_o_HPORT0          0x009B
+#define  USBC_REG_o_TXFADDRx 		0x0098
+#define  USBC_REG_o_TXHADDRx		0x009A
+#define  USBC_REG_o_TXHPORTx		0x009B
+#define  USBC_REG_o_RXFADDRx		0x009C
+#define  USBC_REG_o_RXHADDRx		0x009E
+#define  USBC_REG_o_RXHPORTx		0x009F
+
+
+#define  USBC_REG_o_RPCOUNT			0x008A
+
+//new
+#define  USBC_REG_o_ISCR            0x0400
+#define  USBC_REG_o_PHYCTL          0x0404
+#define  USBC_REG_o_PHYBIST         0x0408
+#define  USBC_REG_o_PHYTUNE         0x040c
+
+
+//-----------------------------------------------------------------------
+//   registers
+//-----------------------------------------------------------------------
+
+#define  USBC_REG_FADDR(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_FADDR		)
+#define  USBC_REG_PCTL(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_PCTL			)
+#define  USBC_REG_INTTx(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_INTTx		)
+#define  USBC_REG_INTRx(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_INTRx		)
+#define  USBC_REG_INTTxE(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_INTTxE     	)
+#define  USBC_REG_INTRxE(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_INTRxE     	)
+#define  USBC_REG_INTUSB(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_INTUSB     	)
+#define  USBC_REG_INTUSBE(usbc_base_addr)           ((usbc_base_addr) + USBC_REG_o_INTUSBE    	)
+#define  USBC_REG_FRNUM(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_FRNUM      	)
+#define  USBC_REG_EPIND(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_EPIND      	)
+#define  USBC_REG_TMCTL(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_TMCTL      	)
+#define  USBC_REG_TXMAXP(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_TXMAXP     	)
+
+#define  USBC_REG_CSR0(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_CSR0       	)
+#define  USBC_REG_TXCSR(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_TXCSR      	)
+
+#define  USBC_REG_RXMAXP(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_RXMAXP     	)
+#define  USBC_REG_RXCSR(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_RXCSR      	)
+
+#define  USBC_REG_COUNT0(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_COUNT0     	)
+#define  USBC_REG_RXCOUNT(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_RXCOUNT    	)
+
+#define  USBC_REG_EP0TYPE(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_EP0TYPE		)
+#define  USBC_REG_TXTYPE(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_TXTYPE     	)
+
+#define  USBC_REG_NAKLIMIT0(usbc_base_addr)	        ((usbc_base_addr) + USBC_REG_o_NAKLIMIT0  	)
+#define  USBC_REG_TXINTERVAL(usbc_base_addr)        ((usbc_base_addr) + USBC_REG_o_TXINTERVAL	)
+
+#define  USBC_REG_RXTYPE(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_RXTYPE		)
+#define  USBC_REG_RXINTERVAL(usbc_base_addr)	    ((usbc_base_addr) + USBC_REG_o_RXINTERVAL	)
+#define  USBC_REG_CONFIGDATA(usbc_base_addr)	    ((usbc_base_addr) + USBC_REG_o_CONFIGDATA	)
+#define  USBC_REG_EPFIFO0(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_EPFIFO0		)
+#define  USBC_REG_EPFIFO1(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_EPFIFO1		)
+#define  USBC_REG_EPFIFO2(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_EPFIFO2		)
+#define  USBC_REG_EPFIFO3(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_EPFIFO3		)
+#define  USBC_REG_EPFIFO4(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_EPFIFO4		)
+#define  USBC_REG_EPFIFO5(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_EPFIFO5		)
+#define  USBC_REG_EPFIFOx(usbc_base_addr, n)	    ((usbc_base_addr) + USBC_REG_o_EPFIFOx(n)	)
+#define  USBC_REG_DEVCTL(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_DEVCTL		)
+#define  USBC_REG_TXFIFOSZ(usbc_base_addr)	        ((usbc_base_addr) + USBC_REG_o_TXFIFOSZ		)
+#define  USBC_REG_RXFIFOSZ(usbc_base_addr)	        ((usbc_base_addr) + USBC_REG_o_RXFIFOSZ		)
+#define  USBC_REG_TXFIFOAD(usbc_base_addr)	        ((usbc_base_addr) + USBC_REG_o_TXFIFOAD		)
+#define  USBC_REG_RXFIFOAD(usbc_base_addr)	        ((usbc_base_addr) + USBC_REG_o_RXFIFOAD		)
+#define  USBC_REG_VEND0(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_VEND0		)
+#define  USBC_REG_VEND1(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_VEND1		)
+#define  USBC_REG_EPINFO(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_EPINFO		)
+#define  USBC_REG_RAMINFO(usbc_base_addr)		    ((usbc_base_addr) + USBC_REG_o_RAMINFO		)
+#define  USBC_REG_LINKINFO(usbc_base_addr)	        ((usbc_base_addr) + USBC_REG_o_LINKINFO		)
+#define  USBC_REG_VPLEN(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_VPLEN		)
+#define  USBC_REG_HSEOF(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_HSEOF		)
+#define  USBC_REG_FSEOF(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_FSEOF		)
+#define  USBC_REG_LSEOF(usbc_base_addr)		        ((usbc_base_addr) + USBC_REG_o_LSEOF		)
+
+#define  USBC_REG_FADDR0(usbc_base_addr)            ((usbc_base_addr) + USBC_REG_o_FADDR0		)
+#define  USBC_REG_HADDR0(usbc_base_addr)            ((usbc_base_addr) + USBC_REG_o_HADDR0		)
+#define  USBC_REG_HPORT0(usbc_base_addr)            ((usbc_base_addr) + USBC_REG_o_HPORT0		)
+
+#define  USBC_REG_TXFADDRx(usbc_base_addr, n)		((usbc_base_addr) + USBC_REG_o_TXFADDRx		)
+#define  USBC_REG_TXHADDRx(usbc_base_addr, n)		((usbc_base_addr) + USBC_REG_o_TXHADDRx		)
+#define  USBC_REG_TXHPORTx(usbc_base_addr, n)		((usbc_base_addr) + USBC_REG_o_TXHPORTx		)
+#define  USBC_REG_RXFADDRx(usbc_base_addr, n)		((usbc_base_addr) + USBC_REG_o_RXFADDRx		)
+#define  USBC_REG_RXHADDRx(usbc_base_addr, n)		((usbc_base_addr) + USBC_REG_o_RXHADDRx		)
+#define  USBC_REG_RXHPORTx(usbc_base_addr, n)		((usbc_base_addr) + USBC_REG_o_RXHPORTx		)
+
+#define  USBC_REG_RPCOUNTx(usbc_base_addr, n)	    ((usbc_base_addr) + USBC_REG_o_RPCOUNT		)
+
+#define  USBC_REG_ISCR(usbc_base_addr)	    	    ((usbc_base_addr) + USBC_REG_o_ISCR			)
+#define  USBC_REG_PHYCTL(usbc_base_addr)	        ((usbc_base_addr) + USBC_REG_o_PHYCTL		)
+#define  USBC_REG_PHYBIST(usbc_base_addr)	        ((usbc_base_addr) + USBC_REG_o_PHYBIST		)
+#define  USBC_REG_PHYTUNE(usbc_base_addr)           ((usbc_base_addr) + USBC_REG_o_PHYTUNE		)
+
+//-----------------------------------------------------------------------
+//  registers extern
+//-----------------------------------------------------------------------
+#define  USBC_REG_EX_USB_EPFIFOn(usbc_base_addr)    ((usbc_base_addr) + (0x00 + (n << 2)))
+#define  USBC_REG_EX_USB_GCS(usbc_base_addr)        ((usbc_base_addr) + 0x0040)
+#define  USBC_REG_EX_USB_EPINTF(usbc_base_addr)     ((usbc_base_addr) + 0x0044)
+#define  USBC_REG_EX_USB_EPINTE(usbc_base_addr)     ((usbc_base_addr) + 0x0048)
+#define  USBC_REG_EX_USB_BUSINTF(usbc_base_addr)    ((usbc_base_addr) + 0x004C)
+#define  USBC_REG_EX_USB_BUSINTE(usbc_base_addr)    ((usbc_base_addr) + 0x0050)
+#define  USBC_REG_EX_USB_FNUM(usbc_base_addr)       ((usbc_base_addr) + 0x0054)
+#define  USBC_REG_EX_USB_TESTC(usbc_base_addr)      ((usbc_base_addr) + 0x007C)
+
+#define  USBC_REG_EX_USB_CSR0(usbc_base_addr)       ((usbc_base_addr) + 0x0080)
+#define  USBC_REG_EX_USB_TXCSR(usbc_base_addr)      ((usbc_base_addr) + 0x0080)
+#define  USBC_REG_EX_USB_RXCSR(usbc_base_addr)      ((usbc_base_addr) + 0x0084)
+#define  USBC_REG_EX_USB_COUNT0(usbc_base_addr)     ((usbc_base_addr) + 0x0088)
+#define  USBC_REG_EX_USB_RXCOUNT(usbc_base_addr)    ((usbc_base_addr) + 0x0088)
+#define  USBC_REG_EX_USB_ATTR0(usbc_base_addr)      ((usbc_base_addr) + 0x008C)
+#define  USBC_REG_EX_USB_EPATTR(usbc_base_addr)     ((usbc_base_addr) + 0x008C)
+#define  USBC_REG_EX_USB_TXFIFO(usbc_base_addr)     ((usbc_base_addr) + 0x0090)
+#define  USBC_REG_EX_USB_RXFIFO(usbc_base_addr)     ((usbc_base_addr) + 0x0094)
+#define  USBC_REG_EX_USB_FADDR(usbc_base_addr)      ((usbc_base_addr) + 0x0098)
+#define  USBC_REG_EX_USB_TXFADDR(usbc_base_addr)    ((usbc_base_addr) + 0x0098)
+#define  USBC_REG_EX_USB_RXFADDR(usbc_base_addr)    ((usbc_base_addr) + 0x009C)
+
+#define  USBC_REG_EX_USB_CONFIGINFO(usbc_base_addr) ((usbc_base_addr) + 0x00C0)
+#define  USBC_REG_EX_USB_LINKTIM(usbc_base_addr)    ((usbc_base_addr) + 0x00C4)
+#define  USBC_REG_EX_USB_OTGTIM(usbc_base_addr)     ((usbc_base_addr) + 0x00C8)
+
+#define  USBC_REG_EX_USB_ISCR(usbc_base_addr)       ((usbc_base_addr) + 0x0400)
+#define  USBC_REG_EX_USB_PHYCTL(usbc_base_addr)     ((usbc_base_addr) + 0x0404)
+#define  USBC_REG_EX_USB_PHYBIST(usbc_base_addr)    ((usbc_base_addr) + 0x0408)
+
+
+//-----------------------------------------------------------------------
+//   bit position
+//-----------------------------------------------------------------------
+
+/* USB Power Control for Host only  */
+#define  USBC_BP_POWER_H_HIGH_SPEED_EN			5
+#define  USBC_BP_POWER_H_HIGH_SPEED_FLAG		4
+#define  USBC_BP_POWER_H_RESET					3
+#define  USBC_BP_POWER_H_RESUME					2
+#define  USBC_BP_POWER_H_SUSPEND				1
+#define  USBC_BP_POWER_H_SUEPEND_EN				0
+
+/* USB Power Control for device only  */
+#define  USBC_BP_POWER_D_ISO_UPDATE_EN			7
+#define  USBC_BP_POWER_D_SOFT_CONNECT			6
+#define  USBC_BP_POWER_D_HIGH_SPEED_EN			5
+#define  USBC_BP_POWER_D_HIGH_SPEED_FLAG		4
+#define  USBC_BP_POWER_D_RESET_FLAG				3
+#define  USBC_BP_POWER_D_RESUME					2
+#define  USBC_BP_POWER_D_SUSPEND				1
+#define  USBC_BP_POWER_D_ENABLE_SUSPENDM		0
+
+/* interrupt flags for ep0 and the Tx ep1~4 */
+#define  USBC_BP_INTTx_FLAG_EP5				    5
+#define  USBC_BP_INTTx_FLAG_EP4				    4
+#define  USBC_BP_INTTx_FLAG_EP3				    3
+#define  USBC_BP_INTTx_FLAG_EP2		    		2
+#define  USBC_BP_INTTx_FLAG_EP1  				1
+#define  USBC_BP_INTTx_FLAG_EP0					0
+
+/* interrupt flags for Rx ep1~4 */
+#define  USBC_BP_INTRx_FLAG_EP5				    5
+#define  USBC_BP_INTRx_FLAG_EP4				    4
+#define  USBC_BP_INTRx_FLAG_EP3				    3
+#define  USBC_BP_INTRx_FLAG_EP2				    2
+#define  USBC_BP_INTRx_FLAG_EP1				    1
+
+/* interrupt enable for Tx ep0~4 */
+#define  USBC_BP_INTTxE_EN_EP5				    5
+#define  USBC_BP_INTTxE_EN_EP4				    4
+#define  USBC_BP_INTTxE_EN_EP3				    3
+#define  USBC_BP_INTTxE_EN_EP2				    2
+#define  USBC_BP_INTTxE_EN_EP1				    1
+#define  USBC_BP_INTTxE_EN_EP0					0
+
+/* interrupt enable for Rx ep1~4 */
+#define  USBC_BP_INTRxE_EN_EP5				    5
+#define  USBC_BP_INTRxE_EN_EP4				    4
+#define  USBC_BP_INTRxE_EN_EP3				    3
+#define  USBC_BP_INTRxE_EN_EP2			    	2
+#define  USBC_BP_INTRxE_EN_EP1  		    	1
+
+/* USB interrupt */
+#define  USBC_BP_INTUSB_VBUS_ERROR				7
+#define  USBC_BP_INTUSB_SESSION_REQ				6
+#define  USBC_BP_INTUSB_DISCONNECT				5
+#define  USBC_BP_INTUSB_CONNECT					4
+#define  USBC_BP_INTUSB_SOF						3
+#define  USBC_BP_INTUSB_RESET					2
+#define  USBC_BP_INTUSB_RESUME					1
+#define  USBC_BP_INTUSB_SUSPEND					0
+
+/* USB interrupt enable */
+#define  USBC_BP_INTUSBE_EN_VBUS_ERROR			7
+#define  USBC_BP_INTUSBE_EN_SESSION_REQ			6
+#define  USBC_BP_INTUSBE_EN_DISCONNECT			5
+#define  USBC_BP_INTUSBE_EN_CONNECT				4
+#define  USBC_BP_INTUSBE_EN_SOF					3
+#define  USBC_BP_INTUSBE_EN_RESET				2
+#define  USBC_BP_INTUSBE_EN_RESUME				1
+#define  USBC_BP_INTUSBE_EN_SUSPEND				0
+
+/* Test Mode Control */
+#define  USBC_BP_TMCTL_FORCE_HOST               7
+#define  USBC_BP_TMCTL_FIFO_ACCESS              6
+#define  USBC_BP_TMCTL_FORCE_FS                 5
+#define  USBC_BP_TMCTL_FORCE_HS                 4
+#define  USBC_BP_TMCTL_TEST_PACKET              3
+#define  USBC_BP_TMCTL_TEST_K                   2
+#define  USBC_BP_TMCTL_TEST_J                   1
+#define  USBC_BP_TMCTL_TEST_SE0_NAK             0
+
+/* Tx Max packet */
+#define  USBC_BP_TXMAXP_PACKET_COUNT            11
+#define  USBC_BP_TXMAXP_MAXIMUM_PAYLOAD         0
+
+/* Control and Status Register for ep0 for Host only */
+#define  USBC_BP_CSR0_H_DisPing 				11
+#define  USBC_BP_CSR0_H_FlushFIFO				8
+#define  USBC_BP_CSR0_H_NAK_Timeout				7
+#define  USBC_BP_CSR0_H_StatusPkt				6
+#define  USBC_BP_CSR0_H_ReqPkt					5
+#define  USBC_BP_CSR0_H_Error					4
+#define  USBC_BP_CSR0_H_SetupPkt				3
+#define  USBC_BP_CSR0_H_RxStall					2
+#define  USBC_BP_CSR0_H_TxPkRdy					1
+#define  USBC_BP_CSR0_H_RxPkRdy					0
+
+/* Control and Status Register for ep0 for device only */
+#define  USBC_BP_CSR0_D_FLUSH_FIFO				8
+#define  USBC_BP_CSR0_D_SERVICED_SETUP_END		7
+#define  USBC_BP_CSR0_D_SERVICED_RX_PKT_READY   6
+#define  USBC_BP_CSR0_D_SEND_STALL				5
+#define  USBC_BP_CSR0_D_SETUP_END				4
+#define  USBC_BP_CSR0_D_DATA_END				3
+#define  USBC_BP_CSR0_D_SENT_STALL				2
+#define  USBC_BP_CSR0_D_TX_PKT_READY			1
+#define  USBC_BP_CSR0_D_RX_PKT_READY			0
+
+/* Tx ep Control and Status Register for Host only */
+#define  USBC_BP_TXCSR_H_AUTOSET				15
+#define  USBC_BP_TXCSR_H_RESERVED				14
+#define  USBC_BP_TXCSR_H_MODE				    13
+#define  USBC_BP_TXCSR_H_DMA_REQ_EN			 	12
+#define  USBC_BP_TXCSR_H_FORCE_DATA_TOGGLE		11
+#define  USBC_BP_TXCSR_H_DMA_REQ_MODE			10
+#define  USBC_BP_TXCSR_H_DATA_TOGGLE_WR_EN      9
+#define  USBC_BP_TXCSR_H_DATA_TOGGLE            8
+#define  USBC_BP_TXCSR_H_NAK_TIMEOUT			7
+#define  USBC_BP_TXCSR_H_CLEAR_DATA_TOGGLE		6
+#define  USBC_BP_TXCSR_H_TX_STALL				5
+#define  USBC_BP_TXCSR_H_FLUSH_FIFO				3
+#define  USBC_BP_TXCSR_H_ERROR					2
+#define  USBC_BP_TXCSR_H_FIFO_NOT_EMPTY 		1
+#define  USBC_BP_TXCSR_H_TX_READY				0
+
+#define  USBC_TXCSR_H_WZC_BITS                  ((1 << USBC_BP_TXCSR_H_NAK_TIMEOUT) | (1 << USBC_BP_TXCSR_H_TX_STALL) \
+                                                | (1 << USBC_BP_TXCSR_H_ERROR) | (1 << USBC_BP_TXCSR_H_FIFO_NOT_EMPTY))
+
+/* Tx ep Control and Status Register for Device only */
+#define  USBC_BP_TXCSR_D_AUTOSET				15
+#define  USBC_BP_TXCSR_D_ISO					14
+#define  USBC_BP_TXCSR_D_MODE					13
+#define  USBC_BP_TXCSR_D_DMA_REQ_EN				12
+#define  USBC_BP_TXCSR_D_FORCE_DATA_TOGGLE		11
+#define  USBC_BP_TXCSR_D_DMA_REQ_MODE			10
+#define  USBC_BP_TXCSR_D_INCOMPLETE				7
+#define  USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE		6
+#define  USBC_BP_TXCSR_D_SENT_STALL				5
+#define  USBC_BP_TXCSR_D_SEND_STALL				4
+#define  USBC_BP_TXCSR_D_FLUSH_FIFO				3
+#define  USBC_BP_TXCSR_D_UNDER_RUN				2
+#define  USBC_BP_TXCSR_D_FIFO_NOT_EMPTY 		1
+#define  USBC_BP_TXCSR_D_TX_READY				0
+
+/* Rx Max Packet */
+#define  USBC_BP_RXMAXP_PACKET_COUNT            11
+#define  USBC_BP_RXMAXP_MAXIMUM_PAYLOAD         0
+
+/* Rx ep Control and Status Register for Host only */
+#define  USBC_BP_RXCSR_H_AUTO_CLEAR			    15
+#define  USBC_BP_RXCSR_H_AUTO_REQ			    14
+#define  USBC_BP_RXCSR_H_DMA_REQ_EN			    13
+#define  USBC_BP_RXCSR_H_DISNYET                12  /* dis nyet */
+#define  USBC_BP_RXCSR_H_PID_ERROR			    12  /* pid error */
+#define  USBC_BP_RXCSR_H_DMA_REQ_MODE		    11
+#define  USBC_BP_RXCSR_H_DATA_TOGGLE_WR_EN      10
+#define  USBC_BP_RXCSR_H_DATA_TOGGLE            9
+#define  USBC_BP_RXCSR_H_INCOMPLETE			    8
+#define  USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE	    7
+#define  USBC_BP_RXCSR_H_RX_STALL			    6
+#define  USBC_BP_RXCSR_H_REQ_PACKET			    5
+#define  USBC_BP_RXCSR_H_FLUSH_FIFO			    4
+#define  USBC_BP_RXCSR_H_DATA_ERR               3   /* iso */
+#define  USBC_BP_RXCSR_H_NAK_TIMEOUT		    3   /* bulk */
+#define  USBC_BP_RXCSR_H_ERROR				    2
+#define  USBC_BP_RXCSR_H_FIFO_FULL			    1
+#define  USBC_BP_RXCSR_H_RX_PKT_READY		    0
+
+#define  USBC_RXCSR_H_WZC_BITS                  ((1 << USBC_BP_RXCSR_H_RX_STALL) | (1 << USBC_BP_RXCSR_H_ERROR) \
+                                                | (1 << USBC_BP_RXCSR_H_DATA_ERR) | (1 << USBC_BP_RXCSR_H_RX_PKT_READY))
+
+/* Rx ep Control and Status Register for Device only */
+#define  USBC_BP_RXCSR_D_AUTO_CLEAR			    15
+#define  USBC_BP_RXCSR_D_ISO				    14
+#define  USBC_BP_RXCSR_D_DMA_REQ_EN			    13
+#define  USBC_BP_RXCSR_D_DISABLE_NYET		    12
+#define  USBC_BP_RXCSR_D_DMA_REQ_MODE		    11
+
+#define  USBC_BP_RXCSR_D_INCOMPLETE			    8
+#define  USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE	    7
+#define  USBC_BP_RXCSR_D_SENT_STALL			    6
+#define  USBC_BP_RXCSR_D_SEND_STALL			    5
+#define  USBC_BP_RXCSR_D_FLUSH_FIFO			    4
+#define  USBC_BP_RXCSR_D_DATA_ERROR			    3
+#define  USBC_BP_RXCSR_D_OVERRUN			    2
+#define  USBC_BP_RXCSR_D_FIFO_FULL			    1
+#define  USBC_BP_RXCSR_D_RX_PKT_READY		    0
+
+/* Tx Type Register for host only */
+#define  USBC_BP_TXTYPE_SPEED	                6              //new
+#define  USBC_BP_TXTYPE_PROROCOL	            4
+#define  USBC_BP_TXTYPE_TARGET_EP_NUM           0
+
+/* Rx Type Register for host only */
+#define  USBC_BP_RXTYPE_SPEED		            6              //new
+#define  USBC_BP_RXTYPE_PROROCOL	            4
+#define  USBC_BP_RXTYPE_TARGET_EP_NUM           0
+
+/* Core Configueation */
+#define  USBC_BP_CONFIGDATA_MPRXE               7
+#define  USBC_BP_CONFIGDATA_MPTXE               6
+#define  USBC_BP_CONFIGDATA_BIGENDIAN		    5
+#define  USBC_BP_CONFIGDATA_HBRXE			    4
+#define  USBC_BP_CONFIGDATA_HBTXE			    3
+#define  USBC_BP_CONFIGDATA_DYNFIFO_SIZING	    2
+#define  USBC_BP_CONFIGDATA_SOFTCONE		    1
+#define  USBC_BP_CONFIGDATA_UTMI_DATAWIDTH	    0
+
+/* OTG Device Control */
+#define  USBC_BP_DEVCTL_B_DEVICE			    7
+#define  USBC_BP_DEVCTL_FS_DEV				    6
+#define  USBC_BP_DEVCTL_LS_DEV				    5
+
+#define  USBC_BP_DEVCTL_VBUS				    3
+#define  USBC_BP_DEVCTL_HOST_MODE			    2
+#define  USBC_BP_DEVCTL_HOST_REQ			    1
+#define  USBC_BP_DEVCTL_SESSION				    0
+
+/* Tx EP FIFO size control */
+#define  USBC_BP_TXFIFOSZ_DPB				    4
+#define  USBC_BP_TXFIFOSZ_SZ				    0
+
+/* Rx EP FIFO size control */
+#define  USBC_BP_RXFIFOSZ_DPB				    4
+#define  USBC_BP_RXFIFOSZ_SZ				    0
+
+/* vendor0 */
+#define  USBC_BP_VEND0_DRQ_SEL				    1
+#define  USBC_BP_VEND0_BUS_SEL				    0
+
+/* hub address */
+#define  USBC_BP_HADDR_MULTI_TT					7
+
+/* Interface Status and Control */
+#define  USBC_BP_ISCR_VBUS_VALID_FROM_DATA		30
+#define  USBC_BP_ISCR_VBUS_VALID_FROM_VBUS		29
+#define  USBC_BP_ISCR_EXT_ID_STATUS				28
+#define  USBC_BP_ISCR_EXT_DM_STATUS				27
+#define  USBC_BP_ISCR_EXT_DP_STATUS				26
+#define  USBC_BP_ISCR_MERGED_VBUS_STATUS		25
+#define  USBC_BP_ISCR_MERGED_ID_STATUS			24
+
+#define  USBC_BP_ISCR_ID_PULLUP_EN				17
+#define  USBC_BP_ISCR_DPDM_PULLUP_EN			16
+#define  USBC_BP_ISCR_FORCE_ID					14
+#define  USBC_BP_ISCR_FORCE_VBUS_VALID			12
+#define  USBC_BP_ISCR_VBUS_VALID_SRC			10
+
+#define  USBC_BP_ISCR_HOSC_EN                 	7
+#define  USBC_BP_ISCR_VBUS_CHANGE_DETECT      	6
+#define  USBC_BP_ISCR_ID_CHANGE_DETECT        	5
+#define  USBC_BP_ISCR_DPDM_CHANGE_DETECT      	4
+#define  USBC_BP_ISCR_IRQ_ENABLE              	3
+#define  USBC_BP_ISCR_VBUS_CHANGE_DETECT_EN   	2
+#define  USBC_BP_ISCR_ID_CHANGE_DETECT_EN     	1
+#define  USBC_BP_ISCR_DPDM_CHANGE_DETECT_EN   	0
+
+//-----------------------------------------------------------------------
+//   
+//-----------------------------------------------------------------------
+
+/* usb */
+#define  USBC_MAX_CTL_NUM		1
+#define  USBC_MAX_EP_NUM      	6   	/* ep, ep0~5 */
+#define  USBC0_MAX_FIFO_SIZE   	(8 * 1024)
+#define  USBC_EP0_FIFOSIZE	  	64	/* This is non-configurable */
+
+/* usb OTG mode */
+#define  USBC_OTG_HOST        0
+#define  USBC_OTG_DEVICE      1
+
+/* usb device type */
+#define  USBC_DEVICE_HSDEV    0
+#define  USBC_DEVICE_FSDEV    1
+#define  USBC_DEVICE_LSDEV    2
+
+/*  usb transfer type  */
+#define  USBC_TS_TYPE_IDLE    0
+#define  USBC_TS_TYPE_CTRL    1
+#define  USBC_TS_TYPE_ISO     2
+#define  USBC_TS_TYPE_INT     3
+#define  USBC_TS_TYPE_BULK    4
+
+/*  usb transfer mode  */
+#define  USBC_TS_MODE_UNKOWN  0
+#define  USBC_TS_MODE_LS      1
+#define  USBC_TS_MODE_FS      2
+#define  USBC_TS_MODE_HS      3
+
+/* usb Vbus status */
+#define  USBC_VBUS_STATUS_BELOW_SESSIONEND                 0
+#define  USBC_VBUS_STATUS_ABOVE_SESSIONEND_BELOW_AVALID    1
+#define  USBC_VBUS_STATUS_ABOVE_AVALID_BELOW_VBUSVALID     2
+#define  USBC_VBUS_STATUS_ABOVE_VBUSVALID                  3
+
+/* usb io type */
+#define  USBC_IO_TYPE_PIO    		0
+#define  USBC_IO_TYPE_DMA    		1
+
+/* usb ep type */
+#define  USBC_EP_TYPE_IDLE    		0
+#define  USBC_EP_TYPE_EP0    		1
+#define  USBC_EP_TYPE_TX     		2
+#define  USBC_EP_TYPE_RX     		3
+
+/* usb id type */
+#define  USBC_ID_TYPE_DISABLE      	0
+#define  USBC_ID_TYPE_HOST         	1
+#define  USBC_ID_TYPE_DEVICE       	2
+
+/* usb vbus valid type */
+#define  USBC_VBUS_TYPE_DISABLE    	0
+#define  USBC_VBUS_TYPE_LOW       	1
+#define  USBC_VBUS_TYPE_HIGH       	2
+
+/* usb a valid source */
+#define  USBC_A_VALID_SOURCE_UTMI_AVALID	0
+#define  USBC_A_VALID_SOURCE_UTMI_VBUS    	1
+
+/* usb device switch */
+#define  USBC_DEVICE_SWITCH_OFF    0
+#define  USBC_DEVICE_SWITCH_ON     1
+
+/* usb fifo config mode */
+#define  USBC_FIFO_MODE_4K    0
+#define  USBC_FIFO_MODE_8K    1
+
+/*
+ **************************************************
+ *  usb interrupt mask
+ *
+ **************************************************
+ */
+
+/* interrupt flags for ep0 and the Tx ep1~4 */
+#define  USBC_INTTx_FLAG_EP5				    (1 << USBC_BP_INTTx_FLAG_EP5)
+#define  USBC_INTTx_FLAG_EP4				    (1 << USBC_BP_INTTx_FLAG_EP4)
+#define  USBC_INTTx_FLAG_EP3				    (1 << USBC_BP_INTTx_FLAG_EP3)
+#define  USBC_INTTx_FLAG_EP2		    		(1 << USBC_BP_INTTx_FLAG_EP2)
+#define  USBC_INTTx_FLAG_EP1  				    (1 << USBC_BP_INTTx_FLAG_EP1)
+#define  USBC_INTTx_FLAG_EP0					(1 << USBC_BP_INTTx_FLAG_EP0)
+
+/* interrupt flags for Rx ep1~4 */
+#define  USBC_INTRx_FLAG_EP5				    (1 << USBC_BP_INTRx_FLAG_EP5)
+#define  USBC_INTRx_FLAG_EP4				    (1 << USBC_BP_INTRx_FLAG_EP4)
+#define  USBC_INTRx_FLAG_EP3				    (1 << USBC_BP_INTRx_FLAG_EP3)
+#define  USBC_INTRx_FLAG_EP2				    (1 << USBC_BP_INTRx_FLAG_EP2)
+#define  USBC_INTRx_FLAG_EP1				    (1 << USBC_BP_INTRx_FLAG_EP1)
+
+/* USB interrupt */
+#define  USBC_INTUSB_VBUS_ERROR				    (1 << USBC_BP_INTUSB_VBUS_ERROR)
+#define  USBC_INTUSB_SESSION_REQ				(1 << USBC_BP_INTUSB_SESSION_REQ)
+#define  USBC_INTUSB_DISCONNECT				    (1 << USBC_BP_INTUSB_DISCONNECT)
+#define  USBC_INTUSB_CONNECT					(1 << USBC_BP_INTUSB_CONNECT)
+#define  USBC_INTUSB_SOF						(1 << USBC_BP_INTUSB_SOF)
+#define  USBC_INTUSB_RESET					    (1 << USBC_BP_INTUSB_RESET)
+#define  USBC_INTUSB_RESUME					    (1 << USBC_BP_INTUSB_RESUME)
+#define  USBC_INTUSB_SUSPEND					(1 << USBC_BP_INTUSB_SUSPEND)
+
+
+//-----------------------------------------------------------------------
+//   USB host 
+//-----------------------------------------------------------------------
+void USBC_Host_SetFunctionAddress_Deafult(__hdle hUSB, __u32 ep_type, __u32 ep_index);
+void USBC_Host_SetFunctionAddress(__hdle hUSB,
+								  __u32 EpType,
+								  __u32 EpIndex,
+								  __u32 FunctionAdress,
+								  __u32 MultiTT,
+								  __u32 HubAddress,
+								  __u32 HubPortNumber);
+void USBC_Host_SetHubAddress_Deafult(__hdle hUSB, __u32 ep_type, __u32 ep_index);
+void USBC_Host_SetHubAddress(__hdle hUSB, __u32 ep_type, __u32 ep_index, __u32 is_mutli_tt, __u8 address);
+void USBC_Host_SetHPortAddress_Deafult(__hdle hUSB, __u32 ep_type, __u32 ep_index);
+void USBC_Host_SetHPortAddress(__hdle hUSB, __u32 ep_type, __u32 ep_index, __u8 address);
+
+__u32 USBC_Host_QueryTransferMode(__hdle hUSB);
+void USBC_Host_ConfigTransferMode(__hdle hUSB, __u32 speed_mode);
+
+void USBC_Host_ResetPort(__hdle hUSB);
+void USBC_Host_ClearResetPortFlag(__hdle hUSB);
+void USBC_Host_RusumePort(__hdle hUSB);
+void USBC_Host_ClearRusumePortFlag(__hdle hUSB);
+void USBC_Host_SuspendPort(__hdle hUSB);
+__u32 USBC_Host_QueryPowerStatus(__hdle hUSB);
+
+void USBC_Host_EnablePing(__hdle hUSB);
+void USBC_Host_DisablePing(__hdle hUSB);
+__u32 USBC_Host_IsReqPktSet(__hdle hUSB, __u32 ep_type);
+void USBC_Host_StartInToken(__hdle hUSB, __u32 ep_type);
+void USBC_Host_StopInToken(__hdle hUSB, __u32 ep_type);
+void USBC_Host_SendCtrlStatus(__hdle hUSB, __u32 is_after_in);
+void USBC_Host_SendSetupPkt(__hdle hUSB);
+
+void USBC_Host_StartSession(__hdle hUSB);
+void USBC_Host_EndSession(__hdle hUSB);
+void USBC_Host_ConfigRqPktCount(__hdle hUSB, __u32 ep_index, __u32 RqPktCount);
+void USBC_Host_ClearRqPktCount(__hdle hUSB, __u32 ep_index);
+
+__u32 USBC_Host_PeripheralType(__hdle hUSB);
+
+void USBC_Host_FlushFifo(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ConfigEp_Default(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ConfigEp(__hdle hUSB, __u32 ep_type, __u32 ep_index, __u32 ts_mode, __u32 ts_type, __u32 is_double_fifo, __u32 ep_MaxPkt, __u32 interval);
+void USBC_Host_ConfigEpDma(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpDma(__hdle hUSB, __u32 ep_type);
+
+__u32 USBC_Host_IsEpStall(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpStall(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Host_IsEpNakTimeOut(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpNakTimeOut(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Host_IsEpError(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpError(__hdle hUSB, __u32 ep_type);
+void USBC_Host_ClearEpCSR(__hdle hUSB, __u32 ep_type);
+
+__u32 USBC_Host_IsReadDataReady(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Host_IsWriteDataReady(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Host_ReadDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete);
+__s32 USBC_Host_WriteDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete);
+
+
+//-----------------------------------------------------------------------
+//   USB device 
+//-----------------------------------------------------------------------
+void USBC_Dev_SetAddress_default(__hdle hUSB);
+void USBC_Dev_SetAddress(__hdle hUSB, __u8 address);
+
+__u32 USBC_Dev_QueryTransferMode(__hdle hUSB);
+void USBC_Dev_ConfigTransferMode(__hdle hUSB, __u8 ts_type, __u8 speed_mode);
+void USBC_Dev_ConectSwitch(__hdle hUSB, __u32 is_on);
+__u32 USBC_Dev_QueryPowerStatus(__hdle hUSB);
+
+__s32 USBC_Dev_ConfigEp(__hdle hUSB, __u32 ts_type, __u32 ep_type, __u32 is_double_fifo, __u32 ep_MaxPkt);
+__s32 USBC_Dev_ConfigEp_Default(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_ConfigEpDma(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_ClearEpDma(__hdle hUSB, __u32 ep_type);
+
+__s32 USBC_Dev_IsEpStall(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_EpSendStall(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_EpClearStall(__hdle hUSB, __u32 ep_type);
+
+__u32 USBC_Dev_Ctrl_IsSetupEnd(__hdle hUSB);
+void USBC_Dev_Ctrl_ClearSetupEnd(__hdle hUSB);
+
+__u32 USBC_Dev_IsReadDataReady(__hdle hUSB, __u32 ep_type);
+__u32 USBC_Dev_IsWriteDataReady(__hdle hUSB, __u32 ep_type);
+__s32 USBC_Dev_WriteDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete);
+__s32 USBC_Dev_ReadDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete);
+
+
+//-----------------------------------------------------------------------
+//   USB 
+//-----------------------------------------------------------------------
+
+/* USB,  */
+void USBC_OTG_SelectMode(__hdle hUSB, __u32 mode);
+
+__u32 USBC_ReadLenFromFifo(__hdle hUSB, __u32 ep_type);
+__u32 USBC_WritePacket(__hdle hUSB, __u32 fifo, __u32 cnt, void *buff);
+__u32 USBC_ReadPacket(__hdle hUSB, __u32 fifo, __u32 cnt, void *buff);
+
+void USBC_ConfigFIFO_Base(__hdle hUSB, __u32 sram_base, __u32 fifo_mode);
+__u32 USBC_GetPortFifoStartAddr(__hdle hUSB);
+__u32 USBC_GetPortFifoSize(__hdle hUSB);
+__u32 USBC_SelectFIFO(__hdle hUSB, __u32 ep_index);
+void USBC_ConfigFifo_Default(__hdle hUSB, __u32 ep_type);
+void USBC_ConfigFifo(__hdle hUSB, __u32 ep_type, __u32 is_double_fifo, __u32 fifo_size, __u32 fifo_addr);
+
+void USBC_SelectBus(__hdle hUSB, __u32 io_type, __u32 ep_type, __u32 ep_index);
+
+__u32 USBC_GetActiveEp(__hdle hUSB);
+void USBC_SelectActiveEp(__hdle hUSB, __u8 ep_index);
+
+void USBC_EnhanceSignal(__hdle hUSB);
+
+__u32 USBC_GetLastFrameNumber(__hdle hUSB);
+
+
+/* usb  */
+__u32 USBC_INT_EpPending(__hdle hUSB, __u32 ep_type);
+__u32 USBC_INT_MiscPending(__hdle hUSB);
+void USBC_INT_ClearEpPending(__hdle hUSB, __u32 ep_type, __u8 ep_index);
+void USBC_INT_ClearMiscPending(__hdle hUSB, __u32 mask);
+void USBC_INT_ClearEpPendingAll(__hdle hUSB, __u32 ep_type);
+void USBC_INT_ClearMiscPendingAll(__hdle hUSB);
+
+void USBC_INT_EnableEp(__hdle hUSB, __u32 ep_type, __u8 ep_index);
+void USBC_INT_EnableUsbMiscUint(__hdle hUSB, __u32 mask);
+
+void USBC_INT_DisableEp(__hdle hUSB, __u32 ep_type, __u8 ep_index);
+void USBC_INT_DisableUsbMiscUint(__hdle hUSB, __u32 mask);
+
+void USBC_INT_DisableEpAll(__hdle hUSB, __u32 ep_type);
+void USBC_INT_DisableUsbMiscAll(__hdle hUSB);
+
+
+/* usb  */
+__u32 USBC_GetVbusStatus(__hdle hUSB);
+__u32 USBC_GetStatus_Dp(__hdle hUSB);
+__u32 USBC_GetStatus_Dm(__hdle hUSB);
+__u32 USBC_GetStatus_DpDm(__hdle hUSB);
+
+__u32 USBC_GetOtgMode_Form_ID(__hdle hUSB);
+__u32 USBC_GetOtgMode_Form_BDevice(__hdle hUSB);
+
+void USBC_SetWakeUp_Default(__hdle hUSB);
+
+void USBC_EnableIdPullUp(__hdle hUSB);
+void USBC_DisableIdPullUp(__hdle hUSB);
+void USBC_EnableDpDmPullUp(__hdle hUSB);
+void USBC_DisableDpDmPullUp(__hdle hUSB);
+
+void USBC_ForceId(__hdle hUSB, __u32 id_type);
+void USBC_ForceVbusValid(__hdle hUSB, __u32 vbus_type);
+
+void USBC_A_valid_InputSelect(__hdle hUSB, __u32 source);
+
+void USBC_EnableUsbLineStateBypass(__hdle hUSB);
+void USBC_DisableUsbLineStateBypass(__hdle hUSB);
+void USBC_EnableHosc(__hdle hUSB);
+void USBC_DisableHosc(__hdle hUSB);
+
+__u32 USBC_IsVbusChange(__hdle hUSB);
+__u32 USBC_IsIdChange(__hdle hUSB);
+__u32 USBC_IsDpDmChange(__hdle hUSB);
+
+void USBC_DisableWakeIrq(__hdle hUSB);
+void USBC_DisableVbusChange(__hdle hUSB);
+void USBC_DisableIdChange(__hdle hUSB);
+void USBC_DisableDpDmChange(__hdle hUSB);
+
+void USBC_EnableWakeIrq(__hdle hUSB);
+void USBC_EnableVbusChange(__hdle hUSB);
+void USBC_EnableIdChange(__hdle hUSB);
+void USBC_EnableDpDmChange(__hdle hUSB);
+
+/* usb phy control*/
+void USBC_PHY_SetCommonConfig(void);
+void USBC_PHY_SetPrivateConfig(__hdle hUSB);
+__u32 USBC_PHY_GetCommonConfig(void);
+void USBC_phy_Standby(__hdle hUSB, __u32 phy_index);
+void USBC_Phy_Standby_Recover(__hdle hUSB, __u32 phy_index);
+void UsbPhyInit(__u32 usbc_no);
+void UsbPhyEndReset(__u32 usbc_no);
+
+/* usb  */
+void USBC_EnterMode_TestPacket(__hdle hUSB);
+void USBC_EnterMode_Test_K(__hdle hUSB);
+void USBC_EnterMode_Test_J(__hdle hUSB);
+void USBC_EnterMode_Test_SE0_NAK(__hdle hUSB);
+void USBC_EnterMode_Idle(__hdle hUSB);
+
+__u32 USBC_TestMode_ReadReg(__hdle hUSB, __u32 offset, __u32 reg_width);
+
+void USBC_SwitchPhyToOtg(__hdle hUSB, u32 sram_addr);
+void USBC_SetUSBRegIdle(__hdle hUSB);
+
+//---------------------------------------------------------------
+//  bsp
+//---------------------------------------------------------------
+/*  */
+typedef struct tag_usbc_info{
+    __u32 num;      /*  */
+    __u32 base;     /*  */
+}usbc_info_t;
+
+typedef struct tag_bsp_usbc{
+    usbc_info_t usbc_info[USBC_MAX_CTL_NUM];
+    __u32 sram_base;
+}bsp_usbc_t;
+
+/*  */
+__hdle USBC_open_otg(__u32 otg_no);
+__s32  USBC_close_otg(__hdle hUSB);
+
+/*  */
+__s32 USBC_init(bsp_usbc_t *usbc);
+__s32 USBC_exit(bsp_usbc_t *usbc);
+
+
+#endif   //__SUNXI_USB_BSP_H__
+
diff --git a/drivers/usb/sunxi_usb/include/sw_hcd.h b/drivers/usb/sunxi_usb/include/sw_hcd.h
new file mode 100644
index 0000000..c1d2c5f
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sw_hcd.h
@@ -0,0 +1,115 @@
+/*
+ * drivers/usb/sunxi_usb/include/sw_hcd.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_HCD_H__
+#define  __SW_HCD_H__
+
+/* The USB role is defined by the connector used on the board, so long as
+ * standards are being followed.  (Developer boards sometimes won't.)
+ */
+enum sw_hcd_mode {
+	SW_HCD_UNDEFINED = 0,
+	SW_HCD_HOST,		/* A or Mini-A connector */
+	SW_HCD_PERIPHERAL,	/* B or Mini-B connector */
+	SW_HCD_OTG		    /* Mini-AB connector */
+};
+
+struct clk;
+
+typedef struct sw_hcd_eps_bits {
+	const char	name[16];
+	u8		bits;
+}sw_hcd_eps_bits_t;
+
+typedef struct sw_hcd_config {
+	/* sw_hcd configuration-specific details */
+	unsigned	multipoint:1;	/* multipoint device */
+	unsigned	dyn_fifo:1;	    /* supports dynamic fifo sizing */
+	unsigned	soft_con:1;	    /* soft connect required */
+	unsigned	utm_16:1;	    /* utm data witdh is 16 bits */
+	unsigned	big_endian:1;	/* true if CPU uses big-endian */
+	unsigned	mult_bulk_tx:1;	/* Tx ep required for multbulk pkts */
+	unsigned	mult_bulk_rx:1;	/* Rx ep required for multbulk pkts */
+	unsigned	high_iso_tx:1;	/* Tx ep required for HB iso */
+	unsigned	high_iso_rx:1;	/* Rx ep required for HD iso */
+	unsigned	dma:1;		    /* supports DMA */
+	unsigned	vendor_req:1;	/* vendor registers required */
+
+	u8		num_eps;	    /* number of endpoints _with_ ep0 */
+	u8		dma_channels;	/* number of dma channels */
+	u8		dyn_fifo_size;	/* dynamic size in bytes */
+	u8		vendor_ctrl;	/* vendor control reg width */
+	u8		vendor_stat;	/* vendor status reg witdh */
+	u8		dma_req_chan;	/* bitmask for required dma channels */
+	u32		ram_size;	    /* ram address size */
+
+	struct sw_hcd_eps_bits *eps_bits;
+	struct usb_port_info *port_info;
+}sw_hcd_config_t;
+
+typedef struct sw_hcd_platform_data {
+	u32 usbc_base;
+
+	/* sw_USB_HOST, SW_USB_PERIPHERAL, or SW_USB_OTG */
+	u8		mode;
+
+	/* (HOST or OTG) switch VBUS on/off */
+	int		(*set_vbus)(struct device *dev, int is_on);
+
+	/* (HOST or OTG) mA/2 power supplied on (default = 8mA) */
+	u8		power;
+
+	/* (PERIPHERAL) mA/2 max power consumed (default = 100mA) */
+	u8		min_power;
+
+	/* (HOST or OTG) msec/2 after VBUS on till power good */
+	u8		potpgt;
+
+	/* Power the device on or off */
+	int		(*set_power)(int state);
+
+	/* Turn device clock on or off */
+	int		(*set_clock)(struct clk *clock, int is_on);
+
+	/* sw_hcd configuration-specific details */
+	struct sw_hcd_config	*config;
+}sw_hcd_platform_data_t;
+
+
+
+int sw_usb_host0_enable(void);
+int sw_usb_host0_disable(void);
+
+int sw_usb_disable_hcd0(void);
+int sw_usb_enable_hcd0(void);
+
+int sw_usb_disable_hcd1(void);
+int sw_usb_enable_hcd1(void);
+
+int sw_usb_disable_hcd2(void);
+int sw_usb_enable_hcd2(void);
+
+void set_hcd0_connect_status(int status);
+
+#endif   //__SW_HCD_H__
+
diff --git a/drivers/usb/sunxi_usb/include/sw_udc.h b/drivers/usb/sunxi_usb/include/sw_udc.h
new file mode 100644
index 0000000..05fc5b7
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sw_udc.h
@@ -0,0 +1,214 @@
+/*
+ * drivers/usb/sunxi_usb/include/sw_udc.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_UDC_H__
+#define  __SW_UDC_H__
+
+#include <linux/usb.h>
+#include <linux/usb/gadget.h>
+
+#ifdef SW_UDC_DMA
+#include <plat/dma.h>
+#include <linux/dma-mapping.h>
+#endif
+
+/*  */
+typedef struct sw_udc_ep {
+	struct list_head		queue;
+	unsigned long			last_io;	/* jiffies timestamp */
+	struct usb_gadget		*gadget;
+	struct sw_udc		    *dev;
+	const struct usb_endpoint_descriptor *desc;
+	struct usb_ep			ep;
+	u8				        num;
+
+	unsigned short			fifo_size;
+	u8				        bEndpointAddress;
+	u8				        bmAttributes;
+
+	unsigned			    halted : 1;
+	unsigned			    already_seen : 1;
+	unsigned			    setup_stage : 1;
+
+	__u32					dma_working;		/* flag. is dma busy? 		*/
+	__u32 					dma_transfer_len;	/* dma want transfer length */
+}sw_udc_ep_t;
+
+
+/* Warning : ep0 has a fifo of 16 bytes */
+/* Don't try to set 32 or 64            */
+/* also testusb 14 fails  wit 16 but is */
+/* fine with 8                          */
+//#define  EP0_FIFO_SIZE		    8
+#define  EP0_FIFO_SIZE		    64
+
+#define  SW_UDC_EP_FIFO_SIZE	    512
+
+#define	 SW_UDC_EP_CTRL_INDEX			0x00
+#define  SW_UDC_EP_BULK_IN_INDEX		0x01
+#define  SW_UDC_EP_BULK_OUT_INDEX		0x02
+
+#ifdef  SW_UDC_DOUBLE_FIFO
+#define  SW_UDC_FIFO_NUM			1
+#else
+#define  SW_UDC_FIFO_NUM			0
+#endif
+
+static const char ep0name [] = "ep0";
+
+static const char *const ep_name[] = {
+	ep0name,	/* everyone has ep0 */
+
+	/* sw_udc four bidirectional bulk endpoints */
+	"ep1-bulk",
+	"ep2-bulk",
+	"ep3-bulk",
+	"ep4-bulk",
+	"ep5-int"
+};
+
+#define SW_UDC_ENDPOINTS       ARRAY_SIZE(ep_name)
+
+struct sw_udc_request {
+	struct list_head		queue;		/* ep's requests */
+	struct usb_request		req;
+
+	__u32 is_queue;  /* flag. ? */
+};
+
+enum ep0_state {
+        EP0_IDLE,
+        EP0_IN_DATA_PHASE,
+        EP0_OUT_DATA_PHASE,
+        EP0_END_XFER,
+        EP0_STALL,
+};
+
+/*
+static const char *ep0states[]= {
+        "EP0_IDLE",
+        "EP0_IN_DATA_PHASE",
+        "EP0_OUT_DATA_PHASE",
+        "EP0_END_XFER",
+        "EP0_STALL",
+};
+*/
+
+#ifdef SW_UDC_DMA
+//---------------------------------------------------------------
+//  DMA
+//---------------------------------------------------------------
+typedef struct sw_udc_dma{
+	char name[32];
+	struct sw_dma_client dma_client;
+
+	int dma_hdle;	/* dma  */
+}sw_udc_dma_t;
+
+/* dma  */
+typedef struct sw_udc_dma_parg{
+	struct sw_udc *dev;
+	struct sw_udc_ep *ep;
+	struct sw_udc_request *req;
+}sw_udc_dma_parg_t;
+#endif
+
+
+/* i/o  */
+typedef struct sw_udc_io{
+	struct resource	*usb_base_res;   	/* USB  resources 		*/
+	struct resource	*usb_base_req;   	/* USB  resources 		*/
+	void __iomem	*usb_vbase;			/* USB  base address 	*/
+
+	struct resource	*sram_base_res;   	/* SRAM resources 		*/
+	struct resource	*sram_base_req;   	/* SRAM resources 		*/
+	void __iomem	*sram_vbase;		/* SRAM base address 	*/
+
+	struct resource	*clock_base_res;   	/* clock resources 		*/
+	struct resource	*clock_base_req;   	/* clock resources 		*/
+	void __iomem	*clock_vbase;		/* clock base address 	*/
+
+	bsp_usbc_t usbc;					/* usb bsp config 		*/
+	__hdle usb_bsp_hdle;				/* usb bsp handle 		*/
+
+	__u32 clk_is_open;					/* is usb clock open? 	*/
+	struct clk	*sie_clk;				/* SIE clock handle 	*/
+	struct clk	*phy_clk;				/* PHY clock handle 	*/
+	struct clk	*phy0_clk;				/* PHY0 clock handle 	*/
+
+	long Drv_vbus_Handle;
+}sw_udc_io_t;
+
+//---------------------------------------------------------------
+//
+//---------------------------------------------------------------
+typedef struct sw_udc {
+	spinlock_t			        lock;
+
+	struct sw_udc_ep		    ep[SW_UDC_ENDPOINTS];
+	int				            address;
+	struct usb_gadget		    gadget;
+	struct usb_gadget_driver	*driver;
+	struct sw_udc_request		fifo_req;
+	u8				            fifo_buf[SW_UDC_EP_FIFO_SIZE];
+	u16				            devstatus;
+
+	u32				            port_status;
+	int				            ep0state;
+
+	unsigned			        got_irq : 1;
+
+	unsigned			        req_std : 1;
+	unsigned			        req_config : 1;
+	unsigned			        req_pending : 1;
+	u8				            vbus;
+	struct dentry			    *regs_info;
+
+	sw_udc_io_t					*sw_udc_io;
+	char 						driver_name[32];
+	__u32 						usbc_no;	/*  	*/
+#ifdef SW_UDC_DMA
+	sw_udc_dma_t 			    sw_udc_dma;
+#endif
+
+	u32							stoped;		/*  	*/
+	u32 						irq_no;		/* USB  		*/
+}sw_udc_t;
+
+enum sw_udc_cmd_e {
+	SW_UDC_P_ENABLE	= 1,	/* Pull-up enable        */
+	SW_UDC_P_DISABLE = 2,	/* Pull-up disable       */
+	SW_UDC_P_RESET	= 3,	/* UDC reset, in case of */
+};
+
+typedef struct sw_udc_mach_info {
+	struct usb_port_info *port_info;
+	unsigned int usbc_base;
+}sw_udc_mach_info_t;
+
+
+int sw_usb_device_enable(void);
+int sw_usb_device_disable(void);
+
+#endif   //__SW_UDC_H__
+
diff --git a/drivers/usb/sunxi_usb/include/sw_usb_board.h b/drivers/usb/sunxi_usb/include/sw_usb_board.h
new file mode 100644
index 0000000..667170f
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sw_usb_board.h
@@ -0,0 +1,108 @@
+/*
+ * drivers/usb/sunxi_usb/include/sw_usb_board.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_USB_BOARD_H__
+#define  __SW_USB_BOARD_H__
+
+//----------------------------------------------------------
+//
+//----------------------------------------------------------
+#define  SET_USB_PARA				"usb_para"
+#define  SET_USB0					"usbc0"
+#define  SET_USB1					"usbc1"
+#define  SET_USB2					"usbc2"
+
+#define  KEY_USB_GLOBAL_ENABLE		"usb_global_enable"
+#define  KEY_USBC_NUM				"usbc_num"
+
+#define  KEY_USB_ENABLE				"usb_used"
+#define  KEY_USB_PORT_TYPE			"usb_port_type"
+#define  KEY_USB_DETECT_TYPE		"usb_detect_type"
+#define  KEY_USB_CONTROLLER_TYPE	"usb_controller_type"
+#define  KEY_USB_ID_GPIO			"usb_id_gpio"
+#define  KEY_USB_DETVBUS_GPIO		"usb_det_vbus_gpio"
+#define  KEY_USB_DRVVBUS_GPIO		"usb_drv_vbus_gpio"
+
+#define  KEY_USB_HOST_INIT_STATE    "usb_host_init_state"
+
+//---------------------------------------------------
+//
+//  USB  
+//
+//---------------------------------------------------
+enum usb_gpio_group_type{
+    GPIO_GROUP_TYPE_PIO = 0,
+    GPIO_GROUP_TYPE_POWER,
+};
+
+/* 0: device only; 1: host only; 2: otg */
+enum usb_port_type{
+    USB_PORT_TYPE_DEVICE = 0,
+    USB_PORT_TYPE_HOST,
+    USB_PORT_TYPE_OTG,
+};
+
+/* 0: dp/dm 1: vbus/id */
+enum usb_detect_type{
+    USB_DETECT_TYPE_DP_DM = 0,
+    USB_DETECT_TYPE_VBUS_ID,
+};
+
+/* 0:  1: ehci 2:ohci */
+enum sw_usbc_type {
+	SW_USB_UNKOWN = 0,
+	SW_USB_EHCI,
+	SW_USB_OHCI,
+};
+
+
+/* pio */
+typedef struct usb_gpio{
+	__u32 valid;          	/* pio 0:, !0:	*/
+
+	__u32 group_type;		/* pio 							*/
+	user_gpio_set_t gpio_set;
+}usb_gpio_t;
+
+typedef struct usb_port_info{
+	__u32 enable;          				/* port			*/
+
+	__u32 port_no;						/* usb			*/
+	enum usb_port_type port_type;    	/* usb			*/
+	enum usb_detect_type detect_type; 	/* usb			*/
+
+	usb_gpio_t id;						/* usb id pin 		*/
+	usb_gpio_t det_vbus;				/* usb vbus pin 	*/
+	usb_gpio_t drv_vbus;				/* usb drv_vbus pin	*/
+	__u32 host_init_state;				/* usb 0 : . 1 :  */
+}usb_port_info_t;
+
+typedef struct usb_cfg{
+	u32 usb_global_enable;
+	u32 usbc_num;
+
+	struct usb_port_info port[USBC_MAX_CTL_NUM];
+}usb_cfg_t;
+
+#endif   //__SW_USB_BOARD_H__
+
diff --git a/drivers/usb/sunxi_usb/include/sw_usb_config.h b/drivers/usb/sunxi_usb/include/sw_usb_config.h
new file mode 100644
index 0000000..e305bd8
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sw_usb_config.h
@@ -0,0 +1,48 @@
+/*
+ * drivers/usb/sunxi_usb/include/sw_usb_config.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_USB_CONFIG_H__
+#define  __SW_USB_CONFIG_H__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+
+#include  "sw_usb_typedef.h"
+#include  "sw_usb_debug.h"
+#include  "sunxi_usb_bsp.h"
+#include  "sunxi_sys_reg.h"
+
+#include <plat/sys_config.h>
+
+#include  "sw_usb_board.h"
+#include  "sw_udc.h"
+#include  "sw_hcd.h"
+
+
+#endif   //__SW_USB_CONFIG_H__
+
diff --git a/drivers/usb/sunxi_usb/include/sw_usb_debug.h b/drivers/usb/sunxi_usb/include/sw_usb_debug.h
new file mode 100644
index 0000000..4071ad9
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sw_usb_debug.h
@@ -0,0 +1,108 @@
+/*
+ * drivers/usb/sunxi_usb/include/sw_usb_debug.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_USB_DEBUG_H__
+#define  __SW_USB_DEBUG_H__
+
+#ifdef  CONFIG_USB_SW_SUNXI_USB_DEBUG
+
+#define  DMSG_PRINT(stuff...)		printk(stuff)
+
+#define  DMSG_INFO_UDC(...)			(DMSG_PRINT("[sw_udc]: "), DMSG_PRINT(__VA_ARGS__))
+#define  DMSG_INFO_HCD0(...)		(DMSG_PRINT("[sw_hcd0]: "), DMSG_PRINT(__VA_ARGS__))
+#define  DMSG_INFO_HCD1(...)		(DMSG_PRINT("[sw_hcd1]: "), DMSG_PRINT(__VA_ARGS__))
+#define  DMSG_INFO_HCD2(...)		(DMSG_PRINT("[sw_hcd2]: "), DMSG_PRINT(__VA_ARGS__))
+#define  DMSG_INFO_MANAGER(...)		(DMSG_PRINT("[usb_manager]: "), DMSG_PRINT(__VA_ARGS__))
+
+#else
+
+#define  DMSG_PRINT(...)
+#define  DMSG_INFO_UDC(...)
+#define  DMSG_INFO_HCD0(...)
+#define  DMSG_INFO_HCD1(...)
+#define  DMSG_INFO_HCD2(...)
+#define  DMSG_INFO_MANAGER(...)
+
+#endif
+
+#define  DMSG_PRINT_EX(stuff...)		printk(stuff)
+
+#define  DMSG_ERR(...)        		(DMSG_PRINT_EX("WRN:L%d(%s):", __LINE__, __FILE__), DMSG_PRINT_EX(__VA_ARGS__))
+
+
+/*  */
+#if  0
+    #define DMSG_TEST         			DMSG_PRINT
+#else
+    #define DMSG_TEST(...)
+#endif
+
+/*  */
+#if  0
+    #define DMSG_MANAGER_DEBUG          DMSG_PRINT
+#else
+    #define DMSG_MANAGER_DEBUG(...)
+#endif
+
+#if  0
+    #define DMSG_DEBUG        			DMSG_PRINT
+#else
+    #define DMSG_DEBUG(...)
+#endif
+
+/*  */
+#if  1
+    #define DMSG_INFO         			DMSG_PRINT
+#else
+    #define DMSG_INFO(...)
+#endif
+
+/*  */
+#if	1
+    #define DMSG_PANIC        			DMSG_ERR
+#else
+    #define DMSG_PANIC(...)
+#endif
+
+/*  */
+#if	0
+    #define DMSG_WRN        			DMSG_ERR
+#else
+    #define DMSG_WRN(...)
+#endif
+
+/* dma  */
+#if	0
+    #define DMSG_DBG_DMA     			DMSG_PRINT
+#else
+    #define DMSG_DBG_DMA(...)
+#endif
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+void print_usb_reg_by_ep(spinlock_t *lock, __u32 usbc_base, __s32 ep_index, char *str);
+void print_all_usb_reg(spinlock_t *lock, __u32 usbc_base, __s32 ep_start, __u32 ep_end, char *str);
+
+#endif   //__SW_USB_DEBUG_H__
+
diff --git a/drivers/usb/sunxi_usb/include/sw_usb_typedef.h b/drivers/usb/sunxi_usb/include/sw_usb_typedef.h
new file mode 100644
index 0000000..afe2ff1
--- /dev/null
+++ b/drivers/usb/sunxi_usb/include/sw_usb_typedef.h
@@ -0,0 +1,117 @@
+/*
+ * drivers/usb/sunxi_usb/include/sw_usb_typedef.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_USB_TYPEDEF_H__
+#define  __SW_USB_TYPEDEF_H__
+
+
+#undef int8
+typedef signed char           int8;
+
+#undef int16
+typedef signed short          int16;
+
+#undef int32
+typedef signed int            int32;
+
+#undef uint8
+typedef unsigned char         uint8;
+
+#undef uint16
+typedef unsigned short        uint16;
+
+#undef uint32
+typedef unsigned int          uint32;
+/*
+#undef s8
+typedef signed char           s8;
+
+#undef s16
+typedef signed short          s16;
+
+#undef s32
+typedef signed int            s32;
+
+#undef u8
+typedef unsigned char         u8;
+
+#undef u16
+typedef unsigned short        u16;
+
+#undef u32
+typedef unsigned int          u32;
+
+#undef __s8
+typedef signed char           __s8;
+
+#undef __s16
+typedef signed short          __s16;
+
+#undef __s32
+typedef signed int            __s32;
+
+#undef __u8
+typedef unsigned char         __u8;
+
+#undef __u16
+typedef unsigned short        __u16;
+
+#undef __u32
+typedef unsigned int          __u32;
+
+#undef __bool
+typedef signed char           __bool;
+*/
+#undef  __hdle
+typedef unsigned int        __hdle;
+
+/* bit1 */
+#undef  x_set_bit
+#define x_set_bit( value, bit )      		( (value) |=  ( 1U << (bit) ) )
+
+/* bit */
+#undef  x_clear_bit
+#define x_clear_bit( value, bit )    		( (value) &= ~( 1U << (bit) ) )
+
+/* bit */
+#undef  x_reverse_bit
+#define x_reverse_bit( value, bit )  		( (value) ^=  ( 1U << (bit) ) )
+
+/* bit1 */
+#undef  x_test_bit
+#define x_test_bit( value, bit )     		( (value)  &  ( 1U << (bit) ) )
+
+/*  */
+#undef  x_min
+#define x_min( x, y )          				( (x) < (y) ? (x) : (y) )
+
+/*  */
+#undef  x_max
+#define x_max( x, y )          				( (x) > (y) ? (x) : (y) )
+
+/*  */
+#undef  x_absolute
+#define x_absolute(p)        				((p) > 0 ? (p) : -(p))
+
+#endif   //__SW_USB_TYPEDEF_H__
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_hcd_servers.c b/drivers/usb/sunxi_usb/manager/usb_hcd_servers.c
new file mode 100644
index 0000000..7034e2d
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_hcd_servers.c
@@ -0,0 +1,135 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_hcd_servers.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include  "../include/sw_usb_config.h"
+#include  "../include/sw_usb_board.h"
+#include  "usb_hcd_servers.h"
+
+int sw_usb_disable_ehci(__u32 usbc_no);
+int sw_usb_enable_ehci(__u32 usbc_no);
+int sw_usb_disable_ohci(__u32 usbc_no);
+int sw_usb_enable_ohci(__u32 usbc_no);
+
+static enum sw_usbc_type controller_type = SW_USB_EHCI;
+
+
+/*
+*******************************************************************************
+*                     sw_usb_disable_hcd
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_usb_disable_hcd(__u32 usbc_no)
+{
+	if (usbc_no == 0) {
+#if defined(CONFIG_USB_SW_SUNXI_USB0_OTG) || defined(USB_SW_SUNXI_USB0_HOST_ONLY)
+		sw_usb_disable_hcd0();
+#endif
+	} else if (usbc_no == 1 || usbc_no == 2) {
+#if defined(CONFIG_USB_SUNXI_EHCI)
+		if (controller_type != SW_USB_OHCI)
+			sw_usb_disable_ehci(usbc_no);
+#endif
+#if defined(CONFIG_USB_SUNXI_OHCI)
+		if (controller_type != SW_USB_EHCI)
+			sw_usb_disable_ohci(usbc_no);
+#endif
+	} else {
+		DMSG_PANIC("ERR: unkown usbc_no(%d)\n", usbc_no);
+		return -1;
+	}
+
+    return 0;
+}
+EXPORT_SYMBOL(sw_usb_disable_hcd);
+
+/*
+*******************************************************************************
+*                     sw_usb_enable_hcd
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+int sw_usb_enable_hcd(__u32 usbc_no)
+{
+	char *set_usbc = NULL;
+	int ret = 0;
+
+	if (usbc_no == 0)
+		set_usbc = SET_USB0;
+	else if (usbc_no == 1)
+		set_usbc = SET_USB1;
+	else
+		set_usbc = SET_USB2;
+
+	/* ----------get usbc_type------------- */
+	ret = script_parser_fetch(set_usbc, KEY_USB_CONTROLLER_TYPE,
+			(int *)&controller_type, 64);
+	if (ret != 0)
+		DMSG_INFO("ERR: script_parser_fetch "
+				"usb_controller_type failed\n");
+
+	if (usbc_no == 0) {
+#if defined(CONFIG_USB_SW_SUNXI_USB0_OTG) || defined(USB_SW_SUNXI_USB0_HOST_ONLY)
+		sw_usb_enable_hcd0();
+#endif
+	} else if (usbc_no == 1 || usbc_no == 2) {
+#if defined(CONFIG_USB_SUNXI_EHCI)
+		if (controller_type != SW_USB_OHCI)
+			sw_usb_enable_ehci(usbc_no);
+#endif
+#if defined(CONFIG_USB_SUNXI_OHCI)
+		if (controller_type != SW_USB_EHCI)
+			sw_usb_enable_ohci(usbc_no);
+#endif
+	} else {
+		DMSG_PANIC("ERR: unkown usbc_no(%d)\n", usbc_no);
+		return -1;
+	}
+
+    return 0;
+}
+EXPORT_SYMBOL(sw_usb_enable_hcd);
diff --git a/drivers/usb/sunxi_usb/manager/usb_hcd_servers.h b/drivers/usb/sunxi_usb/manager/usb_hcd_servers.h
new file mode 100644
index 0000000..644fc6d
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_hcd_servers.h
@@ -0,0 +1,35 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_hcd_servers.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __USB_HCD_SERVERS_H__
+#define  __USB_HCD_SERVERS_H__
+
+
+int sw_usb_disable_hcd(__u32 usbc_no);
+int sw_usb_enable_hcd(__u32 usbc_no);
+
+
+
+#endif  //__USB_HCD_SERVERS_H__
+
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_hw_scan.c b/drivers/usb/sunxi_usb/manager/usb_hw_scan.c
new file mode 100644
index 0000000..117b7e5
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_hw_scan.c
@@ -0,0 +1,809 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_hw_scan.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <mach/irqs.h>
+
+#include  "../include/sw_usb_config.h"
+#include  "usb_manager.h"
+#include  "usb_hw_scan.h"
+#include  "usb_msg_center.h"
+
+static struct usb_scan_info g_usb_scan_info;
+
+void (*__usb_hw_scan) (struct usb_scan_info *);
+
+
+/*
+*******************************************************************************
+*                     __get_pin_data
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __u32 get_pin_data(u32 id_hdle)
+{
+    return gpio_read_one_pin_value(id_hdle, NULL);
+}
+
+/*
+*********************************************************************
+*                     PIODataIn_debounce
+*
+* Description:
+* 	PIO
+* 	1010
+* 	10
+*
+* Arguments:
+*    phdle  :  input.
+*    value  :  output.  PIO
+*
+* Returns:
+*    
+*
+* note:
+*    
+*
+*********************************************************************
+*/
+static __u32 PIODataIn_debounce(__hdle phdle, __u32 *value)
+{
+    __u32 retry  = 0;
+    __u32 time   = 10;
+	__u32 temp1  = 0;
+	__u32 cnt    = 0;
+	__u32 change = 0;	/* ? */
+
+    /*  10 PIO10
+       
+    */
+    if(phdle){
+        retry = time;
+		while(retry--){
+			temp1 = get_pin_data(phdle);
+			if(temp1){
+				cnt++;
+			}
+		}
+
+        /* 10 01 */
+		if((cnt == time)||(cnt == 0)){
+		    change = 0;
+		}
+	    else{
+	        change = 1;
+	    }
+	}else{
+		change = 1;
+	}
+
+	if(!change){
+		*value = temp1;
+	}
+
+	DMSG_DBG_MANAGER("phdle = %x, cnt = %x, change= %d, temp1 = %x\n", phdle, cnt, change, temp1);
+
+	return change;
+}
+
+/*
+*******************************************************************************
+*                     get_id_state
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static u32 get_id_state(struct usb_scan_info *info)
+{
+	enum usb_id_state id_state = USB_DEVICE_MODE;
+	__u32 pin_data = 0;
+
+	if(info->id_hdle){
+		if(!PIODataIn_debounce(info->id_hdle, &pin_data)){
+			if(pin_data){
+				id_state = USB_DEVICE_MODE;
+			}else{
+				id_state = USB_HOST_MODE;
+			}
+
+			info->id_old_state = id_state;
+		}else{
+			id_state = info->id_old_state;
+		}
+	}
+
+    return id_state;
+}
+
+/*
+*******************************************************************************
+*                     get_detect_vbus_state
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static u32 get_detect_vbus_state(struct usb_scan_info *info)
+{
+	enum usb_det_vbus_state det_vbus_state = USB_DET_VBUS_INVALID;
+	__u32 pin_data = 0;
+
+	if(info->det_vbus_hdle){
+		if(!PIODataIn_debounce(info->det_vbus_hdle, &pin_data)){
+			if(pin_data){
+				det_vbus_state = USB_DET_VBUS_VALID;
+			}else{
+				det_vbus_state = USB_DET_VBUS_INVALID;
+			}
+
+			info->det_vbus_old_state = det_vbus_state;
+		}else{
+			det_vbus_state = info->det_vbus_old_state;
+		}
+	}
+
+    return det_vbus_state;
+}
+
+static u32 get_dp_dm_status_normal(struct usb_scan_info *info)
+{
+	__u32 reg_val = 0;
+	__u32 dp = 0;
+	__u32 dm = 0;
+
+	/* USBC_EnableDpDmPullUp */
+	reg_val = USBC_Readl(USBC_REG_ISCR(SW_VA_USB0_IO_BASE));
+	reg_val |= (1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
+	USBC_Writel(reg_val, USBC_REG_ISCR(SW_VA_USB0_IO_BASE));
+
+	/* USBC_EnableIdPullUp */
+	reg_val = USBC_Readl(USBC_REG_ISCR(SW_VA_USB0_IO_BASE));
+	reg_val |= (1 << USBC_BP_ISCR_ID_PULLUP_EN);
+	USBC_Writel(reg_val, USBC_REG_ISCR(SW_VA_USB0_IO_BASE));
+
+	msleep(10); /* HdG: New from sun7i code dump */
+
+	reg_val = USBC_Readl(USBC_REG_ISCR(SW_VA_USB0_IO_BASE));
+	dp = (reg_val >> USBC_BP_ISCR_EXT_DP_STATUS) & 0x01;
+	dm = (reg_val >> USBC_BP_ISCR_EXT_DM_STATUS) & 0x01;
+
+	/*printk("USBC_REG_ISCR = 0x%x\n", reg_val);*/
+
+	return (dp << 1) | dm;
+}
+
+static u32 get_dp_dm_status(struct usb_scan_info *info)
+{
+	u32 ret  = 0;
+	u32 ret0 = 0;
+	u32 ret1 = 0;
+	u32 ret2 = 0;
+
+	ret0 = get_dp_dm_status_normal(info);
+	ret1 = get_dp_dm_status_normal(info);
+	ret2 = get_dp_dm_status_normal(info);
+
+	/*3*/
+	if ((ret0 == ret1) && (ret0 == ret2))
+		ret = ret0;
+	else if (ret2 == 0x11) {
+		if (get_usb_role() == USB_ROLE_DEVICE) {
+			ret = 0x11;
+			DMSG_INFO("ERR: dp/dm status is continuous(0x11)\n");
+		}
+	} else
+		ret = ret2;
+
+	/*printk("dp/dm: %d, (%d, %d, %d)\n", ret, ret0, ret1, ret2);*/
+
+	return ret;
+}
+
+
+/*
+*******************************************************************************
+*                     do_vbus0_id0
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void do_vbus0_id0(struct usb_scan_info *info)
+{
+	enum usb_role role = USB_ROLE_NULL;
+
+	role = get_usb_role();
+	info->device_insmod_delay = 0;
+
+	switch(role){
+		case USB_ROLE_NULL:
+			/* delay for vbus is stably */
+			if(info->host_insmod_delay < USB_SCAN_INSMOD_HOST_DRIVER_DELAY){
+				info->host_insmod_delay++;
+				break;
+			}
+			info->host_insmod_delay = 0;
+
+			/* insmod usb host */
+			hw_insmod_usb_host();
+		break;
+
+		case USB_ROLE_HOST:
+			/* nothing to do */
+		break;
+
+		case USB_ROLE_DEVICE:
+			/* rmmod usb device */
+			hw_rmmod_usb_device();
+		break;
+
+		default:
+			DMSG_PANIC("ERR: unkown usb role(%d)\n", role);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     do_vbus0_id1
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void do_vbus0_id1(struct usb_scan_info *info)
+{
+	enum usb_role role = USB_ROLE_NULL;
+
+	role = get_usb_role();
+	info->device_insmod_delay = 0;
+	info->host_insmod_delay   = 0;
+
+	switch(role){
+		case USB_ROLE_NULL:
+			/* nothing to do */
+		break;
+
+		case USB_ROLE_HOST:
+			hw_rmmod_usb_host();
+		break;
+
+		case USB_ROLE_DEVICE:
+			hw_rmmod_usb_device();
+		break;
+
+		default:
+			DMSG_PANIC("ERR: unkown usb role(%d)\n", role);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     do_vbus1_id0
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void do_vbus1_id0(struct usb_scan_info *info)
+{
+	enum usb_role role = USB_ROLE_NULL;
+
+	role = get_usb_role();
+	info->device_insmod_delay = 0;
+
+	switch(role){
+		case USB_ROLE_NULL:
+			/* delay for vbus is stably */
+			if(info->host_insmod_delay < USB_SCAN_INSMOD_HOST_DRIVER_DELAY){
+				info->host_insmod_delay++;
+				break;
+			}
+			info->host_insmod_delay = 0;
+
+			hw_insmod_usb_host();
+		break;
+
+		case USB_ROLE_HOST:
+			/* nothing to do */
+		break;
+
+		case USB_ROLE_DEVICE:
+			hw_rmmod_usb_device();
+		break;
+
+		default:
+			DMSG_PANIC("ERR: unkown usb role(%d)\n", role);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     do_vbus1_id1
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void do_vbus1_id1(struct usb_scan_info *info)
+{
+	enum usb_role role = USB_ROLE_NULL;
+
+	role = get_usb_role();
+	info->host_insmod_delay = 0;
+
+	switch(role){
+		case USB_ROLE_NULL:
+			if (get_dp_dm_status(info) == 0x00) {
+				/* delay for vbus is stably */
+				if (info->device_insmod_delay <
+					USB_SCAN_INSMOD_DEVICE_DRIVER_DELAY) {
+					info->device_insmod_delay++;
+					break;
+				}
+
+				info->device_insmod_delay = 0;
+				hw_insmod_usb_device();
+			}
+		break;
+
+		case USB_ROLE_HOST:
+			hw_rmmod_usb_host();
+		break;
+
+		case USB_ROLE_DEVICE:
+			/* nothing to do */
+		break;
+
+		default:
+			DMSG_PANIC("ERR: unkown usb role(%d)\n", role);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     get_vbus_id_state
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __u32 get_vbus_id_state(struct usb_scan_info *info)
+{
+    u32 state = 0;
+
+	if(get_id_state(info) == USB_DEVICE_MODE){
+		x_set_bit(state, 0);
+	}
+
+	if(get_detect_vbus_state(info) == USB_DET_VBUS_VALID){
+		x_set_bit(state, 1);
+	}
+
+	return state;
+}
+
+/*
+*******************************************************************************
+*                     vbus_id_hw_scan
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void vbus_id_hw_scan(struct usb_scan_info *info)
+{
+	__u32 vbus_id_state = 0;
+
+	vbus_id_state = get_vbus_id_state(info);
+
+	DMSG_DBG_MANAGER("vbus_id=%d, role=%d\n", vbus_id_state, get_usb_role());
+
+	switch(vbus_id_state){
+		case  0x00:
+			do_vbus0_id0(info);
+		break;
+
+		case  0x01:
+			do_vbus0_id1(info);
+		break;
+
+		case  0x02:
+			do_vbus1_id0(info);
+		break;
+
+		case  0x03:
+			do_vbus1_id1(info);
+		break;
+
+		default:
+			DMSG_PANIC("ERR: vbus_id_hw_scan: unkown vbus_id_state(0x%x)\n", vbus_id_state);
+	}
+
+	return ;
+}
+
+/*
+*******************************************************************************
+*                     usb_hw_scan
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void null_hw_scan(struct usb_scan_info *info)
+{
+	DMSG_DBG_MANAGER("null_hw_scan\n");
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     usb_hw_scan
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void usb_hw_scan(struct usb_cfg *cfg)
+{
+    __usb_hw_scan(&g_usb_scan_info);
+}
+
+/*
+*******************************************************************************
+*                     usb_hw_scan_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 usb_hw_scan_init(struct usb_cfg *cfg)
+{
+	struct usb_scan_info *scan_info = &g_usb_scan_info;
+	struct usb_port_info *port_info = NULL;
+	__s32 ret = 0;
+
+	memset(scan_info, 0, sizeof(struct usb_scan_info));
+	scan_info->cfg 					= cfg;
+	scan_info->id_old_state 		= USB_DEVICE_MODE;
+	scan_info->det_vbus_old_state 	= USB_DET_VBUS_INVALID;
+
+	port_info =&(cfg->port[0]);
+	switch(port_info->port_type){
+		case USB_PORT_TYPE_DEVICE:
+			__usb_hw_scan = null_hw_scan;
+		break;
+
+		case USB_PORT_TYPE_HOST:
+			__usb_hw_scan = null_hw_scan;
+		break;
+
+		case USB_PORT_TYPE_OTG:
+		{
+			switch(port_info->detect_type){
+				case USB_DETECT_TYPE_DP_DM:
+					__usb_hw_scan = null_hw_scan;
+				break;
+
+				case USB_DETECT_TYPE_VBUS_ID:
+				{
+					__u32 need_pull_pio = 1;
+
+					if((port_info->id.valid == 0) || (port_info->det_vbus.valid == 0)){
+						DMSG_PANIC("ERR: usb detect tpye is vbus/id, but id(%d)/vbus(%d) is invalid\n",
+							       port_info->id.valid, port_info->det_vbus.valid);
+						ret = -1;
+						goto failed;
+					}
+
+                    /* idvbuspin, pio */
+					if(port_info->id.gpio_set.port_num == port_info->det_vbus.gpio_set.port_num){
+						need_pull_pio = 0;
+					}
+
+					/* request id gpio */
+					switch(port_info->id.group_type){
+						case GPIO_GROUP_TYPE_PIO:
+							/* request gpio */
+							scan_info->id_hdle = sunxi_gpio_request_array(&port_info->id.gpio_set, 1);
+							if(scan_info->id_hdle == 0){
+								DMSG_PANIC("ERR: id gpio_request failed\n");
+								ret = -1;
+								goto failed;
+							}
+
+							/* set config, input */
+							gpio_set_one_pin_io_status(scan_info->id_hdle, 0, NULL);
+
+							/* reserved is pull up */
+							if(need_pull_pio){
+								gpio_set_one_pin_pull(scan_info->id_hdle, 1, NULL);
+							}
+						break;
+
+						case GPIO_GROUP_TYPE_POWER:
+							/* not support */
+						break;
+
+						default:
+							DMSG_PANIC("ERR: unkown id gpio group type(%d)\n", port_info->id.group_type);
+							ret = -1;
+							goto failed;
+					}
+
+					/* request det_vbus gpio */
+					switch(port_info->det_vbus.group_type){
+						case GPIO_GROUP_TYPE_PIO:
+							/* request gpio */
+							scan_info->det_vbus_hdle = sunxi_gpio_request_array(&port_info->det_vbus.gpio_set, 1);
+							if(scan_info->det_vbus_hdle == 0){
+								DMSG_PANIC("ERR: det_vbus gpio_request failed\n");
+								ret = -1;
+								goto failed;
+							}
+
+							/* set config, input */
+							gpio_set_one_pin_io_status(scan_info->det_vbus_hdle, 0, NULL);
+
+							/* reserved is disable */
+							if(need_pull_pio){
+								gpio_set_one_pin_pull(scan_info->det_vbus_hdle, 0, NULL);
+							}
+						break;
+
+						case GPIO_GROUP_TYPE_POWER:
+							/* not support */
+						break;
+
+						default:
+							DMSG_PANIC("ERR: unkown det_vbus gpio group type(%d)\n", port_info->det_vbus.group_type);
+							ret = -1;
+							goto failed;
+					}
+
+					__usb_hw_scan = vbus_id_hw_scan;
+				}
+				break;
+
+				default:
+					DMSG_PANIC("ERR: unkown detect_type(%d)\n", port_info->detect_type);
+					ret = -1;
+					goto failed;
+			}
+		}
+		break;
+
+		default:
+			DMSG_PANIC("ERR: unkown port_type(%d)\n", cfg->port[0].port_type);
+			ret = -1;
+			goto failed;
+	}
+
+	return 0;
+
+failed:
+	if(scan_info->id_hdle){
+		gpio_release(scan_info->id_hdle, 0);
+		scan_info->id_hdle = 0;
+	}
+
+	if(scan_info->det_vbus_hdle){
+		gpio_release(scan_info->det_vbus_hdle, 0);
+		scan_info->det_vbus_hdle = 0;
+	}
+
+	__usb_hw_scan = null_hw_scan;
+
+	return ret;
+}
+
+/*
+*******************************************************************************
+*                     usb_hw_scan_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 usb_hw_scan_exit(struct usb_cfg *cfg)
+{
+	struct usb_scan_info *scan_info = &g_usb_scan_info;
+
+	if(scan_info->id_hdle){
+		gpio_release(scan_info->id_hdle, 0);
+		scan_info->id_hdle = 0;
+	}
+
+	if(scan_info->det_vbus_hdle){
+		gpio_release(scan_info->det_vbus_hdle, 0);
+		scan_info->det_vbus_hdle = 0;
+	}
+
+	return 0;
+}
+
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_hw_scan.h b/drivers/usb/sunxi_usb/manager/usb_hw_scan.h
new file mode 100644
index 0000000..fe0ee47
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_hw_scan.h
@@ -0,0 +1,65 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_hw_scan.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __USB_HW_SCAN_H__
+#define  __USB_HW_SCAN_H__
+
+#define  USB_SCAN_INSMOD_DEVICE_DRIVER_DELAY	2
+#define  USB_SCAN_INSMOD_HOST_DRIVER_DELAY		1
+
+/* ubs id */
+typedef enum usb_id_state{
+	USB_HOST_MODE = 0,
+	USB_DEVICE_MODE = 1,
+}usb_id_state_t;
+
+/* usb detect vbus */
+typedef enum usb_det_vbus_state{
+    USB_DET_VBUS_INVALID = 0,
+	USB_DET_VBUS_VALID  = 1
+}usb_det_vbus_state_t;
+
+/* usb info */
+typedef struct usb_scan_info{
+	struct usb_cfg 			*cfg;
+
+	u32                     id_hdle;                /* id handle                */
+	user_gpio_set_t         id_gpio_set;            /* id gpio set              */
+
+	u32                     det_vbus_hdle;        	/* detect vbus handle       */
+	user_gpio_set_t         det_vbus_gpio_set;      /* detect vbus gpio set     */
+
+    usb_id_state_t          id_old_state;           /* last id state            */
+    usb_det_vbus_state_t    det_vbus_old_state;     /* last detect vbus state   */
+
+    u32                     device_insmod_delay;    /* debounce time            */
+    u32                     host_insmod_delay;    	/* debounce time            */
+}usb_scan_info_t;
+
+void usb_hw_scan(struct usb_cfg *cfg);
+
+__s32 usb_hw_scan_init(struct usb_cfg *cfg);
+__s32 usb_hw_scan_exit(struct usb_cfg *cfg);
+
+#endif   //__USB_HW_SCAN_H__
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_manager.c b/drivers/usb/sunxi_usb/manager/usb_manager.c
new file mode 100644
index 0000000..7382cf1
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_manager.c
@@ -0,0 +1,605 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_manager.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/kthread.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <mach/irqs.h>
+#include <plat/system.h>
+
+#include  "../include/sw_usb_config.h"
+#include  "usb_manager.h"
+#include  "usbc_platform.h"
+#include  "usb_hw_scan.h"
+#include  "usb_msg_center.h"
+
+
+static struct usb_cfg g_usb_cfg;
+
+#ifdef CONFIG_USB_SW_SUNXI_USB0_OTG
+static __u32 thread_run_flag = 1;
+static __u32 thread_stopped_flag = 1;
+#endif
+
+/*
+*******************************************************************************
+*                     usb_hardware_scan_thread
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+#ifdef CONFIG_USB_SW_SUNXI_USB0_OTG
+
+static int usb_hardware_scan_thread(void * pArg)
+{
+	struct usb_cfg *cfg = pArg;
+
+	/* delay for udc & hcd ready */
+	msleep(3000);
+
+	while(thread_run_flag){
+		DMSG_DBG_MANAGER("\n\n");
+
+		usb_hw_scan(cfg);
+		usb_msg_center(cfg);
+
+		DMSG_DBG_MANAGER("\n\n");
+
+		msleep(1000);  /* 1s */
+	}
+
+	thread_stopped_flag = 1;
+
+	return 0;
+}
+
+#endif
+
+/*
+*******************************************************************************
+*                     usb_manager_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 usb_script_parse(struct usb_cfg *cfg)
+{
+	s32 ret = 0;
+	u32 i = 0;
+	char *set_usbc = NULL;
+
+	for(i = 0; i < cfg->usbc_num; i++){
+		if(i == 0){
+			set_usbc = SET_USB0;
+		}else if(i == 1){
+			set_usbc = SET_USB1;
+		}else{
+			set_usbc = SET_USB2;
+		}
+
+		/* usbc enable */
+		ret = script_parser_fetch(set_usbc, KEY_USB_ENABLE, (int *)&(cfg->port[i].enable), 64);
+		if(ret != 0){
+			DMSG_PANIC("ERR: get usbc(%d) enable failed\n", i);
+		}
+
+		/* usbc port type */
+		ret = script_parser_fetch(set_usbc, KEY_USB_PORT_TYPE, (int *)&(cfg->port[i].port_type), 64);
+		if(ret != 0){
+			DMSG_PANIC("ERR: get usbc(%d) port type failed\n", i);
+		}
+
+		/* usbc detect type */
+		ret = script_parser_fetch(set_usbc, KEY_USB_DETECT_TYPE, (int *)&(cfg->port[i].detect_type), 64);
+		if(ret != 0){
+			DMSG_PANIC("ERR: get usbc(%d) detect type failed\n", i);
+		}
+
+		/* usbc id */
+		ret = script_parser_fetch(set_usbc, KEY_USB_ID_GPIO, (int *)&(cfg->port[i].id.gpio_set), 64);
+		if(ret != 0){
+			DMSG_PANIC("ERR: get usbc(%d) id failed\n", i);
+		}
+
+		/* usbc det_vbus */
+		ret = script_parser_fetch(set_usbc, KEY_USB_DETVBUS_GPIO, (int *)&(cfg->port[i].det_vbus.gpio_set), 64);
+		if(ret != 0){
+			DMSG_PANIC("ERR: get usbc(%d) det_vbus failed\n", i);
+		}
+
+		/* usbc drv_vbus */
+		ret = script_parser_fetch(set_usbc, KEY_USB_DRVVBUS_GPIO, (int *)&(cfg->port[i].drv_vbus.gpio_set), 64);
+		if(ret != 0){
+			DMSG_PANIC("ERR: get usbc(%d) drv_vbus failed\n", i);
+		}
+	}
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     modify_usb_borad_info
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void modify_usb_borad_info(struct usb_cfg *cfg)
+{
+    u32 i = 0;
+
+	for(i = 0; i < cfg->usbc_num; i++){
+		if(cfg->port[i].id.gpio_set.port){
+			cfg->port[i].id.valid = 1;
+
+			if(cfg->port[i].id.gpio_set.port == 0xffff){
+				cfg->port[i].id.group_type = GPIO_GROUP_TYPE_POWER;
+			}else{
+				cfg->port[i].id.group_type = GPIO_GROUP_TYPE_PIO;
+			}
+		}
+
+		if(cfg->port[i].det_vbus.gpio_set.port){
+			cfg->port[i].det_vbus.valid = 1;
+
+			if(cfg->port[i].det_vbus.gpio_set.port == 0xffff){
+				cfg->port[i].det_vbus.group_type = GPIO_GROUP_TYPE_POWER;
+			}else{
+				cfg->port[i].det_vbus.group_type = GPIO_GROUP_TYPE_PIO;
+			}
+		}
+
+		if(cfg->port[i].drv_vbus.gpio_set.port){
+			cfg->port[i].drv_vbus.valid = 1;
+
+			if(cfg->port[i].drv_vbus.gpio_set.port == 0xffff){
+				cfg->port[i].drv_vbus.group_type = GPIO_GROUP_TYPE_POWER;
+			}else{
+				cfg->port[i].drv_vbus.group_type = GPIO_GROUP_TYPE_PIO;
+			}
+		}
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     check_usb_board_info
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 check_usb_board_info(struct usb_cfg *cfg)
+{
+    //-------------------------------------
+    // USB0
+    //-------------------------------------
+    if(cfg->port[0].enable){
+        /* port */
+        if(cfg->port[0].port_type != USB_PORT_TYPE_DEVICE
+           && cfg->port[0].port_type != USB_PORT_TYPE_HOST
+           && cfg->port[0].port_type != USB_PORT_TYPE_OTG){
+            DMSG_PANIC("ERR: usbc0 port_type(%d) is unkown\n", cfg->port[0].port_type);
+    	    goto err;
+        }
+
+        /* USB */
+        if(cfg->port[0].detect_type != USB_DETECT_TYPE_DP_DM
+           && cfg->port[0].detect_type != USB_DETECT_TYPE_VBUS_ID){
+            DMSG_PANIC("ERR: usbc0 detect_type(%d) is unkown\n", cfg->port[0].detect_type);
+    	    goto err;
+        }
+
+        /* VBUS/IDid/vbus pin  */
+        if(cfg->port[0].detect_type == USB_DETECT_TYPE_VBUS_ID){
+            if(cfg->port[0].id.valid == 0){
+                DMSG_PANIC("ERR: id pin is invaild\n");
+    		    goto err;
+            }
+
+            if(cfg->port[0].det_vbus.valid == 0){
+                DMSG_PANIC("ERR: det_vbus pin is invaild\n");
+    		    goto err;
+            }
+        }
+    }
+
+    //-------------------------------------
+    // USB1
+    //-------------------------------------
+
+    //-------------------------------------
+    // USB2
+    //-------------------------------------
+
+    return 0;
+
+err:
+    return -1;
+}
+
+/*
+*******************************************************************************
+*                     print_gpio_set
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void print_gpio_set(user_gpio_set_t *gpio_set)
+{
+	DMSG_MANAGER_DEBUG("gpio_name            = %s\n", gpio_set->gpio_name);
+	DMSG_MANAGER_DEBUG("port                 = %x\n", gpio_set->port);
+	DMSG_MANAGER_DEBUG("port_num             = %x\n", gpio_set->port_num);
+	DMSG_MANAGER_DEBUG("mul_sel              = %x\n", gpio_set->mul_sel);
+	DMSG_MANAGER_DEBUG("pull                 = %x\n", gpio_set->pull);
+	DMSG_MANAGER_DEBUG("drv_level            = %x\n", gpio_set->drv_level);
+	DMSG_MANAGER_DEBUG("data                 = %x\n", gpio_set->data);
+}
+
+/*
+*******************************************************************************
+*                     print_usb_cfg
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void print_usb_cfg(struct usb_cfg *cfg)
+{
+    u32 i = 0;
+
+	DMSG_MANAGER_DEBUG("\n-----------usb config information--------------\n");
+
+	DMSG_MANAGER_DEBUG("controller number    = %x\n", (u32)USBC_MAX_CTL_NUM);
+
+	DMSG_MANAGER_DEBUG("usb_global_enable    = %x\n", cfg->usb_global_enable);
+	DMSG_MANAGER_DEBUG("usbc_num             = %x\n", cfg->usbc_num);
+
+    for(i = 0; i < USBC_MAX_CTL_NUM; i++){
+		DMSG_MANAGER_DEBUG("\n");
+		DMSG_MANAGER_DEBUG("port[%d]:\n", i);
+		DMSG_MANAGER_DEBUG("enable               = %x\n", cfg->port[i].enable);
+		DMSG_MANAGER_DEBUG("port_no              = %x\n", cfg->port[i].port_no);
+		DMSG_MANAGER_DEBUG("port_type            = %x\n", cfg->port[i].port_type);
+		DMSG_MANAGER_DEBUG("detect_type          = %x\n", cfg->port[i].detect_type);
+
+		DMSG_MANAGER_DEBUG("id.valid             = %x\n", cfg->port[i].id.valid);
+		DMSG_MANAGER_DEBUG("id.group_type        = %x\n", cfg->port[i].id.group_type);
+		print_gpio_set(&cfg->port[i].id.gpio_set);
+
+		DMSG_MANAGER_DEBUG("vbus.valid           = %x\n", cfg->port[i].det_vbus.valid);
+		DMSG_MANAGER_DEBUG("vbus.group_type      = %x\n", cfg->port[i].det_vbus.group_type);
+		print_gpio_set(&cfg->port[i].det_vbus.gpio_set);
+
+		DMSG_MANAGER_DEBUG("drv_vbus.valid       = %x\n", cfg->port[i].drv_vbus.valid);
+		DMSG_MANAGER_DEBUG("drv_vbus.group_type  = %x\n", cfg->port[i].drv_vbus.group_type);
+		print_gpio_set(&cfg->port[i].drv_vbus.gpio_set);
+
+		DMSG_MANAGER_DEBUG("\n");
+    }
+
+	DMSG_MANAGER_DEBUG("-------------------------------------------------\n");
+}
+
+/*
+*******************************************************************************
+*                     get_usb_cfg
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __s32 get_usb_cfg(struct usb_cfg *cfg)
+{
+	__s32 ret = 0;
+
+	/* parse script */
+	ret = usb_script_parse(cfg);
+	if(ret != 0){
+		DMSG_PANIC("ERR: usb_script_parse failed\n");
+		return -1;
+	}
+
+	modify_usb_borad_info(cfg);
+
+	print_usb_cfg(cfg);
+
+    ret = check_usb_board_info(cfg);
+	if(ret != 0){
+		DMSG_PANIC("ERR: check_usb_board_info failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     usb_manager_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int __init usb_manager_init(void)
+{
+	__s32 ret = 0;
+	bsp_usbc_t usbc;
+	u32 i = 0;
+
+#ifdef CONFIG_USB_SW_SUNXI_USB0_OTG
+	struct task_struct *th = NULL;
+#endif
+
+    DMSG_MANAGER_DEBUG("[sw usb]: usb_manager_init\n");
+
+#if defined(CONFIG_USB_SW_SUNXI_USB0_DEVICE_ONLY)
+	DMSG_INFO_MANAGER("CONFIG_USB_SW_SUNXI_USB0_DEVICE_ONLY\n");
+#elif defined(CONFIG_USB_SW_SUNXI_USB0_HOST_ONLY)
+	DMSG_INFO_MANAGER("CONFIG_USB_SW_SUNXI_USB0_HOST_ONLY\n");
+#elif defined(CONFIG_USB_SW_SUNXI_USB0_OTG)
+	DMSG_INFO_MANAGER("CONFIG_USB_SW_SUNXI_USB0_OTG\n");
+#else
+	DMSG_INFO_MANAGER("CONFIG_USB_SW_SUNXI_USB0_NULL\n");
+	return 0;
+#endif
+
+	memset(&g_usb_cfg, 0, sizeof(struct usb_cfg));
+	g_usb_cfg.usb_global_enable = 1;
+	g_usb_cfg.usbc_num = 1;
+
+	ret = get_usb_cfg(&g_usb_cfg);
+	if(ret != 0){
+		DMSG_PANIC("ERR: get_usb_cfg failed\n");
+		return -1;
+	}
+
+	if(g_usb_cfg.port[0].enable == 0){
+		DMSG_PANIC("wrn: usb0 is disable\n");
+		return 0;
+	}
+
+    memset(&usbc, 0, sizeof(bsp_usbc_t));
+   	for(i = 0; i < USBC_MAX_CTL_NUM; i++){
+		usbc.usbc_info[i].num = i;
+
+		switch(i){
+            case 0:
+                usbc.usbc_info[i].base = SW_VA_USB0_IO_BASE;
+            break;
+
+            case 1:
+                usbc.usbc_info[i].base = SW_VA_USB1_IO_BASE;
+            break;
+
+			case 2:
+                usbc.usbc_info[i].base = SW_VA_USB2_IO_BASE;
+            break;
+
+            default:
+                DMSG_PANIC("ERR: unkown cnt(%d)\n", i);
+                usbc.usbc_info[i].base = 0;
+        }
+	}
+	usbc.sram_base = SW_VA_SRAM_IO_BASE;
+	USBC_init(&usbc);
+
+    usbc0_platform_device_init(&g_usb_cfg.port[0]);
+
+#ifdef CONFIG_USB_SW_SUNXI_USB0_OTG
+    if(g_usb_cfg.port[0].port_type == USB_PORT_TYPE_OTG
+       && g_usb_cfg.port[0].detect_type == USB_DETECT_TYPE_VBUS_ID){
+#if defined(CONFIG_ARCH_SUN5I)
+        usb_msg_center_init(&g_usb_cfg);
+#endif
+    	usb_hw_scan_init(&g_usb_cfg);
+
+    	thread_run_flag = 1;
+    	thread_stopped_flag = 0;
+    	th = kthread_create(usb_hardware_scan_thread, &g_usb_cfg, "usb-hardware-scan");
+    	if(IS_ERR(th)){
+    		DMSG_PANIC("ERR: kthread_create failed\n");
+    		return -1;
+    	}
+
+    	wake_up_process(th);
+	}
+#endif
+
+    DMSG_MANAGER_DEBUG("[sw usb]: usb_manager_init end\n");
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     usb_manager_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void __exit usb_manager_exit(void)
+{
+	bsp_usbc_t usbc;
+
+    DMSG_MANAGER_DEBUG("[sw usb]: usb_manager_exit\n");
+
+#if defined(CONFIG_USB_SW_SUNXI_USB0_DEVICE_ONLY)
+	DMSG_INFO("CONFIG_USB_SW_SUNXI_USB0_DEVICE_ONLY\n");
+#elif defined(CONFIG_USB_SW_SUNXI_USB0_HOST_ONLY)
+	DMSG_INFO("CONFIG_USB_SW_SUNXI_USB0_HOST_ONLY\n");
+#elif defined(CONFIG_USB_SW_SUNXI_USB0_OTG)
+	DMSG_INFO("CONFIG_USB_SW_SUNXI_USB0_OTG\n");
+#else
+	DMSG_INFO("CONFIG_USB_SW_SUNXI_USB0_NULL\n");
+	return;
+#endif
+
+	if(g_usb_cfg.port[0].enable == 0){
+		DMSG_PANIC("wrn: usb0 is disable\n");
+		return ;
+	}
+
+    memset(&usbc, 0, sizeof(bsp_usbc_t));
+	USBC_exit(&usbc);
+
+#ifdef CONFIG_USB_SW_SUNXI_USB0_OTG
+    if(g_usb_cfg.port[0].port_type == USB_PORT_TYPE_OTG
+       && g_usb_cfg.port[0].detect_type == USB_DETECT_TYPE_VBUS_ID){
+    	thread_run_flag = 0;
+    	while(!thread_stopped_flag){
+    		DMSG_INFO("waitting for usb_hardware_scan_thread stop\n");
+    		msleep(10);
+    	}
+
+    	usb_hw_scan_exit(&g_usb_cfg);
+    }
+#endif
+
+    usbc0_platform_device_exit(&g_usb_cfg.port[0]);
+
+    return;
+}
+
+//module_init(usb_manager_init);
+fs_initcall(usb_manager_init);
+module_exit(usb_manager_exit);
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_manager.h b/drivers/usb/sunxi_usb/manager/usb_manager.h
new file mode 100644
index 0000000..b903a5a
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_manager.h
@@ -0,0 +1,35 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_manager.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __USB_MANAGER_H__
+#define  __USB_MANAGER_H__
+
+#if	0
+    #define DMSG_DBG_MANAGER     		DMSG_PRINT
+#else
+    #define DMSG_DBG_MANAGER(...)
+#endif
+
+#endif   //__USB_MANAGER_H__
+
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_msg_center.c b/drivers/usb/sunxi_usb/manager/usb_msg_center.c
new file mode 100644
index 0000000..9451beb
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_msg_center.c
@@ -0,0 +1,493 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_msg_center.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <mach/irqs.h>
+
+#include  "../include/sw_usb_config.h"
+#include  "usb_manager.h"
+#include  "usbc_platform.h"
+#include  "usb_hw_scan.h"
+#include  "usb_msg_center.h"
+
+
+static struct usb_msg_center_info g_center_info;
+
+
+void print_usb_msg(struct usb_msg_center_info * center_info)
+{
+	DMSG_DBG_MANAGER("hw_insmod_host   = %d\n", center_info->msg.hw_insmod_host);
+	DMSG_DBG_MANAGER("hw_rmmod_host    = %d\n", center_info->msg.hw_rmmod_host);
+	DMSG_DBG_MANAGER("hw_insmod_device = %d\n", center_info->msg.hw_insmod_device);
+	DMSG_DBG_MANAGER("hw_rmmod_device  = %d\n", center_info->msg.hw_rmmod_device);
+}
+
+enum usb_role get_usb_role(void)
+{
+	return g_center_info.role;
+}
+
+static void set_usb_role(struct usb_msg_center_info *center_info, enum usb_role role)
+{
+	center_info->role = role;
+
+	return;
+}
+
+/*
+void app_insmod_usb_host(void)
+{
+	g_center_info.msg.app_insmod_host = 1;
+}
+
+void app_rmmod_usb_host(void)
+{
+	g_center_info.msg.app_rmmod_host = 1;
+}
+
+void app_insmod_usb_device(void)
+{
+	g_center_info.msg.app_insmod_device = 1;
+}
+
+void app_rmmod_usb_device(void)
+{
+	g_center_info.msg.app_rmmod_device = 1;
+}
+*/
+
+void hw_insmod_usb_host(void)
+{
+	g_center_info.msg.hw_insmod_host = 1;
+}
+
+void hw_rmmod_usb_host(void)
+{
+	g_center_info.msg.hw_rmmod_host = 1;
+}
+
+void hw_insmod_usb_device(void)
+{
+	g_center_info.msg.hw_insmod_device = 1;
+}
+
+void hw_rmmod_usb_device(void)
+{
+	g_center_info.msg.hw_rmmod_device = 1;
+}
+
+/*
+*******************************************************************************
+*                     modify_msg
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void modify_msg(struct usb_msg *msg)
+{
+	if(msg->hw_insmod_host && msg->hw_rmmod_host){
+		msg->hw_insmod_host = 0;
+		msg->hw_rmmod_host  = 0;
+	}
+
+	if(msg->hw_insmod_device && msg->hw_rmmod_device){
+		msg->hw_insmod_device = 0;
+		msg->hw_rmmod_device  = 0;
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     insmod_host_driver
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void insmod_host_driver(struct usb_msg_center_info *center_info)
+{
+	DMSG_INFO("\n\ninsmod_host_driver\n\n");
+
+	set_usb_role(center_info, USB_ROLE_HOST);
+	sw_usb_host0_enable();
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     rmmod_host_driver
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void rmmod_host_driver(struct usb_msg_center_info *center_info)
+{
+    int ret = 0;
+
+	DMSG_INFO("\n\nrmmod_host_driver\n\n");
+
+	ret = sw_usb_host0_disable();
+	if(ret != 0){
+    	DMSG_PANIC("err: disable hcd0 failed\n");
+    	return;
+	}
+
+	set_usb_role(center_info, USB_ROLE_NULL);
+
+	return;
+}
+/*
+*******************************************************************************
+*                     insmod_device_driver
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+
+static void insmod_device_driver(struct usb_msg_center_info *center_info)
+{
+	DMSG_INFO("\n\ninsmod_device_driver\n\n");
+#if 0
+	axp_usbvol();
+	axp_usbcur();
+#endif
+
+	set_usb_role(center_info, USB_ROLE_DEVICE);
+	sw_usb_device_enable();
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     rmmod_device_driver
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void rmmod_device_driver(struct usb_msg_center_info *center_info)
+{
+	DMSG_INFO("\n\nrmmod_device_driver\n\n");
+
+	set_usb_role(center_info, USB_ROLE_NULL);
+	sw_usb_device_disable();
+#if 0
+	axp_usbcur_restore();
+	axp_usbvol_restore();
+#endif
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     do_usb_role_null
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void do_usb_role_null(struct usb_msg_center_info *center_info)
+{
+	if(center_info->msg.hw_insmod_host){
+		insmod_host_driver(center_info);
+		center_info->msg.hw_insmod_host = 0;
+
+		goto end;
+	}
+
+	if(center_info->msg.hw_insmod_device){
+		insmod_device_driver(center_info);
+		center_info->msg.hw_insmod_device = 0;
+
+		goto end;
+	}
+
+end:
+	memset(&center_info->msg, 0, sizeof(struct usb_msg));
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     do_usb_role_host
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void do_usb_role_host(struct usb_msg_center_info *center_info)
+{
+	if(center_info->msg.hw_rmmod_host){
+		rmmod_host_driver(center_info);
+		center_info->msg.hw_rmmod_host = 0;
+
+		goto end;
+	}
+
+end:
+	memset(&center_info->msg, 0, sizeof(struct usb_msg));
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     do_usb_role_device
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void do_usb_role_device(struct usb_msg_center_info *center_info)
+{
+	if(center_info->msg.hw_rmmod_device){
+		rmmod_device_driver(center_info);
+		center_info->msg.hw_rmmod_device = 0;
+
+		goto end;
+	}
+
+end:
+	memset(&center_info->msg, 0, sizeof(struct usb_msg));
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     usb_msg_center
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void usb_msg_center(struct usb_cfg *cfg)
+{
+	enum usb_role role = USB_ROLE_NULL;
+	struct usb_msg_center_info * center_info = &g_center_info;
+
+	/* receive massage */
+	print_usb_msg(center_info);
+
+	modify_msg(&center_info->msg);
+
+	/* execute cmd */
+	role = get_usb_role();
+
+	DMSG_DBG_MANAGER("role=%d\n", get_usb_role());
+
+	switch(role){
+		case USB_ROLE_NULL:
+			do_usb_role_null(center_info);
+		break;
+
+		case USB_ROLE_HOST:
+			do_usb_role_host(center_info);
+		break;
+
+		case USB_ROLE_DEVICE:
+			do_usb_role_device(center_info);
+		break;
+
+		default:
+			DMSG_PANIC("ERR: unkown role(%x)\n", role);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     usb_msg_center_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+s32 usb_msg_center_init(struct usb_cfg *cfg)
+{
+	struct usb_msg_center_info *center_info = &g_center_info;
+
+	memset(center_info, 0, sizeof(struct usb_msg_center_info));
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     usb_msg_center_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+s32 usb_msg_center_exit(struct usb_cfg *cfg)
+{
+	struct usb_msg_center_info *center_info = &g_center_info;
+
+	memset(center_info, 0, sizeof(struct usb_msg_center_info));
+
+	return 0;
+}
+
diff --git a/drivers/usb/sunxi_usb/manager/usb_msg_center.h b/drivers/usb/sunxi_usb/manager/usb_msg_center.h
new file mode 100644
index 0000000..3be91a5
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usb_msg_center.h
@@ -0,0 +1,73 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usb_msg_center.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __USB_MSG_CENTER_H__
+#define  __USB_MSG_CENTER_H__
+
+/* usb role mode */
+typedef enum usb_role{
+	USB_ROLE_NULL = 0,
+	USB_ROLE_HOST,
+	USB_ROLE_DEVICE,
+}usb_role_t;
+
+typedef struct usb_msg{
+	u8  app_drv_null;       //
+	u8  app_insmod_host;
+	u8  app_rmmod_host;
+	u8  app_insmod_device;
+	u8  app_rmmod_device;
+
+	u8  hw_insmod_host;
+	u8  hw_rmmod_host;
+	u8  hw_insmod_device;
+	u8  hw_rmmod_device;
+}usb_msg_t;
+
+typedef struct usb_msg_center_info{
+	struct usb_cfg *cfg;
+
+	struct usb_msg msg;
+	enum usb_role role;
+
+	u32 skip;                 	//
+	                          	//
+}usb_msg_center_info_t;
+
+//----------------------------------------------------------
+//
+//----------------------------------------------------------
+void hw_insmod_usb_host(void);
+void hw_rmmod_usb_host(void);
+void hw_insmod_usb_device(void);
+void hw_rmmod_usb_device(void);
+
+enum usb_role get_usb_role(void);
+void usb_msg_center(struct usb_cfg *cfg);
+
+s32 usb_msg_center_init(struct usb_cfg *cfg);
+s32 usb_msg_center_exit(struct usb_cfg *cfg);
+
+#endif   //__USB_MSG_CENTER_H__
+
+
diff --git a/drivers/usb/sunxi_usb/manager/usbc0_platform.c b/drivers/usb/sunxi_usb/manager/usbc0_platform.c
new file mode 100644
index 0000000..6933e54
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usbc0_platform.c
@@ -0,0 +1,207 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usbc0_platform.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <mach/irqs.h>
+
+#include  "../include/sw_usb_config.h"
+
+//---------------------------------------------------------------
+//  device 
+//---------------------------------------------------------------
+static struct sw_udc_mach_info sw_udc_cfg;
+
+//static u64 sw_udc_dmamask = 0xffffffffUL;
+
+static struct platform_device sw_udc_device = {
+	.name				= "sw_usb_udc",
+	.id					= -1,
+
+	.dev = {
+//		.dma_mask			= &sw_udc_dmamask,
+//		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &sw_udc_cfg,
+	},
+};
+
+//---------------------------------------------------------------
+//  host 
+//---------------------------------------------------------------
+static struct sw_hcd_eps_bits sw_hcd_eps[] = {
+	{ "ep1_tx", 8, },
+	{ "ep1_rx", 8, },
+	{ "ep2_tx", 8, },
+	{ "ep2_rx", 8, },
+	{ "ep3_tx", 8, },
+	{ "ep3_rx", 8, },
+	{ "ep4_tx", 8, },
+	{ "ep4_rx", 8, },
+	{ "ep5_tx", 8, },
+	{ "ep5_rx", 8, },
+};
+
+static struct sw_hcd_config sw_hcd_config = {
+	.multipoint		= 1,
+	.dyn_fifo		= 1,
+	.soft_con		= 1,
+	.dma			= 0,
+
+	.num_eps		= USBC_MAX_EP_NUM,
+	.dma_channels	= 0,
+	.ram_size		= USBC0_MAX_FIFO_SIZE,
+	.eps_bits	    = sw_hcd_eps,
+};
+
+static struct sw_hcd_platform_data sw_hcd_plat = {
+	.mode		= SW_HCD_HOST,
+	.config		= &sw_hcd_config,
+};
+
+//static u64 sw_hcd_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device sw_hcd_device = {
+	.name				= "sw_hcd_host0",
+	.id					= -1,
+
+	.dev = {
+//		.dma_mask			= &sw_hcd_dmamask,
+//		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &sw_hcd_plat,
+	},
+};
+
+/*
+*******************************************************************************
+*                     usbc0_platform_device_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 usbc0_platform_device_init(struct usb_port_info *port_info)
+{
+    /* device */
+    sw_udc_cfg.port_info = port_info;
+    sw_udc_cfg.usbc_base = SW_VA_USB0_IO_BASE;
+
+    /* host */
+    sw_hcd_config.port_info = port_info;
+
+    switch(port_info->port_type){
+        case USB_PORT_TYPE_DEVICE:
+            platform_device_register(&sw_udc_device);
+            device_enable_async_suspend(&sw_udc_device.dev);
+        break;
+
+        case USB_PORT_TYPE_HOST:
+            platform_device_register(&sw_hcd_device);
+            device_enable_async_suspend(&sw_hcd_device.dev);
+        break;
+
+        case USB_PORT_TYPE_OTG:
+            platform_device_register(&sw_udc_device);
+            device_enable_async_suspend(&sw_udc_device.dev);
+            platform_device_register(&sw_hcd_device);
+            device_enable_async_suspend(&sw_hcd_device.dev);
+        break;
+
+        default:
+            DMSG_PANIC("ERR: unkown port_type(%d)\n", port_info->port_type);
+    }
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     usbc0_platform_device_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 usbc0_platform_device_exit(struct usb_port_info *info)
+{
+    switch(info->port_type){
+        case USB_PORT_TYPE_DEVICE:
+            platform_device_unregister(&sw_udc_device);
+        break;
+
+        case USB_PORT_TYPE_HOST:
+            platform_device_unregister(&sw_hcd_device);
+        break;
+
+        case USB_PORT_TYPE_OTG:
+            platform_device_unregister(&sw_udc_device);
+            platform_device_unregister(&sw_hcd_device);
+        break;
+
+        default:
+            DMSG_PANIC("ERR: unkown port_type(%d)\n", info->port_type);
+    }
+
+    return 0;
+}
+
+
diff --git a/drivers/usb/sunxi_usb/manager/usbc_platform.h b/drivers/usb/sunxi_usb/manager/usbc_platform.h
new file mode 100644
index 0000000..d4439e0
--- /dev/null
+++ b/drivers/usb/sunxi_usb/manager/usbc_platform.h
@@ -0,0 +1,32 @@
+/*
+ * drivers/usb/sunxi_usb/manager/usbc_platform.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __USBC_PLATFORM_H__
+#define  __USBC_PLATFORM_H__
+
+__s32 usbc0_platform_device_init(struct usb_port_info *port_info);
+__s32 usbc0_platform_device_exit(struct usb_port_info *port_info);
+
+
+#endif   //__USBC_PLATFORM_H__
+
diff --git a/drivers/usb/sunxi_usb/misc/sw_usb_debug.c b/drivers/usb/sunxi_usb/misc/sw_usb_debug.c
new file mode 100644
index 0000000..91239e1
--- /dev/null
+++ b/drivers/usb/sunxi_usb/misc/sw_usb_debug.c
@@ -0,0 +1,171 @@
+/*
+ * drivers/usb/sunxi_usb/misc/sw_usb_debug.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include  "../include/sw_usb_config.h"
+
+/*
+*******************************************************************************
+*                     print_usb_reg_by_ep
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void print_usb_reg_by_ep(spinlock_t *lock, __u32 usbc_base, __s32 ep_index, char *str)
+{
+//	__u32 i = 0;
+	__u32 old_ep_index = 0;
+	unsigned long flags = 0;
+
+	if(lock){
+		spin_lock_irqsave(lock, flags);
+	}
+
+    DMSG_INFO("\n");
+    DMSG_INFO("--------------------------ep%d: %s--------------------------\n", ep_index, str);
+
+	if(ep_index >= 0){
+		old_ep_index = USBC_Readw(usbc_base + USBC_REG_o_EPIND);
+		USBC_Writew(ep_index, (usbc_base + USBC_REG_o_EPIND));
+		DMSG_INFO("old_ep_index = %d, ep_index = %d\n", old_ep_index, ep_index);
+	}
+
+    DMSG_INFO("USBC_REG_o_FADDR         = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_FADDR));
+    DMSG_INFO("USBC_REG_o_PCTL          = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_PCTL));
+    DMSG_INFO("USBC_REG_o_INTTx         = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_INTTx));
+    DMSG_INFO("USBC_REG_o_INTRx         = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_INTRx));
+    DMSG_INFO("USBC_REG_o_INTTxE        = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_INTTxE));
+    DMSG_INFO("USBC_REG_o_INTRxE        = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_INTRxE));
+    DMSG_INFO("USBC_REG_o_INTUSB        = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_INTUSB));
+    DMSG_INFO("USBC_REG_o_INTUSBE       = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_INTUSBE));
+    DMSG_INFO("USBC_REG_o_EPIND         = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_EPIND));
+    DMSG_INFO("USBC_REG_o_TXMAXP        = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_TXMAXP));
+    DMSG_INFO("USBC_REG_o_CSR0          = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_CSR0));
+    DMSG_INFO("USBC_REG_o_TXCSR         = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_TXCSR));
+    DMSG_INFO("USBC_REG_o_RXMAXP        = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_RXMAXP));
+    DMSG_INFO("USBC_REG_o_RXCSR         = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_RXCSR));
+
+    DMSG_INFO("USBC_REG_o_COUNT0        = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_COUNT0));
+    DMSG_INFO("USBC_REG_o_RXCOUNT       = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_RXCOUNT));
+    DMSG_INFO("USBC_REG_o_TXTYPE        = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_TXTYPE));
+    DMSG_INFO("USBC_REG_o_NAKLIMIT0     = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_NAKLIMIT0));
+    DMSG_INFO("USBC_REG_o_TXINTERVAL    = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_TXINTERVAL));
+    DMSG_INFO("USBC_REG_o_RXTYPE        = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_RXTYPE));
+    DMSG_INFO("USBC_REG_o_RXINTERVAL    = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_RXINTERVAL));
+    DMSG_INFO("USBC_REG_o_CONFIGDATA    = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_CONFIGDATA));
+
+    DMSG_INFO("USBC_REG_o_DEVCTL        = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_DEVCTL));
+    DMSG_INFO("USBC_REG_o_TXFIFOSZ      = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_TXFIFOSZ));
+    DMSG_INFO("USBC_REG_o_RXFIFOSZ      = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_RXFIFOSZ));
+    DMSG_INFO("USBC_REG_o_TXFIFOAD      = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_TXFIFOAD));
+    DMSG_INFO("USBC_REG_o_RXFIFOAD      = 0x%x\n", USBC_Readw(usbc_base + USBC_REG_o_RXFIFOAD));
+    DMSG_INFO("USBC_REG_o_VEND0         = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_VEND0));
+    DMSG_INFO("USBC_REG_o_VEND1         = 0x%x\n", USBC_Readb(usbc_base + USBC_REG_o_VEND1));
+
+	DMSG_INFO("TXFADDRx(%d)             = 0x%x\n", ep_index, USBC_Readb(usbc_base + USBC_REG_o_TXFADDRx));
+	DMSG_INFO("TXHADDRx(%d              = 0x%x\n", ep_index, USBC_Readb(usbc_base + USBC_REG_o_TXHADDRx));
+	DMSG_INFO("TXHPORTx(%d)             = 0x%x\n", ep_index, USBC_Readb(usbc_base + USBC_REG_o_TXHPORTx));
+	DMSG_INFO("RXFADDRx(%d)             = 0x%x\n", ep_index, USBC_Readb(usbc_base + USBC_REG_o_RXFADDRx));
+	DMSG_INFO("RXHADDRx(%d)             = 0x%x\n", ep_index, USBC_Readb(usbc_base + USBC_REG_o_RXHADDRx));
+	DMSG_INFO("RXHPORTx(%d)             = 0x%x\n", ep_index, USBC_Readb(usbc_base + USBC_REG_o_RXHPORTx));
+	DMSG_INFO("RPCOUNTx(%d)             = 0x%x\n", ep_index, (u32)USBC_Readl(usbc_base + USBC_REG_o_RPCOUNT));
+
+    DMSG_INFO("USBC_REG_o_ISCR          = 0x%x\n", (u32)USBC_Readl(usbc_base + USBC_REG_o_ISCR));
+    DMSG_INFO("USBC_REG_o_PHYCTL        = 0x%x\n", (u32)USBC_Readl(usbc_base + USBC_REG_o_PHYCTL));
+    DMSG_INFO("USBC_REG_o_PHYBIST       = 0x%x\n", (u32)USBC_Readl(usbc_base + USBC_REG_o_PHYBIST));
+
+	if(ep_index >= 0){
+		USBC_Writew(old_ep_index, (usbc_base + USBC_REG_o_EPIND));
+	}
+
+	DMSG_INFO("---------------------------------------------------------------------------\n");
+	DMSG_INFO("\n");
+
+	if(lock){
+		spin_unlock_irqrestore(lock, flags);
+	}
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     print_all_usb_reg
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void print_all_usb_reg(spinlock_t *lock, __u32 usbc_base, __s32 ep_start, __u32 ep_end, char *str)
+{
+	__u32 i = 0;
+	__u32 old_ep_index = 0;
+	unsigned long flags = 0;
+
+	if(lock){
+		spin_lock_irqsave(lock, flags);
+	}
+
+    DMSG_INFO("\n");
+    DMSG_INFO("-------------------print_all_usb_reg: %s----------------\n", str);
+
+	old_ep_index = USBC_Readw(usbc_base + USBC_REG_o_EPIND);
+
+	for(i = ep_start; i <= ep_end; i++){
+		print_usb_reg_by_ep(lock, usbc_base, i, str);
+	}
+
+	USBC_Writew(old_ep_index, (usbc_base + USBC_REG_o_EPIND));
+
+	DMSG_INFO("---------------------------------------------------------------------------\n");
+	DMSG_INFO("\n");
+
+	if(lock){
+		spin_unlock_irqrestore(lock, flags);
+	}
+
+    return;
+}
+
+
diff --git a/drivers/usb/sunxi_usb/udc/sw_udc.c b/drivers/usb/sunxi_usb/udc/sw_udc.c
new file mode 100644
index 0000000..1e054a5
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sw_udc.c
@@ -0,0 +1,3866 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sw_udc.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <mach/irqs.h>
+
+#include  "sw_udc_config.h"
+#include  "sw_udc_board.h"
+
+#include  "sw_udc_debug.h"
+#include  "sw_udc_dma.h"
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+#define DRIVER_DESC	    "SoftWinner USB Device Controller"
+#define DRIVER_VERSION	"20080411"
+#define DRIVER_AUTHOR	"SoftWinner USB Developer"
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+static const char		gadget_name[] = "sw_usb_udc";
+static const char		driver_desc[] = DRIVER_DESC;
+
+static struct sw_udc	*the_controller = NULL;
+static u32              usbd_port_no = 0;
+static sw_udc_io_t      g_sw_udc_io;
+static u32 usb_connect = 0;
+static u32 is_controller_alive = 0;
+static u8 is_udc_enable = 0; /* is udc enable by gadget? */
+
+#ifdef CONFIG_USB_SW_SUNXI_USB0_OTG
+static struct platform_device *g_udc_pdev = NULL;
+#endif
+
+static u8 crq_bRequest = 0;
+static const unsigned char TestPkt[54] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
+		                                 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xEE, 0xEE, 0xEE,
+		                                 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
+		                                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF,
+		                                 0xEF, 0xF7, 0xFB, 0xFD, 0xFC, 0x7E, 0xBF, 0xDF, 0xEF, 0xF7,
+		                                 0xFB, 0xFD, 0x7E, 0x00};
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+
+/*DMA:
+ * 1DMA
+ * 2ep0
+ * 3
+ */
+#define  is_sw_udc_dma_capable(len, maxpacket, epnum)		(is_udc_support_dma() \
+	                                                 	&& (len > maxpacket) \
+	                                                 	&& epnum)
+
+
+static void cfg_udc_command(enum sw_udc_cmd_e cmd);
+static void cfg_vbus_draw(unsigned int ma);
+
+static __u32 is_peripheral_active(void)
+{
+	return is_controller_alive;
+}
+
+/*
+**********************************************************
+*    USB
+**********************************************************
+*/
+static void disable_irq_udc(struct sw_udc *dev)
+{
+//    disable_irq(dev->irq_no);
+}
+
+/*
+**********************************************************
+*    USB
+**********************************************************
+*/
+static void enable_irq_udc(struct sw_udc *dev)
+{
+//    enable_irq(dev->irq_no);
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_udc_done
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_done(struct sw_udc_ep *ep,
+		struct sw_udc_request *req, int status)
+{
+	unsigned halted = ep->halted;
+
+	DMSG_TEST("d: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d)\n\n",
+		         ep, ep->num,
+		         req, &(req->req), req->req.length, req->req.actual);
+
+	//DMSG_INFO("d: (0x%p, %d, %d)\n\n", &(req->req), req->req.length, req->req.actual);
+	//DMSG_INFO("d\n\n");
+
+	list_del_init(&req->queue);
+
+	if (likely (req->req.status == -EINPROGRESS))
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	ep->halted = 1;
+	spin_unlock(&ep->dev->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->dev->lock);
+	ep->halted = halted;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_nuke
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_nuke(struct sw_udc *udc, struct sw_udc_ep *ep, int status)
+{
+	/* Sanity check */
+	if (&ep->queue == NULL)
+		return;
+
+	while (!list_empty (&ep->queue)) {
+		struct sw_udc_request *req;
+		req = list_entry (ep->queue.next, struct sw_udc_request,
+				queue);
+		DMSG_INFO("nuke: ep num is %d\n", ep->num);
+		sw_udc_done(ep, req, status);
+	}
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_clear_ep_state
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static inline void sw_udc_clear_ep_state(struct sw_udc *dev)
+{
+	unsigned i = 0;
+
+	/* hardware SET_{CONFIGURATION,INTERFACE} automagic resets endpoint
+	 * fifos, and pending transactions mustn't be continued in any case.
+	 */
+
+	for (i = 1; i < SW_UDC_ENDPOINTS; i++){
+		sw_udc_nuke(dev, &dev->ep[i], -ECONNABORTED);
+	}
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_fifo_count_out
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static inline int sw_udc_fifo_count_out(__hdle usb_bsp_hdle, __u8 ep_index)
+{
+    if(ep_index){
+        return USBC_ReadLenFromFifo(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+    }else{
+        return USBC_ReadLenFromFifo(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+    }
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_write_packet
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static inline int sw_udc_write_packet(int fifo,
+		struct sw_udc_request *req,
+		unsigned max)
+{
+	unsigned len = min(req->req.length - req->req.actual, max);
+	u8 *buf = req->req.buf + req->req.actual;
+
+	prefetch(buf);
+
+	DMSG_DBG_UDC("W: req.actual(%d), req.length(%d), len(%d), total(%d)\n",
+		         req->req.actual, req->req.length, len, req->req.actual + len);
+
+	req->req.actual += len;
+
+	udelay(5);
+	USBC_WritePacket(g_sw_udc_io.usb_bsp_hdle, fifo, len, buf);
+
+	return len;
+}
+
+/*
+*******************************************************************************
+*                     pio_write_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int pio_write_fifo(struct sw_udc_ep *ep, struct sw_udc_request *req)
+{
+	unsigned    count       = 0;
+	int		    is_last     = 0;
+	u32		    idx         = 0;
+	int		    fifo_reg    = 0;
+	__s32 		ret 		= 0;
+	u8		old_ep_index 	= 0;
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+    /* select ep */
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, idx);
+
+    /* select fifo */
+    fifo_reg = USBC_SelectFIFO(g_sw_udc_io.usb_bsp_hdle, idx);
+
+	count = sw_udc_write_packet(fifo_reg, req, ep->ep.maxpacket);
+
+	/* last packet is often short (sometimes a zlp) */
+	if(count != ep->ep.maxpacket){
+		is_last = 1;
+	}else if (req->req.length != req->req.actual || req->req.zero){
+		is_last = 0;
+	}else{
+	    is_last = 2;
+	}
+
+	DMSG_TEST("pw: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d), cnt(%d, %d)\n",
+		         ep, ep->num,
+		         req, &(req->req), req->req.length, req->req.actual,
+		         count, is_last);
+
+	if(idx){  //ep1~4
+		ret = USBC_Dev_WriteDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX, is_last);
+		if(ret != 0){
+			DMSG_PANIC("ERR: USBC_Dev_WriteDataStatus, failed\n");
+		    req->req.status = -EOVERFLOW;
+		}
+	}else{  //ep0
+		ret = USBC_Dev_WriteDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, is_last);
+		if(ret != 0){
+			DMSG_PANIC("ERR: USBC_Dev_WriteDataStatus, failed\n");
+			req->req.status = -EOVERFLOW;
+		}
+	}
+
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+	if(is_last){
+		if (!idx) {  /* ep0 */
+			ep->dev->ep0state=EP0_IDLE;
+			sw_udc_done(ep, req, 0);
+		}
+
+		is_last = 1;
+	}
+
+	return is_last;
+}
+
+/*
+*******************************************************************************
+*                     dma_write_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int dma_write_fifo(struct sw_udc_ep *ep, struct sw_udc_request *req)
+{
+	u32   	left_len 	= 0;
+	u32		idx         = 0;
+	int		fifo_reg    = 0;
+	u8		old_ep_index 	= 0;
+
+	DMSG_TEST("dw: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d)\n",
+		         ep, ep->num,
+		         req, &(req->req), req->req.length, req->req.actual);
+
+	if(ep->dma_working){
+/*
+		DMSG_PANIC("ERR: dma is busy, write fifo. ep(0x%p, %d), req(0x%p, 0x%p, 0x%x, %d, %d)\n\n",
+						ep, ep->num,
+						req, &(req->req), (u32)req->req.buf, req->req.length, req->req.actual);
+*/
+		return 0;
+	}
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+    /* select ep */
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, idx);
+
+    /* select fifo */
+    fifo_reg = USBC_SelectFIFO(g_sw_udc_io.usb_bsp_hdle, idx);
+
+    /* auto_set, tx_mode, dma_tx_en, mode1 */
+	USBC_Dev_ConfigEpDma(ep->dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_TX);
+
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+	/*  */
+	left_len = req->req.length - req->req.actual;
+    left_len = left_len - (left_len % ep->ep.maxpacket);
+
+	ep->dma_working	= 1;
+	ep->dma_transfer_len = left_len;
+
+	sw_udc_dma_set_config(ep, req, (__u32)req->req.buf, left_len);
+	sw_udc_dma_start(ep, fifo_reg, (__u32)req->req.buf, left_len);
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_write_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    0 = still running, 1 = completed, negative = errno
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_write_fifo(struct sw_udc_ep *ep, struct sw_udc_request *req)
+{
+	if(is_sw_udc_dma_capable((req->req.length - req->req.actual), ep->ep.maxpacket, ep->num)){
+		return dma_write_fifo(ep, req);
+	}else{
+		return pio_write_fifo(ep, req);
+	}
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_read_packet
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static inline int sw_udc_read_packet(int fifo, u8 *buf,
+		struct sw_udc_request *req, unsigned avail)
+{
+	unsigned len = 0;
+
+	len = min(req->req.length - req->req.actual, avail);
+	req->req.actual += len;
+
+	DMSG_DBG_UDC("R: req.actual(%d), req.length(%d), len(%d), total(%d)\n",
+		         req->req.actual, req->req.length, len, req->req.actual + len);
+
+	USBC_ReadPacket(g_sw_udc_io.usb_bsp_hdle, fifo, len, buf);
+
+	return len;
+}
+
+/*
+*******************************************************************************
+*                     pio_read_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    0 = still running, 1 = completed, negative = errno
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int pio_read_fifo(struct sw_udc_ep *ep, struct sw_udc_request *req)
+{
+	u8			*buf 		= NULL;
+	unsigned	bufferspace = 0;
+	int			is_last		= 1;
+	unsigned	avail 		= 0;
+	int			fifo_count 	= 0;
+	u32			idx 		= 0;
+	int			fifo_reg 	= 0;
+	__s32 		ret 		= 0;
+	u8		old_ep_index 	= 0;
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+    /* select fifo */
+    fifo_reg = USBC_SelectFIFO(g_sw_udc_io.usb_bsp_hdle, idx);
+
+	if(!req->req.length){
+	    DMSG_PANIC("ERR: req->req.length == 0\n");
+		return 1;
+    }
+
+	buf = req->req.buf + req->req.actual;
+	bufferspace = req->req.length - req->req.actual;
+	if (!bufferspace) {
+		DMSG_PANIC("ERR: buffer full!\n");
+		return -1;
+	}
+
+    /* select ep */
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, idx);
+
+	fifo_count = sw_udc_fifo_count_out(g_sw_udc_io.usb_bsp_hdle, idx);
+	if(fifo_count > ep->ep.maxpacket){
+		avail = ep->ep.maxpacket;
+	}else{
+		avail = fifo_count;
+    }
+
+	fifo_count = sw_udc_read_packet(fifo_reg, buf, req, avail);
+
+	/* checking this with ep0 is not accurate as we already
+	 * read a control request
+	 **/
+	if (idx != 0 && fifo_count < ep->ep.maxpacket) {
+		is_last = 1;
+		/* overflowed this request?  flush extra data */
+		if (fifo_count != avail)
+			req->req.status = -EOVERFLOW;
+	} else {
+		is_last = (req->req.length <= req->req.actual) ? 1 : 0;
+	}
+
+	DMSG_TEST("pr: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d), cnt(%d, %d)\n",
+		         ep, ep->num,
+		         req, &(req->req), req->req.length, req->req.actual,
+		         fifo_count, is_last);
+
+    if (idx){
+		ret = USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX, is_last);
+		if(ret != 0){
+			DMSG_PANIC("ERR: pio_read_fifo: USBC_Dev_WriteDataStatus, failed\n");
+			req->req.status = -EOVERFLOW;
+		}
+    }else{
+		ret = USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, is_last);
+		if(ret != 0){
+			DMSG_PANIC("ERR: pio_read_fifo: USBC_Dev_WriteDataStatus, failed\n");
+			req->req.status = -EOVERFLOW;
+		}
+    }
+
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+	if(is_last){
+		if(!idx){
+			ep->dev->ep0state = EP0_IDLE;
+		}
+
+        sw_udc_done(ep, req, 0);
+        is_last = 1;
+	}
+
+	return is_last;
+}
+
+/*
+*******************************************************************************
+*                     dma_read_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int dma_read_fifo(struct sw_udc_ep *ep, struct sw_udc_request *req)
+{
+	u32   	left_len 	= 0;
+	u32		idx         = 0;
+	int		fifo_reg    = 0;
+	u8		old_ep_index 	= 0;
+
+	DMSG_TEST("dr: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d)\n",
+		         ep, ep->num,
+		         req, &(req->req), req->req.length, req->req.actual);
+
+	if(ep->dma_working){
+/*
+		DMSG_PANIC("ERR: dma is busy, read fifo. ep(0x%p, %d), req(0x%p, 0x%p, 0x%x, %d, %d)\n\n",
+						ep, ep->num,
+						req, &(req->req), (u32)req->req.buf, req->req.length, req->req.actual);
+*/
+		return 0;
+	}
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+    /* select ep */
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, idx);
+
+    /* select fifo */
+    fifo_reg = USBC_SelectFIFO(g_sw_udc_io.usb_bsp_hdle, idx);
+
+    /* auto_set, tx_mode, dma_tx_en, mode1 */
+	USBC_Dev_ConfigEpDma(ep->dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+	/*  */
+	left_len = req->req.length - req->req.actual;
+    left_len = left_len - (left_len % ep->ep.maxpacket);
+
+	ep->dma_working	= 1;
+	ep->dma_transfer_len = left_len;
+	sw_udc_dma_set_config(ep, req, (__u32)req->req.buf, left_len);
+	sw_udc_dma_start(ep, fifo_reg, (__u32)req->req.buf, left_len);
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_read_fifo
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    0 = still running, 1 = completed, negative = errno
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_read_fifo(struct sw_udc_ep *ep, struct sw_udc_request *req)
+{
+	if(is_sw_udc_dma_capable((req->req.length - req->req.actual), ep->ep.maxpacket, ep->num)){
+		return dma_read_fifo(ep, req);
+	}else{
+		return pio_read_fifo(ep, req);
+	}
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_read_fifo_crq
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_read_fifo_crq(struct usb_ctrlrequest *crq)
+{
+	u32 fifo_count  = 0;
+	u32 i           = 0;
+    u8  *pOut       = (u8 *) crq;
+	u32 fifo        = 0;
+
+    fifo = USBC_SelectFIFO(g_sw_udc_io.usb_bsp_hdle, 0);
+    fifo_count = USBC_ReadLenFromFifo(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+
+	if(fifo_count != 8){
+		i = 0;
+
+		while(i < 16 && (fifo_count != 8) ){
+			fifo_count = USBC_ReadLenFromFifo(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+			i++;
+		}
+
+		if(i >= 16){
+			DMSG_PANIC("ERR: get ep0 fifo len failed\n");
+		}
+	}
+
+    return USBC_ReadPacket(g_sw_udc_io.usb_bsp_hdle, fifo, fifo_count, pOut);
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_get_status
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_get_status(struct sw_udc *dev, struct usb_ctrlrequest *crq)
+{
+	u16 status  = 0;
+	u8 	buf[8];
+	u8  ep_num  = crq->wIndex & 0x7F;
+	u8  is_in   = crq->wIndex & USB_DIR_IN;
+	u32 fifo = 0;
+
+	switch (crq->bRequestType & USB_RECIP_MASK) {
+    	case USB_RECIP_INTERFACE:
+			buf[0] = 0x00;
+			buf[1] = 0x00;
+    	break;
+
+	    case USB_RECIP_DEVICE:
+		    status = dev->devstatus;
+			buf[0] = 0x01;
+			buf[1] = 0x00;
+		break;
+
+    	case USB_RECIP_ENDPOINT:
+    		if (ep_num > 4 || crq->wLength > 2){
+    			return 1;
+    		}
+
+            USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, ep_num);
+    		if (ep_num == 0) {
+    			status = USBC_Dev_IsEpStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+    		} else {
+    			if (is_in) {
+    				status = USBC_Dev_IsEpStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+    			} else {
+    				status = USBC_Dev_IsEpStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+    			}
+    		}
+    		status = status ? 1 : 0;
+			if (status) {
+				buf[0] = 0x01;
+				buf[1] = 0x00;
+			} else {
+				buf[0] = 0x00;
+				buf[1] = 0x00;
+			}
+		break;
+
+    	default:
+    	return 1;
+	}
+
+	/* Seems to be needed to get it working. ouch :( */
+	udelay(5);
+	USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 0);
+
+	fifo = USBC_SelectFIFO(g_sw_udc_io.usb_bsp_hdle, 0);
+	USBC_WritePacket(g_sw_udc_io.usb_bsp_hdle, fifo, crq->wLength, buf);
+	USBC_Dev_WriteDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+
+	return 0;
+}
+
+static int sw_udc_set_halt(struct usb_ep *_ep, int value);
+
+#if 1
+
+/*
+*******************************************************************************
+*                     sw_udc_handle_ep0_idle
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_handle_ep0_idle(struct sw_udc *dev,
+					struct sw_udc_ep *ep,
+					struct usb_ctrlrequest *crq,
+					u32 ep0csr)
+{
+	int len = 0, ret = 0, tmp = 0;
+
+	/* start control request? */
+	if (!USBC_Dev_IsReadDataReady(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0)){
+	    DMSG_WRN("ERR: data is ready, can not read data.\n");
+		return;
+    }
+
+	sw_udc_nuke(dev, ep, -EPROTO);
+
+	len = sw_udc_read_fifo_crq(crq);
+	if (len != sizeof(*crq)) {
+		DMSG_PANIC("setup begin: fifo READ ERROR"
+			" wanted %d bytes got %d. Stalling out...\n",
+			sizeof(*crq), len);
+
+		USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 0);
+		USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+
+		return;
+	}
+
+	DMSG_DBG_UDC("ep0: bRequest = %d bRequestType %d wLength = %d\n",
+		crq->bRequest, crq->bRequestType, crq->wLength);
+
+	/* cope with automagic for some standard requests. */
+	dev->req_std        = ((crq->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD);
+	dev->req_config     = 0;
+	dev->req_pending    = 1;
+
+    if(dev->req_std){   //standard request
+    	switch (crq->bRequest) {
+        	case USB_REQ_SET_CONFIGURATION:
+        		DMSG_DBG_UDC("USB_REQ_SET_CONFIGURATION ... \n");
+
+        		if (crq->bRequestType == USB_RECIP_DEVICE) {
+        			dev->req_config = 1;
+        		}
+    		break;
+
+        	case USB_REQ_SET_INTERFACE:
+        		DMSG_DBG_UDC("USB_REQ_SET_INTERFACE ... \n");
+
+        		if (crq->bRequestType == USB_RECIP_INTERFACE) {
+        			dev->req_config = 1;
+        		}
+    		break;
+
+        	case USB_REQ_SET_ADDRESS:
+        		DMSG_DBG_UDC("USB_REQ_SET_ADDRESS ... \n");
+
+        		if (crq->bRequestType == USB_RECIP_DEVICE) {
+        			tmp = crq->wValue & 0x7F;
+        			dev->address = tmp;
+
+        			//rxdataendtx_pakect
+    				USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+
+    				dev->ep0state = EP0_END_XFER;
+
+    				crq_bRequest = USB_REQ_SET_ADDRESS;
+
+        			return;
+        		}
+    		break;
+
+        	case USB_REQ_GET_STATUS:
+        		DMSG_DBG_UDC("USB_REQ_GET_STATUS ... \n");
+
+     			if (!sw_udc_get_status(dev, crq)) {
+    				return;
+    			}
+    		break;
+
+    		case USB_REQ_CLEAR_FEATURE:
+    			//--<1>-- host to device
+    			if(x_test_bit(crq->bRequestType, 7)){
+    				DMSG_PANIC("USB_REQ_CLEAR_FEATURE: data is not host to device\n");
+    				break;
+    			}
+
+    			USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+
+    			//--<3>--
+    			if(crq->bRequestType == USB_RECIP_DEVICE){
+    				/* wValue 0-1 */
+    				if(crq->wValue){
+    					dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+    				}else{
+    					int k = 0;
+    					for(k = 0;k < SW_UDC_ENDPOINTS;k++){
+    						sw_udc_set_halt(&dev->ep[k].ep, 0);
+    					}
+    				}
+
+    			}else if(crq->bRequestType == USB_RECIP_INTERFACE){
+    				//--<2>--
+
+    				//
+
+    			}else if(crq->bRequestType == USB_RECIP_ENDPOINT){
+    				//--<3>--ep
+    				//sw_udc_set_halt(&dev->ep[crq->wIndex & 0x7f].ep, 0);
+    				//dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+    				/* wValue 0-1 */
+    				if(crq->wValue){
+    					dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+    				}else{
+    					sw_udc_set_halt(&dev->ep[crq->wIndex & 0x7f].ep, 0);
+    				}
+
+    			}else{
+    				DMSG_PANIC("PANIC : nonsupport set feature request. (%d)\n", crq->bRequestType);
+    				USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+    			}
+
+    			dev->ep0state = EP0_IDLE;
+
+    			return;
+    		//break;
+
+            case USB_REQ_SET_FEATURE:
+                //--<1>-- host to device
+                if(x_test_bit(crq->bRequestType, 7)){
+                    DMSG_PANIC("USB_REQ_SET_FEATURE: data is not host to device\n");
+                    break;
+                }
+
+                //--<3>--
+                if(crq->bRequestType == USB_RECIP_DEVICE){
+                    if((crq->wValue == USB_DEVICE_TEST_MODE) && (crq->wIndex == 0x0400)){
+                        //setup packet
+                        USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+
+                        dev->ep0state = EP0_END_XFER;
+                        crq_bRequest = USB_REQ_SET_FEATURE;
+
+                        return;
+                    }
+
+    				USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+    				dev->devstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+                }else if(crq->bRequestType == USB_RECIP_INTERFACE){
+                    //--<2>--
+                    USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+                    //
+
+                }else if(crq->bRequestType == USB_RECIP_ENDPOINT){
+                    //--<3>--ep
+                    USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+    				sw_udc_set_halt(&dev->ep[crq->wIndex & 0x7f].ep, 1);
+                }else{
+                    DMSG_PANIC("PANIC : nonsupport set feature request. (%d)\n", crq->bRequestType);
+
+                    USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+                    USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+                }
+
+                dev->ep0state = EP0_IDLE;
+
+    			return;
+            //break;
+
+        	default:
+    			/* setupDataEnd */
+    			USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 0);
+        		break;
+    	}
+    }else{
+        USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 0);
+    }
+
+	if(crq->bRequestType & USB_DIR_IN){
+		dev->ep0state = EP0_IN_DATA_PHASE;
+	}else{
+		dev->ep0state = EP0_OUT_DATA_PHASE;
+    }
+
+	spin_unlock(&dev->lock);
+	ret = dev->driver->setup(&dev->gadget, crq);
+	spin_lock(&dev->lock);
+	if (ret < 0) {
+		if (dev->req_config) {
+			DMSG_PANIC("ERR: config change %02x fail %d?\n", crq->bRequest, ret);
+			return;
+		}
+
+		if(ret == -EOPNOTSUPP){
+			DMSG_PANIC("ERR: Operation not supported\n");
+		}else{
+			DMSG_PANIC("ERR: dev->driver->setup failed. (%d)\n", ret);
+        }
+
+		udelay(5);
+
+		USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+		USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+
+		dev->ep0state = EP0_IDLE;
+		/* deferred i/o == no response yet */
+	} else if (dev->req_pending) {
+//		DMSG_PANIC("ERR: dev->req_pending... what now?\n");
+		dev->req_pending=0;
+	}
+
+	if(crq->bRequest == USB_REQ_SET_CONFIGURATION || crq->bRequest == USB_REQ_SET_INTERFACE){
+		//rx_packet
+		USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+	}
+
+	return;
+}
+
+
+#else
+
+/*
+*******************************************************************************
+*                     sw_udc_handle_ep0_idle
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_handle_ep0_idle(struct sw_udc *dev,
+					struct sw_udc_ep *ep,
+					struct usb_ctrlrequest *crq,
+					u32 ep0csr)
+{
+	int len = 0, ret = 0, tmp = 0;
+
+	/* start control request? */
+	if (!USBC_Dev_IsReadDataReady(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0)){
+	    DMSG_WRN("ERR: data is ready, can not read data.\n");
+		return;
+    }
+
+	sw_udc_nuke(dev, ep, -EPROTO);
+
+	len = sw_udc_read_fifo_crq(crq);
+	if (len != sizeof(*crq)) {
+		DMSG_PANIC("setup begin: fifo READ ERROR"
+			" wanted %d bytes got %d. Stalling out...\n",
+			sizeof(*crq), len);
+
+		USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 0);
+		USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+
+		return;
+	}
+
+	DMSG_DBG_UDC("ep0: bRequest = %d bRequestType %d wLength = %d\n",
+		crq->bRequest, crq->bRequestType, crq->wLength);
+
+	/* cope with automagic for some standard requests. */
+	dev->req_std        = ((crq->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD);
+	dev->req_config     = 0;
+	dev->req_pending    = 1;
+
+	switch (crq->bRequest) {
+    	case USB_REQ_SET_CONFIGURATION:
+    		DMSG_DBG_UDC("USB_REQ_SET_CONFIGURATION ... \n");
+
+    		if (crq->bRequestType == USB_RECIP_DEVICE) {
+    			dev->req_config = 1;
+    		}
+		break;
+
+    	case USB_REQ_SET_INTERFACE:
+    		DMSG_DBG_UDC("USB_REQ_SET_INTERFACE ... \n");
+
+    		if (crq->bRequestType == USB_RECIP_INTERFACE) {
+    			dev->req_config = 1;
+    		}
+		break;
+
+    	case USB_REQ_SET_ADDRESS:
+    		DMSG_DBG_UDC("USB_REQ_SET_ADDRESS ... \n");
+
+    		if (crq->bRequestType == USB_RECIP_DEVICE) {
+    			tmp = crq->wValue & 0x7F;
+    			dev->address = tmp;
+
+    			//rxdataendtx_pakect
+				USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+
+				dev->ep0state = EP0_END_XFER;
+
+				crq_bRequest = USB_REQ_SET_ADDRESS;
+
+    			return;
+    		}
+		break;
+
+    	case USB_REQ_GET_STATUS:
+    		DMSG_DBG_UDC("USB_REQ_GET_STATUS ... \n");
+    		if (dev->req_std) {
+    			if (!sw_udc_get_status(dev, crq)) {
+    				return;
+    			}
+    		}
+		break;
+
+		case USB_REQ_CLEAR_FEATURE:
+			//--<1>-- host to device
+			if(x_test_bit(crq->bRequestType, 7) == 1){
+				DMSG_PANIC("USB_REQ_CLEAR_FEATURE: data is not host to device\n");
+				break;
+			}
+
+			USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+
+			//--<3>--
+			if(crq->bRequestType == USB_RECIP_DEVICE){
+				/* wValue 0-1 */
+				if(crq->wValue){
+					dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+				}else{
+					int k = 0;
+					for(k = 0;k < SW_UDC_ENDPOINTS;k++){
+						sw_udc_set_halt(&dev->ep[k].ep, 0);
+					}
+				}
+
+			}else if(crq->bRequestType == USB_RECIP_INTERFACE){
+				//--<2>--
+
+				//
+
+			}else if(crq->bRequestType == USB_RECIP_ENDPOINT){
+				//--<3>--ep
+				//sw_udc_set_halt(&dev->ep[crq->wIndex & 0x7f].ep, 0);
+				//dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+				/* wValue 0-1 */
+				if(crq->wValue){
+					dev->devstatus &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+				}else{
+					sw_udc_set_halt(&dev->ep[crq->wIndex & 0x7f].ep, 0);
+				}
+
+			}else{
+				DMSG_PANIC("PANIC : nonsupport set feature request. (%d)\n", crq->bRequestType);
+				USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+			}
+			//--<4>--
+			dev->ep0state = EP0_IDLE;
+
+			return;
+		//break;
+
+        case USB_REQ_SET_FEATURE:
+            //--<1>-- host to device
+            if(x_test_bit(crq->bRequestType, 7) == 1){
+                DMSG_PANIC("USB_REQ_SET_FEATURE: data is not host to device\n");
+                break;
+            }
+            //--<3>--
+            if(crq->bRequestType == USB_RECIP_DEVICE){
+                if((crq->wValue == USB_DEVICE_TEST_MODE) && (crq->wIndex == 0x0400)){
+                    //setup packet
+                    USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+
+                    dev->ep0state = EP0_END_XFER;
+                    crq_bRequest = USB_REQ_SET_FEATURE;
+
+                    return;
+                }
+
+				USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+				dev->devstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+
+            }else if(crq->bRequestType == USB_RECIP_INTERFACE){
+                //--<2>--
+                USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+                //
+
+            }else if(crq->bRequestType == USB_RECIP_ENDPOINT){
+                //--<3>--ep
+                USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+				sw_udc_set_halt(&dev->ep[crq->wIndex & 0x7f].ep, 1);
+            }else{
+                DMSG_PANIC("PANIC : nonsupport set feature request. (%d)\n", crq->bRequestType);
+
+                USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+                USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+            }
+            //--<4>--
+            dev->ep0state = EP0_IDLE;
+
+			return;
+        //break;
+
+    	default:
+			/* setupDataEnd */
+			USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 0);
+    		break;
+	}
+
+	if(crq->bRequestType & USB_DIR_IN){
+		dev->ep0state = EP0_IN_DATA_PHASE;
+	}else{
+		dev->ep0state = EP0_OUT_DATA_PHASE;
+    }
+
+	ret = dev->driver->setup(&dev->gadget, crq);
+	if (ret < 0) {
+		if (dev->req_config) {
+			DMSG_PANIC("ERR: config change %02x fail %d?\n", crq->bRequest, ret);
+			return;
+		}
+
+		if(ret == -EOPNOTSUPP){
+			DMSG_PANIC("ERR: Operation not supported\n");
+		}else{
+			DMSG_PANIC("ERR: dev->driver->setup failed. (%d)\n", ret);
+        }
+
+		udelay(5);
+
+		USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+		USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+
+		dev->ep0state = EP0_IDLE;
+		/* deferred i/o == no response yet */
+	} else if (dev->req_pending) {
+//		DMSG_PANIC("ERR: dev->req_pending... what now?\n");
+		dev->req_pending=0;
+	}
+
+	if(crq->bRequest == USB_REQ_SET_CONFIGURATION || crq->bRequest == USB_REQ_SET_INTERFACE){
+		//rx_packet
+		USBC_Dev_ReadDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+	}
+
+	return;
+}
+
+#endif
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_handle_ep0(struct sw_udc *dev)
+{
+	u32			            ep0csr  = 0;
+	struct sw_udc_ep	    *ep     = &dev->ep[0];
+	struct sw_udc_request	*req    = NULL;
+	struct usb_ctrlrequest	crq;
+
+DMSG_DBG_UDC("sw_udc_handle_ep0--1--\n");
+
+	if(list_empty(&ep->queue)){
+		req = NULL;
+	}else{
+		req = list_entry(ep->queue.next, struct sw_udc_request, queue);
+    }
+
+DMSG_DBG_UDC("sw_udc_handle_ep0--2--\n");
+
+
+	/* We make the assumption that sw_udc_UDC_IN_CSR1_REG equal to
+	 * sw_udc_UDC_EP0_CSR_REG when index is zero */
+    USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, 0);
+
+	/* clear stall status */
+	if (USBC_Dev_IsEpStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0)) {
+		DMSG_PANIC("ERR: ep0 stall\n");
+
+		sw_udc_nuke(dev, ep, -EPIPE);
+		USBC_Dev_EpClearStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+		dev->ep0state = EP0_IDLE;
+
+		return;
+	}
+
+	/* clear setup end */
+	if (USBC_Dev_Ctrl_IsSetupEnd(g_sw_udc_io.usb_bsp_hdle)) {
+		DMSG_PANIC("handle_ep0: ep0 setup end\n");
+
+		sw_udc_nuke(dev, ep, 0);
+		USBC_Dev_Ctrl_ClearSetupEnd(g_sw_udc_io.usb_bsp_hdle);
+		dev->ep0state = EP0_IDLE;
+	}
+
+
+DMSG_DBG_UDC("sw_udc_handle_ep0--3--%d\n", dev->ep0state);
+
+
+	ep0csr = USBC_Readw(USBC_REG_RXCSR(g_sw_udc_io.usb_bsp_hdle));
+
+	switch (dev->ep0state) {
+    	case EP0_IDLE:
+    		sw_udc_handle_ep0_idle(dev, ep, &crq, ep0csr);
+		break;
+
+    	case EP0_IN_DATA_PHASE:			/* GET_DESCRIPTOR etc */
+    		DMSG_DBG_UDC("EP0_IN_DATA_PHASE ... what now?\n");
+
+    		if (!USBC_Dev_IsWriteDataReady(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0) && req) {
+    			sw_udc_write_fifo(ep, req);
+    		}
+		break;
+
+    	case EP0_OUT_DATA_PHASE:		/* SET_DESCRIPTOR etc */
+    		DMSG_DBG_UDC("EP0_OUT_DATA_PHASE ... what now?\n");
+
+    		if (USBC_Dev_IsReadDataReady(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0) && req ) {
+    			sw_udc_read_fifo(ep,req);
+    		}
+		break;
+
+    	case EP0_END_XFER:
+    		DMSG_DBG_UDC("EP0_END_XFER ... what now?\n");
+    		DMSG_DBG_UDC("crq_bRequest = 0x%x\n", crq_bRequest);
+
+			switch (crq_bRequest){
+		    	case USB_REQ_SET_ADDRESS:
+					USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, 0);
+
+					USBC_Dev_Ctrl_ClearSetupEnd(g_sw_udc_io.usb_bsp_hdle);
+					USBC_Dev_SetAddress(g_sw_udc_io.usb_bsp_hdle, dev->address);
+
+					DMSG_INFO_UDC("Set address %d\n", dev->address);
+				break;
+
+                case USB_REQ_SET_FEATURE:
+                {
+					u32 fifo = 0;
+
+                    fifo = USBC_SelectFIFO(g_sw_udc_io.usb_bsp_hdle, 0);
+					USBC_WritePacket(g_sw_udc_io.usb_bsp_hdle, fifo, 54, (u32 *)TestPkt);
+                    USBC_EnterMode_TestPacket(g_sw_udc_io.usb_bsp_hdle);
+                    USBC_Dev_WriteDataStatus(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0, 1);
+                }
+                break;
+
+				default:
+				break;
+		    }
+
+			crq_bRequest = 0;
+
+    		dev->ep0state = EP0_IDLE;
+		break;
+
+    	case EP0_STALL:
+    		DMSG_DBG_UDC("EP0_STALL ... what now?\n");
+    		dev->ep0state = EP0_IDLE;
+		break;
+	}
+
+DMSG_DBG_UDC("sw_udc_handle_ep0--4--%d\n", dev->ep0state);
+
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_handle_ep(struct sw_udc_ep *ep)
+{
+	struct sw_udc_request	*req = NULL;
+	int is_in   = ep->bEndpointAddress & USB_DIR_IN;
+	u32 idx     = 0;
+	u8 old_ep_index = 0;
+	u32 is_done = 0;
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, idx);
+
+	if (is_in) {
+		if (USBC_Dev_IsEpStall(g_sw_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_TX)) {
+			DMSG_PANIC("ERR: tx ep(%d) is stall\n", idx);
+			USBC_Dev_EpClearStall(g_sw_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_TX);
+			goto end;
+		}
+	} else {
+		if (USBC_Dev_IsEpStall(g_sw_udc_io.usb_bsp_hdle,
+				USBC_EP_TYPE_RX)) {
+			DMSG_PANIC("ERR: rx ep(%d) is stall\n", idx);
+			USBC_Dev_EpClearStall(g_sw_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_RX);
+			goto end;
+		}
+	}
+
+	/* get req */
+	if (likely(!list_empty(&ep->queue)))
+		req = list_entry(ep->queue.next, struct sw_udc_request, queue);
+	else
+		req = NULL;
+
+	if (req) {
+
+		/*DMSG_INFO("b: (0x%p, %d, %d)\n", &(req->req),
+				req->req.length, req->req.actual);*/
+
+		if (is_in) {
+			/* 
+			 *  */
+			if (req->req.length <= req->req.actual) {
+				sw_udc_done(ep, req, 0);
+				is_done = 1;
+				goto next;
+			} else {
+				if (!USBC_Dev_IsWriteDataReady(
+						g_sw_udc_io.usb_bsp_hdle,
+						USBC_EP_TYPE_TX))
+					sw_udc_write_fifo(ep, req);
+			}
+		} else {
+			if (USBC_Dev_IsReadDataReady(g_sw_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_RX))
+				is_done = sw_udc_read_fifo(ep, req);
+		}
+	}
+
+next:
+	/* do next req */
+	if (is_done) {
+		if (likely(!list_empty(&ep->queue)))
+			req = list_entry(ep->queue.next, struct sw_udc_request,
+					queue);
+		else
+			req = NULL;
+
+		if (req) {
+
+			/*DMSG_INFO("n: (0x%p, %d, %d)\n", &(req->req),
+				req->req.length, req->req.actual);*/
+
+			USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, idx);
+
+			if (is_in && !USBC_Dev_IsWriteDataReady(
+					g_sw_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_TX))
+				sw_udc_write_fifo(ep, req);
+			else if (!is_in && USBC_Dev_IsReadDataReady(
+					g_sw_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_RX))
+				sw_udc_read_fifo(ep, req);
+
+		}
+	}
+
+end:
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     filtrate_irq_misc
+*
+* Description:
+*    ,  disconect, reset, resume, suspend
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static u32 filtrate_irq_misc(u32 irq_misc)
+{
+    u32 irq = irq_misc;
+
+    irq &= ~(USBC_INTUSB_VBUS_ERROR | USBC_INTUSB_SESSION_REQ | USBC_INTUSB_CONNECT | USBC_INTUSB_SOF);
+	USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_VBUS_ERROR);
+	USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_SESSION_REQ);
+	USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_CONNECT);
+	USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_SOF);
+
+	return irq;
+}
+
+/*
+*******************************************************************************
+*                     clear_all_irq
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void clear_all_irq(void)
+{
+    USBC_INT_ClearEpPendingAll(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+    USBC_INT_ClearEpPendingAll(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+    USBC_INT_ClearMiscPendingAll(g_sw_udc_io.usb_bsp_hdle);
+}
+
+/*
+*******************************************************************************
+*                     throw_away_all_urb
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void throw_away_all_urb(struct sw_udc *dev)
+{
+	int k = 0;
+
+	DMSG_INFO_UDC("irq: reset happen, throw away all urb\n");
+	for(k = 0; k < SW_UDC_ENDPOINTS; k++){
+		sw_udc_nuke(dev, (struct sw_udc_ep * )&(dev->ep[k]), -ESHUTDOWN);
+	}
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_clean_dma_status
+*
+* Description:
+*    epDMA, DMA
+*
+* Parameters:
+*    qh  :  input.
+*
+* Return value:
+*    void
+*
+* note:
+*    called with controller irqlocked
+*
+*******************************************************************************
+*/
+void sw_udc_clean_dma_status(struct sw_udc_ep *ep)
+{
+    u8 ep_index = 0;
+	u8 old_ep_index = 0;
+	struct sw_udc_request	*req = NULL;
+
+	ep_index = ep->bEndpointAddress & 0x7F;
+
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, ep_index);
+
+	if((ep->bEndpointAddress) & USB_DIR_IN){  //dma_mode1
+		/* clear ep dma status */
+		USBC_Dev_ClearEpDma(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+
+		/* select bus to pio */
+		sw_udc_switch_bus_to_pio(ep, 1);
+	}else{  //dma_mode0
+		/* clear ep dma status */
+		USBC_Dev_ClearEpDma(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+		/* select bus to pio */
+		sw_udc_switch_bus_to_pio(ep, 0);
+	}
+
+ 	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+	/* done req */
+	while(likely (!list_empty(&ep->queue))){
+		req = list_entry(ep->queue.next, struct sw_udc_request, queue);
+		if(req){
+			req->req.status = -ECONNRESET;
+			req->req.actual = 0;
+			sw_udc_done(ep, req, -ECONNRESET);
+		}
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_stop_dma_work
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_stop_dma_work(struct sw_udc *dev)
+{
+	__u32 i = 0;
+	struct sw_udc_ep *ep = NULL;
+
+	for(i = 0; i < SW_UDC_ENDPOINTS; i++){
+		ep = &dev->ep[i];
+
+		if(sw_udc_dma_is_busy(ep)){
+			DMSG_PANIC("wrn: ep(%d) must stop working\n", i);
+
+			sw_udc_dma_stop(ep);
+			sw_udc_clean_dma_status(ep);
+		}
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_irq
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static irqreturn_t sw_udc_irq(int dummy, void *_dev)
+{
+	struct sw_udc *dev = _dev;
+	int usb_irq     = 0;
+	int tx_irq      = 0;
+	int rx_irq      = 0;
+	int i           = 0;
+	u32 old_ep_idx  = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* Driver connected ? */
+	if (!dev->driver || !is_peripheral_active()) {
+		DMSG_PANIC("ERR: functoin driver is not exist, or udc is not active.\n");
+
+		/* Clear interrupts */
+		clear_all_irq();
+
+		spin_unlock_irqrestore(&dev->lock, flags);
+
+		return IRQ_NONE;
+	}
+
+	/* Save index */
+	old_ep_idx = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+
+	/* Read status registers */
+	usb_irq = USBC_INT_MiscPending(g_sw_udc_io.usb_bsp_hdle);
+	tx_irq  = USBC_INT_EpPending(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+	rx_irq  = USBC_INT_EpPending(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+
+	DMSG_TEST("\n\nirq: usb_irq=%02x, tx_irq=%02x, rx_irq=%02x\n",
+		        usb_irq, tx_irq, rx_irq);
+
+	usb_irq = filtrate_irq_misc(usb_irq);
+
+	/*
+	 * Now, handle interrupts. There's two types :
+	 * - Reset, Resume, Suspend coming -> usb_int_reg
+	 * - EP -> ep_int_reg
+	 */
+
+	/* RESET */
+	if (usb_irq & USBC_INTUSB_RESET) {
+		DMSG_INFO_UDC("IRQ: reset\n");
+
+        USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_RESET);
+        clear_all_irq();
+
+		usb_connect = 1;
+
+		USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, 0);
+		USBC_Dev_SetAddress_default(g_sw_udc_io.usb_bsp_hdle);
+
+		if(is_udc_support_dma()){
+			sw_udc_stop_dma_work(dev);
+		}
+
+        throw_away_all_urb(dev);
+
+		dev->address = 0;
+		dev->ep0state = EP0_IDLE;
+//		dev->gadget.speed = USB_SPEED_FULL;
+
+		spin_unlock_irqrestore(&dev->lock, flags);
+
+		return IRQ_HANDLED;
+	}
+
+	/* RESUME */
+	if (usb_irq & USBC_INTUSB_RESUME) {
+		DMSG_INFO_UDC("IRQ: resume\n");
+
+		/* clear interrupt */
+		USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_RESUME);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+				&& dev->driver
+				&& dev->driver->resume) {
+			spin_unlock(&dev->lock);
+			dev->driver->resume(&dev->gadget);
+			spin_lock(&dev->lock);
+		}
+	}
+
+	/* SUSPEND */
+	if (usb_irq & USBC_INTUSB_SUSPEND) {
+		DMSG_INFO_UDC("IRQ: suspend\n");
+
+		/* clear interrupt */
+		USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_SUSPEND);
+
+		if(dev->gadget.speed != USB_SPEED_UNKNOWN){
+			usb_connect = 0;
+		}else{
+			DMSG_INFO_UDC("ERR: usb speed is unkown\n");
+		}
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+				&& dev->driver
+				&& dev->driver->suspend) {
+			spin_unlock(&dev->lock);
+			dev->driver->suspend(&dev->gadget);
+			spin_lock(&dev->lock);
+		}
+
+		dev->ep0state = EP0_IDLE;
+
+	}
+
+    /* DISCONNECT */
+    if(usb_irq & USBC_INTUSB_DISCONNECT){
+        DMSG_INFO_UDC("IRQ: disconnect\n");
+
+		USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_DISCONNECT);
+
+        dev->ep0state = EP0_IDLE;
+
+		usb_connect = 0;
+	}
+
+	/* EP */
+	/* control traffic */
+	/* check on ep0csr != 0 is not a good idea as clearing in_pkt_ready
+	 * generate an interrupt
+	 */
+	if (tx_irq & USBC_INTTx_FLAG_EP0) {
+		 DMSG_DBG_UDC("USB ep0 irq\n");
+
+		/* Clear the interrupt bit by setting it to 1 */
+		USBC_INT_ClearEpPending(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX, 0);
+
+		if(dev->gadget.speed == USB_SPEED_UNKNOWN){
+			if(USBC_Dev_QueryTransferMode(g_sw_udc_io.usb_bsp_hdle) == USBC_TS_MODE_HS){
+				dev->gadget.speed = USB_SPEED_HIGH;
+
+				DMSG_INFO_UDC("\n+++++++++++++++++++++++++++++++++++++\n");
+			    DMSG_INFO_UDC(" usb enter high speed.\n");
+			    DMSG_INFO_UDC("\n+++++++++++++++++++++++++++++++++++++\n");
+			}else{
+				dev->gadget.speed= USB_SPEED_FULL;
+
+				DMSG_INFO_UDC("\n+++++++++++++++++++++++++++++++++++++\n");
+			    DMSG_INFO_UDC(" usb enter full speed.\n");
+			    DMSG_INFO_UDC("\n+++++++++++++++++++++++++++++++++++++\n");
+			}
+		}
+
+		sw_udc_handle_ep0(dev);
+	}
+
+	/* , PC */
+
+	/* rx endpoint data transfers */
+	for (i = 1; i < SW_UDC_ENDPOINTS; i++) {
+		u32 tmp = 1 << i;
+
+		if (rx_irq & tmp) {
+			DMSG_DBG_UDC("USB rx ep%d irq\n", i);
+
+			/* Clear the interrupt bit by setting it to 1 */
+			USBC_INT_ClearEpPending(g_sw_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_RX, i);
+
+			sw_udc_handle_ep(&dev->ep[i]);
+		}
+	}
+
+	/* tx endpoint data transfers */
+	for (i = 1; i < SW_UDC_ENDPOINTS; i++) {
+		u32 tmp = 1 << i;
+
+		if (tx_irq & tmp) {
+			DMSG_DBG_UDC("USB tx ep%d irq\n", i);
+
+			/* Clear the interrupt bit by setting it to 1 */
+			USBC_INT_ClearEpPending(g_sw_udc_io.usb_bsp_hdle,
+					USBC_EP_TYPE_TX, i);
+
+			sw_udc_handle_ep(&dev->ep[i]);
+		}
+	}
+
+	DMSG_TEST("irq: %d irq end.\n", dev->irq_no);
+
+	/* Restore old index */
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_idx);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_completion
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_udc_dma_completion(struct sw_udc *dev, struct sw_udc_ep *ep, struct sw_udc_request *req)
+{
+	unsigned long	flags 				= 0;
+	__u8  			old_ep_index 		= 0;
+	__u32 			dma_transmit_len 	= 0;
+	int 			is_complete			= 0;
+	struct sw_udc_request *req_next		= NULL;
+
+	if(dev == NULL || ep == NULL || req == NULL){
+		DMSG_PANIC("ERR: argment invaild. (0x%p, 0x%p, 0x%p)\n", dev, ep, req);
+		return;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	old_ep_index = USBC_GetActiveEp(dev->sw_udc_io->usb_bsp_hdle);
+	USBC_SelectActiveEp(dev->sw_udc_io->usb_bsp_hdle, ep->num);
+
+	DMSG_TEST("dq: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d)\n",
+		         ep, ep->num,
+		         req, &(req->req), req->req.length, req->req.actual);
+
+	if((ep->bEndpointAddress) & USB_DIR_IN){  //tx, dma_mode1
+		USBC_Dev_ClearEpDma(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_TX);
+	}else{  //rx, dma_mode0
+		USBC_Dev_ClearEpDma(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_RX);
+	}
+
+	dma_transmit_len = sw_udc_dma_transmit_length(ep, ((ep->bEndpointAddress) & USB_DIR_IN), (__u32)req->req.buf);
+	if(dma_transmit_len < req->req.length){
+		DMSG_PANIC("WRN: DMA recieve data not complete, (%d, %d, %d)\n",
+					req->req.length, req->req.actual, dma_transmit_len);
+
+		if((ep->bEndpointAddress) & USB_DIR_IN){
+			USBC_Dev_ClearEpDma(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_TX);
+			USBC_Dev_WriteDataStatus(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_TX, 1);
+		}else{
+			USBC_Dev_ClearEpDma(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_RX);
+			USBC_Dev_ReadDataStatus(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_RX, 1);
+		}
+	}
+
+    /*  */
+	req->req.actual += dma_transmit_len;
+	if(req->req.length > req->req.actual){
+		DMSG_INFO_UDC("dma irq, transfer left data\n");
+
+		if(((ep->bEndpointAddress & USB_DIR_IN) != 0)
+			&& !USBC_Dev_IsWriteDataReady(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_TX)){
+			if(sw_udc_write_fifo(ep, req)){
+				req = NULL;
+				is_complete = 1;
+			}
+		}else if(((ep->bEndpointAddress & USB_DIR_IN) != 0)
+			&& USBC_Dev_IsReadDataReady(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_RX)){
+			if(sw_udc_read_fifo(ep, req)){
+				req = NULL;
+				is_complete = 1;
+			}
+		}
+	}else{	/* DMAdone */
+		sw_udc_done(ep, req, 0);
+		is_complete = 1;
+	}
+
+    /* DMAdone */
+
+	if(is_complete){
+		ep->dma_working	= 0;
+		ep->dma_transfer_len = 0;
+	}
+
+	//-------------------------------------------------
+	//
+	//-------------------------------------------------
+	if(is_complete){
+		if(likely (!list_empty(&ep->queue))){
+			req_next = list_entry(ep->queue.next, struct sw_udc_request, queue);
+		}else{
+			req_next = NULL;
+	    }
+
+		if(req_next){
+			DMSG_TEST("do next req: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d)\n",
+				         ep, ep->num,
+				         req_next, &(req_next->req), req_next->req.length, req_next->req.actual);
+
+			if(((ep->bEndpointAddress & USB_DIR_IN) != 0)
+				&& !USBC_Dev_IsWriteDataReady(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_TX)){
+				sw_udc_write_fifo(ep, req_next);
+			}else if(((ep->bEndpointAddress & USB_DIR_IN) == 0)
+				&& USBC_Dev_IsReadDataReady(dev->sw_udc_io->usb_bsp_hdle, USBC_EP_TYPE_RX)){
+				sw_udc_read_fifo(ep, req_next);
+			}
+		}
+	}
+
+	USBC_SelectActiveEp(dev->sw_udc_io->usb_bsp_hdle, old_ep_index);
+
+	DMSG_TEST("de\n");
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	return;
+}
+
+/*------------------------- sw_udc_ep_ops ----------------------------------*/
+
+static inline struct sw_udc_ep *to_sw_udc_ep(struct usb_ep *ep)
+{
+	return container_of(ep, struct sw_udc_ep, ep);
+}
+
+static inline struct sw_udc *to_sw_udc(struct usb_gadget *gadget)
+{
+	return container_of(gadget, struct sw_udc, gadget);
+}
+
+static inline struct sw_udc_request *to_sw_udc_req(struct usb_request *req)
+{
+	return container_of(req, struct sw_udc_request, req);
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_ep_enable
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_ep_enable(struct usb_ep *_ep,
+				 const struct usb_endpoint_descriptor *desc)
+{
+	struct sw_udc	*dev			= NULL;
+	struct sw_udc_ep	*ep				= NULL;
+	u32			 	max     		= 0;
+	unsigned long	flags   		= 0;
+    u32     		old_ep_index	= 0;
+	__u32 			fifo_addr 		= 0;
+
+	if(_ep == NULL || desc == NULL){
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	if (_ep->name == ep0name || desc->bDescriptorType != USB_DT_ENDPOINT){
+		DMSG_PANIC("PANIC : _ep->name(%s) == ep0name || desc->bDescriptorType(%d) != USB_DT_ENDPOINT\n",
+				   _ep->name , desc->bDescriptorType);
+		return -EINVAL;
+	}
+
+	ep = to_sw_udc_ep(_ep);
+    if(ep == NULL){
+		DMSG_PANIC("ERR: usbd_ep_enable, ep = NULL\n");
+		return -EINVAL;
+	}
+
+	if(ep->desc){
+		DMSG_PANIC("ERR: usbd_ep_enable, ep->desc is not NULL, ep%d(%s)\n", ep->num, _ep->name);
+		return -EINVAL;
+	}
+
+	DMSG_INFO_UDC("ep enable: ep%d(0x%p, %s, %d, %d)\n",
+		          ep->num, _ep, _ep->name,
+		          (desc->bEndpointAddress & USB_DIR_IN), _ep->maxpacket);
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN){
+		DMSG_PANIC("PANIC : dev->driver = 0x%p ?= NULL  dev->gadget->speed =%d ?= USB_SPEED_UNKNOWN\n",
+				   dev->driver ,dev->gadget.speed);
+		return -ESHUTDOWN;
+    }
+
+	max = le16_to_cpu(desc->wMaxPacketSize) & 0x1fff;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	_ep->maxpacket          = max & 0x7ff;
+	ep->desc                = desc;
+	ep->halted              = 0;
+	ep->bEndpointAddress    = desc->bEndpointAddress;
+
+	/* select fifo address, 
+	 * 1Kep1K
+	 */
+	fifo_addr = ep->num * 1024;
+
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		goto end;
+	}
+
+    old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+    USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, ep->num);
+
+  	//set max packet ,type, direction, address; reset fifo counters, enable irq
+	if ((ep->bEndpointAddress) & USB_DIR_IN){ /* tx */
+	    USBC_Dev_ConfigEp(g_sw_udc_io.usb_bsp_hdle, USBC_TS_TYPE_BULK, USBC_EP_TYPE_TX, SW_UDC_FIFO_NUM, _ep->maxpacket & 0x7ff);
+    	USBC_ConfigFifo(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX, SW_UDC_FIFO_NUM, 512, fifo_addr);
+
+		//eptx_irq en
+		USBC_INT_EnableEp(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX, ep->num);
+	}else{	 /* rx */
+	    USBC_Dev_ConfigEp(g_sw_udc_io.usb_bsp_hdle, USBC_TS_TYPE_BULK, USBC_EP_TYPE_RX, SW_UDC_FIFO_NUM, _ep->maxpacket & 0x7ff);
+   		USBC_ConfigFifo(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX, SW_UDC_FIFO_NUM, 512, fifo_addr);
+
+		//eprx_irq
+		USBC_INT_EnableEp(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX, ep->num);
+	}
+
+    USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+end:
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	sw_udc_set_halt(_ep, 0);
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_ep_disable
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_ep_disable(struct usb_ep *_ep)
+{
+	struct sw_udc_ep   	*ep     = NULL;
+    u32 old_ep_index            = 0;
+	unsigned long flags = 0;
+
+	if (!_ep) {
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	ep = to_sw_udc_ep(_ep);
+	if(ep == NULL){
+		DMSG_PANIC("ERR: usbd_ep_disable: ep = NULL\n");
+		return -EINVAL;
+	}
+
+	if (!ep->desc) {
+		DMSG_PANIC("ERR: %s not enabled\n", _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	DMSG_INFO_UDC("ep disable: ep%d(0x%p, %s, %d, %x)\n",
+		          ep->num, _ep, _ep->name,
+		          (ep->bEndpointAddress & USB_DIR_IN), _ep->maxpacket);
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	DMSG_DBG_UDC("ep_disable: %s\n", _ep->name);
+
+	ep->desc = NULL;
+	ep->halted = 1;
+
+	sw_udc_nuke (ep->dev, ep, -ESHUTDOWN);
+
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		goto end;
+	}
+
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+    USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, ep->num);
+
+	if ((ep->bEndpointAddress) & USB_DIR_IN){ /* tx */
+	    USBC_Dev_ConfigEp_Default(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+		USBC_INT_DisableEp(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX, ep->num);
+	}else{ /* rx */
+	    USBC_Dev_ConfigEp_Default(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+		USBC_INT_DisableEp(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX, ep->num);
+	}
+
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+end:
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DMSG_DBG_UDC("%s disabled\n", _ep->name);
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static struct usb_request * sw_udc_alloc_request(struct usb_ep *_ep, gfp_t mem_flags)
+{
+	struct sw_udc_request *req = NULL;
+
+	if(!_ep){
+	    DMSG_PANIC("ERR: invalid argment\n");
+		return NULL;
+	}
+
+	req = kzalloc (sizeof(struct sw_udc_request), mem_flags);
+	if(!req){
+	    DMSG_PANIC("ERR: kzalloc failed\n");
+		return NULL;
+	}
+
+    memset(req, 0, sizeof(struct sw_udc_request));
+
+	INIT_LIST_HEAD (&req->queue);
+
+	DMSG_INFO_UDC("alloc request: ep(0x%p, %s, %d), req(0x%p)\n",
+		          _ep, _ep->name, _ep->maxpacket, req);
+
+	return &req->req;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_free_request
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct sw_udc_request	*req = NULL;
+
+	if(_ep == NULL || _req == NULL){
+	    DMSG_PANIC("ERR: invalid argment\n");
+		return;
+	}
+
+	req = to_sw_udc_req(_req);
+	if(req == NULL){
+	    DMSG_PANIC("ERR: invalid argment\n");
+		return;
+	}
+
+	DMSG_INFO_UDC("free request: ep(0x%p, %s, %d), req(0x%p)\n",
+		      _ep, _ep->name, _ep->maxpacket, req);
+
+	kfree(req);
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct sw_udc_request	*req    	= NULL;
+	struct sw_udc_ep	    *ep     	= NULL;
+	struct sw_udc	    	*dev    	= NULL;
+	unsigned long flags = 0;
+	u8 old_ep_index = 0;
+
+	if(_ep == NULL || _req == NULL ){
+        DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+    ep = to_sw_udc_ep(_ep);
+    if ((ep == NULL || (!ep->desc && _ep->name != ep0name))){
+        DMSG_PANIC("ERR: sw_udc_queue: inval 2\n");
+        return -EINVAL;
+    }
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN){
+		DMSG_PANIC("ERR : dev->driver=0x%p, dev->gadget.speed=%x\n",
+			       dev->driver, dev->gadget.speed);
+		return -ESHUTDOWN;
+	}
+
+	if (!_req->complete || !_req->buf){
+       	DMSG_PANIC("ERR: usbd_queue: _req is invalid\n");
+        return -EINVAL;
+	}
+
+    req = to_sw_udc_req(_req);
+	if (!req){
+        DMSG_PANIC("ERR: req is NULL\n");
+        return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	list_add_tail(&req->queue, &ep->queue);
+
+	if(!is_peripheral_active()){
+		DMSG_PANIC("warn: peripheral is active\n");
+		goto end;
+	}
+
+	DMSG_TEST("\n\nq: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d)\n",
+		      ep, ep->num,
+		      req, _req, _req->length, _req->actual);
+
+	//DMSG_INFO("\n\nq: (0x%p, %d, %d)\n", _req,_req->length, _req->actual);
+	//DMSG_INFO("\nq\n");
+
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+	if (ep->bEndpointAddress) {
+		USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, ep->bEndpointAddress & 0x7F);
+	} else {
+		USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, 0);
+	}
+
+	/* , */
+	if (!ep->halted && (&req->queue == ep->queue.next)) {
+		if (ep->bEndpointAddress == 0 /* ep0 */) {
+			switch (dev->ep0state) {
+    			case EP0_IN_DATA_PHASE:
+    				if (!USBC_Dev_IsWriteDataReady(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX)
+    				    && sw_udc_write_fifo(ep, req)) {
+    					dev->ep0state = EP0_IDLE;
+    					req = NULL;
+    				}
+				break;
+
+    			case EP0_OUT_DATA_PHASE:
+    				if ((!_req->length)
+    					|| (USBC_Dev_IsReadDataReady(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX)
+    						&& sw_udc_read_fifo(ep, req))) {
+    					dev->ep0state = EP0_IDLE;
+    					req = NULL;
+    				}
+				break;
+
+    			default:
+				spin_unlock_irqrestore(&ep->dev->lock, flags);
+				return -EL2HLT;
+			}
+		} else if ((ep->bEndpointAddress & USB_DIR_IN) != 0
+				&& !USBC_Dev_IsWriteDataReady(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX)) {
+			if(sw_udc_write_fifo(ep, req)){
+				req = NULL;
+			}
+		} else if ((ep->bEndpointAddress & USB_DIR_IN) == 0
+				&& USBC_Dev_IsReadDataReady(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX)) {
+			if(sw_udc_read_fifo(ep, req)){
+				req = NULL;
+			}
+		}
+	}
+
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+end:
+	/*DMSG_INFO("qe\n");*/
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dequeue
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct sw_udc_ep	*ep  	= NULL;
+	struct sw_udc		*udc  	= NULL;
+	int			        retval  = -EINVAL;
+	unsigned long		flags   = 0;
+	struct sw_udc_request *req 	= NULL;
+
+	DMSG_DBG_UDC("(%p,%p)\n", _ep, _req);
+
+	if(!the_controller->driver){
+	    DMSG_PANIC("ERR: sw_udc_dequeue: driver is null\n");
+		return -ESHUTDOWN;
+    }
+
+	if(!_ep || !_req){
+	    DMSG_PANIC("ERR: sw_udc_dequeue: invalid argment\n");
+		return retval;
+    }
+
+	ep = to_sw_udc_ep(_ep);
+	if(ep == NULL){
+		DMSG_PANIC("ERR: ep == NULL\n");
+		return -EINVAL;
+	}
+
+	udc = to_sw_udc(ep->gadget);
+	if(udc == NULL){
+		DMSG_PANIC("ERR: ep == NULL\n");
+		return -EINVAL;
+	}
+
+	DMSG_INFO_UDC("dequeue: ep(0x%p, %d), _req(0x%p, %d, %d)\n",
+		      ep, ep->num,
+		      _req, _req->length, _req->actual);
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	list_for_each_entry (req, &ep->queue, queue) {
+		if (&req->req == _req) {
+			list_del_init (&req->queue);
+			_req->status = -ECONNRESET;
+			retval = 0;
+			break;
+		}
+	}
+
+	if (retval == 0) {
+		DMSG_DBG_UDC("dequeued req %p from %s, len %d buf %p\n",
+			        req, _ep->name, _req->length, _req->buf);
+
+		sw_udc_done(ep, req, -ECONNRESET);
+	}
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	return retval;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_set_halt
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_set_halt(struct usb_ep *_ep, int value)
+{
+	struct sw_udc_ep		*ep     = NULL;
+	unsigned long		flags   = 0;
+	u32			        idx     = 0;
+	__u8    old_ep_index        = 0;
+
+	if(_ep == NULL){
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	ep = to_sw_udc_ep(_ep);
+	if(ep == NULL){
+		DMSG_PANIC("ERR: invalid argment\n");
+		return -EINVAL;
+	}
+
+	if(!ep->desc && ep->ep.name != ep0name){
+		DMSG_PANIC("ERR: !ep->desc && ep->ep.name != ep0name\n");
+		return -EINVAL;
+	}
+
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	idx = ep->bEndpointAddress & 0x7F;
+
+	old_ep_index = USBC_GetActiveEp(g_sw_udc_io.usb_bsp_hdle);
+    USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, idx);
+
+	if (idx == 0) {
+		USBC_Dev_EpClearStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_EP0);
+	} else {
+		if ((ep->bEndpointAddress & USB_DIR_IN) != 0) {
+			if(value){
+				USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+			}else{
+				USBC_Dev_EpClearStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+			}
+		} else {
+			if(value){
+				USBC_Dev_EpSendStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+			}else{
+				USBC_Dev_EpClearStall(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+			}
+		}
+	}
+
+	ep->halted = value ? 1 : 0;
+
+	USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, old_ep_index);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	return 0;
+}
+
+static const struct usb_ep_ops sw_udc_ep_ops = {
+	.enable			= sw_udc_ep_enable,
+	.disable		= sw_udc_ep_disable,
+
+	.alloc_request	= sw_udc_alloc_request,
+	.free_request	= sw_udc_free_request,
+
+	.queue			= sw_udc_queue,
+	.dequeue		= sw_udc_dequeue,
+
+	.set_halt		= sw_udc_set_halt,
+};
+
+
+/*
+*******************************************************************************
+*                     sw_udc_get_frame
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_get_frame(struct usb_gadget *_gadget)
+{
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	return USBC_REG_FRNUM(g_sw_udc_io.usb_bsp_hdle);
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_wakeup
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_wakeup(struct usb_gadget *_gadget)
+{
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_set_selfpowered
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_set_selfpowered(struct usb_gadget *gadget, int value)
+{
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	return 0;
+}
+
+static void sw_udc_disable(struct sw_udc *dev);
+static void sw_udc_enable(struct sw_udc *dev);
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_set_pullup(struct sw_udc *udc, int is_on)
+{
+	DMSG_DBG_UDC("sw_udc_set_pullup\n");
+
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	is_udc_enable = is_on;
+
+	if(is_on){
+		sw_udc_enable(udc);
+	}else{
+		if (udc->gadget.speed != USB_SPEED_UNKNOWN) {
+			if (udc->driver && udc->driver->disconnect)
+				udc->driver->disconnect(&udc->gadget);
+		}
+
+		sw_udc_disable(udc);
+	}
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_vbus_session
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct sw_udc *udc = to_sw_udc(gadget);
+
+	DMSG_DBG_UDC("sw_udc_vbus_session\n");
+
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	udc->vbus = (is_active != 0);
+	sw_udc_set_pullup(udc, is_active);
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_pullup
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct sw_udc *udc = to_sw_udc(gadget);
+
+	DMSG_INFO_UDC("sw_udc_pullup, is_on = %d\n", is_on);
+
+	sw_udc_set_pullup(udc, is_on);
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_vbus_draw
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_vbus_draw(struct usb_gadget *_gadget, unsigned ma)
+{
+	if(!is_peripheral_active()){
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	DMSG_DBG_UDC("sw_udc_vbus_draw\n");
+
+	cfg_vbus_draw(ma);
+
+	return 0;
+}
+
+static int sun4i_start(struct usb_gadget_driver *driver,
+		       int (*bind)(struct usb_gadget *));
+static int sun4i_stop(struct usb_gadget_driver *driver);
+
+static const struct usb_gadget_ops sw_udc_ops = {
+	.get_frame		    = sw_udc_get_frame,
+	.wakeup			    = sw_udc_wakeup,
+	.set_selfpowered	= sw_udc_set_selfpowered,
+	.pullup			    = sw_udc_pullup,
+	.vbus_session		= sw_udc_vbus_session,
+	.vbus_draw		    = sw_udc_vbus_draw,
+	.start			= sun4i_start,
+	.stop			= sun4i_stop,
+};
+
+//---------------------------------------------------------------
+//   gadget driver handling
+//---------------------------------------------------------------
+
+/*
+*******************************************************************************
+*                     sw_udc_reinit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_reinit(struct sw_udc *dev)
+{
+	u32 i = 0;
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD (&dev->gadget.ep_list);
+	INIT_LIST_HEAD (&dev->gadget.ep0->ep_list);
+	dev->ep0state = EP0_IDLE;
+
+	for (i = 0; i < SW_UDC_ENDPOINTS; i++) {
+		struct sw_udc_ep *ep = &dev->ep[i];
+
+		if (i != 0) {
+			list_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);
+        }
+
+		ep->dev     = dev;
+		ep->desc    = NULL;
+		ep->halted  = 0;
+		INIT_LIST_HEAD (&ep->queue);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_enable(struct sw_udc *dev)
+{
+	DMSG_DBG_UDC("sw_udc_enable called\n");
+
+	/* dev->gadget.speed = USB_SPEED_UNKNOWN; */
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+#ifdef	CONFIG_USB_GADGET_DUALSPEED
+	DMSG_INFO_UDC("CONFIG_USB_GADGET_DUALSPEED\n");
+
+	USBC_Dev_ConfigTransferMode(g_sw_udc_io.usb_bsp_hdle, USBC_TS_TYPE_BULK, USBC_TS_MODE_HS);
+#else
+	USBC_Dev_ConfigTransferMode(g_sw_udc_io.usb_bsp_hdle, USBC_TS_TYPE_BULK, USBC_TS_MODE_FS);
+#endif
+
+	/* Enable reset and suspend interrupt interrupts */
+	USBC_INT_EnableUsbMiscUint(g_sw_udc_io.usb_bsp_hdle, USBC_BP_INTUSB_SUSPEND);
+	USBC_INT_EnableUsbMiscUint(g_sw_udc_io.usb_bsp_hdle, USBC_BP_INTUSB_RESUME);
+	USBC_INT_EnableUsbMiscUint(g_sw_udc_io.usb_bsp_hdle, USBC_BP_INTUSB_RESET);
+	USBC_INT_EnableUsbMiscUint(g_sw_udc_io.usb_bsp_hdle, USBC_BP_INTUSB_DISCONNECT);
+
+	/* Enable ep0 interrupt */
+	USBC_INT_EnableEp(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX, 0);
+
+	cfg_udc_command(SW_UDC_P_ENABLE);
+
+	return ;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_disable
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_disable(struct sw_udc *dev)
+{
+	DMSG_DBG_UDC("sw_udc_disable\n");
+
+	/* Disable all interrupts */
+    USBC_INT_DisableUsbMiscAll(g_sw_udc_io.usb_bsp_hdle);
+    USBC_INT_DisableEpAll(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_RX);
+    USBC_INT_DisableEpAll(g_sw_udc_io.usb_bsp_hdle, USBC_EP_TYPE_TX);
+
+	/* Clear the interrupt registers */
+	clear_all_irq();
+	cfg_udc_command(SW_UDC_P_DISABLE);
+
+	/* Set speed to unknown */
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	return;
+}
+
+s32  usbd_start_work(void)
+{
+	DMSG_INFO_UDC("usbd_start_work\n");
+
+	if (!is_peripheral_active()) {
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	enable_irq_udc(the_controller);
+	USBC_Dev_ConectSwitch(g_sw_udc_io.usb_bsp_hdle, USBC_DEVICE_SWITCH_ON);
+
+	return 0;
+}
+
+s32  usbd_stop_work(void)
+{
+	DMSG_INFO_UDC("usbd_stop_work\n");
+
+	if (!is_peripheral_active()) {
+		DMSG_PANIC("ERR: usb device is not active\n");
+		return 0;
+	}
+
+	disable_irq_udc(the_controller);
+    USBC_Dev_ConectSwitch(g_sw_udc_io.usb_bsp_hdle, USBC_DEVICE_SWITCH_OFF);	//pulldown
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     FunctionName
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sun4i_start(struct usb_gadget_driver *driver,
+		       int (*bind)(struct usb_gadget *))
+{
+	struct sw_udc *udc = the_controller;
+	int retval = 0;
+
+	/* Sanity checks */
+	if(!udc){
+	    DMSG_PANIC("ERR: udc is null\n");
+		return -ENODEV;
+    }
+
+	if (udc->driver){
+	    DMSG_PANIC("ERR: udc->driver is not null\n");
+		return -EBUSY;
+    }
+
+	if (!bind || !driver->setup || driver->max_speed < USB_SPEED_FULL) {
+		DMSG_PANIC("ERR: Invalid driver: bind %p setup %p speed %d\n",
+			       bind, driver->setup, driver->max_speed);
+		return -EINVAL;
+	}
+
+#if defined(MODULE)
+    if (!driver->unbind) {
+        DMSG_PANIC("Invalid driver: no unbind method\n");
+        return -EINVAL;
+    }
+#endif
+
+	/* Hook the driver */
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+
+	/* Bind the driver */
+	if ((retval = device_add(&udc->gadget.dev)) != 0) {
+		DMSG_PANIC("ERR: Error in device_add() : %d\n",retval);
+		goto register_error;
+	}
+
+	DMSG_INFO_UDC("[%s]: binding gadget driver '%s'\n", gadget_name, driver->driver.name);
+
+	if ((retval = bind (&udc->gadget)) != 0) {
+	    DMSG_PANIC("ERR: Error in bind() : %d\n",retval);
+		device_del(&udc->gadget.dev);
+		goto register_error;
+	}
+
+	/* Enable udc */
+	sw_udc_set_pullup(udc, 1);
+
+	return 0;
+
+register_error:
+	udc->driver = NULL;
+	udc->gadget.dev.driver = NULL;
+
+	return retval;
+}
+
+/*
+*******************************************************************************
+*                     usb_gadget_unregister_driver
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sun4i_stop(struct usb_gadget_driver *driver)
+{
+	struct sw_udc *udc = the_controller;
+
+	if(!udc){
+	    DMSG_PANIC("ERR: udc is null\n");
+		return -ENODEV;
+    }
+
+	if(!driver || driver != udc->driver || !driver->unbind){
+	    DMSG_PANIC("ERR: driver is null\n");
+		return -EINVAL;
+    }
+
+	DMSG_INFO_UDC("[%s]: usb_gadget_unregister_driver() '%s'\n", gadget_name, driver->driver.name);
+
+	if(driver->disconnect){
+		driver->disconnect(&udc->gadget);
+    }
+
+	/* Disable udc */
+	sw_udc_set_pullup(udc, 0);
+
+    /* unbind gadget driver */
+	driver->unbind(&udc->gadget);
+	udc->gadget.dev.driver = NULL;
+	device_del(&udc->gadget.dev);
+	udc->driver = NULL;
+
+
+	return 0;
+}
+
+static struct sw_udc sw_udc = {
+	.gadget = {
+		.ops		= &sw_udc_ops,
+		.ep0		= &sw_udc.ep[0].ep,
+		.name		= gadget_name,
+		.dev = {
+			.init_name	= "gadget",
+		},
+	},
+
+	/* control endpoint */
+	.ep[0] = {
+		.num			= 0,
+		.ep = {
+			.name		= ep0name,
+			.ops		= &sw_udc_ep_ops,
+			.maxpacket	= EP0_FIFO_SIZE,
+		},
+		.dev			= &sw_udc,
+	},
+
+	/* first group of endpoints */
+	.ep[1] = {
+		.num			= 1,
+		.ep = {
+			.name		= "ep1-bulk",
+			.ops		= &sw_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+		},
+		.dev		        = &sw_udc,
+		.fifo_size	        = (SW_UDC_EP_FIFO_SIZE * (SW_UDC_FIFO_NUM + 1)),
+		.bEndpointAddress   = 1,
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[2] = {
+		.num			= 2,
+		.ep = {
+			.name		= "ep2-bulk",
+			.ops		= &sw_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+		},
+		.dev		        = &sw_udc,
+		.fifo_size	        = (SW_UDC_EP_FIFO_SIZE * (SW_UDC_FIFO_NUM + 1)),
+		.bEndpointAddress   = 2,
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[3] = {
+		.num			= 3,
+		.ep = {
+			.name		= "ep3-bulk",
+			.ops		= &sw_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+		},
+		.dev		        = &sw_udc,
+		.fifo_size	        = (SW_UDC_EP_FIFO_SIZE * (SW_UDC_FIFO_NUM + 1)),
+		.bEndpointAddress   = 3,
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[4] = {
+		.num			= 4,
+		.ep = {
+			.name		= "ep4-bulk",
+			.ops		= &sw_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+		},
+		.dev		        = &sw_udc,
+		.fifo_size	        = (SW_UDC_EP_FIFO_SIZE * (SW_UDC_FIFO_NUM + 1)),
+		.bEndpointAddress   = 4,
+		.bmAttributes	    = USB_ENDPOINT_XFER_BULK,
+	},
+
+	.ep[5] = {
+		.num			= 5,
+		.ep = {
+			.name		= "ep5-int",
+			.ops		= &sw_udc_ep_ops,
+			.maxpacket	= SW_UDC_EP_FIFO_SIZE,
+		},
+		.dev		        = &sw_udc,
+		.fifo_size	        = (SW_UDC_EP_FIFO_SIZE * (SW_UDC_FIFO_NUM + 1)),
+		.bEndpointAddress   = 5,
+		.bmAttributes	    = USB_ENDPOINT_XFER_INT,
+	},
+};
+
+int sw_usb_device_enable(void)
+{
+	struct platform_device *pdev = g_udc_pdev;
+	struct sw_udc  	*udc    = &sw_udc;
+	int           	retval  = 0;
+	int            	irq     = SW_INT_IRQNO_USB0;
+
+	DMSG_INFO_UDC("sw_usb_device_enable start\n");
+
+	if(pdev == NULL){
+		DMSG_PANIC("pdev is null\n");
+		return -1;
+	}
+
+	usbd_port_no   	= 0;
+	usb_connect 	= 0;
+	crq_bRequest 	= 0;
+	is_controller_alive = 1;
+
+    memset(&g_sw_udc_io, 0, sizeof(sw_udc_io_t));
+
+    retval = sw_udc_io_init(usbd_port_no, pdev, &g_sw_udc_io);
+    if(retval != 0){
+        DMSG_PANIC("ERR: sw_udc_io_init failed\n");
+        return -1;
+    }
+
+	udc->sw_udc_io = &g_sw_udc_io;
+	udc->usbc_no = usbd_port_no;
+	strcpy((char *)udc->driver_name, gadget_name);
+	udc->irq_no	 = irq;
+
+	if(is_udc_support_dma()){
+		retval = sw_udc_dma_probe(udc);
+		if(retval != 0){
+			DMSG_PANIC("ERR: sw_udc_dma_probe failef\n");
+			retval = -EBUSY;
+			goto err;
+		}
+	}
+
+	retval = request_irq(irq, sw_udc_irq,
+			     IRQF_DISABLED, gadget_name, udc);
+	if (retval != 0) {
+		DMSG_PANIC("ERR: cannot get irq %i, err %d\n", irq, retval);
+		retval = -EBUSY;
+		goto err;
+	}
+
+	/* Enable udc */
+	if (!is_udc_enable)
+		sw_udc_set_pullup(udc, 1);
+
+	DMSG_INFO_UDC("sw_usb_device_enable end\n");
+
+    return 0;
+
+err:
+	if(is_udc_support_dma()){
+		sw_udc_dma_remove(udc);
+	}
+
+    sw_udc_io_exit(usbd_port_no, pdev, &g_sw_udc_io);
+
+    return retval;
+}
+EXPORT_SYMBOL(sw_usb_device_enable);
+
+int sw_usb_device_disable(void)
+{
+	struct platform_device *pdev = g_udc_pdev;
+	struct sw_udc *udc 	= NULL;
+	unsigned long	flags = 0;
+
+	DMSG_INFO_UDC("sw_usb_device_disable start\n");
+
+	if(pdev == NULL){
+		DMSG_PANIC("pdev is null\n");
+		return -1;
+	}
+
+	udc = platform_get_drvdata(pdev);
+	if(udc == NULL){
+		DMSG_PANIC("udc is null\n");
+		return -1;
+	}
+
+	/* disable usb controller */
+	if (udc->driver && udc->driver->disconnect)
+		udc->driver->disconnect(&udc->gadget);
+
+	/* Disable udc */
+	sw_udc_set_pullup(udc, 0);
+
+	if(is_udc_support_dma()){
+		sw_udc_dma_remove(udc);
+	}
+
+	free_irq(udc->irq_no, udc);
+
+	sw_udc_io_exit(usbd_port_no, pdev, &g_sw_udc_io);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+    memset(&g_sw_udc_io, 0, sizeof(sw_udc_io_t));
+
+	usbd_port_no   = 0;
+	usb_connect    = 0;
+	crq_bRequest   = 0;
+	is_controller_alive = 0;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	DMSG_INFO_UDC("sw_usb_device_disable end\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_usb_device_disable);
+
+/*
+*******************************************************************************
+*                     sw_udc_probe_otg
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_probe_otg(struct platform_device *pdev)
+{
+	struct sw_udc  	*udc = &sw_udc;
+
+	g_udc_pdev = pdev;
+
+	spin_lock_init (&udc->lock);
+
+	device_initialize(&udc->gadget.dev);
+	udc->gadget.dev.parent = &pdev->dev;
+	udc->gadget.dev.dma_mask = pdev->dev.dma_mask;
+
+	sw_udc_reinit(udc);
+
+	the_controller = udc;
+	platform_set_drvdata(pdev, udc);
+
+    return usb_add_gadget_udc(&pdev->dev, &udc->gadget);
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_remove_otg
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_remove_otg(struct platform_device *pdev)
+{
+	struct sw_udc *udc 	= NULL;
+
+	g_udc_pdev = NULL;
+
+	udc = platform_get_drvdata(pdev);
+	if (udc->driver){
+	    DMSG_PANIC("ERR: invalid argment, udc->driver(0x%p)\n", udc->driver);
+		return -EBUSY;
+    }
+	usb_del_gadget_udc(&udc->gadget);
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_probe_device_only
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_probe_device_only(struct platform_device *pdev)
+{
+	struct sw_udc  	*udc    = &sw_udc;
+//	struct device       *dev    = &pdev->dev;
+	int                 retval  = 0;
+	int                 irq     = SW_INT_IRQNO_USB0;
+
+    memset(&g_sw_udc_io, 0, sizeof(sw_udc_io_t));
+
+    retval = sw_udc_io_init(usbd_port_no, pdev, &g_sw_udc_io);
+    if(retval != 0){
+        DMSG_PANIC("ERR: sw_udc_io_init failed\n");
+        return -1;
+    }
+
+	spin_lock_init (&udc->lock);
+
+	device_initialize(&udc->gadget.dev);
+	udc->gadget.dev.parent = &pdev->dev;
+	udc->gadget.dev.dma_mask = pdev->dev.dma_mask;
+
+	is_controller_alive = 1;
+	the_controller = udc;
+	platform_set_drvdata(pdev, udc);
+
+	sw_udc_disable(udc);
+	sw_udc_reinit(udc);
+
+	udc->sw_udc_io = &g_sw_udc_io;
+	udc->usbc_no = usbd_port_no;
+	strcpy((char *)udc->driver_name, gadget_name);
+	udc->irq_no	 = irq;
+
+	if(is_udc_support_dma()){
+		retval = sw_udc_dma_probe(udc);
+		if(retval != 0){
+			DMSG_PANIC("ERR: sw_udc_dma_probe failef\n");
+			retval = -EBUSY;
+			goto err;
+		}
+	}
+
+	retval = request_irq(irq, sw_udc_irq,
+			     IRQF_DISABLED, gadget_name, udc);
+	if (retval != 0) {
+		DMSG_PANIC("ERR: cannot get irq %i, err %d\n", irq, retval);
+		retval = -EBUSY;
+		goto err;
+	}
+
+	retval = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
+	if (retval)
+		goto err;
+
+    return 0;
+
+err:
+	if(is_udc_support_dma()){
+		sw_udc_dma_remove(udc);
+	}
+
+    sw_udc_io_exit(usbd_port_no, pdev, &g_sw_udc_io);
+
+    return retval;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_remove_device_only
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_remove_device_only(struct platform_device *pdev)
+{
+	struct sw_udc *udc 	= platform_get_drvdata(pdev);
+
+	if (udc->driver){
+	    DMSG_PANIC("ERR: invalid argment\n");
+		return -EBUSY;
+    }
+
+	if(is_udc_support_dma()){
+		sw_udc_dma_remove(udc);
+	}
+
+	free_irq(udc->irq_no, udc);
+
+	sw_udc_io_exit(usbd_port_no, pdev, &g_sw_udc_io);
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_probe
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int __init sw_udc_probe(struct platform_device *pdev)
+{
+#ifdef  CONFIG_USB_SW_SUNXI_USB0_OTG
+	struct sw_udc_mach_info *udc_cfg = pdev->dev.platform_data;
+
+    switch(udc_cfg->port_info->port_type){
+        case USB_PORT_TYPE_DEVICE:
+            return sw_udc_probe_device_only(pdev);
+        //break;
+
+        case USB_PORT_TYPE_OTG:
+            return sw_udc_probe_otg(pdev);
+        //break;
+
+        default:
+            DMSG_PANIC("ERR: unkown port_type(%d)\n", udc_cfg->port_info->port_type);
+    }
+
+    return 0;
+#else
+    return sw_udc_probe_device_only(pdev);
+#endif
+}
+
+static int __devexit sw_udc_remove(struct platform_device *pdev)
+{
+#ifdef  CONFIG_USB_SW_SUNXI_USB0_OTG
+	struct sw_udc_mach_info *udc_cfg = pdev->dev.platform_data;
+
+    switch(udc_cfg->port_info->port_type){
+        case USB_PORT_TYPE_DEVICE:
+            return sw_udc_remove_device_only(pdev);
+        //break;
+
+        case USB_PORT_TYPE_OTG:
+            return sw_udc_remove_otg(pdev);
+        //break;
+
+        default:
+            DMSG_PANIC("ERR: unkown port_type(%d)\n", udc_cfg->port_info->port_type);
+    }
+
+    return 0;
+#else
+    return sw_udc_remove_device_only(pdev);
+#endif
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_suspend
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_suspend(struct platform_device *pdev, pm_message_t message)
+{
+	struct sw_udc *udc = platform_get_drvdata(pdev);
+
+    DMSG_INFO_UDC("sw_udc_suspend start\n");
+
+	if(!is_peripheral_active()){
+		DMSG_INFO_UDC("udc is disable, need not enter to suspend\n");
+		return 0;
+	}
+
+    /*  USB  PC,  suspend
+     *  USB  PC,  suspend
+     */
+    if(usb_connect){
+        DMSG_PANIC("ERR: usb is connect to PC, can not suspend\n");
+        return -EBUSY;
+    }
+
+    /* soft disconnect */
+	cfg_udc_command(SW_UDC_P_DISABLE);
+
+    /* disable usb controller */
+	if (udc->driver && udc->driver->disconnect) {
+		udc->driver->disconnect(&udc->gadget);
+	}
+
+	sw_udc_disable(udc);
+
+	/* close USB clock */
+	close_usb_clock(&g_sw_udc_io);
+
+    DMSG_INFO_UDC("sw_udc_suspend end\n");
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_resume
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int sw_udc_resume(struct platform_device *pdev)
+{
+	struct sw_udc *udc = platform_get_drvdata(pdev);
+
+    DMSG_INFO_UDC("sw_udc_resume start\n");
+
+	if(!is_peripheral_active()){
+		DMSG_INFO_UDC("udc is disable, need not enter to resume\n");
+		return 0;
+	}
+
+	/* open USB clock */
+	open_usb_clock(&g_sw_udc_io);
+
+	if (is_udc_enable){
+		/* enable usb controller */
+		sw_udc_set_pullup(udc, 1);
+	}
+
+	DMSG_INFO_UDC("sw_udc_resume end\n");
+
+	return 0;
+}
+
+static struct platform_driver sw_udc_driver = {
+	.driver		= {
+		.name	= (char *)gadget_name,
+		.bus	= &platform_bus_type,
+		.owner	= THIS_MODULE,
+	},
+
+//	.probe		= sw_udc_probe,
+	.remove		= __devexit_p(sw_udc_remove),
+	.suspend	= sw_udc_suspend,
+	.resume		= sw_udc_resume,
+};
+
+static void cfg_udc_command(enum sw_udc_cmd_e cmd)
+{
+	struct sw_udc *udc = the_controller;
+
+	switch (cmd)
+	{
+		case SW_UDC_P_ENABLE:
+		{
+        	if(udc->driver){
+        			usbd_start_work();
+            }else{
+                DMSG_INFO("udc->driver is null, udc is need not start\n");
+            }
+        }
+		break;
+
+		case SW_UDC_P_DISABLE:
+		{
+        	if(udc->driver){
+        			usbd_stop_work();
+            }else{
+                DMSG_INFO("udc->driver is null, udc is need not stop\n");
+            }
+        }
+		break;
+
+		case SW_UDC_P_RESET :
+			DMSG_PANIC("ERR: reset is not support\n");
+		break;
+
+		default:
+			DMSG_PANIC("ERR: unkown cmd(%d)\n",cmd);
+			break;
+	}
+
+	return ;
+}
+
+static void cfg_vbus_draw(unsigned int ma)
+{
+	return;
+}
+
+/*
+*******************************************************************************
+*                     udc_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static int __init udc_init(void)
+{
+	DMSG_INFO_UDC("udc_init: version %s\n", DRIVER_VERSION);
+
+    usb_connect = 0;
+
+    /* driver register */
+	return platform_driver_probe(&sw_udc_driver, sw_udc_probe);
+}
+
+/*
+*******************************************************************************
+*                     udc_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void __exit udc_exit(void)
+{
+	DMSG_INFO_UDC("udc_exit: version %s\n", DRIVER_VERSION);
+	/*TODO: add remove udc gadget driver*/
+	platform_driver_unregister(&sw_udc_driver);
+
+	return ;
+}
+
+//module_init(udc_init);
+fs_initcall(udc_init);
+module_exit(udc_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:softwinner-usbgadget");
+
+
diff --git a/drivers/usb/sunxi_usb/udc/sw_udc_board.c b/drivers/usb/sunxi_usb/udc/sw_udc_board.c
new file mode 100644
index 0000000..6aaa8d3
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sw_udc_board.c
@@ -0,0 +1,470 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sw_udc_board.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include  <mach/clock.h>
+#include  "sw_udc_config.h"
+#include  "sw_udc_board.h"
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+
+#define res_size(_r) (((_r)->end - (_r)->start) + 1)
+
+#if 1
+/*
+*******************************************************************************
+*                     open_usb_clock
+*
+* Description:
+*
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+u32  open_usb_clock(sw_udc_io_t *sw_udc_io)
+{
+ 	DMSG_INFO_UDC("open_usb_clock\n");
+
+	if(sw_udc_io->sie_clk && sw_udc_io->phy_clk && sw_udc_io->phy0_clk && !sw_udc_io->clk_is_open){
+	   	clk_enable(sw_udc_io->sie_clk);
+		mdelay(10);
+
+	    clk_enable(sw_udc_io->phy_clk);
+	    clk_enable(sw_udc_io->phy0_clk);
+	    clk_reset(sw_udc_io->phy0_clk, 0);
+		mdelay(10);
+
+		sw_udc_io->clk_is_open = 1;
+	}else{
+		DMSG_PANIC("ERR: clock handle is null, sie_clk(0x%p), phy_clk(0x%p), phy0_clk(0x%p), open(%d)\n",
+			       sw_udc_io->sie_clk, sw_udc_io->phy_clk, sw_udc_io->phy0_clk, sw_udc_io->clk_is_open);
+	}
+
+	UsbPhyInit(0);
+
+#if 0
+	DMSG_INFO("[udc0]: open, 0x60(0x%x), 0xcc(0x%x)\n",
+		      (u32)USBC_Readl(SW_VA_CCM_IO_BASE + 0x60),
+		      (u32)USBC_Readl(SW_VA_CCM_IO_BASE + 0xcc));
+#endif
+
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     close_usb_clock
+*
+* Description:
+*
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+u32 close_usb_clock(sw_udc_io_t *sw_udc_io)
+{
+	DMSG_INFO_UDC("close_usb_clock\n");
+
+	if(sw_udc_io->sie_clk && sw_udc_io->phy_clk && sw_udc_io->phy0_clk && sw_udc_io->clk_is_open){
+		sw_udc_io->clk_is_open = 0;
+
+	    clk_reset(sw_udc_io->phy0_clk, 1);
+	    clk_disable(sw_udc_io->phy0_clk);
+	    clk_disable(sw_udc_io->phy_clk);
+	    clk_disable(sw_udc_io->sie_clk);
+	}else{
+		DMSG_PANIC("ERR: clock handle is null, sie_clk(0x%p), phy_clk(0x%p), phy0_clk(0x%p), open(%d)\n",
+			       sw_udc_io->sie_clk, sw_udc_io->phy_clk, sw_udc_io->phy0_clk, sw_udc_io->clk_is_open);
+	}
+
+#if 0
+	DMSG_INFO("[udc0]: close, 0x60(0x%x), 0xcc(0x%x)\n",
+		      (u32)USBC_Readl(SW_VA_CCM_IO_BASE + 0x60),
+		      (u32)USBC_Readl(SW_VA_CCM_IO_BASE + 0xcc));
+#endif
+
+	return 0;
+}
+
+#else
+
+/*
+*******************************************************************************
+*                     open_usb_clock
+*
+* Description:
+*
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+u32  open_usb_clock(sw_udc_io_t *sw_udc_io)
+{
+    u32 reg_value = 0;
+    u32 ccmu_base = SW_VA_CCM_IO_BASE;
+
+ 	DMSG_INFO_UDC("open_usb_clock\n");
+
+    //Gating AHB clock for USB_phy0
+	reg_value = USBC_Readl(ccmu_base + 0x60);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value |= (1 << 2);
+	reg_value |= (1 << 1);
+#endif
+	reg_value |= (1 << 0);	            /* AHB clock gate usb0 */
+	USBC_Writel(reg_value, (ccmu_base + 0x60));
+
+    //delay to wati SIE stable
+	reg_value = 10000;
+	while(reg_value--);
+
+	//Enable module clock for USB phy0
+	reg_value = USBC_Readl(ccmu_base + 0xcc);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value |= (1 << 9);
+#endif
+	reg_value |= (1 << 8);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value |= (1 << 6);
+	reg_value |= (1 << 1);
+#endif
+	reg_value |= (1 << 0);          //disable reset
+	USBC_Writel(reg_value, (ccmu_base + 0xcc));
+
+	//delay some time
+	reg_value = 10000;
+	while(reg_value--);
+  sw_udc_io->clk_is_open = 1;
+	return 0;
+}
+
+/*
+*******************************************************************************
+*                     close_usb_clock
+*
+* Description:
+*
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+u32 close_usb_clock(sw_udc_io_t *sw_udc_io)
+{
+#if defined(CONFIG_ARCH_SUN4I)
+    u32 reg_value = 0;
+    u32 ccmu_base = SW_VA_CCM_IO_BASE;
+
+	DMSG_INFO_UDC("close_usb_clock\n");
+
+    //Gating AHB clock for USB_phy0
+	reg_value = USBC_Readl(ccmu_base + 0x60);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value &= ~(1 << 2);
+	reg_value &= ~(1 << 1);
+#endif
+	reg_value &= ~(1 << 0);	            /* AHB clock gate usb0 */
+	USBC_Writel(reg_value, (ccmu_base + 0x60));
+
+    //sie
+	reg_value = 10000;
+	while(reg_value--);
+
+	//Enable module clock for USB phy0
+	reg_value = USBC_Readl(ccmu_base + 0xcc);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value &= ~(1 << 9);
+#endif
+	reg_value &= ~(1 << 8);
+#if defined(CONFIG_ARCH_SUN5I)
+	reg_value &= ~(1 << 6);
+	reg_value &= ~(1 << 1);
+#endif
+	reg_value &= ~(1 << 0);          //disable reset
+	USBC_Writel(reg_value, (ccmu_base + 0xcc));
+
+	//
+	reg_value = 10000;
+	while(reg_value--);
+  sw_udc_io->clk_is_open = 0;
+#endif
+	return 0;
+
+}
+
+#endif
+
+/*
+*******************************************************************************
+*                     sw_udc_bsp_init
+*
+* Description:
+*    initialize usb bsp
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 sw_udc_bsp_init(__u32 usbc_no, sw_udc_io_t *sw_udc_io)
+{
+	sw_udc_io->usbc.usbc_info[usbc_no].num = usbc_no;
+   	sw_udc_io->usbc.usbc_info[usbc_no].base = (u32)sw_udc_io->usb_vbase;
+	sw_udc_io->usbc.sram_base = (u32)sw_udc_io->sram_vbase;
+
+//	USBC_init(&sw_udc_io->usbc);
+	sw_udc_io->usb_bsp_hdle = USBC_open_otg(usbc_no);
+	if(sw_udc_io->usb_bsp_hdle == 0){
+		DMSG_PANIC("ERR: sw_udc_init: USBC_open_otg failed\n");
+		return -1;
+	}
+
+	USBC_EnhanceSignal(sw_udc_io->usb_bsp_hdle);
+
+	USBC_EnableDpDmPullUp(sw_udc_io->usb_bsp_hdle);
+    USBC_EnableIdPullUp(sw_udc_io->usb_bsp_hdle);
+	USBC_ForceId(sw_udc_io->usb_bsp_hdle, USBC_ID_TYPE_DEVICE);
+	USBC_ForceVbusValid(sw_udc_io->usb_bsp_hdle, USBC_VBUS_TYPE_HIGH);
+
+	USBC_SelectBus(sw_udc_io->usb_bsp_hdle, USBC_IO_TYPE_PIO, 0, 0);
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_bsp_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 sw_udc_bsp_exit(__u32 usbc_no, sw_udc_io_t *sw_udc_io)
+{
+    USBC_DisableDpDmPullUp(sw_udc_io->usb_bsp_hdle);
+    USBC_DisableIdPullUp(sw_udc_io->usb_bsp_hdle);
+	USBC_ForceId(sw_udc_io->usb_bsp_hdle, USBC_ID_TYPE_DISABLE);
+	USBC_ForceVbusValid(sw_udc_io->usb_bsp_hdle, USBC_VBUS_TYPE_DISABLE);
+
+	USBC_close_otg(sw_udc_io->usb_bsp_hdle);
+	sw_udc_io->usb_bsp_hdle = 0;
+
+//	USBC_exit(&sw_udc_io->usbc);
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_io_init
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 sw_udc_io_init(__u32 usbc_no, struct platform_device *pdev, sw_udc_io_t *sw_udc_io)
+{
+	__s32 ret = 0;
+	spinlock_t lock;
+	unsigned long flags = 0;
+
+	sw_udc_io->usb_vbase  = (void __iomem *)SW_VA_USB0_IO_BASE;
+	sw_udc_io->sram_vbase = (void __iomem *)SW_VA_SRAM_IO_BASE;
+
+	DMSG_INFO_UDC("usb_vbase  = 0x%x\n", (u32)sw_udc_io->usb_vbase);
+	DMSG_INFO_UDC("sram_vbase = 0x%x\n", (u32)sw_udc_io->sram_vbase);
+
+    /* open usb lock */
+	sw_udc_io->sie_clk = clk_get(NULL, "ahb_usb0");
+	if (IS_ERR(sw_udc_io->sie_clk)){
+		DMSG_PANIC("ERR: get usb sie clk failed.\n");
+		goto io_failed;
+	}
+
+	sw_udc_io->phy_clk = clk_get(NULL, "usb_phy");
+	if (IS_ERR(sw_udc_io->phy_clk)){
+		DMSG_PANIC("ERR: get usb phy clk failed.\n");
+		goto io_failed;
+	}
+
+	sw_udc_io->phy0_clk = clk_get(NULL, "usb_phy0");
+	if (IS_ERR(sw_udc_io->phy0_clk)){
+		DMSG_PANIC("ERR: get usb phy0 clk failed.\n");
+		goto io_failed;
+	}
+
+	open_usb_clock(sw_udc_io);
+
+    /* initialize usb bsp */
+	sw_udc_bsp_init(usbc_no, sw_udc_io);
+
+	/* config usb fifo */
+	spin_lock_init(&lock);
+	spin_lock_irqsave(&lock, flags);
+	USBC_ConfigFIFO_Base(sw_udc_io->usb_bsp_hdle, (u32)sw_udc_io->sram_vbase, USBC_FIFO_MODE_8K);
+	spin_unlock_irqrestore(&lock, flags);
+
+	return 0;
+
+io_failed:
+	if(sw_udc_io->sie_clk){
+		clk_put(sw_udc_io->sie_clk);
+		sw_udc_io->sie_clk = NULL;
+	}
+
+	if(sw_udc_io->phy_clk){
+		clk_put(sw_udc_io->phy_clk);
+		sw_udc_io->phy_clk = NULL;
+	}
+
+	if(sw_udc_io->phy0_clk){
+		clk_put(sw_udc_io->phy0_clk);
+		sw_udc_io->phy0_clk = NULL;
+	}
+
+	return ret;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_exit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 sw_udc_io_exit(__u32 usbc_no, struct platform_device *pdev, sw_udc_io_t *sw_udc_io)
+{
+	sw_udc_bsp_exit(usbc_no, sw_udc_io);
+
+	close_usb_clock(sw_udc_io);
+
+	if(sw_udc_io->sie_clk){
+		clk_put(sw_udc_io->sie_clk);
+		sw_udc_io->sie_clk = NULL;
+	}
+
+	if(sw_udc_io->phy_clk){
+		clk_put(sw_udc_io->phy_clk);
+		sw_udc_io->phy_clk = NULL;
+	}
+
+	if(sw_udc_io->phy0_clk){
+		clk_put(sw_udc_io->phy0_clk);
+		sw_udc_io->phy0_clk = NULL;
+	}
+
+	sw_udc_io->usb_vbase  = NULL;
+	sw_udc_io->sram_vbase = NULL;
+
+	return 0;
+}
+
+
+
+
+
diff --git a/drivers/usb/sunxi_usb/udc/sw_udc_board.h b/drivers/usb/sunxi_usb/udc/sw_udc_board.h
new file mode 100644
index 0000000..5bf628b
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sw_udc_board.h
@@ -0,0 +1,35 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sw_udc_board.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_UDC_BOARD_H__
+#define  __SW_UDC_BOARD_H__
+
+u32 open_usb_clock(sw_udc_io_t *sw_udc_io);
+u32 close_usb_clock(sw_udc_io_t *sw_udc_io);
+
+__s32 sw_udc_io_init(__u32 usbc_no, struct platform_device *pdev, sw_udc_io_t *sw_udc_io);
+__s32 sw_udc_io_exit(__u32 usbc_no, struct platform_device *pdev, sw_udc_io_t *sw_udc_io);
+
+#endif   //__SW_UDC_BOARD_H__
+
+
diff --git a/drivers/usb/sunxi_usb/udc/sw_udc_config.h b/drivers/usb/sunxi_usb/udc/sw_udc_config.h
new file mode 100644
index 0000000..2008aa3
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sw_udc_config.h
@@ -0,0 +1,56 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sw_udc_config.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_UDC_CONFIG_H__
+#define  __SW_UDC_CONFIG_H__
+
+
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+
+#include  "../include/sw_usb_config.h"
+
+#define  SW_UDC_DOUBLE_FIFO       /*  FIFO          */
+//#define  SW_UDC_DMA               /* DMA          */
+#define  SW_UDC_HS_TO_FS          /*  */
+//#define  SW_UDC_DEBUG
+
+//---------------------------------------------------------------
+//  
+//---------------------------------------------------------------
+
+/* sw udc  */
+#if	0
+    #define DMSG_DBG_UDC     			DMSG_MSG
+#else
+    #define DMSG_DBG_UDC(...)
+#endif
+
+
+#endif   //__SW_UDC_CONFIG_H__
+
diff --git a/drivers/usb/sunxi_usb/udc/sw_udc_debug.c b/drivers/usb/sunxi_usb/udc/sw_udc_debug.c
new file mode 100644
index 0000000..2423bbd
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sw_udc_debug.c
@@ -0,0 +1,86 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sw_udc_debug.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include  "sw_udc_config.h"
+#include  "sw_udc_board.h"
+#include  "sw_udc_debug.h"
+
+/*
+*******************************************************************************
+*                     print_list_node
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void print_list_node(struct sw_udc_ep *ep, char *str)
+{
+#ifdef SW_UDC_DEBUG
+//#if 1
+	struct sw_udc_request	*req = NULL;
+	unsigned long		flags = 0;
+
+	local_irq_save(flags);
+
+	DMSG_INFO("---------------ep%d: %s-------------\n", ep->num, str);
+	list_for_each_entry (req, &ep->queue, queue) {
+		DMSG_INFO("print_list_node: ep(0x%p, %d), req(0x%p, 0x%p, %d, %d)\n\n",
+			         ep, ep->num,
+			         req, &(req->req), req->req.length, req->req.actual);
+	}
+	DMSG_INFO("-------------------------------------\n");
+
+	local_irq_restore(flags);
+
+	return;
+#endif
+}
+
+
diff --git a/drivers/usb/sunxi_usb/udc/sw_udc_debug.h b/drivers/usb/sunxi_usb/udc/sw_udc_debug.h
new file mode 100644
index 0000000..6ef5b6b
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sw_udc_debug.h
@@ -0,0 +1,34 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sw_udc_debug.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_UDC_DEBUG_H__
+#define  __SW_UDC_DEBUG_H__
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+
+void print_list_node(struct sw_udc_ep *ep, char *str);
+
+#endif   //__SW_UDC_DEBUG_H__
+
diff --git a/drivers/usb/sunxi_usb/udc/sw_udc_dma.c b/drivers/usb/sunxi_usb/udc/sw_udc_dma.c
new file mode 100644
index 0000000..f510b9f
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sw_udc_dma.c
@@ -0,0 +1,545 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sw_udc_dma.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <asm/cacheflush.h>
+
+#include  "sw_udc_config.h"
+#include  "sw_udc_board.h"
+#include  "sw_udc_dma.h"
+
+#ifdef SW_UDC_DMA
+
+static sw_udc_dma_parg_t sw_udc_dma_para;
+
+extern void sw_udc_dma_completion(struct sw_udc *dev, struct sw_udc_ep *ep, struct sw_udc_request *req);
+
+static void sw_udc_CleanFlushDCacheRegion(void *adr, __u32 bytes)
+{
+	__cpuc_flush_dcache_area(adr, bytes + (1 << 5) * 2 - 2);
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_switch_bus_to_dma
+*
+* Description:
+*     USB  DMA
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_udc_switch_bus_to_dma(struct sw_udc_ep *ep, u32 is_tx)
+{
+	if(!is_tx){ /* ep in, rx */
+		USBC_SelectBus(ep->dev->sw_udc_io->usb_bsp_hdle,
+			           USBC_IO_TYPE_DMA,
+			           USBC_EP_TYPE_RX,
+			           ep->num);
+	}else{  /* ep out, tx */
+		USBC_SelectBus(ep->dev->sw_udc_io->usb_bsp_hdle,
+					   USBC_IO_TYPE_DMA,
+					   USBC_EP_TYPE_TX,
+					   ep->num);
+	}
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_switch_bus_to_pio
+*
+* Description:
+*     USB  PIO
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_udc_switch_bus_to_pio(struct sw_udc_ep *ep, __u32 is_tx)
+{
+	USBC_SelectBus(ep->dev->sw_udc_io->usb_bsp_hdle, USBC_IO_TYPE_PIO, 0, 0);
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_enable_dma_channel_irq
+*
+* Description:
+*     DMA channel 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_udc_enable_dma_channel_irq(struct sw_udc_ep *ep)
+{
+	DMSG_DBG_DMA("sw_udc_enable_dma_channel_irq\n");
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_disable_dma_channel_irq
+*
+* Description:
+*     DMA channel 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_udc_disable_dma_channel_irq(struct sw_udc_ep *ep)
+{
+	DMSG_DBG_DMA("sw_udc_disable_dma_channel_irq\n");
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_set_config
+*
+* Description:
+*     DMA
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_udc_dma_set_config(struct sw_udc_ep *ep, struct sw_udc_request *req, __u32 buff_addr, __u32 len)
+{
+	struct dma_hw_conf dma_config;
+
+	__u32 is_tx				= 0;
+	__u32 packet_size		= 0;
+	__u32 usbc_no          	= 0;
+	__u32 usb_cmt_blk_cnt  	= 0;
+	__u32 dram_cmt_blk_cnt 	= 0;
+	__u32 fifo_addr 	   	= 0;
+
+	memset(&dma_config, 0, sizeof(struct dma_hw_conf));
+
+	is_tx = is_tx_ep(ep);
+	packet_size = ep->ep.maxpacket;
+
+	usb_cmt_blk_cnt  = (((packet_size >> 2) - 1) << 8) | 0x0f;
+	dram_cmt_blk_cnt = (((packet_size >> 2) - 1) << 8);
+	fifo_addr        = USBC_REG_EPFIFOx(USBC0_BASE, ep->num);
+
+	DMSG_DBG_DMA("config: ep(%d), fifo_addr(0x%x), buff_addr(0x%x), len (0x%x)\n",
+		      	ep->num, fifo_addr, buff_addr, len);
+
+	if(!is_tx){ /* ep out, rx*/
+		usbc_no = D_DRQSRC_USB0;
+		dma_config.drqsrc_type	= usbc_no;
+		dma_config.drqdst_type	= D_DRQDST_SDRAM;
+		if((u32)buff_addr & 0x03){
+			dma_config.xfer_type = DMAXFER_D_SBYTE_S_BWORD;
+		}else{
+			dma_config.xfer_type = DMAXFER_D_BWORD_S_BWORD;
+		}
+		dma_config.address_type	= DMAADDRT_D_LN_S_IO;
+		dma_config.dir			= SW_DMA_RDEV;
+		dma_config.hf_irq		= SW_DMA_IRQ_FULL;
+		dma_config.reload		= 0;
+		dma_config.from			= fifo_addr;
+		dma_config.to			= 0;
+		dma_config.cmbk			= usb_cmt_blk_cnt | (dram_cmt_blk_cnt << 16);
+	}else{ /* ep out, tx*/
+		usbc_no = D_DRQDST_USB0;
+		dma_config.drqsrc_type	= D_DRQSRC_SDRAM;
+		dma_config.drqdst_type	= usbc_no;
+		if((u32)buff_addr & 0x03){
+			dma_config.xfer_type = DMAXFER_D_BWORD_S_SBYTE;
+		}else{
+			dma_config.xfer_type = DMAXFER_D_BWORD_S_BWORD;
+		}
+		dma_config.address_type	= DMAADDRT_D_IO_S_LN;
+		dma_config.dir			= SW_DMA_WDEV;
+		dma_config.hf_irq		= SW_DMA_IRQ_FULL;
+		dma_config.reload		= 0;
+		dma_config.from			= 0;
+		dma_config.to			= fifo_addr;
+		dma_config.cmbk			= (usb_cmt_blk_cnt << 16) | dram_cmt_blk_cnt;
+	}
+
+	sw_udc_dma_para.ep    = ep;
+	sw_udc_dma_para.req	= req;
+
+	sw_dma_config(ep->dev->sw_udc_dma.dma_hdle, &dma_config);
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_start
+*
+* Description:
+*     DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_udc_dma_start(struct sw_udc_ep *ep, __u32 fifo, __u32 buffer, __u32 len)
+{
+	DMSG_DBG_DMA("start: ep(%d), fifo = 0x%x, buffer = (0x%x, 0x%x), len = 0x%x\n",
+		      sw_udc_dma_para.ep->num,
+		      fifo, buffer, (u32)phys_to_virt(buffer), len);
+
+	sw_udc_CleanFlushDCacheRegion((void *)buffer, (size_t)len);
+
+	sw_udc_switch_bus_to_dma(ep, is_tx_ep(ep));
+
+	sw_dma_enqueue(ep->dev->sw_udc_dma.dma_hdle, NULL, (dma_addr_t)buffer, len);
+	sw_dma_ctrl(ep->dev->sw_udc_dma.dma_hdle, SW_DMAOP_START);
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_stop
+*
+* Description:
+*     DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void sw_udc_dma_stop(struct sw_udc_ep *ep)
+{
+	DMSG_DBG_DMA("sw_udc_dma_stop\n");
+
+	sw_dma_ctrl(ep->dev->sw_udc_dma.dma_hdle, SW_DMAOP_STOP);
+
+	sw_udc_switch_bus_to_pio(ep, is_tx_ep(ep));
+
+	sw_udc_dma_para.ep    			= NULL;
+	sw_udc_dma_para.req				= NULL;
+
+    return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_transmit_length
+*
+* Description:
+*     DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+#if 0
+__u32 sw_udc_dma_left_length(struct sw_udc_ep *ep, __u32 is_in, __u32 buffer_addr)
+{
+    dma_addr_t src = 0;
+    dma_addr_t dst = 0;
+	__u32 dma_buffer = 0;
+	__u32 left_len = 0;
+
+	DMSG_DBG_DMA("sw_udc_dma_transmit_length\n");
+
+	sw_dma_getcurposition(ep->dev->sw_udc_dma.dma_hdle, &src, &dst);
+	if(is_in){	/* tx */
+		dma_buffer = (__u32)src;
+	}else{	/* rx */
+		dma_buffer = (__u32)dst;
+	}
+
+	left_len = buffer_addr - (u32)phys_to_virt(dma_buffer);
+
+    DMSG_DBG_DMA("dma transfer lenght, buffer_addr(0x%x), dma_buffer(0x%x), left_len(%d), want(%d)\n",
+		      buffer_addr, dma_buffer, left_len, ep->dma_transfer_len);
+
+    return left_len;
+}
+
+__u32 sw_udc_dma_transmit_length(struct sw_udc_ep *ep, __u32 is_in, __u32 buffer_addr)
+{
+    if(ep->dma_transfer_len){
+		return (ep->dma_transfer_len - sw_udc_dma_left_length(ep, is_in, buffer_addr));
+	}
+
+	return ep->dma_transfer_len;
+}
+
+#else
+__u32 sw_udc_dma_transmit_length(struct sw_udc_ep *ep, __u32 is_in, __u32 buffer_addr)
+{
+    return ep->dma_transfer_len;
+}
+#endif
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_probe
+*
+* Description:
+*    DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__u32 sw_udc_dma_is_busy(struct sw_udc_ep *ep)
+{
+	return 	ep->dma_working;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_probe
+*
+* Description:
+*    DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static void sw_udc_dma_callback(struct sw_dma_chan * ch, void *buf, int size, enum sw_dma_buffresult result)
+{
+	struct sw_udc_ep *ep = sw_udc_dma_para.ep;
+	struct sw_udc_request *req = sw_udc_dma_para.req;
+
+	DMSG_DBG_DMA("callback: epnum(%d), ep(0x%p), length(%d)\n",
+		  		sw_udc_dma_para.ep->num, sw_udc_dma_para.ep, sw_udc_dma_para.ep->dma_transfer_len);
+
+	if(sw_udc_dma_para.ep){
+		sw_udc_switch_bus_to_pio(sw_udc_dma_para.ep, is_tx_ep(sw_udc_dma_para.ep));
+
+		sw_udc_dma_para.ep = NULL;
+		sw_udc_dma_para.req = NULL;
+
+		sw_udc_dma_completion(sw_udc_dma_para.dev, ep, req);
+	}else{
+		DMSG_PANIC("ERR: sw_udc_dma_callback: dma is remove, but dma irq is happened, (0x%x, 0x%p)\n",
+			       sw_udc_dma_para.dev->sw_udc_dma.dma_hdle, sw_udc_dma_para.ep);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_probe
+*
+* Description:
+*    DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 sw_udc_dma_probe(struct sw_udc *dev)
+{
+    __u32 channel = 0;
+
+	DMSG_DBG_DMA("sw_udc_dma_probe\n");
+
+	memset(&sw_udc_dma_para, 0, sizeof(sw_udc_dma_parg_t));
+	sw_udc_dma_para.dev = dev;
+
+    /* request dma */
+	strcpy(dev->sw_udc_dma.name, dev->driver_name);
+	strcat(dev->sw_udc_dma.name, "_dma");
+	dev->sw_udc_dma.dma_client.name = dev->sw_udc_dma.name;
+
+	channel = DMACH_DUSB0;
+
+	dev->sw_udc_dma.dma_hdle = sw_dma_request(channel, &(dev->sw_udc_dma.dma_client), NULL);
+	if(dev->sw_udc_dma.dma_hdle < 0){
+		DMSG_PANIC("ERR: sw_dma_request failed\n");
+		return -1;
+	}
+
+	DMSG_INFO_UDC("dma probe name(%s), dma_hdle = 0x%x\n",
+		      dev->sw_udc_dma.name, dev->sw_udc_dma.dma_hdle);
+
+	/* set callback */
+	sw_dma_set_buffdone_fn(dev->sw_udc_dma.dma_hdle, sw_udc_dma_callback);
+
+    return 0;
+}
+
+/*
+*******************************************************************************
+*                     sw_udc_dma_remove
+*
+* Description:
+*    DMA 
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+__s32 sw_udc_dma_remove(struct sw_udc *dev)
+{
+	__u32 channel = 0;
+
+	DMSG_INFO_UDC("dma remove\n");
+
+	channel = DMACH_DUSB0;
+
+
+	if(dev->sw_udc_dma.dma_hdle >= 0){
+		sw_dma_free(channel, &(dev->sw_udc_dma.dma_client));
+		dev->sw_udc_dma.dma_hdle = -1;
+	}else{
+		DMSG_PANIC("ERR: sw_udc_dma_remove, dma_hdle is null\n");
+	}
+
+	memset(&sw_udc_dma_para, 0, sizeof(sw_udc_dma_parg_t));
+
+	return 0;
+}
+
+#else
+
+void sw_udc_switch_bus_to_ddma(struct sw_udc_ep *ep, u32 is_tx){}
+void sw_udc_switch_bus_to_pio(struct sw_udc_ep *ep, __u32 is_tx){}
+
+void sw_udc_enable_dma_channel_irq(struct sw_udc_ep *ep){}
+void sw_udc_disable_dma_channel_irq(struct sw_udc_ep *ep){}
+
+void sw_udc_dma_set_config(struct sw_udc_ep *ep, struct sw_udc_request *req, __u32 buff_addr, __u32 len){}
+void sw_udc_dma_start(struct sw_udc_ep *ep, __u32 fifo, __u32 buffer, __u32 len){}
+void sw_udc_dma_stop(struct sw_udc_ep *ep){}
+__u32 sw_udc_dma_transmit_length(struct sw_udc_ep *ep, __u32 is_in, __u32 buffer_addr){return 0;}
+__u32 sw_udc_dma_is_busy(struct sw_udc_ep *ep){return 0;}
+
+__s32 sw_udc_dma_probe(struct sw_udc *dev){return 0;}
+__s32 sw_udc_dma_remove(struct sw_udc *dev){return 0;}
+
+#endif
diff --git a/drivers/usb/sunxi_usb/udc/sw_udc_dma.h b/drivers/usb/sunxi_usb/udc/sw_udc_dma.h
new file mode 100644
index 0000000..5f7ba8e
--- /dev/null
+++ b/drivers/usb/sunxi_usb/udc/sw_udc_dma.h
@@ -0,0 +1,58 @@
+/*
+ * drivers/usb/sunxi_usb/udc/sw_udc_dma.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * javen <javen@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SW_UDC_DMA_H__
+#define  __SW_UDC_DMA_H__
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+#ifdef  SW_UDC_DMA
+#define  is_udc_support_dma()       1
+#else
+#define  is_udc_support_dma()       0
+#endif
+
+
+#define  is_tx_ep(ep)		((ep->bEndpointAddress) & USB_DIR_IN)
+
+//---------------------------------------------------------------
+//   
+//---------------------------------------------------------------
+void sw_udc_switch_bus_to_dma(struct sw_udc_ep *ep, u32 is_tx);
+void sw_udc_switch_bus_to_pio(struct sw_udc_ep *ep, __u32 is_tx);
+
+void sw_udc_enable_dma_channel_irq(struct sw_udc_ep *ep);
+void sw_udc_disable_dma_channel_irq(struct sw_udc_ep *ep);
+
+void sw_udc_dma_set_config(struct sw_udc_ep *ep, struct sw_udc_request *req, __u32 buff_addr, __u32 len);
+void sw_udc_dma_start(struct sw_udc_ep *ep, __u32 fifo, __u32 buffer, __u32 len);
+void sw_udc_dma_stop(struct sw_udc_ep *ep);
+__u32 sw_udc_dma_transmit_length(struct sw_udc_ep *ep, __u32 is_in, __u32 buffer_addr);
+__u32 sw_udc_dma_is_busy(struct sw_udc_ep *ep);
+
+__s32 sw_udc_dma_probe(struct sw_udc *dev);
+__s32 sw_udc_dma_remove(struct sw_udc *dev);
+
+#endif   //__SW_UDC_DMA_H__
+
diff --git a/drivers/usb/sunxi_usb/usbc/usbc.c b/drivers/usb/sunxi_usb/usbc/usbc.c
new file mode 100644
index 0000000..c79d336
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc.c
@@ -0,0 +1,1923 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel <daniel@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include  "usbc_i.h"
+
+
+static __u32 usbc_base_address[USBC_MAX_CTL_NUM];       /* usb base address */
+static __usbc_otg_t usbc_otg_array[USBC_MAX_OPEN_NUM];  /* usbc , USB */
+static __fifo_info_t usbc_info_g;
+
+/*
+***********************************************************************************
+*                     USBC_GetVbusStatus
+*
+* Description:
+*    vbus
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*    vbus
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_GetVbusStatus(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+    __u8 reg_val = 0;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	reg_val = USBC_Readb(USBC_REG_DEVCTL(usbc_otg->base_addr));
+	reg_val = reg_val >> USBC_BP_DEVCTL_VBUS;
+    switch(reg_val & 0x03){
+		case 0x00:
+			return USBC_VBUS_STATUS_BELOW_SESSIONEND;
+		//break;
+
+		case 0x01:
+			return USBC_VBUS_STATUS_ABOVE_SESSIONEND_BELOW_AVALID;
+		//break;
+
+		case 0x02:
+			return USBC_VBUS_STATUS_ABOVE_AVALID_BELOW_VBUSVALID;
+		//break;
+
+		case 0x03:
+			return USBC_VBUS_STATUS_ABOVE_VBUSVALID;
+		//break;
+
+		default:
+			return USBC_VBUS_STATUS_BELOW_SESSIONEND;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_OTG_SelectMode
+*
+* Description:
+*    device, host
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_OTG_SelectMode(__hdle hUSB, __u32 mode)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	if(mode == USBC_OTG_HOST){
+
+	}else{
+
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_ReadLenFromFifo
+*
+* Description:
+*    fifo
+*
+* Arguments:
+*    hUSB     :  input.  USBC_open_otg, USBC
+*    ep_type  :  input.  ep, rx  tx
+* Returns:
+*    fifo
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_ReadLenFromFifo(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return USBC_Readw(USBC_REG_COUNT0(usbc_otg->base_addr));
+		//break;
+
+		case USBC_EP_TYPE_TX:
+			return 0;
+		//break;
+
+		case USBC_EP_TYPE_RX:
+			return USBC_Readw(USBC_REG_RXCOUNT(usbc_otg->base_addr));
+		//break;
+
+		default:
+			return 0;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_WritePacket
+*
+* Description:
+*    fifo
+*
+* Arguments:
+*    hUSB    :  input.  USBC_open_otg, USBC
+*    fifo    :  input.  fifo.
+*    cnt     :  input.  
+*    buff    :  input.  
+*
+* Returns:
+*    
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_WritePacket(__hdle hUSB, __u32 fifo, __u32 cnt, void *buff)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 len = 0;
+	__u32 i32 = 0;
+	__u32 i8  = 0;
+	__u8  *buf8  = NULL;
+	__u32 *buf32 = NULL;
+
+	if(usbc_otg == NULL || buff == NULL){
+		return 0;
+	}
+
+    //--<1>--
+	buf32 = buff;
+	len   = cnt;
+
+	i32 = len >> 2;
+	i8  = len & 0x03;
+
+    //--<2>--4
+	while (i32--){
+		USBC_Writel(*buf32++, fifo);
+	}
+
+    //--<3>--4
+	buf8 = (__u8 *)buf32;
+	while (i8--){
+		USBC_Writeb(*buf8++, fifo);
+	}
+
+	return len;
+}
+
+/*
+***********************************************************************************
+*                     USBC_ReadPacket
+*
+* Description:
+*    fifo
+*
+* Arguments:
+*    hUSB    :  input.  USBC_open_otg, USBC
+*    fifo    :  input.  fifo.
+*    cnt     :  input.  
+*    buff    :  input.  
+*
+* Returns:
+*    
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_ReadPacket(__hdle hUSB, __u32 fifo, __u32 cnt, void *buff)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 len = 0;
+	__u32 i32 = 0;
+	__u32 i8  = 0;
+	__u8  *buf8  = NULL;
+	__u32 *buf32 = NULL;
+
+    if(usbc_otg == NULL || buff == NULL){
+		return 0;
+	}
+
+	//--<1>--
+	buf32 = buff;
+	len   = cnt;
+
+    i32 = len >> 2;
+	i8  = len & 0x03;
+
+	//--<2>--4
+	while (i32--){
+        *buf32++ = USBC_Readl(fifo);
+    }
+
+	//--<3>--4
+	buf8 = (__u8 *)buf32;
+	while (i8--){
+        *buf8++ = USBC_Readb(fifo);
+    }
+
+	return len;
+}
+
+/* SRAM Dusb fifo */
+void USBC_ConfigFIFO_Base(__hdle hUSB, __u32 sram_base, __u32 fifo_mode)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+    __fifo_info_t *usbc_info = &usbc_info_g;
+	__u32 reg_value = 0;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	if(usbc_otg->port_num == 0){
+		reg_value = USBC_Readl(sram_base + 0x04);
+		reg_value &= ~(0x03 << 0);
+		reg_value |= (1 << 0);
+		USBC_Writel(reg_value, (sram_base + 0x04));
+
+		usbc_info->port0_fifo_addr = 0x00;
+		usbc_info->port0_fifo_size = (8 * 1024);	//8k
+    }
+
+	return ;
+}
+
+/* port fifo */
+__u32 USBC_GetPortFifoStartAddr(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	if(usbc_otg->port_num == 0){
+		return usbc_info_g.port0_fifo_addr;
+	}else if(usbc_otg->port_num == 1){
+	    return usbc_info_g.port1_fifo_addr;
+	}else {
+	    return usbc_info_g.port2_fifo_addr;
+	}
+}
+
+/* port fifo */
+__u32 USBC_GetPortFifoSize(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	if(usbc_otg->port_num == 0){
+		return usbc_info_g.port0_fifo_size;
+	}else{
+	    return usbc_info_g.port1_fifo_size;
+	}
+}
+
+
+/*
+***********************************************************************************
+*                     USBC_SelectFIFO
+*
+* Description:
+*    device, host
+*
+* Arguments:
+*    hUSB     :  input.  USBC_open_otg, USBC
+*    ep_index :  input.  epfifo
+*
+* Returns:
+*    fifo
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+/*
+__u32 USBC_SelectFIFO(__hdle hUSB, __u32 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 fifo = 0;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    switch(ep_index){
+		case 0:
+			fifo = USBC_REG_EPFIFO0(usbc_otg->base_addr);
+		break;
+
+		case 1:
+			fifo = USBC_REG_EPFIFO1(usbc_otg->base_addr);
+		break;
+
+		case 2:
+			fifo = USBC_REG_EPFIFO2(usbc_otg->base_addr);
+		break;
+
+		case 3:
+			fifo = USBC_REG_EPFIFO3(usbc_otg->base_addr);
+		break;
+
+		case 4:
+			fifo = USBC_REG_EPFIFO4(usbc_otg->base_addr);
+		break;
+
+		case 5:
+			fifo = USBC_REG_EPFIFO5(usbc_otg->base_addr);
+		break;
+
+		default:
+			fifo = 0;
+	}
+
+	return fifo;
+}
+*/
+
+__u32 USBC_SelectFIFO(__hdle hUSB, __u32 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	return USBC_REG_EPFIFOx(usbc_otg->base_addr, ep_index);
+}
+
+static void __USBC_ConfigFifo_TxEp_Default(__u32 usbc_base_addr)
+{
+	USBC_Writew(0x00, USBC_REG_TXFIFOAD(usbc_base_addr));
+	USBC_Writeb(0x00, USBC_REG_TXFIFOSZ(usbc_base_addr));
+}
+
+/*
+***********************************************************************************
+*                     USBC_ConfigFifo_TxEp
+*
+* Description:
+*    tx ep fifo
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    is_double_fifo :  input.  Whether to use hardware dual fifo
+*    fifo_size      :  input.  fifo = 2fifo_size
+*    fifo_addr      :  input.  fifo = fifo_addr * 8
+*
+* Returns:
+*    
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void __USBC_ConfigFifo_TxEp(__u32 usbc_base_addr, __u32 is_double_fifo, __u32 fifo_size, __u32 fifo_addr)
+{
+    __u32 temp = 0;
+    __u32 size = 0;   //fifo_size = (size + 3)2
+    __u32 addr = 0;   //fifo_addr = addr * 8
+
+	//--<1>--sz, 512512
+	temp = fifo_size + 511;
+	temp &= ~511;  //511
+	temp >>= 3;
+	temp >>= 1;
+	while(temp){
+		size++;
+		temp >>= 1;
+	}
+
+	//--<2>--addr
+	addr = fifo_addr >> 3;
+
+	//--<3>--config fifo addr
+	USBC_Writew(addr, USBC_REG_TXFIFOAD(usbc_base_addr));
+
+	//--<4>--config fifo size
+	USBC_Writeb((size & 0x0f), USBC_REG_TXFIFOSZ(usbc_base_addr));
+	if(is_double_fifo){
+		USBC_REG_set_bit_b(USBC_BP_TXFIFOSZ_DPB, USBC_REG_TXFIFOSZ(usbc_base_addr));
+	}
+}
+
+void __USBC_ConfigFifo_RxEp_Default(__u32 usbc_base_addr)
+{
+	USBC_Writew(0x00, USBC_REG_RXFIFOAD(usbc_base_addr));
+	USBC_Writeb(0x00, USBC_REG_RXFIFOSZ(usbc_base_addr));
+}
+
+/*
+***********************************************************************************
+*                     USBC_ConfigFifo_RxEp
+*
+* Description:
+*    tx ep fifo
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    is_double_fifo :  input.  fifo
+*    fifo_size      :  input.  fifo = 2fifo_size
+*    fifo_addr      :  input.  fifo = fifo_addr * 8
+*
+* Returns:
+*    
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void __USBC_ConfigFifo_RxEp(__u32 usbc_base_addr, __u32 is_double_fifo, __u32 fifo_size, __u32 fifo_addr)
+{
+    __u32 temp = 0;
+    __u32 size = 0;   //fifo_size = (size + 3)2
+    __u32 addr = 0;   //fifo_addr = addr * 8
+
+	//--<1>--sz, 512512
+	temp = fifo_size + 511;
+	temp &= ~511;  //511
+	temp >>= 3;
+	temp >>= 1;
+	while(temp){
+		size++;
+		temp >>= 1;
+	}
+
+	//--<2>--addr
+	addr = fifo_addr >> 3;
+
+	//--<3>--config fifo addr
+	USBC_Writew(addr, USBC_REG_RXFIFOAD(usbc_base_addr));
+
+	//--<2>--config fifo size
+	USBC_Writeb((size & 0x0f), USBC_REG_RXFIFOSZ(usbc_base_addr));
+	if(is_double_fifo){
+		USBC_REG_set_bit_b(USBC_BP_RXFIFOSZ_DPB, USBC_REG_RXFIFOSZ(usbc_base_addr));
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_ConfigFifo_Default
+*
+* Description:
+*    ep fifo
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*	 ep_type		:  input.  ep
+*
+* Returns:
+*    
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_ConfigFifo_Default(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_ConfigFifo_TxEp_Default(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_ConfigFifo_RxEp_Default(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_ConfigFifo
+*
+* Description:
+*    ep fifo
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*	 ep_type		:  input.  ep
+*    is_double_fifo :  input.  fifo
+*    fifo_size      :  input.  fifo = 2fifo_size
+*    fifo_addr      :  input.  fifo = fifo_addr * 8
+*
+* Returns:
+*    
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_ConfigFifo(__hdle hUSB, __u32 ep_type, __u32 is_double_fifo, __u32 fifo_size, __u32 fifo_addr)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_ConfigFifo_TxEp(usbc_otg->base_addr, is_double_fifo, fifo_size, fifo_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_ConfigFifo_RxEp(usbc_otg->base_addr, is_double_fifo, fifo_size, fifo_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_GetLastFrameNumber
+*
+* Description:
+*    
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_GetLastFrameNumber(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    return USBC_Readl(USBC_REG_FRNUM(usbc_otg->base_addr));
+}
+
+/*
+***********************************************************************************
+*                     USBC_GetStatus_Dp
+*
+* Description:
+*    dp
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+
+__u32 USBC_GetStatus_Dp(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 temp = 0;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	temp = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	temp = (temp >> USBC_BP_ISCR_EXT_DP_STATUS) & 0x01;
+
+    return temp;
+}
+
+
+
+/*
+***********************************************************************************
+*                     USBC_GetStatus_Dm
+*
+* Description:
+*    dm
+*
+* Arguments:
+*    hUSB :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_GetStatus_Dm(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 temp = 0;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	temp = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	temp = (temp >> USBC_BP_ISCR_EXT_DM_STATUS) & 0x01;
+
+    return temp;
+}
+
+
+/*
+***********************************************************************************
+*                     USBC_GetStatus_Dp
+*
+* Description:
+*    dp
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+
+__u32 USBC_GetStatus_DpDm(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 temp = 0;
+	__u32 dp = 0;
+	__u32 dm = 0;
+
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	temp = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	dp = (temp >> USBC_BP_ISCR_EXT_DP_STATUS) & 0x01;
+	dm = (temp >> USBC_BP_ISCR_EXT_DM_STATUS) & 0x01;
+	return ((dp << 1) | dm);
+
+}
+
+/*
+***********************************************************************************
+*                     USBC_GetOtgMode_Form_ID
+*
+* Description:
+*    vendor0  id OTG
+*
+* Arguments:
+*    hUSB :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*    USBC_OTG_DEVICE / USBC_OTG_HOST
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_GetOtgMode_Form_ID(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 mode = 0;
+
+	if(usbc_otg == NULL){
+		return USBC_OTG_DEVICE;
+	}
+
+    mode = USBC_REG_test_bit_l(USBC_BP_ISCR_MERGED_ID_STATUS, USBC_REG_ISCR(usbc_otg->base_addr));
+    if(mode){
+		return USBC_OTG_DEVICE;
+	}else{
+	    return USBC_OTG_HOST;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_GetOtgMode_Form_BDevice
+*
+* Description:
+*     OTG Device  B-Device OTG
+*
+* Arguments:
+*    hUSB :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*    USBC_OTG_DEVICE / USBC_OTG_HOST
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_GetOtgMode_Form_BDevice(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 mode = 0;
+
+	if(usbc_otg == NULL){
+		return USBC_OTG_DEVICE;
+	}
+
+    mode = USBC_REG_test_bit_b(USBC_BP_DEVCTL_B_DEVICE, USBC_REG_DEVCTL(usbc_otg->base_addr));
+    if(mode){
+		return USBC_OTG_DEVICE;
+	}else{
+	    return USBC_OTG_HOST;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_SelectBus
+*
+* Description:
+*    
+*
+* Arguments:
+*    hUSB     :  input.  USBC_open_otg, USBC
+*    io_type  :  input.  , piodma.
+*    ep_type  :  input.  ep, rx  tx
+*    ep_index :  input.  ep
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_SelectBus(__hdle hUSB, __u32 io_type, __u32 ep_type, __u32 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    reg_val = USBC_Readb(USBC_REG_VEND0(usbc_otg->base_addr));
+    if(io_type == USBC_IO_TYPE_DMA){
+		if(ep_type == USBC_EP_TYPE_TX){
+			reg_val |= ((ep_index - 0x01) << 1) << USBC_BP_VEND0_DRQ_SEL;  //drq_sel
+			reg_val |= 0x1<<USBC_BP_VEND0_BUS_SEL;   //io_dma
+		}else{
+		    reg_val |= ((ep_index << 1) - 0x01) << USBC_BP_VEND0_DRQ_SEL;
+			reg_val |= 0x1<<USBC_BP_VEND0_BUS_SEL;
+		}
+	}else{
+	    //reg_val &= ~(0x1 << USBC_BP_VEND0_DRQ_SEL);  //drq_sel, pio
+	    reg_val &= 0x00;  //drq_sel, pio
+	}
+
+	USBC_Writeb(reg_val, USBC_REG_VEND0(usbc_otg->base_addr));
+}
+
+/* tx ep */
+static __u32 __USBC_INT_TxPending(__u32 usbc_base_addr)
+{
+    return (USBC_Readw(USBC_REG_INTTx(usbc_base_addr)));
+}
+
+/* tx ep */
+static void __USBC_INT_ClearTxPending(__u32 usbc_base_addr, __u8 ep_index)
+{
+    USBC_Writew((1 << ep_index), USBC_REG_INTTx(usbc_base_addr));
+}
+
+/* tx ep */
+static void __USBC_INT_ClearTxPendingAll(__u32 usbc_base_addr)
+{
+    USBC_Writew(0xffff, USBC_REG_INTTx(usbc_base_addr));
+}
+
+/* rx ep */
+static __u32 __USBC_INT_RxPending(__u32 usbc_base_addr)
+{
+    return (USBC_Readw(USBC_REG_INTRx(usbc_base_addr)));
+}
+
+/* rx ep */
+static void __USBC_INT_ClearRxPending(__u32 usbc_base_addr, __u8 ep_index)
+{
+    USBC_Writew((1 << ep_index), USBC_REG_INTRx(usbc_base_addr));
+}
+
+/* rx ep */
+static void __USBC_INT_ClearRxPendingAll(__u32 usbc_base_addr)
+{
+    USBC_Writew(0xffff, USBC_REG_INTRx(usbc_base_addr));
+}
+
+/* tx ep */
+static void __USBC_INT_EnableTxEp(__u32 usbc_base_addr, __u8 ep_index)
+{
+    USBC_REG_set_bit_w(ep_index, USBC_REG_INTTxE(usbc_base_addr));
+}
+
+/* rx ep */
+static void __USBC_INT_EnableRxEp(__u32 usbc_base_addr, __u8 ep_index)
+{
+    USBC_REG_set_bit_w(ep_index, USBC_REG_INTRxE(usbc_base_addr));
+}
+
+/* tx ep */
+static void __USBC_INT_DisableTxEp(__u32 usbc_base_addr, __u8 ep_index)
+{
+    USBC_REG_clear_bit_w(ep_index, USBC_REG_INTTxE(usbc_base_addr));
+}
+
+/* rx ep */
+static void __USBC_INT_DisableRxEp(__u32 usbc_base_addr, __u8 ep_index)
+{
+    USBC_REG_clear_bit_w(ep_index, USBC_REG_INTRxE(usbc_base_addr));
+}
+
+/* tx ep */
+static void __USBC_INT_DisableTxAll(__u32 usbc_base_addr)
+{
+    USBC_Writew(0, USBC_REG_INTTxE(usbc_base_addr));
+}
+
+/* rx ep */
+static void __USBC_INT_DisableRxAll(__u32 usbc_base_addr)
+{
+    USBC_Writew(0, USBC_REG_INTRxE(usbc_base_addr));
+}
+
+/* ep */
+__u32 USBC_INT_EpPending(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+		case USBC_EP_TYPE_TX:
+		    return __USBC_INT_TxPending(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_RX:
+		    return __USBC_INT_RxPending(usbc_otg->base_addr);
+
+		default:
+			return 0;
+	}
+}
+
+/* ep */
+void USBC_INT_ClearEpPending(__hdle hUSB, __u32 ep_type, __u8 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+		case USBC_EP_TYPE_TX:
+		    __USBC_INT_ClearTxPending(usbc_otg->base_addr, ep_index);
+		break;
+
+		case USBC_EP_TYPE_RX:
+		    __USBC_INT_ClearRxPending(usbc_otg->base_addr, ep_index);
+		break;
+
+		default:
+			break;
+	}
+
+	return ;
+}
+
+/* ep */
+void USBC_INT_ClearEpPendingAll(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+		case USBC_EP_TYPE_TX:
+		    __USBC_INT_ClearTxPendingAll(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+		    __USBC_INT_ClearRxPendingAll(usbc_otg->base_addr);
+		break;
+
+		default:
+			break;
+	}
+
+	return ;
+}
+
+/* usb misc */
+__u32 USBC_INT_MiscPending(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    return (USBC_Readb(USBC_REG_INTUSB(usbc_otg->base_addr)));
+}
+
+/* usb misc */
+void USBC_INT_ClearMiscPending(__hdle hUSB, __u32 mask)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_Writeb(mask, USBC_REG_INTUSB(usbc_otg->base_addr));
+}
+
+/* usb misc */
+void USBC_INT_ClearMiscPendingAll(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_Writeb(0xff, USBC_REG_INTUSB(usbc_otg->base_addr));
+}
+
+/* ep */
+void USBC_INT_EnableEp(__hdle hUSB, __u32 ep_type, __u8 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_TX:
+		    __USBC_INT_EnableTxEp(usbc_otg->base_addr, ep_index);
+		break;
+
+		case USBC_EP_TYPE_RX:
+		    __USBC_INT_EnableRxEp(usbc_otg->base_addr, ep_index);
+		break;
+
+		default:
+        break;
+	}
+
+	return ;
+}
+
+/* usb misc */
+void USBC_INT_EnableUsbMiscUint(__hdle hUSB, __u32 mask)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	reg_val = USBC_Readb(USBC_REG_INTUSBE(usbc_otg->base_addr));
+	reg_val |= mask;
+	USBC_Writeb(reg_val, USBC_REG_INTUSBE(usbc_otg->base_addr));
+}
+
+/* tx ep */
+void USBC_INT_DisableEp(__hdle hUSB, __u32 ep_type, __u8 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_TX:
+		    __USBC_INT_DisableTxEp(usbc_otg->base_addr, ep_index);
+		break;
+
+		case USBC_EP_TYPE_RX:
+		    __USBC_INT_DisableRxEp(usbc_otg->base_addr, ep_index);
+		break;
+
+		default:
+        break;
+	}
+
+	return;
+}
+
+/* usb misc */
+void USBC_INT_DisableUsbMiscUint(__hdle hUSB, __u32 mask)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	reg_val = USBC_Readb(USBC_REG_INTUSBE(usbc_otg->base_addr));
+	reg_val &= ~mask;
+	USBC_Writeb(reg_val, USBC_REG_INTUSBE(usbc_otg->base_addr));
+}
+
+/* ep */
+void USBC_INT_DisableEpAll(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_TX:
+		    __USBC_INT_DisableTxAll(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+		    __USBC_INT_DisableRxAll(usbc_otg->base_addr);
+		break;
+
+		default:
+        break;
+	}
+
+	return;
+}
+
+/* usb misc */
+void USBC_INT_DisableUsbMiscAll(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_Writeb(0, USBC_REG_INTUSBE(usbc_otg->base_addr));
+}
+
+/* ep */
+__u32 USBC_GetActiveEp(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    return USBC_Readb(USBC_REG_EPIND(usbc_otg->base_addr));
+}
+
+/* ep */
+void USBC_SelectActiveEp(__hdle hUSB, __u8 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	USBC_Writeb(ep_index, USBC_REG_EPIND(usbc_otg->base_addr));
+}
+
+/* usb */
+void USBC_EnhanceSignal(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	return;
+}
+
+/*  TestPacket  */
+void USBC_EnterMode_TestPacket(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_set_bit_b(USBC_BP_TMCTL_TEST_PACKET, USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+
+/*  Test_K  */
+void USBC_EnterMode_Test_K(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_set_bit_b(USBC_BP_TMCTL_TEST_K, USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+
+/*  Test_J  */
+void USBC_EnterMode_Test_J(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_set_bit_b(USBC_BP_TMCTL_TEST_J, USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+
+/*  Test_SE0_NAK  */
+void USBC_EnterMode_Test_SE0_NAK(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_set_bit_b(USBC_BP_TMCTL_TEST_SE0_NAK, USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+
+/*  */
+void USBC_EnterMode_Idle(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_clear_bit_b(USBC_BP_TMCTL_TEST_PACKET, USBC_REG_TMCTL(usbc_otg->base_addr));
+	USBC_REG_clear_bit_b(USBC_BP_TMCTL_TEST_K, USBC_REG_TMCTL(usbc_otg->base_addr));
+	USBC_REG_clear_bit_b(USBC_BP_TMCTL_TEST_J, USBC_REG_TMCTL(usbc_otg->base_addr));
+	USBC_REG_clear_bit_b(USBC_BP_TMCTL_TEST_SE0_NAK, USBC_REG_TMCTL(usbc_otg->base_addr));
+}
+
+/* vbus, id, dpdm1, bit */
+static __u32 __USBC_WakeUp_ClearChangeDetect(__u32 reg_val)
+{
+    __u32 temp = reg_val;
+
+	temp &= ~(1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT);
+	temp &= ~(1 << USBC_BP_ISCR_ID_CHANGE_DETECT);
+	temp &= ~(1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT);
+
+	return temp;
+}
+
+void USBC_SetWakeUp_Default(__hdle hUSB)
+{
+
+	return;
+}
+
+void USBC_EnableIdPullUp(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+    __u32 reg_val = 0;
+
+    //vbus, id, dpdm1, bit
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= (1 << USBC_BP_ISCR_ID_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+void USBC_DisableIdPullUp(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+    __u32 reg_val = 0;
+
+	//vbus, id, dpdm1, bit
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_ID_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+void USBC_EnableDpDmPullUp(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+    __u32 reg_val = 0;
+
+    //vbus, id, dpdm1, bit
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val |= (1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+void USBC_DisableDpDmPullUp(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+    __u32 reg_val = 0;
+
+	//vbus, id, dpdm1, bit
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+	reg_val &= ~(1 << USBC_BP_ISCR_DPDM_PULLUP_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+static void __USBC_ForceIdDisable(__u32 usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	//vbus, id, dpdm1, bit
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+static void __USBC_ForceIdToLow(__u32 usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	//0010
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val |= (0x02 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+static void __USBC_ForceIdToHigh(__u32 usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	//0010
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	//reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val |= (0x03 << USBC_BP_ISCR_FORCE_ID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+/* force id to (id_type) */
+void USBC_ForceId(__hdle hUSB, __u32 id_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+    switch(id_type){
+		case USBC_ID_TYPE_HOST:
+			__USBC_ForceIdToLow(usbc_otg->base_addr);
+		break;
+
+		case USBC_ID_TYPE_DEVICE:
+			__USBC_ForceIdToHigh(usbc_otg->base_addr);
+		break;
+
+		default:
+			__USBC_ForceIdDisable(usbc_otg->base_addr);
+	}
+}
+
+static void __USBC_ForceVbusValidDisable(__u32 usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	//0010
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+static void __USBC_ForceVbusValidToLow(__u32 usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	//0010
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val |= (0x02 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+static void __USBC_ForceVbusValidToHigh(__u32 usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	//0011
+	reg_val = USBC_Readl(USBC_REG_ISCR(usbc_base_addr));
+	//reg_val &= ~(0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val |= (0x03 << USBC_BP_ISCR_FORCE_VBUS_VALID);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_base_addr));
+}
+
+/* force vbus valid to (id_type) */
+void USBC_ForceVbusValid(__hdle hUSB, __u32 vbus_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+    switch(vbus_type){
+		case USBC_VBUS_TYPE_LOW:
+			__USBC_ForceVbusValidToLow(usbc_otg->base_addr);
+		break;
+
+		case USBC_VBUS_TYPE_HIGH:
+			__USBC_ForceVbusValidToHigh(usbc_otg->base_addr);
+		break;
+
+		default:
+			__USBC_ForceVbusValidDisable(usbc_otg->base_addr);
+	}
+}
+
+void USBC_A_valid_InputSelect(__hdle hUSB, __u32 source)
+{
+
+    return;
+}
+
+void USBC_EnableUsbLineStateBypass(__hdle hUSB)
+{
+
+    return;
+}
+
+void USBC_DisableUsbLineStateBypass(__hdle hUSB)
+{
+
+    return;
+}
+
+void USBC_EnableHosc(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val |= 1 << USBC_BP_ISCR_HOSC_EN;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/* Hosc */
+void USBC_DisableHosc(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val &= ~(1 << USBC_BP_ISCR_HOSC_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/*  vbus  */
+__u32 USBC_IsVbusChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+	__u32 temp = 0;
+
+    //, 1
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+
+	temp = reg_val & (1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT);
+
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+    reg_val |= 1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT;
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+
+	return temp;
+}
+
+/*  id  */
+__u32 USBC_IsIdChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+	__u32 temp = 0;
+
+    //, 1
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+
+	temp = reg_val & (1 << USBC_BP_ISCR_ID_CHANGE_DETECT);
+
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+    reg_val |= 1 << USBC_BP_ISCR_ID_CHANGE_DETECT;
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+
+	return temp;
+}
+
+/*  dpdm  */
+__u32 USBC_IsDpDmChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+	__u32 temp = 0;
+
+    //, 1
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+
+	temp = reg_val & (1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT);
+
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+    reg_val |= 1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT;
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+
+	return temp;
+}
+
+/*  wake  */
+void USBC_DisableWakeIrq(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val &= ~(1 << USBC_BP_ISCR_IRQ_ENABLE);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/*  vbus  */
+void USBC_DisableVbusChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val &= ~(1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/*  id  */
+void USBC_DisableIdChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val &= ~(1 << USBC_BP_ISCR_ID_CHANGE_DETECT_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/*  dpdm  */
+void USBC_DisableDpDmChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val &= ~(1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT_EN);
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/*  wake  */
+void USBC_EnableWakeIrq(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val |= 1 << USBC_BP_ISCR_IRQ_ENABLE;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/*  vbus  */
+void USBC_EnableVbusChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val |= 1 << USBC_BP_ISCR_VBUS_CHANGE_DETECT_EN;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/* id */
+void USBC_EnableIdChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val |= 1 << USBC_BP_ISCR_ID_CHANGE_DETECT_EN;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/* dmdp */
+void USBC_EnableDpDmChange(__hdle hUSB)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+    reg_val = USBC_Readl(USBC_REG_ISCR(usbc_otg->base_addr));
+    reg_val |= 1 << USBC_BP_ISCR_DPDM_CHANGE_DETECT_EN;
+	reg_val = __USBC_WakeUp_ClearChangeDetect(reg_val);
+	USBC_Writel(reg_val, USBC_REG_ISCR(usbc_otg->base_addr));
+}
+
+/* ,  */
+__u32 USBC_TestMode_ReadReg(__hdle hUSB, __u32 offset, __u32 reg_width)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 reg_val = 0;
+
+	if(usbc_otg == NULL){
+		return reg_val;
+	}
+
+    if(reg_width == 8){
+		reg_val = USBC_Readb(usbc_otg->base_addr + offset);
+	}else if(reg_width == 16){
+	    reg_val = USBC_Readw(usbc_otg->base_addr + offset);
+	}else if(reg_width == 32){
+	    reg_val = USBC_Readl(usbc_otg->base_addr + offset);
+	}else{
+	    reg_val = 0;
+	}
+
+	return reg_val;
+}
+
+/*
+***********************************************************************************
+*                     USBC_open_otg
+*
+* Description:
+*    bspotg_notog
+*
+* Arguments:
+*    otg_no  :  input.  TOG, : 0 ~ USBC_MAX_CTL_NUM
+*
+* Returns:
+*    , usbc_otg, NULL
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+#if 0
+__hdle USBC_open_otg(__u32 otg_no)
+{
+    __usbc_otg_t *usbc_otg = usbc_otg_array;
+	__u32 i = 0;
+
+    //--<1>--otg_no
+    if(otg_no >= USBC_MAX_CTL_NUM){
+		return 0;
+	}
+
+    //--<2>--, 8
+    for(i = 0; i < USBC_MAX_OPEN_NUM; i++){
+		if(usbc_otg[i].used == 0){
+			usbc_otg[i].used      = 1;
+			usbc_otg[i].no        = i;
+			usbc_otg[i].port_num  = otg_no;
+			usbc_otg[i].base_addr = usbc_base_address[otg_no];
+
+			return (__hdle)(&(usbc_otg[i]));
+		}
+	}
+
+    return 0;
+}
+#else
+__hdle USBC_open_otg(__u32 otg_no)
+{
+    __usbc_otg_t *usbc_otg = usbc_otg_array;
+
+    //--<1>--otg_no
+    if(otg_no >= USBC_MAX_CTL_NUM){
+		return 0;
+	}
+
+    //--<2>--, 8
+	usbc_otg[otg_no].used      = 1;
+	usbc_otg[otg_no].no        = otg_no;
+	usbc_otg[otg_no].port_num  = otg_no;
+	usbc_otg[otg_no].base_addr = usbc_base_address[otg_no];
+
+	return (__hdle)(&(usbc_otg[otg_no]));
+}
+
+#endif
+
+/*
+***********************************************************************************
+*                     USBC_close_otg
+*
+* Description:
+*    tog
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32  USBC_close_otg(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	memset(usbc_otg, 0, sizeof(__usbc_otg_t));
+
+	return 0;
+}
+
+
+/*
+***********************************************************************************
+*                           USBC_init
+*
+* Description:
+*
+*
+* Arguments:
+*
+*
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*
+*
+***********************************************************************************
+*/
+__s32 USBC_init(bsp_usbc_t *usbc)
+{
+ //   __usbc_otg_t *usbc_otg = usbc_otg_array;
+    __u32 i = 0;
+
+//    memset(usbc_base_address, 0, sizeof(usbc_base_address));
+//    memset(&usbc_info_g, 0, sizeof(__fifo_info_t));
+//    memset(usbc_otg, 0, (USBC_MAX_OPEN_NUM * sizeof(__usbc_otg_t)));
+
+    /*  driver  usb  */
+/*
+    for(i = 0; i < USBC_MAX_CTL_NUM; i++){
+        __u32 port_num = 0;
+
+        port_num = usbc->usbc_info[i].num;
+        usbc_base_address[i] = usbc->usbc_info[i].base;
+    }
+*/
+    for(i = 0; i < USBC_MAX_CTL_NUM; i++){
+        __u32 port_num = 0;
+
+		if(usbc->usbc_info[i].base){
+	        port_num = usbc->usbc_info[i].num;
+	        usbc_base_address[i] = usbc->usbc_info[i].base;
+		}
+    }
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                            USBC_exit
+*
+* Description:
+*
+*
+* Arguments:
+*
+*
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*
+*
+***********************************************************************************
+*/
+__s32 USBC_exit(bsp_usbc_t *usbc)
+{
+    __usbc_otg_t *usbc_otg = usbc_otg_array;
+
+    memset(&usbc_info_g, 0, sizeof(__fifo_info_t));
+    memset(usbc_otg, 0, (USBC_MAX_OPEN_NUM * sizeof(__usbc_otg_t)));
+    memset(usbc_base_address, 0, sizeof(usbc_base_address));
+
+    return 0;
+}
+
+/* USB,  */
+EXPORT_SYMBOL(USBC_OTG_SelectMode);
+
+EXPORT_SYMBOL(USBC_ReadLenFromFifo);
+EXPORT_SYMBOL(USBC_WritePacket);
+EXPORT_SYMBOL(USBC_ReadPacket);
+
+EXPORT_SYMBOL(USBC_ConfigFIFO_Base);
+EXPORT_SYMBOL(USBC_GetPortFifoStartAddr);
+EXPORT_SYMBOL(USBC_GetPortFifoSize);
+EXPORT_SYMBOL(USBC_SelectFIFO);
+EXPORT_SYMBOL(USBC_ConfigFifo_Default);
+EXPORT_SYMBOL(USBC_ConfigFifo);
+
+EXPORT_SYMBOL(USBC_SelectBus);
+
+EXPORT_SYMBOL(USBC_GetActiveEp);
+EXPORT_SYMBOL(USBC_SelectActiveEp);
+
+EXPORT_SYMBOL(USBC_EnhanceSignal);
+
+EXPORT_SYMBOL(USBC_GetLastFrameNumber);
+
+
+/* usb  */
+EXPORT_SYMBOL(USBC_INT_EpPending);
+EXPORT_SYMBOL(USBC_INT_MiscPending);
+EXPORT_SYMBOL(USBC_INT_ClearEpPending);
+EXPORT_SYMBOL(USBC_INT_ClearMiscPending);
+EXPORT_SYMBOL(USBC_INT_ClearEpPendingAll);
+EXPORT_SYMBOL(USBC_INT_ClearMiscPendingAll);
+
+EXPORT_SYMBOL(USBC_INT_EnableEp);
+EXPORT_SYMBOL(USBC_INT_EnableUsbMiscUint);
+
+EXPORT_SYMBOL(USBC_INT_DisableEp);
+EXPORT_SYMBOL(USBC_INT_DisableUsbMiscUint);
+
+EXPORT_SYMBOL(USBC_INT_DisableEpAll);
+EXPORT_SYMBOL(USBC_INT_DisableUsbMiscAll);
+
+
+/* usb  */
+EXPORT_SYMBOL(USBC_GetVbusStatus);
+EXPORT_SYMBOL(USBC_GetStatus_Dp);
+EXPORT_SYMBOL(USBC_GetStatus_Dm);
+EXPORT_SYMBOL(USBC_GetStatus_DpDm);
+
+EXPORT_SYMBOL(USBC_GetOtgMode_Form_ID);
+EXPORT_SYMBOL(USBC_GetOtgMode_Form_BDevice);
+
+EXPORT_SYMBOL(USBC_SetWakeUp_Default);
+
+EXPORT_SYMBOL(USBC_EnableIdPullUp);
+EXPORT_SYMBOL(USBC_DisableIdPullUp);
+EXPORT_SYMBOL(USBC_EnableDpDmPullUp);
+EXPORT_SYMBOL(USBC_DisableDpDmPullUp);
+
+EXPORT_SYMBOL(USBC_ForceId);
+EXPORT_SYMBOL(USBC_ForceVbusValid);
+
+EXPORT_SYMBOL(USBC_A_valid_InputSelect);
+
+EXPORT_SYMBOL(USBC_EnableUsbLineStateBypass);
+EXPORT_SYMBOL(USBC_DisableUsbLineStateBypass);
+EXPORT_SYMBOL(USBC_EnableHosc);
+EXPORT_SYMBOL(USBC_DisableHosc);
+
+EXPORT_SYMBOL(USBC_IsVbusChange);
+EXPORT_SYMBOL(USBC_IsIdChange);
+EXPORT_SYMBOL(USBC_IsDpDmChange);
+
+EXPORT_SYMBOL(USBC_DisableWakeIrq);
+EXPORT_SYMBOL(USBC_DisableVbusChange);
+EXPORT_SYMBOL(USBC_DisableIdChange);
+EXPORT_SYMBOL(USBC_DisableDpDmChange);
+
+EXPORT_SYMBOL(USBC_EnableWakeIrq);
+EXPORT_SYMBOL(USBC_EnableVbusChange);
+EXPORT_SYMBOL(USBC_EnableIdChange);
+EXPORT_SYMBOL(USBC_EnableDpDmChange);
+
+/* usb  */
+EXPORT_SYMBOL(USBC_EnterMode_TestPacket);
+EXPORT_SYMBOL(USBC_EnterMode_Test_K);
+EXPORT_SYMBOL(USBC_EnterMode_Test_J);
+EXPORT_SYMBOL(USBC_EnterMode_Test_SE0_NAK);
+EXPORT_SYMBOL(USBC_EnterMode_Idle);
+
+EXPORT_SYMBOL(USBC_TestMode_ReadReg);
+
+EXPORT_SYMBOL(USBC_open_otg);
+EXPORT_SYMBOL(USBC_close_otg);
+EXPORT_SYMBOL(USBC_init);
+EXPORT_SYMBOL(USBC_exit);
+
+
+
diff --git a/drivers/usb/sunxi_usb/usbc/usbc_dev.c b/drivers/usb/sunxi_usb/usbc/usbc_dev.c
new file mode 100644
index 0000000..fc02ab2
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc_dev.c
@@ -0,0 +1,1342 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc_dev.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel <daniel@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include  "usbc_i.h"
+
+/*
+ ***************************************************************************
+ *
+ *  usb device 
+ *
+ ***************************************************************************
+ */
+static void __USBC_Dev_TsType_default(__u32 usbc_base_addr)
+{
+    //disable
+    USBC_REG_clear_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsType_Ctrl(__u32 usbc_base_addr)
+{
+    //--<1>--disable
+    USBC_REG_clear_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN, USBC_REG_PCTL(usbc_base_addr));
+
+	//--<2>-- Ctrl 
+	/*  */
+}
+
+static void __USBC_Dev_TsType_Iso(__u32 usbc_base_addr)
+{
+    //--<1>--disable
+    /*  */
+
+    //--<2>-- Ctrl 
+    USBC_REG_set_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsType_Int(__u32 usbc_base_addr)
+{
+    //--<1>--disable
+    USBC_REG_clear_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN, USBC_REG_PCTL(usbc_base_addr));
+
+	//--<2>-- Ctrl 
+	/*  */
+}
+
+static void __USBC_Dev_TsType_Bulk(__u32 usbc_base_addr)
+{
+    //--<1>--disable
+    USBC_REG_clear_bit_b(USBC_BP_POWER_D_ISO_UPDATE_EN, USBC_REG_PCTL(usbc_base_addr));
+
+	//--<2>-- Ctrl 
+	/*  */
+}
+
+/*
+ ***************************************************************************
+ *
+ *  usb device  
+ *
+ ***************************************************************************
+ */
+
+static void __USBC_Dev_TsMode_default(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_b(USBC_BP_POWER_D_HIGH_SPEED_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsMode_Hs(__u32 usbc_base_addr)
+{
+    USBC_REG_set_bit_b(USBC_BP_POWER_D_HIGH_SPEED_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsMode_Fs(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_b(USBC_BP_POWER_D_HIGH_SPEED_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Dev_TsMode_Ls(__u32 usbc_base_addr)
+{
+    //ls, fs
+    __USBC_Dev_TsMode_Fs(usbc_base_addr);
+}
+
+static void __USBC_Dev_ep0_ConfigEp0_Default(__u32 usbc_base_addr)
+{
+    USBC_Writew(1<<USBC_BP_CSR0_D_FLUSH_FIFO, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ConfigEp0(__u32 usbc_base_addr)
+{
+    USBC_Writew(1<<USBC_BP_CSR0_D_FLUSH_FIFO, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_ep0_IsReadDataReady(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_D_RX_PKT_READY, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_ep0_IsWriteDataReady(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_D_TX_PKT_READY, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ReadDataHalf(__u32 usbc_base_addr)
+{
+	USBC_Writew(1<<USBC_BP_CSR0_D_SERVICED_RX_PKT_READY, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ReadDataComplete(__u32 usbc_base_addr)
+{
+    USBC_Writew((1<<USBC_BP_CSR0_D_SERVICED_RX_PKT_READY) | (1<<USBC_BP_CSR0_D_DATA_END),
+	            USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_WriteDataHalf(__u32 usbc_base_addr)
+{
+	USBC_Writew(1<<USBC_BP_CSR0_D_TX_PKT_READY, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_WriteDataComplete(__u32 usbc_base_addr)
+{
+    USBC_Writew((1<<USBC_BP_CSR0_D_TX_PKT_READY) | (1<<USBC_BP_CSR0_D_DATA_END),
+	            USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_ep0_IsEpStall(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_D_SENT_STALL, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_SendStall(__u32 usbc_base_addr)
+{
+    USBC_REG_set_bit_w(USBC_BP_CSR0_D_SEND_STALL,
+		               USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ClearStall(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_CSR0_D_SEND_STALL, USBC_REG_CSR0(usbc_base_addr));
+    USBC_REG_clear_bit_w(USBC_BP_CSR0_D_SENT_STALL, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_ep0_IsSetupEnd(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_D_SETUP_END, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_ep0_ClearSetupEnd(__u32 usbc_base_addr)
+{
+    USBC_REG_set_bit_w(USBC_BP_CSR0_D_SERVICED_SETUP_END, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_EnableIsoEp(__u32 usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_TXCSR_D_ISO, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_EnableIntEp(__u32 usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_TXCSR_D_ISO, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_EnableBulkEp(__u32 usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_TXCSR_D_ISO, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_ConfigEp_Default(__u32 usbc_base_addr)
+{
+    //--<1>--clear tx csr
+	USBC_Writew(0x00, USBC_REG_TXCSR(usbc_base_addr));
+
+	//--<2>--clear tx ep max packet
+	USBC_Writew(0x00, USBC_REG_TXMAXP(usbc_base_addr));
+
+	//--<3>--config ep transfer type
+}
+
+static void __USBC_Dev_Tx_ConfigEp(__u32 usbc_base_addr, __u32 ts_type, __u32 is_double_fifo, __u32 ep_MaxPkt)
+{
+    __u16 reg_val = 0;
+	__u16 temp = 0;
+
+    //--<1>--config tx csr
+	reg_val = (1 << USBC_BP_TXCSR_D_MODE);
+	reg_val |= (1 << USBC_BP_TXCSR_D_CLEAR_DATA_TOGGLE);
+	reg_val |= (1 << USBC_BP_TXCSR_D_FLUSH_FIFO);
+	USBC_Writew(reg_val, USBC_REG_TXCSR(usbc_base_addr));
+
+	if(is_double_fifo){
+		USBC_Writew(reg_val, USBC_REG_TXCSR(usbc_base_addr));
+	}
+
+	//--<2>--config tx ep max packet
+	reg_val = USBC_Readw(USBC_REG_TXMAXP(usbc_base_addr));
+	temp    = ep_MaxPkt & ((1 << USBC_BP_TXMAXP_PACKET_COUNT) - 1);
+	reg_val |= temp;
+	USBC_Writew(reg_val, USBC_REG_TXMAXP(usbc_base_addr));
+
+	//--<3>--config ep transfer type
+	switch(ts_type){
+		case USBC_TS_TYPE_ISO:
+			__USBC_Dev_Tx_EnableIsoEp(usbc_base_addr);
+		break;
+
+		case USBC_TS_TYPE_INT:
+			__USBC_Dev_Tx_EnableIntEp(usbc_base_addr);
+		break;
+
+		case USBC_TS_TYPE_BULK:
+			__USBC_Dev_Tx_EnableBulkEp(usbc_base_addr);
+		break;
+
+		default:
+			__USBC_Dev_Tx_EnableBulkEp(usbc_base_addr);
+	}
+}
+
+static void __USBC_Dev_Tx_ConfigEpDma(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+	//auto_set, tx_mode, dma_tx_en, mode1
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr |= (1 << USBC_BP_TXCSR_D_AUTOSET) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_D_MODE) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_D_DMA_REQ_EN) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_D_DMA_REQ_MODE) >> 8;
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+}
+
+static void __USBC_Dev_Tx_ClearEpDma(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+	//auto_set, dma_tx_en, mode1
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_D_AUTOSET) >> 8);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_D_DMA_REQ_EN) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+
+	//DMA_REQ_ENDMA_REQ_MODEcycle
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_D_DMA_REQ_MODE) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+}
+
+static __u32 __USBC_Dev_Tx_IsWriteDataReady(__u32 usbc_base_addr)
+{
+    __u32 temp = 0;
+
+    temp = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	temp &= (1 << USBC_BP_TXCSR_D_TX_READY) | (1 << USBC_BP_TXCSR_D_FIFO_NOT_EMPTY);
+
+	return temp;
+}
+
+static void __USBC_Dev_Tx_WriteDataHalf(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+	ep_csr = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	ep_csr |= 1 << USBC_BP_TXCSR_D_TX_READY;
+	ep_csr &= ~(1 << USBC_BP_TXCSR_D_UNDER_RUN);
+	USBC_Writew(ep_csr, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_WriteDataComplete(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+	ep_csr = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	ep_csr |= 1 << USBC_BP_TXCSR_D_TX_READY;
+	ep_csr &= ~(1 << USBC_BP_TXCSR_D_UNDER_RUN);
+	USBC_Writew(ep_csr, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_SendStall(__u32 usbc_base_addr)
+{
+    //send stall, and fifo is flushed automaticly
+	USBC_REG_set_bit_w(USBC_BP_TXCSR_D_SEND_STALL, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_Tx_IsEpStall(__u32 usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_TXCSR_D_SENT_STALL, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+
+static void __USBC_Dev_Tx_ClearStall(__u32 usbc_base_addr)
+{
+	__u32 reg_val;
+
+	reg_val = USBC_Readw(USBC_REG_TXCSR(usbc_base_addr));
+	reg_val &= ~((1 << USBC_BP_TXCSR_D_SENT_STALL)|(1 << USBC_BP_TXCSR_D_SEND_STALL));
+	USBC_Writew(reg_val, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+//warning, 
+/*
+static __u32 __USBC_Dev_Tx_IsEpIncomp(__u32 usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_TXCSR_D_INCOMPLETE, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Tx_ClearIncomp(__u32 usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_TXCSR_D_INCOMPLETE, USBC_REG_TXCSR(usbc_base_addr));
+}
+*/
+static void __USBC_Dev_Rx_EnableIsoEp(__u32 usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_RXCSR_D_ISO, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_EnableIntEp(__u32 usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_RXCSR_D_ISO, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_EnableBulkEp(__u32 usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_RXCSR_D_ISO, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_ConfigEp_Default(__u32 usbc_base_addr)
+{
+    //--<1>--clear tx csr
+	USBC_Writew(0x00, USBC_REG_RXCSR(usbc_base_addr));
+
+	//--<2>--clear tx ep max packet
+	USBC_Writew(0x00, USBC_REG_RXMAXP(usbc_base_addr));
+
+	//--<3>--config ep transfer type
+}
+
+static void __USBC_Dev_Rx_ConfigEp(__u32 usbc_base_addr, __u32 ts_type, __u32 is_double_fifo, __u32 ep_MaxPkt)
+{
+    __u16 reg_val = 0;
+	__u16 temp = 0;
+
+    //--<1>--config tx csr
+    USBC_Writew((1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_RXCSR_D_FLUSH_FIFO),
+                USBC_REG_RXCSR(usbc_base_addr));
+
+	if(is_double_fifo){
+		USBC_Writew((1 << USBC_BP_RXCSR_D_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_RXCSR_D_FLUSH_FIFO),
+                    USBC_REG_RXCSR(usbc_base_addr));
+	}
+
+	//--<2>--config tx ep max packet
+	reg_val = USBC_Readw(USBC_REG_RXMAXP(usbc_base_addr));
+	temp    = ep_MaxPkt & ((1 << USBC_BP_RXMAXP_PACKET_COUNT) - 1);
+	reg_val |= temp;
+	USBC_Writew(reg_val, USBC_REG_RXMAXP(usbc_base_addr));
+
+	//--<3>--config ep transfer type
+	switch(ts_type){
+		case USBC_TS_TYPE_ISO:
+			__USBC_Dev_Rx_EnableIsoEp(usbc_base_addr);
+		break;
+
+		case USBC_TS_TYPE_INT:
+			__USBC_Dev_Rx_EnableIntEp(usbc_base_addr);
+		break;
+
+		case USBC_TS_TYPE_BULK:
+			__USBC_Dev_Rx_EnableBulkEp(usbc_base_addr);
+		break;
+
+		default:
+			__USBC_Dev_Rx_EnableBulkEp(usbc_base_addr);
+	}
+}
+
+static void __USBC_Dev_Rx_ConfigEpDma(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+    //auto_clear, dma_rx_en, mode0
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+	ep_csr |= ((1 << USBC_BP_RXCSR_D_AUTO_CLEAR) >> 8);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_D_DMA_REQ_MODE) >> 8);
+	ep_csr |= ((1 << USBC_BP_RXCSR_D_DMA_REQ_EN) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+}
+
+static void __USBC_Dev_Rx_ClearEpDma(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+    //auto_clear, dma_rx_en, mode0
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_D_AUTO_CLEAR) >> 8);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_D_DMA_REQ_MODE) >> 8);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_D_DMA_REQ_EN) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+}
+
+static __u32 __USBC_Dev_Rx_IsReadDataReady(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_RXCSR_D_RX_PKT_READY, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_ReadDataHalf(__u32 usbc_base_addr)
+{
+	__u32 reg_val = 0;
+
+	//overrun, dataerr is used in iso transfer
+    reg_val = USBC_Readw(USBC_REG_RXCSR(usbc_base_addr));
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_RX_PKT_READY);
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_OVERRUN);
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_DATA_ERROR);
+	USBC_Writew(reg_val, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_ReadDataComplete(__u32 usbc_base_addr)
+{
+    __u32 reg_val = 0;
+
+	//overrun, dataerr is used in iso transfer
+	reg_val = USBC_Readw(USBC_REG_RXCSR(usbc_base_addr));
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_RX_PKT_READY);
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_OVERRUN);
+	reg_val &= ~(1 << USBC_BP_RXCSR_D_DATA_ERROR);
+	USBC_Writew(reg_val, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_SendStall(__u32 usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_RXCSR_D_SEND_STALL, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Dev_Rx_IsEpStall(__u32 usbc_base_addr)
+{
+	return USBC_REG_test_bit_w(USBC_BP_RXCSR_D_SENT_STALL, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Dev_Rx_ClearStall(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_RXCSR_D_SEND_STALL, USBC_REG_RXCSR(usbc_base_addr));
+	USBC_REG_clear_bit_w(USBC_BP_RXCSR_D_SENT_STALL, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_SetAddress_default
+*
+* Description:
+*    hostdevice
+*
+* Arguments:
+*    hUSB       :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Dev_SetAddress_default(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+    USBC_Writeb(0x00, USBC_REG_FADDR(usbc_otg->base_addr));
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_SetAddress
+*
+* Description:
+*    
+*
+* Arguments:
+*    hUSB       :  input.  USBC_open_otg, USBC
+*    address    :  input.  host
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Dev_SetAddress(__hdle hUSB, __u8 address)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+    USBC_Writeb(address, USBC_REG_FADDR(usbc_otg->base_addr));
+}
+
+__u32 USBC_Dev_QueryTransferMode(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return USBC_TS_MODE_UNKOWN;
+	}
+
+	if(USBC_REG_test_bit_b(USBC_BP_POWER_D_HIGH_SPEED_FLAG, USBC_REG_PCTL(usbc_otg->base_addr))){
+		return USBC_TS_MODE_HS;
+	}else{
+	    return USBC_TS_MODE_FS;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_ConfigTransferMode
+*
+* Description:
+*    device
+*
+* Arguments:
+*    hUSB       :  input.  USBC_open_otg, USBC
+*    type       :  input.  
+*    speed_mode :  input.  
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Dev_ConfigTransferMode(__hdle hUSB, __u8 ts_type, __u8 speed_mode)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+    //--<1>--
+    //bulk
+    switch(ts_type){
+		case USBC_TS_TYPE_CTRL:
+			__USBC_Dev_TsType_Ctrl(usbc_otg->base_addr);
+		break;
+
+		case USBC_TS_TYPE_ISO:
+			__USBC_Dev_TsType_Iso(usbc_otg->base_addr);
+		break;
+
+		case USBC_TS_TYPE_INT:
+			__USBC_Dev_TsType_Int(usbc_otg->base_addr);
+		break;
+
+		case USBC_TS_TYPE_BULK:
+			__USBC_Dev_TsType_Bulk(usbc_otg->base_addr);
+		break;
+
+		default:
+			__USBC_Dev_TsType_default(usbc_otg->base_addr);
+	}
+
+    //--<2>--
+    switch(speed_mode){
+		case USBC_TS_MODE_HS:
+			__USBC_Dev_TsMode_Hs(usbc_otg->base_addr);
+		break;
+
+		case USBC_TS_MODE_FS:
+			__USBC_Dev_TsMode_Fs(usbc_otg->base_addr);
+		break;
+
+		case USBC_TS_MODE_LS:
+			__USBC_Dev_TsMode_Ls(usbc_otg->base_addr);
+		break;
+
+		default:
+			__USBC_Dev_TsMode_default(usbc_otg->base_addr);
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_ConectSwitch
+*
+* Description:
+*    PC
+*
+* Arguments:
+*    hUSB   :  input.  USBC_open_otg, USBC
+*    is_on  :  input.  1: PC. 0: PC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Dev_ConectSwitch(__hdle hUSB, __u32 is_on)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	if(is_on == USBC_DEVICE_SWITCH_ON){
+		USBC_REG_set_bit_b(USBC_BP_POWER_D_SOFT_CONNECT, USBC_REG_PCTL(usbc_otg->base_addr));
+	}else{
+		USBC_REG_clear_bit_b(USBC_BP_POWER_D_SOFT_CONNECT, USBC_REG_PCTL(usbc_otg->base_addr));
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_PowerStatus
+*
+* Description:
+*    device, resetresumesuspend
+*
+* Arguments:
+*    hUSB   :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Dev_QueryPowerStatus(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    return (USBC_Readb(USBC_REG_PCTL(usbc_otg->base_addr)) & 0x0f);
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_ConfigEp
+*
+* Description:
+*    ep, FIFO
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+*    is_double_fifo :  input.  
+*    ep_MaxPkt      :  input.  
+*
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_ConfigEp(__hdle hUSB, __u32 ts_type, __u32 ep_type, __u32 is_double_fifo, __u32 ep_MaxPkt)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_ConfigEp0(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_ConfigEp(usbc_otg->base_addr, ts_type, is_double_fifo,  ep_MaxPkt);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_ConfigEp(usbc_otg->base_addr, ts_type, is_double_fifo, ep_MaxPkt);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_ConfigEp
+*
+* Description:
+*    ep, 
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_ConfigEp_Default(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_ConfigEp0_Default(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_ConfigEp_Default(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_ConfigEp_Default(usbc_otg->base_addr);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_ConfigEpDma
+*
+* Description:
+*    epdma
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_ConfigEpDma(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			//not support
+
+			return -1;
+		//break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_ConfigEpDma(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_ConfigEpDma(usbc_otg->base_addr);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_ClearEpDma
+*
+* Description:
+*    epdma
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_ClearEpDma(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			//not support
+
+			return -1;
+		//break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_ClearEpDma(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_ClearEpDma(usbc_otg->base_addr);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_IsEpStall
+*
+* Description:
+*    epstall
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_IsEpStall(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_IsEpStall(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_IsEpStall(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_IsEpStall(usbc_otg->base_addr);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_EpEnterStall
+*
+* Description:
+*    epstall
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_EpSendStall(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_SendStall(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_SendStall(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_SendStall(usbc_otg->base_addr);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_EpClearStall
+*
+* Description:
+*    epstall
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_EpClearStall(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_ClearStall(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_ClearStall(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_ClearStall(usbc_otg->base_addr);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_Ctrl_IsSetupEnd
+*
+* Description:
+*    ep0SetupEnd
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Dev_Ctrl_IsSetupEnd(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    return __USBC_Dev_ep0_IsSetupEnd(usbc_otg->base_addr);
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_Ctrl_ClearSetupEnd
+*
+* Description:
+*    ep0SetupEnd
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Dev_Ctrl_ClearSetupEnd(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	__USBC_Dev_ep0_ClearSetupEnd(usbc_otg->base_addr);
+}
+
+
+static __s32 __USBC_Dev_WriteDataHalf(__u32 usbc_base_addr, __u32 ep_type)
+{
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_WriteDataHalf(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_WriteDataHalf(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			//not support
+			return -1;
+		//break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+static __s32 __USBC_Dev_WriteDataComplete(__u32 usbc_base_addr, __u32 ep_type)
+{
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_WriteDataComplete(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Dev_Tx_WriteDataComplete(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			//not support
+			return -1;
+		//break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+static __s32 __USBC_Dev_ReadDataHalf(__u32 usbc_base_addr, __u32 ep_type)
+{
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_ReadDataHalf(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			//not support
+			return -1;
+		//break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_ReadDataHalf(usbc_base_addr);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+static __s32 __USBC_Dev_ReadDataComplete(__u32 usbc_base_addr, __u32 ep_type)
+{
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Dev_ep0_ReadDataComplete(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			//not support
+			return -1;
+		//break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Dev_Rx_ReadDataComplete(usbc_base_addr);
+		break;
+
+		default:
+			return -1;
+	}
+
+    return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_WriteDataStatus
+*
+* Description:
+*    , , 
+*
+* Arguments:
+*    hUSB      :  input.  USBC_open_otg, USBC
+*    ep_type   :  input.  
+*    complete  :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_WriteDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	if(complete){
+	    return __USBC_Dev_WriteDataComplete(usbc_otg->base_addr, ep_type);
+	}else{
+ 		return __USBC_Dev_WriteDataHalf(usbc_otg->base_addr, ep_type);
+   }
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_ReadDataStatus
+*
+* Description:
+*    , , 
+*
+* Arguments:
+*    hUSB      :  input.  USBC_open_otg, USBC
+*    ep_type   :  input.  
+*    complete  :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Dev_ReadDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	if(complete){
+	    return __USBC_Dev_ReadDataComplete(usbc_otg->base_addr, ep_type);
+	}else{
+		return __USBC_Dev_ReadDataHalf(usbc_otg->base_addr, ep_type);
+    }
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_IsReadDataReady
+*
+* Description:
+*    usb
+*
+* Arguments:
+*    hUSB     :  input.  USBC_open_otg, USBC
+*    ep_type  :  input.  
+*
+* Returns:
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Dev_IsReadDataReady(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return __USBC_Dev_ep0_IsReadDataReady(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_TX:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_RX:
+			return __USBC_Dev_Rx_IsReadDataReady(usbc_otg->base_addr);
+
+		default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_IsWriteDataReady
+*
+* Description:
+*    fifo
+*
+* Arguments:
+*    hUSB    :  input.  USBC_open_otg, USBC
+*    ep_type :  input.  
+*
+* Returns:
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Dev_IsWriteDataReady(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+    switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return __USBC_Dev_ep0_IsWriteDataReady(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_TX:
+			return __USBC_Dev_Tx_IsWriteDataReady(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_RX:
+			//not support
+		break;
+
+		default:
+		break;
+	}
+
+	return 0;
+}
+
+
+EXPORT_SYMBOL(USBC_Dev_SetAddress_default);
+EXPORT_SYMBOL(USBC_Dev_SetAddress);
+
+EXPORT_SYMBOL(USBC_Dev_QueryTransferMode);
+EXPORT_SYMBOL(USBC_Dev_ConfigTransferMode);
+EXPORT_SYMBOL(USBC_Dev_ConectSwitch);
+EXPORT_SYMBOL(USBC_Dev_QueryPowerStatus);
+
+EXPORT_SYMBOL(USBC_Dev_ConfigEp);
+EXPORT_SYMBOL(USBC_Dev_ConfigEp_Default);
+EXPORT_SYMBOL(USBC_Dev_ConfigEpDma);
+EXPORT_SYMBOL(USBC_Dev_ClearEpDma);
+
+EXPORT_SYMBOL(USBC_Dev_IsEpStall);
+EXPORT_SYMBOL(USBC_Dev_EpSendStall);
+EXPORT_SYMBOL(USBC_Dev_EpClearStall);
+
+EXPORT_SYMBOL(USBC_Dev_Ctrl_IsSetupEnd);
+EXPORT_SYMBOL(USBC_Dev_Ctrl_ClearSetupEnd);
+
+EXPORT_SYMBOL(USBC_Dev_IsReadDataReady);
+EXPORT_SYMBOL(USBC_Dev_IsWriteDataReady);
+EXPORT_SYMBOL(USBC_Dev_WriteDataStatus);
+EXPORT_SYMBOL(USBC_Dev_ReadDataStatus);
+
+
diff --git a/drivers/usb/sunxi_usb/usbc/usbc_host.c b/drivers/usb/sunxi_usb/usbc/usbc_host.c
new file mode 100644
index 0000000..e4c69fc
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc_host.c
@@ -0,0 +1,1953 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc_host.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel <daniel@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include  "usbc_i.h"
+
+
+/*
+ ***************************************************************************
+ *
+ *  usb host  
+ *
+ ***************************************************************************
+ */
+/*  */
+static void __USBC_Host_TsMode_Default(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_b(USBC_BP_POWER_H_HIGH_SPEED_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+/*  high speed */
+static void __USBC_Host_TsMode_Hs(__u32 usbc_base_addr)
+{
+    USBC_REG_set_bit_b(USBC_BP_POWER_H_HIGH_SPEED_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+/*  full speed */
+static void __USBC_Host_TsMode_Fs(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_b(USBC_BP_POWER_H_HIGH_SPEED_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+/*  low speed */
+static void __USBC_Host_TsMode_Ls(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_b(USBC_BP_POWER_H_HIGH_SPEED_EN, USBC_REG_PCTL(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_EnablePing(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_CSR0_H_DisPing, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_DisablePing(__u32 usbc_base_addr)
+{
+    USBC_REG_set_bit_w(USBC_BP_CSR0_H_DisPing, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_ep0_IsNakTimeOut(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_H_NAK_Timeout, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_ClearNakTimeOut(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_CSR0_H_NAK_Timeout, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_ep0_IsError(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_H_Error, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_ClearError(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_CSR0_H_Error, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_EpType(__u32 usbc_base_addr, __u32 ts_mode)
+{
+    __u32 reg_val = 0;
+
+	/* config transfer speed */
+	switch(ts_mode){
+		case USBC_TS_MODE_HS:
+			reg_val |= 0x01 << USBC_BP_RXTYPE_SPEED;
+		break;
+
+		case USBC_TS_MODE_FS:
+			reg_val |= 0x02 << USBC_BP_RXTYPE_SPEED;
+		break;
+
+		case USBC_TS_MODE_LS:
+			reg_val |= 0x03 << USBC_BP_RXTYPE_SPEED;
+		break;
+
+		default:
+			reg_val = 0;
+	}
+
+	USBC_Writeb(reg_val, USBC_REG_EP0TYPE(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_FlushFifo(__u32 usbc_base_addr)
+{
+    USBC_Writew(1 << USBC_BP_CSR0_H_FlushFIFO, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_ConfigEp_Default(__u32 usbc_base_addr)
+{
+    //--<1>--config ep0 csr
+    USBC_Writew(1<<USBC_BP_CSR0_H_FlushFIFO, USBC_REG_CSR0(usbc_base_addr));
+
+	//--<2>--config polling interval
+	USBC_Writeb(0x00, USBC_REG_TXINTERVAL(usbc_base_addr));
+
+    /* config ep transfer type */
+	USBC_Writeb(0x00, USBC_REG_EP0TYPE(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_ConfigEp(__u32 usbc_base_addr, __u32 ts_mode, __u32 interval)
+{
+    //--<1>--config ep0 csr
+    USBC_Writew(1<<USBC_BP_CSR0_H_FlushFIFO, USBC_REG_CSR0(usbc_base_addr));
+
+	//--<2>--config polling interval
+	USBC_Writeb(interval, USBC_REG_NAKLIMIT0(usbc_base_addr));
+
+    /* config ep0 transfer type */
+	__USBC_Host_ep0_EpType(usbc_base_addr, ts_mode);
+}
+
+static __u32 __USBC_Host_ep0_IsReadDataReady(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_H_RxPkRdy, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_ep0_IsWriteDataReady(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_H_TxPkRdy, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_ReadDataHalf(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_CSR0_H_RxPkRdy, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_ReadDataComplete(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_CSR0_H_RxPkRdy, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_WriteDataHalf(__u32 usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_CSR0_H_TxPkRdy, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_WriteDataComplete(__u32 usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_CSR0_H_TxPkRdy, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_ep0_IsStall(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_H_RxStall, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_ClearStall(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_CSR0_H_RxStall, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_ClearCSR(__u32 usbc_base_addr)
+{
+    USBC_Writew(0x00, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_ep0_IsReqPktSet(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_CSR0_H_ReqPkt, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_StartInToken(__u32 usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_CSR0_H_ReqPkt, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_StopInToken(__u32 usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_CSR0_H_ReqPkt, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_StatusAfterIn(__u32 usbc_base_addr)
+{
+    __u32 reg_val = 0;
+
+    reg_val = USBC_Readw(USBC_REG_CSR0(usbc_base_addr));
+    reg_val |= 1 << USBC_BP_CSR0_H_TxPkRdy;
+    reg_val |= 1 << USBC_BP_CSR0_H_StatusPkt;
+    USBC_Writew(reg_val, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_StatusAfterOut(__u32 usbc_base_addr)
+{
+    __u32 reg_val = 0;
+
+    reg_val = USBC_Readw(USBC_REG_CSR0(usbc_base_addr));
+    reg_val |= 1 << USBC_BP_CSR0_H_ReqPkt;
+    reg_val |= 1 << USBC_BP_CSR0_H_StatusPkt;
+    USBC_Writew(reg_val, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_ep0_SendSetupPkt(__u32 usbc_base_addr)
+{
+    __u32 reg_val = 0;
+
+    reg_val = USBC_Readw(USBC_REG_CSR0(usbc_base_addr));
+    reg_val |= 1 << USBC_BP_CSR0_H_SetupPkt;
+    reg_val |= 1 << USBC_BP_CSR0_H_TxPkRdy;
+    USBC_Writew(reg_val, USBC_REG_CSR0(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_EpType(__u32 usbc_base_addr, __u32 ep_index, __u32 ts_mode, __u32 ts_type)
+{
+    __u32 reg_val = 0;
+
+	/* config transfer speed */
+	switch(ts_mode){
+		case USBC_TS_MODE_HS:
+			reg_val |= 0x01 << USBC_BP_TXTYPE_SPEED;
+		break;
+
+		case USBC_TS_MODE_FS:
+			reg_val |= 0x02 << USBC_BP_TXTYPE_SPEED;
+		break;
+
+		case USBC_TS_MODE_LS:
+			reg_val |= 0x03 << USBC_BP_TXTYPE_SPEED;
+		break;
+
+		default:
+			reg_val = 0;
+	}
+
+    //--<1>--config protocol
+    switch(ts_type){
+		case USBC_TS_TYPE_ISO:
+		    reg_val |= 0x1 << USBC_BP_TXTYPE_PROROCOL;
+	    break;
+
+		case USBC_TS_TYPE_BULK:
+		    reg_val |= 0x2 << USBC_BP_TXTYPE_PROROCOL;
+		break;
+
+		case USBC_TS_TYPE_INT:
+		    reg_val |= 0x3 << USBC_BP_TXTYPE_PROROCOL;
+		break;
+
+		default:
+		break;
+	}
+
+	//--<2>--config target ep number
+	reg_val |= ep_index;
+
+	USBC_Writeb(reg_val, USBC_REG_TXTYPE(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_FlushFifo(__u32 usbc_base_addr)
+{
+    USBC_Writew((1 << USBC_BP_TXCSR_H_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_TXCSR_H_FLUSH_FIFO),
+                USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_ConfigEp_Default(__u32 usbc_base_addr)
+{
+	//--<1>--config tx_csr, fifo, 
+    USBC_Writew((1 << USBC_BP_TXCSR_H_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_TXCSR_H_FLUSH_FIFO),
+                USBC_REG_TXCSR(usbc_base_addr));
+
+	USBC_Writew(0x00, USBC_REG_TXCSR(usbc_base_addr));
+
+	//--<2>--config tx ep max packet
+	USBC_Writew(0x00, USBC_REG_TXMAXP(usbc_base_addr));
+
+	//--<3>--config ep transfer type
+	USBC_Writeb(0x00, USBC_REG_TXTYPE(usbc_base_addr));
+
+	//--<4>--config polling interval
+	USBC_Writeb(0x00, USBC_REG_TXINTERVAL(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_ConfigEp(__u32 usbc_base_addr, __u32 ep_index, __u32 ts_mode, __u32 ts_type, __u32 is_double_fifo, __u32 ep_MaxPkt, __u32 interval)
+{
+    __u16 reg_val = 0;
+	__u16 temp = 0;
+
+	//--<1>--config tx_csr
+    USBC_Writew((1 << USBC_BP_TXCSR_H_MODE) | (1 << USBC_BP_TXCSR_H_CLEAR_DATA_TOGGLE)
+              	| (1 << USBC_BP_TXCSR_H_FLUSH_FIFO),
+                USBC_REG_TXCSR(usbc_base_addr));
+
+	if(is_double_fifo){
+		USBC_Writew((1 << USBC_BP_TXCSR_H_MODE) | (1 << USBC_BP_TXCSR_H_CLEAR_DATA_TOGGLE)
+                  	| (1 << USBC_BP_TXCSR_H_FLUSH_FIFO),
+                	USBC_REG_TXCSR(usbc_base_addr));
+	}
+
+	//--<2>--config tx ep max packet
+	reg_val = USBC_Readw(USBC_REG_TXMAXP(usbc_base_addr));
+	temp    = ep_MaxPkt & ((1 << USBC_BP_TXMAXP_PACKET_COUNT) - 1);
+	reg_val |= temp;
+	USBC_Writew(reg_val, USBC_REG_TXMAXP(usbc_base_addr));
+
+	//--<3>--config ep transfer type
+	__USBC_Host_Tx_EpType(usbc_base_addr, ep_index, ts_mode, ts_type);
+
+	//--<4>--config polling interval
+	USBC_Writeb(interval, USBC_REG_TXINTERVAL(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_ConfigEpDma(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+	//auto_set, tx_mode, dma_tx_en, mode1
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr |= (1 << USBC_BP_TXCSR_H_AUTOSET) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_H_MODE) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_H_DMA_REQ_EN) >> 8;
+	ep_csr |= (1 << USBC_BP_TXCSR_H_DMA_REQ_MODE) >> 8;
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+}
+
+static void __USBC_Host_Tx_ClearEpDma(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+	//auto_set, dma_tx_en, mode1
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_H_AUTOSET) >> 8);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_H_DMA_REQ_EN) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+
+	//DMA_REQ_ENDMA_REQ_MODEcycle
+	ep_csr = USBC_Readb(USBC_REG_TXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_TXCSR_H_DMA_REQ_MODE) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_TXCSR(usbc_base_addr) + 1));
+}
+
+static __u32 __USBC_Host_Tx_IsWriteDataReady(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_TXCSR_H_TX_READY, USBC_REG_TXCSR(usbc_base_addr))
+    		| USBC_REG_test_bit_w(USBC_BP_TXCSR_H_FIFO_NOT_EMPTY, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_WriteDataHalf(__u32 usbc_base_addr)
+{
+    USBC_REG_set_bit_w(USBC_BP_TXCSR_H_TX_READY, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_WriteDataComplete(__u32 usbc_base_addr)
+{
+    USBC_REG_set_bit_w(USBC_BP_TXCSR_H_TX_READY, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_Tx_IsNakTimeOut(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_TXCSR_H_NAK_TIMEOUT, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_ClearNakTimeOut(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_TXCSR_H_NAK_TIMEOUT, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_Tx_IsError(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_TXCSR_H_ERROR, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_ClearError(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_TXCSR_H_ERROR, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_Tx_IsStall(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_TXCSR_H_TX_STALL, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Tx_ClearStall(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_TXCSR_H_TX_STALL, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+/*
+static void __USBC_Host_Tx_ForbidStall(__u32 usbc_base_addr)
+{
+    USBC_REG_set_bit_w(USBC_BP_TXCSR_H_RX_STALL, USBC_REG_TXCSR(usbc_base_addr));
+}
+*/
+
+static void __USBC_Host_Tx_ClearCSR(__u32 usbc_base_addr)
+{
+    USBC_Writew(0x00, USBC_REG_TXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_EpType(__u32 usbc_base_addr, __u32 ep_index, __u32 ts_mode, __u32 ts_type)
+{
+    __u32 reg_val = 0;
+
+	/* config transfer speed */
+	switch(ts_mode){
+		case USBC_TS_MODE_HS:
+			reg_val |= 0x01 << USBC_BP_RXTYPE_SPEED;
+		break;
+
+		case USBC_TS_MODE_FS:
+			reg_val |= 0x02 << USBC_BP_RXTYPE_SPEED;
+		break;
+
+		case USBC_TS_MODE_LS:
+			reg_val |= 0x03 << USBC_BP_RXTYPE_SPEED;
+		break;
+
+		default:
+			reg_val = 0;
+	}
+
+    //--<1>--config protocol
+    switch(ts_type){
+		case USBC_TS_TYPE_ISO:
+		    reg_val |= 0x1 << USBC_BP_RXTYPE_PROROCOL;
+	    break;
+
+		case USBC_TS_TYPE_BULK:
+		    reg_val |= 0x2 << USBC_BP_RXTYPE_PROROCOL;
+		break;
+
+		case USBC_TS_TYPE_INT:
+		    reg_val |= 0x3 << USBC_BP_RXTYPE_PROROCOL;
+		break;
+
+		default:
+		break;
+	}
+
+	//--<2>--config target ep number
+	reg_val |= ep_index;
+
+	USBC_Writeb(reg_val, USBC_REG_RXTYPE(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_FlushFifo(__u32 usbc_base_addr)
+{
+    USBC_Writew((1 << USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_RXCSR_H_FLUSH_FIFO),
+                USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ConfigEp_Default(__u32 usbc_base_addr)
+{
+	//--<1>--config rx_csr, fifo, 
+    USBC_Writew((1 << USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_RXCSR_H_FLUSH_FIFO),
+                USBC_REG_RXCSR(usbc_base_addr));
+
+	USBC_Writew(0x00, USBC_REG_RXCSR(usbc_base_addr));
+
+	//--<2>--config rx ep max packet
+	USBC_Writew(0x00, USBC_REG_RXMAXP(usbc_base_addr));
+
+	//--<3>--config ep transfer type
+	USBC_Writeb(0x00, USBC_REG_RXTYPE(usbc_base_addr));
+
+	//--<4>--config polling interval
+	USBC_Writeb(0x00, USBC_REG_RXINTERVAL(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ConfigEp(__u32 usbc_base_addr, __u32 ep_index, __u32 ts_mode, __u32 ts_type, __u32 is_double_fifo, __u32 ep_MaxPkt, __u32 interval)
+{
+    __u16 reg_val = 0;
+	__u16 temp = 0;
+
+	//--<1>--config rx_csr
+    USBC_Writew((1 << USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_RXCSR_H_FLUSH_FIFO),
+                USBC_REG_RXCSR(usbc_base_addr));
+
+	if(is_double_fifo){
+		USBC_Writew((1 << USBC_BP_RXCSR_H_CLEAR_DATA_TOGGLE) | (1 << USBC_BP_RXCSR_H_FLUSH_FIFO),
+                    USBC_REG_RXCSR(usbc_base_addr));
+	}
+
+	//--<2>--config tx ep max packet
+	reg_val = USBC_Readw(USBC_REG_RXMAXP(usbc_base_addr));
+	temp    = ep_MaxPkt & ((1 << USBC_BP_RXMAXP_PACKET_COUNT) - 1);
+	reg_val |= temp;
+	USBC_Writew(reg_val, USBC_REG_RXMAXP(usbc_base_addr));
+
+	//--<3>--config ep transfer type
+	__USBC_Host_Rx_EpType(usbc_base_addr, ep_index, ts_mode, ts_type);
+
+	//--<4>--config polling interval
+	USBC_Writeb(interval, USBC_REG_RXINTERVAL(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ConfigEpDma(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+    //dma, auto_clear, dma_rx_en, mode1,
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+	ep_csr |= (1 << USBC_BP_RXCSR_H_AUTO_CLEAR) >> 8;
+	ep_csr |= (1 << USBC_BP_RXCSR_H_AUTO_REQ) >> 8;
+//	ep_csr &= ~((1 << USBC_BP_RXCSR_H_DMA_REQ_MODE) >> 8);
+	ep_csr |= ((1 << USBC_BP_RXCSR_H_DMA_REQ_MODE) >> 8);
+	ep_csr |= (1 << USBC_BP_RXCSR_H_DMA_REQ_EN) >> 8;
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+}
+
+static void __USBC_Host_Rx_ClearEpDma(__u32 usbc_base_addr)
+{
+    __u16 ep_csr = 0;
+
+    //auto_clear, dma_rx_en, mode1,
+	ep_csr = USBC_Readb(USBC_REG_RXCSR(usbc_base_addr) + 1);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_H_AUTO_CLEAR) >> 8);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_H_AUTO_REQ) >> 8);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_H_DMA_REQ_MODE) >> 8);
+	ep_csr &= ~((1 << USBC_BP_RXCSR_H_DMA_REQ_EN) >> 8);
+	USBC_Writeb(ep_csr, (USBC_REG_RXCSR(usbc_base_addr) + 1));
+}
+
+static __u32 __USBC_Host_Rx_IsReadDataReady(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_RXCSR_H_RX_PKT_READY, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ReadDataHalf(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_RXCSR_H_RX_PKT_READY, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ReadDataComplete(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_RXCSR_H_RX_PKT_READY, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_Rx_IsNakTimeOut(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_RXCSR_H_NAK_TIMEOUT, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ClearNakTimeOut(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_RXCSR_H_NAK_TIMEOUT, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_Rx_IsError(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_RXCSR_H_ERROR, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ClearError(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_RXCSR_H_ERROR, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_Rx_IsStall(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_RXCSR_H_RX_STALL, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ClearStall(__u32 usbc_base_addr)
+{
+    USBC_REG_clear_bit_w(USBC_BP_RXCSR_H_RX_STALL, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_ClearCSR(__u32 usbc_base_addr)
+{
+    USBC_Writew(0x00, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static __u32 __USBC_Host_Rx_IsReqPktSet(__u32 usbc_base_addr)
+{
+    return USBC_REG_test_bit_w(USBC_BP_RXCSR_H_REQ_PACKET, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_StartInToken(__u32 usbc_base_addr)
+{
+	USBC_REG_set_bit_w(USBC_BP_RXCSR_H_REQ_PACKET, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+static void __USBC_Host_Rx_StopInToken(__u32 usbc_base_addr)
+{
+	USBC_REG_clear_bit_w(USBC_BP_RXCSR_H_REQ_PACKET, USBC_REG_RXCSR(usbc_base_addr));
+}
+
+void USBC_Host_SetFunctionAddress_Deafult(__hdle hUSB, __u32 ep_type, __u32 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_TX:
+			USBC_Writeb(0x00, USBC_REG_TXFADDRx(usbc_otg->base_addr, ep_index));
+			USBC_Writeb(0x00, USBC_REG_TXHADDRx(usbc_otg->base_addr, ep_index));
+			USBC_Writeb(0x00, USBC_REG_TXHPORTx(usbc_otg->base_addr, ep_index));
+		break;
+
+		case USBC_EP_TYPE_RX:
+			USBC_Writeb(0x00, USBC_REG_RXFADDRx(usbc_otg->base_addr, ep_index));
+			USBC_Writeb(0x00, USBC_REG_RXHADDRx(usbc_otg->base_addr, ep_index));
+			USBC_Writeb(0x00, USBC_REG_RXHPORTx(usbc_otg->base_addr, ep_index));
+		break;
+
+		default:
+		break;
+	}
+}
+
+void USBC_Host_SetFunctionAddress(__hdle hUSB,
+								  __u32 EpType,
+								  __u32 EpIndex,
+								  __u32 FunctionAdress,
+								  __u32 MultiTT,
+								  __u32 HubAddress,
+								  __u32 HubPortNumber)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u8 temp_8 = 0;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	if(MultiTT){
+		temp_8 = 1 << USBC_BP_HADDR_MULTI_TT;
+	}
+
+	temp_8 |= HubAddress;
+
+	switch(EpType){
+		case USBC_EP_TYPE_TX:
+			USBC_Writeb(FunctionAdress, USBC_REG_TXFADDRx(usbc_otg->base_addr, EpIndex));
+			USBC_Writeb(temp_8, USBC_REG_TXHADDRx(usbc_otg->base_addr, EpIndex));
+			USBC_Writeb(HubPortNumber, USBC_REG_TXHPORTx(usbc_otg->base_addr, EpIndex));
+		break;
+
+		case USBC_EP_TYPE_RX:
+			USBC_Writeb(FunctionAdress, USBC_REG_RXFADDRx(usbc_otg->base_addr, EpIndex));
+			USBC_Writeb(temp_8, USBC_REG_RXHADDRx(usbc_otg->base_addr, EpIndex));
+			USBC_Writeb(HubPortNumber, USBC_REG_RXHPORTx(usbc_otg->base_addr, EpIndex));
+		break;
+
+		default:
+		break;
+	}
+}
+
+void USBC_Host_SetHubAddress_Deafult(__hdle hUSB, __u32 ep_type, __u32 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_TX:
+			USBC_Writeb(0x00, USBC_REG_TXHADDRx(usbc_otg->base_addr, ep_index));
+		break;
+
+		case USBC_EP_TYPE_RX:
+			USBC_Writeb(0x00, USBC_REG_RXHADDRx(usbc_otg->base_addr, ep_index));
+		break;
+
+		default:
+		break;
+	}
+}
+
+void USBC_Host_SetHubAddress(__hdle hUSB, __u32 ep_type, __u32 ep_index, __u32 is_mutli_tt, __u8 address)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_TX:
+			USBC_Writeb(((is_mutli_tt << USBC_BP_HADDR_MULTI_TT) | address), USBC_REG_TXHADDRx(usbc_otg->base_addr, ep_index));
+		break;
+
+		case USBC_EP_TYPE_RX:
+			USBC_Writeb(((is_mutli_tt << USBC_BP_HADDR_MULTI_TT) | address), USBC_REG_RXHADDRx(usbc_otg->base_addr, ep_index));
+		break;
+
+		default:
+		break;
+	}
+}
+
+void USBC_Host_SetHPortAddress_Deafult(__hdle hUSB, __u32 ep_type, __u32 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_TX:
+			USBC_Writeb(0x00, USBC_REG_TXHPORTx(usbc_otg->base_addr, ep_index));
+		break;
+
+		case USBC_EP_TYPE_RX:
+			USBC_Writeb(0x00, USBC_REG_RXHPORTx(usbc_otg->base_addr, ep_index));
+		break;
+
+		default:
+		break;
+	}
+}
+
+void USBC_Host_SetHPortAddress(__hdle hUSB, __u32 ep_type, __u32 ep_index, __u8 address)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_TX:
+			USBC_Writeb(address, USBC_REG_TXHPORTx(usbc_otg->base_addr, ep_index));
+		break;
+
+		case USBC_EP_TYPE_RX:
+			USBC_Writeb(address, USBC_REG_RXHPORTx(usbc_otg->base_addr, ep_index));
+		break;
+
+		default:
+		break;
+	}
+}
+
+__u32 USBC_Host_QueryTransferMode(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return USBC_TS_MODE_UNKOWN;
+	}
+
+    if(USBC_REG_test_bit_b(USBC_BP_POWER_H_HIGH_SPEED_FLAG, USBC_REG_PCTL(usbc_otg->base_addr))){
+		return USBC_TS_MODE_HS;
+	}else{
+	    return USBC_TS_MODE_FS;
+	}
+}
+
+void USBC_Host_ConfigTransferMode(__hdle hUSB, __u32 speed_mode)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	//
+    switch(speed_mode){
+		case USBC_TS_MODE_HS:
+			__USBC_Host_TsMode_Hs(usbc_otg->base_addr);
+		break;
+
+		case USBC_TS_MODE_FS:
+			__USBC_Host_TsMode_Fs(usbc_otg->base_addr);
+		break;
+
+		case USBC_TS_MODE_LS:
+			__USBC_Host_TsMode_Ls(usbc_otg->base_addr);
+		break;
+
+		default:  //hs
+			__USBC_Host_TsMode_Default(usbc_otg->base_addr);
+	}
+}
+
+/* reset usb , reset100ms */
+void USBC_Host_ResetPort(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_set_bit_b(USBC_BP_POWER_H_RESET, USBC_REG_PCTL(usbc_otg->base_addr));
+}
+
+/* USBC_Host_ResetPortUSBC_Host_ClearResetPortFlag, bsp */
+void USBC_Host_ClearResetPortFlag(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_clear_bit_b(USBC_BP_POWER_H_RESET, USBC_REG_PCTL(usbc_otg->base_addr));
+}
+
+/* resume usb , resume10ms */
+void USBC_Host_RusumePort(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_set_bit_b(USBC_BP_POWER_H_RESUME, USBC_REG_PCTL(usbc_otg->base_addr));
+}
+
+/* USBC_Host_RusumePortUSBC_Host_ClearRusumePortFlag, bsp */
+void USBC_Host_ClearRusumePortFlag(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_clear_bit_b(USBC_BP_POWER_H_RESUME, USBC_REG_PCTL(usbc_otg->base_addr));
+}
+
+/* usb suspend */
+void USBC_Host_SuspendPort(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+    USBC_REG_set_bit_b(USBC_BP_POWER_H_SUSPEND, USBC_REG_PCTL(usbc_otg->base_addr));
+}
+
+__u32 USBC_Host_QueryPowerStatus(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	return USBC_Readb(USBC_REG_PCTL(usbc_otg->base_addr));
+}
+
+
+void USBC_Host_StartSession(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	USBC_REG_set_bit_b(USBC_BP_DEVCTL_SESSION, USBC_REG_DEVCTL(usbc_otg->base_addr));
+}
+
+void USBC_Host_EndSession(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	USBC_REG_clear_bit_b(USBC_BP_DEVCTL_SESSION, USBC_REG_DEVCTL(usbc_otg->base_addr));
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_PeripheralType
+*
+* Description:
+*    
+*
+* Arguments:
+*    hUSB  :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Host_PeripheralType(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+    __u8 reg_val = 0;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	reg_val = USBC_Readb(USBC_REG_DEVCTL(usbc_otg->base_addr));
+	if(reg_val & (1 << USBC_BP_DEVCTL_FS_DEV)){
+		return USBC_DEVICE_FSDEV;
+	}else if(reg_val & (1 << USBC_BP_DEVCTL_LS_DEV)){
+	    return USBC_DEVICE_LSDEV;
+	}else{
+	    return USBC_DEVICE_LSDEV;
+	}
+}
+
+void USBC_Host_FlushFifo(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_FlushFifo(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_FlushFifo(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_FlushFifo(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_ConfigEp_Default
+*
+* Description:
+*    ep, 
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_ConfigEp_Default(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_ConfigEp_Default(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_ConfigEp_Default(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ConfigEp_Default(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Dev_ConfigEp
+*
+* Description:
+*    ep, FIFO
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  ep
+*    ep_index       :  input.  ep
+*    ts_type        :  input.  
+*    is_double_fifo :  input.  
+*    ep_MaxPkt      :  input.  
+*    interval       :  input.  
+*
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_ConfigEp(__hdle hUSB, __u32 ep_type, __u32 ep_index, __u32 ts_mode, __u32 ts_type, __u32 is_double_fifo, __u32 ep_MaxPkt, __u32 interval)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_ConfigEp(usbc_otg->base_addr, ts_mode, interval);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_ConfigEp(usbc_otg->base_addr, ep_index, ts_mode, ts_type, is_double_fifo, ep_MaxPkt, interval);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ConfigEp(usbc_otg->base_addr, ep_index, ts_mode, ts_type, is_double_fifo, ep_MaxPkt, interval);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_ConfigEpDma
+*
+* Description:
+*    epdma
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_ConfigEpDma(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_ConfigEpDma(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ConfigEpDma(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_ClearEpDma
+*
+* Description:
+*    epdma
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_ClearEpDma(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_ClearEpDma(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ClearEpDma(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_IsEpNakTimeOut
+*
+* Description:
+*    eperror
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*    0  :  NAK not timeout
+*    1  :  NAK timeout
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Host_IsEpNakTimeOut(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return __USBC_Host_ep0_IsNakTimeOut(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_TX:
+			return __USBC_Host_Tx_IsNakTimeOut(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_RX:
+			return __USBC_Host_Rx_IsNakTimeOut(usbc_otg->base_addr);
+
+		default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_ClearEpNakTimeOut
+*
+* Description:
+*    eperror
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_ClearEpNakTimeOut(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_ClearNakTimeOut(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_ClearNakTimeOut(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ClearNakTimeOut(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_IsEpError
+*
+* Description:
+*    eperror
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*    0  :  ep is not error
+*    1  :  ep is error
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Host_IsEpError(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return __USBC_Host_ep0_IsError(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_TX:
+			return __USBC_Host_Tx_IsError(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_RX:
+			return __USBC_Host_Rx_IsError(usbc_otg->base_addr);
+
+		default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_ClearEpError
+*
+* Description:
+*    eperror
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_ClearEpError(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_ClearError(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_ClearError(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ClearError(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_IsEpStall
+*
+* Description:
+*    epstall
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*    0  :  ep is not stall
+*    1  :  ep is stall
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Host_IsEpStall(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return __USBC_Host_ep0_IsStall(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_TX:
+			return __USBC_Host_Tx_IsStall(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_RX:
+			return __USBC_Host_Rx_IsStall(usbc_otg->base_addr);
+
+		default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_ClearEpStall
+*
+* Description:
+*    epstall
+*
+* Arguments:
+*    hUSB           :  input.  USBC_open_otg, USBC
+*    ep_type        :  input.  
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_ClearEpStall(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return ;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_ClearStall(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_ClearStall(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ClearStall(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+void USBC_Host_ClearEpCSR(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_ClearCSR(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_ClearCSR(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ClearCSR(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+static __s32 __USBC_Host_ReadDataHalf(__u32 usbc_base_addr, __u32 ep_type)
+{
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_ReadDataHalf(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			//not support
+		    return -1;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ReadDataHalf(usbc_base_addr);
+		break;
+
+		default:
+		    return -1;
+	}
+
+	return 0;
+}
+
+static __s32 __USBC_Host_ReadDataComplete(__u32 usbc_base_addr, __u32 ep_type)
+{
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_ReadDataComplete(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			//not support
+		    return -1;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_ReadDataComplete(usbc_base_addr);
+		break;
+
+		default:
+		    return -1;
+	}
+
+	return 0;
+}
+
+static __s32 __USBC_Host_WriteDataHalf(__u32 usbc_base_addr, __u32 ep_type)
+{
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_WriteDataHalf(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_WriteDataHalf(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			//not support
+		    return -1;
+
+		default:
+		    return -1;
+	}
+
+	return 0;
+}
+
+static __s32 __USBC_Host_WriteDataComplete(__u32 usbc_base_addr, __u32 ep_type)
+{
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_WriteDataComplete(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			__USBC_Host_Tx_WriteDataComplete(usbc_base_addr);
+		break;
+
+		case USBC_EP_TYPE_RX:
+			//not support
+		    return -1;
+
+		default:
+		    return -1;
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_IsReadDataReady
+*
+* Description:
+*    usb
+*
+* Arguments:
+*    hUSB     :  input.  USBC_open_otg, USBC
+*    ep_type  :  input.  
+*
+* Returns:
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Host_IsReadDataReady(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return __USBC_Host_ep0_IsReadDataReady(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_TX:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_RX:
+			return __USBC_Host_Rx_IsReadDataReady(usbc_otg->base_addr);
+
+		default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_IsWriteDataReady
+*
+* Description:
+*    fifo
+*
+* Arguments:
+*    hUSB    :  input.  USBC_open_otg, USBC
+*    ep_type :  input.  
+*
+* Returns:
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Host_IsWriteDataReady(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return __USBC_Host_ep0_IsWriteDataReady(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_TX:
+			return __USBC_Host_Tx_IsWriteDataReady(usbc_otg->base_addr);
+
+		case USBC_EP_TYPE_RX:
+			//not support
+		break;
+
+		default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_ReadDataStatus
+*
+* Description:
+*    , , 
+*
+* Arguments:
+*    hUSB      :  input.  USBC_open_otg, USBC
+*    ep_type   :  input.  
+*    complete  :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Host_ReadDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	if(complete){
+		__USBC_Host_ReadDataComplete(usbc_otg->base_addr, ep_type);
+	}else{
+	    __USBC_Host_ReadDataHalf(usbc_otg->base_addr, ep_type);
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_WriteDataStatus
+*
+* Description:
+*    , , 
+*
+* Arguments:
+*    hUSB      :  input.  USBC_open_otg, USBC
+*    ep_type   :  input.  
+*    complete  :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__s32 USBC_Host_WriteDataStatus(__hdle hUSB, __u32 ep_type, __u32 complete)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return -1;
+	}
+
+	if(complete){
+		return __USBC_Host_WriteDataComplete(usbc_otg->base_addr, ep_type);
+	}else{
+	    return __USBC_Host_WriteDataHalf(usbc_otg->base_addr, ep_type);
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_IsReqPktSet
+*
+* Description:
+*    ReqPkt
+*
+* Arguments:
+*    hUSB      :  input.  USBC_open_otg, USBC
+*    ep_type   :  input.  
+* Returns:
+*    0  :  
+*   !0  :  
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_Host_IsReqPktSet(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return 0;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			return __USBC_Host_ep0_IsReqPktSet(usbc_otg->base_addr);
+		//break;
+
+		case USBC_EP_TYPE_TX:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_RX:
+			return __USBC_Host_Rx_IsReqPktSet(usbc_otg->base_addr);
+		//break;
+
+		default:
+		break;
+	}
+
+	return 0;
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_StartInToken
+*
+* Description:
+*    in token
+*
+* Arguments:
+*    hUSB      :  input.  USBC_open_otg, USBC
+*    ep_type   :  input.  
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_StartInToken(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_StartInToken(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_StartInToken(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+
+/*
+***********************************************************************************
+*                     USBC_Host_StopInToken
+*
+* Description:
+*    in token
+*
+* Arguments:
+*    hUSB      :  input.  USBC_open_otg, USBC
+*    ep_type   :  input.  
+* Returns:
+*
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_Host_StopInToken(__hdle hUSB, __u32 ep_type)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	switch(ep_type){
+		case USBC_EP_TYPE_EP0:
+			__USBC_Host_ep0_StopInToken(usbc_otg->base_addr);
+		break;
+
+		case USBC_EP_TYPE_TX:
+			//not support
+		break;
+
+		case USBC_EP_TYPE_RX:
+			__USBC_Host_Rx_StopInToken(usbc_otg->base_addr);
+		break;
+
+		default:
+		break;
+	}
+}
+/*
+void USBC_Host_ConfigRqPktCount(__hdle hUSB, __u32 ep_index, __u32 RqPktCount)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	USBC_Writew(RqPktCount, USBC_REG_RPCOUNTx(usbc_otg->base_addr, ep_index));
+}
+*/
+void USBC_Host_ConfigRqPktCount(__hdle hUSB, __u32 ep_index, __u32 RqPktCount)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+	__u32 temp = 0;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	temp = USBC_REG_RPCOUNTx(usbc_otg->base_addr, ep_index);
+
+	USBC_Writew(RqPktCount, temp);
+}
+
+void USBC_Host_ClearRqPktCount(__hdle hUSB, __u32 ep_index)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	USBC_Writew(0x00, USBC_REG_RPCOUNTx(usbc_otg->base_addr, ep_index));
+}
+
+void USBC_Host_EnablePing(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	__USBC_Host_ep0_EnablePing(usbc_otg->base_addr);
+}
+
+void USBC_Host_DisablePing(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	__USBC_Host_ep0_DisablePing(usbc_otg->base_addr);
+}
+
+void USBC_Host_SendCtrlStatus(__hdle hUSB, __u32 is_after_in)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+    if(is_after_in){
+		__USBC_Host_ep0_StatusAfterIn(usbc_otg->base_addr);
+	}else{
+		__USBC_Host_ep0_StatusAfterOut(usbc_otg->base_addr);
+	}
+}
+
+void USBC_Host_SendSetupPkt(__hdle hUSB)
+{
+    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(usbc_otg == NULL){
+		return;
+	}
+
+	__USBC_Host_ep0_SendSetupPkt(usbc_otg->base_addr);
+}
+
+
+
+EXPORT_SYMBOL(USBC_Host_SetFunctionAddress_Deafult);
+EXPORT_SYMBOL(USBC_Host_SetFunctionAddress);
+EXPORT_SYMBOL(USBC_Host_SetHubAddress_Deafult);
+EXPORT_SYMBOL(USBC_Host_SetHubAddress);
+EXPORT_SYMBOL(USBC_Host_SetHPortAddress_Deafult);
+EXPORT_SYMBOL(USBC_Host_SetHPortAddress);
+
+EXPORT_SYMBOL(USBC_Host_QueryTransferMode);
+EXPORT_SYMBOL(USBC_Host_ConfigTransferMode);
+
+EXPORT_SYMBOL(USBC_Host_ResetPort);
+EXPORT_SYMBOL(USBC_Host_ClearResetPortFlag);
+EXPORT_SYMBOL(USBC_Host_RusumePort);
+EXPORT_SYMBOL(USBC_Host_ClearRusumePortFlag);
+EXPORT_SYMBOL(USBC_Host_SuspendPort);
+EXPORT_SYMBOL(USBC_Host_QueryPowerStatus);
+
+EXPORT_SYMBOL(USBC_Host_EnablePing);
+EXPORT_SYMBOL(USBC_Host_DisablePing);
+EXPORT_SYMBOL(USBC_Host_IsReqPktSet);
+EXPORT_SYMBOL(USBC_Host_StartInToken);
+EXPORT_SYMBOL(USBC_Host_StopInToken);
+EXPORT_SYMBOL(USBC_Host_SendCtrlStatus);
+EXPORT_SYMBOL(USBC_Host_SendSetupPkt);
+
+EXPORT_SYMBOL(USBC_Host_StartSession);
+EXPORT_SYMBOL(USBC_Host_EndSession);
+EXPORT_SYMBOL(USBC_Host_ConfigRqPktCount);
+EXPORT_SYMBOL(USBC_Host_ClearRqPktCount);
+
+EXPORT_SYMBOL(USBC_Host_PeripheralType);
+
+EXPORT_SYMBOL(USBC_Host_FlushFifo);
+EXPORT_SYMBOL(USBC_Host_ConfigEp_Default);
+EXPORT_SYMBOL(USBC_Host_ConfigEp);
+EXPORT_SYMBOL(USBC_Host_ConfigEpDma);
+EXPORT_SYMBOL(USBC_Host_ClearEpDma);
+
+EXPORT_SYMBOL(USBC_Host_IsEpStall);
+EXPORT_SYMBOL(USBC_Host_ClearEpStall);
+EXPORT_SYMBOL(USBC_Host_IsEpNakTimeOut);
+EXPORT_SYMBOL(USBC_Host_ClearEpNakTimeOut);
+EXPORT_SYMBOL(USBC_Host_IsEpError);
+EXPORT_SYMBOL(USBC_Host_ClearEpError);
+EXPORT_SYMBOL(USBC_Host_ClearEpCSR);
+
+EXPORT_SYMBOL(USBC_Host_IsReadDataReady);
+EXPORT_SYMBOL(USBC_Host_IsWriteDataReady);
+EXPORT_SYMBOL(USBC_Host_ReadDataStatus);
+EXPORT_SYMBOL(USBC_Host_WriteDataStatus);
+
+
+
diff --git a/drivers/usb/sunxi_usb/usbc/usbc_i.h b/drivers/usb/sunxi_usb/usbc/usbc_i.h
new file mode 100644
index 0000000..6f6071b
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc_i.h
@@ -0,0 +1,53 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc_i.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel <daniel@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __USBC_I_H__
+#define  __USBC_I_H__
+
+#include "../include/sw_usb_config.h"
+
+#define  USBC_MAX_OPEN_NUM    8
+
+/* USB */
+typedef struct __fifo_info{
+    __u32 port0_fifo_addr;
+	__u32 port0_fifo_size;
+
+    __u32 port1_fifo_addr;
+	__u32 port1_fifo_size;
+
+	__u32 port2_fifo_addr;
+	__u32 port2_fifo_size;
+}__fifo_info_t;
+
+/* USB port */
+typedef struct __usbc_otg{
+    __u32 port_num;
+	__u32 base_addr;        /* usb base address 		*/
+
+	__u32 used;             /*    		*/
+    __u32 no;               /*  		*/
+}__usbc_otg_t;
+
+#endif   //__USBC_I_H__
+
diff --git a/drivers/usb/sunxi_usb/usbc/usbc_phy.c b/drivers/usb/sunxi_usb/usbc/usbc_phy.c
new file mode 100644
index 0000000..2837ede
--- /dev/null
+++ b/drivers/usb/sunxi_usb/usbc/usbc_phy.c
@@ -0,0 +1,668 @@
+/*
+ * drivers/usb/sunxi_usb/usbc/usbc_phy.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * daniel <daniel@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include  "usbc_i.h"
+
+
+/*
+ ***************************************************************************
+ *
+ * USB PHY
+ *
+ ***************************************************************************
+ */
+
+//Common Control Bits for Both PHYs
+#define  USBC_PHY_PLL_BW				0x03
+#define  USBC_PHY_RES45_CAL_EN			0x0c
+
+//Private Control Bits for Each PHY
+#define  USBC_PHY_TX_AMPLITUDE_TUNE		0x20
+#define  USBC_PHY_TX_SLEWRATE_TUNE		0x22
+#define  USBC_PHY_VBUSVALID_TH_SEL		0x25
+#define  USBC_PHY_PULLUP_RES_SEL		0x27
+#define  USBC_PHY_OTG_FUNC_EN			0x28
+#define  USBC_PHY_VBUS_DET_EN			0x29
+#define  USBC_PHY_DISCON_TH_SEL			0x2a
+
+#if 0
+/*
+ ***************************************************************************
+ *
+ * read out one bit of USB PHY register
+ *
+ ***************************************************************************
+ */
+static __u32 __USBC_PHY_REG_READ(__u32 usbc_base_addr, __u32 usbc_phy_reg_addr)
+{
+  	__u32 reg_val = 0;
+  	__u32 i = 0;
+
+  	USBC_Writeb(usbc_phy_reg_addr, USBC_REG_PHYCTL(USBC0_REGS_BASE) + 1);
+  	for(i=0; i<0x4; i++);
+  	reg_val = USBC_Readb(USBC_REG_PHYCTL(USBC0_REGS_BASE) + 2);
+  	if(usbc_base_addr == USBC0_REGS_BASE)
+  		return (reg_val & 0x1);
+  	else
+  		return ((reg_val >> 1) & 0x1);
+}
+
+/*
+ ***************************************************************************
+ *
+ * Write one bit of USB PHY register
+ *
+ ***************************************************************************
+ */
+static void __USBC_PHY_REG_WRITE(__u32 usbc_base_addr, __u32 usbc_phy_reg_addr, __u32 usbc_phy_reg_data)
+{
+  	__u32 reg_val = 0;
+
+  	USBC_Writeb(usbc_phy_reg_addr, USBC_REG_PHYCTL(USBC0_REGS_BASE) + 1);
+  	reg_val = USBC_Readb(USBC_REG_PHYCTL(USBC0_REGS_BASE));
+  	reg_val &= ~(0x1 << 7);
+  	reg_val |= (usbc_phy_reg_data & 0x1) << 7;
+  	if(usbc_base_addr == USBC0_REGS_BASE){
+  		reg_val &= ~0x1;
+  		USBC_Writeb(reg_val, USBC_REG_PHYCTL(USBC0_REGS_BASE));
+  		reg_val |= 0x1;
+  		USBC_Writeb(reg_val, USBC_REG_PHYCTL(USBC0_REGS_BASE));
+  		reg_val &= ~0x1;
+  		USBC_Writeb(reg_val, USBC_REG_PHYCTL(USBC0_REGS_BASE));
+  	}else{
+  		reg_val &= ~0x2;
+  		USBC_Writeb(reg_val, USBC_REG_PHYCTL(USBC0_REGS_BASE));
+  		reg_val |= 0x2;
+  		USBC_Writeb(reg_val, USBC_REG_PHYCTL(USBC0_REGS_BASE));
+  		reg_val &= ~0x2;
+  		USBC_Writeb(reg_val, USBC_REG_PHYCTL(USBC0_REGS_BASE));
+  	}
+}
+
+
+/*
+ ***************************************************************************
+ *
+ * Set USB PLL BandWidth, val = 0~3, defualt = 0x2
+ *
+ ***************************************************************************
+ */
+/*
+static void __USBC_PHY_SET_PLL_BW(__u32 val)
+{
+    __USBC_PHY_REG_WRITE(USBC0_REGS_BASE, USBC_PHY_PLL_BW, val);
+    __USBC_PHY_REG_WRITE(USBC0_REGS_BASE, USBC_PHY_PLL_BW + 1, val >> 1);
+}
+*/
+
+/*
+ ***************************************************************************
+ *
+ * Enable/Disable USB res45 Calibration, val = 0--Disable1--Enable, default = 0
+ *
+ ***************************************************************************
+ */
+static void __USBC_PHY_RES45_CALIBRATION_ENABLE(__u32 val)
+{
+    __USBC_PHY_REG_WRITE(USBC0_REGS_BASE, USBC_PHY_RES45_CAL_EN, val);
+}
+
+/*
+ ***************************************************************************
+ *
+ * Set USB TX Signal Amplitude, val = 0~3, default = 0x0
+ *
+ ***************************************************************************
+ */
+static void __USBC_PHY_SET_TX_AMPLITUDE(__u32 usbc_base_addr, __u32 val)
+{
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_TX_AMPLITUDE_TUNE, val);
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_TX_AMPLITUDE_TUNE + 1, val >> 1);
+}
+
+/*
+ ***************************************************************************
+ *
+ * Set USB TX Signal Slew Rate, val = 0~7, default = 0x5
+ *
+ ***************************************************************************
+ */
+static void __USBC_PHY_SET_TX_SLEWRATE(__u32 usbc_base_addr, __u32 val)
+{
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_TX_SLEWRATE_TUNE, val);
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_TX_SLEWRATE_TUNE + 1, val >> 1);
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_TX_SLEWRATE_TUNE + 2, val >> 2);
+}
+
+/*
+ ***************************************************************************
+ *
+ * Set USB VBUS Valid Threshold, val = 0~3, default = 2
+ *
+ ***************************************************************************
+ */
+/*
+static void __USBC_PHY_SET_VBUS_VALID_THRESHOLD(__u32 usbc_base_addr, __u32 val)
+{
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_VBUSVALID_TH_SEL, val);
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_VBUSVALID_TH_SEL + 1, val >> 1);
+}
+*/
+
+/*
+ ***************************************************************************
+ *
+ * Enable/Diasble USB OTG Function, val = 0--Disable1--Enable, default = 1
+ *
+ ***************************************************************************
+ */
+/*
+static void __USBC_PHY_OTG_FUNC_ENABLE(__u32 usbc_base_addr, __u32 val)
+{
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_OTG_FUNC_EN, val);
+}
+*/
+
+/*
+ ***************************************************************************
+ *
+ * Enable/Diasble USB VBUS Detect Function, val = 0--Disable1--Enable, default = 1
+ *
+ ***************************************************************************
+ */
+/*
+static void __USBC_PHY_VBUS_DET_ENABLE(__u32 usbc_base_addr, __u32 val)
+{
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_VBUS_DET_EN, val);
+}
+*/
+
+/*
+ ***************************************************************************
+ *
+ * Set USB Disconnect Detect Threshold, val = 0~3, default = 1
+ *
+ ***************************************************************************
+ */
+static void __USBC_PHY_SET_DISCON_DET_THRESHOLD(__u32 usbc_base_addr, __u32 val)
+{
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_DISCON_TH_SEL, val);
+    __USBC_PHY_REG_WRITE(usbc_base_addr, USBC_PHY_DISCON_TH_SEL + 1, val >> 1);
+}
+#endif
+
+/*
+***********************************************************************************
+*                     USBC_PHY_SetCommonConfig
+*
+* Description:
+*    PhyUSB PHY
+*
+* Arguments:
+*    NULL
+*
+* Returns:
+*    NULL
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_PHY_SetCommonConfig(void)
+{
+    //__USBC_PHY_RES45_CALIBRATION_ENABLE(1);
+}
+
+/*
+***********************************************************************************
+*                     USBC_PHY_SetPrivateConfig
+*
+* Description:
+*    USB PHY
+*
+* Arguments:
+*    hUSB       :  input.  USBC_open_otg, USBC
+*
+* Returns:
+*    NULL
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+void USBC_PHY_SetPrivateConfig(__hdle hUSB)
+{
+//    __usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+//
+//	if(usbc_otg == NULL){
+//		return ;
+//	}
+//
+//    USBC_REG_set_bit_l(0, USBC_REG_PHYTUNE(usbc_otg->base_addr));
+//    USBC_REG_set_bit_l(7, USBC_REG_PHYTUNE(usbc_otg->base_addr));
+//    USBC_REG_set_bit_l(6, USBC_REG_PHYTUNE(usbc_otg->base_addr));
+//    USBC_REG_set_bit_l(5, USBC_REG_PHYTUNE(usbc_otg->base_addr));
+//    USBC_REG_set_bit_l(4, USBC_REG_PHYTUNE(usbc_otg->base_addr));
+//    //__USBC_PHY_SET_TX_AMPLITUDE(usbc_otg->base_addr, 2);
+//    //__USBC_PHY_SET_TX_SLEWRATE(usbc_otg->base_addr, 6);
+//    //__USBC_PHY_SET_DISCON_DET_THRESHOLD(usbc_otg->base_addr, 3);
+}
+
+/*
+***********************************************************************************
+*                     USBC_PHY_GetCommonConfig
+*
+* Description:
+*    PhyDebugPhy
+*
+* Arguments:
+*    NULL
+*
+* Returns:
+*    32bitsUSB PHY
+*
+* note:
+*    
+*
+***********************************************************************************
+*/
+__u32 USBC_PHY_GetCommonConfig(void)
+{
+    __u32 reg_val = 0;
+/*
+    __u32 i = 0;
+
+    reg_val = 0;
+	for(i=0; i<0x20; i++)
+	{
+		reg_val = reg_val << 1;
+		reg_val |= __USBC_PHY_REG_READ(USBC0_REGS_BASE, (0x1f - i)) & 0x1;
+	}
+*/
+	return reg_val;
+}
+
+/*
+***********************************************************************************
+*                                usb_phy0_write
+*Description:
+*    usb phy0phyphy0 standby
+*
+*Arguments:
+*    address,  data,   dmask
+*
+*returns:
+*    return the data wrote
+*
+*note:
+*    no
+************************************************************************************
+*/
+
+static __u32 usb_phy0_write(__u32 addr, __u32 data, __u32 dmask, __u32 usbc_base_addr)
+{
+	__u32 i=0;
+
+	data = data & 0x0f;
+	addr = addr & 0x0f;
+	dmask = dmask & 0x0f;
+
+	USBC_Writeb((dmask<<4)|data, usbc_base_addr + 0x404 + 2);
+	USBC_Writeb(addr|0x10, usbc_base_addr + 0x404);
+	for(i=0;i<5;i++);
+	USBC_Writeb(addr|0x30, usbc_base_addr + 0x404);
+	for(i=0;i<5;i++);
+	USBC_Writeb(addr|0x10, usbc_base_addr + 0x404);
+	for(i=0;i<5;i++);
+	return (USBC_Readb(usbc_base_addr + 0x404 + 3) & 0x0f);
+}
+
+/*
+*******************************************************************************
+*                     USBC_phy_Standby
+*
+* Description:
+*    Standby the usb phy with the input usb phy index number
+*
+* Parameters:
+*    usb phy index number, which used to select the phy to standby
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void USBC_phy_Standby(__hdle hUSB, __u32 phy_index)
+{
+	__usbc_otg_t *usbc_otg = (__usbc_otg_t *)hUSB;
+
+	if(phy_index == 0){
+        usb_phy0_write(0xB, 0x8, 0xf, usbc_otg->base_addr);
+        usb_phy0_write(0x7, 0xf, 0xf, usbc_otg->base_addr);
+        usb_phy0_write(0x1, 0xf, 0xf, usbc_otg->base_addr);
+        usb_phy0_write(0x2, 0xf, 0xf, usbc_otg->base_addr);
+    }
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     USBC_Phy_Standby_Recover
+*
+* Description:
+*    Recover the standby phy with the input index number
+*
+* Parameters:
+*    usb phy index number
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void USBC_Phy_Standby_Recover(__hdle hUSB, __u32 phy_index)
+{
+	__u32 i;
+
+	if(phy_index == 0){
+		for(i=0; i<0x10; i++);
+	}
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     USBC_Phy_GetCsr
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __u32 USBC_Phy_GetCsr(__u32 usbc_no)
+{
+	__u32 val = 0x0;
+
+	switch(usbc_no){
+		case 0:
+			val = SW_VA_USB0_IO_BASE + 0x404;
+		break;
+
+		case 1:
+			val = SW_VA_USB0_IO_BASE + 0x404;
+		break;
+
+		case 2:
+			val = SW_VA_USB0_IO_BASE + 0x404;
+		break;
+
+		default:
+		break;
+	}
+
+	return val;
+}
+
+/*
+*******************************************************************************
+*                     USBC_Phy_TpRead
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+#if 0
+static __u32 USBC_Phy_TpRead(__u32 usbc_no, __u32 addr, __u32 len)
+{
+	__u32 temp = 0, ret = 0;
+	__u32 i=0;
+	__u32 j=0;
+
+	for(j = len; j > 0; j--)
+	{
+		/* set  the bit address to be read */
+		temp = USBC_Readl(USBC_Phy_GetCsr(usbc_no));
+		temp &= ~(0xff << 8);
+		temp |= ((addr + j -1) << 8);
+		USBC_Writel(temp, USBC_Phy_GetCsr(usbc_no));
+
+		for(i = 0; i < 0x4; i++);
+
+		temp = USBC_Readl(USBC_Phy_GetCsr(usbc_no));
+		ret <<= 1;
+		ret |= ((temp >> (16 + usbc_no)) & 0x1);
+	}
+
+	return ret;
+}
+#endif
+
+/*
+*******************************************************************************
+*                     USBC_Phy_TpWrite
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __u32 USBC_Phy_TpWrite(__u32 usbc_no, __u32 addr, __u32 data, __u32 len)
+{
+	__u32 temp = 0, dtmp = 0;
+//	__u32 i=0;
+	__u32 j=0;
+
+	dtmp = data;
+	for(j = 0; j < len; j++)
+	{
+		/* set  the bit address to be write */
+		temp = USBC_Readl(USBC_Phy_GetCsr(usbc_no));
+		temp &= ~(0xff << 8);
+		temp |= ((addr + j) << 8);
+		USBC_Writel(temp, USBC_Phy_GetCsr(usbc_no));
+
+		temp = USBC_Readb(USBC_Phy_GetCsr(usbc_no));
+		temp &= ~(0x1 << 7);
+		temp |= (dtmp & 0x1) << 7;
+		temp &= ~(0x1 << (usbc_no << 1));
+		USBC_Writeb(temp, USBC_Phy_GetCsr(usbc_no));
+
+		temp = USBC_Readb(USBC_Phy_GetCsr(usbc_no));
+		temp |= (0x1 << (usbc_no << 1));
+		USBC_Writeb( temp, USBC_Phy_GetCsr(usbc_no));
+
+		temp = USBC_Readb(USBC_Phy_GetCsr(usbc_no));
+		temp &= ~(0x1 << (usbc_no <<1 ));
+		USBC_Writeb(temp, USBC_Phy_GetCsr(usbc_no));
+		dtmp >>= 1;
+	}
+
+	return data;
+}
+
+/*
+*******************************************************************************
+*                     USBC_Phy_Read
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+#if 0
+static __u32 USBC_Phy_Read(__u32 usbc_no, __u32 addr, __u32 len)
+{
+	return USBC_Phy_TpRead(usbc_no, addr, len);
+}
+#endif
+
+/*
+*******************************************************************************
+*                     USBC_Phy_Write
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+static __u32 USBC_Phy_Write(__u32 usbc_no, __u32 addr, __u32 data, __u32 len)
+{
+	return USBC_Phy_TpWrite(usbc_no, addr, data, len);
+}
+
+/*
+*******************************************************************************
+*                     UsbPhyInit
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void UsbPhyInit(__u32 usbc_no)
+{
+//	DMSG_INFO("csr1: usbc%d: 0x%x\n", usbc_no, (u32)USBC_Readl(USBC_Phy_GetCsr(usbc_no)));
+
+    /* 45 */
+	if(usbc_no == 0){
+	    USBC_Phy_Write(usbc_no, 0x0c, 0x01, 1);
+	}
+
+//	DMSG_INFO("csr2-0: usbc%d: 0x%x\n", usbc_no, (u32)USBC_Phy_Read(usbc_no, 0x0c, 1));
+
+    /*  USB0 PHY  */
+	USBC_Phy_Write(usbc_no, 0x20, 0x14, 5);
+
+//	DMSG_INFO("csr2-1: usbc%d: 0x%x\n", usbc_no, (u32)USBC_Phy_Read(usbc_no, 0x20, 5));
+
+    /*  disconnect  */
+#ifdef CONFIG_ARCH_SUN4I
+	USBC_Phy_Write(usbc_no, 0x2a, 3, 2);
+#else
+	USBC_Phy_Write(usbc_no, 0x2a, 2, 2);
+#endif
+
+//	DMSG_INFO("csr2: usbc%d: 0x%x\n", usbc_no, (u32)USBC_Phy_Read(usbc_no, 0x2a, 2));
+//	DMSG_INFO("csr3: usbc%d: 0x%x\n", usbc_no, (u32)USBC_Readl(USBC_Phy_GetCsr(usbc_no)));
+
+	return;
+}
+
+/*
+*******************************************************************************
+*                     UsbPhyEndReset
+*
+* Description:
+*    void
+*
+* Parameters:
+*    void
+*
+* Return value:
+*    void
+*
+* note:
+*    void
+*
+*******************************************************************************
+*/
+void UsbPhyEndReset(__u32 usbc_no)
+{
+	int i;
+
+	if(usbc_no == 0){
+		//Disable Sequelch Detect for a while before Release USB Reset
+		USBC_Phy_Write(usbc_no, 0x3c, 0x2, 2);
+		for(i=0; i<0x100; i++);
+		USBC_Phy_Write(usbc_no, 0x3c, 0x0, 2);
+	}
+
+	return;
+}
+
