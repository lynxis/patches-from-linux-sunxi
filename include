diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index f2f73f9..4bf4100 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -183,6 +183,8 @@ header-y += if_plip.h
 header-y += if_ppp.h
 header-y += if_pppol2tp.h
 header-y += if_pppox.h
+header-y += if_pppolac.h
+header-y += if_pppopns.h
 header-y += if_slip.h
 header-y += if_strip.h
 header-y += if_team.h
@@ -375,6 +377,7 @@ header-y += tty.h
 header-y += types.h
 header-y += udf_fs_i.h
 header-y += udp.h
+header-y += uhid.h
 header-y += uinput.h
 header-y += uio.h
 header-y += ultrasound.h
diff --git a/include/linux/akm8975.h b/include/linux/akm8975.h
new file mode 100644
index 0000000..6a7c432
--- /dev/null
+++ b/include/linux/akm8975.h
@@ -0,0 +1,87 @@
+/*
+ * Definitions for akm8975 compass chip.
+ */
+#ifndef AKM8975_H
+#define AKM8975_H
+
+#include <linux/ioctl.h>
+
+/*! \name AK8975 operation mode
+ \anchor AK8975_Mode
+ Defines an operation mode of the AK8975.*/
+/*! @{*/
+#define AK8975_MODE_SNG_MEASURE   0x01
+#define	AK8975_MODE_SELF_TEST     0x08
+#define	AK8975_MODE_FUSE_ACCESS   0x0F
+#define	AK8975_MODE_POWER_DOWN    0x00
+/*! @}*/
+
+#define RBUFF_SIZE		8	/* Rx buffer size */
+
+/*! \name AK8975 register address
+\anchor AK8975_REG
+Defines a register address of the AK8975.*/
+/*! @{*/
+#define AK8975_REG_WIA		0x00
+#define AK8975_REG_INFO		0x01
+#define AK8975_REG_ST1		0x02
+#define AK8975_REG_HXL		0x03
+#define AK8975_REG_HXH		0x04
+#define AK8975_REG_HYL		0x05
+#define AK8975_REG_HYH		0x06
+#define AK8975_REG_HZL		0x07
+#define AK8975_REG_HZH		0x08
+#define AK8975_REG_ST2		0x09
+#define AK8975_REG_CNTL		0x0A
+#define AK8975_REG_RSV		0x0B
+#define AK8975_REG_ASTC		0x0C
+#define AK8975_REG_TS1		0x0D
+#define AK8975_REG_TS2		0x0E
+#define AK8975_REG_I2CDIS	0x0F
+/*! @}*/
+
+/*! \name AK8975 fuse-rom address
+\anchor AK8975_FUSE
+Defines a read-only address of the fuse ROM of the AK8975.*/
+/*! @{*/
+#define AK8975_FUSE_ASAX	0x10
+#define AK8975_FUSE_ASAY	0x11
+#define AK8975_FUSE_ASAZ	0x12
+/*! @}*/
+
+#define AKMIO                   0xA1
+
+/* IOCTLs for AKM library */
+#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x02, char[5])
+#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x03, char[5])
+#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x08, char[RBUFF_SIZE])
+#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x0C, short[12])
+#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x0D, int)
+#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x0E, int)
+#define ECS_IOCTL_GET_DELAY             _IOR(AKMIO, 0x30, short)
+
+/* IOCTLs for APPs */
+#define ECS_IOCTL_APP_SET_MFLAG		_IOW(AKMIO, 0x11, short)
+#define ECS_IOCTL_APP_GET_MFLAG		_IOW(AKMIO, 0x12, short)
+#define ECS_IOCTL_APP_SET_AFLAG		_IOW(AKMIO, 0x13, short)
+#define ECS_IOCTL_APP_GET_AFLAG		_IOR(AKMIO, 0x14, short)
+#define ECS_IOCTL_APP_SET_DELAY		_IOW(AKMIO, 0x18, short)
+#define ECS_IOCTL_APP_GET_DELAY		ECS_IOCTL_GET_DELAY
+/* Set raw magnetic vector flag */
+#define ECS_IOCTL_APP_SET_MVFLAG	_IOW(AKMIO, 0x19, short)
+/* Get raw magnetic vector flag */
+#define ECS_IOCTL_APP_GET_MVFLAG	_IOR(AKMIO, 0x1A, short)
+#define ECS_IOCTL_APP_SET_TFLAG         _IOR(AKMIO, 0x15, short)
+
+
+struct akm8975_platform_data {
+	int intr;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+#endif
+
diff --git a/include/linux/alarmtimer.h b/include/linux/alarmtimer.h
index 975009e..96c5c24 100644
--- a/include/linux/alarmtimer.h
+++ b/include/linux/alarmtimer.h
@@ -76,4 +76,7 @@ static inline int alarmtimer_callback_running(struct alarm *timer)
 }
 
 
+/* Provide way to access the rtc device being used by alarmtimers */
+struct rtc_device *alarmtimer_get_rtcdev(void);
+
 #endif
diff --git a/include/linux/amba/mmci.h b/include/linux/amba/mmci.h
index 32a89cf..9d1d9ca 100644
--- a/include/linux/amba/mmci.h
+++ b/include/linux/amba/mmci.h
@@ -5,6 +5,15 @@
 #define AMBA_MMCI_H
 
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+
+struct embedded_sdio_data {
+        struct sdio_cis cis;
+        struct sdio_cccr cccr;
+        struct sdio_embedded_func *funcs;
+        int num_funcs;
+};
 
 
 /*
@@ -73,6 +82,9 @@ struct mmci_platform_data {
 	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
 	void *dma_rx_param;
 	void *dma_tx_param;
+	unsigned int status_irq;
+	struct embedded_sdio_data *embedded_sdio;
+	int (*register_status_notify)(void (*callback)(int card_present, void *dev_id), void *dev_id);
 };
 
 #endif
diff --git a/include/linux/android_aid.h b/include/linux/android_aid.h
new file mode 100644
index 0000000..06264b8
--- /dev/null
+++ b/include/linux/android_aid.h
@@ -0,0 +1,28 @@
+/* include/linux/android_aid.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ANDROID_AID_H
+#define _LINUX_ANDROID_AID_H
+
+/* AIDs that the kernel treats differently */
+#define AID_OBSOLETE_000 3001  /* was NET_BT_ADMIN */
+#define AID_OBSOLETE_001 3002  /* was NET_BT */
+#define AID_INET         3003
+#define AID_NET_RAW      3004
+#define AID_NET_ADMIN    3005
+#define AID_NET_BW_STATS 3006  /* read bandwidth statistics */
+#define AID_NET_BW_ACCT  3007  /* change bandwidth statistics accounting */
+
+#endif
diff --git a/include/linux/capability.h b/include/linux/capability.h
index 12d52de..c398cff 100644
--- a/include/linux/capability.h
+++ b/include/linux/capability.h
@@ -360,8 +360,11 @@ struct cpu_vfs_cap_data {
 
 #define CAP_WAKE_ALARM            35
 
+/* Allow preventing system suspends while epoll events are pending */
 
-#define CAP_LAST_CAP         CAP_WAKE_ALARM
+#define CAP_EPOLLWAKEUP      36
+
+#define CAP_LAST_CAP         CAP_EPOLLWAKEUP
 
 #define cap_valid(x) ((x) >= 0 && (x) <= CAP_LAST_CAP)
 
diff --git a/include/linux/cgroup.h b/include/linux/cgroup.h
index 5a85b34..b2a3735 100644
--- a/include/linux/cgroup.h
+++ b/include/linux/cgroup.h
@@ -84,12 +84,6 @@ enum {
 	CSS_REMOVED, /* This CSS is dead */
 };
 
-/* Caller must verify that the css is not for root cgroup */
-static inline void __css_get(struct cgroup_subsys_state *css, int count)
-{
-	atomic_add(count, &css->refcnt);
-}
-
 /*
  * Call css_get() to hold a reference on the css; it can be used
  * for a reference obtained via:
@@ -97,6 +91,7 @@ static inline void __css_get(struct cgroup_subsys_state *css, int count)
  * - task->cgroups for a locked task
  */
 
+extern void __css_get(struct cgroup_subsys_state *css, int count);
 static inline void css_get(struct cgroup_subsys_state *css)
 {
 	/* We don't need to reference count the root state */
@@ -143,10 +138,7 @@ static inline void css_put(struct cgroup_subsys_state *css)
 enum {
 	/* Control Group is dead */
 	CGRP_REMOVED,
-	/*
-	 * Control Group has previously had a child cgroup or a task,
-	 * but no longer (only if CGRP_NOTIFY_ON_RELEASE is set)
-	 */
+	/* Control Group has ever had a child cgroup or a task */
 	CGRP_RELEASABLE,
 	/* Control Group requires release notifications to userspace */
 	CGRP_NOTIFY_ON_RELEASE,
@@ -255,6 +247,7 @@ struct css_set {
 
 	/* For RCU-protected deletion */
 	struct rcu_head rcu_head;
+	struct work_struct work;
 };
 
 /*
@@ -455,6 +448,7 @@ struct cgroup_subsys {
 	struct cgroup_subsys_state *(*create)(struct cgroup *cgrp);
 	int (*pre_destroy)(struct cgroup *cgrp);
 	void (*destroy)(struct cgroup *cgrp);
+	int (*allow_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	int (*can_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	void (*cancel_attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
 	void (*attach)(struct cgroup *cgrp, struct cgroup_taskset *tset);
diff --git a/include/linux/cpu.h b/include/linux/cpu.h
index 78ed62f..caec85b 100644
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@ -213,4 +213,11 @@ static inline int disable_nonboot_cpus(void) { return 0; }
 static inline void enable_nonboot_cpus(void) {}
 #endif /* !CONFIG_PM_SLEEP_SMP */
 
+#define IDLE_START 1
+#define IDLE_END 2
+
+void idle_notifier_register(struct notifier_block *n);
+void idle_notifier_unregister(struct notifier_block *n);
+void idle_notifier_call_chain(unsigned long val);
+
 #endif /* _LINUX_CPU_H_ */
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index b60f6ba..d17c450 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -167,6 +167,9 @@ static inline unsigned long cpufreq_scale(unsigned long old, u_int div, u_int mu
 #define CPUFREQ_GOV_START  1
 #define CPUFREQ_GOV_STOP   2
 #define CPUFREQ_GOV_LIMITS 3
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+#define CPUFREQ_GOV_USRENET 4
+#endif
 
 struct cpufreq_governor {
 	char	name[CPUFREQ_NAME_LEN];
@@ -254,7 +257,10 @@ int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
 
 
 void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);
-
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+/* user event notification */
+void cpufreq_user_event_notify(void);
+#endif
 
 static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max)
 {
@@ -364,6 +370,12 @@ extern struct cpufreq_governor cpufreq_gov_ondemand;
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE)
 extern struct cpufreq_governor cpufreq_gov_conservative;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_conservative)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE)
+extern struct cpufreq_governor cpufreq_gov_interactive;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_interactive)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_FANTASY)
+extern struct cpufreq_governor cpufreq_gov_fantasy;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_fantasy)
 #endif
 
 
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
index 6c26a3d..5ab7183 100644
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -57,6 +57,7 @@ struct cpuidle_state {
 
 /* Idle State Flags */
 #define CPUIDLE_FLAG_TIME_VALID	(0x01) /* is residency time measurable? */
+#define CPUIDLE_FLAG_COUPLED	(0x02) /* state applies to multiple cpus */
 
 #define CPUIDLE_DRIVER_FLAGS_MASK (0xFFFF0000)
 
@@ -100,6 +101,12 @@ struct cpuidle_device {
 	struct list_head 	device_list;
 	struct kobject		kobj;
 	struct completion	kobj_unregister;
+
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+	int			safe_state_index;
+	cpumask_t		coupled_cpus;
+	struct cpuidle_coupled	*coupled;
+#endif
 };
 
 DECLARE_PER_CPU(struct cpuidle_device *, cpuidle_devices);
@@ -176,6 +183,10 @@ static inline int cpuidle_play_dead(void) {return -ENODEV; }
 
 #endif
 
+#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED
+void cpuidle_coupled_parallel_barrier(struct cpuidle_device *dev, atomic_t *a);
+#endif
+
 /******************************
  * CPUIDLE GOVERNOR INTERFACE *
  ******************************/
diff --git a/include/linux/dma-buf.h b/include/linux/dma-buf.h
index 3efbfc2..1f78d15 100644
--- a/include/linux/dma-buf.h
+++ b/include/linux/dma-buf.h
@@ -61,6 +61,10 @@ struct dma_buf_attachment;
  * 		   This Callback must not sleep.
  * @kmap: maps a page from the buffer into kernel address space.
  * @kunmap: [optional] unmaps a page from the buffer.
+ * @mmap: used to expose the backing storage to userspace. Note that the
+ * 	  mapping needs to be coherent - if the exporter doesn't directly
+ * 	  support this, it needs to fake coherency by shooting down any ptes
+ * 	  when transitioning away from the cpu domain.
  */
 struct dma_buf_ops {
 	int (*attach)(struct dma_buf *, struct device *,
@@ -92,6 +96,8 @@ struct dma_buf_ops {
 	void (*kunmap_atomic)(struct dma_buf *, unsigned long, void *);
 	void *(*kmap)(struct dma_buf *, unsigned long);
 	void (*kunmap)(struct dma_buf *, unsigned long, void *);
+
+	int (*mmap)(struct dma_buf *, struct vm_area_struct *vma);
 };
 
 /**
@@ -167,6 +173,9 @@ void *dma_buf_kmap_atomic(struct dma_buf *, unsigned long);
 void dma_buf_kunmap_atomic(struct dma_buf *, unsigned long, void *);
 void *dma_buf_kmap(struct dma_buf *, unsigned long);
 void dma_buf_kunmap(struct dma_buf *, unsigned long, void *);
+
+int dma_buf_mmap(struct dma_buf *, struct vm_area_struct *,
+		 unsigned long);
 #else
 
 static inline struct dma_buf_attachment *dma_buf_attach(struct dma_buf *dmabuf,
@@ -248,6 +257,13 @@ static inline void dma_buf_kunmap(struct dma_buf *dmabuf,
 				  unsigned long pnum, void *vaddr)
 {
 }
+
+static inline int dma_buf_mmap(struct dma_buf *dmabuf,
+			       struct vm_area_struct *vma,
+			       unsigned long pgoff)
+{
+	return -ENODEV;
+}
 #endif /* CONFIG_DMA_SHARED_BUFFER */
 
 #endif /* __DMA_BUF_H__ */
diff --git a/include/linux/drv_hdmi.h b/include/linux/drv_hdmi.h
new file mode 100644
index 0000000..ae0ae6d
--- /dev/null
+++ b/include/linux/drv_hdmi.h
@@ -0,0 +1,49 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __DRV_HDMI_H__
+#define __DRV_HDMI_H__
+
+typedef struct
+{
+	__u8    hw_intf;        /* 0:iis  1:spdif 2:pcm */
+	__u16	fs_between;     /* fs */
+	__u32   sample_rate;    /*sample rate*/  
+	__u8    clk_edge;       /* 0:*/
+	__u8    ch0_en;         /* 1 */
+	__u8    ch1_en;         /* 0 */
+	__u8 	ch2_en;         /* 0 */
+	__u8 	ch3_en;         /* 0 */
+	__u8	word_length;    /* 32 */
+	__u8    shift_ctl;      /* 0 */
+	__u8    dir_ctl;        /* 0 */
+	__u8    ws_pol;
+	__u8    just_pol;
+	__u8    channel_num;
+}hdmi_audio_t;
+
+typedef struct
+{
+    __s32 (*hdmi_audio_enable)(__u8 mode, __u8 channel);
+    __s32 (*hdmi_set_audio_para)(hdmi_audio_t * audio_para);
+}__audio_hdmi_func;
+
+#endif
diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
index 657ab55..6f8be32 100644
--- a/include/linux/eventpoll.h
+++ b/include/linux/eventpoll.h
@@ -26,6 +26,18 @@
 #define EPOLL_CTL_DEL 2
 #define EPOLL_CTL_MOD 3
 
+/*
+ * Request the handling of system wakeup events so as to prevent system suspends
+ * from happening while those events are being processed.
+ *
+ * Assuming neither EPOLLET nor EPOLLONESHOT is set, system suspends will not be
+ * re-allowed until epoll_wait is called again after consuming the wakeup
+ * event(s).
+ *
+ * Requires CAP_EPOLLWAKEUP
+ */
+#define EPOLLWAKEUP (1 << 29)
+
 /* Set the One Shot behaviour for the target file descriptor */
 #define EPOLLONESHOT (1 << 30)
 
diff --git a/include/linux/freezer.h b/include/linux/freezer.h
index ee89932..b79e4d8 100644
--- a/include/linux/freezer.h
+++ b/include/linux/freezer.h
@@ -41,6 +41,17 @@ extern int freeze_kernel_threads(void);
 extern void thaw_processes(void);
 extern void thaw_kernel_threads(void);
 
+/*
+ * HACK: prevent sleeping while atomic warnings due to ARM signal handling
+ * disabling irqs
+ */
+static inline bool try_to_freeze_nowarn(void)
+{
+	if (likely(!freezing(current)))
+		return false;
+	return __refrigerator(false);
+}
+
 static inline bool try_to_freeze(void)
 {
 	might_sleep();
diff --git a/include/linux/g2d_driver.h b/include/linux/g2d_driver.h
new file mode 100644
index 0000000..0474141
--- /dev/null
+++ b/include/linux/g2d_driver.h
@@ -0,0 +1,233 @@
+/* g2d_driver.h
+ *
+ * Copyright (c)	2011 xxxx Electronics
+ *					2011 Yupu Tang
+ *
+ * @ F23 G2D driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA
+ */
+
+#ifndef __G2D_DRIVER_H
+#define __G2D_DRIVER_H
+
+#ifndef __G2D_BSP_DRV_H
+#define __G2D_BSP_DRV_H
+
+/* mixer data format */
+typedef enum {
+	/* share data format */
+	G2D_FMT_ARGB_AYUV8888	= (0x0),
+	G2D_FMT_BGRA_VUYA8888	= (0x1),
+	G2D_FMT_ABGR_AVUY8888	= (0x2),
+	G2D_FMT_RGBA_YUVA8888	= (0x3),
+
+	G2D_FMT_XRGB8888		= (0x4),
+	G2D_FMT_BGRX8888		= (0x5),
+	G2D_FMT_XBGR8888		= (0x6),
+	G2D_FMT_RGBX8888		= (0x7),
+
+	G2D_FMT_ARGB4444		= (0x8),
+	G2D_FMT_ABGR4444		= (0x9),
+	G2D_FMT_RGBA4444		= (0xA),
+	G2D_FMT_BGRA4444		= (0xB),
+
+	G2D_FMT_ARGB1555		= (0xC),
+	G2D_FMT_ABGR1555		= (0xD),
+	G2D_FMT_RGBA5551		= (0xE),
+	G2D_FMT_BGRA5551		= (0xF),
+
+	G2D_FMT_RGB565			= (0x10),
+	G2D_FMT_BGR565			= (0x11),
+
+	G2D_FMT_IYUV422			= (0x12),
+
+	G2D_FMT_8BPP_MONO		= (0x13),
+	G2D_FMT_4BPP_MONO		= (0x14),
+	G2D_FMT_2BPP_MONO		= (0x15),
+	G2D_FMT_1BPP_MONO		= (0x16),
+
+	G2D_FMT_PYUV422UVC		= (0x17),
+	G2D_FMT_PYUV420UVC		= (0x18),
+	G2D_FMT_PYUV411UVC		= (0x19),
+
+	/* just for output format */
+	G2D_FMT_PYUV422			= (0x1A),
+	G2D_FMT_PYUV420			= (0x1B),
+	G2D_FMT_PYUV411			= (0x1C),
+
+	/* just for input format */
+	G2D_FMT_8BPP_PALETTE	= (0x1D),
+	G2D_FMT_4BPP_PALETTE	= (0x1E),
+	G2D_FMT_2BPP_PALETTE	= (0x1F),
+	G2D_FMT_1BPP_PALETTE	= (0x20),
+
+}g2d_data_fmt;
+
+/* pixel sequence in double word */
+typedef enum {
+	G2D_SEQ_NORMAL = 0x0,
+
+	/* for interleaved yuv422 */
+    G2D_SEQ_VYUY   = 0x1,				/* pixel 0在低16位 */
+    G2D_SEQ_YVYU   = 0x2,				/* pixel 1在低16位 */
+
+	/* for uv_combined yuv420 */
+    G2D_SEQ_VUVU   = 0x3,
+
+	/* for 16bpp rgb */
+    G2D_SEQ_P10    = 0x4,				/* pixel 0在低16位 */
+    G2D_SEQ_P01    = 0x5,				/* pixel 1在低16位 */
+
+	/* planar format or 8bpp rgb */
+    G2D_SEQ_P3210  = 0x6,				/* pixel 0在低8位 */
+    G2D_SEQ_P0123  = 0x7,				/* pixel 3在低8位 */
+
+	/* for 4bpp rgb */
+    G2D_SEQ_P76543210  = 0x8,			/* 7,6,5,4,3,2,1,0 */
+    G2D_SEQ_P67452301  = 0x9,			/* 6,7,4,5,2,3,0,1 */
+    G2D_SEQ_P10325476  = 0xA,			/* 1,0,3,2,5,4,7,6 */
+    G2D_SEQ_P01234567  = 0xB,			/* 0,1,2,3,4,5,6,7 */
+
+	/* for 2bpp rgb */
+    G2D_SEQ_2BPP_BIG_BIG       = 0xC,	/* 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 */
+    G2D_SEQ_2BPP_BIG_LITTER    = 0xD,	/* 12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3 */
+    G2D_SEQ_2BPP_LITTER_BIG    = 0xE,	/* 3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12 */
+    G2D_SEQ_2BPP_LITTER_LITTER = 0xF,	/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 */
+
+	/* for 1bpp rgb */
+    G2D_SEQ_1BPP_BIG_BIG       = 0x10,	/* 31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 */
+    G2D_SEQ_1BPP_BIG_LITTER    = 0x11,	/* 24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7 */
+    G2D_SEQ_1BPP_LITTER_BIG    = 0x12,	/* 7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8,23,22,21,20,19,18,17,16,31,30,29,28,27,26,25,24 */
+    G2D_SEQ_1BPP_LITTER_LITTER = 0x13,	/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31 */
+}g2d_pixel_seq;
+
+
+typedef enum {
+	G2D_FIL_NONE			= 0x00000000,
+	G2D_FIL_PIXEL_ALPHA		= 0x00000001,
+	G2D_FIL_PLANE_ALPHA		= 0x00000002,
+	G2D_FIL_MULTI_ALPHA		= 0x00000004,
+}g2d_fillrect_flags;
+
+typedef enum {
+
+	G2D_BLT_NONE			= 0x00000000,
+	G2D_BLT_PIXEL_ALPHA		= 0x00000001,
+	G2D_BLT_PLANE_ALPHA		= 0x00000002,
+	G2D_BLT_MULTI_ALPHA		= 0x00000004,
+	G2D_BLT_SRC_COLORKEY	= 0x00000008,
+	G2D_BLT_DST_COLORKEY	= 0x00000010,
+	G2D_BLT_FLIP_HORIZONTAL	= 0x00000020,
+	G2D_BLT_FLIP_VERTICAL	= 0x00000040,
+	G2D_BLT_ROTATE90		= 0x00000080,
+	G2D_BLT_ROTATE180		= 0x00000100,
+	G2D_BLT_ROTATE270		= 0x00000200,
+	G2D_BLT_MIRROR45		= 0x00000400,
+	G2D_BLT_MIRROR135		= 0x00000800,
+}g2d_blt_flags;
+
+/* flip rectangle struct */
+typedef struct {
+	__s32		x;			/* left top point coordinate x */
+	__s32		y;			/* left top point coordinate y */
+	__u32		w;			/* rectangle width */
+	__u32		h;			/* rectangle height */
+}g2d_rect;
+
+/* image struct */
+typedef struct {
+	__u32			 addr[3];		/* base addr of image frame buffer in byte */
+	__u32			 w;			/* width of image frame buffer in pixel */
+	__u32			 h;			/* height of image frame buffer in pixel */
+	g2d_data_fmt	 format;	/* pixel format of image frame buffer */
+	g2d_pixel_seq	 pixel_seq;	/* pixel sequence of image frame buffer */
+}g2d_image;
+
+typedef struct {
+	g2d_fillrect_flags	 flag;
+	g2d_image			 dst_image;
+	g2d_rect			 dst_rect;
+
+	__u32				 color;		/* fill color */
+	__u32				 alpha;		/* plane alpha value */
+
+}g2d_fillrect;
+
+typedef struct {
+	g2d_blt_flags		 flag;
+	g2d_image			 src_image;
+	g2d_rect			 src_rect;
+
+	g2d_image			 dst_image;
+	__s32				 dst_x;		/* left top point coordinate x of dst rect */
+	__s32				 dst_y;		/* left top point coordinate y of dst rect */
+
+	__u32				 color;		/* colorkey color */
+	__u32				 alpha;		/* plane alpha value */
+
+}g2d_blt;
+
+typedef struct {
+	g2d_blt_flags		 flag;
+	g2d_image			 src_image;
+	g2d_rect			 src_rect;
+
+	g2d_image			 dst_image;
+	g2d_rect			 dst_rect;
+
+	__u32				 color;		/* colorkey color */
+	__u32				 alpha;		/* plane alpha value */
+
+}g2d_stretchblt;
+
+typedef struct {
+	__u32		 flag;		/* 光栅操作码 */
+	g2d_image	 dst_image;
+	g2d_rect	 dst_rect;
+
+	g2d_image	 src_image;
+	__u32		 src_x;
+	__u32		 src_y;
+
+	g2d_image	 mask_image;
+	__u32		 mask_x;
+	__u32		 mask_y;
+
+}g2d_maskblt;
+
+typedef struct {
+	__u32		*pbuffer;
+	__u32		 size;
+
+}g2d_palette;
+
+#endif /*__G2D_BSP_DRV_H*/
+
+typedef enum
+{
+	G2D_CMD_BITBLT			=	0x50,
+	G2D_CMD_FILLRECT		=	0x51,
+	G2D_CMD_STRETCHBLT		=	0x52,
+	G2D_CMD_PALETTE_TBL		=	0x53,
+
+	G2D_CMD_MEM_REQUEST		=	0x59,
+	G2D_CMD_MEM_RELEASE		=	0x5A,
+	G2D_CMD_MEM_GETADR		=	0x5B,
+	G2D_CMD_MEM_SELIDX		=	0x5C,
+}g2d_cmd;
+
+#endif	/* __G2D_DRIVER_H */
+
diff --git a/include/linux/gpio_event.h b/include/linux/gpio_event.h
new file mode 100644
index 0000000..2613fc5
--- /dev/null
+++ b/include/linux/gpio_event.h
@@ -0,0 +1,170 @@
+/* include/linux/gpio_event.h
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_GPIO_EVENT_H
+#define _LINUX_GPIO_EVENT_H
+
+#include <linux/input.h>
+
+struct gpio_event_input_devs {
+	int count;
+	struct input_dev *dev[];
+};
+enum {
+	GPIO_EVENT_FUNC_UNINIT  = 0x0,
+	GPIO_EVENT_FUNC_INIT    = 0x1,
+	GPIO_EVENT_FUNC_SUSPEND = 0x2,
+	GPIO_EVENT_FUNC_RESUME  = 0x3,
+};
+struct gpio_event_info {
+	int (*func)(struct gpio_event_input_devs *input_devs,
+		    struct gpio_event_info *info,
+		    void **data, int func);
+	int (*event)(struct gpio_event_input_devs *input_devs,
+		     struct gpio_event_info *info,
+		     void **data, unsigned int dev, unsigned int type,
+		     unsigned int code, int value); /* out events */
+	bool no_suspend;
+};
+
+struct gpio_event_platform_data {
+	const char *name;
+	struct gpio_event_info **info;
+	size_t info_count;
+	int (*power)(const struct gpio_event_platform_data *pdata, bool on);
+	const char *names[]; /* If name is NULL, names contain a NULL */
+			     /* terminated list of input devices to create */
+};
+
+#define GPIO_EVENT_DEV_NAME "gpio-event"
+
+/* Key matrix */
+
+enum gpio_event_matrix_flags {
+	/* unset: drive active output low, set: drive active output high */
+	GPIOKPF_ACTIVE_HIGH              = 1U << 0,
+	GPIOKPF_DEBOUNCE                 = 1U << 1,
+	GPIOKPF_REMOVE_SOME_PHANTOM_KEYS = 1U << 2,
+	GPIOKPF_REMOVE_PHANTOM_KEYS      = GPIOKPF_REMOVE_SOME_PHANTOM_KEYS |
+					   GPIOKPF_DEBOUNCE,
+	GPIOKPF_DRIVE_INACTIVE           = 1U << 3,
+	GPIOKPF_LEVEL_TRIGGERED_IRQ      = 1U << 4,
+	GPIOKPF_PRINT_UNMAPPED_KEYS      = 1U << 16,
+	GPIOKPF_PRINT_MAPPED_KEYS        = 1U << 17,
+	GPIOKPF_PRINT_PHANTOM_KEYS       = 1U << 18,
+};
+
+#define MATRIX_CODE_BITS (10)
+#define MATRIX_KEY_MASK ((1U << MATRIX_CODE_BITS) - 1)
+#define MATRIX_KEY(dev, code) \
+	(((dev) << MATRIX_CODE_BITS) | (code & MATRIX_KEY_MASK))
+
+extern int gpio_event_matrix_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_matrix_info {
+	/* initialize to gpio_event_matrix_func */
+	struct gpio_event_info info;
+	/* size must be ninputs * noutputs */
+	const unsigned short *keymap;
+	unsigned int *input_gpios;
+	unsigned int *output_gpios;
+	unsigned int ninputs;
+	unsigned int noutputs;
+	/* time to wait before reading inputs after driving each output */
+	ktime_t settle_time;
+	/* time to wait before scanning the keypad a second time */
+	ktime_t debounce_delay;
+	ktime_t poll_time;
+	unsigned flags;
+};
+
+/* Directly connected inputs and outputs */
+
+enum gpio_event_direct_flags {
+	GPIOEDF_ACTIVE_HIGH         = 1U << 0,
+/*	GPIOEDF_USE_DOWN_IRQ        = 1U << 1, */
+/*	GPIOEDF_USE_IRQ             = (1U << 2) | GPIOIDF_USE_DOWN_IRQ, */
+	GPIOEDF_PRINT_KEYS          = 1U << 8,
+	GPIOEDF_PRINT_KEY_DEBOUNCE  = 1U << 9,
+	GPIOEDF_PRINT_KEY_UNSTABLE  = 1U << 10,
+};
+
+struct gpio_event_direct_entry {
+	uint32_t gpio:16;
+	uint32_t code:10;
+	uint32_t dev:6;
+};
+
+/* inputs */
+extern int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_input_info {
+	/* initialize to gpio_event_input_func */
+	struct gpio_event_info info;
+	ktime_t debounce_time;
+	ktime_t poll_time;
+	uint16_t flags;
+	uint16_t type;
+	const struct gpio_event_direct_entry *keymap;
+	size_t keymap_size;
+};
+
+/* outputs */
+extern int gpio_event_output_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+extern int gpio_event_output_event(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data,
+			unsigned int dev, unsigned int type,
+			unsigned int code, int value);
+struct gpio_event_output_info {
+	/* initialize to gpio_event_output_func and gpio_event_output_event */
+	struct gpio_event_info info;
+	uint16_t flags;
+	uint16_t type;
+	const struct gpio_event_direct_entry *keymap;
+	size_t keymap_size;
+};
+
+
+/* axes */
+
+enum gpio_event_axis_flags {
+	GPIOEAF_PRINT_UNKNOWN_DIRECTION  = 1U << 16,
+	GPIOEAF_PRINT_RAW                = 1U << 17,
+	GPIOEAF_PRINT_EVENT              = 1U << 18,
+};
+
+extern int gpio_event_axis_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func);
+struct gpio_event_axis_info {
+	/* initialize to gpio_event_axis_func */
+	struct gpio_event_info info;
+	uint8_t  count; /* number of gpios for this axis */
+	uint8_t  dev; /* device index when using multiple input devices */
+	uint8_t  type; /* EV_REL or EV_ABS */
+	uint16_t code;
+	uint16_t decoded_size;
+	uint16_t (*map)(struct gpio_event_axis_info *info, uint16_t in);
+	uint32_t *gpio;
+	uint32_t flags;
+};
+#define gpio_axis_2bit_gray_map gpio_axis_4bit_gray_map
+#define gpio_axis_3bit_gray_map gpio_axis_4bit_gray_map
+uint16_t gpio_axis_4bit_gray_map(
+			struct gpio_event_axis_info *info, uint16_t in);
+uint16_t gpio_axis_5bit_singletrack_map(
+			struct gpio_event_axis_info *info, uint16_t in);
+
+#endif
diff --git a/include/linux/hdmi-cec/dev.h b/include/linux/hdmi-cec/dev.h
new file mode 100644
index 0000000..a9c2a9a
--- /dev/null
+++ b/include/linux/hdmi-cec/dev.h
@@ -0,0 +1,30 @@
+#ifndef __HDMI_CEC_DEV_H
+#define __HDMI_CEC_DEV_H
+
+#include <linux/ioctl.h>
+#include <linux/hdmi-cec/hdmi-cec.h>
+
+#define CEC_IOCTL_BASE	'C'
+
+#define CEC_SET_LOGICAL_ADDRESS	_IOW(CEC_IOCTL_BASE, 0, int)
+#define CEC_SEND_MESSAGE	_IOW(CEC_IOCTL_BASE, 1, int)
+#define CEC_RECV_MESSAGE	_IOWR(CEC_IOCTL_BASE, 2, struct cec_msg)
+#define CEC_RESET_DEVICE	_IOW(CEC_IOCTL_BASE, 3, int)
+#define CEC_GET_COUNTERS	_IOR(CEC_IOCTL_BASE, 4, struct cec_counters)
+#define CEC_SET_RX_MODE		_IOW(CEC_IOCTL_BASE, 5, enum cec_rx_mode)
+
+#define CEC_MAX_DEVS	(10)
+
+#ifdef __KERNEL__
+
+struct cec_device;
+
+int __init cec_dev_init(void);
+void __exit cec_dev_exit(void);
+
+int cec_create_dev_node(struct cec_device *dev);
+void cec_remove_dev_node(struct cec_device *dev);
+
+#endif /* __KERNEL__ */
+
+#endif /* __HDMI_CEC_DEV_H */
diff --git a/include/linux/hdmi-cec/hdmi-cec.h b/include/linux/hdmi-cec/hdmi-cec.h
new file mode 100644
index 0000000..c198954
--- /dev/null
+++ b/include/linux/hdmi-cec/hdmi-cec.h
@@ -0,0 +1,255 @@
+/*
+ * Header for the HDMI CEC core infrastructure
+ */
+#ifndef __HDMI_CEC_H
+#define __HDMI_CEC_H
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+/* Common defines for HDMI CEC */
+#define CEC_BCAST_ADDR		(0x0f)
+#define CEC_ADDR_MAX		CEC_BCAST_ADDR
+
+#define CEC_MAX_MSG_LEN		(16)	/* 16 blocks */
+
+/**
+ * struct cec_msg - user-space exposed cec message cookie
+ * @data:	cec message payload
+ * @len:	cec message length
+ * @timeout:	signed 32-bits timeout value in seconds
+ * @flags:	optionnal flag field
+ */
+struct cec_msg {
+	__u8	data[CEC_MAX_MSG_LEN];
+	__u8	len;
+	__s32	timeout;
+	__u32	 flags;
+};
+
+#define CEC_MSG_NONBLOCK	(1 << 0)
+#define CEC_MSG_BLOCK		(1 << 1)
+
+/* Counters */
+
+/**
+ * struct cec_rx_counters - cec adpater RX counters
+ * @inv_start_bit:	number of invalid start bit detected
+ * @ack:		number of frames acknowledged
+ * @timeout:		number of timeouts
+ * @bytes:		number of bytes received
+ * @error:		number of general purpose errors
+ */
+struct cec_rx_counters {
+	__u32	inv_start_bit;
+	__u32	ack;
+	__u32	timeout;
+	__u32	bytes;
+	__u32	error;
+};
+
+/**
+ * struct cec_tx_counters - cec adapter TX counters
+ * @busy:	number of busy events while attempting transmission
+ * @bytes:	number of bytes transfered
+ * @error:	number of general purpose errors
+ * @retrans:	number of retransmissions
+ * @arb_loss:	number of arbitration losses
+ */
+struct cec_tx_counters {
+	__u32	busy;
+	__u32	bytes;
+	__u32	error;
+	__u32	retrans;
+	__u32	arb_loss;
+};
+
+/**
+ * struct cec_counters - tx and rx cec counters
+ * @rx:	struct cec_rx_counters
+ * @tx: struct cec_tx_counters
+ */
+struct cec_counters {
+	struct cec_rx_counters	rx;
+	struct cec_tx_counters	tx;
+};
+
+/**
+ * enum cec_rx_mode - cec adapter rx mode
+ * @CEC_RX_MODE_DEFAULT:	accept only unicast traffic
+ * @CEC_RX_MODE_ACCEPT_ALL:	accept all incoming RX traffic (sniffing mode)
+ * @CEC_RX_MODE_MAX:		sentinel
+ */
+enum cec_rx_mode {
+	CEC_RX_MODE_DEFAULT	= 0,
+	CEC_RX_MODE_ACCEPT_ALL,
+	CEC_RX_MODE_MAX
+};
+
+#ifdef __KERNEL__
+
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/completion.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+
+struct cec_driver;
+
+#define CEC_HW_HAS_COUNTERS	(1 << 0)	/* HW counts events */
+#define CEC_HW_HAS_RX_FILTER	(1 << 1)	/* HW has receive filter */
+
+/**
+ * struct cec_driver_ops - cec driver low-level operations
+ * @set_logical_address:	callback to set the logical address
+ * @send:	callback to send a cec payload
+ * @reset:	callback to reset the hardware
+ * @get_counters:	callback to get the counters (if supported by HW)
+ * @set_rx_mode:	callback to set the receive mode
+ * @attach:	callback to attach the host to the device
+ * @detach:	callbackt to detach the host from the device
+ */
+struct cec_driver_ops {
+	int	(*set_logical_address)(struct cec_driver *, const u8);
+	int	(*send)(struct cec_driver *, const u8 *, const u8);
+	int	(*reset)(struct cec_driver *);
+	int	(*get_counters)(struct cec_driver *d, struct cec_counters *);
+	int	(*set_rx_mode)(struct cec_driver *, enum cec_rx_mode);
+	int	(*attach)(struct cec_driver *);
+	int	(*detach)(struct cec_driver *);
+};
+
+/**
+ * struct cec_driver - cec driver structure
+ * @name:		driver name (should be unique)
+ * @module:		module pointer for refcounting
+ * @driver:		struct device_driver cookie for driver model
+ * @ops:		struct cec_driver_ops pointer
+ * @flags:		driver flags bitmask
+ * @lock:		driver all-purpose mutex for exclusive locking
+ * @attached:		driver attached to host or not
+ * @tx_work:		transmit work queue
+ * @tx_msg_list:	transmit message list head
+ * @tx_msg_list_lock:	transmit lessage list lock
+ * @rx_msg_list:	receive message list head
+ * @rx_msg_list_lock:	receive message list lock
+ * @rx_msg_len:		receive message queue len
+ * @rx_wait:		receive waitqueue (used for poll, read)
+ * @priv:		driver private pointer
+ */
+struct cec_driver {
+	const char		*name;
+	struct module		*module;
+	struct device_driver	driver;
+	struct cec_driver_ops	*ops;
+	unsigned int		flags;
+
+	/* private */
+	struct mutex		lock;
+	bool			attached;
+
+	/* transmit message list */
+	struct work_struct	tx_work;
+	struct list_head	tx_msg_list;
+	struct mutex		tx_msg_list_lock;
+
+	/* receive message list */
+	struct list_head	rx_msg_list;
+	struct mutex		rx_msg_list_lock;
+	unsigned int		rx_msg_len;
+	wait_queue_head_t	rx_wait;
+
+	/* driver private cookie */
+	void			*priv;
+};
+
+static inline struct cec_driver *to_cec_driver(struct device_driver *d)
+{
+	return container_of(d, struct cec_driver, driver);
+}
+
+static inline void *cec_driver_priv(struct cec_driver *d)
+{
+	return d->priv;
+}
+
+int register_cec_driver(struct cec_driver *);
+void unregister_cec_driver(struct cec_driver *);
+
+/**
+ * struct cec_device - CEC device main structure
+ * @name:	device name (used to create the character device)
+ * @list:	list node
+ * @major:	device major number
+ * @minor:	device minor number
+ * @cdev:	character device node
+ * @dev:	device structure for device/driver model interaction
+ * @class_dev:	class device pointer
+ */
+struct cec_device {
+	const char		*name;
+	struct list_head	list;
+	int			major;
+	int			minor;
+	struct cdev		cdev;
+	struct device		dev;
+	struct device		*class_dev;
+};
+
+static inline struct cec_device *to_cec_device(struct device *d)
+{
+	return container_of(d, struct cec_device, dev);
+}
+
+int register_cec_device(struct cec_device *);
+void unregister_cec_device(struct cec_device *);
+
+/*
+ * CEC messages
+ */
+enum {
+	CEC_MSG_QUEUED = 0,
+	CEC_MSG_SENT,
+	CEC_MSG_COMPLETED
+};
+
+enum {
+	CEC_MSG_NO_RESP = 0,
+	CEC_MSG_RESP,
+};
+
+/**
+ * struct cec_kmsg - kernel-side cec message cookie
+ * @status:	message status (QUEUED, SENT, COMPLETED)
+ * @ret:	message sending return code
+ * @next:	list pointer to next message
+ * @completion:	message completion cookie
+ * @msg:	user-side cec message cookie
+ */
+struct cec_kmsg {
+	int			status;
+	int			ret;
+	struct list_head	next;
+	struct completion	completion;
+	struct cec_msg		msg;
+};
+
+int cec_receive_message(struct cec_driver *drv, const u8 *data, const u8 len);
+int cec_dequeue_message(struct cec_driver *drv, struct cec_msg *msg);
+int cec_read_message(struct cec_driver *drv, struct cec_msg *msg);
+int cec_send_message(struct cec_driver *drv, struct cec_msg *msg);
+int cec_reset_device(struct cec_driver *drv);
+int cec_get_counters(struct cec_driver *drv, struct cec_counters *cnt);
+int cec_set_logical_address(struct cec_driver *drv, const u8 addr);
+int cec_set_rx_mode(struct cec_driver *drv, enum cec_rx_mode mode);
+void cec_flush_queues(struct cec_driver *drv);
+unsigned __cec_rx_queue_len(struct cec_driver *drv);
+int cec_attach_host(struct cec_driver *drv);
+int cec_detach_host(struct cec_driver *drv);
+
+#endif /* __KERNEL__ */
+
+#endif /* __HDMI_CEC_H */
diff --git a/include/linux/hid.h b/include/linux/hid.h
index 3a95da6..773b4ac 100644
--- a/include/linux/hid.h
+++ b/include/linux/hid.h
@@ -618,6 +618,8 @@ struct hid_usage_id {
  * @input_mapping: invoked on input registering before mapping an usage
  * @input_mapped: invoked on input registering after mapping an usage
  * @feature_mapping: invoked on feature registering
+ * @input_register: called just before input device is registered after reports
+ * 		    are parsed.
  * @suspend: invoked on suspend (NULL means nop)
  * @resume: invoked on resume if device was not reset (NULL means nop)
  * @reset_resume: invoked on resume if device was reset (NULL means nop)
@@ -664,6 +666,8 @@ struct hid_driver {
 	void (*feature_mapping)(struct hid_device *hdev,
 			struct hid_field *field,
 			struct hid_usage *usage);
+	int (*input_register)(struct hid_device *hdev, struct hid_input
+			*hidinput);
 #ifdef CONFIG_PM
 	int (*suspend)(struct hid_device *hdev, pm_message_t message);
 	int (*resume)(struct hid_device *hdev);
diff --git a/include/linux/if_pppolac.h b/include/linux/if_pppolac.h
new file mode 100644
index 0000000..c06bd6c
--- /dev/null
+++ b/include/linux/if_pppolac.h
@@ -0,0 +1,33 @@
+/* include/linux/if_pppolac.h
+ *
+ * Header for PPP on L2TP Access Concentrator / PPPoLAC Socket (RFC 2661)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Chia-chi Yeh <chiachi@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_IF_PPPOLAC_H
+#define __LINUX_IF_PPPOLAC_H
+
+#include <linux/socket.h>
+#include <linux/types.h>
+
+struct sockaddr_pppolac {
+	sa_family_t	sa_family;	/* AF_PPPOX */
+	unsigned int	sa_protocol;	/* PX_PROTO_OLAC */
+	int		udp_socket;
+	struct __attribute__((packed)) {
+		__u16	tunnel, session;
+	} local, remote;
+} __attribute__((packed));
+
+#endif /* __LINUX_IF_PPPOLAC_H */
diff --git a/include/linux/if_pppopns.h b/include/linux/if_pppopns.h
new file mode 100644
index 0000000..0cf34b4
--- /dev/null
+++ b/include/linux/if_pppopns.h
@@ -0,0 +1,32 @@
+/* include/linux/if_pppopns.h
+ *
+ * Header for PPP on PPTP Network Server / PPPoPNS Socket (RFC 2637)
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Author: Chia-chi Yeh <chiachi@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_IF_PPPOPNS_H
+#define __LINUX_IF_PPPOPNS_H
+
+#include <linux/socket.h>
+#include <linux/types.h>
+
+struct sockaddr_pppopns {
+	sa_family_t	sa_family;	/* AF_PPPOX */
+	unsigned int	sa_protocol;	/* PX_PROTO_OPNS */
+	int		tcp_socket;
+	__u16		local;
+	__u16		remote;
+} __attribute__((packed));
+
+#endif /* __LINUX_IF_PPPOPNS_H */
diff --git a/include/linux/if_pppox.h b/include/linux/if_pppox.h
index b5f927f..1597b8b 100644
--- a/include/linux/if_pppox.h
+++ b/include/linux/if_pppox.h
@@ -28,6 +28,8 @@
 #include <linux/ppp_channel.h>
 #endif /* __KERNEL__ */
 #include <linux/if_pppol2tp.h>
+#include <linux/if_pppolac.h>
+#include <linux/if_pppopns.h>
 
 /* For user-space programs to pick up these definitions
  * which they wouldn't get otherwise without defining __KERNEL__
@@ -61,7 +63,9 @@ struct pptp_addr {
 #define PX_PROTO_OE    0 /* Currently just PPPoE */
 #define PX_PROTO_OL2TP 1 /* Now L2TP also */
 #define PX_PROTO_PPTP  2
-#define PX_MAX_PROTO   3
+#define PX_PROTO_OLAC  3
+#define PX_PROTO_OPNS  4
+#define PX_MAX_PROTO   5
 
 struct sockaddr_pppox {
 	__kernel_sa_family_t sa_family;       /* address family, AF_PPPOX */
@@ -168,6 +172,25 @@ struct pptp_opt {
 	u32 seq_sent, seq_recv;
 	int ppp_flags;
 };
+
+struct pppolac_opt {
+	__u32		local;
+	__u32		remote;
+	__u32		recv_sequence;
+	__u32		xmit_sequence;
+	atomic_t	sequencing;
+	int		(*backlog_rcv)(struct sock *sk_udp, struct sk_buff *skb);
+};
+
+struct pppopns_opt {
+	__u16		local;
+	__u16		remote;
+	__u32		recv_sequence;
+	__u32		xmit_sequence;
+	void		(*data_ready)(struct sock *sk_raw, int length);
+	int		(*backlog_rcv)(struct sock *sk_raw, struct sk_buff *skb);
+};
+
 #include <net/sock.h>
 
 struct pppox_sock {
@@ -178,6 +201,8 @@ struct pppox_sock {
 	union {
 		struct pppoe_opt pppoe;
 		struct pptp_opt  pptp;
+		struct pppolac_opt lac;
+		struct pppopns_opt pns;
 	} proto;
 	__be16			num;
 };
diff --git a/include/linux/input.h b/include/linux/input.h
index a816714..49fb20e 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -154,6 +154,9 @@ struct input_keymap_entry {
 
 #define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
 
+#define EVIOCGSUSPENDBLOCK	_IOR('E', 0x91, int)			/* get suspend block enable */
+#define EVIOCSSUSPENDBLOCK	_IOW('E', 0x91, int)			/* set suspend block enable */
+
 #define EVIOCSCLOCKID		_IOW('E', 0xa0, int)			/* Set clockid to be used for timestamps */
 
 /*
diff --git a/include/linux/ion.h b/include/linux/ion.h
new file mode 100644
index 0000000..8414a6d
--- /dev/null
+++ b/include/linux/ion.h
@@ -0,0 +1,373 @@
+/*
+ * include/linux/ion.h
+ *
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ION_H
+#define _LINUX_ION_H
+
+#include <linux/types.h>
+
+struct ion_handle;
+/**
+ * enum ion_heap_types - list of all possible types of heaps
+ * @ION_HEAP_TYPE_SYSTEM:	 memory allocated via vmalloc
+ * @ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kmalloc
+ * @ION_HEAP_TYPE_CARVEOUT:	 memory allocated from a prereserved
+ * 				 carveout heap, allocations are physically
+ * 				 contiguous
+ * @ION_NUM_HEAPS:		 helper for iterating over heaps, a bit mask
+ * 				 is used to identify the heaps, so only 32
+ * 				 total heap types are supported
+ */
+enum ion_heap_type {
+	ION_HEAP_TYPE_SYSTEM,
+	ION_HEAP_TYPE_SYSTEM_CONTIG,
+	ION_HEAP_TYPE_CARVEOUT,
+	ION_HEAP_TYPE_CHUNK,
+	ION_HEAP_TYPE_CUSTOM, /* must be last so device specific heaps always
+				 are at the end of this enum */
+	ION_NUM_HEAPS = 16,
+};
+
+#define ION_HEAP_SYSTEM_MASK		(1 << ION_HEAP_TYPE_SYSTEM)
+#define ION_HEAP_SYSTEM_CONTIG_MASK	(1 << ION_HEAP_TYPE_SYSTEM_CONTIG)
+#define ION_HEAP_CARVEOUT_MASK		(1 << ION_HEAP_TYPE_CARVEOUT)
+
+#define ION_NUM_HEAP_IDS		sizeof(unsigned int) * 8
+
+/**
+ * allocation flags - the lower 16 bits are used by core ion, the upper 16
+ * bits are reserved for use by the heaps themselves.
+ */
+#define ION_FLAG_CACHED 1		/* mappings of this buffer should be
+					   cached, ion will do cache
+					   maintenance when the buffer is
+					   mapped for dma */
+#define ION_FLAG_CACHED_NEEDS_SYNC 2	/* mappings of this buffer will created
+					   at mmap time, if this is set
+					   caches must be managed manually */
+
+#ifdef __KERNEL__
+struct ion_device;
+struct ion_heap;
+struct ion_mapper;
+struct ion_client;
+struct ion_buffer;
+
+/* This should be removed some day when phys_addr_t's are fully
+   plumbed in the kernel, and all instances of ion_phys_addr_t should
+   be converted to phys_addr_t.  For the time being many kernel interfaces
+   do not accept phys_addr_t's that would have to */
+#define ion_phys_addr_t unsigned long
+
+/**
+ * struct ion_platform_heap - defines a heap in the given platform
+ * @type:	type of the heap from ion_heap_type enum
+ * @id:		unique identifier for heap.  When allocating higher numbers
+ * 		will be allocated from first.  At allocation these are passed
+ *		as a bit mask and therefore can not exceed ION_NUM_HEAP_IDS.
+ * @name:	used for debug purposes
+ * @base:	base address of heap in physical memory if applicable
+ * @size:	size of the heap in bytes if applicable
+ * @align:	required alignment in physical memory if applicable
+ * @priv:	private info passed from the board file
+ *
+ * Provided by the board file.
+ */
+struct ion_platform_heap {
+	enum ion_heap_type type;
+	unsigned int id;
+	const char *name;
+	ion_phys_addr_t base;
+	size_t size;
+	ion_phys_addr_t align;
+	void *priv;
+};
+
+/**
+ * struct ion_platform_data - array of platform heaps passed from board file
+ * @nr:		number of structures in the array
+ * @heaps:	array of platform_heap structions
+ *
+ * Provided by the board file in the form of platform data to a platform device.
+ */
+struct ion_platform_data {
+	int nr;
+	struct ion_platform_heap heaps[];
+};
+
+/**
+ * ion_reserve() - reserve memory for ion heaps if applicable
+ * @data:	platform data specifying starting physical address and
+ *		size
+ *
+ * Calls memblock reserve to set aside memory for heaps that are
+ * located at specific memory addresses or of specfic sizes not
+ * managed by the kernel
+ */
+void ion_reserve(struct ion_platform_data *data);
+
+/**
+ * ion_client_create() -  allocate a client and returns it
+ * @dev:		the global ion device
+ * @heap_type_mask:	mask of heaps this client can allocate from
+ * @name:		used for debugging
+ */
+struct ion_client *ion_client_create(struct ion_device *dev,
+				     const char *name);
+
+/**
+ * ion_client_destroy() -  free's a client and all it's handles
+ * @client:	the client
+ *
+ * Free the provided client and all it's resources including
+ * any handles it is holding.
+ */
+void ion_client_destroy(struct ion_client *client);
+
+/**
+ * ion_alloc - allocate ion memory
+ * @client:		the client
+ * @len:		size of the allocation
+ * @align:		requested allocation alignment, lots of hardware blocks
+ *			have alignment requirements of some kind
+ * @heap_id_mask:	mask of heaps to allocate from, if multiple bits are set
+ *			heaps will be tried in order from highest to lowest
+ *			id
+ * @flags:		heap flags, the low 16 bits are consumed by ion, the
+ *			high 16 bits are passed on to the respective heap and
+ *			can be heap custom
+ *
+ * Allocate memory in one of the heaps provided in heap mask and return
+ * an opaque handle to it.
+ */
+struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
+			     size_t align, unsigned int heap_id_mask,
+			     unsigned int flags);
+
+/**
+ * ion_free - free a handle
+ * @client:	the client
+ * @handle:	the handle to free
+ *
+ * Free the provided handle.
+ */
+void ion_free(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_phys - returns the physical address and len of a handle
+ * @client:	the client
+ * @handle:	the handle
+ * @addr:	a pointer to put the address in
+ * @len:	a pointer to put the length in
+ *
+ * This function queries the heap for a particular handle to get the
+ * handle's physical address.  It't output is only correct if
+ * a heap returns physically contiguous memory -- in other cases
+ * this api should not be implemented -- ion_sg_table should be used
+ * instead.  Returns -EINVAL if the handle is invalid.  This has
+ * no implications on the reference counting of the handle --
+ * the returned value may not be valid if the caller is not
+ * holding a reference.
+ */
+int ion_phys(struct ion_client *client, struct ion_handle *handle,
+	     ion_phys_addr_t *addr, size_t *len);
+
+/**
+ * ion_map_dma - return an sg_table describing a handle
+ * @client:	the client
+ * @handle:	the handle
+ *
+ * This function returns the sg_table describing
+ * a particular ion handle.
+ */
+struct sg_table *ion_sg_table(struct ion_client *client,
+			      struct ion_handle *handle);
+
+/**
+ * ion_map_kernel - create mapping for the given handle
+ * @client:	the client
+ * @handle:	handle to map
+ *
+ * Map the given handle into the kernel and return a kernel address that
+ * can be used to access this address.
+ */
+void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_unmap_kernel() - destroy a kernel mapping for a handle
+ * @client:	the client
+ * @handle:	handle to unmap
+ */
+void ion_unmap_kernel(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_share_dma_buf() - share buffer as dma-buf
+ * @client:	the client
+ * @handle:	the handle
+ */
+struct dma_buf *ion_share_dma_buf(struct ion_client *client,
+						struct ion_handle *handle);
+
+/**
+ * ion_share_dma_buf_fd() - given an ion client, create a dma-buf fd
+ * @client:	the client
+ * @handle:	the handle
+ */
+int ion_share_dma_buf_fd(struct ion_client *client, struct ion_handle *handle);
+
+/**
+ * ion_import_dma_buf() - given an dma-buf fd from the ion exporter get handle
+ * @client:	the client
+ * @fd:		the dma-buf fd
+ *
+ * Given an dma-buf fd that was allocated through ion via ion_share_dma_buf,
+ * import that fd and return a handle representing it.  If a dma-buf from
+ * another exporter is passed in this function will return ERR_PTR(-EINVAL)
+ */
+struct ion_handle *ion_import_dma_buf(struct ion_client *client, int fd);
+
+#endif /* __KERNEL__ */
+
+/**
+ * DOC: Ion Userspace API
+ *
+ * create a client by opening /dev/ion
+ * most operations handled via following ioctls
+ *
+ */
+
+/**
+ * struct ion_allocation_data - metadata passed from userspace for allocations
+ * @len:		size of the allocation
+ * @align:		required alignment of the allocation
+ * @heap_id_mask:	mask of heap ids to allocate from
+ * @flags:		flags passed to heap
+ * @handle:		pointer that will be populated with a cookie to use to 
+ *			refer to this allocation
+ *
+ * Provided by userspace as an argument to the ioctl
+ */
+struct ion_allocation_data {
+	size_t len;
+	size_t align;
+	unsigned int heap_id_mask;
+	unsigned int flags;
+	struct ion_handle *handle;
+};
+
+/**
+ * struct ion_fd_data - metadata passed to/from userspace for a handle/fd pair
+ * @handle:	a handle
+ * @fd:		a file descriptor representing that handle
+ *
+ * For ION_IOC_SHARE or ION_IOC_MAP userspace populates the handle field with
+ * the handle returned from ion alloc, and the kernel returns the file
+ * descriptor to share or map in the fd field.  For ION_IOC_IMPORT, userspace
+ * provides the file descriptor and the kernel returns the handle.
+ */
+struct ion_fd_data {
+	struct ion_handle *handle;
+	int fd;
+};
+
+/**
+ * struct ion_handle_data - a handle passed to/from the kernel
+ * @handle:	a handle
+ */
+struct ion_handle_data {
+	struct ion_handle *handle;
+};
+
+/**
+ * struct ion_custom_data - metadata passed to/from userspace for a custom ioctl
+ * @cmd:	the custom ioctl function to call
+ * @arg:	additional data to pass to the custom ioctl, typically a user
+ *		pointer to a predefined structure
+ *
+ * This works just like the regular cmd and arg fields of an ioctl.
+ */
+struct ion_custom_data {
+	unsigned int cmd;
+	unsigned long arg;
+};
+
+#define ION_IOC_MAGIC		'I'
+
+/**
+ * DOC: ION_IOC_ALLOC - allocate memory
+ *
+ * Takes an ion_allocation_data struct and returns it with the handle field
+ * populated with the opaque handle for the allocation.
+ */
+#define ION_IOC_ALLOC		_IOWR(ION_IOC_MAGIC, 0, \
+				      struct ion_allocation_data)
+
+/**
+ * DOC: ION_IOC_FREE - free memory
+ *
+ * Takes an ion_handle_data struct and frees the handle.
+ */
+#define ION_IOC_FREE		_IOWR(ION_IOC_MAGIC, 1, struct ion_handle_data)
+
+/**
+ * DOC: ION_IOC_MAP - get a file descriptor to mmap
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be used as an argument to mmap.
+ */
+#define ION_IOC_MAP		_IOWR(ION_IOC_MAGIC, 2, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_SHARE - creates a file descriptor to use to share an allocation
+ *
+ * Takes an ion_fd_data struct with the handle field populated with a valid
+ * opaque handle.  Returns the struct with the fd field set to a file
+ * descriptor open in the current address space.  This file descriptor
+ * can then be passed to another process.  The corresponding opaque handle can
+ * be retrieved via ION_IOC_IMPORT.
+ */
+#define ION_IOC_SHARE		_IOWR(ION_IOC_MAGIC, 4, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_IMPORT - imports a shared file descriptor
+ *
+ * Takes an ion_fd_data struct with the fd field populated with a valid file
+ * descriptor obtained from ION_IOC_SHARE and returns the struct with the handle
+ * filed set to the corresponding opaque handle.
+ */
+#define ION_IOC_IMPORT		_IOWR(ION_IOC_MAGIC, 5, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_SYNC - syncs a shared file descriptors to memory
+ *
+ * Deprecated in favor of using the dma_buf api's correctly (syncing
+ * will happend automatically when the buffer is mapped to a device).
+ * If necessary should be used after touching a cached buffer from the cpu,
+ * this will make the buffer in memory coherent.
+ */
+#define ION_IOC_SYNC		_IOWR(ION_IOC_MAGIC, 7, struct ion_fd_data)
+
+/**
+ * DOC: ION_IOC_CUSTOM - call architecture specific ion ioctl
+ *
+ * Takes the argument of the architecture specific ioctl to call and
+ * passes appropriate userdata for that ioctl
+ */
+#define ION_IOC_CUSTOM		_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
+
+#endif /* _LINUX_ION_H */
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 645231c..747404a 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -705,6 +705,9 @@ static inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }
 
 extern int do_sysinfo(struct sysinfo *info);
 
+/* To identify board information in panic logs, set this */
+extern char *mach_panic_string;
+
 #endif /* __KERNEL__ */
 
 #endif
diff --git a/include/linux/keychord.h b/include/linux/keychord.h
new file mode 100644
index 0000000..856a585
--- /dev/null
+++ b/include/linux/keychord.h
@@ -0,0 +1,52 @@
+/*
+ *  Key chord input driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef __LINUX_KEYCHORD_H_
+#define __LINUX_KEYCHORD_H_
+
+#include <linux/input.h>
+
+#define KEYCHORD_VERSION		1
+
+/*
+ * One or more input_keychord structs are written to /dev/keychord
+ * at once to specify the list of keychords to monitor.
+ * Reading /dev/keychord returns the id of a keychord when the
+ * keychord combination is pressed.  A keychord is signalled when
+ * all of the keys in the keycode list are in the pressed state.
+ * The order in which the keys are pressed does not matter.
+ * The keychord will not be signalled if keys not in the keycode
+ * list are pressed.
+ * Keychords will not be signalled on key release events.
+ */
+struct input_keychord {
+	/* should be KEYCHORD_VERSION */
+	__u16 version;
+	/*
+	 * client specified ID, returned from read()
+	 * when this keychord is pressed.
+	 */
+	__u16 id;
+
+	/* number of keycodes in this keychord */
+	__u16 count;
+
+	/* variable length array of keycodes */
+	__u16 keycodes[];
+};
+
+#endif	/* __LINUX_KEYCHORD_H_ */
diff --git a/include/linux/keyreset.h b/include/linux/keyreset.h
new file mode 100644
index 0000000..a2ac49e
--- /dev/null
+++ b/include/linux/keyreset.h
@@ -0,0 +1,28 @@
+/*
+ * include/linux/keyreset.h - platform data structure for resetkeys driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_KEYRESET_H
+#define _LINUX_KEYRESET_H
+
+#define KEYRESET_NAME "keyreset"
+
+struct keyreset_platform_data {
+	int (*reset_fn)(void);
+	int *keys_up;
+	int keys_down[]; /* 0 terminated */
+};
+
+#endif /* _LINUX_KEYRESET_H */
diff --git a/include/linux/leds.h b/include/linux/leds.h
index 5884def..23f20fd 100644
--- a/include/linux/leds.h
+++ b/include/linux/leds.h
@@ -210,4 +210,20 @@ struct gpio_led_platform_data {
 struct platform_device *gpio_led_register_device(
 		int id, const struct gpio_led_platform_data *pdata);
 
+enum cpu_led_event {
+	CPU_LED_IDLE_START,	/* CPU enters idle */
+	CPU_LED_IDLE_END,	/* CPU idle ends */
+	CPU_LED_START,		/* Machine starts, especially resume */
+	CPU_LED_STOP,		/* Machine stops, especially suspend */
+	CPU_LED_HALTED,		/* Machine shutdown */
+};
+#ifdef CONFIG_LEDS_TRIGGER_CPU
+extern void ledtrig_cpu(enum cpu_led_event evt);
+#else
+static inline void ledtrig_cpu(enum cpu_led_event evt)
+{
+	return;
+}
+#endif
+
 #endif		/* __LINUX_LEDS_H_INCLUDED */
diff --git a/include/linux/major.h b/include/linux/major.h
index 6a8ca98..a06e813 100644
--- a/include/linux/major.h
+++ b/include/linux/major.h
@@ -1,3 +1,23 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
 #ifndef _LINUX_MAJOR_H
 #define _LINUX_MAJOR_H
 
@@ -169,6 +189,10 @@
 #define IBM_TTY3270_MAJOR	227
 #define IBM_FS3270_MAJOR	228
 
+#define UMP_MAJOR		229
+#define VIOTAPE_MAJOR		230
+#define MALI_MAJOR		230
+
 #define VIOTAPE_MAJOR		230
 
 #define BLOCK_EXT_MAJOR		259
diff --git a/include/linux/mfd/axp-mfd.h b/include/linux/mfd/axp-mfd.h
new file mode 100644
index 0000000..2511473
--- /dev/null
+++ b/include/linux/mfd/axp-mfd.h
@@ -0,0 +1,532 @@
+/*
+ * include/linux/mfd/axp-mfd.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LINUX_AXP_MFD_H_
+#define __LINUX_AXP_MFD_H_
+
+/* Unified sub device IDs for AXP */
+enum {
+	AXP18_ID_LDO1,
+	AXP18_ID_LDO2,
+	AXP18_ID_LDO3,
+	AXP18_ID_LDO4,
+	AXP18_ID_LDO5,
+	AXP18_ID_BUCK1,
+	AXP18_ID_BUCK2,
+	AXP18_ID_BUCK3,
+	AXP18_ID_SW1,
+	AXP18_ID_SW2,
+
+	AXP18_ID_SUPPLY,
+
+	AXP19_ID_LDO1,
+	AXP19_ID_LDO2,
+	AXP19_ID_LDO3,
+	AXP19_ID_LDO4,
+
+	AXP19_ID_BUCK1,
+	AXP19_ID_BUCK2,
+	AXP19_ID_BUCK3,
+
+	AXP19_ID_LDOIO0,
+
+	AXP19_ID_SUPPLY,
+
+	AXP19_ID_GPIO,
+
+	AXP20_ID_LDO1,
+	AXP20_ID_LDO2,
+	AXP20_ID_LDO3,
+	AXP20_ID_LDO4,
+
+	AXP20_ID_BUCK2,
+	AXP20_ID_BUCK3,
+
+	AXP20_ID_LDOIO0,
+
+	AXP20_ID_SUPPLY,
+
+	AXP20_ID_GPIO,
+
+};
+
+#define AXP_MFD_ATTR(_name)					\
+{									\
+	.attr = { .name = #_name,.mode = 0644 },					\
+	.show =  _name##_show,				\
+	.store = _name##_store, \
+}
+
+/* AXP battery charger data */
+struct power_supply_info;
+
+struct axp_supply_init_data {
+	/* battery parameters */
+	struct power_supply_info *battery_info;
+
+	/* current and voltage to use for battery charging */
+	unsigned int chgcur;
+	unsigned int chgvol;
+	unsigned int chgend;
+	/*charger control*/
+	bool chgen;
+	bool limit_on;
+	/*charger time */
+	int chgpretime;
+	int chgcsttime;
+
+	/*adc sample time */
+	unsigned int sample_time;
+
+	/* platform callbacks for battery low and critical IRQs */
+	void (*battery_low)(void);
+	void (*battery_critical)(void);
+};
+
+struct axp_funcdev_info {
+	int		id;
+	const char	*name;
+	void	*platform_data;
+};
+
+struct axp_platform_data {
+	int num_regl_devs;
+	int num_sply_devs;
+	int num_gpio_devs;
+	int gpio_base;
+	struct axp_funcdev_info *regl_devs;
+	struct axp_funcdev_info *sply_devs;
+	struct axp_funcdev_info *gpio_devs;
+
+};
+
+struct axp_mfd_chip {
+	struct i2c_client	*client;
+	struct device		*dev;
+	struct axp_mfd_chip_ops	*ops;
+
+	int			type;
+	uint64_t		irqs_enabled;
+
+	struct mutex		lock;
+	struct work_struct	irq_work;
+
+	struct blocking_notifier_head notifier_list;
+};
+
+struct axp_mfd_chip_ops {
+	int	(*init_chip)(struct axp_mfd_chip *);
+	int	(*enable_irqs)(struct axp_mfd_chip *, uint64_t irqs);
+	int	(*disable_irqs)(struct axp_mfd_chip *, uint64_t irqs);
+	int	(*read_irqs)(struct axp_mfd_chip *, uint64_t *irqs);
+};
+
+#define AXP18                      	18
+#define POWER18_STATUS            	(0x00)
+#define POWER18_IPS_SET             (0x01)
+#define POWER18_ONOFF               (0x02)
+#define POWER18_CHARGE1             (0x03)
+#define POWER18_CHARGE2             (0x04)
+#define POWER18_PEK                 (0x05)
+#define POWER18_INTEN1              (0x06)
+#define POWER18_INTEN2              (0x07)
+#define POWER18_INTEN3              (0x08)
+#define POWER18_INTSTS1             (0x09)
+#define POWER18_INTSTS2             (0x0A)
+#define POWER18_INTSTS3             (0x0B)
+#define POWER18_VENDER_USED1        (0x0C)
+#define POWER18_DCDCCTL             (0x0D)
+#define POWER18_DC12OUT_VOL         (0x0E)
+#define POWER18_LDOOUT_VOL          (0x0F)
+#define POWER18_SW_CTL              (0x10)
+#define POWER18_BATTERY_VOL         (0x11)
+#define POWER18_BATTERY_CURRENT     (0x12)
+#define POWER18_DCIN_VOL            (0x13)
+#define POWER18_DCIN_CURRENT        (0x14)
+#define POWER18_ADCSW_CTL           (0x15)
+#define POWER18_VENDER_USED2        (0x16)
+#define POWER18_EPT_SW              (0x17)
+#define POWER18_DATA_BUFFER1        (0x18)
+#define POWER18_DATA_BUFFER2        (0x19)
+#define POWER18_VENDER_USED3        (0x1A)
+
+
+#define AXP19                       19
+#define POWER19_STATUS              (0x00)
+#define POWER19_MODE_CHGSTATUS      (0x01)
+#define POWER19_OTG_STATUS          (0x02)
+#define POWER19_IC_TYPE             (0x03)
+#define POWER19_DATA_BUFFER1        (0x06)
+#define POWER19_DATA_BUFFER2        (0x07)
+#define POWER19_DATA_BUFFER3        (0x08)
+#define POWER19_DATA_BUFFER4        (0x09)
+#define POWER19_VERSION             (0x0C)
+#define POWER19_LDO3_DC2_CTL        (0x10)
+#define POWER19_LDO24_DC13_CTL      (0x12)
+#define POWER19_DC2OUT_VOL          (0x23)
+#define POWER19_LDO3_DC2_DVM        (0x25)
+#define POWER19_DC1OUT_VOL          (0x26)
+#define POWER19_DC3OUT_VOL          (0x27)
+#define POWER19_LDO24OUT_VOL        (0x28)
+#define POWER19_LDO3OUT_VOL         (0x29)
+#define POWER19_IPS_SET             (0x30)
+#define POWER19_VOFF_SET            (0x31)
+#define POWER19_OFF_CTL             (0x32)
+#define POWER19_CHARGE1             (0x33)
+#define POWER19_CHARGE2             (0x34)
+#define POWER19_BACKUP_CHG          (0x35)
+#define POWER19_POK_SET             (0x36)
+#define POWER19_DCDC_FREQSET        (0x37)
+#define POWER19_VLTF_CHGSET         (0x38)
+#define POWER19_VHTF_CHGSET         (0x39)
+#define POWER19_APS_WARNING1        (0x3A)
+#define POWER19_APS_WARNING2        (0x3B)
+#define POWER19_VLTF_DISCHGSET      (0x3C)
+#define POWER19_VHTF_DISCHGSET      (0x3D)
+#define POWER19_DCDC_MODESET        (0x80)
+#define POWER19_VOUT_MONITOR        (0x81)
+#define POWER19_ADC_EN1             (0x82)
+#define POWER19_ADC_EN2             (0x83)
+#define POWER19_ADC_SPEED           (0x84)
+#define POWER19_ADC_INPUTRANGE      (0x85)
+#define POWER19_TIMER_CTL           (0x8A)
+#define POWER19_VBUS_DET_SRP        (0x8B)
+#define POWER19_HOTOVER_CTL         (0x8F)
+#define POWER19_GPIO0_CTL           (0x90)
+#define POWER19_GPIO0_VOL           (0x91)
+#define POWER19_GPIO1_CTL           (0x92)
+#define POWER19_GPIO2_CTL           (0x93)
+#define POWER19_GPIO012_SIGNAL      (0x94)
+#define POWER19_SENSE_CTL           (0x95)
+#define POWER19_SENSE_SIGNAL        (0x96)
+#define POWER19_GPIO20_PDCTL        (0x97)
+#define POWER19_PWM1_FREQ           (0x98)
+#define POWER19_PWM1_DUTYDE         (0x99)
+#define POWER19_PWM1_DUTY           (0x9A)
+#define POWER19_PWM2_FREQ           (0x9B)
+#define POWER19_PWM2_DUTYDE         (0x9C)
+#define POWER19_PWM2_DUTY           (0x9D)
+#define POWER19_RSTO_CTL            (0x9E)
+#define POWER19_GPIO67_CTL          (0x9F)
+#define POWER19_INTEN1              (0x40)
+#define POWER19_INTEN2              (0x41)
+#define POWER19_INTEN3              (0x42)
+#define POWER19_INTEN4              (0x43)
+#define POWER19_INTSTS1             (0x44)
+#define POWER19_INTSTS2             (0x45)
+#define POWER19_INTSTS3             (0x46)
+#define POWER19_INTSTS4             (0x47)
+#define POWER19_GPIO67_CFG          (0xE0)
+
+//axp 19 adc data register
+#define POWER19_BAT_AVERVOL_H8          (0x78)
+#define POWER19_BAT_AVERVOL_L4          (0x79)
+#define POWER19_BAT_AVERCHGCUR_H8       (0x7A)
+#define POWER19_BAT_AVERCHGCUR_L5       (0x7B)
+#define POWER19_ACIN_VOL_H8             (0x56)
+#define POWER19_ACIN_VOL_L4             (0x57)
+#define POWER19_ACIN_CUR_H8             (0x58)
+#define POWER19_ACIN_CUR_L4             (0x59)
+#define POWER19_VBUS_VOL_H8             (0x5A)
+#define POWER19_VBUS_VOL_L4             (0x5B)
+#define POWER19_VBUS_CUR_H8             (0x5C)
+#define POWER19_VBUS_CUR_L4             (0x5D)
+#define POWER19_BAT_AVERDISCHGCUR_H8    (0x7C)
+#define POWER19_BAT_AVERDISCHGCUR_L5    (0x7D)
+#define POWER19_APS_AVERVOL_H8          (0x7E)
+#define POWER19_APS_AVERVOL_L4          (0x7F)
+#define POWER19_BAT_CHGCOULOMB3         (0xB0)
+#define POWER19_BAT_CHGCOULOMB2         (0xB1)
+#define POWER19_BAT_CHGCOULOMB1         (0xB2)
+#define POWER19_BAT_CHGCOULOMB0         (0xB3)
+#define POWER19_BAT_DISCHGCOULOMB3      (0xB4)
+#define POWER19_BAT_DISCHGCOULOMB2      (0xB5)
+#define POWER19_BAT_DISCHGCOULOMB1      (0xB6)
+#define POWER19_BAT_DISCHGCOULOMB0      (0xB7)
+#define POWER19_COULOMB_CTL             (0xB8)
+#define POWER19_BAT_POWERH8             (0x70)
+#define POWER19_BAT_POWERM8             (0x71)
+#define POWER19_BAT_POWERL8             (0x72)
+
+#define AXP20                       20
+#define POWER20_STATUS              (0x00)
+#define POWER20_MODE_CHGSTATUS      (0x01)
+#define POWER20_OTG_STATUS          (0x02)
+#define POWER20_IC_TYPE             (0x03)
+#define POWER20_DATA_BUFFER1        (0x04)
+#define POWER20_DATA_BUFFER2        (0x05)
+#define POWER20_DATA_BUFFER3        (0x06)
+#define POWER20_DATA_BUFFER4        (0x07)
+#define POWER20_DATA_BUFFER5        (0x08)
+#define POWER20_DATA_BUFFER6        (0x09)
+#define POWER20_DATA_BUFFER7        (0x0A)
+#define POWER20_DATA_BUFFER8        (0x0B)
+#define POWER20_DATA_BUFFER9        (0x0C)
+#define POWER20_DATA_BUFFERA        (0x0D)
+#define POWER20_DATA_BUFFERB        (0x0E)
+#define POWER20_DATA_BUFFERC        (0x0F)
+#define POWER20_LDO234_DC23_CTL     (0x12)
+#define POWER20_DC2OUT_VOL          (0x23)
+#define POWER20_LDO3_DC2_DVM        (0x25)
+#define POWER20_DC3OUT_VOL          (0x27)
+#define POWER20_LDO24OUT_VOL        (0x28)
+#define POWER20_LDO3OUT_VOL         (0x29)
+#define POWER20_IPS_SET             (0x30)
+#define POWER20_VOFF_SET            (0x31)
+#define POWER20_OFF_CTL             (0x32)
+#define POWER20_CHARGE1             (0x33)
+#define POWER20_CHARGE2             (0x34)
+#define POWER20_BACKUP_CHG          (0x35)
+#define POWER20_PEK_SET             (0x36)
+#define POWER20_DCDC_FREQSET        (0x37)
+#define POWER20_VLTF_CHGSET         (0x38)
+#define POWER20_VHTF_CHGSET         (0x39)
+#define POWER20_APS_WARNING1        (0x3A)
+#define POWER20_APS_WARNING2        (0x3B)
+#define POWER20_TLTF_DISCHGSET      (0x3C)
+#define POWER20_THTF_DISCHGSET      (0x3D)
+#define POWER20_DCDC_MODESET        (0x80)
+#define POWER20_ADC_EN1             (0x82)
+#define POWER20_ADC_EN2             (0x83)
+#define POWER20_ADC_SPEED           (0x84)
+#define POWER20_ADC_INPUTRANGE      (0x85)
+#define POWER20_ADC_IRQ_RETFSET     (0x86)
+#define POWER20_ADC_IRQ_FETFSET     (0x87)
+#define POWER20_TIMER_CTL           (0x8A)
+#define POWER20_VBUS_DET_SRP        (0x8B)
+#define POWER20_HOTOVER_CTL         (0x8F)
+#define POWER20_GPIO0_CTL           (0x90)
+#define POWER20_GPIO0_VOL           (0x91)
+#define POWER20_GPIO1_CTL           (0x92)
+#define POWER20_GPIO2_CTL           (0x93)
+#define POWER20_GPIO012_SIGNAL      (0x94)
+#define POWER20_GPIO3_CTL           (0x95)
+#define POWER20_INTEN1              (0x40)
+#define POWER20_INTEN2              (0x41)
+#define POWER20_INTEN3              (0x42)
+#define POWER20_INTEN4              (0x43)
+#define POWER20_INTEN5              (0x44)
+#define POWER20_INTSTS1             (0x48)
+#define POWER20_INTSTS2             (0x49)
+#define POWER20_INTSTS3             (0x4A)
+#define POWER20_INTSTS4             (0x4B)
+#define POWER20_INTSTS5             (0x4C)
+
+//axp 20 adc data register
+#define POWER20_BAT_AVERVOL_H8          (0x78)
+#define POWER20_BAT_AVERVOL_L4          (0x79)
+#define POWER20_BAT_AVERCHGCUR_H8       (0x7A)
+#define POWER20_BAT_AVERCHGCUR_L5       (0x7B)
+#define POWER20_ACIN_VOL_H8             (0x56)
+#define POWER20_ACIN_VOL_L4             (0x57)
+#define POWER20_ACIN_CUR_H8             (0x58)
+#define POWER20_ACIN_CUR_L4             (0x59)
+#define POWER20_VBUS_VOL_H8             (0x5A)
+#define POWER20_VBUS_VOL_L4             (0x5B)
+#define POWER20_VBUS_CUR_H8             (0x5C)
+#define POWER20_VBUS_CUR_L4             (0x5D)
+
+#define POWER20_BAT_AVERDISCHGCUR_H8    (0x7C)
+#define POWER20_BAT_AVERDISCHGCUR_L5    (0x7D)
+#define POWER20_APS_AVERVOL_H8          (0x7E)
+#define POWER20_APS_AVERVOL_L4          (0x7F)
+#define POWER20_BAT_CHGCOULOMB3         (0xB0)
+#define POWER20_BAT_CHGCOULOMB2         (0xB1)
+#define POWER20_BAT_CHGCOULOMB1         (0xB2)
+#define POWER20_BAT_CHGCOULOMB0         (0xB3)
+#define POWER20_BAT_DISCHGCOULOMB3      (0xB4)
+#define POWER20_BAT_DISCHGCOULOMB2      (0xB5)
+#define POWER20_BAT_DISCHGCOULOMB1      (0xB6)
+#define POWER20_BAT_DISCHGCOULOMB0      (0xB7)
+#define POWER20_COULOMB_CTL             (0xB8)
+#define POWER20_BAT_POWERH8             (0x70)
+#define POWER20_BAT_POWERM8             (0x71)
+#define POWER20_BAT_POWERL8             (0x72)
+
+
+/* bit definitions for AXP events ,irq event */
+
+/*  AXP18  */
+#define	AXP18_IRQ_TEMLO								( 1<< 1)
+#define	AXP18_IRQ_TEMOV								( 1<< 2)
+
+#define	AXP18_IRQ_EXTLO								( 1<< 4)
+#define	AXP18_IRQ_EXTRE								( 1<< 5)
+#define	AXP18_IRQ_EXTIN								( 1<< 6)
+#define	AXP18_IRQ_EXTOV      ( 1 <<  7)
+
+#define	AXP18_IRQ_PEKLO		( 1 << 10)
+#define	AXP18_IRQ_PEKSH	    ( 1 << 11)
+
+
+
+
+
+#define	AXP18_IRQ_BATLO 	    ( 1 << 17)
+#define	AXP18_IRQ_CHAOV		( 1 << 18)
+#define	AXP18_IRQ_CHAST		( 1 << 19)
+#define	AXP18_IRQ_BATATIN    ( 1 << 20)
+#define	AXP18_IRQ_BATATOU  	( 1 << 21)
+#define AXP18_IRQ_BATRE		( 1 << 22)
+#define AXP18_IRQ_BATIN		( 1 << 23)
+
+/*  AXP19  */
+#define	AXP19_IRQ_USBLO		( 1 <<  1)
+#define	AXP19_IRQ_USBRE		( 1 <<  2)
+#define	AXP19_IRQ_USBIN		( 1 <<  3)
+#define	AXP19_IRQ_USBOV     ( 1 <<  4)
+#define	AXP19_IRQ_ACRE     ( 1 <<  5)
+#define	AXP19_IRQ_ACIN     ( 1 <<  6)
+#define	AXP19_IRQ_ACOV     ( 1 <<  7)
+#define	AXP19_IRQ_TEMLO      ( 1 <<  8)
+#define	AXP19_IRQ_TEMOV      ( 1 <<  9)
+#define	AXP19_IRQ_CHAOV		( 1 << 10)
+#define	AXP19_IRQ_CHAST 	    ( 1 << 11)
+#define	AXP19_IRQ_BATATOU    ( 1 << 12)
+#define	AXP19_IRQ_BATATIN  	( 1 << 13)
+#define AXP19_IRQ_BATRE		( 1 << 14)
+#define AXP19_IRQ_BATIN		( 1 << 15)
+#define	AXP19_IRQ_PEKLO		( 1 << 16)
+#define	AXP19_IRQ_PEKSH	    ( 1 << 17)
+#define AXP19_IRQ_LDO3LO     ( 1 << 18)
+#define AXP19_IRQ_DCDC3LO    ( 1 << 19)
+#define AXP19_IRQ_DCDC2LO    ( 1 << 20)
+#define AXP19_IRQ_DCDC1LO    ( 1 << 21)
+#define AXP19_IRQ_CHACURLO   ( 1 << 22)
+#define AXP19_IRQ_ICTEMOV    ( 1 << 23)
+
+#define AXP19_IRQ_EXTLOWARN  ( 1 << 25)
+#define AXP19_IRQ_USBSESUN  ( 1 << 26)
+#define AXP19_IRQ_USBSESVA  ( 1 << 27)
+#define AXP19_IRQ_USBUN     ( 1 << 28)
+#define AXP19_IRQ_USBVA     ( 1 << 29)
+#define AXP19_IRQ_NOECLO     ( 1 << 30)
+#define AXP19_IRQ_NOEOPE     ( 1 << 31)
+
+/*  AXP20  */
+#define	AXP20_IRQ_USBLO		( 1 <<  1)
+#define	AXP20_IRQ_USBRE		( 1 <<  2)
+#define	AXP20_IRQ_USBIN		( 1 <<  3)
+#define	AXP20_IRQ_USBOV     ( 1 <<  4)
+#define	AXP20_IRQ_ACRE     ( 1 <<  5)
+#define	AXP20_IRQ_ACIN     ( 1 <<  6)
+#define	AXP20_IRQ_ACOV     ( 1 <<  7)
+#define	AXP20_IRQ_TEMLO      ( 1 <<  8)
+#define	AXP20_IRQ_TEMOV      ( 1 <<  9)
+#define	AXP20_IRQ_CHAOV		( 1 << 10)
+#define	AXP20_IRQ_CHAST 	    ( 1 << 11)
+#define	AXP20_IRQ_BATATOU    ( 1 << 12)
+#define	AXP20_IRQ_BATATIN  	( 1 << 13)
+#define AXP20_IRQ_BATRE		( 1 << 14)
+#define AXP20_IRQ_BATIN		( 1 << 15)
+#define	AXP20_IRQ_PEKLO		( 1 << 16)
+#define	AXP20_IRQ_PEKSH	    ( 1 << 17)
+
+#define AXP20_IRQ_DCDC3LO    ( 1 << 19)
+#define AXP20_IRQ_DCDC2LO    ( 1 << 20)
+#define AXP20_IRQ_DCDC1LO    ( 1 << 21)
+#define AXP20_IRQ_CHACURLO   ( 1 << 22)
+#define AXP20_IRQ_ICTEMOV    ( 1 << 23)
+#define AXP20_IRQ_EXTLOWARN1  ( 1 << 24)
+#define AXP20_IRQ_EXTLOWARN2  ( 1 << 25)
+#define AXP20_IRQ_USBSESUN  ( 1 << 26)
+#define AXP20_IRQ_USBSESVA  ( 1 << 27)
+#define AXP20_IRQ_USBUN     ( 1 << 28)
+#define AXP20_IRQ_USBVA     ( 1 << 29)
+#define AXP20_IRQ_NOECLO     ( 1 << 30)
+#define AXP20_IRQ_NOEOPE     ( 1 << 31)
+#define AXP20_IRQ_GPIO0TG     ( 1 << 32)
+#define AXP20_IRQ_GPIO1TG     ( 1 << 33)
+#define AXP20_IRQ_GPIO2TG     ( 1 << 34)
+#define AXP20_IRQ_GPIO3TG     ( 1 << 35)
+
+#define AXP20_IRQ_PEKFE     ( 1 << 37)
+#define AXP20_IRQ_PEKRE     ( 1 << 38)
+#define AXP20_IRQ_TIMER     ( 1 << 39)
+
+/* Status Query Interface */
+/*  AXP18  */
+#define AXP18_STATUS_BATEN	    ( 1 <<  0)
+#define AXP18_STATUS_USBEN	    ( 1 <<  1)
+#define AXP18_STATUS_BATAT	    ( 1 <<  2)
+#define AXP18_STATUS_SYSON	    ( 1 <<  3)
+#define AXP18_STATUS_EXTVA	    ( 1 <<  4)
+#define AXP18_STATUS_DC3SE	    ( 1 <<  5)
+#define AXP18_STATUS_TEMOV	    ( 1 <<  6)
+#define AXP18_STATUS_DCIEN	    ( 1 <<  7)
+
+/*  AXP19  */
+#define AXP19_STATUS_SOURCE    ( 1 <<  0)
+#define AXP19_STATUS_ACUSBSH ( 1 <<  1)
+#define AXP19_STATUS_BATCURDIR ( 1 <<  2)
+#define AXP19_STATUS_USBLAVHO ( 1 <<  3)
+#define AXP19_STATUS_USBVA    ( 1 <<  4)
+#define AXP19_STATUS_USBEN    ( 1 <<  5)
+#define AXP19_STATUS_ACVA	    ( 1 <<  6)
+#define AXP19_STATUS_ACEN	    ( 1 <<  7)
+
+#define AXP19_STATUS_OPENWAY   ( 1 <<  9)
+#define AXP19_STATUS_CHACURLOEXP (1 << 10)
+#define AXP19_STATUS_BATINACT  ( 1 << 11)
+
+#define AXP19_STATUS_BATEN     ( 1 << 13)
+#define AXP19_STATUS_INCHAR    ( 1 << 14)
+#define AXP19_STATUS_ICTEMOV   ( 1 << 15)
+
+/*  AXP20  */
+#define AXP20_STATUS_SOURCE    ( 1 <<  0)
+#define AXP20_STATUS_ACUSBSH ( 1 <<  1)
+#define AXP20_STATUS_BATCURDIR ( 1 <<  2)
+#define AXP20_STATUS_USBLAVHO ( 1 <<  3)
+#define AXP20_STATUS_USBVA    ( 1 <<  4)
+#define AXP20_STATUS_USBEN    ( 1 <<  5)
+#define AXP20_STATUS_ACVA	    ( 1 <<  6)
+#define AXP20_STATUS_ACEN	    ( 1 <<  7)
+
+
+#define AXP20_STATUS_CHACURLOEXP (1 << 10)
+#define AXP20_STATUS_BATINACT  ( 1 << 11)
+
+#define AXP20_STATUS_BATEN     ( 1 << 13)
+#define AXP20_STATUS_INCHAR    ( 1 << 14)
+#define AXP20_STATUS_ICTEMOV   ( 1 << 15)
+
+
+extern struct device *axp_get_dev(void);
+extern int axp_register_notifier(struct device *dev,
+		struct notifier_block *nb, uint64_t irqs);
+extern int axp_unregister_notifier(struct device *dev,
+		struct notifier_block *nb, uint64_t irqs);
+
+
+/* NOTE: the functions below are not intended for use outside
+ * of the AXP sub-device drivers
+ */
+extern int axp_write(struct device *dev, int reg, uint8_t val);
+extern int axp_writes(struct device *dev, int reg, int len, uint8_t *val);
+extern int axp_read(struct device *dev, int reg, uint8_t *val);
+extern int axp_reads(struct device *dev, int reg, int len, uint8_t *val);
+extern int axp_update(struct device *dev, int reg, uint8_t val, uint8_t mask);
+extern int axp_set_bits(struct device *dev, int reg, uint8_t bit_mask);
+extern int axp_clr_bits(struct device *dev, int reg, uint8_t bit_mask);
+extern struct i2c_client *axp;
+#endif /* __LINUX_PMIC_AXP_H */
diff --git a/include/linux/mm.h b/include/linux/mm.h
index ece5ff4..89c47d9 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -873,6 +873,7 @@ extern bool skip_free_areas_node(unsigned int flags, int nid);
 
 int shmem_lock(struct file *file, int lock, struct user_struct *user);
 struct file *shmem_file_setup(const char *name, loff_t size, unsigned long flags);
+void shmem_set_file(struct vm_area_struct *vma, struct file *file);
 int shmem_zero_setup(struct vm_area_struct *);
 
 extern int can_do_mlock(void);
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0707d22..5674504 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -14,6 +14,7 @@
 #include <linux/sched.h>
 #include <linux/device.h>
 #include <linux/fault-inject.h>
+#include <linux/wakelock.h>
 
 #include <linux/mmc/core.h>
 #include <linux/mmc/pm.h>
@@ -289,12 +290,17 @@ struct mmc_host {
 	int			claim_cnt;	/* "claim" nesting count */
 
 	struct delayed_work	detect;
+	struct wake_lock	detect_wake_lock;
 	int			detect_change;	/* card detect flag */
 	struct mmc_hotplug	hotplug;
 
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */
 
+	unsigned int		bus_resume_flags;
+#define MMC_BUSRESUME_MANUAL_RESUME	(1 << 0)
+#define MMC_BUSRESUME_NEEDS_RESUME	(1 << 1)
+
 	unsigned int		sdio_irqs;
 	struct task_struct	*sdio_irq_thread;
 	bool			sdio_irq_pending;
@@ -320,6 +326,15 @@ struct mmc_host {
 
 	unsigned int		actual_clock;	/* Actual HC clock rate */
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	struct {
+		struct sdio_cis			*cis;
+		struct sdio_cccr		*cccr;
+		struct sdio_embedded_func	*funcs;
+		int				num_funcs;
+	} embedded_sdio_data;
+#endif
+
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
@@ -328,6 +343,14 @@ extern int mmc_add_host(struct mmc_host *);
 extern void mmc_remove_host(struct mmc_host *);
 extern void mmc_free_host(struct mmc_host *);
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+extern void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				       struct sdio_cis *cis,
+				       struct sdio_cccr *cccr,
+				       struct sdio_embedded_func *funcs,
+				       int num_funcs);
+#endif
+
 static inline void *mmc_priv(struct mmc_host *host)
 {
 	return (void *)host->private;
@@ -338,6 +361,18 @@ static inline void *mmc_priv(struct mmc_host *host)
 #define mmc_dev(x)	((x)->parent)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
+#define mmc_bus_needs_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_NEEDS_RESUME)
+#define mmc_bus_manual_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_MANUAL_RESUME)
+
+static inline void mmc_set_bus_resume_policy(struct mmc_host *host, int manual)
+{
+	if (manual)
+		host->bus_resume_flags |= MMC_BUSRESUME_MANUAL_RESUME;
+	else
+		host->bus_resume_flags &= ~MMC_BUSRESUME_MANUAL_RESUME;
+}
+
+extern int mmc_resume_bus(struct mmc_host *host);
 
 extern int mmc_suspend_host(struct mmc_host *);
 extern int mmc_resume_host(struct mmc_host *);
diff --git a/include/linux/mmc/pm.h b/include/linux/mmc/pm.h
index 4a13920..6e2d6a1 100644
--- a/include/linux/mmc/pm.h
+++ b/include/linux/mmc/pm.h
@@ -26,5 +26,6 @@ typedef unsigned int mmc_pm_flag_t;
 
 #define MMC_PM_KEEP_POWER	(1 << 0)	/* preserve card power during suspend */
 #define MMC_PM_WAKE_SDIO_IRQ	(1 << 1)	/* wake up host system on SDIO IRQ assertion */
+#define MMC_PM_IGNORE_PM_NOTIFY	(1 << 2)	/* ignore mmc pm notify */
 
 #endif /* LINUX_MMC_PM_H */
diff --git a/include/linux/mmc/sdio_func.h b/include/linux/mmc/sdio_func.h
old mode 100644
new mode 100755
index 50f0bc9..dc680c4
--- a/include/linux/mmc/sdio_func.h
+++ b/include/linux/mmc/sdio_func.h
@@ -23,6 +23,14 @@ struct sdio_func;
 typedef void (sdio_irq_handler_t)(struct sdio_func *);
 
 /*
+ * Structure used to hold embedded SDIO device data from platform layer
+ */
+struct sdio_embedded_func {
+	uint8_t f_class;
+	uint32_t f_maxblksize;
+};
+
+/*
  * SDIO function CIS tuple (unknown to the core)
  */
 struct sdio_func_tuple {
@@ -130,6 +138,8 @@ extern int sdio_release_irq(struct sdio_func *func);
 extern unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz);
 
 extern u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret);
+extern u8 sdio_readb_ext(struct sdio_func *func, unsigned int addr, int *err_ret,
+	unsigned in);
 extern u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret);
 extern u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret);
 
diff --git a/include/linux/msdos_fs.h b/include/linux/msdos_fs.h
index 34066e6..f38d4f0 100644
--- a/include/linux/msdos_fs.h
+++ b/include/linux/msdos_fs.h
@@ -101,6 +101,7 @@ struct __fat_dirent {
 /* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */
 #define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)
 #define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
+#define VFAT_IOCTL_GET_VOLUME_ID	_IOR('r', 0x12, __u32)
 
 struct fat_boot_sector {
 	__u8	ignored[3];	/* Boot strap short or near jump */
@@ -138,6 +139,17 @@ struct fat_boot_fsinfo {
 	__le32   reserved2[4];
 };
 
+struct fat_boot_bsx {
+	__u8     drive;		    /* drive number */
+	__u8     reserved1;
+	__u8     signature;	    /* extended boot signature */
+	__u8     vol_id[4];     /* volume ID */
+	__u8     vol_label[11]; /* volume label */
+	__u8     type[8];       /* file system type */
+};
+#define FAT16_BSX_OFFSET	36 /* offset of fat_boot_bsx in FAT12 and FAT16 */
+#define FAT32_BSX_OFFSET	64 /* offset of fat_boot_bsx in FAT32 */
+
 struct msdos_dir_entry {
 	__u8	name[MSDOS_NAME];/* name and extension */
 	__u8	attr;		/* attribute bits */
diff --git a/include/linux/netfilter/xt_IDLETIMER.h b/include/linux/netfilter/xt_IDLETIMER.h
index 208ae93..faaa28b 100644
--- a/include/linux/netfilter/xt_IDLETIMER.h
+++ b/include/linux/netfilter/xt_IDLETIMER.h
@@ -4,6 +4,7 @@
  * Header file for Xtables timer target module.
  *
  * Copyright (C) 2004, 2010 Nokia Corporation
+ *
  * Written by Timo Teras <ext-timo.teras@nokia.com>
  *
  * Converted to x_tables and forward-ported to 2.6.34
@@ -32,12 +33,19 @@
 #include <linux/types.h>
 
 #define MAX_IDLETIMER_LABEL_SIZE 28
+#define NLMSG_MAX_SIZE 64
+
+#define NL_EVENT_TYPE_INACTIVE 0
+#define NL_EVENT_TYPE_ACTIVE 1
 
 struct idletimer_tg_info {
 	__u32 timeout;
 
 	char label[MAX_IDLETIMER_LABEL_SIZE];
 
+	/* Use netlink messages for notification in addition to sysfs */
+	__u8 send_nl_msg;
+
 	/* for kernel module internal use only */
 	struct idletimer_tg *timer __attribute__((aligned(8)));
 };
diff --git a/include/linux/netfilter/xt_qtaguid.h b/include/linux/netfilter/xt_qtaguid.h
new file mode 100644
index 0000000..ca60fbd
--- /dev/null
+++ b/include/linux/netfilter/xt_qtaguid.h
@@ -0,0 +1,13 @@
+#ifndef _XT_QTAGUID_MATCH_H
+#define _XT_QTAGUID_MATCH_H
+
+/* For now we just replace the xt_owner.
+ * FIXME: make iptables aware of qtaguid. */
+#include <linux/netfilter/xt_owner.h>
+
+#define XT_QTAGUID_UID    XT_OWNER_UID
+#define XT_QTAGUID_GID    XT_OWNER_GID
+#define XT_QTAGUID_SOCKET XT_OWNER_SOCKET
+#define xt_qtaguid_match_info xt_owner_match_info
+
+#endif /* _XT_QTAGUID_MATCH_H */
diff --git a/include/linux/netfilter/xt_quota2.h b/include/linux/netfilter/xt_quota2.h
new file mode 100644
index 0000000..eadc690
--- /dev/null
+++ b/include/linux/netfilter/xt_quota2.h
@@ -0,0 +1,25 @@
+#ifndef _XT_QUOTA_H
+#define _XT_QUOTA_H
+
+enum xt_quota_flags {
+	XT_QUOTA_INVERT    = 1 << 0,
+	XT_QUOTA_GROW      = 1 << 1,
+	XT_QUOTA_PACKET    = 1 << 2,
+	XT_QUOTA_NO_CHANGE = 1 << 3,
+	XT_QUOTA_MASK      = 0x0F,
+};
+
+struct xt_quota_counter;
+
+struct xt_quota_mtinfo2 {
+	char name[15];
+	u_int8_t flags;
+
+	/* Comparison-invariant */
+	aligned_u64 quota;
+
+	/* Used internally by the kernel */
+	struct xt_quota_counter *master __attribute__((aligned(8)));
+};
+
+#endif /* _XT_QUOTA_H */
diff --git a/include/linux/netfilter/xt_socket.h b/include/linux/netfilter/xt_socket.h
index 26d7217..6359456 100644
--- a/include/linux/netfilter/xt_socket.h
+++ b/include/linux/netfilter/xt_socket.h
@@ -11,4 +11,10 @@ struct xt_socket_mtinfo1 {
 	__u8 flags;
 };
 
+void xt_socket_put_sk(struct sock *sk);
+struct sock *xt_socket_get4_sk(const struct sk_buff *skb,
+			       struct xt_action_param *par);
+struct sock *xt_socket_get6_sk(const struct sk_buff *skb,
+			       struct xt_action_param *par);
+
 #endif /* _XT_SOCKET_H */
diff --git a/include/linux/nmi.h b/include/linux/nmi.h
index db50840..c8f8aa0 100644
--- a/include/linux/nmi.h
+++ b/include/linux/nmi.h
@@ -14,8 +14,11 @@
  * may be used to reset the timeout - for code which intentionally
  * disables interrupts for a long time. This call is stateless.
  */
-#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
+#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR_NMI)
 #include <asm/nmi.h>
+#endif
+
+#if defined(CONFIG_HAVE_NMI_WATCHDOG) || defined(CONFIG_HARDLOCKUP_DETECTOR)
 extern void touch_nmi_watchdog(void);
 #else
 static inline void touch_nmi_watchdog(void)
diff --git a/include/linux/persistent_ram.h b/include/linux/persistent_ram.h
new file mode 100644
index 0000000..2242217
--- /dev/null
+++ b/include/linux/persistent_ram.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __LINUX_PERSISTENT_RAM_H__
+#define __LINUX_PERSISTENT_RAM_H__
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/types.h>
+
+struct persistent_ram_buffer;
+
+struct persistent_ram_descriptor {
+	const char	*name;
+	phys_addr_t	size;
+};
+
+struct persistent_ram {
+	phys_addr_t	start;
+	phys_addr_t	size;
+
+	int ecc_block_size;
+	int ecc_size;
+	int ecc_symsize;
+	int ecc_poly;
+
+	int					num_descs;
+	struct persistent_ram_descriptor	*descs;
+
+	struct list_head node;
+};
+
+struct persistent_ram_zone {
+	struct list_head node;
+	void *vaddr;
+	struct persistent_ram_buffer *buffer;
+	size_t buffer_size;
+
+	/* ECC correction */
+	bool ecc;
+	char *par_buffer;
+	char *par_header;
+	struct rs_control *rs_decoder;
+	int corrected_bytes;
+	int bad_blocks;
+	int ecc_block_size;
+	int ecc_size;
+	int ecc_symsize;
+	int ecc_poly;
+
+	char *old_log;
+	size_t old_log_size;
+	size_t old_log_footer_size;
+	bool early;
+};
+
+int persistent_ram_early_init(struct persistent_ram *ram);
+
+struct persistent_ram_zone *persistent_ram_init_ringbuffer(struct device *dev,
+		bool ecc);
+
+int persistent_ram_write(struct persistent_ram_zone *prz, const void *s,
+	unsigned int count);
+
+size_t persistent_ram_old_size(struct persistent_ram_zone *prz);
+void *persistent_ram_old(struct persistent_ram_zone *prz);
+void persistent_ram_free_old(struct persistent_ram_zone *prz);
+ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,
+	char *str, size_t len);
+
+#endif
diff --git a/include/linux/platform_data/android_battery.h b/include/linux/platform_data/android_battery.h
new file mode 100644
index 0000000..f6c8298
--- /dev/null
+++ b/include/linux/platform_data/android_battery.h
@@ -0,0 +1,47 @@
+/*
+ *  android_battery.h
+ *
+ *  Copyright (C) 2012 Samsung Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_ANDROID_BATTERY_H
+#define _LINUX_ANDROID_BATTERY_H
+
+enum {
+	CHARGE_SOURCE_NONE = 0,
+	CHARGE_SOURCE_AC,
+	CHARGE_SOURCE_USB,
+};
+
+struct android_bat_callbacks {
+	void (*charge_source_changed)
+		(struct android_bat_callbacks *, int);
+	void (*battery_set_full)(struct android_bat_callbacks *);
+};
+
+struct android_bat_platform_data {
+	void (*register_callbacks)(struct android_bat_callbacks *);
+	void (*unregister_callbacks)(void);
+	void (*set_charging_current) (int);
+	void (*set_charging_enable) (int);
+	int (*poll_charge_source) (void);
+	int (*get_capacity) (void);
+	int (*get_temperature) (int *);
+	int (*get_voltage_now)(void);
+	int (*get_current_now)(int *);
+
+	int temp_high_threshold;
+	int temp_high_recovery;
+	int temp_low_recovery;
+	int temp_low_threshold;
+
+	unsigned long full_charging_time;
+	unsigned long recharging_time;
+	unsigned int recharging_voltage;
+};
+
+#endif
diff --git a/include/linux/platform_data/ds2482.h b/include/linux/platform_data/ds2482.h
new file mode 100644
index 0000000..5a6879e2a
--- /dev/null
+++ b/include/linux/platform_data/ds2482.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __PLATFORM_DATA_DS2482__
+#define __PLATFORM_DATA_DS2482__
+
+struct ds2482_platform_data {
+	int		slpz_gpio;
+};
+
+#endif /* __PLATFORM_DATA_DS2482__ */
diff --git a/include/linux/pm.h b/include/linux/pm.h
index 715305e..f067e60 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -544,8 +544,6 @@ struct dev_pm_info {
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;
-	ktime_t			suspend_time;
-	s64			max_time_suspended_ns;
 	struct dev_pm_qos_request *pq_req;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
diff --git a/include/linux/pm_domain.h b/include/linux/pm_domain.h
index 91f8286..30f794e 100644
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@ -14,6 +14,7 @@
 #include <linux/pm.h>
 #include <linux/err.h>
 #include <linux/of.h>
+#include <linux/notifier.h>
 
 enum gpd_status {
 	GPD_STATE_ACTIVE = 0,	/* PM domain is active */
@@ -70,9 +71,9 @@ struct generic_pm_domain {
 	int (*power_on)(struct generic_pm_domain *domain);
 	s64 power_on_latency_ns;
 	struct gpd_dev_ops dev_ops;
-	s64 break_even_ns;	/* Power break even for the entire domain. */
 	s64 max_off_time_ns;	/* Maximum allowed "suspended" time. */
-	ktime_t power_off_time;
+	bool max_off_time_changed;
+	bool cached_power_down_ok;
 	struct device_node *of_node; /* Node in device tree */
 };
 
@@ -93,13 +94,17 @@ struct gpd_timing_data {
 	s64 start_latency_ns;
 	s64 save_state_latency_ns;
 	s64 restore_state_latency_ns;
-	s64 break_even_ns;
+	s64 effective_constraint_ns;
+	bool constraint_changed;
+	bool cached_stop_ok;
 };
 
 struct generic_pm_domain_data {
 	struct pm_domain_data base;
 	struct gpd_dev_ops ops;
 	struct gpd_timing_data td;
+	struct notifier_block nb;
+	struct mutex lock;
 	bool need_restore;
 	bool always_on;
 };
@@ -141,6 +146,7 @@ static inline int pm_genpd_of_add_device(struct device_node *genpd_node,
 extern int pm_genpd_remove_device(struct generic_pm_domain *genpd,
 				  struct device *dev);
 extern void pm_genpd_dev_always_on(struct device *dev, bool val);
+extern void pm_genpd_dev_need_restore(struct device *dev, bool val);
 extern int pm_genpd_add_subdomain(struct generic_pm_domain *genpd,
 				  struct generic_pm_domain *new_subdomain);
 extern int pm_genpd_remove_subdomain(struct generic_pm_domain *genpd,
@@ -184,6 +190,7 @@ static inline int pm_genpd_remove_device(struct generic_pm_domain *genpd,
 	return -ENOSYS;
 }
 static inline void pm_genpd_dev_always_on(struct device *dev, bool val) {}
+static inline void pm_genpd_dev_need_restore(struct device *dev, bool val) {}
 static inline int pm_genpd_add_subdomain(struct generic_pm_domain *genpd,
 					 struct generic_pm_domain *new_sd)
 {
diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 609daae..f271860 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -150,9 +150,6 @@ static inline void pm_runtime_set_autosuspend_delay(struct device *dev,
 static inline unsigned long pm_runtime_autosuspend_expiration(
 				struct device *dev) { return 0; }
 
-static inline void pm_runtime_update_max_time_suspended(struct device *dev,
-							s64 delta_ns) {}
-
 #endif /* !CONFIG_PM_RUNTIME */
 
 static inline int pm_runtime_idle(struct device *dev)
diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
index d9f0511..569781f 100644
--- a/include/linux/pm_wakeup.h
+++ b/include/linux/pm_wakeup.h
@@ -33,12 +33,15 @@
  *
  * @total_time: Total time this wakeup source has been active.
  * @max_time: Maximum time this wakeup source has been continuously active.
- * @last_time: Monotonic clock when the wakeup source's was activated last time.
+ * @last_time: Monotonic clock when the wakeup source's was touched last time.
+ * @prevent_sleep_time: Total time this source has been preventing autosleep.
  * @event_count: Number of signaled wakeup events.
  * @active_count: Number of times the wakeup sorce was activated.
  * @relax_count: Number of times the wakeup sorce was deactivated.
- * @hit_count: Number of times the wakeup sorce might abort system suspend.
+ * @expire_count: Number of times the wakeup source's timeout has expired.
+ * @wakeup_count: Number of times the wakeup source might abort suspend.
  * @active: Status of the wakeup source.
+ * @has_timeout: The wakeup source has been activated with a timeout.
  */
 struct wakeup_source {
 	const char 		*name;
@@ -49,11 +52,15 @@ struct wakeup_source {
 	ktime_t total_time;
 	ktime_t max_time;
 	ktime_t last_time;
+	ktime_t start_prevent_time;
+	ktime_t prevent_sleep_time;
 	unsigned long		event_count;
 	unsigned long		active_count;
 	unsigned long		relax_count;
-	unsigned long		hit_count;
-	unsigned int		active:1;
+	unsigned long		expire_count;
+	unsigned long		wakeup_count;
+	bool			active:1;
+	bool			autosleep_enabled:1;
 };
 
 #ifdef CONFIG_PM_SLEEP
diff --git a/include/linux/power/aw_pm.h b/include/linux/power/aw_pm.h
new file mode 100644
index 0000000..990aca6
--- /dev/null
+++ b/include/linux/power/aw_pm.h
@@ -0,0 +1,135 @@
+/*
+ * include/linux/power/aw_pm.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : pm.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-27 14:08
+* Descript: power manager
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __AW_PM_H__
+#define __AW_PM_H__
+
+
+/**max device number of pmu*/
+#define PMU_MAX_DEVS        2
+/**start address for function run in sram*/
+#define SRAM_FUNC_START     SW_VA_SRAM_BASE
+
+/**
+*@name PMU command
+*@{
+*/
+#define AW_PMU_SET          0x10
+#define AW_PMU_VALID        0x20
+/**
+*@}
+*/
+
+/*
+* define event source for wakeup system when suspended
+*/
+#define SUSPEND_WAKEUP_SRC_EXINT    (1<<0)  /* external interrupt, pmu event for ex.    */
+#define SUSPEND_WAKEUP_SRC_USB      (1<<1)  /* usb connection event */
+#define SUSPEND_WAKEUP_SRC_KEY      (1<<2)  /* key event    */
+#define SUSPEND_WAKEUP_SRC_IR       (1<<3)  /* ir event */
+#define SUSPEND_WAKEUP_SRC_ALARM    (1<<4)  /* alarm event  */
+#define SUSPEND_WAKEUP_SRC_TIMEOFF  (1<<5)  /* set time to power off event  */
+#define SUSPEND_WAKEUP_SRC_PIO      (1<<6)  /* gpio event  */
+
+
+
+/**
+*@brief struct of pmu device arg
+*/
+struct aw_pmu_arg{
+    unsigned int  twi_port;     /**<twi port for pmu chip   */
+    unsigned char dev_addr;     /**<address of pmu device   */
+};
+
+#ifdef CONFIG_ARCH_SUN7I
+typedef struct _boot_dram_para_t
+{
+	unsigned int	dram_baseaddr;
+	unsigned int	dram_clk;
+	unsigned int	dram_type;
+	unsigned int	dram_rank_num;
+	unsigned int	dram_chip_density;
+	unsigned int	dram_io_width;
+	unsigned int	dram_bus_width;
+	unsigned int	dram_cas;
+	unsigned int	dram_zq;
+	unsigned int	dram_odt_en;
+	unsigned int 	dram_size;
+	unsigned int	dram_tpr0;
+	unsigned int	dram_tpr1;
+	unsigned int	dram_tpr2;
+	unsigned int	dram_tpr3;
+	unsigned int	dram_tpr4;
+	unsigned int	dram_tpr5;
+	unsigned int 	dram_emr1;
+	unsigned int	dram_emr2;
+	unsigned int	dram_emr3;
+}standy_dram_para_t;
+#endif
+
+/**
+*@brief struct of standby
+*/
+struct aw_standby_para{
+#ifdef CONFIG_ARCH_SUN7I
+	unsigned int event_enable;   /**<event type for system wakeup        */
+#endif
+    unsigned int event;     /**<event type for system wakeup    */
+#ifdef CONFIG_ARCH_SUN7I
+	unsigned int axp_src;        /**<axp event type for system wakeup    */
+	unsigned int axp_enable;     /**<axp event type for system wakeup    */
+#endif
+    signed int   time_off;  /**<time to power off from now, based on second */
+};
+
+
+/**
+*@brief struct of power management info
+*/
+struct aw_pm_info{
+    struct aw_standby_para  standby_para;   /* standby parameter            */
+    struct aw_pmu_arg       pmu_arg;        /**<args used by main function  */
+#ifdef CONFIG_ARCH_SUN7I
+	standy_dram_para_t	dram_para;
+#endif
+};
+
+
+#endif /* __AW_PM_H__ */
+
diff --git a/include/linux/power/smb347-charger.h b/include/linux/power/smb347-charger.h
index b3cb20d..e9aab94 100644
--- a/include/linux/power/smb347-charger.h
+++ b/include/linux/power/smb347-charger.h
@@ -110,8 +110,14 @@ struct smb347_charger_platform_data {
 	bool		use_mains;
 	bool		use_usb;
 	bool		use_usb_otg;
+	bool		disable_automatic_recharge;
 	int		irq_gpio;
+	bool		disable_stat_interrupts;
 	enum smb347_chg_enable enable_control;
+	bool		usb_mode_pin_ctrl;
+	char		**supplied_to;
+	size_t		num_supplicants;
+	int		en_gpio;
 };
 
 #endif /* SMB347_CHARGER_H */
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
index c38c13d..e1f5447 100644
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -124,6 +124,10 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
 	POWER_SUPPLY_PROP_TYPE, /* use power_supply.type instead */
 	POWER_SUPPLY_PROP_SCOPE,
+	/* Local extensions */
+	POWER_SUPPLY_PROP_USB_HC,
+	POWER_SUPPLY_PROP_USB_OTG,
+	POWER_SUPPLY_PROP_CHARGE_ENABLED,
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_PROP_MODEL_NAME,
 	POWER_SUPPLY_PROP_MANUFACTURER,
@@ -172,6 +176,8 @@ struct power_supply {
 	/* private */
 	struct device *dev;
 	struct work_struct changed_work;
+	spinlock_t changed_lock;
+	bool changed;
 
 #ifdef CONFIG_LEDS_TRIGGERS
 	struct led_trigger *charging_full_trig;
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 3dd0efb..937ab61 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1804,6 +1804,9 @@ static inline void put_task_struct(struct task_struct *t)
 extern void task_times(struct task_struct *p, cputime_t *ut, cputime_t *st);
 extern void thread_group_times(struct task_struct *p, cputime_t *ut, cputime_t *st);
 
+extern int task_free_register(struct notifier_block *n);
+extern int task_free_unregister(struct notifier_block *n);
+
 /*
  * Per process flags
  */
diff --git a/include/linux/security.h b/include/linux/security.h
index 673afbb..b62f396 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -1381,6 +1381,11 @@ static inline void security_free_mnt_opts(struct security_mnt_opts *opts)
 struct security_operations {
 	char name[SECURITY_NAME_MAX + 1];
 
+	int (*binder_set_context_mgr) (struct task_struct *mgr);
+	int (*binder_transaction) (struct task_struct *from, struct task_struct *to);
+	int (*binder_transfer_binder) (struct task_struct *from, struct task_struct *to);
+	int (*binder_transfer_file) (struct task_struct *from, struct task_struct *to, struct file *file);
+
 	int (*ptrace_access_check) (struct task_struct *child, unsigned int mode);
 	int (*ptrace_traceme) (struct task_struct *parent);
 	int (*capget) (struct task_struct *target,
@@ -1664,6 +1669,10 @@ extern void __init security_fixup_ops(struct security_operations *ops);
 
 
 /* Security operations */
+int security_binder_set_context_mgr(struct task_struct *mgr);
+int security_binder_transaction(struct task_struct *from, struct task_struct *to);
+int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to);
+int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file);
 int security_ptrace_access_check(struct task_struct *child, unsigned int mode);
 int security_ptrace_traceme(struct task_struct *parent);
 int security_capget(struct task_struct *target,
@@ -1842,6 +1851,26 @@ static inline int security_init(void)
 	return 0;
 }
 
+static inline int security_binder_set_context_mgr(struct task_struct *mgr)
+{
+	return 0;
+}
+
+static inline int security_binder_transaction(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static inline int security_binder_transfer_binder(struct task_struct *from, struct task_struct *to)
+{
+	return 0;
+}
+
+static inline int security_binder_transfer_file(struct task_struct *from, struct task_struct *to, struct file *file)
+{
+	return 0;
+}
+
 static inline int security_ptrace_access_check(struct task_struct *child,
 					     unsigned int mode)
 {
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 2db407a..828c803 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -252,6 +252,7 @@ struct uart_ops {
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
+	void		(*wake_peer)(struct uart_port *);
 
 	/*
 	 * Return a string describing the type of the port
diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index 7997a50..f7ffe36 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -65,6 +65,7 @@
 #define SIOCDIFADDR	0x8936		/* delete PA address		*/
 #define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
 #define SIOCGIFCOUNT	0x8938		/* get number of devices */
+#define SIOCKILLADDR	0x8939		/* kill sockets with this local addr */
 
 #define SIOCGIFBR	0x8940		/* Bridging support		*/
 #define SIOCSIFBR	0x8941		/* Set bridging options 	*/
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index fa702ae..6c8b6aa 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -505,6 +505,7 @@ struct spi_transfer {
 	unsigned	cs_change:1;
 	u8		bits_per_word;
 	u16		delay_usecs;
+	u16		interbyte_usecs;
 	u32		speed_hz;
 
 	struct list_head transfer_list;
diff --git a/include/linux/spi/spidev.h b/include/linux/spi/spidev.h
index 52d9ed0..66ff93d 100644
--- a/include/linux/spi/spidev.h
+++ b/include/linux/spi/spidev.h
@@ -90,6 +90,7 @@ struct spi_ioc_transfer {
 	__u32		speed_hz;
 
 	__u16		delay_usecs;
+	__u16		interbyte_usecs;
 	__u8		bits_per_word;
 	__u8		cs_change;
 	__u32		pad;
diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index ac1c114..e662d29 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -36,7 +36,13 @@ typedef int __bitwise suspend_state_t;
 #define PM_SUSPEND_ON		((__force suspend_state_t) 0)
 #define PM_SUSPEND_STANDBY	((__force suspend_state_t) 1)
 #define PM_SUSPEND_MEM		((__force suspend_state_t) 3)
+#ifndef CONFIG_ARCH_SUN7I
 #define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
+#else
+#define PM_SUSPEND_BOOTFAST	((__force suspend_state_t) 7)
+#define PM_SUSPEND_MAX		((__force suspend_state_t) 8)
+#endif
+
 
 enum suspend_stat_step {
 	SUSPEND_FREEZE = 1,
@@ -356,8 +362,9 @@ extern int unregister_pm_notifier(struct notifier_block *nb);
 extern bool events_check_enabled;
 
 extern bool pm_wakeup_pending(void);
-extern bool pm_get_wakeup_count(unsigned int *count);
+extern bool pm_get_wakeup_count(unsigned int *count, bool block);
 extern bool pm_save_wakeup_count(unsigned int count);
+extern void pm_wakep_autosleep_enabled(bool set);
 
 static inline void lock_system_sleep(void)
 {
@@ -407,6 +414,17 @@ static inline void unlock_system_sleep(void) {}
 
 #endif /* !CONFIG_PM_SLEEP */
 
+#ifdef CONFIG_PM_AUTOSLEEP
+
+/* kernel/power/autosleep.c */
+void queue_up_suspend_work(void);
+
+#else /* !CONFIG_PM_AUTOSLEEP */
+
+static inline void queue_up_suspend_work(void) {}
+
+#endif /* !CONFIG_PM_AUTOSLEEP */
+
 #ifdef CONFIG_ARCH_SAVE_PAGE_KEYS
 /*
  * The ARCH_SAVE_PAGE_KEYS functions can be used by an architecture
diff --git a/include/linux/sw_sync.h b/include/linux/sw_sync.h
new file mode 100644
index 0000000..bd6f208
--- /dev/null
+++ b/include/linux/sw_sync.h
@@ -0,0 +1,58 @@
+/*
+ * include/linux/sw_sync.h
+ *
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_SW_SYNC_H
+#define _LINUX_SW_SYNC_H
+
+#include <linux/types.h>
+
+#ifdef __KERNEL__
+
+#include <linux/sync.h>
+
+struct sw_sync_timeline {
+	struct	sync_timeline	obj;
+
+	u32			value;
+};
+
+struct sw_sync_pt {
+	struct sync_pt		pt;
+
+	u32			value;
+};
+
+struct sw_sync_timeline *sw_sync_timeline_create(const char *name);
+void sw_sync_timeline_inc(struct sw_sync_timeline *obj, u32 inc);
+
+struct sync_pt *sw_sync_pt_create(struct sw_sync_timeline *obj, u32 value);
+
+#endif /* __KERNEL __ */
+
+struct sw_sync_create_fence_data {
+	__u32	value;
+	char	name[32];
+	__s32	fence; /* fd of new fence */
+};
+
+#define SW_SYNC_IOC_MAGIC	'W'
+
+#define SW_SYNC_IOC_CREATE_FENCE	_IOWR(SW_SYNC_IOC_MAGIC, 0,\
+		struct sw_sync_create_fence_data)
+#define SW_SYNC_IOC_INC			_IOW(SW_SYNC_IOC_MAGIC, 1, __u32)
+
+
+#endif /* _LINUX_SW_SYNC_H */
diff --git a/include/linux/switch.h b/include/linux/switch.h
new file mode 100644
index 0000000..3e4c748
--- /dev/null
+++ b/include/linux/switch.h
@@ -0,0 +1,53 @@
+/*
+ *  Switch class driver
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef __LINUX_SWITCH_H__
+#define __LINUX_SWITCH_H__
+
+struct switch_dev {
+	const char	*name;
+	struct device	*dev;
+	int		index;
+	int		state;
+
+	ssize_t	(*print_name)(struct switch_dev *sdev, char *buf);
+	ssize_t	(*print_state)(struct switch_dev *sdev, char *buf);
+};
+
+struct gpio_switch_platform_data {
+	const char *name;
+	unsigned 	gpio;
+
+	/* if NULL, switch_dev.name will be printed */
+	const char *name_on;
+	const char *name_off;
+	/* if NULL, "0" or "1" will be printed */
+	const char *state_on;
+	const char *state_off;
+};
+
+extern int switch_dev_register(struct switch_dev *sdev);
+extern void switch_dev_unregister(struct switch_dev *sdev);
+
+static inline int switch_get_state(struct switch_dev *sdev)
+{
+	return sdev->state;
+}
+
+extern void switch_set_state(struct switch_dev *sdev, int state);
+
+#endif /* __LINUX_SWITCH_H__ */
diff --git a/include/linux/synaptics_i2c_rmi.h b/include/linux/synaptics_i2c_rmi.h
new file mode 100644
index 0000000..5539cc5
--- /dev/null
+++ b/include/linux/synaptics_i2c_rmi.h
@@ -0,0 +1,55 @@
+/*
+ * include/linux/synaptics_i2c_rmi.h - platform data structure for f75375s sensor
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_SYNAPTICS_I2C_RMI_H
+#define _LINUX_SYNAPTICS_I2C_RMI_H
+
+#define SYNAPTICS_I2C_RMI_NAME "synaptics-rmi-ts"
+
+enum {
+	SYNAPTICS_FLIP_X = 1UL << 0,
+	SYNAPTICS_FLIP_Y = 1UL << 1,
+	SYNAPTICS_SWAP_XY = 1UL << 2,
+	SYNAPTICS_SNAP_TO_INACTIVE_EDGE = 1UL << 3,
+};
+
+struct synaptics_i2c_rmi_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+				/* (major << 8 | minor) version or above. */
+				/* If non-zero another array entry follows */
+	int (*power)(int on);	/* Only valid in first array entry */
+	uint32_t flags;
+	unsigned long irqflags;
+	uint32_t inactive_left; /* 0x10000 = screen width */
+	uint32_t inactive_right; /* 0x10000 = screen width */
+	uint32_t inactive_top; /* 0x10000 = screen height */
+	uint32_t inactive_bottom; /* 0x10000 = screen height */
+	uint32_t snap_left_on; /* 0x10000 = screen width */
+	uint32_t snap_left_off; /* 0x10000 = screen width */
+	uint32_t snap_right_on; /* 0x10000 = screen width */
+	uint32_t snap_right_off; /* 0x10000 = screen width */
+	uint32_t snap_top_on; /* 0x10000 = screen height */
+	uint32_t snap_top_off; /* 0x10000 = screen height */
+	uint32_t snap_bottom_on; /* 0x10000 = screen height */
+	uint32_t snap_bottom_off; /* 0x10000 = screen height */
+	uint32_t fuzz_x; /* 0x10000 = screen width */
+	uint32_t fuzz_y; /* 0x10000 = screen height */
+	int fuzz_p;
+	int fuzz_w;
+	int8_t sensitivity_adjust;
+};
+
+#endif /* _LINUX_SYNAPTICS_I2C_RMI_H */
diff --git a/include/linux/sync.h b/include/linux/sync.h
new file mode 100644
index 0000000..5f49363
--- /dev/null
+++ b/include/linux/sync.h
@@ -0,0 +1,427 @@
+/*
+ * include/linux/sync.h
+ *
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_SYNC_H
+#define _LINUX_SYNC_H
+
+#include <linux/types.h>
+#ifdef __KERNEL__
+
+#include <linux/kref.h>
+#include <linux/ktime.h>
+#include <linux/list.h>
+#include <linux/seq_file.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+
+struct sync_timeline;
+struct sync_pt;
+struct sync_fence;
+
+/**
+ * struct sync_timeline_ops - sync object implementation ops
+ * @driver_name:	name of the implentation
+ * @dup:		duplicate a sync_pt
+ * @has_signaled:	returns:
+ *			  1 if pt has signaled
+ *			  0 if pt has not signaled
+ *			 <0 on error
+ * @compare:		returns:
+ *			  1 if b will signal before a
+ *			  0 if a and b will signal at the same time
+ *			 -1 if a will signabl before b
+ * @free_pt:		called before sync_pt is freed
+ * @release_obj:	called before sync_timeline is freed
+ * @print_obj:		deprecated
+ * @print_pt:		deprecated
+ * @fill_driver_data:	write implmentation specific driver data to data.
+ *			  should return an error if there is not enough room
+ *			  as specified by size.  This information is returned
+ *			  to userspace by SYNC_IOC_FENCE_INFO.
+ * @timeline_value_str: fill str with the value of the sync_timeline's counter
+ * @pt_value_str:	fill str with the value of the sync_pt
+ */
+struct sync_timeline_ops {
+	const char *driver_name;
+
+	/* required */
+	struct sync_pt *(*dup)(struct sync_pt *pt);
+
+	/* required */
+	int (*has_signaled)(struct sync_pt *pt);
+
+	/* required */
+	int (*compare)(struct sync_pt *a, struct sync_pt *b);
+
+	/* optional */
+	void (*free_pt)(struct sync_pt *sync_pt);
+
+	/* optional */
+	void (*release_obj)(struct sync_timeline *sync_timeline);
+
+	/* deprecated */
+	void (*print_obj)(struct seq_file *s,
+			  struct sync_timeline *sync_timeline);
+
+	/* deprecated */
+	void (*print_pt)(struct seq_file *s, struct sync_pt *sync_pt);
+
+	/* optional */
+	int (*fill_driver_data)(struct sync_pt *syncpt, void *data, int size);
+
+	/* optional */
+	void (*timeline_value_str)(struct sync_timeline *timeline, char *str,
+				   int size);
+
+	/* optional */
+	void (*pt_value_str)(struct sync_pt *pt, char *str, int size);
+};
+
+/**
+ * struct sync_timeline - sync object
+ * @kref:		reference count on fence.
+ * @ops:		ops that define the implementaiton of the sync_timeline
+ * @name:		name of the sync_timeline. Useful for debugging
+ * @destoryed:		set when sync_timeline is destroyed
+ * @child_list_head:	list of children sync_pts for this sync_timeline
+ * @child_list_lock:	lock protecting @child_list_head, destroyed, and
+ *			  sync_pt.status
+ * @active_list_head:	list of active (unsignaled/errored) sync_pts
+ * @sync_timeline_list:	membership in global sync_timeline_list
+ */
+struct sync_timeline {
+	struct kref		kref;
+	const struct sync_timeline_ops	*ops;
+	char			name[32];
+
+	/* protected by child_list_lock */
+	bool			destroyed;
+
+	struct list_head	child_list_head;
+	spinlock_t		child_list_lock;
+
+	struct list_head	active_list_head;
+	spinlock_t		active_list_lock;
+
+	struct list_head	sync_timeline_list;
+};
+
+/**
+ * struct sync_pt - sync point
+ * @parent:		sync_timeline to which this sync_pt belongs
+ * @child_list:		membership in sync_timeline.child_list_head
+ * @active_list:	membership in sync_timeline.active_list_head
+ * @signaled_list:	membership in temorary signaled_list on stack
+ * @fence:		sync_fence to which the sync_pt belongs
+ * @pt_list:		membership in sync_fence.pt_list_head
+ * @status:		1: signaled, 0:active, <0: error
+ * @timestamp:		time which sync_pt status transitioned from active to
+ *			  singaled or error.
+ */
+struct sync_pt {
+	struct sync_timeline		*parent;
+	struct list_head	child_list;
+
+	struct list_head	active_list;
+	struct list_head	signaled_list;
+
+	struct sync_fence	*fence;
+	struct list_head	pt_list;
+
+	/* protected by parent->active_list_lock */
+	int			status;
+
+	ktime_t			timestamp;
+};
+
+/**
+ * struct sync_fence - sync fence
+ * @file:		file representing this fence
+ * @kref:		referenace count on fence.
+ * @name:		name of sync_fence.  Useful for debugging
+ * @pt_list_head:	list of sync_pts in ths fence.  immutable once fence
+ *			  is created
+ * @waiter_list_head:	list of asynchronous waiters on this fence
+ * @waiter_list_lock:	lock protecting @waiter_list_head and @status
+ * @status:		1: signaled, 0:active, <0: error
+ *
+ * @wq:			wait queue for fence signaling
+ * @sync_fence_list:	membership in global fence list
+ */
+struct sync_fence {
+	struct file		*file;
+	struct kref		kref;
+	char			name[32];
+
+	/* this list is immutable once the fence is created */
+	struct list_head	pt_list_head;
+
+	struct list_head	waiter_list_head;
+	spinlock_t		waiter_list_lock; /* also protects status */
+	int			status;
+
+	wait_queue_head_t	wq;
+
+	struct list_head	sync_fence_list;
+};
+
+struct sync_fence_waiter;
+typedef void (*sync_callback_t)(struct sync_fence *fence,
+				struct sync_fence_waiter *waiter);
+
+/**
+ * struct sync_fence_waiter - metadata for asynchronous waiter on a fence
+ * @waiter_list:	membership in sync_fence.waiter_list_head
+ * @callback:		function pointer to call when fence signals
+ * @callback_data:	pointer to pass to @callback
+ */
+struct sync_fence_waiter {
+	struct list_head	waiter_list;
+
+	sync_callback_t		callback;
+};
+
+static inline void sync_fence_waiter_init(struct sync_fence_waiter *waiter,
+					  sync_callback_t callback)
+{
+	waiter->callback = callback;
+}
+
+/*
+ * API for sync_timeline implementers
+ */
+
+/**
+ * sync_timeline_create() - creates a sync object
+ * @ops:	specifies the implemention ops for the object
+ * @size:	size to allocate for this obj
+ * @name:	sync_timeline name
+ *
+ * Creates a new sync_timeline which will use the implemetation specified by
+ * @ops.  @size bytes will be allocated allowing for implemntation specific
+ * data to be kept after the generic sync_timeline stuct.
+ */
+struct sync_timeline *sync_timeline_create(const struct sync_timeline_ops *ops,
+					   int size, const char *name);
+
+/**
+ * sync_timeline_destory() - destorys a sync object
+ * @obj:	sync_timeline to destroy
+ *
+ * A sync implemntation should call this when the @obj is going away
+ * (i.e. module unload.)  @obj won't actually be freed until all its childern
+ * sync_pts are freed.
+ */
+void sync_timeline_destroy(struct sync_timeline *obj);
+
+/**
+ * sync_timeline_signal() - signal a status change on a sync_timeline
+ * @obj:	sync_timeline to signal
+ *
+ * A sync implemntation should call this any time one of it's sync_pts
+ * has signaled or has an error condition.
+ */
+void sync_timeline_signal(struct sync_timeline *obj);
+
+/**
+ * sync_pt_create() - creates a sync pt
+ * @parent:	sync_pt's parent sync_timeline
+ * @size:	size to allocate for this pt
+ *
+ * Creates a new sync_pt as a chiled of @parent.  @size bytes will be
+ * allocated allowing for implemntation specific data to be kept after
+ * the generic sync_timeline struct.
+ */
+struct sync_pt *sync_pt_create(struct sync_timeline *parent, int size);
+
+/**
+ * sync_pt_free() - frees a sync pt
+ * @pt:		sync_pt to free
+ *
+ * This should only be called on sync_pts which have been created but
+ * not added to a fence.
+ */
+void sync_pt_free(struct sync_pt *pt);
+
+/**
+ * sync_fence_create() - creates a sync fence
+ * @name:	name of fence to create
+ * @pt:		sync_pt to add to the fence
+ *
+ * Creates a fence containg @pt.  Once this is called, the fence takes
+ * ownership of @pt.
+ */
+struct sync_fence *sync_fence_create(const char *name, struct sync_pt *pt);
+
+/*
+ * API for sync_fence consumers
+ */
+
+/**
+ * sync_fence_merge() - merge two fences
+ * @name:	name of new fence
+ * @a:		fence a
+ * @b:		fence b
+ *
+ * Creates a new fence which contains copies of all the sync_pts in both
+ * @a and @b.  @a and @b remain valid, independent fences.
+ */
+struct sync_fence *sync_fence_merge(const char *name,
+				    struct sync_fence *a, struct sync_fence *b);
+
+/**
+ * sync_fence_fdget() - get a fence from an fd
+ * @fd:		fd referencing a fence
+ *
+ * Ensures @fd references a valid fence, increments the refcount of the backing
+ * file, and returns the fence.
+ */
+struct sync_fence *sync_fence_fdget(int fd);
+
+/**
+ * sync_fence_put() - puts a refernnce of a sync fence
+ * @fence:	fence to put
+ *
+ * Puts a reference on @fence.  If this is the last reference, the fence and
+ * all it's sync_pts will be freed
+ */
+void sync_fence_put(struct sync_fence *fence);
+
+/**
+ * sync_fence_install() - installs a fence into a file descriptor
+ * @fence:	fence to instal
+ * @fd:		file descriptor in which to install the fence
+ *
+ * Installs @fence into @fd.  @fd's should be acquired through get_unused_fd().
+ */
+void sync_fence_install(struct sync_fence *fence, int fd);
+
+/**
+ * sync_fence_wait_async() - registers and async wait on the fence
+ * @fence:		fence to wait on
+ * @waiter:		waiter callback struck
+ *
+ * Returns 1 if @fence has already signaled.
+ *
+ * Registers a callback to be called when @fence signals or has an error.
+ * @waiter should be initialized with sync_fence_waiter_init().
+ */
+int sync_fence_wait_async(struct sync_fence *fence,
+			  struct sync_fence_waiter *waiter);
+
+/**
+ * sync_fence_cancel_async() - cancels an async wait
+ * @fence:		fence to wait on
+ * @waiter:		waiter callback struck
+ *
+ * returns 0 if waiter was removed from fence's async waiter list.
+ * returns -ENOENT if waiter was not found on fence's async waiter list.
+ *
+ * Cancels a previously registered async wait.  Will fail gracefully if
+ * @waiter was never registered or if @fence has already signaled @waiter.
+ */
+int sync_fence_cancel_async(struct sync_fence *fence,
+			    struct sync_fence_waiter *waiter);
+
+/**
+ * sync_fence_wait() - wait on fence
+ * @fence:	fence to wait on
+ * @tiemout:	timeout in ms
+ *
+ * Wait for @fence to be signaled or have an error.  Waits indefinitely
+ * if @timeout < 0
+ */
+int sync_fence_wait(struct sync_fence *fence, long timeout);
+
+#endif /* __KERNEL__ */
+
+/**
+ * struct sync_merge_data - data passed to merge ioctl
+ * @fd2:	file descriptor of second fence
+ * @name:	name of new fence
+ * @fence:	returns the fd of the new fence to userspace
+ */
+struct sync_merge_data {
+	__s32	fd2; /* fd of second fence */
+	char	name[32]; /* name of new fence */
+	__s32	fence; /* fd on newly created fence */
+};
+
+/**
+ * struct sync_pt_info - detailed sync_pt information
+ * @len:		length of sync_pt_info including any driver_data
+ * @obj_name:		name of parent sync_timeline
+ * @driver_name:	name of driver implmenting the parent
+ * @status:		status of the sync_pt 0:active 1:signaled <0:error
+ * @timestamp_ns:	timestamp of status change in nanoseconds
+ * @driver_data:	any driver dependant data
+ */
+struct sync_pt_info {
+	__u32	len;
+	char	obj_name[32];
+	char	driver_name[32];
+	__s32	status;
+	__u64	timestamp_ns;
+
+	__u8	driver_data[0];
+};
+
+/**
+ * struct sync_fence_info_data - data returned from fence info ioctl
+ * @len:	ioctl caller writes the size of the buffer its passing in.
+ *		ioctl returns length of sync_fence_data reutnred to userspace
+ *		including pt_info.
+ * @name:	name of fence
+ * @status:	status of fence. 1: signaled 0:active <0:error
+ * @pt_info:	a sync_pt_info struct for every sync_pt in the fence
+ */
+struct sync_fence_info_data {
+	__u32	len;
+	char	name[32];
+	__s32	status;
+
+	__u8	pt_info[0];
+};
+
+#define SYNC_IOC_MAGIC		'>'
+
+/**
+ * DOC: SYNC_IOC_WAIT - wait for a fence to signal
+ *
+ * pass timeout in milliseconds.  Waits indefinitely timeout < 0.
+ */
+#define SYNC_IOC_WAIT		_IOW(SYNC_IOC_MAGIC, 0, __s32)
+
+/**
+ * DOC: SYNC_IOC_MERGE - merge two fences
+ *
+ * Takes a struct sync_merge_data.  Creates a new fence containing copies of
+ * the sync_pts in both the calling fd and sync_merge_data.fd2.  Returns the
+ * new fence's fd in sync_merge_data.fence
+ */
+#define SYNC_IOC_MERGE		_IOWR(SYNC_IOC_MAGIC, 1, struct sync_merge_data)
+
+/**
+ * DOC: SYNC_IOC_FENCE_INFO - get detailed information on a fence
+ *
+ * Takes a struct sync_fence_info_data with extra space allocated for pt_info.
+ * Caller should write the size of the buffer into len.  On return, len is
+ * updated to reflect the total size of the sync_fence_info_data including
+ * pt_info.
+ *
+ * pt_info is a buffer containing sync_pt_infos for every sync_pt in the fence.
+ * To itterate over the sync_pt_infos, use the sync_pt_info.len field.
+ */
+#define SYNC_IOC_FENCE_INFO	_IOWR(SYNC_IOC_MAGIC, 2,\
+	struct sync_fence_info_data)
+
+#endif /* _LINUX_SYNC_H */
diff --git a/include/linux/timed_output.h b/include/linux/timed_output.h
new file mode 100644
index 0000000..ec907ab
--- /dev/null
+++ b/include/linux/timed_output.h
@@ -0,0 +1,37 @@
+/* include/linux/timed_output.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#ifndef _LINUX_TIMED_OUTPUT_H
+#define _LINUX_TIMED_OUTPUT_H
+
+struct timed_output_dev {
+	const char	*name;
+
+	/* enable the output and set the timer */
+	void	(*enable)(struct timed_output_dev *sdev, int timeout);
+
+	/* returns the current number of milliseconds remaining on the timer */
+	int		(*get_time)(struct timed_output_dev *sdev);
+
+	/* private data */
+	struct device	*dev;
+	int		index;
+	int		state;
+};
+
+extern int timed_output_dev_register(struct timed_output_dev *dev);
+extern void timed_output_dev_unregister(struct timed_output_dev *dev);
+
+#endif
diff --git a/include/linux/uhid.h b/include/linux/uhid.h
new file mode 100644
index 0000000..9c6974f
--- /dev/null
+++ b/include/linux/uhid.h
@@ -0,0 +1,104 @@
+#ifndef __UHID_H_
+#define __UHID_H_
+
+/*
+ * User-space I/O driver support for HID subsystem
+ * Copyright (c) 2012 David Herrmann
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+/*
+ * Public header for user-space communication. We try to keep every structure
+ * aligned but to be safe we also use __attribute__((__packed__)). Therefore,
+ * the communication should be ABI compatible even between architectures.
+ */
+
+#include <linux/input.h>
+#include <linux/types.h>
+
+enum uhid_event_type {
+	UHID_CREATE,
+	UHID_DESTROY,
+	UHID_START,
+	UHID_STOP,
+	UHID_OPEN,
+	UHID_CLOSE,
+	UHID_OUTPUT,
+	UHID_OUTPUT_EV,
+	UHID_INPUT,
+	UHID_FEATURE,
+	UHID_FEATURE_ANSWER,
+};
+
+struct uhid_create_req {
+	__u8 name[128];
+	__u8 phys[64];
+	__u8 uniq[64];
+	__u8 __user *rd_data;
+	__u16 rd_size;
+
+	__u16 bus;
+	__u32 vendor;
+	__u32 product;
+	__u32 version;
+	__u32 country;
+} __attribute__((__packed__));
+
+#define UHID_DATA_MAX 4096
+
+enum uhid_report_type {
+	UHID_FEATURE_REPORT,
+	UHID_OUTPUT_REPORT,
+	UHID_INPUT_REPORT,
+};
+
+struct uhid_input_req {
+	__u8 data[UHID_DATA_MAX];
+	__u16 size;
+} __attribute__((__packed__));
+
+struct uhid_output_req {
+	__u8 data[UHID_DATA_MAX];
+	__u16 size;
+	__u8 rtype;
+} __attribute__((__packed__));
+
+struct uhid_output_ev_req {
+	__u16 type;
+	__u16 code;
+	__s32 value;
+} __attribute__((__packed__));
+
+struct uhid_feature_req {
+	__u32 id;
+	__u8 rnum;
+	__u8 rtype;
+} __attribute__((__packed__));
+
+struct uhid_feature_answer_req {
+	__u32 id;
+	__u16 err;
+	__u16 size;
+	__u8 data[UHID_DATA_MAX];
+};
+
+struct uhid_event {
+	__u32 type;
+
+	union {
+		struct uhid_create_req create;
+		struct uhid_input_req input;
+		struct uhid_output_req output;
+		struct uhid_output_ev_req output_ev;
+		struct uhid_feature_req feature;
+		struct uhid_feature_answer_req feature_answer;
+	} u;
+} __attribute__((__packed__));
+
+#endif /* __UHID_H_ */
diff --git a/include/linux/uid_stat.h b/include/linux/uid_stat.h
new file mode 100644
index 0000000..6bd6c4e
--- /dev/null
+++ b/include/linux/uid_stat.h
@@ -0,0 +1,29 @@
+/* include/linux/uid_stat.h
+ *
+ * Copyright (C) 2008-2009 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __uid_stat_h
+#define __uid_stat_h
+
+/* Contains definitions for resource tracking per uid. */
+
+#ifdef CONFIG_UID_STAT
+int uid_stat_tcp_snd(uid_t uid, int size);
+int uid_stat_tcp_rcv(uid_t uid, int size);
+#else
+#define uid_stat_tcp_snd(uid, size) do {} while (0);
+#define uid_stat_tcp_rcv(uid, size) do {} while (0);
+#endif
+
+#endif /* _LINUX_UID_STAT_H */
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4e8e668..e486775 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1039,6 +1039,7 @@ extern int usb_disabled(void);
 #define URB_SETUP_MAP_LOCAL	0x00200000	/* HCD-local setup packet */
 #define URB_DMA_SG_COMBINED	0x00400000	/* S-G entries were combined */
 #define URB_ALIGNED_TEMP_BUFFER	0x00800000	/* Temp buffer was alloc'd */
+#define URB_ALIGNED_TEMP_SETUP	0x01000000	/* Temp setup packet alloc'd */
 
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
index a316fba..af16097 100644
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -242,6 +242,9 @@ int usb_add_config(struct usb_composite_dev *,
 		struct usb_configuration *,
 		int (*)(struct usb_configuration *));
 
+int usb_remove_config(struct usb_composite_dev *,
+		struct usb_configuration *);
+
 /**
  * struct usb_composite_driver - groups configurations into a gadget
  * @name: For diagnostics, identifies the driver.
@@ -369,6 +372,27 @@ extern int usb_string_ids_tab(struct usb_composite_dev *c,
 			      struct usb_string *str);
 extern int usb_string_ids_n(struct usb_composite_dev *c, unsigned n);
 
+/* add by javen */
+struct android_usb_config{
+    /* usb feature */
+    u32 vendor_id;
+    u32 mass_storage_id;
+    u32 adb_id;
+
+    char usb_manufacturer_name[64];
+    char usb_product_name[64];
+    char usb_serial_number[64];
+
+    /* usb_mass_storage feature */
+    char msc_vendor_name[64];
+    char msc_product_name[64];
+    u32 msc_release;
+    u32 luns;
+};
+
+s32 parse_android_usb_config(void);
+s32 get_android_usb_config(struct android_usb_config *config);
+
 
 /* messaging utils */
 #define DBG(d, fmt, args...) \
diff --git a/include/linux/usb/f_accessory.h b/include/linux/usb/f_accessory.h
new file mode 100644
index 0000000..61ebe0a
--- /dev/null
+++ b/include/linux/usb/f_accessory.h
@@ -0,0 +1,146 @@
+/*
+ * Gadget Function Driver for Android USB accessories
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __LINUX_USB_F_ACCESSORY_H
+#define __LINUX_USB_F_ACCESSORY_H
+
+/* Use Google Vendor ID when in accessory mode */
+#define USB_ACCESSORY_VENDOR_ID 0x18D1
+
+
+/* Product ID to use when in accessory mode */
+#define USB_ACCESSORY_PRODUCT_ID 0x2D00
+
+/* Product ID to use when in accessory mode and adb is enabled */
+#define USB_ACCESSORY_ADB_PRODUCT_ID 0x2D01
+
+/* Indexes for strings sent by the host via ACCESSORY_SEND_STRING */
+#define ACCESSORY_STRING_MANUFACTURER   0
+#define ACCESSORY_STRING_MODEL          1
+#define ACCESSORY_STRING_DESCRIPTION    2
+#define ACCESSORY_STRING_VERSION        3
+#define ACCESSORY_STRING_URI            4
+#define ACCESSORY_STRING_SERIAL         5
+
+/* Control request for retrieving device's protocol version
+ *
+ *	requestType:    USB_DIR_IN | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_GET_PROTOCOL
+ *	value:          0
+ *	index:          0
+ *	data            version number (16 bits little endian)
+ *                     1 for original accessory support
+ *                     2 adds HID and device to host audio support
+ */
+#define ACCESSORY_GET_PROTOCOL  51
+
+/* Control request for host to send a string to the device
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_SEND_STRING
+ *	value:          0
+ *	index:          string ID
+ *	data            zero terminated UTF8 string
+ *
+ *  The device can later retrieve these strings via the
+ *  ACCESSORY_GET_STRING_* ioctls
+ */
+#define ACCESSORY_SEND_STRING   52
+
+/* Control request for starting device in accessory mode.
+ * The host sends this after setting all its strings to the device.
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_START
+ *	value:          0
+ *	index:          0
+ *	data            none
+ */
+#define ACCESSORY_START         53
+
+/* Control request for registering a HID device.
+ * Upon registering, a unique ID is sent by the accessory in the
+ * value parameter. This ID will be used for future commands for
+ * the device
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_REGISTER_HID_DEVICE
+ *	value:          Accessory assigned ID for the HID device
+ *	index:          total length of the HID report descriptor
+ *	data            none
+ */
+#define ACCESSORY_REGISTER_HID         54
+
+/* Control request for unregistering a HID device.
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_REGISTER_HID
+ *	value:          Accessory assigned ID for the HID device
+ *	index:          0
+ *	data            none
+ */
+#define ACCESSORY_UNREGISTER_HID         55
+
+/* Control request for sending the HID report descriptor.
+ * If the HID descriptor is longer than the endpoint zero max packet size,
+ * the descriptor will be sent in multiple ACCESSORY_SET_HID_REPORT_DESC
+ * commands. The data for the descriptor must be sent sequentially
+ * if multiple packets are needed.
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_SET_HID_REPORT_DESC
+ *	value:          Accessory assigned ID for the HID device
+ *	index:          offset of data in descriptor
+ *                      (needed when HID descriptor is too big for one packet)
+ *	data            the HID report descriptor
+ */
+#define ACCESSORY_SET_HID_REPORT_DESC         56
+
+/* Control request for sending HID events.
+ *
+ *	requestType:    USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_SEND_HID_EVENT
+ *	value:          Accessory assigned ID for the HID device
+ *	index:          0
+ *	data            the HID report for the event
+ */
+#define ACCESSORY_SEND_HID_EVENT         57
+
+/* Control request for setting the audio mode.
+ *
+ *	requestType:	USB_DIR_OUT | USB_TYPE_VENDOR
+ *	request:        ACCESSORY_SET_AUDIO_MODE
+ *	value:          0 - no audio
+ *                     1 - device to host, 44100 16-bit stereo PCM
+ *	index:          0
+ *	data            none
+ */
+#define ACCESSORY_SET_AUDIO_MODE         58
+
+/* ioctls for retrieving strings set by the host */
+#define ACCESSORY_GET_STRING_MANUFACTURER   _IOW('M', 1, char[256])
+#define ACCESSORY_GET_STRING_MODEL          _IOW('M', 2, char[256])
+#define ACCESSORY_GET_STRING_DESCRIPTION    _IOW('M', 3, char[256])
+#define ACCESSORY_GET_STRING_VERSION        _IOW('M', 4, char[256])
+#define ACCESSORY_GET_STRING_URI            _IOW('M', 5, char[256])
+#define ACCESSORY_GET_STRING_SERIAL         _IOW('M', 6, char[256])
+/* returns 1 if there is a start request pending */
+#define ACCESSORY_IS_START_REQUESTED        _IO('M', 7)
+/* returns audio mode (set via the ACCESSORY_SET_AUDIO_MODE control request) */
+#define ACCESSORY_GET_AUDIO_MODE            _IO('M', 8)
+
+#endif /* __LINUX_USB_F_ACCESSORY_H */
diff --git a/include/linux/usb/f_mtp.h b/include/linux/usb/f_mtp.h
new file mode 100644
index 0000000..72a432e
--- /dev/null
+++ b/include/linux/usb/f_mtp.h
@@ -0,0 +1,75 @@
+/*
+ * Gadget Function Driver for MTP
+ *
+ * Copyright (C) 2010 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __LINUX_USB_F_MTP_H
+#define __LINUX_USB_F_MTP_H
+
+#include <linux/ioctl.h>
+
+#ifdef __KERNEL__
+
+struct mtp_data_header {
+	/* length of packet, including this header */
+	uint32_t	length;
+	/* container type (2 for data packet) */
+	uint16_t	type;
+	/* MTP command code */
+	uint16_t    command;
+	/* MTP transaction ID */
+	uint32_t	transaction_id;
+};
+
+#endif /* __KERNEL__ */
+
+struct mtp_file_range {
+	/* file descriptor for file to transfer */
+	int			fd;
+	/* offset in file for start of transfer */
+	loff_t		offset;
+	/* number of bytes to transfer */
+	int64_t		length;
+	/* MTP command ID for data header,
+	 * used only for MTP_SEND_FILE_WITH_HEADER
+	 */
+	uint16_t	command;
+	/* MTP transaction ID for data header,
+	 * used only for MTP_SEND_FILE_WITH_HEADER
+	 */
+	uint32_t	transaction_id;
+};
+
+struct mtp_event {
+	/* size of the event */
+	size_t		length;
+	/* event data to send */
+	void		*data;
+};
+
+/* Sends the specified file range to the host */
+#define MTP_SEND_FILE              _IOW('M', 0, struct mtp_file_range)
+/* Receives data from the host and writes it to a file.
+ * The file is created if it does not exist.
+ */
+#define MTP_RECEIVE_FILE           _IOW('M', 1, struct mtp_file_range)
+/* Sends an event to the host via the interrupt endpoint */
+#define MTP_SEND_EVENT             _IOW('M', 3, struct mtp_event)
+/* Sends the specified file range to the host,
+ * with a 12 byte MTP data packet header at the beginning.
+ */
+#define MTP_SEND_FILE_WITH_HEADER  _IOW('M', 4, struct mtp_file_range)
+
+#endif /* __LINUX_USB_F_MTP_H */
diff --git a/include/linux/videodev2.h b/include/linux/videodev2.h
index c9c9a46..6490191 100644
--- a/include/linux/videodev2.h
+++ b/include/linux/videodev2.h
@@ -1208,6 +1208,14 @@ struct v4l2_querymenu {
 #define V4L2_CID_BLACK_LEVEL		(V4L2_CID_BASE+11) /* Deprecated */
 #define V4L2_CID_AUTO_WHITE_BALANCE	(V4L2_CID_BASE+12)
 #define V4L2_CID_DO_WHITE_BALANCE	(V4L2_CID_BASE+13)
+enum v4l2_whiteblance {
+	V4L2_WB_AUTO = 0,
+	V4L2_WB_CLOUD = 1,
+	V4L2_WB_DAYLIGHT = 2,
+	V4L2_WB_INCANDESCENCE = 3,
+	V4L2_WB_FLUORESCENT = 4,
+	V4L2_WB_TUNGSTEN = 5,
+};
 #define V4L2_CID_RED_BALANCE		(V4L2_CID_BASE+14)
 #define V4L2_CID_BLUE_BALANCE		(V4L2_CID_BASE+15)
 #define V4L2_CID_GAMMA			(V4L2_CID_BASE+16)
@@ -1266,6 +1274,15 @@ enum v4l2_colorfx {
 
 /* last CID + 1 */
 #define V4L2_CID_LASTP1                         (V4L2_CID_BASE+42)
+/* Add camera flash light by raymonxiu */
+#define V4L2_CID_CAMERA_FLASH_MODE              (V4L2_CID_PRIVATE_BASE+0)
+enum v4l2_flash_mode {
+	V4L2_FLASH_MODE_OFF = 0,
+	V4L2_FLASH_MODE_AUTO = 1,
+	V4L2_FLASH_MODE_ON = 2,
+	V4L2_FLASH_MODE_TORCH = 3,
+	V4L2_FLASH_MODE_RED_EYE = 4,
+};
 
 /*  MPEG-class control IDs defined by V4L2 */
 #define V4L2_CID_MPEG_BASE 			(V4L2_CTRL_CLASS_MPEG | 0x900)
diff --git a/include/linux/wakelock.h b/include/linux/wakelock.h
new file mode 100644
index 0000000..f4a698a
--- /dev/null
+++ b/include/linux/wakelock.h
@@ -0,0 +1,67 @@
+/* include/linux/wakelock.h
+ *
+ * Copyright (C) 2007-2012 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_WAKELOCK_H
+#define _LINUX_WAKELOCK_H
+
+#include <linux/ktime.h>
+#include <linux/device.h>
+
+/* A wake_lock prevents the system from entering suspend or other low power
+ * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
+ * prevents a full system suspend.
+ */
+
+enum {
+	WAKE_LOCK_SUSPEND, /* Prevent suspend */
+	WAKE_LOCK_TYPE_COUNT
+};
+
+struct wake_lock {
+	struct wakeup_source ws;
+};
+
+static inline void wake_lock_init(struct wake_lock *lock, int type,
+				  const char *name)
+{
+	wakeup_source_init(&lock->ws, name);
+}
+
+static inline void wake_lock_destroy(struct wake_lock *lock)
+{
+	wakeup_source_trash(&lock->ws);
+}
+
+static inline void wake_lock(struct wake_lock *lock)
+{
+	__pm_stay_awake(&lock->ws);
+}
+
+static inline void wake_lock_timeout(struct wake_lock *lock, long timeout)
+{
+	__pm_wakeup_event(&lock->ws, jiffies_to_msecs(timeout));
+}
+
+static inline void wake_unlock(struct wake_lock *lock)
+{
+	__pm_relax(&lock->ws);
+}
+
+static inline int wake_lock_active(struct wake_lock *lock)
+{
+	return lock->ws.active;
+}
+
+#endif
diff --git a/include/linux/wifi_tiwlan.h b/include/linux/wifi_tiwlan.h
new file mode 100644
index 0000000..f07e067
--- /dev/null
+++ b/include/linux/wifi_tiwlan.h
@@ -0,0 +1,27 @@
+/* include/linux/wifi_tiwlan.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LINUX_WIFI_TIWLAN_H_
+#define _LINUX_WIFI_TIWLAN_H_
+
+#include <linux/wlan_plat.h>
+
+#define WMPA_NUMBER_OF_SECTIONS	3
+#define WMPA_NUMBER_OF_BUFFERS	160
+#define WMPA_SECTION_HEADER	24
+#define WMPA_SECTION_SIZE_0	(WMPA_NUMBER_OF_BUFFERS * 64)
+#define WMPA_SECTION_SIZE_1	(WMPA_NUMBER_OF_BUFFERS * 256)
+#define WMPA_SECTION_SIZE_2	(WMPA_NUMBER_OF_BUFFERS * 2048)
+
+#endif
diff --git a/include/linux/wl127x-rfkill.h b/include/linux/wl127x-rfkill.h
new file mode 100644
index 0000000..9057ec6
--- /dev/null
+++ b/include/linux/wl127x-rfkill.h
@@ -0,0 +1,35 @@
+/*
+ * Bluetooth TI wl127x rfkill power control via GPIO
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ * Copyright (C) 2008 Texas Instruments
+ * Initial code: Pavan Savoy <pavan.savoy@gmail.com> (wl127x_power.c)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _LINUX_WL127X_RFKILL_H
+#define _LINUX_WL127X_RFKILL_H
+
+#include <linux/rfkill.h>
+
+struct wl127x_rfkill_platform_data {
+	int nshutdown_gpio;
+
+	struct rfkill *rfkill;  /* for driver only */
+};
+
+#endif
diff --git a/include/linux/wlan_plat.h b/include/linux/wlan_plat.h
new file mode 100644
index 0000000..40ec348
--- /dev/null
+++ b/include/linux/wlan_plat.h
@@ -0,0 +1,27 @@
+/* include/linux/wlan_plat.h
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LINUX_WLAN_PLAT_H_
+#define _LINUX_WLAN_PLAT_H_
+
+struct wifi_platform_data {
+	int (*set_power)(int val);
+	int (*set_reset)(int val);
+	int (*set_carddetect)(int val);
+	void *(*mem_prealloc)(int section, unsigned long size);
+	int (*get_mac_addr)(unsigned char *buf);
+	void *(*get_country_code)(char *ccode);
+};
+
+#endif
diff --git a/include/net/activity_stats.h b/include/net/activity_stats.h
new file mode 100644
index 0000000..10e4c15
--- /dev/null
+++ b/include/net/activity_stats.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Author: Mike Chan (mike@android.com)
+ */
+
+#ifndef __activity_stats_h
+#define __activity_stats_h
+
+#ifdef CONFIG_NET_ACTIVITY_STATS
+void activity_stats_update(void);
+#else
+#define activity_stats_update(void) {}
+#endif
+
+#endif /* _NET_ACTIVITY_STATS_H */
diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
index d47e523..78132a8 100644
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -174,8 +174,10 @@ enum {
 #define ESCO_2EV5	0x0100
 #define ESCO_3EV5	0x0200
 
-#define SCO_ESCO_MASK  (ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
-#define EDR_ESCO_MASK  (ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
+#define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
+#define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
+#define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
+			EDR_ESCO_MASK)
 
 /* ACL flags */
 #define ACL_START_NO_FLUSH	0x00
@@ -1392,6 +1394,9 @@ struct hci_conn_info {
 	__u8     out;
 	__u16    state;
 	__u32    link_mode;
+	__u32    mtu;
+	__u32    cnt;
+	__u32    pkts;
 };
 
 struct hci_dev_req {
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index db1c5df..392b2ca 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -561,7 +561,8 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle);
 void hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
@@ -570,8 +571,9 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn);
 int hci_chan_del(struct hci_chan *chan);
 void hci_chan_list_flush(struct hci_conn *conn);
 
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
-						__u8 sec_level, __u8 auth_type);
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst,
+					__u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
@@ -598,7 +600,7 @@ static inline void hci_conn_put(struct hci_conn *conn)
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 2;
+					timeo *= 20;
 			} else {
 				timeo = msecs_to_jiffies(10);
 			}
diff --git a/include/net/bluetooth/sco.h b/include/net/bluetooth/sco.h
index 1e35c43..6d1857a 100644
--- a/include/net/bluetooth/sco.h
+++ b/include/net/bluetooth/sco.h
@@ -37,6 +37,7 @@
 struct sockaddr_sco {
 	sa_family_t	sco_family;
 	bdaddr_t	sco_bdaddr;
+	__u16		sco_pkt_type;
 };
 
 /* SCO socket options */
@@ -72,7 +73,8 @@ struct sco_conn {
 
 struct sco_pinfo {
 	struct bt_sock	bt;
-	__u32		flags;
+	__u16		pkt_type;
+
 	struct sco_conn	*conn;
 };
 
diff --git a/include/net/tcp.h b/include/net/tcp.h
index 2757a11..ed5b0c7 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1456,6 +1456,8 @@ extern struct sk_buff **tcp4_gro_receive(struct sk_buff **head,
 extern int tcp_gro_complete(struct sk_buff *skb);
 extern int tcp4_gro_complete(struct sk_buff *skb);
 
+extern int tcp_nuke_addr(struct net *net, struct sockaddr *addr);
+
 #ifdef CONFIG_PROC_FS
 extern int tcp4_proc_init(void);
 extern void tcp4_proc_exit(void);
diff --git a/include/sound/soc-dapm.h b/include/sound/soc-dapm.h
index 8da3c24..055242e 100644
--- a/include/sound/soc-dapm.h
+++ b/include/sound/soc-dapm.h
@@ -432,6 +432,11 @@ enum snd_soc_dapm_type {
 	snd_soc_dapm_dai,		/* link to DAI structure */
 };
 
+enum snd_soc_dapm_subclass {
+	SND_SOC_DAPM_CLASS_INIT	= 0,
+	SND_SOC_DAPM_CLASS_PCM	= 1,
+};
+
 /*
  * DAPM audio route definition.
  *
diff --git a/include/sound/soc.h b/include/sound/soc.h
index 2ebf787..66fd9bc 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -288,6 +288,11 @@ enum snd_soc_pcm_subclass {
 	SND_SOC_PCM_CLASS_BE	= 1,
 };
 
+enum snd_soc_card_subclass {
+	SND_SOC_CARD_CLASS_INIT	= 0,
+	SND_SOC_CARD_CLASS_PCM	= 1,
+};
+
 int snd_soc_codec_set_sysclk(struct snd_soc_codec *codec, int clk_id,
 			     int source, unsigned int freq, int dir);
 int snd_soc_codec_set_pll(struct snd_soc_codec *codec, int pll_id, int source,
@@ -800,6 +805,7 @@ struct snd_soc_card {
 
 	struct list_head list;
 	struct mutex mutex;
+	struct mutex dapm_mutex;
 
 	bool instantiated;
 
diff --git a/include/trace/events/cpufreq_interactive.h b/include/trace/events/cpufreq_interactive.h
new file mode 100644
index 0000000..951e6ca
--- /dev/null
+++ b/include/trace/events/cpufreq_interactive.h
@@ -0,0 +1,112 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM cpufreq_interactive
+
+#if !defined(_TRACE_CPUFREQ_INTERACTIVE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_CPUFREQ_INTERACTIVE_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_EVENT_CLASS(set,
+	TP_PROTO(u32 cpu_id, unsigned long targfreq,
+	         unsigned long actualfreq),
+	TP_ARGS(cpu_id, targfreq, actualfreq),
+
+	TP_STRUCT__entry(
+	    __field(          u32, cpu_id    )
+	    __field(unsigned long, targfreq   )
+	    __field(unsigned long, actualfreq )
+	   ),
+
+	TP_fast_assign(
+	    __entry->cpu_id = (u32) cpu_id;
+	    __entry->targfreq = targfreq;
+	    __entry->actualfreq = actualfreq;
+	),
+
+	TP_printk("cpu=%u targ=%lu actual=%lu",
+	      __entry->cpu_id, __entry->targfreq,
+	      __entry->actualfreq)
+);
+
+DEFINE_EVENT(set, cpufreq_interactive_setspeed,
+	TP_PROTO(u32 cpu_id, unsigned long targfreq,
+	     unsigned long actualfreq),
+	TP_ARGS(cpu_id, targfreq, actualfreq)
+);
+
+DECLARE_EVENT_CLASS(loadeval,
+	    TP_PROTO(unsigned long cpu_id, unsigned long load,
+		     unsigned long curtarg, unsigned long curactual,
+		     unsigned long newtarg),
+		    TP_ARGS(cpu_id, load, curtarg, curactual, newtarg),
+
+	    TP_STRUCT__entry(
+		    __field(unsigned long, cpu_id    )
+		    __field(unsigned long, load      )
+		    __field(unsigned long, curtarg   )
+		    __field(unsigned long, curactual )
+		    __field(unsigned long, newtarg   )
+	    ),
+
+	    TP_fast_assign(
+		    __entry->cpu_id = cpu_id;
+		    __entry->load = load;
+		    __entry->curtarg = curtarg;
+		    __entry->curactual = curactual;
+		    __entry->newtarg = newtarg;
+	    ),
+
+	    TP_printk("cpu=%lu load=%lu cur=%lu actual=%lu targ=%lu",
+		      __entry->cpu_id, __entry->load, __entry->curtarg,
+		      __entry->curactual, __entry->newtarg)
+);
+
+DEFINE_EVENT(loadeval, cpufreq_interactive_target,
+	    TP_PROTO(unsigned long cpu_id, unsigned long load,
+		     unsigned long curtarg, unsigned long curactual,
+		     unsigned long newtarg),
+	    TP_ARGS(cpu_id, load, curtarg, curactual, newtarg)
+);
+
+DEFINE_EVENT(loadeval, cpufreq_interactive_already,
+	    TP_PROTO(unsigned long cpu_id, unsigned long load,
+		     unsigned long curtarg, unsigned long curactual,
+		     unsigned long newtarg),
+	    TP_ARGS(cpu_id, load, curtarg, curactual, newtarg)
+);
+
+DEFINE_EVENT(loadeval, cpufreq_interactive_notyet,
+	    TP_PROTO(unsigned long cpu_id, unsigned long load,
+		     unsigned long curtarg, unsigned long curactual,
+		     unsigned long newtarg),
+	    TP_ARGS(cpu_id, load, curtarg, curactual, newtarg)
+);
+
+TRACE_EVENT(cpufreq_interactive_boost,
+	    TP_PROTO(const char *s),
+	    TP_ARGS(s),
+	    TP_STRUCT__entry(
+		    __string(s, s)
+	    ),
+	    TP_fast_assign(
+		    __assign_str(s, s);
+	    ),
+	    TP_printk("%s", __get_str(s))
+);
+
+TRACE_EVENT(cpufreq_interactive_unboost,
+	    TP_PROTO(const char *s),
+	    TP_ARGS(s),
+	    TP_STRUCT__entry(
+		    __string(s, s)
+	    ),
+	    TP_fast_assign(
+		    __assign_str(s, s);
+	    ),
+	    TP_printk("%s", __get_str(s))
+);
+
+#endif /* _TRACE_CPUFREQ_INTERACTIVE_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/events/gpu.h b/include/trace/events/gpu.h
new file mode 100644
index 0000000..7e15cdf
--- /dev/null
+++ b/include/trace/events/gpu.h
@@ -0,0 +1,143 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM gpu
+
+#if !defined(_TRACE_GPU_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_GPU_H
+
+#include <linux/tracepoint.h>
+#include <linux/time.h>
+
+#define show_secs_from_ns(ns) \
+	({ \
+		u64 t = ns + (NSEC_PER_USEC / 2); \
+		do_div(t, NSEC_PER_SEC); \
+		t; \
+	})
+
+#define show_usecs_from_ns(ns) \
+	({ \
+		u64 t = ns + (NSEC_PER_USEC / 2) ; \
+		u32 rem; \
+		do_div(t, NSEC_PER_USEC); \
+		rem = do_div(t, USEC_PER_SEC); \
+	})
+
+/*
+ * The gpu_sched_switch event indicates that a switch from one GPU context to
+ * another occurred on one of the GPU hardware blocks.
+ *
+ * The gpu_name argument identifies the GPU hardware block.  Each independently
+ * scheduled GPU hardware block should have a different name.  This may be used
+ * in different ways for different GPUs.  For example, if a GPU includes
+ * multiple processing cores it may use names "GPU 0", "GPU 1", etc.  If a GPU
+ * includes a separately scheduled 2D and 3D hardware block, it might use the
+ * names "2D" and "3D".
+ *
+ * The timestamp argument is the timestamp at which the switch occurred on the
+ * GPU. These timestamps are in units of nanoseconds and must use
+ * approximately the same time as sched_clock, though they need not come from
+ * any CPU clock. The timestamps for a single hardware block must be
+ * monotonically nondecreasing.  This means that if a variable compensation
+ * offset is used to translate from some other clock to the sched_clock, then
+ * care must be taken when increasing that offset, and doing so may result in
+ * multiple events with the same timestamp.
+ *
+ * The next_ctx_id argument identifies the next context that was running on
+ * the GPU hardware block.  A value of 0 indicates that the hardware block
+ * will be idle.
+ *
+ * The next_prio argument indicates the priority of the next context at the
+ * time of the event.  The exact numeric values may mean different things for
+ * different GPUs, but they should follow the rule that lower values indicate a
+ * higher priority.
+ *
+ * The next_job_id argument identifies the batch of work that the GPU will be
+ * working on.  This should correspond to a job_id that was previously traced
+ * as a gpu_job_enqueue event when the batch of work was created.
+ */
+TRACE_EVENT(gpu_sched_switch,
+
+	TP_PROTO(const char *gpu_name, u64 timestamp,
+		u32 next_ctx_id, s32 next_prio, u32 next_job_id),
+
+	TP_ARGS(gpu_name, timestamp, next_ctx_id, next_prio, next_job_id),
+
+	TP_STRUCT__entry(
+		__string(       gpu_name,       gpu_name        )
+		__field(        u64,            timestamp       )
+		__field(        u32,            next_ctx_id     )
+		__field(        s32,            next_prio       )
+		__field(        u32,            next_job_id     )
+	),
+
+	TP_fast_assign(
+		__assign_str(gpu_name, gpu_name);
+		__entry->timestamp = timestamp;
+		__entry->next_ctx_id = next_ctx_id;
+		__entry->next_prio = next_prio;
+		__entry->next_job_id = next_job_id;
+	),
+
+	TP_printk("gpu_name=%s ts=%llu.%06lu next_ctx_id=%lu next_prio=%ld "
+		"next_job_id=%lu",
+		__get_str(gpu_name),
+		(unsigned long long)show_secs_from_ns(__entry->timestamp),
+		(unsigned long)show_usecs_from_ns(__entry->timestamp),
+		(unsigned long)__entry->next_ctx_id,
+		(long)__entry->next_prio,
+		(unsigned long)__entry->next_job_id)
+);
+
+/*
+ * The gpu_job_enqueue event indicates that a batch of work has been queued up
+ * to be processed by the GPU.  This event is not intended to indicate that
+ * the batch of work has been submitted to the GPU hardware, but rather that
+ * it has been submitted to the GPU kernel driver.
+ *
+ * This event should be traced on the thread that initiated the work being
+ * queued.  For example, if a batch of work is submitted to the kernel by a
+ * userland thread, the event should be traced on that thread.
+ *
+ * The ctx_id field identifies the GPU context in which the batch of work
+ * being queued is to be run.
+ *
+ * The job_id field identifies the batch of work being queued within the given
+ * GPU context.  The first batch of work submitted for a given GPU context
+ * should have a job_id of 0, and each subsequent batch of work should
+ * increment the job_id by 1.
+ *
+ * The type field identifies the type of the job being enqueued.  The job
+ * types may be different for different GPU hardware.  For example, a GPU may
+ * differentiate between "2D", "3D", and "compute" jobs.
+ */
+TRACE_EVENT(gpu_job_enqueue,
+
+	TP_PROTO(u32 ctx_id, u32 job_id, const char *type),
+
+	TP_ARGS(ctx_id, job_id, type),
+
+	TP_STRUCT__entry(
+		__field(        u32,            ctx_id          )
+		__field(        u32,            job_id          )
+		__string(       type,           type            )
+	),
+
+	TP_fast_assign(
+		__entry->ctx_id = ctx_id;
+		__entry->job_id = job_id;
+		__assign_str(type, type);
+	),
+
+	TP_printk("ctx_id=%lu job_id=%lu type=%s",
+		(unsigned long)__entry->ctx_id,
+		(unsigned long)__entry->job_id,
+		__get_str(type))
+);
+
+#undef show_secs_from_ns
+#undef show_usecs_from_ns
+
+#endif /* _TRACE_GPU_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/events/power.h b/include/trace/events/power.h
index cae9a94..243c677 100644
--- a/include/trace/events/power.h
+++ b/include/trace/events/power.h
@@ -65,6 +65,40 @@ TRACE_EVENT(machine_suspend,
 	TP_printk("state=%lu", (unsigned long)__entry->state)
 );
 
+DECLARE_EVENT_CLASS(wakeup_source,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state),
+
+	TP_STRUCT__entry(
+		__string(       name,           name            )
+		__field(        u64,            state           )
+	),
+
+	TP_fast_assign(
+		__assign_str(name, name);
+		__entry->state = state;
+	),
+
+	TP_printk("%s state=0x%lx", __get_str(name),
+		(unsigned long)__entry->state)
+);
+
+DEFINE_EVENT(wakeup_source, wakeup_source_activate,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state)
+);
+
+DEFINE_EVENT(wakeup_source, wakeup_source_deactivate,
+
+	TP_PROTO(const char *name, unsigned int state),
+
+	TP_ARGS(name, state)
+);
+
 #ifdef CONFIG_EVENT_POWER_TRACING_DEPRECATED
 
 /*
@@ -204,6 +238,25 @@ DEFINE_EVENT(clock, clock_set_rate,
 	TP_ARGS(name, state, cpu_id)
 );
 
+TRACE_EVENT(clock_set_parent,
+
+	TP_PROTO(const char *name, const char *parent_name),
+
+	TP_ARGS(name, parent_name),
+
+	TP_STRUCT__entry(
+		__string(       name,           name            )
+		__string(       parent_name,    parent_name     )
+	),
+
+	TP_fast_assign(
+		__assign_str(name, name);
+		__assign_str(parent_name, parent_name);
+	),
+
+	TP_printk("%s parent=%s", __get_str(name), __get_str(parent_name))
+);
+
 /*
  * The power domain events are used for power domains transitions
  */
diff --git a/include/trace/events/sync.h b/include/trace/events/sync.h
new file mode 100644
index 0000000..f31bc63
--- /dev/null
+++ b/include/trace/events/sync.h
@@ -0,0 +1,82 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM sync
+
+#if !defined(_TRACE_SYNC_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_SYNC_H
+
+#include <linux/sync.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(sync_timeline,
+	    TP_PROTO(struct sync_timeline *timeline),
+
+	    TP_ARGS(timeline),
+
+	    TP_STRUCT__entry(
+		    __string(name, timeline->name)
+		    __array(char, value, 32)
+		    ),
+
+	    TP_fast_assign(
+		    __assign_str(name, timeline->name);
+		    if (timeline->ops->timeline_value_str) {
+			    timeline->ops->timeline_value_str(timeline,
+							      __entry->value,
+							      sizeof(__entry->value));
+		    } else {
+			    __entry->value[0] = '\0';
+		    }
+		    ),
+
+	    TP_printk("name=%s value=%s", __get_str(name), __entry->value)
+);
+
+TRACE_EVENT(sync_wait,
+	    TP_PROTO(struct sync_fence *fence, int begin),
+
+	    TP_ARGS(fence, begin),
+
+	    TP_STRUCT__entry(
+		    __string(name, fence->name)
+		    __field(s32, status)
+		    __field(u32, begin)
+		    ),
+
+	    TP_fast_assign(
+		    __assign_str(name, fence->name);
+		    __entry->status = fence->status;
+		    __entry->begin = begin;
+		    ),
+
+	    TP_printk("%s name=%s state=%d", __entry->begin ? "begin" : "end",
+		      __get_str(name), __entry->status)
+);
+
+TRACE_EVENT(sync_pt,
+	    TP_PROTO(struct sync_pt *pt),
+
+	    TP_ARGS(pt),
+
+	    TP_STRUCT__entry(
+		    __string(timeline, pt->parent->name)
+		    __array(char, value, 32)
+		    ),
+
+	    TP_fast_assign(
+		    __assign_str(timeline, pt->parent->name);
+		    if (pt->parent->ops->pt_value_str) {
+			    pt->parent->ops->pt_value_str(pt,
+							__entry->value,
+							sizeof(__entry->value));
+		    } else {
+			    __entry->value[0] = '\0';
+		    }
+		    ),
+
+	    TP_printk("name=%s value=%s", __get_str(timeline), __entry->value)
+	);
+
+#endif /* if !defined(_TRACE_SYNC_H) || defined(TRACE_HEADER_MULTI_READ) */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/video/sunxi_disp_ioctl.h b/include/video/sunxi_disp_ioctl.h
new file mode 100644
index 0000000..5ba03b2
--- /dev/null
+++ b/include/video/sunxi_disp_ioctl.h
@@ -0,0 +1,882 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SUNXI_DISP_IOCTL_H__
+#define __SUNXI_DISP_IOCTL_H__
+
+#define __bool signed char
+
+/* for tracking the ioctls API/ABI */
+#define SUNXI_DISP_VERSION_MAJOR 1
+#define SUNXI_DISP_VERSION_MINOR 0
+
+#define SUNXI_DISP_VERSION ((SUNXI_DISP_VERSION_MAJOR << 16) | SUNXI_DISP_VERSION_MINOR)
+#define SUNXI_DISP_VERSION_MAJOR_GET(x) (((x) >> 16) & 0x7FFF)
+#define SUNXI_DISP_VERSION_MINOR_GET(x) ((x) & 0xFFFF)
+
+typedef struct {
+	__u8 alpha;
+	__u8 red;
+	__u8 green;
+	__u8 blue;
+} __disp_color_t;
+typedef struct {
+	__s32 x;
+	__s32 y;
+	__u32 width;
+	__u32 height;
+} __disp_rect_t;
+typedef struct {
+	__u32 width;
+	__u32 height;
+} __disp_rectsz_t;
+typedef struct {
+	__s32 x;
+	__s32 y;
+} __disp_pos_t;
+
+typedef enum {
+	DISP_FORMAT_1BPP = 0x0,
+	DISP_FORMAT_2BPP = 0x1,
+	DISP_FORMAT_4BPP = 0x2,
+	DISP_FORMAT_8BPP = 0x3,
+	DISP_FORMAT_RGB655 = 0x4,
+	DISP_FORMAT_RGB565 = 0x5,
+	DISP_FORMAT_RGB556 = 0x6,
+	DISP_FORMAT_ARGB1555 = 0x7,
+	DISP_FORMAT_RGBA5551 = 0x8,
+	DISP_FORMAT_ARGB888 = 0x9, /* alpha padding to 0xff */
+	DISP_FORMAT_ARGB8888 = 0xa,
+	DISP_FORMAT_RGB888 = 0xb,
+	DISP_FORMAT_ARGB4444 = 0xc,
+
+	DISP_FORMAT_YUV444 = 0x10,
+	DISP_FORMAT_YUV422 = 0x11,
+	DISP_FORMAT_YUV420 = 0x12,
+	DISP_FORMAT_YUV411 = 0x13,
+	DISP_FORMAT_CSIRGB = 0x14,
+} __disp_pixel_fmt_t;
+
+typedef enum {
+	/* interleaved,1 address */
+	DISP_MOD_INTERLEAVED = 0x1,
+	/*
+	 * No macroblock plane mode, 3 address, RGB/YUV each channel were stored
+	 */
+	DISP_MOD_NON_MB_PLANAR = 0x0,
+	/* No macroblock UV packaged mode, 2 address, Y and UV were stored */
+	DISP_MOD_NON_MB_UV_COMBINED = 0x2,
+	/* Macroblock plane mode, 3 address,RGB/YUV each channel were stored */
+	DISP_MOD_MB_PLANAR = 0x4,
+	/* Macroblock UV packaged mode, 2 address, Y and UV were stored */
+	DISP_MOD_MB_UV_COMBINED = 0x6,
+} __disp_pixel_mod_t;
+
+typedef enum {
+	/* for interleave argb8888 */
+	DISP_SEQ_ARGB = 0x0,	/* A at a high level */
+	DISP_SEQ_BGRA = 0x2,
+
+	/* for interleaved yuv422 */
+	DISP_SEQ_UYVY = 0x3,
+	DISP_SEQ_YUYV = 0x4,
+	DISP_SEQ_VYUY = 0x5,
+	DISP_SEQ_YVYU = 0x6,
+
+	/* for interleaved yuv444 */
+	DISP_SEQ_AYUV = 0x7,
+	DISP_SEQ_VUYA = 0x8,
+
+	/* for uv_combined yuv420 */
+	DISP_SEQ_UVUV = 0x9,
+	DISP_SEQ_VUVU = 0xa,
+
+	/* for 16bpp rgb */
+	DISP_SEQ_P10 = 0xd,	/* p1 high */
+	DISP_SEQ_P01 = 0xe,	/* p0 high */
+
+	/* for planar format or 8bpp rgb */
+	DISP_SEQ_P3210 = 0xf,	/* p3 high */
+	DISP_SEQ_P0123 = 0x10,	/* p0 high */
+
+	/* for 4bpp rgb */
+	DISP_SEQ_P76543210 = 0x11,
+	DISP_SEQ_P67452301 = 0x12,
+	DISP_SEQ_P10325476 = 0x13,
+	DISP_SEQ_P01234567 = 0x14,
+
+	/* for 2bpp rgb */
+	/* 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 */
+	DISP_SEQ_2BPP_BIG_BIG = 0x15,
+	/* 12,13,14,15,8,9,10,11,4,5,6,7,0,1,2,3 */
+	DISP_SEQ_2BPP_BIG_LITTER = 0x16,
+	/* 3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12 */
+	DISP_SEQ_2BPP_LITTER_BIG = 0x17,
+	/* 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 */
+	DISP_SEQ_2BPP_LITTER_LITTER = 0x18,
+
+	/* for 1bpp rgb */
+	/*
+	 * 31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,
+	 * 15,14,13,12,11,10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+	 */
+	DISP_SEQ_1BPP_BIG_BIG = 0x19,
+	/*
+	 * 24,25,26,27,28,29,30,31,16,17,18,19,20,21,22,23,
+	 *  8, 9,10,11,12,13,14,15, 0, 1, 2, 3, 4, 5, 6, 7
+	 */
+	DISP_SEQ_1BPP_BIG_LITTER = 0x1a,
+	/*
+	 *  7, 6, 5, 4, 3, 2, 1, 0,15,14,13,12,11,10, 9, 8,
+	 * 23,22,21,20,19,18,17,16,31,30,29,28,27,26,25,24
+	 */
+	DISP_SEQ_1BPP_LITTER_BIG = 0x1b,
+	/*
+	 *  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
+	 * 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
+	 */
+	DISP_SEQ_1BPP_LITTER_LITTER = 0x1c,
+} __disp_pixel_seq_t;
+
+typedef enum {
+	DISP_3D_SRC_MODE_TB = 0x0, /* top bottom */
+	DISP_3D_SRC_MODE_FP = 0x1, /* frame packing */
+	DISP_3D_SRC_MODE_SSF = 0x2, /* side by side full */
+	DISP_3D_SRC_MODE_SSH = 0x3, /* side by side half */
+	DISP_3D_SRC_MODE_LI = 0x4, /* line interleaved */
+} __disp_3d_src_mode_t;
+
+typedef enum {
+	DISP_3D_OUT_MODE_CI_1 = 0x5, /* column interlaved 1 */
+	DISP_3D_OUT_MODE_CI_2 = 0x6, /* column interlaved 2 */
+	DISP_3D_OUT_MODE_CI_3 = 0x7, /* column interlaved 3 */
+	DISP_3D_OUT_MODE_CI_4 = 0x8, /* column interlaved 4 */
+	DISP_3D_OUT_MODE_LIRGB = 0x9, /* line interleaved rgb */
+
+	DISP_3D_OUT_MODE_TB = 0x0, /* top bottom */
+	DISP_3D_OUT_MODE_FP = 0x1, /* frame packing */
+	DISP_3D_OUT_MODE_SSF = 0x2, /* side by side full */
+	DISP_3D_OUT_MODE_SSH = 0x3, /* side by side half */
+	DISP_3D_OUT_MODE_LI = 0x4, /* line interleaved */
+	DISP_3D_OUT_MODE_FA = 0xa, /* field alternative */
+} __disp_3d_out_mode_t;
+
+typedef enum {
+	DISP_BT601 = 0,
+	DISP_BT709 = 1,
+	DISP_YCC = 2,
+	DISP_VXYCC = 3,
+} __disp_cs_mode_t;
+
+typedef enum {
+	DISP_COLOR_RANGE_16_255 = 0,
+	DISP_COLOR_RANGE_0_255 = 1,
+	DISP_COLOR_RANGE_16_235 = 2,
+} __disp_color_range_t;
+
+typedef enum {
+	DISP_OUTPUT_TYPE_NONE = 0,
+	DISP_OUTPUT_TYPE_LCD = 1,
+	DISP_OUTPUT_TYPE_TV = 2,
+	DISP_OUTPUT_TYPE_HDMI = 4,
+	DISP_OUTPUT_TYPE_VGA = 8,
+} __disp_output_type_t;
+
+typedef enum {
+	DISP_TV_NONE = 0,
+	DISP_TV_CVBS = 1,
+	DISP_TV_YPBPR = 2,
+	DISP_TV_SVIDEO = 4,
+} __disp_tv_output_t;
+
+typedef enum {
+	DISP_TV_MOD_480I = 0,
+	DISP_TV_MOD_576I = 1,
+	DISP_TV_MOD_480P = 2,
+	DISP_TV_MOD_576P = 3,
+	DISP_TV_MOD_720P_50HZ = 4,
+	DISP_TV_MOD_720P_60HZ = 5,
+	DISP_TV_MOD_1080I_50HZ = 6,
+	DISP_TV_MOD_1080I_60HZ = 7,
+	DISP_TV_MOD_1080P_24HZ = 8,
+	DISP_TV_MOD_1080P_50HZ = 9,
+	DISP_TV_MOD_1080P_60HZ = 0xa,
+	DISP_TV_MOD_1080P_24HZ_3D_FP = 0x17,
+	DISP_TV_MOD_720P_50HZ_3D_FP = 0x18,
+	DISP_TV_MOD_720P_60HZ_3D_FP = 0x19,
+	DISP_TV_MOD_PAL = 0xb,
+	DISP_TV_MOD_PAL_SVIDEO = 0xc,
+	DISP_TV_MOD_NTSC = 0xe,
+	DISP_TV_MOD_NTSC_SVIDEO = 0xf,
+	DISP_TV_MOD_PAL_M = 0x11,
+	DISP_TV_MOD_PAL_M_SVIDEO = 0x12,
+	DISP_TV_MOD_PAL_NC = 0x14,
+	DISP_TV_MOD_PAL_NC_SVIDEO = 0x15,
+
+	DISP_TV_MOD_H1360_V768_60HZ = 0x1a,
+	DISP_TV_MOD_H1280_V1024_60HZ = 0x1b,
+
+	DISP_TV_MODE_NUM = 0x1c,
+
+	/* Reserved, do not use in fex files */
+	DISP_TV_MODE_EDID = 0xff
+} __disp_tv_mode_t;
+
+typedef enum {
+	DISP_TV_DAC_SRC_COMPOSITE = 0,
+	DISP_TV_DAC_SRC_LUMA = 1,
+	DISP_TV_DAC_SRC_CHROMA = 2,
+	DISP_TV_DAC_SRC_Y = 4,
+	DISP_TV_DAC_SRC_PB = 5,
+	DISP_TV_DAC_SRC_PR = 6,
+	DISP_TV_DAC_SRC_NONE = 7,
+} __disp_tv_dac_source;
+
+typedef enum {
+	DISP_VGA_H1680_V1050 = 0,
+	DISP_VGA_H1440_V900 = 1,
+	DISP_VGA_H1360_V768 = 2,
+	DISP_VGA_H1280_V1024 = 3,
+	DISP_VGA_H1024_V768 = 4,
+	DISP_VGA_H800_V600 = 5,
+	DISP_VGA_H640_V480 = 6,
+	DISP_VGA_H1440_V900_RB = 7, /* not support yet */
+	DISP_VGA_H1680_V1050_RB = 8, /* not support yet */
+	DISP_VGA_H1920_V1080_RB = 9,
+	DISP_VGA_H1920_V1080 = 0xa,
+	DISP_VGA_H1280_V720 = 0xb,
+	DISP_VGA_MODE_NUM = 0xc,
+} __disp_vga_mode_t;
+
+typedef enum {
+	DISP_LCDC_SRC_DE_CH1 = 0,
+	DISP_LCDC_SRC_DE_CH2 = 1,
+	DISP_LCDC_SRC_DMA = 2,
+	DISP_LCDC_SRC_WHITE = 3,
+	DISP_LCDC_SRC_BLACK = 4,
+	DISP_LCDC_SRC_BLUT = 5,
+} __disp_lcdc_src_t;
+
+typedef enum {
+	DISP_LAYER_WORK_MODE_NORMAL = 0, /* normal work mode */
+	DISP_LAYER_WORK_MODE_PALETTE = 1, /* palette work mode */
+	/* internal frame buffer work mode */
+	DISP_LAYER_WORK_MODE_INTER_BUF = 2,
+	DISP_LAYER_WORK_MODE_GAMMA = 3, /* gamma correction work mode */
+	DISP_LAYER_WORK_MODE_SCALER = 4, /* scaler work mode */
+} __disp_layer_work_mode_t;
+
+typedef enum {
+	DISP_VIDEO_NATUAL = 0,
+	DISP_VIDEO_SOFT = 1,
+	DISP_VIDEO_VERYSOFT = 2,
+	DISP_VIDEO_SHARP = 3,
+	DISP_VIDEO_VERYSHARP = 4
+} __disp_video_smooth_t;
+
+typedef enum {
+	DISP_HWC_MOD_H32_V32_8BPP = 0,
+	DISP_HWC_MOD_H64_V64_2BPP = 1,
+	DISP_HWC_MOD_H64_V32_4BPP = 2,
+	DISP_HWC_MOD_H32_V64_4BPP = 3,
+} __disp_hwc_mode_t;
+
+typedef enum {
+	DISP_EXIT_MODE_CLEAN_ALL = 0,
+	DISP_EXIT_MODE_CLEAN_PARTLY = 1, /* only clean interrupt temply */
+} __disp_exit_mode_t;
+
+typedef enum { /* only for debug!!! */
+	DISP_REG_SCALER0 = 0,
+	DISP_REG_SCALER1 = 1,
+	DISP_REG_IMAGE0 = 2,
+	DISP_REG_IMAGE1 = 3,
+	DISP_REG_LCDC0 = 4,
+	DISP_REG_LCDC1 = 5,
+	DISP_REG_TVEC0 = 6,
+	DISP_REG_TVEC1 = 7,
+	DISP_REG_CCMU = 8,
+	DISP_REG_PIOC = 9,
+	DISP_REG_PWM = 10,
+} __disp_reg_index_t;
+
+typedef struct {
+	/*
+	 * The way these are treated today, these are physical addresses. Are
+	 * there any actual userspace applications out there that use this?
+	 * -- libv.
+	 */
+	/*
+	 * the contents of the frame buffer address for rgb type only addr[0]
+	 * valid
+	 */
+	__u32 addr[3];
+	__disp_rectsz_t size; /* unit is pixel */
+	__disp_pixel_fmt_t format;
+	__disp_pixel_seq_t seq;
+	__disp_pixel_mod_t mode;
+	/*
+	 * blue red color swap flag, FALSE:RGB; TRUE:BGR,only used in rgb format
+	 */
+	__bool br_swap;
+	__disp_cs_mode_t cs_mode; /* color space */
+	__bool b_trd_src; /* if 3d source, used for scaler mode layer */
+	/* source 3d mode, used for scaler mode layer */
+	__disp_3d_src_mode_t trd_mode;
+	__u32 trd_right_addr[3]; /* used when in frame packing 3d mode */
+} __disp_fb_t;
+
+typedef struct {
+	__disp_layer_work_mode_t mode; /* layer work mode */
+	__bool b_from_screen;
+	 /*
+	  * layer pipe,0/1,if in scaler mode, scaler0 must be pipe0,
+	  * scaler1 must be pipe1
+	  */
+	__u8 pipe;
+	/*
+	 * layer priority,can get layer prio,but never set layer prio.
+	 * From bottom to top, priority from low to high
+	 */
+	__u8 prio;
+	__bool alpha_en; /* layer global alpha enable */
+	__u16 alpha_val; /* layer global alpha value */
+	__bool ck_enable; /* layer color key enable */
+	/*  framebuffer source window,only care x,y if is not scaler mode */
+	__disp_rect_t src_win;
+	__disp_rect_t scn_win; /* screen window */
+	__disp_fb_t fb; /* framebuffer */
+	__bool b_trd_out; /* if output 3d mode, used for scaler mode layer */
+	/* output 3d mode, used for scaler mode layer */
+	__disp_3d_out_mode_t out_trd_mode;
+} __disp_layer_info_t;
+
+typedef struct {
+	__disp_color_t ck_max;
+	__disp_color_t ck_min;
+	/*
+	 * 0/1:always match;
+	 * 2:match if min<=color<=max;
+	 * 3:match if color>max or color<min
+	 */
+	__u32 red_match_rule;
+	__u32 green_match_rule;
+	__u32 blue_match_rule;
+} __disp_colorkey_t;
+
+typedef struct {
+	__s32 id;
+	__u32 addr[3];
+	__u32 addr_right[3]; /* used when in frame packing 3d mode */
+	__bool interlace;
+	__bool top_field_first;
+	__u32 frame_rate; /*  *FRAME_RATE_BASE(now scheduled for 1000) */
+	__u32 flag_addr; /* dit maf flag address */
+	__u32 flag_stride; /* dit maf flag line stride */
+	__bool maf_valid;
+	__bool pre_frame_valid;
+} __disp_video_fb_t;
+
+typedef struct {
+	__bool maf_enable;
+	__bool pre_frame_enable;
+} __disp_dit_info_t;
+
+typedef struct {
+	__disp_hwc_mode_t pat_mode;
+	__u32 addr;
+} __disp_hwc_pattern_t;
+
+typedef struct {
+	__disp_fb_t input_fb;
+	__disp_rect_t source_regn;
+	__disp_fb_t output_fb;
+	// __disp_rect_t   out_regn;
+} __disp_scaler_para_t;
+
+typedef struct {
+	__disp_fb_t fb;
+	/* source region,only care x,y because of not scaler */
+	__disp_rect_t src_win;
+	__disp_rect_t scn_win; /*  sceen region */
+} __disp_sprite_block_para_t;
+
+typedef struct {
+	/*
+	 * used when the screen is not displaying on any output device
+	 * (lcd/hdmi/vga/tv)
+	 */
+	__disp_rectsz_t screen_size;
+	__disp_fb_t output_fb;
+} __disp_capture_screen_para_t;
+
+struct __disp_video_timing {
+	__s32 VIC;
+	__s32 PCLK;
+	__s32 AVI_PR;
+
+	__s32 INPUTX;
+	__s32 INPUTY;
+	__s32 HT;
+	__s32 HBP;
+	__s32 HFP;
+	__s32 HPSW;
+	__s32 VT;
+	__s32 VBP;
+	__s32 VFP;
+	__s32 VPSW;
+
+	__s32 I;	/* 0: Progressive 1: Interlaced */
+	__s32 HSYNC;	/* 0: Negative 1: Positive */
+	__s32 VSYNC;	/* 0: Negative 1: Positive */
+};
+
+typedef struct {
+	__s32(*hdmi_wait_edid) (void);
+	__s32(*Hdmi_open) (void);
+	__s32(*Hdmi_close) (void);
+	__s32(*hdmi_set_mode) (__disp_tv_mode_t mode);
+	__s32(*hdmi_set_videomode) (const struct __disp_video_timing *mode);
+	__s32(*hdmi_mode_support) (__disp_tv_mode_t mode);
+	__s32(*hdmi_get_video_timing) (__disp_tv_mode_t mode,
+				struct __disp_video_timing *video_timing);
+	__s32(*hdmi_get_HPD_status) (void);
+	__s32(*hdmi_set_pll) (__u32 pll, __u32 clk);
+} __disp_hdmi_func;
+
+typedef struct {
+	__u32 lcd_x;
+	__u32 lcd_y;
+	__u32 lcd_dclk_freq;
+	__u32 lcd_pwm_not_used;
+	__u32 lcd_pwm_ch;
+	__u32 lcd_pwm_freq;
+	__u32 lcd_pwm_pol;
+	__u32 lcd_srgb;
+	__u32 lcd_swap;
+
+	__u32 lcd_if; /* 0:hv(sync+de); 1:8080; 2:ttl; 3:lvds */
+
+	__u32 lcd_uf;
+	__u32 lcd_vt;
+	__u32 lcd_ht;
+	__u32 lcd_vbp;
+	__u32 lcd_hbp;
+
+	__u32 lcd_hv_if;
+	__u32 lcd_hv_smode;
+	__u32 lcd_hv_s888_if;
+	__u32 lcd_hv_syuv_if;
+	__u32 lcd_hv_vspw;
+	__u32 lcd_hv_hspw;
+	__u32 lcd_hv_lde_used;
+	__u32 lcd_hv_lde_iovalue;
+
+	__u32 lcd_ttl_stvh;
+	__u32 lcd_ttl_stvdl;
+	__u32 lcd_ttl_stvdp;
+	__u32 lcd_ttl_ckvt;
+	__u32 lcd_ttl_ckvh;
+	__u32 lcd_ttl_ckvd;
+	__u32 lcd_ttl_oevt;
+	__u32 lcd_ttl_oevh;
+	__u32 lcd_ttl_oevd;
+	__u32 lcd_ttl_sthh;
+	__u32 lcd_ttl_sthd;
+	__u32 lcd_ttl_oehh;
+	__u32 lcd_ttl_oehd;
+	__u32 lcd_ttl_revd;
+	__u32 lcd_ttl_datarate;
+	__u32 lcd_ttl_revsel;
+	__u32 lcd_ttl_datainv_en;
+	__u32 lcd_ttl_datainv_sel;
+
+	__u32 lcd_lvds_ch; /*  0: single channel; 1:dual channel */
+	__u32 lcd_lvds_mode; /*  0:NS mode; 1:JEIDA mode */
+	__u32 lcd_lvds_bitwidth; /*  0:24bit; 1:18bit */
+	__u32 lcd_lvds_io_cross; /*  0:normal; 1:pn cross */
+
+	/*
+	 * 0:18bit;
+	 * 1:16bit mode0;
+	 * 2:16bit mode1;
+	 * 3:16bit mode2;
+	 * 4:16bit mode3;
+	 * 5:9bit;
+	 * 6:8bit 256K;
+	 * 7:8bit 65K
+	 */
+	__u32 lcd_cpu_if;
+	__u32 lcd_cpu_da;
+	__u32 lcd_frm;
+
+	__u32 lcd_io_cfg0;
+	__u32 lcd_io_cfg1;
+	__u32 lcd_io_strength;
+
+	__u32 lcd_gamma_correction_en;
+	__u32 lcd_gamma_tbl[256];
+
+	__u32 lcd_hv_srgb_seq0;
+	__u32 lcd_hv_srgb_seq1;
+	__u32 lcd_hv_syuv_seq;
+	__u32 lcd_hv_syuv_fdly;
+
+	__u32 port_index;
+	__u32 start_delay; /* not need to config for user */
+	__u32 tcon_index; /* not need to config for user */
+} __panel_para_t;
+
+typedef struct {
+	__u32 base_lcdc0;
+	__u32 base_lcdc1;
+	__u32 base_pioc;
+	__u32 base_ccmu;
+	__u32 base_pwm;
+} __reg_bases_t;
+
+typedef void (*LCD_FUNC) (__u32 sel);
+typedef struct lcd_function {
+	LCD_FUNC func;
+	__u32 delay; /* ms */
+} __lcd_function_t;
+
+typedef struct lcd_flow {
+	__lcd_function_t func[5];
+	__u32 func_num;
+} __lcd_flow_t;
+
+typedef struct {
+	void (*cfg_panel_info) (__panel_para_t *info);
+	 __s32(*cfg_open_flow) (__u32 sel);
+	 __s32(*cfg_close_flow) (__u32 sel);
+	 __s32(*lcd_user_defined_func) (__u32 sel, __u32 para1, __u32 para2,
+					__u32 para3);
+} __lcd_panel_fun_t;
+
+typedef struct {
+	__bool enable;
+	__u32 active_state;
+	__u32 duty_ns;
+	__u32 period_ns;
+} __pwm_info_t;
+
+typedef enum {
+	FB_MODE_SCREEN0 = 0,
+	FB_MODE_SCREEN1 = 1,
+	/* two screen, top buffer for screen0, bottom buffer for screen1 */
+	FB_MODE_DUAL_SAME_SCREEN_TB = 2,
+	/* two screen, they have same contents; */
+	FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS = 3,
+} __fb_mode_t;
+
+typedef struct {
+	__fb_mode_t fb_mode;
+	__disp_layer_work_mode_t mode;
+	__u32 buffer_num;
+	__u32 width;
+	__u32 height;
+
+	__u32 output_width; /* used when scaler mode */
+	__u32 output_height; /* used when scaler mode */
+
+	/* used when FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS */
+	__u32 primary_screen_id;
+	__u32 aux_output_width;
+	__u32 aux_output_height;
+
+	/* maybe not used anymore */
+	__u32 line_length; /* in byte unit */
+	__u32 smem_len;
+	__u32 ch1_offset; /* use when PLANAR or UV_COMBINED mode */
+	__u32 ch2_offset; /* use when PLANAR mode */
+} __disp_fb_create_para_t;
+
+typedef enum {
+	DISP_INIT_MODE_SCREEN0 = 0, /* fb0 for screen0 */
+	DISP_INIT_MODE_SCREEN1 = 1, /* fb0 for screen1 */
+	/* fb0 for screen0 and fb1 for screen1 */
+	DISP_INIT_MODE_TWO_DIFF_SCREEN = 2,
+	/* fb0(up buffer for screen0, down buffer for screen1) */
+	DISP_INIT_MODE_TWO_SAME_SCREEN = 3,
+	/*
+	 * fb0 for two different screen(screen0 layer is normal layer,
+	 * screen1 layer is scaler layer);
+	 */
+	DISP_INIT_MODE_TWO_DIFF_SCREEN_SAME_CONTENTS = 4,
+} __disp_init_mode_t;
+
+typedef struct {
+	__bool b_init;
+	/*
+	 * 0:single screen0(fb0);
+	 * 1:single screen1(fb0);
+	 * 2:dual diff screen(fb0, fb1);
+	 * 3:dual same screen(fb0 up and down);
+	 * 4:dual diff screen same contents(fb0)
+	 */
+	__disp_init_mode_t disp_mode;
+
+	/* for screen0 and screen1 */
+	__disp_output_type_t output_type[2];
+	__disp_tv_mode_t tv_mode[2];
+	__disp_vga_mode_t vga_mode[2];
+
+	/* for fb0 and fb1 */
+	__u32 buffer_num[2];
+	__bool scaler_mode[2];
+	__disp_pixel_fmt_t format[2];
+	__disp_pixel_seq_t seq[2];
+	__bool br_swap[2];
+} __disp_init_t;
+
+typedef enum tag_DISP_CMD {
+	/* ----disp global---- */
+	DISP_CMD_VERSION = 0x00,
+	DISP_CMD_RESERVE1 = 0x01,
+	/* fail when the value is 0x02 in linux,why??? */
+	DISP_CMD_SET_BKCOLOR = 0x3f,
+	DISP_CMD_GET_BKCOLOR = 0x03,
+	DISP_CMD_SET_COLORKEY = 0x04,
+	DISP_CMD_GET_COLORKEY = 0x05,
+	DISP_CMD_SET_PALETTE_TBL = 0x06,
+	DISP_CMD_GET_PALETTE_TBL = 0x07,
+	DISP_CMD_SCN_GET_WIDTH = 0x08,
+	DISP_CMD_SCN_GET_HEIGHT = 0x09,
+	DISP_CMD_GET_OUTPUT_TYPE = 0x0a,
+	DISP_CMD_SET_EXIT_MODE = 0x0c,
+	DISP_CMD_SET_GAMMA_TABLE = 0x0d,
+	DISP_CMD_GAMMA_CORRECTION_ON = 0x0e,
+	DISP_CMD_GAMMA_CORRECTION_OFF = 0x0f,
+	DISP_CMD_START_CMD_CACHE = 0x10,
+	DISP_CMD_EXECUTE_CMD_AND_STOP_CACHE = 0x11,
+	DISP_CMD_SET_BRIGHT = 0x12,
+	DISP_CMD_SET_CONTRAST = 0x13,
+	DISP_CMD_SET_SATURATION = 0x14,
+	DISP_CMD_GET_BRIGHT = 0x16,
+	DISP_CMD_GET_CONTRAST = 0x17,
+	DISP_CMD_GET_SATURATION = 0x18,
+	DISP_CMD_ENHANCE_ON = 0x1a,
+	DISP_CMD_ENHANCE_OFF = 0x1b,
+	DISP_CMD_GET_ENHANCE_EN = 0x1c,
+	DISP_CMD_CLK_ON = 0x1d,
+	DISP_CMD_CLK_OFF = 0x1e,
+	/*
+	 * when the screen is not used to display(lcd/tv/vga/hdmi) directly,
+	 * maybe capture the screen and scaler to dram, or as a layer of
+	 * another screen
+	 */
+	DISP_CMD_SET_SCREEN_SIZE = 0x1f,
+	DISP_CMD_CAPTURE_SCREEN = 0x20,	/* caputre screen and scaler to dram */
+	DISP_CMD_DE_FLICKER_ON = 0x21,
+	DISP_CMD_DE_FLICKER_OFF = 0x22,
+	DISP_CMD_SET_HUE = 0x23,
+	DISP_CMD_GET_HUE = 0x24,
+	DISP_CMD_DRC_OFF = 0x25,
+	DISP_CMD_GET_DRC_EN = 0x26,
+	DISP_CMD_DE_FLICKER_SET_WINDOW = 0x27,
+	DISP_CMD_DRC_SET_WINDOW = 0x28,
+	DISP_CMD_DRC_ON = 0x29,
+	DISP_CMD_GET_DE_FLICKER_EN = 0x2a,
+
+	/* ----layer---- */
+	DISP_CMD_LAYER_REQUEST = 0x40,
+	DISP_CMD_LAYER_RELEASE = 0x41,
+	DISP_CMD_LAYER_OPEN = 0x42,
+	DISP_CMD_LAYER_CLOSE = 0x43,
+	DISP_CMD_LAYER_SET_FB = 0x44,
+	DISP_CMD_LAYER_GET_FB = 0x45,
+	DISP_CMD_LAYER_SET_SRC_WINDOW = 0x46,
+	DISP_CMD_LAYER_GET_SRC_WINDOW = 0x47,
+	DISP_CMD_LAYER_SET_SCN_WINDOW = 0x48,
+	DISP_CMD_LAYER_GET_SCN_WINDOW = 0x49,
+	DISP_CMD_LAYER_SET_PARA = 0x4a,
+	DISP_CMD_LAYER_GET_PARA = 0x4b,
+	DISP_CMD_LAYER_ALPHA_ON = 0x4c,
+	DISP_CMD_LAYER_ALPHA_OFF = 0x4d,
+	DISP_CMD_LAYER_GET_ALPHA_EN = 0x4e,
+	DISP_CMD_LAYER_SET_ALPHA_VALUE = 0x4f,
+	DISP_CMD_LAYER_GET_ALPHA_VALUE = 0x50,
+	DISP_CMD_LAYER_CK_ON = 0x51,
+	DISP_CMD_LAYER_CK_OFF = 0x52,
+	DISP_CMD_LAYER_GET_CK_EN = 0x53,
+	DISP_CMD_LAYER_SET_PIPE = 0x54,
+	DISP_CMD_LAYER_GET_PIPE = 0x55,
+	DISP_CMD_LAYER_TOP = 0x56,
+	DISP_CMD_LAYER_BOTTOM = 0x57,
+	DISP_CMD_LAYER_GET_PRIO = 0x58,
+	DISP_CMD_LAYER_SET_SMOOTH = 0x59,
+	DISP_CMD_LAYER_GET_SMOOTH = 0x5a,
+	DISP_CMD_LAYER_SET_BRIGHT = 0x5b, /* brightness */
+	DISP_CMD_LAYER_SET_CONTRAST = 0x5c, /* contrast */
+	DISP_CMD_LAYER_SET_SATURATION = 0x5d, /* saturation */
+	DISP_CMD_LAYER_SET_HUE = 0x5e, /* hue, chroma */
+	DISP_CMD_LAYER_GET_BRIGHT = 0x5f,
+	DISP_CMD_LAYER_GET_CONTRAST = 0x60,
+	DISP_CMD_LAYER_GET_SATURATION = 0x61,
+	DISP_CMD_LAYER_GET_HUE = 0x62,
+	DISP_CMD_LAYER_ENHANCE_ON = 0x63,
+	DISP_CMD_LAYER_ENHANCE_OFF = 0x64,
+	DISP_CMD_LAYER_GET_ENHANCE_EN = 0x65,
+	DISP_CMD_LAYER_VPP_ON = 0x67,
+	DISP_CMD_LAYER_VPP_OFF = 0x68,
+	DISP_CMD_LAYER_GET_VPP_EN = 0x69,
+	DISP_CMD_LAYER_SET_LUMA_SHARP_LEVEL = 0x6a,
+	DISP_CMD_LAYER_GET_LUMA_SHARP_LEVEL = 0x6b,
+	DISP_CMD_LAYER_SET_CHROMA_SHARP_LEVEL = 0x6c,
+	DISP_CMD_LAYER_GET_CHROMA_SHARP_LEVEL = 0x6d,
+	DISP_CMD_LAYER_SET_WHITE_EXTEN_LEVEL = 0x6e,
+	DISP_CMD_LAYER_GET_WHITE_EXTEN_LEVEL = 0x6f,
+	DISP_CMD_LAYER_SET_BLACK_EXTEN_LEVEL = 0x70,
+	DISP_CMD_LAYER_GET_BLACK_EXTEN_LEVEL = 0x71,
+
+	/* ----scaler---- */
+	DISP_CMD_SCALER_REQUEST = 0x80,
+	DISP_CMD_SCALER_RELEASE = 0x81,
+	DISP_CMD_SCALER_EXECUTE = 0x82,
+
+	/* ----hwc---- */
+	DISP_CMD_HWC_OPEN = 0xc0,
+	DISP_CMD_HWC_CLOSE = 0xc1,
+	DISP_CMD_HWC_SET_POS = 0xc2,
+	DISP_CMD_HWC_GET_POS = 0xc3,
+	DISP_CMD_HWC_SET_FB = 0xc4,
+	DISP_CMD_HWC_SET_PALETTE_TABLE = 0xc5,
+
+	/* ----video---- */
+	DISP_CMD_VIDEO_START = 0x100,
+	DISP_CMD_VIDEO_STOP = 0x101,
+	DISP_CMD_VIDEO_SET_FB = 0x102,
+	DISP_CMD_VIDEO_GET_FRAME_ID = 0x103,
+	DISP_CMD_VIDEO_GET_DIT_INFO = 0x104,
+
+	/* ----lcd---- */
+	DISP_CMD_LCD_ON = 0x140,
+	DISP_CMD_LCD_OFF = 0x141,
+	DISP_CMD_LCD_SET_BRIGHTNESS = 0x142,
+	DISP_CMD_LCD_GET_BRIGHTNESS = 0x143,
+	DISP_CMD_LCD_CPUIF_XY_SWITCH = 0x146,
+	DISP_CMD_LCD_CHECK_OPEN_FINISH = 0x14a,
+	DISP_CMD_LCD_CHECK_CLOSE_FINISH = 0x14b,
+	DISP_CMD_LCD_SET_SRC = 0x14c,
+	DISP_CMD_LCD_USER_DEFINED_FUNC = 0x14d,
+
+	/* ----tv---- */
+	DISP_CMD_TV_ON = 0x180,
+	DISP_CMD_TV_OFF = 0x181,
+	DISP_CMD_TV_SET_MODE = 0x182,
+	DISP_CMD_TV_GET_MODE = 0x183,
+	DISP_CMD_TV_AUTOCHECK_ON = 0x184,
+	DISP_CMD_TV_AUTOCHECK_OFF = 0x185,
+	DISP_CMD_TV_GET_INTERFACE = 0x186,
+	DISP_CMD_TV_SET_SRC = 0x187,
+	DISP_CMD_TV_GET_DAC_STATUS = 0x188,
+	DISP_CMD_TV_SET_DAC_SOURCE = 0x189,
+	DISP_CMD_TV_GET_DAC_SOURCE = 0x18a,
+
+	/* ----hdmi---- */
+	DISP_CMD_HDMI_ON = 0x1c0,
+	DISP_CMD_HDMI_OFF = 0x1c1,
+	DISP_CMD_HDMI_SET_MODE = 0x1c2,
+	DISP_CMD_HDMI_GET_MODE = 0x1c3,
+	DISP_CMD_HDMI_SUPPORT_MODE = 0x1c4,
+	DISP_CMD_HDMI_GET_HPD_STATUS = 0x1c5,
+	DISP_CMD_HDMI_SET_SRC = 0x1c6,
+
+	/* ----vga---- */
+	DISP_CMD_VGA_ON = 0x200,
+	DISP_CMD_VGA_OFF = 0x201,
+	DISP_CMD_VGA_SET_MODE = 0x202,
+	DISP_CMD_VGA_GET_MODE = 0x203,
+	DISP_CMD_VGA_SET_SRC = 0x204,
+
+	/* ----sprite---- */
+	DISP_CMD_SPRITE_OPEN = 0x240,
+	DISP_CMD_SPRITE_CLOSE = 0x241,
+	DISP_CMD_SPRITE_SET_FORMAT = 0x242,
+	DISP_CMD_SPRITE_GLOBAL_ALPHA_ENABLE = 0x243,
+	DISP_CMD_SPRITE_GLOBAL_ALPHA_DISABLE = 0x244,
+	DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_ENABLE = 0x252,
+	DISP_CMD_SPRITE_SET_GLOBAL_ALPHA_VALUE = 0x245,
+	DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_VALUE = 0x253,
+	DISP_CMD_SPRITE_SET_ORDER = 0x246,
+	DISP_CMD_SPRITE_GET_TOP_BLOCK = 0x250,
+	DISP_CMD_SPRITE_GET_BOTTOM_BLOCK = 0x251,
+	DISP_CMD_SPRITE_SET_PALETTE_TBL = 0x247,
+	DISP_CMD_SPRITE_GET_BLOCK_NUM = 0x259,
+	DISP_CMD_SPRITE_BLOCK_REQUEST = 0x248,
+	DISP_CMD_SPRITE_BLOCK_RELEASE = 0x249,
+	DISP_CMD_SPRITE_BLOCK_OPEN = 0x257,
+	DISP_CMD_SPRITE_BLOCK_CLOSE = 0x258,
+	DISP_CMD_SPRITE_BLOCK_SET_SOURCE_WINDOW = 0x25a,
+	DISP_CMD_SPRITE_BLOCK_GET_SOURCE_WINDOW = 0x25b,
+	DISP_CMD_SPRITE_BLOCK_SET_SCREEN_WINDOW = 0x24a,
+	DISP_CMD_SPRITE_BLOCK_GET_SCREEN_WINDOW = 0x24c,
+	DISP_CMD_SPRITE_BLOCK_SET_FB = 0x24b,
+	DISP_CMD_SPRITE_BLOCK_GET_FB = 0x24d,
+	DISP_CMD_SPRITE_BLOCK_SET_PARA = 0x25c,
+	DISP_CMD_SPRITE_BLOCK_GET_PARA = 0x25d,
+	DISP_CMD_SPRITE_BLOCK_SET_TOP = 0x24e,
+	DISP_CMD_SPRITE_BLOCK_SET_BOTTOM = 0x24f,
+	DISP_CMD_SPRITE_BLOCK_GET_PREV_BLOCK = 0x254,
+	DISP_CMD_SPRITE_BLOCK_GET_NEXT_BLOCK = 0x255,
+	DISP_CMD_SPRITE_BLOCK_GET_PRIO = 0x256,
+
+	/* ----framebuffer---- */
+	DISP_CMD_FB_REQUEST = 0x280,
+	DISP_CMD_FB_RELEASE = 0x281,
+	DISP_CMD_FB_GET_PARA = 0x282,
+	DISP_CMD_GET_DISP_INIT_PARA = 0x283,
+
+	/* ---for Displayer Test -------- */
+	DISP_CMD_MEM_REQUEST = 0x2c0,
+	DISP_CMD_MEM_RELASE = 0x2c1,
+	DISP_CMD_MEM_GETADR = 0x2c2,
+	DISP_CMD_MEM_SELIDX = 0x2c3,
+
+	DISP_CMD_SUSPEND = 0x2d0,
+	DISP_CMD_RESUME = 0x2d1,
+
+	DISP_CMD_PRINT_REG = 0x2e0,
+
+	/* ---pwm -------- */
+	DISP_CMD_PWM_SET_PARA = 0x300,
+	DISP_CMD_PWM_GET_PARA = 0x301,
+} __disp_cmd_t;
+
+#define GET_UMP_SECURE_ID_BUF1 _IOWR('m', 310, unsigned int)
+#define GET_UMP_SECURE_ID_BUF2 _IOWR('m', 311, unsigned int)
+
+#define GET_UMP_SECURE_ID_SUNXI_FB _IOWR('s', 100, unsigned int)
+
+#define FBIOGET_LAYER_HDL_0 0x4700
+#define FBIOGET_LAYER_HDL_1 0x4701
+
+#define FBIO_CLOSE 0x4710
+#define FBIO_OPEN 0x4711
+#define FBIO_ALPHA_ON 0x4712
+#define FBIO_ALPHA_OFF 0x4713
+#define FBIOPUT_ALPHA_VALUE 0x4714
+
+#define FBIO_DISPLAY_SCREEN0_ONLY 0x4720
+#define FBIO_DISPLAY_SCREEN1_ONLY 0x4721
+#define FBIO_DISPLAY_TWO_SAME_SCREEN_TB 0x4722
+#define FBIO_DISPLAY_TWO_DIFF_SCREEN_SAME_CONTENTS 0x4723
+
+#endif /* __SUNXI_DISP_IOCTL_H__ */
