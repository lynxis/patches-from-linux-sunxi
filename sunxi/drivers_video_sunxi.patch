diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index a290be5..df63338 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -23,6 +23,10 @@ source "drivers/gpu/drm/Kconfig"
 
 source "drivers/gpu/stub/Kconfig"
 
+source "drivers/gpu/ion/Kconfig"
+
+source "drivers/gpu/mali/Kconfig"
+
 config VGASTATE
        tristate
        default n
@@ -268,6 +272,42 @@ config FB_GRVGA
 	---help---
 	This enables support for the SVGACTRL framebuffer in the GRLIB IP library from Aeroflex Gaisler.
 
+config FB_SUNXI
+        tristate "DISP Driver Support(sunxi)"
+        depends on FB && (ARCH_SUN4I || ARCH_SUN5I || ARCH_SUN7I)
+	select FB_SUNXI_RESERVED_MEM if MALI
+	select FB_MODE_HELPERS
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+        ---help---
+        default m
+
+config FB_SUNXI_RESERVED_MEM
+	bool "Reserve memory block for sunxi/fb"
+	depends on FB_SUNXI
+	default y
+
+config FB_SUNXI_UMP
+	bool "Enable FB/UMP Integration"
+	depends on MALI && FB_SUNXI
+	default y
+
+config FB_SUNXI_LCD
+        tristate "LCD Driver Support(sunxi)"
+        depends on FB_SUNXI
+        ---help---
+        default m
+
+config FB_SUNXI_HDMI
+        tristate "HDMI Driver Support(sunxi)"
+        depends on FB_SUNXI_LCD
+        ---help---
+        default m
+
+config HDMI_CEC
+	tristate "Consumer Electronics Control (CEC)"
+
 config FB_CIRRUS
 	tristate "Cirrus Logic support"
 	depends on FB && (ZORRO || PCI)
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 9356add..aacc4dc 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -13,6 +13,7 @@ fb-objs                           := $(fb-y)
 
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
+obj-$(CONFIG_HDMI_CEC)		  += hdmi-cec/
 obj-y				  += backlight/
 
 obj-$(CONFIG_EXYNOS_VIDEO)     += exynos/
@@ -30,6 +31,10 @@ obj-$(CONFIG_FB_DDC)           += fb_ddc.o
 obj-$(CONFIG_FB_DEFERRED_IO)   += fb_defio.o
 obj-$(CONFIG_FB_WMT_GE_ROPS)   += wmt_ge_rops.o
 
+obj-$(CONFIG_FB_SUNXI)		+= sunxi/disp/
+obj-$(CONFIG_FB_SUNXI_LCD)	+= sunxi/lcd/
+obj-$(CONFIG_FB_SUNXI_HDMI)	+= sunxi/hdmi/
+
 # Hardware specific drivers go first
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
 obj-$(CONFIG_FB_ARC)              += arcfb.o
diff --git a/drivers/video/hdmi-cec/Makefile b/drivers/video/hdmi-cec/Makefile
new file mode 100644
index 0000000..47e8dce
--- /dev/null
+++ b/drivers/video/hdmi-cec/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_HDMI_CEC) += hdmi-cec.o
+
+hdmi-cec-objs := core.o dev.o #driver.o
+
diff --git a/drivers/video/hdmi-cec/README b/drivers/video/hdmi-cec/README
new file mode 100644
index 0000000..d324e7d
--- /dev/null
+++ b/drivers/video/hdmi-cec/README
@@ -0,0 +1 @@
+This repository contains a proposal for a Linux HDMI-CEC stack.
diff --git a/drivers/video/hdmi-cec/core.c b/drivers/video/hdmi-cec/core.c
new file mode 100644
index 0000000..d9909c0
--- /dev/null
+++ b/drivers/video/hdmi-cec/core.c
@@ -0,0 +1,575 @@
+/*
+ * HDMI Consumer Electronics Control, core module
+ *
+ * Copyright (C) 2011, Florian Fainelli <f.fainelli@gmail.com>
+ *
+ * This file is subject to the GPLv2 licensing terms.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+#include <linux/mutex.h>
+
+#include <linux/hdmi-cec/hdmi-cec.h>
+#include <linux/hdmi-cec/dev.h>
+
+#define PFX	KBUILD_MODNAME ": "
+
+#define CEC_RX_QUEUE_MAX_LEN	(20)
+
+/*
+ * CEC bus
+ */
+static int cec_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	return 0;
+}
+
+static int cec_bus_match(struct device *dev, struct device_driver *driver)
+{
+	/* we have no way of matching a device with a driver yet */
+	return 1;
+}
+
+static struct bus_type cec_bus_type = {
+	.name		= "cec",
+	.match		= cec_bus_match,
+	.uevent		= cec_uevent,
+};
+
+/*
+ * CEC driver
+ */
+static int cec_driver_probe(struct device *dev)
+{
+	struct cec_device *cec_dev = to_cec_device(dev);
+
+	return cec_create_dev_node(cec_dev);
+}
+
+static int cec_driver_remove(struct device *dev)
+{
+	struct cec_driver *drv = to_cec_driver(dev->driver);
+
+	cec_detach_host(drv);
+	cec_flush_queues(drv);
+
+	return 0;
+}
+
+/**
+ * cec_set_logical_address() - sets the cec logical address
+ * @drv:	driver pointer
+ * @addr:	logical address
+ *
+ * calls the driver spefific set_logical_address callback to
+ * set the cec adapter logical address.
+ */
+int cec_set_logical_address(struct cec_driver *drv, const u8 addr)
+{
+	int ret;
+
+	if (addr > CEC_ADDR_MAX)
+		return -EINVAL;
+
+	mutex_lock(&drv->lock);
+	ret = drv->ops->set_logical_address(drv, addr);
+	mutex_unlock(&drv->lock);
+
+	return ret;
+}
+
+/**
+ *  __cec_rx_queue_len() - returns the lenght of a cec driver rx queue
+ * @drv:	driver pointer
+ */
+unsigned __cec_rx_queue_len(struct cec_driver *drv)
+{
+	unsigned qlen;
+
+	mutex_lock(&drv->rx_msg_list_lock);
+	qlen = drv->rx_msg_len;
+	mutex_unlock(&drv->rx_msg_list_lock);
+
+	return qlen;
+}
+
+/**
+ * cec_flush_queues() - flushes a cec driver rx queue
+ * @drv:	driver pointer
+ */
+void cec_flush_queues(struct cec_driver *drv)
+{
+	struct cec_kmsg *cur, *next;
+
+	mutex_lock(&drv->lock);
+
+	cancel_work_sync(&drv->tx_work);
+	list_for_each_entry_safe(cur, next, &drv->rx_msg_list, next) {
+		list_del(&cur->next);
+		kfree(cur);
+		drv->rx_msg_len--;
+	}
+
+	mutex_unlock(&drv->lock);
+}
+
+/**
+ * cec_receive_message() - receive a cec message for a given driver
+ * @drv::	driver pointer
+ * @data:	message blob
+ * @len:	message length
+ *
+ * Called by drivers to add a message to the driver's RX queue
+ */
+int cec_receive_message(struct cec_driver *drv, const u8 *data, const u8 len)
+{
+	struct cec_kmsg *kmsg;
+	int ret = 0;
+
+	if (!len || len > CEC_MAX_MSG_LEN)
+		return -EINVAL;
+
+	mutex_lock(&drv->lock);
+	if (!drv->attached) {
+		pr_debug("%s: no client attached, dropping", drv->name);
+		goto out;
+	}
+
+	mutex_lock(&drv->rx_msg_list_lock);
+	if (drv->rx_msg_len >= CEC_RX_QUEUE_MAX_LEN) {
+		pr_debug("%s: queue full!\n", drv->name);
+		ret = -ENOSPC;
+		goto out_unlock;
+	}
+
+	kmsg = list_entry(drv->rx_msg_list.next,
+				struct cec_kmsg,
+				next);
+	if (kmsg->status == CEC_MSG_SENT) {
+		kmsg->status = CEC_MSG_COMPLETED;
+		complete(&kmsg->completion);
+	} else {
+		kmsg = kzalloc(sizeof(*kmsg), GFP_KERNEL);
+		if (!kmsg) {
+			ret = ENOMEM;
+			goto out_unlock;
+		}
+
+		list_add_tail(&kmsg->next, &drv->rx_msg_list);
+		drv->rx_msg_len++;
+	}
+
+	memcpy(kmsg->msg.data, data, len);
+	kmsg->msg.len = len;
+out_unlock:
+	mutex_unlock(&drv->rx_msg_list_lock);
+out:
+	mutex_unlock(&drv->lock);
+
+	/* wake up clients, they can dequeue a buffer now */
+	wake_up_interruptible(&drv->rx_wait);
+
+	return ret;
+}
+EXPORT_SYMBOL(cec_receive_message);
+
+/**
+ * cec_dequeue_message() - dequeue a message from the driver's rx queue
+ * @drv:	driver pointer
+ * @msg:	cec user-space exposed message pointer
+ *
+ * Dequeue a message from the driver's RX queue
+ */
+int cec_dequeue_message(struct cec_driver *drv, struct cec_msg *msg)
+{
+	int ret = 0;
+	struct cec_kmsg *kmsg;
+
+	mutex_lock(&drv->lock);
+	mutex_lock(&drv->rx_msg_list_lock);
+	if (list_empty(&drv->rx_msg_list)) {
+		pr_debug("%s: no message in queue\n", drv->name);
+		ret = -ENOENT;
+		goto out;
+	}
+
+	kmsg = list_entry(drv->rx_msg_list.next,
+				struct cec_kmsg, next);
+	memcpy(msg, &kmsg->msg, sizeof(*msg));
+	list_del(&kmsg->next);
+	kfree(kmsg);
+	drv->rx_msg_len--;
+out:
+	mutex_unlock(&drv->rx_msg_list_lock);
+	mutex_unlock(&drv->lock);
+
+	return ret;
+}
+
+/**
+ * cec_read_message() - reads a cec message from the driver's rx queue
+ * @drv:	driver pointer
+ * @msg:	cec user-space exposed message pointer
+ *
+ * Reads a CEC message from the driver's RX queue in blocking mode with
+ * either a finite or inifinite timeout
+ */
+int cec_read_message(struct cec_driver *drv, struct cec_msg *msg)
+{
+	int ret = 0;
+	struct cec_kmsg *kmsg;
+	unsigned timeout = 1;
+
+	kmsg = kzalloc(sizeof(*kmsg), GFP_KERNEL);
+	if (!kmsg)
+		return -ENOMEM;
+
+	kmsg->msg.timeout = msg->timeout;
+	kmsg->status = CEC_MSG_SENT;
+	init_completion(&kmsg->completion);
+
+	mutex_lock(&drv->rx_msg_list_lock);
+	list_add_tail(&kmsg->next, &drv->rx_msg_list);
+	drv->rx_msg_len++;
+	mutex_unlock(&drv->rx_msg_list_lock);
+
+	/* timeout for a fixed duration or infinite */
+	if (kmsg->msg.timeout > 0)
+		timeout = wait_for_completion_interruptible_timeout(
+						&kmsg->completion,
+						kmsg->msg.timeout * HZ);
+	else
+		wait_for_completion_interruptible(&kmsg->completion);
+
+	if (!__cec_rx_queue_len(drv))
+		ret = -ENOENT;
+	else if (!timeout || kmsg->status != CEC_MSG_COMPLETED)
+		ret = -ETIMEDOUT;
+
+	mutex_lock(&drv->rx_msg_list_lock);
+	/* copy answer back to caller */
+	memcpy(msg, &kmsg->msg, sizeof(*msg));
+	list_del(&kmsg->next);
+	kfree(kmsg);
+	drv->rx_msg_len--;
+	mutex_unlock(&drv->rx_msg_list_lock);
+
+	return ret;
+}
+
+/*
+ * CEC transmit work queue callback
+ */
+static void cec_tx_work(struct work_struct *work)
+{
+	struct cec_driver *drv;
+	struct cec_kmsg *pending;
+
+	drv = container_of(work, struct cec_driver, tx_work);
+
+	mutex_lock(&drv->tx_msg_list_lock);
+	if (list_empty(&drv->tx_msg_list))
+		goto out_exit;
+
+	pending = list_entry(drv->tx_msg_list.next,
+				struct cec_kmsg, next);
+	if (pending->status != CEC_MSG_QUEUED)
+		goto out_exit;
+
+	pending->status = CEC_MSG_SENT;
+	pending->ret = drv->ops->send(drv, pending->msg.data,
+					pending->msg.len);
+	if (!pending->ret)
+		pending->status = CEC_MSG_COMPLETED;
+
+	/* complete the message anyway */
+	complete(&pending->completion);
+
+out_exit:
+	mutex_unlock(&drv->tx_msg_list_lock);
+	return;
+}
+
+/**
+ * cec_send_message() - sends an user fed cec message
+ * @drv:	driver pointer
+ * @msg:	user-exposed cec message pointer
+ *
+ * Send a message using the specific adapter real sending done in workqueue
+ */
+int cec_send_message(struct cec_driver *drv,
+			struct cec_msg *msg)
+{
+	int ret = 0;
+	unsigned int timeout;
+	struct cec_kmsg *kmsg;
+
+	if (!msg->len || msg->len > CEC_MAX_MSG_LEN)
+		return -EINVAL;
+
+	mutex_lock(&drv->lock);
+	kmsg = kzalloc(sizeof(*kmsg), GFP_KERNEL);
+	if (!kmsg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(&kmsg->msg, msg, sizeof(*msg));
+
+	/* specification says there is a maximum 1s desired response time */
+	if (!kmsg->msg.timeout)
+		kmsg->msg.timeout = HZ;
+	init_completion(&kmsg->completion);
+
+	mutex_lock(&drv->tx_msg_list_lock);
+	list_add_tail(&kmsg->next, &drv->tx_msg_list);
+	mutex_unlock(&drv->tx_msg_list_lock);
+
+	/* kick transmission */
+	schedule_work(&drv->tx_work);
+	timeout = wait_for_completion_interruptible_timeout(
+						&kmsg->completion,
+						kmsg->msg.timeout);
+	mutex_lock(&drv->tx_msg_list_lock);
+	if (kmsg->status != CEC_MSG_COMPLETED) {
+		if (!timeout && kmsg->msg.timeout)
+			ret = -ETIMEDOUT;
+		else if (kmsg->msg.timeout)
+			ret = kmsg->ret;
+		else
+			ret = 0;
+	}
+
+	list_del(&kmsg->next);
+	kfree(kmsg);
+	mutex_unlock(&drv->tx_msg_list_lock);
+out:
+	mutex_unlock(&drv->lock);
+
+	return ret;
+}
+
+/**
+ * cec_reset_device() - resets a cec driver
+ * @drv:	driver pointer
+ *
+ * Resets a CEC device to a sane state
+ */
+int cec_reset_device(struct cec_driver *drv)
+{
+	int ret;
+
+	mutex_lock(&drv->lock);
+	cancel_work_sync(&drv->tx_work);
+	ret = drv->ops->reset(drv);
+	mutex_unlock(&drv->lock);
+
+	return ret;
+}
+
+/**
+ * cec_get_counters() - gets counters from a cec driver
+ * @drv:	driver pointer
+ * @cnt:	struct cec_counters pointer
+ *
+ * Get counters from the CEC adapter if supported, driver should advertise
+ * CEC_HW_HAS_COUNTERS flag
+ */
+int cec_get_counters(struct cec_driver *drv, struct cec_counters *cnt)
+{
+	int ret = -ENOTSUPP;
+
+	mutex_lock(&drv->lock);
+	if (drv->flags & CEC_HW_HAS_COUNTERS)
+		ret = drv->ops->get_counters(drv, cnt);
+	mutex_unlock(&drv->lock);
+
+	return ret;
+}
+
+/**
+ * cec_set_rx_mode() - sets the adapter receive mode
+ * @drv:	driver pointer
+ * @mode:	receive mode (accept all, unicast only)
+ *
+ * Set the receive mode filter of the driver
+ */
+int cec_set_rx_mode(struct cec_driver *drv, enum cec_rx_mode mode)
+{
+	int ret;
+
+	if (~drv->flags & CEC_HW_HAS_RX_FILTER)
+		return -ENOTSUPP;
+
+	if (mode >= CEC_RX_MODE_MAX)
+		return -EINVAL;
+
+	mutex_lock(&drv->lock);
+	ret = drv->ops->set_rx_mode(drv, mode);
+	mutex_unlock(&drv->lock);
+
+	return ret;
+}
+
+/**
+ * cec_attach_host - attaches a host to the driver
+ * @drv:	driver pointer
+ *
+ * Attaches the host to the driver. In case the hardware is able
+ * to process CEC messages itself, it should now send them to the
+ * host for processing
+ */
+int cec_attach_host(struct cec_driver *drv)
+{
+	int ret = 0;
+
+	if (drv->attached)
+		return -EBUSY;
+
+	mutex_lock(&drv->lock);
+	if (drv->ops->attach)
+		ret =  drv->ops->attach(drv);
+	if (!ret)
+		drv->attached = true;
+	mutex_unlock(&drv->lock);
+	return ret;
+}
+
+/**
+ * cec_detach_host - detaches a host from the driver
+ * @drv:	driver pointer
+ *
+ * Detaches the host from the driver. In case the hardware is able
+ * to process CEC messages itself, it should now keep the messages for
+ * itself and no longer send them to the host
+ */
+int cec_detach_host(struct cec_driver *drv)
+{
+	mutex_lock(&drv->lock);
+	if (drv->ops->detach)
+		drv->ops->detach(drv);
+	drv->attached = false;
+	mutex_unlock(&drv->lock);
+
+	return 0;
+}
+
+/**
+ * register_cec_driver() - registers a new cec driver
+ * @cec_drv:	cec_driver pointer
+ */
+int register_cec_driver(struct cec_driver *cec_drv)
+{
+	cec_drv->driver.bus = &cec_bus_type;
+	cec_drv->driver.name = cec_drv->name;
+	cec_drv->driver.probe = cec_driver_probe;
+	cec_drv->driver.remove = cec_driver_remove;
+
+	mutex_init(&cec_drv->lock);
+	init_waitqueue_head(&cec_drv->rx_wait);
+
+	mutex_init(&cec_drv->tx_msg_list_lock);
+	INIT_LIST_HEAD(&cec_drv->tx_msg_list);
+	INIT_WORK(&cec_drv->tx_work, cec_tx_work);
+
+	mutex_init(&cec_drv->rx_msg_list_lock);
+	INIT_LIST_HEAD(&cec_drv->rx_msg_list);
+	cec_drv->rx_msg_len = 0;
+
+	return driver_register(&cec_drv->driver);
+}
+EXPORT_SYMBOL(register_cec_driver);
+
+/**
+ * unregister_cec_driver() - unregisters a cec driver
+ * @cec_drv:	cec_driver pointer
+ */
+void unregister_cec_driver(struct cec_driver *cec_drv)
+{
+	driver_unregister(&cec_drv->driver);
+}
+EXPORT_SYMBOL(unregister_cec_driver);
+
+
+/*
+ * CEC device
+ */
+static void cec_device_release(struct device *dev)
+{
+	return;
+}
+
+static unsigned cec_device_count;
+
+/**
+ * register_cec_device() - registers a new cec device
+ * @cec_dev:	cec_device pointer
+ */
+int register_cec_device(struct cec_device *cec_dev)
+{
+	cec_dev->dev.bus = &cec_bus_type;
+	dev_set_name(&cec_dev->dev, "cec%d", cec_device_count++);
+	cec_dev->dev.release = cec_device_release;
+
+	return device_register(&cec_dev->dev);
+}
+EXPORT_SYMBOL(register_cec_device);
+
+/**
+ * unregister_cec_device() - unregister a cec device
+ * @cec_dev:	cec_device pointer
+ */
+void unregister_cec_device(struct cec_device *cec_dev)
+{
+	cec_remove_dev_node(cec_dev);
+	device_unregister(&cec_dev->dev);
+	memset(&cec_dev->dev, 0, sizeof(cec_dev->dev));
+	memset(&cec_dev->cdev, 0, sizeof(cec_dev->cdev));
+	cec_device_count--;
+}
+EXPORT_SYMBOL(unregister_cec_device);
+
+static int __init cec_init(void)
+{
+	int ret;
+
+	ret = bus_register(&cec_bus_type);
+	if (ret) {
+		pr_err(PFX "unable to register cec bus type\n");
+		return ret;
+	}
+
+	ret = cec_dev_init();
+	if (ret) {
+		pr_err(PFX "failed to create devices\n");
+		goto out_bus;
+	}
+
+	pr_info(PFX "bus registered\n");
+
+	return 0;
+
+out_bus:
+	bus_unregister(&cec_bus_type);
+	return ret;
+}
+
+static void __exit cec_exit(void)
+{
+	cec_dev_exit();
+	bus_unregister(&cec_bus_type);
+	printk(KERN_INFO PFX "bus unregistered\n");
+}
+
+module_init(cec_init);
+module_exit(cec_exit);
+
+MODULE_AUTHOR("Florian Fainelli <f.fainelli@gmail.com>");
+MODULE_DESCRIPTION("HDMI CEC core driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/hdmi-cec/dev.c b/drivers/video/hdmi-cec/dev.c
new file mode 100644
index 0000000..a3ba5db
--- /dev/null
+++ b/drivers/video/hdmi-cec/dev.c
@@ -0,0 +1,317 @@
+/*
+ * HDMI CEC character device code
+ *
+ * Copyright (C), 2011 Florian Fainelli <f.fainelli@gmail.com>
+ *
+ * This file is subject to the GPLv2 licensing terms
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/spinlock.h>
+#include <linux/ioctl.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+
+#include <linux/hdmi-cec/hdmi-cec.h>
+#include <linux/hdmi-cec/dev.h>
+
+static unsigned num_cec_devs;
+static int cec_major;
+static struct list_head cec_devs_list;
+static DEFINE_SPINLOCK(cec_devs_list_lock);
+static struct class *cec_class;
+
+static int cec_dev_open(struct inode *i, struct file *f)
+{
+	struct cdev *cdev = i->i_cdev;
+	struct cec_device *cec_dev =
+			container_of(cdev, struct cec_device, cdev);
+	struct cec_driver *driver = to_cec_driver(cec_dev->dev.driver);
+
+	if (f->private_data)
+		return -EBUSY;
+
+	f->private_data = cec_dev;
+
+	return cec_attach_host(driver);
+}
+
+static int cec_dev_close(struct inode *i, struct file *f)
+{
+	struct cdev *cdev = i->i_cdev;
+	struct cec_device *cec_dev =
+			container_of(cdev, struct cec_device, cdev);
+	struct cec_driver *driver = to_cec_driver(cec_dev->dev.driver);
+	int ret;
+
+	ret = cec_detach_host(driver);
+
+	cec_flush_queues(driver);
+
+	f->private_data = NULL;
+
+	return ret;
+}
+
+static long cec_dev_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
+{
+	struct cec_device *cec_dev;
+	struct cec_driver *driver;
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	int val, ret = -EFAULT;
+	struct cec_msg msg;
+	struct cec_counters cnt;
+
+	if (!f->private_data)
+		return -ENODEV;
+
+	cec_dev = f->private_data;
+	driver = to_cec_driver(cec_dev->dev.driver);
+
+	switch (cmd) {
+	case CEC_SET_LOGICAL_ADDRESS:
+		if (get_user(val, p))
+			return -EFAULT;
+
+		ret = cec_set_logical_address(driver, (u8)val);
+		break;
+
+	/* cecd compatibility ioctls, should use poll() + read() */
+	case CEC_SEND_MESSAGE:
+		if (copy_from_user(&msg, argp, sizeof(msg)))
+			return -EFAULT;
+
+		if (!msg.len)
+			return -EINVAL;
+
+		ret = cec_send_message(driver, &msg);
+		break;
+
+	/* cecd compatibility ioctls, should use poll() + read() */
+	case CEC_RECV_MESSAGE:
+		if (copy_from_user(&msg, argp, sizeof(msg)))
+			return -EFAULT;
+
+		if (msg.flags & CEC_MSG_NONBLOCK)
+			ret = cec_dequeue_message(driver, &msg);
+		else
+			ret = cec_read_message(driver, &msg);
+
+		if (ret)
+			return ret;
+
+		if (copy_to_user(argp, &msg, sizeof(msg)))
+			return -EFAULT;
+
+		break;
+
+	case CEC_RESET_DEVICE:
+		ret = cec_reset_device(driver);
+		break;
+
+	case CEC_GET_COUNTERS:
+		memset(&cnt, 0, sizeof(cnt));
+
+		ret = cec_get_counters(driver, &cnt);
+		if (ret)
+			return ret;
+
+		if (copy_to_user(argp, &cnt, sizeof(cnt)))
+			return -EFAULT;
+
+		break;
+
+	case CEC_SET_RX_MODE:
+		if (get_user(val, p))
+			return -EFAULT;
+
+		ret = cec_set_rx_mode(driver, (enum cec_rx_mode)val);
+		break;
+
+	default:
+		dev_err(&cec_dev->dev, "unsupported ioctl: %08x\n", cmd);
+		break;
+	}
+
+	return ret;
+}
+
+static int cec_dev_write(struct file *f, const char __user *buf,
+			size_t count, loff_t *pos)
+{
+	struct cec_device *cec_dev = f->private_data;
+	struct cec_driver *driver = to_cec_driver(cec_dev->dev.driver);
+	struct cec_msg msg;
+	int ret;
+
+	memset(&msg, 0, sizeof(msg));
+
+	if (count > CEC_MAX_MSG_LEN || !count)
+		return -EINVAL;
+
+	if (copy_from_user(&msg.data, buf, count))
+		return -EFAULT;
+
+	msg.len = count;
+
+	ret = cec_send_message(driver, &msg);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static int cec_dev_read(struct file *f, char __user *buf,
+			size_t count, loff_t *pos)
+{
+	struct cec_device *cec_dev = f->private_data;
+	struct cec_driver *driver = to_cec_driver(cec_dev->dev.driver);
+	int ret;
+	struct cec_msg msg;
+
+	ret = wait_event_interruptible(driver->rx_wait,
+					__cec_rx_queue_len(driver) != 0);
+	if (ret)
+		return ret;
+
+	ret = cec_dequeue_message(driver, &msg);
+	if (ret)
+		return ret;
+
+	if (copy_to_user(buf, &msg.data, msg.len))
+		return -EFAULT;
+
+	return msg.len;
+}
+
+static unsigned int cec_dev_poll(struct file *f, poll_table *wait)
+{
+	struct cec_device *cec_dev = f->private_data;
+	struct cec_driver *driver = to_cec_driver(cec_dev->dev.driver);
+
+	if (__cec_rx_queue_len(driver))
+		return POLLIN | POLLRDNORM;
+
+	poll_wait(f, &driver->rx_wait, wait);
+
+	return 0;
+}
+
+static const struct file_operations cec_dev_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.open		= cec_dev_open,
+	.release	= cec_dev_close,
+	.unlocked_ioctl	= cec_dev_ioctl,
+	.read		= cec_dev_read,
+	.write		= cec_dev_write,
+	.poll		= cec_dev_poll,
+};
+
+int cec_create_dev_node(struct cec_device *cec_dev)
+{
+	int ret;
+	dev_t devno;
+
+	devno = MKDEV(cec_major, num_cec_devs);
+
+	cdev_init(&cec_dev->cdev, &cec_dev_fops);
+	cec_dev->cdev.owner = THIS_MODULE;
+	cec_dev->minor = num_cec_devs;
+	cec_dev->major = cec_major;
+
+	ret = cdev_add(&cec_dev->cdev, devno, 1);
+	if (ret) {
+		dev_err(&cec_dev->dev, "failed to add char device\n");
+		return ret;
+	}
+
+	cec_dev->class_dev = device_create(cec_class, NULL, devno,
+						cec_dev, cec_dev->name);
+	if (IS_ERR(cec_dev->class_dev)) {
+		ret = PTR_ERR(cec_dev->class_dev);
+		dev_err(&cec_dev->dev, "failed to create device\n");
+		goto out_err;
+	}
+
+	spin_lock(&cec_devs_list_lock);
+	list_add_tail(&cec_dev->list, &cec_devs_list);
+	num_cec_devs++;
+	spin_unlock(&cec_devs_list_lock);
+
+	return 0;
+
+out_err:
+	cdev_del(&cec_dev->cdev);
+	return ret;
+}
+
+static void cec_remove_one_device(unsigned minor)
+{
+	struct cec_device *cur, *n;
+
+	list_for_each_entry_safe(cur, n, &cec_devs_list, list) {
+		if (cur->minor != minor)
+			continue;
+
+		device_del(cur->class_dev);
+		cdev_del(&cur->cdev);
+		list_del(&cur->list);
+	}
+}
+
+void cec_remove_dev_node(struct cec_device *cec_dev)
+{
+	cec_remove_one_device(cec_dev->minor);
+}
+
+static void cec_cleanup_devs(void)
+{
+	unsigned i;
+
+	for (i = 0; i < num_cec_devs; i++)
+		cec_remove_one_device(i);
+}
+
+int __init cec_dev_init(void)
+{
+	dev_t dev = 0;
+	int ret;
+
+	INIT_LIST_HEAD(&cec_devs_list);
+
+	ret = alloc_chrdev_region(&dev, 0, CEC_MAX_DEVS, "cec");
+	if (ret < 0) {
+		printk(KERN_ERR "alloc_chrdev_region() failed for cec\n");
+		goto out;
+	}
+
+	cec_major = MAJOR(dev);
+
+	cec_class = class_create(THIS_MODULE, "cec");
+	if (IS_ERR(cec_class)) {
+		printk(KERN_ERR "class_create failed\n");
+		ret = PTR_ERR(cec_class);
+		goto out;
+	}
+
+	return 0;
+
+out:
+	unregister_chrdev_region(MKDEV(cec_major, 0), CEC_MAX_DEVS);
+	return ret;
+}
+
+void __exit cec_dev_exit(void)
+{
+	class_unregister(cec_class);
+	cec_cleanup_devs();
+
+	if (cec_major)
+		unregister_chrdev_region(MKDEV(cec_major, 0), CEC_MAX_DEVS);
+}
+
diff --git a/drivers/video/hdmi-cec/driver.c b/drivers/video/hdmi-cec/driver.c
new file mode 100644
index 0000000..71aa3d9
--- /dev/null
+++ b/drivers/video/hdmi-cec/driver.c
@@ -0,0 +1,224 @@
+/*
+ * CEC example driver for demonstrating the use of this HDMI CEC stack
+ * proposal.
+ *
+ * Copyright (C) 2012, Florian Fainelli <f.fainelli@gmail.com>
+ *
+ * Licensed under ther terms of the GPLv2
+ *
+ * This driver assumes we would be writing to some memory-mapped CEC
+ * hardware with the the register mapping described below. Such hardware
+ * would provide some kind of hardware FIFO to transmit the message,
+ * and interrupt us upon reception of a complete CEC frame. It does not
+ * support hardware counters nor detaching from host.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+
+#include "hdmi-cec.h"
+
+#define CEC_EXAMPLE_ADDR_REG	0x00
+#define CEC_EXAMPLE_RST_REG	0x01
+#define CEC_EXAMPLE_RX_MODE_REG	0x02
+#define CEC_EXAMPLE_ATTACH_REG	0x03
+#define CEC_EXAMPLE_ISR_REG	0x04
+#define CEC_EXAMPLE_ISR_TX	(1 << 0) /* interrupt on TX completion */
+#define CEC_EXAMPLE_ISR_RX	(1 << 1) /* interrupt on RX completion */
+#define CEC_EXAMPLE_ISR_MSG_CNT	(1 << 2) /* size of the incoming message */
+#define CEC_EXAMPLE_IM_REG	0x05
+#define CEC_EXAMPLE_FIFO_REG	0x06
+
+struct cec_example_priv {
+	void __iomem		*regs;
+	struct platform_device	*pdev;
+	int			irq;
+	struct cec_driver	cec_drv;
+	struct completion	tx_complete;
+	spinlock_t		lock;
+};
+
+static irqreturn_t cec_example_isr(int irq, void *dev_id)
+{
+	struct cec_example_priv *priv = dev_id;
+	u8 cause;
+	u8 msg[CEC_MAX_MSG_LEN], count;
+
+	/* read cause and mask all other causes */
+	cause = ioread8(priv->regs + CEC_EXAMPLE_IM_REG);
+	iowrite8(0, priv->regs + CEC_EXAMPLE_IM_REG);
+
+	if (cause & CEC_EXAMPLE_ISR_TX)
+		complete(&priv->tx_complete);
+
+	/* we should probably use a bottom-half here, but there is not
+	 * so much work to do */
+	if (cause & CEC_EXAMPLE_ISR_RX) {
+		count = cause >> CEC_EXAMPLE_ISR_MSG_CNT;
+		ioread8_rep(priv->regs + CEC_EXAMPLE_FIFO_REG,
+				msg, count);
+		cec_receive_message(&priv->cec_drv, msg, count);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int cec_example_set_addr(struct cec_driver *drv, const u8 addr)
+{
+	struct cec_example_priv *priv =
+		container_of(drv, struct cec_example_priv, cec_drv);
+
+	iowrite8(addr, priv->regs + CEC_EXAMPLE_ADDR_REG);
+
+	return 0;
+}
+
+static int
+cec_example_send(struct cec_driver *drv, const u8 *data, const u8 len)
+{
+	struct cec_example_priv *priv =
+		container_of(drv, struct cec_example_priv, cec_drv);
+	unsigned int timeout;
+	u8 reg;
+	unsigned long flags;
+
+	init_completion(&priv->tx_complete);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	/* enable TX completion interrupt */
+	reg = ioread8(priv->regs + CEC_EXAMPLE_ISR_REG);
+	reg |=  CEC_EXAMPLE_ISR_TX;
+	iowrite8(reg, priv->regs + CEC_EXAMPLE_ISR_REG);
+
+	/* write to the hardware fifo */
+	iowrite8_rep(priv->regs + CEC_EXAMPLE_FIFO_REG,
+			data, len);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	/* ISR will complete our tx completion */
+	timeout = wait_for_completion_interruptible_timeout(
+				&priv->tx_complete, HZ / 2);
+
+	return !timeout ? -ETIMEDOUT : 0;
+}
+
+static int cec_example_reset(struct cec_driver *drv)
+{
+	struct cec_example_priv *priv =
+		container_of(drv, struct cec_example_priv, cec_drv);
+
+	/* clear all registers */
+	iowrite8_rep(priv->regs, 0, 6 + CEC_MAX_MSG_LEN);
+
+	return 0;
+}
+
+static struct cec_driver_ops cec_example_ops = {
+	.set_logical_address	= cec_example_set_addr,
+	.send			= cec_example_send,
+	.reset			= cec_example_reset,
+};
+
+static int cec_example_probe(struct platform_device *pdev)
+{
+	struct cec_example_priv *priv;
+	struct resource *r;
+	int irq;
+	int ret;
+
+	r = platform_get_resource(pdev, 0, IORESOURCE_MEM);
+	if (!r)
+		return -ENODEV;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0)
+		return -ENODEV;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regs = ioremap(r->start, resource_size(r));
+	if (!priv->regs) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	spin_lock_init(&priv->lock);
+
+	platform_set_drvdata(pdev, priv);
+	priv->irq = irq;
+	priv->pdev = pdev;
+	priv->cec_drv.ops = &cec_example_ops;
+
+	ret = register_cec_driver(&priv->cec_drv);
+	if (ret)
+		goto out_iomem;
+
+	ret = request_irq(irq, cec_example_isr, 0, pdev->name, priv);
+	if (ret)
+		goto out_drv;
+
+	/* enable CEC RX completion (TX enabled later) */
+	iowrite8(CEC_EXAMPLE_ISR_RX, priv->regs + CEC_EXAMPLE_ISR_REG);
+
+	dev_info(&pdev->dev, "CEC example driver registered");
+
+	return 0;
+
+out_drv:
+	unregister_cec_driver(&priv->cec_drv);
+out_iomem:
+	iounmap(priv->regs);
+out:
+	kfree(priv);
+	return ret;
+}
+
+static int cec_example_remove(struct platform_device *pdev)
+{
+	struct cec_example_priv *priv = platform_get_drvdata(pdev);
+
+	/* disable all interrupts */
+	iowrite8(0, priv->regs + CEC_EXAMPLE_ISR_REG);
+	free_irq(priv->irq, priv);
+	unregister_cec_driver(&priv->cec_drv);
+	iounmap(priv->regs);
+	kfree(priv);
+
+	return 0;
+}
+
+static struct platform_driver cec_example_driver = {
+	.driver	= {
+		.name	= "cec-example",
+		.owner	= THIS_MODULE,
+	},
+	.probe	= cec_example_probe,
+	.remove	= __devexit_p(cec_example_remove),
+};
+
+static int __init cec_example_init(void)
+{
+	return platform_driver_register(&cec_example_driver);
+}
+
+static void __exit cec_example_exit(void)
+{
+	platform_driver_unregister(&cec_example_driver);
+}
+
+module_init(cec_example_init);
+module_exit(cec_example_exit);
+
+MODULE_AUTHOR("Florian Fainelli <f.fainelli@gmail.com>");
+MODULE_DESCRIPTION("HDMI-CEC example driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cec-example");
diff --git a/drivers/video/modedb.c b/drivers/video/modedb.c
index a9a907c..33d0f67 100644
--- a/drivers/video/modedb.c
+++ b/drivers/video/modedb.c
@@ -939,6 +939,11 @@ const struct fb_videomode *fb_find_nearest_mode(const struct fb_videomode *mode,
 			if (diff_refresh > d) {
 				diff_refresh = d;
 				best = cmode;
+			} else if (diff_refresh == d &&
+			           (cmode->vmode & FB_VMODE_INTERLACED) ==
+			           (mode->vmode & FB_VMODE_INTERLACED)) {
+			        diff_refresh = d;
+				best = cmode;
 			}
 		}
 	}
diff --git a/drivers/video/sunxi/adb_push.bat b/drivers/video/sunxi/adb_push.bat
new file mode 100644
index 0000000..40ca3cb
--- /dev/null
+++ b/drivers/video/sunxi/adb_push.bat
@@ -0,0 +1,13 @@
+adb devices
+adb shell mount -o remount,rw /dev/block/nandc /system
+adb shell mount -o remount,rw /dev/root /
+adb push disp/disp.ko /drv/disp.ko
+adb shell chmod 777 /drv/disp.ko
+adb push lcd/lcd.ko /drv/lcd.ko
+adb shell chmod 777 /drv/lcd.ko
+adb push hdmi/hdmi.ko /drv/hdmi.ko
+adb shell chmod 777 /drv/hdmi.ko
+adb shell sync
+echo press any key to reboot
+pause
+adb shell reboot
\ No newline at end of file
diff --git a/drivers/video/sunxi/disp/Makefile b/drivers/video/sunxi/disp/Makefile
new file mode 100644
index 0000000..2bdf6c8
--- /dev/null
+++ b/drivers/video/sunxi/disp/Makefile
@@ -0,0 +1,17 @@
+obj-$(CONFIG_FB_SUNXI) += disp.o
+
+disp-objs :=  dev_disp.o dev_fb.o
+
+disp-objs += OSAL_Clock.o OSAL_Pin.o
+
+disp-objs += de_be.o de_fe.o de_hwc.o\
+	de_layer.o de_lcdc.o de_tvec.o\
+	disp_clk.o disp_combined.o disp_de.o disp_display.o\
+	disp_event.o disp_hdmi.o disp_hwc.o disp_layer.o\
+	disp_lcd.o disp_scaler.o disp_sprite.o disp_tv.o\
+	disp_vga.o disp_video.o de_iep.o disp_iep.o
+
+ifeq ($(CONFIG_FB_SUNXI_UMP),y)
+obj-m += disp_ump.o
+ccflags-y += -Idrivers/gpu/mali/ump/include
+endif
diff --git a/drivers/video/sunxi/disp/OSAL_Clock.c b/drivers/video/sunxi/disp/OSAL_Clock.c
new file mode 100644
index 0000000..50aee4b
--- /dev/null
+++ b/drivers/video/sunxi/disp/OSAL_Clock.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "bsp_display.h"
+#include "OSAL_Clock.h"
+
+static char *_sysClkName[AW_SYS_CLK_CNT] = {
+	"none",		/*  0 */
+
+	"losc",		/*  1 */
+	"hosc",		/*  2 */
+
+	"core_pll",	/*  3 */
+	"audio_pll",	/*  4 */
+	"audio_pllx8",	/*  5 */
+	"video_pll0",	/*  6 */
+	"video_pll0x2",	/*  7 */
+	"ve_pll",	/*  8 */
+	"sdram_pll",	/*  9 */
+	"sdram_pll_m",	/* 10 */
+	"sdram_pll_p",	/* 11 */
+	"sata_pll",	/* 12 */
+	"video_pll1",	/* 13 */
+	"video_pll1x2",	/* 14 */
+	"200m_pll",	/* 15 */
+
+	"cpu",		/* 16 */
+	"axi",		/* 17 */
+	"ahb",		/* 18 */
+	"apb",		/* 19 */
+	"apb1",		/* 20 */
+
+	"sata_pll_m",
+	"sata_pll_2",
+};
+
+static char *_modClkName[AW_MOD_CLK_CNT] = {
+	"none",
+
+	"nfc",
+	"msc",
+	"sdc0",
+	"sdc1",
+	"sdc2",
+	"sdc3",
+	"ts",
+	"ss",
+	"spi0",
+	"spi1",
+	"spi2",
+	"pata",
+	"ir0",
+	"ir1",
+	"i2s",
+	"ac97",
+	"spdif",
+	"key_pad",
+	"sata",
+	"usb_phy",
+	"usb_phy0",
+	"usb_phy1",
+	"usb_phy2",
+	"usb_ohci0",
+	"usb_ohci1",
+	"com",
+	"spi3",
+	"de_image0",
+	"de_image1",
+	"de_scale0",
+	"de_scale1",
+	"de_mix",
+	"lcd0_ch0",
+	"lcd1_ch0",
+	"csi_isp",
+	"tvd",
+	"lcd0_ch1_s1",
+	"lcd0_ch1_s2",
+	"lcd1_ch1_s1",
+	"lcd1_ch1_s2",
+	"csi0",
+	"csi1",
+	"ve",
+	"audio_codec",
+	"avs",
+	"ace",
+	"lvds",
+	"hdmi",
+	"mali",
+	"twi0",
+	"twi1",
+	"twi2",
+	"can",
+	"scr",
+	"ps0",
+	"ps1",
+	"uart0",
+	"uart1",
+	"uart2",
+	"uart3",
+	"uart4",
+	"uart5",
+	"uart6",
+	"uart7",
+
+	/* clock gating for hang to AXI bus */
+	"axi_dram",
+
+	/* clock gating for hang to AHB bus */
+	"ahb_usb0",
+	"ahb_usb1",
+	"ahb_usb2",
+	"ahb_ss",
+	"ahb_dma",
+	"ahb_bist",
+	"ahb_sdc0",
+	"ahb_sdc1",
+	"ahb_sdc2",
+	"ahb_sdc3",
+	"ahb_msc",
+	"ahb_nfc",
+	"ahb_sdramc",
+	"ahb_ace",
+	"ahb_emac",
+	"ahb_ts",
+	"ahb_spi0",
+	"ahb_spi1",
+	"ahb_spi2",
+	"ahb_spi3",
+	"ahb_pata",
+	"ahb_sata",
+	"ahb_com",
+	"ahb_ve",
+	"ahb_tvd",
+	"ahb_tve0",
+	"ahb_tve1",
+	"ahb_lcd0",
+	"ahb_lcd1",
+	"ahb_csi0",
+	"ahb_csi1",
+	"ahb_hdmi",
+	"ahb_de_image0",
+	"ahb_de_image1",
+	"ahb_de_scale0",
+	"ahb_de_scale1",
+	"ahb_de_mix",
+	"ahb_mali",
+
+	/* clock gating for hang APB bus */
+	"apb_audio_codec",
+	"apb_spdif",
+	"apb_ac97",
+	"apb_i2s",
+	"apb_pio",
+	"apb_ir0",
+	"apb_ir1",
+	"apb_key_pad",
+	"apb_twi0",
+	"apb_twi1",
+	"apb_twi2",
+	"apb_can",
+	"apb_scr",
+	"apb_ps0",
+	"apb_ps1",
+	"apb_uart0",
+	"apb_uart1",
+	"apb_uart2",
+	"apb_uart3",
+	"apb_uart4",
+	"apb_uart5",
+	"apb_uart6",
+	"apb_uart7",
+
+	/* clock gating for access dram */
+	"sdram_ve",
+	"sdram_csi0",
+	"sdram_csi1",
+	"sdram_ts",
+	"sdram_tvd",
+	"sdram_tve0",
+	"sdram_tve1",
+	"sdram_de_scale0",
+	"sdram_de_scale1",
+	"sdram_de_image0",
+	"sdram_de_image1",
+	"sdram_de_mix",
+	"sdram_ace",
+	"ahb_ehci1",
+	"ahb_ohci1",
+
+#ifdef CONFIG_ARCH_SUN5I
+	"iep",
+	"ahb_iep",
+	"sdram_iep",
+#endif
+};
+
+__s32 OSAL_CCMU_SetSrcFreq(__u32 nSclkNo, __u32 nFreq)
+{
+	struct clk *hSysClk = NULL;
+	s32 retCode = -1;
+
+	hSysClk = clk_get(NULL, _sysClkName[nSclkNo]);
+
+	if (NULL == hSysClk) {
+		__wrn("Fail to get handle for system clock [%d].\n", nSclkNo);
+		return -1;
+	} else
+		__inf("OSAL_CCMU_SetSrcFreq<%s,%d>\n",
+		      clk_name(hSysClk), nFreq);
+
+	if (nFreq == clk_get_rate(hSysClk)) {
+#if 0
+		__inf("Sys clk[%d] freq is alreay %d, not need to set.\n",
+		      nSclkNo, nFreq);
+#endif
+
+		clk_put(hSysClk);
+		return 0;
+	}
+	retCode = clk_set_rate(hSysClk, nFreq);
+	if (retCode == -1) {
+		__wrn("Fail to set nFreq[%d] for sys clk[%d].\n", nFreq,
+		      nSclkNo);
+		clk_put(hSysClk);
+		return retCode;
+	}
+	clk_put(hSysClk);
+	hSysClk = NULL;
+
+	return retCode;
+}
+
+__u32 OSAL_CCMU_GetSrcFreq(__u32 nSclkNo)
+{
+	struct clk *hSysClk = NULL;
+	u32 nFreq = 0;
+
+	hSysClk = clk_get(NULL, _sysClkName[nSclkNo]);
+	if (NULL == hSysClk) {
+		__wrn("Fail to get handle for system clock [%d].\n", nSclkNo);
+		return -1;
+	}
+	nFreq = clk_get_rate(hSysClk);
+	clk_put(hSysClk);
+	hSysClk = NULL;
+
+	return nFreq;
+}
+
+__hdle OSAL_CCMU_OpenMclk(__s32 nMclkNo)
+{
+	struct clk *hModClk = NULL;
+
+	hModClk = clk_get(NULL, _modClkName[nMclkNo]);
+
+	return (__hdle) hModClk;
+}
+
+__s32 OSAL_CCMU_CloseMclk(__hdle hMclk)
+{
+	struct clk *hModClk = (struct clk *)hMclk;
+
+	clk_put(hModClk);
+
+	return 0;
+}
+
+__s32 OSAL_CCMU_SetMclkSrc(__hdle hMclk, __u32 nSclkNo)
+{
+	struct clk *hSysClk = NULL;
+	struct clk *hModClk = (struct clk *)hMclk;
+	s32 retCode = -1;
+
+	hSysClk = clk_get(NULL, _sysClkName[nSclkNo]);
+
+	if (NULL == hSysClk) {
+		__wrn("Fail to get handle for system clock [%d].\n", nSclkNo);
+		return -1;
+	} else
+		__inf("OSAL_CCMU_SetMclkSrc<%s,%s>\n", clk_name(hModClk),
+		      clk_name(hSysClk));
+
+	if (clk_get_parent(hModClk) == hSysClk) {
+		__inf("Parent is alreay %d, not need to set.\n", nSclkNo);
+		clk_put(hSysClk);
+		return 0;
+	}
+	retCode = clk_set_parent(hModClk, hSysClk);
+	if (-1 == retCode) {
+		__wrn("Fail to set parent for clk.\n");
+		clk_put(hSysClk);
+		return -1;
+	}
+
+	clk_put(hSysClk);
+
+	return retCode;
+}
+
+__s32 OSAL_CCMU_SetMclkDiv(__hdle hMclk, __s32 nDiv)
+{
+	struct clk *hModClk = (struct clk *)hMclk;
+	struct clk *hParentClk = clk_get_parent(hModClk);
+	u32 srcRate = clk_get_rate(hParentClk);
+
+	__inf("OSAL_CCMU_SetMclkDiv<p:%s,m:%s,%d>\n", clk_name(hParentClk),
+	      clk_name(hModClk), nDiv);
+
+	if (nDiv == 0)
+		return -1;
+
+	return clk_set_rate(hModClk, srcRate / nDiv);
+}
+
+__s32 OSAL_CCMU_MclkOnOff(__hdle hMclk, __s32 bOnOff)
+{
+	struct clk *hModClk = (struct clk *)hMclk;
+	__s32 ret = 0;
+
+	__inf("OSAL_CCMU_MclkOnOff<%s,%d>\n", clk_name(hModClk), bOnOff);
+
+	if (bOnOff) {
+		if (!hModClk->enable)
+			ret = clk_enable(hModClk);
+	} else {
+		while (hModClk->enable)
+			clk_disable(hModClk);
+	}
+	return ret;
+}
+
+__s32 OSAL_CCMU_MclkReset(__hdle hMclk, __s32 bReset)
+{
+	struct clk *hModClk = (struct clk *)hMclk;
+
+	__inf("OSAL_CCMU_MclkReset<%s,%d>\n", clk_name(hModClk), bReset);
+
+	return clk_reset(hModClk, bReset);
+}
diff --git a/drivers/video/sunxi/disp/OSAL_Clock.h b/drivers/video/sunxi/disp/OSAL_Clock.h
new file mode 100644
index 0000000..f370100
--- /dev/null
+++ b/drivers/video/sunxi/disp/OSAL_Clock.h
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __OSAL_CLOCK_H__
+#define __OSAL_CLOCK_H__
+
+#include "bsp_display.h"
+
+/* The sun7i mach code does not define clock numbers, instead users are
+   supposed to use clock names directly */
+#ifndef CONFIG_ARCH_SUN7I
+#include <mach/aw_ccu.h>
+#else
+/* Note these need to be in sync with the string arrays in OSAL_Clock.c */
+enum {
+	AW_SYS_CLK_NONE,    /* invalid clock id                     */
+
+	AW_SYS_CLK_LOSC,    /* "losc"       ,LOSC, 32768 hz clock   */
+	AW_SYS_CLK_HOSC,    /* "hosc"       ,HOSC, 24Mhz clock      */
+
+	AW_SYS_CLK_PLL1,    /* "core_pll"   ,PLL1 clock             */
+	AW_SYS_CLK_PLL2,    /* "audio_pll"  ,PLL2 clock             */
+	AW_SYS_CLK_PLL2X8,  /* "audio_pllx8"  ,PLL2 8x clock        */
+	AW_SYS_CLK_PLL3,    /* "video_pll0" ,PLL3 clock             */
+	AW_SYS_CLK_PLL3X2,  /* "video_pll0x2" ,PLL3 2x clock        */
+	AW_SYS_CLK_PLL4,    /* "ve_pll"     ,PLL4 clock             */
+	AW_SYS_CLK_PLL5,    /* "sdram_pll"  ,PLL5 clock             */
+	AW_SYS_CLK_PLL5M,   /* "sdram_pll_m",PLL5 M clock           */
+	AW_SYS_CLK_PLL5P,   /* "sdram_pll_p",PLL5 P clock           */
+	AW_SYS_CLK_PLL6,    /* "sata_pll"   ,PLL6 clock, just used
+	                       as source of sata_pll_m and sata_pll_2,
+	                       users should not use this clock dirctly
+	                    */
+	AW_SYS_CLK_PLL7,    /* "video_pll1" ,PLL7 clock             */
+	AW_SYS_CLK_PLL7X2,  /* "video_pll1x2" ,PLL7 2x clock        */
+	AW_SYS_CLK_200M,    /* "200m_pll"   ,200Mhz clock           */
+
+	AW_SYS_CLK_CPU,     /* "cpu"        ,CPU clock              */
+	AW_SYS_CLK_AXI,     /* "axi"        ,AXI clock              */
+	AW_SYS_CLK_AHB,     /* "ahb"        ,AHB clock              */
+	AW_SYS_CLK_APB0,    /* "apb"        ,APB0 clock             */
+	AW_SYS_CLK_APB1,    /* "apb1"       ,APB1 clock             */
+
+	/* add by kevin, 2011-7-21 19:01 */
+	AW_SYS_CLK_PLL6M,   /* "sata_pll_m" ,PLL6 M clock, just for SATA    */
+	AW_SYS_CLK_PLL62,   /* "sata_pll_2" ,PLL6 2 clock, for module       */
+
+	AW_SYS_CLK_CNT      /* invalid id, for calc count           */
+};
+
+enum {
+	AW_MOD_CLK_NONE,        /* invalid clock id */
+
+	AW_MOD_CLK_NFC,         /* "nfc"            */
+	AW_MOD_CLK_MSC,         /* "msc"            */
+	AW_MOD_CLK_SDC0,        /* "sdc0"           */
+	AW_MOD_CLK_SDC1,        /* "sdc1"           */
+	AW_MOD_CLK_SDC2,        /* "sdc2"           */
+	AW_MOD_CLK_SDC3,        /* "sdc3"           */
+	AW_MOD_CLK_TS,          /* "ts"             */
+	AW_MOD_CLK_SS,          /* "ss"             */
+	AW_MOD_CLK_SPI0,        /* "spi0"           */
+	AW_MOD_CLK_SPI1,        /* "spi1"           */
+	AW_MOD_CLK_SPI2,        /* "spi2"           */
+	AW_MOD_CLK_PATA,        /* "pata"           */
+	AW_MOD_CLK_IR0,         /* "ir0"            */
+	AW_MOD_CLK_IR1,         /* "ir1"            */
+	AW_MOD_CLK_I2S,         /* "i2s"            */
+	AW_MOD_CLK_AC97,        /* "ac97"           */
+	AW_MOD_CLK_SPDIF,       /* "spdif"          */
+	AW_MOD_CLK_KEYPAD,      /* "key_pad"        */
+	AW_MOD_CLK_SATA,        /* "sata"           */
+	AW_MOD_CLK_USBPHY,      /* "usb_phy"        */
+	AW_MOD_CLK_USBPHY0,     /* "usb_phy0"       */
+	AW_MOD_CLK_USBPHY1,     /* "usb_phy1"       */
+	AW_MOD_CLK_USBPHY2,     /* "usb_phy2"       */
+	AW_MOD_CLK_USBOHCI0,    /* "usb_ohci0"      */
+	AW_MOD_CLK_USBOHCI1,    /* "usb_ohci1"      */
+	AW_MOD_CLK_GPS,         /* "com"            */
+	AW_MOD_CLK_SPI3,        /* "spi3"           */
+	AW_MOD_CLK_DEBE0,       /* "de_image0"      */
+	AW_MOD_CLK_DEBE1,       /* "de_image1"      */
+	AW_MOD_CLK_DEFE0,       /* "de_scale0"      */
+	AW_MOD_CLK_DEFE1,       /* "de_scale1"      */
+	AW_MOD_CLK_DEMIX,       /* "de_mix"         */
+	AW_MOD_CLK_LCD0CH0,     /* "lcd0_ch0"       */
+	AW_MOD_CLK_LCD1CH0,     /* "lcd1_ch0"       */
+	AW_MOD_CLK_CSIISP,      /* "csi_isp"        */
+	AW_MOD_CLK_TVD,         /* "tvd"            */
+	AW_MOD_CLK_LCD0CH1_S1,  /* "lcd0_ch1_s1"    */
+	AW_MOD_CLK_LCD0CH1_S2,  /* "lcd0_ch1_s2"    */
+	AW_MOD_CLK_LCD1CH1_S1,  /* "lcd1_ch1_s1"    */
+	AW_MOD_CLK_LCD1CH1_S2,  /* "lcd1_ch1_s2"    */
+	AW_MOD_CLK_CSI0,        /* "csi0"           */
+	AW_MOD_CLK_CSI1,        /* "csi1"           */
+	AW_MOD_CLK_VE,          /* "ve"             */
+	AW_MOD_CLK_ADDA,        /* "audio_codec"    */
+	AW_MOD_CLK_AVS,         /* "avs"            */
+	AW_MOD_CLK_ACE,         /* "ace"            */
+	AW_MOD_CLK_LVDS,        /* "lvds"           */
+	AW_MOD_CLK_HDMI,        /* "hdmi"           */
+	AW_MOD_CLK_MALI,        /* "mali"           */
+	AW_MOD_CLK_TWI0,        /* "twi0"           */
+	AW_MOD_CLK_TWI1,        /* "twi1"           */
+	AW_MOD_CLK_TWI2,        /* "twi2"           */
+	AW_MOD_CLK_CAN,         /* "can"            */
+	AW_MOD_CLK_SCR,         /* "scr"            */
+	AW_MOD_CLK_PS20,        /* "ps0"            */
+	AW_MOD_CLK_PS21,        /* "ps1"            */
+	AW_MOD_CLK_UART0,       /* "uart0"          */
+	AW_MOD_CLK_UART1,       /* "uart1"          */
+	AW_MOD_CLK_UART2,       /* "uart2"          */
+	AW_MOD_CLK_UART3,       /* "uart3"          */
+	AW_MOD_CLK_UART4,       /* "uart4"          */
+	AW_MOD_CLK_UART5,       /* "uart5"          */
+	AW_MOD_CLK_UART6,       /* "uart6"          */
+	AW_MOD_CLK_UART7,       /* "uart7"          */
+
+	/* clock gating for hang to AXI bus */
+	AW_MOD_CLK_AXI_DRAM,    /* "axi_dram"       */
+
+	/* clock gating for hang to AHB bus */
+	AW_MOD_CLK_AHB_USB0,    /* "ahb_usb0"       */
+	AW_MOD_CLK_AHB_EHCI0,   /* "ahb_ehci0"      */
+	AW_MOD_CLK_AHB_OHCI0,   /* "ahb_ohci0"      */
+	AW_MOD_CLK_AHB_SS,      /* "ahb_ss"         */
+	AW_MOD_CLK_AHB_DMA,     /* "ahb_dma"        */
+	AW_MOD_CLK_AHB_BIST,    /* "ahb_bist"       */
+	AW_MOD_CLK_AHB_SDMMC0,  /* "ahb_sdc0"       */
+	AW_MOD_CLK_AHB_SDMMC1,  /* "ahb_sdc1"       */
+	AW_MOD_CLK_AHB_SDMMC2,  /* "ahb_sdc2"       */
+	AW_MOD_CLK_AHB_SDMMC3,  /* "ahb_sdc3"       */
+	AW_MOD_CLK_AHB_MS,      /* "ahb_msc"        */
+	AW_MOD_CLK_AHB_NAND,    /* "ahb_nfc"        */
+	AW_MOD_CLK_AHB_SDRAM,   /* "ahb_sdramc"     */
+	AW_MOD_CLK_AHB_ACE,     /* "ahb_ace"        */
+	AW_MOD_CLK_AHB_EMAC,    /* "ahb_emac"       */
+	AW_MOD_CLK_AHB_TS,      /* "ahb_ts"         */
+	AW_MOD_CLK_AHB_SPI0,    /* "ahb_spi0"       */
+	AW_MOD_CLK_AHB_SPI1,    /* "ahb_spi1"       */
+	AW_MOD_CLK_AHB_SPI2,    /* "ahb_spi2"       */
+	AW_MOD_CLK_AHB_SPI3,    /* "ahb_spi3"       */
+	AW_MOD_CLK_AHB_PATA,    /* "ahb_pata"       */
+	AW_MOD_CLK_AHB_SATA,    /* "ahb_sata"       */
+	AW_MOD_CLK_AHB_GPS,     /* "ahb_com"        */
+	AW_MOD_CLK_AHB_VE,      /* "ahb_ve"         */
+	AW_MOD_CLK_AHB_TVD,     /* "ahb_tvd"        */
+	AW_MOD_CLK_AHB_TVE0,    /* "ahb_tve0"       */
+	AW_MOD_CLK_AHB_TVE1,    /* "ahb_tve1"       */
+	AW_MOD_CLK_AHB_LCD0,    /* "ahb_lcd0"       */
+	AW_MOD_CLK_AHB_LCD1,    /* "ahb_lcd1"       */
+	AW_MOD_CLK_AHB_CSI0,    /* "ahb_csi0"       */
+	AW_MOD_CLK_AHB_CSI1,    /* "ahb_csi1"       */
+	AW_MOD_CLK_AHB_HDMI,    /* "ahb_hdmi"       */
+	AW_MOD_CLK_AHB_DEBE0,   /* "ahb_de_image0"  */
+	AW_MOD_CLK_AHB_DEBE1,   /* "ahb_de_image1"  */
+	AW_MOD_CLK_AHB_DEFE0,   /* "ahb_de_scale0"  */
+	AW_MOD_CLK_AHB_DEFE1,   /* "ahb_de_scale1"  */
+	AW_MOD_CLK_AHB_MP,      /* "ahb_de_mix"     */
+	AW_MOD_CLK_AHB_MALI,    /* "ahb_mali"       */
+
+	/* clock gating for hang APB bus */
+	AW_MOD_CLK_APB_ADDA,    /* "apb_audio_codec"    */
+	AW_MOD_CLK_APB_SPDIF,   /* "apb_spdif"          */
+	AW_MOD_CLK_APB_AC97,    /* "apb_ac97"           */
+	AW_MOD_CLK_APB_I2S,     /* "apb_i2s"            */
+	AW_MOD_CLK_APB_PIO,     /* "apb_pio"            */
+	AW_MOD_CLK_APB_IR0,     /* "apb_ir0"            */
+	AW_MOD_CLK_APB_IR1,     /* "apb_ir1"            */
+	AW_MOD_CLK_APB_KEYPAD,  /* "apb_key_pad"        */
+	AW_MOD_CLK_APB_TWI0,    /* "apb_twi0"           */
+	AW_MOD_CLK_APB_TWI1,    /* "apb_twi1"           */
+	AW_MOD_CLK_APB_TWI2,    /* "apb_twi2"           */
+	AW_MOD_CLK_APB_CAN,     /* "apb_can"            */
+	AW_MOD_CLK_APB_SCR,     /* "apb_scr"            */
+	AW_MOD_CLK_APB_PS20,    /* "apb_ps0"            */
+	AW_MOD_CLK_APB_PS21,    /* "apb_ps1"            */
+	AW_MOD_CLK_APB_UART0,   /* "apb_uart0"          */
+	AW_MOD_CLK_APB_UART1,   /* "apb_uart1"          */
+	AW_MOD_CLK_APB_UART2,   /* "apb_uart2"          */
+	AW_MOD_CLK_APB_UART3,   /* "apb_uart3"          */
+	AW_MOD_CLK_APB_UART4,   /* "apb_uart4"          */
+	AW_MOD_CLK_APB_UART5,   /* "apb_uart5"          */
+	AW_MOD_CLK_APB_UART6,   /* "apb_uart6"          */
+	AW_MOD_CLK_APB_UART7,   /* "apb_uart7"          */
+
+	/* clock gating for access dram */
+	AW_MOD_CLK_SDRAM_VE,    /* "sdram_ve"           */
+	AW_MOD_CLK_SDRAM_CSI0,  /* "sdram_csi0"         */
+	AW_MOD_CLK_SDRAM_CSI1,  /* "sdram_csi1"         */
+	AW_MOD_CLK_SDRAM_TS,    /* "sdram_ts"           */
+	AW_MOD_CLK_SDRAM_TVD,   /* "sdram_tvd"          */
+	AW_MOD_CLK_SDRAM_TVE0,  /* "sdram_tve0"         */
+	AW_MOD_CLK_SDRAM_TVE1,  /* "sdram_tve1"         */
+	AW_MOD_CLK_SDRAM_DEFE0, /* "sdram_de_scale0"    */
+	AW_MOD_CLK_SDRAM_DEFE1, /* "sdram_de_scale1"    */
+	AW_MOD_CLK_SDRAM_DEBE0, /* "sdram_de_image0"    */
+	AW_MOD_CLK_SDRAM_DEBE1, /* "sdram_de_image1"    */
+	AW_MOD_CLK_SDRAM_DEMP,  /* "sdram_de_mix"       */
+	AW_MOD_CLK_SDRAM_ACE,   /* "sdram_ace"          */
+
+	AW_MOD_CLK_AHB_EHCI1,   /* "ahb_ehci1"          */
+	AW_MOD_CLK_AHB_OHCI1,   /* "ahb_ohci1"          */
+
+	AW_MOD_CLK_CNT
+};
+#endif
+
+__s32 OSAL_CCMU_SetSrcFreq(__u32 nSclkNo, __u32 nFreq);
+__u32 OSAL_CCMU_GetSrcFreq(__u32 nSclkNo);
+__hdle OSAL_CCMU_OpenMclk(__s32 nMclkNo);
+__s32 OSAL_CCMU_CloseMclk(__hdle hMclk);
+__s32 OSAL_CCMU_SetMclkSrc(__hdle hMclk, __u32 nSclkNo);
+__s32 OSAL_CCMU_SetMclkDiv(__hdle hMclk, __s32 nDiv);
+__s32 OSAL_CCMU_MclkOnOff(__hdle hMclk, __s32 bOnOff);
+
+__s32 OSAL_CCMU_MclkReset(__hdle hMclk, __s32 bReset);
+
+#endif /* __OSAL_CLOCK_H__ */
diff --git a/drivers/video/sunxi/disp/OSAL_Pin.c b/drivers/video/sunxi/disp/OSAL_Pin.c
new file mode 100644
index 0000000..df1671e
--- /dev/null
+++ b/drivers/video/sunxi/disp/OSAL_Pin.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "bsp_display.h"
+#include "OSAL_Pin.h"
+
+#if defined(CONFIG_AW_AXP) || \
+    (defined(CONFIG_FB_SUNXI_MODULE) && defined(CONFIG_AW_AXP_MODULE))
+#include "../../../power/axp_power/axp-gpio.h"
+#define SUNXI_USE_AXP_GPIO
+#else
+#warning "Building sunxi-fb without axp gpio support"
+#endif
+
+__hdle OSAL_GPIO_Request(user_gpio_set_t *gpio_list, __u32 group_count_max)
+{
+	__inf("OSAL_GPIO_Request, port:%d, port_num:%d, mul_sel:%d, "
+	      "pull:%d, drv_level:%d, data:%d\n", gpio_list->port,
+	      gpio_list->port_num, gpio_list->mul_sel, gpio_list->pull,
+	      gpio_list->drv_level, gpio_list->data);
+
+	if (gpio_list->port == 0xffff) {
+		if (gpio_list->mul_sel == 0 || gpio_list->mul_sel == 1) {
+#ifdef SUNXI_USE_AXP_GPIO
+			axp_gpio_set_io(gpio_list->port_num,
+					gpio_list->mul_sel);
+			axp_gpio_set_value(gpio_list->port_num,
+					   gpio_list->data);
+			return 100 + gpio_list->port_num;
+#else
+			WARN_ON_ONCE("axp gpio used without AXP");
+			return 0;
+#endif
+		} else
+			return 0;
+	} else
+		return sunxi_gpio_request_array(gpio_list, group_count_max);
+}
+
+__hdle OSAL_GPIO_Request_Ex(char *main_name, const char *sub_name)
+{
+	return gpio_request_ex(main_name, sub_name);
+}
+
+/*
+ * if_release_to_default_status:
+ * If it is 0 or 1, and represents the input state, after release of the GPIO
+ * input shaped state does not lead to the error of the external level.
+ * If it is 2, said that the the GPIO status quo after the release, the release
+ * does not manage the current GPIO hardware register.
+ */
+__s32 OSAL_GPIO_Release(__hdle p_handler, __s32 if_release_to_default_status)
+{
+	//__inf("OSAL_GPIO_Release\n");
+	if (p_handler < 200 && p_handler >= 100)
+		return 0;
+	else
+		return gpio_release(p_handler, if_release_to_default_status);
+}
+
+__s32 OSAL_GPIO_DevSetONEPIN_IO_STATUS(u32 p_handler,
+				       __u32 if_set_to_output_status,
+				       const char *gpio_name)
+{
+	if (p_handler < 200 && p_handler >= 100) {
+#ifdef SUNXI_USE_AXP_GPIO
+		return axp_gpio_set_io(p_handler - 100,
+				       if_set_to_output_status);
+#else
+		WARN_ON_ONCE("axp gpio used without AXP");
+		return 0;
+#endif
+	} else
+		return gpio_set_one_pin_io_status(p_handler,
+						  if_set_to_output_status,
+						  gpio_name);
+}
+
+__s32 OSAL_GPIO_DevREAD_ONEPIN_DATA(u32 p_handler, const char *gpio_name)
+{
+	if (p_handler < 200 && p_handler >= 100) {
+#ifdef SUNXI_USE_AXP_GPIO
+		int value;
+
+		axp_gpio_get_value(p_handler - 100, &value);
+		return value;
+#else
+		WARN_ON_ONCE("axp gpio used without AXP");
+		return 0;
+#endif
+	} else
+		return gpio_read_one_pin_value(p_handler, gpio_name);
+}
+
+__s32 OSAL_GPIO_DevWRITE_ONEPIN_DATA(u32 p_handler, __u32 value_to_gpio,
+				     const char *gpio_name)
+{
+	if ((p_handler < 200) && (p_handler >= 100)) {
+#ifdef SUNXI_USE_AXP_GPIO
+		return axp_gpio_set_value(p_handler - 100, value_to_gpio);
+#else
+		WARN_ON_ONCE("axp gpio used without AXP");
+		return 0;
+#endif
+	} else
+		return gpio_write_one_pin_value(p_handler, value_to_gpio,
+						gpio_name);
+}
diff --git a/drivers/video/sunxi/disp/OSAL_Pin.h b/drivers/video/sunxi/disp/OSAL_Pin.h
new file mode 100644
index 0000000..c81bdbf
--- /dev/null
+++ b/drivers/video/sunxi/disp/OSAL_Pin.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __OSAL_PIN_H__
+#define __OSAL_PIN_H__
+
+__hdle OSAL_GPIO_Request(user_gpio_set_t *gpio_list, __u32 group_count_max);
+
+__hdle OSAL_GPIO_Request_Ex(char *main_name, const char *sub_name);
+
+__s32 OSAL_GPIO_Release(__hdle p_handler, __s32 if_release_to_default_status);
+
+
+__s32 OSAL_GPIO_DevSetONEPIN_IO_STATUS(u32 p_handler,
+				       __u32 if_set_to_output_status,
+				       const char *gpio_name);
+
+__s32 OSAL_GPIO_DevREAD_ONEPIN_DATA(u32 p_handler, const char *gpio_name);
+
+__s32 OSAL_GPIO_DevWRITE_ONEPIN_DATA(u32 p_handler, __u32 value_to_gpio,
+				     const char *gpio_name);
+
+#endif /* __OSAL_PIN_H__ */
diff --git a/drivers/video/sunxi/disp/bsp_display.h b/drivers/video/sunxi/disp/bsp_display.h
new file mode 100644
index 0000000..22dae74
--- /dev/null
+++ b/drivers/video/sunxi/disp/bsp_display.h
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EBSP_DISPLAY_H__
+#define __EBSP_DISPLAY_H__
+
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include <linux/uaccess.h>
+#include <asm/memory.h>
+#include <linux/unistd.h>
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+#include <linux/sched.h> /* wake_up_process() */
+#include <linux/kthread.h> /* kthread_create(), kthread_run() */
+#include <linux/err.h> /* IS_ERR(), PTR_ERR() */
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "asm-generic/int-ll64.h"
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <plat/sys_config.h>
+#include <mach/clock.h>
+#include <mach/system.h>
+#include <linux/types.h>
+
+typedef unsigned int __hdle;
+
+#include <video/sunxi_disp_ioctl.h>
+
+#define __inf(msg, ...) pr_debug("[DISP] " msg, ##__VA_ARGS__)
+#define __wrn(msg, ...) pr_warn("[DISP] " msg, ##__VA_ARGS__)
+
+typedef struct {
+	__u32 base_image0;
+	__u32 base_image1;
+	__u32 base_scaler0;
+	__u32 base_scaler1;
+	__u32 base_lcdc0;
+	__u32 base_lcdc1;
+	__u32 base_tvec0;
+	__u32 base_tvec1;
+	__u32 base_pioc;
+	__u32 base_sdram;
+	__u32 base_ccmu;
+	__u32 base_pwm;
+	__u32 base_iep;
+
+	void (*tve_interrup) (__u32 sel);
+	 __s32(*hdmi_set_mode) (__disp_tv_mode_t mode);
+	 __s32(*hdmi_set_videomode) (const struct __disp_video_timing *mode);
+	 __s32(*hdmi_wait_edid) (void);
+	 __s32(*Hdmi_open) (void);
+	 __s32(*Hdmi_close) (void);
+	 __s32(*hdmi_mode_support) (__disp_tv_mode_t mode);
+	 __s32(*hdmi_get_video_timing) (__disp_tv_mode_t mode,
+				struct __disp_video_timing *video_timing);
+	 __s32(*hdmi_get_HPD_status) (void);
+	 __s32(*hdmi_set_pll) (__u32 pll, __u32 clk);
+	 __s32(*disp_int_process) (__u32 sel);
+} __disp_bsp_init_para;
+
+extern __s32 BSP_disp_clk_on(__u32 type);
+extern __s32 BSP_disp_clk_off(__u32 type);
+extern __s32 BSP_disp_init(__disp_bsp_init_para *para);
+extern __s32 BSP_disp_exit(__u32 mode);
+extern __s32 BSP_disp_open(void);
+extern __s32 BSP_disp_close(void);
+extern __s32 BSP_disp_print_reg(__bool b_force_on, __u32 id);
+extern __s32 BSP_disp_cmd_cache(__u32 sel);
+extern __s32 BSP_disp_cmd_submit(__u32 sel);
+extern __s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color);
+extern __s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color);
+extern __s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
+extern __s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode);
+extern __s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer,
+					__u32 offset, __u32 size);
+extern __s32 BSP_disp_get_palette_table(__u32 sel, __u32 *pbuffer,
+					__u32 offset, __u32 size);
+extern __s32 BSP_disp_get_screen_height(__u32 sel);
+extern __s32 BSP_disp_get_screen_width(__u32 sel);
+extern __s32 BSP_disp_get_output_type(__u32 sel);
+extern __s32 BSP_disp_gamma_correction_enable(__u32 sel);
+extern __s32 BSP_disp_gamma_correction_disable(__u32 sel);
+extern __s32 BSP_disp_set_bright(__u32 sel, __u32 bright);
+extern __s32 BSP_disp_get_bright(__u32 sel);
+extern __s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast);
+extern __s32 BSP_disp_get_contrast(__u32 sel);
+extern __s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation);
+extern __s32 BSP_disp_get_saturation(__u32 sel);
+extern __s32 BSP_disp_set_hue(__u32 sel, __u32 hue);
+extern __s32 BSP_disp_get_hue(__u32 sel);
+extern __s32 BSP_disp_enhance_enable(__u32 sel, __bool enable);
+extern __s32 BSP_disp_get_enhance_enable(__u32 sel);
+extern __s32 BSP_disp_capture_screen(__u32 sel,
+				     __disp_capture_screen_para_t *para);
+extern __s32 BSP_disp_set_screen_size(__u32 sel, __disp_rectsz_t *size);
+extern __s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type,
+				     __u32 drc_en);
+extern __s32 BSP_disp_de_flicker_enable(__u32 sel, __bool b_en);
+extern __s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode);
+extern __s32 BSP_disp_layer_release(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_open(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_close(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid,
+					    __disp_fb_t *fbinfo);
+extern __s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid,
+					    __disp_fb_t *fbinfo);
+extern __s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid,
+					   __disp_rect_t *regn);
+extern __s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid,
+					   __disp_rect_t *regn);
+extern __s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,
+					      __disp_rect_t *regn);
+extern __s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,
+					      __disp_rect_t *regn);
+extern __s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
+				     __disp_layer_info_t *layer_para);
+extern __s32 BSP_disp_layer_get_para(__u32 sel, __u32 hid,
+				     __disp_layer_info_t *layer_para);
+extern __s32 BSP_disp_layer_set_top(__u32 sel, __u32 handle);
+extern __s32 BSP_disp_layer_set_bottom(__u32 sel, __u32 handle);
+extern __s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid, __u8 value);
+extern __s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid, __u8 pipe);
+extern __s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid,
+					    __bool enable);
+extern __s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid,
+				       __disp_video_smooth_t mode);
+extern __s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright);
+extern __s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast);
+extern __s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid,
+					   __u32 saturation);
+extern __s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue);
+extern __s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid);
+
+extern __s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable);
+extern __s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid,
+						 __u32 level);
+extern __s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid,
+						   __u32 level);
+extern __s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid,
+						  __u32 level);
+extern __s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid,
+						  __u32 level);
+extern __s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid);
+
+extern __s32 BSP_disp_scaler_get_smooth(__u32 sel);
+extern __s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t mode);
+extern __s32 BSP_disp_scaler_request(void);
+extern __s32 BSP_disp_scaler_release(__u32 handle);
+extern __s32 BSP_disp_scaler_start(__u32 handle, __disp_scaler_para_t *scl);
+
+extern __s32 BSP_disp_hwc_enable(__u32 sel, __bool enable);
+extern __s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos);
+extern __s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos);
+extern __s32 BSP_disp_hwc_set_framebuffer(__u32 sel,
+					  __disp_hwc_pattern_t *patmem);
+extern __s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette, __u32 offset,
+				      __u32 palette_size);
+
+extern __s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid,
+				   __disp_video_fb_t *in_addr);
+extern __s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid,
+					 __disp_dit_info_t *dit_info);
+extern __s32 BSP_disp_video_start(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_video_stop(__u32 sel, __u32 hid);
+
+extern __s32 BSP_disp_lcd_open_before(__u32 sel);
+extern __s32 BSP_disp_lcd_open_after(__u32 sel);
+extern __lcd_flow_t *BSP_disp_lcd_get_open_flow(__u32 sel);
+extern __s32 BSP_disp_lcd_close_befor(__u32 sel);
+extern __s32 BSP_disp_lcd_close_after(__u32 sel);
+extern __lcd_flow_t *BSP_disp_lcd_get_close_flow(__u32 sel);
+extern __s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode);
+extern __s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,
+				      __u32 gamtbl_size);
+extern __s32 BSP_disp_lcd_set_bright(__u32 sel, __u32 bright, __u32 from_iep);
+extern __s32 BSP_disp_lcd_get_bright(__u32 sel);
+extern __s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src);
+extern __s32 LCD_PWM_EN(__u32 sel, __bool b_en);
+extern __s32 LCD_BL_EN(__u32 sel, __bool b_en);
+extern __s32 BSP_disp_lcd_user_defined_func(__u32 sel, __u32 para1, __u32 para2,
+					    __u32 para3);
+extern __s32 BSP_disp_get_videomode(__u32 sel, struct fb_videomode *videomode);
+extern __u32 BSP_disp_get_cur_line(__u32 sel);
+extern __s32 BSP_disp_close_lcd_backlight(__u32 sel);
+
+extern __s32 BSP_disp_tv_open(__u32 sel);
+extern __s32 BSP_disp_tv_close(__u32 sel);
+extern __s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod);
+extern __s32 BSP_disp_tv_get_mode(__u32 sel);
+extern __s32 BSP_disp_tv_get_interface(__u32 sel);
+extern __s32 BSP_disp_tv_auto_check_enable(__u32 sel);
+extern __s32 BSP_disp_tv_auto_check_disable(__u32 sel);
+extern __s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src);
+extern __s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index);
+extern __s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index,
+					__disp_tv_dac_source source);
+extern __s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index);
+
+extern __s32 BSP_disp_hdmi_open(__u32 sel, __u32 wait_edid);
+extern __s32 BSP_disp_hdmi_close(__u32 sel);
+extern __s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t mode);
+extern __s32 BSP_disp_set_videomode(__u32 sel,
+		const struct fb_videomode *mode);
+extern __s32 BSP_disp_hdmi_get_mode(__u32 sel);
+extern __s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8 mode);
+extern __s32 BSP_disp_hdmi_get_hpd_status(__u32 sel);
+extern __s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src);
+extern __s32 BSP_disp_set_hdmi_func(__disp_hdmi_func *func);
+
+extern __s32 BSP_disp_vga_open(__u32 sel);
+extern __s32 BSP_disp_vga_close(__u32 sel);
+extern __s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t mode);
+extern __s32 BSP_disp_vga_get_mode(__u32 sel);
+extern __s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src);
+
+extern __s32 BSP_disp_sprite_init(__u32 sel);
+extern __s32 BSP_disp_sprite_exit(__u32 sel);
+extern __s32 BSP_disp_sprite_open(__u32 sel);
+extern __s32 BSP_disp_sprite_close(__u32 sel);
+extern __s32 BSP_disp_sprite_alpha_enable(__u32 sel);
+extern __s32 BSP_disp_sprite_alpha_disable(__u32 sel);
+extern __s32 BSP_disp_sprite_get_alpha_enable(__u32 sel);
+extern __s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha);
+extern __s32 BSP_disp_sprite_get_alpha_value(__u32 sel);
+extern __s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format,
+					__disp_pixel_seq_t pixel_seq);
+extern __s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer,
+					       __u32 offset, __u32 size);
+extern __s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid, __s32 dst_hid);
+extern __s32 BSP_disp_sprite_get_top_block(__u32 sel);
+extern __s32 BSP_disp_sprite_get_bottom_block(__u32 sel);
+extern __s32 BSP_disp_sprite_get_block_number(__u32 sel);
+extern __s32 BSP_disp_sprite_block_request(__u32 sel,
+					   __disp_sprite_block_para_t *para);
+extern __s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid);
+extern __s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid,
+						  __disp_rect_t *scn_win);
+extern __s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid,
+						  __disp_rect_t *scn_win);
+extern __s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid,
+					       __disp_rect_t *scn_win);
+extern __s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid,
+					       __disp_rect_t *scn_win);
+extern __s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid,
+						   __disp_fb_t *fb);
+extern __s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,
+						  __disp_fb_t *fb);
+extern __s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid);
+extern __s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,
+					    __disp_sprite_block_para_t *para);
+extern __s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,
+					    __disp_sprite_block_para_t *para);
+
+extern __s32 BSP_disp_iep_deflicker_enable(__u32 sel, __bool en);
+extern __s32 BSP_disp_iep_get_deflicker_enable(__u32 sel);
+extern __s32 BSP_disp_iep_drc_enable(__u32 sel, __bool en);
+extern __s32 BSP_disp_iep_get_drc_enable(__u32 sel);
+extern __s32 BSP_disp_iep_set_demo_win(__u32 sel, __u32 mode,
+				       __disp_rect_t *regn);
+
+__s32 Display_set_fb_timing(__u32 sel);
+
+#endif
diff --git a/drivers/video/sunxi/disp/de_be.c b/drivers/video/sunxi/disp/de_be.c
new file mode 100644
index 0000000..401b043
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_be.c
@@ -0,0 +1,1535 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "de_be.h"
+#include "de_fe.h"
+
+__u32 image_reg_base[2] = { 0, 0 }; /* DISE_REGS_BASE; */
+
+__u32 csc_tab[192] = {
+	/* Y/G   Y/G     Y/G     Y/G     U/R     U/R     U/R     U/R     V/B     V/B     V/B     V/B */
+	/* bt601 */
+	0x04a7, 0x1e6f, 0x1cbf, 0x0877, 0x04a7, 0x0000, 0x0662, 0x3211, 0x04a7, 0x0812, 0x0000, 0x2eb1,	/* yuv2rgb */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* yuv2yuv */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* rgb2rgb */
+	0x0204, 0x0107, 0x0064, 0x0100, 0x1ed6, 0x1f68, 0x01c1, 0x0800, 0x1e87, 0x01c1, 0x1fb7, 0x0800,	/* rgb2yuv */
+
+	/* bt709 */
+	0x04a7, 0x1f25, 0x1ddd, 0x04cf, 0x04a7, 0x0000, 0x072c, 0x307d, 0x04a7, 0x0875, 0x0000, 0x2dea,	/* yuv2rgb */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* yuv2yuv */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* rgb2rgb */
+	0x0274, 0x00bb, 0x003f, 0x0100, 0x1ea5, 0x1f98, 0x01c1, 0x0800, 0x1e67, 0x01c1, 0x1fd7, 0x0800,	/* rgb2yuv */
+
+	/* DISP_YCC */
+	0x0400, 0x1e9e, 0x1d24, 0x087b, 0x0400, 0x0000, 0x059b, 0x34c8, 0x0400, 0x0715, 0x0000, 0x31d4,	/* yuv2rgb */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* yuv2yuv */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* rgb2rgb */
+	0x0258, 0x0132, 0x0075, 0x0000, 0x1eac, 0x1f53, 0x0200, 0x0800, 0x1e53, 0x0200, 0x1fac, 0x0800,	/* rgb2yuv */
+
+	/* xvYCC */
+	0x04a7, 0x1f25, 0x1ddd, 0x04cf, 0x04a7, 0x0000, 0x072c, 0x307d, 0x04a7, 0x0875, 0x0000, 0x2dea,	/* yuv2rgb */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* yuv2yuv */
+	0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,	/* rgb2rgb */
+	0x0274, 0x00bb, 0x003f, 0x0100, 0x1ea5, 0x1f98, 0x01c1, 0x0800, 0x1e67, 0x01c1, 0x1fd7, 0x0800	/* rgb2yuv */
+};
+
+__u32 image_enhance_tab[224] = {
+#ifndef CONFIG_ARCH_SUN5I
+	/* bt601(CONSTANT and COEFFICIENT in 12bit fraction) */
+	0x0000041D, 0x00000810, 0x00000191, 0x00010000, 0xFFFFFDA2, 0xFFFFFB58, 0x00000706, 0x00080000,
+	0x00000706, 0xFFFFFA1D, 0xFFFFFEDD, 0x00080000, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	0x000012A0, 0x00000000, 0x00001989, 0xFFF21168, 0x000012A0, 0xFFFFF9BE, 0xFFFFF2FE, 0x000877CF,
+	0x000012A0, 0x0000204A, 0x00000000, 0xFFEEB127, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	/* bt709(CONSTANT and COEFFICIENT in 12bit fraction) */
+	0x000002EE, 0x000009D3, 0x000000FE, 0x00010000, 0xfffffe62, 0xfffffA98, 0x00000706, 0x00080000,
+	0x00000706, 0xfffff99E, 0xffffff5C, 0x00080000, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	0x000012A0, 0x00000000, 0x00001CB0, 0xFFF07DF4, 0x000012A0, 0xfffffC98, 0xfffff775, 0x0004CFDF,
+	0x000012A0, 0x000021D7, 0x00000000, 0xFFEDEA7F, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	/* YCC(CONSTANT and COEFFICIENT in 12bit fraction) */
+	0x000004C8, 0x00000963, 0x000001D5, 0x00000000, 0xFFFFFD4D, 0xFFFFFAB3, 0x00000800, 0x00080000,
+	0x00000800, 0xFFFFF94F, 0xFFFFFEB2, 0x00080000, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+	0x00001000, 0x00000000, 0x0000166F, 0xFFF4C84B, 0x00001000, 0xFFFFFA78, 0xFFFFF491, 0x00087B16,
+	0x00001000, 0x00001C56, 0x00000000, 0xFFF1D4FE, 0x00000000, 0x00000000, 0x00000000, 0x00001000,
+#else
+	/* csc convert table */
+	0x00000107, 0x00000204, 0x00000064, 0x00004000, 0xffffff69, 0xfffffed7, 0x000001c1, 0x00020000,
+	0x000001c1, 0xfffffe88, 0xffffffb8, 0x00020000, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+	0x000004a7, 0x00000000, 0x00000662, 0xfffc845b, 0x000004a7, 0xfffffe70, 0xfffffcc0, 0x00021df3,
+	0x000004a7, 0x00000812, 0x00000000, 0xfffbac4a, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+
+	0x000000bb, 0x00000274, 0x0000003f, 0x00004000, 0xffffff99, 0xfffffea6, 0x000001c1, 0x00020000,
+	0x000001c1, 0xfffffe68, 0xffffffd8, 0x00020000, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+	0x000004a7, 0x00000000, 0x0000072c, 0xfffc1f7d, 0x000004a7, 0xffffff26, 0xfffffdde, 0x000133f7,
+	0x000004a7, 0x00000875, 0x00000000, 0xfffb7aa0, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+
+	0x00000132, 0x00000258, 0x00000075, 0x00000000, 0xffffff54, 0xfffffead, 0x00000200, 0x00020000,
+	0x00000200, 0xfffffe54, 0xffffffad, 0x00020000, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+	0x00000400, 0x00000000, 0x0000059b, 0xfffd3213, 0x00000400, 0xfffffe9f, 0xfffffd25, 0x00021ec5,
+	0x00000400, 0x00000715, 0x00000000, 0xfffc7540, 0x00000000, 0x00000000, 0x00000000, 0x00000400,
+#endif /* not CONFIG_ARCH_SUN5I */
+	/* sin table */
+	0xffffffbd, 0xffffffbf, 0xffffffc1, 0xffffffc2, 0xffffffc4, 0xffffffc6, 0xffffffc8, 0xffffffca,
+	0xffffffcc, 0xffffffce, 0xffffffd1, 0xffffffd3, 0xffffffd5, 0xffffffd7, 0xffffffd9, 0xffffffdb,
+	0xffffffdd, 0xffffffdf, 0xffffffe2, 0xffffffe4, 0xffffffe6, 0xffffffe8, 0xffffffea, 0xffffffec,
+	0xffffffef, 0xfffffff1, 0xfffffff3, 0xfffffff5, 0xfffffff8, 0xfffffffa, 0xfffffffc, 0xfffffffe,
+	0x00000000, 0x00000002, 0x00000004, 0x00000006, 0x00000008, 0x0000000b, 0x0000000d, 0x0000000f,
+	0x00000011, 0x00000014, 0x00000016, 0x00000018, 0x0000001a, 0x0000001c, 0x0000001e, 0x00000021,
+	0x00000023, 0x00000025, 0x00000027, 0x00000029, 0x0000002b, 0x0000002d, 0x0000002f, 0x00000032,
+	0x00000034, 0x00000036, 0x00000038, 0x0000003a, 0x0000003c, 0x0000003e, 0x0000003f, 0x00000041,
+	/* cos table */
+	0x0000006c, 0x0000006d, 0x0000006e, 0x0000006f, 0x00000071, 0x00000072, 0x00000073, 0x00000074,
+	0x00000074, 0x00000075, 0x00000076, 0x00000077, 0x00000078, 0x00000079, 0x00000079, 0x0000007a,
+	0x0000007b, 0x0000007b, 0x0000007c, 0x0000007c, 0x0000007d, 0x0000007d, 0x0000007e, 0x0000007e,
+	0x0000007e, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f,
+	0x00000080, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f, 0x0000007f,
+	0x0000007e, 0x0000007e, 0x0000007e, 0x0000007d, 0x0000007d, 0x0000007c, 0x0000007c, 0x0000007b,
+	0x0000007b, 0x0000007a, 0x00000079, 0x00000079, 0x00000078, 0x00000077, 0x00000076, 0x00000075,
+	0x00000074, 0x00000074, 0x00000073, 0x00000072, 0x00000071, 0x0000006f, 0x0000006e, 0x0000006d
+};
+
+__u32 fir_tab_sun4i[FIR_TAB_SUN4I_SIZE] = {
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc, 0x000a3bfb, 0xff0d39fb,
+	0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,
+	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,
+	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400, 0xfe3f0300, 0xff400100,
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc, 0x000a3bfb, 0xff0d39fb,
+	0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,
+	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,
+	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400, 0xfe3f0300, 0xff400100,
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+	0x00083008, 0x00093007, 0x000b3005, 0x000d2f04, 0x000e2f03, 0x00102e02, 0x00112e01, 0x00132d00,
+	0x00142c00, 0x00152b00, 0x00172900, 0x00182800, 0x001a2600, 0x001b2500, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00241c00, 0x00251b00, 0x00271900, 0x00281800, 0x002a1600,
+	0x002b1500, 0x002d1300, 0x012d1200, 0x022e1000, 0x032e0f00, 0x042f0d00, 0x052f0c00, 0x072f0a00,
+
+	0x000b2a0b, 0x000d2a09, 0x000e2a08, 0x000f2a07, 0x00102a06, 0x00122905, 0x00132904, 0x00142903,
+	0x00162802, 0x00172702, 0x00182701, 0x001a2600, 0x001b2500, 0x001c2400, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00231d00, 0x00241c00, 0x00261a00, 0x01261900, 0x02271700,
+	0x02281600, 0x03281500, 0x04291300, 0x05291200, 0x06291100, 0x072a0f00, 0x082a0e00, 0x092a0d00,
+	0x000d270c, 0x000f260b, 0x0010260a, 0x00112609, 0x00122608, 0x00122608, 0x00132607, 0x00152506,
+	0x00162505, 0x00172504, 0x00192403, 0x00192403, 0x001b2302, 0x001d2201, 0x001d2201, 0x001f2100,
+	0x00202000, 0x00211f00, 0x01211e00, 0x01221d00, 0x02221c00, 0x03231a00, 0x03241900, 0x04241800,
+	0x05241700, 0x06251500, 0x07251400, 0x08251300, 0x08261200, 0x09261100, 0x0a261000, 0x0b260f00,
+	0x000e240e, 0x000f240d, 0x0010240c, 0x0012230b, 0x0013230a, 0x0013230a, 0x00142309, 0x00152308,
+	0x00162307, 0x00182206, 0x00182206, 0x00192205, 0x001b2104, 0x001c2103, 0x001d2003, 0x011e1f02,
+	0x021e1e02, 0x021f1e01, 0x03201d00, 0x03211c00, 0x04211b00, 0x05211a00, 0x06211900, 0x06221800,
+	0x07221700, 0x08221600, 0x09221500, 0x0a221400, 0x0a231300, 0x0b231200, 0x0c231100, 0x0d231000,
+	0x0010210f, 0x0011210e, 0x0012210d, 0x0012210d, 0x0013210c, 0x0014210b, 0x0015210a, 0x0015210a,
+	0x00162109, 0x00182008, 0x00182008, 0x01191f07, 0x011a1f06, 0x021b1e05, 0x021b1e05, 0x031c1d04,
+	0x031d1d03, 0x041d1c03, 0x051e1b02, 0x051e1b02, 0x061f1a01, 0x071f1901, 0x07201801, 0x08201800,
+	0x09201700, 0x0a201600, 0x0a211500, 0x0b211400, 0x0c211300, 0x0d201300, 0x0d211200, 0x0e211100,
+
+	0x00102010, 0x0011200f, 0x0012200e, 0x0012200e, 0x0013200d, 0x00151f0c, 0x00151f0c, 0x01151f0b,
+	0x01161e0b, 0x01171e0a, 0x02171e09, 0x02181d09, 0x03191d07, 0x03191c08, 0x041a1c06, 0x041a1c06,
+	0x051b1b05, 0x061b1b04, 0x061c1a04, 0x071c1904, 0x071d1903, 0x081d1803, 0x091d1802, 0x091e1702,
+	0x0a1e1602, 0x0b1e1601, 0x0c1f1500, 0x0c1f1500, 0x0d1f1400, 0x0e1f1300, 0x0e201200, 0x0f1f1200,
+	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141d0e, 0x02151d0c, 0x02151d0c,
+	0x02161d0b, 0x03161c0b, 0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08, 0x05191b07, 0x06191a07,
+	0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805, 0x091b1804, 0x091c1704, 0x0a1c1703, 0x0a1c1604,
+	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301, 0x0f1e1300, 0x101e1200,
+	0x02121b11, 0x02121b11, 0x02131b10, 0x03131b0f, 0x03131b0f, 0x04141a0e, 0x04141a0e, 0x04151a0d,
+	0x05151a0c, 0x05151a0c, 0x0616190b, 0x0616190b, 0x0616190b, 0x0716190a, 0x0717180a, 0x08171809,
+	0x08181808, 0x09181708, 0x09181708, 0x0a181707, 0x0a191607, 0x0b191606, 0x0b191606, 0x0c1a1505,
+	0x0c1a1505, 0x0d1a1504, 0x0d1a1405, 0x0e1a1404, 0x0f1a1403, 0x0f1b1303, 0x101b1302, 0x101b1203,
+	0x04121911, 0x04121911, 0x05121910, 0x05121910, 0x0513190f, 0x0613180f, 0x0614180e, 0x0614180e,
+	0x0714180d, 0x0714180d, 0x0715180c, 0x0815170c, 0x0815170c, 0x0915170b, 0x0915170b, 0x0916160b,
+	0x0a16160a, 0x0a16160a, 0x0b161609, 0x0b161609, 0x0b171509, 0x0c171508, 0x0c181507, 0x0d171507,
+	0x0d181407, 0x0e181406, 0x0e181406, 0x0f181306, 0x0f191305, 0x10181305, 0x10181305, 0x10191205,
+
+	0x06111811, 0x06121711, 0x06121711, 0x06131710, 0x0713170f, 0x0713170f, 0x0713170f, 0x0813170e,
+	0x0813170e, 0x0814160e, 0x0914160d, 0x0914160d, 0x0914160d, 0x0a14160c, 0x0a14160c, 0x0a15150c,
+	0x0b15150b, 0x0b15150b, 0x0c15150a, 0x0c15150a, 0x0c16140a, 0x0d161409, 0x0d161409, 0x0d161409,
+	0x0e161408, 0x0e171308, 0x0f171307, 0x0f171307, 0x0f171307, 0x10171306, 0x10171207, 0x11171206,
+	0x07121611, 0x07121611, 0x08121610, 0x08121610, 0x0813160f, 0x0813160f, 0x0912160f, 0x0913160e,
+	0x0913150f, 0x0a13150e, 0x0a14150d, 0x0a14150d, 0x0a14150d, 0x0b13150d, 0x0b14150c, 0x0b14150c,
+	0x0c14140c, 0x0c15140b, 0x0c15140b, 0x0d14140b, 0x0d15140a, 0x0d15140a, 0x0d15140a, 0x0e15130a,
+	0x0e15130a, 0x0e161309, 0x0f151309, 0x0f161308, 0x0f161308, 0x10161208, 0x10161208, 0x10161208,
+	0x0b111410, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b121310, 0x0b121310, 0x0c12130f, 0x0c12130f,
+	0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0d12130e, 0x0d12130e, 0x0d12130e, 0x0d12130e,
+	0x0d13130d, 0x0e12130d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0f13120c,
+	0x0f13120c, 0x0f13120c, 0x0f13120c, 0x0f13120c, 0x1013120b, 0x1013120b, 0x1013120b, 0x1014110b,
+	0x0c111310, 0x0c111211, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210,
+	0x0d111210, 0x0d12120f, 0x0d12120f, 0x0e11120f, 0x0e11120f, 0x0e11120f, 0x0e12120e, 0x0e12120e,
+	0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0f11120e, 0x0f11120e, 0x0f11120e, 0x0f12120d, 0x0f12120d,
+	0x0f12110e, 0x0f12110e, 0x0f12110e, 0x0f12110e, 0x1012110d, 0x1012110d, 0x1012110d, 0x1012110d,
+
+	0x40000000, 0x00000000, 0x40fe0000, 0x0000ff03, 0x3ffd0000, 0x0000ff05, 0x3ffc0000, 0x0000ff06,
+	0x3efb0000, 0x0000ff08, 0x3dfb0000, 0x0000ff09, 0x3bfa0000, 0x0000fe0d, 0x39fa0000, 0x0000fe0f,
+	0x38fa0000, 0x0000fe10, 0x36fa0000, 0x0000fe12, 0x33fa0000, 0x0000fd16, 0x31fa0000, 0x0000fd18,
+	0x2ffa0000, 0x0000fd1a, 0x2cfa0000, 0x0000fc1e, 0x29fa0000, 0x0000fc21, 0x27fb0000, 0x0000fb23,
+	0x24fb0000, 0x0000fb26, 0x21fb0000, 0x0000fb29, 0x1ffc0000, 0x0000fa2b, 0x1cfc0000, 0x0000fa2e,
+	0x19fd0000, 0x0000fa30, 0x16fd0000, 0x0000fa33, 0x14fd0000, 0x0000fa35, 0x11fe0000, 0x0000fa37,
+	0x0ffe0000, 0x0000fa39, 0x0dfe0000, 0x0000fa3b, 0x0afe0000, 0x0000fa3e, 0x08ff0000, 0x0000fb3e,
+	0x06ff0000, 0x0000fb40, 0x05ff0000, 0x0000fc40, 0x03ff0000, 0x0000fd41, 0x01ff0000, 0x0000fe42,
+	/* 8 tap */
+	0x40000000, 0x00000000, 0x40fe0000, 0x0000ff03, 0x3ffd0000, 0x0000ff05, 0x3ffc0000, 0x0000ff06,
+	0x3efb0000, 0x0000ff08, 0x3dfb0000, 0x0000ff09, 0x3bfa0000, 0x0000fe0d, 0x39fa0000, 0x0000fe0f,
+	0x38fa0000, 0x0000fe10, 0x36fa0000, 0x0000fe12, 0x33fa0000, 0x0000fd16, 0x31fa0000, 0x0000fd18,
+	0x2ffa0000, 0x0000fd1a, 0x2cfa0000, 0x0000fc1e, 0x29fa0000, 0x0000fc21, 0x27fb0000, 0x0000fb23,
+	0x24fb0000, 0x0000fb26, 0x21fb0000, 0x0000fb29, 0x1ffc0000, 0x0000fa2b, 0x1cfc0000, 0x0000fa2e,
+	0x19fd0000, 0x0000fa30, 0x16fd0000, 0x0000fa33, 0x14fd0000, 0x0000fa35, 0x11fe0000, 0x0000fa37,
+	0x0ffe0000, 0x0000fa39, 0x0dfe0000, 0x0000fa3b, 0x0afe0000, 0x0000fa3e, 0x08ff0000, 0x0000fb3e,
+	0x06ff0000, 0x0000fb40, 0x05ff0000, 0x0000fc40, 0x03ff0000, 0x0000fd41, 0x01ff0000, 0x0000fe42,
+	0x3a05fefe, 0x00fefe09, 0x3a04fefe, 0x00fefe0a, 0x3a02fffe, 0x00fefe0b, 0x3901fffe, 0x00fefd0e,
+	0x3900fffe, 0x00fefd0f, 0x38fefffe, 0x00fefd12, 0x37fdfffe, 0x00fefd14, 0x36fcfffe, 0x00fefc17,
+	0x34fcffff, 0x00fefc18, 0x33fbffff, 0x00fefc1a, 0x31fbffff, 0x00fefb1d, 0x2ffbffff, 0x00fefb1f,
+	0x2dfaff00, 0x00fefb21, 0x2cfaff00, 0x00fefb22, 0x2afaff00, 0x00fefa25, 0x28faff00, 0x00fefa27,
+	0x25fafe00, 0x00fefa2b, 0x23fafe00, 0x00fffa2c, 0x21fafe00, 0x00fffa2e, 0x1ffbfe00, 0x00fffa2f,
+	0x1dfbfe00, 0x00fffa31, 0x1afbfe00, 0x00fffb33, 0x18fbfe00, 0x00fffb35, 0x16fcfe00, 0x00fffb36,
+	0x14fcfe00, 0x00fffc37, 0x12fcfe00, 0x00fffc39, 0x0ffdfe00, 0x00fffd3a, 0x0dfdfe00, 0x00fffe3b,
+	0x0cfdfe00, 0x00ff003a, 0x0afdfe00, 0x00ff013b, 0x08fefe00, 0x00ff023b, 0x06fefe00, 0x00fe043c,
+	0x3409fdfe, 0x00fefd0d, 0x3408fdfe, 0x00fefc0f, 0x3406fdfe, 0x00fefc11, 0x3405fdfe, 0x00fefc12,
+	0x3304fefe, 0x00fefc13, 0x3203fefe, 0x00fefb16, 0x3202fefe, 0x00fefb17, 0x3101fefe, 0x00fffb18,
+	0x3000fefe, 0x00fffb1a, 0x2ffefffe, 0x00fffb1c, 0x2dfefffe, 0x00fffb1e, 0x2cfdfffe, 0x00fffb20,
+	0x2bfcfffe, 0x00fffb22, 0x29fcfffe, 0x00fffb24, 0x28fcfffe, 0x00fffb25, 0x26fbfffe, 0x00fffb28,
+	0x24fbfffe, 0x00fffb2a, 0x23fbfffe, 0x00fffb2b, 0x21fbfffe, 0x00fffc2c, 0x1ffbffff, 0x00fffc2d,
+	0x1dfbffff, 0x00fffc2f, 0x1cfbffff, 0x00fffd2f, 0x1afbffff, 0x00fffe30, 0x18fbffff, 0x00fffe32,
+	0x16fbff00, 0x00fe0032, 0x14fbff00, 0x00fe0133, 0x13fbfe00, 0x00fe0234, 0x11fcfe00, 0x00fe0334,
+	0x0ffcfe00, 0x00fe0435, 0x0efcfe00, 0x00fd0536, 0x0cfcfe00, 0x00fd0637, 0x0bfcfe00, 0x00fd0836,
+
+	0x2f0cfcff, 0x00fffc0f, 0x2f0bfcff, 0x00fffb11, 0x2f0afcff, 0x00fffb12, 0x2e09fcfe, 0x00fffb15,
+	0x2e07fcfe, 0x00fffb17, 0x2d06fdfe, 0x00fffb18, 0x2d05fdfe, 0x00fffb19, 0x2c04fdfe, 0x00fffb1b,
+	0x2c03fdfe, 0x00fffb1c, 0x2b02fdfe, 0x00fffb1e, 0x2a01fefe, 0x00fffb1f, 0x2901fefe, 0x00fffb20,
+	0x2800fefe, 0x00fffb22, 0x27fefefe, 0x00fffc24, 0x26fefefe, 0x00fffc25, 0x24fdfefe, 0x00fffc28,
+	0x23fdfffe, 0x00fffd27, 0x22fcfffe, 0x00fefd2a, 0x21fcfffe, 0x00fefe2a, 0x1ffcfffe, 0x00fefe2c,
+	0x1efbfffe, 0x00fe002c, 0x1cfbfffe, 0x00fe012d, 0x1bfbfffe, 0x00fe012e, 0x19fbfffe, 0x00fd0230,
+	0x18fbfffe, 0x00fd0330, 0x16fbfffe, 0x00fd0431, 0x15fbfffe, 0x00fd0531, 0x13fbfffe, 0x00fd0632,
+	0x12fbfffe, 0x00fc0733, 0x10fbfffe, 0x00fc0933, 0x0ffbffff, 0x00fc0a32, 0x0efbffff, 0x00fc0b32,
+	0x2a0efbff, 0x00fffb14, 0x2a0dfbff, 0x00fffb15, 0x2a0cfcff, 0x00fffb15, 0x2a0bfcff, 0x00fffb16,
+	0x2a0afcff, 0x00fffb17, 0x2909fcff, 0x00fffb19, 0x2908fcff, 0x00fffc19, 0x2907fcff, 0x00fffc1a,
+	0x2806fcff, 0x00fffc1c, 0x2705fcff, 0x00fffc1e, 0x2704fdff, 0x00fefc1f, 0x2603fdff, 0x00fefd20,
+	0x2503fdff, 0x00fefd21, 0x2402fdfe, 0x00fefe23, 0x2401fdfe, 0x00fefe24, 0x2301fdfe, 0x00fefe25,
+	0x2200fefe, 0x00fe0024, 0x21fefefe, 0x00fd0127, 0x20fefefe, 0x00fd0128, 0x1ffefefe, 0x00fd0228,
+	0x1dfdfefe, 0x00fd032a, 0x1cfdfefe, 0x00fd032b, 0x1bfcfefe, 0x00fd042c, 0x1afcfffe, 0x00fc052c,
+	0x19fcfffe, 0x00fc062c, 0x17fcfffe, 0x00fc072d, 0x16fcfffe, 0x00fc082d, 0x15fbfffe, 0x00fc092e,
+	0x14fbfffe, 0x00fc0a2e, 0x12fbfffe, 0x00fc0b2f, 0x11fbfffe, 0x00fb0c30, 0x10fbfffe, 0x00fb0d30,
+	0x2710fcff, 0x00fffc13, 0x270ffcff, 0x00fffc14, 0x270efcff, 0x00fffc15, 0x270dfcff, 0x00fffc16,
+	0x260cfcff, 0x00fefc19, 0x260bfcff, 0x00fefd19, 0x260afcff, 0x00fefd1a, 0x2609fcff, 0x00fefd1b,
+	0x2508fcff, 0x00fefd1d, 0x2507fcff, 0x00fefe1d, 0x2407fcff, 0x00fefe1e, 0x2406fcff, 0x00feff1e,
+	0x2305fcff, 0x00fd0020, 0x2204fcff, 0x00fd0022, 0x2204fdff, 0x00fd0120, 0x2103fdff, 0x00fd0221,
+	0x2002fdff, 0x00fd0223, 0x1f02fdff, 0x00fd0323, 0x1e01fdff, 0x00fd0424, 0x1e00fdff, 0x00fc0426,
+	0x1d00fdff, 0x00fc0526, 0x1cfffeff, 0x00fc0626, 0x1bfefeff, 0x00fc0727, 0x1afefefe, 0x00fc0729,
+	0x19fdfefe, 0x00fc082a, 0x18fdfefe, 0x00fc092a, 0x17fdfefe, 0x00fc0a2a, 0x16fdfefe, 0x00fc0b2a,
+	0x14fcfefe, 0x00fc0c2c, 0x13fcfefe, 0x00fc0d2c, 0x12fcfffe, 0x00fc0e2b, 0x11fcfffe, 0x00fc0f2b,
+
+	0x2411fdfe, 0x00fefd15, 0x2410fcfe, 0x00fefd17, 0x240ffcfe, 0x00fefd18, 0x240efcfe, 0x00fefd19,
+	0x240efcff, 0x00fefe17, 0x240dfcff, 0x00fefe18, 0x230cfcff, 0x00fdfe1b, 0x230bfcff, 0x00fdff1b,
+	0x230afcff, 0x00fd001b, 0x2209fcff, 0x00fd001d, 0x2209fcff, 0x00fd011c, 0x2108fcff, 0x00fd011e,
+	0x2107fcff, 0x00fd021e, 0x2006fcff, 0x00fd0220, 0x2006fcff, 0x00fc0320, 0x1f05fcff, 0x00fc0421,
+	0x1f04fcff, 0x00fc0422, 0x1e04fcff, 0x00fc0522, 0x1d03fcff, 0x00fc0623, 0x1c02fdff, 0x00fc0624,
+	0x1c02fdff, 0x00fc0723, 0x1b01fdff, 0x00fc0824, 0x1a01fdff, 0x00fc0924, 0x1900fdff, 0x00fc0926,
+	0x1800fdff, 0x00fc0a26, 0x17fffdff, 0x00fc0b27, 0x17fefdff, 0x00fc0c27, 0x16fefeff, 0x00fc0d26,
+	0x15fefeff, 0x00fc0e26, 0x14fdfeff, 0x00fc0e28, 0x13fdfeff, 0x00fc0f28, 0x12fdfeff, 0x00fc1028,
+	0x2212fefe, 0x00fefe14, 0x2211fefe, 0x00fdfe16, 0x2210fdfe, 0x00fdfe18, 0x220ffdfe, 0x00fdff18,
+	0x220ffdfe, 0x00fd0017, 0x210efdfe, 0x00fd0019, 0x210dfdfe, 0x00fd0119, 0x210cfcfe, 0x00fd011b,
+	0x210cfcfe, 0x00fd021a, 0x200bfcfe, 0x00fd021c, 0x200afcfe, 0x00fc031d, 0x1f09fcff, 0x00fc031e,
+	0x1f09fcff, 0x00fc041d, 0x1f08fcff, 0x00fc041e, 0x1e07fcff, 0x00fc051f, 0x1e07fcff, 0x00fc051f,
+	0x1d06fcff, 0x00fc0620, 0x1c05fcff, 0x00fc0721, 0x1c05fcff, 0x00fc0721, 0x1b04fcff, 0x00fc0822,
+	0x1b04fcff, 0x00fc0921, 0x1a03fcff, 0x00fc0923, 0x1903fcff, 0x00fc0a23, 0x1802fdff, 0x00fc0b23,
+	0x1802fdff, 0x00fc0b23, 0x1701fdff, 0x00fc0c24, 0x1601fdff, 0x00fd0d23, 0x1500fdff, 0x00fd0e24,
+	0x1500fdff, 0x00fd0e24, 0x14fffdff, 0x00fd0f25, 0x13fefdff, 0x00fd1026, 0x12fefdff, 0x00fe1125,
+	0x201200fd, 0x00fd0014, 0x2011fffd, 0x00fd0016, 0x2011fefd, 0x00fd0116, 0x2010fefd, 0x00fd0117,
+	0x1f0ffefd, 0x00fd0119, 0x1f0ffefd, 0x00fd0218, 0x1f0efdfe, 0x00fd0219, 0x1f0dfdfe, 0x00fc031a,
+	0x1f0dfdfe, 0x00fc031a, 0x1e0cfdfe, 0x00fc041b, 0x1e0bfdfe, 0x00fc041c, 0x1e0bfdfe, 0x00fc051b,
+	0x1d0afdfe, 0x00fc051d, 0x1d09fdfe, 0x00fc061d, 0x1c09fcfe, 0x00fc061f, 0x1c08fcfe, 0x00fc071f,
+	0x1c07fcfe, 0x00fc0720, 0x1b07fcff, 0x00fc081f, 0x1b06fcff, 0x00fc091f, 0x1a06fcff, 0x00fd091f,
+	0x1905fcff, 0x00fd0a20, 0x1905fcff, 0x00fd0a20, 0x1804fcff, 0x00fd0b21, 0x1804fcff, 0x00fd0c20,
+	0x1703fcff, 0x00fd0c22, 0x1603fcff, 0x00fd0d22, 0x1602fdff, 0x00fd0e21, 0x1502fdff, 0x00fe0e21,
+	0x1401fdff, 0x00fe0f22, 0x1401fdff, 0x00fe1021, 0x1301fdff, 0x00fe1022, 0x1200fdff, 0x00ff1122,
+
+	0x1c1202fd, 0x00fd0214, 0x1c1202fd, 0x00fd0313, 0x1c1102fd, 0x00fd0314, 0x1c1001fd, 0x00fd0415,
+	0x1c1001fd, 0x00fd0415, 0x1c0f01fd, 0x00fd0416, 0x1b0f01fd, 0x00fd0516, 0x1b0e00fd, 0x00fd0518,
+	0x1b0e00fd, 0x00fd0617, 0x1b0dfffd, 0x00fd0619, 0x1b0dfffd, 0x00fd0718, 0x1a0cfefd, 0x00fd071b,
+	0x1a0cfefd, 0x00fd071b, 0x1a0bfefd, 0x00fd081b, 0x1a0afefd, 0x00fd081c, 0x190afefd, 0x00fd091c,
+	0x1909fdfe, 0x00fd091d, 0x1809fdfe, 0x00fe0a1c, 0x1808fdfe, 0x00fe0a1d, 0x1808fdfe, 0x00fe0b1c,
+	0x1707fdfe, 0x00fe0b1e, 0x1707fdfe, 0x00fe0c1d, 0x1606fdfe, 0x00ff0c1e, 0x1606fdfe, 0x00ff0d1d,
+	0x1606fdfe, 0x00000d1c, 0x1505fdfe, 0x00000e1d, 0x1505fdfe, 0x00010f1b, 0x1404fdfe, 0x00010f1d,
+	0x1404fdfe, 0x0001101c, 0x1303fdfe, 0x0001101e, 0x1303fdff, 0x0002111b, 0x1203fdff, 0x0002111c,
+	0x181104fd, 0x00fd0415, 0x181104fd, 0x00fd0514, 0x181104fd, 0x00fd0514, 0x181003fd, 0x00fd0516,
+	0x181003fd, 0x00fd0615, 0x180f03fd, 0x00fd0616, 0x180f02fd, 0x00fe0715, 0x180e02fd, 0x00fe0716,
+	0x180e02fd, 0x00fe0716, 0x180e02fd, 0x00fe0815, 0x180d01fd, 0x00fe0817, 0x170d01fd, 0x00fe0818,
+	0x170c01fd, 0x00fe0918, 0x170c01fd, 0x00fe0918, 0x170b00fd, 0x00ff0a18, 0x170b00fd, 0x00ff0a18,
+	0x160b00fd, 0x00000b17, 0x160afffd, 0x00000b19, 0x160afffd, 0x00000b19, 0x1609fefd, 0x00010c19,
+	0x1509fefd, 0x00010c1a, 0x1508fefd, 0x00010d1a, 0x1508fefd, 0x00010d1a, 0x1408fefd, 0x00020d1a,
+	0x1407fefd, 0x00020e1a, 0x1407fefe, 0x00020e19, 0x1306fefe, 0x00020f1a, 0x1306fdfe, 0x00030f1a,
+	0x1306fdfe, 0x00031019, 0x1205fdfe, 0x0003101b, 0x1205fdfe, 0x0004101a, 0x1205fdfe, 0x00041119,
+	0x161006fe, 0x00fe0612, 0x161005fe, 0x00fe0613, 0x161005fe, 0x00fe0613, 0x160f05fe, 0x00fe0713,
+	0x160f05fe, 0x00fe0713, 0x160f04fe, 0x00ff0713, 0x160f04fd, 0x00ff0813, 0x150e04fd, 0x00ff0815,
+	0x150e03fd, 0x00000815, 0x150e03fd, 0x00000914, 0x150d03fd, 0x00000915, 0x150d03fd, 0x00010914,
+	0x150c02fd, 0x00010a15, 0x150c02fd, 0x00010a15, 0x150c02fd, 0x00010a15, 0x150b02fd, 0x00010b15,
+	0x140b01fd, 0x00010b17, 0x140b01fd, 0x00020b16, 0x140a01fd, 0x00020c16, 0x140a01fd, 0x00020c16,
+	0x140a01fd, 0x00020c16, 0x130901fd, 0x00030d16, 0x130900fd, 0x00030d17, 0x130900fd, 0x00030e16,
+	0x130800fd, 0x00030e17, 0x1208fffd, 0x00040e18, 0x1208fffd, 0x00040f17, 0x1207fffd, 0x00040f18,
+	0x1207fefd, 0x00050f18, 0x1107fefd, 0x00051018, 0x1106fefd, 0x00051019, 0x1106fefd, 0x00051019,
+
+	0x140f0700, 0x0000070f, 0x140f06ff, 0x00000711, 0x140f06ff, 0x00000711, 0x140f06ff, 0x00000810,
+	0x130f06ff, 0x00010810, 0x140e05fe, 0x00010812, 0x130e05fe, 0x00010813, 0x130e05fe, 0x00010912,
+	0x130d05fe, 0x00010913, 0x130d04fe, 0x00010914, 0x130d04fe, 0x00020a12, 0x130d04fe, 0x00020a12,
+	0x130c04fe, 0x00020a13, 0x130c03fe, 0x00020a14, 0x130c03fe, 0x00020b13, 0x130c03fe, 0x00030b12,
+	0x130b03fe, 0x00030b13, 0x120b03fe, 0x00030c13, 0x120b02fd, 0x00030c15, 0x120a02fd, 0x00030c16,
+	0x120a02fd, 0x00040c15, 0x120a02fd, 0x00040d14, 0x120a02fd, 0x00040d14, 0x120901fd, 0x00040d16,
+	0x110901fd, 0x00050e15, 0x110901fd, 0x00050e15, 0x110901fd, 0x00050e15, 0x110801fd, 0x00050f15,
+	0x110801fd, 0x00060f14, 0x110800fd, 0x00060f15, 0x100700fd, 0x00060f17, 0x100700fd, 0x00071015,
+	0x120f0701, 0x0001070f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f,
+	0x120e0600, 0x00020810, 0x110e0600, 0x00020910, 0x120d0600, 0x00020910, 0x120d0600, 0x00020910,
+	0x120d0600, 0x00020910, 0x120d05ff, 0x00020a11, 0x120d05ff, 0x00030a10, 0x120c05ff, 0x00030a11,
+	0x120c05ff, 0x00030a11, 0x110c04ff, 0x00030b12, 0x110c04fe, 0x00030b13, 0x110c04fe, 0x00040b12,
+	0x110b04fe, 0x00040b13, 0x110b04fe, 0x00040c12, 0x110b03fe, 0x00040c13, 0x110b03fe, 0x00040c13,
+	0x110a03fe, 0x00050c13, 0x110a03fe, 0x00050d12, 0x110a03fe, 0x00050d12, 0x100a03fe, 0x00050d13,
+	0x100a02fe, 0x00060d13, 0x100902fe, 0x00060e13, 0x100902fe, 0x00060e13, 0x100902fe, 0x00060e13,
+	0x100902fe, 0x00070e12, 0x100802fe, 0x00070f12, 0x100801fe, 0x00070f13, 0x0f0801fd, 0x00070f15,
+	0x100e0802, 0x0002080e, 0x100e0802, 0x0002080e, 0x110e0702, 0x0002080e, 0x110d0702, 0x0002080f,
+	0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0601, 0x00030910,
+	0x100d0601, 0x00030a0f, 0x100c0601, 0x00030a10, 0x100c0601, 0x00040a0f, 0x100c0601, 0x00040a0f,
+	0x100c0500, 0x00040a11, 0x100c0500, 0x00040b10, 0x100c0500, 0x00040b10, 0x100b0500, 0x00040b11,
+	0x100b0500, 0x00050b10, 0x100b05ff, 0x00050b11, 0x100b04ff, 0x00050c11, 0x100b04ff, 0x00050c11,
+	0x100b04ff, 0x00060c10, 0x100a04ff, 0x00060c11, 0x100a04fe, 0x00060d11, 0x100a03fe, 0x00060d12,
+	0x0f0a03fe, 0x00060d13, 0x0f0a03fe, 0x00070d12, 0x0f0903fe, 0x00070d13, 0x0f0903fe, 0x00070e12,
+	0x0f0903fe, 0x00070e12, 0x0f0902fe, 0x00080e12, 0x0f0902fe, 0x00080e12, 0x0f0802fe, 0x00080e13,
+
+	0x0f0d0803, 0x0003080e, 0x0f0d0803, 0x0003080e, 0x0f0d0802, 0x0003090e, 0x0f0d0802, 0x0003090e,
+	0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0004090e, 0x0f0c0702, 0x0004090f,
+	0x0f0c0702, 0x00040a0e, 0x0f0c0702, 0x00040a0e, 0x0f0c0601, 0x00040a10, 0x0f0c0601, 0x00040a10,
+	0x0f0c0601, 0x00050a0f, 0x0e0c0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f,
+	0x0f0b0501, 0x00050b10, 0x0f0b0501, 0x00060b0f, 0x0f0b0501, 0x00060b0f, 0x0f0b0500, 0x00060c0f,
+	0x0f0b0500, 0x00060c0f, 0x0f0a0500, 0x00060c10, 0x0f0a0400, 0x00070c10, 0x0f0a0400, 0x00070c10,
+	0x0e0a0400, 0x00070d10, 0x0f0a04ff, 0x00070d10, 0x0f0a04ff, 0x00070d10, 0x0e0904ff, 0x00080d11,
+	0x0e0903ff, 0x00080d12, 0x0e0903ff, 0x00080e11, 0x0e0903ff, 0x00080e11, 0x0e0903fe, 0x00080e12,
+	0x0f0d0803, 0x0003080e, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d,
+	0x0f0c0803, 0x0004090d, 0x0f0c0803, 0x0004090d, 0x0f0c0703, 0x0004090e, 0x0e0c0703, 0x00040a0e,
+	0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e,
+	0x0e0b0702, 0x00050a0f, 0x0e0b0602, 0x00050a10, 0x0e0b0602, 0x00060b0e, 0x0e0b0602, 0x00060b0e,
+	0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0501, 0x00060b10,
+	0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f,
+	0x0e0a0501, 0x00070c0f, 0x0d0a0501, 0x00080c0f, 0x0e0a0400, 0x00080d0f, 0x0e0a0400, 0x00080d0f,
+	0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00090d0f,
+	0x0c0c0905, 0x0005090c, 0x0d0c0904, 0x0005090c, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d,
+	0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0b0804, 0x00050a0d,
+	0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00060a0d, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e,
+	0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0c0b0703, 0x00070b0d,
+	0x0c0b0703, 0x00070b0d, 0x0c0b0703, 0x00070b0d, 0x0d0b0603, 0x00070b0d, 0x0d0a0602, 0x00070b0f,
+	0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00080b0e, 0x0c0a0602, 0x00080c0e,
+	0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0d0a0502, 0x00080c0e,
+	0x0c0a0502, 0x00090c0e, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090d0e,
+
+	0x0c0b0905, 0x0005090d, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c,
+	0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x00060a0c,
+	0x0c0b0805, 0x00060a0c, 0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c,
+	0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c, 0x0c0b0704, 0x00070a0d, 0x0c0b0704, 0x00070a0d,
+	0x0c0a0704, 0x00070a0e, 0x0c0a0704, 0x00070b0d, 0x0c0a0704, 0x00070b0d, 0x0c0a0703, 0x00080b0d,
+	0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d,
+	0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00090b0d, 0x0b0a0603, 0x00090c0d,
+	0x0b0a0603, 0x00090c0d, 0x0b0a0603, 0x00090c0d, 0x0c090602, 0x00090c0e, 0x0c090602, 0x00090c0e,
+};
+
+__u32 fir_tab_sun5i[FIR_TAB_SUN5I_SIZE] = {
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc, 0x000a3bfb, 0xff0d39fb,
+	0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,
+	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,
+	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400, 0xfe3f0300, 0xff400100,
+	0x00004000, 0x000140ff, 0x00033ffe, 0x00043ffd, 0x00063efc, 0xff083dfc, 0x000a3bfb, 0xff0d39fb,
+	0xff0f37fb, 0xff1136fa, 0xfe1433fb, 0xfe1631fb, 0xfd192ffb, 0xfd1c2cfb, 0xfd1f29fb, 0xfc2127fc,
+	0xfc2424fc, 0xfc2721fc, 0xfb291ffd, 0xfb2c1cfd, 0xfb2f19fd, 0xfb3116fe, 0xfb3314fe, 0xfa3611ff,
+	0xfb370fff, 0xfb390dff, 0xfb3b0a00, 0xfc3d08ff, 0xfc3e0600, 0xfd3f0400, 0xfe3f0300, 0xff400100,
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+	0x00083008, 0x00093007, 0x000b3005, 0x000d2f04, 0x000e2f03, 0x00102e02, 0x00112e01, 0x00132d00,
+	0x00142c00, 0x00152b00, 0x00172900, 0x00182800, 0x001a2600, 0x001b2500, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00241c00, 0x00251b00, 0x00271900, 0x00281800, 0x002a1600,
+	0x002b1500, 0x002d1300, 0x012d1200, 0x022e1000, 0x032e0f00, 0x042f0d00, 0x052f0c00, 0x072f0a00,
+
+	0x000b2a0b, 0x000d2a09, 0x000e2a08, 0x000f2a07, 0x00102a06, 0x00122905, 0x00132904, 0x00142903,
+	0x00162802, 0x00172702, 0x00182701, 0x001a2600, 0x001b2500, 0x001c2400, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00231d00, 0x00241c00, 0x00261a00, 0x01261900, 0x02271700,
+	0x02281600, 0x03281500, 0x04291300, 0x05291200, 0x06291100, 0x072a0f00, 0x082a0e00, 0x092a0d00,
+	0x000d270c, 0x000f260b, 0x0010260a, 0x00112609, 0x00122608, 0x00122608, 0x00132607, 0x00152506,
+	0x00162505, 0x00172504, 0x00192403, 0x00192403, 0x001b2302, 0x001d2201, 0x001d2201, 0x001f2100,
+	0x00202000, 0x00211f00, 0x01211e00, 0x01221d00, 0x02221c00, 0x03231a00, 0x03241900, 0x04241800,
+	0x05241700, 0x06251500, 0x07251400, 0x08251300, 0x08261200, 0x09261100, 0x0a261000, 0x0b260f00,
+	0x000e240e, 0x000f240d, 0x0010240c, 0x0012230b, 0x0013230a, 0x0013230a, 0x00142309, 0x00152308,
+	0x00162307, 0x00182206, 0x00182206, 0x00192205, 0x001b2104, 0x001c2103, 0x001d2003, 0x011e1f02,
+	0x021e1e02, 0x021f1e01, 0x03201d00, 0x03211c00, 0x04211b00, 0x05211a00, 0x06211900, 0x06221800,
+	0x07221700, 0x08221600, 0x09221500, 0x0a221400, 0x0a231300, 0x0b231200, 0x0c231100, 0x0d231000,
+	0x0010210f, 0x0011210e, 0x0012210d, 0x0012210d, 0x0013210c, 0x0014210b, 0x0015210a, 0x0015210a,
+	0x00162109, 0x00182008, 0x00182008, 0x01191f07, 0x011a1f06, 0x021b1e05, 0x021b1e05, 0x031c1d04,
+	0x031d1d03, 0x041d1c03, 0x051e1b02, 0x051e1b02, 0x061f1a01, 0x071f1901, 0x07201801, 0x08201800,
+	0x09201700, 0x0a201600, 0x0a211500, 0x0b211400, 0x0c211300, 0x0d201300, 0x0d211200, 0x0e211100,
+
+	0x00102010, 0x0011200f, 0x0012200e, 0x0012200e, 0x0013200d, 0x00151f0c, 0x00151f0c, 0x01151f0b,
+	0x01161e0b, 0x01171e0a, 0x02171e09, 0x02181d09, 0x03191d07, 0x03191c08, 0x041a1c06, 0x041a1c06,
+	0x051b1b05, 0x061b1b04, 0x061c1a04, 0x071c1904, 0x071d1903, 0x081d1803, 0x091d1802, 0x091e1702,
+	0x0a1e1602, 0x0b1e1601, 0x0c1f1500, 0x0c1f1500, 0x0d1f1400, 0x0e1f1300, 0x0e201200, 0x0f1f1200,
+	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141d0e, 0x02151d0c, 0x02151d0c,
+	0x02161d0b, 0x03161c0b, 0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08, 0x05191b07, 0x06191a07,
+	0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805, 0x091b1804, 0x091c1704, 0x0a1c1703, 0x0a1c1604,
+	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301, 0x0f1e1300, 0x101e1200,
+	0x02121b11, 0x02121b11, 0x02131b10, 0x03131b0f, 0x03131b0f, 0x04141a0e, 0x04141a0e, 0x04151a0d,
+	0x05151a0c, 0x05151a0c, 0x0616190b, 0x0616190b, 0x0616190b, 0x0716190a, 0x0717180a, 0x08171809,
+	0x08181808, 0x09181708, 0x09181708, 0x0a181707, 0x0a191607, 0x0b191606, 0x0b191606, 0x0c1a1505,
+	0x0c1a1505, 0x0d1a1504, 0x0d1a1405, 0x0e1a1404, 0x0f1a1403, 0x0f1b1303, 0x101b1302, 0x101b1203,
+	0x04121911, 0x04121911, 0x05121910, 0x05121910, 0x0513190f, 0x0613180f, 0x0614180e, 0x0614180e,
+	0x0714180d, 0x0714180d, 0x0715180c, 0x0815170c, 0x0815170c, 0x0915170b, 0x0915170b, 0x0916160b,
+	0x0a16160a, 0x0a16160a, 0x0b161609, 0x0b161609, 0x0b171509, 0x0c171508, 0x0c181507, 0x0d171507,
+	0x0d181407, 0x0e181406, 0x0e181406, 0x0f181306, 0x0f191305, 0x10181305, 0x10181305, 0x10191205,
+
+	0x06111811, 0x06121711, 0x06121711, 0x06131710, 0x0713170f, 0x0713170f, 0x0713170f, 0x0813170e,
+	0x0813170e, 0x0814160e, 0x0914160d, 0x0914160d, 0x0914160d, 0x0a14160c, 0x0a14160c, 0x0a15150c,
+	0x0b15150b, 0x0b15150b, 0x0c15150a, 0x0c15150a, 0x0c16140a, 0x0d161409, 0x0d161409, 0x0d161409,
+	0x0e161408, 0x0e171308, 0x0f171307, 0x0f171307, 0x0f171307, 0x10171306, 0x10171207, 0x11171206,
+	0x07121611, 0x07121611, 0x08121610, 0x08121610, 0x0813160f, 0x0813160f, 0x0912160f, 0x0913160e,
+	0x0913150f, 0x0a13150e, 0x0a14150d, 0x0a14150d, 0x0a14150d, 0x0b13150d, 0x0b14150c, 0x0b14150c,
+	0x0c14140c, 0x0c15140b, 0x0c15140b, 0x0d14140b, 0x0d15140a, 0x0d15140a, 0x0d15140a, 0x0e15130a,
+	0x0e15130a, 0x0e161309, 0x0f151309, 0x0f161308, 0x0f161308, 0x10161208, 0x10161208, 0x10161208,
+	0x0b111410, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b121310, 0x0b121310, 0x0c12130f, 0x0c12130f,
+	0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0d12130e, 0x0d12130e, 0x0d12130e, 0x0d12130e,
+	0x0d13130d, 0x0e12130d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0f13120c,
+	0x0f13120c, 0x0f13120c, 0x0f13120c, 0x0f13120c, 0x1013120b, 0x1013120b, 0x1013120b, 0x1014110b,
+	0x0c111310, 0x0c111211, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210,
+	0x0d111210, 0x0d12120f, 0x0d12120f, 0x0e11120f, 0x0e11120f, 0x0e11120f, 0x0e12120e, 0x0e12120e,
+	0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0f11120e, 0x0f11120e, 0x0f11120e, 0x0f12120d, 0x0f12120d,
+	0x0f12110e, 0x0f12110e, 0x0f12110e, 0x0f12110e, 0x1012110d, 0x1012110d, 0x1012110d, 0x1012110d,
+
+	0x00400000, 0x023e0000, 0x043c0000, 0x063a0000, 0x08380000, 0x0a360000, 0x0c340000, 0x0e320000,
+	0x10300000, 0x122e0000, 0x142c0000, 0x162a0000, 0x18280000, 0x1a260000, 0x1c240000, 0x1e220000,
+	0x20200000, 0x221e0000, 0x241c0000, 0x261a0000, 0x28180000, 0x2a160000, 0x2c140000, 0x2e120000,
+	0x30100000, 0x320e0000, 0x340c0000, 0x360a0000, 0x38080000, 0x3a060000, 0x3c040000, 0x3e020000,
+	0x152b0000, 0x162a0000, 0x17290000, 0x17290000, 0x18280000, 0x19270000, 0x19270000, 0x1a260000,
+	0x1b250000, 0x1b250000, 0x1c240000, 0x1d230000, 0x1d230000, 0x1e220000, 0x1f210000, 0x1f210000,
+	0x20200000, 0x211f0000, 0x211f0000, 0x221e0000, 0x231d0000, 0x231d0000, 0x241c0000, 0x251b0000,
+	0x251b0000, 0x261a0000, 0x27190000, 0x27190000, 0x28180000, 0x29170000, 0x29170000, 0x2a160000,
+	0x1a260000, 0x1a260000, 0x1a260000, 0x1b250000, 0x1b250000, 0x1c240000, 0x1c240000, 0x1c240000,
+	0x1d230000, 0x1d230000, 0x1e220000, 0x1e220000, 0x1e220000, 0x1f210000, 0x1f210000, 0x20200000,
+	0x20200000, 0x20200000, 0x211f0000, 0x211f0000, 0x221e0000, 0x221e0000, 0x221e0000, 0x231d0000,
+	0x231d0000, 0x241c0000, 0x241c0000, 0x241c0000, 0x251b0000, 0x251b0000, 0x261a0000, 0x261a0000,
+	0x1b250000, 0x1c240000, 0x1c240000, 0x1c240000, 0x1d230000, 0x1d230000, 0x1d230000, 0x1d230000,
+	0x1e220000, 0x1e220000, 0x1e220000, 0x1f210000, 0x1f210000, 0x1f210000, 0x1f210000, 0x20200000,
+	0x20200000, 0x20200000, 0x211f0000, 0x211f0000, 0x211f0000, 0x211f0000, 0x221e0000, 0x221e0000,
+	0x221e0000, 0x231d0000, 0x231d0000, 0x231d0000, 0x231d0000, 0x241c0000, 0x241c0000, 0x241c0000,
+
+	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
+	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
+	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000,
+	0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x40000000
+};
+
+#ifdef UNUSED
+/* smooth for video */
+static __u32 fir_tab_video_sun4i[FIR_TAB_SIZE] = {
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+
+	0x00053704, 0x00063703, 0x00073702, 0x00093601, 0x000b3500, 0x000c3400, 0x000e3200, 0x000f3100,
+	0x00112f00, 0x00132d00, 0x00152b00, 0x00162a00, 0x00182800, 0x001a2600, 0x001c2400, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00231d00, 0x00251b00, 0x00271900, 0x00291700, 0x002a1600, 0x002c1400,
+	0x002e1200, 0x00301000, 0x00310f00, 0x00330d00, 0x00340c00, 0x01350a00, 0x02360800, 0x03360700,
+	0x00083008, 0x00093007, 0x000b3005, 0x000d2f04, 0x000e2f03, 0x00102e02, 0x00112e01, 0x00132d00,
+	0x00142c00, 0x00152b00, 0x00172900, 0x00182800, 0x001a2600, 0x001b2500, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00241c00, 0x00251b00, 0x00271900, 0x00281800, 0x002a1600,
+	0x002b1500, 0x002d1300, 0x012d1200, 0x022e1000, 0x032e0f00, 0x042f0d00, 0x052f0c00, 0x072f0a00,
+	0x000b2a0b, 0x000d2a09, 0x000e2a08, 0x000f2a07, 0x00102a06, 0x00122905, 0x00132904, 0x00142903,
+	0x00162802, 0x00172702, 0x00182701, 0x001a2600, 0x001b2500, 0x001c2400, 0x001d2300, 0x001e2200,
+	0x00202000, 0x00211f00, 0x00221e00, 0x00231d00, 0x00241c00, 0x00261a00, 0x01261900, 0x02271700,
+	0x02281600, 0x03281500, 0x04291300, 0x05291200, 0x06291100, 0x072a0f00, 0x082a0e00, 0x092a0d00,
+	0x000d270c, 0x000f260b, 0x0010260a, 0x00112609, 0x00122608, 0x00122608, 0x00132607, 0x00152506,
+	0x00162505, 0x00172504, 0x00192403, 0x00192403, 0x001b2302, 0x001d2201, 0x001d2201, 0x001f2100,
+	0x00202000, 0x00211f00, 0x01211e00, 0x01221d00, 0x02221c00, 0x03231a00, 0x03241900, 0x04241800,
+	0x05241700, 0x06251500, 0x07251400, 0x08251300, 0x08261200, 0x09261100, 0x0a261000, 0x0b260f00,
+	0x000e240e, 0x000f240d, 0x0010240c, 0x0012230b, 0x0013230a, 0x0013230a, 0x00142309, 0x00152308,
+	0x00162307, 0x00182206, 0x00182206, 0x00192205, 0x001b2104, 0x001c2103, 0x001d2003, 0x011e1f02,
+	0x021e1e02, 0x021f1e01, 0x03201d00, 0x03211c00, 0x04211b00, 0x05211a00, 0x06211900, 0x06221800,
+	0x07221700, 0x08221600, 0x09221500, 0x0a221400, 0x0a231300, 0x0b231200, 0x0c231100, 0x0d231000,
+	0x0010210f, 0x0011210e, 0x0012210d, 0x0012210d, 0x0013210c, 0x0014210b, 0x0015210a, 0x0015210a,
+	0x00162109, 0x00182008, 0x00182008, 0x01191f07, 0x011a1f06, 0x021b1e05, 0x021b1e05, 0x031c1d04,
+	0x031d1d03, 0x041d1c03, 0x051e1b02, 0x051e1b02, 0x061f1a01, 0x071f1901, 0x07201801, 0x08201800,
+	0x09201700, 0x0a201600, 0x0a211500, 0x0b211400, 0x0c211300, 0x0d201300, 0x0d211200, 0x0e211100,
+	0x00102010, 0x0011200f, 0x0012200e, 0x0012200e, 0x0013200d, 0x00151f0c, 0x00151f0c, 0x01151f0b,
+	0x01161e0b, 0x01171e0a, 0x02171e09, 0x02181d09, 0x03191d07, 0x03191c08, 0x041a1c06, 0x041a1c06,
+	0x051b1b05, 0x061b1b04, 0x061c1a04, 0x071c1904, 0x071d1903, 0x081d1803, 0x091d1802, 0x091e1702,
+	0x0a1e1602, 0x0b1e1601, 0x0c1f1500, 0x0c1f1500, 0x0d1f1400, 0x0e1f1300, 0x0e201200, 0x0f1f1200,
+	0x00111e11, 0x00121e10, 0x00131e0f, 0x00131e0f, 0x01131e0e, 0x01141d0e, 0x02151d0c, 0x02151d0c,
+	0x02161d0b, 0x03161c0b, 0x03171c0a, 0x04171c09, 0x04181b09, 0x05181b08, 0x05191b07, 0x06191a07,
+	0x061a1a06, 0x071a1906, 0x071b1905, 0x081b1805, 0x091b1804, 0x091c1704, 0x0a1c1703, 0x0a1c1604,
+	0x0b1d1602, 0x0c1d1502, 0x0c1d1502, 0x0d1d1402, 0x0e1d1401, 0x0e1e1301, 0x0f1e1300, 0x101e1200,
+	0x02121b11, 0x02121b11, 0x02131b10, 0x03131b0f, 0x03131b0f, 0x04141a0e, 0x04141a0e, 0x04151a0d,
+	0x05151a0c, 0x05151a0c, 0x0616190b, 0x0616190b, 0x0616190b, 0x0716190a, 0x0717180a, 0x08171809,
+	0x08181808, 0x09181708, 0x09181708, 0x0a181707, 0x0a191607, 0x0b191606, 0x0b191606, 0x0c1a1505,
+	0x0c1a1505, 0x0d1a1504, 0x0d1a1405, 0x0e1a1404, 0x0f1a1403, 0x0f1b1303, 0x101b1302, 0x101b1203,
+	0x04121911, 0x04121911, 0x05121910, 0x05121910, 0x0513190f, 0x0613180f, 0x0614180e, 0x0614180e,
+	0x0714180d, 0x0714180d, 0x0715180c, 0x0815170c, 0x0815170c, 0x0915170b, 0x0915170b, 0x0916160b,
+	0x0a16160a, 0x0a16160a, 0x0b161609, 0x0b161609, 0x0b171509, 0x0c171508, 0x0c181507, 0x0d171507,
+	0x0d181407, 0x0e181406, 0x0e181406, 0x0f181306, 0x0f191305, 0x10181305, 0x10181305, 0x10191205,
+	0x06111811, 0x06121711, 0x06121711, 0x06131710, 0x0713170f, 0x0713170f, 0x0713170f, 0x0813170e,
+	0x0813170e, 0x0814160e, 0x0914160d, 0x0914160d, 0x0914160d, 0x0a14160c, 0x0a14160c, 0x0a15150c,
+	0x0b15150b, 0x0b15150b, 0x0c15150a, 0x0c15150a, 0x0c16140a, 0x0d161409, 0x0d161409, 0x0d161409,
+	0x0e161408, 0x0e171308, 0x0f171307, 0x0f171307, 0x0f171307, 0x10171306, 0x10171207, 0x11171206,
+	0x07121611, 0x07121611, 0x08121610, 0x08121610, 0x0813160f, 0x0813160f, 0x0912160f, 0x0913160e,
+	0x0913150f, 0x0a13150e, 0x0a14150d, 0x0a14150d, 0x0a14150d, 0x0b13150d, 0x0b14150c, 0x0b14150c,
+	0x0c14140c, 0x0c15140b, 0x0c15140b, 0x0d14140b, 0x0d15140a, 0x0d15140a, 0x0d15140a, 0x0e15130a,
+	0x0e15130a, 0x0e161309, 0x0f151309, 0x0f161308, 0x0f161308, 0x10161208, 0x10161208, 0x10161208,
+	0x0b111410, 0x0b111410, 0x0b111410, 0x0b111410, 0x0b121310, 0x0b121310, 0x0c12130f, 0x0c12130f,
+	0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0c12130f, 0x0d12130e, 0x0d12130e, 0x0d12130e, 0x0d12130e,
+	0x0d13130d, 0x0e12130d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0e13120d, 0x0f13120c,
+	0x0f13120c, 0x0f13120c, 0x0f13120c, 0x0f13120c, 0x1013120b, 0x1013120b, 0x1013120b, 0x1014110b,
+	0x0c111310, 0x0c111211, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210, 0x0d111210,
+	0x0d111210, 0x0d12120f, 0x0d12120f, 0x0e11120f, 0x0e11120f, 0x0e11120f, 0x0e12120e, 0x0e12120e,
+	0x0e12120e, 0x0e12120e, 0x0e12120e, 0x0f11120e, 0x0f11120e, 0x0f11120e, 0x0f12120d, 0x0f12120d,
+	0x0f12110e, 0x0f12110e, 0x0f12110e, 0x0f12110e, 0x1012110d, 0x1012110d, 0x1012110d, 0x1012110d,
+
+	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008, 0x36010000, 0x00000009,
+	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e, 0x30000000, 0x00000010,
+	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015, 0x29000000, 0x00000017,
+	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e,
+	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024, 0x1a000000, 0x00000026,
+	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b, 0x13000000, 0x0000002d,
+	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032, 0x0d000000, 0x00000033,
+	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236, 0x06000000, 0x00000337,
+
+	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008, 0x36010000, 0x00000009,
+	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e, 0x30000000, 0x00000010,
+	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015, 0x29000000, 0x00000017,
+	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e,
+	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024, 0x1a000000, 0x00000026,
+	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b, 0x13000000, 0x0000002d,
+	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032, 0x0d000000, 0x00000033,
+	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236, 0x06000000, 0x00000337,
+
+	0x36050000, 0x00000005, 0x36030000, 0x00000007, 0x36020000, 0x00000008, 0x36010000, 0x00000009,
+	0x35000000, 0x0000000b, 0x33000000, 0x0000000d, 0x32000000, 0x0000000e, 0x30000000, 0x00000010,
+	0x2e000000, 0x00000012, 0x2d000000, 0x00000013, 0x2b000000, 0x00000015, 0x29000000, 0x00000017,
+	0x27000000, 0x00000019, 0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e,
+	0x20000000, 0x00000020, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024, 0x1a000000, 0x00000026,
+	0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x15000000, 0x0000002b, 0x13000000, 0x0000002d,
+	0x12000000, 0x0000002e, 0x10000000, 0x00000030, 0x0e000000, 0x00000032, 0x0d000000, 0x00000033,
+	0x0b000000, 0x00000035, 0x09000000, 0x00000136, 0x08000000, 0x00000236, 0x06000000, 0x00000337,
+
+	0x2f080000, 0x00000009, 0x2f070000, 0x0000000a, 0x2f060000, 0x0000000b, 0x2e050000, 0x0000000d,
+	0x2e040000, 0x0000000e, 0x2d030000, 0x00000010, 0x2d020000, 0x00000011, 0x2c010000, 0x00000013,
+	0x2c000000, 0x00000014, 0x2a000000, 0x00000016, 0x29000000, 0x00000017, 0x27000000, 0x00000019,
+	0x26000000, 0x0000001a, 0x24000000, 0x0000001c, 0x23000000, 0x0000001d, 0x21000000, 0x0000001f,
+	0x20000000, 0x00000020, 0x1f000000, 0x00000021, 0x1d000000, 0x00000023, 0x1c000000, 0x00000024,
+	0x1a000000, 0x00000026, 0x19000000, 0x00000027, 0x17000000, 0x00000029, 0x16000000, 0x0000002a,
+	0x14000000, 0x0000002c, 0x13000000, 0x0000012c, 0x11000000, 0x0000022d, 0x0f000000, 0x0000032e,
+	0x0e000000, 0x0000042e, 0x0c000000, 0x0000052f, 0x0b000000, 0x0000062f, 0x0a000000, 0x0000072f,
+	0x2a0b0000, 0x0000000b, 0x2a0a0000, 0x0000000c, 0x2a090000, 0x0000000d, 0x29080000, 0x0000000f,
+	0x29070000, 0x00000010, 0x29060000, 0x00000011, 0x28050000, 0x00000013, 0x28040000, 0x00000014,
+	0x27030000, 0x00000016, 0x27020000, 0x00000017, 0x26010000, 0x00000019, 0x25010000, 0x0000001a,
+	0x25000000, 0x0000001b, 0x24000000, 0x0000001c, 0x22000000, 0x0000001e, 0x21000000, 0x0000001f,
+	0x20000000, 0x00000020, 0x1f000000, 0x00000021, 0x1e000000, 0x00000022, 0x1c000000, 0x00000024,
+	0x1b000000, 0x00000025, 0x19000000, 0x00000126, 0x18000000, 0x00000127, 0x17000000, 0x00000227,
+	0x15000000, 0x00000328, 0x14000000, 0x00000428, 0x12000000, 0x00000529, 0x11000000, 0x00000629,
+	0x10000000, 0x00000729, 0x0e000000, 0x0000082a, 0x0d000000, 0x0000092a, 0x0c000000, 0x00000a2a,
+	0x260d0000, 0x0000000d, 0x260c0000, 0x0000000e, 0x260b0000, 0x0000000f, 0x260a0000, 0x00000010,
+	0x26090000, 0x00000011, 0x25080000, 0x00000013, 0x25070000, 0x00000014, 0x25060000, 0x00000015,
+	0x24050000, 0x00000017, 0x24050000, 0x00000017, 0x23040000, 0x00000019, 0x23030000, 0x0000001a,
+	0x23020000, 0x0000001b, 0x22020000, 0x0000001c, 0x21010000, 0x0000001e, 0x20010000, 0x0000001f,
+	0x20000000, 0x00000020, 0x1e000000, 0x00000121, 0x1e000000, 0x00000121, 0x1c000000, 0x00000222,
+	0x1b000000, 0x00000223, 0x1a000000, 0x00000323, 0x18000000, 0x00000424, 0x17000000, 0x00000524,
+	0x16000000, 0x00000525, 0x15000000, 0x00000625, 0x14000000, 0x00000725, 0x13000000, 0x00000825,
+	0x11000000, 0x00000926, 0x10000000, 0x00000a26, 0x0f000000, 0x00000b26, 0x0e000000, 0x00000c26,
+	0x230e0000, 0x0000000f, 0x230e0000, 0x0000000f, 0x230d0000, 0x00000010, 0x230c0000, 0x00000011,
+	0x230b0000, 0x00000012, 0x230a0000, 0x00000013, 0x22090000, 0x00000015, 0x22080000, 0x00000016,
+	0x22080000, 0x00000016, 0x22070000, 0x00000017, 0x21060000, 0x00000019, 0x21050000, 0x0000001a,
+	0x20050000, 0x0000001b, 0x20040000, 0x0000001c, 0x1f030000, 0x0000011d, 0x1f030000, 0x0000011d,
+	0x1e020000, 0x0000021e, 0x1d010000, 0x0000031f, 0x1c010000, 0x00000320, 0x1b000000, 0x00000421,
+	0x1a000000, 0x00000521, 0x1a000000, 0x00000521, 0x18000000, 0x00000622, 0x17000000, 0x00000722,
+	0x16000000, 0x00000822, 0x15000000, 0x00000823, 0x14000000, 0x00000923, 0x13000000, 0x00000a23,
+	0x12000000, 0x00000b23, 0x11000000, 0x00000c23, 0x10000000, 0x00000d23, 0x0f000000, 0x00000e23,
+	0x20100000, 0x00000010, 0x210f0000, 0x00000010, 0x210e0000, 0x00000011, 0x210d0000, 0x00000012,
+	0x210c0000, 0x00000013, 0x200c0000, 0x00000014, 0x200b0000, 0x00000015, 0x200a0000, 0x00000016,
+	0x20090000, 0x00000017, 0x20090000, 0x00000017, 0x1f080000, 0x00000118, 0x1f070000, 0x00000119,
+	0x1e060000, 0x0000021a, 0x1e060000, 0x0000021a, 0x1d050000, 0x0000031b, 0x1d040000, 0x0000031c,
+	0x1c040000, 0x0000041c, 0x1b030000, 0x0000041e, 0x1b030000, 0x0000051d, 0x1a020000, 0x0000061e,
+	0x19020000, 0x0000061f, 0x19010000, 0x0000071f, 0x18010000, 0x0000081f, 0x17000000, 0x00000920,
+	0x16000000, 0x00000921, 0x16000000, 0x00000a20, 0x15000000, 0x00000b20, 0x13000000, 0x00000c21,
+	0x13000000, 0x00000c21, 0x12000000, 0x00000d21, 0x11000000, 0x00000e21, 0x10000000, 0x00000f21,
+	0x1f100000, 0x00000011, 0x1f100000, 0x00000011, 0x1f0f0000, 0x00000012, 0x1f0e0000, 0x00000013,
+	0x1f0e0000, 0x00000013, 0x1f0d0000, 0x00000014, 0x1e0c0000, 0x00000115, 0x1e0b0000, 0x00000116,
+	0x1e0b0000, 0x00000116, 0x1d0a0000, 0x00000217, 0x1d090000, 0x00000218, 0x1c090000, 0x00000318,
+	0x1c080000, 0x00000319, 0x1c070000, 0x00000419, 0x1c070000, 0x00000419, 0x1b060000, 0x0000051a,
+	0x1b050000, 0x0000051b, 0x1a050000, 0x0000061b, 0x19040000, 0x0000071c, 0x19040000, 0x0000071c,
+	0x18030000, 0x0000081d, 0x17030000, 0x0000091d, 0x17020000, 0x0000091e, 0x16020000, 0x00000a1e,
+	0x16010000, 0x00000b1e, 0x15010000, 0x00000b1f, 0x14010000, 0x00000c1f, 0x14000000, 0x00000d1f,
+	0x13000000, 0x00000e1f, 0x13000000, 0x00000e1f, 0x12000000, 0x00000f1f, 0x11000000, 0x0000101f,
+	0x1e110000, 0x00000011, 0x1e100000, 0x00000012, 0x1d100000, 0x00000112, 0x1d0f0000, 0x00000113,
+	0x1d0e0000, 0x00000114, 0x1c0e0000, 0x00000214, 0x1d0d0000, 0x00000214, 0x1c0c0000, 0x00000216,
+	0x1c0c0000, 0x00000315, 0x1c0b0000, 0x00000316, 0x1b0a0000, 0x00000417, 0x1b0a0000, 0x00000417,
+	0x1b090000, 0x00000517, 0x1a080000, 0x00000519, 0x1a080000, 0x00000618, 0x1a070000, 0x00000619,
+	0x19070000, 0x00000719, 0x19060000, 0x0000071a, 0x18060000, 0x0000081a, 0x18050000, 0x0000081b,
+	0x17050000, 0x0000091b, 0x17040000, 0x00000a1b, 0x16040000, 0x00000a1c, 0x16030000, 0x00000b1c,
+	0x15030000, 0x00000c1c, 0x15020000, 0x00000c1d, 0x14020000, 0x00000d1d, 0x13020000, 0x00000e1d,
+	0x13010000, 0x00000e1e, 0x13010000, 0x00000f1d, 0x11010000, 0x0000101e, 0x12000000, 0x0000101e,
+	0x1a110200, 0x00000211, 0x1a100200, 0x00000311, 0x19100200, 0x00000312, 0x1a0f0100, 0x00000313,
+	0x190f0100, 0x00000413, 0x1a0e0100, 0x00000413, 0x1a0e0000, 0x00000414, 0x190d0000, 0x00000515,
+	0x190d0000, 0x00000515, 0x190c0000, 0x00000615, 0x190c0000, 0x00000615, 0x180b0000, 0x00000716,
+	0x180b0000, 0x00000716, 0x180a0000, 0x00000717, 0x170a0000, 0x00000817, 0x18090000, 0x00000817,
+	0x17090000, 0x00000917, 0x17080000, 0x00000918, 0x16080000, 0x00000a18, 0x16070000, 0x00000a19,
+	0x16070000, 0x00000b18, 0x15070000, 0x00000b19, 0x15060000, 0x00000c19, 0x15060000, 0x00000c19,
+	0x15050000, 0x00000d19, 0x14050000, 0x00000d1a, 0x14040000, 0x00000e1a, 0x13040000, 0x00010e1a,
+	0x12040000, 0x00010f1a, 0x12030000, 0x00010f1b, 0x11030000, 0x0002101a, 0x11030000, 0x0002101a,
+	0x17100400, 0x00000411, 0x17100400, 0x00000411, 0x17100300, 0x00000511, 0x170f0300, 0x00000512,
+	0x170f0300, 0x00000512, 0x170e0300, 0x00000612, 0x170e0200, 0x00000613, 0x160e0200, 0x00000713,
+	0x170d0200, 0x00000713, 0x160d0200, 0x00000714, 0x160d0100, 0x00000814, 0x160c0100, 0x00000815,
+	0x150c0100, 0x00000915, 0x160b0100, 0x00000915, 0x160b0000, 0x00000916, 0x160b0000, 0x00000a15,
+	0x160a0000, 0x00000a16, 0x150a0000, 0x00000b16, 0x15090000, 0x00000b17, 0x15090000, 0x00010b16,
+	0x14090000, 0x00010c16, 0x14080000, 0x00010c17, 0x13080000, 0x00010d17, 0x13070000, 0x00020d17,
+	0x13070000, 0x00020d17, 0x12070000, 0x00020e17, 0x13060000, 0x00020e17, 0x12060000, 0x00030e17,
+	0x12050000, 0x00030f17, 0x11050000, 0x00030f18, 0x11050000, 0x00031017, 0x11040000, 0x00041017,
+	0x14100600, 0x00000610, 0x15100500, 0x00000610, 0x150f0500, 0x00000611, 0x150f0500, 0x00000611,
+	0x150f0400, 0x00000711, 0x150e0400, 0x00000712, 0x150e0400, 0x00000712, 0x140e0400, 0x00000812,
+	0x150d0300, 0x00000813, 0x150d0300, 0x00000813, 0x140d0300, 0x00000913, 0x150c0300, 0x00000913,
+	0x140c0200, 0x00010914, 0x140c0200, 0x00010a13, 0x140b0200, 0x00010a14, 0x140b0200, 0x00010a14,
+	0x140b0100, 0x00010b14, 0x140a0100, 0x00020b14, 0x130a0100, 0x00020b15, 0x130a0100, 0x00020c14,
+	0x13090100, 0x00020c15, 0x13090000, 0x00030c15, 0x12090000, 0x00030d15, 0x12080000, 0x00030d16,
+	0x12080000, 0x00030d16, 0x11080000, 0x00040e15, 0x12070000, 0x00040e15, 0x11070000, 0x00040e16,
+	0x11070000, 0x00040f15, 0x11060000, 0x00050f15, 0x10060000, 0x00050f16, 0x10060000, 0x00051015,
+	0x140f0700, 0x0000070f, 0x140f0600, 0x00000710, 0x140f0600, 0x00000710, 0x130f0600, 0x00000711,
+	0x130e0600, 0x00010810, 0x130e0500, 0x00010811, 0x130e0500, 0x00010811, 0x120e0500, 0x00010911,
+	0x130d0500, 0x00010911, 0x130d0400, 0x00010912, 0x130d0400, 0x00020911, 0x130c0400, 0x00020a11,
+	0x120c0400, 0x00020a12, 0x130c0300, 0x00020a12, 0x120c0300, 0x00020b12, 0x120b0300, 0x00030b12,
+	0x120b0300, 0x00030b12, 0x120b0300, 0x00030b12, 0x120b0200, 0x00030c12, 0x120a0200, 0x00030c13,
+	0x110a0200, 0x00040c13, 0x110a0200, 0x00040c13, 0x11090200, 0x00040d13, 0x11090100, 0x00040d14,
+	0x11090100, 0x00050d13, 0x10090100, 0x00050e13, 0x11080100, 0x00050e13, 0x10080100, 0x00050e14,
+	0x10080100, 0x00060e13, 0x10070000, 0x00060f14, 0x10070000, 0x00060f14, 0x10070000, 0x00060f14,
+	0x120f0701, 0x0001070f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f, 0x120e0701, 0x0001080f,
+	0x120e0600, 0x00020810, 0x110e0600, 0x00020910, 0x120d0600, 0x00020910, 0x120d0600, 0x00020910,
+	0x120d0600, 0x00020910, 0x120d0500, 0x00020a10, 0x110d0500, 0x00030a10, 0x110c0500, 0x00030a11,
+	0x110c0500, 0x00030a11, 0x110c0400, 0x00030a12, 0x110c0400, 0x00030b11, 0x110b0400, 0x00040b11,
+	0x110b0400, 0x00040b11, 0x110b0400, 0x00040b11, 0x110b0300, 0x00040c11, 0x110a0300, 0x00040c12,
+	0x110a0300, 0x00050c11, 0x100a0300, 0x00050c12, 0x0f0a0300, 0x00050d12, 0x100a0200, 0x00050d12,
+	0x10090200, 0x00060d12, 0x10090200, 0x00060d12, 0x0f090200, 0x00060e12, 0x0f090200, 0x00060e12,
+	0x10080200, 0x00060e12, 0x0f080100, 0x00070e13, 0x0f080100, 0x00070e13, 0x0f080100, 0x00070f12,
+	0x100e0802, 0x0002080e, 0x100e0802, 0x0002080e, 0x110e0702, 0x0002080e, 0x110d0702, 0x0002080f,
+	0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0701, 0x0003090f, 0x100d0601, 0x00030910,
+	0x100d0601, 0x00030a0f, 0x100c0601, 0x00030a10, 0x100c0601, 0x00040a0f, 0x100c0601, 0x00040a0f,
+	0x100c0500, 0x00040a11, 0x100c0500, 0x00040b10, 0x100c0500, 0x00040b10, 0x100b0500, 0x00040b11,
+	0x100b0500, 0x00050b10, 0x100b0500, 0x00050b10, 0x100b0400, 0x00050c10, 0x100b0400, 0x00050c10,
+	0x100a0400, 0x00050c11, 0x100a0400, 0x00060c10, 0x0f0a0400, 0x00060c11, 0x0f0a0300, 0x00060d11,
+	0x0f0a0300, 0x00060d11, 0x0f090300, 0x00070d11, 0x0f090300, 0x00070d11, 0x0f090300, 0x00070d11,
+	0x0e090300, 0x00070e11, 0x0f090200, 0x00070e11, 0x0f080200, 0x00080e11, 0x0f080200, 0x00080e11,
+	0x0f0d0803, 0x0003080e, 0x0f0d0803, 0x0003080e, 0x0f0d0802, 0x0003090e, 0x0f0d0802, 0x0003090e,
+	0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0003090f, 0x0f0d0702, 0x0004090e, 0x0f0c0702, 0x0004090f,
+	0x0f0c0702, 0x00040a0e, 0x0f0c0702, 0x00040a0e, 0x0f0c0601, 0x00040a10, 0x0f0c0601, 0x00040a10,
+	0x0f0c0601, 0x00050a0f, 0x0e0c0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f, 0x0f0b0601, 0x00050b0f,
+	0x0f0b0501, 0x00050b10, 0x0f0b0501, 0x00060b0f, 0x0f0b0501, 0x00060b0f, 0x0f0b0500, 0x00060c0f,
+	0x0f0b0500, 0x00060c0f, 0x0f0a0500, 0x00060c10, 0x0f0a0400, 0x00070c10, 0x0f0a0400, 0x00070c10,
+	0x0e0a0400, 0x00070d10, 0x0e0a0400, 0x00070d10, 0x0e0a0400, 0x00070d10, 0x0e090400, 0x00080d10,
+	0x0e090300, 0x00080d11, 0x0e090300, 0x00080d11, 0x0e090300, 0x00080e10, 0x0e090300, 0x00080e10,
+	0x0f0d0803, 0x0003080e, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d, 0x0e0d0803, 0x0004090d,
+	0x0f0c0803, 0x0004090d, 0x0f0c0803, 0x0004090d, 0x0f0c0703, 0x0004090e, 0x0e0c0703, 0x00040a0e,
+	0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e, 0x0e0c0702, 0x00050a0e,
+	0x0e0b0702, 0x00050a0f, 0x0e0b0602, 0x00050a10, 0x0e0b0602, 0x00060b0e, 0x0e0b0602, 0x00060b0e,
+	0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0601, 0x00060b0f, 0x0e0b0501, 0x00060b10,
+	0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f, 0x0e0a0501, 0x00070c0f,
+	0x0e0a0501, 0x00070c0f, 0x0d0a0501, 0x00080c0f, 0x0e0a0400, 0x00080d0f, 0x0e0a0400, 0x00080d0f,
+	0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00080d10, 0x0e090400, 0x00090d0f,
+	0x0c0c0905, 0x0005090c, 0x0d0c0904, 0x0005090c, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d,
+	0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0c0804, 0x0005090d, 0x0d0b0804, 0x00050a0d,
+	0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00060a0d, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e,
+	0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0d0b0703, 0x00060a0e, 0x0c0b0703, 0x00070b0d,
+	0x0c0b0703, 0x00070b0d, 0x0c0b0703, 0x00070b0d, 0x0d0b0603, 0x00070b0d, 0x0d0a0602, 0x00070b0f,
+	0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00070b0f, 0x0d0a0602, 0x00080b0e, 0x0c0a0602, 0x00080c0e,
+	0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0c0a0602, 0x00080c0e, 0x0d0a0502, 0x00080c0e,
+	0x0c0a0502, 0x00090c0e, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090c0f, 0x0d090501, 0x00090d0e,
+	0x0c0b0905, 0x0005090d, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c, 0x0c0b0905, 0x0006090c,
+	0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x0006090d, 0x0c0b0805, 0x00060a0c,
+	0x0c0b0805, 0x00060a0c, 0x0c0b0804, 0x00060a0d, 0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c,
+	0x0c0b0804, 0x00070a0c, 0x0c0b0804, 0x00070a0c, 0x0c0b0704, 0x00070a0d, 0x0c0b0704, 0x00070a0d,
+	0x0c0a0704, 0x00070a0e, 0x0c0a0704, 0x00070b0d, 0x0c0a0704, 0x00070b0d, 0x0c0a0703, 0x00080b0d,
+	0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d, 0x0c0a0703, 0x00080b0d,
+	0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00080b0e, 0x0c0a0603, 0x00090b0d, 0x0b0a0603, 0x00090c0d,
+	0x0b0a0603, 0x00090c0d, 0x0b0a0603, 0x00090c0d, 0x0c090602, 0x00090c0e, 0x0c090602, 0x00090c0e
+};
+#endif /* UNUSED */
+
+__s32 DE_Set_Reg_Base(__u32 sel, __u32 address)
+{
+	image_reg_base[sel] = address;
+	//memset((void *)(image0_reg_base + 0x800), 0, 0x1000 - 0x800);
+
+	return 0;
+}
+
+__u32 DE_Get_Reg_Base(__u32 sel)
+{
+
+	return image_reg_base[sel];
+
+}
+
+__u32 DE_BE_Reg_Init(__u32 sel)
+{
+	memset((void *)(image_reg_base[sel] + 0x800), 0, 0x1000 - 0x800);
+
+	return 0;
+}
+
+__s32 DE_BE_Set_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,
+			      __u32 size)
+{
+	__u32 *pdest_end;
+	__u32 *psrc_cur;
+	__u32 *pdest_cur;
+
+	if (size > DE_BE_PALETTE_TABLE_SIZE)
+		size = DE_BE_PALETTE_TABLE_SIZE;
+
+	psrc_cur = pbuffer;
+	pdest_cur = (__u32 *) (DE_Get_Reg_Base(sel) +
+			       DE_BE_PALETTE_TABLE_ADDR_OFF + offset);
+	pdest_end = pdest_cur + (size >> 2);
+
+	while (pdest_cur < pdest_end)
+		*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+
+	return 0;
+}
+
+__s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,
+			      __u32 size)
+{
+	__u32 *pdest_end;
+	__u32 *psrc_cur;
+	__u32 *pdest_cur;
+
+	if (size > DE_BE_PALETTE_TABLE_SIZE)
+		size = DE_BE_PALETTE_TABLE_SIZE;
+
+	psrc_cur = (__u32 *) (DE_Get_Reg_Base(sel) +
+			      DE_BE_PALETTE_TABLE_ADDR_OFF + offset);
+	pdest_cur = pbuffer;
+	pdest_end = pdest_cur + (size >> 2);
+
+	while (pdest_cur < pdest_end)
+		*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+
+	return 0;
+}
+
+__s32 DE_BE_Enable(__u32 sel)
+{
+	/* start */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | (0x01 << 1));
+	/* enable */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) | 0x01);
+	return 0;
+}
+
+__s32 DE_BE_Disable(__u32 sel)
+{
+	/* reset */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffd);
+	/* disable */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xfffffffe);
+
+	return 0;
+}
+
+/*
+ * 0: lcd0 only
+ * 1: lcd1 only
+ * 2: lcd0 + fe0
+ * 3: lcd1 + fe0
+ * 4: lcd0 + fe1
+ * 5: lcd1 + fe1
+ * 6: fe0 only
+ * 7: fe1 only
+ */
+__s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel)
+{
+	/* start */
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      (DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & 0xff8fffff) |
+		      (out_sel << 20));
+
+	if ((out_sel == 6) || (out_sel == 7))
+		DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0xffffffff);
+	else
+		DE_BE_WUINT32(sel, DE_BE_ERROR_CORRECTION, 0);
+
+	return 0;
+}
+
+__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor)
+{
+	DE_BE_WUINT32(sel, DE_BE_COLOR_CTL_OFF, (bkcolor.alpha << 24) |
+		      (bkcolor.red << 16) | (bkcolor.green << 8) |
+		      bkcolor.blue);
+
+	return 0;
+}
+
+__s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,
+			 __disp_color_t ck_min, __u32 ck_red_match,
+			 __u32 ck_green_match, __u32 ck_blue_match)
+{
+	DE_BE_WUINT32(sel, DE_BE_CLRKEY_MAX_OFF, (ck_max.alpha << 24) |
+		      (ck_max.red << 16) | (ck_max.green << 8) | ck_max.blue);
+	DE_BE_WUINT32(sel, DE_BE_CLRKEY_MIN_OFF, (ck_min.alpha << 24) |
+		      (ck_min.red << 16) | (ck_min.green << 8) | ck_min.blue);
+	DE_BE_WUINT32(sel, DE_BE_CLRKEY_CFG_OFF, (ck_red_match << 4) |
+		      (ck_green_match << 2) | ck_blue_match);
+
+	return 0;
+}
+
+__s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
+
+	/* bit1:enable, bit0:ready */
+	DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | ((1 - en) << 1));
+
+	return 0;
+}
+
+__s32 DE_BE_Cfg_Ready(__u32 sel)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_CTL_OFF);
+
+	/* bit1:enable, bit0:ready */
+	DE_BE_WUINT32(sel, DE_BE_FRMBUF_CTL_OFF, tmp | 0x1);
+
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Enable(__u32 sel, __bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_EN_OFF,
+		      (DE_BE_RUINT32(sel, DE_BE_SPRITE_EN_OFF) & 0xfffffffe) |
+		      enable);
+	return 0;
+}
+
+#ifdef UNUSED
+static __s32 DE_BE_Sprite_Disable(__u32 sel)
+{
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_EN_OFF,
+		      DE_BE_RUINT32(sel, DE_BE_SPRITE_EN_OFF) & 0xfffffffe);
+	return 0;
+}
+#endif
+
+__s32 DE_BE_Sprite_Set_Format(__u32 sel, __u8 pixel_seq, __u8 format)
+{
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_FORMAT_CTRL_OFF,
+		      (pixel_seq << 12) | (format << 8));
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Global_Alpha_Enable(__u32 sel, bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF, enable);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Set_Global_Alpha(__u32 sel, __u8 alpha_val)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF);
+	tmp = (tmp & 0x00ffffff) | (alpha_val << 24);
+
+	DE_BE_WUINT32(sel, DE_BE_SPRITE_ALPHA_CTRL_OFF, tmp);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx, __s16 x, __s16 y)
+{
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_POS_CTRL_OFF, blk_idx,
+			 ((y & 0xffff) << 16) | (x & 0xffff));
+	return 0;
+}
+
+/*
+ * todo.
+ */
+__s32
+DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx, __u32 xsize, __u32 ysize)
+{
+	__u32 tmp = 0;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF, blk_idx) &
+		0x0000003f;
+
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF, blk_idx,
+			 tmp | ((ysize - 1) << 20) | ((xsize - 1) << 8));
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_fb(__u32 sel, __u8 blk_idx, __u32 addr,
+				__u32 line_width)
+{
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ADDR_OFF, blk_idx, addr);
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_LINE_WIDTH_OFF, blk_idx,
+			 line_width << 3);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx, __u8 next_blk_id)
+{
+	__u32 tmp = 0;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF, blk_idx) &
+		0xffffffc0;
+	DE_BE_WUINT32IDX(sel, DE_BE_SPRITE_ATTR_CTRL_OFF, blk_idx,
+			 tmp | next_blk_id);
+	return 0;
+}
+
+__s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset,
+				     __u32 size)
+{
+	__u32 *pdest_end;
+	__u32 *psrc_cur;
+	__u32 *pdest_cur;
+
+	if (size > DE_BE_SPRITE_PALETTE_TABLE_SIZE)
+		size = DE_BE_SPRITE_PALETTE_TABLE_SIZE;
+
+	psrc_cur = (__u32 *) address;
+	pdest_cur = (__u32 *) (DE_Get_Reg_Base(sel) +
+			       DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF + offset);
+	pdest_end = pdest_cur + (size >> 2);
+
+	while (pdest_cur < pdest_end)
+		*(volatile __u32 *)pdest_cur++ = *psrc_cur++;
+
+	return 0;
+}
+
+#ifndef CONFIG_ARCH_SUN5I
+/*
+ * out_csc: 0:rgb, 1:yuv for tv, 2:yuv for hdmi
+ * out_color_range:  0:16~255, 1:0~255, 2:16~235
+ */
+__s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
+			   __u32 enhance_en, __u32 brightness, __u32 contrast,
+			   __u32 saturation, __u32 hue)
+{
+	__s32 i_bright;
+	__s32 i_contrast;
+	__s32 i_saturation;
+	__s32 i_hue; /* fix */
+	__scal_matrix4x4 matrixEn;
+	__scal_matrix4x4 matrixconv, *ptmatrix;
+	__scal_matrix4x4 matrixresult;
+	__s64 *pt;
+	__s32 sinv, cosv; /* sin_tab: 7 bit fractional */
+	__s32 i;
+	__scal_matrix4x4 tmpcoeff;
+
+	brightness = brightness > 100 ? 100 : (brightness < 0 ? 0 : brightness);
+	contrast = contrast > 100 ? 100 : (contrast < 0 ? 0 : contrast);
+	saturation = saturation > 100 ? 100 : (saturation < 0 ? 0 : saturation);
+
+	i_bright = (__s32) (brightness * 64 / 100);
+	i_saturation = (__s32) (saturation * 64 / 100);
+	i_contrast = (__s32) (contrast * 64 / 100);
+	i_hue = (__s32) (hue * 64 / 100);
+
+	sinv = image_enhance_tab[8 * 12 + (i_hue & 0x3f)];
+	cosv = image_enhance_tab[8 * 12 + 8 * 8 + (i_hue & 0x3f)];
+
+	/* calculate enhance matrix */
+	matrixEn.x00 = i_contrast << 5;
+	matrixEn.x01 = 0;
+	matrixEn.x02 = 0;
+	matrixEn.x03 = (((i_bright - 32) + 16) << 10) - (i_contrast << 9);
+	matrixEn.x10 = 0;
+	matrixEn.x11 = (i_contrast * i_saturation * cosv) >> 7;
+	matrixEn.x12 = (i_contrast * i_saturation * sinv) >> 7;
+	matrixEn.x13 = (1 << 17) - ((matrixEn.x11 + matrixEn.x12) << 7);
+	matrixEn.x20 = 0;
+	matrixEn.x21 = (-i_contrast * i_saturation * sinv) >> 7;
+	matrixEn.x22 = (i_contrast * i_saturation * cosv) >> 7;
+	matrixEn.x23 = (1 << 17) - ((matrixEn.x22 + matrixEn.x21) << 7);
+	matrixEn.x30 = 0;
+	matrixEn.x31 = 0;
+	matrixEn.x32 = 0;
+	matrixEn.x33 = 1024;
+
+	if (out_csc == DE_RGB) { /* RGB output */
+		if (enhance_en == 1) {
+			for (i = 0; i < 16; i++) {
+#if 1
+				/* bt709 rgb2yuv coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x20 + i)
+					 << 32) >> 32;
+#elif 0
+				/* bt601 rgb2yuv coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + i) <<
+					 32) >> 32;
+#else
+				/* YCC rgb2yuv coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x40 + i)
+					 << 32) >> 32;
+#endif
+			}
+
+			ptmatrix = &tmpcoeff;
+
+			/* convolution of enhance matrix and rgb2yuv matrix */
+			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+
+			for (i = 0; i < 16; i++) {
+#if 1
+				/* bt709 yuv2rgb coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x30 + i)
+					 << 32) >> 32;
+#elif 0
+				/* bt601 yuv2rgb coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x10 + i)
+					 << 32) >> 32;
+#else
+				/* YCC yuv2rgb coeff */
+				*((__s64 *) (&tmpcoeff.x00) + i) =
+					((__s64) *(image_enhance_tab + 0x50 + i)
+					 << 32) >> 32;
+#endif
+			}
+
+			ptmatrix = &tmpcoeff;
+
+			/* convert to RGB */
+			iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
+
+			/* rearrange CSC coeff */
+			matrixresult.x00 = (matrixconv.x00 + 8) / 16;
+			matrixresult.x01 = (matrixconv.x01 + 8) / 16;
+			matrixresult.x02 = (matrixconv.x02 + 8) / 16;
+			matrixresult.x03 = (matrixconv.x03 + 512) / 1024;
+			matrixresult.x10 = (matrixconv.x10 + 8) / 16;
+			matrixresult.x11 = (matrixconv.x11 + 8) / 16;
+			matrixresult.x12 = (matrixconv.x12 + 8) / 16;
+			matrixresult.x13 = (matrixconv.x13 + 512) / 1024;
+			matrixresult.x20 = (matrixconv.x20 + 8) / 16;
+			matrixresult.x21 = (matrixconv.x21 + 8) / 16;
+			matrixresult.x22 = (matrixconv.x22 + 8) / 16;
+			matrixresult.x23 = (matrixconv.x23 + 512) / 1024;
+			matrixresult.x30 = (matrixconv.x30 + 8) / 16;
+			matrixresult.x31 = (matrixconv.x31 + 8) / 16;
+			matrixresult.x32 = (matrixconv.x32 + 8) / 16;
+			matrixresult.x33 = (matrixconv.x33 + 512) / 1024;
+		} else {
+			matrixresult.x00 = 0x400;
+			matrixresult.x01 = 0;
+			matrixresult.x02 = 0;
+			matrixresult.x03 = 0;
+			matrixresult.x10 = 0;
+			matrixresult.x11 = 0x400;
+			matrixresult.x12 = 0;
+			matrixresult.x13 = 0;
+			matrixresult.x20 = 0;
+			matrixresult.x21 = 0;
+			matrixresult.x22 = 0x400;
+			matrixresult.x23 = 0;
+			matrixresult.x30 = 0;
+			matrixresult.x31 = 0;
+			matrixresult.x32 = 0;
+			matrixresult.x33 = 0xe8;
+		}
+
+		/* OUTPUT RANGE MODIFY */
+		ptmatrix = &matrixresult;
+
+		matrixconv.x30 = 0x0000;
+		matrixconv.x31 = 0x0000;
+		matrixconv.x32 = 0x0000;
+		matrixconv.x33 = 0x0000;
+
+		if (out_color_range == DISP_COLOR_RANGE_16_255) {
+			matrixconv.x00 = 0x03c4;
+			matrixconv.x01 = 0x0000;
+			matrixconv.x02 = 0x0000;
+			matrixconv.x03 = 0x0100;
+			matrixconv.x10 = 0x0000;
+			matrixconv.x11 = 0x03c4;
+			matrixconv.x12 = 0x0000;
+			matrixconv.x13 = 0x0100;
+			matrixconv.x20 = 0x0000;
+			matrixconv.x21 = 0x0000;
+			matrixconv.x22 = 0x03c4;
+			matrixconv.x23 = 0x0100;
+		} else if (out_color_range == DISP_COLOR_RANGE_16_235) {
+			matrixconv.x00 = 0x0370;
+			matrixconv.x01 = 0x0000;
+			matrixconv.x02 = 0x0000;
+			matrixconv.x03 = 0x0100;
+			matrixconv.x10 = 0x0000;
+			matrixconv.x11 = 0x0370;
+			matrixconv.x12 = 0x0000;
+			matrixconv.x13 = 0x0100;
+			matrixconv.x20 = 0x0000;
+			matrixconv.x21 = 0x0000;
+			matrixconv.x22 = 0x0370;
+			matrixconv.x23 = 0x0100;
+		} else { /* DISP_COLOR_RANGE_0_255 */
+			matrixconv.x00 = 0x0400;
+			matrixconv.x01 = 0x0000;
+			matrixconv.x02 = 0x0000;
+			matrixconv.x03 = 0x0000;
+			matrixconv.x10 = 0x0000;
+			matrixconv.x11 = 0x0400;
+			matrixconv.x12 = 0x0000;
+			matrixconv.x13 = 0x0000;
+			matrixconv.x20 = 0x0000;
+			matrixconv.x21 = 0x0000;
+			matrixconv.x22 = 0x0400;
+			matrixconv.x23 = 0x0000;
+		}
+
+		iDE_SCAL_Matrix_Mul(matrixconv, *ptmatrix, &matrixresult);
+
+		matrixresult.x00 = matrixresult.x00;
+		matrixresult.x01 = matrixresult.x01;
+		matrixresult.x02 = matrixresult.x02;
+		matrixresult.x03 = matrixresult.x03 + 8;
+		matrixresult.x10 = matrixresult.x10;
+		matrixresult.x11 = matrixresult.x11;
+		matrixresult.x12 = matrixresult.x12;
+		matrixresult.x13 = matrixresult.x13 + 8;
+		matrixresult.x20 = matrixresult.x20;
+		matrixresult.x21 = matrixresult.x21;
+		matrixresult.x22 = matrixresult.x22;
+		matrixresult.x23 = matrixresult.x23 + 8;
+	} else if (out_csc == DE_YUV_TV) { /* YUV for tv (range 16-235) */
+		for (i = 0; i < 16; i++) {
+			/* bt601 rgb2yuv coeff */
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) *(image_enhance_tab + i) << 32) >> 32;
+		}
+
+		if (enhance_en == 1) {
+			/* convolution of enhance matrix and rgb2yuv matrix */
+
+			ptmatrix = &tmpcoeff;
+
+			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+
+			matrixresult.x00 = matrixconv.x00 / 4;
+			matrixresult.x01 = matrixconv.x01 / 4;
+			matrixresult.x02 = matrixconv.x02 / 4;
+			matrixresult.x03 = matrixconv.x03 / 256 + 8;
+			matrixresult.x10 = matrixconv.x10 / 4;
+			matrixresult.x11 = matrixconv.x11 / 4;
+			matrixresult.x12 = matrixconv.x12 / 4;
+			matrixresult.x13 = matrixconv.x13 / 256 + 8;
+			matrixresult.x20 = matrixconv.x20 / 4;
+			matrixresult.x21 = matrixconv.x21 / 4;
+			matrixresult.x22 = matrixconv.x22 / 4;
+			matrixresult.x23 = matrixconv.x23 / 256 + 8;
+		} else {
+			matrixresult.x00 = tmpcoeff.x00 / 4;
+			matrixresult.x01 = tmpcoeff.x01 / 4;
+			matrixresult.x02 = tmpcoeff.x02 / 4;
+			matrixresult.x03 = tmpcoeff.x03 / 256 + 8;
+			matrixresult.x10 = tmpcoeff.x10 / 4;
+			matrixresult.x11 = tmpcoeff.x11 / 4;
+			matrixresult.x12 = tmpcoeff.x12 / 4;
+			matrixresult.x13 = tmpcoeff.x13 / 256 + 8;
+			matrixresult.x20 = tmpcoeff.x20 / 4;
+			matrixresult.x21 = tmpcoeff.x21 / 4;
+			matrixresult.x22 = tmpcoeff.x22 / 4;
+			matrixresult.x23 = tmpcoeff.x23 / 256 + 8;
+		}
+	} else { /* YUV for HDMI(range 16-235) */
+		for (i = 0; i < 16; i++) {
+			/* bt601 rgb2yuv coeff */
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) *(image_enhance_tab + i) << 32) >> 32;
+		}
+
+		if (enhance_en == 1) {
+			/* convolution of enhance matrix and rgb2yuv matrix */
+
+			ptmatrix = &tmpcoeff;
+
+			iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+
+			matrixresult.x00 = matrixconv.x20 / 4;
+			matrixresult.x01 = matrixconv.x21 / 4;
+			matrixresult.x02 = matrixconv.x22 / 4;
+			matrixresult.x03 = matrixconv.x23 / 256 + 8;
+			matrixresult.x10 = matrixconv.x00 / 4;
+			matrixresult.x11 = matrixconv.x01 / 4;
+			matrixresult.x12 = matrixconv.x02 / 4;
+			matrixresult.x13 = matrixconv.x03 / 256 + 8;
+			matrixresult.x20 = matrixconv.x10 / 4;
+			matrixresult.x21 = matrixconv.x11 / 4;
+			matrixresult.x22 = matrixconv.x12 / 4;
+			matrixresult.x23 = matrixconv.x13 / 256 + 8;
+		} else {
+			matrixresult.x00 = tmpcoeff.x20 / 4;
+			matrixresult.x01 = tmpcoeff.x21 / 4;
+			matrixresult.x02 = tmpcoeff.x22 / 4;
+			matrixresult.x03 = tmpcoeff.x23 / 256 + 8;
+			matrixresult.x10 = tmpcoeff.x00 / 4;
+			matrixresult.x11 = tmpcoeff.x01 / 4;
+			matrixresult.x12 = tmpcoeff.x02 / 4;
+			matrixresult.x13 = tmpcoeff.x03 / 256 + 8;
+			matrixresult.x20 = tmpcoeff.x10 / 4;
+			matrixresult.x21 = tmpcoeff.x11 / 4;
+			matrixresult.x22 = tmpcoeff.x12 / 4;
+			matrixresult.x23 = tmpcoeff.x13 / 256 + 8;
+		}
+	}
+
+
+	/* range limited */
+	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -16383, 16383, 0, 32767);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -16383, 16383, 0, 32767);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 0, 32767);
+
+	/* write csc register */
+	pt = (__s64 *) &(matrixresult.x00);
+
+	for (i = 0; i < 4; i++) {
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_R_COEFF_OFF + 4 * i,
+			      (__u32) (*(pt + i)));
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_G_COEFF_OFF + 4 * i,
+			      (__u32) (*(pt + 4 + i)));
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF + 4 * i,
+			      (__u32) (*(pt + 8 + i)));
+	}
+
+	DE_BE_enhance_enable(sel, 1);
+
+	return 0;
+}
+#else
+/*
+ * brightness -100~100
+ * contrast -100~100
+ * saturation -100~100
+ */
+__s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
+			__s32 brightness, __s32 contrast, __s32 saturation,
+			__s32 hue)
+{
+	__s32 i_bright;
+	__s32 i_contrast;
+	__s32 i_saturation;
+	__s32 i_hue;
+	__scal_matrix4x4 matrixEn;
+	__scal_matrix4x4 *ptmatrix;
+	__scal_matrix4x4 matrixresult;
+	__s32 *pt;
+	__u32 i;
+	__s32 sinv, cosv; /* sin_tab: 7 bit fractional */
+
+	brightness = brightness > 100 ? 100 : (brightness < 0 ? 0 : brightness);
+	contrast = contrast > 100 ? 100 : (contrast < 0 ? 0 : contrast);
+	saturation = saturation > 100 ? 100 : (saturation < 0 ? 0 : saturation);
+	hue = hue > 100 ? 100 : (hue < 0 ? 0 : saturation);
+
+	i_bright = (__s32) (brightness * 64 / 100);
+	i_saturation = (__s32) (saturation * 64 / 100);
+	i_contrast = (__s32) (contrast * 64 / 100);
+	i_hue = (__s32) (hue * 64 / 100);
+
+	sinv = image_enhance_tab[8 * 12 + (i_hue & 0x3f)];
+	cosv = image_enhance_tab[8 * 12 + 8 * 8 + (i_hue & 0x3f)];
+
+	matrixEn.x00 = i_contrast << 5;
+	matrixEn.x01 = 0;
+	matrixEn.x02 = 0;
+	matrixEn.x03 = (((i_bright - 32) + 16) << 10) - (i_contrast << 9);
+	matrixEn.x10 = 0;
+	matrixEn.x11 = (i_contrast * i_saturation * cosv) >> 7;
+	matrixEn.x12 = (i_contrast * i_saturation * sinv) >> 7;
+	matrixEn.x13 = (1 << 17) - ((matrixEn.x11 + matrixEn.x12) << 7);
+	matrixEn.x20 = 0;
+	matrixEn.x21 = (-i_contrast * i_saturation * sinv) >> 7;
+	matrixEn.x22 = (i_contrast * i_saturation * cosv) >> 7;
+	matrixEn.x23 = (1 << 17) - ((matrixEn.x22 + matrixEn.x21) << 7);
+	matrixEn.x30 = 0;
+	matrixEn.x31 = 0;
+	matrixEn.x32 = 0;
+	matrixEn.x33 = 1024;
+
+	if (out_csc == 1) { /* rgb to yuv */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7));
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
+	} else if (out_csc == 0) { /* rgb to rgb */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7));
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixresult);
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7) + 0x40);
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
+	} else if (out_csc == 2) {
+		__scal_matrix4x4 matrix_16_255;
+
+#if 0
+		/* rgb to rgb */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7));
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (2 << 7) + 0x40);
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixresult, &matrixresult);
+
+		/* rgb to igb */
+		matrix_16_255.x00 = 0x0155;
+		matrix_16_255.x01 = 0x0155;
+		matrix_16_255.x02 = 0x0155;
+		matrix_16_255.x03 = 0;
+		matrix_16_255.x10 = 0;
+		matrix_16_255.x11 = 0x0400;
+		matrix_16_255.x12 = 0;
+		matrix_16_255.x13 = 0;
+		matrix_16_255.x20 = 0;
+		matrix_16_255.x21 = 0;
+		matrix_16_255.x22 = 0x0400;
+		matrix_16_255.x23 = 0;
+		matrix_16_255.x30 = 0;
+		matrix_16_255.x31 = 0;
+		matrix_16_255.x32 = 0;
+		matrix_16_255.x33 = 0;
+		iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
+#else
+		matrix_16_255.x00 = 0x00C3;
+		matrix_16_255.x01 = 0x029A;
+		matrix_16_255.x02 = 0x00A4;
+		matrix_16_255.x03 = 0x0000;
+		matrix_16_255.x10 = 0xFFFFFF8C;
+		matrix_16_255.x11 = 0xFFFFFE74;
+		matrix_16_255.x12 = 0x0200;
+		matrix_16_255.x13 = 0x20000;	//0x0800;
+		matrix_16_255.x20 = 0x0200;
+		matrix_16_255.x21 = 0xFFFFFE65;
+		matrix_16_255.x22 = 0xFFFFFF9B;
+		matrix_16_255.x23 = 0x20000;	//0x0800;
+		matrix_16_255.x30 = 0x0000;
+		matrix_16_255.x31 = 0x0000;
+		matrix_16_255.x32 = 0x0000;
+		matrix_16_255.x33 = 0x0000;
+		ptmatrix = &matrix_16_255;
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixresult);
+#endif
+	}
+
+	if (out_color_range == 0) { /* [16,255] */
+		__scal_matrix4x4 matrix_16_255;
+
+		matrix_16_255.x00 = 0x03c4;
+		matrix_16_255.x01 = 0;
+		matrix_16_255.x02 = 0;
+		matrix_16_255.x03 = 0x0100;
+		matrix_16_255.x10 = 0;
+		matrix_16_255.x11 = 0x03c4;
+		matrix_16_255.x12 = 0;
+		matrix_16_255.x13 = 0x0100;
+		matrix_16_255.x20 = 0;
+		matrix_16_255.x21 = 0;
+		matrix_16_255.x22 = 0x03c4;
+		matrix_16_255.x23 = 0x0100;
+		matrix_16_255.x30 = 0;
+		matrix_16_255.x31 = 0;
+		matrix_16_255.x32 = 0;
+		matrix_16_255.x33 = 0;
+		iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
+	} else if (out_color_range == 2) { /* [16,235] */
+		__scal_matrix4x4 matrix_16_255;
+
+		matrix_16_255.x00 = 0x0370;
+		matrix_16_255.x01 = 0;
+		matrix_16_255.x02 = 0;
+		matrix_16_255.x03 = 0x0100;
+		matrix_16_255.x10 = 0;
+		matrix_16_255.x11 = 0x0370;
+		matrix_16_255.x12 = 0;
+		matrix_16_255.x13 = 0x0100;
+		matrix_16_255.x20 = 0;
+		matrix_16_255.x21 = 0;
+		matrix_16_255.x22 = 0x0370;
+		matrix_16_255.x23 = 0x0100;
+		matrix_16_255.x30 = 0;
+		matrix_16_255.x31 = 0;
+		matrix_16_255.x32 = 0;
+		matrix_16_255.x33 = 0;
+		iDE_SCAL_Matrix_Mul(matrix_16_255, matrixresult, &matrixresult);
+	}
+	/*
+	 * data bit convert:
+	 * for coefficient:
+	 *   1 bit sign,
+	 *   2 bit integer,
+	 *  10 bits fractional
+	 * for constant:
+	 *   1 bit sign,
+	 *   9 bit integer,
+	 *   4 bit fractional
+	 *
+	 * range limited
+	 */
+	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -16383, 16383, 6, 32767);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -16383, 16383, 6, 32767);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -16383, 16383, 6, 32767);
+
+	/* write csc register */
+	pt = &(matrixresult.x00);
+
+	for (i = 0; i < 4; i++) {
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_R_COEFF_OFF + 4 * i,
+			      *(pt + i));
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_G_COEFF_OFF + 4 * i,
+			      *(pt + 4 + i));
+		DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_B_COEFF_OFF + 4 * i,
+			      *(pt + 8 + i));
+#if 0
+		DE_WRN("R:%x,\tG:%x,\tB:%x\n", *(pt + i), *(pt + 4 + i),
+		       *(pt + 8 + i));
+#endif
+	}
+
+	DE_BE_enhance_enable(sel, 1);
+	return 0;
+}
+#endif /* not CONFIG_ARCH_SUN5I */
+
+__s32 DE_BE_enhance_enable(__u32 sel, bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_OUT_COLOR_CTRL_OFF, enable);
+
+	return 0;
+}
+
+__s32 DE_BE_deflicker_enable(__u32 sel, __bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      (DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & (~(1 << 4))) |
+		      (enable << 4));
+
+	return 0;
+}
+
+__s32 DE_BE_Set_Outitl_enable(__u32 sel, __bool enable)
+{
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+		      (DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) & (~(1 << 28))) |
+		      (enable << 28));
+
+	return 0;
+}
+
+__s32 DE_BE_set_display_size(__u32 sel, __u32 width, __u32 height)
+{
+	DE_BE_WUINT32(sel, DE_BE_DISP_SIZE_OFF,
+		      ((height - 1) << 16) | (width - 1));
+	return 0;
+}
+
+__s32 DE_BE_get_display_width(__u32 sel)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_DISP_SIZE_OFF) & 0x0000ffff;
+
+	return tmp + 1;
+}
+
+__s32 DE_BE_get_display_height(__u32 sel)
+{
+	__u32 tmp;
+
+	tmp = (DE_BE_RUINT32(sel, DE_BE_DISP_SIZE_OFF) & 0xffff0000) >> 16;
+
+	return tmp + 1;
+}
+
+__s32 DE_BE_EnableINT(__u8 sel, __u32 irqsrc)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_INT_EN_OFF);
+	DE_BE_WUINT32(sel, DE_BE_INT_EN_OFF, tmp | irqsrc);
+
+	return 0;
+}
+
+__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_INT_EN_OFF);
+	DE_BE_WUINT32(sel, DE_BE_INT_EN_OFF, tmp & (~irqsrc));
+
+	return 0;
+}
+
+__u32 DE_BE_QueryINT(__u8 sel)
+{
+	__u32 ret = 0;
+
+	ret = DE_BE_RUINT32(sel, DE_BE_INT_FLAG_OFF);
+
+	return ret;
+}
+
+__u32 DE_BE_ClearINT(__u8 sel, __u32 irqsrc)
+{
+	DE_BE_WUINT32(sel, DE_BE_INT_FLAG_OFF, irqsrc);
+
+	return 0;
+}
diff --git a/drivers/video/sunxi/disp/de_be.h b/drivers/video/sunxi/disp/de_be.h
new file mode 100644
index 0000000..9e7df28
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_be.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DE_BE_H__
+#define __DE_BE_H__
+
+#include "ebios_de.h"
+
+/*back-end registers offset*/
+#define DE_BE_MODE_CTL_OFF		0x800 /* back-end mode control register offset */
+#define DE_BE_COLOR_CTL_OFF		0x804 /* back-end color control register offset */
+#define DE_BE_DISP_SIZE_OFF		0x808 /* back-end display size setting register offset */
+#define DE_BE_ERROR_CORRECTION		0x80c
+#define DE_BE_LAYER_SIZE_OFF		0x810 /* back-end layer size register offset */
+#define DE_BE_LAYER_CRD_CTL_OFF		0x820 /* back-end layer coordinate control register offset */
+#define DE_BE_FRMBUF_WLINE_OFF		0x840 /* back-end frame buffer line width register offset */
+#define DE_BE_FRMBUF_LOW32ADDR_OFF	0X850 /* back-end frame buffer low 32bit address register offset */
+#define DE_BE_FRMBUF_HIGH4ADDR_OFF	0X860 /* back-end frame buffer high 4bit address register offset */
+#define DE_BE_FRMBUF_CTL_OFF		0X870 /* back-end frame buffer control register offset */
+#define DE_BE_CLRKEY_MAX_OFF		0x880 /* back-end color key max register offset */
+#define DE_BE_CLRKEY_MIN_OFF		0x884 /* back-end color key min register offset */
+#define DE_BE_CLRKEY_CFG_OFF		0x888 /* back-end color key configuration register offset */
+#define DE_BE_LAYER_ATTRCTL_OFF0	0x890 /* back-end layer attribute control register0 offset */
+#define DE_BE_LAYER_ATTRCTL_OFF1	0x8a0 /* back-end layer attribute control register1 offset */
+#define DE_BE_DLCDP_CTL_OFF		0x8b0 /* direct lcd pipe control register offset */
+#define DE_BE_DLCDP_FRMBUF_ADDRCTL_OFF	0x8b4 /* direct lcd pipe frame buffer address control register offset */
+#define DE_BE_DLCDP_CRD_CTL_OFF0	0x8b8 /* direct lcd pipe coordinate control register0 offset */
+#define DE_BE_DLCDP_CRD_CTL_OFF1	0x8bc /* direct lcd pipe coordinate control register1 offset */
+#define DE_BE_INT_EN_OFF		0x8c0
+#define DE_BE_INT_FLAG_OFF		0x8c4
+#define DE_BE_HWC_CRD_CTL_OFF		0x8d8 /* hardware cursor coordinate control register offset */
+#define DE_BE_HWC_FRMBUF_OFF		0x8e0 /* hardware cursor framebuffer control */
+#define DE_BE_WB_CTRL_OFF		0x8f0 /* back-end write back control */
+#define DE_BE_WB_ADDR_OFF		0x8f4 /* back-end write back address */
+#define DE_BE_WB_LINE_WIDTH_OFF		0x8f8 /* back-end write back buffer line width */
+#define DE_BE_SPRITE_EN_OFF		0x900 /* sprite enable */
+#define DE_BE_SPRITE_FORMAT_CTRL_OFF	0x908 /* sprite format control */
+#define DE_BE_SPRITE_ALPHA_CTRL_OFF	0x90c /* sprite alpha control */
+#define DE_BE_SPRITE_POS_CTRL_OFF	0xa00 /* sprite single block coordinate control */
+#define DE_BE_SPRITE_ATTR_CTRL_OFF	0xb00 /* sprite single block attribute control */
+#define DE_BE_SPRITE_ADDR_OFF		0xc00 /* sprite single block address setting SRAM array */
+#define DE_BE_SPRITE_LINE_WIDTH_OFF	0xd00
+#define DE_BE_YUV_CTRL_OFF		0x920 /* back-end input YUV channel control */
+#define DE_BE_YUV_ADDR_OFF		0x930 /* back-end YUV channel frame buffer address */
+#define DE_BE_YUV_LINE_WIDTH_OFF	0x940 /* back-end YUV channel buffer line width */
+#define DE_BE_YG_COEFF_OFF		0x950 /* back Y/G coefficient */
+#define DE_BE_YG_CONSTANT_OFF		0x95c /* back Y/G constant */
+#define DE_BE_UR_COEFF_OFF		0x960 /* back U/R coefficient */
+#define DE_BE_UR_CONSTANT_OFF		0x96c /* back U/R constant */
+#define DE_BE_VB_COEFF_OFF		0x970 /* back V/B coefficient */
+#define DE_BE_VB_CONSTANT_OFF		0x97c /* back V/B constant */
+#define DE_BE_OUT_COLOR_CTRL_OFF	0x9c0
+#define DE_BE_OUT_COLOR_R_COEFF_OFF	0x9d0
+#define DE_BE_OUT_COLOR_R_CONSTANT_OFF	0x9dc
+#define DE_BE_OUT_COLOR_G_COEFF_OFF	0x9e0
+#define DE_BE_OUT_COLOR_G_CONSTANT_OFF	0x9ec
+#define DE_BE_OUT_COLOR_B_COEFF_OFF	0x9f0
+#define DE_BE_OUT_COLOR_B_CONSTANT_OFF	0x9fc
+
+#define DE_BE_REG_ADDR_OFF			0x0
+#define DE_BE_HWC_PALETTE_TABLE_ADDR_OFF	0x4c00 /* back-end hardware cursor palette table address */
+#define DE_BE_INTER_PALETTE_TABLE_ADDR_OFF	0x5000 /* back-end internal framebuffer or direct lcd pipe palette table */
+#define DE_BE_SPRITE_PALETTE_TABLE_ADDR_OFF	0x4000 /* back-end sprite palette table address */
+#define DE_BE_HWC_MEMORY_ADDR_OFF		0x4800 /* back-end hwc pattern memory block address */
+#define DE_BE_INTERNAL_FB_ADDR_OFF		0x4000 /* back-end internal frame bufffer address definition */
+#define DE_BE_GAMMA_TABLE_ADDR_OFF		0x4400 /* back-end gamma table address */
+#define DE_BE_PALETTE_TABLE_ADDR_OFF		0x5000 /* back-end palette table address */
+#define DE_FE_REG_ADDR_OFF			0x20000
+#define DE_SCAL2_REG_ADDR_OFF			0x40000
+
+#define DE_BE_REG_SIZE			0x1000
+#define DE_BE_HWC_PALETTE_TABLE_SIZE	0x400 /* back-end hardware cursor palette table size */
+#define DE_BE_INTER_PALETTE_TABLE_SIZE	0x400 /* back-end internal framebuffer or direct lcd pipe palette table size in bytes */
+#define DE_BE_SPRITE_PALETTE_TABLE_SIZE	0x400 /* back-end sprite palette table size in bytes */
+#define DE_BE_HWC_PATTERN_SIZE		0x400
+#define DE_BE_INTERNAL_FB_SIZE		0x1800 /* back-end internal frame buffer size in byte*/
+#define DE_BE_GAMMA_TABLE_SIZE		0x400 /* back-end gamma table size */
+#define DE_BE_PALETTE_TABLE_SIZE	0x400 /* back-end palette table size in bytes */
+#define DE_FE_REG_SIZE			0x1000
+#define DE_SCAL2_REG_SIZE		0x1000
+
+extern __u32 image_reg_base[2];
+#define DE_BE_GET_REG_BASE(sel) image_reg_base[sel]
+
+#define DE_BE_WUINT8(sel, offset, value) \
+	writeb(value, DE_BE_GET_REG_BASE(sel)+offset)
+#define DE_BE_RUINT8(sel, offset) \
+	readb(DE_BE_GET_REG_BASE(sel)+offset)
+#define DE_BE_WUINT16(sel, offset, value) \
+	writew(value, DE_BE_GET_REG_BASE(sel)+offset)
+#define DE_BE_RUINT16(sel, offset) \
+	readw(DE_BE_GET_REG_BASE(sel)+offset)
+#define DE_BE_WUINT32(sel, offset, value) \
+	writel(value, DE_BE_GET_REG_BASE(sel)+offset)
+#define DE_BE_RUINT32(sel, offset) \
+	readl(DE_BE_GET_REG_BASE(sel)+offset)
+#define DE_BE_WUINT8IDX(sel, offset, index, value) \
+	writeb(value, DE_BE_GET_REG_BASE(sel)+(offset)+index)
+#define DE_BE_RUINT8IDX(sel, offset, index) \
+	readb(DE_BE_GET_REG_BASE(sel)+(offset)+index)
+#define DE_BE_WUINT16IDX(sel, offset, index, value) \
+	writew(value, DE_BE_GET_REG_BASE(sel)+(offset)+2*index)
+#define DE_BE_RUINT16IDX(sel, offset, index) \
+	readw(DE_BE_GET_REG_BASE(sel)+(offset)+2*index)
+#define DE_BE_WUINT32IDX(sel, offset, index, value) \
+	writel(value, DE_BE_GET_REG_BASE(sel)+(offset)+4*index)
+#define DE_BE_RUINT32IDX(sel, offset, index) \
+	readl(DE_BE_GET_REG_BASE(sel)+(offset)+4*index)
+
+#define FIR_TAB_SUN4I_SIZE 1792
+#define FIR_TAB_SUN5I_SIZE 672
+
+extern __u32 csc_tab[192];
+extern __u32 image_enhance_tab[224];
+extern __u32 fir_tab_sun4i[FIR_TAB_SUN4I_SIZE];
+extern __u32 fir_tab_sun5i[FIR_TAB_SUN5I_SIZE];
+
+#endif
diff --git a/drivers/video/sunxi/disp/de_fe.c b/drivers/video/sunxi/disp/de_fe.c
new file mode 100644
index 0000000..92799a0
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_fe.c
@@ -0,0 +1,2766 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <plat/system.h>
+#include "de_fe.h"
+
+static volatile __de_scal_dev_t *scal_dev[2];
+static __u32 de_scal_ch0_offset;
+static __u32 de_scal_ch1_offset;
+static __u32 de_scal_ch2_offset;
+static __u32 de_scal_trd_fp_en;
+static __u32 de_scal_trd_itl_en;
+static __u32 de_scal_ch0r_offset;
+static __u32 de_scal_ch1r_offset;
+static __u32 de_scal_ch2r_offset;
+
+
+/*
+ * set scale reg base.
+ */
+__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base)
+{
+	scal_dev[sel] = (__de_scal_dev_t *) base;
+
+	return 0;
+}
+
+/*
+ * get scale reg base
+ */
+__u32 DE_SCAL_Get_Reg_Base(__u8 sel)
+{
+	__u32 ret = 0;
+
+	ret = (__u32) (scal_dev[sel]);
+
+	return ret;
+}
+
+/*
+ * scaler source concerning parameter configure
+ * args:
+ *   sel:   scaler select
+ *   addr:  frame buffer address for 3 channel, 32 bit absolute address
+ *   size:  scale region define,  src size, offset, scal size
+ *   type:  src data type, include byte sequence, mode, format, pixel sequence
+ *   field: frame/field data get
+ *   dien:  deinterlace enable
+ */
+__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr,
+			 __scal_src_size_t *size, __scal_src_type_t *type,
+			 __u8 field, __u8 dien)
+{
+	__u8 w_shift, h_shift;
+	__u32 image_w0, image_w1;
+	__u32 x_off0, y_off0, x_off1, y_off1;
+	__u32 in_w0, in_h0, in_w1, in_h1;
+
+	image_w0 = size->src_width;
+	in_w0 = size->scal_width;
+	in_h0 = size->scal_height;
+	x_off0 = size->x_off;
+	/* scan mod enable or deinterlace, odd dy un-support */
+	y_off0 = (field | dien) ? (size->y_off & 0xfffffffe) : size->y_off;
+
+#if 0
+	if (sel == 0) /* scaler 0 scaler 1 */
+#endif
+	{
+		if (type->fmt == DE_SCAL_INYUV422 ||
+		    type->fmt == DE_SCAL_INYUV420) {
+			w_shift = 1;
+			image_w1 = (image_w0 + 0x1) >> w_shift;
+			in_w1 = (in_w0 + 0x1) >> w_shift;
+			x_off1 = (x_off0) >> w_shift;
+
+			if (type->mod == DISP_MOD_INTERLEAVED) {
+				image_w0 = (image_w0 + 0x1) & 0xfffffffe;
+				image_w1 = image_w0 >> 1;
+				in_w0 &= 0xfffffffe;
+				in_w1 = in_w0 >> 0x1;
+				x_off0 &= 0xfffffffe;
+				x_off1 = x_off0 >> w_shift;
+			}
+		} else if (type->fmt == DE_SCAL_INYUV411) {
+			w_shift = 2;
+			image_w1 = (image_w0 + 0x3) >> w_shift;
+			in_w1 = (in_w0 + 0x3) >> w_shift;
+			x_off1 = (x_off0) >> w_shift;
+		} else {
+			w_shift = 0;
+			image_w1 = image_w0;
+			in_w1 = in_w0;
+			x_off1 = x_off0;
+		}
+		if (type->fmt == DE_SCAL_INYUV420 ||
+		    type->fmt == DE_SCAL_INCSIRGB) {
+			h_shift = 1;
+			in_h1 = (in_h0 + 0x1) >> h_shift;
+			y_off1 = (y_off0) >> h_shift;
+		} else {
+			h_shift = 0;
+			in_h1 = in_h0;
+			y_off1 = y_off0;
+		}
+	}
+
+	/* added no-zero limited */
+	in_h0 = (in_h0 != 0) ? in_h0 : 1;
+	in_h1 = (in_h1 != 0) ? in_h1 : 1;
+	in_w0 = (in_w0 != 0) ? in_w0 : 1;
+	in_w1 = (in_w1 != 0) ? in_w1 : 1;
+
+	if (type->mod == DISP_MOD_NON_MB_PLANAR) {
+		scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1;
+		scal_dev[sel]->linestrd2.dwval = image_w1;
+
+		de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+		de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
+		de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+	} else if (type->mod == DISP_MOD_INTERLEAVED) {
+		scal_dev[sel]->linestrd0.dwval = image_w0 << (0x2 - w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0x0;
+		scal_dev[sel]->linestrd2.dwval = 0x0;
+
+		de_scal_ch0_offset =
+			((image_w0 * y_off0 + x_off0) << (0x2 - w_shift));
+		de_scal_ch1_offset = 0x0;
+		de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
+	} else if (type->mod == DISP_MOD_NON_MB_UV_COMBINED) {
+		scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1 << 1;
+		scal_dev[sel]->linestrd2.dwval = 0x0;
+
+		de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+		de_scal_ch1_offset = (((image_w1) * (y_off1) + (x_off1)) << 1);
+		de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr;
+	} else if (type->mod == DISP_MOD_MB_PLANAR) {
+		image_w0 = (image_w0 + 0xf) & 0xfff0;
+		image_w1 = (image_w1 + (0xf >> w_shift)) & (~(0xf >> w_shift));
+
+		/* block offset */
+		scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x0f);
+		scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x0f);
+		scal_dev[sel]->mb_off0.bits.x_offset1 =
+			(((x_off0 & 0x0f) & (0x0f)) + in_w0 + 0x0f) & 0x0f;
+		scal_dev[sel]->mb_off1.bits.x_offset0 =
+			((x_off1) & (0x0f >> w_shift));
+		scal_dev[sel]->mb_off1.bits.y_offset0 =
+			((y_off1) & (0x0f >> h_shift));
+		scal_dev[sel]->mb_off1.bits.x_offset1 =
+			((((x_off1) & (0x0f >> w_shift)) & (0x0f >> w_shift)) +
+			 (in_w1) + (0x0f >> w_shift)) & (0x0f >> w_shift);
+		scal_dev[sel]->mb_off2.bits.x_offset0 =
+			scal_dev[sel]->mb_off1.bits.x_offset0;
+		scal_dev[sel]->mb_off2.bits.y_offset0 =
+			scal_dev[sel]->mb_off1.bits.y_offset0;
+		scal_dev[sel]->mb_off2.bits.x_offset1 =
+			scal_dev[sel]->mb_off1.bits.x_offset1;
+
+		scal_dev[sel]->linestrd0.dwval = (image_w0 - 0xf) << 4;
+		scal_dev[sel]->linestrd1.dwval =
+			((image_w1) << (0x04 - h_shift)) -
+			((0xf >> h_shift) << (0x04 - w_shift));
+		scal_dev[sel]->linestrd2.dwval = scal_dev[sel]->linestrd1.dwval;
+
+		de_scal_ch0_offset =
+			((image_w0 + 0x0f) & 0xfff0) * (y_off0 & 0xfff0) +
+			((y_off0 & 0x00f) << 4) + ((x_off0 & 0xff0) << 4);
+		de_scal_ch1_offset =
+			(((image_w1) +
+			  (0x0f >> w_shift)) & (0xfff0 >> w_shift)) *
+			((y_off1) & (0xfff0 >> h_shift)) +
+			((((y_off1) & (0x00f >> h_shift)) << (0x4 - w_shift))) +
+			(((x_off1) & (0xfff0 >> w_shift)) << (0x4 - h_shift));
+		de_scal_ch2_offset = de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+	} else if (type->mod == DISP_MOD_MB_UV_COMBINED) {
+		image_w0 = (image_w0 + 0x1f) & 0xffffffe0;
+		image_w1 = (image_w1 + 0x0f) & 0xfffffff0;
+
+		/* block offset */
+		scal_dev[sel]->mb_off0.bits.x_offset0 = (x_off0 & 0x1f);
+		scal_dev[sel]->mb_off0.bits.y_offset0 = (y_off0 & 0x1f);
+		scal_dev[sel]->mb_off0.bits.x_offset1 =
+			(((x_off0 & 0x1f) & 0x1f) + in_w0 + 0x1f) & 0x1f;
+		scal_dev[sel]->mb_off1.bits.x_offset0 =
+			(((x_off1) << 1) & 0x1f);
+		scal_dev[sel]->mb_off1.bits.y_offset0 = ((y_off1) & 0x1f);
+		scal_dev[sel]->mb_off1.bits.x_offset1 =
+			(((((x_off1) << 1) & 0x1f) & 0x1e) + ((in_w1) << 1) +
+			 0x1f) & 0x1f;
+
+		scal_dev[sel]->linestrd0.dwval =
+			(((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd1.dwval =
+			(((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		de_scal_ch0_offset =
+			((image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
+			((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
+		de_scal_ch1_offset =
+			(((image_w1 << 0x01) +
+			  0x1f) & 0xffe0) * ((y_off1) & 0xffe0) +
+			(((y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
+		de_scal_ch2_offset = 0x0;
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval = 0x0;
+	}
+
+	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
+	scal_dev[sel]->input_fmt.bits.data_mod = type->mod;
+	scal_dev[sel]->input_fmt.bits.data_fmt = type->fmt;
+	scal_dev[sel]->input_fmt.bits.data_ps = type->ps;
+
+	scal_dev[sel]->ch0_insize.bits.in_width = in_w0 - 1;
+	scal_dev[sel]->ch0_insize.bits.in_height = in_h0 - 1;
+	scal_dev[sel]->ch1_insize.bits.in_width = in_w1 - 1;
+	scal_dev[sel]->ch1_insize.bits.in_height = in_h1 - 1;
+
+	scal_dev[sel]->trd_ctrl.dwval = 0;
+	return 0;
+}
+
+/*
+ * scaler change frame buffer address, only change start address parameters.
+ *
+ * address is the frame buffer address for 3 channel, 32 bit absolute address.
+ */
+__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr)
+{
+	scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr + de_scal_ch0_offset;
+	scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr + de_scal_ch1_offset;
+	scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr + de_scal_ch2_offset;
+
+	return 0;
+}
+
+/*
+ * Set scaler init phase according to in/out information.
+ *
+ * Args:
+ *   sel: scaler select
+ *   in_scan: scale src data scan mode, if deinterlaceing open, the scan mode is
+ *            progressive for scale
+ *   in_size: scale region define,  src size, offset, scal size
+ *   in_type: src data type
+ *   out_scan: scale output data scan mode
+ *   out_size: scale out size
+ *   out_type: output data format
+ *   dien: deinterlace enable
+ *
+ * Note: when 3D mode (when output mode is HDMI_FPI), the Function Set_3D_Ctrl
+ * must carry out first. When 3D mode(HDMI_FPI), this function used once.
+ */
+__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan,
+			     __scal_src_size_t *in_size,
+			     __scal_src_type_t *in_type,
+			     __scal_scan_mod_t *out_scan,
+			     __scal_out_size_t *out_size,
+			     __scal_out_type_t *out_type, __u8 dien)
+{
+	__s32 ch0_h_phase = 0, ch0_v_phase0 = 0, ch0_v_phase1 =
+	    0, ch12_h_phase = 0, ch12_v_phase0 = 0, ch12_v_phase1 = 0;
+	__u8 h_shift = 0, w_shift = 0;
+	__s32 in_h0, in_h1, out_h0, out_h1;
+
+	/* set register value */
+	scal_dev[sel]->output_fmt.bits.scan_mod = out_scan->field;
+	/* out scan and in scan are not valid at the same time */
+	scal_dev[sel]->input_fmt.bits.scan_mod =
+		out_scan->field ? 0x0 : in_scan->field;
+	/*
+	 * Added for 3D top_bottom mode, zchmin 2011-05-04.
+	 * note: when HDMI_FPI, the input inscan mode must open,
+	 */
+	if (de_scal_trd_itl_en == 0) {
+		scal_dev[sel]->field_ctrl.bits.field_loop_mod = 0x0;
+		scal_dev[sel]->field_ctrl.bits.valid_field_cnt = 0x1 - 0x1;
+		scal_dev[sel]->field_ctrl.bits.field_cnt = in_scan->bottom;
+	}
+
+	/* sampling method, phase */
+	if (in_type->fmt == DE_SCAL_INYUV420) {
+		if (in_type->sample_method == 0x0) {
+			ch0_h_phase = 0x0;
+			ch0_v_phase0 = 0x0;
+			ch0_v_phase1 = 0x0;
+			ch12_h_phase = 0xfc000; /* -0.25 */
+			ch12_v_phase0 = 0xfc000; /* -0.25 */
+			ch12_v_phase1 = 0xfc000; /* -0.25 */
+		} else {
+			ch0_h_phase = 0x0;
+			ch0_v_phase0 = 0x0;
+			ch0_v_phase1 = 0x0;
+			ch12_h_phase = 0x0; /* 0 */
+			ch12_v_phase0 = 0xfc000; /* -0.25 */
+			ch12_v_phase1 = 0xfc000; /* -0.25 */
+		}
+	} else { /* can added yuv411 or yuv420 init phase for sample method */
+		ch0_h_phase = 0x0;
+		ch0_v_phase0 = 0x0;
+		ch0_v_phase1 = 0x0;
+		ch12_h_phase = 0x0;
+		ch12_v_phase0 = 0x0;
+		ch12_v_phase1 = 0x0;
+	}
+
+	/* location offset */
+	w_shift = (in_type->fmt == DE_SCAL_INYUV420 ||
+		   in_type->fmt == DE_SCAL_INYUV422) ?
+		0x1 : ((in_type->fmt == DE_SCAL_INYUV411) ? 0x2 : 0x0);
+	h_shift = (in_type->fmt == DE_SCAL_INYUV420 ||
+		   in_type->fmt == DE_SCAL_INCSIRGB) ? 0x1 : 0x0;
+
+	/* deinterlace and in scan mode enable, --dy */
+	if (((dien == 0x01) || (in_scan->field == 0x1)) &&
+	    (in_size->y_off & 0x1) && (in_scan->bottom == 0x0))	{
+		ch0_v_phase0 = (ch0_v_phase0 + 0x10000) & SCALINITPASELMT;
+		ch12_v_phase0 = (ch12_v_phase0 + 0x10000) & SCALINITPASELMT;
+	} else {
+		ch12_v_phase0 = (ch12_v_phase0 +
+				 (in_size->y_off & ((1 << h_shift) - 1)) *
+				 (0x10000 >> h_shift)) & SCALINITPASELMT;
+		ch12_v_phase1 = ch12_v_phase0;
+	}
+
+	/* dx */
+	scal_dev[sel]->ch0_horzphase.bits.phase = ch0_h_phase;
+	scal_dev[sel]->ch1_horzphase.bits.phase =
+	    (ch12_h_phase + (in_size->x_off & ((1 << w_shift) - 1)) *
+	     (0x10000 >> w_shift)) & SCALINITPASELMT;
+
+	/* outinterlace, */
+	if (out_scan->field == 0x1) { /* outinterlace enable */
+		in_h0 = in_size->scal_height;
+		in_h1 = (in_type->fmt == DE_SCAL_INYUV420) ?
+			(in_h0 + 0x1) >> 1 : in_h0;
+		out_h0 = out_size->height;
+		out_h1 = (out_type->fmt == DE_SCAL_OUTPYUV420) ?
+			(out_h0 + 0x1) >> 1 : out_h0;
+
+		/* added no-zero limited */
+		in_h0 = (in_h0 != 0) ? in_h0 : 1;
+		in_h1 = (in_h1 != 0) ? in_h1 : 1;
+		out_h0 = (out_h0 != 0) ? out_h0 : 1;
+		out_h1 = (out_h1 != 0) ? out_h1 : 1;
+
+		if (in_scan->bottom == 0x0) {
+			scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
+			scal_dev[sel]->ch0_vertphase1.bits.phase =
+				ch0_v_phase0 +
+				((in_h0 >> in_scan->field) << 16) / (out_h0);
+			scal_dev[sel]->ch1_vertphase0.bits.phase =
+				ch12_v_phase0;
+			scal_dev[sel]->ch1_vertphase1.bits.phase =
+				ch12_v_phase0 +
+				((in_h1 >> in_scan->field) << 16) / (out_h1);
+		} else {
+			scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase1;
+			scal_dev[sel]->ch0_vertphase1.bits.phase =
+				ch0_v_phase1 +
+				((in_h0 >> in_scan->field) << 16) / (out_h0);
+			scal_dev[sel]->ch1_vertphase0.bits.phase =
+				ch12_v_phase1;
+			scal_dev[sel]->ch1_vertphase1.bits.phase =
+				ch12_v_phase1 +
+				((in_h1 >> in_scan->field) << 16) / (out_h1);
+		}
+	} else { /* outinterlace disable */
+		scal_dev[sel]->ch0_vertphase0.bits.phase = ch0_v_phase0;
+		scal_dev[sel]->ch0_vertphase1.bits.phase = ch0_v_phase1;
+		scal_dev[sel]->ch1_vertphase0.bits.phase = ch12_v_phase0;
+		scal_dev[sel]->ch1_vertphase1.bits.phase = ch12_v_phase1;
+	}
+
+	return 0;
+}
+
+/*
+ * Sset scaler scaling factor, modify algorithm and tape offset.
+ *
+ * Args:
+ *  sel:      scaler select
+ *  in_scan:  scale src data scan mode, if deinterlaceing open, the scan mode is
+ *            progressive for scale
+ *  in_size:  scale region define,  src size, offset, scal size
+ *  in_type:  src data type
+ *  out_scan: scale output data scan mode
+ *  out_size: scale out size, when output interlace, the height is 2xoutheight.
+ *            For example 480i, the value is 480.
+ *  out_type: output data format
+ */
+__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan,
+				 __scal_src_size_t *in_size,
+				 __scal_src_type_t *in_type,
+				 __scal_scan_mod_t *out_scan,
+				 __scal_out_size_t *out_size,
+				 __scal_out_type_t *out_type)
+{
+	__s32 in_w0, in_h0, out_w0, out_h0;
+	__s32 ch0_hstep, ch0_vstep;
+	__s8 w_shift, h_shift;
+
+	in_w0 = in_size->scal_width;
+	in_h0 = in_size->scal_height;
+
+	out_w0 = out_size->width;
+	out_h0 = out_size->height + (out_scan->field & 0x1);
+
+	/* sc0 */
+	if ((in_type->mod == DISP_MOD_INTERLEAVED) &&
+	    (in_type->fmt == DE_SCAL_INYUV422))
+		in_w0 &= 0xfffffffe;
+
+	/* algorithm select */
+	if (out_w0 > SCALLINEMAX) {
+		scal_dev[sel]->agth_sel.bits.linebuf_agth = 0x1;
+		if (in_w0 > SCALLINEMAX)
+			in_w0 = SCALLINEMAX;
+	} else
+		scal_dev[sel]->agth_sel.bits.linebuf_agth = 0x0;
+
+	w_shift = (in_type->fmt == DE_SCAL_INYUV411) ? 2 :
+		((in_type->fmt == DE_SCAL_INYUV420) ||
+		 (in_type->fmt == DE_SCAL_INYUV422)) ? 1 : 0;
+	h_shift = ((in_type->fmt == DE_SCAL_INYUV420) ||
+		   (in_type->fmt == DE_SCAL_INCSIRGB)) ? 1 : 0;
+
+	if ((out_type->fmt == DE_SCAL_OUTPYUV420) ||
+	    (out_type->fmt == DE_SCAL_OUTPYUV422))
+		w_shift -= 1;
+	else if (out_type->fmt == DE_SCAL_OUTPYUV411)
+		w_shift -= 2;
+	else
+		w_shift -= 0;
+
+	if (out_type->fmt == DE_SCAL_OUTPYUV420)
+		h_shift -= 1;
+	else
+		h_shift -= 0;
+
+	/* added no-zero limited */
+	in_h0 = (in_h0 != 0) ? in_h0 : 1;
+	in_w0 = (in_w0 != 0) ? in_w0 : 1;
+	out_h0 = (out_h0 != 0) ? out_h0 : 1;
+	out_w0 = (out_w0 != 0) ? out_w0 : 1;
+
+	/* step factor */
+	ch0_hstep = (in_w0 << 16) / out_w0;
+	ch0_vstep = ((in_h0 >> in_scan->field) << 16) / (out_h0);
+
+	scal_dev[sel]->ch0_horzfact.dwval = ch0_hstep;
+	scal_dev[sel]->ch0_vertfact.dwval = ch0_vstep << (out_scan->field);
+	scal_dev[sel]->ch1_horzfact.dwval = (w_shift > 0) ?
+		(ch0_hstep >> w_shift) : ch0_hstep << (0 - w_shift);
+	scal_dev[sel]->ch1_vertfact.dwval = (h_shift > 0) ?
+		(ch0_vstep >> h_shift) << (out_scan->field) :
+		(ch0_vstep << (0 - h_shift)) << (out_scan->field);
+
+	return 0;
+}
+
+/*
+ * set scaler scaling filter coefficients.
+ *
+ * Args:
+ *   sel:       scaler select
+ *   in_scan:   scale src data scan mode, if deinterlaceing open, the scan mode
+ *              is progressive for scale
+ *   in_size:   scale region define,  src size, offset, scal size
+ *   in_type:   src data type
+ *   out_scan:  scale output data scan mode
+ *   out_size:  scale out size
+ *   out_type:  output data format
+ *   smth_mode: scaler filter effect select
+ */
+__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan,
+			       __scal_src_size_t *in_size,
+			       __scal_src_type_t *in_type,
+			       __scal_scan_mod_t *out_scan,
+			       __scal_out_size_t *out_size,
+			       __scal_out_type_t *out_type, __u32 smth_mode)
+{
+	__s32 in_w0, in_h0, in_w1, in_h1, out_w0, out_h0, out_w1, out_h1;
+	__s32 ch0h_smth_level, ch0v_smth_level, ch1h_smth_level,
+	    ch1v_smth_level;
+	__u32 int_part, float_part;
+	__u32 zoom0_size, zoom1_size, zoom2_size, zoom3_size, zoom4_size,
+	    zoom5_size, al1_size;
+	__u32 ch0h_sc, ch0v_sc, ch1h_sc, ch1v_sc;
+	__u32 ch0v_fir_coef_addr, ch0h_fir_coef_addr, ch1v_fir_coef_addr,
+	    ch1h_fir_coef_addr;
+	__u32 ch0v_fir_coef_ofst, ch0h_fir_coef_ofst, ch1v_fir_coef_ofst,
+	    ch1h_fir_coef_ofst;
+	__s32 fir_ofst_tmp;
+	__u32 i;
+
+	in_w0 = in_size->scal_width;
+	in_h0 = in_size->scal_height;
+
+	out_w0 = out_size->width;
+	out_h0 = out_size->height;
+
+	ch1h_smth_level = 0;
+	ch1v_smth_level = 0;
+
+	zoom0_size = 1;
+	zoom1_size = 8;
+	zoom2_size = 4;
+	zoom3_size = 1;
+	zoom4_size = 1;
+	zoom5_size = 1;
+	al1_size = zoom0_size + zoom1_size + zoom2_size + zoom3_size +
+		zoom4_size + zoom5_size;
+
+	if ((in_type->mod == DISP_MOD_INTERLEAVED) &&
+	    (in_type->fmt == DE_SCAL_INYUV422))
+		in_w0 &= 0xfffffffe;
+
+	/* channel 1,2 size  */
+	if ((in_type->fmt == DE_SCAL_INYUV420) ||
+	    (in_type->fmt == DE_SCAL_INYUV422))
+		in_w1 = (in_w0 + 0x1) >> 0x1;
+	else if (in_type->fmt == DE_SCAL_INYUV411)
+		in_w1 = (in_w0 + 0x3) >> 0x2;
+	else
+		in_w1 = in_w0;
+
+	if ((in_type->fmt == DE_SCAL_INYUV420) ||
+	    (in_type->fmt == DE_SCAL_INCSIRGB))
+		in_h1 = (in_h0 + 0x1) >> 0x1;
+	else
+		in_h1 = in_h0;
+
+	if ((out_type->fmt == DE_SCAL_OUTPYUV420) ||
+	    (out_type->fmt == DE_SCAL_OUTPYUV422))
+		out_w1 = (out_w0 + 0x1) >> 0x1;
+	else if (out_type->fmt == DE_SCAL_OUTPYUV411)
+		out_w1 = (out_w0 + 0x3) >> 0x2;
+	else
+		out_w1 = out_w0;
+
+	if (out_type->fmt == DE_SCAL_OUTPYUV420)
+		out_h1 = (out_h0 + 0x1) >> 0x1;
+	else
+		out_h1 = out_h0;
+
+	/* added no-zero limited */
+	in_h0 = (in_h0 != 0) ? in_h0 : 1;
+	in_h1 = (in_h1 != 0) ? in_h1 : 1;
+	in_w0 = (in_w0 != 0) ? in_w0 : 1;
+	in_w1 = (in_w1 != 0) ? in_w1 : 1;
+	out_h0 = (out_h0 != 0) ? out_h0 : 1;
+	out_h1 = (out_h1 != 0) ? out_h1 : 1;
+	out_w0 = (out_w0 != 0) ? out_w0 : 1;
+	out_w1 = (out_w1 != 0) ? out_w1 : 1;
+
+	/* smooth level for channel 0,1 in vertical and horizontal direction */
+	ch0h_smth_level = (smth_mode & 0x40) ?
+		0 - (smth_mode & 0x3f) : smth_mode & 0x3f;
+	ch0v_smth_level = ch0h_smth_level;
+	if ((smth_mode >> 7) & 0x01) {
+		ch0v_smth_level = (smth_mode & 0x4000) ?
+			0 - ((smth_mode & 0x3f00) >> 8) :
+			((smth_mode & 0x3f00) >> 8);
+	}
+	if ((smth_mode >> 31) & 0x01) {
+		ch1h_smth_level = (smth_mode & 0x400000) ?
+			0 - ((smth_mode & 0x3f0000) >> 16) :
+			((smth_mode & 0x3f0000) >> 16);
+		ch1v_smth_level = ch1h_smth_level;
+		if ((smth_mode >> 23) & 0x1) {
+			ch1v_smth_level = (smth_mode & 0x40000000) ?
+				0 - ((smth_mode & 0x3f000000) >> 24) :
+				((smth_mode & 0x3f000000) >> 24);
+		}
+	}
+
+	ch0h_sc = (in_w0 << 3) / out_w0;
+	ch0v_sc = (in_h0 << (3 - in_scan->field)) / (out_h0);
+	ch1h_sc = (in_w1 << 3) / out_w1;
+	ch1v_sc = (in_h1 << (3 - in_scan->field)) / (out_h1);
+
+	/* modify ch1 smooth level according to ratio to ch0 */
+	if (((smth_mode >> 31) & 0x01) == 0x0) {
+		if (!ch1h_sc)
+			ch1h_smth_level = 0;
+		else
+			ch1h_smth_level =
+				ch0h_smth_level >> (ch0h_sc / ch1h_sc);
+
+		if (!ch1v_sc)
+			ch1v_smth_level = 0;
+		else
+			ch1v_smth_level =
+				ch0v_smth_level >> (ch0v_sc / ch1v_sc);
+	}
+	/* comput the fir coefficient offset in coefficient table */
+	int_part = ch0v_sc >> 3;
+	float_part = ch0v_sc & 0x7;
+	ch0v_fir_coef_ofst = (int_part == 0) ? zoom0_size :
+		(int_part == 1) ? zoom0_size + float_part :
+		(int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
+		(int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
+		(int_part == 4) ? zoom0_size + zoom1_size + zoom2_size +
+		zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+	int_part = ch0h_sc >> 3;
+	float_part = ch0h_sc & 0x7;
+	ch0h_fir_coef_ofst = (int_part == 0) ? zoom0_size :
+		(int_part == 1) ? zoom0_size + float_part :
+		(int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
+		(int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
+		(int_part == 4) ? zoom0_size + zoom1_size + zoom2_size +
+		zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+	int_part = ch1v_sc >> 3;
+	float_part = ch1v_sc & 0x7;
+	ch1v_fir_coef_ofst = (int_part == 0) ? zoom0_size :
+		(int_part == 1) ? zoom0_size + float_part :
+		(int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
+		(int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
+		(int_part == 4) ? zoom0_size + zoom1_size + zoom2_size +
+		zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+	int_part = ch1h_sc >> 3;
+	float_part = ch1h_sc & 0x7;
+	ch1h_fir_coef_ofst = (int_part == 0) ? zoom0_size :
+		(int_part == 1) ? zoom0_size + float_part :
+		(int_part == 2) ? zoom0_size + zoom1_size + (float_part >> 1) :
+		(int_part == 3) ? zoom0_size + zoom1_size + zoom2_size :
+		(int_part == 4) ? zoom0_size + zoom1_size + zoom2_size +
+		zoom3_size :
+		zoom0_size + zoom1_size + zoom2_size + zoom3_size + zoom4_size;
+
+	/*
+	 * added smooth level for each channel in horizontal and vertical
+	 * direction
+	 */
+	fir_ofst_tmp = ch0v_fir_coef_ofst + ch0v_smth_level;
+	ch0v_fir_coef_ofst = (fir_ofst_tmp < 0) ? 0 : fir_ofst_tmp;
+	fir_ofst_tmp = ch0h_fir_coef_ofst + ch0h_smth_level;
+	ch0h_fir_coef_ofst = (fir_ofst_tmp < 0) ? 0 : fir_ofst_tmp;
+	fir_ofst_tmp = ch1v_fir_coef_ofst + ch1v_smth_level;
+	ch1v_fir_coef_ofst = (fir_ofst_tmp < 0) ? 0 : fir_ofst_tmp;
+	fir_ofst_tmp = ch1h_fir_coef_ofst + ch1h_smth_level;
+	ch1h_fir_coef_ofst = (fir_ofst_tmp < 0) ? 0 : fir_ofst_tmp;
+	/* modify coefficient offset */
+	ch0v_fir_coef_ofst = (ch0v_fir_coef_ofst > (al1_size - 1)) ?
+		(al1_size - 1) : ch0v_fir_coef_ofst;
+	ch1v_fir_coef_ofst = (ch1v_fir_coef_ofst > (al1_size - 1)) ?
+		(al1_size - 1) : ch1v_fir_coef_ofst;
+	ch0h_fir_coef_ofst = (ch0h_fir_coef_ofst > (al1_size - 1)) ?
+		(al1_size - 1) : ch0h_fir_coef_ofst;
+	ch1h_fir_coef_ofst = (ch1h_fir_coef_ofst > (al1_size - 1)) ?
+		(al1_size - 1) : ch1h_fir_coef_ofst;
+
+	/*
+	 * compute the fir coeficient address for each channel in horizontal and
+	 * vertical direction
+	 */
+	if (!sunxi_is_sun5i()) {
+		ch0v_fir_coef_addr = (ch0v_fir_coef_ofst << 7);
+		ch0h_fir_coef_addr = ((al1_size) << 7) + (ch0h_fir_coef_ofst << 8);
+		ch1v_fir_coef_addr = (ch1v_fir_coef_ofst << 7);
+		ch1h_fir_coef_addr = ((al1_size) << 7) + (ch1h_fir_coef_ofst << 8);
+
+		for (i = 0; i < 32; i++) {
+			scal_dev[sel]->ch0_horzcoef0[i].dwval =
+				fir_tab_sun4i[(ch0h_fir_coef_addr >> 2) + 2 * i];
+			scal_dev[sel]->ch0_horzcoef1[i].dwval =
+				fir_tab_sun4i[(ch0h_fir_coef_addr >> 2) + 2 * i + 1];
+			scal_dev[sel]->ch0_vertcoef[i].dwval =
+				fir_tab_sun4i[(ch0v_fir_coef_addr >> 2) + i];
+			scal_dev[sel]->ch1_horzcoef0[i].dwval =
+				fir_tab_sun4i[(ch1h_fir_coef_addr >> 2) + 2 * i];
+			scal_dev[sel]->ch1_horzcoef1[i].dwval =
+				fir_tab_sun4i[(ch1h_fir_coef_addr >> 2) + 2 * i + 1];
+			scal_dev[sel]->ch1_vertcoef[i].dwval =
+				fir_tab_sun4i[(ch1v_fir_coef_addr >> 2) + i];
+		}
+
+		scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
+	} else {
+		ch0v_fir_coef_addr = (ch0v_fir_coef_ofst << 7);
+		ch0h_fir_coef_addr = (ch0h_fir_coef_ofst << 7);
+		ch1v_fir_coef_addr = (ch1v_fir_coef_ofst << 7);
+		ch1h_fir_coef_addr = (ch1h_fir_coef_ofst << 7);
+
+		/* added for aw1625, wait ceof access */
+		scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl = 1;
+		while (scal_dev[sel]->status.bits.coef_access_status == 0)
+			;
+
+		for (i = 0; i < 32; i++) {
+			scal_dev[sel]->ch0_horzcoef0[i].dwval =
+				fir_tab_sun5i[(ch0h_fir_coef_addr >> 2) + i];
+			scal_dev[sel]->ch0_vertcoef[i].dwval =
+				fir_tab_sun5i[(ch0v_fir_coef_addr >> 2) + i];
+			scal_dev[sel]->ch1_horzcoef0[i].dwval =
+				fir_tab_sun5i[(ch1h_fir_coef_addr >> 2) + i];
+			scal_dev[sel]->ch1_vertcoef[i].dwval =
+				fir_tab_sun5i[(ch1v_fir_coef_addr >> 2) + i];
+		}
+
+		scal_dev[sel]->frm_ctrl.bits.coef_access_ctrl = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Set scaler input/output color space convert coefficients
+ *
+ * Args:
+ *  sel: scaler select
+ *  in_csc_mode: color space select, bt601, bt709, ycc, xycc
+ *  out_csc_mode: color space select, bt601, bt709, ycc, xycc
+ *  incs: source color space
+ *    0: rgb
+ *    1: yuv
+ *  outcs: destination color space
+ *    0: rgb
+ *    1: yuv
+ * in_br_swap: swap b r component
+ *    0: normal
+ *    1: swap enable. Note: when input yuv, then u v swap
+ * out_br_swap: swap output b r component
+ *    0: normal
+ *    1: swap enable. Note: when output yuv, then u v swap
+ */
+__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode,
+			   __u8 incs, __u8 outcs, __u32 in_br_swap,
+			   __u32 out_br_swap)
+{
+	__u8 csc_pass;
+	__u32 csc_coef_addr;
+	__u32 i;
+
+	/* compute csc bypass enable */
+	if (incs == 0x0) { /* rgb */
+		if (outcs == 0x0) { /* rgb */
+			csc_pass = 0x01;
+			csc_coef_addr = ((in_csc_mode & 0x3) << 7) +
+				((in_csc_mode & 0x3) << 6) + 0x60;
+		} else {
+			//out_br_swap = 0;
+			csc_pass = 0x0;
+			csc_coef_addr = ((in_csc_mode & 0x3) << 7) +
+				((in_csc_mode & 0x3) << 6) + 0x60 + 0x30;
+		}
+	} else {
+		//in_br_swap = 0;
+		if (outcs == 0x0) {
+			csc_pass = 0x00;
+			csc_coef_addr = ((in_csc_mode & 0x3) << 7) +
+				((in_csc_mode & 0x3) << 6);
+		} else {
+			csc_pass = 0x01;
+			csc_coef_addr = ((in_csc_mode & 0x3) << 7) +
+				((in_csc_mode & 0x3) << 6) + 0x30;
+		}
+	}
+
+	if (in_br_swap || out_br_swap)
+		csc_pass = 0;
+
+	if (!csc_pass) {
+		for (i = 0; i < 4; i++) {
+			scal_dev[sel]->csc_coef[i].dwval =
+				csc_tab[(csc_coef_addr >> 2) + i];
+			scal_dev[sel]->csc_coef[i + 4 + out_br_swap * 4].dwval =
+				csc_tab[(csc_coef_addr >> 2) + i + 4 +
+					in_br_swap * 4];
+			scal_dev[sel]->csc_coef[i + 8 - out_br_swap * 4].dwval =
+				csc_tab[(csc_coef_addr >> 2) + i + 8 -
+					in_br_swap * 4];
+
+		}
+	}
+	scal_dev[sel]->bypass.bits.csc_bypass_en = csc_pass;
+
+	return 0;
+}
+
+
+/*
+ * Set scaler set output format
+ */
+__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type)
+{
+	scal_dev[sel]->output_fmt.bits.byte_seq = out_type->byte_seq;
+	scal_dev[sel]->output_fmt.bits.data_fmt = out_type->fmt;
+	return 0;
+}
+
+/*
+ * set scaler set output size
+ */
+__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan,
+			   __scal_out_type_t *out_type,
+			   __scal_out_size_t *out_size)
+{
+	__u32 out_w1, out_h1, out_w0, out_h0;
+
+	/* sc0 */
+	if ((out_type->fmt == DE_SCAL_OUTPYUV420) ||
+	    (out_type->fmt == DE_SCAL_OUTPYUV422)) {
+		out_w1 = (out_size->width + 0x1) >> 1;
+	} else if (out_type->fmt == DE_SCAL_OUTPYUV411) {
+		out_w1 = (out_size->width + 0x3) >> 2;
+	} else {
+		out_w1 = out_size->width;
+	}
+
+	if (out_type->fmt == DE_SCAL_OUTPYUV420)
+		out_h1 = (out_size->height + 0x1) >> 1;
+	else
+		out_h1 = out_size->height;
+
+	out_h0 = out_size->height;
+	out_w0 = out_size->width;
+	/* added no-zero limited */
+	out_h0 = (out_h0 != 0) ? out_h0 : 1;
+	out_h1 = (out_h1 != 0) ? out_h1 : 1;
+	out_w0 = (out_w0 != 0) ? out_w0 : 1;
+	out_w1 = (out_w1 != 0) ? out_w1 : 1;
+
+	scal_dev[sel]->ch0_outsize.bits.out_height =
+		((out_h0 + (out_scan->field & 0x1)) >> out_scan->field) - 1;
+	scal_dev[sel]->ch0_outsize.bits.out_width = out_w0 - 1;
+	scal_dev[sel]->ch1_outsize.bits.out_height =
+		((out_h1 + (out_scan->field & 0x1)) >> out_scan->field) - 1;
+	scal_dev[sel]->ch1_outsize.bits.out_width = out_w1 - 1;
+	return 0;
+}
+
+/*
+ * set scaler output trigger line.
+ */
+__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line)
+{
+	scal_dev[sel]->lint_ctrl.bits.field_sel = 0x0;
+	scal_dev[sel]->lint_ctrl.bits.trig_line = line;
+	return 0;
+}
+
+/*
+ * set scaler interrupt enable bit
+ *
+ * int_num: {7, 9, 10}
+ *  7: write back interrupt
+ *  9: line interrupt
+ * 10: register ready load interrupt
+ */
+__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num)
+{
+	if (int_num == 7)
+		scal_dev[sel]->int_en.bits.wb_en = 0x1;
+	else if (int_num == 9)
+		scal_dev[sel]->int_en.bits.line_en = 0x1;
+	else if (int_num == 10)
+		scal_dev[sel]->int_en.bits.reg_load_en = 0x1;
+
+	return 0;
+}
+
+/*
+ * set scaler deinterlace control parameter
+ *
+ * mode: {0,1,2,3}
+ * 0: weave
+ * 1: bob
+ * 2: maf
+ * 3: maf-bob
+ * diagintp_en: {0, 1}
+ * tempdiff_en: {0,1}
+ */
+__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en,
+			  __u8 tempdiff_en)
+{
+	scal_dev[sel]->di_ctrl.bits.en = en;
+	scal_dev[sel]->di_ctrl.bits.mod = mode;
+	scal_dev[sel]->di_ctrl.bits.diagintp_en = diagintp_en;
+	scal_dev[sel]->di_ctrl.bits.tempdiff_en = tempdiff_en;
+	return 0;
+}
+
+/*
+ * set scaler deinterlace pre frame luma address
+ */
+__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr)
+{
+	scal_dev[sel]->di_preluma.dwval = addr;
+	return 0;
+}
+
+/*
+ * set scaler deinterlace maf flag address and linestride
+ */
+__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride)
+{
+	scal_dev[sel]->di_blkflag.dwval = addr;
+	scal_dev[sel]->di_flaglinestrd.dwval = stride;
+	return 0;
+}
+
+/*
+ * scaler module  start set
+ */
+__s32 DE_SCAL_Start(__u8 sel)
+{
+	scal_dev[sel]->frm_ctrl.bits.frm_start = 0x1;
+
+	return 0;
+}
+
+/*
+ * scaler filter coefficient set ready
+ */
+__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel)
+{
+	if (!sunxi_is_sun5i())
+		scal_dev[sel]->frm_ctrl.bits.coef_rdy_en = 0x1;
+
+	return 0;
+}
+
+/*
+ * scaler configure registers set ready
+ */
+__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel)
+{
+	scal_dev[sel]->frm_ctrl.bits.reg_rdy_en = 0x1;
+
+	return 0;
+}
+
+/*
+ *scaler module reset(reset module status machine)
+ */
+__s32 DE_SCAL_Reset(__u8 sel)
+{
+	scal_dev[sel]->frm_ctrl.bits.frm_start = 0x0;
+
+	/* clear wb err */
+	scal_dev[sel]->status.bits.wb_err_status = 0x0;
+	scal_dev[sel]->status.bits.wb_err_losedata = 0x0;
+	scal_dev[sel]->status.bits.wb_err_sync = 0x0;
+
+	return 0;
+}
+
+/*
+ * scaler input source select
+ *
+ * port <scaler input port>
+ * 0: dram
+ * 4: interface of image0 to lcd
+ * 5: interface of image1 to lcd
+ * 6: image0
+ * 7: image1
+ */
+__s32 DE_SCAL_Input_Select(__u8 sel, __u32 source)
+{
+	scal_dev[sel]->frm_ctrl.bits.in_ctrl = source;
+	return 0;
+}
+
+/*
+ * scaler output select
+ *
+ * out:
+ * 0: be0
+ * 1: be1
+ * 2: me
+ * 3: writeback
+ */
+__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out)
+{
+	if (out == 3) { /* write back */
+		/* disable scaler output to be/me */
+		scal_dev[sel]->frm_ctrl.bits.out_ctrl = 1;
+		scal_dev[sel]->frm_ctrl.bits.out_port_sel = 0;
+	} else if (out < 3) {
+		/* enable scaler output to be/me */
+		scal_dev[sel]->frm_ctrl.bits.out_ctrl = 0;
+		scal_dev[sel]->frm_ctrl.bits.out_port_sel = out;
+	}
+
+	return 0;
+}
+
+/*
+ * scaler write back enable
+ */
+__s32 DE_SCAL_Writeback_Enable(__u8 sel)
+{
+	scal_dev[sel]->frm_ctrl.bits.wb_en = 0x1;
+
+	return 0;
+}
+
+/*
+ * scaler write back enable
+ */
+__s32 DE_SCAL_Writeback_Disable(__u8 sel)
+{
+	scal_dev[sel]->frm_ctrl.bits.wb_en = 0x0;
+
+	return 0;
+}
+
+/*
+ * scaler module enable
+ */
+__s32 DE_SCAL_Enable(__u8 sel)
+{
+	de_scal_trd_fp_en = 0;
+	de_scal_trd_itl_en = 0;
+	scal_dev[sel]->modl_en.bits.en = 0x1;
+	//scal_dev[sel]->field_ctrl.sync_edge= 0x1;
+
+	return 0;
+}
+
+/*
+ * scaler module disable
+ */
+__s32 DE_SCAL_Disable(__u8 sel)
+{
+	scal_dev[sel]->modl_en.bits.en = 0x0;
+
+	return 0;
+}
+
+/*
+ * scaler write back address set
+ */
+__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr)
+{
+	scal_dev[sel]->wb_addr0.dwval = addr->ch0_addr;
+	if (!sunxi_is_sun5i()) {
+		scal_dev[sel]->wb_addr1.dwval = addr->ch1_addr;
+		scal_dev[sel]->wb_addr2.dwval = addr->ch2_addr;
+	}
+
+	return 0;
+}
+
+/*
+ * scaler write back channel selection
+ *
+ * channel: channel for wb.
+ *  0,1: Y/G channel
+ *  2:   U/R channel
+ *  3:   V/B channel
+ */
+__s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (channel == 0)
+		scal_dev[sel]->output_fmt.bits.wb_chsel = 0;
+	else if (channel == 1)
+		scal_dev[sel]->output_fmt.bits.wb_chsel = 2;
+	else if (channel == 2)
+		scal_dev[sel]->output_fmt.bits.wb_chsel = 3;
+
+	return 0;
+}
+
+#ifdef UNUSED
+/*
+ * scaler input format get
+ *
+ * return format: [0-5]
+ * 0: yuv444
+ * 1: yuv422
+ * 2: yuv420
+ * 3: yuv411
+ * 4: csirgb
+ * 5: rgb888
+ */
+static __u8
+DE_SCAL_Get_Input_Format(__u8 sel)
+{
+	__u8 fmt_ret;
+	fmt_ret = scal_dev[sel]->input_fmt.bits.data_fmt;
+
+	return fmt_ret;
+}
+
+/*
+ * scaler input mode get
+ *
+ * returns mode [0-4]
+ * 0 non-macro block plannar data
+ * 1 interleaved data
+ * 2 non-macro block uv combined data
+ * 3 macro block plannar data
+ * 4 macro block uv combined data
+ */
+static __u8
+DE_SCAL_Get_Input_Mode(__u8 sel)
+{
+	__u8 mode_ret;
+	mode_ret = scal_dev[sel]->input_fmt.bits.data_mod;
+
+	return mode_ret;
+}
+
+/*
+ * display engine front-end output data format get
+ *
+ * returns format:
+ * 0: plannar rgb output
+ * 1: interleaved argb ouptut
+ * 4: plannar yuv444
+ * 5: plannar yuv420
+ * 6: plannar yuv422
+ * 7: plannar yuv411
+ */
+static __u8
+DE_SCAL_Get_Output_Format(__u8 sel)
+{
+	__u8 fmt_ret;
+	fmt_ret = scal_dev[sel]->output_fmt.bits.data_fmt;
+
+	return fmt_ret;
+}
+
+/*
+ * scaler input width get
+ *
+ * returns width: [8-8192]
+ */
+static __u16
+DE_SCAL_Get_Input_Width(__u8 sel)
+{
+	__u16 in_w;
+	in_w = scal_dev[sel]->ch0_insize.bits.in_width + 0x1;
+
+	return in_w;
+}
+
+/*
+ * scaler input height get
+ *
+ * returns height: [8-8192]
+ */
+static __u16
+DE_SCAL_Get_Input_Height(__u8 sel)
+{
+	__u16 in_h;
+	in_h = scal_dev[sel]->ch0_insize.bits.in_height + 0x1;
+
+	return in_h;
+}
+
+/*
+ * scaler output width get
+ *
+ * returns width: [8-8192]
+ */
+static __u16
+DE_SCAL_Get_Output_Width(__u8 sel)
+{
+	__u16 out_w;
+	out_w = scal_dev[sel]->ch0_outsize.bits.out_width + 0x1;
+
+	return out_w;
+}
+
+/*
+ * scaler output height get
+ *
+ * returns height: [8-8192]
+ */
+static __u16
+DE_SCAL_Get_Output_Height(__u8 sel)
+{
+	__u16 out_h;
+	out_h = scal_dev[sel]->ch0_outsize.bits.out_height + 0x1;
+
+	return out_h;
+}
+
+/*
+ * scaler start status get
+ *
+ * returns:
+ *  0  scaler enable
+ * -1 scaler disable
+ */
+static __s32
+DE_SCAL_Get_Start_Status(__u8 sel)
+{
+	if (scal_dev[sel]->modl_en.bits.en &&
+	    scal_dev[sel]->frm_ctrl.bits.frm_start) {
+		return 0;
+	} else {
+		return -1;
+	}
+}
+#endif /* UNUSED */
+
+/*
+ * lcd field status
+ *
+ * returns:
+ * 0: top field
+ * 1: bottom field
+ */
+__s32 DE_SCAL_Get_Field_Status(__u8 sel)
+{
+	return scal_dev[sel]->status.bits.lcd_field;
+}
+
+/*
+ * matrix multiple of 4x4, m1 * m2.
+ */
+__s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2,
+			  __scal_matrix4x4 *result)
+{
+	__scal_matrix4x4 tmp;
+
+	tmp.x00 = (in1.x00 * in2.x00 + in1.x01 * in2.x10 + in1.x02 * in2.x20 +
+		   in1.x03 * in2.x30) >> 10;
+	tmp.x01 = (in1.x00 * in2.x01 + in1.x01 * in2.x11 + in1.x02 * in2.x21 +
+		   in1.x03 * in2.x31) >> 10;
+	tmp.x02 = (in1.x00 * in2.x02 + in1.x01 * in2.x12 + in1.x02 * in2.x22 +
+		   in1.x03 * in2.x32) >> 10;
+	tmp.x03 = (in1.x00 * in2.x03 + in1.x01 * in2.x13 + in1.x02 * in2.x23 +
+		   in1.x03 * in2.x33) >> 10;
+	tmp.x10 = (in1.x10 * in2.x00 + in1.x11 * in2.x10 + in1.x12 * in2.x20 +
+		   in1.x13 * in2.x30) >> 10;
+	tmp.x11 = (in1.x10 * in2.x01 + in1.x11 * in2.x11 + in1.x12 * in2.x21 +
+		   in1.x13 * in2.x31) >> 10;
+	tmp.x12 = (in1.x10 * in2.x02 + in1.x11 * in2.x12 + in1.x12 * in2.x22 +
+		   in1.x13 * in2.x32) >> 10;
+	tmp.x13 = (in1.x10 * in2.x03 + in1.x11 * in2.x13 + in1.x12 * in2.x23 +
+		   in1.x13 * in2.x33) >> 10;
+	tmp.x20 = (in1.x20 * in2.x00 + in1.x21 * in2.x10 + in1.x22 * in2.x20 +
+		   in1.x23 * in2.x30) >> 10;
+	tmp.x21 = (in1.x20 * in2.x01 + in1.x21 * in2.x11 + in1.x22 * in2.x21 +
+		   in1.x23 * in2.x31) >> 10;
+	tmp.x22 = (in1.x20 * in2.x02 + in1.x21 * in2.x12 + in1.x22 * in2.x22 +
+		   in1.x23 * in2.x32) >> 10;
+	tmp.x23 = (in1.x20 * in2.x03 + in1.x21 * in2.x13 + in1.x22 * in2.x23 +
+		   in1.x23 * in2.x33) >> 10;
+	tmp.x30 = (in1.x30 * in2.x00 + in1.x31 * in2.x10 + in1.x32 * in2.x20 +
+		   in1.x33 * in2.x30) >> 10;
+	tmp.x31 = (in1.x30 * in2.x01 + in1.x31 * in2.x11 + in1.x32 * in2.x21 +
+		   in1.x33 * in2.x31) >> 10;
+	tmp.x32 = (in1.x30 * in2.x02 + in1.x31 * in2.x12 + in1.x32 * in2.x22 +
+		   in1.x33 * in2.x32) >> 10;
+	tmp.x33 = (in1.x30 * in2.x03 + in1.x31 * in2.x13 + in1.x32 * in2.x23 +
+		   in1.x33 * in2.x33) >> 10;
+
+	*result = tmp;
+
+	return 0;
+}
+
+/*
+ * csc coefficient and constant limited
+ */
+#ifndef CONFIG_ARCH_SUN5I
+__s32 iDE_SCAL_Csc_Lmt(__s64 *value, __s32 min, __s32 max, __s32 shift,
+		       __s32 validbit)
+{
+	__s64 tmp;
+	tmp = (*value) >> shift;
+	if (tmp < min)
+		*value = min & validbit;
+	else if (tmp > max)
+		*value = max & validbit;
+	else
+		*value = tmp & validbit;
+
+	return 0;
+}
+#else
+__s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift,
+		       __s32 validbit)
+{
+	__s32 tmp;
+
+	tmp = (*value) >> shift;
+	if (tmp < min)
+		*value = min & validbit;
+	else if (tmp > max)
+		*value = max & validbit;
+	else
+		*value = tmp & validbit;
+
+	return 0;
+}
+#endif /* not CONFIG_ARCH_SUN5I */
+
+/*
+ * set scaler input/output color space convert coefficients
+ *
+ * Args:
+ *  sel: scaler select
+ *  in_csc_mode: color space select, bt601, bt709, ycc, xycc
+ *  out_csc_mode: color space select, bt601, bt709, ycc, xycc
+ *  incs: source color space
+ *    0  rgb
+ *    1  yuv
+ *  outcs: destination color space
+ *    0  rgb
+ *    1  yuv
+ *  brightness: [0-63], default 32
+ *  contrast: [0-63] = [0.0-2.0]*32, default 32
+ *  saturation: [0-63] = [0.0-2.0]*32, default 32
+ *  hue: [0-63], default 32
+ *  in_br_swap: swap b r component.
+ *    0  normal
+ *    1  swap enable, note: when input yuv, then u v swap
+ *  out_br_swap: swap output b r component
+ *    0  normal
+ *    1  swap enable, note: when output yuv, then u v swap
+ */
+__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
+				   __u8 out_csc_mode, __u8 incs, __u8 outcs,
+				   __s32 bright, __s32 contrast,
+				   __s32 saturation, __s32 hue,
+				   __u32 in_br_swap, __u32 out_br_swap)
+{
+	__scal_matrix4x4 matrixEn;
+	__scal_matrix4x4 matrixconv, *ptmatrix;
+	__scal_matrix4x4 matrixresult;
+#ifndef CONFIG_ARCH_SUN5I
+	__scal_matrix4x4 tmpcoeff;
+#endif
+	__u32 i;
+	__s32 sinv, cosv; /* sin_tab: 7 bit fractional */
+
+	bright = bright * 64 / 100;
+	bright = saturation * 64 / 100;
+	bright = contrast * 64 / 100;
+	bright = hue * 64 / 100;
+
+	sinv = image_enhance_tab[8 * 12 + (hue & 0x3f)];
+	cosv = image_enhance_tab[8 * 12 + 8 * 8 + (hue & 0x3f)];
+
+	matrixEn.x00 = contrast << 5;
+	matrixEn.x01 = 0;
+	matrixEn.x02 = 0;
+	matrixEn.x03 = (((bright - 32) + 16) << 10) - (contrast << 9);
+	matrixEn.x10 = 0;
+	matrixEn.x11 = (contrast * saturation * cosv) >> 7;
+	matrixEn.x12 = (contrast * saturation * sinv) >> 7;
+	matrixEn.x13 = (1 << 17) - ((matrixEn.x11 + matrixEn.x12) << 7);
+	matrixEn.x20 = 0;
+	matrixEn.x21 = (-contrast * saturation * sinv) >> 7;
+	matrixEn.x22 = (contrast * saturation * cosv) >> 7;
+	matrixEn.x23 = (1 << 17) - ((matrixEn.x22 + matrixEn.x21) << 7);
+	matrixEn.x30 = 0;
+	matrixEn.x31 = 0;
+	matrixEn.x32 = 0;
+	matrixEn.x33 = 1024;
+
+#ifndef CONFIG_ARCH_SUN5I
+	if ((incs == 0) && (outcs == 0)) { /* rgb to rgb */
+		for (i = 0; i < 16; i++) {
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) *(image_enhance_tab +
+					   (in_csc_mode << 5) + i) << 32)
+				>> 32; /* RGB2YUV */
+
+		}
+
+		ptmatrix = &tmpcoeff;
+
+		/* convolution of enhance matrix and rgb2yuv matrix */
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+
+		for (i = 0; i < 16; i++) {
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) *(image_enhance_tab +
+					   (in_csc_mode << 5) + 0x10 + i)
+				 << 32) >> 32; /* YUV2RGB */
+		}
+
+		ptmatrix = &tmpcoeff;
+
+		/* convert to RGB */
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
+
+		matrixresult.x00 = (matrixconv.x11 + 8) / 16;
+		matrixresult.x01 = (matrixconv.x10 + 8) / 16;
+		matrixresult.x02 = (matrixconv.x12 + 8) / 16;
+		matrixresult.x03 = (matrixconv.x13 + 512) / 1024;
+		matrixresult.x10 = (matrixconv.x01 + 8) / 16;
+		matrixresult.x11 = (matrixconv.x00 + 8) / 16;
+		matrixresult.x12 = (matrixconv.x02 + 8) / 16;
+		matrixresult.x13 = (matrixconv.x03 + 512) / 1024;
+		matrixresult.x20 = (matrixconv.x21 + 8) / 16;
+		matrixresult.x21 = (matrixconv.x20 + 8) / 16;
+		matrixresult.x22 = (matrixconv.x22 + 8) / 16;
+		matrixresult.x23 = (matrixconv.x23 + 512) / 1024;
+		matrixresult.x30 = (matrixconv.x31 + 8) / 16;
+		matrixresult.x31 = (matrixconv.x30 + 8) / 16;
+		matrixresult.x32 = (matrixconv.x32 + 8) / 16;
+		matrixresult.x33 = (matrixconv.x33 + 8) / 16;
+
+	} else if ((incs == 1) && (outcs == 0))	{ /* yuv to rgb */
+		for (i = 0; i < 16; i++) {
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) *(image_enhance_tab +
+					   (in_csc_mode << 5) + 0x10 + i)
+				 << 32) >> 32; /* YUV2RGB */
+		}
+
+		ptmatrix = &tmpcoeff;
+
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
+		matrixresult.x00 = matrixconv.x10 / 4;
+		matrixresult.x01 = matrixconv.x11 / 4;
+		matrixresult.x02 = matrixconv.x12 / 4;
+		matrixresult.x03 = matrixconv.x13 / 256;
+		matrixresult.x10 = matrixconv.x00 / 4;
+		matrixresult.x11 = matrixconv.x01 / 4;
+		matrixresult.x12 = matrixconv.x02 / 4;
+		matrixresult.x13 = matrixconv.x03 / 256;
+		matrixresult.x20 = matrixconv.x20 / 4;
+		matrixresult.x21 = matrixconv.x21 / 4;
+		matrixresult.x22 = matrixconv.x22 / 4;
+		matrixresult.x23 = matrixconv.x23 / 256;
+		matrixresult.x30 = matrixconv.x30 / 4;
+		matrixresult.x31 = matrixconv.x31 / 4;
+		matrixresult.x32 = matrixconv.x32 / 4;
+		matrixresult.x33 = matrixconv.x33 / 4;
+
+	} else if ((incs == 0) && (outcs == 1))	{ /* rgb to yuv */
+		for (i = 0; i < 16; i++) {
+			*((__s64 *) (&tmpcoeff.x00) + i) =
+				((__s64) *(image_enhance_tab +
+					   (in_csc_mode << 5) + i) << 32)
+				>> 32; /* RGB2YUV */
+		}
+
+		ptmatrix = &tmpcoeff;
+
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+		matrixresult.x00 = matrixconv.x01 / 4;
+		matrixresult.x01 = matrixconv.x00 / 4;
+		matrixresult.x02 = matrixconv.x02 / 4;
+		matrixresult.x03 = matrixconv.x03 / 256;
+		matrixresult.x10 = matrixconv.x11 / 4;
+		matrixresult.x11 = matrixconv.x10 / 4;
+		matrixresult.x12 = matrixconv.x12 / 4;
+		matrixresult.x13 = matrixconv.x13 / 256;
+		matrixresult.x20 = matrixconv.x21 / 4;
+		matrixresult.x21 = matrixconv.x20 / 4;
+		matrixresult.x22 = matrixconv.x22 / 4;
+		matrixresult.x23 = matrixconv.x23 / 256;
+		matrixresult.x30 = matrixconv.x31 / 4;
+		matrixresult.x31 = matrixconv.x30 / 4;
+		matrixresult.x32 = matrixconv.x32 / 4;
+		matrixresult.x33 = matrixconv.x33 / 4;
+	} else { /* yuv to yuv */
+		matrixresult = matrixEn;
+	}
+
+	/*
+	 * data bit convert
+	 *
+	 * For coefficient:
+	 * 1 bit sign,
+	 * 2 bit integer,
+	 * 10 bits fractrional
+	 * For constant:
+	 * 1 bit sign,
+	 * 9 bit integer,
+	 * 4 bit fractional
+	 *
+	 * range limited
+	 */
+	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 0, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 0, 16383);
+#else
+	if ((incs == 0) && (outcs == 0)) { /* rgb to rgb */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (in_csc_mode << 7) + 0x40);
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (in_csc_mode << 7));
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixconv, &matrixconv);
+		matrixresult.x00 = matrixconv.x11;
+		matrixresult.x01 = matrixconv.x10;
+		matrixresult.x02 = matrixconv.x12;
+		matrixresult.x03 = matrixconv.x13;
+		matrixresult.x10 = matrixconv.x01;
+		matrixresult.x11 = matrixconv.x00;
+		matrixresult.x12 = matrixconv.x02;
+		matrixresult.x13 = matrixconv.x03;
+		matrixresult.x20 = matrixconv.x21;
+		matrixresult.x21 = matrixconv.x20;
+		matrixresult.x22 = matrixconv.x22;
+		matrixresult.x23 = matrixconv.x23;
+		matrixresult.x30 = matrixconv.x31;
+		matrixresult.x31 = matrixconv.x30;
+		matrixresult.x32 = matrixconv.x32;
+		matrixresult.x33 = matrixconv.x33;
+
+	} else if ((incs == 1) && (outcs == 0))	{ /* yuv to rgb */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (in_csc_mode << 7) + 0x40);
+		iDE_SCAL_Matrix_Mul(*ptmatrix, matrixEn, &matrixconv);
+		matrixresult.x00 = matrixconv.x10;
+		matrixresult.x01 = matrixconv.x11;
+		matrixresult.x02 = matrixconv.x12;
+		matrixresult.x03 = matrixconv.x13;
+		matrixresult.x10 = matrixconv.x00;
+		matrixresult.x11 = matrixconv.x01;
+		matrixresult.x12 = matrixconv.x02;
+		matrixresult.x13 = matrixconv.x03;
+		matrixresult.x20 = matrixconv.x20;
+		matrixresult.x21 = matrixconv.x21;
+		matrixresult.x22 = matrixconv.x22;
+		matrixresult.x23 = matrixconv.x23;
+		matrixresult.x30 = matrixconv.x30;
+		matrixresult.x31 = matrixconv.x31;
+		matrixresult.x32 = matrixconv.x32;
+		matrixresult.x33 = matrixconv.x33;
+
+	} else if ((incs == 0) && (outcs == 1))	{ /* rgb to yuv */
+		ptmatrix = (__scal_matrix4x4 *)
+			((__u32) image_enhance_tab + (in_csc_mode << 7));
+		iDE_SCAL_Matrix_Mul(matrixEn, *ptmatrix, &matrixconv);
+		matrixresult.x00 = matrixconv.x01;
+		matrixresult.x01 = matrixconv.x00;
+		matrixresult.x02 = matrixconv.x02;
+		matrixresult.x03 = matrixconv.x03;
+		matrixresult.x10 = matrixconv.x11;
+		matrixresult.x11 = matrixconv.x10;
+		matrixresult.x12 = matrixconv.x12;
+		matrixresult.x13 = matrixconv.x13;
+		matrixresult.x20 = matrixconv.x21;
+		matrixresult.x21 = matrixconv.x20;
+		matrixresult.x22 = matrixconv.x22;
+		matrixresult.x23 = matrixconv.x23;
+		matrixresult.x30 = matrixconv.x31;
+		matrixresult.x31 = matrixconv.x30;
+		matrixresult.x32 = matrixconv.x32;
+		matrixresult.x33 = matrixconv.x33;
+	} else { /* yuv to yuv */
+		matrixresult = matrixEn;
+	}
+
+	/*
+	 * data bit convert:
+	 * For coefficient:
+	 *   1 bit sign
+	 *   2 bit integer
+	 *  10 bits fractional
+	 * For constant:
+	 *   1 bit sign
+	 *   9 bit integer
+	 *   4 bit fractional
+	 * range limited.
+	 */
+	iDE_SCAL_Csc_Lmt(&matrixresult.x00, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x01, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x02, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x03, -8191, 8191, 6, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x10, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x11, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x12, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x13, -8191, 8191, 6, 16383);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x20, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x21, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x22, -4095, 4095, 0, 8191);
+	iDE_SCAL_Csc_Lmt(&matrixresult.x23, -8191, 8191, 6, 16383);
+#endif /* not CONFIG_ARCH_SUN5I */
+
+	/* write csc register */
+	{
+#ifndef CONFIG_ARCH_SUN5I
+		__s64 *pt = &(matrixresult.x00);
+#else
+		__s32 *pt = &(matrixresult.x00);
+#endif
+		for (i = 0; i < 4; i++) {
+			scal_dev[sel]->csc_coef[i].dwval = *(pt + i);
+			scal_dev[sel]->csc_coef[i + 4 + out_br_swap * 4].dwval =
+			    *(pt + i + 4 + in_br_swap * 4);
+			scal_dev[sel]->csc_coef[i + 8 - out_br_swap * 4].dwval =
+			    *(pt + i + 8 - in_br_swap * 4);
+		}
+	}
+	scal_dev[sel]->bypass.bits.csc_bypass_en = 0;
+
+	return 0;
+}
+
+/*
+ * get single image size according to 3D inmode and full size
+ * Args:
+ *  sel:        scaler select
+ *  inmode:     3D input mode
+ *  fullsize:   3D source size, maybe double width of left image or
+ *              double heigth of left height>
+ *  singlesize: 3D left image size
+ */
+__s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode,
+				    __scal_src_size_t *fullsize,
+				    __scal_src_size_t *singlesize)
+{
+	switch (inmode) {
+	case DE_SCAL_3DIN_TB:
+		singlesize->src_width = fullsize->src_width;
+		singlesize->src_height = fullsize->src_height >> 1;
+		singlesize->scal_width = fullsize->scal_width;
+		singlesize->scal_height = fullsize->scal_height >> 1;
+		singlesize->x_off = fullsize->x_off;
+		singlesize->y_off = fullsize->y_off;
+		break;
+	case DE_SCAL_3DIN_SSF:
+	case DE_SCAL_3DIN_SSH:
+		singlesize->src_width = fullsize->src_width >> 1;
+		singlesize->src_height = fullsize->src_height;
+		singlesize->scal_width = fullsize->scal_width >> 1;
+		singlesize->scal_height = fullsize->scal_height;
+		singlesize->x_off = fullsize->x_off;
+		singlesize->y_off = fullsize->y_off;
+		break;
+	case DE_SCAL_3DIN_LI:
+		singlesize->src_width = fullsize->src_width;
+		singlesize->src_height = fullsize->src_height >> 1;
+		singlesize->scal_width = fullsize->scal_width;
+		singlesize->scal_height = fullsize->scal_height >> 1;
+		singlesize->x_off = fullsize->x_off;
+		singlesize->y_off = fullsize->y_off >> 1;
+		break;
+	case DE_SCAL_3DIN_FP:
+		singlesize->src_width = fullsize->src_width;
+		singlesize->src_height = fullsize->src_height;
+		singlesize->scal_width = fullsize->scal_width;
+		singlesize->scal_height = fullsize->scal_height;
+		singlesize->x_off = fullsize->x_off;
+		singlesize->y_off = fullsize->y_off;
+		break;
+	default:
+		/* undefine input mode */
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * get 3D output single size according to 3D outmode and full image size
+ *
+ * Args:
+ *  sel: scaler select
+ *  inmode: 3D output mode
+ *  fullsize: 3D source size, maybe double width of left image or double heigth
+ *            of left height>
+ *  singlesize: 3D left image size.
+ */
+__s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode,
+				     __scal_out_size_t *singlesize,
+				     __scal_out_size_t *fullsize)
+{
+	switch (outmode) {
+	case DE_SCAL_3DOUT_CI_1:
+	case DE_SCAL_3DOUT_CI_2:
+	case DE_SCAL_3DOUT_CI_3:
+	case DE_SCAL_3DOUT_CI_4:
+	case DE_SCAL_3DOUT_HDMI_SSF:
+	case DE_SCAL_3DOUT_HDMI_SSH:
+		singlesize->height = fullsize->height;
+		singlesize->width = fullsize->width >> 1;
+		break;
+	case DE_SCAL_3DOUT_LIRGB:
+	case DE_SCAL_3DOUT_HDMI_TB:
+	case DE_SCAL_3DOUT_HDMI_FPP:
+	case DE_SCAL_3DOUT_HDMI_FPI:
+	case DE_SCAL_3DOUT_HDMI_LI:
+		singlesize->height = fullsize->height >> 1;
+		singlesize->width = fullsize->width;
+		break;
+	case DE_SCAL_3DOUT_HDMI_FA:
+		singlesize->height = fullsize->height;
+		singlesize->width = fullsize->width;
+	default:
+		/* undefined mode */
+		break;
+
+	}
+	return 0;
+}
+
+/*
+ * get 3D output full size according to 3D outmode and left/right image size
+ *
+ * Args:
+ * sel: scaler select
+ * inmode: 3D output mode
+ * fullsize: 3D source size, maybe double width of left image or double heigth
+ *           of left height
+ * singlesize: 3D left image size
+ */
+__s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode,
+				   __scal_out_size_t *singlesize,
+				   __scal_out_size_t *fullsize)
+{
+	switch (outmode) {
+	case DE_SCAL_3DOUT_CI_1:
+	case DE_SCAL_3DOUT_CI_2:
+	case DE_SCAL_3DOUT_CI_3:
+	case DE_SCAL_3DOUT_CI_4:
+	case DE_SCAL_3DOUT_HDMI_SSF:
+	case DE_SCAL_3DOUT_HDMI_SSH:
+		fullsize->height = singlesize->height;
+		fullsize->width = singlesize->width << 1;
+		break;
+	case DE_SCAL_3DOUT_LIRGB:
+	case DE_SCAL_3DOUT_HDMI_TB:
+	case DE_SCAL_3DOUT_HDMI_FPP:
+	case DE_SCAL_3DOUT_HDMI_FPI:
+	case DE_SCAL_3DOUT_HDMI_LI:
+		fullsize->height = singlesize->height << 1;
+		fullsize->width = singlesize->width;
+		break;
+	case DE_SCAL_3DOUT_HDMI_FA:
+		fullsize->height = singlesize->height;
+		fullsize->width = singlesize->width;
+	default:
+		/* undefined mode */
+		break;
+
+	}
+	return 0;
+}
+
+/*
+ * scaler change frame buffer address, only change start address parameters
+ *
+ * Args:
+ *  sel: scaler select
+ *  addr: frame buffer address for 3 channel, 32 bit absolute address
+ * addrtrd: 3D source right image buffer address, only needed when 3dinmode is
+ *          FP
+ */
+__s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr,
+			     __scal_buf_addr_t *addrtrd)
+{
+	scal_dev[sel]->buf_addr0.dwval = addr->ch0_addr + de_scal_ch0_offset;
+	scal_dev[sel]->buf_addr1.dwval = addr->ch1_addr + de_scal_ch1_offset;
+	scal_dev[sel]->buf_addr2.dwval = addr->ch2_addr + de_scal_ch2_offset;
+	if (de_scal_trd_fp_en) {
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addrtrd->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addrtrd->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addrtrd->ch2_addr + de_scal_ch2r_offset;
+	} else {
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	}
+
+	return 0;
+}
+
+/*
+ * scaler 3D control setting
+ *
+ * Args:
+ *  sel: scaler select
+ *  trden: 3D enable, when 3D mode close, left picture
+ *  inmode: 3D input mode
+ *  outmode: 3D output mode
+ */
+__s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
+			  __scal_3d_outmode_t outmode)
+{
+	__u8 in_li_en = 0;
+	__u8 out_ci_en = 0, out_tb_en = 0, out_ss_en = 0, out_itl_en = 0;
+	__u8 model_sel = 0;
+	__u8 ci_mod = 0;
+
+	switch (inmode) {
+	case DE_SCAL_3DIN_LI:
+		in_li_en = 1;
+		break;
+	default:
+		in_li_en = 0;
+		break;
+	}
+
+	if (trden) {
+		switch (outmode) {
+		case DE_SCAL_3DOUT_CI_1:
+			ci_mod = 0;
+			out_ci_en = 1;
+			break;
+		case DE_SCAL_3DOUT_CI_2:
+			ci_mod = 1;
+			out_ci_en = 1;
+			break;
+		case DE_SCAL_3DOUT_CI_3:
+			ci_mod = 2;
+			out_ci_en = 1;
+			break;
+		case DE_SCAL_3DOUT_CI_4:
+			ci_mod = 3;
+			out_ci_en = 1;
+			break;
+		case DE_SCAL_3DOUT_HDMI_SSF:
+		case DE_SCAL_3DOUT_HDMI_SSH:
+			out_ss_en = 1;
+			break;
+		case DE_SCAL_3DOUT_HDMI_TB:
+		case DE_SCAL_3DOUT_HDMI_FPP:
+			out_tb_en = 1;
+			break;
+		case DE_SCAL_3DOUT_HDMI_FPI:
+			out_tb_en = 1;
+			out_itl_en = 1;
+			break;
+		case DE_SCAL_3DOUT_HDMI_FA:
+			break;
+		default:
+			/* undefined mode */
+			break;
+		}
+	}
+	model_sel = trden ? (out_tb_en ? 2 : 1) : 0;
+
+	scal_dev[sel]->trd_ctrl.bits.mod_sel = model_sel;
+	scal_dev[sel]->trd_ctrl.bits.ci_out_en = out_ci_en;
+	scal_dev[sel]->trd_ctrl.bits.ss_out_en = out_ss_en;
+	scal_dev[sel]->trd_ctrl.bits.li_in_en = in_li_en;
+	scal_dev[sel]->trd_ctrl.bits.tb_out_scan_mod = out_itl_en;
+	scal_dev[sel]->trd_ctrl.bits.ci_out_mod = ci_mod;
+	scal_dev[sel]->trd_ctrl.bits.tb_out_mod_field =
+		out_tb_en ? (out_itl_en ? 3 : 1) : 0;
+	scal_dev[sel]->field_ctrl.bits.valid_field_cnt =
+		out_tb_en ? (out_itl_en ? 3 : 1) : 0;
+	scal_dev[sel]->field_ctrl.bits.field_cnt =
+		out_tb_en ? (out_itl_en ? 0xC : 2) : 0;
+	de_scal_trd_itl_en = out_itl_en;
+
+	return 0;
+}
+
+/*
+ * scaler 3D source concerning parameter configure
+ *
+ * Args:
+ *   sel <scaler select>
+ *   addr: 3D left image frame buffer address for 3 channel,
+ *         32 bit absolute address
+ *   size: scale region define,  src size, offset, scal size
+ *   type: src data type, include byte sequence, mode, format, pixel sequence
+ *   trdinmode: 3D input mode
+ *   addrtrd: 3D right image frame buffer address for 3 channel, this address
+ *            must be set when 3d inmode is FP_P/FP_M, for other mode, the right
+ *            image buffer address can be get through left image address
+ */
+__s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr,
+			    __scal_src_size_t *size, __scal_src_type_t *type,
+			    __scal_3d_inmode_t trdinmode,
+			    __scal_buf_addr_t *addrtrd)
+{
+	__u8 w_shift, h_shift;
+	__u32 image_w0, image_w1, image_h0, image_h1;
+	__u32 x_off0, y_off0, x_off1, y_off1;
+	__u32 in_w0, in_h0, in_w1, in_h1;
+	__u8 de_scal_ch0_dx0, de_scal_ch0_dx1, de_scal_ch0_dy0;
+	__u8 de_scal_ch1_dx0, de_scal_ch1_dx1, de_scal_ch1_dy0;
+
+	image_w0 = size->src_width;
+	/* must be set in 3D mode, because of right address based on it !!!! */
+	image_h0 = size->src_height;
+	in_w0 = size->scal_width;
+	in_h0 = size->scal_height;
+	x_off0 = size->x_off;
+	y_off0 = size->y_off;
+
+	de_scal_trd_fp_en = 0;
+
+	if (type->fmt == DE_SCAL_INYUV422 || type->fmt == DE_SCAL_INYUV420) {
+		w_shift = 1;
+		image_w0 = (image_w0 + 1) & 0xfffffffe;
+		image_w1 = (image_w0) >> w_shift;
+		in_w0 = in_w0 & 0xfffffffe;
+		in_w1 = (in_w0 + 0x1) >> w_shift;
+		x_off0 = x_off0 & 0xfffffffe;
+		x_off1 = (x_off0) >> w_shift;
+	} else if (type->fmt == DE_SCAL_INYUV411) {
+		w_shift = 2;
+		image_w1 = (image_w0 + 0x3) >> w_shift;
+		in_w0 &= 0xfffffffc;
+		in_w1 = (in_w0 + 0x3) >> w_shift;
+		x_off0 &= 0xfffffffc;
+		x_off1 = (x_off0) >> w_shift;
+	} else {
+		w_shift = 0;
+		image_w1 = image_w0;
+		in_w1 = in_w0;
+		x_off1 = x_off0;
+	}
+	if (type->fmt == DE_SCAL_INYUV420 || type->fmt == DE_SCAL_INCSIRGB) {
+		h_shift = 1;
+		image_h0 &= 0xfffffffe;
+		image_h1 = ((image_h0 + 0x1) >> h_shift);
+		in_h0 &= 0xfffffffe;
+		in_h1 = (in_h0 + 0x1) >> h_shift;
+		y_off0 &= 0xfffffffe;
+		y_off1 = (y_off0) >> h_shift;
+	} else {
+		h_shift = 0;
+		image_h1 = image_h0;
+		in_h1 = in_h0;
+		y_off1 = y_off0;
+	}
+
+	/* added no-zero limited */
+	in_h0 = (in_h0 != 0) ? in_h0 : 1;
+	in_h1 = (in_h1 != 0) ? in_h1 : 1;
+	in_w0 = (in_w0 != 0) ? in_w0 : 1;
+	in_w1 = (in_w1 != 0) ? in_w1 : 1;
+
+	if ((trdinmode == DE_SCAL_3DIN_TB) &&
+			(type->mod == DISP_MOD_NON_MB_PLANAR)) {
+		scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1;
+		scal_dev[sel]->linestrd2.dwval = image_w1;
+
+		de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+		de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
+		de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
+
+		de_scal_ch0r_offset = image_w0 * image_h0 + de_scal_ch0_offset;
+		de_scal_ch1r_offset = image_w1 * image_h1 + de_scal_ch1_offset;
+		de_scal_ch2r_offset = image_w1 * image_h1 + de_scal_ch2_offset;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+
+	} else if ((trdinmode == DE_SCAL_3DIN_FP)
+		   && (type->mod == DISP_MOD_NON_MB_PLANAR)) {
+		scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1;
+		scal_dev[sel]->linestrd2.dwval = image_w1;
+
+		de_scal_ch0_offset = image_w0 * y_off0 + x_off0;
+		de_scal_ch1_offset = image_w1 * y_off1 + x_off1;
+		de_scal_ch2_offset = image_w1 * y_off1 + x_off1;
+
+		de_scal_ch0r_offset = de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 1;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addrtrd->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addrtrd->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addrtrd->ch2_addr + de_scal_ch2r_offset;
+	} else if (((trdinmode == DE_SCAL_3DIN_SSF) ||
+		    (trdinmode == DE_SCAL_3DIN_SSH)) &&
+		   (type->mod == DISP_MOD_NON_MB_PLANAR)) {
+		scal_dev[sel]->linestrd0.dwval = image_w0 << 1;
+		scal_dev[sel]->linestrd1.dwval = image_w1 << 1;
+		scal_dev[sel]->linestrd2.dwval = image_w1 << 1;
+
+		de_scal_ch0_offset = (image_w0 << 1) * y_off0 + x_off0;
+		de_scal_ch1_offset = (image_w1 << 1) * y_off1 + x_off1;
+		de_scal_ch2_offset = (image_w1 << 1) * y_off1 + x_off1;
+
+		de_scal_ch0r_offset = image_w0 + de_scal_ch0_offset;
+		de_scal_ch1r_offset = image_w1 + de_scal_ch1_offset;
+		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_LI) &&
+		   (type->mod == DISP_MOD_NON_MB_PLANAR)) {
+		scal_dev[sel]->linestrd0.dwval = image_w0;
+		scal_dev[sel]->linestrd1.dwval = image_w1;
+		scal_dev[sel]->linestrd2.dwval = image_w1;
+
+		de_scal_ch0_offset = (image_w0) * (y_off0 << 1) + x_off0;
+		de_scal_ch1_offset = (image_w1) * (y_off1 << 1) + x_off1;
+		de_scal_ch2_offset = (image_w1) * (y_off1 << 1) + x_off1;
+
+		de_scal_ch0r_offset = image_w0 + de_scal_ch0_offset;
+		de_scal_ch1r_offset = image_w1 + de_scal_ch1_offset;
+		de_scal_ch2r_offset = image_w1 + de_scal_ch2_offset;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_FP) &&
+		   (type->mod == DISP_MOD_INTERLEAVED)) {
+		scal_dev[sel]->linestrd0.dwval = image_w0 << (2 - w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0;
+		scal_dev[sel]->linestrd2.dwval = 0;
+
+		de_scal_ch0_offset =
+			(image_w0 << (2 - w_shift)) * y_off0 + x_off0;
+		de_scal_ch1_offset = 0;
+		de_scal_ch2_offset = 0;
+
+		de_scal_ch0r_offset = de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 1;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addrtrd->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addrtrd->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addrtrd->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_TB) &&
+		   (type->mod == DISP_MOD_INTERLEAVED)) {
+		scal_dev[sel]->linestrd0.dwval = image_w0 << (2 - w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0;
+		scal_dev[sel]->linestrd2.dwval = 0;
+
+		de_scal_ch0_offset =
+			(image_w0 << (2 - w_shift)) * y_off0 + x_off0;
+		de_scal_ch1_offset = 0;
+		de_scal_ch2_offset = 0;
+
+		de_scal_ch0r_offset = (image_w0 << (2 - w_shift)) * image_h0 +
+			de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 0;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if (((trdinmode == DE_SCAL_3DIN_SSF) ||
+		    (trdinmode == DE_SCAL_3DIN_SSH)) &&
+		   (type->mod == DISP_MOD_INTERLEAVED)) {
+		scal_dev[sel]->linestrd0.dwval = image_w0 << (3 - w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0;
+		scal_dev[sel]->linestrd2.dwval = 0;
+
+		de_scal_ch0_offset =
+			(image_w0 << (3 - w_shift)) * y_off0 + x_off0;
+		de_scal_ch1_offset = 0;
+		de_scal_ch2_offset = 0;
+
+		de_scal_ch0r_offset =
+			(image_w0 << (2 - w_shift)) + de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 0;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_LI) &&
+		   (type->mod == DISP_MOD_INTERLEAVED)) {
+		scal_dev[sel]->linestrd0.dwval = image_w0 << (2 - w_shift);
+		scal_dev[sel]->linestrd1.dwval = 0;
+		scal_dev[sel]->linestrd2.dwval = 0;
+
+		de_scal_ch0_offset =
+			(image_w0 << (2 - w_shift)) * (y_off0 << 1) + x_off0;
+		de_scal_ch1_offset = 0;
+		de_scal_ch2_offset = 0;
+
+		de_scal_ch0r_offset =
+			(image_w0 << (2 - w_shift)) + de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = de_scal_ch2_offset;
+
+		de_scal_trd_fp_en = 0;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_TB) &&
+		   (type->mod == DISP_MOD_MB_UV_COMBINED)) {
+		scal_dev[sel]->linestrd0.dwval =
+			(((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd1.dwval =
+			(((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		/* block offset */
+		de_scal_ch0_dx0 = (x_off0 & 0x1f);
+		de_scal_ch0_dy0 = (y_off0 & 0x1f);
+		de_scal_ch0_dx1 =
+			((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
+		de_scal_ch1_dx0 = (((x_off1) << 1) & 0x1f);
+		de_scal_ch1_dy0 = ((y_off1) & 0x1f);
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) +
+				   ((in_w1) << 1) + 0x1f) & 0x1f;
+
+		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->trd_mb_off0.bits.y_offset0 =
+			(image_h0 + y_off0) & 0x1f;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->trd_mb_off1.bits.y_offset0 =
+			(image_h1 + y_off1) & 0x1f;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+
+		de_scal_ch0_offset =
+			((image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
+			((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
+		de_scal_ch1_offset =
+			(((image_w1 << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1) & 0xffe0) + (((y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
+		de_scal_ch2_offset = 0x0;
+
+		de_scal_ch0r_offset = ((image_w0 + 0x1f) & 0xffe0) *
+			((y_off0 + image_h0) & 0xffe0) +
+			(((y_off0 + image_h0) & 0x01f) << 5) +
+			((x_off0 & 0xffe0) << 5);
+		de_scal_ch1r_offset =
+			(((image_w1 << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1 + image_h1) & 0xffe0) +
+			(((y_off1 + image_h1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
+		de_scal_ch2r_offset = 0x0;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_FP) &&
+		   (type->mod == DISP_MOD_MB_UV_COMBINED)) {
+		de_scal_trd_fp_en = 1;
+		scal_dev[sel]->linestrd0.dwval =
+			(((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd1.dwval =
+			(((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		/* block offset */
+		de_scal_ch0_dx0 = (x_off0 & 0x1f);
+		de_scal_ch0_dy0 = (y_off0 & 0x1f);
+		de_scal_ch0_dx1 =
+			((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
+		de_scal_ch1_dx0 = (((x_off1) << 1) & 0x1f);
+		de_scal_ch1_dy0 = ((y_off1) & 0x1f);
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) + ((in_w1) << 1) +
+				   0x1f) & 0x1f;
+
+		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+
+		de_scal_ch0_offset = ((image_w0 + 0x1f) & 0xffe0) *
+			(y_off0 & 0xffe0) + ((y_off0 & 0x01f) << 5) +
+			((x_off0 & 0xffe0) << 5);
+		de_scal_ch1_offset = (((image_w1 << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1) & 0xffe0) + (((y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
+		de_scal_ch2_offset = 0x0;
+
+		de_scal_ch0r_offset = de_scal_ch0_offset;
+		de_scal_ch1r_offset = de_scal_ch1_offset;
+		de_scal_ch2r_offset = 0x0;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addrtrd->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addrtrd->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addrtrd->ch2_addr + de_scal_ch2r_offset;
+	} else if (((trdinmode == DE_SCAL_3DIN_SSF) ||
+		    (trdinmode == DE_SCAL_3DIN_SSH)) &&
+		   (type->mod == DISP_MOD_MB_UV_COMBINED)) {
+		scal_dev[sel]->linestrd0.dwval =
+			(((2 * image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05;
+		scal_dev[sel]->linestrd1.dwval =
+			(((((2 * image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) <<
+			0x05;
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		/* block offset */
+		de_scal_ch0_dx0 = (x_off0 & 0x1f);
+		de_scal_ch0_dy0 = (y_off0 & 0x1f);
+		de_scal_ch0_dx1 =
+			((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
+		de_scal_ch1_dx0 = (((x_off1) << 1) & 0x1f);
+		de_scal_ch1_dy0 = ((y_off1) & 0x1f);
+		de_scal_ch1_dx1 =
+			((de_scal_ch1_dx0 & 0x1e) + ((in_w1) << 1) + 0x1f) &
+			0x1f;
+
+		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset0 =
+			(image_w0 + x_off0) & 0x1f;
+		scal_dev[sel]->trd_mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset1 =
+			(((image_w0 + x_off0) & 0x1f) + in_w0 + 0x1f) & 0x1f;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset0 =
+			((2 * (image_w1 + x_off1)) & 0x1f);
+		scal_dev[sel]->trd_mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset1 =
+			(((2 * (image_w1 + x_off1)) & 0x1f) + (in_w1 << 1) +
+			 0x1f) & 0x1f;
+
+		de_scal_ch0_offset =
+			((2 * image_w0 + 0x1f) & 0xffe0) * (y_off0 & 0xffe0) +
+			((y_off0 & 0x01f) << 5) + ((x_off0 & 0xffe0) << 5);
+		de_scal_ch1_offset =
+			((((2 * image_w1) << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1) & 0xffe0) + (((y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
+		de_scal_ch2_offset = 0x0;
+
+		de_scal_ch0r_offset = ((2 * image_w0 + 0x1f) & 0xffe0) *
+			(y_off0 & 0xffe0) + ((y_off0 & 0x01f) << 5) +
+			(((image_w0 + x_off0) & 0xffe0) << 5);
+		de_scal_ch1r_offset =
+			((((2 * image_w1) << 0x01) + 0x1f) & 0xffe0) *
+			((y_off1) & 0xffe0) + (((y_off1) & 0x01f) << 5) +
+			((((image_w1 + x_off1) << 0x01) & 0xffe0) << 5);
+		de_scal_ch2r_offset = 0x0;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	} else if ((trdinmode == DE_SCAL_3DIN_LI) &&
+		   (type->mod == DISP_MOD_MB_UV_COMBINED)) {
+		scal_dev[sel]->linestrd0.dwval =
+			((((image_w0 + 0x1f) & 0xffe0) - 0x1f) << 0x05);
+		scal_dev[sel]->linestrd1.dwval =
+			((((((image_w1) << 1) + 0x1f) & 0xffe0) - 0x1f) <<
+			 0x05);
+		scal_dev[sel]->linestrd2.dwval = 0x00;
+
+		/* block offset */
+		de_scal_ch0_dx0 = (x_off0 & 0x1f);
+		de_scal_ch0_dy0 = ((2 * y_off0) & 0x1f);
+		de_scal_ch0_dx1 =
+			((de_scal_ch0_dx0 & 0x1f) + in_w0 + 0x1f) & 0x1f;
+		de_scal_ch1_dx0 = (((x_off1) << 1) & 0x1f);
+		de_scal_ch1_dy0 = ((2 * y_off1) & 0x1f);
+		de_scal_ch1_dx1 = ((de_scal_ch1_dx0 & 0x1e) +
+				   ((in_w1) << 1) + 0x1f) & 0x1f;
+
+		scal_dev[sel]->mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->mb_off0.bits.y_offset0 = de_scal_ch0_dy0;
+		scal_dev[sel]->mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->mb_off1.bits.y_offset0 = de_scal_ch1_dy0;
+		scal_dev[sel]->mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset0 = de_scal_ch0_dx0;
+		scal_dev[sel]->trd_mb_off0.bits.y_offset0 =
+			(2 * y_off0 + 1) & 0x1f;
+		scal_dev[sel]->trd_mb_off0.bits.x_offset1 = de_scal_ch0_dx1;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset0 = de_scal_ch1_dx0;
+		scal_dev[sel]->trd_mb_off1.bits.y_offset0 =
+			(2 * y_off1 + 1) & 0x1f;
+		scal_dev[sel]->trd_mb_off1.bits.x_offset1 = de_scal_ch1_dx1;
+
+		de_scal_ch0_offset =
+			((image_w0 + 0x1f) & 0xffe0) * ((2 * y_off0) & 0xffe0) +
+			(((2 * y_off0) & 0x01f) << 5) +
+			((x_off0 & 0xffe0) << 5);
+		de_scal_ch1_offset =
+			(((image_w1 << 0x01) + 0x1f) & 0xffe0) *
+			((2 * y_off1) & 0xffe0) +
+			(((2 * y_off1) & 0x01f) << 5) +
+			(((x_off1 << 0x01) & 0xffe0) << 5);
+		de_scal_ch2_offset = 0x0;
+
+		de_scal_ch0r_offset = de_scal_ch0_offset + 32;
+		de_scal_ch1r_offset = de_scal_ch1_offset + 32;
+		de_scal_ch2r_offset = 0x0;
+
+		scal_dev[sel]->buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0_offset;
+		scal_dev[sel]->buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1_offset;
+		scal_dev[sel]->buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2_offset;
+
+		scal_dev[sel]->trd_buf_addr0.dwval =
+			addr->ch0_addr + de_scal_ch0r_offset;
+		scal_dev[sel]->trd_buf_addr1.dwval =
+			addr->ch1_addr + de_scal_ch1r_offset;
+		scal_dev[sel]->trd_buf_addr2.dwval =
+			addr->ch2_addr + de_scal_ch2r_offset;
+	}
+
+	scal_dev[sel]->input_fmt.bits.byte_seq = type->byte_seq;
+	scal_dev[sel]->input_fmt.bits.data_mod = type->mod;
+	scal_dev[sel]->input_fmt.bits.data_fmt = type->fmt;
+	scal_dev[sel]->input_fmt.bits.data_ps = type->ps;
+
+	scal_dev[sel]->ch0_insize.bits.in_width = in_w0 - 1;
+	scal_dev[sel]->ch0_insize.bits.in_height = in_h0 - 1;
+	scal_dev[sel]->ch1_insize.bits.in_width = in_w1 - 1;
+	scal_dev[sel]->ch1_insize.bits.in_height = in_h1 - 1;
+
+	return 0;
+}
+
+/*
+ * Enable/Disable Video Post Processing
+ */
+__s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable)
+{
+	if (enable) {
+		scal_dev[sel]->vpp_en.bits.en = 0x1;
+	} else {
+		scal_dev[sel]->vpp_en.bits.en = 0x0;
+		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
+		scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
+		scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
+	}
+	return 0;
+}
+
+/*
+ * Set Luminance Sharpen Level
+ *
+ * sharpness level:
+ *  0: sharpen off
+ *  1-4: higher level, more sharper
+ */
+__s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level)
+{
+
+	scal_dev[sel]->vpp_lp2.bits.lpf_gain = 31;
+	scal_dev[sel]->vpp_lp2.bits.neggain = 3;
+	scal_dev[sel]->vpp_lp2.bits.delta = 3;
+	scal_dev[sel]->vpp_lp2.bits.limit_thr = 3;
+
+	switch (level) {
+	case 0x0:
+		scal_dev[sel]->vpp_lp1.bits.tau = 0;
+		scal_dev[sel]->vpp_lp1.bits.alpha = 0;
+		scal_dev[sel]->vpp_lp1.bits.beta = 0;
+		scal_dev[sel]->vpp_lp2.bits.corthr = 255;
+		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
+		break;
+
+	case 0x1:
+		scal_dev[sel]->vpp_lp1.bits.tau = 4;
+		scal_dev[sel]->vpp_lp1.bits.alpha = 0;
+		scal_dev[sel]->vpp_lp1.bits.beta = 20;
+		scal_dev[sel]->vpp_lp2.bits.corthr = 2;
+		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
+		break;
+
+	case 0x2:
+		scal_dev[sel]->vpp_lp1.bits.tau = 11;
+		scal_dev[sel]->vpp_lp1.bits.alpha = 0;
+		scal_dev[sel]->vpp_lp1.bits.beta = 16;
+		scal_dev[sel]->vpp_lp2.bits.corthr = 5;
+		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
+		break;
+
+	case 0x3:
+		scal_dev[sel]->vpp_lp1.bits.tau = 15;
+		scal_dev[sel]->vpp_lp1.bits.alpha = 4;
+		scal_dev[sel]->vpp_lp1.bits.beta = 8;
+		scal_dev[sel]->vpp_lp2.bits.corthr = 5;
+		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
+		break;
+
+	case 0x4:
+		scal_dev[sel]->vpp_lp1.bits.tau = 8;
+		scal_dev[sel]->vpp_lp1.bits.alpha = 16;
+		scal_dev[sel]->vpp_lp1.bits.beta = 8;
+		scal_dev[sel]->vpp_lp2.bits.corthr = 5;
+		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x1;
+		break;
+
+	default:
+		scal_dev[sel]->vpp_lp1.bits.tau = 0;
+		scal_dev[sel]->vpp_lp1.bits.alpha = 0;
+		scal_dev[sel]->vpp_lp1.bits.beta = 0;
+		scal_dev[sel]->vpp_lp2.bits.corthr = 255;
+		scal_dev[sel]->vpp_lp1.bits.lp_en = 0x0;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * Set Chrominance Sharpen Level
+ *
+ * sharpness level:
+ *   0: sharpen off
+ * 1-4: higher level, more sharper
+ */
+__s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level)
+{
+	scal_dev[sel]->vpp_dcti.bits.dcti_filter1_sel = 2;
+	scal_dev[sel]->vpp_dcti.bits.dcti_filter2_sel = 2;
+	scal_dev[sel]->vpp_dcti.bits.dcti_hill_en = 1;
+	scal_dev[sel]->vpp_dcti.bits.dcti_suphill_en = 1;
+	scal_dev[sel]->vpp_dcti.bits.uv_separate_en = 0;
+	scal_dev[sel]->vpp_dcti.bits.uv_same_sign_mode_sel = 3;
+	scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_mode_sel = 3;
+
+	switch (level) {
+	case 0x0:
+		scal_dev[sel]->vpp_dcti.bits.dcti_gain = 0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 0;
+		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
+		break;
+
+	case 0x1:
+		scal_dev[sel]->vpp_dcti.bits.dcti_gain = 12;
+		scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
+		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
+		break;
+
+	case 0x2:
+		scal_dev[sel]->vpp_dcti.bits.dcti_gain = 23;
+		scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
+		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
+		break;
+
+	case 0x3:
+		scal_dev[sel]->vpp_dcti.bits.dcti_gain = 23;
+		scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 4;
+		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
+		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
+		break;
+
+	case 0x4:
+		scal_dev[sel]->vpp_dcti.bits.dcti_gain = 32;
+		scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 5;
+		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 1;
+		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 1;
+		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x1;
+		break;
+
+	default:
+		scal_dev[sel]->vpp_dcti.bits.dcti_gain = 0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_path_limit = 0;
+		scal_dev[sel]->vpp_dcti.bits.uv_same_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.uv_diff_sign_maxmin_mode_sel = 0;
+		scal_dev[sel]->vpp_dcti.bits.dcti_en = 0x0;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * Set White Level Extension Level
+ * level: sharpness level.
+ *   0: function off
+ * 1~4: higher level, more obvious
+ */
+__s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level)
+{
+	scal_dev[sel]->vpp_wle.bits.wle_thr = 128;
+
+	switch (level) {
+	case 0x0:
+		scal_dev[sel]->vpp_wle.bits.wle_gain = 64;
+		scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
+		break;
+
+	case 0x1:
+		scal_dev[sel]->vpp_wle.bits.wle_gain = 73;
+		scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
+		break;
+
+	case 0x2:
+		scal_dev[sel]->vpp_wle.bits.wle_gain = 79;
+		scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
+		break;
+
+	case 0x3:
+		scal_dev[sel]->vpp_wle.bits.wle_gain = 92;
+		scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
+		break;
+
+	case 0x4:
+		scal_dev[sel]->vpp_wle.bits.wle_gain = 127;
+		scal_dev[sel]->vpp_wle.bits.wle_en = 0x1;
+		break;
+
+	default:
+		scal_dev[sel]->vpp_wle.bits.wle_gain = 64;
+		scal_dev[sel]->vpp_wle.bits.wle_en = 0x0;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * Set Black Level Extension Level
+ * level: sharpness level.
+ *   0: function off
+ * 1~4: higher level, more obvious
+ */
+__s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level)
+{
+	scal_dev[sel]->vpp_ble.bits.ble_thr = 127;
+
+	switch (level) {
+	case 0x0:
+		scal_dev[sel]->vpp_ble.bits.ble_gain = 0;
+		scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
+		break;
+
+	case 0x1:
+		scal_dev[sel]->vpp_ble.bits.ble_gain = 9;
+		scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
+		break;
+
+	case 0x2:
+		scal_dev[sel]->vpp_ble.bits.ble_gain = 16;
+		scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
+		break;
+
+	case 0x3:
+		scal_dev[sel]->vpp_ble.bits.ble_gain = 32;
+		scal_dev[sel]->vpp_ble.bits.ble_en = 0x1;
+		break;
+
+	case 0x4:
+		scal_dev[sel]->vpp_ble.bits.ble_gain = 64;
+		scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
+		break;
+
+	default:
+		scal_dev[sel]->vpp_ble.bits.ble_gain = 0;
+		scal_dev[sel]->vpp_ble.bits.ble_en = 0x0;
+		break;
+
+	}
+
+	return 0;
+}
+
+__s32 DE_SCAL_EnableINT(__u8 sel, __u32 irqsrc)
+{
+	scal_dev[sel]->int_en.dwval |= irqsrc;
+
+	return 0;
+}
+
+__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc)
+{
+	scal_dev[sel]->int_en.dwval &= (~irqsrc);
+
+	return 0;
+}
+
+__u32 DE_SCAL_QueryINT(__u8 sel)
+{
+	return scal_dev[sel]->int_status.dwval;
+}
+
+/* write 1 to clear */
+__u32 DE_SCAL_ClearINT(__u8 sel, __u32 irqsrc)
+{
+	scal_dev[sel]->int_status.dwval |= DE_WB_END_IE;
+	return 0;
+}
diff --git a/drivers/video/sunxi/disp/de_fe.h b/drivers/video/sunxi/disp/de_fe.h
new file mode 100644
index 0000000..81aab97
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_fe.h
@@ -0,0 +1,2109 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DE_FE_H__
+#define __DE_FE_H__
+
+#include "de_be.h"
+
+#define SCALINITPASELMT (0xfffff)
+#define SCALLINEMAX (2048)
+
+/*
+ * Detail information of registers
+ */
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * RIGHT_CH0_ADDR: 3D mode channel 0 buffer address.
+		 * This address is the start address of right image in 3D mode.
+		 */
+		u32 right_ch0_addr; /* Default: 0 */
+	} bits;
+} SCAL_3D_BUF_ADDR0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * RIGHT_CH1_ADDR: 3D mode channel 1 buffer address.
+		 * This address is the start address of right image in 3D mode.
+		 */
+		u32 right_ch1_addr; /* Default: 0 */
+	} bits;
+} SCAL_3D_BUF_ADDR1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * RIGHT_CH2_ADDR: 3D mode channel 2 buffer address.
+		 * This address is the start address of right image in 3D mode.
+		 */
+		u32 right_ch2_addr; /* Default: 0 */
+	} bits;
+} SCAL_3D_BUF_ADDR2_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * MOD_SEL: 3D mode select.
+		 * 00: normal output mode(2D mode)
+		 * 01: 3D side by side/line interleaved/column interleaved
+		 *     output mode
+		 * 10: 3D top/bottom output mode,
+		 * 11: reserved
+		 *
+		 * When 3D mode is enable, scaler will enter 3D mode (source
+		 * will be composed of left and right frame, output will be
+		 * composed of left and right frame)
+		 */
+		u32 mod_sel:2; /* Default: 0 */
+		u32 res0:6;
+		/*
+		 * CI_OUT_EN: 3D Column interleaved mode output enable
+		 */
+		u32 ci_out_en:1; /* Default: 0 */
+		u32 res1:1;
+		/*
+		 * SS_OUT_EN: 3D output side by side mode enable
+		 */
+		u32 ss_out_en:1; /* Default: 0 */
+		/*
+		 * LI_IN_EN: 3D input line interleaved enable
+		 */
+		u32 li_in_en:1; /* Default: 0 */
+		/*
+		 * TB_OUT_SCAN_MOD: Output top/bottom scan mode selection
+		 *  0: progressive
+		 *  1: interlace
+		 */
+		u32 tb_out_scan_mod:1; /* Default: 0 */
+		u32 res2:3;
+		/*
+		 * CI_OUT_MOD: 3D column interleaved mode
+		 *  0: CI_1
+		 *  1: CI_2
+		 *  2: CI_3
+		 *  3: CI_4
+		 * Other: reserved
+		 */
+		u32 ci_out_mod:3; /* Default: 0 */
+		u32 res3:5;
+		/*
+		 * TB_OUT_MOD_FIELD: Top/bottom output mode field number
+		 * 0: left or left 1st field(determined by reg0x2c)
+		 * 1: right or right 1st field
+		 * 2: left 2nd field
+		 * 3: right 2nd field
+		 */
+		u32 tb_out_mod_field:2; /* Default: 0 */
+		u32 res4:6;
+	} bits;
+} SCAL_3D_CTRL_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block. This value is the start offset of right image in
+		 * 3D mode.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the
+		 * first macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
+	} bits;
+} SCAL_3D_MB_OFF0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block, This value is the start offset of right image
+		 * in 3D mode.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the
+		 * first macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
+	} bits;
+} SCAL_3D_MB_OFF1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block, This value is the start offset of right image
+		 * in 3D mode.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the
+		 * first macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
+	} bits;
+} SCAL_3D_MB_OFF2_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0:8;
+		/*
+		 * LINEBUF_AGTH: Scaler line buffer algorithm select.
+		 * 0: horizontal filtered result
+		 * 1: original data
+		 */
+		u32 linebuf_agth:1; /* Default: 0 */
+		u32 res1:23;
+	} bits;
+} SCAL_AGTH_SEL_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * BUF_ADDR: Scaler frame buffer address.
+		 * In macro block type:
+		 *   The address is the start address of the line in the first
+		 *   macro block used to generating output frame.
+		 * In non-macro block type:
+		 *   The address is the start address of the first line.
+		 */
+		u32 buf_addr; /* Default: 0 */
+	} bits;
+} SCAL_BUF_ADDR0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * BUF_ADDR: Scaler frame buffer address.
+		 * In macro block type:
+		 *   The address is the start address of the line in the first
+		 *   macro block used to generating output frame.
+		 * In non-macro block type:
+		 *   The address is the start address of the first line.
+		 */
+		u32 buf_addr; /* Default: 0 */
+	} bits;
+} SCAL_BUF_ADDR1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * BUF_ADDR: Scaler frame buffer address.
+		 * In macro block type:
+		 *   The address is the start address of the line in the first
+		 *   macro block used to generating output frame.
+		 * In non-macro block type:
+		 *   The address is the start address of the first line.
+		 */
+		u32 buf_addr; /* Default: 0 */
+	} bits;
+} SCAL_BUF_ADDR2_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0:1;
+		/*
+		 * CSC_BYPASS_EN: CSC by-pass enable.
+		 * 0: CSC enable
+		 * 1: CSC will be by-passed
+		 * Actually, in order ensure the module working be correct,
+		 * this bit only can be set when input data format is the same
+		 * as output data format (both YUV or both RGB).
+		 */
+		u32 csc_bypass_en:1; /* Default: 0 */
+		u32 res1:1;
+	} bits;
+} SCAL_BYPASS_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP0: Horizontal tap0 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap0:8; /* default: 0 */
+		/*
+		 * TAP1: Horizontal tap1 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap1:8; /* default: 0 */
+		/*
+		 * TAP2: Horizontal tap2 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap2:8; /* default: 0 */
+		/*
+		 * TAP3: Horizontal tap3 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap3:8; /* default: 0 */
+	} bits;
+} SCAL_CH0_HORZCOEF0_REGNN0;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP0: Horizontal tap0 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap0:8; /* default: 0 */
+		/*
+		 * TAP1: Horizontal tap1 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap1:8; /* default: 0 */
+		/*
+		 * TAP2: Horizontal tap2 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap2:8; /* default: 0 */
+		/*
+		 * TAP3: Horizontal tap3 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap3:8; /* default: 0 */
+	} bits;
+} SCAL_CH0_HORZCOEF0_REGN;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP4: Horizontal tap4 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap4:8; /* default: 0 */
+		/*
+		 * TAP5: Horizontal tap5 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap5:8; /* default: 0 */
+		/*
+		 * TAP6: Horizontal tap6 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap6:8; /* default: 0 */
+		/*
+		 * TAP7: Horizontal tap7 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap7:8; /* default: 0 */
+	} bits;
+} SCAL_CH0_HORZCOEF1_REGNN0;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP4: Horizontal tap4 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap4:8; /* default: 0 */
+		 /*
+		 * TAP5: Horizontal tap5 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap5:8; /* default: 0 */
+		/*
+		 * TAP6: Horizontal tap6 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap6:8; /* default: 0 */
+		/*
+		 * TAP7: Horizontal tap7 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap7:8; /* default: 0 */
+	} bits;
+} SCAL_CH0_HORZCOEF1_REGN;
+
+typedef union {
+	u32 dwval;
+	struct {
+
+		/*
+		 * FACTOR_FRAC: The fractional part of the horizontal scaling
+		 * ratio. The horizontal scaling ratio = input width/output
+		 * width.
+		 */
+		u32 factor_frac:16; /* Default: 0 */
+		/*
+		 * FACTOR_INT: The integer part of the horizontal scaling ratio.
+		 * The horizontal scaling ratio = input width/output width.
+		 */
+		u32 factor_int:8; /* Default: 0 */
+		u32 res0:8;
+	} bits;
+} SCAL_CH0_HORZFACT_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * PHASE: Y/G component initial phase in horizontal
+		 * (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
+	} bits;
+} SCAL_CH0_HORZPHASE_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TAP0: Tap 0 offset in horizontal */
+		u32 tap0:7; /* Default: 0x7D */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in horizontal */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in horizontal */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in horizontal */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
+	} bits;
+} SCAL_CH0_HORZTAP0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TAP4: Tap 4 offset in horizontal */
+		u32 tap4:7; /* Default: 0x1 */
+		u32 res0:1;
+		/* TAP5: Tap 5 offset in horizontal */
+		u32 tap5:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP6: Tap 6 offset in horizontal */
+		u32 tap6:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP7: Tap 7 offset in horizontal */
+		u32 tap7:7; /* Default: 0x1 */
+		u32 res3:1;
+	} bits;
+} SCAL_CH0_HORZTAP1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * IN_WIDTH: Input image Y/G component width. The image width =
+		 * The value of these bits add 1. When line buffer result
+		 * selection is original data, the maximum width is 2048.
+		 */
+		u32 in_width:13; /* Default: 0x0 */
+		u32 res0:3;
+		/*
+		 * IN_HEIGHT: Input image Y/G component height. Input image
+		 * height = The value of these bits add 1.
+		 */
+		u32 in_height:13; /* Default: 0x0 */
+		u32 res1:3;
+	} bits;
+} SCAL_CH0_INSIZE_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * OUT_WIDTH: Output layer Y/G component width. The output layer
+		 * width = The value of these bits add 1. When line buffer
+		 * result selection is horizontal filtered result, the maximum
+		 * width is 2048.
+		 */
+		u32 out_width:13; /* Default: 0x0 */
+		u32 res0:3;
+		/*
+		 * OUT_HEIGHT: Output layer Y/G component height. The output
+		 * layer height = The value of these bits add 1.
+		 */
+		u32 out_height:13; /* Default: 0x0 */
+		u32 res1:3;
+	} bits;
+} SCAL_CH0_OUTSIZE_REG;
+
+typedef union {
+	u32 dwval;
+
+	struct {
+
+		/*
+		 * TAP0: Vertical tap0 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap0:8; /* Default: 0 */
+		/*
+		 * TAP1: Vertical tap1 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap1:8; /* Default: 0 */
+		/*
+		 * TAP2: Vertical tap2 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap2:8; /* Default: 0 */
+		/*
+		 * TAP3: Vertical tap3 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap3:8; /* Default: 0 */
+	} bits;
+} SCAL_CH0_VERTCOEF_REGNN0;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP0: Vertical tap0 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap0:8; /* Default: 0 */
+		 /*
+		 * TAP1: Vertical tap1 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap1:8; /* Default: 0 */
+		/*
+		 * TAP2: Vertical tap2 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap2:8; /* Default: 0 */
+		/*
+		 * TAP3: Vertical tap3 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap3:8; /* Default: 0 */
+	} bits;
+} SCAL_CH0_VERTCOEF_REGN;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * FACTOR_FRAC: The fractional part of the vertical scaling
+		 * ratio. The vertical scaling ratio = input height /output
+		 * height.
+		 */
+		u32 factor_frac:16; /* Default: 0 */
+		/*
+		 * FACTOR_INT: The integer part of the vertical scaling ratio.
+		 * The vertical scaling ratio = input height/output height.
+		 */
+		u32 factor_int:8; /* Default: 0x0 */
+		u32 res0:8;
+	} bits;
+} SCAL_CH0_VERTFACT_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * PHASE: Y/G component initial phase in vertical for top field
+		 * (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
+	} bits;
+} SCAL_CH0_VERTPHASE0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * PHASE: Y/G component initial phase in vertical for bottom
+		 * field (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
+	} bits;
+} SCAL_CH0_VERTPHASE1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TAP0: Tap 0 offset in vertical. */
+		u32 tap0:7; /* Default: 0x7F */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in vertical. */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in vertical. */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in vertical. */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
+	} bits;
+} SCAL_CH0_VERTTAP;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TAP0: Tap 0 offset in vertical. */
+		u32 tap0:7; /* Default: 0x7F */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in vertical. */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in vertical. */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in vertical. */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
+	} bits;
+} SCAL_CH0_VERTTAP_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP0: Horizontal tap0 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap0:8; /* default: 0 */
+		 /*
+		 * TAP1: Horizontal tap1 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap1:8; /* default: 0 */
+		/*
+		 * TAP2: Horizontal tap2 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap2:8; /* default: 0 */
+		/*
+		 * TAP3: Horizontal tap3 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap3:8; /* default: 0 */
+	} bits;
+} SCAL_CH1_HORZCOEF0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP0: Horizontal tap0 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap0:8; /* default: 0 */
+		/*
+		 * TAP1: Horizontal tap1 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap1:8; /* default: 0 */
+		/*
+		 * TAP2: Horizontal tap2 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap2:8; /* default: 0 */
+		/*
+		 * TAP3: Horizontal tap3 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap3:8; /* default: 0 */
+	} bits;
+} SCAL_CH1_HORZCOEF0_REGN;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP4: Horizontal tap4 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap4:8; /* default: 0 */
+		/*
+		 * TAP5: Horizontal tap5 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap5:8; /* default: 0 */
+		/*
+		 * TAP6: Horizontal tap6 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap6:8; /* default: 0 */
+		/*
+		 * TAP7: Horizontal tap7 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap7:8; /* default: 0 */
+	} bits;
+} SCAL_CH1_HORZCOEF1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP4: Horizontal tap4 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap4:8; /* default: 0 */
+		/*
+		 * TAP5: Horizontal tap5 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap5:8; /* default: 0 */
+		/*
+		 * TAP6: Horizontal tap6 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap6:8; /* default: 0 */
+		/*
+		 * TAP7: Horizontal tap7 coefficient.
+		 * The value equals to coefficient * 26
+		 */
+		u32 tap7:8; /* default: 0 */
+	} bits;
+} SCAL_CH1_HORZCOEF1_REGN;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * FACTOR_FRAC: The fractional part of the horizontal scaling
+		 * ratio. The horizontal scaling ratio = input width/output
+		 * width.
+		 */
+		u32 factor_frac:16; /* Default: 0 */
+		/*
+		 * FACTOR_INT: The integer part of the horizontal scaling ratio.
+		 * the horizontal scaling ratio = input width/output width.
+		 */
+		u32 factor_int:8; /* Default: 0 */
+		u32 res0:8;
+	} bits;
+} SCAL_CH1_HORZFACT_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * PHASE: U/R component initial phase in horizontal
+		 * (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
+	} bits;
+} SCAL_CH1_HORZPHASE_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TAP0: Tap 0 offset in horizontal */
+		u32 tap0:7; /* Default: 0x7D */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in horizontal */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in horizontal */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in horizontal */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
+	} bits;
+} SCAL_CH1_HORZTAP0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TAP4: Tap 4 offset in horizontal */
+		u32 tap4:7; /* Default: 0x1 */
+		u32 res0:1;
+		/* TAP5: Tap 5 offset in horizontal */
+		u32 tap5:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP6: Tap 6 offset in horizontal */
+		u32 tap6:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP7: Tap 7 offset in horizontal */
+		u32 tap7:7; /* Default: 0x1 */
+		u32 res3:1;
+	} bits;
+} SCAL_CH1_HORZTAP1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * IN_WIDTH: Input image U/R component width, The image width =
+		 * The value of these bits add 1. When line buffer result
+		 * selection is original data, the maximum width is 2048.
+		 */
+		u32 in_width:13; /* Default: 0x0 */
+		u32 res0:3;
+		/*
+		 * IN_HEIGHT: Input image U/R component height. Input image
+		 * height = The value of these bits add 1.
+		 */
+		u32 in_height:13; /* Default: 0x0 */
+		u32 res1:3;
+	} bits;
+} SCAL_CH1_INSIZE_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * OUT_WIDTH: Output layer U/R component width. The output layer
+		 * width = The value of these bits add 1. When line buffer
+		 * result selection is horizontal filtered result, the maximum
+		 * width is 2048.
+		 */
+		u32 out_width:13; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * OUT_HEIGHT: Output layer U/R component height. The output
+		 * layer height = The value of these bits add 1.
+		 */
+		u32 out_height:13; /* Default: 0 */
+		u32 res1:3;
+	} bits;
+} SCAL_CH1_OUTSIZE_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP0: Vertical tap0 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap0:8; /* Default: 0 */
+		/*
+		 * TAP1: Vertical tap1 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap1:8; /* Default: 0 */
+		/*
+		 * TAP2: Vertical tap2 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap2:8; /* Default: 0 */
+		/*
+		 * TAP3: Vertical tap3 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap3:8; /* Default: 0 */
+	} bits;
+} SCAL_CH1_VERTCOEF_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * TAP0: Vertical tap0 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap0:8; /* Default: 0 */
+		/*
+		 * TAP1: Vertical tap1 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap1:8; /* Default: 0 */
+		 /*
+		 * TAP2: Vertical tap2 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap2:8; /* Default: 0 */
+		/*
+		 * TAP3: Vertical tap3 coefficient.
+		 * The value equals to coefficient*26.
+		 */
+		u32 tap3:8; /* Default: 0 */
+	} bits;
+} SCAL_CH1_VERTCOEF_REGN;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * FACTOR_FRAC: The fractional part of the vertical scaling
+		 * ratio. The vertical scaling ratio = input height / output
+		 * height.
+		 */
+		u32 factor_frac:16; /* Default: 0 */
+		/*
+		 * FACTOR_INT: The integer part of the vertical scaling ratio.
+		 * The vertical scaling ratio = input height / output height.
+		 */
+		u32 factor_int:8; /* Default: 0 */
+		u32 res0:8;
+	} bits;
+} SCAL_CH1_VERTFACT_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * PHASE: U/R component initial phase in vertical for top field
+		 * (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
+	} bits;
+} SCAL_CH1_VERTPHASE0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * PHASE: U/R component initial phase in vertical for bottom
+		 * field (complement). This value equals to initial phase * 216.
+		 */
+		u32 phase:20; /* Default: 0 */
+		u32 res0:12;
+	} bits;
+} SCAL_CH1_VERTPHASE1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TAP0: Tap 0 offset in vertical. */
+		u32 tap0:7; /* Default: 0x7F */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in vertical. */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in vertical. */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in vertical. */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
+	} bits;
+} SCAL_CH1_VERTTAP;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TAP0: Tap 0 offset in vertical. */
+		u32 tap0:7; /* Default: 0x7F */
+		u32 res0:1;
+		/* TAP1: Tap 1 offset in vertical. */
+		u32 tap1:7; /* Default: 0x1 */
+		u32 res1:1;
+		/* TAP2: Tap 2 offset in vertical. */
+		u32 tap2:7; /* Default: 0x1 */
+		u32 res2:1;
+		/* TAP3: Tap 3 offset in vertical. */
+		u32 tap3:7; /* Default: 0x1 */
+		u32 res3:1;
+	} bits;
+} SCAL_CH1_VERTTAP_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the Y/G coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF00_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the Y/G coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF01_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the Y/G coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF02_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * CONT: the Y/G constant. The value equals to coefficient * 24.
+		 */
+		u32 cont:14; /* Default: 0 */
+		u32 res0:18;
+	} bits;
+} SCAL_CSC_COEF03_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the U/R coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF10_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the U/R coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF11_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the U/R coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF12_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * CONT: the U/R constant. The value equals to coefficient * 24.
+		 */
+		u32 cont:14; /* Default: 0 */
+		u32 res0:18;
+	} bits;
+} SCAL_CSC_COEF13_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the V/B coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF20_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the V/B coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF21_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * COEF: the V/B coefficient. The value equals to coefficient *
+		 * 210.
+		 */
+		u32 coef:13; /* Default: 0 */
+		u32 res0:19;
+	} bits;
+} SCAL_CSC_COEF22_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * CONT: the V/B constant. The value equals to coefficient * 24.
+		 */
+		u32 cont:14; /* Default: 0 */
+		u32 res0:18;
+	} bits;
+} SCAL_CSC_COEF23_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * BLK_FLAG_ADDR: Current frame block flag buffer address.
+		 */
+		u32 blk_flag_addr; /* Default: 0 */
+	} bits;
+} SCAL_DI_BLKFLAG_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* LUMA: Luma burst length */
+		u32 luma:6; /* Default: 0x1F */
+		u32 res0:2;
+		/* CHROMA: Chroma burst length */
+		u32 chroma:6; /* Default: 0x1F */
+		u32 res1:18;
+	} bits;
+} SCAL_DI_BURSTLEN_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * EN: De-interlacing enable.
+		 * 0: de-interlacing disable.
+		 * 1: de-interlacing enable.
+		 */
+		u32 en:1; /* Default: 0 */
+		u32 res0:15;
+		/*
+		 * MOD: De-interlacing mode select.
+		 * 00: weave
+		 * 01: bob
+		 * 10: DI-MAF
+		 * 11: DI-MAF-BOB
+		 */
+		u32 mod:2; /* Default: 0 */
+		u32 res1:6;
+		/*
+		 * DIAGINTP_EN: De-interlacing diagonal interpolate enable.
+		 * 0: disable
+		 * 1: enable
+		 */
+		u32 diagintp_en:1; /* Default: 0 */
+		/*
+		 * TEMPDIFF_EN: Temporal difference compare enable.
+		 * 0: disable
+		 * 1: enable
+		 */
+		u32 tempdiff_en:1; /* Default: 0 */
+		u32 res2:6;
+	} bits;
+} SCAL_DI_CTRL_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TH0: Diagintp_th0 */
+		u32 th0:7; /* Default: 0x4F */
+		u32 res0:1;
+		/* TH1: Diagintp_th1 */
+		u32 th1:7; /* Default: 0x5 */
+		u32 res1:1;
+		/* TH2: Diagintp_th2 */
+		u32 th2:8; /* Default: 0x10 */
+		/* TH3: Diagintp_th3 */
+		u32 th3:8; /* Default: 0x8 */
+	} bits;
+} SCAL_DI_DIAGINTP_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* BLK_FLAG_LINESTRD: block flag line-stride. */
+		u32 blk_flag_linestrd; /* Default: 0x40 */
+	} bits;
+} SCAL_DI_FLAGLINESTRD_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* PREFRM_ADDR: Pre-frame buffer address of luma. */
+		u32 prefrm_addr; /* Default: 0 */
+	} bits;
+} SCAL_DI_PRELUMA_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TH1: Sawtooth_th1 */
+		u32 th1:8; /* Default: 0x14 */
+		/* TH2: Sawtooth_th2 */
+		u32 th2:8; /* Default: 0x8 */
+		u32 res0:16;
+	} bits;
+} SCAL_DI_SAWTOOTH_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TH0: spatial_th0 */
+		u32 th0:9; /* Default: 0x64 */
+		u32 res0:7;
+		/* TH1: spatial_th1 */
+		u32 th1:9; /* Default: 0xA */
+		u32 res1:7;
+	} bits;
+} SCAL_DI_SPATCOMP_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0:8;
+		/* TH: Temporal_th */
+		u32 th:5; /* Default: 0xF */
+		u32 res1:19;
+	} bits;
+} SCAL_DI_TEMPDIFF_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * EN: Scaler enable
+		 *  0: Disable
+		 *  1: Enable
+		 * When scaler enable bit is disabled, the clock of scaler
+		 * module will be disabled. If this bit is transitioned from 0
+		 * to 1, the frame process control register and the interrupt
+		 * enable register will be initialed to default value, and the
+		 * state machine of the module is reset.
+		 */
+		u32 en:1; /* Default: 0 */
+		u32 res0:31;
+	} bits;
+} SCAL_EN_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * FIELD_CNT: Field counter, each bit specify a field to
+		 * display.
+		 * 0: top field
+		 * 1: bottom field
+		 */
+		u32 field_cnt:8; /* Default: 0 */
+		/*
+		 * VALID_FIELD_CNT: Valid field counter bit.
+		 * the valid value = this value + 1
+		 */
+		u32 valid_field_cnt:3; /* Default: 0 */
+		u32 res0:1;
+		/*
+		 * FIELD_LOOP_MOD: Field loop mode
+		 * 0: the last field
+		 * 1: the full frame
+		 */
+		u32 field_loop_mod:1; /* Default: 0 */
+		u32 res1:19;
+	} bits;
+} SCAL_FIELD_CTRL_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * REG_RDY_EN: Register ready enable.
+		 *  0: not ready
+		 *  1: registers configuration ready.
+		 * As same as filter coefficients configuration, in order to
+		 * ensure the display be correct, the correlative display
+		 * configuration registers are buffered too, the programmer also
+		 * can change the value of correlative registers in any time.
+		 * When the registers setting is finished, the programmer should
+		 * set the bit if the programmer need the new configuration in
+		 * next scaling frame., When the new frame start, the bit will
+		 * also be self-cleared.
+		 */
+		u32 reg_rdy_en:1; /* Default: 0 */
+		/*
+		 * COEF_RDY_EN: Filter coefficients ready enable.
+		 *  0: not ready
+		 *  1: filter coefficients configuration ready.
+		 * In order to avoid the noise, you have to ensure the same set
+		 * filter coefficients are used in one frame, so the filter
+		 * coefficients are buffered, the programmer can change the
+		 * coefficients in any time. When the filter coefficients
+		 * setting is finished, the pro, rammer should set the bit if
+		 * the programmer need the new coefficients in next scaling
+		 * frame. When the new frame start, the bit will be
+		 * self-cleared.
+		 */
+		u32 coef_rdy_en:1; /* Default: 0 */
+		/*
+		 * WB_EN: Write back enable.
+		 *  0: Disable
+		 *  1: Enable
+		 * If output to image is enable, the writing back process will
+		 * start when write back enable bit is set and a new frame
+		 * processing begins. The bit will be self-cleared when
+		 * writing-back frame process starts.
+		 */
+		u32 wb_en:1; /* Default: 0 */
+		u32 res0:5;
+		/*
+		 * OUT_PORT_SEL: Scaler output port select.
+		 * 00: image0
+		 * 01: image1
+		 * other: reserved
+		 */
+		u32 out_port_sel:2; /* Default: 0 */
+		u32 res1:1;
+		/*
+		 * OUT_CTRL: Scaler output control.
+		 *  0: enable scaler output to image
+		 *  1: disable scaler output to image.
+		 * If scaler write back function is enable, scaler output to
+		 * image isn't recommended.
+		 */
+		u32 out_ctrl:1; /* Default: 0 */
+		/*
+		 * IN_CTRL: Scaler input source control.
+		 * 000: from dram
+		 * 100: from image0 interface of image2lcd (don't influence the
+		 *      interface timing of image)
+		 * 101: from image1 interface of image2lcd (don't influence the
+		 *      interface timing of image)
+		 * 110: from image0 (influence the interface timing of image)
+		 * 111: from image1 (influence the interface timing of image)
+		 * Other: reserved
+		 */
+		u32 in_ctrl:3; /* Default: 0 */
+		u32 res2:1;
+		/*
+		 * FRM_START: Frame start & reset control.
+		 *  0: reset
+		 *  1: start
+		 * If the bit is written to zero, the whole state machine and
+		 * data paths of scaler module will be reset., When the bit is
+		 * written to 1, Scaler will start a new frame process.
+		 */
+		u32 frm_start:1; /* Default: 0 */
+		u32 res3:6;
+		u32 coef_access_ctrl:1; /* sun5i fir coef ram access control */
+		u32 res4:8;
+	} bits;
+} SCAL_FRM_CTRL_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * DATA_PS: Pixel sequence.
+		 * In interleaved YUV422 data mode:
+		 *  00: Y1V0Y0U0
+		 *  01: V0Y1U0Y0
+		 *  10: Y1U0Y0V0
+		 *  11: U0Y1V0Y0
+		 * In interleaved YUV444 data mode:
+		 *  00: VUYA
+		 *  01: AYUV
+		 *  Other: reserved
+		 * In UV combined data mode (UV component):
+		 *  00: V1U1V0U0
+		 *  01: U1V1U0V0
+		 *  Other: reserved
+		 * In interleaved ARGB8888 data mode:
+		 *  00: BGRA
+		 *  01: ARGB
+		 *  Other: reserved
+		 */
+		u32 data_ps:2; /* Default: 0x0 */
+		u32 res0:2;
+		/*
+		 * DATA_FMT: Input component data format.
+		 * In non-macro block planar data mode:
+		 *  000: YUV 4:4:4
+		 *  001: YUV 4:2:2
+		 *  010: YUV 4:2:0
+		 *  011: YUV 4:1:1
+		 *  100: CSI RGB data
+		 *  101: RGB888
+		 *  Other: Reserved
+		 * In interleaved data mode:
+		 *  000: YUV 4:4:4
+		 *  001: YUV 4:2:2
+		 *  101: ARGB8888
+		 *  Other: reserved
+		 * In non-macro block UV combined data mode:
+		 *  001: YUV 4:2:2
+		 *  010: YUV 4:2:0
+		 *  011: YUV 4:1:1
+		 *  Other: reserved
+		 * In macro block planar data mode:
+		 *  001: YUV 4:2:2
+		 *  010: YUV 4:2:0
+		 *  011: YUV 4:1:1
+		 *  Other: Reserved
+		 * In macro block UV combined data mode:
+		 *  001: YUV 4:2:2
+		 *  010: YUV 4:2:0
+		 *  011: YUV 4:1:1
+		 *  Other: reserved
+		 */
+		u32 data_fmt:3; /* Default: 0 */
+		u32 res1:1;
+		/*
+		 * DATA_MOD: Input data mode selection.
+		 *  000: non-macro block planar data
+		 *  001: interleaved data
+		 *  010: non-macro block UV combined data
+		 *  100: macro block planar data
+		 *  110: macro block UV combined data
+		 *  other: reserved
+		 */
+		u32 data_mod:3; /* Default: 0 */
+		u32 res2:1;
+		/*
+		 * SCAN_MOD: Scanning Mode selection.
+		 * 0: non-interlace
+		 * 1: interlace
+		 */
+		u32 scan_mod:1; /* Default: 0 */
+		u32 res3:3;
+		/*
+		 *  BYTE_SEQ: Input data byte sequence selection.
+		 * 0: P3P2P1P0(word)
+		 * 1: P0P1P2P3(word)
+		 */
+		u32 byte_seq:1; /* Default: 0 */
+		u32 res4:15;
+	} bits;
+} SCAL_INPUT_FMT_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0:7;
+		/*
+		 * WB_EN: Write-back end interrupt enable.
+		 * 0: Disable
+		 * 1: Enable
+		 */
+		u32 wb_en:1; /* Default: 0 */
+		u32 res1:1;
+		/* LINE_EN: Line interrupt enable */
+		u32 line_en:1; /* Default: 0 */
+		/* REG_LOAD_EN: Register ready load interrupt enable */
+		u32 reg_load_en:1; /* Default: 0 */
+		u32 res2:21;
+	} bits;
+} SCAL_INT_EN_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		u32 res0:7;
+		/* WB_STATUS: Write-back end interrupt status. */
+		u32 wb_status:1; /* Default: 0 */
+		u32 res1:1;
+		/* LINE_STATUS: Line interrupt status */
+		u32 line_status:1; /* Default: 0 */
+		/* REG_LOAD_STATUS: Register ready load interrupt status */
+		u32 reg_load_status:1; /* Default: 0 */
+		u32 res2:21;
+	} bits;
+} SCAL_INT_STATUS_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * LINE_STRIDE:
+		 * In macro block type: The stride length is the distance from
+		 *   the start of the end line in one macro block to the start
+		 *   of the first line in next macro block (here next macro
+		 *   block is in vertical direction).
+		 * In no macro block type: The stride length is the distance
+		 *   from the start of one line to the start of the next line.
+		 */
+		u32 line_stride; /* Default: 0 */
+	} bits;
+} SCAL_LINESTRD0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * LINE_STRIDE:
+		 * In macro block type: The stride length is the distance from
+		 *   the start of the end line in one macro block to the start
+		 *   of the first line in next macro block (here next macro
+		 *   block is in vertical direction).
+		 * In no macro block type: The stride length is the distance
+		 *   from the start of one line to the start of the next line.
+		 */
+		u32 line_stride; /* Default: 0 */
+	} bits;
+} SCAL_LINESTRD1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * LINE_STRIDE:
+		 * In macro block type: The stride length is the distance from
+		 *   the start of the end line in one macro block to the start
+		 *   of the first line in next macro block (here next macro
+		 *   block is in vertical direction).
+		 * In no macro block type: The stride length is the distance
+		 *   from the start of one line to the start of the next line.
+		 */
+		u32 line_stride; /* Default: 0 */
+	} bits;
+} SCAL_LINESTRD2_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* TRIG_LINE: Trigger line number of line interrupt */
+		u32 trig_line:13; /* Default: 0 */
+		u32 res0:2;
+		/*
+		 * FIELD_SEL: Field select.
+		 * 0: each field
+		 * 1: end field (field counter in reg0x2c)
+		 */
+		u32 field_sel:1; /* Default: 0 */
+		/* CURRENT_LINE */
+		u32 current_line:12; /* Default: 0x0 */
+		u32 res1:4;
+	} bits;
+} SCAL_LINT_CTRL_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the end
+		 * macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
+	} bits;
+} SCAL_MB_OFF0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the end
+		 * macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
+	} bits;
+} SCAL_MB_OFF1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * X_OFFSET0: The x offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 x_offset0:5; /* Default: 0 */
+		u32 res0:3;
+		/*
+		 * Y_OFFSET0: The y offset of the top-left point in the first
+		 * macro block.
+		 */
+		u32 y_offset0:5; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * X_OFFSET1: The x offset of the bottom-right point in the end
+		 * macro block.
+		 */
+		u32 x_offset1:5; /* Default: 0 */
+		u32 res2:11;
+	} bits;
+} SCAL_MB_OFF2_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * DATA_FMT: Data format.
+		 * 000: planar RGB888 conversion data format,
+		 * 001: interleaved BGRA8888 conversion data format (A component
+		 *      always be pad 0xff).
+		 * 010: interleaved ARGB8888 conversion data format (A component
+		 *       always be pad 0xff)
+		 * 100: planar YUV 444
+		 * 101: planar YUV 420 (only support YUV input and not
+		 *      interleaved mode)
+		 * 110: planar YUV 422 (only support YUV input)
+		 * 111: planar YUV 411 (only support YUV input)
+		 * Other: reserved
+		 */
+		u32 data_fmt:3; /* Default: 0 */
+		u32 res0:1;
+		/*
+		 * SCAN_MOD: Output interlace enable.
+		 *  0: disable
+		 *  1: enable
+		 * When output interlace enable, scaler selects YUV initial
+		 * phase according to LCD field signal.
+		 */
+		u32 scan_mod:1; /* Default: 0 */
+		u32 res1:3;
+		/*
+		 * BYTE_SEQ: Output data byte sequence selection.
+		 * 0: P3P2P1P0(word)
+		 * 1: P0P1P2P3(word)
+		 * For ARGB, when this bit is 0, the byte sequence is BGRA, and
+		 * when this bit is 1, the byte sequence is ARGB.
+		 */
+		u32 byte_seq:1; /* Default: 0 */
+		u32 res2:7;
+		/* write back channel select (sun5i only) */
+		u32 wb_chsel:2;
+		u32 res3:14;
+	} bits;
+} SCAL_OUTPUT_FMT_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * FRM_BUSY: Frame busy.
+		 * This flag indicates that the frame is being processed.
+		 * The bit will be set when frame process reset & start is set,
+		 * and be cleared when frame process reset or disabled.
+		 */
+		u32 frm_busy:1; /* Default: 0 */
+		/*
+		 * WB_STATUS: Write-back process status.
+		 *  0: write-back end or write-back disable
+		 *  1: write-back in process
+		 * This flag indicates that a full frame has not been written
+		 * back to memory. The bit will be set when write-back enable
+		 * bit is set, and be cleared when write-back process end.
+		 */
+		u32 wb_status:1; /* Default: 0 */
+		/*
+		 * CFG_PENDING: Register configuration pending.
+		 *  0: no pending.
+		 *  1: configuration pending
+		 * This bit indicates the registers for the next frame has been
+		 * configured. This bit will be set when configuration ready bit
+		 * is set and this bit will be cleared when a new frame process
+		 * begin.
+		 */
+		u32 cfg_pending:1; /* Default: 0 */
+		u32 res0:1;
+		/*
+		 * DRAM_STATUS: Access dram status.
+		 *  0: idle
+		 *  1: busy
+		 * This flag indicates whether scaler is accessing dram.
+		 */
+		u32 dram_status:1; /* Default: 0 */
+		/*
+		 * LCD_FIELD: LCD field status.
+		 *  0: top field
+		 *  1: bottom field
+		 */
+		u32 lcd_field:1; /* Default: 0 */
+		u32 res1:5;
+		/* fir coef access status (sun5i only) */
+		u32 coef_access_status:1;
+		/*
+		 * WB_ERR_STATUS: write-back error status.
+		 *  0: valid write back
+		 *  1: un-valid write back
+		 * This bit is cleared through write 0 to reset/start bit in
+		 * frame control register
+		 */
+		u32 wb_err_status:1; /* Default: 0 */
+		u32 res2:1;
+		/* WB_ERR_LOSEDATA: Lose data flag when capture in process. */
+		u32 wb_err_losedata:1; /* Default: 0 */
+		/* WB_ERR_SYNC: Sync reach flag when capture in process. */
+		u32 wb_err_sync:1; /* Default: 0 */
+		/* LINE_ON_SYNC: Line number when sync reached. */
+		u32 line_on_sync:13; /* Default: 0 */
+		u32 res3:3;
+	} bits;
+} SCAL_STATUS_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* BLE_EN: BLE enable */
+		u32 ble_en:1; /* Default: 0 */
+		u32 res0:7;
+		/* BLE_THR: BLE threshold. Note: MUST BE set [0:127] */
+		u32 ble_thr:8; /* Default: 0 */
+		/* BLE_GAIN: BLE gain */
+		u32 ble_gain:8; /* Default: 0 */
+		u32 res1:8;
+	} bits;
+} SCAL_VPP_BLE_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * DCTI_EN:
+		 * 0: Disable
+		 * 1: Enable
+		 */
+		u32 dcti_en:1; /* Default: 0 */
+		u32 res0:5;
+		/*
+		 * DCTI_HILL_EN: DCTI hill protection enable.
+		 * 0: Disable
+		 * 1: Enable
+		 */
+		u32 dcti_hill_en:1; /* Default: 0 */
+		/*
+		 * DCTI_SUPHILL_EN: DCTI super hill protection enable.
+		 *  0: Disable
+		 *  1: Enable
+		 */
+		u32 dcti_suphill_en:1; /* Default: 0 */
+		/*
+		 * DCTI_FILTER1_SEL: DCTI 1st filter algorithm selection.
+		 * 00: algorithm0
+		 * 01: algorithm1
+		 * 10: algorithm2
+		 * 11: reserved
+		 */
+		u32 dcti_filter1_sel:2; /* Default: 0 */
+		/*
+		 * DCTI_FILTER2_SEL: DCTI 2nd filter algorithm selection.
+		 * 00: algorithm0
+		 * 01: algorithm1
+		 * 10: algorithm2
+		 * 11: reserved
+		 */
+		u32 dcti_filter2_sel:2; /* Default: 0 */
+		/* DCTI_PATH_LIMIT: Max path limit equal to 12 */
+		u32 dcti_path_limit:4; /* Default: 0 */
+		/* DCTI_GAIN */
+		u32 dcti_gain:6; /* Default: 0 */
+		u32 res1:2;
+		/*
+		 * UV_DIFF_SIGN_MODE_SEL: UV separate mode in different sign
+		 * condition:
+		 *  00: Using U always
+		 *  01: Using V always
+		 *  10: Using 0 always
+		 *  11: Using Max/Min mode
+		 */
+		u32 uv_diff_sign_mode_sel:2; /* Default: 0 */
+		/*
+		 * UV_SAME_SIGN_MODE_SEL: UV separate mode in same sign
+		 * condition:
+		 *  00: Using U always
+		 *  01: Using V always
+		 *  10: Using 0 always
+		 *  11: Using Max/Min mode
+		 */
+		u32 uv_same_sign_mode_sel:2; /* Default: 0 */
+		/*
+		 * UV_DIFF_SIGN_ MAX/MIN_MODE_SEL: UV direction detection using
+		 * max or min of |U|/|V| in different sign condition, when
+		 * related separate mode select "Using Max/Min mode" and U/V
+		 * path shift are in the different sign, path shift use:
+		 * 0: min(|U|,|V|)
+		 * 1: max(|U|,|V|)
+		 */
+		u32 uv_diff_sign_maxmin_mode_sel:1; /* Default: 0 */
+		/*
+		 * UV_SAME_SIGN_MAX/MIN_MODE_SEL: UV direction detection using
+		 * max or min of |U|/|V| in same sign condition, when related
+		 * separate mode select "Using Max/Min mode" and U/V path shift
+		 * are in the same sign, path shift use:
+		 * 0: min(|U|,|V|)
+		 * 1: max(|U|,|V|)
+		 */
+		u32 uv_same_sign_maxmin_mode_sel:1; /* Default: 0 */
+		u32 res2:1;
+		/*
+		 * UV_SEPARATE_EN: UV separate enable.
+		 * 0: U/V will be under direction detection control
+		 * 1: U/V wont be under direction detection control
+		 */
+		u32 uv_separate_en:1; /* Default: 0 */
+	} bits;
+} SCAL_VPP_DCTI_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * EN: VPP enable.
+		 *  0: Disable
+		 *  1: Enable
+		 */
+		u32 en:1; /* Default: 0 */
+		u32 res0:31;
+	} bits;
+} SCAL_VPP_EN_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * LP_EN:
+		 * 0: Disable
+		 * 1: Enable
+		 */
+		u32 lp_en:1; /* Default: 0 */
+		u32 res0:7;
+		/* TAU: LP band-pass filter1 gain. */
+		u32 tau:5; /* Default: 0 */
+		u32 res1:3;
+		/* ALPHA: LP band-pass filter2 gain. */
+		u32 alpha:5; /* Default: 0 */
+		u32 res2:3;
+		/* BETA: LP high-pass filter gain. */
+		u32 beta:5; /* Default: 0 */
+		u32 res3:3;
+	} bits;
+} SCAL_VPP_LP1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* LPF_GAIN: LP low-pass-filter gain. */
+		u32 lpf_gain:5; /* Default: 0 */
+		u32 res0:3;
+		/* CPRTHR: LP coring threshold */
+		u32 corthr:8; /* Default: 0 */
+		/*
+		 * NEGGAIN: LP LUT selection for undershot.
+		 * 00: NEGGAIN0
+		 * 01: NEGGAIN025
+		 * 10: NEGGAIN05
+		 * 11: NEGGAIN1
+		 */
+		 u32 neggain:2; /* Default: 0 */
+		u32 res1:4;
+		/*
+		 * DELTA: LP LUT selection for overshoot.
+		 * 00: DELTA0
+		 * 01: DELTA025
+		 * 10: DELTA05
+		 * 11: DELTA1
+		 */
+		u32 delta:2; /* Default: 0 */
+		/* LIMIT_THR: LP limit threshold. */
+		u32 limit_thr:8; /* Default: 0 */
+	} bits;
+} SCAL_VPP_LP2_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* WLE_EN: WLE enable. */
+		u32 wle_en:1; /* Default: 0 */
+		u32 res0:7;
+		/* WLE_THR: WLE threshold. Note: MUST BE set [128-255] */
+		u32 wle_thr:8; /* Default: 0 */
+		/* WLE_GAIN: WLE gain. */
+		u32 wle_gain:8; /* Default: 0 */
+		u32 res1:8;
+	} bits;
+} SCAL_VPP_WLE_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* WB_ADDR: Write-back address setting for scaled data. */
+		u32 wb_addr; /* Default: 0 */
+	} bits;
+} SCAL_WB_ADDR0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* WB_ADDR: Write-back address setting for scaled data. */
+		u32 wb_addr; /* Default: 0 */
+	} bits;
+} SCAL_WB_ADDR1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* WB_ADDR: Write-back address setting for scaled data. */
+		u32 wb_addr; /* Default: 0 */
+	} bits;
+} SCAL_WB_ADDR2_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* LINE_STRD: Ch3 write back line-stride. */
+		u32 line_strd; /* Default: 0 */
+	} bits;
+} SCAL_WB_LINESTRD0_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* LINE_STRD: Ch4 write back line-stride. */
+		u32 line_strd; /* Default: 0 */
+	} bits;
+} SCAL_WB_LINESTRD1_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/* LINE_STRD: Ch5 write back line-stride. */
+		u32 line_strd; /* Default: 0 */
+	} bits;
+} SCAL_WB_LINESTRD2_REG;
+
+typedef union {
+	u32 dwval;
+	struct {
+		/*
+		 * EN: Write back line-stride enable.
+		 * 0: disable
+		 * 1: enable
+		 */
+		u32 en:1; /* Default: 0 */
+		u32 res0:31;
+	} bits;
+} SCAL_WB_LINESTRD_EN_REG;
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 res0; /* Default: 0 */
+	} bits;
+} SCAL_RESERVED_REG;
+
+/*
+ * device define
+ */
+typedef struct __DE_SCAL_DEV {
+	SCAL_EN_REG modl_en;				/* 0x00 */
+	SCAL_FRM_CTRL_REG frm_ctrl;			/* 0x04 */
+	SCAL_BYPASS_REG bypass;				/* 0x08 */
+	SCAL_AGTH_SEL_REG agth_sel;			/* 0x0c */
+	SCAL_LINT_CTRL_REG lint_ctrl;			/* 0x10 */
+	SCAL_RESERVED_REG res0x14[3];			/* 0x14-0x1f */
+	SCAL_BUF_ADDR0_REG buf_addr0;			/* 0x20 */
+	SCAL_BUF_ADDR1_REG buf_addr1;			/* 0x24 */
+	SCAL_BUF_ADDR2_REG buf_addr2;			/* 0x28 */
+	SCAL_FIELD_CTRL_REG field_ctrl;			/* 0x2c */
+	SCAL_MB_OFF0_REG mb_off0;			/* 0x30 */
+	SCAL_MB_OFF1_REG mb_off1;			/* 0x34 */
+	SCAL_MB_OFF2_REG mb_off2;			/* 0x38 */
+	SCAL_RESERVED_REG res0x3c;			/* 0x3c */
+	SCAL_LINESTRD0_REG linestrd0;			/* 0x40 */
+	SCAL_LINESTRD1_REG linestrd1;			/* 0x44 */
+	SCAL_LINESTRD2_REG linestrd2;			/* 0x48 */
+	SCAL_INPUT_FMT_REG input_fmt;			/* 0x4c */
+	SCAL_WB_ADDR0_REG wb_addr0;			/* 0x50 */
+	SCAL_WB_ADDR1_REG wb_addr1;			/* 0x54 */
+	SCAL_WB_ADDR2_REG wb_addr2;			/* 0x58 */
+	SCAL_OUTPUT_FMT_REG output_fmt;			/* 0x5c */
+	SCAL_INT_EN_REG int_en;				/* 0x60 */
+	SCAL_INT_STATUS_REG int_status;			/* 0x64 */
+	SCAL_STATUS_REG status;				/* 0x68 */
+	SCAL_RESERVED_REG res0x6c;			/* 0x6c */
+	SCAL_CSC_COEF03_REG csc_coef[12];		/* 0x70-0x9f */
+	SCAL_DI_CTRL_REG di_ctrl;			/* 0xa0 */
+	SCAL_DI_DIAGINTP_REG di_diagintp;		/* 0xa4 */
+	SCAL_DI_TEMPDIFF_REG di_tempdiff;		/* 0xa8 */
+	SCAL_DI_SAWTOOTH_REG di_sawtooth;		/* 0xac */
+	SCAL_DI_SPATCOMP_REG di_spatcomp;		/* 0xb0 */
+	SCAL_DI_BURSTLEN_REG di_burstlen;		/* 0xb4 */
+	SCAL_DI_PRELUMA_REG di_preluma;			/* 0xb8 */
+	SCAL_DI_BLKFLAG_REG di_blkflag;			/* 0xbc */
+	SCAL_DI_FLAGLINESTRD_REG di_flaglinestrd;	/* 0xc0 */
+	SCAL_RESERVED_REG res0xc4[3];			/* 0xc4-0xcf */
+	SCAL_WB_LINESTRD_EN_REG wb_linestrd_en;		/* 0xd0 */
+	SCAL_WB_LINESTRD0_REG wb_linestrd0;		/* 0xd4 */
+	SCAL_WB_LINESTRD1_REG wb_linestrd1;		/* 0xd8 */
+	SCAL_WB_LINESTRD2_REG wb_linestrd2;		/* 0xdc */
+	SCAL_3D_CTRL_REG trd_ctrl;			/* 0xe0 */
+	SCAL_3D_BUF_ADDR0_REG trd_buf_addr0;		/* 0xe4 */
+	SCAL_3D_BUF_ADDR1_REG trd_buf_addr1;		/* 0xe8 */
+	SCAL_3D_BUF_ADDR2_REG trd_buf_addr2;		/* 0xec */
+	SCAL_3D_MB_OFF0_REG trd_mb_off0;		/* 0xf0 */
+	SCAL_3D_MB_OFF1_REG trd_mb_off1;		/* 0xf4 */
+	SCAL_3D_MB_OFF2_REG trd_mb_off2;		/* 0xf8 */
+	SCAL_RESERVED_REG res0xfc;			/* 0xfc */
+	SCAL_CH0_INSIZE_REG ch0_insize;			/* 0x100 */
+	SCAL_CH0_OUTSIZE_REG ch0_outsize;		/* 0x104 */
+	SCAL_CH0_HORZFACT_REG ch0_horzfact;		/* 0x108 */
+	SCAL_CH0_VERTFACT_REG ch0_vertfact;		/* 0x10c */
+	SCAL_CH0_HORZPHASE_REG ch0_horzphase;		/* 0x110 */
+	SCAL_CH0_VERTPHASE0_REG ch0_vertphase0;		/* 0x114 */
+	SCAL_CH0_VERTPHASE1_REG ch0_vertphase1;		/* 0x118 */
+	SCAL_RESERVED_REG res0x11c;			/* 0x11c */
+	SCAL_CH0_HORZTAP0_REG ch0_horztap0;		/* 0x120 */
+	SCAL_CH0_HORZTAP1_REG ch0_horztap1;		/* 0x124 */
+	SCAL_CH0_VERTTAP_REG ch0_verttap;		/* 0x128 */
+	SCAL_RESERVED_REG res0x12c[53];			/* 0x12c-0x1FF */
+	SCAL_CH1_INSIZE_REG ch1_insize;			/* 0x200 */
+	SCAL_CH1_OUTSIZE_REG ch1_outsize;		/* 0x204 */
+	SCAL_CH1_HORZFACT_REG ch1_horzfact;		/* 0x208 */
+	SCAL_CH1_VERTFACT_REG ch1_vertfact;		/* 0x20c */
+	SCAL_CH1_HORZPHASE_REG ch1_horzphase;		/* 0x210 */
+	SCAL_CH1_VERTPHASE0_REG ch1_vertphase0;		/* 0x214 */
+	SCAL_CH1_VERTPHASE1_REG ch1_vertphase1;		/* 0x218 */
+	SCAL_RESERVED_REG res0x21c;			/* 0x21c */
+	SCAL_CH1_HORZTAP0_REG ch1_horztap0;		/* 0x220 */
+	SCAL_CH1_HORZTAP1_REG ch1_horztap1;		/* 0x224 */
+	SCAL_CH1_VERTTAP_REG ch1_verttap;		/* 0x228 */
+	SCAL_RESERVED_REG res0x22c[117];		/* 0x22c-0x3FF */
+	SCAL_CH0_HORZCOEF0_REGN ch0_horzcoef0[32];	/* 0x400-0x47f */
+	SCAL_CH0_HORZCOEF1_REGN ch0_horzcoef1[32];	/* 0x480-0x4ff */
+	SCAL_CH0_VERTCOEF_REGN ch0_vertcoef[32];	/* 0x500-0x5ff */
+	SCAL_RESERVED_REG res0x580[32];			/* 0x580-0x57f */
+	SCAL_CH1_HORZCOEF0_REGN ch1_horzcoef0[32];	/* 0x600-0x67f */
+	SCAL_CH1_HORZCOEF1_REGN ch1_horzcoef1[32];	/* 0x680-6ff */
+	SCAL_CH1_VERTCOEF_REGN ch1_vertcoef[32];	/* 0x700-0x77f */
+	SCAL_RESERVED_REG res0x780[32];			/* 0x780-0x7ff */
+	SCAL_RESERVED_REG res0x800[128];		/* 0x800-0x9ff */
+	SCAL_VPP_EN_REG vpp_en;				/* 0xA00 */
+	SCAL_VPP_DCTI_REG vpp_dcti;			/* 0xa04 */
+	SCAL_VPP_LP1_REG vpp_lp1;			/* 0xa08 */
+	SCAL_VPP_LP2_REG vpp_lp2;			/* 0xa0c */
+	SCAL_VPP_WLE_REG vpp_wle;			/* 0xa10 */
+	SCAL_VPP_BLE_REG vpp_ble;			/* 0xa14 */
+} __de_scal_dev_t;
+
+#ifndef CONFIG_ARCH_SUN5I
+typedef struct __SCAL_MATRIX4X4 {
+	__s64 x00;
+	__s64 x01;
+	__s64 x02;
+	__s64 x03;
+	__s64 x10;
+	__s64 x11;
+	__s64 x12;
+	__s64 x13;
+	__s64 x20;
+	__s64 x21;
+	__s64 x22;
+	__s64 x23;
+	__s64 x30;
+	__s64 x31;
+	__s64 x32;
+	__s64 x33;
+} __scal_matrix4x4;
+
+extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2,
+				 __scal_matrix4x4 *result);
+extern __s32 iDE_SCAL_Csc_Lmt(__s64 *value, __s32 min, __s32 max, __s32 shift,
+			      __s32 validbit);
+#else
+typedef struct __SCAL_MATRIX4X4 {
+	__s32 x00;
+	__s32 x01;
+	__s32 x02;
+	__s32 x03;
+	__s32 x10;
+	__s32 x11;
+	__s32 x12;
+	__s32 x13;
+	__s32 x20;
+	__s32 x21;
+	__s32 x22;
+	__s32 x23;
+	__s32 x30;
+	__s32 x31;
+	__s32 x32;
+	__s32 x33;
+} __scal_matrix4x4;
+
+extern __s32 iDE_SCAL_Matrix_Mul(__scal_matrix4x4 in1, __scal_matrix4x4 in2,
+				 __scal_matrix4x4 *result);
+extern __s32 iDE_SCAL_Csc_Lmt(__s32 *value, __s32 min, __s32 max, __s32 shift,
+			      __s32 validbit);
+#endif /* not CONFIG_ARCH_SUN5I */
+
+#endif
diff --git a/drivers/video/sunxi/disp/de_hwc.c b/drivers/video/sunxi/disp/de_hwc.c
new file mode 100644
index 0000000..44c94a8
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_hwc.c
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "de_be.h"
+
+__s32 DE_BE_HWC_Enable(__u32 sel, __bool enable)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF);
+	tmp &= (~(1 << 16));
+	DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF, tmp | (enable << 16));
+
+	return 0;
+}
+
+__s32 DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t *pos)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
+	DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF, (tmp & 0xf800f800) |
+		      (pos->y & 0x7ff) << 16 | (pos->x & 0x7ff));
+
+	return 0;
+}
+
+__s32 DE_BE_HWC_Get_Pos(__u32 sel, __disp_pos_t *pos)
+{
+	__u32 readval;
+
+	readval = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
+	pos->y = (readval & 0x07ff0000) >> 16;
+	pos->x = (readval & 0x07ff);
+
+	return 0;
+
+}
+
+__s32 DE_BE_HWC_Set_Palette(__u32 sel, __u32 address, __u32 offset, __u32 size)
+{
+	__u16 i;
+	__u32 read_val;
+	__u32 reg_addr;
+
+	reg_addr = DE_BE_HWC_PALETTE_TABLE_ADDR_OFF + offset;
+
+	for (i = 0; i < size; i = i + 4) {
+		read_val = readl(address + i);
+		DE_BE_WUINT32(sel, reg_addr, read_val);
+		reg_addr = reg_addr + 4;
+	}
+
+	return 0;
+}
+
+__s32 DE_BE_HWC_Set_Src(__u32 sel, __disp_hwc_pattern_t *hwc_pat)
+{
+	__u32 tmp;
+	de_pixels_num_t x_size = 0, y_size = 0;
+	de_inter_fbfmt_e pixel_fmt = 0;
+	__u32 i;
+	__u32 size;
+
+	switch (hwc_pat->pat_mode) {
+	case DISP_HWC_MOD_H32_V32_8BPP:
+		x_size = DE_N32PIXELS;
+		y_size = DE_N32PIXELS;
+		pixel_fmt = DE_IF8BPP;
+		size = 32 * 32;
+		break;
+
+	case DISP_HWC_MOD_H64_V64_2BPP:
+		x_size = DE_N64PIXELS;
+		y_size = DE_N64PIXELS;
+		pixel_fmt = DE_IF2BPP;
+		size = 64 * 64 / 4;
+		break;
+
+	case DISP_HWC_MOD_H64_V32_4BPP:
+		x_size = DE_N64PIXELS;
+		y_size = DE_N32PIXELS;
+		pixel_fmt = DE_IF4BPP;
+		size = 64 * 32 / 2;
+		break;
+
+	case DISP_HWC_MOD_H32_V64_4BPP:
+		x_size = DE_N32PIXELS;
+		y_size = DE_N64PIXELS;
+		pixel_fmt = DE_IF4BPP;
+		size = 32 * 64 / 2;
+		break;
+
+	default:
+		break;
+	}
+
+	if (hwc_pat->addr & 0x3) { /* Address not 32bit aligned */
+		for (i = 0; i < size; i += 4) {
+			__u32 value = 0;
+
+			tmp = readb(hwc_pat->addr + i);
+			value = tmp;
+			tmp = readb(hwc_pat->addr + i + 1);
+			value |= (tmp << 8);
+			tmp = readb(hwc_pat->addr + i + 2);
+			value |= (tmp << 16);
+			tmp = readb(hwc_pat->addr + i + 3);
+			value |= (tmp << 24);
+			DE_BE_WUINT32(sel, DE_BE_HWC_MEMORY_ADDR_OFF + i,
+				      value);
+		}
+	} else {
+		for (i = 0; i < size; i += 4) {
+			tmp = readl(hwc_pat->addr + i);
+			DE_BE_WUINT32(sel, DE_BE_HWC_MEMORY_ADDR_OFF + i, tmp);
+		}
+	}
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
+	DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF, (tmp & 0xffffffc3) |
+		      (x_size << 2) | (y_size << 4)); /* xsize and ysize */
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_HWC_FRMBUF_OFF);
+	DE_BE_WUINT32(sel, DE_BE_HWC_FRMBUF_OFF,
+		      (tmp & 0xfffffffc) | pixel_fmt); /* format */
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_HWC_CRD_CTL_OFF);
+	DE_BE_WUINT32(sel, DE_BE_HWC_CRD_CTL_OFF,
+		      (tmp & 0x07ff07ff) | 0 << 27 | 0 << 11); /* offset */
+	return 0;
+}
diff --git a/drivers/video/sunxi/disp/de_iep.c b/drivers/video/sunxi/disp/de_iep.c
new file mode 100644
index 0000000..e66566f
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_iep.c
@@ -0,0 +1,370 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "de_iep.h"
+
+static __de_iep_dev_t *iep_dev;
+
+#define ____SEPARATOR_IEP____
+
+__s32 DE_IEP_Set_Reg_Base(__u32 sel, __u32 base)
+{
+	if (sel == 0) {
+		iep_dev = (__de_iep_dev_t *) base;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Get_Reg_Base(__u32 sel, __u32 base)
+{
+	__u32 ret = 0;
+	if (sel == 0) {
+		ret = (__u32) iep_dev;
+		return ret;
+	} else {
+		return 0;
+	}
+}
+
+__s32 DE_IEP_Enable(__u32 sel)
+{
+	if (sel == 0) {
+		iep_dev->gnectl.bits.en = 1;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 DE_IEP_Disable(__u32 sel)
+{
+	if (sel == 0) {
+		iep_dev->gnectl.bits.en = 0;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 DE_IEP_Set_Mode(__u32 sel, __u32 mod)
+{
+	if (sel == 0) {
+		iep_dev->gnectl.bits.mod = mod;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 DE_IEP_Bist_Enable(__u32 sel, __u32 en)
+{
+	if (sel == 0) {
+		iep_dev->gnectl.bits.bist_en = en;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 DE_IEP_Set_Reg_Refresh_Edge(__u32 sel, __u32 falling)
+{
+	if (sel == 0) {
+		iep_dev->gnectl.bits.sync_edge = falling;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 DE_IEP_Set_Csc_Coeff(__u32 sel, __u32 mod)
+{
+	if (sel == 0) {
+		if (mod == 2) { /* yuv2rgb for drc mode */
+			/* bt709 full range(to fit output CSC in DEBE ) */
+			iep_dev->cscygcoff[0].bits.csc_yg_coff = 0x4a7;
+			iep_dev->cscygcoff[1].bits.csc_yg_coff = 0x000;
+			iep_dev->cscygcoff[2].bits.csc_yg_coff = 0x72c;
+			iep_dev->cscygcon.bits.csc_yg_con = 0x307d;
+			iep_dev->cscurcoff[0].bits.csc_ur_coff = 0x4a7;
+			iep_dev->cscurcoff[1].bits.csc_ur_coff = 0x1f25;
+			iep_dev->cscurcoff[2].bits.csc_ur_coff = 0x1ddd;
+			iep_dev->cscurcon.bits.csc_ur_con = 0x4cf;
+			iep_dev->cscvbcoff[0].bits.csc_vb_coff = 0x4a7;
+			iep_dev->cscvbcoff[1].bits.csc_vb_coff = 0x875;
+			iep_dev->cscvbcoff[2].bits.csc_vb_coff = 0x000;
+			iep_dev->cscvbcon.bits.csc_vb_con = 0x2dea;
+		} else if (mod == 3) {
+#if 0
+			/* IGB to RGB */
+			iep_dev->cscygcoff[0].bits.csc_yg_coff = 0x0c00;
+			iep_dev->cscygcoff[1].bits.csc_yg_coff = 0x1c00;
+			iep_dev->cscygcoff[2].bits.csc_yg_coff = 0x1c00;
+			iep_dev->cscygcon.bits.csc_yg_con = 0x0000;
+			iep_dev->cscurcoff[0].bits.csc_ur_coff = 0x0000;
+			iep_dev->cscurcoff[1].bits.csc_ur_coff = 0x0400;
+			iep_dev->cscurcoff[2].bits.csc_ur_coff = 0x0000;
+			iep_dev->cscurcon.bits.csc_ur_con = 0x0000;
+			iep_dev->cscvbcoff[0].bits.csc_vb_coff = 0x0000;
+			iep_dev->cscvbcoff[1].bits.csc_vb_coff = 0x0000;
+			iep_dev->cscvbcoff[2].bits.csc_vb_coff = 0x0400;
+			iep_dev->cscvbcon.bits.csc_vb_con = 0x0000;
+#else
+			/* YUV2RGB when Er = 19%, Eg = 65%, Eb = 16%. */
+			iep_dev->cscygcoff[0].bits.csc_yg_coff = 0x0400;
+			iep_dev->cscygcoff[1].bits.csc_yg_coff = 0x0000;
+			iep_dev->cscygcoff[2].bits.csc_yg_coff = 0x067B;
+			iep_dev->cscygcon.bits.csc_yg_con = 0x330A;
+			iep_dev->cscurcoff[0].bits.csc_ur_coff = 0x0400;
+			iep_dev->cscurcoff[1].bits.csc_ur_coff = 0x1E59;
+			iep_dev->cscurcoff[2].bits.csc_ur_coff = 0x1E1B;
+			iep_dev->cscurcon.bits.csc_ur_con = 0x0719;
+			iep_dev->cscvbcoff[0].bits.csc_vb_coff = 0x0400;
+			iep_dev->cscvbcoff[1].bits.csc_vb_coff = 0x06B8;
+			iep_dev->cscvbcoff[2].bits.csc_vb_coff = 0x0000;
+			iep_dev->cscvbcon.bits.csc_vb_con = 0x328F;
+
+#endif
+		} else { /* yuv2yuv       for de-flicker mode */
+			iep_dev->cscygcoff[0].bits.csc_yg_coff = 0x400;
+			iep_dev->cscygcoff[1].bits.csc_yg_coff = 0x000;
+			iep_dev->cscygcoff[2].bits.csc_yg_coff = 0x000;
+			iep_dev->cscygcon.bits.csc_yg_con = 0x000;
+			iep_dev->cscurcoff[0].bits.csc_ur_coff = 0x000;
+			iep_dev->cscurcoff[1].bits.csc_ur_coff = 0x400;
+			iep_dev->cscurcoff[2].bits.csc_ur_coff = 0x000;
+			iep_dev->cscurcon.bits.csc_ur_con = 0x000;
+			iep_dev->cscvbcoff[0].bits.csc_vb_coff = 0x000;
+			iep_dev->cscvbcoff[1].bits.csc_vb_coff = 0x000;
+			iep_dev->cscvbcoff[2].bits.csc_vb_coff = 0x400;
+			iep_dev->cscvbcon.bits.csc_vb_con = 0x000;
+		}
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 DE_IEP_Set_Display_Size(__u32 sel, __u32 width, __u32 height)
+{
+	if (sel == 0) {
+		iep_dev->drcsize.bits.disp_w = width - 1;
+		iep_dev->drcsize.bits.disp_h = height - 1;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 DE_IEP_Demo_Win_Enable(__u32 sel, __u32 en)
+{
+	if (sel == 0) {
+		iep_dev->drcctl.bits.win_en = en;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Set_Demo_Win_Para(__u32 sel, __u32 top, __u32 bot, __u32 left,
+			       __u32 right)
+{
+	if (sel == 0) {
+		iep_dev->drc_wp0.bits.win_left = left;
+		iep_dev->drc_wp0.bits.win_top = top;
+		iep_dev->drc_wp1.bits.win_right = right;
+		iep_dev->drc_wp1.bits.win_bottom = bot;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+#define ____SEPARATOR_DRC____
+
+__s32 DE_IEP_Drc_Cfg_Rdy(__u32 sel)
+{
+	if (sel == 0) {
+		iep_dev->drcctl.bits.dbrdy_ctl = 1;
+		iep_dev->drcctl.bits.db_en = 1;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Drc_Set_Lgc_Addr(__u32 sel, __u32 addr)
+{
+	if (sel == 0) {
+		iep_dev->drclgc_addr.bits.lgc_addr = addr;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Drc_Set_Lgc_Autoload_Disable(__u32 sel, __u32 disable)
+{
+	if (sel == 0) {
+		iep_dev->drc_set.bits.gain_autoload_dis = disable;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Drc_Adjust_Enable(__u32 sel, __u32 en)
+{
+	if (sel == 0) {
+		iep_dev->drc_set.bits.adjust_en = en;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Drc_Set_Adjust_Para(__u32 sel, __u32 abslumperval, __u32 abslumshf)
+{
+	if (sel == 0) {
+		iep_dev->drc_set.bits.lgc_abslumshf = abslumshf;
+		iep_dev->drc_set.bits.lgc_abslumperval = abslumperval;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Drc_Set_Spa_Coeff(__u32 sel, __u8 spatab[IEP_DRC_SPA_TAB_LEN])
+{
+	if (sel == 0) {
+		iep_dev->drcspacoff[0].bits.spa_coff0 = spatab[0];
+		iep_dev->drcspacoff[0].bits.spa_coff1 = spatab[1];
+		iep_dev->drcspacoff[0].bits.spa_coff2 = spatab[2];
+		iep_dev->drcspacoff[1].bits.spa_coff0 = spatab[3];
+		iep_dev->drcspacoff[1].bits.spa_coff1 = spatab[4];
+		iep_dev->drcspacoff[1].bits.spa_coff2 = spatab[5];
+		iep_dev->drcspacoff[2].bits.spa_coff0 = spatab[6];
+		iep_dev->drcspacoff[2].bits.spa_coff1 = spatab[7];
+		iep_dev->drcspacoff[2].bits.spa_coff2 = spatab[8];
+
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Drc_Set_Int_Coeff(__u32 sel, __u8 inttab[IEP_DRC_INT_TAB_LEN])
+{
+	__u32 i;
+
+	if (sel == 0) {
+		for (i = 0; i < IEP_DRC_INT_TAB_LEN / 4; i++) {
+			iep_dev->drcintcoff[i].bits.inten_coff0 = inttab[4 * i];
+			iep_dev->drcintcoff[i].bits.inten_coff1 =
+			    inttab[4 * i + 1];
+			iep_dev->drcintcoff[i].bits.inten_coff2 =
+			    inttab[4 * i + 2];
+			iep_dev->drcintcoff[i].bits.inten_coff3 =
+			    inttab[4 * i + 3];
+		}
+
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+#if 0
+__u32 DE_IEP_Drc_Set_Lgc_Coeff(__u32 sel, __u16 lgctab[IEP_DRC_INT_TAB_LEN])
+{
+	__u32 i;
+
+	if (sel == 0)
+		return 0;
+	else
+		return -1;
+}
+#endif
+
+#define ____SEPARATOR_LH____
+
+__u32 DE_IEP_Lh_Set_Mode(__u32 sel, __u32 mod)
+{
+	if (sel == 0) {
+		/* 0:current frame case; 1:average case */
+		iep_dev->lhctl.bits.lh_mod = mod;
+		return 0;
+	} else {
+		return -1;
+	}
+
+}
+
+__u32 DE_IEP_Lh_Clr_Rec(__u32 sel)
+{
+	if (sel == 0) {
+		iep_dev->lhctl.bits.lh_rec_clr = 1;
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Lh_Set_Thres(__u32 sel, __u8 thres[])
+{
+	if (sel == 0) {
+		iep_dev->lhthr0.bits.lh_thres_val1 = thres[0];
+		iep_dev->lhthr0.bits.lh_thres_val2 = thres[1];
+		iep_dev->lhthr0.bits.lh_thres_val3 = thres[2];
+		iep_dev->lhthr0.bits.lh_thres_val4 = thres[3];
+		iep_dev->lhthr1.bits.lh_thres_val5 = thres[4];
+		iep_dev->lhthr1.bits.lh_thres_val6 = thres[5];
+		iep_dev->lhthr1.bits.lh_thres_val7 = thres[6];
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__u32 DE_IEP_Lh_Get_Sum_Rec(__u32 sel, __u32 *sum)
+{
+	__u32 i;
+
+	if (sel == 0) {
+		for (i = 0; i < IEP_LH_INTERVAL_NUM; i++)
+			*sum++ = iep_dev->lhslum[i].bits.lh_lum_data;
+		return 0;
+	}
+
+	return -1;
+}
+
+__u32 DE_IEP_Lh_Get_Cnt_Rec(__u32 sel, __u32 *cnt)
+{
+	__u32 i;
+
+	if (sel == 0)
+		for (i = 0; i < IEP_LH_INTERVAL_NUM; i++)
+			*cnt++ = iep_dev->lhscnt[i].bits.lh_cnt_data;
+
+	return 0;
+}
+
+#define ____SEPARATOR_DF____
diff --git a/drivers/video/sunxi/disp/de_iep.h b/drivers/video/sunxi/disp/de_iep.h
new file mode 100644
index 0000000..527fb91
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_iep.h
@@ -0,0 +1,334 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ *  Display engine Image Enhancement Processor registers and interface
+ * functions define for aw1625
+ */
+
+#ifndef __DE_IEP_H__
+#define __DE_IEP_H__
+
+#include "bsp_display.h"
+
+#define IEP_DRC_SPA_TAB_LEN	9
+#define IEP_DRC_INT_TAB_LEN 256
+#define IEP_DRC_LGC_TAB_LEN 256
+#define IEP_LH_INTERVAL_NUM 8
+#define IEP_LH_THRES_NUM    7
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 en:1;	/* bit0 */
+		__u32 r0:7;	/* bit1~7 */
+		__u32 mod:2;	/* bit8~9 */
+		__u32 r1:6;	/* bit10~15 */
+		__u32 sync_edge:1;	/* bit16 */
+		__u32 field_parity:1;	/* bit17 */
+		__u32 r2:13;	/* bit18~30 */
+		__u32 bist_en:1;	/* bit31 */
+	} bits;
+} __imgehc_gnectl_reg_t;	/* 0x0 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 disp_w:12;	/* bit0~11 */
+		__u32 r0:4;	/* bit12~15 */
+		__u32 disp_h:12;	/* bit16~27 */
+		__u32 r1:4;	/* bit31~28 */
+	} bits;
+} __imgehc_drcsize_reg_t;
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 db_en:1;	/* bit0 */
+		__u32 dbrdy_ctl:1;	/* bit1 */
+		__u32 r0:6;	/* bit2~7 */
+		__u32 win_en:1;	/* bit8 */
+		__u32 r1:23;	/* bit9~31 */
+	} bits;
+} __imgehc_drcctl_reg_t;	/* 0x10 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 lgc_addr:32;	/* bit0~31 */
+	} bits;
+} __imgehc_drclgc_staadd_reg_t;	/* 0x14 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 lgc_abslumshf:1;	/* bit0 */
+		__u32 adjust_en:1;	/* bit1 */
+		__u32 r0:6;	/* bit2~7 */
+		__u32 lgc_abslumperval:8;	/* bit8~15 */
+		__u32 r1:8;	/* bit16~23 */
+		__u32 gain_autoload_dis:1;	/* bit24 */
+		__u32 r2:7;	/* bit25~31 */
+	} bits;
+} __imgehc_drc_set_reg_t;	/* 0x18 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 win_left:12;	/* bit0~11 */
+		__u32 r0:4;	/* bit12~15 */
+		__u32 win_top:12;	/* bit16~27 */
+		__u32 r1:4;	/* bit28~31 */
+	} bits;
+} __imgehc_drc_wp_reg0_t;	/* 0x1c */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 win_right:12;	/* bit0~11 */
+		__u32 r0:4;	/* bit12~15 */
+		__u32 win_bottom:12;	/* bit16~27 */
+		__u32 r1:4;	/* bit28~31 */
+	} bits;
+} __imgehc_drc_wp_reg1_t;	/* 0x20 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 wb_en:1;	/* bit0 */
+		__u32 r0:7;	/* bit1~7 */
+		__u32 wb_mode:1;	/* bit8 */
+		__u32 r1:7;	/* bit9~15 */
+		__u32 wb_ps:1;	/* bit16 */
+		__u32 r2:7;	/* bit17~23 */
+		__u32 field:1;	/* bit24 */
+		__u32 r3:6;	/* bit25~30 */
+		__u32 wb_sts:1;	/* bit31 */
+	} bits;
+} __imgehc_wbctl_reg_t;		/* 0x24 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 wb_addr:32;
+	} bits;
+} __imgehc_wbaddr_reg_t;	/* 0x28 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 linestride:32;
+	} bits;
+} __imgehc_wbline_reg_t;	/* 0x2c */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 lh_rec_clr:1;	/* bit0 */
+		__u32 lh_mod:1;	/* bit1 */
+		__u32 r0:30;	/* bit2~31 */
+	} bits;
+} __imgehc_lhctl_reg_t;		/* 0x30 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 lh_thres_val1:8;	/* bit0~7 */
+		__u32 lh_thres_val2:8;	/* bit8~15 */
+		__u32 lh_thres_val3:8;	/* bit16~23 */
+		__u32 lh_thres_val4:8;	/* bit24~31 */
+	} bits;
+} __imgehc_lhthr_reg0_t;	/* 0x34 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 lh_thres_val5:8;	/* bit0~7 */
+		__u32 lh_thres_val6:8;	/* bit8~15 */
+		__u32 lh_thres_val7:8;	/* bit16~23 */
+		__u32 r0:8;	/* bit24~31 */
+	} bits;
+} __imgehc_lhthr_reg1_t;	/* 0x38 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 lh_lum_data:32;	/* bit0~31 */
+	} bits;
+} __imgehc_lhslum_reg_t;	/*  0x0040 ~ 0x005c */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 lh_cnt_data:32;	/* bit0~31 */
+	} bits;
+} __imgehc_lhscnt_reg_t;	/* 0x0060 ~ 0x007c */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 df_en:1;	/* bit0 */
+		__u32 r0:7;	/* bit1~7 */
+		__u32 df_y_bypass:1;	/* bit8 */
+		__u32 df_u_bypass:1;	/* bit9 */
+		__u32 df_v_bypass:1;	/* bit10 */
+		__u32 r1:21;	/* bit11~31 */
+	} bits;
+} __imgehc_dfctl_reg_t;		/* 0x0080 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 csc_yg_coff:13;	/* bit0~12 */
+		__u32 r0:19;	/* bit13~31 */
+	} bits;
+} __imgehc_cscygcoff_reg_t;	/* 0xc0~0xc8 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 csc_yg_con:14;	/* bit0~13 */
+		__u32 r0:18;	/* bit14~31 */
+	} bits;
+} __imgehc_cscygcon_reg_t;	/* 0xcc */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 csc_ur_coff:13;	/* bit0~12 */
+		__u32 r0:19;	/* bit13~31 */
+	} bits;
+} __imgehc_cscurcoff_reg_t;	/* 0xd0~0xd8 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 csc_ur_con:14;	/* bit0~13 */
+		__u32 r0:18;	/* bit14~31 */
+	} bits;
+} __imgehc_cscurcon_reg_t;	/* 0xdc */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 csc_vb_coff:13;	/* bit0~12 */
+		__u32 r0:19;	/* bit13~31 */
+	} bits;
+} __imgehc_cscvbcoff_reg_t;	/* 0xe0~0xe8 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 csc_vb_con:14;	/* bit0~13 */
+		__u32 r0:18;	/* bit14~31 */
+	} bits;
+} __imgehc_cscvbcon_reg_t;	/* 0xec */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 spa_coff0:8;	/* bit0~7 */
+		__u32 spa_coff1:8;	/* bit8~15 */
+		__u32 spa_coff2:8;	/* bit16~23 */
+		__u32 r0:8;	/* bit24~31 */
+	} bits;
+} __imgehc_drcspacoff_reg_t;	/* 0xf0~0xf8 */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 inten_coff0:8;	/* bit0~7 */
+		__u32 inten_coff1:8;	/* bit8~15 */
+		__u32 inten_coff2:8;	/* bit16~23 */
+		__u32 inten_coff3:8;	/* bit24~31 */
+	} bits;
+} __imgehc_drcintcoff_reg_t;	/* 0x0100 ~ 0x01fc */
+
+typedef union {
+	__u32 dwval;
+	struct {
+		__u32 lumagain_coff0:16;	/* bit0~15 */
+		__u32 lumagain_coff1:16;	/* bit16~31 */
+	} bits;
+} __imgehc_drclgcoff_reg_t;	/* 0x0200 ~ 0x03fc */
+
+typedef struct {
+	__imgehc_gnectl_reg_t gnectl;	/* 0x00 */
+	__imgehc_drcsize_reg_t drcsize;	/* 0x04 */
+	__u32 r0[2];		/* 0x08~0x0c */
+	__imgehc_drcctl_reg_t drcctl;	/* 0x10 */
+	__imgehc_drclgc_staadd_reg_t drclgc_addr;	/* 0x14 */
+	__imgehc_drc_set_reg_t drc_set;	/* 0x18 */
+	__imgehc_drc_wp_reg0_t drc_wp0;	/* 0x1c */
+	__imgehc_drc_wp_reg1_t drc_wp1;	/* 0x20 */
+	__imgehc_wbctl_reg_t wbctl;	/* 0x24 */
+	__imgehc_wbaddr_reg_t wbaddr;	/* 0x28 */
+	__imgehc_wbline_reg_t wbline;	/* 0x2c */
+	__imgehc_lhctl_reg_t lhctl;	/* 0x30 */
+	__imgehc_lhthr_reg0_t lhthr0;	/* 0x34 */
+	__imgehc_lhthr_reg1_t lhthr1;	/* 0x38 */
+	__u32 r2;		/* 0x3c */
+	__imgehc_lhslum_reg_t lhslum[8];	/* 0x40~0x5c */
+	__imgehc_lhscnt_reg_t lhscnt[8];	/* 0x0060 ~ 0x007c */
+	__imgehc_dfctl_reg_t dfctl;	/* 0x80 */
+	__u32 r3[15];		/* 0x84~0xbc */
+	__imgehc_cscygcoff_reg_t cscygcoff[3];	/* 0xc0~0xc8 */
+	__imgehc_cscygcon_reg_t cscygcon;	/* 0xcc */
+	__imgehc_cscurcoff_reg_t cscurcoff[3];	/* 0xd0~0xd8 */
+	__imgehc_cscurcon_reg_t cscurcon;	/* 0xdc */
+	__imgehc_cscvbcoff_reg_t cscvbcoff[3];	/* 0xe0~0xe8 */
+	__imgehc_cscvbcon_reg_t cscvbcon;	/* 0xec */
+	__imgehc_drcspacoff_reg_t drcspacoff[3];	/* 0xf0~0xf8 */
+	__u32 r4;		/* 0xff */
+	__imgehc_drcintcoff_reg_t drcintcoff[64];	/* 0x0100 ~ 0x01fc */
+	__imgehc_drclgcoff_reg_t drclgcoff[128];	/* 0x0200 ~ 0x03fc */
+} __de_iep_dev_t;
+
+#define ____SEPARATOR_IEP____
+
+__s32 DE_IEP_Set_Reg_Base(__u32 sel, __u32 base);
+__u32 DE_IEP_Get_Reg_Base(__u32 sel, __u32 base);
+__s32 DE_IEP_Enable(__u32 sel);
+__s32 DE_IEP_Disable(__u32 sel);
+__s32 DE_IEP_Set_Mode(__u32 sel, __u32 mod);
+__s32 DE_IEP_Bist_Enable(__u32 sel, __u32 en);
+__s32 DE_IEP_Set_Reg_Refresh_Edge(__u32 sel, __u32 falling);
+__s32 DE_IEP_Set_Csc_Coeff(__u32 sel, __u32 mod);
+__s32 DE_IEP_Set_Display_Size(__u32 sel, __u32 width, __u32 height);
+__s32 DE_IEP_Demo_Win_Enable(__u32 sel, __u32 en);
+__u32 DE_IEP_Set_Demo_Win_Para(__u32 sel, __u32 top, __u32 bot, __u32 left,
+			       __u32 right);
+#define ____SEPARATOR_DRC____
+__s32 DE_IEP_Drc_Cfg_Rdy(__u32 sel);
+__u32 DE_IEP_Drc_Set_Lgc_Addr(__u32 sel, __u32 addr);
+__u32 DE_IEP_Drc_Set_Lgc_Autoload_Disable(__u32 sel, __u32 disable);
+__u32 DE_IEP_Drc_Adjust_Enable(__u32 sel, __u32 en);
+__u32 DE_IEP_Drc_Set_Adjust_Para(__u32 sel, __u32 abslumperval,
+				 __u32 abslumshf);
+__u32 DE_IEP_Drc_Set_Spa_Coeff(__u32 sel, __u8 spatab[IEP_DRC_SPA_TAB_LEN]);
+__u32 DE_IEP_Drc_Set_Int_Coeff(__u32 sel, __u8 inttab[IEP_DRC_INT_TAB_LEN]);
+//__u32 DE_IEP_Drc_Set_Lgc_Coeff(__u32 sel,  __u16 lgctab[IEP_DRC_INT_TAB_LEN]);
+#define ____SEPARATOR_LH____
+__u32 DE_IEP_Lh_Set_Mode(__u32 sel, __u32 mod);
+__u32 DE_IEP_Lh_Clr_Rec(__u32 sel);
+__u32 DE_IEP_Lh_Set_Thres(__u32 sel, __u8 thres[IEP_LH_THRES_NUM]);
+__u32 DE_IEP_Lh_Get_Sum_Rec(__u32 sel, __u32 *sum);
+__u32 DE_IEP_Lh_Get_Cnt_Rec(__u32 sel, __u32 *cnt);
+#define ____SEPARATOR_DF____
+#endif
diff --git a/drivers/video/sunxi/disp/de_iep_tab.h b/drivers/video/sunxi/disp/de_iep_tab.h
new file mode 100644
index 0000000..2a2c5c4
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_iep_tab.h
@@ -0,0 +1,3011 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+static __u16 pwrsv_lgc_tab[128][256] = {
+	/* tab index : 128 */
+	{2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896,
+	 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2896, 2889, 2882, 2875,
+	 2868, 2861, 2854, 2847, 2840, 2833, 2826, 2819, 2812, 2805, 2798, 2791,
+	 2784, 2777, 2770, 2763, 2756, 2749, 2742, 2736, 2729, 2722, 2715, 2708,
+	 2701, 2694, 2688, 2681, 2674, 2667, 2660, 2654, 2647, 2640, 2633, 2627,
+	 2620, 2613, 2606, 2600, 2593, 2586, 2579, 2573, 2566, 2559, 2553, 2546,
+	 2539, 2533, 2526, 2519, 2513, 2506, 2499, 2493, 2486, 2479, 2473, 2466,
+	 2459, 2453, 2446, 2440, 2433, 2426, 2420, 2413, 2406, 2400, 2393, 2387,
+	 2380, 2374, 2367, 2360, 2354, 2347, 2341, 2334, 2328, 2321, 2314, 2308,
+	 2301, 2295, 2288, 2282, 2275, 2269, 2262, 2256, 2249, 2243, 2236, 2230,
+	 2223, 2217, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2165, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 129 */
+	{2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885,
+	 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2885, 2878, 2871,
+	 2864, 2857, 2850, 2843, 2836, 2829, 2822, 2816, 2809, 2802, 2795, 2788,
+	 2781, 2774, 2767, 2761, 2754, 2747, 2740, 2733, 2726, 2720, 2713, 2706,
+	 2699, 2693, 2686, 2679, 2672, 2665, 2659, 2652, 2645, 2639, 2632, 2625,
+	 2618, 2612, 2605, 2598, 2592, 2585, 2578, 2572, 2565, 2558, 2552, 2545,
+	 2538, 2532, 2525, 2518, 2512, 2505, 2498, 2492, 2485, 2479, 2472, 2465,
+	 2459, 2452, 2446, 2439, 2432, 2426, 2419, 2413, 2406, 2399, 2393, 2386,
+	 2380, 2373, 2367, 2360, 2354, 2347, 2340, 2334, 2327, 2321, 2314, 2308,
+	 2301, 2295, 2288, 2282, 2275, 2269, 2262, 2256, 2249, 2242, 2236, 2229,
+	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2165, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 130 */
+	{2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874,
+	 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2874, 2867,
+	 2860, 2853, 2846, 2840, 2833, 2826, 2819, 2812, 2805, 2799, 2792, 2785,
+	 2778, 2771, 2765, 2758, 2751, 2744, 2738, 2731, 2724, 2717, 2711, 2704,
+	 2697, 2690, 2684, 2677, 2670, 2664, 2657, 2650, 2644, 2637, 2630, 2624,
+	 2617, 2610, 2604, 2597, 2590, 2584, 2577, 2570, 2564, 2557, 2551, 2544,
+	 2537, 2531, 2524, 2517, 2511, 2504, 2498, 2491, 2485, 2478, 2471, 2465,
+	 2458, 2452, 2445, 2438, 2432, 2425, 2419, 2412, 2406, 2399, 2393, 2386,
+	 2379, 2373, 2366, 2360, 2353, 2347, 2340, 2334, 2327, 2321, 2314, 2308,
+	 2301, 2295, 2288, 2281, 2275, 2268, 2262, 2255, 2249, 2242, 2236, 2229,
+	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 131 */
+	{2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863, 2863,
+	 2856, 2849, 2843, 2836, 2829, 2822, 2816, 2809, 2802, 2795, 2789, 2782,
+	 2775, 2769, 2762, 2755, 2748, 2742, 2735, 2728, 2722, 2715, 2708, 2702,
+	 2695, 2688, 2682, 2675, 2668, 2662, 2655, 2649, 2642, 2635, 2629, 2622,
+	 2615, 2609, 2602, 2596, 2589, 2582, 2576, 2569, 2563, 2556, 2549, 2543,
+	 2536, 2530, 2523, 2517, 2510, 2503, 2497, 2490, 2484, 2477, 2471, 2464,
+	 2458, 2451, 2444, 2438, 2431, 2425, 2418, 2412, 2405, 2399, 2392, 2386,
+	 2379, 2373, 2366, 2360, 2353, 2346, 2340, 2333, 2327, 2320, 2314, 2307,
+	 2301, 2294, 2288, 2281, 2275, 2268, 2262, 2255, 2249, 2242, 2236, 2229,
+	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 132 */
+	{2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852, 2852,
+	 2852, 2845, 2839, 2832, 2825, 2819, 2812, 2805, 2799, 2792, 2786, 2779,
+	 2772, 2766, 2759, 2752, 2746, 2739, 2733, 2726, 2719, 2713, 2706, 2700,
+	 2693, 2686, 2680, 2673, 2667, 2660, 2653, 2647, 2640, 2634, 2627, 2621,
+	 2614, 2607, 2601, 2594, 2588, 2581, 2575, 2568, 2562, 2555, 2548, 2542,
+	 2535, 2529, 2522, 2516, 2509, 2503, 2496, 2490, 2483, 2477, 2470, 2463,
+	 2457, 2450, 2444, 2437, 2431, 2424, 2418, 2411, 2405, 2398, 2392, 2385,
+	 2379, 2372, 2366, 2359, 2353, 2346, 2340, 2333, 2327, 2320, 2314, 2307,
+	 2301, 2294, 2288, 2281, 2275, 2268, 2262, 2255, 2249, 2242, 2236, 2229,
+	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 133 */
+	{2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841, 2841,
+	 2841, 2841, 2835, 2828, 2822, 2815, 2809, 2802, 2795, 2789, 2782, 2776,
+	 2769, 2763, 2756, 2750, 2743, 2736, 2730, 2723, 2717, 2710, 2704, 2697,
+	 2691, 2684, 2678, 2671, 2665, 2658, 2652, 2645, 2639, 2632, 2625, 2619,
+	 2612, 2606, 2599, 2593, 2586, 2580, 2573, 2567, 2560, 2554, 2547, 2541,
+	 2534, 2528, 2521, 2515, 2508, 2502, 2495, 2489, 2482, 2476, 2469, 2463,
+	 2456, 2450, 2443, 2437, 2430, 2424, 2417, 2411, 2404, 2398, 2391, 2385,
+	 2378, 2372, 2365, 2359, 2352, 2346, 2339, 2333, 2326, 2320, 2313, 2307,
+	 2301, 2294, 2288, 2281, 2275, 2268, 2262, 2255, 2249, 2242, 2236, 2229,
+	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 134 */
+	{2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831, 2831,
+	 2831, 2831, 2831, 2824, 2818, 2811, 2805, 2798, 2792, 2785, 2779, 2773,
+	 2766, 2760, 2753, 2747, 2740, 2734, 2727, 2721, 2714, 2708, 2701, 2695,
+	 2688, 2682, 2676, 2669, 2663, 2656, 2650, 2643, 2637, 2630, 2624, 2617,
+	 2611, 2604, 2598, 2591, 2585, 2579, 2572, 2566, 2559, 2553, 2546, 2540,
+	 2533, 2527, 2520, 2514, 2507, 2501, 2494, 2488, 2481, 2475, 2469, 2462,
+	 2456, 2449, 2443, 2436, 2430, 2423, 2417, 2410, 2404, 2397, 2391, 2384,
+	 2378, 2371, 2365, 2359, 2352, 2346, 2339, 2333, 2326, 2320, 2313, 2307,
+	 2300, 2294, 2287, 2281, 2274, 2268, 2262, 2255, 2249, 2242, 2236, 2229,
+	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 135 */
+	{2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820, 2820,
+	 2820, 2820, 2820, 2820, 2814, 2807, 2801, 2795, 2788, 2782, 2776, 2769,
+	 2763, 2756, 2750, 2744, 2737, 2731, 2725, 2718, 2712, 2705, 2699, 2693,
+	 2686, 2680, 2673, 2667, 2661, 2654, 2648, 2641, 2635, 2628, 2622, 2616,
+	 2609, 2603, 2596, 2590, 2584, 2577, 2571, 2564, 2558, 2551, 2545, 2539,
+	 2532, 2526, 2519, 2513, 2506, 2500, 2494, 2487, 2481, 2474, 2468, 2461,
+	 2455, 2448, 2442, 2436, 2429, 2423, 2416, 2410, 2403, 2397, 2390, 2384,
+	 2378, 2371, 2365, 2358, 2352, 2345, 2339, 2332, 2326, 2320, 2313, 2307,
+	 2300, 2294, 2287, 2281, 2274, 2268, 2261, 2255, 2248, 2242, 2236, 2229,
+	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 136 */
+	{2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810, 2810,
+	 2810, 2810, 2810, 2810, 2810, 2804, 2797, 2791, 2785, 2778, 2772, 2766,
+	 2760, 2753, 2747, 2741, 2734, 2728, 2722, 2715, 2709, 2703, 2696, 2690,
+	 2684, 2677, 2671, 2665, 2658, 2652, 2646, 2639, 2633, 2627, 2620, 2614,
+	 2608, 2601, 2595, 2588, 2582, 2576, 2569, 2563, 2557, 2550, 2544, 2537,
+	 2531, 2525, 2518, 2512, 2505, 2499, 2493, 2486, 2480, 2473, 2467, 2461,
+	 2454, 2448, 2441, 2435, 2429, 2422, 2416, 2409, 2403, 2396, 2390, 2384,
+	 2377, 2371, 2364, 2358, 2351, 2345, 2339, 2332, 2326, 2319, 2313, 2306,
+	 2300, 2294, 2287, 2281, 2274, 2268, 2261, 2255, 2248, 2242, 2235, 2229,
+	 2223, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 137 */
+	{2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800, 2800,
+	 2800, 2800, 2800, 2800, 2800, 2800, 2793, 2787, 2781, 2775, 2769, 2762,
+	 2756, 2750, 2744, 2738, 2731, 2725, 2719, 2713, 2706, 2700, 2694, 2688,
+	 2681, 2675, 2669, 2663, 2656, 2650, 2644, 2637, 2631, 2625, 2618, 2612,
+	 2606, 2600, 2593, 2587, 2581, 2574, 2568, 2562, 2555, 2549, 2543, 2536,
+	 2530, 2524, 2517, 2511, 2504, 2498, 2492, 2485, 2479, 2473, 2466, 2460,
+	 2453, 2447, 2441, 2434, 2428, 2422, 2415, 2409, 2402, 2396, 2390, 2383,
+	 2377, 2370, 2364, 2358, 2351, 2345, 2338, 2332, 2325, 2319, 2313, 2306,
+	 2300, 2293, 2287, 2280, 2274, 2268, 2261, 2255, 2248, 2242, 2235, 2229,
+	 2222, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 138 */
+	{2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2789,
+	 2789, 2789, 2789, 2789, 2789, 2789, 2789, 2783, 2777, 2771, 2765, 2759,
+	 2753, 2747, 2741, 2734, 2728, 2722, 2716, 2710, 2704, 2697, 2691, 2685,
+	 2679, 2673, 2666, 2660, 2654, 2648, 2642, 2635, 2629, 2623, 2617, 2610,
+	 2604, 2598, 2592, 2585, 2579, 2573, 2567, 2560, 2554, 2548, 2541, 2535,
+	 2529, 2522, 2516, 2510, 2503, 2497, 2491, 2484, 2478, 2472, 2465, 2459,
+	 2453, 2446, 2440, 2434, 2427, 2421, 2415, 2408, 2402, 2395, 2389, 2383,
+	 2376, 2370, 2364, 2357, 2351, 2344, 2338, 2332, 2325, 2319, 2312, 2306,
+	 2300, 2293, 2287, 2280, 2274, 2267, 2261, 2255, 2248, 2242, 2235, 2229,
+	 2222, 2216, 2210, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2152,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 139 */
+	{2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779,
+	 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2779, 2773, 2767, 2761, 2755,
+	 2749, 2743, 2737, 2731, 2725, 2719, 2713, 2707, 2701, 2695, 2689, 2682,
+	 2676, 2670, 2664, 2658, 2652, 2646, 2639, 2633, 2627, 2621, 2615, 2609,
+	 2602, 2596, 2590, 2584, 2578, 2571, 2565, 2559, 2553, 2546, 2540, 2534,
+	 2528, 2521, 2515, 2509, 2502, 2496, 2490, 2484, 2477, 2471, 2465, 2458,
+	 2452, 2446, 2439, 2433, 2427, 2420, 2414, 2408, 2401, 2395, 2389, 2382,
+	 2376, 2370, 2363, 2357, 2350, 2344, 2338, 2331, 2325, 2319, 2312, 2306,
+	 2299, 2293, 2287, 2280, 2274, 2267, 2261, 2254, 2248, 2242, 2235, 2229,
+	 2222, 2216, 2209, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 140 */
+	{2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769,
+	 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2769, 2764, 2758, 2752,
+	 2746, 2740, 2734, 2728, 2722, 2716, 2710, 2704, 2698, 2692, 2686, 2680,
+	 2674, 2668, 2662, 2656, 2650, 2643, 2637, 2631, 2625, 2619, 2613, 2607,
+	 2601, 2594, 2588, 2582, 2576, 2570, 2564, 2557, 2551, 2545, 2539, 2533,
+	 2526, 2520, 2514, 2508, 2501, 2495, 2489, 2483, 2476, 2470, 2464, 2457,
+	 2451, 2445, 2439, 2432, 2426, 2420, 2413, 2407, 2401, 2394, 2388, 2382,
+	 2375, 2369, 2363, 2356, 2350, 2344, 2337, 2331, 2325, 2318, 2312, 2305,
+	 2299, 2293, 2286, 2280, 2274, 2267, 2261, 2254, 2248, 2242, 2235, 2229,
+	 2222, 2216, 2209, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 141 */
+	{2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760,
+	 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2760, 2754, 2748,
+	 2742, 2736, 2730, 2725, 2719, 2713, 2707, 2701, 2695, 2689, 2683, 2677,
+	 2671, 2665, 2659, 2653, 2647, 2641, 2635, 2629, 2623, 2617, 2611, 2605,
+	 2599, 2593, 2587, 2580, 2574, 2568, 2562, 2556, 2550, 2544, 2537, 2531,
+	 2525, 2519, 2513, 2506, 2500, 2494, 2488, 2482, 2475, 2469, 2463, 2457,
+	 2450, 2444, 2438, 2432, 2425, 2419, 2413, 2406, 2400, 2394, 2388, 2381,
+	 2375, 2369, 2362, 2356, 2350, 2343, 2337, 2331, 2324, 2318, 2312, 2305,
+	 2299, 2292, 2286, 2280, 2273, 2267, 2261, 2254, 2248, 2241, 2235, 2229,
+	 2222, 2216, 2209, 2203, 2197, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 142 */
+	{2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750,
+	 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2744,
+	 2738, 2733, 2727, 2721, 2715, 2709, 2704, 2698, 2692, 2686, 2680, 2674,
+	 2668, 2663, 2657, 2651, 2645, 2639, 2633, 2627, 2621, 2615, 2609, 2603,
+	 2597, 2591, 2585, 2579, 2573, 2567, 2560, 2554, 2548, 2542, 2536, 2530,
+	 2524, 2518, 2511, 2505, 2499, 2493, 2487, 2481, 2474, 2468, 2462, 2456,
+	 2450, 2443, 2437, 2431, 2425, 2418, 2412, 2406, 2400, 2393, 2387, 2381,
+	 2375, 2368, 2362, 2356, 2349, 2343, 2337, 2330, 2324, 2318, 2311, 2305,
+	 2299, 2292, 2286, 2280, 2273, 2267, 2260, 2254, 2248, 2241, 2235, 2229,
+	 2222, 2216, 2209, 2203, 2196, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 143 */
+	{2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740, 2740,
+	 2735, 2729, 2723, 2718, 2712, 2706, 2700, 2695, 2689, 2683, 2677, 2672,
+	 2666, 2660, 2654, 2648, 2642, 2636, 2630, 2625, 2619, 2613, 2607, 2601,
+	 2595, 2589, 2583, 2577, 2571, 2565, 2559, 2553, 2547, 2541, 2535, 2529,
+	 2522, 2516, 2510, 2504, 2498, 2492, 2486, 2480, 2473, 2467, 2461, 2455,
+	 2449, 2443, 2436, 2430, 2424, 2418, 2412, 2405, 2399, 2393, 2387, 2380,
+	 2374, 2368, 2361, 2355, 2349, 2343, 2336, 2330, 2324, 2317, 2311, 2305,
+	 2298, 2292, 2286, 2279, 2273, 2267, 2260, 2254, 2248, 2241, 2235, 2228,
+	 2222, 2216, 2209, 2203, 2196, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 144 */
+	{2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731, 2731,
+	 2731, 2725, 2720, 2714, 2708, 2703, 2697, 2691, 2686, 2680, 2674, 2669,
+	 2663, 2657, 2651, 2646, 2640, 2634, 2628, 2622, 2616, 2611, 2605, 2599,
+	 2593, 2587, 2581, 2575, 2569, 2563, 2557, 2551, 2545, 2539, 2533, 2527,
+	 2521, 2515, 2509, 2503, 2497, 2491, 2485, 2479, 2472, 2466, 2460, 2454,
+	 2448, 2442, 2436, 2429, 2423, 2417, 2411, 2405, 2398, 2392, 2386, 2380,
+	 2374, 2367, 2361, 2355, 2348, 2342, 2336, 2330, 2323, 2317, 2311, 2304,
+	 2298, 2292, 2285, 2279, 2273, 2266, 2260, 2254, 2247, 2241, 2235, 2228,
+	 2222, 2216, 2209, 2203, 2196, 2190, 2184, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 145 */
+	{2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721, 2721,
+	 2721, 2721, 2716, 2710, 2705, 2699, 2694, 2688, 2683, 2677, 2671, 2666,
+	 2660, 2654, 2649, 2643, 2637, 2631, 2626, 2620, 2614, 2608, 2603, 2597,
+	 2591, 2585, 2579, 2573, 2567, 2561, 2556, 2550, 2544, 2538, 2532, 2526,
+	 2520, 2514, 2508, 2502, 2496, 2490, 2484, 2477, 2471, 2465, 2459, 2453,
+	 2447, 2441, 2435, 2429, 2422, 2416, 2410, 2404, 2398, 2392, 2385, 2379,
+	 2373, 2367, 2361, 2354, 2348, 2342, 2336, 2329, 2323, 2317, 2310, 2304,
+	 2298, 2292, 2285, 2279, 2273, 2266, 2260, 2254, 2247, 2241, 2235, 2228,
+	 2222, 2215, 2209, 2203, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 146 */
+	{2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712, 2712,
+	 2712, 2712, 2712, 2707, 2701, 2696, 2690, 2685, 2679, 2674, 2668, 2663,
+	 2657, 2651, 2646, 2640, 2635, 2629, 2623, 2618, 2612, 2606, 2600, 2595,
+	 2589, 2583, 2577, 2571, 2566, 2560, 2554, 2548, 2542, 2536, 2530, 2524,
+	 2518, 2512, 2506, 2500, 2494, 2488, 2482, 2476, 2470, 2464, 2458, 2452,
+	 2446, 2440, 2434, 2428, 2422, 2416, 2409, 2403, 2397, 2391, 2385, 2379,
+	 2372, 2366, 2360, 2354, 2348, 2341, 2335, 2329, 2323, 2316, 2310, 2304,
+	 2298, 2291, 2285, 2279, 2272, 2266, 2260, 2253, 2247, 2241, 2234, 2228,
+	 2222, 2215, 2209, 2203, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 147 */
+	{2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703, 2703,
+	 2703, 2703, 2703, 2703, 2697, 2692, 2687, 2681, 2676, 2670, 2665, 2660,
+	 2654, 2649, 2643, 2637, 2632, 2626, 2621, 2615, 2609, 2604, 2598, 2592,
+	 2587, 2581, 2575, 2569, 2564, 2558, 2552, 2546, 2540, 2535, 2529, 2523,
+	 2517, 2511, 2505, 2499, 2493, 2487, 2481, 2475, 2469, 2463, 2457, 2451,
+	 2445, 2439, 2433, 2427, 2421, 2415, 2409, 2403, 2397, 2390, 2384, 2378,
+	 2372, 2366, 2360, 2353, 2347, 2341, 2335, 2329, 2322, 2316, 2310, 2304,
+	 2297, 2291, 2285, 2279, 2272, 2266, 2260, 2253, 2247, 2241, 2234, 2228,
+	 2222, 2215, 2209, 2203, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2054, 2048},
+	/* tab index : 148 */
+	{2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694, 2694,
+	 2694, 2694, 2694, 2694, 2694, 2688, 2683, 2678, 2672, 2667, 2662, 2656,
+	 2651, 2646, 2640, 2635, 2629, 2624, 2618, 2613, 2607, 2601, 2596, 2590,
+	 2584, 2579, 2573, 2567, 2562, 2556, 2550, 2544, 2539, 2533, 2527, 2521,
+	 2515, 2510, 2504, 2498, 2492, 2486, 2480, 2474, 2468, 2462, 2456, 2450,
+	 2444, 2438, 2432, 2426, 2420, 2414, 2408, 2402, 2396, 2390, 2384, 2378,
+	 2371, 2365, 2359, 2353, 2347, 2341, 2334, 2328, 2322, 2316, 2310, 2303,
+	 2297, 2291, 2285, 2278, 2272, 2266, 2259, 2253, 2247, 2241, 2234, 2228,
+	 2222, 2215, 2209, 2202, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 149 */
+	{2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684, 2684,
+	 2684, 2684, 2684, 2684, 2684, 2684, 2679, 2674, 2669, 2664, 2658, 2653,
+	 2648, 2642, 2637, 2632, 2626, 2621, 2615, 2610, 2604, 2599, 2593, 2588,
+	 2582, 2577, 2571, 2565, 2560, 2554, 2548, 2543, 2537, 2531, 2525, 2520,
+	 2514, 2508, 2502, 2496, 2491, 2485, 2479, 2473, 2467, 2461, 2455, 2449,
+	 2443, 2437, 2431, 2425, 2419, 2413, 2407, 2401, 2395, 2389, 2383, 2377,
+	 2371, 2365, 2359, 2352, 2346, 2340, 2334, 2328, 2322, 2315, 2309, 2303,
+	 2297, 2291, 2284, 2278, 2272, 2266, 2259, 2253, 2247, 2240, 2234, 2228,
+	 2221, 2215, 2209, 2202, 2196, 2190, 2183, 2177, 2171, 2164, 2158, 2151,
+	 2145, 2139, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 150 */
+	{2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2675,
+	 2675, 2675, 2675, 2675, 2675, 2675, 2675, 2670, 2665, 2660, 2655, 2650,
+	 2645, 2639, 2634, 2629, 2623, 2618, 2613, 2607, 2602, 2596, 2591, 2585,
+	 2580, 2574, 2569, 2563, 2558, 2552, 2546, 2541, 2535, 2529, 2524, 2518,
+	 2512, 2507, 2501, 2495, 2489, 2483, 2478, 2472, 2466, 2460, 2454, 2448,
+	 2442, 2436, 2430, 2424, 2418, 2412, 2406, 2400, 2394, 2388, 2382, 2376,
+	 2370, 2364, 2358, 2352, 2346, 2340, 2334, 2327, 2321, 2315, 2309, 2303,
+	 2296, 2290, 2284, 2278, 2272, 2265, 2259, 2253, 2246, 2240, 2234, 2228,
+	 2221, 2215, 2209, 2202, 2196, 2190, 2183, 2177, 2170, 2164, 2158, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 151 */
+	{2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667,
+	 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2667, 2662, 2657, 2651, 2646,
+	 2641, 2636, 2631, 2626, 2620, 2615, 2610, 2605, 2599, 2594, 2588, 2583,
+	 2578, 2572, 2567, 2561, 2556, 2550, 2545, 2539, 2533, 2528, 2522, 2516,
+	 2511, 2505, 2499, 2494, 2488, 2482, 2476, 2471, 2465, 2459, 2453, 2447,
+	 2441, 2435, 2429, 2424, 2418, 2412, 2406, 2400, 2394, 2388, 2382, 2376,
+	 2370, 2364, 2357, 2351, 2345, 2339, 2333, 2327, 2321, 2315, 2309, 2302,
+	 2296, 2290, 2284, 2278, 2271, 2265, 2259, 2253, 2246, 2240, 2234, 2227,
+	 2221, 2215, 2209, 2202, 2196, 2190, 2183, 2177, 2170, 2164, 2158, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 152 */
+	{2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658,
+	 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2658, 2653, 2648, 2643,
+	 2638, 2633, 2628, 2623, 2617, 2612, 2607, 2602, 2597, 2591, 2586, 2581,
+	 2575, 2570, 2564, 2559, 2554, 2548, 2543, 2537, 2532, 2526, 2520, 2515,
+	 2509, 2503, 2498, 2492, 2486, 2481, 2475, 2469, 2463, 2458, 2452, 2446,
+	 2440, 2434, 2429, 2423, 2417, 2411, 2405, 2399, 2393, 2387, 2381, 2375,
+	 2369, 2363, 2357, 2351, 2345, 2339, 2333, 2327, 2320, 2314, 2308, 2302,
+	 2296, 2290, 2283, 2277, 2271, 2265, 2259, 2252, 2246, 2240, 2234, 2227,
+	 2221, 2215, 2208, 2202, 2196, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 153 */
+	{2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649,
+	 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2649, 2644, 2639,
+	 2634, 2629, 2624, 2619, 2614, 2609, 2604, 2599, 2594, 2589, 2583, 2578,
+	 2573, 2567, 2562, 2557, 2551, 2546, 2541, 2535, 2530, 2524, 2519, 2513,
+	 2507, 2502, 2496, 2491, 2485, 2479, 2474, 2468, 2462, 2456, 2451, 2445,
+	 2439, 2433, 2428, 2422, 2416, 2410, 2404, 2398, 2392, 2386, 2380, 2374,
+	 2368, 2362, 2356, 2350, 2344, 2338, 2332, 2326, 2320, 2314, 2308, 2302,
+	 2296, 2289, 2283, 2277, 2271, 2265, 2258, 2252, 2246, 2240, 2233, 2227,
+	 2221, 2215, 2208, 2202, 2196, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 154 */
+	{2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641,
+	 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2641, 2636,
+	 2631, 2626, 2621, 2616, 2611, 2606, 2601, 2596, 2591, 2586, 2581, 2575,
+	 2570, 2565, 2560, 2554, 2549, 2544, 2538, 2533, 2528, 2522, 2517, 2511,
+	 2506, 2500, 2495, 2489, 2484, 2478, 2472, 2467, 2461, 2455, 2450, 2444,
+	 2438, 2432, 2426, 2421, 2415, 2409, 2403, 2397, 2391, 2386, 2380, 2374,
+	 2368, 2362, 2356, 2350, 2344, 2338, 2332, 2326, 2320, 2313, 2307, 2301,
+	 2295, 2289, 2283, 2277, 2271, 2264, 2258, 2252, 2246, 2240, 2233, 2227,
+	 2221, 2215, 2208, 2202, 2196, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 155 */
+	{2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632, 2632,
+	 2627, 2622, 2618, 2613, 2608, 2603, 2598, 2593, 2588, 2583, 2578, 2573,
+	 2568, 2563, 2557, 2552, 2547, 2542, 2536, 2531, 2526, 2520, 2515, 2509,
+	 2504, 2499, 2493, 2488, 2482, 2476, 2471, 2465, 2460, 2454, 2448, 2443,
+	 2437, 2431, 2425, 2420, 2414, 2408, 2402, 2396, 2391, 2385, 2379, 2373,
+	 2367, 2361, 2355, 2349, 2343, 2337, 2331, 2325, 2319, 2313, 2307, 2301,
+	 2295, 2289, 2283, 2276, 2270, 2264, 2258, 2252, 2246, 2239, 2233, 2227,
+	 2221, 2214, 2208, 2202, 2196, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 156 */
+	{2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624, 2624,
+	 2624, 2619, 2614, 2609, 2605, 2600, 2595, 2590, 2585, 2580, 2575, 2570,
+	 2565, 2560, 2555, 2550, 2545, 2539, 2534, 2529, 2524, 2518, 2513, 2508,
+	 2502, 2497, 2491, 2486, 2480, 2475, 2469, 2464, 2458, 2453, 2447, 2441,
+	 2436, 2430, 2424, 2419, 2413, 2407, 2401, 2396, 2390, 2384, 2378, 2372,
+	 2366, 2360, 2355, 2349, 2343, 2337, 2331, 2325, 2319, 2313, 2307, 2301,
+	 2294, 2288, 2282, 2276, 2270, 2264, 2258, 2252, 2245, 2239, 2233, 2227,
+	 2221, 2214, 2208, 2202, 2195, 2189, 2183, 2177, 2170, 2164, 2158, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 157 */
+	{2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615, 2615,
+	 2615, 2615, 2611, 2606, 2601, 2596, 2592, 2587, 2582, 2577, 2572, 2567,
+	 2562, 2557, 2552, 2547, 2542, 2537, 2532, 2527, 2522, 2516, 2511, 2506,
+	 2500, 2495, 2490, 2484, 2479, 2473, 2468, 2462, 2457, 2451, 2446, 2440,
+	 2435, 2429, 2423, 2418, 2412, 2406, 2400, 2395, 2389, 2383, 2377, 2372,
+	 2366, 2360, 2354, 2348, 2342, 2336, 2330, 2324, 2318, 2312, 2306, 2300,
+	 2294, 2288, 2282, 2276, 2270, 2264, 2257, 2251, 2245, 2239, 2233, 2227,
+	 2220, 2214, 2208, 2202, 2195, 2189, 2183, 2176, 2170, 2164, 2157, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 158 */
+	{2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607, 2607,
+	 2607, 2607, 2607, 2602, 2598, 2593, 2588, 2584, 2579, 2574, 2569, 2565,
+	 2560, 2555, 2550, 2545, 2540, 2535, 2530, 2525, 2519, 2514, 2509, 2504,
+	 2499, 2493, 2488, 2483, 2477, 2472, 2466, 2461, 2455, 2450, 2444, 2439,
+	 2433, 2428, 2422, 2417, 2411, 2405, 2400, 2394, 2388, 2382, 2377, 2371,
+	 2365, 2359, 2353, 2347, 2341, 2336, 2330, 2324, 2318, 2312, 2306, 2300,
+	 2294, 2288, 2282, 2276, 2269, 2263, 2257, 2251, 2245, 2239, 2233, 2226,
+	 2220, 2214, 2208, 2202, 2195, 2189, 2183, 2176, 2170, 2164, 2157, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 159 */
+	{2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599, 2599,
+	 2599, 2599, 2599, 2599, 2594, 2590, 2585, 2580, 2576, 2571, 2566, 2562,
+	 2557, 2552, 2547, 2542, 2537, 2532, 2527, 2522, 2517, 2512, 2507, 2502,
+	 2497, 2491, 2486, 2481, 2476, 2470, 2465, 2459, 2454, 2449, 2443, 2438,
+	 2432, 2427, 2421, 2415, 2410, 2404, 2399, 2393, 2387, 2381, 2376, 2370,
+	 2364, 2358, 2353, 2347, 2341, 2335, 2329, 2323, 2317, 2311, 2305, 2299,
+	 2293, 2287, 2281, 2275, 2269, 2263, 2257, 2251, 2245, 2239, 2232, 2226,
+	 2220, 2214, 2208, 2201, 2195, 2189, 2183, 2176, 2170, 2164, 2157, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 160 */
+	{2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591, 2591,
+	 2591, 2591, 2591, 2591, 2591, 2586, 2582, 2577, 2573, 2568, 2563, 2559,
+	 2554, 2549, 2544, 2540, 2535, 2530, 2525, 2520, 2515, 2510, 2505, 2500,
+	 2495, 2489, 2484, 2479, 2474, 2469, 2463, 2458, 2453, 2447, 2442, 2436,
+	 2431, 2425, 2420, 2414, 2409, 2403, 2398, 2392, 2386, 2381, 2375, 2369,
+	 2363, 2358, 2352, 2346, 2340, 2334, 2329, 2323, 2317, 2311, 2305, 2299,
+	 2293, 2287, 2281, 2275, 2269, 2263, 2257, 2251, 2245, 2238, 2232, 2226,
+	 2220, 2214, 2208, 2201, 2195, 2189, 2183, 2176, 2170, 2164, 2157, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 161 */
+	{2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582, 2582,
+	 2582, 2582, 2582, 2582, 2582, 2582, 2578, 2574, 2569, 2565, 2560, 2556,
+	 2551, 2546, 2542, 2537, 2532, 2527, 2522, 2518, 2513, 2508, 2503, 2498,
+	 2493, 2488, 2482, 2477, 2472, 2467, 2462, 2456, 2451, 2446, 2440, 2435,
+	 2430, 2424, 2419, 2413, 2408, 2402, 2397, 2391, 2385, 2380, 2374, 2368,
+	 2363, 2357, 2351, 2345, 2340, 2334, 2328, 2322, 2316, 2310, 2304, 2298,
+	 2293, 2287, 2281, 2275, 2269, 2263, 2256, 2250, 2244, 2238, 2232, 2226,
+	 2220, 2214, 2207, 2201, 2195, 2189, 2182, 2176, 2170, 2164, 2157, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 162 */
+	{2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2574,
+	 2574, 2574, 2574, 2574, 2574, 2574, 2574, 2570, 2566, 2561, 2557, 2552,
+	 2548, 2543, 2539, 2534, 2529, 2525, 2520, 2515, 2510, 2505, 2500, 2496,
+	 2491, 2486, 2480, 2475, 2470, 2465, 2460, 2455, 2449, 2444, 2439, 2434,
+	 2428, 2423, 2417, 2412, 2407, 2401, 2395, 2390, 2384, 2379, 2373, 2368,
+	 2362, 2356, 2350, 2345, 2339, 2333, 2327, 2322, 2316, 2310, 2304, 2298,
+	 2292, 2286, 2280, 2274, 2268, 2262, 2256, 2250, 2244, 2238, 2232, 2226,
+	 2220, 2213, 2207, 2201, 2195, 2189, 2182, 2176, 2170, 2164, 2157, 2151,
+	 2145, 2138, 2132, 2126, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 163 */
+	{2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567,
+	 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2567, 2562, 2558, 2554, 2549,
+	 2545, 2540, 2536, 2531, 2527, 2522, 2517, 2513, 2508, 2503, 2498, 2493,
+	 2488, 2483, 2478, 2473, 2468, 2463, 2458, 2453, 2448, 2443, 2437, 2432,
+	 2427, 2421, 2416, 2411, 2405, 2400, 2394, 2389, 2383, 2378, 2372, 2367,
+	 2361, 2355, 2350, 2344, 2338, 2333, 2327, 2321, 2315, 2309, 2303, 2298,
+	 2292, 2286, 2280, 2274, 2268, 2262, 2256, 2250, 2244, 2238, 2232, 2226,
+	 2219, 2213, 2207, 2201, 2195, 2188, 2182, 2176, 2170, 2163, 2157, 2151,
+	 2145, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 164 */
+	{2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559,
+	 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2559, 2555, 2550, 2546,
+	 2542, 2537, 2533, 2528, 2524, 2519, 2515, 2510, 2505, 2501, 2496, 2491,
+	 2486, 2481, 2476, 2471, 2467, 2461, 2456, 2451, 2446, 2441, 2436, 2431,
+	 2425, 2420, 2415, 2409, 2404, 2399, 2393, 2388, 2382, 2377, 2371, 2366,
+	 2360, 2355, 2349, 2343, 2338, 2332, 2326, 2320, 2315, 2309, 2303, 2297,
+	 2291, 2285, 2279, 2274, 2268, 2262, 2256, 2250, 2244, 2237, 2231, 2225,
+	 2219, 2213, 2207, 2201, 2195, 2188, 2182, 2176, 2170, 2163, 2157, 2151,
+	 2145, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 165 */
+	{2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551,
+	 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2551, 2547, 2543,
+	 2538, 2534, 2530, 2525, 2521, 2516, 2512, 2507, 2503, 2498, 2493, 2489,
+	 2484, 2479, 2474, 2469, 2465, 2460, 2455, 2450, 2445, 2439, 2434, 2429,
+	 2424, 2419, 2413, 2408, 2403, 2398, 2392, 2387, 2381, 2376, 2370, 2365,
+	 2359, 2354, 2348, 2343, 2337, 2331, 2325, 2320, 2314, 2308, 2302, 2297,
+	 2291, 2285, 2279, 2273, 2267, 2261, 2255, 2249, 2243, 2237, 2231, 2225,
+	 2219, 2213, 2207, 2201, 2194, 2188, 2182, 2176, 2170, 2163, 2157, 2151,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 166 */
+	{2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543,
+	 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 2539,
+	 2535, 2531, 2527, 2522, 2518, 2514, 2509, 2505, 2500, 2496, 2491, 2486,
+	 2482, 2477, 2472, 2467, 2463, 2458, 2453, 2448, 2443, 2438, 2433, 2428,
+	 2422, 2417, 2412, 2407, 2402, 2396, 2391, 2386, 2380, 2375, 2369, 2364,
+	 2358, 2353, 2347, 2342, 2336, 2331, 2325, 2319, 2313, 2308, 2302, 2296,
+	 2290, 2284, 2279, 2273, 2267, 2261, 2255, 2249, 2243, 2237, 2231, 2225,
+	 2219, 2213, 2207, 2200, 2194, 2188, 2182, 2176, 2170, 2163, 2157, 2151,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 167 */
+	{2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536, 2536,
+	 2532, 2528, 2523, 2519, 2515, 2511, 2506, 2502, 2498, 2493, 2489, 2484,
+	 2479, 2475, 2470, 2465, 2461, 2456, 2451, 2446, 2441, 2436, 2431, 2426,
+	 2421, 2416, 2411, 2406, 2400, 2395, 2390, 2384, 2379, 2374, 2368, 2363,
+	 2358, 2352, 2347, 2341, 2335, 2330, 2324, 2319, 2313, 2307, 2301, 2296,
+	 2290, 2284, 2278, 2272, 2266, 2261, 2255, 2249, 2243, 2237, 2231, 2225,
+	 2219, 2213, 2206, 2200, 2194, 2188, 2182, 2176, 2169, 2163, 2157, 2151,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 168 */
+	{2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528, 2528,
+	 2528, 2524, 2520, 2516, 2512, 2508, 2503, 2499, 2495, 2490, 2486, 2481,
+	 2477, 2472, 2468, 2463, 2458, 2454, 2449, 2444, 2439, 2434, 2429, 2424,
+	 2419, 2414, 2409, 2404, 2399, 2394, 2389, 2383, 2378, 2373, 2367, 2362,
+	 2357, 2351, 2346, 2340, 2335, 2329, 2323, 2318, 2312, 2307, 2301, 2295,
+	 2289, 2284, 2278, 2272, 2266, 2260, 2254, 2248, 2242, 2236, 2230, 2224,
+	 2218, 2212, 2206, 2200, 2194, 2188, 2182, 2176, 2169, 2163, 2157, 2151,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 169 */
+	{2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521,
+	 2521, 2521, 2517, 2513, 2509, 2505, 2500, 2496, 2492, 2488, 2483, 2479,
+	 2474, 2470, 2465, 2461, 2456, 2452, 2447, 2442, 2437, 2433, 2428, 2423,
+	 2418, 2413, 2408, 2403, 2398, 2392, 2387, 2382, 2377, 2372, 2366, 2361,
+	 2356, 2350, 2345, 2339, 2334, 2328, 2323, 2317, 2312, 2306, 2300, 2295,
+	 2289, 2283, 2277, 2272, 2266, 2260, 2254, 2248, 2242, 2236, 2230, 2224,
+	 2218, 2212, 2206, 2200, 2194, 2188, 2182, 2175, 2169, 2163, 2157, 2151,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 170 */
+	{2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513, 2513,
+	 2513, 2513, 2513, 2509, 2505, 2501, 2497, 2493, 2489, 2485, 2481, 2476,
+	 2472, 2468, 2463, 2459, 2454, 2449, 2445, 2440, 2435, 2431, 2426, 2421,
+	 2416, 2411, 2406, 2401, 2396, 2391, 2386, 2381, 2376, 2370, 2365, 2360,
+	 2355, 2349, 2344, 2338, 2333, 2328, 2322, 2316, 2311, 2305, 2300, 2294,
+	 2288, 2283, 2277, 2271, 2265, 2259, 2254, 2248, 2242, 2236, 2230, 2224,
+	 2218, 2212, 2206, 2200, 2194, 2188, 2182, 2175, 2169, 2163, 2157, 2151,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 171 */
+	{2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506, 2506,
+	 2506, 2506, 2506, 2506, 2502, 2498, 2494, 2490, 2486, 2482, 2478, 2474,
+	 2469, 2465, 2461, 2456, 2452, 2447, 2443, 2438, 2433, 2429, 2424, 2419,
+	 2414, 2410, 2405, 2400, 2395, 2390, 2385, 2380, 2374, 2369, 2364, 2359,
+	 2354, 2348, 2343, 2338, 2332, 2327, 2321, 2316, 2310, 2305, 2299, 2293,
+	 2288, 2282, 2276, 2271, 2265, 2259, 2253, 2247, 2242, 2236, 2230, 2224,
+	 2218, 2212, 2206, 2200, 2194, 2188, 2181, 2175, 2169, 2163, 2157, 2150,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 172 */
+	{2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499, 2499,
+	 2499, 2499, 2499, 2499, 2499, 2495, 2491, 2487, 2483, 2479, 2475, 2471,
+	 2467, 2462, 2458, 2454, 2449, 2445, 2441, 2436, 2431, 2427, 2422, 2417,
+	 2413, 2408, 2403, 2398, 2393, 2388, 2383, 2378, 2373, 2368, 2363, 2358,
+	 2353, 2347, 2342, 2337, 2331, 2326, 2320, 2315, 2310, 2304, 2298, 2293,
+	 2287, 2282, 2276, 2270, 2264, 2259, 2253, 2247, 2241, 2235, 2229, 2223,
+	 2218, 2212, 2206, 2200, 2193, 2187, 2181, 2175, 2169, 2163, 2157, 2150,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 173 */
+	{2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491, 2491,
+	 2491, 2491, 2491, 2491, 2491, 2491, 2488, 2484, 2480, 2476, 2472, 2468,
+	 2464, 2460, 2456, 2451, 2447, 2443, 2438, 2434, 2429, 2425, 2420, 2416,
+	 2411, 2406, 2401, 2397, 2392, 2387, 2382, 2377, 2372, 2367, 2362, 2357,
+	 2351, 2346, 2341, 2336, 2330, 2325, 2320, 2314, 2309, 2303, 2298, 2292,
+	 2287, 2281, 2275, 2270, 2264, 2258, 2252, 2247, 2241, 2235, 2229, 2223,
+	 2217, 2211, 2205, 2199, 2193, 2187, 2181, 2175, 2169, 2163, 2157, 2150,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 174 */
+	{2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2484,
+	 2484, 2484, 2484, 2484, 2484, 2484, 2484, 2480, 2477, 2473, 2469, 2465,
+	 2461, 2457, 2453, 2449, 2445, 2440, 2436, 2432, 2427, 2423, 2418, 2414,
+	 2409, 2404, 2400, 2395, 2390, 2385, 2380, 2376, 2371, 2366, 2361, 2355,
+	 2350, 2345, 2340, 2335, 2329, 2324, 2319, 2313, 2308, 2303, 2297, 2292,
+	 2286, 2280, 2275, 2269, 2264, 2258, 2252, 2246, 2241, 2235, 2229, 2223,
+	 2217, 2211, 2205, 2199, 2193, 2187, 2181, 2175, 2169, 2163, 2156, 2150,
+	 2144, 2138, 2132, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 175 */
+	{2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477,
+	 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2477, 2473, 2470, 2466, 2462,
+	 2458, 2454, 2450, 2446, 2442, 2438, 2434, 2429, 2425, 2421, 2416, 2412,
+	 2407, 2403, 2398, 2393, 2389, 2384, 2379, 2374, 2369, 2364, 2359, 2354,
+	 2349, 2344, 2339, 2334, 2329, 2323, 2318, 2313, 2307, 2302, 2296, 2291,
+	 2285, 2280, 2274, 2269, 2263, 2257, 2252, 2246, 2240, 2234, 2229, 2223,
+	 2217, 2211, 2205, 2199, 2193, 2187, 2181, 2175, 2169, 2163, 2156, 2150,
+	 2144, 2138, 2131, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 176 */
+	{2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470,
+	 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2470, 2466, 2463, 2459,
+	 2455, 2451, 2447, 2443, 2439, 2435, 2431, 2427, 2423, 2418, 2414, 2410,
+	 2405, 2401, 2396, 2392, 2387, 2382, 2377, 2373, 2368, 2363, 2358, 2353,
+	 2348, 2343, 2338, 2333, 2328, 2322, 2317, 2312, 2306, 2301, 2296, 2290,
+	 2285, 2279, 2274, 2268, 2263, 2257, 2251, 2246, 2240, 2234, 2228, 2222,
+	 2217, 2211, 2205, 2199, 2193, 2187, 2181, 2175, 2169, 2162, 2156, 2150,
+	 2144, 2138, 2131, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 177 */
+	{2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463,
+	 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2463, 2459, 2456,
+	 2452, 2448, 2445, 2441, 2437, 2433, 2429, 2425, 2420, 2416, 2412, 2408,
+	 2403, 2399, 2394, 2390, 2385, 2381, 2376, 2371, 2366, 2362, 2357, 2352,
+	 2347, 2342, 2337, 2332, 2327, 2321, 2316, 2311, 2306, 2300, 2295, 2290,
+	 2284, 2279, 2273, 2268, 2262, 2256, 2251, 2245, 2239, 2234, 2228, 2222,
+	 2216, 2210, 2204, 2199, 2193, 2187, 2181, 2175, 2168, 2162, 2156, 2150,
+	 2144, 2138, 2131, 2125, 2119, 2113, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 178 */
+	{2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456,
+	 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2456, 2453,
+	 2449, 2445, 2442, 2438, 2434, 2430, 2426, 2422, 2418, 2414, 2410, 2405,
+	 2401, 2397, 2392, 2388, 2383, 2379, 2374, 2370, 2365, 2360, 2355, 2350,
+	 2346, 2341, 2336, 2331, 2326, 2320, 2315, 2310, 2305, 2300, 2294, 2289,
+	 2283, 2278, 2273, 2267, 2262, 2256, 2250, 2245, 2239, 2233, 2228, 2222,
+	 2216, 2210, 2204, 2198, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
+	 2144, 2138, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 179 */
+	{2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449, 2449,
+	 2446, 2442, 2439, 2435, 2431, 2427, 2423, 2420, 2416, 2412, 2407, 2403,
+	 2399, 2395, 2390, 2386, 2382, 2377, 2373, 2368, 2363, 2359, 2354, 2349,
+	 2344, 2339, 2334, 2330, 2324, 2319, 2314, 2309, 2304, 2299, 2293, 2288,
+	 2283, 2277, 2272, 2267, 2261, 2255, 2250, 2244, 2239, 2233, 2227, 2221,
+	 2216, 2210, 2204, 2198, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
+	 2144, 2138, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 180 */
+	{2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442, 2442,
+	 2442, 2439, 2435, 2432, 2428, 2425, 2421, 2417, 2413, 2409, 2405, 2401,
+	 2397, 2393, 2388, 2384, 2380, 2375, 2371, 2366, 2362, 2357, 2352, 2348,
+	 2343, 2338, 2333, 2328, 2323, 2318, 2313, 2308, 2303, 2298, 2293, 2287,
+	 2282, 2277, 2271, 2266, 2260, 2255, 2249, 2244, 2238, 2233, 2227, 2221,
+	 2215, 2210, 2204, 2198, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
+	 2144, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 181 */
+	{2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436, 2436,
+	 2436, 2436, 2432, 2429, 2425, 2422, 2418, 2414, 2410, 2407, 2403, 2399,
+	 2395, 2390, 2386, 2382, 2378, 2373, 2369, 2365, 2360, 2356, 2351, 2346,
+	 2342, 2337, 2332, 2327, 2322, 2317, 2312, 2307, 2302, 2297, 2292, 2287,
+	 2281, 2276, 2271, 2265, 2260, 2254, 2249, 2243, 2238, 2232, 2226, 2221,
+	 2215, 2209, 2203, 2198, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
+	 2144, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 182 */
+	{2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429, 2429,
+	 2429, 2429, 2429, 2426, 2422, 2419, 2415, 2411, 2408, 2404, 2400, 2396,
+	 2392, 2388, 2384, 2380, 2376, 2372, 2367, 2363, 2358, 2354, 2349, 2345,
+	 2340, 2336, 2331, 2326, 2321, 2316, 2311, 2306, 2301, 2296, 2291, 2286,
+	 2281, 2275, 2270, 2265, 2259, 2254, 2248, 2243, 2237, 2232, 2226, 2220,
+	 2215, 2209, 2203, 2197, 2192, 2186, 2180, 2174, 2168, 2162, 2156, 2150,
+	 2143, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 183 */
+	{2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422, 2422,
+	 2422, 2422, 2422, 2422, 2419, 2416, 2412, 2409, 2405, 2401, 2398, 2394,
+	 2390, 2386, 2382, 2378, 2374, 2370, 2365, 2361, 2357, 2352, 2348, 2343,
+	 2339, 2334, 2329, 2325, 2320, 2315, 2310, 2305, 2300, 2295, 2290, 2285,
+	 2280, 2275, 2269, 2264, 2259, 2253, 2248, 2242, 2237, 2231, 2226, 2220,
+	 2214, 2209, 2203, 2197, 2191, 2185, 2180, 2174, 2168, 2162, 2156, 2149,
+	 2143, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 184 */
+	{2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416, 2416,
+	 2416, 2416, 2416, 2416, 2416, 2412, 2409, 2406, 2402, 2399, 2395, 2391,
+	 2387, 2384, 2380, 2376, 2372, 2368, 2363, 2359, 2355, 2351, 2346, 2342,
+	 2337, 2333, 2328, 2323, 2319, 2314, 2309, 2304, 2299, 2294, 2289, 2284,
+	 2279, 2274, 2269, 2263, 2258, 2253, 2247, 2242, 2236, 2231, 2225, 2220,
+	 2214, 2208, 2203, 2197, 2191, 2185, 2179, 2173, 2167, 2161, 2155, 2149,
+	 2143, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 185 */
+	{2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409, 2409,
+	 2409, 2409, 2409, 2409, 2409, 2409, 2406, 2403, 2399, 2396, 2392, 2389,
+	 2385, 2381, 2377, 2373, 2370, 2366, 2361, 2357, 2353, 2349, 2345, 2340,
+	 2336, 2331, 2327, 2322, 2317, 2313, 2308, 2303, 2298, 2293, 2288, 2283,
+	 2278, 2273, 2268, 2263, 2257, 2252, 2247, 2241, 2236, 2230, 2225, 2219,
+	 2214, 2208, 2202, 2197, 2191, 2185, 2179, 2173, 2167, 2161, 2155, 2149,
+	 2143, 2137, 2131, 2125, 2119, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 186 */
+	{2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2403,
+	 2403, 2403, 2403, 2403, 2403, 2403, 2403, 2399, 2396, 2393, 2389, 2386,
+	 2382, 2379, 2375, 2371, 2367, 2363, 2359, 2355, 2351, 2347, 2343, 2339,
+	 2334, 2330, 2325, 2321, 2316, 2311, 2307, 2302, 2297, 2292, 2287, 2282,
+	 2277, 2272, 2267, 2262, 2257, 2251, 2246, 2241, 2235, 2230, 2224, 2219,
+	 2213, 2208, 2202, 2196, 2191, 2185, 2179, 2173, 2167, 2161, 2155, 2149,
+	 2143, 2137, 2131, 2125, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 187 */
+	{2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396,
+	 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2396, 2393, 2390, 2387, 2383,
+	 2380, 2376, 2372, 2369, 2365, 2361, 2357, 2353, 2349, 2345, 2341, 2337,
+	 2333, 2328, 2324, 2319, 2315, 2310, 2306, 2301, 2296, 2291, 2286, 2281,
+	 2276, 2271, 2266, 2261, 2256, 2251, 2246, 2240, 2235, 2229, 2224, 2218,
+	 2213, 2207, 2202, 2196, 2190, 2185, 2179, 2173, 2167, 2161, 2155, 2149,
+	 2143, 2137, 2131, 2125, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 188 */
+	{2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390,
+	 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2390, 2387, 2384, 2380,
+	 2377, 2373, 2370, 2366, 2363, 2359, 2355, 2351, 2347, 2343, 2339, 2335,
+	 2331, 2327, 2322, 2318, 2313, 2309, 2304, 2300, 2295, 2290, 2285, 2280,
+	 2276, 2271, 2266, 2260, 2255, 2250, 2245, 2240, 2234, 2229, 2224, 2218,
+	 2213, 2207, 2201, 2196, 2190, 2184, 2178, 2173, 2167, 2161, 2155, 2149,
+	 2143, 2137, 2131, 2125, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 189 */
+	{2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384,
+	 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2384, 2380, 2377,
+	 2374, 2371, 2367, 2364, 2360, 2357, 2353, 2349, 2345, 2341, 2337, 2333,
+	 2329, 2325, 2321, 2316, 2312, 2307, 2303, 2298, 2294, 2289, 2284, 2279,
+	 2275, 2270, 2265, 2260, 2255, 2249, 2244, 2239, 2234, 2228, 2223, 2218,
+	 2212, 2207, 2201, 2195, 2190, 2184, 2178, 2172, 2167, 2161, 2155, 2149,
+	 2143, 2137, 2131, 2125, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 190 */
+	{2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377,
+	 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2377, 2374,
+	 2371, 2368, 2365, 2361, 2358, 2354, 2351, 2347, 2343, 2339, 2335, 2331,
+	 2327, 2323, 2319, 2315, 2310, 2306, 2302, 2297, 2293, 2288, 2283, 2278,
+	 2274, 2269, 2264, 2259, 2254, 2249, 2244, 2238, 2233, 2228, 2223, 2217,
+	 2212, 2206, 2201, 2195, 2189, 2184, 2178, 2172, 2166, 2161, 2155, 2149,
+	 2143, 2137, 2131, 2124, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 191 */
+	{2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371, 2371,
+	 2368, 2365, 2362, 2358, 2355, 2352, 2348, 2345, 2341, 2337, 2333, 2329,
+	 2325, 2321, 2317, 2313, 2309, 2305, 2300, 2296, 2291, 2287, 2282, 2277,
+	 2273, 2268, 2263, 2258, 2253, 2248, 2243, 2238, 2233, 2227, 2222, 2217,
+	 2211, 2206, 2200, 2195, 2189, 2183, 2178, 2172, 2166, 2160, 2155, 2149,
+	 2143, 2137, 2131, 2124, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 192 */
+	{2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365, 2365,
+	 2365, 2362, 2359, 2356, 2352, 2349, 2346, 2342, 2339, 2335, 2331, 2327,
+	 2324, 2320, 2316, 2311, 2307, 2303, 2299, 2294, 2290, 2285, 2281, 2276,
+	 2272, 2267, 2262, 2257, 2252, 2247, 2242, 2237, 2232, 2227, 2222, 2216,
+	 2211, 2205, 2200, 2194, 2189, 2183, 2178, 2172, 2166, 2160, 2154, 2148,
+	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 193 */
+	{2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359, 2359,
+	 2359, 2359, 2356, 2353, 2350, 2346, 2343, 2340, 2336, 2333, 2329, 2325,
+	 2322, 2318, 2314, 2310, 2306, 2301, 2297, 2293, 2289, 2284, 2280, 2275,
+	 2271, 2266, 2261, 2256, 2251, 2246, 2242, 2236, 2231, 2226, 2221, 2216,
+	 2210, 2205, 2200, 2194, 2188, 2183, 2177, 2172, 2166, 2160, 2154, 2148,
+	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2100, 2093, 2087, 2081, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 194 */
+	{2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353, 2353,
+	 2353, 2353, 2353, 2350, 2347, 2344, 2340, 2337, 2334, 2330, 2327, 2323,
+	 2319, 2316, 2312, 2308, 2304, 2300, 2296, 2292, 2287, 2283, 2278, 2274,
+	 2269, 2265, 2260, 2255, 2251, 2246, 2241, 2236, 2231, 2226, 2220, 2215,
+	 2210, 2205, 2199, 2194, 2188, 2183, 2177, 2171, 2166, 2160, 2154, 2148,
+	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 195 */
+	{2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347, 2347,
+	 2347, 2347, 2347, 2347, 2344, 2341, 2338, 2334, 2331, 2328, 2324, 2321,
+	 2317, 2314, 2310, 2306, 2302, 2298, 2294, 2290, 2286, 2282, 2277, 2273,
+	 2268, 2264, 2259, 2254, 2250, 2245, 2240, 2235, 2230, 2225, 2220, 2215,
+	 2209, 2204, 2199, 2193, 2188, 2182, 2177, 2171, 2165, 2160, 2154, 2148,
+	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 196 */
+	{2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341, 2341,
+	 2341, 2341, 2341, 2341, 2341, 2338, 2335, 2332, 2329, 2325, 2322, 2319,
+	 2315, 2312, 2308, 2304, 2300, 2296, 2292, 2288, 2284, 2280, 2276, 2271,
+	 2267, 2263, 2258, 2253, 2249, 2244, 2239, 2234, 2229, 2224, 2219, 2214,
+	 2209, 2204, 2198, 2193, 2187, 2182, 2176, 2171, 2165, 2159, 2154, 2148,
+	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 197 */
+	{2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335, 2335,
+	 2335, 2335, 2335, 2335, 2335, 2335, 2332, 2329, 2326, 2323, 2320, 2316,
+	 2313, 2309, 2306, 2302, 2298, 2295, 2291, 2287, 2283, 2279, 2274, 2270,
+	 2266, 2261, 2257, 2252, 2248, 2243, 2238, 2233, 2229, 2224, 2219, 2213,
+	 2208, 2203, 2198, 2192, 2187, 2182, 2176, 2171, 2165, 2159, 2153, 2148,
+	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 198 */
+	{2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2329,
+	 2329, 2329, 2329, 2329, 2329, 2329, 2329, 2326, 2323, 2320, 2317, 2314,
+	 2310, 2307, 2304, 2300, 2296, 2293, 2289, 2285, 2281, 2277, 2273, 2269,
+	 2265, 2260, 2256, 2251, 2247, 2242, 2237, 2233, 2228, 2223, 2218, 2213,
+	 2208, 2203, 2197, 2192, 2187, 2181, 2176, 2170, 2165, 2159, 2153, 2147,
+	 2142, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 199 */
+	{2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323,
+	 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2323, 2320, 2317, 2314, 2311,
+	 2308, 2305, 2301, 2298, 2294, 2291, 2287, 2283, 2279, 2276, 2272, 2267,
+	 2263, 2259, 2255, 2250, 2246, 2241, 2236, 2232, 2227, 2222, 2217, 2212,
+	 2207, 2202, 2197, 2192, 2186, 2181, 2175, 2170, 2164, 2159, 2153, 2147,
+	 2141, 2136, 2130, 2124, 2118, 2112, 2106, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 200 */
+	{2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317,
+	 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2317, 2314, 2311, 2309,
+	 2305, 2302, 2299, 2296, 2292, 2289, 2285, 2282, 2278, 2274, 2270, 2266,
+	 2262, 2258, 2253, 2249, 2245, 2240, 2236, 2231, 2226, 2221, 2216, 2212,
+	 2207, 2201, 2196, 2191, 2186, 2180, 2175, 2170, 2164, 2158, 2153, 2147,
+	 2141, 2135, 2130, 2124, 2118, 2112, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 201 */
+	{2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311,
+	 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2311, 2309, 2306,
+	 2303, 2300, 2297, 2293, 2290, 2287, 2283, 2280, 2276, 2272, 2268, 2264,
+	 2260, 2256, 2252, 2248, 2243, 2239, 2235, 2230, 2225, 2221, 2216, 2211,
+	 2206, 2201, 2196, 2191, 2185, 2180, 2175, 2169, 2164, 2158, 2153, 2147,
+	 2141, 2135, 2129, 2124, 2118, 2112, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 202 */
+	{2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306,
+	 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2306, 2303,
+	 2300, 2297, 2294, 2291, 2288, 2285, 2281, 2278, 2274, 2270, 2267, 2263,
+	 2259, 2255, 2251, 2247, 2242, 2238, 2233, 2229, 2224, 2220, 2215, 2210,
+	 2205, 2200, 2195, 2190, 2185, 2180, 2174, 2169, 2163, 2158, 2152, 2147,
+	 2141, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 203 */
+	{2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300, 2300,
+	 2297, 2294, 2292, 2289, 2285, 2282, 2279, 2276, 2272, 2269, 2265, 2261,
+	 2257, 2253, 2249, 2245, 2241, 2237, 2232, 2228, 2223, 2219, 2214, 2209,
+	 2205, 2200, 2195, 2190, 2184, 2179, 2174, 2169, 2163, 2158, 2152, 2146,
+	 2141, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 204 */
+	{2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294, 2294,
+	 2294, 2292, 2289, 2286, 2283, 2280, 2277, 2274, 2270, 2267, 2263, 2259,
+	 2256, 2252, 2248, 2244, 2240, 2236, 2231, 2227, 2222, 2218, 2213, 2209,
+	 2204, 2199, 2194, 2189, 2184, 2179, 2174, 2168, 2163, 2157, 2152, 2146,
+	 2141, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 205 */
+	{2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289, 2289,
+	 2289, 2289, 2286, 2283, 2280, 2277, 2274, 2271, 2268, 2265, 2261, 2258,
+	 2254, 2250, 2246, 2242, 2238, 2234, 2230, 2226, 2221, 2217, 2212, 2208,
+	 2203, 2198, 2193, 2188, 2183, 2178, 2173, 2168, 2162, 2157, 2152, 2146,
+	 2140, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 206 */
+	{2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283, 2283,
+	 2283, 2283, 2283, 2280, 2278, 2275, 2272, 2269, 2266, 2263, 2259, 2256,
+	 2252, 2249, 2245, 2241, 2237, 2233, 2229, 2225, 2220, 2216, 2212, 2207,
+	 2202, 2198, 2193, 2188, 2183, 2178, 2173, 2167, 2162, 2157, 2151, 2146,
+	 2140, 2135, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 207 */
+	{2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278, 2278,
+	 2278, 2278, 2278, 2278, 2275, 2272, 2269, 2267, 2264, 2260, 2257, 2254,
+	 2250, 2247, 2243, 2239, 2236, 2232, 2228, 2224, 2219, 2215, 2211, 2206,
+	 2201, 2197, 2192, 2187, 2182, 2177, 2172, 2167, 2162, 2156, 2151, 2146,
+	 2140, 2134, 2129, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 208 */
+	{2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272, 2272,
+	 2272, 2272, 2272, 2272, 2272, 2270, 2267, 2264, 2261, 2258, 2255, 2252,
+	 2249, 2245, 2242, 2238, 2234, 2230, 2226, 2222, 2218, 2214, 2210, 2205,
+	 2201, 2196, 2191, 2187, 2182, 2177, 2172, 2167, 2161, 2156, 2151, 2145,
+	 2140, 2134, 2128, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 209 */
+	{2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267, 2267,
+	 2267, 2267, 2267, 2267, 2267, 2267, 2264, 2261, 2259, 2256, 2253, 2250,
+	 2247, 2243, 2240, 2236, 2233, 2229, 2225, 2221, 2217, 2213, 2209, 2204,
+	 2200, 2195, 2191, 2186, 2181, 2176, 2171, 2166, 2161, 2156, 2150, 2145,
+	 2139, 2134, 2128, 2123, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 210 */
+	{2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2261,
+	 2261, 2261, 2261, 2261, 2261, 2261, 2261, 2259, 2256, 2253, 2250, 2248,
+	 2244, 2241, 2238, 2234, 2231, 2227, 2224, 2220, 2216, 2212, 2207, 2203,
+	 2199, 2194, 2190, 2185, 2180, 2176, 2171, 2166, 2161, 2155, 2150, 2145,
+	 2139, 2134, 2128, 2122, 2117, 2111, 2105, 2099, 2093, 2087, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 211 */
+	{2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256,
+	 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2256, 2253, 2251, 2248, 2245,
+	 2242, 2239, 2236, 2233, 2229, 2226, 2222, 2218, 2214, 2210, 2206, 2202,
+	 2198, 2193, 2189, 2184, 2180, 2175, 2170, 2165, 2160, 2155, 2150, 2144,
+	 2139, 2133, 2128, 2122, 2116, 2111, 2105, 2099, 2093, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 212 */
+	{2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251,
+	 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2251, 2248, 2245, 2243,
+	 2240, 2237, 2234, 2231, 2227, 2224, 2220, 2217, 2213, 2209, 2205, 2201,
+	 2197, 2193, 2188, 2184, 2179, 2174, 2169, 2165, 2160, 2154, 2149, 2144,
+	 2139, 2133, 2128, 2122, 2116, 2111, 2105, 2099, 2093, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 213 */
+	{2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245,
+	 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2245, 2243, 2240,
+	 2238, 2235, 2232, 2229, 2226, 2222, 2219, 2215, 2212, 2208, 2204, 2200,
+	 2196, 2192, 2187, 2183, 2178, 2174, 2169, 2164, 2159, 2154, 2149, 2144,
+	 2138, 2133, 2127, 2122, 2116, 2110, 2105, 2099, 2093, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 214 */
+	{2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240,
+	 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2240, 2238,
+	 2235, 2232, 2230, 2227, 2224, 2220, 2217, 2214, 2210, 2206, 2203, 2199,
+	 2195, 2191, 2186, 2182, 2177, 2173, 2168, 2163, 2159, 2154, 2149, 2143,
+	 2138, 2133, 2127, 2122, 2116, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 215 */
+	{2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235, 2235,
+	 2232, 2230, 2227, 2224, 2221, 2218, 2215, 2212, 2208, 2205, 2201, 2197,
+	 2193, 2189, 2185, 2181, 2177, 2172, 2168, 2163, 2158, 2153, 2148, 2143,
+	 2138, 2132, 2127, 2121, 2116, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 216 */
+	{2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230, 2230,
+	 2230, 2227, 2225, 2222, 2219, 2216, 2213, 2210, 2207, 2203, 2200, 2196,
+	 2192, 2188, 2184, 2180, 2176, 2171, 2167, 2162, 2157, 2153, 2148, 2143,
+	 2137, 2132, 2127, 2121, 2116, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 217 */
+	{2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224, 2224,
+	 2224, 2224, 2222, 2220, 2217, 2214, 2211, 2208, 2205, 2202, 2198, 2195,
+	 2191, 2187, 2183, 2179, 2175, 2170, 2166, 2161, 2157, 2152, 2147, 2142,
+	 2137, 2132, 2126, 2121, 2115, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 218 */
+	{2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219, 2219,
+	 2219, 2219, 2219, 2217, 2215, 2212, 2209, 2206, 2203, 2200, 2197, 2193,
+	 2190, 2186, 2182, 2178, 2174, 2170, 2165, 2161, 2156, 2151, 2147, 2142,
+	 2137, 2131, 2126, 2121, 2115, 2110, 2104, 2098, 2092, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 219 */
+	{2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214, 2214,
+	 2214, 2214, 2214, 2214, 2212, 2209, 2207, 2204, 2201, 2198, 2195, 2192,
+	 2188, 2184, 2181, 2177, 2173, 2169, 2164, 2160, 2155, 2151, 2146, 2141,
+	 2136, 2131, 2126, 2121, 2115, 2109, 2104, 2098, 2092, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 220 */
+	{2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209, 2209,
+	 2209, 2209, 2209, 2209, 2209, 2207, 2204, 2202, 2199, 2196, 2193, 2190,
+	 2187, 2183, 2179, 2176, 2172, 2168, 2164, 2159, 2155, 2150, 2146, 2141,
+	 2136, 2131, 2126, 2120, 2115, 2109, 2104, 2098, 2092, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 221 */
+	{2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204, 2204,
+	 2204, 2204, 2204, 2204, 2204, 2204, 2202, 2199, 2197, 2194, 2191, 2188,
+	 2185, 2182, 2178, 2174, 2171, 2167, 2163, 2158, 2154, 2150, 2145, 2140,
+	 2135, 2130, 2125, 2120, 2115, 2109, 2104, 2098, 2092, 2086, 2080, 2074,
+	 2068, 2061, 2055, 2048},
+	/* tab index : 222 */
+	{2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2199,
+	 2199, 2199, 2199, 2199, 2199, 2199, 2199, 2197, 2195, 2192, 2189, 2186,
+	 2183, 2180, 2177, 2173, 2169, 2166, 2162, 2157, 2153, 2149, 2144, 2140,
+	 2135, 2130, 2125, 2120, 2114, 2109, 2103, 2098, 2092, 2086, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 223 */
+	{2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194,
+	 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2194, 2192, 2190, 2187, 2184,
+	 2181, 2178, 2175, 2172, 2168, 2164, 2160, 2156, 2152, 2148, 2144, 2139,
+	 2134, 2129, 2124, 2119, 2114, 2109, 2103, 2098, 2092, 2086, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 224 */
+	{2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189,
+	 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2189, 2187, 2185, 2182,
+	 2179, 2176, 2173, 2170, 2167, 2163, 2159, 2155, 2151, 2147, 2143, 2138,
+	 2134, 2129, 2124, 2119, 2114, 2108, 2103, 2097, 2092, 2086, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 225 */
+	{2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185,
+	 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2185, 2182, 2180,
+	 2177, 2175, 2172, 2168, 2165, 2162, 2158, 2154, 2150, 2146, 2142, 2138,
+	 2133, 2128, 2124, 2119, 2114, 2108, 2103, 2097, 2092, 2086, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 226 */
+	{2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180,
+	 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2180, 2177,
+	 2175, 2172, 2170, 2167, 2164, 2160, 2157, 2153, 2149, 2145, 2141, 2137,
+	 2133, 2128, 2123, 2118, 2113, 2108, 2103, 2097, 2091, 2086, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 227 */
+	{2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175,
+	 2173, 2170, 2168, 2165, 2162, 2159, 2155, 2152, 2148, 2144, 2140, 2136,
+	 2132, 2127, 2123, 2118, 2113, 2108, 2102, 2097, 2091, 2086, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 228 */
+	{2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170, 2170,
+	 2170, 2168, 2165, 2163, 2160, 2157, 2154, 2151, 2147, 2143, 2139, 2135,
+	 2131, 2127, 2122, 2117, 2112, 2107, 2102, 2097, 2091, 2085, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 229 */
+	{2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165, 2165,
+	 2165, 2165, 2163, 2161, 2158, 2155, 2152, 2149, 2146, 2142, 2138, 2134,
+	 2130, 2126, 2122, 2117, 2112, 2107, 2102, 2097, 2091, 2085, 2080, 2074,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 230 */
+	{2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161, 2161,
+	 2161, 2161, 2161, 2158, 2156, 2153, 2151, 2148, 2144, 2141, 2137, 2134,
+	 2130, 2125, 2121, 2116, 2112, 2107, 2102, 2096, 2091, 2085, 2079, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 231 */
+	{2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156, 2156,
+	 2156, 2156, 2156, 2156, 2154, 2151, 2149, 2146, 2143, 2140, 2136, 2132,
+	 2129, 2125, 2120, 2116, 2111, 2106, 2101, 2096, 2091, 2085, 2079, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 232 */
+	{2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151, 2151,
+	 2151, 2151, 2151, 2151, 2151, 2149, 2147, 2144, 2141, 2138, 2135, 2131,
+	 2128, 2124, 2120, 2115, 2111, 2106, 2101, 2096, 2090, 2085, 2079, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 233 */
+	{2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147, 2147,
+	 2147, 2147, 2147, 2147, 2147, 2147, 2145, 2142, 2139, 2137, 2133, 2130,
+	 2127, 2123, 2119, 2115, 2110, 2105, 2101, 2096, 2090, 2085, 2079, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 234 */
+	{2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2142,
+	 2142, 2142, 2142, 2142, 2142, 2142, 2142, 2140, 2137, 2135, 2132, 2129,
+	 2125, 2122, 2118, 2114, 2109, 2105, 2100, 2095, 2090, 2085, 2079, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 235 */
+	{2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138,
+	 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2138, 2135, 2133, 2130, 2127,
+	 2124, 2121, 2117, 2113, 2109, 2104, 2100, 2095, 2090, 2084, 2079, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 236 */
+	{2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133,
+	 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2133, 2131, 2128, 2126,
+	 2123, 2119, 2116, 2112, 2108, 2104, 2099, 2095, 2090, 2084, 2079, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 237 */
+	{2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129,
+	 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2129, 2126, 2124,
+	 2121, 2118, 2115, 2111, 2107, 2103, 2099, 2094, 2089, 2084, 2079, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 238 */
+	{2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124,
+	 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2124, 2122,
+	 2119, 2117, 2113, 2110, 2106, 2102, 2098, 2094, 2089, 2084, 2078, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 239 */
+	{2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120, 2120,
+	 2117, 2115, 2112, 2109, 2105, 2102, 2097, 2093, 2088, 2084, 2078, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 240 */
+	{2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115, 2115,
+	 2115, 2113, 2110, 2107, 2104, 2101, 2097, 2093, 2088, 2083, 2078, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 241 */
+	{2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111, 2111,
+	 2111, 2111, 2109, 2106, 2103, 2100, 2096, 2092, 2088, 2083, 2078, 2073,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 242 */
+	{2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106, 2106,
+	 2106, 2106, 2106, 2104, 2101, 2098, 2095, 2091, 2087, 2082, 2078, 2072,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 243 */
+	{2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102, 2102,
+	 2102, 2102, 2102, 2102, 2100, 2097, 2094, 2090, 2086, 2082, 2077, 2072,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 244 */
+	{2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,
+	 2098, 2098, 2098, 2098, 2098, 2095, 2093, 2089, 2086, 2081, 2077, 2072,
+	 2067, 2061, 2055, 2048},
+	/* tab index : 245 */
+	{2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093, 2093,
+	 2093, 2093, 2093, 2093, 2093, 2093, 2091, 2088, 2085, 2081, 2076, 2072,
+	 2066, 2061, 2055, 2048},
+	/* tab index : 246 */
+	{2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2089,
+	 2089, 2089, 2089, 2089, 2089, 2089, 2089, 2087, 2084, 2080, 2076, 2071,
+	 2066, 2061, 2055, 2048},
+	/* tab index : 247 */
+	{2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085,
+	 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2085, 2082, 2079, 2075, 2071,
+	 2066, 2061, 2055, 2048},
+	/* tab index : 248 */
+	{2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081,
+	 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2081, 2078, 2075, 2071,
+	 2066, 2060, 2055, 2048},
+	/* tab index : 249 */
+	{2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077,
+	 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2077, 2074, 2070,
+	 2066, 2060, 2055, 2048},
+	/* tab index : 250 */
+	{2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072,
+	 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2072, 2069,
+	 2065, 2060, 2055, 2048},
+	/* tab index : 251 */
+	{2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068, 2068,
+	 2065, 2060, 2055, 2048},
+	/* tab index : 252 */
+	{2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064, 2064,
+	 2064, 2060, 2055, 2048},
+	/* tab index : 253 */
+	{2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060, 2060,
+	 2060, 2060, 2055, 2048},
+	/* tab index : 254 */
+	{2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056, 2056,
+	 2056, 2056, 2056, 2048},
+	/* tab index : 255 */
+	{2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048,
+	 2048, 2048, 2048, 2048}
+};
+
+static __u8 spatial_coeff[9] = { 228, 241, 228, 241, 255, 241, 228, 241, 228 };
+
+static __u8 intensity_coeff[256] = {
+	0xFF, 0xFE, 0xFE, 0xFD, 0xFB, 0xF9, 0xF7, 0xF5,
+	0xF2, 0xEE, 0xEB, 0xE7, 0xE3, 0xDE, 0xD9, 0xD4,
+	0xCF, 0xCA, 0xC4, 0xBF, 0xB9, 0xB3, 0xAD, 0xA7,
+	0xA0, 0x9A, 0x94, 0x8E, 0x88, 0x82, 0x7C, 0x76,
+	0x70, 0x6A, 0x65, 0x5F, 0x5A, 0x55, 0x50, 0x4B,
+	0x46, 0x42, 0x3E, 0x3A, 0x36, 0x32, 0x2E, 0x2B,
+	0x28, 0x25, 0x22, 0x1F, 0x1D, 0x1A, 0x18, 0x16,
+	0x14, 0x12, 0x11, 0x0F, 0x0E, 0x0C, 0x0B, 0x0A,
+	0x09, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04,
+	0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+#ifdef UNUSED
+static __u8 hist_thres_drc[8] = { 25, 30, 50, 70, 110, 180, 200, 255 };
+#endif
+
+static __u8 hist_thres_pwrsv[8] = { 128, 147, 175, 199, 219, 235, 247, 255 };
+static __u8 drc_filter[IEP_LH_PWRSV_NUM] = { 9, 10, 11, 12, 14, 15, 17, 18,
+					     20, 22, 25, 27, 30, 33, 37, 41,
+					     45, 50, 55, 61, 67, 74, 82, 90 };
diff --git a/drivers/video/sunxi/disp/de_layer.c b/drivers/video/sunxi/disp/de_layer.c
new file mode 100644
index 0000000..3fd803e
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_layer.c
@@ -0,0 +1,496 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "de_be.h"
+
+__s32 DE_BE_Format_To_Bpp(__disp_pixel_fmt_t format)
+{
+	__u8 bpp = 0;
+
+	switch (format) {
+	case DISP_FORMAT_1BPP:
+		bpp = 1;
+		break;
+
+	case DISP_FORMAT_2BPP:
+		bpp = 2;
+		break;
+
+	case DISP_FORMAT_4BPP:
+		bpp = 4;
+		break;
+
+	case DISP_FORMAT_8BPP:
+		bpp = 8;
+		break;
+
+	case DISP_FORMAT_RGB655:
+	case DISP_FORMAT_RGB565:
+	case DISP_FORMAT_RGB556:
+	case DISP_FORMAT_ARGB1555:
+	case DISP_FORMAT_RGBA5551:
+	case DISP_FORMAT_ARGB4444:
+		bpp = 16;
+		break;
+	case DISP_FORMAT_RGB888:
+		bpp = 24;
+		break;
+	case DISP_FORMAT_ARGB888:
+		bpp = 32;
+		break;
+
+	case DISP_FORMAT_ARGB8888:
+		bpp = 32;
+		break;
+
+	case DISP_FORMAT_YUV444:
+		bpp = 24;
+		break;
+
+	case DISP_FORMAT_YUV422:
+		bpp = 16;
+		break;
+
+	case DISP_FORMAT_YUV420:
+	case DISP_FORMAT_YUV411:
+		bpp = 12;
+		break;
+
+	case DISP_FORMAT_CSIRGB:
+		bpp = 32; /* ? */
+		break;
+
+	default:
+		bpp = 0;
+		break;
+	}
+
+	return bpp;
+}
+
+__u32 DE_BE_Offset_To_Addr(__u32 src_addr, __u32 width, __u32 x, __u32 y,
+			   __u32 bpp)
+{
+	__u32 addr;
+
+	addr = src_addr + ((y * (width * bpp)) >> 3) + ((x * bpp) >> 3);
+
+	return addr;
+}
+
+__u32 DE_BE_Addr_To_Offset(__u32 src_addr, __u32 off_addr, __u32 width,
+			   __u32 bpp, __disp_pos_t *pos)
+{
+	__u32 dist;
+	__disp_pos_t offset;
+
+	dist = off_addr - src_addr;
+	offset.y = (dist << 3) / (width * bpp);
+	offset.x = ((dist << 3) % (width * bpp)) / bpp;
+	pos->x = offset.x;
+	pos->y = offset.y;
+
+	return 0;
+
+}
+
+__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx, __u8 mode)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+			 (tmp & 0xff3fffff) | mode << 22);
+
+	return 0;
+}
+
+/*
+ * bit
+ */
+static __s32 DE_BE_Layer_Set_Addr(__u32 sel, __u8 layidx, __u32 addr)
+{
+	__u32 tmp_l, tmp_h, tmp;
+	tmp_l = addr << 3;
+	tmp_h = (__u8) ((addr & 0xe0000000) >> 29);
+	DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_LOW32ADDR_OFF, layidx, tmp_l);
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_FRMBUF_HIGH4ADDR_OFF) &
+		(~(0xff << (layidx * 8)));
+	DE_BE_WUINT32(sel, DE_BE_FRMBUF_HIGH4ADDR_OFF,
+		      tmp | (tmp_h << (layidx * 8)));
+
+	return 0;
+}
+
+/*
+ * in bytes
+ */
+static __s32 DE_BE_Layer_Set_Line_Width(__u32 sel, __u8 layidx, __u32 width)
+{
+	DE_BE_WUINT32IDX(sel, DE_BE_FRMBUF_WLINE_OFF, layidx, width);
+	return 0;
+}
+
+__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx, __disp_pixel_fmt_t format,
+			     __bool br_swap, __u8 order)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF1, layidx);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF1, layidx,
+			 (tmp & 0xfffff000) | format << 8 | br_swap << 2 |
+			 order);
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx,
+				  layer_src_t *layer_fb)
+{
+	__s32 bpp;
+	__u32 addr;
+
+	bpp = DE_BE_Format_To_Bpp(layer_fb->format);
+	if (bpp <= 0)
+		return -1;
+
+	addr = DE_BE_Offset_To_Addr(layer_fb->fb_addr, layer_fb->fb_width,
+				    layer_fb->offset_x, layer_fb->offset_y,
+				    bpp);
+	DE_BE_Layer_Set_Format(sel, layidx, layer_fb->format, layer_fb->br_swap,
+			       layer_fb->pixseq);
+
+	DE_BE_Layer_Set_Addr(sel, layidx, addr);
+	DE_BE_Layer_Set_Line_Width(sel, layidx, layer_fb->fb_width * bpp);
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t *win)
+{
+	__u32 tmp;
+
+	tmp = ((((__u32) (win->y)) >> 31) << 31) |
+		((((__u32) (win->y)) & 0x7fff) << 16) |
+		((((__u32) (win->x)) >> 31) << 15) |
+		(((__u32) (win->x)) & 0x7fff);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_CRD_CTL_OFF, layidx, tmp);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_SIZE_OFF, layidx,
+			 (win->height - 1) << 16 | (win->width - 1));
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx, __bool video_en)
+{
+
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+			 (tmp & 0xfffffffd) | video_en << 1);
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Video_Ch_Sel(__u32 sel, __u8 layidx, __bool scaler_index)
+{
+
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+			 (tmp & 0xffffffef) | scaler_index << 4);
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx, __bool yuv_en)
+{
+
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+			 (tmp & 0xfffffffb) | yuv_en << 2);
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx, __u8 prio)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+			 (tmp & 0xfffff3ff) | prio << 10);
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx, __u8 pipe)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+			 (tmp & 0xffff7fff) | pipe << 15);
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+
+	__u32 tmp;
+
+	if (enable) {
+		tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+		DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+				 (tmp & 0xfff3ffff) | 1 << 18);
+	} else {
+		tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+		DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+				 (tmp & 0xfff3ffff));
+	}
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+	__u32 tmp;
+
+	if (enable) {
+		tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+		DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+				 (tmp & 0xfffffffe) | 0x01);
+	} else {
+		tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+		DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+				 (tmp & 0xfffffffe));
+	}
+
+	return 0;
+}
+
+/*
+ *
+ */
+__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx, __u8 alpha_val)
+{
+
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx);
+	DE_BE_WUINT32IDX(sel, DE_BE_LAYER_ATTRCTL_OFF0, layidx,
+			 (tmp & 0x0ffffff) | alpha_val << 24);
+
+	return 0;
+}
+
+__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable)
+{
+	if (enable) {
+		DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+			      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) |
+			      (1 << layidx) << 8);
+	} else {
+		DE_BE_WUINT32(sel, DE_BE_MODE_CTL_OFF,
+			      DE_BE_RUINT32(sel, DE_BE_MODE_CTL_OFF) &
+			      (~((1 << layidx) << 8)));
+	}
+
+	return 0;
+}
+
+/*
+ * todo
+ */
+static __s32 DE_BE_YUV_CH_Cfg_Csc_Coeff(__u32 sel, __u8 cs_mode)
+{
+	__u32 csc_coef_off;
+	__u32 *pdest_end;
+	__u32 *psrc_cur;
+	__u32 *pdest_cur;
+	__u32 temp;
+
+	csc_coef_off = (((cs_mode & 0x3) << 7) + ((cs_mode & 0x3) << 6)) +
+		0 /*yuv in */ + 0 /*rgb out */ ;
+
+	pdest_cur = (__u32 *) (DE_Get_Reg_Base(sel) + DE_BE_YG_COEFF_OFF);
+	psrc_cur = (__u32 *) (&csc_tab[csc_coef_off >> 2]);
+	pdest_end = pdest_cur + 12;
+
+	while (pdest_cur < pdest_end) {
+		temp = *(volatile __u32 *)pdest_cur;
+		temp &= 0xffff0000;
+		*(volatile __u32 *)pdest_cur++ =
+			((*psrc_cur++) & 0xffff) | temp;
+	}
+
+	return 0;
+}
+
+/*
+ * de be input YUV channel format setting
+ * parameters:
+ * format:
+ *   0: planar YUV 411
+ *   1: planar YUV 422
+ *   2: planar YUV 444
+ *   3: interleaved YUV 422
+ *   4: interleaved YUV 444
+ *
+ * pixel_seq:
+ *  - in planar data format mode
+ *    0:Y3Y2Y1Y0
+ *    1:Y0Y1Y2Y3
+ *  - in interleaved YUV 422 data format mode
+ *    0:DE_SCAL_UYVY
+ *    1:DE_SCAL_YUYV
+ *    2:DE_SCAL_VYUY
+ *    3:DE_SCAL_YVYU
+ *  - in interleaved YUV 444 format mode
+ *    0:DE_SCAL_AYUV
+ *    1:DE_SCAL_VUYA
+ */
+static __s32 DE_BE_YUV_CH_Set_Format(__u32 sel, __u8 format, __u8 pixel_seq)
+{
+	__u32 tmp;
+
+	tmp = DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF);
+	tmp &= 0xffff8cff; /* clear bit14:12, bit9:8 */
+	DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,
+		      tmp | (format << 12) | (pixel_seq << 8));
+
+	return 0;
+}
+
+static __s32 DE_BE_YUV_CH_Set_Addr(__u32 sel, __u8 ch_no, __u32 addr)
+{
+	/* address in bytes */
+	DE_BE_WUINT32IDX(sel, DE_BE_YUV_ADDR_OFF, ch_no, addr);
+	return 0;
+}
+
+static __s32 DE_BE_YUV_CH_Set_Line_Width(__u32 sel, __u8 ch_no, __u32 width)
+{
+	DE_BE_WUINT32IDX(sel, DE_BE_YUV_LINE_WIDTH_OFF, ch_no, width);
+	return 0;
+}
+
+__s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t *in_src)
+{
+	__u32 ch0_base, ch1_base, ch2_base;
+	__u32 image_w;
+	__u32 offset_x, offset_y;
+	__u8 in_fmt, in_mode, pixseq;
+	__u32 ch0_addr, ch1_addr, ch2_addr;
+	__u32 ch0_line_stride, ch1_line_stride, ch2_line_stride;
+	__u8 w_shift, h_shift;
+	__u32 de_scal_ch0_offset;
+	__u32 de_scal_ch1_offset;
+	__u32 de_scal_ch2_offset;
+
+	ch0_base = in_src->ch0_base;
+	ch1_base = in_src->ch1_base;
+	ch2_base = in_src->ch2_base;
+	image_w = in_src->line_width;
+	offset_x = in_src->offset_x;
+	offset_y = in_src->offset_y;
+	in_fmt = in_src->format;
+	in_mode = in_src->mode;
+	pixseq = in_src->pixseq;
+
+	w_shift = (in_fmt == 0x1
+		   || in_fmt == 0x3) ? 1 : ((in_fmt == 0x0) ? 2 : 0);
+	h_shift = 0;
+
+	/* modify offset and input size */
+	offset_x = (offset_x >> w_shift) << w_shift;
+	offset_y = (offset_y >> h_shift) << h_shift;
+	image_w = ((image_w + ((1 << w_shift) - 1)) >> w_shift) << w_shift;
+	/*
+	 * compute buffer address: the size ratio of Y/G to UV/RB must fit
+	 * with input format and mode
+	 */
+	if (in_mode == 0x00) { /* non macro block planar */
+		/* line stride */
+		ch0_line_stride = image_w;
+		ch1_line_stride = image_w >> (w_shift);
+		ch2_line_stride = image_w >> (w_shift);
+		/* buffer address */
+		de_scal_ch0_offset = image_w * offset_y + offset_x;
+		de_scal_ch1_offset = (image_w >> w_shift) *
+			(offset_y >> h_shift) +
+			(offset_x >> w_shift); /* image_w */
+		de_scal_ch2_offset = (image_w >> w_shift) *
+			(offset_y >> h_shift) +
+			(offset_x >> w_shift); /* image_w */
+
+		ch0_addr = ch0_base + de_scal_ch0_offset;
+		ch1_addr = ch1_base + de_scal_ch1_offset;
+		ch2_addr = ch2_base + de_scal_ch2_offset;
+	} else if (in_mode == 0x01) { /* interleaved data */
+		/* line stride */
+		ch0_line_stride = image_w << (0x02 - w_shift);
+		ch1_line_stride = 0x00;
+		ch2_line_stride = 0x00;
+		/* buffer address */
+		de_scal_ch0_offset =
+		    ((image_w * offset_y + offset_x) << (0x02 - w_shift));
+		de_scal_ch1_offset = 0x0;
+		de_scal_ch2_offset = 0x0;
+
+		ch0_addr = ch0_base + de_scal_ch0_offset;
+		ch1_addr = 0x00;
+		ch2_addr = 0x00;
+	} else {
+		return 0;
+	}
+
+	DE_BE_YUV_CH_Set_Format(sel, in_fmt, pixseq);
+	/* set line stride */
+	DE_BE_YUV_CH_Set_Line_Width(sel, 0x00, ch0_line_stride << 3);
+	DE_BE_YUV_CH_Set_Line_Width(sel, 0x01, ch1_line_stride << 3);
+	DE_BE_YUV_CH_Set_Line_Width(sel, 0x02, ch2_line_stride << 3);
+	/* set buffer address */
+	DE_BE_YUV_CH_Set_Addr(sel, 0x00, ch0_addr);
+	DE_BE_YUV_CH_Set_Addr(sel, 0x01, ch1_addr);
+	DE_BE_YUV_CH_Set_Addr(sel, 0x02, ch2_addr);
+
+	DE_BE_YUV_CH_Cfg_Csc_Coeff(sel, in_src->cs_mode);
+	return 0;
+}
+
+__s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable)
+{
+	if (enable) {
+		DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,
+			      DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF) |
+			      0x00000001);
+	} else {
+		DE_BE_WUINT32(sel, DE_BE_YUV_CTRL_OFF,
+			      DE_BE_RUINT32(sel, DE_BE_YUV_CTRL_OFF) &
+			      0xfffffffe);
+	}
+	return 0;
+}
diff --git a/drivers/video/sunxi/disp/de_lcdc.c b/drivers/video/sunxi/disp/de_lcdc.c
new file mode 100644
index 0000000..d5988b1
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_lcdc.c
@@ -0,0 +1,1529 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "ebios_lcdc_tve.h"
+#include "de_lcdc_i.h"
+#include "disp_display.h"
+
+static __u32 lcdc_reg_base0;
+static __u32 lcdc_reg_base1;
+
+#define ____SEPARATOR_LCDC____
+
+__s32 LCDC_set_reg_base(__u32 sel, __u32 address)
+{
+	if (sel == 0)
+		lcdc_reg_base0 = address;
+	else if (sel == 1)
+		lcdc_reg_base1 = address;
+
+	return 0;
+}
+
+__u32 LCDC_get_reg_base(__u32 sel)
+{
+	if (sel == 0)
+		return lcdc_reg_base0;
+	else if (sel == 1)
+		return lcdc_reg_base1;
+
+	return 0;
+}
+
+__s32 LCDC_init(__u32 sel)
+{
+	TCON0_close(sel);
+	TCON1_close(sel);
+
+	LCDC_enable_int(sel, LCDC_VBI_LCD_EN);
+	LCDC_enable_int(sel, LCDC_VBI_HD_EN);
+	LCDC_enable_int(sel, LCDC_LTI_LCD_EN);
+	LCDC_enable_int(sel, LCDC_LTI_HD_EN);
+
+	TCON0_select_src(sel, LCDC_SRC_DE1);
+	TCON1_select_src(sel, LCDC_SRC_DE1);
+
+	LCDC_open(sel);
+
+	return 0;
+}
+
+__s32 LCDC_exit(__u32 sel)
+{
+	LCDC_disable_int(sel, LCDC_VBI_LCD_EN | LCDC_VBI_HD_EN |
+			 LCDC_LTI_LCD_EN | LCDC_LTI_HD_EN);
+	LCDC_close(sel);
+	return 0;
+}
+
+void LCDC_open(__u32 sel)
+{
+	LCDC_SET_BIT(sel, LCDC_DCLK_OFF,
+		     LCDC_BIT31 | LCDC_BIT30 | LCDC_BIT29 | LCDC_BIT28);
+	LCDC_SET_BIT(sel, LCDC_GCTL_OFF, LCDC_BIT31);
+}
+
+void LCDC_close(__u32 sel)
+{
+	LCDC_CLR_BIT(sel, LCDC_DCLK_OFF,
+		     LCDC_BIT31 | LCDC_BIT30 | LCDC_BIT29 | LCDC_BIT28);
+	LCDC_CLR_BIT(sel, LCDC_GCTL_OFF, LCDC_BIT31);
+}
+
+__s32 LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay)
+{
+	__u32 tmp;
+
+	if (tcon_index == 0) {
+		/* clears bits 8:4 */
+		tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF) & 0xfffffe0f;
+		tmp |= ((delay & 0x1f) << 4);
+		LCDC_WUINT32(sel, LCDC_CTL_OFF, tmp);
+	} else if (tcon_index == 1) {
+		/* clear bit8:4 */
+		tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF) & 0xfffffe0f;
+		tmp |= ((delay & 0x1f) << 4);
+		LCDC_WUINT32(sel, LCDC_HDTVIF_OFF, tmp);
+	}
+	return 0;
+}
+
+__s32 LCDC_get_start_delay(__u32 sel, __u32 tcon_index)
+{
+	__u32 tmp;
+
+	if (tcon_index == 0) {
+		tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF) & 0x000001f0;
+		tmp >>= 4;
+		return tmp;
+	} else if (tcon_index == 1) {
+		tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF) & 0x000001f0;
+		tmp >>= 4;
+		return tmp;
+	}
+
+	return 0;
+}
+
+__u32 LCDC_get_cur_line(__u32 sel, __u32 tcon_index)
+{
+	__u32 tmp;
+
+	if (tcon_index == 0) {
+		tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF) & 0x03ff0000;
+		tmp >>= 16;
+	} else {
+		tmp = LCDC_RUINT32(sel, LCDC_DUBUG_OFF) & 0x00000fff;
+	}
+
+	return tmp;
+}
+
+__s32 LCDC_set_int_line(__u32 sel, __u32 tcon_index, __u32 num)
+{
+	__u32 tmp = 0;
+
+	tmp = LCDC_RUINT32(sel, LCDC_GINT0_OFF);
+
+	if (tcon_index == 0) {
+		LCDC_CLR_BIT(sel, LCDC_GINT0_OFF, 1 << 29);
+		LCDC_INIT_BIT(sel, LCDC_GINT1_OFF, 0x7ff << 16, num << 16);
+	} else {
+		LCDC_CLR_BIT(sel, LCDC_GINT0_OFF, 1 << 28);
+		LCDC_INIT_BIT(sel, LCDC_GINT1_OFF, 0x7ff, num);
+	}
+
+	LCDC_WUINT32(sel, LCDC_GINT0_OFF, tmp);
+
+	return 0;
+}
+
+__s32 LCDC_enable_int(__u32 sel, __u32 irqsrc)
+{
+	LCDC_SET_BIT(sel, LCDC_GINT0_OFF, irqsrc);
+	return 0;
+}
+
+__s32 LCDC_disable_int(__u32 sel, __u32 irqsrc)
+{
+	LCDC_CLR_BIT(sel, LCDC_GINT0_OFF, irqsrc);
+	return 0;
+}
+
+__u32 LCDC_query_int(__u32 sel)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT32(sel, LCDC_GINT0_OFF) & 0x0000f000;
+
+	return tmp;
+}
+
+__s32 LCDC_clear_int(__u32 sel, __u32 irqsrc)
+{
+	LCDC_CLR_BIT(sel, LCDC_GINT0_OFF, irqsrc);
+	return 0;
+}
+
+__s32 LCDC_get_timing(__u32 sel, __u32 index, struct fb_videomode *videomode)
+{
+	__u32 reg0, reg1, reg2, reg3;
+	__u32 x, y, ht, hbp, vt, vbp, hspw, vspw;
+
+	if (index == 0) {
+		reg0 = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
+		reg1 = LCDC_RUINT32(sel, LCDC_BASIC1_OFF);
+		reg2 = LCDC_RUINT32(sel, LCDC_BASIC2_OFF);
+		reg3 = LCDC_RUINT32(sel, LCDC_BASIC3_OFF);
+	} else {
+		reg0 = LCDC_RUINT32(sel, LCDC_HDTV0_OFF);
+		reg1 = LCDC_RUINT32(sel, LCDC_HDTV3_OFF);
+		reg2 = LCDC_RUINT32(sel, LCDC_HDTV4_OFF);
+		reg3 = LCDC_RUINT32(sel, LCDC_HDTV5_OFF);
+	}
+	x = (reg0 >> 16) & 0x7ff;
+	y = (reg0 >> 0) & 0x7ff;
+	ht = (reg1 >> 16) & 0xfff;
+	hbp = (reg1 >> 0) & 0xfff;
+	vt = (reg2 >> 16) & 0xfff;
+	vbp = (reg2 >> 0) & 0xfff;
+	hspw = (reg3 >> 16) & 0x3ff;
+	vspw = (reg3 >> 0) & 0x3ff;
+
+	/* left margin */
+	videomode->left_margin = (hbp + 1) - (hspw + 1);
+	/* right margin */
+	videomode->right_margin = (ht + 1) - (x + 1) - (hbp + 1);
+	/* upper margin */
+	videomode->upper_margin = (vbp + 1) - (vspw + 1);
+	/* lower margin */
+	videomode->lower_margin = (vt / 2) - (y + 1) - (vbp + 1);
+	/* hsync_len */
+	videomode->hsync_len = (hspw + 1);
+	/* vsync_len */
+	videomode->vsync_len = (vspw + 1);
+
+	return 0;
+}
+
+#define ____SEPARATOR_TCON0____
+
+__s32 TCON0_open(__u32 sel)
+{
+	LCDC_SET_BIT(sel, LCDC_CTL_OFF, LCDC_BIT31);
+	return 0;
+}
+
+__s32 TCON0_close(__u32 sel)
+{
+	LCDC_CLR_BIT(sel, LCDC_CTL_OFF, LCDC_BIT31);
+	LCDC_WUINT32(sel, LCDC_IOCTL1_OFF, 0xffffffff);	/* ? */
+	return 0;
+}
+
+void TCON0_cfg(__u32 sel, __panel_para_t *info)
+{
+	__u32 vblank_len;
+	__u32 lcd_if_reg = 0;
+	__u32 lcd_hv_if_tmp = 0;
+	__u32 lcd_hv_smode_tmp = 0;
+
+	vblank_len = info->lcd_vt / 2 - info->lcd_y;
+
+	if (vblank_len >= 32)
+		info->start_delay = 30;
+	else
+		info->start_delay = vblank_len - 2;
+
+	switch (info->lcd_if) {
+	case LCDC_LCDIF_HV:
+		lcd_if_reg = 0;
+		break;
+	case LCDC_LCDIF_CPU:
+		lcd_if_reg = 1;
+		break;
+	case LCDC_LCDIF_TTL:
+		lcd_if_reg = 2;
+		break;
+	case LCDC_LCDIF_LVDS:
+		lcd_if_reg = 0;
+		break;
+	}
+	if (info->lcd_hv_if == 0) {
+		lcd_hv_if_tmp = 0;
+		lcd_hv_smode_tmp = 0;
+	} else if (info->lcd_hv_if == 1) {
+		lcd_hv_if_tmp = 1;
+		lcd_hv_smode_tmp = 0;
+	} else if (info->lcd_hv_if == 2) {
+		lcd_hv_if_tmp = 1;
+		lcd_hv_smode_tmp = 1;
+	}
+
+	LCDC_INIT_BIT(sel, LCDC_CTL_OFF, 0x0ffffff0,
+		      (lcd_if_reg << 24) | (info->
+					    lcd_swap << 23) | (0 << 20) |
+		      (info->start_delay << 4));
+
+	LCDC_SET_BIT(sel, LCDC_DCLK_OFF, (__u32) 1 << 31);
+
+	LCDC_WUINT32(sel, LCDC_BASIC0_OFF,
+		     ((info->lcd_x - 1) << 16) | (info->lcd_y - 1));
+
+	LCDC_WUINT32(sel, LCDC_BASIC1_OFF,
+		     ((info->lcd_ht - 1) << 16) | (info->lcd_hbp - 1));
+
+	LCDC_WUINT32(sel, LCDC_BASIC2_OFF,
+		     (info->lcd_vt << 16) | (info->lcd_vbp - 1));
+
+	if (info->lcd_if == LCDC_LCDIF_HV) {
+		__u32 hspw_tmp = info->lcd_hv_hspw;
+		__u32 vspw_tmp = info->lcd_hv_vspw;
+
+		if (info->lcd_hv_hspw != 0)
+			hspw_tmp--;
+		if (info->lcd_hv_vspw != 0)
+			vspw_tmp--;
+		LCDC_WUINT32(sel, LCDC_BASIC3_OFF, (hspw_tmp << 16) | vspw_tmp);
+
+		LCDC_WUINT32(sel, LCDC_HVIF_OFF,
+			     (lcd_hv_if_tmp << 31) | (lcd_hv_smode_tmp << 30) |
+			     (info->lcd_hv_srgb_seq0 << 26) |
+			     (info->lcd_hv_srgb_seq1 << 24) |
+			     (info->lcd_hv_syuv_seq << 22) |
+			     (info->lcd_hv_syuv_fdly << 20));
+	} else if (info->lcd_if == LCDC_LCDIF_TTL) {
+		LCDC_WUINT32(sel, LCDC_TTL0_OFF,
+			     (info->lcd_ttl_stvh << 20) |
+			     (info->lcd_ttl_stvdl << 10) |
+			     (info->lcd_ttl_stvdp));
+
+		LCDC_WUINT32(sel, LCDC_TTL1_OFF,
+			     (info->lcd_ttl_ckvt << 30) |
+			     (info->lcd_ttl_ckvh << 10) |
+			     (info->lcd_ttl_ckvd << 0));
+
+		LCDC_WUINT32(sel, LCDC_TTL2_OFF,
+			     (info->lcd_ttl_oevt << 30) |
+			     (info->lcd_ttl_oevh << 10) |
+			     (info->lcd_ttl_oevd << 0));
+
+		LCDC_WUINT32(sel, LCDC_TTL3_OFF,
+			     (info->lcd_ttl_sthh << 26) |
+			     (info->lcd_ttl_sthd << 16) |
+			     (info->lcd_ttl_oehh << 10) |
+			     (info->lcd_ttl_oehd << 0));
+
+		LCDC_WUINT32(sel, LCDC_TTL4_OFF,
+			     (info->lcd_ttl_datarate << 23) |
+			     (info->lcd_ttl_revsel << 22) |
+			     (info->lcd_ttl_datainv_en << 21) |
+			     (info->lcd_ttl_datainv_sel << 20) |
+			     info->lcd_ttl_revd);
+
+	} else if (info->lcd_if == LCDC_LCDIF_CPU) {
+		LCDC_WUINT32(sel, LCDC_CPUIF_OFF,
+			     (info->lcd_cpu_if << 29) |
+			     (1 << 26));
+	} else if (info->lcd_if == LCDC_LCDIF_LVDS) {
+		LCDC_WUINT32(sel, LCDC_LVDS_OFF,
+			     (info->lcd_lvds_ch << 30) |
+			     (0 << 29) | (0 << 28) |
+			     (info->lcd_lvds_mode << 27) |
+			     (info->lcd_lvds_bitwidth << 26) | (0 << 23));
+
+		if (info->lcd_lvds_io_cross != 0)
+			LCDC_SET_BIT(sel, LCDC_LVDS_ANA1,
+				     (0x1f << 21) | (0x1f << 5));
+	}
+
+	if (info->lcd_frm == LCDC_FRM_RGB666)
+		LCDC_CLR_BIT(sel, LCDC_FRM0_OFF, (__u32) 0x7 << 4);
+	else if (info->lcd_frm == LCDC_FRM_RGB656)
+		LCDC_INIT_BIT(sel, LCDC_FRM0_OFF, 0x7 << 4, 0x5 << 4);
+	else
+		LCDC_CLR_BIT(sel, LCDC_FRM0_OFF, LCDC_BIT31);
+
+	if (info->lcd_frm == LCDC_FRM_RGB666 ||
+	    info->lcd_frm == LCDC_FRM_RGB656) {
+		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x00, 0x11111111);
+		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x04, 0x11111111);
+		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x08, 0x11111111);
+		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x0c, 0x11111111);
+		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x10, 0x11111111);
+		LCDC_WUINT32(sel, LCDC_FRM1_OFF + 0x14, 0x11111111);
+		LCDC_WUINT32(sel, LCDC_FRM2_OFF + 0x00, 0x01010000);
+		LCDC_WUINT32(sel, LCDC_FRM2_OFF + 0x04, 0x15151111);
+		LCDC_WUINT32(sel, LCDC_FRM2_OFF + 0x08, 0x57575555);
+		LCDC_WUINT32(sel, LCDC_FRM2_OFF + 0x0c, 0x7f7f7777);
+		LCDC_SET_BIT(sel, LCDC_FRM0_OFF, LCDC_BIT31);
+	}
+
+	if (info->lcd_gamma_correction_en) {
+		TCON1_set_gamma_table(sel, (__u32) (info->lcd_gamma_tbl), 1024);
+		TCON1_set_gamma_Enable(sel, 1);
+	} else if (!sunxi_is_sun5i())
+		TCON1_set_gamma_Enable(sel, 0);
+
+	LCDC_WUINT32(sel, LCDC_IOCTL0_OFF, info->lcd_io_cfg0);
+	LCDC_WUINT32(sel, LCDC_IOCTL1_OFF, info->lcd_io_cfg1);
+
+	LCDC_set_int_line(sel, 0, info->start_delay + 2);
+}
+
+__s32 TCON0_select_src(__u32 sel, enum lcdc_src src)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT32(sel, LCDC_CTL_OFF);
+	tmp = tmp & 0xffbffffc;
+
+	switch (src) {
+	case LCDC_SRC_DE1:
+		tmp = tmp | 0x00;
+		break;
+	case LCDC_SRC_DE2:
+		tmp = tmp | 0x01;
+		break;
+	case LCDC_SRC_DMA:
+		tmp = tmp | 0x02;
+		break;
+	case LCDC_SRC_WHITE:
+		tmp = tmp | 0x00400003;
+		break;
+	case LCDC_SRC_BLACK:
+		tmp = tmp | 0x03;
+		break;
+	default:
+		pr_warn("%s: unknown source %d\n", __func__, src);
+		break;
+	}
+
+	LCDC_WUINT32(sel, LCDC_CTL_OFF, tmp);
+	return 0;
+}
+
+__s32 TCON0_set_dclk_div(__u32 sel, __u8 div)
+{
+	LCDC_INIT_BIT(sel, LCDC_DCLK_OFF, 0xff, div);
+	return 0;
+}
+
+__u32 TCON0_get_dclk_div(__u32 sel)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT32(sel, LCDC_DCLK_OFF) & 0xff;
+
+	return tmp;
+}
+
+#define ____SEPARATOR_TCON1____
+
+__u32 TCON1_open(__u32 sel)
+{
+	LCDC_SET_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
+	return 0;
+}
+
+__u32 TCON1_close(__u32 sel)
+{
+	__u32 tmp;
+
+	LCDC_CLR_BIT(sel, LCDC_HDTVIF_OFF, LCDC_BIT31);
+
+	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);	/* ? */
+	tmp &= (~(1 << 0));	/* disable hdif */
+	LCDC_WUINT32(sel, LCDC_GCTL_OFF, tmp);
+
+	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, 0xffffffff);	/* ? */
+
+	if (sunxi_is_sun5i())
+		LCDC_CLR_BIT(sel, LCDC_MUX_CTRL, 1 << 0);
+
+	return 0;
+}
+
+__u32 TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg)
+{
+	__u32 vblank_len;
+	__u32 reg_val;
+
+	vblank_len = cfg->vt / 2 - cfg->src_y - 2;
+	if (vblank_len >= 32)
+		cfg->start_delay = 30;
+	else
+		cfg->start_delay = vblank_len - 2; /* was vblank_len - 1 */
+
+	if (cfg->b_remap_if)
+		LCDC_SET_BIT(sel, LCDC_GCTL_OFF, LCDC_BIT0);
+	else
+		LCDC_CLR_BIT(sel, LCDC_GCTL_OFF, LCDC_BIT0);
+
+	reg_val = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF);
+	reg_val &= 0xffeffe0f;
+	if (cfg->b_interlace)
+		reg_val |= (1 << 20);
+
+	reg_val |= ((cfg->start_delay & 0x1f) << 4);
+
+	LCDC_WUINT32(sel, LCDC_HDTVIF_OFF, reg_val);
+
+	LCDC_WUINT32(sel, LCDC_HDTV0_OFF, (((cfg->src_x - 1) & 0xfff) << 16) |
+		     ((cfg->src_y - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV1_OFF, (((cfg->scl_x - 1) & 0xfff) << 16) |
+		     ((cfg->scl_y - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV2_OFF, (((cfg->out_x - 1) & 0xfff) << 16) |
+		     ((cfg->out_y - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV3_OFF, (((cfg->ht - 1) & 0xffff) << 16) |
+		     ((cfg->hbp - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV4_OFF, (((cfg->vt) & 0xffff) << 16) |
+		     ((cfg->vbp - 1) & 0xfff));
+	LCDC_WUINT32(sel, LCDC_HDTV5_OFF, (((cfg->hspw - 1) & 0x3ff) << 16) |
+		     ((cfg->vspw - 1) & 0x3ff));
+	LCDC_WUINT32(sel, LCDC_IOCTL2_OFF, cfg->io_pol); /* add */
+	LCDC_WUINT32(sel, LCDC_IOCTL3_OFF, cfg->io_out); /* add */
+
+	LCDC_set_int_line(sel, 1, cfg->start_delay + 2);
+
+	return 0;
+}
+
+__u32 TCON1_cfg_ex(__u32 sel, __panel_para_t *info)
+{
+	__tcon1_cfg_t tcon1_cfg;
+
+	tcon1_cfg.b_interlace = 0;
+	tcon1_cfg.b_rgb_internal_hd = 0;
+	tcon1_cfg.b_rgb_remap_io = 1; /* rgb */
+	tcon1_cfg.b_remap_if = 1; /* remap tcon1 to io */
+	tcon1_cfg.src_x = info->lcd_x;
+	tcon1_cfg.src_y = info->lcd_y;
+	tcon1_cfg.scl_x = info->lcd_x;
+	tcon1_cfg.scl_y = info->lcd_y;
+	tcon1_cfg.out_x = info->lcd_x;
+	tcon1_cfg.out_y = info->lcd_y;
+	tcon1_cfg.ht = info->lcd_ht;
+	tcon1_cfg.hbp = info->lcd_hbp;
+	tcon1_cfg.vt = info->lcd_vt;
+	tcon1_cfg.vbp = info->lcd_vbp;
+	tcon1_cfg.vspw = info->lcd_hv_vspw;
+	tcon1_cfg.hspw = info->lcd_hv_hspw;
+	tcon1_cfg.io_pol = info->lcd_io_cfg0;
+	tcon1_cfg.io_out = info->lcd_io_cfg1;
+
+	TCON1_cfg(sel, &tcon1_cfg);
+
+	return 0;
+}
+
+__u32 TCON1_set_hdmi_mode(__u32 sel, __u8 mode)
+{
+	__tcon1_cfg_t cfg;
+	struct __disp_video_timing video_timing;
+	int extra_y;
+
+	if (gdisp.init_para.hdmi_get_video_timing(mode, &video_timing) != 0)
+		return 0;
+
+	if (video_timing.I)
+		video_timing.INPUTY /= 2;
+
+	cfg.b_interlace = video_timing.I;
+	cfg.src_x = video_timing.INPUTX;
+	cfg.src_y = video_timing.INPUTY;
+	cfg.scl_x = video_timing.INPUTX;
+	cfg.scl_y = video_timing.INPUTY;
+	cfg.out_x = video_timing.INPUTX;
+	cfg.out_y = video_timing.INPUTY;
+	cfg.ht    = video_timing.HT;
+	cfg.hbp   = video_timing.HBP;
+	cfg.hspw  = video_timing.HPSW;
+	cfg.vt    = video_timing.VT;
+	cfg.vbp   = video_timing.VBP;
+	cfg.vspw  = video_timing.VPSW;
+	cfg.io_pol = 0x04000000; /* HDG: unknow bit must be set */
+	/*
+	 * HDG: Note I'm not sure if I don't have Hsync versus Vsync swapped,
+	 * does not matter for standard modes which are NN or PP, but could
+	 * impact EDID.
+	 */
+	if (video_timing.HSYNC)
+		cfg.io_pol |= 0x01000000; /* Positive Hsync */
+	if (video_timing.VSYNC)
+		cfg.io_pol |= 0x02000000; /* Positive Vsync */
+
+	switch (mode) {
+	case DISP_TV_MOD_1080P_24HZ_3D_FP:
+	case DISP_TV_MOD_720P_50HZ_3D_FP:
+	case DISP_TV_MOD_720P_60HZ_3D_FP:
+		if (mode == DISP_TV_MOD_1080P_24HZ_3D_FP)
+			extra_y = 45;
+		else
+			extra_y = 30;
+		LCDC_WUINT32(sel, LCDC_3DF_A1B, (cfg.vt + 1) << 12);
+		LCDC_WUINT32(sel, LCDC_3DF_A1E, (cfg.vt + extra_y) << 12);
+		LCDC_WUINT32(sel, LCDC_3DF_D1, 0);
+		LCDC_SET_BIT(sel, LCDC_3DF_CTL, 1 << 31);
+		cfg.scl_y += extra_y;
+		cfg.out_y += extra_y;
+		cfg.vt *= 2;
+		break;
+	}
+
+	if (!cfg.b_interlace)
+		cfg.vt *= 2;
+
+	cfg.io_out = 0x00000000;
+	cfg.b_rgb_internal_hd = 0;
+	cfg.b_rgb_remap_io = 1;	/* rgb */
+	cfg.b_remap_if = 1;
+	TCON1_cfg(sel, &cfg);
+	if (!sunxi_is_sun5i())
+		TCON_set_hdmi_src(sel);
+
+	return 0;
+}
+
+__u32 TCON1_set_tv_mode(__u32 sel, __u8 mode)
+{
+	__tcon1_cfg_t cfg;
+
+	switch (mode) {
+	case DISP_TV_MOD_576I:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL_NC:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+		cfg.b_interlace = 1;
+		cfg.src_x = 720;
+		cfg.src_y = 288;
+		cfg.scl_x = 720;
+		cfg.scl_y = 288;
+		cfg.out_x = 720;
+		cfg.out_y = 288;
+		cfg.ht = 864;
+		cfg.hbp = 139;
+		cfg.vt = 625;
+		cfg.vbp = 22;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_480I:
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_NTSC_SVIDEO:
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+		cfg.b_interlace = 1;
+		cfg.src_x = 720;
+		cfg.src_y = 240;
+		cfg.scl_x = 720;
+		cfg.scl_y = 240;
+		cfg.out_x = 720;
+		cfg.out_y = 240;
+		cfg.ht = 858;
+		cfg.hbp = 118;
+		cfg.vt = 525;
+		cfg.vbp = 18;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_480P:
+		cfg.b_interlace = 0;
+		cfg.src_x = 720;
+		cfg.src_y = 480;
+		cfg.scl_x = 720;
+		cfg.scl_y = 480;
+		cfg.out_x = 720;
+		cfg.out_y = 480;
+		cfg.ht = 858;
+		cfg.hbp = 118;
+		cfg.vt = 1050;
+		cfg.vbp = 22;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_576P:
+		cfg.b_interlace = 0;
+		cfg.src_x = 720;
+		cfg.src_y = 576;
+		cfg.scl_x = 720;
+		cfg.scl_y = 576;
+		cfg.out_x = 720;
+		cfg.out_y = 576;
+		cfg.ht = 864;
+		cfg.hbp = 139;
+		cfg.vt = 1250;
+		cfg.vbp = 22;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_720P_50HZ:
+		cfg.b_interlace = 0;
+		cfg.src_x = 1280;
+		cfg.src_y = 720;
+		cfg.scl_x = 1280;
+		cfg.scl_y = 720;
+		cfg.out_x = 1280;
+		cfg.out_y = 720;
+		cfg.ht = 1980;
+		cfg.hbp = 260;
+		cfg.vt = 1500;
+		cfg.vbp = 24;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_720P_60HZ:
+		cfg.b_interlace = 0;
+		cfg.src_x = 1280;
+		cfg.src_y = 720;
+		cfg.scl_x = 1280;
+		cfg.scl_y = 720;
+		cfg.out_x = 1280;
+		cfg.out_y = 720;
+		cfg.ht = 1650;
+		cfg.hbp = 260;
+		cfg.vt = 1500;
+		cfg.vbp = 24;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_1080I_50HZ:
+		cfg.b_interlace = 0;
+		cfg.src_x = 1920;
+		cfg.src_y = 540;
+		cfg.scl_x = 1920;
+		cfg.scl_y = 540;
+		cfg.out_x = 1920;
+		cfg.out_y = 540;
+		cfg.ht = 2640;
+		cfg.hbp = 192;
+		cfg.vt = 1125;
+		cfg.vbp = 16;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_1080I_60HZ:
+		cfg.b_interlace = 1;
+		cfg.src_x = 1920;
+		cfg.src_y = 540;
+		cfg.scl_x = 1920;
+		cfg.scl_y = 540;
+		cfg.out_x = 1920;
+		cfg.out_y = 540;
+		cfg.ht = 2200;
+		cfg.hbp = 192;
+		cfg.vt = 1125;
+		cfg.vbp = 16;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_1080P_50HZ:
+		cfg.b_interlace = 0;
+		cfg.src_x = 1920;
+		cfg.src_y = 1080;
+		cfg.scl_x = 1920;
+		cfg.scl_y = 1080;
+		cfg.out_x = 1920;
+		cfg.out_y = 1080;
+		cfg.ht = 2640;
+		cfg.hbp = 192;
+		cfg.vt = 2250;
+		cfg.vbp = 44;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	case DISP_TV_MOD_1080P_60HZ:
+		cfg.b_interlace = 0;
+		cfg.src_x = 1920;
+		cfg.src_y = 1080;
+		cfg.scl_x = 1920;
+		cfg.scl_y = 1080;
+		cfg.out_x = 1920;
+		cfg.out_y = 1080;
+		cfg.ht = 2200;
+		cfg.hbp = 192;
+		cfg.vt = 2250;
+		cfg.vbp = 44;
+		cfg.vspw = 2;
+		cfg.hspw = 2;
+		break;
+
+	default:
+		return 0;
+	}
+	cfg.io_pol = 0x00000000;
+	cfg.io_out = 0x0fffffff;
+	cfg.b_rgb_internal_hd = 0; /* yuv */
+	cfg.b_rgb_remap_io = 0;
+	cfg.b_remap_if = 0;
+	TCON1_cfg(sel, &cfg);
+
+	if (!sunxi_is_sun5i())
+		TCON_set_tv_src(sel, sel);
+	else
+		LCDC_SET_BIT(sel, LCDC_MUX_CTRL, 1 << 0);
+
+	return 0;
+}
+
+/*
+ * set mode
+ */
+__s32 TCON1_set_vga_mode(__u32 sel, __u8 mode)
+{
+	__tcon1_cfg_t cfg;
+
+	switch (mode) {
+	case DISP_VGA_H640_V480:
+		cfg.src_x = cfg.scl_x = cfg.out_x = 640; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 480; /* VA */
+		cfg.ht = 0x320; /* HT - 1 = -1 */
+		cfg.hbp = 0x90; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x41a; /* VT * 2 = * 2 */
+		cfg.vbp = 0x22; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x2; /* VS - 1 = -1 */
+		cfg.hspw = 0x60; /* HS - 1 = -1 */
+		break;
+	case DISP_VGA_H800_V600:
+		cfg.src_x = cfg.scl_x = cfg.out_x = 800; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 600; /* VA */
+		cfg.ht = 0x420; /* HT - 1 = -1 */
+		cfg.hbp = 0xd8; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x4e8; /* VT * 2 = * 2 */
+		cfg.vbp = 0x1a; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x4; /* VS - 1 = -1 */
+		cfg.hspw = 0x80; /* HS - 1 = -1 */
+		break;
+	case DISP_VGA_H1024_V768:
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1024;
+		cfg.src_y = cfg.scl_y = cfg.out_y = 768;
+		cfg.ht = 1344; /* HT - 1 = 1344 - 1 */
+		cfg.hbp = 296; /* HS + HBP - 1 = 136 + 160 - 1 */
+		cfg.vt = 1612; /* VT * 2 = 806 * 2 */
+		cfg.vbp = 34; /* VS + VBP - 1 = 6 + 29 - 1 */
+		cfg.vspw = 6; /* VS - 1 = 6 - 1 */
+		cfg.hspw = 136;	/* HS - 1 = 136 - 1 */
+		break;
+	case DISP_VGA_H1280_V1024:
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1280; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 1024; /* VA */
+		cfg.ht = 0x698; /* HT - 1 = -1 */
+		cfg.hbp = 0x168; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x854; /* VT * 2 = * 2 */
+		cfg.vbp = 0x28; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x3; /* VS - 1 = -1 */
+		cfg.hspw = 0x70; /* HS - 1 = -1 */
+		break;
+	case DISP_VGA_H1360_V768:
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1360; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 768; /* VA */
+		cfg.ht = 0x700; /* HT - 1 = -1 */
+		cfg.hbp = 0x170; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x636; /* VT * 2 = * 2 */
+		cfg.vbp = 0x17; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x6; /* VS - 1 = -1 */
+		cfg.hspw = 0x70; /* HS - 1 = -1 */
+		break;
+	case DISP_VGA_H1440_V900:
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1440; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 900; /* VA */
+		cfg.ht = 0x770; /* HT - 1 = -1 */
+		cfg.hbp = 0x180; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 0x74c; /* VT * 2 = * 2 */
+		cfg.vbp = 0x1e; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 0x6; /* VS - 1 = -1 */
+		cfg.hspw = 0x98; /* HS - 1 = -1 */
+		break;
+	case DISP_VGA_H1680_V1050:
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1680; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 1050; /* VA */
+		cfg.ht = 2240; /* HT - 1 = -1 */
+		cfg.hbp = 464; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 2178; /* VT * 2 = * 2 */
+		cfg.vbp = 35; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 6; /* VS - 1 = -1 */
+		cfg.hspw = 176; /* HS - 1 = -1 */
+		break;
+	case DISP_VGA_H1920_V1080_RB:
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1920; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 1080; /* VA */
+		cfg.ht = 2017; /* HT - 1 = -1 */
+		cfg.hbp = 63; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 2222; /* VT * 2 = * 2 */
+		cfg.vbp = 27; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 5; /* VS - 1 = -1 */
+		cfg.hspw = 32; /* HS - 1 = -1 */
+		break;
+	case DISP_VGA_H1920_V1080: /* TBD */
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1920; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 1080; /* VA */
+		cfg.ht = 2200; /* HT - 1 = -1 */
+		cfg.hbp = 148 + 44; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 1125 * 2; /* VT * 2 = * 2 */
+		cfg.vbp = 36 + 5; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 5; /* VS - 1 = -1 */
+		cfg.hspw = 44; /* HS - 1 = -1 */
+		cfg.io_pol = 0x03000000;
+		break;
+	case DISP_VGA_H1280_V720: /* TBD */
+		cfg.src_x = cfg.scl_x = cfg.out_x = 1280; /* HA */
+		cfg.src_y = cfg.scl_y = cfg.out_y = 720; /* VA */
+		cfg.ht = 1650; /* HT - 1 = -1 */
+		cfg.hbp = 220 + 40; /* HS + HBP - 1 = +- 1 */
+		cfg.vt = 750 * 2; /* VT * 2 = * 2 */
+		cfg.vbp = 5 + 20; /* VS + VBP - 1 = +- 1 */
+		cfg.vspw = 5; /* VS - 1 = -1 */
+		cfg.hspw = 40; /* HS - 1 = -1 */
+		cfg.io_pol = 0x03000000;
+		break;
+	default:
+		return 0;
+	}
+	cfg.b_interlace = 0;
+	cfg.io_pol = 0x00000000;
+	cfg.io_out = 0x0cffffff; /* hs vs is use */
+	cfg.b_rgb_internal_hd = 1; /* rgb */
+	cfg.b_rgb_remap_io = 0;
+	cfg.b_remap_if = 1;
+	TCON1_cfg(sel, &cfg);
+
+	if (!sunxi_is_sun5i())
+		TCON_set_tv_src(sel, sel);
+
+	return 0;
+}
+
+__s32 TCON1_select_src(__u32 sel, enum lcdc_src src)
+{
+	__u32 tv_tmp;
+
+	tv_tmp = LCDC_RUINT32(sel, LCDC_HDTVIF_OFF);
+
+	tv_tmp = tv_tmp & 0xfffffffc;
+
+	switch (src) {
+	case LCDC_SRC_DE1:
+		tv_tmp = tv_tmp | 0x00;
+		break;
+	case LCDC_SRC_DE2:
+		tv_tmp = tv_tmp | 0x01;
+		break;
+	case LCDC_SRC_BLUE:
+		tv_tmp = tv_tmp | 0x02;
+		break;
+	default:
+		pr_warn("%s: unknown source %d\n", __func__, src);
+		break;
+	}
+
+	LCDC_WUINT32(sel, LCDC_HDTVIF_OFF, tv_tmp);
+
+	return 0;
+}
+
+/*
+ * ???
+ */
+__bool TCON1_in_valid_regn(__u32 sel, __u32 juststd)
+{
+	__u32 readval;
+	__u32 SY2;
+	__u32 VT;
+
+	readval = LCDC_RUINT32(sel, LCDC_HDTV4_OFF);
+	VT = (readval & 0xffff0000) >> 17;
+
+	readval = LCDC_RUINT32(sel, LCDC_DUBUG_OFF);
+	SY2 = (readval) & 0xfff;
+
+	if ((SY2 < juststd) || (SY2 > VT))
+		return 1;
+	else
+		return 0;
+
+}
+
+/*
+ * add nex time
+ */
+__s32 TCON1_set_gamma_table(__u32 sel, __u32 address, __u32 size)
+{
+	__u32 tmp;
+
+	__s32 *pmem_align_dest;
+	__s32 *pmem_align_src;
+	__s32 *pmem_dest_cur;
+
+	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
+	/* disable gamma correction sel */
+	LCDC_WUINT32(sel, LCDC_GCTL_OFF, tmp & (~(1 << 30)));
+
+	pmem_dest_cur = (__s32 *)
+		(LCDC_get_reg_base(sel) + LCDC_GAMMA_TABLE_OFF);
+	pmem_align_src = (__s32 *) address;
+	pmem_align_dest = pmem_dest_cur + (size >> 2);
+
+	while (pmem_dest_cur < pmem_align_dest)
+		*(volatile __u32 *)pmem_dest_cur++ = *pmem_align_src++;
+
+	LCDC_WUINT32(sel, LCDC_GCTL_OFF, tmp);
+
+	return 0;
+}
+
+__s32 TCON1_set_gamma_Enable(__u32 sel, __bool enable)
+{
+	__u32 tmp;
+
+	tmp = LCDC_RUINT32(sel, LCDC_GCTL_OFF);
+	if (enable)
+		LCDC_WUINT32(sel, LCDC_GCTL_OFF, tmp | (1 << 30));
+	else
+		LCDC_WUINT32(sel, LCDC_GCTL_OFF, tmp & (~(1 << 30)));
+
+	return 0;
+}
+
+#define ____SEPARATOR_CPU____
+
+#if 0
+__asm void my_stmia(int addr, int data1, int data2)
+{
+	stmia r0!, {r1,r2}
+	BX    lr
+}
+#endif
+
+#ifdef UNUSED
+static void
+LCD_CPU_Burst_Write(__u32 sel, int addr, int data1, int data2)
+{
+	//my_stmia(LCDC_GET_REG_BASE(sel) + addr,data1,data2);
+}
+#endif /* UNUSED */
+
+static __u32
+LCD_CPU_Busy(__u32 sel)
+{
+	volatile __u32 i;
+	__u32 counter = 0;
+	__u32 reg_val;
+
+	if (sunxi_is_sun5i())
+		return LCDC_RUINT32(sel, LCDC_CPUIF_OFF) &
+						(LCDC_BIT23 | LCDC_BIT22);
+
+	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT0);
+	for (i = 0; i < 80; i++)
+		;
+
+	while (1) {
+		reg_val = LCDC_RUINT32(sel, LCDC_CPUIF_OFF);
+		if (reg_val & 0x00c00000) {
+			if (counter > 200)
+				return 0;
+			else
+				counter++;
+		} else {
+			return 0;
+		}
+	}
+}
+
+static void
+LCD_CPU_WR_INDEX_24b(__u32 sel, __u32 index)
+{
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+	LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT25); /* ca = 0 */
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+	/* write data on 8080 bus */
+	LCDC_WUINT32(sel, LCDC_CPUWR_OFF, index);
+
+#if 0
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+#endif
+}
+
+static void
+LCD_CPU_WR_DATA_24b(__u32 sel, __u32 data)
+{
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+	LCDC_SET_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT25); /* ca = 1 */
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+	LCDC_WUINT32(sel, LCDC_CPUWR_OFF, data);
+
+#if 0
+	while (LCD_CPU_Busy(sel)) /* check wr finish */
+		;
+#endif
+}
+
+static void
+LCD_CPU_WR_24b(__u32 sel, __u32 index, __u32 data)
+{
+	LCD_CPU_WR_INDEX_24b(sel, index);
+	LCD_CPU_WR_DATA_24b(sel, data);
+}
+
+#ifdef UNUSED
+static void
+LCD_CPU_RD_24b(__u32 sel, __u32 index, __u32 *data)
+{
+}
+#endif
+
+/*
+ * 16bit
+ */
+static __u32
+LCD_CPU_IO_extend_16b(__u32 value)
+{
+	return ((value & 0xfc00) << 8) |
+		((value & 0x0300) << 6) |
+		((value & 0x00e0) << 5) |
+		((value & 0x001f) << 3);
+}
+
+#ifdef UNUSED
+static __u32
+LCD_CPU_IO_shrink_16b(__u32 value)
+{
+	return ((value & 0xfc0000) >> 8) |
+		((value & 0x00c000) >> 6) |
+		((value & 0x001c00) >> 5) |
+		((value & 0x0000f8) >> 3);
+}
+#endif
+
+void LCD_CPU_WR(__u32 sel, __u32 index, __u32 data)
+{
+	LCD_CPU_WR_24b(sel, LCD_CPU_IO_extend_16b(index),
+		       LCD_CPU_IO_extend_16b(data));
+}
+EXPORT_SYMBOL(LCD_CPU_WR);
+
+void LCD_CPU_WR_INDEX(__u32 sel, __u32 index)
+{
+	LCD_CPU_WR_INDEX_24b(sel, LCD_CPU_IO_extend_16b(index));
+}
+EXPORT_SYMBOL(LCD_CPU_WR_INDEX);
+
+void LCD_CPU_WR_DATA(__u32 sel, __u32 data)
+{
+	LCD_CPU_WR_DATA_24b(sel, LCD_CPU_IO_extend_16b(data));
+}
+EXPORT_SYMBOL(LCD_CPU_WR_DATA);
+
+void LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data)
+{
+}
+
+void LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en)
+{
+	if (en == 0)
+		LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT28);
+	else
+		LCDC_SET_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT28);
+}
+EXPORT_SYMBOL(LCD_CPU_AUTO_FLUSH);
+
+void LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en)
+{
+	if (en == 0)
+		LCDC_CLR_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT27);
+	else
+		LCDC_SET_BIT(sel, LCDC_CPUIF_OFF, LCDC_BIT27);
+}
+
+void LCD_XY_SWAP(__u32 sel)
+{
+	__u32 reg, x, y;
+
+	reg = LCDC_RUINT32(sel, LCDC_BASIC0_OFF);
+	y = reg & 0x7ff;
+	x = (reg >> 16) & 0x7ff;
+	LCDC_WUINT32(sel, LCDC_BASIC0_OFF, (y << 16) | x);
+}
+
+__s32 LCD_LVDS_open(__u32 sel)
+{
+	__u32 i;
+
+	LCDC_SET_BIT(sel, LCDC_LVDS_OFF, (__u32) 1 << 31);
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0, 0x3F310000);
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0, 1 << 22);
+	for (i = 0; i < 1200; i++) /* 1200ns */
+		;
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1, 0x1f << 26 | 0x1f << 10);
+	for (i = 0; i < 120; i++) /* 120ns */
+		;
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA1, 0x1f << 16 | 0x1f << 00);
+	LCDC_SET_BIT(sel, LCDC_LVDS_ANA0, 1 << 22);
+
+	return 0;
+}
+
+__s32 LCD_LVDS_close(__u32 sel)
+{
+	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA1, 0x1f << 16 | 0x1f << 00);
+	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA1, 0x1f << 26 | 0x1f << 10);
+	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA0, 1 << 22);
+	LCDC_CLR_BIT(sel, LCDC_LVDS_ANA0, 0x3F310000);
+	LCDC_CLR_BIT(sel, LCDC_LVDS_OFF, (__u32) 1 << 31);
+	return 0;
+}
+
+#define ____TCON_MUX_CTL____
+
+__u8 TCON_mux_init(void)
+{
+	LCDC_CLR_BIT(0, LCDC_MUX_CTRL, LCDC_BIT31);
+	LCDC_INIT_BIT(0, LCDC_MUX_CTRL, 0xf << 4, 0 << 4);
+	LCDC_INIT_BIT(0, LCDC_MUX_CTRL, 0xf, 1);
+	return 0;
+}
+
+__u8 TCON_set_hdmi_src(__u8 src)
+{
+	LCDC_INIT_BIT(0, LCDC_MUX_CTRL, 0x3 << 8, src << 8);
+	return 0;
+}
+
+__u8 TCON_set_tv_src(__u32 tv_index, __u8 src)
+{
+	if (tv_index == 0)
+		LCDC_INIT_BIT(0, LCDC_MUX_CTRL, 0x3 << 4, src << 4);
+	else
+		LCDC_INIT_BIT(0, LCDC_MUX_CTRL, 0x3 << 0, src << 0);
+
+	return 0;
+}
+
+#ifdef UNUSED
+#define ____TCON_CEU____
+
+static __u32 range_cut(__s32 *x_value, __s32 x_min, __s32 x_max)
+{
+	if (*x_value > x_max) {
+		*x_value = x_max;
+		return 1;
+	} else if (*x_value < x_min) {
+		*x_value = x_min;
+		return 1;
+	} else
+		return 0;
+}
+
+static void rect_multi(__s32 *dest, __s32 *src1, __s32 *src2)
+{
+	__u32 x, y, z;
+	__s64 val_int64;
+
+	for (x = 0; x < 4; x++)
+		for (y = 0; y < 4; y++) {
+			val_int64 = 0;
+			for (z = 0; z < 4; z++)
+				val_int64 += (__s64)
+					src1[x * 4 + z] * src2[z * 4 + y];
+			val_int64 = (val_int64 + 512) >> 10;
+			dest[x * 4 + y] = val_int64;
+		}
+}
+
+static __s32 reg_corr(__s32 val, __u32 bit)
+{
+	if (val >= 0)
+		return val;
+	else
+		return (bit) | (__u32) (-val);
+}
+
+static void rect_ceu_pro(__s32 *p_rect, __s32 b, __s32 c, __s32 s, __s32 h)
+{
+	const __u8 table_sin[91] = {
+		0, 2, 4, 7, 9, 11, 13, 16, 18, 20,
+		22, 24, 27, 29, 31, 33, 35, 37, 40, 42,
+		44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
+		64, 66, 68, 70, 72, 73, 75, 77, 79, 81,
+		82, 84, 86, 87, 89, 91, 92, 94, 95, 97,
+		98, 99, 101, 102, 104, 105, 106, 107, 109, 110,
+		111, 112, 113, 114, 115, 116, 117, 118, 119, 119,
+		120, 121, 122, 122, 123, 124, 124, 125, 125, 126,
+		126, 126, 127, 127, 127, 128, 128, 128, 128, 128,
+		128
+	};
+
+	const __s32 f_csh = 1024;
+	const __s32 f_sh = 8;
+	__s32 h1 = 0, h2 = 0, h3 = 0, h4 = 0;
+
+	if (h >= 0 && h < 90) {
+		h1 = table_sin[90 - h];
+		h2 = table_sin[h];
+		h3 = -table_sin[h];
+		h4 = table_sin[90 - h];
+	} else if (h >= 90 && h < 180) {
+		h1 = -table_sin[h - 90];
+		h2 = table_sin[180 - h];
+		h3 = -table_sin[180 - h];
+		h4 = -table_sin[h - 90];
+	} else if (h >= 180 && h < 270) {
+		h1 = -table_sin[270 - h];
+		h2 = -table_sin[h - 180];
+		h3 = table_sin[h - 180];
+		h4 = -table_sin[270 - h];
+	} else if (h >= 270 && h <= 360) {
+		h1 = table_sin[h - 270];
+		h2 = -table_sin[360 - h];
+		h3 = table_sin[360 - h];
+		h4 = table_sin[h - 270];
+	}
+
+	p_rect[0] = c * f_sh;
+	p_rect[1] = 0;
+	p_rect[2] = 0;
+	p_rect[3] = -16 * c * f_sh + (b + 16) * f_csh;
+	p_rect[4] = 0;
+	p_rect[5] = (c * s * h1) >> 11;
+	p_rect[6] = (c * s * h2) >> 11;
+	p_rect[7] = 128 * (1 * f_csh - p_rect[5] - p_rect[6]);
+	p_rect[8] = 0;
+	p_rect[9] = (c * s * h3) >> 11;
+	p_rect[10] = (c * s * h4) >> 11;
+	p_rect[11] = 128 * (1 * f_csh - p_rect[9] - p_rect[10]);
+	p_rect[12] = 0;
+	p_rect[13] = 0;
+	p_rect[14] = 0;
+	p_rect[15] = 1024;
+}
+
+static void lcd_ceu(__u32 r2y_type, __u32 cen_type, __u32 y2r_type, __s32 b,
+		    __s32 c, __s32 s, __s32 h, __s32 *p_coff)
+{
+	const __s32 rect_1[16] = {
+		1024, 0, 0, 0,
+		0, 1024, 0, 0,
+		0, 0, 1024, 0,
+		0, 0, 0, 1024
+	};
+
+	const __s32 rect_r2y_sd[16] = {
+		263, 516, 100, 16384,
+		-152, -298, 450, 131072,
+		450, -377, -73, 131072,
+		0, 0, 0, 1024
+	};
+
+	const __s32 rect_r2y_hd[16] = {
+		187, 629, 63, 16384,
+		-103, -346, 450, 131072,
+		450, -409, -41, 131072,
+		0, 0, 0, 1024
+	};
+
+	const __s32 rect_y2r_sd[16] = {
+		1192, 0, 1634, -228262,
+		1192, -400, -833, 138740,
+		1192, 2066, 0, -283574,
+		0, 0, 0, 1024
+	};
+
+	const __s32 rect_y2r_hd[16] = {
+		1192, 0, 1836, -254083,
+		1192, -218, -547, 78840,
+		1192, 2166, 0, -296288,
+		0, 0, 0, 1024
+	};
+
+	__s32 rect_tmp0[16];
+	__s32 rect_tmp1[16];
+
+	__s32 *p_rect = 0;
+	__s32 *p_r2y = 0;
+	__s32 *p_y2r = 0;
+	__s32 *p_ceu = 0;
+	__u32 i = 0;
+
+	if (r2y_type) {
+		if (r2y_type == 1)
+			p_r2y = (__s32 *) rect_r2y_sd;
+		else if (r2y_type == 2)
+			p_r2y = (__s32 *) rect_r2y_hd;
+		p_rect = p_r2y;
+	} else
+		p_rect = (__s32 *) rect_1;
+
+	if (cen_type) {
+		range_cut(&b, -600, 600);
+		range_cut(&c, 0, 300);
+		range_cut(&s, 0, 300);
+		range_cut(&h, 0, 360);
+		p_ceu = rect_tmp1;
+		rect_ceu_pro(p_ceu, b, c, s, h);
+		rect_multi(rect_tmp0, p_ceu, p_rect);
+		p_rect = rect_tmp0;
+	}
+
+	if (y2r_type) {
+		if (y2r_type == 1)
+			p_y2r = (__s32 *) rect_y2r_sd;
+		else if (y2r_type == 2)
+			p_y2r = (__s32 *) rect_y2r_hd;
+		rect_multi(rect_tmp1, p_y2r, p_rect);
+		p_rect = rect_tmp1;
+	}
+
+#if 0
+	const __s32 rect_srgb_warm[16] = {
+		1280,	   0,	   0,	   0,
+		0,	1024,	   0,	   0,
+		0,	   0,	 819,	   0,
+		0,	   0,      0,	1024
+	};
+
+	const __s32 rect_srgb_cool[16] = {
+		819,	   0,	   0,	   0,
+		0,	1024,	   0,	   0,
+		0,	   0,	1280,	   0,
+		0,	   0,      0,	1024
+	};
+
+	if (srgb_type) {
+		if (srgb_type == 1)
+			p_srgb == (__s32 *)rect_srgb_warm;
+		else if (srgb_type == 2)
+			p_srgb == (__s32 *)rect_srgb_cool;
+		rect_multi(rect_tmp0, p_srgb, p_rect);
+		p_rect = rect_tmp0;
+	}
+#endif
+
+	for (i = 0; i < 12; i++)
+		*(p_coff + i) = *(p_rect + i);
+}
+
+/*
+ * lcdc color enhance
+ *
+ * parameters:
+ * sel:  sel tcon
+ * func: 0:disable
+ *       1:rgb->rgb
+ *       2:yuv->yuv
+ * b:    brightness [-600:600]
+ * c:    contrast [0:300]
+ * s:    saturation [0:300]
+ * h:    hue [0:360]
+ */
+static void
+LCDC_ceu(__u32 sel, __u32 func, __s32 b, __s32 c, __s32 s, __s32 h)
+{
+	__s32 ceu_coff[12];
+	__u32 error;
+
+	if (func == 1 || func == 2) {
+		if (func == 1) {
+			lcd_ceu(1, 1, 1, b, c, s, h, ceu_coff);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x40, 0x000000ff);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x44, 0x000000ff);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x48, 0x000000ff);
+		} else if (func == 2) {
+			lcd_ceu(0, 1, 0, b, c, s, h, ceu_coff);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x40, 0x000000eb);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x44, 0x000000f0);
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x48, 0x000000f0);
+		}
+
+		ceu_coff[0] = (ceu_coff[0] + 2) >> 2;
+		ceu_coff[1] = (ceu_coff[1] + 2) >> 2;
+		ceu_coff[2] = (ceu_coff[2] + 2) >> 2;
+		ceu_coff[3] = (ceu_coff[3] + 32) >> 6;
+		ceu_coff[4] = (ceu_coff[4] + 2) >> 2;
+		ceu_coff[5] = (ceu_coff[5] + 2) >> 2;
+		ceu_coff[6] = (ceu_coff[6] + 2) >> 2;
+		ceu_coff[7] = (ceu_coff[7] + 32) >> 6;
+		ceu_coff[8] = (ceu_coff[8] + 2) >> 2;
+		ceu_coff[9] = (ceu_coff[9] + 2) >> 2;
+		ceu_coff[10] = (ceu_coff[10] + 2) >> 2;
+		ceu_coff[11] = (ceu_coff[11] + 32) >> 6;
+
+		error = 0;
+		error |= range_cut(ceu_coff + 0, -4095, 4095);
+		error |= range_cut(ceu_coff + 1, -4095, 4095);
+		error |= range_cut(ceu_coff + 2, -4095, 4095);
+		error |= range_cut(ceu_coff + 3, -262143, 262143);
+		error |= range_cut(ceu_coff + 4, -4095, 4095);
+		error |= range_cut(ceu_coff + 5, -4095, 4095);
+		error |= range_cut(ceu_coff + 6, -4095, 4095);
+		error |= range_cut(ceu_coff + 7, -262143, 262143);
+		error |= range_cut(ceu_coff + 8, -4095, 4095);
+		error |= range_cut(ceu_coff + 9, -4095, 4095);
+		error |= range_cut(ceu_coff + 10, -4095, 4095);
+		error |= range_cut(ceu_coff + 11, -262143, 262143);
+
+		if (error) {
+			LCDC_CLR_BIT(sel, LCDC_CEU_OFF, (__u32) 1 << 31);
+			return;
+		} else {
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x10,
+				     reg_corr(ceu_coff[0], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x14,
+				     reg_corr(ceu_coff[1], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x18,
+				     reg_corr(ceu_coff[2], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x1c,
+				     reg_corr(ceu_coff[3], 1 << 18));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x20,
+				     reg_corr(ceu_coff[4], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x24,
+				     reg_corr(ceu_coff[5], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x28,
+				     reg_corr(ceu_coff[6], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x2c,
+				     reg_corr(ceu_coff[7], 1 << 18));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x30,
+				     reg_corr(ceu_coff[8], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x34,
+				     reg_corr(ceu_coff[9], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x38,
+				     reg_corr(ceu_coff[10], 1 << 12));
+			LCDC_WUINT32(sel, LCDC_CEU_OFF + 0x3c,
+				     reg_corr(ceu_coff[11], 1 << 18));
+			LCDC_SET_BIT(sel, LCDC_CEU_OFF, (__u32) 1 << 31);
+		}
+	} else {
+		LCDC_CLR_BIT(sel, LCDC_CEU_OFF, (__u32) 1 << 31);
+	}
+}
+#endif
diff --git a/drivers/video/sunxi/disp/de_lcdc_i.h b/drivers/video/sunxi/disp/de_lcdc_i.h
new file mode 100644
index 0000000..d539e3f
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_lcdc_i.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DE_LCDC_I_H__
+#define __DE_LCDC_I_H__
+
+#define LCDC_BIT0       (0x00000001)
+#define LCDC_BIT1	(0x00000002)
+#define LCDC_BIT2	(0x00000004)
+#define LCDC_BIT3	(0x00000008)
+#define LCDC_BIT4	(0x00000010)
+#define LCDC_BIT5	(0x00000020)
+#define LCDC_BIT6	(0x00000040)
+#define LCDC_BIT7	(0x00000080)
+#define LCDC_BIT8	(0x00000100)
+#define LCDC_BIT9	(0x00000200)
+#define LCDC_BIT10	(0x00000400)
+#define LCDC_BIT11	(0x00000800)
+#define LCDC_BIT12	(0x00001000)
+#define LCDC_BIT13	(0x00002000)
+#define LCDC_BIT14	(0x00004000)
+#define LCDC_BIT15	(0x00008000)
+#define LCDC_BIT16	(0x00010000)
+#define LCDC_BIT17	(0x00020000)
+#define LCDC_BIT18	(0x00040000)
+#define LCDC_BIT19	(0x00080000)
+#define LCDC_BIT20	(0x00100000)
+#define LCDC_BIT21	(0x00200000)
+#define LCDC_BIT22	(0x00400000)
+#define LCDC_BIT23	(0x00800000)
+#define LCDC_BIT24	(0x01000000)
+#define LCDC_BIT25	(0x02000000)
+#define LCDC_BIT26	(0x04000000)
+#define LCDC_BIT27	(0x08000000)
+#define LCDC_BIT28	(0x10000000)
+#define LCDC_BIT29	(0x20000000)
+#define LCDC_BIT30	(0x40000000)
+#define LCDC_BIT31	(0x80000000)
+
+/* LCD Controller */
+#define LCDC_GCTL_OFF		(0x000) /* global control registers offset */
+#define LCDC_GINT0_OFF		(0x004) /* interrupt registers offset */
+#define LCDC_GINT1_OFF		(0x008) /* interrupt registers offset */
+#define LCDC_FRM0_OFF		(0x010) /* frm registers offset */
+#define LCDC_FRM1_OFF		(0x014) /* frm registers offset */
+#define LCDC_FRM2_OFF		(0x02c) /* frm registers offset */
+#define LCDC_CTL_OFF		(0x040) /* control registers offset */
+#define LCDC_DCLK_OFF		(0x044) /* dot clock registers offset */
+#define LCDC_BASIC0_OFF		(0x048) /* base0 registers offset */
+#define LCDC_BASIC1_OFF		(0x04c) /* base1 registers offset */
+#define LCDC_BASIC2_OFF		(0x050) /* base2 registers offset */
+#define LCDC_BASIC3_OFF		(0x054) /* base3 registers offset */
+#define LCDC_HVIF_OFF		(0x058) /* hv interface registers offset */
+#define LCDC_CPUIF_OFF		(0x060) /* cpu interface registers offset */
+#define LCDC_CPUWR_OFF		(0x064) /* cpu wr registers offset */
+#define LCDC_CPURD_OFF		(0x068) /* cpu rd registers offset */
+#define LCDC_CPURDNX_OFF	(0x06c) /* cpu rdnx registers offset */
+#define LCDC_TTL0_OFF		(0x070) /* TTL0 registers offset */
+#define LCDC_TTL1_OFF		(0x074) /* TTL1 registers offset */
+#define LCDC_TTL2_OFF		(0x078) /* TTL2 registers offset */
+#define LCDC_TTL3_OFF		(0x07c) /* TTL3 registers offset */
+#define LCDC_TTL4_OFF		(0x080) /* TTL4 registers offset */
+#define LCDC_LVDS_OFF		(0x084) /* LVDS registers offset */
+#define LCDC_IOCTL0_OFF		(0x088) /* io control0 registers offset */
+#define LCDC_IOCTL1_OFF		(0x08c) /* io control1 registers offset */
+
+#define LCDC_HDTVIF_OFF		(0x090) /* tv interface  registers offset */
+#define LCDC_HDTV0_OFF		(0x094) /* HDTV0 registers offset */
+#define LCDC_HDTV1_OFF		(0x098) /* HDTV1 registers offset */
+#define LCDC_HDTV2_OFF		(0x09c) /* HDTV2 registers offset */
+#define LCDC_HDTV3_OFF		(0x0a0) /* HDTV3 registers offset */
+#define LCDC_HDTV4_OFF		(0x0a4) /* HDTV4 registers offset */
+#define LCDC_HDTV5_OFF		(0x0a8) /* HDTV5 registers offset */
+#define LCDC_IOCTL2_OFF		(0x0f0) /* io control2 registers offset */
+#define LCDC_IOCTL3_OFF		(0x0f4) /* io control3 registers offset */
+#define LCDC_DUBUG_OFF		(0x0fc) /* debug register */
+
+#define LCDC_CEU_OFF		(0x100)
+#define LCDC_MUX_CTRL		(0x200)
+#define LCDC_LVDS_ANA0		(0x220)
+#define LCDC_LVDS_ANA1		(0x224)
+
+#define LCDC_3DF_CTL		(0x300)
+#define LCDC_3DF_A1B		(0x304)
+#define LCDC_3DF_A1E		(0x308)
+#define LCDC_3DF_D1		(0x30C)
+#define LCDC_3DF_A2B		(0x310)
+#define LCDC_3DF_A2E		(0x314)
+#define LCDC_3DF_D2		(0x318)
+#define LCDC_3DF_A3B		(0x31C)
+#define LCDC_3DF_A3E		(0x320)
+#define LCDC_3DF_D3		(0x318)
+
+#define LCDC_GAMMA_TABLE_OFF    (0x400)
+
+#define LCDC_GET_REG_BASE(sel)  ((sel)==0?(lcdc_reg_base0):(lcdc_reg_base1))
+
+#define LCDC_WUINT32(sel, offset, value) \
+	writel(value, LCDC_GET_REG_BASE(sel)+offset)
+#define LCDC_RUINT32(sel, offset) \
+	readl(LCDC_GET_REG_BASE(sel)+offset)
+
+#define LCDC_SET_BIT(sel, offset, bit) \
+	writel(readl(LCDC_GET_REG_BASE(sel)+offset) | (bit), \
+			LCDC_GET_REG_BASE(sel)+offset)
+#define LCDC_CLR_BIT(sel, offset, bit) \
+	writel(readl(LCDC_GET_REG_BASE(sel)+offset) & ~(bit), \
+			LCDC_GET_REG_BASE(sel)+offset)
+#define LCDC_INIT_BIT(sel, offset, c, s) \
+	writel((readl(LCDC_GET_REG_BASE(sel)+offset) & ~(c)) | (s), \
+			LCDC_GET_REG_BASE(sel)+offset)
+
+#endif
diff --git a/drivers/video/sunxi/disp/de_tvec.c b/drivers/video/sunxi/disp/de_tvec.c
new file mode 100644
index 0000000..cb2ae1c
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_tvec.c
@@ -0,0 +1,639 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "ebios_lcdc_tve.h"
+#include "de_tvec_i.h"
+
+static __u32 tve_reg_base0;
+static __u32 tve_reg_base1;
+
+__s32 TVE_set_reg_base(__u32 sel, __u32 address)
+{
+	if (sel == 0)
+		tve_reg_base0 = address;
+	else if (sel == 1)
+		tve_reg_base1 = address;
+
+	return 0;
+}
+
+/*
+ * init module
+ */
+__s32 TVE_init(__u32 sel)
+{
+	TVE_close(sel);
+
+	TVE_dac_set_de_bounce(sel, 0, 0);
+	TVE_dac_set_de_bounce(sel, 1, 0);
+	TVE_dac_set_de_bounce(sel, 2, 0);
+	TVE_dac_set_de_bounce(sel, 3, 0);
+	TVE_dac_int_disable(sel, 0);
+	TVE_dac_int_disable(sel, 1);
+	TVE_dac_int_disable(sel, 2);
+	TVE_dac_int_disable(sel, 3);
+	TVE_dac_autocheck_enable(sel, 0);
+	TVE_dac_autocheck_enable(sel, 1);
+	TVE_dac_autocheck_enable(sel, 2);
+	TVE_dac_autocheck_enable(sel, 3);
+	TVE_csc_init(sel, 0);
+
+	if (sel == 0) {
+		TVE_dac_sel(0, 0, 0);
+		TVE_dac_sel(0, 1, 1);
+		TVE_dac_sel(0, 2, 2);
+		TVE_dac_sel(0, 3, 3);
+	}
+	TVE_SET_BIT(sel, TVE_008, 0x3 << 16);
+	TVE_WUINT32(sel, TVE_024, 0x18181818);
+
+	return 0;
+}
+
+__s32 TVE_exit(__u32 sel)
+{
+	TVE_dac_int_disable(sel, 0);
+	TVE_dac_int_disable(sel, 1);
+	TVE_dac_int_disable(sel, 2);
+	TVE_dac_int_disable(sel, 3);
+	TVE_dac_autocheck_disable(sel, 0);
+	TVE_dac_autocheck_disable(sel, 1);
+	TVE_dac_autocheck_disable(sel, 2);
+	TVE_dac_autocheck_disable(sel, 3);
+
+	return 0;
+}
+
+/*
+ * open module
+ */
+__s32 TVE_open(__u32 sel)
+{
+	TVE_SET_BIT(sel, TVE_000, 0x1 << 0);
+
+	return 0;
+}
+
+__s32 TVE_close(__u32 sel)
+{
+	TVE_CLR_BIT(sel, TVE_000, 0x1 << 0);
+	TVE_WUINT32(sel, TVE_024, 0x18181818);
+	return 0;
+}
+
+/*
+ * 15~13     12~10       9~7         6~4
+ * DAC3      DAC2        DAC1        DAC0
+ *
+ * CVBS(0)
+ *           CR(4)       CB(5)       Y(6)
+ *                       Chroma(1)   Luma(2)
+ */
+__s32 TVE_set_tv_mode(__u32 sel, __u8 mode)
+{
+	switch (mode) {
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL:
+		TVE_WUINT32(sel, TVE_004, 0x07030001);
+		TVE_WUINT32(sel, TVE_014, 0x008a0018);
+		TVE_WUINT32(sel, TVE_01C, 0x00160271);
+		TVE_WUINT32(sel, TVE_114, 0x0016447e);
+		TVE_WUINT32(sel, TVE_124, 0x000005a0);
+		TVE_WUINT32(sel, TVE_130, 0x800D000C);
+		TVE_WUINT32(sel, TVE_13C, 0x00000000);
+		TVE_WUINT32(sel, TVE_00C, 0x00000120);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel, TVE_10C, 0x00002828);
+		TVE_WUINT32(sel, TVE_128, 0x00000002);
+		TVE_WUINT32(sel, TVE_118, 0x0000e0e0);
+		TVE_WUINT32(sel, TVE_12C, 0x00000101);
+		break;
+
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+		TVE_WUINT32(sel, TVE_004, 0x07030000); /* ntsc */
+		TVE_WUINT32(sel, TVE_014, 0x00760020);
+		TVE_WUINT32(sel, TVE_01C, 0x0016020d);
+		TVE_WUINT32(sel, TVE_114, 0x0016447e);
+		TVE_WUINT32(sel, TVE_124, 0x000005a0);
+		TVE_WUINT32(sel, TVE_130, 0x000e000c);
+		TVE_WUINT32(sel, TVE_13C, 0x00000000);
+		TVE_WUINT32(sel, TVE_00C, 0x00000120);
+		TVE_WUINT32(sel, TVE_020, 0x00f0011a);
+		TVE_WUINT32(sel, TVE_10C, 0x0000004f);
+		TVE_WUINT32(sel, TVE_110, 0x00000000);
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel, TVE_11C, 0x001000f0);
+		TVE_WUINT32(sel, TVE_010, 0x21e6efe3); /* add for pal-m */
+		TVE_WUINT32(sel, TVE_100, 0x00000000); /* add for pal-m */
+		TVE_WUINT32(sel, TVE_128, 0x00000002);
+		TVE_WUINT32(sel, TVE_12C, 0x00000101);
+		break;
+
+	case DISP_TV_MOD_PAL_NC:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+		TVE_WUINT32(sel, TVE_004, 0x07030001); /* PAL */
+		TVE_WUINT32(sel, TVE_014, 0x008a0018);
+		TVE_WUINT32(sel, TVE_01C, 0x00160271);
+		TVE_WUINT32(sel, TVE_114, 0x0016447e);
+		TVE_WUINT32(sel, TVE_124, 0x000005a0);
+		TVE_WUINT32(sel, TVE_130, 0x800D000C);
+		TVE_WUINT32(sel, TVE_13C, 0x00000000);
+		TVE_WUINT32(sel, TVE_00C, 0x00000120);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel, TVE_10C, 0x00002828);
+		TVE_WUINT32(sel, TVE_010, 0x21F69446); /* add for PAL-NC */
+		TVE_WUINT32(sel, TVE_128, 0x00000002);
+		TVE_WUINT32(sel, TVE_118, 0x0000e0e0);
+		TVE_WUINT32(sel, TVE_12C, 0x00000101);
+		break;
+
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_NTSC_SVIDEO:
+		TVE_WUINT32(sel, TVE_004, 0x07030000);
+		TVE_WUINT32(sel, TVE_014, 0x00760020);
+		TVE_WUINT32(sel, TVE_01C, 0x0016020d);
+		TVE_WUINT32(sel, TVE_114, 0x0016447e);
+		TVE_WUINT32(sel, TVE_124, 0x000005a0);
+		TVE_WUINT32(sel, TVE_130, 0x000e000c);
+		TVE_WUINT32(sel, TVE_13C, 0x00000000);
+		TVE_WUINT32(sel, TVE_00C, 0x00000120);
+		TVE_WUINT32(sel, TVE_020, 0x00f0011a);
+		TVE_WUINT32(sel, TVE_10C, 0x0000004f);
+		TVE_WUINT32(sel, TVE_110, 0x00000000);
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel, TVE_11C, 0x001000f0);
+		TVE_WUINT32(sel, TVE_128, 0x00000002);
+		TVE_WUINT32(sel, TVE_12C, 0x00000101);
+		break;
+
+	case DISP_TV_MOD_480I:
+		TVE_WUINT32(sel, TVE_004, 0x07040000);
+		TVE_WUINT32(sel, TVE_014, 0x00760020);
+		TVE_WUINT32(sel, TVE_01C, 0x0016020d);
+		TVE_WUINT32(sel, TVE_114, 0x0016447e);
+		TVE_WUINT32(sel, TVE_124, 0x000005a0);
+		TVE_WUINT32(sel, TVE_130, 0x000e000c);
+		TVE_WUINT32(sel, TVE_13C, 0x00000000);
+		TVE_WUINT32(sel, TVE_00C, 0x00000120);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel, TVE_10C, 0x0000004f);
+		TVE_WUINT32(sel, TVE_110, 0x00000000);
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel, TVE_11C, 0x001000fc);
+		break;
+
+	case DISP_TV_MOD_576I:
+		TVE_WUINT32(sel, TVE_004, 0x07040001);
+		TVE_WUINT32(sel, TVE_014, 0x008a0018);
+		TVE_WUINT32(sel, TVE_01C, 0x00160271);
+		TVE_WUINT32(sel, TVE_114, 0x0016447e);
+		TVE_WUINT32(sel, TVE_124, 0x000005a0);
+		TVE_WUINT32(sel, TVE_130, 0x800D000C);
+		TVE_WUINT32(sel, TVE_13C, 0x00000000);
+		TVE_WUINT32(sel, TVE_00C, 0x00000120);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel, TVE_10C, 0x00002828);
+		break;
+
+	case DISP_TV_MOD_480P:
+		TVE_WUINT32(sel, TVE_004, 0x07040002);
+		TVE_WUINT32(sel, TVE_014, 0x00760020);
+		TVE_WUINT32(sel, TVE_01C, 0x002c020d);
+		TVE_WUINT32(sel, TVE_114, 0x0016447e);
+		TVE_WUINT32(sel, TVE_124, 0x000005a0);
+		TVE_WUINT32(sel, TVE_130, 0x000e000C);
+		TVE_WUINT32(sel, TVE_13C, 0x00000000);
+		TVE_WUINT32(sel, TVE_00C, 0x00000120);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		break;
+
+	case DISP_TV_MOD_576P:
+		TVE_WUINT32(sel, TVE_004, 0x07040003);
+		TVE_WUINT32(sel, TVE_014, 0x008a0018);
+		TVE_WUINT32(sel, TVE_01C, 0x002c0271);
+		TVE_WUINT32(sel, TVE_114, 0x0016447e);
+		TVE_WUINT32(sel, TVE_124, 0x000005a0);
+		TVE_WUINT32(sel, TVE_130, 0x800B000C);
+		TVE_WUINT32(sel, TVE_13C, 0x00000000);
+		TVE_WUINT32(sel, TVE_00C, 0x00000120);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		break;
+
+	case DISP_TV_MOD_720P_50HZ:
+		TVE_WUINT32(sel, TVE_004, 0x0004000a);
+		TVE_WUINT32(sel, TVE_014, 0x01040190);
+		TVE_WUINT32(sel, TVE_018, 0x05000190);
+		TVE_WUINT32(sel, TVE_01C, 0x001902ee);
+		TVE_WUINT32(sel, TVE_114, 0xdc280228);
+		TVE_WUINT32(sel, TVE_124, 0x00000500);
+		TVE_WUINT32(sel, TVE_130, 0x000e000c);
+		TVE_WUINT32(sel, TVE_13C, 0x07000000);
+		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_720P_60HZ:
+		TVE_WUINT32(sel, TVE_004, 0x0004000a);
+		TVE_WUINT32(sel, TVE_014, 0x01040046);
+		TVE_WUINT32(sel, TVE_018, 0x05000046);
+		TVE_WUINT32(sel, TVE_01C, 0x001902ee);
+		TVE_WUINT32(sel, TVE_114, 0xdc280228);
+		TVE_WUINT32(sel, TVE_124, 0x00000500);
+		TVE_WUINT32(sel, TVE_130, 0x000c0008);
+		TVE_WUINT32(sel, TVE_13C, 0x07000000);
+		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_1080I_50HZ:
+		TVE_WUINT32(sel, TVE_004, 0x0004000c);
+		TVE_WUINT32(sel, TVE_014, 0x00c001e4);
+		TVE_WUINT32(sel, TVE_018, 0x03700108);
+		TVE_WUINT32(sel, TVE_01C, 0x00140465);
+		TVE_WUINT32(sel, TVE_114, 0x582c442c);
+		TVE_WUINT32(sel, TVE_124, 0x00000780);
+		TVE_WUINT32(sel, TVE_130, 0x000e0008);
+		TVE_WUINT32(sel, TVE_13C, 0x07000000);
+		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel, TVE_104, 0x00000000);
+		break;
+
+	case DISP_TV_MOD_1080I_60HZ:
+		TVE_WUINT32(sel, TVE_004, 0x0004000c);
+		TVE_WUINT32(sel, TVE_014, 0x00c0002c);
+		TVE_WUINT32(sel, TVE_018, 0x0370002c);
+		TVE_WUINT32(sel, TVE_01C, 0x00140465);
+		TVE_WUINT32(sel, TVE_114, 0x582c442c);
+		TVE_WUINT32(sel, TVE_124, 0x00000780);
+		TVE_WUINT32(sel, TVE_130, 0x000e0008);
+		TVE_WUINT32(sel, TVE_13C, 0x07000000);
+		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00fc);
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel, TVE_104, 0x00000000);
+		break;
+
+	case DISP_TV_MOD_1080P_50HZ:
+		TVE_WUINT32(sel, TVE_004, 0x0004000e);
+		TVE_WUINT32(sel, TVE_014, 0x00c001e4); /* 50hz */
+		TVE_WUINT32(sel, TVE_018, 0x07bc01e4); /* 50hz */
+		TVE_WUINT32(sel, TVE_01C, 0x00290465);
+		TVE_WUINT32(sel, TVE_114, 0x582c022c);
+		TVE_WUINT32(sel, TVE_124, 0x00000780);
+		TVE_WUINT32(sel, TVE_130, 0x000e000c);
+		TVE_WUINT32(sel, TVE_13C, 0x07000000);
+		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00c0); /* ghost? */
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		break;
+
+	case DISP_TV_MOD_1080P_60HZ:
+		TVE_WUINT32(sel, TVE_004, 0x0004000e);
+		TVE_WUINT32(sel, TVE_00C, 0x01be0124);
+		TVE_WUINT32(sel, TVE_014, 0x00c0002c); /* 60hz */
+		TVE_WUINT32(sel, TVE_018, 0x07bc002c); /* 60hz */
+		TVE_WUINT32(sel, TVE_01C, 0x00290465);
+		TVE_WUINT32(sel, TVE_020, 0x00fc00c0); /* ghost? */
+		TVE_WUINT32(sel, TVE_114, 0x582c022c);
+		TVE_WUINT32(sel, TVE_118, 0x0000a0a0);
+		TVE_WUINT32(sel, TVE_124, 0x00000780);
+		TVE_WUINT32(sel, TVE_128, 0x00000000);
+		TVE_WUINT32(sel, TVE_130, 0x000e000c);
+		TVE_WUINT32(sel, TVE_13C, 0x07000000);
+		break;
+
+	default:
+		return 0;
+	}
+	TVE_CLR_BIT(sel, TVE_008, 0xfff << 4);
+	TVE_SET_BIT(sel, TVE_008, 0x3 << 16);
+	TVE_SET_BIT(sel, TVE_008, 0xf << 18);
+	TVE_WUINT32(sel, TVE_024, 0x18181818);
+
+	return 0;
+}
+
+__s32 TVE_set_vga_mode(__u32 sel)
+{
+	__u32 readval;
+
+	TVE_WUINT32(sel, TVE_004, 0x20000000);
+	TVE_WUINT32(sel, TVE_008, 0x403f1ac7);
+
+	readval = TVE_RUINT32(sel, TVE_024);
+	TVE_WUINT32(sel, TVE_024, readval & 0xff000000);
+
+	TVE_INIT_BIT(0, TVE_000, 0xfff << 4, 0x321 << 4);
+	return 0;
+}
+
+__u8 TVE_query_int(__u32 sel)
+{
+	__u8 sts = 0;
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_034);
+	sts = readval & 0x0f;
+
+	return sts;
+}
+
+__u8 TVE_clear_int(__u32 sel)
+{
+	__u32 sts = 0;
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_034);
+	sts = readval & 0x0f;
+	TVE_WUINT32(sel, TVE_034, sts);
+
+	return 0;
+}
+
+/*
+ * 0:unconnected
+ * 1:connected
+ * 3:short to ground
+ */
+__s32 TVE_get_dac_status(__u32 index)
+{
+	__u32 reg_000, map, sel, dac;
+	__s32 status;
+
+	reg_000 = TVE_RUINT32(0, TVE_000);
+	map = (reg_000 >> (4 * (index + 1))) & 0xf;
+	if (map >= 1 && map <= 4) {
+		sel = 0;
+		dac = map - 1;
+	} else if (map >= 5 && map <= 8) {
+		sel = 1;
+		dac = map - 5;
+	} else {
+		return -1;
+	}
+
+	status = TVE_RUINT32(sel, TVE_038) >> (dac * 8);
+	status &= 0x3;
+
+	return status;
+}
+
+__u8 TVE_dac_int_enable(__u32 sel, __u8 index)
+{
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_030);
+	readval |= (1 << (16 + index));
+	TVE_WUINT32(sel, TVE_030, readval);
+
+	return 0;
+}
+
+__u8 TVE_dac_int_disable(__u32 sel, __u8 index)
+{
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_030);
+	readval &= (~(1 << (16 + index)));
+	TVE_WUINT32(sel, TVE_030, readval);
+
+	return 0;
+}
+
+__u8 TVE_dac_autocheck_enable(__u32 sel, __u8 index)
+{
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_030);
+	readval |= (1 << index);
+	TVE_WUINT32(sel, TVE_030, readval);
+
+	return 0;
+}
+
+__u8 TVE_dac_autocheck_disable(__u32 sel, __u8 index)
+{
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_030);
+	readval &= (~(1 << index));
+	TVE_WUINT32(sel, TVE_030, readval);
+
+	return 0;
+}
+
+__u8 TVE_dac_enable(__u32 sel, __u8 index)
+{
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_008);
+
+	TVE_SET_BIT(sel, TVE_008, readval | (1 << index));
+
+	return 0;
+}
+
+__u8 TVE_dac_disable(__u32 sel, __u8 index)
+{
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_008);
+
+	TVE_WUINT32(sel, TVE_008, readval & (~(1 << index)));
+
+	return 0;
+}
+
+__s32 TVE_dac_set_source(__u32 sel, __u32 index, __u32 source)
+{
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_008);
+
+	if (index == 0)
+		readval = (readval & 0xffffff8f) | ((source & 0x7) << 4);
+	else if (index == 1)
+		readval = (readval & 0xfffffc7f) | ((source & 0x7) << 7);
+	else if (index == 2)
+		readval = (readval & 0xffffe3ff) | ((source & 0x7) << 10);
+	else if (index == 3)
+		readval = (readval & 0xffff1fff) | ((source & 0x7) << 13);
+	else
+		return 0;
+
+	TVE_WUINT32(sel, TVE_008, readval);
+
+	return 0;
+}
+
+__s32 TVE_dac_get_source(__u32 sel, __u32 index)
+{
+	__u32 readval = 0;
+
+	readval = TVE_RUINT32(sel, TVE_008);
+
+	if (index == 0)
+		readval = (readval >> 4) & 0x7;
+	else if (index == 1)
+		readval = (readval >> 7) & 0x7;
+	else if (index == 2)
+		readval = (readval >> 10) & 0x7;
+	else if (index == 3)
+		readval = (readval >> 13) & 0x7;
+
+	return readval;
+}
+
+__u8 TVE_dac_set_de_bounce(__u32 sel, __u8 index, __u32 times)
+{
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_03C);
+
+	if (index == 0)
+		readval = (readval & 0xfffffff0) | (times & 0xf);
+	else if (index == 1)
+		readval = (readval & 0xfffff0ff) | ((times & 0xf) << 8);
+	else if (index == 2)
+		readval = (readval & 0xfff0ffff) | ((times & 0xf) << 16);
+	else if (index == 3)
+		readval = (readval & 0xfff0ffff) | ((times & 0xf) << 20);
+	else
+		return 0;
+
+	TVE_WUINT32(sel, TVE_03C, readval);
+
+	return 0;
+}
+
+__u8 TVE_dac_get_de_bounce(__u32 sel, __u8 index)
+{
+	__u8 sts = 0;
+	__u32 readval;
+
+	readval = TVE_RUINT32(sel, TVE_03C);
+
+	if (index == 0)
+		sts = readval & 0xf;
+	else if (index == 1)
+		sts = (readval & 0xf00) >> 8;
+	else if (index == 2)
+		sts = (readval & 0xf0000) >> 16;
+	else if (index == 3)
+		sts = (readval & 0xf000000) >> 20;
+	else
+		return 0;
+
+	return sts;
+}
+
+/*
+ * dac: 0~3
+ * index: 0~3
+ */
+__s32 TVE_dac_sel(__u32 sel, __u32 dac, __u32 index)
+{
+	__u32 readval;
+
+	if (dac == 0) {
+		readval = TVE_RUINT32(sel, TVE_000);
+		readval &= (~(0xf << 4));
+		readval |= ((sel * 4 + index + 1) << 4);
+		TVE_WUINT32(sel, TVE_000, readval);
+
+		if (sel == 1) {
+			readval = TVE_RUINT32(0, TVE_000);
+			readval &= (~(0xf << 4));
+			readval |= ((sel * 4 + index + 1) << 4);
+			TVE_WUINT32(0, TVE_000, readval);
+		}
+	} else if (dac == 1) {
+		readval = TVE_RUINT32(sel, TVE_000);
+		readval &= (~(0xf << 8));
+		readval |= ((sel * 4 + index + 1) << 8);
+		TVE_WUINT32(sel, TVE_000, readval);
+		if (sel == 1) {
+			readval = TVE_RUINT32(0, TVE_000);
+			readval &= (~(0xf << 8));
+			readval |= ((sel * 4 + index + 1) << 8);
+			TVE_WUINT32(0, TVE_000, readval);
+		}
+	} else if (dac == 2) {
+		readval = TVE_RUINT32(sel, TVE_000);
+		readval &= (~(0xf << 12));
+		readval |= ((sel * 4 + index + 1) << 12);
+		TVE_WUINT32(sel, TVE_000, readval);
+		if (sel == 1) {
+			readval = TVE_RUINT32(0, TVE_000);
+			readval &= (~(0xf << 12));
+			readval |= ((sel * 4 + index + 1) << 12);
+			TVE_WUINT32(0, TVE_000, readval);
+		}
+	} else if (dac == 3) {
+		readval = TVE_RUINT32(sel, TVE_000);
+		readval &= (~(0xf << 16));
+		readval |= ((sel * 4 + index + 1) << 16);
+		TVE_WUINT32(sel, TVE_000, readval);
+		if (sel == 1) {
+			readval = TVE_RUINT32(0, TVE_000);
+			readval &= (~(0xf << 16));
+			readval |= ((sel * 4 + index + 1) << 16);
+			TVE_WUINT32(0, TVE_000, readval);
+		}
+	}
+	return 0;
+}
+
+__u8 TVE_csc_init(__u32 sel, __u8 type)
+{
+	if (sel == 0) {
+		TVE_WUINT32(sel, TVE_040, 0x08440832);
+		TVE_WUINT32(sel, TVE_044, 0x3B6DACE1);
+		TVE_WUINT32(sel, TVE_048, 0x0E1D13DC);
+		TVE_WUINT32(sel, TVE_04C, 0x00108080);
+		return 0;
+	} else
+		return 0;
+}
+
+#ifdef UNUSED
+static __u8
+TVE_csc_enable(__u32 sel)
+{
+	TVE_SET_BIT(sel, TVE_040, (__u32) (0x1 << 31));
+	return 0;
+}
+
+static __u8
+TVE_csc_disable(__u32 sel)
+{
+	TVE_CLR_BIT(sel, TVE_040, 0x1 << 31);
+	return 0;
+}
+#endif
diff --git a/drivers/video/sunxi/disp/de_tvec_i.h b/drivers/video/sunxi/disp/de_tvec_i.h
new file mode 100644
index 0000000..7324718
--- /dev/null
+++ b/drivers/video/sunxi/disp/de_tvec_i.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DE_TVE_I_H__
+#define __DE_TVE_I_H__
+
+/*tv encoder registers offset*/
+#define TVE_000    (0x000)
+#define TVE_004    (0x004)
+#define TVE_008    (0x008)
+#define TVE_00C    (0x00c)
+#define TVE_010    (0x010)
+#define TVE_014    (0x014)
+#define TVE_018    (0x018)
+#define TVE_01C    (0x01c)
+#define TVE_020    (0x020)
+#define TVE_024    (0x024)
+#define TVE_030    (0X030)
+#define TVE_034    (0x034)
+#define TVE_038    (0x038)
+#define TVE_03C    (0x03c)
+#define TVE_040    (0x040)
+#define TVE_044    (0x044)
+#define TVE_048    (0x048)
+#define TVE_04C    (0x04c)
+#define TVE_100    (0x100)
+#define TVE_104    (0x104)
+#define TVE_10C    (0x10c)
+#define TVE_110    (0x110)
+#define TVE_114    (0x114)
+#define TVE_118    (0x118)
+#define TVE_11C    (0x11c)
+#define TVE_124    (0x124)
+#define TVE_128    (0x128)
+#define TVE_12C    (0x12c)
+#define TVE_130    (0x130)
+#define TVE_138    (0x138)
+#define TVE_13C    (0x13C)
+
+/* pfff, get do { } while (0) around these */
+#define TVE_GET_REG_BASE(sel) ((sel)==0?(tve_reg_base0):(tve_reg_base1))
+
+#define TVE_WUINT32(sel, offset, value) \
+	writel(value, TVE_GET_REG_BASE(sel)+offset)
+#define TVE_RUINT32(sel, offset) \
+	readl(TVE_GET_REG_BASE(sel)+offset)
+
+#define TVE_SET_BIT(sel, offset, bit) \
+	writel(readl(TVE_GET_REG_BASE(sel)+offset) | (bit), \
+			TVE_GET_REG_BASE(sel)+offset)
+#define TVE_CLR_BIT(sel, offset, bit) \
+	writel(readl(TVE_GET_REG_BASE(sel)+offset) & ~(bit), \
+			TVE_GET_REG_BASE(sel)+offset)
+#define TVE_INIT_BIT(sel, offset, c, s) \
+	writel((readl(TVE_GET_REG_BASE(sel)+offset) & ~(c)) | (s), \
+			TVE_GET_REG_BASE(sel)+offset)
+
+#endif
diff --git a/drivers/video/sunxi/disp/dev_disp.c b/drivers/video/sunxi/disp/dev_disp.c
new file mode 100644
index 0000000..9b59810
--- /dev/null
+++ b/drivers/video/sunxi/disp/dev_disp.c
@@ -0,0 +1,1988 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ * Copyright (C) 2012 Luc Verhaegen <libv@skynet.be>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#ifdef CONFIG_FB_SUNXI_UMP
+#include <ump/ump_kernel_interface.h>
+#endif
+
+#include <linux/console.h>
+
+#include "drv_disp_i.h"
+#include "dev_disp.h"
+#include "disp_lcd.h"
+#include "dev_fb.h"
+#include "disp_display.h"
+
+
+struct info_mm {
+	void *info_base;	/* Virtual address */
+	unsigned long mem_start;	/* Start of frame buffer mem */
+	/* (physical address) */
+	__u32 mem_len;		/* Length of frame buffer mem */
+};
+
+struct __disp_drv_t {
+	__u32 mid;
+	__u32 used;
+	__u32 status;
+	__u32 exit_mode;	/* 0:clean all  1:disable interrupt */
+	__bool b_cache[2];
+	__bool b_lcd_open[2];
+} ;
+
+struct alloc_struct_t {
+	__u32 address; /* Application memory address */
+	__u32 size; /* The size of the allocated memory */
+	__u32 o_size; /* User application memory size */
+	struct alloc_struct_t *next;
+};
+
+static struct __disp_drv_t g_disp_drv;
+
+/* alloc based on 4K byte */
+#define MY_BYTE_ALIGN(x) (((x + (4*1024-1)) >> 12) << 12)
+static struct alloc_struct_t boot_heap_head, boot_heap_tail;
+
+static unsigned int gbuffer[4096];
+static __u32 suspend_output_type[2];
+
+/*
+ * 0:normal;
+ * suspend_status&1 != 0:in early_suspend;
+ * suspend_status&2 != 0:in suspend;
+ */
+static __u32 suspend_status;
+
+static struct info_mm g_disp_mm[10];
+static int g_disp_mm_sel;
+
+static struct cdev *my_cdev;
+static dev_t devid;
+static struct class *disp_class;
+
+static struct resource disp_resource[DISP_IO_NUM] = {
+	[DISP_IO_SCALER0] = {
+			     .start = 0x01e00000,
+			     .end = 0x01e0077f,
+			     .flags = IORESOURCE_MEM,
+			     },
+	[DISP_IO_SCALER1] = {
+			     .start = 0x01e20000,
+			     .end = 0x01e2077f,
+			     .flags = IORESOURCE_MEM,
+			     },
+	[DISP_IO_IMAGE0] = {
+			    .start = 0x01e60000,
+			    .end = 0x01e657ff,
+			    .flags = IORESOURCE_MEM,
+			    },
+	[DISP_IO_IMAGE1] = {
+			    .start = 0x01e40000,
+			    .end = 0x01e457ff,
+			    .flags = IORESOURCE_MEM,
+			    },
+	[DISP_IO_LCDC0] = {
+			   .start = 0x01c0c000,
+			   .end = 0x01c0cfff,
+			   .flags = IORESOURCE_MEM,
+			   },
+	[DISP_IO_LCDC1] = {
+			   .start = 0x01c0d000,
+			   .end = 0x01c0dfff,
+			   .flags = IORESOURCE_MEM,
+			   },
+	[DISP_IO_TVEC0] = {
+			   .start = 0x01c0a000,
+			   .end = 0x01c0afff,
+			   .flags = IORESOURCE_MEM,
+			   },
+	[DISP_IO_TVEC1] = {
+			   .start = 0x01c1b000,
+			   .end = 0x01c1bfff,
+			   .flags = IORESOURCE_MEM,
+			   },
+	[DISP_IO_IEP] = {
+			 .start = 0x01e70000,
+			 .end = 0x01e703ff,
+			 .flags = IORESOURCE_MEM,
+			 },
+};
+
+__s32 disp_create_heap(__u32 pHeapHead, __u32 nHeapSize)
+{
+	boot_heap_head.size = boot_heap_tail.size = 0;
+	boot_heap_head.address = pHeapHead;
+	boot_heap_tail.address = pHeapHead + nHeapSize;
+	boot_heap_head.next = &boot_heap_tail;
+	boot_heap_tail.next = NULL;
+
+	__inf("head:%x,tail:%x\n", boot_heap_head.address,
+	      boot_heap_tail.address);
+	return 0;
+}
+
+void *disp_malloc(__u32 num_bytes)
+{
+	struct alloc_struct_t *ptr, *newptr;
+	__u32 actual_bytes;
+
+	if (!num_bytes)
+		return NULL;
+
+	/* translate the byte count to size of long type  */
+	actual_bytes = MY_BYTE_ALIGN(num_bytes);
+
+	/* scan from the boot_heap_head of the heap */
+	ptr = &boot_heap_head;
+
+	/* look for enough memory for alloc */
+	while (ptr && ptr->next) {
+		if (ptr->next->address >=
+		    (ptr->address + ptr->size + (8 * 1024) + actual_bytes)) {
+			break;
+		}
+		/* find enough memory to alloc */
+		ptr = ptr->next;
+	}
+
+	if (!ptr->next) {
+		__wrn(" it has reached the boot_heap_tail of the heap now\n");
+		return NULL;
+	}
+
+	newptr = (struct alloc_struct_t *)(ptr->address + ptr->size);
+	/* create a new node for the memory block */
+	if (!newptr) {
+		__wrn(" create the node failed, can't manage the block\n");
+		return NULL;
+	}
+
+	/* set the memory block chain, insert the node to the chain */
+	newptr->address = ptr->address + ptr->size + 4 * 1024;
+	newptr->size = actual_bytes;
+	newptr->o_size = num_bytes;
+	newptr->next = ptr->next;
+	ptr->next = newptr;
+
+	return (void *)newptr->address;
+}
+
+void disp_free(void *p)
+{
+	struct alloc_struct_t *ptr, *prev;
+
+	if (p == NULL)
+		return;
+
+	/* look for the node which po__s32 this memory block */
+	ptr = &boot_heap_head;
+	while (ptr && ptr->next) {
+		if (((void *) ptr->next->address) == p)
+			break;	/* find the node which need to be release */
+		ptr = ptr->next;
+	}
+
+	prev = ptr;
+	ptr = ptr->next;
+
+	if (!ptr)
+		return; /* the node is heap boot_heap_tail */
+
+	/*
+	 * delete the node which need be released from the memory block chain
+	 */
+	prev->next = ptr->next;
+
+	return;
+}
+
+__s32 DRV_lcd_open(__u32 sel)
+{
+	__u32 i = 0;
+	__lcd_flow_t *flow;
+
+	if (g_disp_drv.b_lcd_open[sel] == 0) {
+		BSP_disp_lcd_open_before(sel);
+
+		flow = BSP_disp_lcd_get_open_flow(sel);
+		for (i = 0; i < flow->func_num; i++) {
+			__u32 timeout = flow->func[i].delay * HZ / 1000;
+
+			flow->func[i].func(sel);
+
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(timeout);
+
+		}
+
+		BSP_disp_lcd_open_after(sel);
+
+		g_disp_drv.b_lcd_open[sel] = 1;
+	}
+
+	return 0;
+}
+
+__s32 DRV_lcd_close(__u32 sel)
+{
+	__u32 i = 0;
+	__lcd_flow_t *flow;
+
+	if (g_disp_drv.b_lcd_open[sel] == 1) {
+		BSP_disp_lcd_close_befor(sel);
+
+		flow = BSP_disp_lcd_get_close_flow(sel);
+		for (i = 0; i < flow->func_num; i++) {
+			__u32 timeout = flow->func[i].delay * HZ / 1000;
+
+			flow->func[i].func(sel);
+
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(timeout);
+
+		}
+
+		BSP_disp_lcd_close_after(sel);
+
+		g_disp_drv.b_lcd_open[sel] = 0;
+	}
+	return 0;
+}
+
+__s32 disp_set_hdmi_func(__disp_hdmi_func *func)
+{
+	BSP_disp_set_hdmi_func(func);
+
+	return 0;
+}
+EXPORT_SYMBOL(disp_set_hdmi_func);
+
+__s32 DRV_DISP_Init(void)
+{
+	__disp_bsp_init_para para;
+
+	init_waitqueue_head(&g_fbi.wait[0]);
+	init_waitqueue_head(&g_fbi.wait[1]);
+	g_fbi.wait_count[0] = 0;
+	g_fbi.wait_count[1] = 0;
+
+	memset(&para, 0, sizeof(__disp_bsp_init_para));
+	para.base_image0 = (__u32) g_fbi.base_image0;
+	para.base_image1 = (__u32) g_fbi.base_image1;
+	para.base_scaler0 = (__u32) g_fbi.base_scaler0;
+	para.base_scaler1 = (__u32) g_fbi.base_scaler1;
+	para.base_lcdc0 = (__u32) g_fbi.base_lcdc0;
+	para.base_lcdc1 = (__u32) g_fbi.base_lcdc1;
+	para.base_tvec0 = (__u32) g_fbi.base_tvec0;
+	para.base_tvec1 = (__u32) g_fbi.base_tvec1;
+	para.base_iep = (__u32) g_fbi.base_iep;
+	para.base_ccmu = (__u32) g_fbi.base_ccmu;
+	para.base_sdram = (__u32) g_fbi.base_sdram;
+	para.base_pioc = (__u32) g_fbi.base_pioc;
+	para.base_pwm = (__u32) g_fbi.base_pwm;
+	para.disp_int_process = DRV_disp_int_process;
+
+	memset(&g_disp_drv, 0, sizeof(struct __disp_drv_t));
+
+	BSP_disp_init(&para);
+	BSP_disp_open();
+
+	return 0;
+}
+
+__s32 DRV_DISP_Exit(void)
+{
+	Fb_Exit();
+	BSP_disp_close();
+	BSP_disp_exit(g_disp_drv.exit_mode);
+
+	return 0;
+}
+
+static int
+disp_mem_request(int sel, __u32 size)
+{
+	unsigned map_size = 0;
+	struct page *page;
+
+	if (g_disp_mm[sel].info_base != NULL)
+		return -EINVAL;
+
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+	if (fb_size) {
+		void *ret = disp_malloc(size);
+		if (ret) {
+			g_disp_mm[sel].info_base = ret;
+			g_disp_mm[sel].mem_start =
+				virt_to_phys(g_disp_mm[sel].info_base);
+			memset(g_disp_mm[sel].info_base, 0, size);
+			__inf("pa=0x%08lx va=0x%p size:0x%x\n",
+			      g_disp_mm[sel].mem_start,
+			      g_disp_mm[sel].info_base, size);
+			return 0;
+		} else {
+			__wrn("disp_malloc fail!\n");
+			return -ENOMEM;
+		}
+	}
+#endif
+	g_disp_mm[sel].mem_len = size;
+	map_size = PAGE_ALIGN(g_disp_mm[sel].mem_len);
+
+	page = alloc_pages(GFP_KERNEL, get_order(map_size));
+	if (page != NULL) {
+		g_disp_mm[sel].info_base = page_address(page);
+		if (g_disp_mm[sel].info_base == NULL) {
+			free_pages((unsigned long)(page), get_order(map_size));
+			__wrn("page_address fail!\n");
+			return -ENOMEM;
+		}
+		g_disp_mm[sel].mem_start =
+		    virt_to_phys(g_disp_mm[sel].info_base);
+		memset(g_disp_mm[sel].info_base, 0, size);
+
+		__inf("pa=0x%08lx va=0x%p size:0x%x\n",
+		      g_disp_mm[sel].mem_start, g_disp_mm[sel].info_base, size);
+		return 0;
+	} else {
+		__wrn("alloc_pages fail!\n");
+		return -ENOMEM;
+	}
+}
+
+static int
+disp_mem_release(int sel)
+{
+	unsigned map_size = PAGE_ALIGN(g_disp_mm[sel].mem_len);
+
+	if (g_disp_mm[sel].info_base == NULL)
+		return -EINVAL;
+
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+	if (fb_size)
+		disp_free((void *)g_disp_mm[sel].info_base);
+	else
+#endif
+		free_pages((unsigned long)(g_disp_mm[sel].info_base),
+			   get_order(map_size));
+	memset(&g_disp_mm[sel], 0, sizeof(struct info_mm));
+	return 0;
+}
+
+static int disp_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	// - PAGE_OFFSET;
+	unsigned long physics = g_disp_mm[g_disp_mm_sel].mem_start;
+	unsigned long mypfn = physics >> PAGE_SHIFT;
+	unsigned long vmsize = vma->vm_end - vma->vm_start;
+
+	if (remap_pfn_range(vma, vma->vm_start, mypfn, vmsize,
+			    vma->vm_page_prot))
+		return -EAGAIN;
+
+	return 0;
+}
+
+/*
+ *
+ */
+struct dev_disp_data {
+	/* Version of the user of /dev/disp */
+#define SUNXI_DISP_VERSION_PENDING -1
+#define SUNXI_DISP_VERSION_SKIPPED -2
+	int version;
+	struct  {
+		__u32 layer[SUNXI_DISP_MAX_LAYERS];
+	} layers[2];
+};
+
+static int disp_open(struct inode *inode, struct file *filp)
+{
+	struct dev_disp_data *data =
+		kzalloc(sizeof(struct dev_disp_data), GFP_KERNEL);
+	static bool warned;
+
+	if (!data)
+		return -ENOMEM;
+
+	data->version = SUNXI_DISP_VERSION_PENDING;
+
+	filp->private_data = data;
+
+	if (!warned) {
+		pr_warn("Warning: this sunxi disp driver will see significant "
+			"redesign.\n");
+		pr_warn("Applications using /dev/disp directly will break.\n");
+		pr_warn("For more information visit: "
+			"http://linux-sunxi.org/Sunxi_disp_driver\n");
+		warned = true;
+	}
+
+	return 0;
+}
+
+static int disp_release(struct inode *inode, struct file *filp)
+{
+	struct dev_disp_data *data = filp->private_data;
+	int i,j;
+
+	for (j = 0; j < 2; j++)
+		for (i = 0; i < SUNXI_DISP_MAX_LAYERS ; i++)
+			if (data->layers[j].layer[i]) {
+				__wrn("layer allocated at close: %i,%u\n", j, data->layers[j].layer[i]);
+				BSP_disp_layer_release(j,data->layers[j].layer[i]);
+			}
+
+	kfree(data);
+	filp->private_data = NULL;
+
+	return 0;
+}
+
+static ssize_t disp_read(struct file *filp,
+		char __user *buf, size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+static ssize_t disp_write(struct file *filp,
+		const char __user *buf, size_t count, loff_t *ppos)
+{
+	return 0;
+}
+
+/*
+ * called when platform_driver_register
+ */
+static int __devinit disp_probe(struct platform_device *pdev)
+{
+	fb_info_t *info = NULL;
+
+	__inf("disp_probe call\n");
+
+	info = &g_fbi;
+	info->dev = &pdev->dev;
+	platform_set_drvdata(pdev, info);
+
+	info->base_image0 = 0xf1e60000;
+	info->base_image1 = 0xf1e40000;
+	info->base_scaler0 = 0xf1e00000;
+	info->base_scaler1 = 0xf1e20000;
+	info->base_lcdc0 = 0xf1c0c000;
+	info->base_lcdc1 = 0xf1c0d000;
+	info->base_tvec0 = 0xf1c0a000;
+	info->base_tvec1 = 0xf1c1b000;
+	info->base_ccmu = 0xf1c20000;
+	info->base_sdram = 0xf1c01000;
+	info->base_pioc = 0xf1c20800;
+	info->base_pwm = 0xf1c20c00;
+	info->base_iep = 0xf1e70000;
+	__inf("SCALER0 base 0x%08x\n", info->base_scaler0);
+	__inf("SCALER1 base 0x%08x\n", info->base_scaler1);
+	__inf("IMAGE0 base 0x%08x\n", info->base_image0 + 0x800);
+	__inf("IMAGE1 base 0x%08x\n", info->base_image1 + 0x800);
+	__inf("LCDC0 base 0x%08x\n", info->base_lcdc0);
+	__inf("LCDC1 base 0x%08x\n", info->base_lcdc1);
+	__inf("TVEC0 base 0x%08x\n", info->base_tvec0);
+	__inf("TVEC1 base 0x%08x\n", info->base_tvec1);
+	if (sunxi_is_sun5i())
+		__inf("IEP base 0x%08x\n", info->base_iep);
+	__inf("CCMU base 0x%08x\n", info->base_ccmu);
+	__inf("SDRAM base 0x%08x\n", info->base_sdram);
+	__inf("PIO base 0x%08x\n", info->base_pioc);
+	__inf("PWM base 0x%08x\n", info->base_pwm);
+
+	pr_info("sunxi disp driver loaded (/dev/disp api %d.%d)\n",
+		SUNXI_DISP_VERSION_MAJOR, SUNXI_DISP_VERSION_MINOR);
+
+	return 0;
+}
+
+static int disp_remove(struct platform_device *pdev)
+{
+	__inf("disp_remove call\n");
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+int disp_suspend(int clk, int status)
+{
+	int i = 0;
+
+	__inf("disp_suspend clk %d status %d call\n", clk, status);
+
+	if (clk != 1)
+	for (i = 0; i < 2; i++) {
+		suspend_output_type[i] = BSP_disp_get_output_type(i);
+		if (suspend_output_type[i] == DISP_OUTPUT_TYPE_LCD)
+			DRV_lcd_close(i);
+		else if (suspend_output_type[i] == DISP_OUTPUT_TYPE_TV)
+			BSP_disp_tv_close(i);
+		else if (suspend_output_type[i] == DISP_OUTPUT_TYPE_VGA)
+			BSP_disp_vga_close(i);
+		else if (suspend_output_type[i] == DISP_OUTPUT_TYPE_HDMI)
+			BSP_disp_hdmi_close(i);
+	}
+	BSP_disp_clk_off(clk);
+	suspend_status |= status;
+
+	return 0;
+}
+
+int disp_resume(int clk, int status)
+{
+	int i = 0;
+
+	__inf("disp_resume clk %d status %d call\n", clk, status);
+
+	BSP_disp_clk_on(clk);
+
+	if (clk != 1)
+	for (i = 0; i < 2; i++) {
+		if (suspend_output_type[i] == DISP_OUTPUT_TYPE_LCD)
+			DRV_lcd_open(i);
+		else if (suspend_output_type[i] == DISP_OUTPUT_TYPE_TV)
+			BSP_disp_tv_open(i);
+		else if (suspend_output_type[i] == DISP_OUTPUT_TYPE_VGA)
+			BSP_disp_vga_open(i);
+		else if (suspend_output_type[i] == DISP_OUTPUT_TYPE_HDMI)
+			BSP_disp_hdmi_open(i, 0);
+	}
+
+	suspend_status &= ~status;
+
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void backlight_early_suspend(struct early_suspend *h)
+{
+	disp_suspend(2, 1);
+}
+
+static void backlight_late_resume(struct early_suspend *h)
+{
+	disp_resume(2, 1);
+}
+
+static struct early_suspend backlight_early_suspend_handler = {
+	.level = EARLY_SUSPEND_LEVEL_DISABLE_FB,
+	.suspend = backlight_early_suspend,
+	.resume = backlight_late_resume,
+};
+#endif
+
+static int
+disp_normal_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int i;
+	console_lock();
+	for(i = 0; i < SUNXI_MAX_FB; i++)
+		fb_set_suspend(g_fbi.fbinfo[i], 1);
+	console_unlock();
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	disp_suspend(3, 3);
+#else
+	disp_suspend(1, 2);
+#endif
+	return 0;
+}
+
+static int
+disp_normal_resume(struct platform_device *pdev)
+{
+	int i;
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	disp_resume(3, 3);
+#else
+	disp_resume(1, 2);
+#endif
+	console_lock();
+	for(i = 0; i < SUNXI_MAX_FB; i++)
+		fb_set_suspend(g_fbi.fbinfo[i], 0);
+	console_unlock();
+	return 0;
+}
+
+static void
+disp_shutdown(struct platform_device *pdev)
+{
+	__u32 type = 0, i = 0;
+
+	for (i = 0; i < 2; i++) {
+		type = BSP_disp_get_output_type(i);
+		if (type == DISP_OUTPUT_TYPE_LCD)
+			DRV_lcd_close(i);
+	}
+}
+
+static long disp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct dev_disp_data *filp_data = filp->private_data;
+	unsigned long karg[4];
+	unsigned long ubuffer[4] = { 0 };
+	__s32 ret = 0;
+
+	if (copy_from_user
+	    ((void *)karg, (void __user *)arg, 4 * sizeof(unsigned long))) {
+		__wrn("copy_from_user fail\n");
+		return -EFAULT;
+	}
+
+	ubuffer[0] = *(unsigned long *)karg;
+	ubuffer[1] = (*(unsigned long *)(karg + 1));
+	ubuffer[2] = (*(unsigned long *)(karg + 2));
+	ubuffer[3] = (*(unsigned long *)(karg + 3));
+
+	/* Verify version handshake first. */
+	if (filp_data->version == SUNXI_DISP_VERSION_PENDING) {
+		if (cmd == DISP_CMD_VERSION) {
+			int version = *((int *) karg);
+
+			if (version < 0) {
+				pr_err("disp: process %d (%s) provided an "
+				       "invalid version.\n",
+				       current->pid, current->comm);
+				filp_data->version = SUNXI_DISP_VERSION_SKIPPED;
+				return -EINVAL;
+			}
+
+			if (version != SUNXI_DISP_VERSION)
+				pr_warn("disp: process %d (%s) has a different "
+				       "version: %d.%d (vs. %d.%d)\n",
+					current->pid, current->comm,
+					SUNXI_DISP_VERSION_MAJOR_GET(version),
+					SUNXI_DISP_VERSION_MINOR_GET(version),
+					SUNXI_DISP_VERSION_MAJOR,
+					SUNXI_DISP_VERSION_MINOR);
+
+			/* Add compatibility checks here */
+
+			filp_data->version = version;
+			return SUNXI_DISP_VERSION;
+		} else {
+			pr_err_once("disp: process %d (%s) has skipped "
+					"the version handshake.\n",
+					current->pid, current->comm);
+			filp_data->version = SUNXI_DISP_VERSION_SKIPPED;
+		}
+	}
+
+	if (cmd < DISP_CMD_FB_REQUEST) {
+		if ((ubuffer[0] != 0) && (ubuffer[0] != 1)) {
+			__wrn("para err in disp_ioctl, cmd = 0x%x,"
+			      "screen id = %d\n", cmd, (int)ubuffer[0]);
+			return -1;
+		}
+	}
+	if (suspend_status & 2) {
+		__wrn("ioctl:%x fail when in suspend!\n", cmd);
+		return -1;
+	}
+#if 0
+	if (cmd != DISP_CMD_TV_GET_INTERFACE &&
+	    cmd != DISP_CMD_HDMI_GET_HPD_STATUS &&
+	    cmd != DISP_CMD_GET_OUTPUT_TYPE && cmd != DISP_CMD_SCN_GET_WIDTH &&
+	    cmd != DISP_CMD_SCN_GET_HEIGHT && cmd != DISP_CMD_VIDEO_SET_FB &&
+	    cmd != DISP_CMD_VIDEO_GET_FRAME_ID)
+		DE_WRN("cmd:0x%x,%ld,%ld\n", cmd, ubuffer[0], ubuffer[1]);
+#endif
+
+	switch (cmd) {
+	/* ----disp global---- */
+	case DISP_CMD_SET_BKCOLOR:
+		{
+			__disp_color_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_color_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_set_bk_color(ubuffer[0], &para);
+			break;
+		}
+
+	case DISP_CMD_SET_COLORKEY:
+		{
+			__disp_colorkey_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_colorkey_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_set_color_key(ubuffer[0], &para);
+			break;
+		}
+
+	case DISP_CMD_SET_PALETTE_TBL:
+		if ((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0)) {
+			__wrn("para invalid in disp ioctrl "
+			      "DISP_CMD_SET_PALETTE_TBL,buffer:0x%x, "
+			      "size:0x%x\n", (unsigned int) ubuffer[1],
+			     (unsigned int) ubuffer[3]);
+			return -1;
+		}
+		if (copy_from_user(gbuffer, (void __user *) ubuffer[1],
+				   ubuffer[3])) {
+			__wrn("copy_from_user fail\n");
+			return -EFAULT;
+		}
+		ret = BSP_disp_set_palette_table(ubuffer[0], (__u32 *) gbuffer,
+						 ubuffer[2], ubuffer[3]);
+		break;
+
+	case DISP_CMD_GET_PALETTE_TBL:
+		if ((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0)) {
+			__wrn("para invalid in disp ioctrl "
+			      "DISP_CMD_GET_PALETTE_TBL,buffer:0x%x, "
+			      "size:0x%x\n", (unsigned int) ubuffer[1],
+			     (unsigned int) ubuffer[3]);
+			return -1;
+		}
+		ret =
+		    BSP_disp_get_palette_table(ubuffer[0], (__u32 *) gbuffer,
+					       ubuffer[2], ubuffer[3]);
+		if (copy_to_user((void __user *) ubuffer[1], gbuffer,
+				 ubuffer[3])) {
+			__wrn("copy_to_user fail\n");
+			return -EFAULT;
+		}
+		break;
+
+	case DISP_CMD_START_CMD_CACHE:
+		ret = BSP_disp_cmd_cache(ubuffer[0]);
+		break;
+
+	case DISP_CMD_EXECUTE_CMD_AND_STOP_CACHE:
+		ret = BSP_disp_cmd_submit(ubuffer[0]);
+		break;
+
+	case DISP_CMD_GET_OUTPUT_TYPE:
+		ret = BSP_disp_get_output_type(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SCN_GET_WIDTH:
+		ret = BSP_disp_get_screen_width(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SCN_GET_HEIGHT:
+		ret = BSP_disp_get_screen_height(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SET_GAMMA_TABLE:
+		if ((ubuffer[1] == 0) || ((int)ubuffer[2] <= 0)) {
+			__wrn("para invalid in disp ioctrl "
+			      "DISP_CMD_SET_GAMMA_TABLE,buffer:0x%x, "
+			      "size:0x%x\n", (unsigned int) ubuffer[1],
+			     (unsigned int) ubuffer[2]);
+			return -1;
+		}
+		if (copy_from_user(gbuffer, (void __user *) ubuffer[1],
+				   ubuffer[2])) {
+			__wrn("copy_from_user fail\n");
+			return -EFAULT;
+		}
+		ret = BSP_disp_set_gamma_table(ubuffer[0], (__u32 *) gbuffer,
+					     ubuffer[2]);
+		break;
+
+	case DISP_CMD_GAMMA_CORRECTION_ON:
+		ret = BSP_disp_gamma_correction_enable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_GAMMA_CORRECTION_OFF:
+		ret = BSP_disp_gamma_correction_disable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SET_BRIGHT:
+		ret = BSP_disp_set_bright(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_GET_BRIGHT:
+		ret = BSP_disp_get_bright(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SET_CONTRAST:
+		ret = BSP_disp_set_contrast(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_GET_CONTRAST:
+		ret = BSP_disp_get_contrast(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SET_SATURATION:
+		ret = BSP_disp_set_saturation(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_GET_SATURATION:
+		ret = BSP_disp_get_saturation(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SET_HUE:
+		ret = BSP_disp_set_hue(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_GET_HUE:
+		ret = BSP_disp_get_hue(ubuffer[0]);
+		break;
+	case DISP_CMD_ENHANCE_ON:
+		ret = BSP_disp_enhance_enable(ubuffer[0], 1);
+		break;
+
+	case DISP_CMD_ENHANCE_OFF:
+		ret = BSP_disp_enhance_enable(ubuffer[0], 0);
+		break;
+
+	case DISP_CMD_GET_ENHANCE_EN:
+		ret = BSP_disp_get_enhance_enable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_CAPTURE_SCREEN:
+		ret = BSP_disp_capture_screen(ubuffer[0],
+					      (__disp_capture_screen_para_t *)
+					      ubuffer[1]);
+		break;
+
+	case DISP_CMD_SET_SCREEN_SIZE:
+		ret = BSP_disp_set_screen_size(ubuffer[0],
+					       (__disp_rectsz_t *) ubuffer[1]);
+		break;
+
+	/* ----iep---- */
+	case DISP_CMD_DE_FLICKER_ON:
+		ret = BSP_disp_de_flicker_enable(ubuffer[0], 1);
+		break;
+
+	case DISP_CMD_DE_FLICKER_OFF:
+		ret = BSP_disp_de_flicker_enable(ubuffer[0], 0);
+		break;
+
+	case DISP_CMD_GET_DE_FLICKER_EN:
+		ret = BSP_disp_iep_get_deflicker_enable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_DRC_ON:
+		ret = BSP_disp_iep_drc_enable(ubuffer[0], 1);
+		break;
+
+	case DISP_CMD_DRC_OFF:
+		ret = BSP_disp_iep_drc_enable(ubuffer[0], 0);
+		break;
+
+	case DISP_CMD_GET_DRC_EN:
+		ret = BSP_disp_iep_get_drc_enable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_DE_FLICKER_SET_WINDOW:
+		{
+			__disp_rect_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_rect_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+
+			ret = BSP_disp_iep_set_demo_win(ubuffer[0], 1, &para);
+			break;
+		}
+
+	case DISP_CMD_DRC_SET_WINDOW:
+		{
+			__disp_rect_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_rect_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+
+			ret = BSP_disp_iep_set_demo_win(ubuffer[0], 2, &para);
+			break;
+		}
+
+	/* ----layer---- */
+	case DISP_CMD_LAYER_REQUEST:
+		ret = BSP_disp_layer_request(ubuffer[0],
+					     (__disp_layer_work_mode_t)
+					     ubuffer[1]);
+		if (ret != DIS_NULL) {
+			int i;
+			__wrn("layer allocated: %lu,%i\n", ubuffer[0], ret);
+			for (i = 0; i < SUNXI_DISP_MAX_LAYERS ; i++)
+				if (! filp_data->layers[ubuffer[0]].layer[i]) {
+					filp_data->layers[ubuffer[0]].layer[i] = ret;
+					break;
+				}
+			BUG_ON (i == SUNXI_DISP_MAX_LAYERS);
+		}
+		break;
+
+	case DISP_CMD_LAYER_RELEASE:
+		ret = BSP_disp_layer_release(ubuffer[0], ubuffer[1]);
+		if (ret == DIS_SUCCESS) {
+			int i;
+			__wrn("layer released: %lu,%lu\n", ubuffer[0], ubuffer[1]);
+			for (i = 0; i < SUNXI_DISP_MAX_LAYERS ; i++)
+				if (filp_data->layers[ubuffer[0]].layer[i] == ubuffer[1]) {
+					filp_data->layers[ubuffer[0]].layer[i] = 0;
+					break;
+				}
+			if (i == SUNXI_DISP_MAX_LAYERS)
+				__wrn("released layer not allocated in this session: %lu,%lu\n", ubuffer[0], ubuffer[1]);
+		}
+		break;
+
+	case DISP_CMD_LAYER_OPEN:
+		ret = BSP_disp_layer_open(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_CLOSE:
+		ret = BSP_disp_layer_close(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_FB:
+		{
+			__disp_fb_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_fb_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_layer_set_framebuffer(ubuffer[0],
+							     ubuffer[1], &para);
+			//DRV_disp_wait_cmd_finish(ubuffer[0]);
+			break;
+		}
+
+	case DISP_CMD_LAYER_GET_FB:
+		{
+			__disp_fb_t para;
+
+			ret = BSP_disp_layer_get_framebuffer(ubuffer[0],
+							     ubuffer[1], &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_fb_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_LAYER_SET_SRC_WINDOW:
+		{
+			__disp_rect_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_rect_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_layer_set_src_window(ubuffer[0],
+							    ubuffer[1], &para);
+			//DRV_disp_wait_cmd_finish(ubuffer[0]);
+			break;
+		}
+
+	case DISP_CMD_LAYER_GET_SRC_WINDOW:
+		{
+			__disp_rect_t para;
+
+			ret = BSP_disp_layer_get_src_window(ubuffer[0],
+							    ubuffer[1], &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_rect_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_LAYER_SET_SCN_WINDOW:
+		{
+			__disp_rect_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_rect_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_layer_set_screen_window(ubuffer[0],
+							       ubuffer[1],
+							       &para);
+			//DRV_disp_wait_cmd_finish(ubuffer[0]);
+			break;
+		}
+
+	case DISP_CMD_LAYER_GET_SCN_WINDOW:
+		{
+			__disp_rect_t para;
+
+			ret = BSP_disp_layer_get_screen_window(ubuffer[0],
+							       ubuffer[1],
+							       &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_rect_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_LAYER_SET_PARA:
+		{
+			__disp_layer_info_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_layer_info_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_layer_set_para(ubuffer[0], ubuffer[1],
+						      &para);
+			//DRV_disp_wait_cmd_finish(ubuffer[0]);
+			break;
+		}
+
+	case DISP_CMD_LAYER_GET_PARA:
+		{
+			__disp_layer_info_t para;
+
+			ret = BSP_disp_layer_get_para(ubuffer[0], ubuffer[1],
+						      &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_layer_info_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_LAYER_TOP:
+		ret = BSP_disp_layer_set_top(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_BOTTOM:
+		ret = BSP_disp_layer_set_bottom(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_ALPHA_ON:
+		ret = BSP_disp_layer_alpha_enable(ubuffer[0], ubuffer[1], 1);
+		break;
+
+	case DISP_CMD_LAYER_ALPHA_OFF:
+		ret = BSP_disp_layer_alpha_enable(ubuffer[0], ubuffer[1], 0);
+		break;
+
+	case DISP_CMD_LAYER_SET_ALPHA_VALUE:
+		ret = BSP_disp_layer_set_alpha_value(ubuffer[0], ubuffer[1],
+						     ubuffer[2]);
+		//DRV_disp_wait_cmd_finish(ubuffer[0]);
+		break;
+
+	case DISP_CMD_LAYER_CK_ON:
+		ret = BSP_disp_layer_colorkey_enable(ubuffer[0], ubuffer[1], 1);
+		break;
+
+	case DISP_CMD_LAYER_CK_OFF:
+		ret = BSP_disp_layer_colorkey_enable(ubuffer[0], ubuffer[1], 0);
+		break;
+
+	case DISP_CMD_LAYER_SET_PIPE:
+		ret = BSP_disp_layer_set_pipe(ubuffer[0], ubuffer[1],
+					      ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_ALPHA_VALUE:
+		ret = BSP_disp_layer_get_alpha_value(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_GET_ALPHA_EN:
+		ret = BSP_disp_layer_get_alpha_enable(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_GET_CK_EN:
+		ret = BSP_disp_layer_get_colorkey_enable(ubuffer[0],
+							 ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_GET_PRIO:
+		ret = BSP_disp_layer_get_piro(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_GET_PIPE:
+		ret = BSP_disp_layer_get_pipe(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_SMOOTH:
+		ret = BSP_disp_layer_set_smooth(ubuffer[0], ubuffer[1],
+						(__disp_video_smooth_t)
+						ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_SMOOTH:
+		ret = BSP_disp_layer_get_smooth(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_BRIGHT:
+		ret = BSP_disp_layer_set_bright(ubuffer[0], ubuffer[1],
+						ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_BRIGHT:
+		ret = BSP_disp_layer_get_bright(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_CONTRAST:
+		ret = BSP_disp_layer_set_contrast(ubuffer[0], ubuffer[1],
+						  ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_CONTRAST:
+		ret = BSP_disp_layer_get_contrast(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_SATURATION:
+		ret = BSP_disp_layer_set_saturation(ubuffer[0], ubuffer[1],
+						    ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_SATURATION:
+		ret = BSP_disp_layer_get_saturation(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_HUE:
+		ret = BSP_disp_layer_set_hue(ubuffer[0], ubuffer[1],
+					     ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_HUE:
+		ret = BSP_disp_layer_get_hue(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_ENHANCE_ON:
+		ret = BSP_disp_layer_enhance_enable(ubuffer[0], ubuffer[1], 1);
+		break;
+
+	case DISP_CMD_LAYER_ENHANCE_OFF:
+		ret = BSP_disp_layer_enhance_enable(ubuffer[0], ubuffer[1], 0);
+		break;
+
+	case DISP_CMD_LAYER_GET_ENHANCE_EN:
+		ret = BSP_disp_layer_get_enhance_enable(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_VPP_ON:
+		ret = BSP_disp_layer_vpp_enable(ubuffer[0], ubuffer[1], 1);
+		break;
+
+	case DISP_CMD_LAYER_VPP_OFF:
+		ret = BSP_disp_layer_vpp_enable(ubuffer[0], ubuffer[1], 0);
+		break;
+
+	case DISP_CMD_LAYER_GET_VPP_EN:
+		ret = BSP_disp_layer_get_vpp_enable(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_LUMA_SHARP_LEVEL:
+		ret = BSP_disp_layer_set_luma_sharp_level(ubuffer[0],
+							  ubuffer[1],
+							  ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_LUMA_SHARP_LEVEL:
+		ret =
+		    BSP_disp_layer_get_luma_sharp_level(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_CHROMA_SHARP_LEVEL:
+		ret = BSP_disp_layer_set_chroma_sharp_level(ubuffer[0],
+							    ubuffer[1],
+							    ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_CHROMA_SHARP_LEVEL:
+		ret = BSP_disp_layer_get_chroma_sharp_level(ubuffer[0],
+							    ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_WHITE_EXTEN_LEVEL:
+		ret = BSP_disp_layer_set_white_exten_level(ubuffer[0],
+							   ubuffer[1],
+							   ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_WHITE_EXTEN_LEVEL:
+		ret = BSP_disp_layer_get_white_exten_level(ubuffer[0],
+							   ubuffer[1]);
+		break;
+
+	case DISP_CMD_LAYER_SET_BLACK_EXTEN_LEVEL:
+		ret = BSP_disp_layer_set_black_exten_level(ubuffer[0],
+							   ubuffer[1],
+							   ubuffer[2]);
+		break;
+
+	case DISP_CMD_LAYER_GET_BLACK_EXTEN_LEVEL:
+		ret = BSP_disp_layer_get_black_exten_level(ubuffer[0],
+							   ubuffer[1]);
+		break;
+
+	/* ----scaler---- */
+	case DISP_CMD_SCALER_REQUEST:
+		ret = BSP_disp_scaler_request();
+		break;
+
+	case DISP_CMD_SCALER_RELEASE:
+		ret = BSP_disp_scaler_release(ubuffer[1]);
+		break;
+
+	case DISP_CMD_SCALER_EXECUTE:
+		{
+			__disp_scaler_para_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_scaler_para_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_scaler_start(ubuffer[1], &para);
+			break;
+		}
+
+	/* ----hwc---- */
+	case DISP_CMD_HWC_OPEN:
+		ret = BSP_disp_hwc_enable(ubuffer[0], 1);
+		break;
+
+	case DISP_CMD_HWC_CLOSE:
+		ret = BSP_disp_hwc_enable(ubuffer[0], 0);
+		break;
+
+	case DISP_CMD_HWC_SET_POS:
+		{
+			__disp_pos_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_pos_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_hwc_set_pos(ubuffer[0], &para);
+			break;
+		}
+
+	case DISP_CMD_HWC_GET_POS:
+		{
+			__disp_pos_t para;
+
+			ret = BSP_disp_hwc_get_pos(ubuffer[0], &para);
+			if (copy_to_user((void __user *)ubuffer[1], &para,
+					 sizeof(__disp_pos_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_HWC_SET_FB:
+		{
+			__disp_hwc_pattern_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_hwc_pattern_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_hwc_set_framebuffer(ubuffer[0], &para);
+			break;
+		}
+
+	case DISP_CMD_HWC_SET_PALETTE_TABLE:
+		if ((ubuffer[1] == 0) || ((int)ubuffer[3] <= 0)) {
+			__wrn("para invalid in display ioctrl "
+			      "DISP_CMD_HWC_SET_PALETTE_TABLE,buffer:0x%x, "
+			      "size:0x%x\n", (unsigned int)ubuffer[1],
+			     (unsigned int)ubuffer[3]);
+			return -1;
+		}
+		if (copy_from_user(gbuffer, (void __user *)ubuffer[1],
+				   ubuffer[3])) {
+			__wrn("copy_from_user fail\n");
+			return -EFAULT;
+		}
+		ret = BSP_disp_hwc_set_palette(ubuffer[0], (void *)gbuffer,
+					       ubuffer[2], ubuffer[3]);
+		break;
+
+	/* ----video---- */
+	case DISP_CMD_VIDEO_START:
+		ret = BSP_disp_video_start(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_VIDEO_STOP:
+		ret = BSP_disp_video_stop(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_VIDEO_SET_FB:
+		{
+			__disp_video_fb_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_video_fb_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_video_set_fb(ubuffer[0], ubuffer[1],
+						    &para);
+			break;
+		}
+
+	case DISP_CMD_VIDEO_GET_FRAME_ID:
+		ret = BSP_disp_video_get_frame_id(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_VIDEO_GET_DIT_INFO:
+		{
+			__disp_dit_info_t para;
+
+			ret = BSP_disp_video_get_dit_info(ubuffer[0],
+							  ubuffer[1],
+							  &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_dit_info_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	/* ----lcd---- */
+	case DISP_CMD_LCD_ON:
+		ret = DRV_lcd_open(ubuffer[0]);
+		if (suspend_status != 0)
+			suspend_output_type[ubuffer[0]] = DISP_OUTPUT_TYPE_LCD;
+		break;
+
+	case DISP_CMD_LCD_OFF:
+		ret = DRV_lcd_close(ubuffer[0]);
+		if (suspend_status != 0)
+			suspend_output_type[ubuffer[0]] = DISP_OUTPUT_TYPE_NONE;
+		break;
+
+	case DISP_CMD_LCD_SET_BRIGHTNESS:
+		ret = BSP_disp_lcd_set_bright(ubuffer[0], ubuffer[1], 0);
+		break;
+
+	case DISP_CMD_LCD_GET_BRIGHTNESS:
+		ret = BSP_disp_lcd_get_bright(ubuffer[0]);
+		break;
+
+	case DISP_CMD_LCD_CPUIF_XY_SWITCH:
+		ret = BSP_disp_lcd_xy_switch(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_LCD_SET_SRC:
+		ret = BSP_disp_lcd_set_src(ubuffer[0],
+					   (__disp_lcdc_src_t) ubuffer[1]);
+		break;
+
+	case DISP_CMD_LCD_USER_DEFINED_FUNC:
+		ret =  BSP_disp_lcd_user_defined_func(ubuffer[0], ubuffer[1],
+						      ubuffer[2], ubuffer[3]);
+		break;
+
+	/* ----pwm---- */
+	case DISP_CMD_PWM_SET_PARA:
+		ret = pwm_set_para(ubuffer[0], (__pwm_info_t *) ubuffer[1]);
+		break;
+
+	case DISP_CMD_PWM_GET_PARA:
+		ret = pwm_get_para(ubuffer[0], (__pwm_info_t *) ubuffer[1]);
+		break;
+
+	/* ----tv---- */
+	case DISP_CMD_TV_ON:
+		ret = BSP_disp_tv_open(ubuffer[0]);
+		if (suspend_status != 0)
+			suspend_output_type[ubuffer[0]] = DISP_OUTPUT_TYPE_TV;
+		break;
+
+	case DISP_CMD_TV_OFF:
+		ret = BSP_disp_tv_close(ubuffer[0]);
+		if (suspend_status != 0)
+			suspend_output_type[ubuffer[0]] = DISP_OUTPUT_TYPE_NONE;
+		break;
+
+	case DISP_CMD_TV_SET_MODE:
+		ret = BSP_disp_tv_set_mode(ubuffer[0],
+					   (__disp_tv_mode_t) ubuffer[1]);
+		break;
+
+	case DISP_CMD_TV_GET_MODE:
+		ret = BSP_disp_tv_get_mode(ubuffer[0]);
+		break;
+
+	case DISP_CMD_TV_AUTOCHECK_ON:
+		ret = BSP_disp_tv_auto_check_enable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_TV_AUTOCHECK_OFF:
+		ret = BSP_disp_tv_auto_check_disable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_TV_GET_INTERFACE:
+		if (suspend_status != 0)
+			ret = DISP_TV_NONE;
+		else
+			ret = BSP_disp_tv_get_interface(ubuffer[0]);
+		break;
+
+	case DISP_CMD_TV_SET_SRC:
+		ret = BSP_disp_tv_set_src(ubuffer[0],
+					  (__disp_lcdc_src_t) ubuffer[1]);
+		break;
+
+	case DISP_CMD_TV_GET_DAC_STATUS:
+		if (suspend_status != 0)
+			ret = 0;
+		else
+			ret = BSP_disp_tv_get_dac_status(ubuffer[0],
+							 ubuffer[1]);
+		break;
+
+	case DISP_CMD_TV_SET_DAC_SOURCE:
+		ret = BSP_disp_tv_set_dac_source(ubuffer[0], ubuffer[1],
+						 (__disp_tv_dac_source)
+						 ubuffer[2]);
+		break;
+
+	case DISP_CMD_TV_GET_DAC_SOURCE:
+		ret = BSP_disp_tv_get_dac_source(ubuffer[0], ubuffer[1]);
+		break;
+
+	/* ----hdmi---- */
+	case DISP_CMD_HDMI_ON:
+		ret = BSP_disp_hdmi_open(ubuffer[0], 0);
+		if (suspend_status != 0)
+			suspend_output_type[ubuffer[0]] = DISP_OUTPUT_TYPE_HDMI;
+		break;
+
+	case DISP_CMD_HDMI_OFF:
+		ret = BSP_disp_hdmi_close(ubuffer[0]);
+		if (suspend_status != 0)
+			suspend_output_type[ubuffer[0]] = DISP_OUTPUT_TYPE_NONE;
+		break;
+
+	case DISP_CMD_HDMI_SET_MODE:
+		ret = BSP_disp_hdmi_set_mode(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_HDMI_GET_MODE:
+		ret = BSP_disp_hdmi_get_mode(ubuffer[0]);
+		break;
+
+	case DISP_CMD_HDMI_GET_HPD_STATUS:
+		if (suspend_status != 0)
+			ret = 0;
+		else
+			ret = BSP_disp_hdmi_get_hpd_status(ubuffer[0]);
+		break;
+
+	case DISP_CMD_HDMI_SUPPORT_MODE:
+		ret = BSP_disp_hdmi_check_support_mode(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_HDMI_SET_SRC:
+		ret = BSP_disp_hdmi_set_src(ubuffer[0],
+					    (__disp_lcdc_src_t) ubuffer[1]);
+		break;
+
+	/* ----vga---- */
+	case DISP_CMD_VGA_ON:
+		ret = BSP_disp_vga_open(ubuffer[0]);
+		if (suspend_status != 0)
+			suspend_output_type[ubuffer[0]] = DISP_OUTPUT_TYPE_VGA;
+
+		break;
+
+	case DISP_CMD_VGA_OFF:
+		ret = BSP_disp_vga_close(ubuffer[0]);
+		if (suspend_status != 0)
+			suspend_output_type[ubuffer[0]] = DISP_OUTPUT_TYPE_NONE;
+
+		break;
+
+	case DISP_CMD_VGA_SET_MODE:
+		ret = BSP_disp_vga_set_mode(ubuffer[0],
+					    (__disp_vga_mode_t) ubuffer[1]);
+		break;
+
+	case DISP_CMD_VGA_GET_MODE:
+		ret = BSP_disp_vga_get_mode(ubuffer[0]);
+		break;
+
+	case DISP_CMD_VGA_SET_SRC:
+		ret = BSP_disp_vga_set_src(ubuffer[0],
+					   (__disp_lcdc_src_t) ubuffer[1]);
+		break;
+
+	/* ----sprite---- */
+	case DISP_CMD_SPRITE_OPEN:
+		ret = BSP_disp_sprite_open(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_CLOSE:
+		ret = BSP_disp_sprite_close(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_SET_FORMAT:
+		ret =
+		    BSP_disp_sprite_set_format(ubuffer[0],
+					       (__disp_pixel_fmt_t) ubuffer[1],
+					       (__disp_pixel_seq_t) ubuffer[2]);
+		break;
+
+	case DISP_CMD_SPRITE_GLOBAL_ALPHA_ENABLE:
+		ret = BSP_disp_sprite_alpha_enable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_GLOBAL_ALPHA_DISABLE:
+		ret = BSP_disp_sprite_alpha_disable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_ENABLE:
+		ret = BSP_disp_sprite_get_alpha_enable(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_SET_GLOBAL_ALPHA_VALUE:
+		ret = BSP_disp_sprite_set_alpha_vale(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_GET_GLOBAL_ALPHA_VALUE:
+		ret = BSP_disp_sprite_get_alpha_value(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_SET_ORDER:
+		ret = BSP_disp_sprite_set_order(ubuffer[0], ubuffer[1],
+						ubuffer[2]);
+		break;
+
+	case DISP_CMD_SPRITE_GET_TOP_BLOCK:
+		ret = BSP_disp_sprite_get_top_block(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_GET_BOTTOM_BLOCK:
+		ret = BSP_disp_sprite_get_bottom_block(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_SET_PALETTE_TBL:
+		if ((ubuffer[1] == 0) || ((int) ubuffer[3] <= 0)) {
+			__wrn("para invalid in display ioctrl "
+			      "DISP_CMD_SPRITE_SET_PALETTE_TBL,buffer:0x%x,"
+			      " size:0x%x\n", (unsigned int) ubuffer[1],
+			     (unsigned int) ubuffer[3]);
+			return -1;
+		}
+		if (copy_from_user(gbuffer, (void __user *)ubuffer[1],
+				   ubuffer[3])) {
+			__wrn("copy_from_user fail\n");
+			return -EFAULT;
+		}
+		ret = BSP_disp_sprite_set_palette_table(ubuffer[0],
+							(__u32 *) gbuffer,
+							ubuffer[2], ubuffer[3]);
+		break;
+
+	case DISP_CMD_SPRITE_GET_BLOCK_NUM:
+		ret = BSP_disp_sprite_get_block_number(ubuffer[0]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_REQUEST:
+		{
+			__disp_sprite_block_para_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_sprite_block_para_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_sprite_block_request(ubuffer[0], &para);
+			break;
+		}
+
+	case DISP_CMD_SPRITE_BLOCK_RELEASE:
+		ret = BSP_disp_sprite_block_release(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_SET_SCREEN_WINDOW:
+		{
+			__disp_rect_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_rect_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_sprite_block_set_screen_win(ubuffer[0],
+								   ubuffer[1],
+								   &para);
+			break;
+		}
+
+	case DISP_CMD_SPRITE_BLOCK_GET_SCREEN_WINDOW:
+		{
+			__disp_rect_t para;
+
+			ret = BSP_disp_sprite_block_get_srceen_win(ubuffer[0],
+								   ubuffer[1],
+								   &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_rect_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_SPRITE_BLOCK_SET_SOURCE_WINDOW:
+		{
+			__disp_rect_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_rect_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_sprite_block_set_src_win(ubuffer[0],
+								ubuffer[1],
+								&para);
+			break;
+		}
+
+	case DISP_CMD_SPRITE_BLOCK_GET_SOURCE_WINDOW:
+		{
+			__disp_rect_t para;
+
+			ret = BSP_disp_sprite_block_get_src_win(ubuffer[0],
+								ubuffer[1],
+								&para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_rect_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_SPRITE_BLOCK_SET_FB:
+		{
+			__disp_fb_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_fb_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_sprite_block_set_framebuffer(ubuffer[0],
+								    ubuffer[1],
+								    &para);
+			break;
+		}
+
+	case DISP_CMD_SPRITE_BLOCK_GET_FB:
+		{
+			__disp_fb_t para;
+
+			ret = BSP_disp_sprite_block_get_framebufer(ubuffer[0],
+								   ubuffer[1],
+								   &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_fb_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_SPRITE_BLOCK_SET_TOP:
+		ret = BSP_disp_sprite_block_set_top(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_SET_BOTTOM:
+		ret = BSP_disp_sprite_block_set_bottom(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_GET_PREV_BLOCK:
+		ret = BSP_disp_sprite_block_get_pre_block(ubuffer[0],
+							  ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_GET_NEXT_BLOCK:
+		ret = BSP_disp_sprite_block_get_next_block(ubuffer[0],
+							   ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_GET_PRIO:
+		ret = BSP_disp_sprite_block_get_prio(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_OPEN:
+		ret = BSP_disp_sprite_block_open(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_CLOSE:
+		ret = BSP_disp_sprite_block_close(ubuffer[0], ubuffer[1]);
+		break;
+
+	case DISP_CMD_SPRITE_BLOCK_SET_PARA:
+		{
+			__disp_sprite_block_para_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[2],
+					   sizeof(__disp_sprite_block_para_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = BSP_disp_sprite_block_set_para(ubuffer[0],
+							     ubuffer[1], &para);
+			break;
+		}
+
+	case DISP_CMD_SPRITE_BLOCK_GET_PARA:
+		{
+			__disp_sprite_block_para_t para;
+
+			ret = BSP_disp_sprite_block_get_para(ubuffer[0],
+							     ubuffer[1], &para);
+			if (copy_to_user((void __user *)ubuffer[2], &para,
+					 sizeof(__disp_sprite_block_para_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	/* ----framebuffer---- */
+	case DISP_CMD_FB_REQUEST:
+		{
+			__disp_fb_create_para_t para;
+
+			if (copy_from_user(&para, (void __user *)ubuffer[1],
+					   sizeof(__disp_fb_create_para_t))) {
+				__wrn("copy_from_user fail\n");
+				return -EFAULT;
+			}
+			ret = Display_Fb_Request(ubuffer[0], &para);
+			break;
+		}
+
+	case DISP_CMD_FB_RELEASE:
+		ret = Display_Fb_Release(ubuffer[0]);
+		break;
+
+	case DISP_CMD_FB_GET_PARA:
+		{
+			__disp_fb_create_para_t para;
+
+			ret = Display_Fb_get_para(ubuffer[0], &para);
+			if (copy_to_user((void __user *)ubuffer[1], &para,
+					 sizeof(__disp_fb_create_para_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_GET_DISP_INIT_PARA:
+		{
+			__disp_init_t para;
+
+			ret = Display_get_disp_init_para(&para);
+			if (copy_to_user((void __user *)ubuffer[0], &para,
+					 sizeof(__disp_init_t))) {
+				__wrn("copy_to_user fail\n");
+				return -EFAULT;
+			}
+			break;
+		}
+
+	case DISP_CMD_MEM_REQUEST:
+		ret = disp_mem_request(ubuffer[0], ubuffer[1]);
+		break;
+
+	/* ----for test---- */
+	case DISP_CMD_MEM_RELASE:
+		ret = disp_mem_release(ubuffer[0]);
+		break;
+
+	case DISP_CMD_MEM_SELIDX:
+		g_disp_mm_sel = ubuffer[0];
+		break;
+
+	case DISP_CMD_MEM_GETADR:
+		ret = g_disp_mm[ubuffer[0]].mem_start;
+		break;
+
+	case DISP_CMD_SUSPEND:
+		ret = disp_suspend(3, 3);
+		break;
+
+	case DISP_CMD_RESUME:
+		ret = disp_resume(3, 3);
+		break;
+
+	case DISP_CMD_PRINT_REG:
+		ret = BSP_disp_print_reg(1, ubuffer[0]);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static void
+disp_device_release(struct device *dev)
+{
+	/* FILL ME! */
+}
+
+static const struct file_operations disp_fops = {
+	.owner = THIS_MODULE,
+	.open = disp_open,
+	.release = disp_release,
+	.write = disp_write,
+	.read = disp_read,
+	.unlocked_ioctl = disp_ioctl,
+	.mmap = disp_mmap,
+};
+
+static struct platform_driver disp_driver = {
+	.probe = disp_probe,
+	.remove = disp_remove,
+	.suspend = disp_normal_suspend,
+	.resume = disp_normal_resume,
+	.shutdown = disp_shutdown,
+	.driver = {
+		.name = "disp",
+		.owner = THIS_MODULE,
+	},
+};
+
+static struct platform_device disp_device_sun4i = {
+	.name = "disp",
+	.id = -1,
+	.num_resources = 8,
+	.resource = disp_resource,
+	.dev = {
+		.release = disp_device_release,
+	}
+};
+
+static struct platform_device disp_device_sun5i = {
+	.name = "disp",
+	.id = -1,
+	.num_resources = 9,
+	.resource = disp_resource,
+	.dev = {
+		.release = disp_device_release,
+	}
+};
+
+static int __init disp_module_init(void)
+{
+	int ret, err;
+
+	__inf("disp_module_init\n");
+
+	alloc_chrdev_region(&devid, 0, 1, "disp");
+	my_cdev = cdev_alloc();
+	cdev_init(my_cdev, &disp_fops);
+	my_cdev->owner = THIS_MODULE;
+	err = cdev_add(my_cdev, devid, 1);
+	if (err) {
+		__wrn("cdev_add fail\n");
+		return -1;
+	}
+
+	disp_class = class_create(THIS_MODULE, "disp");
+	if (IS_ERR(disp_class)) {
+		__wrn("class_create fail\n");
+		return -1;
+	}
+
+	device_create(disp_class, NULL, devid, NULL, "disp");
+
+	if (sunxi_is_sun5i())
+		ret = platform_device_register(&disp_device_sun5i);
+	else
+		ret = platform_device_register(&disp_device_sun4i);
+
+	if (ret == 0)
+		ret = platform_driver_register(&disp_driver);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	register_early_suspend(&backlight_early_suspend_handler);
+#endif
+
+	return ret;
+}
+
+static void __exit disp_module_exit(void)
+{
+	__inf("disp_module_exit\n");
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&backlight_early_suspend_handler);
+#endif
+	DRV_DISP_Exit();
+
+	platform_driver_unregister(&disp_driver);
+	if (sunxi_is_sun5i())
+		platform_device_unregister(&disp_device_sun5i);
+	else
+		platform_device_unregister(&disp_device_sun4i);
+
+	device_destroy(disp_class, devid);
+	class_destroy(disp_class);
+
+	cdev_del(my_cdev);
+}
+
+module_init(disp_module_init);
+module_exit(disp_module_exit);
+
+MODULE_AUTHOR("danling_xiao");
+MODULE_DESCRIPTION("display driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:disp");
diff --git a/drivers/video/sunxi/disp/dev_disp.h b/drivers/video/sunxi/disp/dev_disp.h
new file mode 100644
index 0000000..f181097
--- /dev/null
+++ b/drivers/video/sunxi/disp/dev_disp.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DEV_DISP_H__
+#define __DEV_DISP_H__
+
+enum {
+	SUNXI_LCD,
+	SUNXI_HDMI
+};
+
+__s32 disp_create_heap(__u32 pHeapHead, __u32 nHeapSize);
+void *disp_malloc(__u32 num_bytes);
+void disp_free(void *p);
+
+__s32 DRV_disp_int_process(__u32 sel);
+
+__s32 DRV_DISP_Init(void);
+__s32 DRV_DISP_Exit(void);
+
+int disp_suspend(int clk, int status);
+int disp_resume(int clk, int status);
+
+int disp_check_fbmem(int sel, int width, int height);
+void hdmi_edid_received(unsigned char *edid, int block);
+__s32 Fb_Init(__u32 from);
+__s32 DRV_lcd_open(__u32 sel);
+__s32 DRV_lcd_close(__u32 sel);
+
+__s32 disp_set_hdmi_func(__disp_hdmi_func *func);
+__s32 disp_get_pll_freq(__u32 pclk, __u32 *pll_freq,  __u32 *pll_2x);
+
+#endif
diff --git a/drivers/video/sunxi/disp/dev_fb.c b/drivers/video/sunxi/disp/dev_fb.c
new file mode 100644
index 0000000..53e4c27
--- /dev/null
+++ b/drivers/video/sunxi/disp/dev_fb.c
@@ -0,0 +1,2061 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+
+#ifdef CONFIG_FB_SUNXI_UMP
+#include <ump/ump_kernel_interface.h>
+#endif
+
+#include "drv_disp_i.h"
+#include "dev_disp.h"
+#include "dev_fb.h"
+#include "disp_display.h"
+#include "disp_lcd.h"
+#include "disp_hdmi.h"
+
+fb_info_t g_fbi;
+static DEFINE_MUTEX(g_fbi_mutex);
+
+static int screen0_output_type = -1;
+module_param(screen0_output_type, int, 0444);
+MODULE_PARM_DESC(screen0_output_type, "0:none; 1:lcd; 2:tv; 3:hdmi; 4:vga");
+
+static char *screen0_output_mode;
+module_param(screen0_output_mode, charp, 0444);
+MODULE_PARM_DESC(screen0_output_mode,
+	"tv: pal, pal-svideo, ntsc, ntsc-svideo, pal-m, pal-m-svideo, pal-nc "
+	"or pal-nc-svideo "
+	"hdmi: <width>x<height><i|p><24|50|60> vga: <width>x<height> "
+	"hdmi modes can be prefixed with \"EDID:\". Then EDID will be used, "
+	"with the specified mode as a fallback, ie \"EDID:1280x720p60\".");
+
+static int screen1_output_type = -1;
+module_param(screen1_output_type, int, 0444);
+MODULE_PARM_DESC(screen1_output_type, "0:none; 1:lcd; 2:tv; 3:hdmi; 4:vga");
+
+static char *screen1_output_mode;
+module_param(screen1_output_mode, charp, 0444);
+MODULE_PARM_DESC(screen1_output_mode, "See screen0_output_mode");
+
+static const char * const tv_mode_names[] = {
+	[DISP_TV_MOD_PAL]		= "pal",
+	[DISP_TV_MOD_PAL_SVIDEO]	= "pal-svideo",
+	[DISP_TV_MOD_NTSC]		= "ntsc",
+	[DISP_TV_MOD_NTSC_SVIDEO]	= "ntsc-svideo",
+	[DISP_TV_MOD_PAL_M]		= "pal-m",
+	[DISP_TV_MOD_PAL_M_SVIDEO]	= "pal-m-svideo",
+	[DISP_TV_MOD_PAL_NC]		= "pal-nc",
+	[DISP_TV_MOD_PAL_NC_SVIDEO]	= "pal-nc-svideo",
+};
+
+static u32 tv_mode_to_frame_rate(u32 mode)
+{
+	switch (mode) {
+	case DISP_TV_MOD_1080P_24HZ:
+	case DISP_TV_MOD_1080P_24HZ_3D_FP:
+		return 24;
+	case DISP_TV_MOD_576I:
+	case DISP_TV_MOD_576P:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL_NC:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+	case DISP_TV_MOD_720P_50HZ:
+	case DISP_TV_MOD_720P_50HZ_3D_FP:
+	case DISP_TV_MOD_1080I_50HZ:
+	case DISP_TV_MOD_1080P_50HZ:
+		return 50;
+	default:
+		return 60;
+	}
+}
+
+static int parse_output_mode(char *mode, int type, int fallback, __bool *edid)
+{
+	u32 i, width, height, interlace, frame_rate;
+	char *ep;
+
+	if (type == DISP_OUTPUT_TYPE_TV) {
+		for (i = 0; i < ARRAY_SIZE(tv_mode_names); i++) {
+			if (tv_mode_names[i] &&
+					strcmp(mode, tv_mode_names[i]) == 0)
+				return i;
+		}
+		__wrn("Unsupported mode: %s, ignoring\n", mode);
+		return fallback;
+	}
+
+	if (type == DISP_OUTPUT_TYPE_HDMI && strncmp(mode, "EDID:", 5) == 0) {
+		*edid = true;
+		mode += 5;
+	}
+
+	width = simple_strtol(mode, &ep, 10);
+	if (*ep != 'x') {
+		__wrn("Invalid mode string: %s, ignoring\n", mode);
+		return fallback;
+	}
+	height = simple_strtol(ep + 1, &ep, 10);
+
+	if (type == DISP_OUTPUT_TYPE_HDMI) {
+		if (*ep == 'i') {
+			interlace = 1;
+		} else if (*ep == 'p') {
+			interlace = 0;
+		} else {
+			__wrn("Invalid tv-mode string: %s, ignoring\n", mode);
+			return fallback;
+		}
+		frame_rate = simple_strtol(ep + 1, &ep, 10);
+
+		for (i = 0; i < DISP_TV_MODE_NUM; i++) {
+			if (tv_mode_to_width(i) == width &&
+			    tv_mode_to_height(i) == height &&
+			    Disp_get_screen_scan_mode(i) == interlace &&
+			    tv_mode_to_frame_rate(i) == frame_rate) {
+				return i;
+			}
+		}
+	} else {
+		for (i = 0; i < DISP_VGA_MODE_NUM; i++) {
+			if (i == DISP_VGA_H1440_V900_RB)
+				i = DISP_VGA_H1920_V1080; /* Skip RB modes */
+
+			if (vga_mode_to_width(i) == width &&
+			    vga_mode_to_height(i) == height) {
+				return i;
+			}
+		}
+	}
+	__wrn("Unsupported mode: %s, ignoring\n", mode);
+	return fallback;
+}
+
+/*
+ *          0:ARGB  1:BRGA  2:ABGR  3:RGBA
+ *     seq:  ARGB    BRGA    ARGB    BRGA
+ * br_swqp:   0       0       1       1
+ */
+static __s32
+parser_disp_init_para(__disp_init_t *init_para)
+{
+	int value;
+	int i;
+
+	memset(init_para, 0, sizeof(__disp_init_t));
+
+	if (script_parser_fetch("disp_init", "disp_init_enable",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.disp_init_enable fail\n");
+		return -1;
+	}
+	init_para->b_init = value;
+
+	if (script_parser_fetch("disp_init", "disp_mode", &value, 1) < 0) {
+		__wrn("fetch script data disp_init.disp_mode fail\n");
+		return -1;
+	}
+	init_para->disp_mode = value;
+
+	/* screen0 */
+	if (screen0_output_type != -1)
+		value = screen0_output_type;
+	else if (script_parser_fetch("disp_init", "screen0_output_type",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.screen0_output_type fail\n");
+		return -1;
+	}
+
+	if (value == 0) {
+		init_para->output_type[0] = DISP_OUTPUT_TYPE_NONE;
+	} else if (value == 1) {
+		init_para->output_type[0] = DISP_OUTPUT_TYPE_LCD;
+	} else if (value == 2) {
+		init_para->output_type[0] = DISP_OUTPUT_TYPE_TV;
+	} else if (value == 3) {
+		init_para->output_type[0] = DISP_OUTPUT_TYPE_HDMI;
+	} else if (value == 4) {
+		init_para->output_type[0] = DISP_OUTPUT_TYPE_VGA;
+	} else {
+		__wrn("invalid screen0_output_type %d\n",
+		      init_para->output_type[0]);
+		return -1;
+	}
+
+	if (script_parser_fetch("disp_init", "screen0_output_mode",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.screen0_output_mode fail\n");
+		return -1;
+	}
+	if (init_para->output_type[0] == DISP_OUTPUT_TYPE_TV ||
+	    init_para->output_type[0] == DISP_OUTPUT_TYPE_HDMI) {
+		if (screen0_output_mode) {
+			init_para->tv_mode[0] = (__disp_tv_mode_t)
+				parse_output_mode(screen0_output_mode,
+					init_para->output_type[0], value,
+					&gdisp.screen[0].use_edid);
+		} else {
+			init_para->tv_mode[0] = (__disp_tv_mode_t) value;
+		}
+	} else if (init_para->output_type[0] == DISP_OUTPUT_TYPE_VGA) {
+		if (screen0_output_mode) {
+			init_para->vga_mode[0] = (__disp_vga_mode_t)
+				parse_output_mode(screen0_output_mode,
+					init_para->output_type[0], value,
+					&gdisp.screen[0].use_edid);
+		} else {
+			init_para->vga_mode[0] = (__disp_vga_mode_t) value;
+		}
+	}
+
+	/* screen1 */
+	if (screen1_output_type != -1)
+		value = screen1_output_type;
+	else if (script_parser_fetch("disp_init", "screen1_output_type",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.screen1_output_type fail\n");
+		return -1;
+	}
+
+	if (value == 0) {
+		init_para->output_type[1] = DISP_OUTPUT_TYPE_NONE;
+	} else if (value == 1) {
+		init_para->output_type[1] = DISP_OUTPUT_TYPE_LCD;
+	} else if (value == 2) {
+		init_para->output_type[1] = DISP_OUTPUT_TYPE_TV;
+	} else if (value == 3) {
+		init_para->output_type[1] = DISP_OUTPUT_TYPE_HDMI;
+	} else if (value == 4) {
+		init_para->output_type[1] = DISP_OUTPUT_TYPE_VGA;
+	} else {
+		__wrn("invalid screen1_output_type %d\n",
+		      init_para->output_type[1]);
+		return -1;
+	}
+
+	if (script_parser_fetch("disp_init", "screen1_output_mode",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.screen1_output_mode fail\n");
+		return -1;
+	}
+
+	if (init_para->output_type[1] == DISP_OUTPUT_TYPE_TV ||
+	    init_para->output_type[1] == DISP_OUTPUT_TYPE_HDMI) {
+		if (screen1_output_mode) {
+			init_para->tv_mode[1] = (__disp_tv_mode_t)
+				parse_output_mode(screen1_output_mode,
+					init_para->output_type[1], value,
+					&gdisp.screen[1].use_edid);
+		} else {
+			init_para->tv_mode[1] = (__disp_tv_mode_t) value;
+		}
+	} else if (init_para->output_type[1] == DISP_OUTPUT_TYPE_VGA) {
+		if (screen1_output_mode) {
+			init_para->vga_mode[1] = (__disp_vga_mode_t)
+				parse_output_mode(screen1_output_mode,
+					init_para->output_type[1], value,
+					&gdisp.screen[1].use_edid);
+		} else {
+			init_para->vga_mode[1] = (__disp_vga_mode_t) value;
+		}
+	}
+
+	/* fb0 */
+	if (script_parser_fetch("disp_init", "fb0_framebuffer_num",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.fb0_framebuffer_num fail\n");
+		return -1;
+	}
+	init_para->buffer_num[0] = value;
+
+	if (script_parser_fetch("disp_init", "fb0_format", &value, 1) < 0) {
+		__wrn("fetch script data disp_init.fb0_format fail\n");
+		return -1;
+	}
+	init_para->format[0] = value;
+
+	if (script_parser_fetch("disp_init", "fb0_pixel_sequence",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.fb0_pixel_sequence fail\n");
+		return -1;
+	}
+	init_para->seq[0] = value;
+
+	if (script_parser_fetch
+	    ("disp_init", "fb0_scaler_mode_enable", &value, 1) < 0) {
+		__wrn("fetch script data disp_init.fb0_scaler_mode_enable "
+		      "fail\n");
+		return -1;
+	}
+	init_para->scaler_mode[0] = value;
+
+	/* fb1 */
+	if (script_parser_fetch("disp_init", "fb1_framebuffer_num",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.fb1_framebuffer_num fail\n");
+		return -1;
+	}
+	init_para->buffer_num[1] = value;
+
+	if (script_parser_fetch("disp_init", "fb1_format", &value, 1) < 0) {
+		__wrn("fetch script data disp_init.fb1_format fail\n");
+		return -1;
+	}
+	init_para->format[1] = value;
+
+	if (script_parser_fetch("disp_init", "fb1_pixel_sequence",
+				&value, 1) < 0) {
+		__wrn("fetch script data disp_init.fb1_pixel_sequence fail\n");
+		return -1;
+	}
+	init_para->seq[1] = value;
+
+	if (script_parser_fetch
+	    ("disp_init", "fb1_scaler_mode_enable", &value, 1) < 0) {
+		__wrn("fetch script data disp_init.fb1_scaler_mode_enable "
+		      "fail\n");
+		return -1;
+	}
+	init_para->scaler_mode[1] = value;
+
+	__inf("====display init para begin====\n");
+	__inf("b_init:%d\n", init_para->b_init);
+	__inf("disp_mode:%d\n\n", init_para->disp_mode);
+	for (i = 0; i < 2; i++) {
+		__inf("output_type[%d]:%d\n", i, init_para->output_type[i]);
+		__inf("tv_mode[%d]:%d\n", i, init_para->tv_mode[i]);
+		__inf("vga_mode[%d]:%d\n\n", i, init_para->vga_mode[i]);
+	}
+	for (i = 0; i < 2; i++) {
+		__inf("buffer_num[%d]:%d\n", i, init_para->buffer_num[i]);
+		__inf("format[%d]:%d\n", i, init_para->format[i]);
+		__inf("seq[%d]:%d\n", i, init_para->seq[i]);
+		__inf("br_swap[%d]:%d\n", i, init_para->br_swap[i]);
+		__inf("b_scaler_mode[%d]:%d\n", i, init_para->scaler_mode[i]);
+	}
+	__inf("====display init para end====\n");
+
+	return 0;
+}
+
+#ifdef UNUSED
+static __s32
+fb_draw_colorbar(__u32 base, __u32 width, __u32 height,
+		 struct fb_var_screeninfo *var)
+{
+	__u32 i = 0, j = 0;
+
+	for (i = 0; i < height; i++) {
+		for (j = 0; j < width / 4; j++) {
+			__u32 offset = 0;
+
+			if (var->bits_per_pixel == 32) {
+				offset = width * i + j;
+				writel((((1 << var->transp.length) -
+						 1) << var->transp.offset) |
+					       (((1 << var->red.length) -
+						 1) << var->red.offset),
+						 base + offset * 4);
+
+				offset = width * i + j + width / 4;
+				writel((((1 << var->transp.length) -
+						 1) << var->transp.offset) |
+					       (((1 << var->green.length) -
+						 1) << var->green.offset),
+						 base + offset * 4);
+
+				offset = width * i + j + width / 4 * 2;
+				writel((((1 << var->transp.length) -
+						 1) << var->transp.offset) |
+					       (((1 << var->blue.length) -
+						 1) << var->blue.offset),
+						 base + offset * 4);
+
+				offset = width * i + j + width / 4 * 3;
+				writel((((1 << var->transp.length) -
+						 1) << var->transp.offset) |
+					       (((1 << var->red.length) -
+						 1) << var->red.offset) |
+					       (((1 << var->green.length) -
+						 1) << var->green.offset),
+						 base + offset * 4);
+			} else if (var->bits_per_pixel == 16) {
+				offset = width * i + j;
+				sys_put_hvalue(base + offset * 2,
+					       (((1 << var->transp.length) -
+						 1) << var->transp.offset) |
+					       (((1 << var->red.length) -
+						 1) << var->red.offset));
+
+				offset = width * i + j + width / 4;
+				sys_put_hvalue(base + offset * 2,
+					       (((1 << var->transp.length) -
+						 1) << var->transp.offset) |
+					       (((1 << var->green.length) -
+						 1) << var->green.offset));
+
+				offset = width * i + j + width / 4 * 2;
+				sys_put_hvalue(base + offset * 2,
+					       (((1 << var->transp.length) -
+						 1) << var->transp.offset) |
+					       (((1 << var->blue.length) -
+						 1) << var->blue.offset));
+
+				offset = width * i + j + width / 4 * 3;
+				sys_put_hvalue(base + offset * 2,
+					       (((1 << var->transp.length) -
+						 1) << var->transp.offset) |
+					       (((1 << var->red.length) -
+						 1) << var->red.
+						offset) |
+					       (((1 << var->green.length) -
+						 1) << var->green.offset));
+			}
+		}
+	}
+
+	return 0;
+}
+
+static __s32
+fb_draw_gray_pictures(__u32 base, __u32 width, __u32 height,
+		      struct fb_var_screeninfo *var)
+{
+	__u32 time = 0;
+
+	for (time = 0; time < 18; time++) {
+		__u32 i = 0, j = 0;
+
+		for (i = 0; i < height; i++) {
+			for (j = 0; j < width; j++) {
+				__u32 addr = base + (i * width + j) * 4;
+				__u32 value = (0xff << 24) |
+					((time * 15) << 16) |
+					((time * 15) << 8) | (time * 15);
+
+				writel(value, addr);
+			}
+		}
+		DE_WRN("----%d\n", time * 15);
+		msleep(1000 * 5);
+	}
+	return 0;
+}
+#endif /* UNUSED */
+
+static int __init Fb_map_video_memory(__u32 fb_id, struct fb_info *info)
+{
+	unsigned map_size = PAGE_ALIGN(info->fix.smem_len);
+	struct page *page;
+
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+	if (fb_size)
+		goto use_reserved_mem;
+#endif
+	page = alloc_pages(GFP_KERNEL, get_order(map_size));
+	if (page != NULL) {
+		info->screen_base = page_address(page);
+		info->fix.smem_start = virt_to_phys(info->screen_base);
+		memset(info->screen_base, 0, info->fix.smem_len);
+		__inf("Fb_map_video_memory, pa=0x%08lx size:0x%x\n",
+		      info->fix.smem_start, info->fix.smem_len);
+		return 0;
+	} else {
+		__wrn("alloc_pages fail!\n");
+		return -ENOMEM;
+	}
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+use_reserved_mem:
+	g_fbi.malloc_screen_base[fb_id] = disp_malloc(info->fix.smem_len);
+	if (g_fbi.malloc_screen_base[fb_id] == NULL)
+		return -ENOMEM;
+	info->fix.smem_start = (unsigned long)
+					__pa(g_fbi.malloc_screen_base[fb_id]);
+	info->screen_base = ioremap_wc(info->fix.smem_start,
+				       info->fix.smem_len);
+	__inf("Fb_map_video_memory: fb_id=%d, disp_malloc=%p, ioremap_wc=%p\n",
+		    fb_id, g_fbi.malloc_screen_base[fb_id], info->screen_base);
+	if (!info->screen_base) {
+		__wrn("ioremap_wc() failed, falling back to the existing "
+		      "cached mapping\n");
+		info->screen_base = g_fbi.malloc_screen_base[fb_id];
+	}
+	memset_io(info->screen_base, 0, info->fix.smem_len);
+
+	__inf("Fb_map_video_memory, pa=0x%08lx size:0x%x\n",
+	      info->fix.smem_start, info->fix.smem_len);
+
+	return 0;
+#endif
+}
+
+static inline void Fb_unmap_video_memory(__u32 fb_id, struct fb_info *info)
+{
+	unsigned map_size = PAGE_ALIGN(info->fix.smem_len);
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+	if (fb_size) {
+		if ((void *)info->screen_base !=
+					g_fbi.malloc_screen_base[fb_id]) {
+			__inf("Fb_unmap_video_memory: fb_id=%d, iounmap(%p)\n",
+				fb_id, info->screen_base);
+			iounmap(info->screen_base);
+		}
+		__inf("Fb_unmap_video_memory: fb_id=%d, disp_free(%p)\n",
+				fb_id, g_fbi.malloc_screen_base[fb_id]);
+		disp_free(g_fbi.malloc_screen_base[fb_id]);
+	} else
+#endif
+		free_pages((unsigned long)info->screen_base,
+			   get_order(map_size));
+}
+
+/*
+ * todo.
+ */
+static __s32
+disp_fb_to_var(__disp_pixel_fmt_t format, __disp_pixel_seq_t seq,
+	       __bool br_swap, struct fb_var_screeninfo *var)
+{
+	if (format == DISP_FORMAT_ARGB8888) {
+		var->bits_per_pixel = 32;
+		var->transp.length = 8;
+		var->red.length = 8;
+		var->green.length = 8;
+		var->blue.length = 8;
+		if (seq == DISP_SEQ_ARGB && br_swap == 0) { /* argb */
+			var->blue.offset = 0;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+			var->transp.offset = var->red.offset + var->red.length;
+		} else if (seq == DISP_SEQ_BGRA && br_swap == 0) { /* bgra */
+			var->transp.offset = 0;
+			var->red.offset =
+				var->transp.offset + var->transp.length;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset =
+				var->green.offset + var->green.length;
+		} else if (seq == DISP_SEQ_ARGB && br_swap == 1) { /* abgr */
+			var->red.offset = 0;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset =
+				var->green.offset + var->green.length;
+			var->transp.offset =
+				var->blue.offset + var->blue.length;
+		} else if (seq == DISP_SEQ_BGRA && br_swap == 1) { /* rgba */
+			var->transp.offset = 0;
+			var->blue.offset =
+				var->transp.offset + var->transp.length;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+		}
+	} else if (format == DISP_FORMAT_RGB888) {
+		var->bits_per_pixel = 24;
+		var->transp.length = 0;
+		var->red.length = 8;
+		var->green.length = 8;
+		var->blue.length = 8;
+		if (br_swap == 0) { /* rgb */
+			var->blue.offset = 0;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+		} else { /* bgr */
+			var->red.offset = 0;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset =
+				var->green.offset + var->green.length;
+		}
+	} else if (format == DISP_FORMAT_RGB655) {
+		var->bits_per_pixel = 16;
+		var->transp.length = 0;
+		var->red.length = 6;
+		var->green.length = 5;
+		var->blue.length = 5;
+		if (br_swap == 0) { /* rgb */
+			var->blue.offset = 0;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+		} else { /* bgr */
+			var->red.offset = 0;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset =
+				var->green.offset + var->green.length;
+		}
+	} else if (format == DISP_FORMAT_RGB565) {
+		var->bits_per_pixel = 16;
+		var->transp.length = 0;
+		var->red.length = 5;
+		var->green.length = 6;
+		var->blue.length = 5;
+		if (br_swap == 0) { /* rgb */
+			var->blue.offset = 0;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+		} else { /* bgr */
+			var->red.offset = 0;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset =
+				var->green.offset + var->green.length;
+		}
+	} else if (format == DISP_FORMAT_RGB556) {
+		var->bits_per_pixel = 16;
+		var->transp.length = 0;
+		var->red.length = 5;
+		var->green.length = 5;
+		var->blue.length = 6;
+		if (br_swap == 0) { /* rgb */
+			var->blue.offset = 0;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+		} else { /* bgr */
+			var->red.offset = 0;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset = var->blue.offset + var->blue.length;
+		}
+	} else if (format == DISP_FORMAT_ARGB1555) {
+		var->bits_per_pixel = 16;
+		var->transp.length = 1;
+		var->red.length = 5;
+		var->green.length = 5;
+		var->blue.length = 5;
+		if (br_swap == 0) { /* rgb */
+			var->blue.offset = 0;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+			var->transp.offset = var->red.offset + var->red.length;
+		} else { /* bgr */
+			var->red.offset = 0;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset =
+				var->green.offset + var->green.length;
+			var->transp.offset =
+				var->blue.offset + var->blue.length;
+		}
+	} else if (format == DISP_FORMAT_RGBA5551) {
+		var->bits_per_pixel = 16;
+		var->red.length = 5;
+		var->green.length = 5;
+		var->blue.length = 5;
+		var->transp.length = 1;
+		if (br_swap == 0) { /* rgba */
+			var->transp.offset = 0;
+			var->blue.offset =
+				var->transp.offset + var->transp.length;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+		} else { /* bgra */
+			var->transp.offset = 0;
+			var->red.offset =
+				var->transp.offset + var->transp.length;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset =
+				var->green.offset + var->green.length;
+		}
+	} else if (format == DISP_FORMAT_ARGB4444) {
+		var->bits_per_pixel = 16;
+		var->transp.length = 4;
+		var->red.length = 4;
+		var->green.length = 4;
+		var->blue.length = 4;
+		if (br_swap == 0) { /* argb */
+			var->blue.offset = 0;
+			var->green.offset = var->blue.offset + var->blue.length;
+			var->red.offset = var->green.offset + var->green.length;
+			var->transp.offset = var->red.offset + var->red.length;
+		} else { /* abgr */
+			var->red.offset = 0;
+			var->green.offset = var->red.offset + var->red.length;
+			var->blue.offset =
+				var->green.offset + var->green.length;
+			var->transp.offset =
+				var->blue.offset + var->blue.length;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * todo
+ */
+static __s32
+var_to_disp_fb(__disp_fb_t *fb, struct fb_var_screeninfo *var,
+	       struct fb_fix_screeninfo *fix)
+{
+	if (var->nonstd == 0) { /* argb */
+		var->reserved[0] = DISP_MOD_INTERLEAVED;
+		var->reserved[1] = DISP_FORMAT_ARGB8888;
+		var->reserved[2] = DISP_SEQ_ARGB;
+		var->reserved[3] = 0;
+
+		switch (var->bits_per_pixel) {
+		case 1:
+			var->red.offset = var->green.offset = var->blue.offset =
+			    0;
+			var->red.length = var->green.length = var->blue.length =
+			    1;
+			var->reserved[1] = DISP_FORMAT_1BPP;
+			break;
+
+		case 2:
+			var->red.offset = var->green.offset = var->blue.offset =
+			    0;
+			var->red.length = var->green.length = var->blue.length =
+			    2;
+			var->reserved[1] = DISP_FORMAT_2BPP;
+			break;
+
+		case 4:
+			var->red.offset = var->green.offset = var->blue.offset =
+			    0;
+			var->red.length = var->green.length = var->blue.length =
+			    4;
+			var->reserved[1] = DISP_FORMAT_4BPP;
+			break;
+
+		case 8:
+			var->red.offset = var->green.offset = var->blue.offset =
+			    0;
+			var->red.length = var->green.length = var->blue.length =
+			    8;
+			var->reserved[1] = DISP_FORMAT_8BPP;
+			break;
+
+		case 16:
+			if (var->red.length == 6 && var->green.length == 5 &&
+			    var->blue.length == 5) {
+				var->reserved[1] = DISP_FORMAT_RGB655;
+				if (var->red.offset == 10 &&
+				    var->green.offset == 5 &&
+				    var->blue.offset == 0) { /* rgb */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				} else if (var->blue.offset == 11 &&
+					   var->green.offset == 6 &&
+					   var->red.offset == 0) { /* bgr */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 1;
+				} else {
+					__wrn("invalid RGB655 format"
+					      "<red.offset:%d,green.offset:%d,"
+					      "blue.offset:%d>\n",
+					      var->red.offset,
+					      var->green.offset,
+					      var->blue.offset);
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				}
+
+			} else if (var->red.length == 5 &&
+				   var->green.length == 6 &&
+				   var->blue.length == 5) {
+				var->reserved[1] = DISP_FORMAT_RGB565;
+				if (var->red.offset == 11 &&
+				    var->green.offset == 5 &&
+				    var->blue.offset == 0) { /* rgb */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				} else if (var->blue.offset == 11 &&
+					   var->green.offset == 5 &&
+					   var->red.offset == 0) { /* bgr */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 1;
+				} else {
+					__wrn("invalid RGB565 format"
+					      "<red.offset:%d,green.offset:%d,"
+					      "blue.offset:%d>\n",
+					      var->red.offset,
+					      var->green.offset,
+					      var->blue.offset);
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				}
+			} else if (var->red.length == 5 &&
+				   var->green.length == 5 &&
+				   var->blue.length == 6) {
+				var->reserved[1] = DISP_FORMAT_RGB556;
+				if (var->red.offset == 11 &&
+				    var->green.offset == 6 &&
+				    var->blue.offset == 0) { /* rgb */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				} else if (var->blue.offset == 10 &&
+					   var->green.offset == 5 &&
+					   var->red.offset == 0) { /* bgr */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 1;
+				} else {
+					__wrn("invalid RGB556 format"
+					      "<red.offset:%d,green.offset:%d,"
+					      "blue.offset:%d>\n",
+					      var->red.offset,
+					      var->green.offset,
+					      var->blue.offset);
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				}
+			} else if (var->transp.length == 1 &&
+				   var->red.length == 5 &&
+				   var->green.length == 5 &&
+				   var->blue.length == 5) {
+				var->reserved[1] = DISP_FORMAT_ARGB1555;
+				if (var->transp.offset == 15 &&
+				    var->red.offset == 10 &&
+				    var->green.offset == 5 &&
+				    var->blue.offset == 0) { /* argb */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				} else if (var->transp.offset == 15 &&
+					   var->blue.offset == 10 &&
+					   var->green.offset == 5 &&
+					   var->red.offset == 0) { /* abgr */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 1;
+				} else {
+					__wrn("invalid ARGB1555 format"
+					      "<transp.offset:%d,red.offset:%d,"
+					      "green.offset:%d,"
+					      "blue.offset:%d>\n",
+					      var->transp.offset,
+					      var->red.offset,
+					      var->green.offset,
+					      var->blue.offset);
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				}
+			} else if (var->transp.length == 4 &&
+				   var->red.length == 4 &&
+				   var->green.length == 4 &&
+				   var->blue.length == 4) {
+				var->reserved[1] = DISP_FORMAT_ARGB4444;
+				if (var->transp.offset == 12 &&
+				    var->red.offset == 8 &&
+				    var->green.offset == 4 &&
+				    var->blue.offset == 0) { /* argb */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				} else if (var->transp.offset == 12 &&
+					   var->blue.offset == 8 &&
+					   var->green.offset == 4 &&
+					   var->red.offset == 0) { /* abgr */
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 1;
+				} else {
+					__wrn("invalid ARGB4444 format"
+					      "<transp.offset:%d,red.offset:%d,"
+					      "green.offset:%d,blue.offset:%d>"
+					      "\n", var->transp.offset,
+					     var->red.offset, var->green.offset,
+					     var->blue.offset);
+					var->reserved[2] = DISP_SEQ_ARGB;
+					var->reserved[3] = 0;
+				}
+			} else {
+				__wrn("invalid bits_per_pixel :%d\n",
+				      var->bits_per_pixel);
+				return -EINVAL;
+			}
+			break;
+
+		case 24:
+			var->red.length = 8;
+			var->green.length = 8;
+			var->blue.length = 8;
+			var->reserved[1] = DISP_FORMAT_RGB888;
+			if (var->red.offset == 16 &&
+			    var->green.offset == 8 &&
+			    var->blue.offset == 0) { /* rgb */
+				var->reserved[2] = DISP_SEQ_ARGB;
+				var->reserved[3] = 0;
+			} else if (var->blue.offset == 16 &&
+				   var->green.offset == 8 &&
+				   var->red.offset == 0) { /* bgr */
+				var->reserved[2] = DISP_SEQ_ARGB;
+				var->reserved[3] = 1;
+			} else {
+				__wrn("invalid RGB888 format"
+				      "<red.offset:%d,green.offset:%d,"
+				      "blue.offset:%d>\n",
+				      var->red.offset, var->green.offset,
+				      var->blue.offset);
+				var->reserved[2] = DISP_SEQ_ARGB;
+				var->reserved[3] = 0;
+			}
+			break;
+
+		case 32:
+			var->transp.length = 8;
+			var->red.length = 8;
+			var->green.length = 8;
+			var->blue.length = 8;
+			if (var->transp.offset == var->blue.offset ||
+			    var->transp.offset == var->red.offset) {
+				var->reserved[1] = DISP_FORMAT_ARGB888;
+				__inf("Mode:     ARGB888");
+			} else {
+				var->reserved[1] = DISP_FORMAT_ARGB8888;
+				__inf("Mode:     ARGB8888");
+			}
+
+			if (var->red.offset == 16 &&
+			    var->green.offset == 8 &&
+			    var->blue.offset == 0) { /* argb */
+				var->reserved[2] = DISP_SEQ_ARGB;
+				var->reserved[3] = 0;
+			} else if (var->blue.offset == 24 &&
+				   var->green.offset == 16 &&
+				   var->red.offset == 8) { /* bgra */
+				var->reserved[2] = DISP_SEQ_BGRA;
+				var->reserved[3] = 0;
+			} else if (var->blue.offset == 16 &&
+				   var->green.offset == 8 &&
+				   var->red.offset == 0) { /* abgr */
+				var->reserved[2] = DISP_SEQ_ARGB;
+				var->reserved[3] = 1;
+			} else if (var->red.offset == 24 &&
+				   var->green.offset == 16 &&
+				   var->blue.offset == 8) { /* rgba */
+				var->reserved[2] = DISP_SEQ_BGRA;
+				var->reserved[3] = 1;
+			} else {
+				__wrn("invalid argb format"
+				      "<transp.offset:%d,red.offset:%d,"
+				      "green.offset:%d,blue.offset:%d>\n",
+				      var->transp.offset, var->red.offset,
+				      var->green.offset, var->blue.offset);
+				var->reserved[2] = DISP_SEQ_ARGB;
+				var->reserved[3] = 0;
+			}
+			break;
+
+		default:
+			__wrn("invalid bits_per_pixel :%d\n",
+			      var->bits_per_pixel);
+			return -EINVAL;
+		}
+	}
+
+	fb->mode = var->reserved[0];
+	fb->format = var->reserved[1];
+	fb->seq = var->reserved[2];
+	fb->br_swap = var->reserved[3];
+	fb->size.width = var->xres_virtual;
+
+	fix->line_length = (var->xres_virtual * var->bits_per_pixel) / 8;
+
+	return 0;
+}
+
+static int Fb_open(struct fb_info *info, int user)
+{
+	return 0;
+}
+
+static int Fb_release(struct fb_info *info, int user)
+{
+	return 0;
+}
+
+static int Fb_wait_for_vsync(struct fb_info *info)
+{
+	unsigned long count;
+	__u32 sel = 0;
+	int ret;
+
+	for (sel = 0; sel < 2; sel++) {
+		if (((sel == 0) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
+
+			if (BSP_disp_get_output_type(sel) ==
+			    DISP_OUTPUT_TYPE_NONE) {
+				return 0;
+			}
+
+			count = g_fbi.wait_count[sel];
+			ret = wait_event_interruptible_timeout(g_fbi.wait[sel],
+							       count !=
+							       g_fbi.
+							       wait_count[sel],
+							       msecs_to_jiffies
+							       (50));
+			if (ret == 0) {
+				__inf("timeout\n");
+				return -ETIMEDOUT;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int Fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	__u32 sel = 0;
+
+	//__inf("Fb_pan_display\n");
+
+	for (sel = 0; sel < 2; sel++) {
+		if (((sel == 0) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
+			__s32 layer_hdl = g_fbi.layer_hdl[info->node][sel];
+			__disp_layer_info_t layer_para;
+			__u32 buffer_num = 1;
+			__u32 y_offset = 0;
+
+			if (g_fbi.fb_mode[info->node] ==
+			    FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS)
+				if (sel != var->reserved[0])
+					return -1;
+
+			if (g_fbi.fb_mode[info->node] ==
+			    FB_MODE_DUAL_SAME_SCREEN_TB)
+				buffer_num = 2;
+			if ((sel == 0) &&
+			    (g_fbi.fb_mode[info->node] ==
+				FB_MODE_DUAL_SAME_SCREEN_TB))
+				y_offset = var->yres / 2;
+
+			BSP_disp_layer_get_para(sel, layer_hdl, &layer_para);
+
+			if (layer_para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+				layer_para.src_win.x = var->xoffset;
+				layer_para.src_win.y = var->yoffset + y_offset;
+				layer_para.src_win.width = var->xres;
+				layer_para.src_win.height =
+					var->yres / buffer_num;
+
+				BSP_disp_layer_set_src_window(sel, layer_hdl,
+							      &(layer_para.
+								src_win));
+			} else {
+				layer_para.src_win.x = var->xoffset;
+				layer_para.src_win.y = var->yoffset + y_offset;
+				layer_para.src_win.width = var->xres;
+				layer_para.src_win.height =
+				    var->yres / buffer_num;
+
+				layer_para.scn_win.width = var->xres;
+				layer_para.scn_win.height =
+					var->yres / buffer_num;
+
+				BSP_disp_layer_set_src_window(sel, layer_hdl,
+							      &(layer_para.
+								src_win));
+				BSP_disp_layer_set_screen_window(sel, layer_hdl,
+								 &(layer_para.
+								   scn_win));
+			}
+		}
+	}
+
+	// Fb_wait_for_vsync(info);
+
+	return 0;
+}
+
+/*
+ * todo
+ */
+static int Fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	__disp_pixel_fmt_t fmt;
+	int dummy, sel;
+	__inf("Fb_check_var: %dx%d %dbits\n", var->xres, var->yres,
+	      var->bits_per_pixel);
+
+	for (sel = 0; sel < 2; sel++) {
+		if (!(((sel == 0) &&
+		       (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1)) ||
+		      ((sel == 1) &&
+		       (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) ||
+		    g_fbi.disp_init.output_type[sel] != DISP_OUTPUT_TYPE_HDMI)
+			continue;
+
+		/* Check that pll is found */
+		if (disp_get_pll_freq(
+			fb_videomode_pixclock_to_hdmi_pclk(var->pixclock),
+				&dummy, &dummy))
+			return -EINVAL;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		if (var->transp.length == 1 && var->transp.offset == 15)
+			fmt = DISP_FORMAT_ARGB1555;
+		else if (var->transp.length == 1 && var->transp.offset == 0)
+			fmt = DISP_FORMAT_RGBA5551;
+		else if (var->transp.length == 4)
+			fmt = DISP_FORMAT_ARGB4444;
+		else if (var->red.length == 6)
+			fmt = DISP_FORMAT_RGB655;
+		else if (var->green.length == 6)
+			fmt = DISP_FORMAT_RGB565;
+		else if (var->blue.length == 6)
+			fmt = DISP_FORMAT_RGB556;
+		else
+			return -EINVAL;
+
+		disp_fb_to_var(fmt, DISP_SEQ_P10, 0, var);
+		break;
+	case 24:
+		disp_fb_to_var(DISP_FORMAT_RGB888, DISP_SEQ_ARGB, 0, var);
+		break;
+	case 32:
+		disp_fb_to_var(DISP_FORMAT_ARGB8888, DISP_SEQ_ARGB, 0, var);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * todo
+ */
+static int Fb_set_par(struct fb_info *info)
+{
+	__u32 sel = 0;
+
+	__inf("Fb_set_par: %dx%d %dbits\n", info->var.xres, info->var.yres,
+	      info->var.bits_per_pixel);
+
+	for (sel = 0; sel < 2; sel++) {
+		if (((sel == 0) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) &&
+		     (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
+			struct fb_var_screeninfo *var = &info->var;
+			struct fb_fix_screeninfo *fix = &info->fix;
+			bool mode_changed = false;
+			__s32 layer_hdl = g_fbi.layer_hdl[info->node][sel];
+			__disp_layer_info_t layer_para;
+			__u32 buffer_num = 1;
+			__u32 y_offset = 0;
+
+
+			if (g_fbi.disp_init.output_type[sel] ==
+					DISP_OUTPUT_TYPE_HDMI) {
+				struct fb_videomode new_mode;
+				struct fb_videomode old_mode;
+				fb_var_to_videomode(&new_mode, var);
+				var->yres_virtual = new_mode.yres *
+						g_fbi.fb_para[sel].buffer_num;
+				BSP_disp_get_videomode(sel, &old_mode);
+				if (!fb_mode_is_equal(&new_mode, &old_mode)) {
+					mode_changed = (BSP_disp_set_videomode(
+							sel, &new_mode) == 0);
+
+				}
+			}
+
+			if (g_fbi.fb_mode[info->node] ==
+			    FB_MODE_DUAL_SAME_SCREEN_TB)
+				buffer_num = 2;
+
+			if ((sel == 0) && (g_fbi.fb_mode[info->node] ==
+			     FB_MODE_DUAL_SAME_SCREEN_TB))
+				y_offset = var->yres / 2;
+
+			BSP_disp_layer_get_para(sel, layer_hdl, &layer_para);
+
+			var_to_disp_fb(&(layer_para.fb), var, fix);
+			layer_para.src_win.x = var->xoffset;
+			layer_para.src_win.y = var->yoffset + y_offset;
+			layer_para.src_win.width = var->xres;
+			layer_para.src_win.height = var->yres / buffer_num;
+			if (layer_para.mode != DISP_LAYER_WORK_MODE_SCALER ||
+					mode_changed) {
+				layer_para.scn_win.width =
+					layer_para.src_win.width;
+				layer_para.scn_win.height =
+					layer_para.src_win.height;
+			}
+			BSP_disp_layer_set_para(sel, layer_hdl, &layer_para);
+		}
+	}
+	return 0;
+}
+
+static inline __u32 convert_bitfield(int val, struct fb_bitfield *bf)
+{
+	__u32 mask = ((1 << bf->length) - 1) << bf->offset;
+	return ((val >> (8 - bf->length)) << bf->offset) & mask;
+}
+
+static int Fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			unsigned blue, unsigned transp, struct fb_info *info)
+{
+	__u32 val;
+	__u32 ret = 0;
+	__u32 sel = 0;
+
+	switch (info->fix.visual) {
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < 256) {
+			for (sel = 0; sel < 2; sel++) {
+				if (((sel == 0) && (g_fbi.fb_mode[info->node] !=
+						    FB_MODE_SCREEN1)) ||
+				    ((sel == 1) && (g_fbi.fb_mode[info->node] !=
+						    FB_MODE_SCREEN0))) {
+					val = (transp << 24) | (red << 16) |
+						(green << 8) | blue;
+					BSP_disp_set_palette_table(sel, &val,
+								   regno * 4,
+								   4);
+				}
+			}
+		} else {
+			ret = -EINVAL;
+		}
+		break;
+	case FB_VISUAL_TRUECOLOR:
+		if (regno < 16) {
+			val = convert_bitfield(transp, &info->var.transp) |
+			    convert_bitfield(red, &info->var.red) |
+			    convert_bitfield(green, &info->var.green) |
+			    convert_bitfield(blue, &info->var.blue);
+			__inf("Fb_setcolreg,regno=%2d,a=%2X,r=%2X,g=%2X,b=%2X, "
+			      "result=%08X\n", regno, transp, red, green, blue,
+			      val);
+			((__u32 *) info->pseudo_palette)[regno] = val;
+		} else {
+			ret = -EINVAL;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int Fb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
+{
+	unsigned int j, r = 0;
+	unsigned char hred, hgreen, hblue, htransp = 0xff;
+	unsigned short *red, *green, *blue, *transp;
+
+	__inf("Fb_setcmap, cmap start:%d len:%d, %dbpp\n", cmap->start,
+	      cmap->len, info->var.bits_per_pixel);
+
+	red = cmap->red;
+	green = cmap->green;
+	blue = cmap->blue;
+	transp = cmap->transp;
+
+	for (j = 0; j < cmap->len; j++) {
+		hred = *red++;
+		hgreen = *green++;
+		hblue = *blue++;
+		if (transp)
+			htransp = (*transp++) & 0xff;
+		else
+			htransp = 0xff;
+
+		r = Fb_setcolreg(cmap->start + j, hred, hgreen, hblue, htransp,
+				 info);
+		if (r)
+			return r;
+	}
+
+	return 0;
+}
+
+static int
+Fb_blank(int blank_mode, struct fb_info *info)
+{
+	__u32 sel = 0;
+	int ret = 0;
+
+	__inf("Fb_blank,mode:%d\n", blank_mode);
+
+	switch (blank_mode)	{
+	case FB_BLANK_POWERDOWN:
+		disp_suspend(3, 3);
+		break;
+	case FB_BLANK_UNBLANK:
+		disp_resume(3, 3);
+		/* fall through */
+	case FB_BLANK_NORMAL:
+		for (sel = 0; sel < 2; sel++) {
+			if (((sel == 0) && (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1))
+			 || ((sel == 1) && (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0))) {
+				__s32 layer_hdl = g_fbi.layer_hdl[info->node][sel];
+
+				if (blank_mode == FB_BLANK_NORMAL)
+					BSP_disp_layer_close(sel, layer_hdl);
+				else
+					BSP_disp_layer_open(sel, layer_hdl);
+			}
+		}
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int Fb_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	// __inf("Fb_cursor\n");
+
+	return -EINVAL;
+}
+
+__s32 DRV_disp_int_process(__u32 sel)
+{
+	g_fbi.wait_count[sel]++;
+	wake_up_interruptible(&g_fbi.wait[sel]);
+
+	return 0;
+}
+
+#ifdef CONFIG_FB_SUNXI_UMP
+int (*disp_get_ump_secure_id) (struct fb_info *info, fb_info_t *g_fbi,
+			       unsigned long arg, int buf);
+EXPORT_SYMBOL(disp_get_ump_secure_id);
+#endif
+
+static int Fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	long ret = 0;
+	unsigned long layer_hdl = 0;
+#ifdef CONFIG_FB_SUNXI_UMP
+	int secure_id_buf_num = 0;
+#endif
+
+	switch (cmd) {
+	case FBIOGET_LAYER_HDL_0:
+		if (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN1) {
+			layer_hdl = g_fbi.layer_hdl[info->node][0];
+			ret = copy_to_user((void __user *)arg, &layer_hdl,
+					   sizeof(unsigned long));
+		} else {
+			ret = -1;
+		}
+		break;
+
+	case FBIOGET_LAYER_HDL_1:
+		if (g_fbi.fb_mode[info->node] != FB_MODE_SCREEN0) {
+			layer_hdl = g_fbi.layer_hdl[info->node][1];
+			ret = copy_to_user((void __user *)arg, &layer_hdl,
+					   sizeof(unsigned long));
+		} else {
+			ret = -1;
+		}
+		break;
+
+#if 0
+	case FBIOGET_VBLANK:
+		{
+			struct fb_vblank vblank;
+			__disp_tcon_timing_t tt;
+			__u32 line = 0;
+			__u32 sel;
+
+			sel = (g_fbi.fb_mode[info->node] == FB_MODE_SCREEN1) ?
+				1 : 0;
+			line = BSP_disp_get_cur_line(sel);
+			BSP_disp_get_timing(sel, &tt);
+
+			memset(&vblank, 0, sizeof(struct fb_vblank));
+			vblank.flags |= FB_VBLANK_HAVE_VBLANK;
+			vblank.flags |= FB_VBLANK_HAVE_VSYNC;
+
+			if (line <= (tt.ver_total_time - tt.ver_pixels))
+				vblank.flags |= FB_VBLANK_VBLANKING;
+
+			if ((line > tt.ver_front_porch) &&
+			    (line < (tt.ver_front_porch + tt.ver_sync_time)))
+				vblank.flags |= FB_VBLANK_VSYNCING;
+
+			if (copy_to_user((void __user *)arg, &vblank,
+					 sizeof(struct fb_vblank)))
+				ret = -EFAULT;
+
+			break;
+		}
+#endif
+
+	case FBIO_WAITFORVSYNC:
+		{
+			ret = Fb_wait_for_vsync(info);
+			break;
+		}
+
+#ifdef CONFIG_FB_SUNXI_UMP
+	case GET_UMP_SECURE_ID_BUF2:	/* flow trough */
+		secure_id_buf_num++;
+	case GET_UMP_SECURE_ID_BUF1:	/* flow trough */
+		secure_id_buf_num++;
+	case GET_UMP_SECURE_ID_SUNXI_FB:
+		{
+			if (!disp_get_ump_secure_id)
+				request_module("disp_ump");
+			if (disp_get_ump_secure_id)
+				return disp_get_ump_secure_id(info, &g_fbi, arg,
+							      secure_id_buf_num);
+			else
+				return -ENOTSUPP;
+		}
+#endif
+
+	default:
+		//__inf("not supported fb io cmd:%x\n", cmd);
+		break;
+	}
+	return ret;
+}
+
+static struct fb_ops dispfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = Fb_open,
+	.fb_release = Fb_release,
+	.fb_pan_display = Fb_pan_display,
+	.fb_ioctl = Fb_ioctl,
+	.fb_check_var = Fb_check_var,
+	.fb_set_par = Fb_set_par,
+	.fb_setcolreg = Fb_setcolreg,
+	.fb_setcmap = Fb_setcmap,
+	.fb_blank = Fb_blank,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_cursor = Fb_cursor,
+};
+
+__s32 Display_Fb_Request(__u32 fb_id, __disp_fb_create_para_t * fb_para)
+{
+	struct fb_info *info = NULL;
+	__s32 hdl = 0;
+	__disp_layer_info_t layer_para;
+	__u32 sel;
+	__u32 xres, yres;
+
+	__inf("Display_Fb_Request,fb_id:%d\n", fb_id);
+
+	info = g_fbi.fbinfo[fb_id];
+
+	xres = fb_para->width;
+	yres = fb_para->height;
+
+	info->var.xoffset = 0;
+	info->var.yoffset = 0;
+	info->var.xres = xres;
+	info->var.yres = yres;
+	info->var.xres_virtual = xres;
+	info->var.yres_virtual = yres * fb_para->buffer_num;
+	info->fix.line_length =
+		(fb_para->width * info->var.bits_per_pixel) >> 3;
+	info->fix.smem_len = PAGE_ALIGN(
+		info->fix.line_length * fb_para->height * fb_para->buffer_num);
+	Fb_map_video_memory(fb_id, info);
+
+	for (sel = 0; sel < 2; sel++) {
+		if (((sel == 0) && (fb_para->fb_mode != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) && (fb_para->fb_mode != FB_MODE_SCREEN0))) {
+			__u32 y_offset = 0, src_width = xres, src_height = yres;
+
+			if (((sel == 0) &&
+			     (fb_para->fb_mode == FB_MODE_SCREEN0 ||
+			      fb_para->fb_mode ==
+			      FB_MODE_DUAL_SAME_SCREEN_TB)) ||
+			    ((sel == 1) &&
+			     (fb_para->fb_mode == FB_MODE_SCREEN1)) ||
+			    ((sel == fb_para->primary_screen_id) &&
+			     (fb_para->fb_mode ==
+			      FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS))) {
+
+				struct fb_videomode mode;
+				if (BSP_disp_get_videomode(sel, &mode) == 0) {
+					fb_videomode_to_var(&info->var, &mode);
+					info->var.yres_virtual =
+						mode.yres * fb_para->buffer_num;
+				}
+			}
+
+			if (fb_para->fb_mode == FB_MODE_DUAL_SAME_SCREEN_TB) {
+				src_height = yres / 2;
+				if (sel == 0)
+					y_offset = yres / 2;
+			}
+
+			memset(&layer_para, 0, sizeof(__disp_layer_info_t));
+			layer_para.mode = fb_para->mode;
+			layer_para.scn_win.width = src_width;
+			layer_para.scn_win.height = src_height;
+			if (fb_para->fb_mode ==
+			    FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS) {
+				if (sel != fb_para->primary_screen_id) {
+					layer_para.mode =
+					    DISP_LAYER_WORK_MODE_SCALER;
+					layer_para.scn_win.width =
+					    fb_para->aux_output_width;
+					layer_para.scn_win.height =
+					    fb_para->aux_output_height;
+				} else if (fb_para->mode ==
+					   DISP_LAYER_WORK_MODE_SCALER) {
+					layer_para.scn_win.width =
+					    fb_para->output_width;
+					layer_para.scn_win.height =
+					    fb_para->output_height;
+				}
+			} else if (fb_para->mode ==
+				   DISP_LAYER_WORK_MODE_SCALER) {
+				layer_para.scn_win.width =
+				    fb_para->output_width;
+				layer_para.scn_win.height =
+				    fb_para->output_height;
+			}
+
+			hdl = BSP_disp_layer_request(sel, layer_para.mode);
+
+			layer_para.pipe = 0;
+			layer_para.alpha_en = 1;
+			layer_para.alpha_val = 0xff;
+			layer_para.ck_enable = 0;
+			layer_para.src_win.x = 0;
+			layer_para.src_win.y = y_offset;
+			layer_para.src_win.width = src_width;
+			layer_para.src_win.height = src_height;
+			layer_para.scn_win.x = 0;
+			layer_para.scn_win.y = 0;
+			var_to_disp_fb(&(layer_para.fb), &(info->var),
+				       &(info->fix));
+			layer_para.fb.addr[0] = (__u32) info->fix.smem_start;
+			layer_para.fb.addr[1] = 0;
+			layer_para.fb.addr[2] = 0;
+			layer_para.fb.size.width = fb_para->width;
+			layer_para.fb.size.height = fb_para->height;
+			layer_para.fb.cs_mode = DISP_BT601;
+			layer_para.b_from_screen = 0;
+			BSP_disp_layer_set_para(sel, hdl, &layer_para);
+
+			BSP_disp_layer_open(sel, hdl);
+
+			g_fbi.layer_hdl[fb_id][sel] = hdl;
+		}
+	}
+
+	g_fbi.fb_enable[fb_id] = 1;
+	g_fbi.fb_mode[fb_id] = fb_para->fb_mode;
+	memcpy(&g_fbi.fb_para[fb_id], fb_para, sizeof(__disp_fb_create_para_t));
+
+	return DIS_SUCCESS;
+}
+
+__s32 Display_Fb_Release(__u32 fb_id)
+{
+	struct fb_info *info = g_fbi.fbinfo[fb_id];
+	__u32 sel = 0;
+
+	__inf("Display_Fb_Release, fb_id:%d\n", fb_id);
+
+	if (!g_fbi.fb_enable[fb_id])
+		return DIS_SUCCESS;
+
+	for (sel = 0; sel < 2; sel++)
+		if (((sel == 0) && (g_fbi.fb_mode[fb_id] != FB_MODE_SCREEN1)) ||
+		    ((sel == 1) && (g_fbi.fb_mode[fb_id] != FB_MODE_SCREEN0))) {
+			__s32 layer_hdl = g_fbi.layer_hdl[fb_id][sel];
+
+			BSP_disp_layer_release(sel, layer_hdl);
+		}
+
+	g_fbi.layer_hdl[fb_id][0] = 0;
+	g_fbi.layer_hdl[fb_id][1] = 0;
+	g_fbi.fb_mode[fb_id] = FB_MODE_SCREEN0;
+	memset(&g_fbi.fb_para[fb_id], 0, sizeof(__disp_fb_create_para_t));
+	g_fbi.fb_enable[fb_id] = 0;
+
+	fb_dealloc_cmap(&info->cmap);
+	Fb_unmap_video_memory(fb_id, info);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Display_Fb_get_para(__u32 fb_id, __disp_fb_create_para_t *fb_para)
+{
+	__inf("Display_Fb_Release, fb_id:%d\n", fb_id);
+
+	if ((fb_id >= 0) && g_fbi.fb_enable[fb_id]) {
+		memcpy(fb_para, &g_fbi.fb_para[fb_id],
+		       sizeof(__disp_fb_create_para_t));
+
+		return DIS_SUCCESS;
+	} else {
+		__wrn("invalid paras fb_id:%d in Display_Fb_get_para\n", fb_id);
+		return DIS_FAIL;
+	}
+}
+
+__s32 Display_get_disp_init_para(__disp_init_t *init_para)
+{
+	memcpy(init_para, &g_fbi.disp_init, sizeof(__disp_init_t));
+
+	return 0;
+}
+
+__s32 Display_set_fb_timing(__u32 sel)
+{
+	__u8 fb_id = 0;
+
+	for (fb_id = 0; fb_id < SUNXI_MAX_FB; fb_id++) {
+		__disp_fb_create_para_t *fb_para = &g_fbi.fb_para[fb_id];
+		__fb_mode_t fb_mode = g_fbi.fb_mode[fb_id];
+		struct fb_var_screeninfo *var = &g_fbi.fbinfo[sel]->var;
+		if (g_fbi.fb_enable[fb_id]) {
+			if (((sel == 0) &&
+			     (fb_mode == FB_MODE_SCREEN0 ||
+				 fb_mode == FB_MODE_DUAL_SAME_SCREEN_TB)) ||
+			    ((sel == 1) &&
+			     (fb_mode == FB_MODE_SCREEN1)) ||
+			    ((sel == fb_para->primary_screen_id) &&
+			     (fb_mode ==
+			      FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS))) {
+
+				struct fb_videomode mode;
+				if (BSP_disp_get_videomode(sel, &mode) == 0) {
+					fb_videomode_to_var(var, &mode);
+					var->yres_virtual = mode.yres *
+						fb_para->buffer_num;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+int disp_check_fbmem(int sel, int width, int height)
+{
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+	int i, bytes_per_pixel, needed;
+
+	/* If necessary determine sel */
+	if (sel == -1) {
+		for (i = 0; i < 2; i++) {
+			if (g_fbi.disp_init.output_type[i] ==
+       						DISP_OUTPUT_TYPE_HDMI) {
+				sel = i;
+				break;
+			}
+		}
+		if (sel == -1)
+			return -1;
+	}
+
+	/* Get bytes_per_pixel */
+	if (g_fbi.disp_init.format[sel] == DISP_FORMAT_ARGB8888)
+		bytes_per_pixel = 4;
+	else if (g_fbi.disp_init.format[sel] == DISP_FORMAT_RGB888)
+		bytes_per_pixel = 3;
+	else
+		bytes_per_pixel = 2;
+
+	/* And finally check we've enough mem */
+	needed = width * height * bytes_per_pixel *
+	         g_fbi.disp_init.buffer_num[sel];
+        if (needed > fb_size) {
+		pr_warn("fbdev: %dx%d needs %d bytes, but only %ld avail.\n",
+		        width, height, needed, fb_size);
+		return -1;
+	}
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(disp_check_fbmem);
+
+void hdmi_edid_received(unsigned char *edid, int block_count)
+{
+	struct fb_event event;
+	struct fb_modelist *m, *n;
+	int dummy;
+	__u32 sel = 0;
+	__u32 block = 0;
+	LIST_HEAD(old_modelist);
+
+	mutex_lock(&g_fbi_mutex);
+	for (sel = 0; sel < 2; sel++) {
+		struct fb_info *fbi = g_fbi.fbinfo[sel];
+		int err = 0;
+
+		if (g_fbi.disp_init.output_type[sel] != DISP_OUTPUT_TYPE_HDMI)
+			continue;
+
+		if (g_fbi.fb_registered[sel]) {
+			if (!lock_fb_info(fbi))
+				continue;
+
+			console_lock();
+		}
+
+		for (block = 0; block < block_count; block++) {
+			if (block == 0) {
+				if (fbi->monspecs.modedb != NULL) {
+					fb_destroy_modedb(fbi->monspecs.modedb);
+					fbi->monspecs.modedb = NULL;
+				}
+
+				fb_edid_to_monspecs(edid, &fbi->monspecs);
+			} else {
+				fb_edid_add_monspecs(edid + 0x80 * block, &fbi->monspecs);
+			}
+		}
+
+		if (fbi->monspecs.modedb_len == 0) {
+			/*
+			 * Should not happen? Avoid panics and skip in this
+			 * case.
+			 */
+			if (g_fbi.fb_registered[sel]) {
+				console_unlock();
+				unlock_fb_info(fbi);
+			}
+
+			WARN_ON(fbi->monspecs.modedb_len == 0);
+			continue;
+		}
+
+		list_splice(&fbi->modelist, &old_modelist);
+
+		fb_videomode_to_modelist(fbi->monspecs.modedb,
+					 fbi->monspecs.modedb_len,
+					 &fbi->modelist);
+
+		/* Filter out modes which we cannot do */
+		list_for_each_entry_safe(m, n, &fbi->modelist, list) {
+			if (disp_get_pll_freq(
+				fb_videomode_pixclock_to_hdmi_pclk(
+				    m->mode.pixclock), &dummy, &dummy) != 0 ||
+			    disp_check_fbmem(sel,
+					   m->mode.xres, m->mode.yres) != 0) {
+				list_del(&m->list);
+				kfree(m);
+			}
+		}
+		/*
+		 * When edid is not enabled make sure the current mode is in
+		 * the mode-list, so that the user-set mode is honored.
+		 */
+		if (!gdisp.screen[sel].use_edid) {
+			struct fb_videomode videomode;
+			if (BSP_disp_get_videomode(sel, &videomode) == 0)
+				fb_add_videomode(&videomode, &fbi->modelist);
+		}
+		/* Are there any usable modes left? */
+		if (list_empty(&fbi->modelist)) {
+			list_splice(&old_modelist, &fbi->modelist);
+			pr_warn("EDID: No modes with good pixelclock found\n");
+			continue;
+		}
+
+		/*
+		 * Tell framebuffer users that modelist was replaced. This is
+		 * to avoid use of old removed modes and to avoid panics.
+		 */
+		event.info = fbi;
+		err = fb_notifier_call_chain(FB_EVENT_NEW_MODELIST, &event);
+
+		fb_destroy_modelist(&old_modelist);
+
+		if (g_fbi.fb_registered[sel]) {
+			console_unlock();
+			unlock_fb_info(fbi);
+		}
+
+		WARN_ON(err);
+	}
+	mutex_unlock(&g_fbi_mutex);
+}
+EXPORT_SYMBOL(hdmi_edid_received);
+
+/* ??? --libv */
+extern unsigned long fb_start;
+extern unsigned long fb_size;
+
+__s32 Fb_Init(__u32 from)
+{
+	__s32 i;
+	__bool need_open_hdmi = 0;
+	__disp_fb_create_para_t fb_para = {
+		.primary_screen_id = 0,
+	};
+	static DEFINE_MUTEX(fb_init_mutex);
+	static bool first_time = true;
+
+	mutex_lock(&fb_init_mutex);
+	if (first_time) { /* First call ? */
+		DRV_DISP_Init();
+
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+		__inf("fbmem: fb_start=%lu, fb_size=%lu\n", fb_start, fb_size);
+		disp_create_heap((unsigned long)(__va(fb_start)), fb_size);
+#endif
+
+		for (i = 0; i < SUNXI_MAX_FB; i++) {
+			g_fbi.fbinfo[i] = framebuffer_alloc(0, g_fbi.dev);
+			INIT_LIST_HEAD(&g_fbi.fbinfo[i]->modelist);
+			g_fbi.fbinfo[i]->fbops = &dispfb_ops;
+			g_fbi.fbinfo[i]->flags = 0;
+			g_fbi.fbinfo[i]->device = g_fbi.dev;
+			g_fbi.fbinfo[i]->par = &g_fbi;
+			g_fbi.fbinfo[i]->var.xoffset = 0;
+			g_fbi.fbinfo[i]->var.yoffset = 0;
+			g_fbi.fbinfo[i]->var.xres = 800;
+			g_fbi.fbinfo[i]->var.yres = 480;
+			g_fbi.fbinfo[i]->var.xres_virtual = 800;
+			g_fbi.fbinfo[i]->var.yres_virtual = 480 * 2;
+			g_fbi.fbinfo[i]->var.nonstd = 0;
+			g_fbi.fbinfo[i]->var.grayscale = 0;
+			g_fbi.fbinfo[i]->var.bits_per_pixel = 32;
+			g_fbi.fbinfo[i]->var.transp.length = 8;
+			g_fbi.fbinfo[i]->var.red.length = 8;
+			g_fbi.fbinfo[i]->var.green.length = 8;
+			g_fbi.fbinfo[i]->var.blue.length = 8;
+			g_fbi.fbinfo[i]->var.transp.offset = 24;
+			g_fbi.fbinfo[i]->var.red.offset = 16;
+			g_fbi.fbinfo[i]->var.green.offset = 8;
+			g_fbi.fbinfo[i]->var.blue.offset = 0;
+			g_fbi.fbinfo[i]->var.activate = FB_ACTIVATE_FORCE;
+			g_fbi.fbinfo[i]->fix.type = FB_TYPE_PACKED_PIXELS;
+			g_fbi.fbinfo[i]->fix.type_aux = 0;
+			g_fbi.fbinfo[i]->fix.visual = FB_VISUAL_TRUECOLOR;
+			g_fbi.fbinfo[i]->fix.xpanstep = 1;
+			g_fbi.fbinfo[i]->fix.ypanstep = 1;
+			g_fbi.fbinfo[i]->fix.ywrapstep = 0;
+			g_fbi.fbinfo[i]->fix.accel = FB_ACCEL_NONE;
+			g_fbi.fbinfo[i]->fix.line_length =
+				g_fbi.fbinfo[i]->var.xres_virtual * 4;
+			g_fbi.fbinfo[i]->fix.smem_len = PAGE_ALIGN(
+				g_fbi.fbinfo[i]->fix.line_length *
+				g_fbi.fbinfo[i]->var.yres_virtual * 2);
+			g_fbi.fbinfo[i]->screen_base = NULL;
+			g_fbi.fbinfo[i]->pseudo_palette =
+				g_fbi.pseudo_palette[i];
+			g_fbi.fbinfo[i]->fix.smem_start = 0x0;
+			g_fbi.fbinfo[i]->fix.mmio_start = 0;
+			g_fbi.fbinfo[i]->fix.mmio_len = 0;
+
+			if (fb_alloc_cmap(&g_fbi.fbinfo[i]->cmap, 256, 1) < 0)
+				return -ENOMEM;
+		}
+		parser_disp_init_para(&(g_fbi.disp_init));
+		first_time = false;
+	}
+	mutex_unlock(&fb_init_mutex);
+
+	if (g_fbi.disp_init.b_init) {
+		__u32 sel = 0;
+
+		for (sel = 0; sel < 2; sel++) {
+			if (((sel == 0) && (g_fbi.disp_init.disp_mode !=
+					    DISP_INIT_MODE_SCREEN1)) ||
+			    ((sel == 1) && (g_fbi.disp_init.disp_mode !=
+					    DISP_INIT_MODE_SCREEN0))) {
+				if (g_fbi.disp_init.output_type[sel] ==
+				    DISP_OUTPUT_TYPE_HDMI)
+					need_open_hdmi = 1;
+			}
+		}
+	}
+
+	__inf("Fb_Init: %d %d\n", from, need_open_hdmi);
+
+	if (need_open_hdmi == 1 && from == SUNXI_LCD)
+		/* it is called from lcd driver, but hdmi need to be opened */
+		return 0;
+	else if (need_open_hdmi == 0 && from == SUNXI_HDMI)
+		/* it is called from hdmi driver, but hdmi need not be opened */
+		return 0;
+
+	if (g_fbi.disp_init.b_init) {
+		__u32 fb_num = 0, sel = 0;
+
+		for (sel = 0; sel < 2; sel++) {
+			if (((sel == 0) && (g_fbi.disp_init.disp_mode !=
+					    DISP_INIT_MODE_SCREEN1)) ||
+			    ((sel == 1) && (g_fbi.disp_init.disp_mode !=
+					    DISP_INIT_MODE_SCREEN0))) {
+				if (g_fbi.disp_init.output_type[sel] ==
+				    DISP_OUTPUT_TYPE_LCD) {
+					DRV_lcd_open(sel);
+				} else if (g_fbi.disp_init.output_type[sel] ==
+					   DISP_OUTPUT_TYPE_TV) {
+					BSP_disp_tv_set_mode(sel,
+							     g_fbi.disp_init.
+							     tv_mode[sel]);
+					BSP_disp_tv_open(sel);
+				} else if (g_fbi.disp_init.output_type[sel] ==
+					   DISP_OUTPUT_TYPE_HDMI) {
+					BSP_disp_hdmi_set_mode(sel,
+							       g_fbi.disp_init.
+							       tv_mode[sel]);
+					BSP_disp_hdmi_open(sel,
+						gdisp.screen[sel].use_edid);
+				} else if (g_fbi.disp_init.output_type[sel] ==
+					   DISP_OUTPUT_TYPE_VGA) {
+					BSP_disp_vga_set_mode(sel,
+							      g_fbi.disp_init.
+							      vga_mode[sel]);
+					BSP_disp_vga_open(sel);
+				}
+			}
+		}
+
+		fb_num = (g_fbi.disp_init.disp_mode ==
+			  DISP_INIT_MODE_TWO_DIFF_SCREEN) ? 2 : 1;
+		for (i = 0; i < fb_num; i++) {
+			__u32 screen_id = i;
+
+			disp_fb_to_var(g_fbi.disp_init.format[i],
+				       g_fbi.disp_init.seq[i],
+				       g_fbi.disp_init.br_swap[i],
+				       &(g_fbi.fbinfo[i]->var));
+
+			if (g_fbi.disp_init.disp_mode ==
+			    DISP_INIT_MODE_SCREEN1)
+				screen_id = 1;
+
+			fb_para.buffer_num = g_fbi.disp_init.buffer_num[i];
+			fb_para.width = BSP_disp_get_screen_width(screen_id);
+			fb_para.height = BSP_disp_get_screen_height(screen_id);
+			fb_para.output_width =
+				BSP_disp_get_screen_width(screen_id);
+			fb_para.output_height =
+				BSP_disp_get_screen_height(screen_id);
+			fb_para.mode = (g_fbi.disp_init.scaler_mode[i] == 0) ?
+				DISP_LAYER_WORK_MODE_NORMAL :
+				DISP_LAYER_WORK_MODE_SCALER;
+			if (g_fbi.disp_init.disp_mode ==
+			    DISP_INIT_MODE_SCREEN0) {
+				fb_para.fb_mode = FB_MODE_SCREEN0;
+			} else if (g_fbi.disp_init.disp_mode ==
+				   DISP_INIT_MODE_SCREEN1) {
+				fb_para.fb_mode = FB_MODE_SCREEN1;
+			} else if (g_fbi.disp_init.disp_mode ==
+				   DISP_INIT_MODE_TWO_DIFF_SCREEN) {
+				if (i == 0)
+					fb_para.fb_mode = FB_MODE_SCREEN0;
+				else
+					fb_para.fb_mode = FB_MODE_SCREEN1;
+			} else if (g_fbi.disp_init.disp_mode ==
+				   DISP_INIT_MODE_TWO_SAME_SCREEN) {
+				fb_para.fb_mode = FB_MODE_DUAL_SAME_SCREEN_TB;
+				fb_para.height *= 2;
+				fb_para.output_height *= 2;
+			} else if (g_fbi.disp_init.disp_mode ==
+				   DISP_INIT_MODE_TWO_DIFF_SCREEN_SAME_CONTENTS) {
+				fb_para.fb_mode =
+				    FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS;
+				fb_para.output_width =
+				    BSP_disp_get_screen_width(fb_para.
+							      primary_screen_id);
+				fb_para.output_height =
+				    BSP_disp_get_screen_height(fb_para.
+							       primary_screen_id);
+				fb_para.aux_output_width =
+				    BSP_disp_get_screen_width(1 -
+							      fb_para.
+							      primary_screen_id);
+				fb_para.aux_output_height =
+				    BSP_disp_get_screen_height(1 -
+							       fb_para.
+							       primary_screen_id);
+			}
+			Display_Fb_Request(i, &fb_para);
+
+#if 0
+			fb_draw_colorbar((__u32)g_fbi.fbinfo[i]->screen_base,
+					 fb_para.width, fb_para.height *
+					 fb_para.buffer_num,
+					 &(g_fbi.fbinfo[i]->var));
+#endif
+		}
+
+		mutex_lock(&g_fbi_mutex);
+		for (i = 0; i < SUNXI_MAX_FB; i++) {
+			/* Register framebuffers after they are initialized */
+			register_framebuffer(g_fbi.fbinfo[i]);
+			g_fbi.fb_registered[i] = true;
+		}
+		mutex_unlock(&g_fbi_mutex);
+
+		if (g_fbi.disp_init.scaler_mode[0])
+			BSP_disp_print_reg(0, DISP_REG_SCALER0);
+
+		if (g_fbi.disp_init.scaler_mode[1])
+			BSP_disp_print_reg(0, DISP_REG_SCALER1);
+
+		if (g_fbi.disp_init.disp_mode != DISP_INIT_MODE_SCREEN1) {
+			BSP_disp_print_reg(0, DISP_REG_IMAGE0);
+			BSP_disp_print_reg(0, DISP_REG_LCDC0);
+			if ((g_fbi.disp_init.output_type[0] ==
+			     DISP_OUTPUT_TYPE_TV) ||
+			    (g_fbi.disp_init.output_type[0] ==
+			     DISP_OUTPUT_TYPE_VGA))
+				BSP_disp_print_reg(0, DISP_REG_TVEC0);
+		}
+		if (g_fbi.disp_init.disp_mode != DISP_INIT_MODE_SCREEN0) {
+			BSP_disp_print_reg(0, DISP_REG_IMAGE1);
+			BSP_disp_print_reg(0, DISP_REG_LCDC1);
+			if ((g_fbi.disp_init.output_type[1] ==
+			     DISP_OUTPUT_TYPE_TV) ||
+			    (g_fbi.disp_init.output_type[1] ==
+			     DISP_OUTPUT_TYPE_VGA))
+				BSP_disp_print_reg(0, DISP_REG_TVEC1);
+		}
+		BSP_disp_print_reg(0, DISP_REG_CCMU);
+		BSP_disp_print_reg(0, DISP_REG_PWM);
+		BSP_disp_print_reg(0, DISP_REG_PIOC);
+	}
+
+	__inf("Fb_Init: END\n");
+	return 0;
+}
+EXPORT_SYMBOL(Fb_Init);
+
+__s32 Fb_Exit(void)
+{
+	__u8 fb_id = 0;
+
+	for (fb_id = 0; fb_id < SUNXI_MAX_FB; fb_id++) {
+		if (g_fbi.fbinfo[fb_id] == NULL)
+			continue;
+
+		Display_Fb_Release(fb_id);
+
+		unregister_framebuffer(g_fbi.fbinfo[fb_id]);
+		framebuffer_release(g_fbi.fbinfo[fb_id]);
+		g_fbi.fbinfo[fb_id] = NULL;
+	}
+
+	return 0;
+}
diff --git a/drivers/video/sunxi/disp/dev_fb.h b/drivers/video/sunxi/disp/dev_fb.h
new file mode 100644
index 0000000..4245661
--- /dev/null
+++ b/drivers/video/sunxi/disp/dev_fb.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DEV_FB_H__
+#define __DEV_FB_H__
+
+#define SUNXI_MAX_FB 2
+
+typedef struct {
+	struct device *dev;
+
+	__u32 base_image0;
+	__u32 base_image1;
+	__u32 base_scaler0;
+	__u32 base_scaler1;
+	__u32 base_lcdc0;
+	__u32 base_lcdc1;
+	__u32 base_tvec0;
+	__u32 base_tvec1;
+	__u32 base_hdmi;
+	__u32 base_ccmu;
+	__u32 base_sdram;
+	__u32 base_pioc;
+	__u32 base_pwm;
+	__u32 base_iep;
+	__disp_init_t disp_init;
+
+	__bool fb_enable[SUNXI_MAX_FB];
+	__bool fb_registered[SUNXI_MAX_FB];
+	__fb_mode_t fb_mode[SUNXI_MAX_FB];
+	/*
+	 * [fb_id][0]: screen0 layer handle;
+	 * [fb_id][1]: screen1 layer handle
+	 */
+	__u32 layer_hdl[SUNXI_MAX_FB][2];
+	struct fb_info *fbinfo[SUNXI_MAX_FB];
+	__disp_fb_create_para_t fb_para[SUNXI_MAX_FB];
+	wait_queue_head_t wait[SUNXI_MAX_FB];
+	unsigned long wait_count[SUNXI_MAX_FB];
+	__u32 pseudo_palette[SUNXI_MAX_FB][16];
+#ifdef CONFIG_FB_SUNXI_UMP
+	ump_dd_handle ump_wrapped_buffer[SUNXI_MAX_FB][3];
+#endif
+	/* screen_base address, allocated with disp_malloc() */
+	void *malloc_screen_base[SUNXI_MAX_FB];
+} fb_info_t;
+
+extern fb_info_t g_fbi;
+
+#ifdef CONFIG_FB_SUNXI_UMP
+extern int (*disp_get_ump_secure_id) (struct fb_info *info, fb_info_t *g_fbi,
+				      unsigned long arg, int buf);
+#endif
+
+__s32 Display_Fb_Request(__u32 fb_id, __disp_fb_create_para_t *fb_para);
+__s32 Display_Fb_Release(__u32 fb_id);
+__s32 Display_Fb_get_para(__u32 fb_id, __disp_fb_create_para_t *fb_para);
+
+__s32 Display_get_disp_init_para(__disp_init_t *init_para);
+
+__s32 Fb_Exit(void);
+
+#endif /* __DEV_FB_H__ */
diff --git a/drivers/video/sunxi/disp/disp_clk.c b/drivers/video/sunxi/disp/disp_clk.c
new file mode 100644
index 0000000..abd1877
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_clk.c
@@ -0,0 +1,1183 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display_i.h"
+#include "disp_display.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+#include "OSAL_Clock.h"
+
+#define CLK_ON 1
+#define CLK_OFF 0
+#define RST_INVALID 0
+#define RST_VALID   1
+
+#define CLK_DEBE0_AHB_ON	0x00000001
+#define CLK_DEBE0_MOD_ON	0x00000002
+#define CLK_DEBE0_DRAM_ON	0x00000004
+#define CLK_DEBE1_AHB_ON	0x00000010
+#define CLK_DEBE1_MOD_ON	0x00000020
+#define CLK_DEBE1_DRAM_ON	0x00000040
+#define CLK_DEFE0_AHB_ON	0x00000100
+#define CLK_DEFE0_MOD_ON	0x00000200
+#define CLK_DEFE0_DRAM_ON	0x00000400
+#define CLK_DEFE1_AHB_ON	0x00001000
+#define CLK_DEFE1_MOD_ON	0x00002000
+#define CLK_DEFE1_DRAM_ON	0x00004000
+#define CLK_LCDC0_AHB_ON	0x00010000
+#define CLK_LCDC0_MOD0_ON	0x00020000
+/* represent lcd0-ch1-clk1 and lcd0-ch1-clk2 */
+#define CLK_LCDC0_MOD1_ON	0x00040000
+#define CLK_LCDC1_AHB_ON	0x00100000
+#define CLK_LCDC1_MOD0_ON	0x00200000
+/* represent lcd1-ch1-clk1 and lcd1-ch1-clk2 */
+#define CLK_LCDC1_MOD1_ON	0x00400000
+#define CLK_TVENC0_AHB_ON	0x01000000
+#define CLK_TVENC1_AHB_ON	0x02000000
+#define CLK_HDMI_AHB_ON		0x10000000
+#define CLK_HDMI_MOD_ON		0x20000000
+//#define CLK_LVDS_MOD_ON
+
+static __hdle h_debe0ahbclk, h_debe0mclk, h_debe0dramclk;
+static __hdle h_debe1ahbclk, h_debe1mclk, h_debe1dramclk;
+static __hdle h_defe0ahbclk, h_defe0mclk, h_defe0dramclk;
+static __hdle h_defe1ahbclk, h_defe1mclk, h_defe1dramclk;
+static __hdle h_tvenc0ahbclk;
+static __hdle h_tvenc1ahbclk;
+static __hdle h_lcd0ahbclk, h_lcd0ch0mclk0, h_lcd0ch1mclk1, h_lcd0ch1mclk2;
+static __hdle h_lcd1ahbclk, h_lcd1ch0mclk0, h_lcd1ch1mclk1, h_lcd1ch1mclk2;
+static __hdle h_lvdsmclk;		/* only for reset */
+static __hdle h_hdmiahbclk, h_hdmimclk;
+
+__u32 g_clk_status;
+
+#define RESET_OSAL
+
+/* record tv/vga/hdmi mode clock requirement */
+__disp_clk_tab clk_tab = {
+	/* { LCDx_CH1_CLK2, CLK2/CLK1, HDMI_CLK, PLL_CLK, PLLX2 req}, MODE, INDEX (FOLLOW enum order) */
+	{ /* TV mode and HDMI mode */
+	  /* HDG: Note only HDMI_CLK is used now, and only in TV mode. */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_480I, 0x0 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_576I, 0x1 */
+		{ 54000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_480P, 0x2 */
+		{ 54000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_576P, 0x3 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_720P_50HZ, 0x4 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_720P_60HZ , 0x5 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_1080I_50HZ, 0x6 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_1080I_60HZ, 0x7 */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_TV_MOD_1080P_24HZ, 0x8 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_1080P_50HZ, 0x9 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_1080P_60HZ, 0xa */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL//0xb */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_SVIDEO, 0xc */
+		{0, 1, 0, 0, 0}, /* reserved//0xd */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_NTSC, 0xe */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_NTSC_SVIDEO//0xf */
+		{0, 1, 0, 0, 0}, /* reserved , 0x10 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_M, 0x11 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_M_SVIDEO, 0x12 */
+		{0, 1, 0, 0, 0}, /* reserved, 0x13 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_NC, 0x14 */
+		{ 27000000, 2,  27000000, 270000000, 0}, /* DISP_TV_MOD_PAL_NC_SVIDEO, 0x15 */
+		{0, 1, 0, 0, 0}, /* reserved//0x16 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_1080P_24HZ_3D_FP, 0x17 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_720P_50HZ_3D_FP, 0x18 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_TV_MOD_720P_60HZ_3D_FP, 0x19 */
+		{ 85500000, 1,  85500000, 342000000, 0}, /* DISP_TV_H1360_V768_60HZ, 0x1a */
+		{108000000, 1, 108000000, 108000000, 0}, /* DISP_TV_H1280_V1024_60HZ, 0x1b */
+		{0, 1, 0, 0, 0}, /* reserved, 0x1c */
+		{0, 1, 0, 0, 0}, /* reserved, 0x1d */
+	}, { /* VGA mode */
+		{147000000, 1, 147000000, 294000000, 0}, /* DISP_VGA_H1680_V1050, 0X0 */
+		{106800000, 1, 106800000, 267000000, 1}, /* DISP_VGA_H1440_V900, 0X1 */
+		{ 86000000, 1,  86000000, 258000000, 0}, /* DISP_VGA_H1360_V768, 0X2 */
+		{108000000, 1, 108000000, 270000000, 1}, /* DISP_VGA_H1280_V1024, 0X3 */
+		{ 65250000, 1,  65250000, 261000000, 0}, /* DISP_VGA_H1024_V768, 0X4 */
+		{ 39857143, 1,  39857143, 279000000, 0}, /* DISP_VGA_H800_V600, 0X5 */
+		{ 25090909, 1,  25090909, 276000000, 0}, /* DISP_VGA_H640_V480  0X6 */
+		{0, 1, 0, 0, 0}, /* DISP_VGA_H1440_V900_RB, 0X7 */
+		{0, 1, 0, 0, 0}, /* DISP_VGA_H1680_V1050_RB, 0X8 */
+		{138000000, 1, 138000000, 276000000, 0}, /* DISP_VGA_H1920_V1080_RB, 0X9 */
+		{148500000, 1, 148500000, 297000000, 0}, /* DISP_VGA_H1920_V1080, 0xa */
+		{ 74250000, 1,  74250000, 297000000, 0}, /* DISP_VGA_H1280_V720, 0xb */
+	}
+};
+
+__s32 image_clk_init(__u32 sel)
+{
+	__u32 dram_pll;
+
+	if (sel == 0) {
+		h_debe0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEBE0);
+		h_debe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE0);
+		h_debe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE0);
+
+		/* NEW OSAL_clk reset */
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe0mclk, RST_INVALID);
+#endif
+		/* FIX CONNECT TO DRAM PLL */
+		OSAL_CCMU_SetMclkSrc(h_debe0mclk, AW_SYS_CLK_PLL5P);
+
+		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
+		if (dram_pll < 300000000)
+			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 1);
+		else
+			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
+
+		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
+		if (sunxi_is_sun4i()) {
+			OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
+			OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+		}
+		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
+
+		g_clk_status |= (CLK_DEBE0_AHB_ON | CLK_DEBE0_MOD_ON);
+	} else if (sel == 1) {
+		h_debe1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEBE1);
+		h_debe1mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEBE1);
+		h_debe1dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEBE1);
+#ifdef RESET_OSAL
+
+		OSAL_CCMU_MclkReset(h_debe1mclk, RST_INVALID);
+#endif
+		/* FIX CONNECT TO DRAM PLL */
+		OSAL_CCMU_SetMclkSrc(h_debe1mclk, AW_SYS_CLK_PLL5P);
+
+		dram_pll = OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL5P);
+		if (dram_pll < 300000000)
+			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 1);
+		else
+			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
+
+		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
+		if (sunxi_is_sun4i()) {
+			OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
+			OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+		}
+		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
+
+		g_clk_status |= (CLK_DEBE1_AHB_ON | CLK_DEBE1_MOD_ON);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 image_clk_exit(__u32 sel)
+{
+	if (sel == 0) {
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe0mclk, RST_VALID);
+#endif
+		OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_debe0ahbclk);
+		OSAL_CCMU_CloseMclk(h_debe0dramclk);
+		OSAL_CCMU_CloseMclk(h_debe0mclk);
+
+		g_clk_status &= ~(CLK_DEBE0_AHB_ON | CLK_DEBE0_MOD_ON |
+				  CLK_DEBE0_DRAM_ON);
+	} else if (sel == 1) {
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_debe1mclk, RST_VALID);
+#endif
+		OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_debe1ahbclk);
+		OSAL_CCMU_CloseMclk(h_debe1dramclk);
+		OSAL_CCMU_CloseMclk(h_debe1mclk);
+
+		g_clk_status &= ~(CLK_DEBE1_AHB_ON | CLK_DEBE1_MOD_ON |
+				  CLK_DEBE1_DRAM_ON);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 image_clk_on(__u32 sel)
+{
+	if (sel == 0) {
+		/*
+		 * need to comfirm:
+		 * REGisters can be accessed if  be_mclk was close.
+		 */
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
+		g_clk_status |= CLK_DEBE0_DRAM_ON;
+	} else if (sel == 1) {
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
+		g_clk_status |= CLK_DEBE1_DRAM_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 image_clk_off(__u32 sel)
+{
+	if (sel == 0) {
+		OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+		g_clk_status &= ~CLK_DEBE0_DRAM_ON;
+	} else if (sel == 1) {
+		OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+		g_clk_status &= ~CLK_DEBE1_DRAM_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 scaler_clk_init(__u32 sel)
+{
+	if (sel == 0) {
+		h_defe0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEFE0);
+		h_defe0dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEFE0);
+		h_defe0mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEFE0);
+#ifdef RESET_OSAL
+
+		OSAL_CCMU_MclkReset(h_defe0mclk, RST_INVALID);
+#endif
+
+		/* FIX CONNECT TO VIDEO PLL1 */
+		OSAL_CCMU_SetMclkSrc(h_defe0mclk, AW_SYS_CLK_PLL7);
+		OSAL_CCMU_SetMclkDiv(h_defe0mclk, 1);
+
+		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+
+		g_clk_status |= CLK_DEFE0_AHB_ON;
+	} else if (sel == 1) {
+		h_defe1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_DEFE1);
+		h_defe1dramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_DEFE1);
+		h_defe1mclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_DEFE1);
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_defe1mclk, RST_INVALID);
+#endif
+		/* FIX CONNECT TO VIDEO PLL1 */
+		OSAL_CCMU_SetMclkSrc(h_defe1mclk, AW_SYS_CLK_PLL7);
+		OSAL_CCMU_SetMclkDiv(h_defe1mclk, 1);
+
+		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+
+		g_clk_status |= CLK_DEFE1_AHB_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 scaler_clk_exit(__u32 sel)
+{
+	if (sel == 0) {
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_defe0mclk, RST_VALID);
+#endif
+		OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_defe0ahbclk);
+		OSAL_CCMU_CloseMclk(h_defe0dramclk);
+		OSAL_CCMU_CloseMclk(h_defe0mclk);
+
+		g_clk_status &= ~(CLK_DEFE0_AHB_ON | CLK_DEFE0_MOD_ON |
+				  CLK_DEFE0_DRAM_ON);
+
+	} else if (sel == 1) {
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_defe1mclk, RST_VALID);
+#endif
+		OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_defe1ahbclk);
+		OSAL_CCMU_CloseMclk(h_defe1dramclk);
+		OSAL_CCMU_CloseMclk(h_defe1mclk);
+
+		g_clk_status &= ~(CLK_DEFE1_AHB_ON | CLK_DEFE1_MOD_ON |
+				  CLK_DEFE1_DRAM_ON);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 scaler_clk_on(__u32 sel)
+{
+	if (sel == 0) {
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
+
+		g_clk_status |= (CLK_DEFE0_MOD_ON | CLK_DEFE0_DRAM_ON);
+	} else if (sel == 1) {
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
+
+		g_clk_status |= (CLK_DEFE1_MOD_ON | CLK_DEFE1_DRAM_ON);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 scaler_clk_off(__u32 sel)
+{
+	if (sel == 0) {
+		OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+
+		g_clk_status &= ~(CLK_DEFE0_MOD_ON | CLK_DEFE0_DRAM_ON);
+	} else if (sel == 1) {
+		OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+
+		g_clk_status &= ~(CLK_DEFE1_MOD_ON | CLK_DEFE1_DRAM_ON);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 lcdc_clk_init(__u32 sel)
+{
+	if (sel == 0) {
+		h_lcd0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_LCD0);
+		h_lcd0ch0mclk0 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH0);
+		h_lcd0ch1mclk1 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S1);
+		h_lcd0ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD0CH1_S2);
+
+		if (!sunxi_is_sun5i()) {
+			/* Default to Video Pll0 */
+			OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL7);
+			/* Default to Video Pll0 */
+			OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL7);
+			/* Default to Video Pll0 */
+			//OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk2, AW_SYS_CLK_PLL7);
+		} else {
+			/* Default to Video Pll0 */
+			OSAL_CCMU_SetMclkSrc(h_lcd0ch0mclk0, AW_SYS_CLK_PLL3);
+			/* Default to Video Pll0 */
+			OSAL_CCMU_SetMclkSrc(h_lcd0ch1mclk1, AW_SYS_CLK_PLL3);
+		}
+
+		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk2, 10);
+		OSAL_CCMU_SetMclkDiv(h_lcd0ch1mclk1, 10);
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_lcd0ch0mclk0, RST_INVALID);
+#endif
+		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
+
+		g_clk_status |= CLK_LCDC0_AHB_ON;
+	} else if (sel == 1) {
+		h_lcd1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_LCD1);
+		h_lcd1ch0mclk0 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH0);
+		h_lcd1ch1mclk1 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S1);
+		h_lcd1ch1mclk2 = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LCD1CH1_S2);
+
+		if (!sunxi_is_sun5i()) {
+			/* Default to Video Pll0 */
+			OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL7);
+			/* Default to Video Pll0 */
+			OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL7);
+			/* Default to Video Pll0 */
+			//OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk2, AW_SYS_CLK_PLL7);
+		} else {
+			/* Default to Video Pll0 */
+			OSAL_CCMU_SetMclkSrc(h_lcd1ch0mclk0, AW_SYS_CLK_PLL3);
+			/* Default to Video Pll0 */
+			OSAL_CCMU_SetMclkSrc(h_lcd1ch1mclk1, AW_SYS_CLK_PLL3);
+		}
+
+		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk2, 10);
+		OSAL_CCMU_SetMclkDiv(h_lcd1ch1mclk1, 10);
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_INVALID);
+#endif
+		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
+
+		g_clk_status |= CLK_LCDC1_AHB_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 lcdc_clk_exit(__u32 sel)
+{
+	if (sel == 0) {
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_lcd0ch0mclk0, RST_VALID);
+#endif
+		OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_lcd0ahbclk);
+		OSAL_CCMU_CloseMclk(h_lcd0ch0mclk0);
+		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk1);
+		OSAL_CCMU_CloseMclk(h_lcd0ch1mclk2);
+
+		g_clk_status &= ~(CLK_LCDC0_AHB_ON | CLK_LCDC0_MOD0_ON |
+				  CLK_LCDC0_MOD1_ON);
+	} else if (sel == 1) {
+#ifdef RESET_OSAL
+		OSAL_CCMU_MclkReset(h_lcd1ch0mclk0, RST_VALID);
+#endif
+		OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_lcd1ahbclk);
+		OSAL_CCMU_CloseMclk(h_lcd1ch0mclk0);
+		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk1);
+		OSAL_CCMU_CloseMclk(h_lcd1ch1mclk2);
+
+		g_clk_status &= ~(CLK_LCDC1_AHB_ON | CLK_LCDC1_MOD0_ON |
+				  CLK_LCDC1_MOD1_ON);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 lcdc_clk_on(__u32 sel)
+{
+	if (sel == 0) {
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
+
+		g_clk_status |= CLK_LCDC0_MOD0_ON | CLK_LCDC0_MOD1_ON;
+	} else if (sel == 1) {
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
+
+		g_clk_status |= CLK_LCDC1_MOD0_ON | CLK_LCDC1_MOD1_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 lcdc_clk_off(__u32 sel)
+{
+	if (sel == 0) {
+		OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
+
+		g_clk_status &= ~(CLK_LCDC0_MOD0_ON | CLK_LCDC0_MOD1_ON);
+	} else if (sel == 1) {
+		OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
+		OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
+
+		g_clk_status &= ~(CLK_LCDC1_MOD0_ON | CLK_LCDC1_MOD1_ON);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 tve_clk_init(__u32 sel)
+{
+	if (sel == 0) {
+		if (sunxi_is_sun5i())
+			OSAL_CCMU_MclkReset(h_lcd0ch1mclk2, RST_INVALID);
+		h_tvenc0ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_TVE0);
+		OSAL_CCMU_MclkOnOff(h_tvenc0ahbclk, CLK_ON);
+
+		g_clk_status |= CLK_TVENC0_AHB_ON;
+	} else if (sel == 1) {
+		h_tvenc1ahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_TVE1);
+		OSAL_CCMU_MclkOnOff(h_tvenc1ahbclk, CLK_ON);
+
+		g_clk_status |= CLK_TVENC1_AHB_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 tve_clk_exit(__u32 sel)
+{
+	if (sel == 0) {
+		OSAL_CCMU_MclkOnOff(h_tvenc0ahbclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_tvenc0ahbclk);
+		if (sunxi_is_sun5i())
+			OSAL_CCMU_MclkReset(h_lcd0ch1mclk2, RST_VALID);
+
+		g_clk_status &= ~CLK_TVENC0_AHB_ON;
+	} else if (sel == 1) {
+		OSAL_CCMU_MclkOnOff(h_tvenc1ahbclk, CLK_OFF);
+		OSAL_CCMU_CloseMclk(h_tvenc1ahbclk);
+
+		g_clk_status &= ~CLK_TVENC1_AHB_ON;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 tve_clk_on(__u32 sel)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 tve_clk_off(__u32 sel)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 hdmi_clk_init(void)
+{
+	h_hdmiahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_HDMI);
+	h_hdmimclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_HDMI);
+#ifdef RESET_OSAL
+	OSAL_CCMU_MclkReset(h_hdmimclk, RST_INVALID);
+#endif
+	if (!sunxi_is_sun5i())
+		OSAL_CCMU_SetMclkSrc(h_hdmimclk, AW_SYS_CLK_PLL7);
+	else
+		OSAL_CCMU_SetMclkSrc(h_hdmimclk, AW_SYS_CLK_PLL3);
+	OSAL_CCMU_SetMclkDiv(h_hdmimclk, 1);
+
+	OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_ON);
+	g_clk_status |= CLK_HDMI_AHB_ON;
+
+	/* We need to turn on the hdmi clk early for sun5i and sun7i
+	   (and make hdmi_clk_on a nop) */
+	if (!sunxi_is_sun4i()) {
+		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
+		g_clk_status |= CLK_HDMI_MOD_ON;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 hdmi_clk_exit(void)
+{
+#ifdef RESET_OSAL
+	OSAL_CCMU_MclkReset(h_hdmimclk, RST_VALID);
+#endif
+	OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
+	OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_OFF);
+	OSAL_CCMU_CloseMclk(h_hdmiahbclk);
+	OSAL_CCMU_CloseMclk(h_hdmimclk);
+	if (!sunxi_is_sun4i())
+		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
+	g_clk_status &= ~(CLK_HDMI_AHB_ON | CLK_HDMI_MOD_ON);
+
+	return DIS_SUCCESS;
+}
+
+__s32 hdmi_clk_on(void)
+{
+	if (sunxi_is_sun4i()) {
+		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
+		g_clk_status |= CLK_HDMI_MOD_ON;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 hdmi_clk_off(void)
+{
+	if (sunxi_is_sun4i()) {
+		OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
+		g_clk_status &= ~CLK_HDMI_MOD_ON;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 lvds_clk_init(void)
+{
+	h_lvdsmclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_LVDS);
+#ifdef RESET_OSAL
+	OSAL_CCMU_MclkReset(h_lvdsmclk, RST_INVALID);
+#endif
+	return DIS_SUCCESS;
+}
+
+__s32 lvds_clk_exit(void)
+{
+#ifdef RESET_OSAL
+	OSAL_CCMU_MclkReset(h_lvdsmclk, RST_VALID);
+#endif
+	OSAL_CCMU_CloseMclk(AW_MOD_CLK_LVDS);
+
+	return DIS_SUCCESS;
+}
+
+__s32 lvds_clk_on(void)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 lvds_clk_off(void)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 disp_pll_init(void)
+{
+	OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL3, 297000000);
+	OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL7, 297000000);
+
+	return DIS_SUCCESS;
+}
+
+/*
+ * Calculate PLL frequence and divider depend on all kinds of lcd panel
+ *
+ * 1. support hv/cpu/ttl panels which pixel frequence between 2MHz~297MHz
+ * 2. support all lvds panels, when pll can't reach  (pixel clk x7),
+ *    set pll to 381MHz(pllx1), which will depress the frame rate.
+ */
+static __s32 LCD_PLL_Calc(__u32 sel, __panel_para_t *info, __u32 *divider)
+{
+	__u32 lcd_dclk_freq; /* Hz */
+	__s32 pll_freq = -1;
+
+	lcd_dclk_freq = info->lcd_dclk_freq * 1000000;
+
+	/* hv panel, CPU panel and ttl panel */
+	if (info->lcd_if == 0 || info->lcd_if == 1 || info->lcd_if == 2) {
+		/* MHz */
+		if (lcd_dclk_freq > 2000000 && lcd_dclk_freq <= 297000000) {
+			/* divider for dclk in tcon0 */
+			*divider = 297000000 / (lcd_dclk_freq);
+			pll_freq = lcd_dclk_freq * (*divider);
+		} else {
+			return -1;
+		}
+
+	} else if (info->lcd_if == 3) {	/* lvds panel */
+		__u32 clk_max;
+
+		if (sw_get_ic_ver() != SUNXI_VER_A10A)
+			clk_max = 150000000;
+		else
+			/*
+			 * pixel clock can't be larger than 108MHz,
+			 * limited by Video pll frequency
+			 */
+			clk_max = 108000000;
+
+		if (lcd_dclk_freq > clk_max)
+			lcd_dclk_freq = clk_max;
+
+
+		if (lcd_dclk_freq > 4000000) { /* pixel clk */
+			pll_freq = lcd_dclk_freq * 7;
+			*divider = 7;
+		} else
+			return -1;
+	}
+	return pll_freq;
+}
+
+/*
+ * Select a video pll for the display device under configuration by specific
+ * rules
+ *
+ * returns:
+ *   0:video pll0;
+ *   1:video pll1;
+ *   2:sata pll
+ *   -1: fail
+ *
+ * ASSIGNMENT RULES
+ * RULE1: video pll1(1x) work between [250,300]MHz, when no lcdc using video
+ *        pll1 and required freq is in [250,300]MHz, choose video pll1;
+ * RULE2: when video pll1 used by another lcdc, but running frequency is equal
+ *        to required frequency, choose video pll1;
+ * RULE3. when video pll1 used by another lcdc, and running frequency is NOT
+ * equal to required frequency, choose video pll0;
+ *
+ * CONDICTION CAN'T BE HANDLE
+ * 1.two lvds panel are both require a pll freq outside [250,300], and pll
+ * freq are different, the second panel will fail to assign.
+ */
+static __s32 disp_pll_assign(__u32 sel, __u32 pll_clk)
+{
+	__u32 another_lcdc, another_pll_use_status;
+	__s32 ret = -1;
+
+	if (sunxi_is_sun5i()) {
+		if (pll_clk <= (381000000 * 2))
+			ret = 0;
+		else
+			DE_WRN("Can't assign PLL for screen%d, pll_clk:%d\n",
+				sel, pll_clk);
+		return ret;
+	}
+
+	another_lcdc = (sel == 0) ? 1 : 0;
+	another_pll_use_status = gdisp.screen[another_lcdc].pll_use_status;
+
+	if (pll_clk >= 250000000 && pll_clk <= 300000000) {
+		if ((!(another_pll_use_status & VIDEO_PLL1_USED)) ||
+		    (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk))
+			ret = 1;
+		else if ((!(another_pll_use_status & VIDEO_PLL0_USED)) ||
+			 (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk))
+			ret = 0;
+	} else if (pll_clk <= (381000000 * 2)) {
+		if ((!(another_pll_use_status & VIDEO_PLL0_USED)) ||
+		    (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL3) == pll_clk))
+			ret = 0;
+		else if ((!(another_pll_use_status & VIDEO_PLL1_USED)) ||
+			 (OSAL_CCMU_GetSrcFreq(AW_SYS_CLK_PLL7) == pll_clk))
+			ret = 1;
+	} else if (pll_clk <= 1200000000) {
+		if (sw_get_ic_ver() != SUNXI_VER_A10A)
+			ret = 2; /* sata pll */
+	}
+
+	if (ret == -1)
+		DE_WRN("Can't assign PLL for screen%d, pll_clk:%d\n", sel,
+		       pll_clk);
+
+	DE_INF("====disp_pll_assign====: sel:%d,pll_clk:%d,pll_sel:%d\n", sel,
+	       pll_clk, ret);
+
+	return ret;
+}
+
+/*
+ * Set clock control module
+ *
+ * Arguments:
+ *  sel: display channel
+ *  videopll_sel: sel pll
+ *  pll_freq: sel pll freq
+ *  tve_freq: lcdx_ch1_clk2 freq
+ *  pre_scale: lcdx_ch1_clk2/lcdx_ch1_ch1
+ *  lcd_clk_div: lcd panel clk div
+ *  hdmi_freq: hdmi module clk freq
+ *  pll_2x: pll 2x required
+ *  type: display device type: tv/vga/hdmi/lcd
+ */
+static __s32 disp_pll_set(__u32 sel, __s32 videopll_sel, __u32 pll_freq,
+			  __u32 tve_freq, __s32 pre_scale, __u32 lcd_clk_div,
+			  __u32 hdmi_freq, __u32 pll_2x, __u32 type)
+{
+	__u32 videopll;
+	__hdle h_lcdmclk0, h_lcdmclk1, h_lcdmclk2;
+	__s32 pll_2x_req;
+	__u32 lcdmclk1_div, lcdmclk2_div, hdmiclk_div;
+
+	if (type == DISP_OUTPUT_TYPE_LCD) { /* lcd panel */
+		if (videopll_sel == 2) { /* sata pll, fix to 960M */
+			videopll = AW_SYS_CLK_PLL7X2;
+#if 0
+			pll_freq = ((pll_freq + 12000000) / 24000000) *
+				24000000;
+			OSAL_CCMU_SetSrcFreq(AW_SYS_CLK_PLL6, pll_freq);
+#endif
+		} else { /* video pll0 or video pll1 */
+			pll_2x_req = (pll_freq > 381000000) ? 1 : 0;
+			if (pll_2x_req)
+				pll_freq /= 2;
+
+			/* in 3M unit */
+			pll_freq = (pll_freq + 1500000) / 3000000;
+			pll_freq = pll_freq * 3000000;
+
+			videopll = (videopll_sel == 0) ?
+				AW_SYS_CLK_PLL3 : AW_SYS_CLK_PLL7;
+			OSAL_CCMU_SetSrcFreq(videopll, pll_freq);
+			if (pll_2x_req)
+				videopll = (videopll == AW_SYS_CLK_PLL3) ?
+					AW_SYS_CLK_PLL3X2 : AW_SYS_CLK_PLL7X2;
+		}
+
+		if (gpanel_info[sel].tcon_index == 0) {
+			/* tcon0 drive lcd panel */
+
+			h_lcdmclk0 = (sel == 0) ?
+				h_lcd0ch0mclk0 : h_lcd1ch0mclk0;
+			OSAL_CCMU_SetMclkSrc(h_lcdmclk0, videopll);
+			TCON0_set_dclk_div(sel, lcd_clk_div);
+		} else {
+			/* tcon1 drive lcd panel */
+			h_lcdmclk1 = (sel == 0) ?
+				h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
+			h_lcdmclk2 = (sel == 0) ?
+				h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
+			OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
+			OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
+			OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcd_clk_div);
+			OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcd_clk_div);
+		}
+	} else { /* tv/vga/hdmi */
+		__u32 pll_freq_used;
+
+		pll_2x_req = pll_2x;
+		videopll = (videopll_sel == 0) ?
+			AW_SYS_CLK_PLL3 : AW_SYS_CLK_PLL7;
+
+		/* Set related Video Pll Frequency */
+		OSAL_CCMU_SetSrcFreq(videopll, pll_freq);
+
+		videopll = (videopll_sel == 0) ?
+		    ((pll_2x_req) ? AW_SYS_CLK_PLL3X2 : AW_SYS_CLK_PLL3) :
+		    ((pll_2x_req) ? AW_SYS_CLK_PLL7X2 : AW_SYS_CLK_PLL7);
+
+		pll_freq_used = pll_freq * (pll_2x_req + 1);
+
+		lcdmclk2_div = (pll_freq_used + (tve_freq / 2)) / tve_freq;
+		lcdmclk1_div = lcdmclk2_div * pre_scale;
+		hdmiclk_div = (pll_freq_used + (hdmi_freq / 2)) / hdmi_freq;
+
+		h_lcdmclk1 = (sel == 0) ? h_lcd0ch1mclk1 : h_lcd1ch1mclk1;
+		h_lcdmclk2 = (sel == 0) ? h_lcd0ch1mclk2 : h_lcd1ch1mclk2;
+		OSAL_CCMU_SetMclkSrc(h_lcdmclk2, videopll);
+		OSAL_CCMU_SetMclkSrc(h_lcdmclk1, videopll);
+		OSAL_CCMU_SetMclkDiv(h_lcdmclk2, lcdmclk2_div);
+		OSAL_CCMU_SetMclkDiv(h_lcdmclk1, lcdmclk1_div);
+
+		/* hdmi internal mode */
+		if (type == DISP_OUTPUT_TYPE_HDMI &&
+		    gdisp.screen[sel].hdmi_index == 0) {
+			OSAL_CCMU_SetMclkSrc(h_hdmimclk, videopll);
+			OSAL_CCMU_SetMclkDiv(h_hdmimclk, hdmiclk_div);
+
+			if (gdisp.init_para.hdmi_set_pll != NULL) {
+				gdisp.init_para.hdmi_set_pll(videopll,
+							     pll_freq_used);
+			} else
+				DE_WRN("gdisp.init_para.hdmi_set_pll is "
+				       "NULL\n");
+		}
+	}
+
+	return DIS_SUCCESS;
+}
+
+static __s32 disp_get_pll_freq_between(__u32 pclk, __u32 min, __u32 max,
+				       __u32 *pll_freq, __u32 *pll_2x)
+{
+	__u32 mult, mult_min, mult_max, freq;
+
+	mult_min = min / pclk;
+	mult_max = (max * 2) / pclk;
+	if (mult_max > 15)
+		mult_max = 15;
+	for (mult = mult_min; mult <= mult_max; mult++) {
+		freq = pclk * mult;
+		if (freq >= min && freq <= max && (freq % 3000000) == 0) {
+			*pll_freq = freq;
+			*pll_2x = 0;
+			return 0;
+		}
+		if (freq >= (min * 2) && freq <= (max * 2) &&
+		    (freq % 6000000) == 0) {
+			*pll_freq = freq / 2;
+			*pll_2x = 1;
+			return 0;
+		}
+	}
+	return -1;
+}
+
+__s32 disp_get_pll_freq(__u32 pclk, __u32 *pll_freq,  __u32 *pll_2x)
+{
+	if (pclk == 0)
+		return -1;
+
+	/* First try the 2 special video pll clks */
+	if ((270000000 % pclk) == 0) {
+		*pll_freq = 270000000;
+		*pll_2x = 0;
+		return 0;
+	}
+	if ((297000000 % pclk) == 0) {
+		*pll_freq = 297000000;
+		*pll_2x = 0;
+		return 0;
+	}
+
+	/* Not working, try to find a frequency between 250 and 300 Mhz */
+	if (disp_get_pll_freq_between(pclk, 250000000, 300000000,
+				      pll_freq, pll_2x) == 0)
+		return 0;
+
+	/* Not working, try to find a frequency between 27 and 381 Mhz */
+	if (disp_get_pll_freq_between(pclk, 27000000, 381000000,
+				      pll_freq, pll_2x) == 0)
+		return 0;
+
+	pr_warn("disp_clk: Could not find a matching pll-freq for %d pclk\n",
+		pclk);
+	return -1;
+}
+EXPORT_SYMBOL(disp_get_pll_freq);
+
+/*
+ * Config PLL and mclk depend on all kinds of display devices
+ */
+__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode)
+{
+	__u32 pll_freq = 297000000, tve_freq = 27000000;
+	__u32 hdmi_freq = 74250000;
+	__s32 videopll_sel, pre_scale = 1;
+	__u32 lcd_clk_div = 0;
+	__u32 pll_2x = 0;
+
+	if (type == DISP_OUTPUT_TYPE_TV || type == DISP_OUTPUT_TYPE_HDMI) {
+		if (type == DISP_OUTPUT_TYPE_HDMI) {
+			struct __disp_video_timing video_timing;
+			if (gdisp.init_para.hdmi_get_video_timing(mode,
+							&video_timing) != 0)
+				return -1;
+			hdmi_freq = video_timing.PCLK;
+		} else {
+			hdmi_freq = clk_tab.tv_clk_tab[mode].hdmi_clk;
+		}
+
+		/* Special handling for standard tv modes */
+		if (hdmi_freq == 27000000) {
+			if (Disp_get_screen_scan_mode(mode))
+				tve_freq  = 27000000;
+			else
+				tve_freq  = 54000000;
+			pre_scale = 2;
+		} else {
+			tve_freq = hdmi_freq;
+			pre_scale = 1;
+		}
+
+		if (disp_get_pll_freq(hdmi_freq, &pll_freq, &pll_2x) != 0)
+			return -1;
+
+		pr_info("disp clks: lcd %d pre_scale %d hdmi %d pll %d 2x %d\n",
+			tve_freq, pre_scale, hdmi_freq, pll_freq, pll_2x);
+	} else if (type == DISP_OUTPUT_TYPE_VGA) {
+		pll_freq = clk_tab.vga_clk_tab[mode].pll_clk;
+		tve_freq = clk_tab.vga_clk_tab[mode].tve_clk;
+		pre_scale = clk_tab.vga_clk_tab[mode].pre_scale;
+		pll_2x = clk_tab.vga_clk_tab[mode].pll_2x;
+	} else if (type == DISP_OUTPUT_TYPE_LCD) {
+		pll_freq =
+		    LCD_PLL_Calc(sel, (__panel_para_t *) &gpanel_info[sel],
+				 &lcd_clk_div);
+		pre_scale = 1;
+	} else {
+		return DIS_SUCCESS;
+	}
+
+	videopll_sel = disp_pll_assign(sel, pll_freq);
+	if (videopll_sel == -1)
+		return DIS_FAIL;
+
+	disp_pll_set(sel, videopll_sel, pll_freq, tve_freq, pre_scale,
+		     lcd_clk_div, hdmi_freq, pll_2x, type);
+	if (videopll_sel == 0)
+		gdisp.screen[sel].pll_use_status |= VIDEO_PLL0_USED;
+	else if (videopll_sel == 1)
+		gdisp.screen[sel].pll_use_status |= VIDEO_PLL1_USED;
+
+	return DIS_SUCCESS;
+}
+
+/*
+ * type==1: open ahb clk and image mclk
+ * type==2: open all clk except ahb clk and image mclk
+ * type==3: open all clk
+ */
+__s32 BSP_disp_clk_on(__u32 type)
+{
+	if (type & 1) {
+		/* AHB CLK */
+		if ((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_ON);
+
+		if ((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_ON);
+
+		if ((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_ON);
+
+		if ((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_ON);
+
+		// OK?? REG wont clear?
+		if ((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_ON);
+
+		// OK?? REG wont clear?
+		if ((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_ON);
+
+		if ((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_ON);
+
+		//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_ON);
+
+		/* MODULE CLK */
+		if ((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_ON);
+
+		if ((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_ON);
+	}
+
+	if (type & 2) {
+		/* DRAM CLK */
+		if ((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
+			OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_ON);
+
+		if ((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
+			OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_ON);
+
+		if ((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
+			OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_ON);
+
+		if ((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
+			OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_ON);
+
+		/* MODULE CLK */
+		if ((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_ON);
+
+		if ((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_ON);
+
+		if ((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
+			OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_ON);
+
+		if ((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON) {
+			OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_ON);
+			OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_ON);
+		}
+		if ((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
+			OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_ON);
+
+		if ((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON) {
+			OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_ON);
+			OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_ON);
+		}
+		if (sunxi_is_sun4i() &&
+		    (g_clk_status & CLK_HDMI_MOD_ON) == CLK_HDMI_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_ON);
+	}
+
+	if (type == 2) {
+		if ((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 2);
+
+		if ((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 2);
+	}
+
+	return DIS_SUCCESS;
+}
+
+/*
+ * type==1: close ahb clk and image mclk
+ * type==2: close all clk except ahb clk and image mclk
+ * type==3: close all clk
+ */
+__s32 BSP_disp_clk_off(__u32 type)
+{
+	if (type & 1) {
+		/* AHB CLK */
+		if ((g_clk_status & CLK_DEFE0_AHB_ON) == CLK_DEFE0_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_defe0ahbclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_DEFE1_AHB_ON) == CLK_DEFE1_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_defe1ahbclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_DEBE0_AHB_ON) == CLK_DEBE0_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_debe0ahbclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_DEBE1_AHB_ON) == CLK_DEBE1_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_debe1ahbclk, CLK_OFF);
+
+		//OK?? REG wont clear?
+		if ((g_clk_status & CLK_LCDC0_AHB_ON) == CLK_LCDC0_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_lcd0ahbclk, CLK_OFF);
+
+		//OK?? REG wont clear?
+		if ((g_clk_status & CLK_LCDC1_AHB_ON) == CLK_LCDC1_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_lcd1ahbclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_HDMI_AHB_ON) == CLK_HDMI_AHB_ON)
+			OSAL_CCMU_MclkOnOff(h_hdmiahbclk, CLK_OFF);
+
+		//OSAL_CCMU_MclkOnOff(h_tveahbclk, CLK_OFF);
+
+		/* MODULE CLK */
+		if ((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_debe0mclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_debe1mclk, CLK_OFF);
+	}
+
+	if (type & 2) {
+		/* DRAM CLK */
+		if ((g_clk_status & CLK_DEFE0_DRAM_ON) == CLK_DEFE0_DRAM_ON)
+			OSAL_CCMU_MclkOnOff(h_defe0dramclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_DEFE1_DRAM_ON) == CLK_DEFE1_DRAM_ON)
+			OSAL_CCMU_MclkOnOff(h_defe1dramclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_DEBE0_DRAM_ON) == CLK_DEBE0_DRAM_ON)
+			OSAL_CCMU_MclkOnOff(h_debe0dramclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_DEBE1_DRAM_ON) == CLK_DEBE1_DRAM_ON)
+			OSAL_CCMU_MclkOnOff(h_debe1dramclk, CLK_OFF);
+
+		/* MODULE CLK */
+		if ((g_clk_status & CLK_DEFE0_MOD_ON) == CLK_DEFE0_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_defe0mclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_DEFE1_MOD_ON) == CLK_DEFE1_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_defe1mclk, CLK_OFF);
+
+		if ((g_clk_status & CLK_LCDC0_MOD0_ON) == CLK_LCDC0_MOD0_ON)
+			OSAL_CCMU_MclkOnOff(h_lcd0ch0mclk0, CLK_OFF);
+
+		if ((g_clk_status & CLK_LCDC0_MOD1_ON) == CLK_LCDC0_MOD1_ON) {
+			OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk1, CLK_OFF);
+			OSAL_CCMU_MclkOnOff(h_lcd0ch1mclk2, CLK_OFF);
+		}
+		if ((g_clk_status & CLK_LCDC1_MOD0_ON) == CLK_LCDC1_MOD0_ON)
+			OSAL_CCMU_MclkOnOff(h_lcd1ch0mclk0, CLK_OFF);
+
+		if ((g_clk_status & CLK_LCDC1_MOD1_ON) == CLK_LCDC1_MOD1_ON) {
+			OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk1, CLK_OFF);
+			OSAL_CCMU_MclkOnOff(h_lcd1ch1mclk2, CLK_OFF);
+		}
+		if (sunxi_is_sun4i() &&
+		    (g_clk_status & CLK_HDMI_MOD_ON) == CLK_HDMI_MOD_ON)
+			OSAL_CCMU_MclkOnOff(h_hdmimclk, CLK_OFF);
+	}
+
+	if (type == 2) {
+		if ((g_clk_status & CLK_DEBE0_MOD_ON) == CLK_DEBE0_MOD_ON)
+			OSAL_CCMU_SetMclkDiv(h_debe0mclk, 16);
+
+		if ((g_clk_status & CLK_DEBE1_MOD_ON) == CLK_DEBE1_MOD_ON)
+			OSAL_CCMU_SetMclkDiv(h_debe1mclk, 16);
+	}
+
+	return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_clk.h b/drivers/video/sunxi/disp/disp_clk.h
new file mode 100644
index 0000000..cbbb4da
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_clk.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_CLK_H__
+#define __DISP_CLK_H__
+
+#include "disp_display_i.h"
+
+/*
+ * record tv/vga/hdmi mode clock requirement
+ */
+typedef struct {
+	/* required clock frequency for LCDx_ch1_clk2, for tv output used ,Hz */
+	__u32 tve_clk;
+	/*
+	 * required divide LCDx_ch1_clk2 by 2 for LCDx_ch1_clk1 or NOT:
+	 * 1:not divided , 2: divide by two
+	 */
+	__u32 pre_scale;
+	/* required clock frequency for internal hdmi module, Hz */
+	__u32 hdmi_clk;
+	/* required pll frequency for VIDEO_PLL0(1x) or VIDEO_PLL1(1x), Hz */
+	__u32 pll_clk;
+	/* required 2x VIDEO_PLL or NOT: 0:no, 1: required */
+	__u32 pll_2x;
+
+} __disp_tv_vga_clk_t;
+
+typedef struct {
+	/* number related to number of tv mode supported */
+	__disp_tv_vga_clk_t tv_clk_tab[30];
+	/* number related to number of vga mode supported */
+	__disp_tv_vga_clk_t vga_clk_tab[12];
+} __disp_clk_tab;
+
+__s32 image_clk_init(__u32 sel);
+__s32 image_clk_exit(__u32 sel);
+__s32 image_clk_on(__u32 sel);
+__s32 image_clk_off(__u32 sel);
+
+__s32 scaler_clk_init(__u32 sel);
+__s32 scaler_clk_exit(__u32 sel);
+__s32 scaler_clk_on(__u32 sel);
+__s32 scaler_clk_off(__u32 sel);
+
+__s32 lcdc_clk_init(__u32 sel);
+__s32 lcdc_clk_exit(__u32 sel);
+__s32 lcdc_clk_on(__u32 sel);
+__s32 lcdc_clk_off(__u32 sel);
+
+__s32 tve_clk_init(__u32 sel);
+__s32 tve_clk_exit(__u32 sel);
+__s32 tve_clk_on(__u32 sel);
+__s32 tve_clk_off(__u32 sel);
+
+__s32 hdmi_clk_init(void);
+__s32 hdmi_clk_exit(void);
+__s32 hdmi_clk_on(void);
+__s32 hdmi_clk_off(void);
+
+__s32 lvds_clk_init(void);
+__s32 lvds_clk_exit(void);
+__s32 lvds_clk_on(void);
+__s32 lvds_clk_off(void);
+
+__s32 disp_pll_init(void);
+__s32 disp_clk_cfg(__u32 sel, __u32 type, __u8 mode);
+
+extern __disp_clk_tab clk_tab;
+extern __u32 g_clk_status;
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_combined.c b/drivers/video/sunxi/disp/disp_combined.c
new file mode 100644
index 0000000..02e872a
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_combined.c
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display.h"
+#include "disp_event.h"
+
+__s32 BSP_disp_set_bk_color(__u32 sel, __disp_color_t *color)
+{
+	if (color == NULL)
+		return DIS_PARA_FAILED;
+
+	gdisp.screen[sel].bk_color.blue = color->blue;
+	gdisp.screen[sel].bk_color.red = color->red;
+	gdisp.screen[sel].bk_color.green = color->green;
+
+	DE_BE_Set_BkColor(sel, gdisp.screen[sel].bk_color);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_bk_color(__u32 sel, __disp_color_t *color)
+{
+	if (color == NULL) {
+		DE_WRN("para invalid in BSP_disp_get_bk_color\n");
+		return DIS_PARA_FAILED;
+	}
+	color->blue = gdisp.screen[sel].bk_color.blue;
+	color->red = gdisp.screen[sel].bk_color.red;
+	color->green = gdisp.screen[sel].bk_color.green;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_set_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
+{
+	if ((ck_mode == NULL) || (ck_mode->red_match_rule > 3) ||
+	    (ck_mode->green_match_rule > 3) || (ck_mode->blue_match_rule > 3)) {
+		DE_WRN("para invalid in BSP_disp_set_color_key\n");
+		return DIS_PARA_FAILED;
+	}
+	memcpy(&(gdisp.screen[sel].color_key), ck_mode,
+	       sizeof(__disp_colorkey_t));
+	DE_BE_Set_ColorKey(sel, ck_mode->ck_max, ck_mode->ck_min,
+			   ck_mode->red_match_rule, ck_mode->green_match_rule,
+			   ck_mode->blue_match_rule);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_color_key(__u32 sel, __disp_colorkey_t *ck_mode)
+{
+	memcpy(ck_mode, &(gdisp.screen[sel].color_key),
+	       sizeof(__disp_colorkey_t));
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_set_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset,
+				 __u32 size)
+{
+	if ((pbuffer == NULL) || ((offset + size) > 1024)) {
+		DE_WRN("para invalid in BSP_disp_set_palette_table,"
+		       "offset:0x%x,size:0x%x\n", offset, size);
+		return DIS_FAIL;
+	}
+	DE_BE_Set_SystemPalette(sel, pbuffer, offset, size);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_palette_table(__u32 sel, __u32 *pbuffer, __u32 offset,
+				 __u32 size)
+{
+	if ((pbuffer == NULL) || ((offset + size) > 1024)) {
+		DE_WRN("para invalid in BSP_disp_get_palette_table,"
+		       "offset:0x%x,size:0x%x\n", offset, size);
+		return DIS_FAIL;
+	}
+
+	DE_BE_Get_SystemPalette(sel, pbuffer, offset, size);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_set_top(__u32 sel, __u32 hid)
+{
+	__s32 i, j;
+	__u32 layer_prio[4];
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) {
+		__u32 prio = gdisp.screen[sel].max_layers - 1;
+
+		for (i = 0; i < gdisp.screen[sel].max_layers; i++)
+			layer_prio[i] =
+			    gdisp.screen[sel].layer_manage[i].para.prio;
+
+		layer_prio[hid] = prio--;
+
+		for (j = gdisp.screen[sel].max_layers - 1; j >= 0; j--)	{
+			for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
+				if ((gdisp.screen[sel].layer_manage[i].status &
+				     LAYER_USED) && (i != hid) &&
+				    (gdisp.screen[sel].layer_manage[i].para.prio
+				     == j))
+					layer_prio[i] = prio--;
+			}
+		}
+
+		for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
+			if (gdisp.screen[sel].layer_manage[i].status &
+			    LAYER_USED) {
+				DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
+				gdisp.screen[sel].layer_manage[i].para.prio =
+					layer_prio[i];
+			}
+		}
+
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_set_bottom(__u32 sel, __u32 hid)
+{
+	__s32 i, j;
+	__u32 layer_prio[4];
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) {
+		__u32 prio = 0;
+
+		for (i = 0; i < gdisp.screen[sel].max_layers; i++)
+			layer_prio[i] =
+				gdisp.screen[sel].layer_manage[i].para.prio;
+
+		layer_prio[hid] = prio++;
+		for (j = 0; j < gdisp.screen[sel].max_layers; j++) {
+			for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
+				if ((gdisp.screen[sel].layer_manage[i].status &
+				     LAYER_USED) && (i != hid) &&
+				    (gdisp.screen[sel].layer_manage[i].para.prio
+				     == j))
+					layer_prio[i] = prio++;
+			}
+		}
+
+		for (i = 0; i < gdisp.screen[sel].max_layers; i++) {
+			if (gdisp.screen[sel].layer_manage[i].
+			    status & LAYER_USED) {
+				DE_BE_Layer_Set_Prio(sel, i, layer_prio[i]);
+				gdisp.screen[sel].layer_manage[i].para.prio =
+					layer_prio[i];
+			}
+		}
+
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_set_alpha_value(__u32 sel, __u32 hid, __u8 value)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) {
+		DE_BE_Layer_Set_Alpha_Value(sel, hid, value);
+
+		gdisp.screen[sel].layer_manage[hid].para.alpha_val = value;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_get_alpha_value(__u32 sel, __u32 hid)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+		return gdisp.screen[sel].layer_manage[hid].para.alpha_val;
+	else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_layer_alpha_enable(__u32 sel, __u32 hid, __bool enable)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) {
+		DE_BE_Layer_Alpha_Enable(sel, hid, enable);
+
+		gdisp.screen[sel].layer_manage[hid].para.alpha_en = enable;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_get_alpha_enable(__u32 sel, __u32 hid)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+		return gdisp.screen[sel].layer_manage[hid].para.alpha_en;
+	else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_layer_set_pipe(__u32 sel, __u32 hid, __u8 pipe)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+	if (pipe != 0 && pipe != 1)
+		return DIS_OBJ_NOT_INITED;
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) {
+		DE_BE_Layer_Set_Pipe(sel, hid, pipe);
+
+		gdisp.screen[sel].layer_manage[hid].para.pipe = pipe;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_get_pipe(__u32 sel, __u32 hid)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+		return gdisp.screen[sel].layer_manage[hid].para.pipe;
+	else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_layer_colorkey_enable(__u32 sel, __u32 hid, __bool enable)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) {
+		DE_BE_Layer_ColorKey_Enable(sel, hid, enable);
+
+		gdisp.screen[sel].layer_manage[hid].para.ck_enable = enable;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_get_colorkey_enable(__u32 sel, __u32 hid)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+		return gdisp.screen[sel].layer_manage[hid].para.ck_enable;
+	else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_layer_get_piro(__u32 sel, __u32 hid)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+		return gdisp.screen[sel].layer_manage[hid].para.prio;
+	else
+		return DIS_OBJ_NOT_INITED;
+}
diff --git a/drivers/video/sunxi/disp/disp_de.c b/drivers/video/sunxi/disp/disp_de.c
new file mode 100644
index 0000000..9603ba7
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_de.c
@@ -0,0 +1,379 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_scaler.h"
+#include "disp_clk.h"
+#include "disp_lcd.h"
+
+__s32 Image_init(__u32 sel)
+{
+
+	image_clk_init(sel);
+
+	/* when access image registers, must open MODULE CLOCK of image */
+	image_clk_on(sel);
+	DE_BE_Reg_Init(sel);
+
+	BSP_disp_sprite_init(sel);
+	if (sunxi_is_sun5i())
+		BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_LCD,
+				gdisp.screen[sel].iep_status & DRC_USED);
+
+	Image_open(sel);
+
+	DE_BE_EnableINT(sel, DE_IMG_REG_LOAD_FINISH);
+	DE_BE_reg_auto_load_en(sel, 0);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Image_exit(__u32 sel)
+{
+	DE_BE_DisableINT(sel, DE_IMG_REG_LOAD_FINISH);
+	BSP_disp_sprite_exit(sel);
+	image_clk_exit(sel);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Image_open(__u32 sel)
+{
+	DE_BE_Enable(sel);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Image_close(__u32 sel)
+{
+	DE_BE_Disable(sel);
+
+	gdisp.screen[sel].status &= ~IMAGE_USED;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_set_bright(__u32 sel, __u32 bright)
+{
+	gdisp.screen[sel].bright = bright;
+
+#ifndef CONFIG_ARCH_SUN5I
+	DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc,
+			     gdisp.screen[sel].out_color_range,
+			     gdisp.screen[sel].enhance_en,
+			     gdisp.screen[sel].bright,
+			     gdisp.screen[sel].contrast,
+			     gdisp.screen[sel].saturation,
+			     gdisp.screen[sel].hue);
+#else
+	BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type,
+				gdisp.screen[sel].iep_status & DRC_USED);
+#endif
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_bright(__u32 sel)
+{
+	return gdisp.screen[sel].bright;
+}
+
+__s32 BSP_disp_set_contrast(__u32 sel, __u32 contrast)
+{
+	gdisp.screen[sel].contrast = contrast;
+
+#ifndef CONFIG_ARCH_SUN5I
+	DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc,
+			     gdisp.screen[sel].out_color_range,
+			     gdisp.screen[sel].enhance_en,
+			     gdisp.screen[sel].bright,
+			     gdisp.screen[sel].contrast,
+			     gdisp.screen[sel].saturation,
+			     gdisp.screen[sel].hue);
+#else
+	BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type,
+				gdisp.screen[sel].iep_status & DRC_USED);
+#endif
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_contrast(__u32 sel)
+{
+	return gdisp.screen[sel].contrast;
+}
+
+__s32 BSP_disp_set_saturation(__u32 sel, __u32 saturation)
+{
+	gdisp.screen[sel].saturation = saturation;
+
+#ifndef CONFIG_ARCH_SUN5I
+	DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc,
+			     gdisp.screen[sel].out_color_range,
+			     gdisp.screen[sel].enhance_en,
+			     gdisp.screen[sel].bright,
+			     gdisp.screen[sel].contrast,
+			     gdisp.screen[sel].saturation,
+			     gdisp.screen[sel].hue);
+#else
+	BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type,
+				gdisp.screen[sel].iep_status & DRC_USED);
+#endif
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_saturation(__u32 sel)
+{
+	return gdisp.screen[sel].saturation;
+}
+
+__s32 BSP_disp_set_hue(__u32 sel, __u32 hue)
+{
+	gdisp.screen[sel].hue = hue;
+
+#ifndef CONFIG_ARCH_SUN5I
+	DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc,
+			     gdisp.screen[sel].out_color_range,
+			     gdisp.screen[sel].enhance_en,
+			     gdisp.screen[sel].bright,
+			     gdisp.screen[sel].contrast,
+			     gdisp.screen[sel].saturation,
+			     gdisp.screen[sel].hue);
+#else
+	BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type,
+				gdisp.screen[sel].iep_status & DRC_USED);
+#endif
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_hue(__u32 sel)
+{
+	return gdisp.screen[sel].hue;
+}
+
+__s32 BSP_disp_enhance_enable(__u32 sel, __bool enable)
+{
+#ifndef CONFIG_ARCH_SUN5I
+	gdisp.screen[sel].enhance_en = enable;
+
+	DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc,
+			     gdisp.screen[sel].out_color_range,
+			     gdisp.screen[sel].enhance_en,
+			     gdisp.screen[sel].bright,
+			     gdisp.screen[sel].contrast,
+			     gdisp.screen[sel].saturation,
+			     gdisp.screen[sel].hue);
+#endif
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_get_enhance_enable(__u32 sel)
+{
+        if (sunxi_is_sun5i())
+                return 0;
+
+	return gdisp.screen[sel].enhance_en;
+}
+
+__s32 BSP_disp_set_screen_size(__u32 sel, __disp_rectsz_t *size)
+{
+	DE_BE_set_display_size(sel, size->width, size->height);
+
+	gdisp.screen[sel].screen_width = size->width;
+	gdisp.screen[sel].screen_height = size->height;
+
+	return DIS_SUCCESS;
+}
+
+#ifndef CONFIG_ARCH_SUN5I
+static __s32 BSP_disp_set_output_csc_sun4i(__u32 sel,
+					   __disp_output_type_t type)
+{
+	__disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
+	__csc_t out_csc = DE_RGB;
+	__u32 enhance_en, bright, contrast, saturation, hue;
+
+	enhance_en = gdisp.screen[sel].enhance_en;
+	bright = gdisp.screen[sel].bright;
+	contrast = gdisp.screen[sel].contrast;
+	saturation = gdisp.screen[sel].saturation;
+	hue = gdisp.screen[sel].hue;
+
+	if (type == DISP_OUTPUT_TYPE_HDMI) {
+		__s32 ret = 0;
+		__s32 value = 0;
+
+		out_color_range = DISP_COLOR_RANGE_16_255;
+#ifdef YUV_COLORSPACE /* Fix me */
+		out_csc = DE_YUV_HDMI;
+#endif
+
+		ret =
+		    script_parser_fetch("disp_init", "screen0_out_color_range",
+					&value, 1);
+		if (ret < 0) {
+			DE_INF("fetch script data "
+			       "disp_init.screen0_out_color_range fail\n");
+		} else {
+			out_color_range = value;
+			DE_INF("screen0_out_color_range = %d\n", value);
+		}
+	} else if (type == DISP_OUTPUT_TYPE_TV) {
+		out_csc = DE_YUV_TV;
+	}
+
+	else if (type == DISP_OUTPUT_TYPE_LCD) {
+		if (enhance_en == 0) {
+			enhance_en = 1;
+
+			bright = 50;
+			contrast = 50;
+			saturation = 57;
+			hue = 50;
+		}
+	}
+
+	gdisp.screen[sel].out_color_range = out_color_range;
+	gdisp.screen[sel].out_csc = out_csc;
+
+	DE_BE_Set_Enhance_ex(sel, gdisp.screen[sel].out_csc,
+			     gdisp.screen[sel].out_color_range, enhance_en,
+			     bright, contrast, saturation, hue);
+
+	return DIS_SUCCESS;
+}
+#else
+static __s32 BSP_disp_set_output_csc_sun5i(__u32 sel,
+					   __disp_output_type_t out_type,
+					   __u32 drc_en)
+{
+	__disp_color_range_t out_color_range = DISP_COLOR_RANGE_0_255;
+	__u32 out_csc = 0; /* out_csc: 0:rgb  1:yuv  2:igb */
+
+	if (out_type == DISP_OUTPUT_TYPE_HDMI) {
+		__s32 ret = 0;
+		__s32 value = 0;
+
+		out_color_range = DISP_COLOR_RANGE_16_255;
+
+		ret = script_parser_fetch("disp_init",
+					  "screen0_out_color_range", &value, 1);
+		if (ret < 0) {
+			DE_INF("fetch script data "
+			       "disp_init.screen0_out_color_range fail\n");
+		} else {
+			out_color_range = value;
+			DE_INF("screen0_out_color_range = %d\n", value);
+		}
+		out_csc = 0;
+	} else if (out_type == DISP_OUTPUT_TYPE_LCD) {
+		out_csc = 0;
+	} else if (out_type == DISP_OUTPUT_TYPE_TV) {
+		out_csc = 1;
+	}
+
+	if (drc_en)
+		out_csc = 2;
+
+	DE_BE_Set_Enhance(sel, out_csc, out_color_range,
+			  gdisp.screen[sel].bright, gdisp.screen[sel].contrast,
+			  gdisp.screen[sel].saturation, gdisp.screen[sel].hue);
+
+	return DIS_SUCCESS;
+}
+#endif /* not CONFIG_ARCH_SUN5I */
+
+__s32 BSP_disp_set_output_csc(__u32 sel, __disp_output_type_t type,
+			      __u32 drc_en)
+{
+#ifndef CONFIG_ARCH_SUN5I
+	return BSP_disp_set_output_csc_sun4i(sel, type);
+#else
+	return BSP_disp_set_output_csc_sun5i(sel, type, drc_en);
+#endif
+}
+
+__s32 BSP_disp_de_flicker_enable(__u32 sel, __bool b_en)
+{
+	if (sunxi_is_sun5i())
+		return BSP_disp_iep_deflicker_enable(sel, b_en);
+
+	if (b_en)
+		gdisp.screen[sel].de_flicker_status |= DE_FLICKER_REQUIRED;
+	else
+		gdisp.screen[sel].de_flicker_status &= ~DE_FLICKER_REQUIRED;
+
+	Disp_set_out_interlace(sel);
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_set_out_interlace(__u32 sel)
+{
+	__u32 i;
+	__bool b_cvbs_out = 0;
+
+	if (sunxi_is_sun5i())
+		return 0;
+
+	if (gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_TV &&
+	    (gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL ||
+	     gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL_M ||
+	     gdisp.screen[sel].tv_mode == DISP_TV_MOD_PAL_NC ||
+	     gdisp.screen[sel].tv_mode == DISP_TV_MOD_NTSC)) {
+		b_cvbs_out = 1;
+	}
+
+	gdisp.screen[sel].de_flicker_status |= DE_FLICKER_REQUIRED;
+
+	BSP_disp_cfg_start(sel);
+
+	/* when output device is cvbs */
+	if ((gdisp.screen[sel].de_flicker_status & DE_FLICKER_REQUIRED) &&
+	    b_cvbs_out)	{
+		DE_BE_deflicker_enable(sel, TRUE);
+		for (i = 0; i < 2; i++) {
+			if ((gdisp.scaler[i].status & SCALER_USED) &&
+			    (gdisp.scaler[i].screen_index == sel)) {
+				Scaler_Set_Outitl(i, FALSE);
+			}
+		}
+		gdisp.screen[sel].de_flicker_status |= DE_FLICKER_USED;
+	} else {
+		DE_BE_deflicker_enable(sel, FALSE);
+		for (i = 0; i < 2; i++) {
+			if ((gdisp.scaler[i].status & SCALER_USED) &&
+			    (gdisp.scaler[i].screen_index == sel)) {
+				Scaler_Set_Outitl(i,
+						  gdisp.screen[sel].
+						  b_out_interlace);
+			}
+		}
+		gdisp.screen[sel].de_flicker_status &= ~DE_FLICKER_USED;
+	}
+	DE_BE_Set_Outitl_enable(sel, gdisp.screen[sel].b_out_interlace);
+
+	BSP_disp_cfg_finish(sel);
+
+	return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_de.h b/drivers/video/sunxi/disp/disp_de.h
new file mode 100644
index 0000000..b35ee6b
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_de.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_DE_H_
+#define __DISP_DE_H_
+
+#include "disp_display_i.h"
+
+extern __hdle h_tvahbclk;
+extern __hdle h_tv1clk;
+extern __hdle h_tv2clk;
+
+__s32 Image_init(__u32 sel);
+__s32 Image_exit(__u32 sel);
+__s32 Image_open(__u32 sel);
+__s32 Image_close(__u32 sel);
+__s32 Disp_set_out_interlace(__u32 sel);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_display.c b/drivers/video/sunxi/disp/disp_display.c
new file mode 100644
index 0000000..c47980b
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_display.c
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display.h"
+#include "disp_de.h"
+#include "disp_lcd.h"
+#include "disp_tv.h"
+#include "disp_event.h"
+#include "disp_sprite.h"
+#include "disp_scaler.h"
+#include "disp_video.h"
+#include "disp_clk.h"
+#include "disp_hdmi.h"
+
+__disp_dev_t gdisp;
+static bool disp_initialised;
+
+__s32 BSP_disp_init(__disp_bsp_init_para *para)
+{
+	__u32 i = 0, screen_id = 0;
+
+	memset(&gdisp, 0x00, sizeof(__disp_dev_t));
+
+	for (screen_id = 0; screen_id < 2; screen_id++) {
+		gdisp.screen[screen_id].max_layers = SUNXI_DISP_MAX_LAYERS;
+		for (i = 0; i < gdisp.screen[screen_id].max_layers; i++)
+			gdisp.screen[screen_id].layer_manage[i].para.prio =
+			    IDLE_PRIO;
+
+		gdisp.screen[screen_id].image_output_type = IMAGE_OUTPUT_LCDC;
+
+		gdisp.screen[screen_id].bright = 50;
+		gdisp.screen[screen_id].contrast = 50;
+		gdisp.screen[screen_id].saturation = 50;
+		gdisp.screen[screen_id].hue = 50;
+
+		gdisp.scaler[screen_id].bright = 50;
+		gdisp.scaler[screen_id].contrast = 50;
+		gdisp.scaler[screen_id].saturation = 50;
+		gdisp.scaler[screen_id].hue = 50;
+
+		gdisp.screen[screen_id].lcd_bright = 192;
+		gdisp.screen[screen_id].lcd_bright_dimming = 256;
+	}
+	memcpy(&gdisp.init_para, para, sizeof(__disp_bsp_init_para));
+	memset(g_video, 0, sizeof(g_video));
+
+	DE_Set_Reg_Base(0, para->base_image0);
+	DE_SCAL_Set_Reg_Base(0, para->base_scaler0);
+	LCDC_set_reg_base(0, para->base_lcdc0);
+	TVE_set_reg_base(0, para->base_tvec0);
+
+	if (!sunxi_is_sun5i()) {
+		DE_Set_Reg_Base(1, para->base_image1);
+		DE_SCAL_Set_Reg_Base(1, para->base_scaler1);
+		LCDC_set_reg_base(1, para->base_lcdc1);
+		TVE_set_reg_base(1, para->base_tvec1);
+	} else
+		DE_IEP_Set_Reg_Base(0, para->base_iep);
+
+	BSP_disp_close_lcd_backlight(0);
+
+	disp_pll_init();
+
+	Scaler_Init(0);
+	Image_init(0);
+	Disp_lcdc_init(0);
+	Disp_TVEC_Init(0);
+
+	if (!sunxi_is_sun5i()) {
+		Scaler_Init(1);
+		Image_init(1);
+		Disp_lcdc_init(1);
+		Disp_TVEC_Init(1);
+	}
+
+	Display_Hdmi_Init();
+
+	Disp_iep_init(0);
+
+	disp_initialised = true;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_exit(__u32 mode)
+{
+	if (!disp_initialised)
+		return DIS_SUCCESS;
+
+	if (mode == DISP_EXIT_MODE_CLEAN_ALL) {
+		BSP_disp_close();
+
+		Scaler_Exit(0);
+		Image_exit(0);
+		Disp_lcdc_exit(0);
+		Disp_TVEC_Exit(0);
+
+		if (!sunxi_is_sun5i()) {
+			Scaler_Exit(1);
+			Image_exit(1);
+			Disp_lcdc_exit(1);
+			Disp_TVEC_Exit(1);
+		}
+
+		Display_Hdmi_Exit();
+		Disp_iep_exit(0);
+	} else if (mode == DISP_EXIT_MODE_CLEAN_PARTLY) {
+		disable_irq(INTC_IRQNO_LCDC0);
+		free_irq(INTC_IRQNO_LCDC0, NULL);
+
+
+		if (!sunxi_is_sun5i()) {
+			disable_irq(INTC_IRQNO_LCDC1);
+			free_irq(INTC_IRQNO_LCDC1, NULL);
+		}
+
+		disable_irq(INTC_IRQNO_SCALER0);
+		free_irq(INTC_IRQNO_SCALER0, NULL);
+
+		if (!sunxi_is_sun5i()) {
+			disable_irq(INTC_IRQNO_SCALER1);
+			free_irq(INTC_IRQNO_SCALER1, NULL);
+		}
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_open(void)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_close(void)
+{
+	__u32 sel = 0;
+
+	if (!disp_initialised)
+		return DIS_SUCCESS;
+
+	for (sel = 0; sel < 2; sel++) {
+		Image_close(sel);
+		if (gdisp.scaler[sel].status & SCALER_USED)
+			Scaler_close(sel);
+
+		if (gdisp.screen[sel].lcdc_status & LCDC_TCON0_USED) {
+			TCON0_close(sel);
+			LCDC_close(sel);
+		} else if (gdisp.screen[sel].lcdc_status & LCDC_TCON1_USED) {
+			TCON1_close(sel);
+			LCDC_close(sel);
+		} else if (gdisp.screen[sel].status & (TV_ON | VGA_ON)) {
+			TVE_close(sel);
+		}
+	}
+
+	for (sel = 0; sel < 2; sel++) {
+		gdisp.screen[sel].status &=
+			~(IMAGE_USED | LCD_ON | TV_ON | VGA_ON | HDMI_ON);
+		gdisp.screen[sel].lcdc_status &=
+			~(LCDC_TCON0_USED & LCDC_TCON1_USED);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_print_reg(__bool b_force_on, __u32 id)
+{
+	__u32 base = 0, size = 0;
+	__u32 i = 0;
+	unsigned char str[20];
+
+	switch (id) {
+	case DISP_REG_SCALER0:
+		base = gdisp.init_para.base_scaler0;
+		size = 0xa18;
+		sprintf(str, "scaler0:\n");
+		break;
+
+	case DISP_REG_SCALER1:
+		base = gdisp.init_para.base_scaler1;
+		size = 0xa18;
+		sprintf(str, "scaler1:\n");
+		break;
+
+	case DISP_REG_IMAGE0:
+		base = gdisp.init_para.base_image0 + 0x800;
+		size = 0xdff - 0x800;
+		sprintf(str, "image0:\n");
+		break;
+
+	case DISP_REG_IMAGE1:
+		base = gdisp.init_para.base_image1 + 0x800;
+		size = 0xdff - 0x800;
+		sprintf(str, "image1:\n");
+		break;
+	case DISP_REG_LCDC0:
+		base = gdisp.init_para.base_lcdc0;
+		size = 0x800;
+		sprintf(str, "lcdc0:\n");
+		break;
+
+	case DISP_REG_LCDC1:
+		base = gdisp.init_para.base_lcdc1;
+		size = 0x800;
+		sprintf(str, "lcdc1:\n");
+		break;
+
+	case DISP_REG_TVEC0:
+		base = gdisp.init_para.base_tvec0;
+		size = 0x20c;
+		sprintf(str, "tvec0:\n");
+		break;
+
+	case DISP_REG_TVEC1:
+		base = gdisp.init_para.base_tvec1;
+		size = 0x20c;
+		sprintf(str, "tvec1:\n");
+		break;
+
+	case DISP_REG_CCMU:
+		base = gdisp.init_para.base_ccmu;
+		size = sunxi_is_sun5i() ? 0x164 : 0x158;
+		sprintf(str, "ccmu:\n");
+		break;
+
+	case DISP_REG_PIOC:
+		base = gdisp.init_para.base_pioc;
+		size = 0x228;
+		sprintf(str, "pioc:\n");
+		break;
+
+	case DISP_REG_PWM:
+		base = gdisp.init_para.base_pwm + 0x200;
+		size = 0x0c;
+		sprintf(str, "pwm:\n");
+		break;
+
+	default:
+		return DIS_FAIL;
+	}
+
+	if (b_force_on)
+		DE_WRN("%s", str);
+	else
+		DE_INF("%s", str);
+
+	for (i = 0; i < size; i += 16) {
+		__u32 reg[4];
+
+		reg[0] = readl(base + i);
+		reg[1] = readl(base + i + 4);
+		reg[2] = readl(base + i + 8);
+		reg[3] = readl(base + i + 12);
+
+		if (b_force_on)
+			DE_WRN("0x%08x:%08x,%08x:%08x,%08x\n", base + i,
+			       reg[0], reg[1], reg[2], reg[3]);
+		else
+			DE_INF("0x%08x:%08x,%08x:%08x,%08x\n", base + i, reg[0],
+			       reg[1], reg[2], reg[3]);
+	}
+
+	return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_display.h b/drivers/video/sunxi/disp/disp_display.h
new file mode 100644
index 0000000..6c6ed80
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_display.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_DISPLAY_H__
+#define __DISP_DISPLAY_H__
+
+#include "disp_display_i.h"
+#include "disp_layer.h"
+#include "disp_scaler.h"
+#include "disp_video.h"
+#include "disp_iep.h"
+#include <asm/div64.h>
+
+#define IMAGE_USED	0x00000004
+#define YUV_CH_USED	0x00000010
+#define HWC_USED	0x00000040
+#define LCDC_TCON0_USED	0x00000080
+#define LCDC_TCON1_USED	0x00000100
+#define SCALER_USED	0x00000200
+
+#define LCD_ON		0x00010000
+#define TV_ON		0x00020000
+#define HDMI_ON		0x00040000
+#define VGA_ON		0x00080000
+
+#define VIDEO_PLL0_USED		0x00100000
+#define VIDEO_PLL1_USED		0x00200000
+
+#define IMAGE_OUTPUT_LCDC		0x00000001
+#define IMAGE_OUTPUT_SCALER		0x00000002
+#define IMAGE_OUTPUT_LCDC_AND_SCALER	0x00000003
+
+#define DE_FLICKER_USED 0x01000000
+#define DE_FLICKER_REQUIRED 0x02000000
+
+#define SUNXI_DISP_MAX_LAYERS 4
+
+static inline __u32 PICOS2HZ(__u32 picos)
+{
+	__u64 numerator = 1000000000000ULL + (picos / 2);
+	do_div(numerator, picos);
+	return numerator;
+}
+
+static inline __u32 HZ2PICOS(__u32 hz)
+{
+	__u64 numerator = 1000000000000ULL + (hz / 2);
+	do_div(numerator, hz);
+	return numerator;
+}
+
+typedef struct {
+	__bool lcd_used;
+
+	__bool lcd_bl_en_used;
+	user_gpio_set_t lcd_bl_en;
+
+	__bool lcd_power_used;
+	user_gpio_set_t lcd_power;
+
+	__bool lcd_pwm_used;
+	user_gpio_set_t lcd_pwm;
+
+	__bool lcd_gpio_used[4];
+	user_gpio_set_t lcd_gpio[4];
+
+	__bool lcd_io_used[28];
+	user_gpio_set_t lcd_io[28];
+
+	__u32 init_bright;
+} __disp_lcd_cfg_t;
+
+typedef struct {
+	__u32 status;		/* display engine,lcd,tv,vga,hdmi status */
+	__u32 lcdc_status;	/* tcon0 used, tcon1 used */
+	__bool have_cfg_reg;
+	__u32 cache_flag;
+	__u32 cfg_cnt;
+
+	__u32 screen_width;
+	__u32 screen_height;
+	__disp_color_t bk_color;
+	__disp_colorkey_t color_key;
+	__u32 bright;
+	__u32 contrast;
+	__u32 saturation;
+	__u32 hue;
+	__bool enhance_en;
+	__u32 max_layers;
+	__layer_man_t layer_manage[4];
+	__u32 de_flicker_status;
+	__u32 iep_status;
+
+	/*
+	 * see macro definition IMAGE_OUTPUT_XXX above, it can be
+	 * lcd only /lcd+scaler/ scaler only
+	 */
+	__u32 image_output_type;
+	__u32 out_scaler_index;
+	__u32 hdmi_index;	/* 0: internal hdmi; 1:external hdmi(if exit) */
+
+	__bool use_edid;
+	__bool b_out_interlace;
+	__disp_output_type_t output_type;	/* sw status */
+	__disp_vga_mode_t vga_mode;
+	__disp_tv_mode_t tv_mode;
+	__disp_tv_mode_t hdmi_mode;
+	__disp_tv_dac_source dac_source[4];
+
+	 __s32(*LCD_CPUIF_XY_Swap) (__s32 mode);
+	void (*LCD_CPUIF_ISR) (void);
+	__u32 pll_use_status;	/* lcdc0/lcdc1 using which video pll(0 or 1) */
+
+	__u32 lcd_bright;
+	/*
+	 * IEP-drc backlight dimming rate:
+	 * 0 -256 (256: no dimming; 0: the most dimming)
+	 */
+	__u32 lcd_bright_dimming;
+
+	__disp_color_range_t out_color_range;
+	__csc_t out_csc;
+
+	__disp_lcd_cfg_t lcd_cfg;
+	__hdle gpio_hdl[4];
+} __disp_screen_t;
+
+typedef struct {
+	__bool enable;
+	__u32 freq;
+	__u32 pre_scal;
+	__u32 active_state;
+	__u32 duty_ns;
+	__u32 period_ns;
+	__u32 entire_cycle;
+	__u32 active_cycle;
+} __disp_pwm_t;
+
+typedef struct {
+	__disp_bsp_init_para init_para;	/* para from driver */
+	__disp_screen_t screen[2];
+	__disp_scaler_t scaler[2];
+	__disp_pwm_t pwm[2];
+} __disp_dev_t;
+
+extern __disp_dev_t gdisp;
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_display_i.h b/drivers/video/sunxi/disp/disp_display_i.h
new file mode 100644
index 0000000..05f770a
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_display_i.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_DISPLAY_I_H__
+#define __DISP_DISPLAY_I_H__
+
+#include "ebios_de.h"
+#include "ebios_lcdc_tve.h"
+#include "drv_disp_i.h" /* For DISP_XXXXXX status codes */
+
+#define DE_INF __inf
+#define DE_WRN __wrn
+
+#define OSAL_IRQ_RETURN IRQ_HANDLED
+
+#define HANDTOID(handle)  ((handle) - 100)
+#define IDTOHAND(ID)  ((ID) + 100)
+
+#define INTC_IRQNO_SCALER0  SW_INT_IRQNO_DEFEBE0
+#define INTC_IRQNO_SCALER1  SW_INT_IRQNO_DEFEBE1
+#define INTC_IRQNO_LCDC0    SW_INT_IRQNO_LCDCTRL0
+#define INTC_IRQNO_LCDC1    SW_INT_IRQNO_LCDCTRL1
+
+#define MAX_SPRITE_BLOCKS   32
+
+/*basic data information definition*/
+enum {
+	FALSE = 0,
+	TRUE
+};
+
+#define DIS_NULL 0
+
+#define BIT0    0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+#define BIT4	0x00000010
+#define BIT5	0x00000020
+#define BIT6	0x00000040
+#define BIT7	0x00000080
+#define BIT8	0x00000100
+#define BIT9	0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_event.c b/drivers/video/sunxi/disp/disp_event.c
new file mode 100644
index 0000000..1b0f9f4
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_event.c
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_event.h"
+#include "disp_display.h"
+#include "disp_de.h"
+#include "disp_video.h"
+#include "disp_scaler.h"
+
+__s32 BSP_disp_cmd_cache(__u32 sel)
+{
+	gdisp.screen[sel].cache_flag = TRUE;
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cmd_submit(__u32 sel)
+{
+	gdisp.screen[sel].cache_flag = FALSE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cfg_start(__u32 sel)
+{
+	gdisp.screen[sel].cfg_cnt++;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_cfg_finish(__u32 sel)
+{
+	gdisp.screen[sel].cfg_cnt--;
+
+	return DIS_SUCCESS;
+}
+
+void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index)
+{
+	__u32 cur_line = 0, start_delay = 0;
+	__u32 i = 0;
+
+	Video_Operation_In_Vblanking(sel, tcon_index);
+
+	cur_line = LCDC_get_cur_line(sel, tcon_index);
+	start_delay = LCDC_get_start_delay(sel, tcon_index);
+	if (cur_line > start_delay - 3) {
+#if 0
+		DE_INF("cur_line(%d) >= start_delay(%d)-3 in "
+		       "LCD_vbi_event_proc\n", cur_line, start_delay);
+#endif
+		return;
+	}
+	IEP_Operation_In_Vblanking(sel, tcon_index);
+
+	if (gdisp.screen[sel].LCD_CPUIF_ISR)
+		(*gdisp.screen[sel].LCD_CPUIF_ISR) ();
+
+	if (gdisp.screen[sel].cache_flag == FALSE &&
+	    gdisp.screen[sel].cfg_cnt == 0) {
+		for (i = 0; i < 2; i++) {
+			if ((gdisp.scaler[i].status & SCALER_USED) &&
+			    (gdisp.scaler[i].screen_index == sel)) {
+				DE_SCAL_Set_Reg_Rdy(i);
+#if 0
+				DE_SCAL_Reset(i);
+				DE_SCAL_Start(i);
+#endif
+			}
+			if (gdisp.scaler[i].b_close == TRUE) {
+				Scaler_close(i);
+				gdisp.scaler[i].b_close = FALSE;
+			}
+			if (sunxi_is_sun5i() &&
+			    gdisp.scaler[i].coef_change == TRUE) {
+				__scal_src_size_t in_size;
+				__scal_out_size_t out_size;
+				__scal_src_type_t in_type;
+				__scal_out_type_t out_type;
+				__scal_scan_mod_t in_scan;
+				__scal_scan_mod_t out_scan;
+				__disp_scaler_t *scaler;
+
+				scaler = &(gdisp.scaler[sel]);
+
+				in_scan.field = FALSE;
+				in_scan.bottom = FALSE;
+
+				in_type.fmt = Scaler_sw_para_to_reg1(
+						scaler->in_fb.format);
+				in_type.mod = scaler->in_fb.mode;
+				in_type.ps = Scaler_sw_para_to_reg3(
+						scaler->in_fb.seq);
+				in_type.byte_seq = 0;
+				in_type.sample_method = 0;
+
+				in_size.src_width = scaler->in_fb.size.width;
+				in_size.src_height = scaler->in_fb.size.height;
+				in_size.x_off = scaler->src_win.x;
+				in_size.y_off = scaler->src_win.y;
+				in_size.scal_width = scaler->src_win.width;
+				in_size.scal_height = scaler->src_win.height;
+
+				out_scan.field = (gdisp.screen[sel].iep_status &
+						  DE_FLICKER_USED) ?
+					FALSE :
+					gdisp.screen[sel].b_out_interlace;
+
+				out_type.byte_seq = scaler->out_fb.seq;
+				out_type.fmt = scaler->out_fb.format;
+
+				out_size.width = scaler->out_size.width;
+				out_size.height = scaler->out_size.height;
+
+				DE_SCAL_Set_Scaling_Coef(sel, &in_scan,
+							 &in_size, &in_type,
+							 &out_scan, &out_size,
+							 &out_type,
+							 scaler->smooth_mode);
+
+				gdisp.scaler[i].coef_change = FALSE;
+			}
+		}
+		DE_BE_Cfg_Ready(sel);
+		gdisp.screen[sel].have_cfg_reg = TRUE;
+	}
+#if 0
+	cur_line = LCDC_get_cur_line(sel, tcon_index);
+
+	if (cur_line > 5)
+		DE_INF("%d\n", cur_line);
+#endif
+
+	return;
+}
+
+void LCD_line_event_proc(__u32 sel)
+{
+	if (gdisp.screen[sel].have_cfg_reg) {
+		gdisp.init_para.disp_int_process(sel);
+		gdisp.screen[sel].have_cfg_reg = FALSE;
+	}
+}
diff --git a/drivers/video/sunxi/disp/disp_event.h b/drivers/video/sunxi/disp/disp_event.h
new file mode 100644
index 0000000..9f9ff64
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_event.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_EVENT_H__
+#define __DISP_EVENT_H__
+
+#include "disp_display_i.h"
+#include "disp_layer.h"
+
+void LCD_vbi_event_proc(__u32 sel, __u32 tcon_index);
+void LCD_line_event_proc(__u32 sel);
+__s32 BSP_disp_cfg_start(__u32 sel);
+__s32 BSP_disp_cfg_finish(__u32 sel);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_hdmi.c b/drivers/video/sunxi/disp/disp_hdmi.c
new file mode 100644
index 0000000..1043215
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_hdmi.c
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display_i.h"
+#include "disp_hdmi.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_tv.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+
+__s32 Display_Hdmi_Init(void)
+{
+	hdmi_clk_init();
+
+	gdisp.screen[0].hdmi_mode = DISP_TV_MOD_720P_50HZ;
+	gdisp.screen[1].hdmi_mode = DISP_TV_MOD_720P_50HZ;
+
+	return DIS_SUCCESS;
+}
+
+__s32 Display_Hdmi_Exit(void)
+{
+	hdmi_clk_exit();
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_open(__u32 sel, __u32 wait_edid)
+{
+	if (!(gdisp.screen[sel].status & HDMI_ON)) {
+		__disp_tv_mode_t tv_mod = gdisp.screen[sel].hdmi_mode;
+
+		if (!gdisp.init_para.hdmi_wait_edid) {
+			pr_err("hdmi funcs NULL, hdmi module not loaded?\n");
+			return -1;
+		}
+
+		hdmi_clk_on();
+
+		if (wait_edid && gdisp.init_para.hdmi_wait_edid() == 0) {
+			tv_mod = DISP_TV_MODE_EDID;
+			gdisp.init_para.hdmi_set_mode(tv_mod);
+			gdisp.screen[sel].hdmi_mode = tv_mod;
+		}
+
+		lcdc_clk_on(sel);
+		image_clk_on(sel);
+
+		/*
+		 * set image normal channel start bit, because every
+		 * de_clk_off( ) will reset this bit
+		 */
+		Image_open(sel);
+		disp_clk_cfg(sel, DISP_OUTPUT_TYPE_HDMI, tv_mod);
+
+		BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_HDMI,
+					gdisp.screen[sel].
+					iep_status & DRC_USED);
+		DE_BE_set_display_size(sel, tv_mode_to_width(tv_mod),
+				       tv_mode_to_height(tv_mod));
+		DE_BE_Output_Select(sel, sel);
+
+		if (sunxi_is_sun5i()) {
+			int scaler_index;
+
+			DE_BE_Set_Outitl_enable(sel, Disp_get_screen_scan_mode(tv_mod));
+
+			for (scaler_index = 0; scaler_index < 2; scaler_index++)
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel)) {
+					/* interlace output */
+					if (Disp_get_screen_scan_mode(tv_mod) ==
+					    1)
+						Scaler_Set_Outitl(scaler_index,
+								  TRUE);
+					else
+						Scaler_Set_Outitl(scaler_index,
+								  FALSE);
+				}
+		}
+
+		TCON1_set_hdmi_mode(sel, tv_mod);
+		TCON1_open(sel);
+		if (gdisp.init_para.Hdmi_open)
+			gdisp.init_para.Hdmi_open();
+		else {
+			DE_WRN("Hdmi_open is NULL\n");
+			return -1;
+		}
+
+		Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_HDMI, tv_mod);
+
+		gdisp.screen[sel].b_out_interlace =
+			Disp_get_screen_scan_mode(tv_mod);
+		gdisp.screen[sel].status |= HDMI_ON;
+		gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
+
+		Disp_set_out_interlace(sel);
+		Display_set_fb_timing(sel);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_close(__u32 sel)
+{
+	if (gdisp.screen[sel].status & HDMI_ON) {
+		if (gdisp.init_para.Hdmi_close) {
+			gdisp.init_para.Hdmi_close();
+		} else {
+			DE_WRN("Hdmi_close is NULL\n");
+			return -1;
+		}
+		Image_close(sel);
+		TCON1_close(sel);
+
+		image_clk_off(sel);
+		lcdc_clk_off(sel);
+		hdmi_clk_off();
+
+		if (sunxi_is_sun5i()) {
+			int scaler_index;
+
+			DE_BE_Set_Outitl_enable(sel, FALSE);
+
+			for (scaler_index = 0; scaler_index < 2; scaler_index++)
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel))
+					Scaler_Set_Outitl(scaler_index, FALSE);
+		}
+
+		gdisp.screen[sel].b_out_interlace = 0;
+		gdisp.screen[sel].lcdc_status &= ~LCDC_TCON1_USED;
+		gdisp.screen[sel].status &= ~HDMI_ON;
+		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &=
+			(gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED) ?
+			~VIDEO_PLL0_USED : ~VIDEO_PLL1_USED;
+
+		Disp_set_out_interlace(sel);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hdmi_set_mode(__u32 sel, __disp_tv_mode_t mode)
+{
+	if (mode >= DISP_TV_MODE_NUM) {
+		DE_WRN("unsupported hdmi mode:%d in BSP_disp_hdmi_set_mode\n",
+		       mode);
+		return DIS_FAIL;
+	}
+
+	if (gdisp.init_para.hdmi_set_mode) {
+		gdisp.init_para.hdmi_set_mode(mode);
+	} else {
+		DE_WRN("hdmi_set_mode is NULL\n");
+		return -1;
+	}
+
+	gdisp.screen[sel].hdmi_mode = mode;
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_HDMI;
+
+	return DIS_SUCCESS;
+}
+
+__u32 fb_videomode_pixclock_to_hdmi_pclk(__u32 pixclock)
+{
+	/*
+	 * The pixelclock -> picoseconds -> pixelclock conversions we do
+	 * lose precision, which *is* a problem.
+	 * We can only do pixelclocks which are a divider of 1 - 15 of
+	 * a multiple of 3 MHz. So all clocks must have been a multiple of
+	 * 100 or 250 KHz before the conversion -> round to the nearest
+	 * multiple of 50 KHz to undo the precision loss.
+	 */
+	__u32 pclk;
+
+	if (pixclock == 0)
+		return 0;
+
+	pclk = (PICOS2HZ(pixclock) + 25000) / 50000;
+	return pclk * 50000;
+}
+
+void videomode_to_video_timing(struct __disp_video_timing *video_timing,
+		const struct fb_videomode *mode)
+{
+	memset(video_timing, 0, sizeof(struct __disp_video_timing));
+	video_timing->VIC = 511;
+	video_timing->PCLK =
+		fb_videomode_pixclock_to_hdmi_pclk(mode->pixclock);
+	video_timing->AVI_PR = 0;
+	video_timing->INPUTX = mode->xres;
+	video_timing->INPUTY = mode->yres;
+	video_timing->HT = mode->xres + mode->left_margin +
+			mode->right_margin + mode->hsync_len;
+	video_timing->HBP = mode->left_margin + mode->hsync_len;
+	video_timing->HFP = mode->right_margin;
+	video_timing->HPSW =  mode->hsync_len;
+	video_timing->VT = mode->yres + mode->upper_margin +
+			mode->lower_margin + mode->vsync_len;
+	video_timing->VBP = mode->upper_margin + mode->vsync_len;
+	video_timing->VFP = mode->lower_margin;
+	video_timing->VPSW = mode->vsync_len;
+	if (mode->vmode & FB_VMODE_INTERLACED)
+		video_timing->I = true;
+
+	if (mode->sync & FB_SYNC_HOR_HIGH_ACT)
+		video_timing->HSYNC = true;
+
+	if (mode->sync & FB_SYNC_VERT_HIGH_ACT)
+		video_timing->VSYNC = true;
+
+}
+
+__s32 BSP_disp_set_videomode(__u32 sel, const struct fb_videomode *mode)
+{
+	struct __disp_video_timing *old_video_timing =
+			kzalloc(sizeof(struct __disp_video_timing), GFP_KERNEL);
+	struct __disp_video_timing *new_video_timing =
+			kzalloc(sizeof(struct __disp_video_timing), GFP_KERNEL);
+	__disp_tv_mode_t hdmi_mode = gdisp.screen[sel].hdmi_mode;
+
+	if (!old_video_timing && !new_video_timing)
+		return DIS_FAIL;
+
+	if (!gdisp.init_para.hdmi_set_videomode)
+		return DIS_FAIL;
+
+	if (gdisp.init_para.hdmi_get_video_timing(hdmi_mode,
+			old_video_timing) != 0)
+		return DIS_FAIL;
+
+	videomode_to_video_timing(new_video_timing, mode);
+
+	gdisp.init_para.hdmi_set_mode(DISP_TV_MODE_EDID);
+	if (gdisp.init_para.hdmi_set_videomode(new_video_timing) != 0)
+		goto failure;
+
+	if (disp_clk_cfg(sel, DISP_OUTPUT_TYPE_HDMI, DISP_TV_MODE_EDID) != 0)
+		goto failure;
+
+	if (DE_BE_set_display_size(sel, new_video_timing->INPUTX,
+			new_video_timing->INPUTY) != 0)
+		goto failure;
+
+	if (TCON1_set_hdmi_mode(sel, DISP_TV_MODE_EDID) != 0)
+		goto failure;
+
+	gdisp.screen[sel].hdmi_mode = DISP_TV_MODE_EDID;
+	gdisp.screen[sel].b_out_interlace = new_video_timing->I;
+
+	kfree(old_video_timing);
+	kfree(new_video_timing);
+	return DIS_SUCCESS;
+
+failure:
+	gdisp.init_para.hdmi_set_mode(hdmi_mode);
+	gdisp.init_para.hdmi_set_videomode(old_video_timing);
+	disp_clk_cfg(sel, DISP_OUTPUT_TYPE_HDMI, hdmi_mode);
+	DE_BE_set_display_size(sel, old_video_timing->INPUTX,
+			old_video_timing->INPUTY);
+	TCON1_set_hdmi_mode(sel, hdmi_mode);
+	kfree(old_video_timing);
+	kfree(new_video_timing);
+	return DIS_FAIL;
+}
+
+__s32 BSP_disp_hdmi_get_mode(__u32 sel)
+{
+	return gdisp.screen[sel].hdmi_mode;
+}
+
+__s32 BSP_disp_hdmi_check_support_mode(__u32 sel, __u8 mode)
+{
+	__s32 ret = 0;
+
+	if (gdisp.init_para.hdmi_mode_support) {
+		ret = gdisp.init_para.hdmi_mode_support(mode);
+	} else {
+		DE_WRN("hdmi_mode_support is NULL\n");
+		return -1;
+	}
+
+	return ret;
+}
+
+__s32 BSP_disp_hdmi_get_hpd_status(__u32 sel)
+{
+	__s32 ret = 0;
+
+	if (gdisp.init_para.hdmi_get_HPD_status) {
+		ret = gdisp.init_para.hdmi_get_HPD_status();
+	} else {
+		pr_warn_once("hdmi_get_HPD_status is NULL\n");
+		return -1;
+	}
+
+	return ret;
+}
+
+__s32 BSP_disp_hdmi_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+	switch (src) {
+	case DISP_LCDC_SRC_DE_CH1:
+		TCON1_select_src(sel, LCDC_SRC_DE1);
+		break;
+
+	case DISP_LCDC_SRC_DE_CH2:
+		TCON1_select_src(sel, LCDC_SRC_DE2);
+		break;
+
+	case DISP_LCDC_SRC_BLUT:
+		TCON1_select_src(sel, LCDC_SRC_BLUE);
+		break;
+
+	default:
+		DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n",
+		       src);
+		return DIS_NOT_SUPPORT;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_set_hdmi_func(__disp_hdmi_func *func)
+{
+	gdisp.init_para.hdmi_wait_edid = func->hdmi_wait_edid;
+	gdisp.init_para.Hdmi_open = func->Hdmi_open;
+	gdisp.init_para.Hdmi_close = func->Hdmi_close;
+	gdisp.init_para.hdmi_set_mode = func->hdmi_set_mode;
+	gdisp.init_para.hdmi_set_videomode = func->hdmi_set_videomode;
+	gdisp.init_para.hdmi_mode_support = func->hdmi_mode_support;
+	gdisp.init_para.hdmi_get_video_timing = func->hdmi_get_video_timing;
+	gdisp.init_para.hdmi_get_HPD_status = func->hdmi_get_HPD_status;
+	gdisp.init_para.hdmi_set_pll = func->hdmi_set_pll;
+
+	return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_hdmi.h b/drivers/video/sunxi/disp/disp_hdmi.h
new file mode 100644
index 0000000..c1e61e0
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_hdmi.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_HDMI_H__
+#define __DISP_HDMI_H__
+
+__s32 Display_Hdmi_Init(void);
+__s32 Display_Hdmi_Exit(void);
+__u32 fb_videomode_pixclock_to_hdmi_pclk(__u32 pixclock);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_hwc.c b/drivers/video/sunxi/disp/disp_hwc.c
new file mode 100644
index 0000000..862f853
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_hwc.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_display.h"
+
+__s32 BSP_disp_hwc_enable(__u32 sel, __bool enable)
+{
+	DE_BE_HWC_Enable(sel, enable);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hwc_set_pos(__u32 sel, __disp_pos_t *pos)
+{
+	DE_BE_HWC_Set_Pos(sel, pos);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hwc_get_pos(__u32 sel, __disp_pos_t *pos)
+{
+	DE_BE_HWC_Get_Pos(sel, pos);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hwc_set_framebuffer(__u32 sel, __disp_hwc_pattern_t *patmem)
+{
+	if (patmem == NULL)
+		return DIS_PARA_FAILED;
+
+	DE_BE_HWC_Set_Src(sel, patmem);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_hwc_set_palette(__u32 sel, void *palette, __u32 offset,
+			       __u32 palette_size)
+{
+	if ((palette == NULL) || ((offset + palette_size) > 1024)) {
+		DE_WRN("para invalid in BSP_disp_hwc_set_palette\n");
+		return DIS_PARA_FAILED;
+	}
+	DE_BE_HWC_Set_Palette(sel, (__u32) palette, offset, palette_size);
+
+	return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_iep.c b/drivers/video/sunxi/disp/disp_iep.c
new file mode 100644
index 0000000..d123055
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_iep.c
@@ -0,0 +1,878 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_iep.h"
+#include "de_iep.h"
+#include "de_iep_tab.h"
+#include "disp_clk.h"
+#include "disp_lcd.h"
+#include "OSAL_Clock.h"
+
+static __s32 Disp_drc_init(__u32 sel);
+static __s32 Disp_drc_proc(__u32 sel, __u32 tcon_index);
+static __s32 Disp_drc_close_proc(__u32 sel, __u32 tcon_index);
+
+static __hdle h_iepahbclk, h_iepdramclk, h_iepmclk;
+static __disp_iep_t giep[2]; /* IEP module parameters */
+static __disp_pwrsv_t gpwrsv[2]; /* Power Saving algorithm parameters */
+static __u32 *pttab; /* POINTER of LGC tab */
+static __u32 printf_cnt; /* for test */
+
+/* power save core */
+#define SCENE_CHNG_THR 45
+/* enable detetion cause filcker in actual ic test 111230, so disable it. */
+#define SCENE_CHANGE_DETECT_DISABLE 1
+
+#define CLK_ON 1
+#define CLK_OFF 0
+#define RST_INVALID 0
+#define RST_VALID 1
+
+//#define DRC_DEFAULT_ENABLE /* Enable drc default */
+//#define DRC_DEMO /* when defined DRC_DEFAULT_ENABLE, run DRC in DEMO mode */
+/* when BSP_disp_lcd_get_bright() exceed PWRSAVE_PROC_THRES, STOP PWRSAVE. */
+#define PWRSAVE_PROC_THRES 85
+
+#define ____SEPARATOR_IEP_DRC_CORE____
+
+/*
+* PoWeRSAVE alg core
+*
+* Note: power save mode alg. Dynamic adjust backlight and lgc gain through
+* screen content and user backlight setting.
+*  - Add SCENE CHANGE DETECT.
+*  - Add HANG-UP DETECT: When use PWRSAVE_CORE in LOW referential backlight
+* condiction, backlight will flicker. So STOP use PWRSAVE_CORE.
+*/
+static inline __s32 PWRSAVE_CORE(__u32 sel)
+{
+	__u32 i;
+	__u32 hist_region_num = 8;
+	__u32 histcnt[IEP_LH_INTERVAL_NUM];
+	__u32 hist[IEP_LH_INTERVAL_NUM], p95;
+	__u32 size = 0;
+	__u32 min_adj_index;
+	__u32 lgcaddr;
+	__u32 drc_filter_total = 0, drc_filter_tmp = 0;
+
+	if (BSP_disp_lcd_get_bright(sel) < PWRSAVE_PROC_THRES) {
+		memset(gpwrsv[sel].min_adj_index_hist, 255,
+		       sizeof(__u8) * IEP_LH_PWRSV_NUM);
+		lgcaddr = (__u32) pttab + ((128 - 1) << 9);
+		lgcaddr = __pa(lgcaddr);
+		/* set "gain=1" tab to lgc */
+		DE_IEP_Drc_Set_Lgc_Addr(sel, lgcaddr);
+
+		gdisp.screen[sel].lcd_bright_dimming = 256;
+		BSP_disp_lcd_set_bright(sel, BSP_disp_lcd_get_bright(sel), 1);
+
+	} else {
+		p95 = 0;
+
+		hist_region_num = (hist_region_num > 8) ?
+			8 : IEP_LH_INTERVAL_NUM;
+
+		/* read histogram result */
+		DE_IEP_Lh_Get_Cnt_Rec(sel, histcnt);
+
+		for (i = 0; i < IEP_LH_INTERVAL_NUM; i++)
+			size += histcnt[i];
+
+		size = (size == 0) ? 1 : size;
+
+		/* calculate some var */
+		hist[0] = (histcnt[0] * 100) / size;
+		for (i = 1; i < hist_region_num; i++)
+			hist[i] = (histcnt[i] * 100) / size + hist[i - 1];
+
+		for (i = 0; i < hist_region_num; i++) {
+			if (hist[i] >= 95) {
+				p95 = hist_thres_pwrsv[i];
+				break;
+			}
+		}
+
+		/*
+		 * sometime, hist[hist_region_num - 1] may less than 95 due to
+		 * integer calc
+		 */
+		if (i == hist_region_num)
+			p95 = hist_thres_pwrsv[7];
+
+		min_adj_index = p95;
+
+		//__inf("min_adj_index: %d\n", min_adj_index);
+
+#if SCENE_CHANGE_DETECT_DISABLE
+		for (i = 0; i < IEP_LH_PWRSV_NUM - 1; i++) {
+			gpwrsv[sel].min_adj_index_hist[i] =
+				gpwrsv[sel].min_adj_index_hist[i + 1];
+		}
+		gpwrsv[sel].min_adj_index_hist[IEP_LH_PWRSV_NUM - 1] =
+			min_adj_index;
+
+		for (i = 0; i < IEP_LH_PWRSV_NUM; i++) {
+			drc_filter_total += drc_filter[i];
+			drc_filter_tmp += drc_filter[i] *
+				gpwrsv[sel].min_adj_index_hist[i];
+		}
+		min_adj_index = drc_filter_tmp / drc_filter_total;
+#else
+		/*
+		 * ADD frame average alg
+		 * SCENE CHANGE DETECT
+		 */
+		if (abs((__s32) min_adj_index -
+			gpwrsv[sel].min_adj_index_hist[IEP_LH_PWRSV_NUM - 1]) >
+		    SCENE_CHNG_THR) {
+			memset(gpwrsv[sel].min_adj_index_hist, min_adj_index,
+			       sizeof(__u8) * IEP_LH_PWRSV_NUM);
+		} else {
+			/* store new gain index, shift history data */
+			for (i = 0; i < IEP_LH_PWRSV_NUM - 1; i++) {
+				gpwrsv[sel].min_adj_index_hist[i] =
+					gpwrsv[sel].min_adj_index_hist[i + 1];
+			}
+			gpwrsv[sel].min_adj_index_hist[IEP_LH_PWRSV_NUM - 1] =
+				min_adj_index;
+
+			for (i = 0; i < IEP_LH_PWRSV_NUM; i++) {
+				drc_filter_total += drc_filter[i];
+				drc_filter_tmp += drc_filter[i] *
+					gpwrsv[sel].min_adj_index_hist[i];
+			}
+			min_adj_index = drc_filter_tmp / drc_filter_total;
+		}
+
+#endif
+
+		min_adj_index = (min_adj_index >= 255) ?
+			255 : ((min_adj_index < hist_thres_pwrsv[0]) ?
+			       hist_thres_pwrsv[0] : min_adj_index);
+		gdisp.screen[sel].lcd_bright_dimming = (min_adj_index + 1);
+
+		BSP_disp_lcd_set_bright(sel, BSP_disp_lcd_get_bright(sel), 1);
+
+		//lgcaddr = (__u32) pwrsv_lgc_tab[min_adj_index - 128];
+		lgcaddr = (__u32) pttab + ((min_adj_index - 128) << 9);
+
+		if (printf_cnt == 120) {
+			__inf("save backlight power: %d percent\n",
+			      (256 - (__u32) min_adj_index) * 100 / 256);
+			printf_cnt = 0;
+		} else {
+			printf_cnt++;
+		}
+
+		/* virtual to physcal addr */
+		lgcaddr = __pa(lgcaddr);
+
+		DE_IEP_Drc_Set_Lgc_Addr(sel, lgcaddr);
+	}
+
+	return 0;
+}
+
+#define ____SEPARATOR_IEP_BSP____
+
+/*
+ *Enable / disable automatic backlight control function
+ */
+__s32 BSP_disp_iep_drc_enable(__u32 sel, __bool en)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (sel == 0) {
+		if (en)
+			gdisp.screen[sel].iep_status |= DRC_REQUIRED;
+		else
+			gdisp.screen[sel].iep_status &= ~DRC_REQUIRED;
+
+		Disp_drc_enable(sel, en);
+		return DIS_SUCCESS;
+	} else {
+		return DIS_NOT_SUPPORT;
+	}
+
+}
+
+__s32 BSP_disp_iep_get_drc_enable(__u32 sel)
+{
+	__u32 ret;
+
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (sel == 0) {
+		if (gdisp.screen[sel].iep_status & DRC_USED) { /* used (ON) */
+			ret = 1;
+		} else if (!(gdisp.screen[sel].iep_status & DRC_USED) &&
+			   (gdisp.screen[sel].iep_status & DRC_REQUIRED)) {
+			/* required but not used(ON) */
+			ret = 2;
+		} else { /* not required and not used (OFF) */
+			ret = 0;
+		}
+
+		return ret;
+	} else {
+		return DIS_NOT_SUPPORT;
+	}
+}
+
+/*
+ *On / Off go jitter function between the lines
+ */
+__s32 BSP_disp_iep_deflicker_enable(__u32 sel, __bool en)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (sel == 0) {
+		if (en)
+			gdisp.screen[sel].iep_status |= DE_FLICKER_REQUIRED;
+		else
+			gdisp.screen[sel].iep_status &= ~DE_FLICKER_REQUIRED;
+
+		Disp_de_flicker_enable(sel, en);
+		return DIS_SUCCESS;
+	} else {
+		return DIS_NOT_SUPPORT;
+	}
+
+}
+
+__s32 BSP_disp_iep_get_deflicker_enable(__u32 sel)
+{
+	__u32 ret;
+
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (sel == 0) {
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_USED)
+			/* used (ON) */
+			ret = 1;
+		else if (!(gdisp.screen[sel].iep_status & DE_FLICKER_USED) &&
+			   (gdisp.screen[sel].iep_status &
+			    DE_FLICKER_REQUIRED))
+			/* required but not used(ON) */
+			ret = 2;
+		else /* not required and not used (OFF) */
+			ret = 0;
+
+		return ret;
+	} else {
+		return DIS_NOT_SUPPORT;
+	}
+}
+
+__s32 BSP_disp_iep_set_demo_win(__u32 sel, __u32 mode, __disp_rect_t *regn)
+{
+	__u32 scn_width, scn_height;
+
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (regn == NULL) {
+		DE_WRN("BSP_disp_iep_set_demo_win: parameters invalid!\n");
+		return DIS_PARA_FAILED;
+	}
+
+	scn_width = BSP_disp_get_screen_width(sel);
+	scn_height = BSP_disp_get_screen_height(sel);
+
+	if ((regn->x < 0) || ((regn->x + regn->width) > scn_width) ||
+	    (regn->y < 0) || ((regn->y + regn->height) > scn_height)) {
+		DE_WRN("BSP_disp_iep_set_demo_win: win_x: %d, win_y: %d, "
+		       "win_width: %d, win_height: %d.\n",
+		       regn->x, regn->y, regn->width, regn->height);
+		DE_WRN("IEP Windows Size Invalid!\n");
+		return DIS_PARA_FAILED;
+	}
+
+	if (mode == 2) { /* drc */
+		memcpy(&giep[sel].drc_win, regn, sizeof(__disp_rect_t));
+		DE_INF("BSP_disp_iep_set_demo_win: drc window  win_x: %d, "
+		       "win_y: %d, win_width: %d, win_height: %d.\n",
+		       giep[sel].drc_win.x, giep[sel].drc_win.y,
+		       giep[sel].drc_win.width, giep[sel].drc_win.height);
+	} else if (mode == 1) { /* de-flicker */
+		memcpy(&giep[sel].deflicker_win, regn, sizeof(__disp_rect_t));
+		DE_INF("BSP_disp_iep_set_demo_win: drc window  win_x: %d, "
+		       "win_y: %d, win_width: %d, win_height: %d.\n",
+		       giep[sel].drc_win.x, giep[sel].drc_win.y,
+		       giep[sel].drc_win.width, giep[sel].drc_win.height);
+	}
+	return DIS_SUCCESS;
+}
+
+#define ____SEPARATOR_IEP_MAIN_TASK____
+
+/*
+ * en : 0-close when vbi
+ * en : 1- open when vbi
+ * en : 2-close immediately
+ */
+__s32 Disp_drc_enable(__u32 sel, __u32 en)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (sel)
+		return -1;
+
+	switch (en) {
+	case 0:
+		if (gdisp.screen[sel].iep_status & DRC_USED)
+			gdisp.screen[sel].iep_status |= DRC_NEED_CLOSED;
+		else
+			DE_INF("de: DRC hasn't opened yet !\n");
+		break;
+
+	case 1:
+		if (gdisp.screen[sel].iep_status & DRC_REQUIRED) {
+			if ((gdisp.screen[sel].output_type ==
+			     DISP_OUTPUT_TYPE_LCD) &&
+			    (gdisp.screen[sel].status & LCD_ON)) {
+				if (!(gdisp.screen[sel].iep_status &
+				      DRC_USED)) {
+					Disp_drc_init(sel);
+					gdisp.screen[sel].iep_status |=
+						DRC_USED;
+					DE_INF("de: DRC open now!\n");
+				} else {
+					DE_INF("de: DRC has already opened "
+					       "before!\n");
+				}
+			} else {
+				DE_INF("de: Will OPEN DRC when output to "
+				       "LCD!\n");
+			}
+		} else {
+			DE_INF("de: Run DISP_CMD_DRC_ON will open DRC!\n");
+		}
+		break;
+
+	case 2:
+		if (gdisp.screen[sel].iep_status & DRC_USED)
+			Disp_drc_close_proc(sel, 0);
+		else
+			DE_INF("de: DRC hasn't opened yet !\n");
+
+		break;
+	}
+
+	return 0;
+}
+
+static __s32 Disp_drc_init(__u32 sel)
+{
+	__u32 scn_width, scn_height;
+
+	scn_width = BSP_disp_get_screen_width(sel);
+	scn_height = BSP_disp_get_screen_height(sel);
+
+	if (sel == 0) {
+		/* to prevent BE OUTCSC output YUV when IEP CSC not ready */
+		//BSP_disp_cfg_start(sel);
+		/* IEP clk */
+		iep_clk_open(sel);
+
+		/* another module */
+		/* when running drc mode, debe must output yuv format */
+#if 0
+		DE_BE_Output_Cfg_Csc_Coeff(sel, DISP_OUTPUT_TYPE_TV, 0);
+		BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, 1);
+#endif
+
+		/* IEP module */
+		DE_IEP_Set_Mode(sel, 2);
+		DE_IEP_Set_Display_Size(sel, scn_width, scn_height);
+		//DE_IEP_Set_Csc_Coeff(sel, 3);
+		DE_IEP_Drc_Set_Spa_Coeff(sel, spatial_coeff);
+		DE_IEP_Drc_Set_Int_Coeff(sel, intensity_coeff);
+
+		/* default: no adjust */
+		DE_IEP_Drc_Adjust_Enable(sel, 0);
+		/* default: autoload enable */
+		DE_IEP_Drc_Set_Lgc_Autoload_Disable(sel, 0);
+
+		DE_IEP_Lh_Set_Mode(sel, 0); /* default: histogram normal mode */
+		//DE_IEP_Lh_Set_Mode(sel, 1); /* histogram average mode */
+
+		//DE_IEP_Lh_Set_Thres(sel, hist_thres_drc);
+		DE_IEP_Lh_Set_Thres(sel, hist_thres_pwrsv);
+		//gpwrsv[sel].user_bl = gdisp.screen[sel].lcd_bright;
+
+		memset(gpwrsv[sel].min_adj_index_hist, 255,
+		       sizeof(__u8) * IEP_LH_PWRSV_NUM);
+
+		//giep[sel].drc_en = 1;
+		giep[sel].drc_win_en = 1;
+#if 0
+		giep[sel].drc_win.x = 0;
+		giep[sel].drc_win.y = 0;
+		giep[sel].drc_win.width = scn_width;
+		/*
+		 * will clear when drc enable actually, but apps dont know when,
+		 * so delete it.
+		 */
+		giep[sel].drc_win.height = scn_height;
+#endif
+		/* set 1 to make sure first frame wont get a random lgc table */
+		giep[sel].waitframe = 1;
+		giep[sel].runframe = 0;
+
+		/* to prevent BE OUTCSC output YUV when IEP CSC not ready */
+		//BSP_disp_cfg_finish(sel);
+
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+/*
+ * en : 0-close when vbi
+ * en : 1- open when vbi
+ * en : 2-close immediately
+ */
+__s32 Disp_de_flicker_enable(__u32 sel, __u32 en)
+{
+	__disp_tv_mode_t tv_mode;
+	__u32 scan_mode;
+	__u32 scaler_index;
+
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	tv_mode = gdisp.screen[sel].tv_mode;
+	scan_mode = gdisp.screen[sel].b_out_interlace;
+
+	if (sel)
+		return -1;
+
+	switch (en) {
+	case 0:
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_USED) {
+			BSP_disp_cfg_start(sel);
+
+			for (scaler_index = 0; scaler_index < 2;
+			     scaler_index++) {
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel)) {
+					Scaler_Set_Outitl(scaler_index, TRUE);
+				}
+			}
+
+			/* must do in sun5i */
+			DE_BE_Set_Outitl_enable(sel, TRUE);
+
+			gdisp.screen[sel].iep_status &= DE_FLICKER_NEED_CLOSED;
+
+			BSP_disp_cfg_finish(sel);
+		} else {
+			DE_INF("de: De-flicker hasn't opened yet!\n");
+		}
+		break;
+
+	case 1:
+		/* when set DISP_CMD_DE_FLICKER_ON before */
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_REQUIRED) {
+			if ((gdisp.screen[sel].output_type ==
+			     DISP_OUTPUT_TYPE_TV) && scan_mode &&
+			    (gdisp.screen[sel].status & TV_ON))	{
+				/* when interlaced tv on */
+				if (!(gdisp.screen[sel].iep_status &
+				      DE_FLICKER_USED)) {
+					BSP_disp_cfg_start(sel);
+
+					/* config defe to fit de-flicker */
+					for (scaler_index = 0;
+					     scaler_index < 2;
+					     scaler_index++) {
+						if ((gdisp.scaler[scaler_index].
+						     status & SCALER_USED) &&
+						    (gdisp.scaler[scaler_index].
+						     screen_index == sel)) {
+							Scaler_Set_Outitl
+								(scaler_index,
+								 FALSE);
+						}
+					}
+
+					/* config debe to fit de-flicker */
+					/* must do in sun5i */
+					DE_BE_Set_Outitl_enable(sel, FALSE);
+
+					Disp_de_flicker_init(sel);
+					gdisp.screen[sel].iep_status |=
+						DE_FLICKER_USED;
+
+					BSP_disp_cfg_finish(sel);
+				} else {
+					DE_INF("de: De-flicker has already "
+					       "opened before !\n");
+				}
+			} else {
+				DE_INF("de: Will OPEN de-flicker when output to"
+				       " interlaced device !\n");
+			}
+		} else {
+			DE_INF("de: Run DISP_CMD_DE_FLICKER_ON will open "
+			       "de-flicker !\n");
+		}
+		break;
+
+	case 2:
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_USED) {
+			BSP_disp_cfg_start(sel);
+
+			for (scaler_index = 0; scaler_index < 2;
+			     scaler_index++) {
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel)) {
+					Scaler_Set_Outitl(scaler_index, TRUE);
+				}
+			}
+
+			/* must do in sun5i */
+			DE_BE_Set_Outitl_enable(sel, TRUE);
+
+			Disp_de_flicker_close_proc(sel, 1);
+
+			BSP_disp_cfg_finish(sel);
+		} else {
+			DE_INF("de: De-flicker hasn't opened yet!\n");
+		}
+		break;
+
+	}
+
+	return 0;
+}
+
+__s32 Disp_de_flicker_init(__u32 sel)
+{
+	__u32 scn_width, scn_height;
+
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	scn_width = BSP_disp_get_screen_width(sel);
+	scn_height = BSP_disp_get_screen_height(sel);
+
+	if (sel == 0) {
+		DE_IEP_Set_Mode(sel, 1);
+		DE_IEP_Set_Display_Size(sel, scn_width, scn_height);
+		DE_IEP_Set_Csc_Coeff(sel, 1);
+
+		giep[sel].deflicker_win_en = 1;
+
+		giep[sel].deflicker_win.x = 0;
+		giep[sel].deflicker_win.y = 0;
+		giep[sel].deflicker_win.width = scn_width;
+		giep[sel].deflicker_win.height = scn_height;
+
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+#define ____SEPARATOR_IEP_CLK____
+
+__s32 iep_clk_init(__u32 sel)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+#ifdef CONFIG_ARCH_SUN5I
+	h_iepahbclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_AHB_IEP);
+	h_iepdramclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_SDRAM_IEP);
+	h_iepmclk = OSAL_CCMU_OpenMclk(AW_MOD_CLK_IEP);
+
+	OSAL_CCMU_MclkReset(h_iepmclk, RST_INVALID);
+	OSAL_CCMU_MclkOnOff(h_iepahbclk, CLK_ON);
+
+	g_clk_status |= CLK_IEP_AHB_ON;
+#endif
+	return DIS_SUCCESS;
+}
+
+__s32 iep_clk_exit(__u32 sel)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	OSAL_CCMU_MclkReset(h_iepmclk, RST_VALID);
+
+	if (g_clk_status & CLK_IEP_DRAM_ON)
+		OSAL_CCMU_MclkOnOff(h_iepdramclk, CLK_OFF);
+
+	if (g_clk_status & CLK_IEP_MOD_ON)
+		OSAL_CCMU_MclkOnOff(h_iepmclk, CLK_OFF);
+
+	OSAL_CCMU_MclkOnOff(h_iepahbclk, CLK_OFF);
+
+	OSAL_CCMU_CloseMclk(h_iepahbclk);
+	OSAL_CCMU_CloseMclk(h_iepdramclk);
+	OSAL_CCMU_CloseMclk(h_iepmclk);
+
+	g_clk_status &= ~(CLK_IEP_AHB_ON | CLK_IEP_MOD_ON | CLK_IEP_DRAM_ON);
+	return DIS_SUCCESS;
+}
+
+__s32 iep_clk_open(__u32 sel)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	OSAL_CCMU_MclkOnOff(h_iepmclk, CLK_ON);
+	OSAL_CCMU_MclkOnOff(h_iepdramclk, CLK_ON);
+
+	g_clk_status |= CLK_IEP_MOD_ON | CLK_IEP_DRAM_ON;
+	return DIS_SUCCESS;
+}
+
+__s32 iep_clk_close(__u32 sel)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	OSAL_CCMU_MclkOnOff(h_iepmclk, CLK_OFF);
+	OSAL_CCMU_MclkOnOff(h_iepdramclk, CLK_OFF);
+
+	g_clk_status &= ~(CLK_IEP_MOD_ON | CLK_IEP_DRAM_ON);
+	return DIS_SUCCESS;
+}
+
+#define ____SEPARATOR_IEP_INIT_EXIT____
+
+__s32 Disp_iep_init(__u32 sel)
+{
+
+#ifdef DRC_DEFAULT_ENABLE
+	__disp_rect_t regn;
+#endif
+
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	memset(giep, 0, sizeof(giep));
+	memset(gpwrsv, 0, sizeof(gpwrsv));
+
+	if (sel == 0) {
+		iep_clk_init(sel);
+		pttab = kmalloc(sizeof(pwrsv_lgc_tab), GFP_KERNEL | __GFP_ZERO);
+
+		memcpy(pttab, pwrsv_lgc_tab, sizeof(pwrsv_lgc_tab));
+
+#ifdef DRC_DEFAULT_ENABLE
+#ifdef DRC_DEMO
+		regn.x = BSP_disp_get_screen_width(sel) / 2;
+		regn.y = 0;
+		regn.width = BSP_disp_get_screen_width(sel) / 2;
+		regn.height = BSP_disp_get_screen_height(sel);
+#else
+		regn.x = 0;
+		regn.y = 0;
+		regn.width = BSP_disp_get_screen_width(sel);
+		regn.height = BSP_disp_get_screen_height(sel);
+#endif
+		BSP_disp_iep_drc_enable(sel, 1);
+		BSP_disp_iep_set_demo_win(sel, 2, &regn);
+#endif
+
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 Disp_iep_exit(__u32 sel)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (sel == 0) {
+		iep_clk_exit(sel);
+		kfree(pttab);
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+#define ____SEPARATOR_IEP_INT_PROC____
+
+__s32 IEP_Operation_In_Vblanking(__u32 sel, __u32 tcon_index)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	/* if use DMA mode for LCD panel?? */
+	if (gpanel_info[sel].tcon_index == tcon_index) {
+		if (gdisp.screen[sel].iep_status & DRC_NEED_CLOSED)
+			Disp_drc_close_proc(sel, tcon_index);
+		else if (gdisp.screen[sel].iep_status & DRC_USED)
+			Disp_drc_proc(sel, tcon_index);
+	} else if (tcon_index == 1) {
+		if (gdisp.screen[sel].iep_status & DE_FLICKER_NEED_CLOSED)
+			Disp_de_flicker_close_proc(sel, tcon_index);
+		else if (gdisp.screen[sel].iep_status & DE_FLICKER_USED)
+			Disp_de_flicker_proc(sel, tcon_index);
+	}
+
+	return DIS_SUCCESS;
+}
+
+static __s32 Disp_drc_proc(__u32 sel, __u32 tcon_index)
+{
+	__u32 top, bot, left, right;
+	__u32 lgcaddr;
+
+	if (sel == 0) {
+		if (giep[sel].runframe < giep[sel].waitframe) {
+			/*
+			 * first  frame, wont get the valid histogram, so open
+			 * a "zero" window
+			 */
+			top = 0;
+			bot = 0;
+			left = 0;
+			right = 0;
+
+			DE_IEP_Set_Demo_Win_Para(sel, top, bot, left, right);
+			DE_IEP_Demo_Win_Enable(sel, 1);	/* enable here */
+			/* 12-04-01 debug flicker in LCD opening */
+			DE_IEP_Set_Csc_Coeff(sel, 3);
+			BSP_disp_set_output_csc(sel,
+						gdisp.screen[sel].output_type,
+						1);
+
+			lgcaddr = (__u32) pttab + ((128 - 1) << 9);
+			lgcaddr = __pa(lgcaddr);
+			/* set "gain=1" tab to lgc */
+			DE_IEP_Drc_Set_Lgc_Addr(sel, lgcaddr);
+			DE_IEP_Enable(sel); /* enable here */
+#if 0
+			DE_INF("waitting for runframe %d up to%d!\n",
+			       giep.runframe, giep.waitframe);
+#endif
+			giep[sel].runframe++;
+		} else {
+			if (giep[sel].drc_win_en) {
+				/* convert rectangle to register */
+				top = giep[sel].drc_win.y;
+				bot = giep[sel].drc_win.y +
+					giep[sel].drc_win.height - 1;
+				left = giep[sel].drc_win.x;
+				right = giep[sel].drc_win.x +
+					giep[sel].drc_win.width - 1;
+
+				DE_IEP_Set_Demo_Win_Para(sel, top, bot, left,
+							 right);
+			}
+			/* BACKLIGHT Control ALG */
+			PWRSAVE_CORE(sel);
+		}
+
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+static __s32 Disp_drc_close_proc(__u32 sel, __u32 tcon_index)
+{
+	if (sel == 0) {
+		/* IEP module */
+		DE_IEP_Disable(sel);
+
+		/* another module */
+		BSP_disp_set_output_csc(sel, gdisp.screen[sel].output_type, 0);
+
+		/* IEP clk */
+		iep_clk_close(sel);
+
+		gdisp.screen[sel].iep_status &= ~(DRC_USED | DRC_NEED_CLOSED);
+
+		gdisp.screen[sel].lcd_bright_dimming = 256;
+		BSP_disp_lcd_set_bright(sel, BSP_disp_lcd_get_bright(sel), 1);
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 Disp_de_flicker_proc(__u32 sel, __u32 tcon_index)
+{
+	__u32 top, bot, left, right;
+
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (sel == 0) {
+		if (giep[sel].deflicker_win_en) {
+			top = giep[sel].deflicker_win.y;
+			bot = giep[sel].deflicker_win.y +
+				giep[sel].deflicker_win.height - 1;
+			left = giep[sel].deflicker_win.x;
+			right =  giep[sel].deflicker_win.x +
+				giep[sel].deflicker_win.width - 1;
+
+			DE_IEP_Set_Demo_Win_Para(sel, top, bot, left, right);
+			DE_IEP_Demo_Win_Enable(sel, 1);
+		}
+
+		DE_IEP_Enable(sel);
+
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+__s32 Disp_de_flicker_close_proc(__u32 sel, __u32 tcon_index)
+{
+	if (!sunxi_is_sun5i())
+		return 0;
+
+	if (sel == 0) {
+		/* IEP module */
+		DE_IEP_Disable(sel);
+
+		/* IEP clk */
+		iep_clk_close(sel);
+
+		gdisp.screen[sel].iep_status &=
+			~(DE_FLICKER_NEED_CLOSED | DE_FLICKER_USED);
+
+		return 0;
+	} else {
+		return -1;
+	}
+}
diff --git a/drivers/video/sunxi/disp/disp_iep.h b/drivers/video/sunxi/disp/disp_iep.h
new file mode 100644
index 0000000..aea3735
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_iep.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_IEP_H__
+#define __DISP_IEP_H__
+
+#include "disp_display.h"
+#include "de_iep.h"
+#include "disp_event.h"
+
+#define CLK_IEP_AHB_ON	0x00000008
+#define CLK_IEP_MOD_ON	0x00000080
+#define CLK_IEP_DRAM_ON	0x00000800
+
+#define DE_FLICKER_USED			0x01000000
+#define DE_FLICKER_REQUIRED		0x02000000
+#define DRC_USED			0x04000000
+#define DRC_REQUIRED			0x08000000
+#define DE_FLICKER_NEED_CLOSED		0x10000000
+#define DRC_NEED_CLOSED			0x20000000
+
+/* for power saving mode alg0 */
+#define IEP_LH_PWRSV_NUM 24
+
+typedef struct {
+	__u32 mod;
+
+	/* drc */
+	//__u32 drc_en;
+	__u32 drc_win_en;
+	__disp_rect_t drc_win;
+	__u32 adjust_en;
+	__u32 lgc_autoload_dis;
+	__u32 waitframe;
+	__u32 runframe;
+	__u32 valid_width;
+	__u32 valid_height;
+
+	/* lh */
+	__u32 lgc_base_add;
+	__u8 lh_thres_val[IEP_LH_THRES_NUM];
+
+	/* de-flicker */
+	//__u32 deflicker_en;
+	__u32 deflicker_win_en;
+	__disp_rect_t deflicker_win;
+} __disp_iep_t;
+
+typedef struct {
+	__u8 min_adj_index_hist[IEP_LH_PWRSV_NUM];
+	__u32 user_bl;
+} __disp_pwrsv_t;
+
+extern __s32 Disp_iep_init(__u32 sel);
+extern __s32 Disp_iep_exit(__u32 sel);
+extern __s32 Disp_drc_enable(__u32 sel, __u32 en);
+extern __s32 Disp_de_flicker_enable(__u32 sel, __u32 en);
+extern __s32 Disp_de_flicker_init(__u32 sel);
+extern __s32 iep_clk_init(__u32 sel);
+extern __s32 iep_clk_exit(__u32 sel);
+extern __s32 iep_clk_open(__u32 sel);
+extern __s32 iep_clk_close(__u32 sel);
+extern __s32 IEP_Operation_In_Vblanking(__u32 sel, __u32 tcon_index);
+extern __s32 Disp_de_flicker_proc(__u32 sel, __u32 tcon_index);
+extern __s32 Disp_de_flicker_close_proc(__u32 sel, __u32 tcon_index);
+
+extern __s32 DE_IEP_Set_Reg_Base(__u32 sel, __u32 base);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_layer.c b/drivers/video/sunxi/disp/disp_layer.c
new file mode 100644
index 0000000..b765d6f
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_layer.c
@@ -0,0 +1,1304 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_layer.h"
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_scaler.h"
+#include "disp_event.h"
+#include "disp_clk.h"
+
+static __s32 Layer_Get_Idle_Hid(__u32 sel)
+{
+	__s32 i;
+
+	for (i = 0; i < gdisp.screen[sel].max_layers; i++)
+		if (!(gdisp.screen[sel].layer_manage[i].status & LAYER_USED))
+			return i;
+
+	return (__s32) DIS_NO_RES;
+}
+
+static __s32 Layer_Get_Idle_Prio(__u32 sel)
+{
+	__s32 i, j;
+
+	for (i = 0; i < gdisp.screen[sel].max_layers; i++)
+		for (j = 0; j < gdisp.screen[sel].max_layers; j++) {
+			if (gdisp.screen[sel].layer_manage[j].para.prio == i)
+				break;
+			else if (j == gdisp.screen[sel].max_layers - 1)
+				return i;
+		}
+
+	return DIS_PRIO_ERROR;
+}
+
+__u32 Layer_Get_Prio(__u32 sel, __u32 hid)
+{
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED)
+		return gdisp.screen[sel].layer_manage[hid].para.prio;
+
+	return (__u32) DIS_PARA_FAILED;
+}
+
+__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t format)
+{
+	if (format == DISP_FORMAT_YUV444 || format == DISP_FORMAT_YUV422 ||
+	    format == DISP_FORMAT_YUV420 || format == DISP_FORMAT_YUV411)
+		return DISP_FB_TYPE_YUV;
+	else
+		return DISP_FB_TYPE_RGB;
+}
+
+/*
+ * 0: yuv channel format
+ * 1: yuv channel pixel sequence
+ * 3: image0 pixel sequence
+ */
+__s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value)
+{
+	if (type == 0) { /* yuv channel format */
+		if (mode == DISP_MOD_NON_MB_PLANAR &&
+		    value == DISP_FORMAT_YUV411) {
+			return 0;
+		} else if (mode == DISP_MOD_NON_MB_PLANAR &&
+			   value == DISP_FORMAT_YUV422) {
+			return 1;
+		} else if (mode == DISP_MOD_NON_MB_PLANAR &&
+			   value == DISP_FORMAT_YUV444) {
+			return 2;
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_FORMAT_YUV422) {
+			return 3;
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_FORMAT_YUV444) {
+			return 4;
+		} else {
+			DE_WRN("not supported yuv channel format:%d in "
+			       "img_sw_para_to_reg\n", value);
+			return 0;
+		}
+	} else if (type == 1) { /* yuv channel pixel sequence */
+		if (mode == DISP_MOD_NON_MB_PLANAR && value == DISP_SEQ_P3210) {
+			return 0;
+		} else if (mode == DISP_MOD_NON_MB_PLANAR &&
+			   value == DISP_SEQ_P0123) {
+			return 1;
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_UYVY) {
+			return 0;
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_YUYV) {
+			return 1;
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_VYUY) {
+			return 2;
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_YVYU) {
+			return 3;
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_AYUV) {
+			return 0;
+		} else if (mode == DISP_MOD_INTERLEAVED &&
+			   value == DISP_SEQ_VUYA) {
+			return 1;
+		} else {
+			DE_WRN("not supported yuv channel pixel sequence:%d "
+			       "in img_sw_para_to_reg\n", value);
+			return 0;
+		}
+	} else if (type == 3) {	/* image0 pixel sequence */
+		if (value == DISP_SEQ_ARGB) {
+			return 0;
+		} else if (value == DISP_SEQ_BGRA) {
+			return 2;
+		} else if (value == DISP_SEQ_P10) {
+			return 0;
+		} else if (value == DISP_SEQ_P01) {
+			return 1;
+		} else if (value == DISP_SEQ_P3210) {
+			return 0;
+		} else if (value == DISP_SEQ_P0123) {
+			return 1;
+		} else if (value == DISP_SEQ_P76543210) {
+			return 0;
+		} else if (value == DISP_SEQ_P67452301) {
+			return 1;
+		} else if (value == DISP_SEQ_P10325476) {
+			return 2;
+		} else if (value == DISP_SEQ_P01234567) {
+			return 3;
+		} else if (value == DISP_SEQ_2BPP_BIG_BIG) {
+			return 0;
+		} else if (value == DISP_SEQ_2BPP_BIG_LITTER) {
+			return 1;
+		} else if (value == DISP_SEQ_2BPP_LITTER_BIG) {
+			return 2;
+		} else if (value == DISP_SEQ_2BPP_LITTER_LITTER) {
+			return 3;
+		} else if (value == DISP_SEQ_1BPP_BIG_BIG) {
+			return 0;
+		} else if (value == DISP_SEQ_1BPP_BIG_LITTER) {
+			return 1;
+		} else if (value == DISP_SEQ_1BPP_LITTER_BIG) {
+			return 2;
+		} else if (value == DISP_SEQ_1BPP_LITTER_LITTER) {
+			return 3;
+		} else {
+			DE_WRN("not supported image0 pixel sequence:%d in "
+			       "img_sw_para_to_reg\n", value);
+			return 0;
+		}
+	}
+
+	DE_WRN("not supported type:%d in img_sw_para_to_reg\n", type);
+	return 0;
+}
+
+static __s32 Yuv_Channel_Request(__u32 sel, __u8 hid)
+{
+	if (!(gdisp.screen[sel].status & YUV_CH_USED)) {
+		DE_BE_YUV_CH_Enable(sel, TRUE);
+		DE_BE_Layer_Yuv_Ch_Enable(sel, hid, TRUE);
+
+		gdisp.screen[sel].layer_manage[hid].byuv_ch = TRUE;
+		gdisp.screen[sel].status |= YUV_CH_USED;
+		return DIS_SUCCESS;
+	}
+	return DIS_NO_RES;
+}
+
+static __s32 Yuv_Channel_Release(__u32 sel, __u8 hid)
+{
+	de_yuv_ch_src_t yuv_src;
+
+	memset(&yuv_src, 0, sizeof(de_yuv_ch_src_t));
+	DE_BE_YUV_CH_Set_Src(sel, &yuv_src);
+	DE_BE_YUV_CH_Enable(sel, FALSE);
+	DE_BE_Layer_Yuv_Ch_Enable(sel, hid, FALSE);
+
+	gdisp.screen[sel].layer_manage[hid].byuv_ch = FALSE;
+	gdisp.screen[sel].status &= ~YUV_CH_USED;
+
+	return DIS_SUCCESS;
+}
+
+__s32 Yuv_Channel_Set_framebuffer(__u32 sel, __disp_fb_t *pfb, __u32 xoffset,
+				  __u32 yoffset)
+{
+	de_yuv_ch_src_t yuv_src;
+
+	yuv_src.format = img_sw_para_to_reg(0, pfb->mode, pfb->format);
+	yuv_src.mode = pfb->mode;
+	yuv_src.pixseq = img_sw_para_to_reg(1, pfb->mode, pfb->seq);
+	yuv_src.ch0_base = pfb->addr[0];
+	yuv_src.ch1_base = pfb->addr[1];
+	yuv_src.ch2_base = pfb->addr[2];
+	yuv_src.line_width = pfb->size.width;
+	yuv_src.offset_x = xoffset;
+	yuv_src.offset_y = yoffset;
+	yuv_src.cs_mode = pfb->cs_mode;
+	DE_BE_YUV_CH_Set_Src(sel, &yuv_src);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode, __u32 format, __s32 *src_x,
+			    __u32 *scn_width)
+{
+	__u32 w_shift;
+	__u32 reg_format;
+
+	reg_format = img_sw_para_to_reg(0, mode, format);
+
+	if (reg_format == 0x0) /* planar yuv411 */
+		w_shift = 4;
+	else if (reg_format == 0x1) /* planar yuv422 */
+		w_shift = 3;
+	else if (reg_format == 0x2) /* planar yuv444 */
+		w_shift = 2;
+	else
+		w_shift = 0;
+
+	*src_x = (*src_x >> w_shift) << w_shift;
+	*scn_width = (*scn_width >> w_shift) << w_shift;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_request(__u32 sel, __disp_layer_work_mode_t mode)
+{
+	__s32 hid;
+	__s32 prio = 0;
+	__layer_man_t *layer_man;
+
+	hid = Layer_Get_Idle_Hid(sel);
+	if (hid == DIS_NO_RES) {
+		DE_WRN("all layer resource used!\n");
+		return DIS_NULL;
+	}
+	prio = Layer_Get_Idle_Prio(sel);
+	if (prio < 0) {
+		DE_WRN("all layer prio used!\n");
+		return DIS_NULL;
+	}
+
+	BSP_disp_cfg_start(sel);
+
+	DE_BE_Layer_Enable(sel, hid, FALSE);
+	DE_BE_Layer_Set_Prio(sel, hid, prio);
+	DE_BE_Layer_Set_Work_Mode(sel, hid, DISP_LAYER_WORK_MODE_NORMAL);
+	DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+
+	BSP_disp_cfg_finish(sel);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	memset(&layer_man->para, 0, sizeof(__disp_layer_info_t));
+	layer_man->para.mode = DISP_LAYER_WORK_MODE_NORMAL;
+	layer_man->para.prio = prio;
+	layer_man->byuv_ch = 0;
+	layer_man->status = LAYER_USED;
+
+	return IDTOHAND(hid);
+}
+
+__s32 BSP_disp_layer_release(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	BSP_disp_cfg_start(sel);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+
+	if (layer_man->status & LAYER_USED) {
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			if (layer_man->para.b_from_screen) {
+				Image_close(1 - sel);
+				image_clk_off(1 - sel);
+				gdisp.screen[1 - sel].image_output_type = 0;
+			}
+			/* release a scaler object */
+			Scaler_Release(layer_man->scaler_index, FALSE);
+		} else {
+			if (layer_man->byuv_ch) {
+				Yuv_Channel_Release(sel, hid);
+			} else {
+				layer_src_t layer_src;
+
+				memset(&layer_src, 0, sizeof(layer_src_t));
+				DE_BE_Layer_Set_Framebuffer(sel, hid,
+							    &layer_src);
+			}
+		}
+	}
+	memset(layer_man, 0, sizeof(__layer_man_t));
+	DE_BE_Layer_Enable(sel, hid, FALSE);
+	DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+	DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
+	DE_BE_Layer_Yuv_Ch_Enable(sel, hid, FALSE);
+	DE_BE_Layer_Set_Screen_Win(sel, hid, &(layer_man->para.scn_win));
+	DE_BE_Layer_Set_Prio(sel, hid, 0);
+	DE_BE_Layer_Set_Pipe(sel, hid, 0);
+	DE_BE_Layer_Alpha_Enable(sel, hid, FALSE);
+	DE_BE_Layer_Set_Alpha_Value(sel, hid, 0);
+	DE_BE_Layer_ColorKey_Enable(sel, hid, FALSE);
+
+	BSP_disp_cfg_finish(sel);
+
+	layer_man->para.prio = IDLE_PRIO;
+	layer_man->status &= ~(LAYER_USED | LAYER_OPENED);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_layer_open(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		if (!(layer_man->status & LAYER_OPENED)) {
+			BSP_disp_cfg_start(sel);
+			DE_BE_Layer_Enable(sel, hid, TRUE);
+			BSP_disp_cfg_finish(sel);
+			layer_man->status |= LAYER_OPENED;
+		}
+		return DIS_SUCCESS;
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_layer_close(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		if (layer_man->status & LAYER_OPENED) {
+			BSP_disp_cfg_start(sel);
+			DE_BE_Layer_Enable(sel, hid, FALSE);
+			BSP_disp_cfg_finish(sel);
+			layer_man->status &= ~LAYER_OPENED;
+		}
+		return DIS_SUCCESS;
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+/*
+ * keep the src window offset x/y
+ */
+__s32 BSP_disp_layer_set_framebuffer(__u32 sel, __u32 hid, __disp_fb_t *pfb)
+{
+	__s32 ret;
+	layer_src_t layer_fb;
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (pfb == NULL)
+		return DIS_PARA_FAILED;
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		BSP_disp_cfg_start(sel);
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			ret = Scaler_Set_Framebuffer(layer_man->scaler_index,
+						     pfb);
+			BSP_disp_cfg_finish(sel);
+			return ret;
+		} else {
+			if (get_fb_type(pfb->format) == DISP_FB_TYPE_YUV) {
+				if (layer_man->byuv_ch == FALSE) {
+					ret = Yuv_Channel_Request(sel, hid);
+					if (ret != DIS_SUCCESS) {
+						DE_WRN("request yuv channel "
+						       "fail\n");
+						BSP_disp_cfg_finish(sel);
+						return ret;
+					}
+				}
+				Yuv_Channel_adjusting(sel, pfb->mode,
+						      pfb->format,
+						      &layer_man->para.src_win.
+						      x,
+						      &layer_man->para.scn_win.
+						      width);
+				Yuv_Channel_Set_framebuffer(sel, pfb,
+							    layer_man->para.
+							    src_win.x,
+							    layer_man->para.
+							    src_win.y);
+			} else {
+				layer_fb.fb_addr = pfb->addr[0];
+				layer_fb.pixseq = img_sw_para_to_reg(3, 0,
+								     pfb->seq);
+				layer_fb.br_swap = pfb->br_swap;
+				layer_fb.fb_width = pfb->size.width;
+				layer_fb.offset_x = layer_man->para.src_win.x;
+				layer_fb.offset_y = layer_man->para.src_win.y;
+				layer_fb.format = pfb->format;
+				DE_BE_Layer_Set_Framebuffer(sel, hid,
+							    &layer_fb);
+			}
+
+			memcpy(&layer_man->para.fb, pfb, sizeof(__disp_fb_t));
+			BSP_disp_cfg_finish(sel);
+
+			return DIS_SUCCESS;
+		}
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_layer_get_framebuffer(__u32 sel, __u32 hid, __disp_fb_t *pfb)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (pfb == NULL)
+		return DIS_PARA_FAILED;
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			return Scaler_Get_Framebuffer(layer_man->scaler_index,
+						      pfb);
+		} else {
+			memcpy(pfb, &layer_man->para.fb, sizeof(__disp_fb_t));
+			return DIS_SUCCESS;
+		}
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+/*
+ * if not scaler mode, ignore the src window width&height.
+ */
+__s32 BSP_disp_layer_set_src_window(__u32 sel, __u32 hid, __disp_rect_t *regn)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (regn == NULL)
+		return DIS_PARA_FAILED;
+
+	if (regn->width <= 0 || regn->height <= 0)
+		return DIS_PARA_FAILED;
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		BSP_disp_cfg_start(sel);
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			__s32 ret = 0;
+
+			ret = Scaler_Set_SclRegn(layer_man->scaler_index, regn);
+			BSP_disp_cfg_finish(sel);
+			return ret;
+		} else {
+			if (get_fb_type(layer_man->para.fb.format) ==
+			    DISP_FB_TYPE_YUV) {
+				Yuv_Channel_adjusting(sel,
+						      layer_man->para.fb.mode,
+						      layer_man->para.fb.format,
+						      &layer_man->para.src_win.
+						      x,
+						      &layer_man->para.scn_win.
+						      width);
+				Yuv_Channel_Set_framebuffer(sel,
+							    &(layer_man->para.
+							      fb), regn->x,
+							    regn->y);
+			} else {
+				layer_src_t layer_fb;
+
+				layer_fb.fb_addr = layer_man->para.fb.addr[0];
+				layer_fb.format = layer_man->para.fb.format;
+				layer_fb.pixseq =
+				    img_sw_para_to_reg(3, 0,
+						       layer_man->para.fb.seq);
+				layer_fb.br_swap = layer_man->para.fb.br_swap;
+				layer_fb.fb_width =
+				    layer_man->para.fb.size.width;
+				layer_fb.offset_x = regn->x;
+				layer_fb.offset_y = regn->y;
+				layer_fb.format = layer_man->para.fb.format;
+
+				DE_BE_Layer_Set_Framebuffer(sel, hid,
+							    &layer_fb);
+			}
+
+			layer_man->para.src_win.x = regn->x;
+			layer_man->para.src_win.y = regn->y;
+			layer_man->para.src_win.width = regn->width;
+			layer_man->para.src_win.height = regn->height;
+
+			BSP_disp_cfg_finish(sel);
+
+			return DIS_SUCCESS;
+		}
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_layer_get_src_window(__u32 sel, __u32 hid, __disp_rect_t *regn)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (regn == NULL) {
+		DE_WRN("input parameter can't be null!\n");
+		return DIS_PARA_FAILED;
+	}
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			return Scaler_Get_SclRegn(layer_man->scaler_index,
+						  regn);
+		} else {
+			regn->x = layer_man->para.src_win.x;
+			regn->y = layer_man->para.src_win.y;
+			regn->width = layer_man->para.scn_win.width;
+			regn->height = layer_man->para.scn_win.height;
+			return 0;
+		}
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_layer_set_screen_window(__u32 sel, __u32 hid,
+				       __disp_rect_t *regn)
+{
+	__disp_rectsz_t outsize;
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (regn == NULL) {
+		DE_WRN("para is null in BSP_disp_layer_set_screen_window\n");
+		return DIS_PARA_FAILED;
+	}
+	if (regn->width <= 0 || regn->height <= 0) {
+		DE_WRN
+		    ("width:%x,height:%x in BSP_disp_layer_set_screen_window\n",
+		     regn->width, regn->height);
+		return DIS_PARA_FAILED;
+	}
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+
+	if (layer_man->status & LAYER_USED) {
+		BSP_disp_cfg_start(sel);
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			__s32 ret;
+
+			/*
+			 * when scaler display on a interlace screen
+			 * (480i, ntsc etc), scaler window must be even
+			 * vertical offset
+			 */
+			regn->y &= ((gdisp.screen[sel].b_out_interlace == 1) ?
+				    0xfffffffe : 0xffffffff);
+
+			outsize.height = regn->height;
+			outsize.width = regn->width;
+
+			ret = Scaler_Set_Output_Size(layer_man->scaler_index,
+						     &outsize);
+			if (ret != DIS_SUCCESS) {
+				DE_WRN("Scaler_Set_Output_Size fail!\n");
+				BSP_disp_cfg_finish(sel);
+				return ret;
+			}
+		}
+		if (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV
+		    && layer_man->para.mode != DISP_LAYER_WORK_MODE_SCALER) {
+			Yuv_Channel_adjusting(sel, layer_man->para.fb.mode,
+					      layer_man->para.fb.format,
+					      &layer_man->para.src_win.x,
+					      &regn->width);
+		}
+		DE_BE_Layer_Set_Screen_Win(sel, hid, regn);
+		layer_man->para.scn_win.x = regn->x;
+		layer_man->para.scn_win.y = regn->y;
+		layer_man->para.scn_win.width = regn->width;
+		layer_man->para.scn_win.height = regn->height;
+		BSP_disp_cfg_finish(sel);
+
+		return DIS_SUCCESS;
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_layer_get_screen_window(__u32 sel, __u32 hid,
+				       __disp_rect_t *regn)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (regn == NULL)
+		return DIS_PARA_FAILED;
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		regn->x = layer_man->para.scn_win.x;
+		regn->y = layer_man->para.scn_win.y;
+		regn->width = layer_man->para.scn_win.width;
+		regn->height = layer_man->para.scn_win.height;
+
+		return DIS_SUCCESS;
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_layer_set_para(__u32 sel, __u32 hid,
+			      __disp_layer_info_t *player)
+{
+	__s32 ret;
+	__layer_man_t *layer_man;
+	__u32 prio_tmp = 0;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (player->b_from_screen)
+		player->mode = DISP_LAYER_WORK_MODE_SCALER;
+
+	if (layer_man->status & LAYER_USED) {
+		BSP_disp_cfg_start(sel);
+		if (player->mode != DISP_LAYER_WORK_MODE_NORMAL ||
+		    get_fb_type(player->fb.format) != DISP_FB_TYPE_YUV) {
+			if (layer_man->byuv_ch)
+				Yuv_Channel_Release(sel, hid);
+		}
+		if (player->mode != DISP_LAYER_WORK_MODE_SCALER) {
+			if (layer_man->para.mode ==
+			    DISP_LAYER_WORK_MODE_SCALER) {
+				Scaler_Release(layer_man->scaler_index, TRUE);
+				DE_BE_Layer_Video_Enable(sel, hid, FALSE);
+				DE_BE_Layer_Video_Ch_Sel(sel, hid, 0);
+				layer_man->para.mode =
+					DISP_LAYER_WORK_MODE_NORMAL;
+			}
+		}
+
+		if (player->mode == DISP_LAYER_WORK_MODE_SCALER) {
+			__disp_scaler_t *scaler;
+
+			if (layer_man->para.mode !=
+			    DISP_LAYER_WORK_MODE_SCALER) {
+				__u32 format = DISP_FORMAT_ARGB8888;
+
+				ret = Scaler_Request(0xff);
+				if (ret < 0) {
+					DE_WRN("request scaler layer fail!\n");
+					BSP_disp_cfg_finish(sel);
+					return DIS_NO_RES;
+				}
+				DE_SCAL_Start(ret);
+
+				format = DISP_FORMAT_ARGB8888;
+				DE_BE_Layer_Set_Format(sel, hid, format, FALSE,
+						       DISP_SEQ_ARGB);
+				DE_BE_Layer_Video_Enable(sel, hid, TRUE);
+				DE_BE_Layer_Video_Ch_Sel(sel, hid, ret);
+				layer_man->scaler_index = ret;
+				layer_man->para.mode =
+					DISP_LAYER_WORK_MODE_SCALER;
+				gdisp.scaler[ret].screen_index = sel;
+			}
+			scaler = &(gdisp.scaler[layer_man->scaler_index]);
+
+			player->scn_win.y &=
+				(gdisp.screen[sel].b_out_interlace == 1) ?
+				0xfffffffe : 0xffffffff;
+			scaler->out_fb.seq = DISP_SEQ_ARGB;
+			scaler->out_fb.format = DISP_FORMAT_RGB888;
+			scaler->out_size.height = player->scn_win.height;
+			scaler->out_size.width = player->scn_win.width;
+			if (player->b_from_screen) {
+				scaler->src_win.x = 0;
+				scaler->src_win.y = 0;
+				scaler->src_win.width =
+					BSP_disp_get_screen_width(1 - sel);
+				scaler->src_win.height =
+					BSP_disp_get_screen_height(1 - sel);
+				scaler->in_fb.addr[0] = 0;
+				scaler->in_fb.size.width =
+					BSP_disp_get_screen_width(1 - sel);
+				scaler->in_fb.size.height =
+					BSP_disp_get_screen_height(1 - sel);
+				scaler->in_fb.format = DISP_FORMAT_ARGB8888;
+				scaler->in_fb.seq = DISP_SEQ_ARGB;
+				scaler->in_fb.mode = DISP_MOD_INTERLEAVED;
+				scaler->in_fb.br_swap = FALSE;
+				scaler->in_fb.cs_mode = DISP_BT601;
+				image_clk_on(sel);
+				Image_open(1 - sel);
+				DE_BE_Output_Select(1 - sel, 6 +
+						    layer_man->scaler_index);
+				DE_SCAL_Input_Select(layer_man->scaler_index,
+						     6 + (1 - sel));
+				gdisp.screen[1 - sel].image_output_type =
+					IMAGE_OUTPUT_SCALER;
+			} else {
+				scaler->src_win.x = player->src_win.x;
+				scaler->src_win.y = player->src_win.y;
+				scaler->src_win.width = player->src_win.width;
+				scaler->src_win.height = player->src_win.height;
+				memcpy(&scaler->in_fb, &player->fb,
+				       sizeof(__disp_fb_t));
+				DE_SCAL_Input_Select(layer_man->scaler_index,
+						     0);
+			}
+			scaler->b_trd_out = player->b_trd_out;
+			scaler->out_trd_mode = player->out_trd_mode;
+			DE_SCAL_Output_Select(layer_man->scaler_index, sel);
+			Scaler_Set_Para(layer_man->scaler_index, scaler);
+		} else {
+			/* yuv channel */
+			if (get_fb_type(player->fb.format) ==
+			    DISP_FB_TYPE_YUV) {
+				if (layer_man->byuv_ch == FALSE) {
+					__s32 err = 0;
+
+					err = Yuv_Channel_Request(sel, hid);
+					if (err != DIS_SUCCESS) {
+						DE_WRN("request yuv channel "
+						       "fail\n");
+						BSP_disp_cfg_finish(sel);
+						return err;
+					}
+				}
+				Yuv_Channel_adjusting(sel, player->fb.mode,
+						      player->fb.format,
+						      &player->src_win.x,
+						      &player->scn_win.width);
+				Yuv_Channel_Set_framebuffer(sel, &(player->fb),
+							    player->src_win.x,
+							    player->src_win.y);
+			} else { /* normal rgb */
+				layer_src_t layer_fb;
+
+				layer_fb.fb_addr = player->fb.addr[0];
+				layer_fb.format = player->fb.format;
+				layer_fb.pixseq =
+				    img_sw_para_to_reg(3, 0, player->fb.seq);
+				layer_fb.br_swap = player->fb.br_swap;
+				layer_fb.fb_width = player->fb.size.width;
+				layer_fb.offset_x = player->src_win.x;
+				layer_fb.offset_y = player->src_win.y;
+
+				DE_BE_Layer_Set_Framebuffer(sel, hid,
+							    &layer_fb);
+			}
+		}
+
+		DE_BE_Layer_Set_Work_Mode(sel, hid, player->mode);
+		DE_BE_Layer_Set_Pipe(sel, hid, player->pipe);
+		DE_BE_Layer_Alpha_Enable(sel, hid, player->alpha_en);
+		DE_BE_Layer_Set_Alpha_Value(sel, hid, player->alpha_val);
+		DE_BE_Layer_ColorKey_Enable(sel, hid, player->ck_enable);
+		DE_BE_Layer_Set_Screen_Win(sel, hid, &player->scn_win);
+
+		prio_tmp = layer_man->para.prio;
+		memcpy(&(layer_man->para), player, sizeof(__disp_layer_info_t));
+		layer_man->para.prio = prio_tmp; /* ignore the prio setting */
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			layer_man->para.src_win.width = player->src_win.width;
+			layer_man->para.src_win.height = player->src_win.height;
+			layer_man->para.b_from_screen = player->b_from_screen;
+		}
+
+		BSP_disp_cfg_finish(sel);
+
+		return DIS_SUCCESS;
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+/*
+ * todo
+ */
+__s32
+BSP_disp_layer_get_para(__u32 sel, __u32 hid, __disp_layer_info_t *player)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		memcpy(player, &layer_man->para, sizeof(__disp_layer_info_t));
+
+		return DIS_SUCCESS;
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_layer_set_smooth(__u32 sel, __u32 hid,
+				__disp_video_smooth_t mode)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			BSP_disp_scaler_set_smooth(layer_man->scaler_index,
+						   mode);
+			return DIS_SUCCESS;
+		} else {
+			DE_WRN("layer not scaler mode!\n");
+			return DIS_NOT_SUPPORT;
+		}
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_layer_get_smooth(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if (layer_man->status & LAYER_USED) {
+		if (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+			__s32 mode;
+			mode = (__s32)
+				BSP_disp_scaler_get_smooth(layer_man->
+							   scaler_index);
+			return mode;
+		} else {
+			DE_WRN("layer not scaler mode!\n");
+			return DIS_NOT_SUPPORT;
+		}
+	} else {
+		DE_WRN("layer %d in screen %d not inited!\n", hid, sel);
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_layer_set_bright(__u32 sel, __u32 hid, __u32 bright)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		gdisp.scaler[layer_man->scaler_index].bright = bright;
+		if (gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE) {
+			Scaler_Set_Enhance(layer_man->scaler_index,
+					   gdisp.scaler[layer_man->
+							scaler_index].bright,
+					   gdisp.scaler[layer_man->
+							scaler_index].contrast,
+					   gdisp.scaler[layer_man->
+							scaler_index].
+					   saturation,
+					   gdisp.scaler[layer_man->
+							scaler_index].hue);
+		}
+
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_bright(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		return gdisp.scaler[layer_man->scaler_index].bright;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_contrast(__u32 sel, __u32 hid, __u32 contrast)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		gdisp.scaler[layer_man->scaler_index].contrast = contrast;
+		if (gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE) {
+			Scaler_Set_Enhance(layer_man->scaler_index,
+					   gdisp.scaler[layer_man->
+							scaler_index].bright,
+					   gdisp.scaler[layer_man->
+							scaler_index].contrast,
+					   gdisp.scaler[layer_man->
+							scaler_index].
+					   saturation,
+					   gdisp.scaler[layer_man->
+							scaler_index].hue);
+		}
+
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_contrast(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		return gdisp.scaler[layer_man->scaler_index].contrast;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_saturation(__u32 sel, __u32 hid, __u32 saturation)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		gdisp.scaler[layer_man->scaler_index].saturation = saturation;
+		if (gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE) {
+			Scaler_Set_Enhance(layer_man->scaler_index,
+					   gdisp.scaler[layer_man->
+							scaler_index].bright,
+					   gdisp.scaler[layer_man->
+							scaler_index].contrast,
+					   gdisp.scaler[layer_man->
+							scaler_index].
+					   saturation,
+					   gdisp.scaler[layer_man->
+							scaler_index].hue);
+		}
+
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_saturation(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		return gdisp.scaler[layer_man->scaler_index].saturation;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_hue(__u32 sel, __u32 hid, __u32 hue)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		gdisp.scaler[layer_man->scaler_index].hue = hue;
+		if (gdisp.scaler[layer_man->scaler_index].enhance_en == TRUE) {
+			Scaler_Set_Enhance(layer_man->scaler_index,
+					   gdisp.scaler[layer_man->
+							scaler_index].bright,
+					   gdisp.scaler[layer_man->
+							scaler_index].contrast,
+					   gdisp.scaler[layer_man->
+							scaler_index].
+					   saturation,
+					   gdisp.scaler[layer_man->
+							scaler_index].hue);
+		}
+
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_hue(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		return gdisp.scaler[layer_man->scaler_index].hue;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_enhance_enable(__u32 sel, __u32 hid, __bool enable)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		if (enable == FALSE) {
+			Scaler_Set_Enhance(layer_man->scaler_index, 32, 32, 32,
+					   32);
+		} else {
+			Scaler_Set_Enhance(layer_man->scaler_index,
+					   gdisp.scaler[layer_man->
+							scaler_index].bright,
+					   gdisp.scaler[layer_man->
+							scaler_index].contrast,
+					   gdisp.scaler[layer_man->
+							scaler_index].
+					   saturation,
+					   gdisp.scaler[layer_man->
+							scaler_index].hue);
+		}
+		gdisp.scaler[layer_man->scaler_index].enhance_en = enable;
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_enhance_enable(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) {
+		return gdisp.scaler[layer_man->scaler_index].enhance_en;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_vpp_enable(__u32 sel, __u32 hid, __bool enable)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		DE_SCAL_Vpp_Enable(layer_man->scaler_index, enable);
+		gdisp.scaler[layer_man->scaler_index].vpp_en = enable;
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_vpp_enable(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		return gdisp.scaler[layer_man->scaler_index].vpp_en;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_luma_sharp_level(__u32 sel, __u32 hid, __u32 level)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		DE_SCAL_Vpp_Set_Luma_Sharpness_Level(layer_man->scaler_index,
+						     level);
+		gdisp.scaler[layer_man->scaler_index].luma_sharpe_level = level;
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_luma_sharp_level(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		return gdisp.scaler[layer_man->scaler_index].luma_sharpe_level;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_chroma_sharp_level(__u32 sel, __u32 hid, __u32 level)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(layer_man->scaler_index,
+						       level);
+		gdisp.scaler[layer_man->scaler_index].chroma_sharpe_level =
+			level;
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_chroma_sharp_level(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		return gdisp.scaler[layer_man->scaler_index].
+			chroma_sharpe_level;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_white_exten_level(__u32 sel, __u32 hid, __u32 level)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		DE_SCAL_Vpp_Set_White_Level_Extension(layer_man->scaler_index,
+						      level);
+		gdisp.scaler[layer_man->scaler_index].while_exten_level = level;
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_white_exten_level(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		return gdisp.scaler[layer_man->scaler_index].while_exten_level;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_set_black_exten_level(__u32 sel, __u32 hid, __u32 level)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		DE_SCAL_Vpp_Set_Black_Level_Extension(layer_man->scaler_index,
+						      level);
+		gdisp.scaler[layer_man->scaler_index].black_exten_level = level;
+		return DIS_SUCCESS;
+	}
+	return DIS_NOT_SUPPORT;
+}
+
+__s32 BSP_disp_layer_get_black_exten_level(__u32 sel, __u32 hid)
+{
+	__layer_man_t *layer_man;
+
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	layer_man = &gdisp.screen[sel].layer_manage[hid];
+	if ((layer_man->status & LAYER_USED) &&
+	    (layer_man->para.mode == DISP_LAYER_WORK_MODE_SCALER) &&
+	    (get_fb_type(layer_man->para.fb.format) == DISP_FB_TYPE_YUV)) {
+		return gdisp.scaler[layer_man->scaler_index].black_exten_level;
+	}
+	return DIS_NOT_SUPPORT;
+}
diff --git a/drivers/video/sunxi/disp/disp_layer.h b/drivers/video/sunxi/disp/disp_layer.h
new file mode 100644
index 0000000..9a7f52c
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_layer.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _DISP_LAYER_H_
+#define _DISP_LAYER_H_
+
+#include "disp_display_i.h"
+
+#define HLID_ASSERT(no, max) \
+do { \
+	if ((__s32)(no) < DIS_SUCCESS || (no) >= (max))	\
+		return DIS_PARA_FAILED;			\
+} while (0);
+
+#define IDLE_HID    0xff
+#define IDLE_PRIO   0xff
+
+#define LAYER_OPENED        0x00000001
+#define LAYER_USED          0x00000002
+
+typedef struct layer_man_t {
+	__u32 status;
+	__bool byuv_ch;
+
+	/*
+	 * used if scaler mode: 0/1
+	 */
+	__u32 scaler_index;
+	__bool video_enhancement_en;
+	__disp_layer_info_t para;
+} __layer_man_t;
+
+typedef enum {
+	DISP_FB_TYPE_RGB = 0x0,
+	DISP_FB_TYPE_YUV = 0x1,
+} __disp_pixel_type_t;
+
+__u32 Layer_Get_Prio(__u32 sel, __u32 hid);
+__disp_pixel_type_t get_fb_type(__disp_pixel_fmt_t format);
+__s32 img_sw_para_to_reg(__u8 type, __u8 mode, __u8 value);
+__s32 Yuv_Channel_Set_framebuffer(__u32 sel, __disp_fb_t *pfb, __u32 xoffset,
+				  __u32 yoffset);
+__s32 Yuv_Channel_adjusting(__u32 sel, __u32 mode, __u32 format, __s32 *src_x,
+			    __u32 *scn_width);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_lcd.c b/drivers/video/sunxi/disp/disp_lcd.c
new file mode 100644
index 0000000..8040fb9
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_lcd.c
@@ -0,0 +1,1942 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include "disp_display_i.h"
+#include "disp_lcd.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_clk.h"
+#include "OSAL_Pin.h"
+
+static __lcd_flow_t open_flow[2];
+static __lcd_flow_t close_flow[2];
+__panel_para_t gpanel_info[2];
+static __lcd_panel_fun_t lcd_panel_fun[2];
+
+static void
+LCD_get_reg_bases(__reg_bases_t *para)
+{
+	para->base_lcdc0 = gdisp.init_para.base_lcdc0;
+	para->base_lcdc1 = gdisp.init_para.base_lcdc1;
+	para->base_pioc = gdisp.init_para.base_pioc;
+	para->base_ccmu = gdisp.init_para.base_ccmu;
+	para->base_pwm = gdisp.init_para.base_pwm;
+}
+EXPORT_SYMBOL(LCD_get_reg_bases);
+
+static void
+Lcd_Panel_Parameter_Check(__u32 sel)
+{
+	__panel_para_t *info;
+	__u32 cycle_num = 1;
+	__u32 Lcd_Panel_Err_Flag = 0;
+	__u32 Lcd_Panel_Wrn_Flag = 0;
+	__u32 Disp_Driver_Bug_Flag = 0;
+
+	__u32 lcd_fclk_frq;
+	__u32 lcd_clk_div;
+
+	info = &(gpanel_info[sel]);
+
+	if (info->lcd_if == 0 && info->lcd_hv_if == 1 &&
+	    info->lcd_hv_smode == 0)
+		cycle_num = 3;
+	else if (info->lcd_if == 0 && info->lcd_hv_if == 1 &&
+		 info->lcd_hv_smode == 1)
+		cycle_num = 2;
+	else if (info->lcd_if == 1 && info->lcd_cpu_if == 1)
+		cycle_num = 3;
+	else if (info->lcd_if == 1 && info->lcd_cpu_if == 2)
+		cycle_num = 2;
+	else if (info->lcd_if == 1 && info->lcd_cpu_if == 3)
+		cycle_num = 2;
+	else if (info->lcd_if == 1 && info->lcd_cpu_if == 5)
+		cycle_num = 2;
+	else if (info->lcd_if == 1 && info->lcd_cpu_if == 6)
+		cycle_num = 3;
+	else if (info->lcd_if == 1 && info->lcd_cpu_if == 7)
+		cycle_num = 2;
+	else
+		cycle_num = 1;
+
+	if (info->lcd_hbp > info->lcd_hv_hspw)
+		;
+	else
+		Lcd_Panel_Err_Flag |= BIT0;
+
+	if (info->lcd_vbp > info->lcd_hv_vspw)
+		;
+	else
+		Lcd_Panel_Err_Flag |= BIT1;
+
+	if (info->lcd_ht >= (info->lcd_hbp + info->lcd_x * cycle_num + 4))
+		;
+	else
+		Lcd_Panel_Err_Flag |= BIT2;
+
+	if ((info->lcd_vt / 2) >= (info->lcd_vbp + info->lcd_y + 2))
+		;
+	else
+		Lcd_Panel_Err_Flag |= BIT3;
+
+	lcd_clk_div = TCON0_get_dclk_div(sel);
+	if (lcd_clk_div >= 6) {
+		;
+	} else if ((lcd_clk_div == 5) || (lcd_clk_div == 4) ||
+		   (lcd_clk_div == 2)) {
+		if ((info->lcd_io_cfg0 != 0x00000000) &&
+		    (info->lcd_io_cfg0 != 0x04000000))
+			Lcd_Panel_Err_Flag |= BIT10;
+	} else
+		Disp_Driver_Bug_Flag |= 1;
+
+	if ((info->lcd_if == 1 && info->lcd_cpu_if == 0) ||
+	    (info->lcd_if == 3 && info->lcd_lvds_bitwidth == 1)) {
+		if (info->lcd_frm != 1)
+			Lcd_Panel_Wrn_Flag |= BIT0;
+	} else if (info->lcd_if == 1 && info->lcd_cpu_if == 4) {
+		if (info->lcd_frm != 2)
+			Lcd_Panel_Wrn_Flag |= BIT1;
+	}
+
+	lcd_fclk_frq = (info->lcd_dclk_freq * 1000 * 1000) /
+		((info->lcd_vt / 2) * info->lcd_ht);
+	if (lcd_fclk_frq < 50 || lcd_fclk_frq > 70)
+		Lcd_Panel_Wrn_Flag |= BIT2;
+
+	if (Lcd_Panel_Err_Flag != 0 || Lcd_Panel_Wrn_Flag != 0) {
+		if (Lcd_Panel_Err_Flag != 0) {
+			__u32 i;
+
+			for (i = 0; i < 200; i++)
+				DE_WRN("*** Lcd in danger...\n");
+		}
+
+		DE_WRN("*******************************************************"
+		       "**********\n");
+		DE_WRN("***\n");
+		DE_WRN("*** LCD Panel Parameter Check\n");
+		DE_WRN("***\n");
+		DE_WRN("***             by dulianping\n");
+		DE_WRN("***\n");
+		DE_WRN("*******************************************************"
+		       "**********\n");
+
+		DE_WRN("***\n");
+		DE_WRN("*** Interface:");
+		if (info->lcd_if == 0 && info->lcd_hv_if == 0) {
+			DE_WRN("*** Parallel HV Panel\n");
+		} else if (info->lcd_if == 0 && info->lcd_hv_if == 1) {
+			DE_WRN("*** Serial HV Panel\n");
+		} else if (info->lcd_if == 0 && info->lcd_hv_if == 2) {
+			DE_WRN("*** Serial YUV Panel\n");
+		} else if (info->lcd_if == 3 && info->lcd_lvds_bitwidth == 0) {
+			DE_WRN("*** 24Bit LVDS Panel\n");
+		} else if (info->lcd_if == 3 && info->lcd_lvds_bitwidth == 1) {
+			DE_WRN("*** 18Bit LVDS Panel\n");
+		} else if (info->lcd_if == 1 && info->lcd_cpu_if == 0) {
+			DE_WRN("*** 18Bit CPU Panel\n");
+		} else if (info->lcd_if == 1 && info->lcd_cpu_if == 4) {
+			DE_WRN("*** 16Bit CPU Panel\n");
+		} else {
+			DE_WRN("\n");
+			DE_WRN("*** lcd_if:     %d\n", info->lcd_if);
+			DE_WRN("*** lcd_hv_if:  %d\n", info->lcd_hv_if);
+			DE_WRN("*** lcd_cpu_if: %d\n", info->lcd_cpu_if);
+		}
+
+		if (info->lcd_frm == 0)
+			DE_WRN("*** Lcd Frm Disable\n");
+		else if (info->lcd_frm == 1)
+			DE_WRN("*** Lcd Frm to RGB666\n");
+		else if (info->lcd_frm == 2)
+			DE_WRN("*** Lcd Frm to RGB565\n");
+
+		DE_WRN("***\n");
+		DE_WRN("*** Timing:\n");
+		DE_WRN("*** lcd_x:      %d\n", info->lcd_x);
+		DE_WRN("*** lcd_y:      %d\n", info->lcd_y);
+		DE_WRN("*** lcd_ht:     %d\n", info->lcd_ht);
+		DE_WRN("*** lcd_hbp:    %d\n", info->lcd_hbp);
+		DE_WRN("*** lcd_vt:     %d\n", info->lcd_vt);
+		DE_WRN("*** lcd_vbp:    %d\n", info->lcd_vbp);
+		DE_WRN("*** lcd_hspw:   %d\n", info->lcd_hv_hspw);
+		DE_WRN("*** lcd_vspw:   %d\n", info->lcd_hv_vspw);
+		DE_WRN("*** lcd_frame_frq:  %dHz\n", lcd_fclk_frq);
+
+		/* Print Error */
+		DE_WRN("***\n");
+		if (Lcd_Panel_Err_Flag & BIT0)
+			DE_WRN("*** Err01: Violate \"lcd_hbp > lcd_hspw\"\n");
+
+		if (Lcd_Panel_Err_Flag & BIT1)
+			DE_WRN("*** Err02: Violate \"lcd_vbp > lcd_vspw\"\n");
+
+		if (Lcd_Panel_Err_Flag & BIT2)
+			DE_WRN("*** Err03: Violate \"lcd_ht >= "
+			       "(lcd_hbp+lcd_x*%d+4)\"\n", cycle_num);
+
+		if (Lcd_Panel_Err_Flag & BIT3)
+			DE_WRN("*** Err04: Violate \"(lcd_vt/2) >= "
+			       "(lcd_vbp+lcd_y+2)\"\n");
+
+		if (Lcd_Panel_Err_Flag & BIT10)
+			DE_WRN("*** Err10: Violate \"lcd_io_cfg0\", "
+			       "use \"0x00000000\" or \"0x04000000\"");
+
+		if (Lcd_Panel_Wrn_Flag & BIT0)
+			DE_WRN("*** WRN01: Recommend \"lcd_frm = 1\"\n");
+
+		if (Lcd_Panel_Wrn_Flag & BIT1)
+			DE_WRN("*** WRN02: Recommend \"lcd_frm = 2\"\n");
+
+		if (Lcd_Panel_Wrn_Flag & BIT2)
+			DE_WRN("*** WRN03: Recommend \"lcd_dclk_frq = %d\"\n",
+			       ((info->lcd_vt / 2) * info->lcd_ht) * 60 /
+			       (1000 * 1000));
+		DE_WRN("***\n");
+
+		if (Lcd_Panel_Err_Flag != 0) {
+			__u32 image_base_addr;
+			__u32 reg_value = 0;
+
+			image_base_addr = DE_Get_Reg_Base(sel);
+
+			/* set background color */
+			writel(0xffff00ff, image_base_addr + 0x804);
+
+			reg_value = readl(image_base_addr + 0x800);
+			/* close all layer */
+			writel(reg_value & 0xfffff0ff, image_base_addr + 0x800);
+
+			LCD_delay_ms(2000);
+			/* set background color */
+			writel(0x00000000, image_base_addr + 0x804);
+			/* open layer */
+			writel(reg_value, image_base_addr + 0x800);
+
+			DE_WRN("*** Try new parameters, you can make it "
+			       "pass!\n");
+		}
+		DE_WRN("*** LCD Panel Parameter Check End\n");
+		DE_WRN("*******************************************************"
+		       "**********\n");
+	}
+}
+
+static __s32
+LCD_get_panel_para(__u32 sel, __panel_para_t *info)
+{
+	__s32 ret = 0;
+	char primary_key[20];
+	__s32 value = 0;
+	__u32 i = 0;
+
+	sprintf(primary_key, "lcd%d_para", sel);
+
+	memset(info, 0, sizeof(__panel_para_t));
+
+	ret = script_parser_fetch(primary_key, "lcd_x", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_x fail\n", primary_key);
+	} else {
+		info->lcd_x = value;
+		DE_INF("lcd_x = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_y", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_y fail\n", primary_key);
+	} else {
+		info->lcd_y = value;
+		DE_INF("lcd_y = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_dclk_freq", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_dclk_freq fail\n",
+		       primary_key);
+	} else {
+		info->lcd_dclk_freq = value;
+		DE_INF("lcd_dclk_freq = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_pwm_not_used", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_pwm_not_used fail\n",
+		       primary_key);
+	} else {
+		info->lcd_pwm_not_used = value;
+		DE_INF("lcd_pwm_not_used = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_pwm_ch", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_pwm_ch fail\n", primary_key);
+	} else {
+		info->lcd_pwm_ch = value;
+		DE_INF("lcd_pwm_ch = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_pwm_freq", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_pwm_freq fail\n", primary_key);
+	} else {
+		info->lcd_pwm_freq = value;
+		DE_INF("lcd_pwm_freq = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_pwm_pol", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_pwm_pol fail\n", primary_key);
+	} else {
+		info->lcd_pwm_pol = value;
+		DE_INF("lcd_pwm_pol = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_if", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_if fail\n", primary_key);
+	} else {
+		info->lcd_if = value;
+		DE_INF("lcd_if = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_hbp", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_hbp fail\n", primary_key);
+	} else {
+		info->lcd_hbp = value;
+		DE_INF("lcd_hbp = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_ht", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_ht fail\n", primary_key);
+	} else {
+		info->lcd_ht = value;
+		DE_INF("lcd_ht = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_vbp", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_vbp fail\n", primary_key);
+	} else {
+		info->lcd_vbp = value;
+		DE_INF("lcd_vbp = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_vt", &value, 1);
+	if (ret < 0) {
+		DE_WRN("fetch script data %s.lcd_vt fail\n", primary_key);
+	} else {
+		info->lcd_vt = value;
+		DE_INF("lcd_vt = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_hv_if", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_hv_if fail\n", primary_key);
+	} else {
+		info->lcd_hv_if = value;
+		DE_INF("lcd_hv_if = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_hv_smode", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_hv_smode fail\n", primary_key);
+	} else {
+		info->lcd_hv_smode = value;
+		DE_INF("lcd_hv_smode = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_hv_s888_if", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_hv_s888_if fail\n",
+		       primary_key);
+	} else {
+		info->lcd_hv_s888_if = value;
+		DE_INF("lcd_hv_s888_if = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_hv_syuv_if", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_hv_syuv_if fail\n",
+		       primary_key);
+	} else {
+		info->lcd_hv_syuv_if = value;
+		DE_INF("lcd_hv_syuv_if = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_hv_vspw", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_hv_vspw fail\n", primary_key);
+	} else {
+		info->lcd_hv_vspw = value;
+		DE_INF("lcd_hv_vspw = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_hv_hspw", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_hv_hspw fail\n", primary_key);
+	} else {
+		info->lcd_hv_hspw = value;
+		DE_INF("lcd_hv_hspw = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_lvds_ch", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_lvds_ch fail\n", primary_key);
+	} else {
+		info->lcd_lvds_ch = value;
+		DE_INF("lcd_lvds_ch = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_lvds_mode", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_lvds_mode fail\n",
+		       primary_key);
+	} else {
+		info->lcd_lvds_mode = value;
+		DE_INF("lcd_lvds_mode = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_lvds_bitwidth", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_lvds_bitwidth fail\n",
+		       primary_key);
+	} else {
+		info->lcd_lvds_bitwidth = value;
+		DE_INF("lcd_lvds_bitwidth = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_lvds_io_cross", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_lvds_io_cross fail\n",
+		       primary_key);
+	} else {
+		info->lcd_lvds_io_cross = value;
+		DE_INF("lcd_lvds_io_cross = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_cpu_if", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_cpu_if fail\n", primary_key);
+	} else {
+		info->lcd_cpu_if = value;
+		DE_INF("lcd_cpu_if = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_frm", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_frm fail\n", primary_key);
+	} else {
+		info->lcd_frm = value;
+		DE_INF("lcd_frm = %d\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_io_cfg0", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_io_cfg0 fail\n", primary_key);
+	} else {
+		info->lcd_io_cfg0 = value;
+		DE_INF("lcd_io_cfg0 = 0x%08x\n", value);
+	}
+
+	ret = script_parser_fetch(primary_key, "lcd_gamma_correction_en",
+				  &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data %s.lcd_gamma_correction_en fail\n",
+		       primary_key);
+	} else {
+		info->lcd_gamma_correction_en = value;
+		DE_INF("lcd_gamma_correction_en = %d\n", value);
+	}
+
+	if (info->lcd_gamma_correction_en) {
+		for (i = 0; i < 256; i++) {
+			char name[20];
+
+			sprintf(name, "lcd_gamma_tbl_%d", i);
+
+			ret = script_parser_fetch(primary_key, name, &value, 1);
+			if (ret < 0) {
+				info->lcd_gamma_tbl[i] =
+				    (i << 16) | (i << 8) | i;
+				DE_INF("fetch script data %s.%s fail\n",
+				       primary_key, name);
+			} else {
+				info->lcd_gamma_tbl[i] = value;
+				DE_INF("%s = 0x%x\n", name, value);
+			}
+		}
+	}
+	return 0;
+}
+
+static void
+LCD_get_sys_config(__u32 sel, __disp_lcd_cfg_t *lcd_cfg)
+{
+	char io_name[28][20] = {
+		"lcdd0", "lcdd1", "lcdd2", "lcdd3", "lcdd4", "lcdd5",
+		"lcdd6", "lcdd7", "lcdd8", "lcdd9", "lcdd10", "lcdd11",
+		"lcdd12", "lcdd13", "lcdd14", "lcdd15", "lcdd16", "lcdd17",
+		"lcdd18", "lcdd19", "lcdd20", "lcdd21", "lcdd22", "lcdd23",
+		"lcdclk", "lcdde", "lcdhsync", "lcdvsync"};
+	user_gpio_set_t *gpio_info;
+	int value = 1;
+	char primary_key[20], sub_name[20];
+	int i = 0;
+	int ret;
+
+	sprintf(primary_key, "lcd%d_para", sel);
+
+	/* lcd_used */
+	ret = script_parser_fetch(primary_key, "lcd_used", &value, 1);
+	if (ret < 0) {
+		DE_WRN("%s.lcd_used not exit\n", primary_key);
+		lcd_cfg->lcd_used = 0;
+	} else {
+		DE_INF("%s.lcd_used = %d\n", primary_key, value);
+		lcd_cfg->lcd_used = value;
+	}
+
+	/* lcd_bl_en */
+	lcd_cfg->lcd_bl_en_used = 0;
+	value = 1;
+	ret = script_parser_fetch(primary_key, "lcd_bl_en_used", &value, 1);
+	if (value == 0) {
+		DE_INF("%s.lcd_bl_en is not used\n", primary_key);
+	} else {
+		gpio_info = &(lcd_cfg->lcd_bl_en);
+		ret = script_parser_fetch(primary_key, "lcd_bl_en",
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
+		if (ret < 0) {
+			DE_INF("%s.lcd_bl_en not exist\n", primary_key);
+		} else {
+			DE_INF("%s.lcd_bl_en gpio_port=%d,gpio_port_num:%d, "
+			       "data:%d\n", primary_key, gpio_info->port,
+			       gpio_info->port_num, gpio_info->data);
+			lcd_cfg->lcd_bl_en_used = 1;
+		}
+	}
+
+	/* lcd_power */
+	lcd_cfg->lcd_power_used = 0;
+	value = 1;
+	ret = script_parser_fetch(primary_key, "lcd_power_used", &value, 1);
+	if (value == 0) {
+		DE_INF("%s.lcd_power is not used\n", primary_key);
+	} else {
+		gpio_info = &(lcd_cfg->lcd_power);
+		ret = script_parser_fetch(primary_key, "lcd_power",
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
+		if (ret < 0) {
+			DE_INF("%s.lcd_power not exist\n", primary_key);
+		} else {
+			DE_INF("%s.lcd_power gpio_port=%d,gpio_port_num:%d, "
+			       "data:%d\n", primary_key, gpio_info->port,
+			       gpio_info->port_num, gpio_info->data);
+			lcd_cfg->lcd_power_used = 1;
+		}
+	}
+
+	/* lcd_pwm */
+	lcd_cfg->lcd_pwm_used = 0;
+	value = 1;
+	ret = script_parser_fetch(primary_key, "lcd_pwm_used", &value, 1);
+	if (value == 0) {
+		DE_INF("%s.lcd_pwm is not used\n", primary_key);
+	} else {
+		gpio_info = &(lcd_cfg->lcd_pwm);
+		ret = script_parser_fetch(primary_key, "lcd_pwm",
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
+		if (ret < 0) {
+			DE_INF("%s.lcd_pwm not exist\n", primary_key);
+		} else {
+			DE_INF("%s.lcd_pwm gpio_port=%d,gpio_port_num:%d, "
+			       "data:%d\n", primary_key, gpio_info->port,
+			       gpio_info->port_num, gpio_info->data);
+			lcd_cfg->lcd_pwm_used = 1;
+		}
+	}
+
+	/* lcd_gpio */
+	for (i = 0; i < 4; i++) {
+		sprintf(sub_name, "lcd_gpio_%d", i);
+
+		gpio_info = &(lcd_cfg->lcd_gpio[i]);
+		ret = script_parser_fetch(primary_key, sub_name,
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
+		if (ret < 0) {
+			DE_INF("%s.%s not exist\n", primary_key, sub_name);
+			lcd_cfg->lcd_gpio_used[i] = 0;
+		} else {
+			DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, "
+			       "mul_sel:%d\n", primary_key, sub_name,
+			       gpio_info->port, gpio_info->port_num,
+			       gpio_info->mul_sel);
+			lcd_cfg->lcd_gpio_used[i] = 1;
+		}
+	}
+
+	/* lcd io */
+	for (i = 0; i < 28; i++) {
+		gpio_info = &(lcd_cfg->lcd_io[i]);
+		ret = script_parser_fetch(primary_key, io_name[i],
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
+		if (ret < 0) {
+			DE_INF("%s.%s not exist\n", primary_key, io_name[i]);
+			lcd_cfg->lcd_io_used[i] = 0;
+		} else {
+			DE_INF("%s.%s gpio_port=%d,gpio_port_num:%d, "
+			       "mul_sel:%d\n", primary_key, io_name[i],
+			       gpio_info->port, gpio_info->port_num,
+			       gpio_info->mul_sel);
+			lcd_cfg->lcd_io_used[i] = 1;
+		}
+	}
+
+	/* init_brightness */
+	sprintf(primary_key, "disp_init");
+	sprintf(sub_name, "lcd%d_bright", sel);
+
+	ret = script_parser_fetch(primary_key, sub_name, &value, 1);
+	if (ret < 0) {
+		DE_INF("%s.%s not exit\n", primary_key, sub_name);
+		lcd_cfg->init_bright = 192;
+	} else {
+		DE_INF("%s.%s = %d\n", primary_key, sub_name, value);
+		if (value > 256)
+			value = 256;
+
+		lcd_cfg->init_bright = value;
+	}
+}
+
+void LCD_delay_ms(__u32 ms)
+{
+	__u32 timeout = ms * HZ / 1000;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(timeout);
+}
+EXPORT_SYMBOL(LCD_delay_ms);
+
+void LCD_delay_us(__u32 us)
+{
+	udelay(us);
+}
+EXPORT_SYMBOL(LCD_delay_us);
+
+void
+LCD_OPEN_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
+{
+	open_flow[sel].func[open_flow[sel].func_num].func = func;
+	open_flow[sel].func[open_flow[sel].func_num].delay = delay;
+	open_flow[sel].func_num++;
+}
+EXPORT_SYMBOL(LCD_OPEN_FUNC);
+
+void
+LCD_CLOSE_FUNC(__u32 sel, LCD_FUNC func, __u32 delay)
+{
+	close_flow[sel].func[close_flow[sel].func_num].func = func;
+	close_flow[sel].func[close_flow[sel].func_num].delay = delay;
+	close_flow[sel].func_num++;
+}
+EXPORT_SYMBOL(LCD_CLOSE_FUNC);
+
+void
+TCON_open(__u32 sel)
+{
+	if (gpanel_info[sel].tcon_index == 0) {
+		TCON0_open(sel);
+		gdisp.screen[sel].lcdc_status |= LCDC_TCON0_USED;
+	} else {
+		TCON1_open(sel);
+		gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+	}
+
+	if (gpanel_info[sel].lcd_if == 3)
+		LCD_LVDS_open(sel);
+}
+EXPORT_SYMBOL(TCON_open);
+
+void
+TCON_close(__u32 sel)
+{
+	if (gpanel_info[sel].lcd_if == 3)
+		LCD_LVDS_close(sel);
+
+	if (gpanel_info[sel].tcon_index == 0) {
+		TCON0_close(sel);
+		gdisp.screen[sel].lcdc_status &= ~LCDC_TCON0_USED;
+	} else {
+		TCON1_close(sel);
+		gdisp.screen[sel].lcdc_status &= ~LCDC_TCON1_USED;
+	}
+}
+EXPORT_SYMBOL(TCON_close);
+
+static __u32 pwm_read_reg(__u32 offset)
+{
+	__u32 value = 0;
+
+	value = readl(gdisp.init_para.base_pwm + offset);
+
+	return value;
+}
+
+static __s32 pwm_write_reg(__u32 offset, __u32 value)
+{
+	writel(value, gdisp.init_para.base_pwm + offset);
+
+	if (sunxi_is_sun4i())
+        	LCD_delay_ms(20);
+
+	return 0;
+}
+
+static __s32
+pwm_enable(__u32 channel, __bool b_en)
+{
+	__u32 tmp = 0;
+	__hdle hdl;
+
+	if (gdisp.screen[channel].lcd_cfg.lcd_pwm_used) {
+		user_gpio_set_t gpio_info[1];
+
+		memcpy(gpio_info, &(gdisp.screen[channel].lcd_cfg.lcd_pwm),
+		       sizeof(user_gpio_set_t));
+
+		if (b_en)
+			gpio_info->mul_sel = 2;
+		else
+			gpio_info->mul_sel = 0;
+
+		hdl = OSAL_GPIO_Request(gpio_info, 1);
+		OSAL_GPIO_Release(hdl, 2);
+	}
+
+	if (channel == 0) {
+		tmp = pwm_read_reg(0x200);
+		if (b_en)
+			tmp |= (1 << 4);
+		else
+			tmp &= (~(1 << 4));
+
+		pwm_write_reg(0x200, tmp);
+	} else {
+		tmp = pwm_read_reg(0x200);
+		if (b_en)
+			tmp |= (1 << 19);
+		else
+			tmp &= (~(1 << 19));
+
+		pwm_write_reg(0x200, tmp);
+	}
+
+	gdisp.pwm[channel].enable = b_en;
+
+	return 0;
+}
+
+#ifdef CONFIG_ARCH_SUN4I
+/*
+ * channel: pwm channel,0/1
+ * pwm_info->freq:  pwm freq, in hz
+ * pwm_info->active_state: 0:low level; 1:high level
+ */
+__s32 pwm_set_para(__u32 channel, __pwm_info_t *pwm_info)
+{
+	__u32 pre_scal[10] = { 120, 180, 240, 360, 480,
+			       12000, 24000, 36000, 48000, 72000 };
+	__u32 pre_scal_id = 0, entire_cycle = 256, active_cycle = 192;
+	__u32 i = 0, tmp = 0;
+	__u32 freq;
+
+	freq = 1000000 / pwm_info->period_ns;
+
+	if (freq > 200000) {
+		DE_WRN("pwm preq is large then 200khz, fix to 200khz\n");
+		freq = 200000;
+	}
+
+	if (freq > 781) {
+		pre_scal_id = 0;
+		entire_cycle =
+		    (24000000 / pre_scal[pre_scal_id] + (freq / 2)) / freq;
+		DE_INF("pre_scal:%d, entire_cycle:%d, pwm_freq:%d\n",
+		       pre_scal[i], entire_cycle,
+		       24000000 / pre_scal[pre_scal_id] / entire_cycle);
+	} else {
+		for (i = 0; i < 10; i++) {
+			__u32 pwm_freq = 0;
+
+			pwm_freq = 24000000 / (pre_scal[i] * 256);
+			if (abs(pwm_freq - freq) < abs(tmp - freq)) {
+				tmp = pwm_freq;
+				pre_scal_id = i;
+				entire_cycle = 256;
+				DE_INF("pre_scal:%d, entire_cycle:%d, "
+				       "pwm_freq:%d\n", pre_scal[i], 256,
+				       pwm_freq);
+				DE_INF("----%d\n", tmp);
+			}
+		}
+	}
+	active_cycle = (pwm_info->duty_ns * entire_cycle +
+			(pwm_info->period_ns / 2)) / pwm_info->period_ns;
+
+	gdisp.pwm[channel].enable = pwm_info->enable;
+	gdisp.pwm[channel].freq = freq;
+	gdisp.pwm[channel].pre_scal = pre_scal[pre_scal_id];
+	gdisp.pwm[channel].active_state = pwm_info->active_state;
+	gdisp.pwm[channel].duty_ns = pwm_info->duty_ns;
+	gdisp.pwm[channel].period_ns = pwm_info->period_ns;
+	gdisp.pwm[channel].entire_cycle = entire_cycle;
+	gdisp.pwm[channel].active_cycle = active_cycle;
+
+	if (pre_scal_id >= 5)
+		pre_scal_id += 3;
+
+	if (channel == 0) {
+		pwm_write_reg(0x204, ((entire_cycle - 1) << 16) | active_cycle);
+
+		tmp = pwm_read_reg(0x200) & 0xffffff00;
+		/*
+		 * bit6: gating the special clock for pwm0
+		 * bit5: pwm0: active state is high level
+		 */
+		tmp |= (1 << 6) | (pwm_info->active_state << 5) | pre_scal_id;
+		pwm_write_reg(0x200, tmp);
+	} else {
+		pwm_write_reg(0x208, ((entire_cycle - 1) << 16) | active_cycle);
+
+		tmp = pwm_read_reg(0x200) & 0xff807fff;
+		/*
+		 * bit21: gating the special clock for pwm1
+		 * bit20: pwm1:  active state is high level
+		 */
+		tmp |= (1 << 21) | (pwm_info->active_state << 20) |
+			(pre_scal_id << 15);
+		pwm_write_reg(0x200, tmp);
+	}
+
+	pwm_enable(channel, pwm_info->enable);
+
+	return 0;
+}
+#else /* SUN5I or SUN7I */
+/*
+ * channel: pwm channel,0/1
+ * pwm_info->freq:  pwm freq, in hz
+ * pwm_info->active_state: 0:low level; 1:high level
+ */
+__s32 pwm_set_para(__u32 channel, __pwm_info_t *pwm_info)
+{
+	__u32 pre_scal[11][2] = {
+		{1, 0xf},
+		{120, 0}, {180, 1}, {240, 2}, {360, 3}, {480, 4},
+		{12000, 8}, {24000, 9}, {36000, 0xa},
+		{48000, 0xb}, {72000, 0xc}
+	};
+	__u32 pre_scal_id = 0, entire_cycle = 16, active_cycle = 12;
+	__u32 i = 0, j = 0, tmp = 0;
+	__u32 freq;
+
+	freq = 1000000 / pwm_info->period_ns;
+
+	if (freq > 366) {
+		pre_scal_id = 0;
+		entire_cycle = 24000000 / freq;
+	} else {
+		for (i = 1; i < 11; i++) {
+			for (j = 16;; j += 16) {
+				__u32 pwm_freq = 0;
+
+				pwm_freq = 24000000 / (pre_scal[i][0] * j);
+				if (abs(pwm_freq - freq) < abs(tmp - freq)) {
+					tmp = pwm_freq;
+					pre_scal_id = i;
+					entire_cycle = j;
+					DE_INF("pre_scal:%d, entire_cycle:%d, "
+					       "pwm_freq:%d\n",
+					       pre_scal[i][0], j, pwm_freq);
+					DE_INF("----%d\n", tmp);
+				} else if ((tmp < freq) && (pwm_freq < tmp)) {
+					break;
+				}
+			}
+		}
+	}
+
+	active_cycle = (pwm_info->duty_ns * entire_cycle +
+			(pwm_info->period_ns / 2)) / pwm_info->period_ns;
+
+	gdisp.pwm[channel].enable = pwm_info->enable;
+	gdisp.pwm[channel].freq = freq;
+	gdisp.pwm[channel].pre_scal = pre_scal[pre_scal_id][0];
+	gdisp.pwm[channel].active_state = pwm_info->active_state;
+	gdisp.pwm[channel].duty_ns = pwm_info->duty_ns;
+	gdisp.pwm[channel].period_ns = pwm_info->period_ns;
+	gdisp.pwm[channel].entire_cycle = entire_cycle;
+	gdisp.pwm[channel].active_cycle = active_cycle;
+
+	if (channel == 0) {
+		pwm_write_reg(0x204, ((entire_cycle - 1) << 16) | active_cycle);
+
+		tmp = pwm_read_reg(0x200) & 0xffffff00;
+		/*
+		 * bit6: gating the special clock for pwm0
+		 * bit5: pwm0: active state is high level
+		 */
+		tmp |= ((1 << 6) | (pwm_info->active_state << 5) |
+			pre_scal[pre_scal_id][1]);
+		pwm_write_reg(0x200, tmp);
+	} else {
+		pwm_write_reg(0x208, ((entire_cycle - 1) << 16) | active_cycle);
+
+		tmp = pwm_read_reg(0x200) & 0xff807fff;
+		/*
+		 * bit21: gating the special clock for pwm1
+		 * bit20: pwm1: active state is high level
+		 */
+		tmp |= ((1 << 21) | (pwm_info->active_state << 20) |
+			(pre_scal[pre_scal_id][1] << 15));
+		pwm_write_reg(0x200, tmp);
+	}
+
+	pwm_enable(channel, pwm_info->enable);
+
+	return 0;
+}
+#endif /* CONFIG_ARCH_SUN4I */
+EXPORT_SYMBOL(pwm_set_para);
+
+__s32 pwm_get_para(__u32 channel, __pwm_info_t *pwm_info)
+{
+	pwm_info->enable = gdisp.pwm[channel].enable;
+	pwm_info->active_state = gdisp.pwm[channel].active_state;
+	pwm_info->duty_ns = gdisp.pwm[channel].duty_ns;
+	pwm_info->period_ns = gdisp.pwm[channel].period_ns;
+
+	return 0;
+}
+EXPORT_SYMBOL(pwm_get_para);
+
+static __s32
+pwm_set_duty_ns(__u32 channel, __u32 duty_ns)
+{
+	__u32 active_cycle = 0;
+	__u32 tmp;
+
+	active_cycle = (duty_ns * gdisp.pwm[channel].entire_cycle +
+			(gdisp.pwm[channel].period_ns / 2)) /
+		gdisp.pwm[channel].period_ns;
+
+	if (channel == 0) {
+		tmp = pwm_read_reg(0x204);
+		pwm_write_reg(0x204, (tmp & 0xffff0000) | active_cycle);
+	} else {
+		tmp = pwm_read_reg(0x208);
+		pwm_write_reg(0x208, (tmp & 0xffff0000) | active_cycle);
+	}
+
+	gdisp.pwm[channel].duty_ns = duty_ns;
+
+	/* DE_INF("%d,%d,%d,%d\n", duty_ns, gdisp.pwm[channel].period_ns, "
+	   "active_cycle, gdisp.pwm[channel].entire_cycle); */
+
+	return 0;
+}
+EXPORT_SYMBOL(pwm_set_duty_ns);
+
+__s32 LCD_PWM_EN(__u32 sel, __bool b_en)
+{
+	if (gdisp.screen[sel].lcd_cfg.lcd_pwm_used) {
+		user_gpio_set_t gpio_info[1];
+		__hdle hdl;
+
+		memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_pwm),
+		       sizeof(user_gpio_set_t));
+
+		if (sw_get_ic_ver() != SUNXI_VER_A10A &&
+		    (gpanel_info[sel].lcd_pwm_not_used == 0)) {
+			if (b_en)
+				pwm_enable(gpanel_info[sel].lcd_pwm_ch, b_en);
+			else {
+				gpio_info->mul_sel = 0;
+				hdl = OSAL_GPIO_Request(gpio_info, 1);
+				OSAL_GPIO_Release(hdl, 2);
+			}
+		} else {
+			if (b_en != gpanel_info[sel].lcd_pwm_pol) {
+				gpio_info->mul_sel = 1;
+				gpio_info->data = 1;
+				hdl = OSAL_GPIO_Request(gpio_info, 1);
+				OSAL_GPIO_Release(hdl, 2);
+			} else {
+				gpio_info->mul_sel = 1;
+				gpio_info->data = 0;
+				hdl = OSAL_GPIO_Request(gpio_info, 1);
+				OSAL_GPIO_Release(hdl, 2);
+			}
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(LCD_PWM_EN);
+
+__s32 LCD_BL_EN(__u32 sel, __bool b_en)
+{
+	user_gpio_set_t gpio_info[1];
+	__hdle hdl;
+
+	if (gdisp.screen[sel].lcd_cfg.lcd_bl_en_used) {
+		memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_bl_en),
+		       sizeof(user_gpio_set_t));
+
+		if (!b_en)
+			gpio_info->data = (gpio_info->data == 0) ? 1 : 0;
+
+		hdl = OSAL_GPIO_Request(gpio_info, 1);
+		OSAL_GPIO_Release(hdl, 2);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(LCD_BL_EN);
+
+__s32
+LCD_POWER_EN(__u32 sel, __bool b_en)
+{
+	user_gpio_set_t gpio_info[1];
+	__hdle hdl;
+
+	if (gdisp.screen[sel].lcd_cfg.lcd_power_used) {
+		memcpy(gpio_info, &(gdisp.screen[sel].lcd_cfg.lcd_power),
+		       sizeof(user_gpio_set_t));
+
+		if (!b_en)
+			gpio_info->data = (gpio_info->data == 0) ? 1 : 0;
+
+		hdl = OSAL_GPIO_Request(gpio_info, 1);
+		OSAL_GPIO_Release(hdl, 2);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(LCD_POWER_EN);
+
+__s32
+LCD_GPIO_request(__u32 sel, __u32 io_index)
+{
+	return 0;
+}
+EXPORT_SYMBOL(LCD_GPIO_request);
+
+__s32
+LCD_GPIO_release(__u32 sel, __u32 io_index)
+{
+	return 0;
+}
+EXPORT_SYMBOL(LCD_GPIO_release);
+
+__s32
+LCD_GPIO_set_attr(__u32 sel, __u32 io_index, __bool b_output)
+{
+	char gpio_name[20];
+
+	sprintf(gpio_name, "lcd_gpio_%d", io_index);
+	return OSAL_GPIO_DevSetONEPIN_IO_STATUS(gdisp.screen[sel].
+						gpio_hdl[io_index], b_output,
+						gpio_name);
+}
+EXPORT_SYMBOL(LCD_GPIO_set_attr);
+
+__s32
+LCD_GPIO_read(__u32 sel, __u32 io_index)
+{
+	char gpio_name[20];
+
+	sprintf(gpio_name, "lcd_gpio_%d", io_index);
+	return OSAL_GPIO_DevREAD_ONEPIN_DATA(gdisp.screen[sel].
+					     gpio_hdl[io_index], gpio_name);
+}
+EXPORT_SYMBOL(LCD_GPIO_read);
+
+__s32
+LCD_GPIO_write(__u32 sel, __u32 io_index, __u32 data)
+{
+	char gpio_name[20];
+
+	sprintf(gpio_name, "lcd_gpio_%d", io_index);
+	return OSAL_GPIO_DevWRITE_ONEPIN_DATA(gdisp.screen[sel].
+					      gpio_hdl[io_index], data,
+					      gpio_name);
+}
+EXPORT_SYMBOL(LCD_GPIO_write);
+
+static __s32
+LCD_GPIO_init(__u32 sel)
+{
+	__u32 i = 0;
+
+	for (i = 0; i < 4; i++) {
+		gdisp.screen[sel].gpio_hdl[i] = 0;
+
+		if (gdisp.screen[sel].lcd_cfg.lcd_gpio_used[i]) {
+			user_gpio_set_t gpio_info[1];
+
+			memcpy(gpio_info,
+			       &(gdisp.screen[sel].lcd_cfg.lcd_gpio[i]),
+			       sizeof(user_gpio_set_t));
+			gdisp.screen[sel].gpio_hdl[i] =
+				OSAL_GPIO_Request(gpio_info, 1);
+		}
+	}
+
+	return 0;
+}
+
+static __s32
+LCD_GPIO_exit(__u32 sel)
+{
+	__u32 i = 0;
+
+	for (i = 0; i < 4; i++)
+		if (gdisp.screen[sel].gpio_hdl[i])
+			OSAL_GPIO_Release(gdisp.screen[sel].gpio_hdl[i], 2);
+
+	return 0;
+}
+
+static void
+LCD_CPU_register_irq(__u32 sel, void (*Lcd_cpuisr_proc) (void))
+{
+	gdisp.screen[sel].LCD_CPUIF_ISR = Lcd_cpuisr_proc;
+}
+EXPORT_SYMBOL(LCD_CPU_register_irq);
+
+__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon)
+{
+	if (out_type == DISP_OUTPUT_TYPE_LCD) {
+		__hdle lcd_pin_hdl;
+		int i;
+
+		for (i = 0; i < 28; i++) {
+			if (gdisp.screen[sel].lcd_cfg.lcd_io_used[i]) {
+				user_gpio_set_t gpio_info[1];
+
+				memcpy(gpio_info,
+				       &(gdisp.screen[sel].lcd_cfg.lcd_io[i]),
+				       sizeof(user_gpio_set_t));
+				if (!bon)
+					gpio_info->mul_sel = 0;
+				else {
+					if ((gpanel_info[sel].lcd_if == 3) &&
+					    (gpio_info->mul_sel == 2))
+						gpio_info->mul_sel = 3;
+				}
+				lcd_pin_hdl = OSAL_GPIO_Request(gpio_info, 1);
+				OSAL_GPIO_Release(lcd_pin_hdl, 2);
+			}
+		}
+	} else if (out_type == DISP_OUTPUT_TYPE_VGA) {
+		__u32 reg_start = 0;
+		__u32 tmp = 0;
+
+		if (sel == 0)
+			reg_start = gdisp.init_para.base_pioc + 0x6c;
+		else
+			reg_start = gdisp.init_para.base_pioc + 0xfc;
+
+		if (bon) {
+			tmp = readl(reg_start + 0x0c) & 0xffff00ff;
+			writel(tmp | 0x00002200, reg_start + 0x0c);
+		} else {
+			tmp = readl(reg_start + 0x0c) & 0xffff00ff;
+			writel(tmp, reg_start + 0x0c);
+		}
+	}
+
+	return DIS_SUCCESS;
+}
+
+static irqreturn_t Disp_lcdc_event_proc(int irq, void *parg)
+{
+	__u32 lcdc_flags;
+	__u32 sel = (__u32) parg;
+
+	lcdc_flags = LCDC_query_int(sel);
+	LCDC_clear_int(sel, lcdc_flags);
+
+	if (lcdc_flags & LCDC_VBI_LCD)
+		LCD_vbi_event_proc(sel, 0);
+
+	if (lcdc_flags & LCDC_VBI_HD)
+		LCD_vbi_event_proc(sel, 1);
+
+	return OSAL_IRQ_RETURN;
+}
+
+__s32 Disp_lcdc_init(__u32 sel)
+{
+	irqreturn_t ret;
+
+	LCD_get_sys_config(sel, &(gdisp.screen[sel].lcd_cfg));
+
+	lcdc_clk_init(sel);
+	lvds_clk_init();
+	lcdc_clk_on(sel); /* ??need to be open */
+	LCDC_init(sel);
+	lcdc_clk_off(sel);
+
+	if (sel == 0)
+		ret = request_irq(INTC_IRQNO_LCDC0, Disp_lcdc_event_proc,
+				  IRQF_DISABLED, "sunxi lcd0", (void *)sel);
+	else
+		ret = request_irq(INTC_IRQNO_LCDC1, Disp_lcdc_event_proc,
+				  IRQF_DISABLED, "sunxi lcd1", (void *)sel);
+
+	if (gdisp.screen[sel].lcd_cfg.lcd_used) {
+		if (lcd_panel_fun[sel].cfg_panel_info)
+			lcd_panel_fun[sel].cfg_panel_info(&gpanel_info[sel]);
+		else
+			LCD_get_panel_para(sel, &gpanel_info[sel]);
+
+		gpanel_info[sel].tcon_index = 0;
+
+		if (sw_get_ic_ver() != SUNXI_VER_A10A &&
+		    (gpanel_info[sel].lcd_pwm_not_used == 0)) {
+			__pwm_info_t pwm_info;
+
+			pwm_info.enable = 0;
+			pwm_info.active_state = 1;
+			pwm_info.period_ns =
+			    1000000 / gpanel_info[sel].lcd_pwm_freq;
+			if (gpanel_info[sel].lcd_pwm_pol == 0)
+				pwm_info.duty_ns =
+				    (gdisp.screen[sel].lcd_cfg.init_bright *
+				     pwm_info.period_ns) / 256;
+			else
+				pwm_info.duty_ns =
+				    ((256 -
+				      gdisp.screen[sel].lcd_cfg.init_bright) *
+				     pwm_info.period_ns) / 256;
+
+			pwm_set_para(gpanel_info[sel].lcd_pwm_ch, &pwm_info);
+		}
+		LCD_GPIO_init(sel);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_lcdc_exit(__u32 sel)
+{
+	if (sel == 0) {
+		disable_irq(INTC_IRQNO_LCDC0);
+		free_irq(INTC_IRQNO_LCDC0, (void *)sel);
+	} else if (sel == 1) {
+		disable_irq(INTC_IRQNO_LCDC1);
+		free_irq(INTC_IRQNO_LCDC1, (void *)sel);
+	}
+
+	LCDC_exit(sel);
+
+	lcdc_clk_exit(sel);
+
+	LCD_GPIO_exit(sel);
+
+	return DIS_SUCCESS;
+}
+
+__u32 tv_mode_to_width(__disp_tv_mode_t mode)
+{
+	struct __disp_video_timing video_timing;
+	__u32 width = 0;
+
+	switch (mode) {
+	case DISP_TV_MOD_480I:
+	case DISP_TV_MOD_576I:
+	case DISP_TV_MOD_480P:
+	case DISP_TV_MOD_576P:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_NTSC_SVIDEO:
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+	case DISP_TV_MOD_PAL_NC:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+		width = 720;
+		break;
+	case DISP_TV_MOD_720P_50HZ:
+	case DISP_TV_MOD_720P_60HZ:
+	case DISP_TV_MOD_720P_50HZ_3D_FP:
+	case DISP_TV_MOD_720P_60HZ_3D_FP:
+	case DISP_TV_MOD_H1280_V1024_60HZ:
+		width = 1280;
+		break;
+	case DISP_TV_MOD_H1360_V768_60HZ:
+		width = 1360;
+		break;
+	case DISP_TV_MOD_1080I_50HZ:
+	case DISP_TV_MOD_1080I_60HZ:
+	case DISP_TV_MOD_1080P_24HZ:
+	case DISP_TV_MOD_1080P_50HZ:
+	case DISP_TV_MOD_1080P_60HZ:
+	case DISP_TV_MOD_1080P_24HZ_3D_FP:
+		width = 1920;
+		break;
+	case DISP_TV_MODE_EDID:
+		if (gdisp.init_para.hdmi_get_video_timing(mode,
+							  &video_timing) == 0)
+			width = video_timing.INPUTX;
+		break;
+	default:
+		width = 0;
+		break;
+	}
+
+	return width;
+}
+
+__u32 tv_mode_to_height(__disp_tv_mode_t mode)
+{
+	struct __disp_video_timing video_timing;
+	__u32 height = 0;
+
+	switch (mode) {
+	case DISP_TV_MOD_480I:
+	case DISP_TV_MOD_480P:
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_NTSC_SVIDEO:
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+		height = 480;
+		break;
+	case DISP_TV_MOD_576I:
+	case DISP_TV_MOD_576P:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL_NC:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+		height = 576;
+		break;
+	case DISP_TV_MOD_720P_50HZ:
+	case DISP_TV_MOD_720P_60HZ:
+		height = 720;
+		break;
+	case DISP_TV_MOD_H1360_V768_60HZ:
+		height = 768;
+		break;
+	case DISP_TV_MOD_H1280_V1024_60HZ:
+		height = 1024;
+		break;
+	case DISP_TV_MOD_1080I_50HZ:
+	case DISP_TV_MOD_1080I_60HZ:
+	case DISP_TV_MOD_1080P_24HZ:
+	case DISP_TV_MOD_1080P_50HZ:
+	case DISP_TV_MOD_1080P_60HZ:
+		height = 1080;
+		break;
+	case DISP_TV_MOD_1080P_24HZ_3D_FP:
+		height = 1080 * 2;
+		break;
+	case DISP_TV_MOD_720P_50HZ_3D_FP:
+	case DISP_TV_MOD_720P_60HZ_3D_FP:
+		height = 720 * 2;
+		break;
+	case DISP_TV_MODE_EDID:
+		if (gdisp.init_para.hdmi_get_video_timing(mode,
+							  &video_timing) == 0)
+			height = video_timing.INPUTY;
+		break;
+	default:
+		height = 0;
+		break;
+	}
+
+	return height;
+}
+
+__u32 vga_mode_to_width(__disp_vga_mode_t mode)
+{
+	__u32 width = 0;
+
+	switch (mode) {
+	case DISP_VGA_H1680_V1050:
+		width = 1680;
+		break;
+	case DISP_VGA_H1440_V900:
+		width = 1440;
+		break;
+	case DISP_VGA_H1360_V768:
+		width = 1360;
+		break;
+	case DISP_VGA_H1280_V1024:
+		width = 1280;
+		break;
+	case DISP_VGA_H1024_V768:
+		width = 1024;
+		break;
+	case DISP_VGA_H800_V600:
+		width = 800;
+		break;
+	case DISP_VGA_H640_V480:
+		width = 640;
+		break;
+	case DISP_VGA_H1440_V900_RB:
+		width = 1440;
+		break;
+	case DISP_VGA_H1680_V1050_RB:
+		width = 1680;
+		break;
+	case DISP_VGA_H1920_V1080_RB:
+	case DISP_VGA_H1920_V1080:
+		width = 1920;
+		break;
+	case DISP_VGA_H1280_V720:
+		width = 1280;
+		break;
+	default:
+		width = 0;
+		break;
+	}
+
+	return width;
+}
+
+__u32 vga_mode_to_height(__disp_vga_mode_t mode)
+{
+	__u32 height = 0;
+
+	switch (mode) {
+	case DISP_VGA_H1680_V1050:
+		height = 1050;
+		break;
+	case DISP_VGA_H1440_V900:
+		height = 900;
+		break;
+	case DISP_VGA_H1360_V768:
+		height = 768;
+		break;
+	case DISP_VGA_H1280_V1024:
+		height = 1024;
+		break;
+	case DISP_VGA_H1024_V768:
+		height = 768;
+		break;
+	case DISP_VGA_H800_V600:
+		height = 600;
+		break;
+	case DISP_VGA_H640_V480:
+		height = 480;
+		break;
+	case DISP_VGA_H1440_V900_RB:
+		height = 1440;
+		break;
+	case DISP_VGA_H1680_V1050_RB:
+		height = 1050;
+		break;
+	case DISP_VGA_H1920_V1080_RB:
+	case DISP_VGA_H1920_V1080:
+		height = 1080;
+		break;
+	case DISP_VGA_H1280_V720:
+		height = 720;
+		break;
+	default:
+		height = 0;
+		break;
+	}
+
+	return height;
+}
+
+/*
+ * return 0: progressive scan mode; return 1: interlace scan mode
+ */
+__u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode)
+{
+	struct __disp_video_timing video_timing;
+	__u32 ret = 0;
+
+	switch (tv_mode) {
+	case DISP_TV_MOD_480I:
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_NTSC_SVIDEO:
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+	case DISP_TV_MOD_576I:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL_NC:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+	case DISP_TV_MOD_1080I_50HZ:
+	case DISP_TV_MOD_1080I_60HZ:
+		ret = 1;
+		break;
+	case DISP_TV_MODE_EDID:
+		if (gdisp.init_para.hdmi_get_video_timing(tv_mode,
+							  &video_timing) == 0)
+			ret = video_timing.I;
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+__s32 BSP_disp_get_screen_width(__u32 sel)
+{
+	__u32 width = 0;
+
+	if ((gdisp.screen[sel].status & LCD_ON) ||
+	    (gdisp.screen[sel].status & TV_ON) ||
+	    (gdisp.screen[sel].status & HDMI_ON) ||
+	    (gdisp.screen[sel].status & VGA_ON)) {
+		width = DE_BE_get_display_width(sel);
+	} else {
+		width = gpanel_info[sel].lcd_x;
+	}
+
+	return width;
+}
+
+__s32 BSP_disp_get_screen_height(__u32 sel)
+{
+	__u32 height = 0;
+
+	if ((gdisp.screen[sel].status & LCD_ON) ||
+	    (gdisp.screen[sel].status & TV_ON) ||
+	    (gdisp.screen[sel].status & HDMI_ON) ||
+	    (gdisp.screen[sel].status & VGA_ON)) {
+		height = DE_BE_get_display_height(sel);
+	} else {
+		height = gpanel_info[sel].lcd_y;
+	}
+
+	return height;
+}
+
+__s32 BSP_disp_get_output_type(__u32 sel)
+{
+	if (gdisp.screen[sel].status & TV_ON)
+		return (__s32) DISP_OUTPUT_TYPE_TV;
+
+	if (gdisp.screen[sel].status & LCD_ON)
+		return (__s32) DISP_OUTPUT_TYPE_LCD;
+
+	if (gdisp.screen[sel].status & HDMI_ON)
+		return (__s32) DISP_OUTPUT_TYPE_HDMI;
+
+	if (gdisp.screen[sel].status & VGA_ON)
+		return (__s32) DISP_OUTPUT_TYPE_VGA;
+
+	return (__s32) DISP_OUTPUT_TYPE_NONE;
+}
+
+__s32 BSP_disp_lcd_open_before(__u32 sel)
+{
+	disp_clk_cfg(sel, DISP_OUTPUT_TYPE_LCD, DIS_NULL);
+	lcdc_clk_on(sel);
+	image_clk_on(sel);
+
+	/*
+	 * set image normal channel start bit, because every de_clk_off( )
+	 * will reset this bit
+	 */
+	Image_open(sel);
+	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 1);
+
+	if (gpanel_info[sel].tcon_index == 0)
+		TCON0_cfg(sel, (__panel_para_t *) &gpanel_info[sel]);
+	else
+		TCON1_cfg_ex(sel, (__panel_para_t *) &gpanel_info[sel]);
+
+	BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_LCD,
+				gdisp.screen[sel].iep_status & DRC_USED);
+	DE_BE_set_display_size(sel, gpanel_info[sel].lcd_x,
+			       gpanel_info[sel].lcd_y);
+	DE_BE_Output_Select(sel, sel);
+
+	open_flow[sel].func_num = 0;
+	lcd_panel_fun[sel].cfg_open_flow(sel);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_open_after(__u32 sel)
+{
+	//esMEM_SwitchDramWorkMode(DRAM_WORK_MODE_LCD);
+	gdisp.screen[sel].b_out_interlace = 0;
+	gdisp.screen[sel].status |= LCD_ON;
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_LCD;
+	Lcd_Panel_Parameter_Check(sel);
+	Disp_drc_enable(sel, TRUE);
+
+	Display_set_fb_timing(sel);
+
+	return DIS_SUCCESS;
+}
+
+__lcd_flow_t *BSP_disp_lcd_get_open_flow(__u32 sel)
+{
+	return &open_flow[sel];
+}
+
+__s32 BSP_disp_lcd_close_befor(__u32 sel)
+{
+	close_flow[sel].func_num = 0;
+	lcd_panel_fun[sel].cfg_close_flow(sel);
+	/* must close immediately, cause vbi may not come */
+	Disp_drc_enable(sel, 2);
+
+	gdisp.screen[sel].status &= ~LCD_ON;
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_close_after(__u32 sel)
+{
+	Image_close(sel);
+
+	Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_LCD, 0);
+	image_clk_off(sel);
+	lcdc_clk_off(sel);
+
+	gdisp.screen[sel].pll_use_status &=
+		(gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED) ?
+		~VIDEO_PLL0_USED : ~VIDEO_PLL1_USED;
+
+	return DIS_SUCCESS;
+}
+
+__lcd_flow_t *BSP_disp_lcd_get_close_flow(__u32 sel)
+{
+	return &close_flow[sel];
+}
+
+__s32 BSP_disp_lcd_xy_switch(__u32 sel, __s32 mode)
+{
+	if (gdisp.screen[sel].LCD_CPUIF_XY_Swap != NULL) {
+		LCD_CPU_AUTO_FLUSH(sel, 0);
+		LCD_XY_SWAP(sel);
+		(*gdisp.screen[sel].LCD_CPUIF_XY_Swap)(mode);
+		LCD_CPU_AUTO_FLUSH(sel, 1);
+	}
+
+	return DIS_SUCCESS;
+}
+
+/*
+ * sun4i: 0-16
+ * sun5i: 0-256
+ */
+__s32 BSP_disp_lcd_set_bright(__u32 sel, __u32 bright, __u32 from_iep)
+{
+	__u32 duty_ns;
+
+	if (!sunxi_is_sun5i() && sw_get_ic_ver() != SUNXI_VER_A10A &&
+	    gpanel_info[sel].lcd_pwm_not_used == 0) {
+		if (bright != 0)
+			bright += 1;
+
+		if (gpanel_info[sel].lcd_pwm_pol == 0)
+			duty_ns =
+			    (bright *
+			     gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns +
+			     128) / 256;
+		else
+			duty_ns =
+			    ((256 -
+			      bright) *
+			     gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns +
+			     128) / 256;
+
+		pwm_set_duty_ns(gpanel_info[sel].lcd_pwm_ch, duty_ns);
+	}
+	if (sunxi_is_sun5i()) {
+		if (gpanel_info[sel].lcd_pwm_pol == 0)
+			duty_ns =
+			    (bright * gdisp.screen[sel].lcd_bright_dimming *
+			     gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns /
+			     256 + 128) / 256;
+		else
+			duty_ns =
+			    ((256 -
+			      bright * gdisp.screen[sel].lcd_bright_dimming /
+			      256) *
+			     gdisp.pwm[gpanel_info[sel].lcd_pwm_ch].period_ns +
+			     128) / 256;
+
+		pwm_set_duty_ns(gpanel_info[sel].lcd_pwm_ch, duty_ns);
+	}
+	if (!sunxi_is_sun5i() || !from_iep)
+		gdisp.screen[sel].lcd_bright = bright;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_get_bright(__u32 sel)
+{
+	return gdisp.screen[sel].lcd_bright;
+}
+
+__s32 BSP_disp_set_gamma_table(__u32 sel, __u32 *gamtbl_addr,
+			       __u32 gamtbl_size)
+{
+	if ((gamtbl_addr == NULL) || (gamtbl_size > 1024)) {
+		DE_WRN("para invalid in BSP_disp_set_gamma_table\n");
+		return DIS_FAIL;
+	}
+
+	TCON1_set_gamma_table(sel, (__u32) (gamtbl_addr), gamtbl_size);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_gamma_correction_enable(__u32 sel)
+{
+	TCON1_set_gamma_Enable(sel, TRUE);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_gamma_correction_disable(__u32 sel)
+{
+	TCON1_set_gamma_Enable(sel, FALSE);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+	switch (src) {
+	case DISP_LCDC_SRC_DE_CH1:
+		TCON0_select_src(sel, LCDC_SRC_DE1);
+		break;
+
+	case DISP_LCDC_SRC_DE_CH2:
+		TCON0_select_src(sel, LCDC_SRC_DE2);
+		break;
+
+	case DISP_LCDC_SRC_DMA:
+		TCON0_select_src(sel, LCDC_SRC_DMA);
+		break;
+
+	case DISP_LCDC_SRC_WHITE:
+		TCON0_select_src(sel, LCDC_SRC_WHITE);
+		break;
+
+	case DISP_LCDC_SRC_BLACK:
+		TCON0_select_src(sel, LCDC_SRC_BLACK);
+		break;
+
+	default:
+		DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n",
+		       src);
+		return DIS_NOT_SUPPORT;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_lcd_user_defined_func(__u32 sel, __u32 para1, __u32 para2,
+				     __u32 para3)
+{
+	return lcd_panel_fun[sel].lcd_user_defined_func(sel, para1, para2,
+							para3);
+}
+
+void LCD_set_panel_funs(__lcd_panel_fun_t *lcd0_cfg,
+			__lcd_panel_fun_t *lcd1_cfg)
+{
+	memset(&lcd_panel_fun[0], 0, sizeof(__lcd_panel_fun_t));
+	memset(&lcd_panel_fun[1], 0, sizeof(__lcd_panel_fun_t));
+
+	lcd_panel_fun[0].cfg_panel_info = lcd0_cfg->cfg_panel_info;
+	lcd_panel_fun[0].cfg_open_flow = lcd0_cfg->cfg_open_flow;
+	lcd_panel_fun[0].cfg_close_flow = lcd0_cfg->cfg_close_flow;
+	lcd_panel_fun[0].lcd_user_defined_func =
+		lcd0_cfg->lcd_user_defined_func;
+	lcd_panel_fun[1].cfg_panel_info = lcd1_cfg->cfg_panel_info;
+	lcd_panel_fun[1].cfg_open_flow = lcd1_cfg->cfg_open_flow;
+	lcd_panel_fun[1].cfg_close_flow = lcd1_cfg->cfg_close_flow;
+	lcd_panel_fun[1].lcd_user_defined_func =
+		lcd1_cfg->lcd_user_defined_func;
+}
+EXPORT_SYMBOL(LCD_set_panel_funs);
+
+__s32 BSP_disp_get_videomode(__u32 sel, struct fb_videomode *videomode)
+{
+	bool interlaced = false, hsync = false, vsync = false;
+	u32 pixclock, hfreq, htotal, vtotal;
+	memset(videomode, 0, sizeof(struct fb_videomode));
+
+	if (gdisp.screen[sel].status & LCD_ON) {
+		LCDC_get_timing(sel, 0, videomode);
+		videomode->pixclock = KHZ2PICOS(
+			gpanel_info[sel].lcd_dclk_freq * 1000);
+		interlaced = false;
+	} else if ((gdisp.screen[sel].status & TV_ON)) {
+		__disp_tv_mode_t tv_mode = gdisp.screen[sel].tv_mode;
+		LCDC_get_timing(sel, 1, videomode);
+		videomode->pixclock = HZ2PICOS(
+			clk_tab.tv_clk_tab[tv_mode].tve_clk /
+			clk_tab.tv_clk_tab[tv_mode].pre_scale);
+
+		interlaced = Disp_get_screen_scan_mode(tv_mode);
+	} else if (gdisp.screen[sel].status & HDMI_ON) {
+		struct __disp_video_timing video_timing;
+		__disp_tv_mode_t hdmi_mode = gdisp.screen[sel].hdmi_mode;
+		if (gdisp.init_para.hdmi_get_video_timing(
+				hdmi_mode, &video_timing) != 0)
+			return DIS_FAIL;
+
+		LCDC_get_timing(sel, 1, videomode);
+		videomode->pixclock = HZ2PICOS(video_timing.PCLK);
+		interlaced = video_timing.I;
+		hsync = video_timing.HSYNC;
+		vsync = video_timing.VSYNC;
+	} else if (gdisp.screen[sel].status & VGA_ON) {
+		__disp_vga_mode_t vga_mode = gdisp.screen[sel].vga_mode;
+
+		LCDC_get_timing(sel, 1, videomode);
+
+		videomode->pixclock = HZ2PICOS(
+			clk_tab.vga_clk_tab[vga_mode].tve_clk /
+			clk_tab.vga_clk_tab[vga_mode].pre_scale);
+	} else {
+		DE_INF("get videomode fail because device is not output !\n");
+		return DIS_FAIL;
+	}
+
+	videomode->xres = BSP_disp_get_screen_width(sel);
+	videomode->yres = BSP_disp_get_screen_height(sel);
+
+	if (interlaced)
+		videomode->vmode = FB_VMODE_INTERLACED;
+
+	if (vsync)
+		videomode->sync = FB_SYNC_VERT_HIGH_ACT;
+
+	if (hsync)
+		videomode->sync |= FB_SYNC_HOR_HIGH_ACT;
+
+	if (!videomode->pixclock)
+		return DIS_SUCCESS;
+
+	pixclock = PICOS2HZ(videomode->pixclock);
+
+	htotal = videomode->xres + videomode->right_margin +
+			videomode->hsync_len + videomode->left_margin;
+	vtotal = videomode->yres + videomode->lower_margin +
+			videomode->vsync_len + videomode->upper_margin;
+
+	if (videomode->vmode & FB_VMODE_INTERLACED)
+		vtotal /= 2;
+	if (videomode->vmode & FB_VMODE_DOUBLE)
+		vtotal *= 2;
+
+	hfreq = pixclock/htotal;
+	videomode->refresh = hfreq/vtotal;
+	return DIS_SUCCESS;
+}
+
+__u32 BSP_disp_get_cur_line(__u32 sel)
+{
+	__u32 line = 0;
+
+	if (gdisp.screen[sel].status & LCD_ON) {
+		line = LCDC_get_cur_line(sel, 0);
+	} else if ((gdisp.screen[sel].status & TV_ON) ||
+		   (gdisp.screen[sel].status & HDMI_ON) ||
+		   (gdisp.screen[sel].status & VGA_ON)) {
+		line = LCDC_get_cur_line(sel, 1);
+	}
+
+	return line;
+}
+
+__s32 BSP_disp_close_lcd_backlight(__u32 sel)
+{
+	user_gpio_set_t gpio_info[1];
+	__hdle hdl;
+	int value, ret;
+	char primary_key[20];
+
+	if (!sunxi_is_sun5i())
+	        return 0;
+
+	sprintf(primary_key, "lcd%d_para", sel);
+	value = 1;
+	ret = script_parser_fetch(primary_key, "lcd_bl_en_used", &value, 1);
+	if (value == 0) {
+		DE_INF("%s.lcd_bl_en is not used\n", primary_key);
+	} else {
+		ret =
+		    script_parser_fetch(primary_key, "lcd_bl_en",
+					(int *)gpio_info,
+					sizeof(user_gpio_set_t) / sizeof(int));
+		if (ret < 0) {
+			DE_INF("%s.lcd_bl_en not exist\n", primary_key);
+		} else {
+			gpio_info->data = (gpio_info->data == 0) ? 1 : 0;
+			hdl = OSAL_GPIO_Request(gpio_info, 1);
+			OSAL_GPIO_Release(hdl, 2);
+		}
+	}
+	value = 1;
+	ret = script_parser_fetch(primary_key, "lcd_pwm_used", &value, 1);
+	if (value == 0) {
+		DE_INF("%s.lcd_pwm is not used\n", primary_key);
+	} else {
+		ret = script_parser_fetch(primary_key, "lcd_pwm",
+					  (int *)gpio_info,
+					  sizeof(user_gpio_set_t) /
+					  sizeof(int));
+		if (ret < 0) {
+			DE_INF("%s.lcd_pwm not exist\n", primary_key);
+		} else {
+			gpio_info->mul_sel = 0;
+			hdl = OSAL_GPIO_Request(gpio_info, 1);
+			OSAL_GPIO_Release(hdl, 2);
+		}
+	}
+	return 0;
+}
diff --git a/drivers/video/sunxi/disp/disp_lcd.h b/drivers/video/sunxi/disp/disp_lcd.h
new file mode 100644
index 0000000..b7084bf
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_lcd.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_LCD_H__
+#define __DISP_LCD_H__
+
+extern __panel_para_t gpanel_info[2];
+
+__s32 Disp_lcdc_init(__u32 sel);
+__s32 Disp_lcdc_exit(__u32 sel);
+
+__s32 Disp_lcdc_pin_cfg(__u32 sel, __disp_output_type_t out_type, __u32 bon);
+__u32 Disp_get_screen_scan_mode(__disp_tv_mode_t tv_mode);
+
+__u32 tv_mode_to_width(__disp_tv_mode_t mode);
+__u32 tv_mode_to_height(__disp_tv_mode_t mode);
+__u32 vga_mode_to_width(__disp_vga_mode_t mode);
+__u32 vga_mode_to_height(__disp_vga_mode_t mode);
+
+void LCD_delay_ms(__u32 ms);
+void LCD_delay_us(__u32 ns);
+
+void TCON_open(__u32 sel);
+void TCON_close(__u32 sel);
+__s32 LCD_PWM_EN(__u32 sel, __bool b_en);
+__s32 LCD_BL_EN(__u32 sel, __bool b_en);
+__s32 LCD_POWER_EN(__u32 sel, __bool b_en);
+
+__s32 LCD_GPIO_request(__u32 sel, __u32 io_index);
+__s32 LCD_GPIO_release(__u32 sel, __u32 io_index);
+__s32 LCD_GPIO_set_attr(__u32 sel, __u32 io_index, __bool b_output);
+__s32 LCD_GPIO_read(__u32 sel, __u32 io_index);
+__s32 LCD_GPIO_write(__u32 sel, __u32 io_index, __u32 data);
+
+__s32 pwm_set_para(__u32 channel, __pwm_info_t *pwm_info);
+__s32 pwm_get_para(__u32 channel, __pwm_info_t *pwm_info);
+
+void LCD_set_panel_funs(__lcd_panel_fun_t *lcd0_cfg,
+			__lcd_panel_fun_t *lcd1_cfg);
+
+void LCD_OPEN_FUNC(__u32 sel, LCD_FUNC func, __u32 delay);
+void LCD_CLOSE_FUNC(__u32 sel, LCD_FUNC func, __u32 delay);
+__s32 LCD_POWER_EN(__u32 sel, __bool b_en);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_scaler.c b/drivers/video/sunxi/disp/disp_scaler.c
new file mode 100644
index 0000000..322a3cf
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_scaler.c
@@ -0,0 +1,1254 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_scaler.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_layer.h"
+#include "disp_clk.h"
+#include "disp_lcd.h"
+#include "disp_de.h"
+
+/* scaler input pixel format */
+__scal_infmt_t Scaler_sw_para_to_reg1(__disp_pixel_fmt_t value)
+{
+	if (value == DISP_FORMAT_YUV444)
+		return DE_SCAL_INYUV444;
+	else if (value == DISP_FORMAT_YUV420)
+		return DE_SCAL_INYUV420;
+	else if (value == DISP_FORMAT_YUV422)
+		return DE_SCAL_INYUV422;
+	else if (value == DISP_FORMAT_YUV411)
+		return DE_SCAL_INYUV411;
+	else if (value == DISP_FORMAT_CSIRGB)
+		return DE_SCAL_INCSIRGB;
+	else if (value == DISP_FORMAT_ARGB8888)
+		return DE_SCAL_INRGB888;
+	else if (value == DISP_FORMAT_RGB888)
+		return DE_SCAL_INRGB888;
+	else
+		DE_WRN("not supported scaler input pixel format:%d in "
+		       "Scaler_sw_para_to_reg1\n", value);
+
+	return DE_SCAL_INRGB888;
+}
+
+/* scaler input pixel sequence */
+__scal_ps_t Scaler_sw_para_to_reg3(__disp_pixel_seq_t value)
+{
+	if (value == DISP_SEQ_UYVY)
+		return DE_SCAL_UYVY;
+	else if (value == DISP_SEQ_YUYV)
+		return DE_SCAL_YUYV;
+	else if (value == DISP_SEQ_VYUY)
+		return DE_SCAL_VYUY;
+	else if (value == DISP_SEQ_YVYU)
+		return DE_SCAL_YVYU;
+	else if (value == DISP_SEQ_AYUV)
+		return DE_SCAL_AYUV;
+	else if (value == DISP_SEQ_UVUV)
+		return DE_SCAL_UVUV;
+	else if (value == DISP_SEQ_VUVU)
+		return DE_SCAL_VUVU;
+	else if (value == DISP_SEQ_ARGB)
+		return DE_SCAL_ARGB;
+	else if (value == DISP_SEQ_BGRA)
+		return DE_SCAL_BGRA;
+	else if (value == DISP_SEQ_P3210)
+		return 0;
+	else
+		DE_WRN("not supported scaler input pixel sequence:%d "
+		       "in Scaler_sw_para_to_reg3\n", value);
+	return 0;
+}
+
+/* scaler output format */
+__scal_outfmt_t Scaler_sw_para_to_reg4(__disp_pixel_fmt_t value)
+{
+	if (value == DISP_FORMAT_YUV444)
+		return DE_SCAL_OUTPYUV444;
+	else if (value == DISP_FORMAT_YUV422)
+		return DE_SCAL_OUTPYUV422;
+	else if (value == DISP_FORMAT_YUV420)
+		return DE_SCAL_OUTPYUV420;
+	else if (value == DISP_FORMAT_YUV411)
+		return DE_SCAL_OUTPYUV411;
+	else if (value == DISP_FORMAT_ARGB8888)
+		return DE_SCAL_OUTI0RGB888;
+	else if (value == DISP_FORMAT_RGB888)
+		return DE_SCAL_OUTPRGB888;
+	else
+		DE_WRN("not supported scaler output value:%d in "
+		       "Scaler_sw_para_to_reg4\n", value);
+
+	return DE_SCAL_OUTI0RGB888;
+}
+
+/*
+ * 0: 3d in mode
+ * 1: 3d out mode
+ */
+__s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace)
+{
+	if (type == 0) {
+		switch (mode) {
+		case DISP_3D_SRC_MODE_TB:
+			return DE_SCAL_3DIN_TB;
+
+		case DISP_3D_SRC_MODE_FP:
+			return DE_SCAL_3DIN_FP;
+
+		case DISP_3D_SRC_MODE_SSF:
+			return DE_SCAL_3DIN_SSF;
+
+		case DISP_3D_SRC_MODE_SSH:
+			return DE_SCAL_3DIN_SSH;
+
+		case DISP_3D_SRC_MODE_LI:
+			return DE_SCAL_3DIN_LI;
+
+		default:
+			DE_WRN("not supported 3d in mode:%d in "
+			       "Scaler_3d_sw_para_to_reg\n", mode);
+			return DIS_FAIL;
+		}
+	} else if (type == 1) {
+		switch (mode) {
+		case DISP_3D_OUT_MODE_CI_1:
+			return DE_SCAL_3DOUT_CI_1;
+
+		case DISP_3D_OUT_MODE_CI_2:
+			return DE_SCAL_3DOUT_CI_2;
+
+		case DISP_3D_OUT_MODE_CI_3:
+			return DE_SCAL_3DOUT_CI_3;
+
+		case DISP_3D_OUT_MODE_CI_4:
+			return DE_SCAL_3DOUT_CI_4;
+
+		case DISP_3D_OUT_MODE_LIRGB:
+			return DE_SCAL_3DOUT_LIRGB;
+
+		case DISP_3D_OUT_MODE_TB:
+			return DE_SCAL_3DOUT_HDMI_TB;
+
+		case DISP_3D_OUT_MODE_FP:
+			if (b_out_interlace == TRUE)
+				return DE_SCAL_3DOUT_HDMI_FPI;
+			else
+				return DE_SCAL_3DOUT_HDMI_FPP;
+
+		case DISP_3D_OUT_MODE_SSF:
+			return DE_SCAL_3DOUT_HDMI_SSF;
+
+		case DISP_3D_OUT_MODE_SSH:
+			return DE_SCAL_3DOUT_HDMI_SSH;
+
+		case DISP_3D_OUT_MODE_LI:
+			return DE_SCAL_3DOUT_HDMI_LI;
+
+		case DISP_3D_OUT_MODE_FA:
+			return DE_SCAL_3DOUT_HDMI_FA;
+
+		default:
+			DE_WRN("not supported 3d output mode:%d in "
+			       "Scaler_3d_sw_para_to_reg\n", mode);
+			return DIS_FAIL;
+		}
+	}
+
+	return DIS_FAIL;
+}
+
+static irqreturn_t Scaler_event_proc(int irq, void *parg)
+{
+	__u8 fe_intflags, be_intflags;
+	__u32 sel = (__u32) parg;
+
+	fe_intflags = DE_SCAL_QueryINT(sel);
+	be_intflags = DE_BE_QueryINT(sel);
+	DE_SCAL_ClearINT(sel, fe_intflags);
+	DE_BE_ClearINT(sel, be_intflags);
+
+	DE_INF("scaler %d interrupt, scal_int_status:0x%x!\n", sel,
+	       fe_intflags);
+
+	if (be_intflags & DE_IMG_REG_LOAD_FINISH)
+		LCD_line_event_proc(sel);
+
+	if (fe_intflags & DE_WB_END_IE) {
+		DE_SCAL_DisableINT(sel, DE_FE_INTEN_ALL);
+
+		if (gdisp.scaler[sel].b_scaler_finished == 1 &&
+		    (&gdisp.scaler[sel].scaler_queue != NULL)) {
+			gdisp.scaler[sel].b_scaler_finished = 2;
+			wake_up_interruptible(&gdisp.scaler[sel].scaler_queue);
+		} else
+			__wrn("not scaler %d begin in DRV_scaler_finish\n",
+			      sel);
+	}
+
+	return OSAL_IRQ_RETURN;
+}
+
+__s32 Scaler_Init(__u32 sel)
+{
+	irqreturn_t ret;
+
+	scaler_clk_init(sel);
+	DE_SCAL_EnableINT(sel, DE_WB_END_IE);
+
+	if (sel == 0)
+		ret = request_irq(INTC_IRQNO_SCALER0, Scaler_event_proc,
+				  IRQF_DISABLED, "sunxi scaler0", (void *)sel);
+	else if (sel == 1)
+		ret = request_irq(INTC_IRQNO_SCALER1, Scaler_event_proc,
+				  IRQF_DISABLED, "sunxi scaler1", (void *)sel);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Exit(__u32 sel)
+{
+	if (sel == 0) {
+		disable_irq(INTC_IRQNO_SCALER0);
+		free_irq(INTC_IRQNO_SCALER0, (void *)sel);
+	} else if (sel == 1) {
+		disable_irq(INTC_IRQNO_SCALER1);
+		free_irq(INTC_IRQNO_SCALER1, (void *)sel);
+	}
+
+	DE_SCAL_DisableINT(sel, DE_WB_END_IE);
+	DE_SCAL_Reset(sel);
+	DE_SCAL_Disable(sel);
+	scaler_clk_off(sel);
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_open(__u32 sel)
+{
+	DE_INF("scaler %d open\n", sel);
+
+	scaler_clk_on(sel);
+	DE_SCAL_Reset(sel);
+	DE_SCAL_Enable(sel);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_close(__u32 sel)
+{
+	DE_INF("scaler %d close\n", sel);
+
+	DE_SCAL_Reset(sel);
+	DE_SCAL_Disable(sel);
+	scaler_clk_off(sel);
+
+	memset(&gdisp.scaler[sel], 0, sizeof(__disp_scaler_t));
+	gdisp.scaler[sel].bright = 32;
+	gdisp.scaler[sel].contrast = 32;
+	gdisp.scaler[sel].saturation = 32;
+	gdisp.scaler[sel].hue = 32;
+	gdisp.scaler[sel].status &= ~SCALER_USED;
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Request(__u32 sel)
+{
+	__s32 ret = DIS_NO_RES;
+
+	DE_INF("Scaler_Request,%d\n", sel);
+
+	if (sunxi_is_sun5i())
+		sel = 0; /* only one scaler */
+
+	if (sel == 0) { /* request scaler0 */
+		if (!(gdisp.scaler[0].status & SCALER_USED))
+			ret = 0;
+	} else if (sel == 1) { /* request scaler1 */
+		if (!(gdisp.scaler[1].status & SCALER_USED))
+			ret = 1;
+	} else { /* request any scaler */
+		if (!(gdisp.scaler[0].status & SCALER_USED))
+			ret = 0;
+		else if (!(gdisp.scaler[1].status & SCALER_USED))
+			ret = 1;
+	}
+
+	if (ret == 0 || ret == 1) {
+		Scaler_open(ret);
+		gdisp.scaler[ret].b_close = FALSE;
+		gdisp.scaler[ret].status |= SCALER_USED;
+	} else
+		DE_WRN("request scaler fail\n");
+
+	return ret;
+}
+
+__s32 Scaler_Release(__u32 sel, __bool b_display)
+{
+	DE_INF("Scaler_Release:%d\n", sel);
+
+	DE_SCAL_Set_Di_Ctrl(sel, 0, 0, 0, 0);
+	if (b_display == FALSE ||
+	    BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE) {
+		Scaler_close(sel);
+	} else {
+		gdisp.scaler[sel].b_close = TRUE;
+	}
+
+	return DIS_SUCCESS;
+}
+
+/*
+ *  keep the source window
+ */
+__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *pfb)
+{
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__disp_scaler_t *scaler;
+	__u32 screen_index, status;
+
+	scaler = &(gdisp.scaler[sel]);
+	screen_index = gdisp.scaler[sel].screen_index;
+
+	memcpy(&scaler->in_fb, pfb, sizeof(__disp_fb_t));
+
+	in_type.fmt = Scaler_sw_para_to_reg1(scaler->in_fb.format);
+	in_type.mod = scaler->in_fb.mode;
+	in_type.ps = Scaler_sw_para_to_reg3(scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	scal_addr.ch0_addr = scaler->in_fb.addr[0];
+	scal_addr.ch1_addr = scaler->in_fb.addr[1];
+	scal_addr.ch2_addr = scaler->in_fb.addr[2];
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_width = scaler->src_win.width;
+	in_size.scal_height = scaler->src_win.height;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = Scaler_sw_para_to_reg4(scaler->out_fb.format);
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	if (sunxi_is_sun5i())
+		status = gdisp.screen[screen_index].iep_status;
+	else
+		status = gdisp.screen[screen_index].de_flicker_status;
+
+	out_scan.field = (status & DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
+
+	if (scaler->in_fb.cs_mode > DISP_VXYCC)
+		scaler->in_fb.cs_mode = DISP_BT601;
+
+	if (scaler->in_fb.b_trd_src) {
+		__scal_3d_inmode_t inmode;
+		__scal_3d_outmode_t outmode = 0;
+		__scal_buf_addr_t scal_addr_right;
+
+		inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
+		outmode =
+		    Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode,
+					     gdisp.screen[screen_index].
+					     b_out_interlace);
+
+		DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+		if (scaler->b_trd_out) {
+			DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size,
+						       &out_size);
+		}
+
+		scal_addr_right.ch0_addr = scaler->in_fb.trd_right_addr[0];
+		scal_addr_right.ch1_addr = scaler->in_fb.trd_right_addr[1];
+		scal_addr_right.ch2_addr = scaler->in_fb.trd_right_addr[2];
+
+		DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
+		DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type,
+				      inmode, &scal_addr_right);
+	} else
+		DE_SCAL_Config_Src(sel, &scal_addr, &in_size, &in_type, FALSE,
+				   FALSE);
+
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan,
+				   &out_size, &out_type);
+	if (scaler->enhance_en == TRUE)
+		Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast,
+				   scaler->saturation, scaler->hue);
+	else
+		DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601,
+				     get_fb_type(scaler->in_fb.format),
+				     DISP_FB_TYPE_RGB, scaler->in_fb.br_swap,
+				     0);
+
+	if (sunxi_is_sun5i())
+		gdisp.scaler[sel].coef_change = 1;
+	else
+		DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type,
+			&out_scan, &out_size, &out_type, scaler->smooth_mode);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *pfb)
+{
+	__disp_scaler_t *scaler;
+
+	if (pfb == NULL)
+		return DIS_PARA_FAILED;
+
+	scaler = &(gdisp.scaler[sel]);
+	if (scaler->status & SCALER_USED)
+		memcpy(pfb, &scaler->in_fb, sizeof(__disp_fb_t));
+	else
+		return DIS_PARA_FAILED;
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *size)
+{
+	__disp_scaler_t *scaler;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 screen_index, status;
+
+	scaler = &(gdisp.scaler[sel]);
+	screen_index = gdisp.scaler[sel].screen_index;
+
+	scaler->out_size.height = size->height;
+	scaler->out_size.width = size->width;
+
+	in_type.fmt = Scaler_sw_para_to_reg1(scaler->in_fb.format);
+	in_type.mod = scaler->in_fb.mode;
+	in_type.ps = Scaler_sw_para_to_reg3(scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	in_size.src_width = scaler->src_win.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height = scaler->src_win.height;
+	in_size.scal_width = scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = Scaler_sw_para_to_reg4(scaler->out_fb.format);
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	if (sunxi_is_sun5i())
+		status = gdisp.screen[screen_index].iep_status;
+	else
+		status = gdisp.screen[screen_index].de_flicker_status;
+
+	out_scan.field = (status & DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
+
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan,
+				   &out_size, &out_type);
+	if (scaler->enhance_en == TRUE)
+		Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast,
+				   scaler->saturation, scaler->hue);
+	else
+		DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601,
+				     get_fb_type(scaler->in_fb.format),
+				     DISP_FB_TYPE_RGB, scaler->in_fb.br_swap,
+				     0);
+
+	if (sunxi_is_sun5i())
+		gdisp.scaler[sel].coef_change = 1;
+	else
+		DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type,
+			&out_scan, &out_size, &out_type, scaler->smooth_mode);
+
+	DE_SCAL_Set_Out_Size(sel, &out_scan, &out_type, &out_size);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
+{
+	__disp_scaler_t *scaler;
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 screen_index, status;
+
+	scaler = &(gdisp.scaler[sel]);
+	screen_index = gdisp.scaler[sel].screen_index;
+
+	scaler->src_win.x = scl_rect->x;
+	scaler->src_win.y = scl_rect->y;
+	scaler->src_win.height = scl_rect->height;
+	scaler->src_win.width = scl_rect->width;
+
+	in_type.fmt = Scaler_sw_para_to_reg1(scaler->in_fb.format);
+	in_type.mod = scaler->in_fb.mode;
+	in_type.ps = Scaler_sw_para_to_reg3(scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	scal_addr.ch0_addr = scaler->in_fb.addr[0];
+	scal_addr.ch1_addr = scaler->in_fb.addr[1];
+	scal_addr.ch2_addr = scaler->in_fb.addr[2];
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_width = scaler->src_win.width;
+	in_size.scal_height = scaler->src_win.height;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = Scaler_sw_para_to_reg4(scaler->out_fb.format);
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	if (sunxi_is_sun5i())
+		status = gdisp.screen[screen_index].iep_status;
+	else
+		status = gdisp.screen[screen_index].de_flicker_status;
+
+	out_scan.field = (status & DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
+
+	if (scaler->in_fb.cs_mode > DISP_VXYCC)
+		scaler->in_fb.cs_mode = DISP_BT601;
+
+	if (scaler->in_fb.b_trd_src) {
+		__scal_3d_inmode_t inmode;
+		__scal_3d_outmode_t outmode = 0;
+		__scal_buf_addr_t scal_addr_right;
+
+		inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
+		outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode,
+						   gdisp.screen[screen_index].
+						   b_out_interlace);
+
+		DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+		if (scaler->b_trd_out) {
+			DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size,
+						       &out_size);
+		}
+
+		scal_addr_right.ch0_addr = scaler->in_fb.trd_right_addr[0];
+		scal_addr_right.ch1_addr = scaler->in_fb.trd_right_addr[1];
+		scal_addr_right.ch2_addr = scaler->in_fb.trd_right_addr[2];
+
+		DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
+		DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type,
+				      inmode, &scal_addr_right);
+	} else {
+		DE_SCAL_Config_Src(sel, &scal_addr, &in_size, &in_type, FALSE,
+				   FALSE);
+	}
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan,
+				   &out_size, &out_type);
+
+	if (sunxi_is_sun5i())
+		gdisp.scaler[sel].coef_change = 1;
+	else
+		DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type,
+			&out_scan, &out_size, &out_type, scaler->smooth_mode);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect)
+{
+	__disp_scaler_t *scaler;
+
+	if (scl_rect == NULL)
+		return DIS_PARA_FAILED;
+
+	scaler = &(gdisp.scaler[sel]);
+	if (scaler->status & SCALER_USED) {
+		scl_rect->x = scaler->src_win.x;
+		scl_rect->y = scaler->src_win.y;
+		scl_rect->width = scaler->src_win.width;
+		scl_rect->height = scaler->src_win.height;
+	} else
+		return DIS_PARA_FAILED;
+
+	return DIS_SUCCESS;
+}
+
+__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl)
+{
+	__disp_scaler_t *scaler;
+	__scal_buf_addr_t scal_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 screen_index, status;
+
+	scaler = &(gdisp.scaler[sel]);
+	screen_index = gdisp.scaler[sel].screen_index;
+
+	memcpy(&(scaler->in_fb), &(scl->in_fb), sizeof(__disp_fb_t));
+	memcpy(&(scaler->src_win), &(scl->src_win), sizeof(__disp_rect_t));
+	memcpy(&(scaler->out_size), &(scl->out_size), sizeof(__disp_rectsz_t));
+
+	in_type.fmt = Scaler_sw_para_to_reg1(scaler->in_fb.format);
+	in_type.mod = scaler->in_fb.mode;
+	in_type.ps = Scaler_sw_para_to_reg3(scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	scal_addr.ch0_addr = scaler->in_fb.addr[0];
+	scal_addr.ch1_addr = scaler->in_fb.addr[1];
+	scal_addr.ch2_addr = scaler->in_fb.addr[2];
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height = scaler->src_win.height;
+	in_size.scal_width = scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = Scaler_sw_para_to_reg4(scaler->out_fb.format);
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	if (sunxi_is_sun5i())
+		status = gdisp.screen[screen_index].iep_status;
+	else
+		status = gdisp.screen[screen_index].de_flicker_status;
+
+	out_scan.field = (status & DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
+
+	if (scaler->in_fb.cs_mode > DISP_VXYCC)
+		scaler->in_fb.cs_mode = DISP_BT601;
+
+	if (scaler->in_fb.b_trd_src) {
+		__scal_3d_inmode_t inmode;
+		__scal_3d_outmode_t outmode = 0;
+		__scal_buf_addr_t scal_addr_right;
+
+		inmode = Scaler_3d_sw_para_to_reg(0, scaler->in_fb.trd_mode, 0);
+		outmode = Scaler_3d_sw_para_to_reg(1, scaler->out_trd_mode,
+						   gdisp.screen[screen_index].
+						   b_out_interlace);
+
+		DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+		if (scaler->b_trd_out) {
+			DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size,
+						       &out_size);
+		}
+
+		scal_addr_right.ch0_addr = scaler->in_fb.trd_right_addr[0];
+		scal_addr_right.ch1_addr = scaler->in_fb.trd_right_addr[1];
+		scal_addr_right.ch2_addr = scaler->in_fb.trd_right_addr[2];
+
+		DE_SCAL_Set_3D_Ctrl(sel, scaler->b_trd_out, inmode, outmode);
+		DE_SCAL_Config_3D_Src(sel, &scal_addr, &in_size, &in_type,
+				      inmode, &scal_addr_right);
+	} else {
+		DE_SCAL_Config_Src(sel, &scal_addr, &in_size, &in_type, FALSE,
+				   FALSE);
+	}
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan,
+				   &out_size, &out_type);
+	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan,
+			       &out_size, &out_type, FALSE);
+	if (scaler->enhance_en == TRUE) {
+		Scaler_Set_Enhance(sel, scaler->bright, scaler->contrast,
+				   scaler->saturation, scaler->hue);
+	} else {
+		DE_SCAL_Set_CSC_Coef(sel, scaler->in_fb.cs_mode, DISP_BT601,
+				     get_fb_type(scaler->in_fb.format),
+				     DISP_FB_TYPE_RGB, scaler->in_fb.br_swap,
+				     0);
+	}
+
+	if (sunxi_is_sun5i())
+		gdisp.scaler[sel].coef_change = 1;
+	else
+		DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type,
+			&out_scan, &out_size, &out_type, scaler->smooth_mode);
+
+	DE_SCAL_Set_Out_Format(sel, &out_type);
+	DE_SCAL_Set_Out_Size(sel, &out_scan, &out_type, &out_size);
+
+	return DIS_NULL;
+}
+
+__s32 Scaler_Set_Outitl(__u32 sel, __bool enable)
+{
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__disp_scaler_t *scaler;
+
+	scaler = &(gdisp.scaler[sel]);
+
+	in_type.fmt = Scaler_sw_para_to_reg1(scaler->in_fb.format);
+	in_type.mod = scaler->in_fb.mode;
+	in_type.ps = Scaler_sw_para_to_reg3(scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height = scaler->src_win.height;
+	in_size.scal_width = scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = Scaler_sw_para_to_reg4(scaler->out_fb.format);
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	out_scan.field = enable;
+
+	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan,
+			       &out_size, &out_type, FALSE);
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan,
+				   &out_size, &out_type);
+
+	if (sunxi_is_sun5i())
+		gdisp.scaler[sel].coef_change = 1;
+	else
+		DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type,
+			&out_scan, &out_size, &out_type, scaler->smooth_mode);
+
+	DE_SCAL_Set_Out_Size(sel, &out_scan, &out_type, &out_size);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_scaler_set_smooth(__u32 sel, __disp_video_smooth_t mode)
+{
+	__disp_scaler_t *scaler;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 screen_index, status;
+
+	scaler = &(gdisp.scaler[sel]);
+	screen_index = gdisp.scaler[sel].screen_index;
+	scaler->smooth_mode = mode;
+
+	in_type.fmt = Scaler_sw_para_to_reg1(scaler->in_fb.format);
+	in_type.mod = scaler->in_fb.mode;
+	in_type.ps = Scaler_sw_para_to_reg3(scaler->in_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	in_size.src_width = scaler->in_fb.size.width;
+	in_size.src_height = scaler->in_fb.size.height;
+	in_size.x_off = scaler->src_win.x;
+	in_size.y_off = scaler->src_win.y;
+	in_size.scal_height = scaler->src_win.height;
+	in_size.scal_width = scaler->src_win.width;
+
+	out_type.byte_seq = scaler->out_fb.seq;
+	out_type.fmt = Scaler_sw_para_to_reg4(scaler->out_fb.format);
+
+	out_size.width = scaler->out_size.width;
+	out_size.height = scaler->out_size.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	if (sunxi_is_sun5i())
+		status = gdisp.screen[screen_index].iep_status;
+	else
+		status = gdisp.screen[screen_index].de_flicker_status;
+
+	out_scan.field = (status & DE_FLICKER_USED) ?
+		FALSE : gdisp.screen[screen_index].b_out_interlace;
+
+	if (sunxi_is_sun5i())
+		gdisp.scaler[sel].coef_change = 1;
+	else
+		DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type,
+			&out_scan, &out_size, &out_type, scaler->smooth_mode);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_scaler_get_smooth(__u32 sel)
+{
+	return gdisp.scaler[sel].smooth_mode;
+}
+
+__s32 BSP_disp_scaler_request(void)
+{
+	__s32 sel = 0;
+	sel = Scaler_Request(0xff);
+	if (sel < 0)
+		return sel;
+	else
+		gdisp.scaler[sel].screen_index = 0xff;
+	return SCALER_IDTOHAND(sel);
+}
+
+__s32 BSP_disp_scaler_release(__u32 handle)
+{
+	__u32 sel = 0;
+
+	sel = SCALER_HANDTOID(handle);
+	return Scaler_Release(sel, FALSE);
+}
+
+__s32 BSP_disp_scaler_start(__u32 handle, __disp_scaler_para_t *para)
+{
+	__scal_buf_addr_t in_addr;
+	__scal_buf_addr_t out_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__u32 sel = 0;
+	__s32 ret = 0;
+	__u32 i = 0;
+	__u32 ch_num = 0;
+
+	if (para == NULL) {
+		DE_WRN("input parameter can't be null!\n");
+		return DIS_FAIL;
+	}
+
+	sel = SCALER_HANDTOID(handle);
+
+	in_type.fmt = Scaler_sw_para_to_reg1(para->input_fb.format);
+	in_type.mod = para->input_fb.mode;
+	in_type.ps = Scaler_sw_para_to_reg3(para->input_fb.seq);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	if (get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV) {
+		if (para->output_fb.mode == DISP_MOD_NON_MB_PLANAR) {
+			out_type.fmt =
+			    Scaler_sw_para_to_reg4(para->output_fb.format);
+		} else {
+			DE_WRN("output mode:%d invalid in "
+			       "Display_Scaler_Start\n", para->output_fb.mode);
+			return DIS_FAIL;
+		}
+	} else {
+		if (para->output_fb.mode == DISP_MOD_NON_MB_PLANAR &&
+		    (para->output_fb.format == DISP_FORMAT_RGB888 ||
+		     para->output_fb.format == DISP_FORMAT_ARGB8888)) {
+			out_type.fmt = DE_SCAL_OUTPRGB888;
+		} else if (para->output_fb.mode == DISP_MOD_INTERLEAVED &&
+			   para->output_fb.format == DISP_FORMAT_ARGB8888) {
+			out_type.fmt = DE_SCAL_OUTI0RGB888;
+		} else {
+			DE_WRN("output para invalid in Display_Scaler_Start,"
+			       "mode:%d,format:%d\n", para->output_fb.mode,
+			       para->output_fb.format);
+			return DIS_FAIL;
+		}
+	}
+	out_type.byte_seq = Scaler_sw_para_to_reg3(para->output_fb.seq);
+
+	out_size.width = para->output_fb.size.width;
+	out_size.height = para->output_fb.size.height;
+
+	in_addr.ch0_addr = para->input_fb.addr[0];
+	in_addr.ch1_addr = para->input_fb.addr[1];
+	in_addr.ch2_addr = para->input_fb.addr[2];
+
+	in_size.src_width = para->input_fb.size.width;
+	in_size.src_height = para->input_fb.size.height;
+	in_size.x_off = para->source_regn.x;
+	in_size.y_off = para->source_regn.y;
+	in_size.scal_width = para->source_regn.width;
+	in_size.scal_height = para->source_regn.height;
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	/*
+	 * when use scaler as writeback, won't be outinterlaced for any
+	 * display device
+	 */
+	out_scan.field = FALSE;
+	out_scan.bottom = FALSE;
+
+	out_addr.ch0_addr = para->output_fb.addr[0];
+	out_addr.ch1_addr = para->output_fb.addr[1];
+	out_addr.ch2_addr = para->output_fb.addr[2];
+
+	if (para->input_fb.b_trd_src) {
+		__scal_3d_inmode_t inmode;
+		__scal_3d_outmode_t outmode = 0;
+		__scal_buf_addr_t scal_addr_right;
+
+		inmode = Scaler_3d_sw_para_to_reg(0, para->input_fb.trd_mode,
+						  FALSE);
+		outmode = Scaler_3d_sw_para_to_reg(1, para->output_fb.trd_mode,
+						   FALSE);
+
+		DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size, &in_size);
+		if (para->output_fb.b_trd_src) {
+			DE_SCAL_Get_3D_Out_Single_Size(outmode, &out_size,
+						       &out_size);
+		}
+
+		scal_addr_right.ch0_addr = para->input_fb.trd_right_addr[0];
+		scal_addr_right.ch1_addr = para->input_fb.trd_right_addr[1];
+		scal_addr_right.ch2_addr = para->input_fb.trd_right_addr[2];
+
+		DE_SCAL_Set_3D_Ctrl(sel, para->output_fb.b_trd_src, inmode,
+				    outmode);
+		DE_SCAL_Config_3D_Src(sel, &in_addr, &in_size, &in_type, inmode,
+				      &scal_addr_right);
+	} else {
+		DE_SCAL_Config_Src(sel, &in_addr, &in_size, &in_type, FALSE,
+				   FALSE);
+	}
+	DE_SCAL_Set_Scaling_Factor(sel, &in_scan, &in_size, &in_type, &out_scan,
+				   &out_size, &out_type);
+	DE_SCAL_Set_Init_Phase(sel, &in_scan, &in_size, &in_type, &out_scan,
+			       &out_size, &out_type, FALSE);
+	DE_SCAL_Set_CSC_Coef(sel, para->input_fb.cs_mode,
+			     para->output_fb.cs_mode,
+			     get_fb_type(para->input_fb.format),
+			     get_fb_type(para->output_fb.format),
+			     para->input_fb.br_swap, para->output_fb.br_swap);
+	DE_SCAL_Set_Scaling_Coef(sel, &in_scan, &in_size, &in_type, &out_scan,
+				 &out_size, &out_type, DISP_VIDEO_NATUAL);
+	DE_SCAL_Set_Out_Format(sel, &out_type);
+	DE_SCAL_Set_Out_Size(sel, &out_scan, &out_type, &out_size);
+
+	if (!sunxi_is_sun5i()) {
+		long timeout = (100 * HZ) / 1000; /* 100ms */
+
+		DE_SCAL_Set_Writeback_Addr(sel, &out_addr);
+
+		DE_SCAL_Output_Select(sel, 3);
+		DE_SCAL_EnableINT(sel, DE_WB_END_IE);
+		DE_SCAL_Start(sel);
+		DE_SCAL_Set_Reg_Rdy(sel);
+
+		init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
+		gdisp.scaler[sel].b_scaler_finished = 1;
+		DE_SCAL_Writeback_Enable(sel);
+
+		timeout =
+		    wait_event_interruptible_timeout(gdisp.scaler[sel].
+						     scaler_queue,
+						     gdisp.scaler[sel].
+						     b_scaler_finished == 2,
+						     timeout);
+		gdisp.scaler[sel].b_scaler_finished = 0;
+		if (timeout == 0) {
+			__wrn("wait scaler %d finished timeout\n", sel);
+			return -1;
+		}
+		DE_SCAL_Reset(sel);
+		DE_SCAL_Writeback_Disable(sel);
+	} else {
+		if (para->output_fb.mode == DISP_MOD_INTERLEAVED)
+			ch_num = 1;
+		else if (para->output_fb.mode == DISP_MOD_MB_UV_COMBINED ||
+			 para->output_fb.mode == DISP_MOD_NON_MB_UV_COMBINED)
+			ch_num = 2;
+		else if (para->output_fb.mode == DISP_MOD_MB_PLANAR ||
+			 para->output_fb.mode == DISP_MOD_NON_MB_PLANAR)
+			ch_num = 3;
+
+		for (i = 0; i < ch_num; i++) {
+			long timeout = (100 * HZ) / 1000; /* 100ms */
+			__scal_buf_addr_t addr;
+			ret = 0;
+
+			addr.ch0_addr = out_addr.ch0_addr;
+			if (i == 1)
+				addr.ch0_addr = out_addr.ch1_addr;
+			else if (i == 2)
+				addr.ch0_addr = out_addr.ch2_addr;
+			DE_SCAL_Enable(sel);
+
+			DE_SCAL_Set_Writeback_Addr(sel, &addr);
+			DE_SCAL_Set_Writeback_Chnl(sel, i);
+
+			DE_SCAL_Output_Select(sel, 3);
+			DE_SCAL_EnableINT(sel, DE_WB_END_IE);
+			DE_SCAL_Start(sel);
+			DE_SCAL_Set_Reg_Rdy(sel);
+
+			init_waitqueue_head(&(gdisp.scaler[sel].scaler_queue));
+			gdisp.scaler[sel].b_scaler_finished = 1;
+			DE_SCAL_Writeback_Enable(sel);
+
+			timeout =
+			    wait_event_interruptible_timeout(gdisp.scaler[sel].
+							     scaler_queue,
+							     gdisp.scaler[sel].
+							     b_scaler_finished
+							     == 2, timeout);
+			gdisp.scaler[sel].b_scaler_finished = 0;
+
+			if (timeout == 0) {
+				__wrn("wait scaler %d finished timeout\n", sel);
+				DE_SCAL_Writeback_Disable(sel);
+				DE_SCAL_Reset(sel);
+				DE_SCAL_Disable(sel);
+				return -1;
+			}
+		}
+
+		DE_SCAL_Writeback_Disable(sel);
+		DE_SCAL_Reset(sel);
+		DE_SCAL_Disable(sel);
+	}
+
+	return ret;
+}
+
+__s32 BSP_disp_capture_screen(__u32 sel, __disp_capture_screen_para_t *para)
+{
+	__scal_buf_addr_t in_addr;
+	__scal_buf_addr_t out_addr;
+	__scal_src_size_t in_size;
+	__scal_out_size_t out_size;
+	__scal_src_type_t in_type;
+	__scal_out_type_t out_type;
+	__scal_scan_mod_t in_scan;
+	__scal_scan_mod_t out_scan;
+	__s32 scaler_idx = 0;
+	__s32 ret = 0;
+
+	if (para == NULL) {
+		DE_WRN("input parameter can't be null!\n");
+		return DIS_FAIL;
+	}
+
+	scaler_idx = Scaler_Request(0xff);
+	if (scaler_idx < 0) {
+		DE_WRN("request scaler fail in BSP_disp_capture_screen\n");
+		return DIS_FAIL;
+	} else {
+		gdisp.scaler[sel].screen_index = 0xff;
+	}
+
+	in_type.fmt = Scaler_sw_para_to_reg1(DISP_FORMAT_ARGB8888);
+	in_type.mod = DISP_MOD_INTERLEAVED;
+	in_type.ps = Scaler_sw_para_to_reg3(DISP_SEQ_ARGB);
+	in_type.byte_seq = 0;
+	in_type.sample_method = 0;
+
+	if (get_fb_type(para->output_fb.format) == DISP_FB_TYPE_YUV) {
+		if (para->output_fb.mode == DISP_MOD_NON_MB_PLANAR) {
+			out_type.fmt =
+			    Scaler_sw_para_to_reg4(para->output_fb.format);
+		} else {
+			DE_WRN("output mode:%d invalid in "
+			       "Display_Scaler_Start\n", para->output_fb.mode);
+			return DIS_FAIL;
+		}
+	} else {
+		if (para->output_fb.mode == DISP_MOD_NON_MB_PLANAR &&
+		    (para->output_fb.format == DISP_FORMAT_RGB888 ||
+		     para->output_fb.format == DISP_FORMAT_ARGB8888)) {
+			out_type.fmt = DE_SCAL_OUTPRGB888;
+		} else if (para->output_fb.mode == DISP_MOD_INTERLEAVED &&
+			   para->output_fb.format == DISP_FORMAT_ARGB8888) {
+			out_type.fmt = DE_SCAL_OUTI0RGB888;
+		} else {
+			DE_WRN("output para invalid in Display_Scaler_Start, "
+			       "mode:%d,format:%d\n", para->output_fb.mode,
+			       para->output_fb.format);
+			return DIS_FAIL;
+		}
+		para->output_fb.br_swap = FALSE;
+	}
+	out_type.byte_seq = Scaler_sw_para_to_reg3(para->output_fb.seq);
+
+	out_size.width = para->output_fb.size.width;
+	out_size.height = para->output_fb.size.height;
+
+	if (BSP_disp_get_output_type(sel) != DISP_OUTPUT_TYPE_NONE) {
+		in_size.src_width = BSP_disp_get_screen_width(sel);
+		in_size.src_height = BSP_disp_get_screen_height(sel);
+		in_size.x_off = 0;
+		in_size.y_off = 0;
+		in_size.scal_width = BSP_disp_get_screen_width(sel);
+		in_size.scal_height = BSP_disp_get_screen_height(sel);
+	} else {
+		in_size.src_width = para->screen_size.width;
+		in_size.src_height = para->screen_size.height;
+		in_size.x_off = 0;
+		in_size.y_off = 0;
+		in_size.scal_width = para->screen_size.width;
+		in_size.scal_height = para->screen_size.height;
+	}
+
+	in_scan.field = FALSE;
+	in_scan.bottom = FALSE;
+
+	/*
+	 * when use scaler as writeback, won't be outinterlaced for any
+	 * display device
+	 */
+	out_scan.field = FALSE;
+	out_scan.bottom = FALSE;
+
+	in_addr.ch0_addr = 0;
+	in_addr.ch1_addr = 0;
+	in_addr.ch2_addr = 0;
+
+	out_addr.ch0_addr = para->output_fb.addr[0];
+	out_addr.ch1_addr = para->output_fb.addr[1];
+	out_addr.ch2_addr = para->output_fb.addr[2];
+
+	if (BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE) {
+		DE_SCAL_Input_Select(scaler_idx, 6 + sel);
+		DE_BE_set_display_size(sel, para->screen_size.width,
+				       para->screen_size.height);
+		DE_BE_Output_Select(sel, 6 + scaler_idx);
+		image_clk_on(sel);
+		Image_open(sel);
+		DE_BE_Cfg_Ready(sel);
+	} else {
+		DE_SCAL_Input_Select(scaler_idx, 4 + sel);
+		DE_BE_Output_Select(sel, 2 + (scaler_idx * 2) + sel);
+	}
+	DE_SCAL_Config_Src(scaler_idx, &in_addr, &in_size, &in_type, FALSE,
+			   FALSE);
+	DE_SCAL_Set_Scaling_Factor(scaler_idx, &in_scan, &in_size, &in_type,
+				   &out_scan, &out_size, &out_type);
+	DE_SCAL_Set_Init_Phase(scaler_idx, &in_scan, &in_size, &in_type,
+			       &out_scan, &out_size, &out_type, FALSE);
+	DE_SCAL_Set_CSC_Coef(scaler_idx, DISP_BT601, para->output_fb.cs_mode,
+			     DISP_FB_TYPE_RGB,
+			     get_fb_type(para->output_fb.format), 0, 0);
+	DE_SCAL_Set_Scaling_Coef(scaler_idx, &in_scan, &in_size, &in_type,
+				 &out_scan, &out_size, &out_type,
+				 DISP_VIDEO_NATUAL);
+	DE_SCAL_Set_Out_Format(scaler_idx, &out_type);
+	DE_SCAL_Set_Out_Size(scaler_idx, &out_scan, &out_type, &out_size);
+	DE_SCAL_Set_Writeback_Addr(scaler_idx, &out_addr);
+	DE_SCAL_Output_Select(scaler_idx, 3);
+	DE_SCAL_ClearINT(scaler_idx, DE_WB_END_IE);
+	DE_SCAL_EnableINT(scaler_idx, DE_WB_END_IE);
+	DE_SCAL_Set_Reg_Rdy(scaler_idx);
+	DE_SCAL_Writeback_Enable(scaler_idx);
+	DE_SCAL_Start(scaler_idx);
+
+	DE_INF("capture begin\n");
+	{
+		long timeout = (100 * HZ) / 1000; /* 100ms */
+
+		init_waitqueue_head(&(gdisp.scaler[scaler_idx].scaler_queue));
+		gdisp.scaler[scaler_idx].b_scaler_finished = 1;
+		DE_SCAL_Writeback_Enable(scaler_idx);
+
+		timeout =
+		    wait_event_interruptible_timeout(gdisp.scaler[scaler_idx].
+						     scaler_queue,
+						     gdisp.scaler[scaler_idx].
+						     b_scaler_finished == 2,
+						     timeout);
+		gdisp.scaler[scaler_idx].b_scaler_finished = 0;
+		if (timeout == 0) {
+			__wrn("wait scaler %d finished timeout\n", scaler_idx);
+			return -1;
+		}
+	}
+
+	DE_SCAL_Reset(scaler_idx);
+	Scaler_Release(scaler_idx, FALSE);
+	if (BSP_disp_get_output_type(sel) == DISP_OUTPUT_TYPE_NONE) {
+		Image_close(sel);
+		image_clk_off(sel);
+	}
+	DE_BE_Output_Select(sel, sel);
+
+	return ret;
+}
+
+__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast,
+			 __u32 saturation, __u32 hue)
+{
+	__u32 b_yuv_in, b_yuv_out;
+	__disp_scaler_t *scaler;
+
+	scaler = &(gdisp.scaler[sel]);
+
+	b_yuv_in = (get_fb_type(scaler->in_fb.format) == DISP_FB_TYPE_YUV) ?
+		1 : 0;
+	b_yuv_out = (get_fb_type(scaler->out_fb.format) == DISP_FB_TYPE_YUV) ?
+		1 : 0;
+	DE_SCAL_Set_CSC_Coef_Enhance(sel, scaler->in_fb.cs_mode,
+				     scaler->out_fb.cs_mode, b_yuv_in,
+				     b_yuv_out, bright, contrast, saturation,
+				     hue, scaler->in_fb.br_swap, 0);
+
+	return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_scaler.h b/drivers/video/sunxi/disp/disp_scaler.h
new file mode 100644
index 0000000..1df8c03
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_scaler.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _DISP_SCALER_H_
+#define _DISP_SCALER_H_
+
+#include "disp_display_i.h"
+
+#define SCALER_HANDTOID(handle)  ((handle) - 100)
+#define SCALER_IDTOHAND(ID)  ((ID) + 100)
+
+#define SCALER_WB_FINISHED 0x00000002
+
+typedef enum {
+	SCALER_IN_SRC_DRAM = 0,
+	SCALER_IN_SRC_IMAGE0_TO_LCD = 1,
+	SCALER_IN_SRC_IMAGE1_TO_LCD = 2,
+	SCALER_IN_SRC_IMAGE0 = 2,
+	SCALER_IN_SRC_IMAGE1 = 3,
+} __disp_scaler_in_src;
+
+typedef struct {
+	__u32 status;
+	__bool b_close;
+
+	__u32 screen_index;
+	__disp_scaler_in_src input_sel;
+
+	__u32 layer_id;
+	__disp_fb_t in_fb;
+	__disp_fb_t out_fb;
+	__disp_rect_t src_win;
+	__disp_rectsz_t out_size;
+	__u32 smooth_mode;
+
+	__bool enhance_en;
+	__u32 bright;
+	__u32 contrast;
+	__u32 saturation;
+	__u32 hue;
+
+	__bool vpp_en;
+	__u32 luma_sharpe_level;
+	__u32 chroma_sharpe_level;
+	__u32 while_exten_level;
+	__u32 black_exten_level;
+
+	__bool b_trd_out;
+	__disp_3d_out_mode_t out_trd_mode;
+	wait_queue_head_t scaler_queue;
+	__bool b_scaler_finished;
+	__bool coef_change;
+} __disp_scaler_t;
+
+extern __disp_scaler_t gscl;
+
+__s32 Scaler_Init(__u32 sel);
+__s32 Scaler_Exit(__u32 sel);
+__s32 Scaler_open(__u32 sel);
+__s32 Scaler_close(__u32 sel);
+__s32 Scaler_Request(__u32 sel);
+__s32 Scaler_Release(__u32 sel, __bool b_display);
+__s32 Scaler_Set_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
+__s32 Scaler_Get_Framebuffer(__u32 sel, __disp_fb_t *vfb_info);
+__s32 Scaler_Set_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
+__s32 Scaler_Get_SclRegn(__u32 sel, __disp_rect_t *scl_rect);
+__s32 Scaler_Set_Output_Size(__u32 sel, __disp_rectsz_t *out_size);
+__s32 Scaler_Set_Para(__u32 sel, __disp_scaler_t *scl);
+__s32 Scaler_Set_Outitl(__u32 sel, __bool enable);
+__s32 Scaler_Set_Enhance(__u32 sel, __u32 bright, __u32 contrast,
+			 __u32 saturation, __u32 hue);
+__s32 Scaler_3d_sw_para_to_reg(__u32 type, __u32 mode, __bool b_out_interlace);
+__scal_infmt_t Scaler_sw_para_to_reg1(__disp_pixel_fmt_t value);
+__scal_ps_t Scaler_sw_para_to_reg3(__disp_pixel_seq_t value);
+__scal_outfmt_t Scaler_sw_para_to_reg4(__disp_pixel_fmt_t value);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_sprite.c b/drivers/video/sunxi/disp/disp_sprite.c
new file mode 100644
index 0000000..a81fe92
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_sprite.c
@@ -0,0 +1,1047 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_sprite.h"
+#include "disp_display.h"
+#include "disp_layer.h"
+#include "disp_event.h"
+
+static sprite_t gsprite[2];
+
+static __s32 Sprite_Get_Idle_Block_id(__u32 sel)
+{
+	__s32 i = 0;
+
+	for (i = 0; i < MAX_SPRITE_BLOCKS; i++)
+		if (!(gsprite[sel].block_status[i] & SPRITE_BLOCK_USED))
+			return i;
+
+	return (__s32) DIS_NO_RES;
+}
+
+static __s32 Sprite_Id_To_Hid(__u32 sel, __s32 id)
+{
+	if (id == -1)
+		return 0;
+	else
+		return gsprite[sel].sprite_hid[id];
+}
+
+static __s32 Sprite_Hid_To_Id(__u32 sel, __s32 hid)
+{
+	if (hid == 0)
+		return -1;
+	else {
+		__s32 i = 0;
+		for (i = 0; i < MAX_SPRITE_BLOCKS; i++) {
+			if (gsprite[sel].sprite_hid[i] == hid)
+				return i;
+		}
+		return -1;
+	}
+}
+
+/*
+ * With this premise: prev, next must be there, otherwise collapse.
+ */
+static inline void ___list_add(list_head_t *node, list_head_t *prev,
+				 list_head_t *next)
+{
+	node->next = next;
+	node->prev = prev;
+	prev->next = node;
+	next->prev = node;
+}
+
+/*
+ * Node is added to the list of the last surface, also both front
+ */
+static inline void list_add_node_tail(list_head_t *node, list_head_t **head)
+{
+	if (*head == NULL)
+		*head = node;
+	else
+		___list_add(node, (*head)->prev, *head);
+}
+
+/*
+ * Delete the entry from the list in
+ */
+static inline void list_del_node(list_head_t *entry)
+{
+	entry->prev->next = entry->next;
+	entry->next->prev = entry->prev;
+	entry->next = entry;
+	entry->prev = entry;
+}
+
+/*
+ * Internal function, the release space of the node
+ */
+static inline void list_free_node(list_head_t *node)
+{
+	if (node != NULL) {
+		vfree((void *) node->data);
+		vfree((void *) node);
+		node = NULL;
+	}
+}
+
+/*
+ * To apply for a new node, and initialize
+ */
+static list_head_t *
+List_New_Sprite_Block(__u32 sel, __disp_sprite_block_para_t *para)
+{
+	list_head_t *node = NULL;
+	sprite_block_data_t *data = NULL;
+	__s32 id;
+
+	id = Sprite_Get_Idle_Block_id(sel);
+
+	if (id != DIS_NO_RES) {
+		data = vmalloc(sizeof(sprite_block_data_t));
+		data->enable = FALSE;
+		data->id = id;
+		data->src_win.x = para->src_win.x;
+		data->src_win.y = para->src_win.y;
+		data->scn_win.x = para->scn_win.x;
+		data->scn_win.y = para->scn_win.y;
+		data->scn_win.width = para->scn_win.width;
+		data->scn_win.height = para->scn_win.height;
+		data->address = (__u32) para->fb.addr[0];
+		data->size.width = para->fb.size.width;
+
+		node = vmalloc(sizeof(list_head_t));
+		node->next = node->prev = node;
+		node->data = data;
+
+		return node;
+	} else {
+		return NULL;
+	}
+}
+
+/*
+ * Add a new node at the end of the list
+ */
+static void *
+List_Add_Sprite_Block(__u32 sel, __disp_sprite_block_para_t *para)
+{
+	list_head_t *node = NULL;
+
+	node = List_New_Sprite_Block(sel, para);
+
+	if (node != NULL) {
+		list_add_node_tail(node, &gsprite[sel].header);
+		return node;
+	}
+	return NULL;
+}
+
+/*
+ * In the linked list to find the block id, and returns the node pointer
+ */
+static list_head_t *List_Find_Sprite_Block(__u32 sel, __s32 id)
+{
+	list_head_t *guard = NULL;
+
+	guard = gsprite[sel].header;
+
+	if (guard != NULL) {
+		do {
+			if (guard->data->id == id)
+				return guard;
+
+			guard = guard->next;
+		} while (guard != gsprite[sel].header);
+	}
+
+	return NULL;
+
+}
+
+/*
+ * Block id, removed from the list and return to the block pointer
+ */
+static list_head_t *List_Delete_Sprite_Block(__u32 sel, list_head_t *node)
+{
+	__s32 id = 0;
+
+	if (node != NULL) {
+		id = node->data->id;
+		if (id == 0) { /* delete the first block */
+			__s32 next_id = 0;
+			list_head_t *next_node = NULL;
+
+			next_id = node->next->data->id;
+			next_node = node->next;
+
+			if (id == next_id) /* free the only block */
+				gsprite[sel].header = NULL;
+			else {
+				__s32 id_tmp = 0;
+
+				id_tmp = gsprite[sel].sprite_hid[0];
+				gsprite[sel].sprite_hid[0] =
+					gsprite[sel].sprite_hid[next_id];
+				gsprite[sel].sprite_hid[next_id] = id_tmp;
+
+				next_node->data->id = 0;
+				node->data->id = next_id;
+
+				gsprite[sel].header = next_node;
+			}
+		}
+		list_del_node(node);
+
+		return node;
+	} else
+		return NULL;
+}
+
+/*
+ * Block id, and the release of its space removed from the list and return to
+ * the block id (the id may not be the original id)
+ */
+static __s32 List_Delete_Free_Sprite_Block(__u32 sel, list_head_t *node)
+{
+	__s32 ret = -1;
+
+	if (node != NULL) {
+		List_Delete_Sprite_Block(sel, node);
+		ret = node->data->id;
+		list_free_node(node);
+	}
+	return ret;
+}
+
+static __s32 List_Assert_Sprite_Block(__u32 sel, list_head_t *dst_node,
+				      list_head_t *node)
+{
+	list_head_t *next_node = NULL;
+
+	if (gsprite[sel].header == NULL) {
+		gsprite[sel].header = node;
+		return DIS_SUCCESS;
+	} else if (dst_node == NULL) { /* asset to the front of the list */
+		__s32 id = 0;
+		__s32 id_tmp = 0;
+
+		next_node = gsprite[sel].header;
+
+		id = node->data->id;
+		node->data->id = 0;
+		next_node->data->id = id;
+
+		id_tmp = gsprite[sel].sprite_hid[0];
+		gsprite[sel].sprite_hid[0] = gsprite[sel].sprite_hid[id];
+		gsprite[sel].sprite_hid[id] = id_tmp;
+
+		gsprite[sel].header = node;
+
+		dst_node = next_node->prev;
+	} else
+		next_node = dst_node->next;
+
+	___list_add(node, dst_node, next_node);
+
+	return DIS_SUCCESS;
+}
+
+static __s32 List_Get_First_Sprite_Block_Id(__u32 sel)
+{
+	if (gsprite[sel].header == NULL)
+		return -1;
+	else
+		return gsprite[sel].header->data->id;
+}
+
+static __s32 List_Get_Last_Sprite_Block_Id(__u32 sel)
+{
+	if (gsprite[sel].header == NULL)
+		return -1;
+	else
+		return gsprite[sel].header->prev->data->id;
+}
+
+static __s32 sprite_set_sprite_block_para(__u32 sel, __u32 id, __u32 next_id,
+					  __disp_sprite_block_para_t *para)
+{
+	__u32 bpp, addr;
+
+	bpp = DE_BE_Format_To_Bpp(gsprite[sel].format);
+
+	addr = DE_BE_Offset_To_Addr((__u32) para->fb.addr[0],
+				    para->fb.size.width,
+				    para->src_win.x, para->src_win.y, bpp);
+	DE_BE_Sprite_Block_Set_fb(sel, id, addr,
+				  para->fb.size.width * (bpp >> 3));
+	DE_BE_Sprite_Block_Set_Pos(sel, id, para->scn_win.x, para->scn_win.y);
+	DE_BE_Sprite_Block_Set_Size(sel, id, para->scn_win.width,
+				    para->scn_win.height);
+	DE_BE_Sprite_Block_Set_Next_Id(sel, id, next_id);
+
+	return 0;
+}
+
+__s32 BSP_disp_sprite_init(__u32 sel)
+{
+	__s32 i = 0;
+
+	memset(&gsprite[sel], 0, sizeof(sprite_t));
+	gsprite[sel].status = 0;
+	for (i = 0; i < MAX_SPRITE_BLOCKS; i++) {
+		gsprite[sel].block_status[i] = 0;
+		gsprite[sel].sprite_hid[i] = 100 + i;
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_exit(__u32 sel)
+{
+	__s32 i = 0;
+	list_head_t *pGuard = NULL;
+	list_head_t *pNext = NULL;
+
+	gsprite[sel].status = 0;
+	for (i = 0; i < MAX_SPRITE_BLOCKS; i++) {
+		gsprite[sel].block_status[i] = 0;
+		gsprite[sel].sprite_hid[i] = 100 + i;
+	}
+
+	pGuard = gsprite[sel].header;
+	if (pGuard) {
+		pGuard->prev->next = NULL;
+
+		while (pGuard != NULL) {
+			pNext = pGuard->next;
+			list_free_node(pGuard);
+			pGuard = pNext;
+		}
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_open(__u32 sel)
+{
+	if (!(gsprite[sel].status & SPRITE_OPENED)) {
+		DE_BE_Sprite_Enable(sel, TRUE);
+
+		gsprite[sel].enable = TRUE;
+		gsprite[sel].status |= SPRITE_OPENED;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_close(__u32 sel)
+{
+	if (gsprite[sel].status & SPRITE_OPENED) {
+		DE_BE_Sprite_Enable(sel, FALSE);
+
+		gsprite[sel].enable = FALSE;
+		gsprite[sel].status &= ~SPRITE_OPENED;
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_alpha_enable(__u32 sel)
+{
+	DE_BE_Sprite_Global_Alpha_Enable(sel, TRUE);
+	gsprite[sel].global_alpha_enable = TRUE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_alpha_disable(__u32 sel)
+{
+	DE_BE_Sprite_Global_Alpha_Enable(sel, FALSE);
+	gsprite[sel].global_alpha_enable = FALSE;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_get_alpha_enable(__u32 sel)
+{
+	return gsprite[sel].global_alpha_enable;
+}
+
+__s32 BSP_disp_sprite_set_alpha_vale(__u32 sel, __u32 alpha)
+{
+	DE_BE_Sprite_Set_Global_Alpha(sel, alpha);
+	gsprite[sel].global_alpha_value = alpha;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_get_alpha_value(__u32 sel)
+{
+	return gsprite[sel].global_alpha_value;
+}
+
+__s32 BSP_disp_sprite_set_format(__u32 sel, __disp_pixel_fmt_t format,
+				 __disp_pixel_seq_t pixel_seq)
+{
+	gsprite[sel].format = format;
+	gsprite[sel].pixel_seq = pixel_seq;
+	DE_BE_Sprite_Set_Format(sel, (pixel_seq == DISP_SEQ_ARGB) ? 0 : 1,
+				(format == DISP_FORMAT_ARGB8888) ? 0 : 1);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_sprite_set_palette_table(__u32 sel, __u32 *buffer, __u32 offset,
+					__u32 size)
+{
+	if ((buffer == NULL) || ((offset + size) > 1024)) {
+		DE_WRN("para invalid in BSP_disp_sprite_set_palette_table\n");
+		return DIS_PARA_FAILED;
+	}
+
+	DE_BE_Sprite_Set_Palette_Table(sel, (__u32) buffer, offset, size);
+
+	return DIS_SUCCESS;
+}
+
+/*
+ * todo
+ */
+__s32 BSP_disp_sprite_set_order(__u32 sel, __s32 hid, __s32 dst_hid)
+{
+	__s32 id = 0, dst_id = 0;
+	list_head_t *node = NULL, *dst_node = NULL;
+	list_head_t *chg_node0 = NULL, *chg_node1 = NULL;
+	__disp_sprite_block_para_t para;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	dst_id = Sprite_Hid_To_Id(sel, dst_hid);
+	if ((gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) &&
+	    (dst_id == -1 ||
+	     (gsprite[sel].block_status[dst_id] & SPRITE_BLOCK_USED))) {
+		if (id == dst_id) /* same block,not need to move */
+			return DIS_SUCCESS;
+
+		if (dst_id != -1) {
+			dst_node = List_Find_Sprite_Block(sel, dst_id);
+			/* it is the order,not need to move */
+			if (dst_node->next->data->id == id && id != 0)
+				return DIS_SUCCESS;
+		} else
+			dst_node = NULL;
+
+		node = List_Find_Sprite_Block(sel, id);
+		if (id == 0) /* the block is the first block */
+			chg_node0 = node->next;
+		else
+			chg_node0 = node->prev;
+
+		if (dst_id == -1) /* move to the front of the list */
+			chg_node1 = gsprite[sel].header;
+		else
+			chg_node1 = List_Find_Sprite_Block(sel, dst_id);
+
+		List_Delete_Sprite_Block(sel, node);
+		List_Assert_Sprite_Block(sel, dst_node, node);
+
+		para.fb.addr[0] = node->data->address;
+		para.fb.size.width = node->data->size.width;
+		para.src_win.x = node->data->src_win.x;
+		para.src_win.y = node->data->src_win.y;
+		memcpy(&para.scn_win, &node->data->scn_win,
+		       sizeof(__disp_rect_t));
+		if (node->data->enable == FALSE)
+			para.scn_win.y = -2000;
+
+		sprite_set_sprite_block_para(sel, node->data->id,
+					     node->next->data->id, &para);
+
+		para.fb.addr[0] = chg_node0->data->address;
+		para.fb.size.width = chg_node0->data->size.width;
+		para.src_win.x = chg_node0->data->src_win.x;
+		para.src_win.y = chg_node0->data->src_win.y;
+		memcpy(&para.scn_win, &chg_node0->data->scn_win,
+		       sizeof(__disp_rect_t));
+		if (chg_node0->data->enable == FALSE)
+			para.scn_win.y = -2000;
+
+		sprite_set_sprite_block_para(sel, chg_node0->data->id,
+					     chg_node0->next->data->id, &para);
+
+		para.fb.addr[0] = chg_node1->data->address;
+		para.fb.size.width = chg_node1->data->size.width;
+		para.src_win.x = chg_node1->data->src_win.x;
+		para.src_win.y = chg_node1->data->src_win.y;
+		memcpy(&para.scn_win, &chg_node1->data->scn_win,
+		       sizeof(__disp_rect_t));
+		if (chg_node1->data->enable == FALSE)
+			para.scn_win.y = -2000;
+
+		sprite_set_sprite_block_para(sel, chg_node1->data->id,
+					     chg_node1->next->data->id, &para);
+
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+__s32 BSP_disp_sprite_get_top_block(__u32 sel)
+{
+	__u32 id;
+
+	id = List_Get_First_Sprite_Block_Id(sel);
+	return Sprite_Id_To_Hid(sel, id);
+}
+
+__s32 BSP_disp_sprite_get_bottom_block(__u32 sel)
+{
+	__u32 id;
+
+	id = List_Get_Last_Sprite_Block_Id(sel);
+	return Sprite_Id_To_Hid(sel, id);
+}
+
+__s32 BSP_disp_sprite_get_block_number(__u32 sel)
+{
+	return gsprite[sel].block_num;
+}
+
+/*
+ * the para including fb address,fb width,fb height,source x/y offset,
+ * screen window
+ */
+__s32
+BSP_disp_sprite_block_request(__u32 sel, __disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	__disp_sprite_block_para_t cur_para;
+	list_head_t *node = NULL;
+
+	if ((para->scn_win.width != 8) && (para->scn_win.width != 16) &&
+	    (para->scn_win.width != 32) && (para->scn_win.width != 64) &&
+	    (para->scn_win.width != 128) && (para->scn_win.width != 256) &&
+	    (para->scn_win.width != 512)) {
+		DE_WRN("BSP_disp_sprite_block_request,scn_win width "
+		       "invalid:%d\n", para->scn_win.width);
+		return DIS_NULL;
+	}
+	if ((para->scn_win.height != 8) && (para->scn_win.height != 16) &&
+	    (para->scn_win.height != 32) && (para->scn_win.height != 64) &&
+	    (para->scn_win.height != 128) && (para->scn_win.height != 256) &&
+	    (para->scn_win.height != 512) && (para->scn_win.height != 1024)) {
+		DE_WRN("BSP_disp_sprite_block_request,scn_win height "
+		       "invalid:%d\n", para->scn_win.height);
+		return DIS_NULL;
+	}
+
+	node = List_Add_Sprite_Block(sel, para);
+	if (node == NULL)
+		return (__s32) NULL;
+
+	id = node->data->id;
+	node->data->address = (__u32) para->fb.addr[0];
+	node->data->size.width = para->fb.size.width;
+	node->data->src_win.x = para->src_win.x;
+	node->data->src_win.y = para->src_win.y;
+	node->data->scn_win.x = para->scn_win.x;
+	node->data->scn_win.y = para->scn_win.y;
+	node->data->scn_win.width = para->scn_win.width;
+	node->data->scn_win.height = para->scn_win.height;
+
+	memcpy(&cur_para, para, sizeof(__disp_sprite_block_para_t));
+	cur_para.scn_win.y = -2000;
+
+	DE_BE_Sprite_Block_Set_Next_Id(sel, node->prev->data->id, id);
+	sprite_set_sprite_block_para(sel, id, 0, para);
+
+	gsprite[sel].block_status[id] |= SPRITE_BLOCK_USED;
+	gsprite[sel].block_num++;
+
+	return Sprite_Id_To_Hid(sel, id);
+}
+
+__s32 BSP_disp_sprite_block_release(__u32 sel, __s32 hid)
+{
+	__s32 id = 0, pre_id = 0, next_id = 0;
+	list_head_t *node = NULL, *next_node = NULL, *pre_node = NULL;
+	__s32 release_id = 0;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+		pre_node = node->prev;
+		next_node = node->next;
+		pre_id = node->prev->data->id;
+		next_id = node->next->data->id;
+		release_id = List_Delete_Free_Sprite_Block(sel, node);
+
+		/* release the only block */
+		if (id == pre_id) {
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width = 8;
+			para.fb.format = DISP_FORMAT_ARGB8888;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+
+			sprite_set_sprite_block_para(sel, id, 0, &para);
+		} else if (id == 0) { /* release the first block */
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = next_node->data->address;
+			para.fb.size.width = next_node->data->size.width;
+			para.src_win.x = next_node->data->src_win.x;
+			para.src_win.y = next_node->data->src_win.y;
+			para.scn_win.x = next_node->data->scn_win.x;
+			if (next_node->data->enable == FALSE)
+				para.scn_win.y = -2000;
+			else
+				para.scn_win.y = next_node->data->scn_win.y;
+
+			para.scn_win.width = next_node->data->scn_win.width;
+			para.scn_win.height = next_node->data->scn_win.height;
+			sprite_set_sprite_block_para(sel, 0,
+						     next_node->next->data->id,
+						     &para);
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width = 8;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+			sprite_set_sprite_block_para(sel, next_id, 0, &para);
+		} else {
+			__disp_sprite_block_para_t para;
+
+			para.fb.addr[0] = pre_node->data->address;
+			para.fb.size.width = pre_node->data->size.width;
+			para.src_win.x = pre_node->data->src_win.x;
+			para.src_win.y = pre_node->data->src_win.y;
+			para.scn_win.x = pre_node->data->scn_win.x;
+			if (node->data->enable == FALSE)
+				para.scn_win.y = -2000;
+			else
+				para.scn_win.y = pre_node->data->scn_win.y;
+
+			para.scn_win.width = pre_node->data->scn_win.width;
+			para.scn_win.height = pre_node->data->scn_win.height;
+			sprite_set_sprite_block_para(sel, pre_id, next_id,
+						     &para);
+
+			para.fb.addr[0] = 0;
+			para.fb.size.width = 8;
+			para.src_win.x = 0;
+			para.src_win.y = 0;
+			para.scn_win.x = 0;
+			para.scn_win.y = -2000;
+			para.scn_win.width = 8;
+			para.scn_win.height = 8;
+			sprite_set_sprite_block_para(sel, id, 0, &para);
+		}
+
+		gsprite[sel].block_status[release_id] &= ~SPRITE_BLOCK_USED;
+		gsprite[sel].block_num--;
+
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+/*
+ * setting srceen window(x,y,width,height)
+ */
+__s32 BSP_disp_sprite_block_set_screen_win(__u32 sel, __s32 hid,
+					   __disp_rect_t *scn_win)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+	__disp_rect_t cur_scn;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		if ((scn_win->width != 8) && (scn_win->width != 16) &&
+		    (scn_win->width != 32) && (scn_win->width != 64) &&
+		    (scn_win->width != 128) && (scn_win->width != 256) &&
+		    (scn_win->width != 512)) {
+			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win "
+			       "width invalid:%d\n", scn_win->width);
+			return DIS_PARA_FAILED;
+		}
+		if ((scn_win->height != 8) && (scn_win->height != 16) &&
+		    (scn_win->height != 32) && (scn_win->height != 64) &&
+		    (scn_win->height != 128) && (scn_win->height != 256) &&
+		    (scn_win->height != 512) && (scn_win->height != 1024)) {
+			DE_WRN("BSP_disp_sprite_block_set_screen_win,scn_win "
+			       "height invalid:%d\n", scn_win->height);
+			return DIS_PARA_FAILED;
+		}
+
+		node = List_Find_Sprite_Block(sel, id);
+		if (node == NULL)
+			return DIS_PARA_FAILED;
+
+		cur_scn.x = scn_win->x;
+		cur_scn.y = scn_win->y;
+		cur_scn.width = scn_win->width;
+		cur_scn.height = scn_win->height;
+
+		if (node->data->enable == FALSE)
+			cur_scn.y = -2000;
+
+		DE_BE_Sprite_Block_Set_Pos(sel, id, cur_scn.x, cur_scn.y);
+		DE_BE_Sprite_Block_Set_Size(sel, id, cur_scn.width,
+					    cur_scn.height);
+
+		node->data->scn_win.x = scn_win->x;
+		node->data->scn_win.y = scn_win->y;
+		node->data->scn_win.width = scn_win->width;
+		node->data->scn_win.height = scn_win->height;
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_srceen_win(__u32 sel, __s32 hid,
+					   __disp_rect_t *scn_win)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+
+		scn_win->x = node->data->scn_win.x;
+		scn_win->y = node->data->scn_win.y;
+		scn_win->width = node->data->scn_win.width;
+		scn_win->height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+/*
+ * setting source x/y offset
+ */
+__s32 BSP_disp_sprite_block_set_src_win(__u32 sel, __s32 hid,
+					__disp_rect_t *src_win)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+	__u32 bpp, addr;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+
+		bpp = DE_BE_Format_To_Bpp(gsprite[sel].format);
+		addr =
+		    DE_BE_Offset_To_Addr(node->data->address,
+					 node->data->size.width, src_win->x,
+					 src_win->y, bpp);
+		DE_BE_Sprite_Block_Set_fb(sel, id, addr,
+					  node->data->size.width * (bpp >> 3));
+
+		node->data->src_win.x = src_win->x;
+		node->data->src_win.y = src_win->y;
+
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_src_win(__u32 sel, __s32 hid,
+					__disp_rect_t *src_win)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+
+		src_win->x = node->data->src_win.x;
+		src_win->y = node->data->src_win.y;
+		src_win->width = node->data->scn_win.width;
+		src_win->height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+/*
+ * setting fb address,fb width,fb height;keep the source x/y offset
+ */
+__s32 BSP_disp_sprite_block_set_framebuffer(__u32 sel, __s32 hid,
+					    __disp_fb_t *fb)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+	__s32 bpp = 0, addr;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+
+		bpp = DE_BE_Format_To_Bpp(gsprite[sel].format);
+
+		addr = DE_BE_Offset_To_Addr(fb->addr[0], fb->size.width,
+					    node->data->src_win.x,
+					    node->data->src_win.y, bpp);
+		DE_BE_Sprite_Block_Set_fb(sel, id, addr,
+					  fb->size.width * (bpp >> 3));
+
+		node->data->address = fb->addr[0];
+		node->data->size.width = fb->size.width;
+		node->data->size.height = fb->size.height;
+
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+
+}
+
+__s32 BSP_disp_sprite_block_get_framebufer(__u32 sel, __s32 hid,
+					   __disp_fb_t *fb)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+
+		fb->format = gsprite[sel].format;
+		fb->seq = gsprite[sel].pixel_seq;
+		fb->addr[0] = node->data->address;
+		fb->size.width = node->data->size.width;
+		fb->size.height = node->data->size.height;
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+}
+
+/*
+ * setting fb address,fb width,fb height,source x/y offset,screen window
+ */
+__s32 BSP_disp_sprite_block_set_para(__u32 sel, __u32 hid,
+				     __disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+	__disp_sprite_block_para_t cur_para;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+
+		memcpy(&cur_para, para, sizeof(__disp_sprite_block_para_t));
+		if (node->data->enable == FALSE)
+			cur_para.scn_win.y = -2000;
+
+		sprite_set_sprite_block_para(sel, id, node->next->data->id,
+					     &cur_para);
+
+		node->data->address = para->fb.addr[0];
+		node->data->size.width = para->fb.size.width;
+		node->data->size.height = para->fb.size.height;
+		node->data->src_win.x = para->src_win.x;
+		node->data->src_win.y = para->src_win.y;
+		node->data->scn_win.x = para->scn_win.x;
+		node->data->scn_win.y = para->scn_win.y;
+		node->data->scn_win.width = para->scn_win.width;
+		node->data->scn_win.height = para->scn_win.height;
+		return DIS_SUCCESS;
+	} else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_sprite_block_get_para(__u32 sel, __u32 hid,
+				     __disp_sprite_block_para_t *para)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+
+		para->fb.format = gsprite[sel].format;
+		para->fb.addr[0] = node->data->address;
+		para->fb.size.width = node->data->size.width;
+		para->fb.size.height = node->data->size.height;
+		para->src_win.x = node->data->src_win.x;
+		para->src_win.y = node->data->src_win.y;
+		para->src_win.width = node->data->scn_win.width;
+		para->src_win.height = node->data->scn_win.height;
+		para->scn_win.x = node->data->scn_win.x;
+		para->scn_win.y = node->data->scn_win.y;
+		para->scn_win.width = node->data->scn_win.width;
+		para->scn_win.height = node->data->scn_win.height;
+
+		return DIS_SUCCESS;
+	} else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_sprite_block_set_top(__u32 sel, __u32 hid)
+{
+	__u32 id;
+
+	id = List_Get_Last_Sprite_Block_Id(sel);
+	return BSP_disp_sprite_set_order(sel, hid, Sprite_Id_To_Hid(sel, id));
+}
+
+__s32 BSP_disp_sprite_block_set_bottom(__u32 sel, __u32 hid)
+{
+	return BSP_disp_sprite_set_order(sel, hid, 0);
+}
+
+__s32 BSP_disp_sprite_block_get_pre_block(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+		/* the block is the first */
+		if (node == gsprite[sel].header)
+			return 0;
+
+		return Sprite_Id_To_Hid(sel, node->prev->data->id);
+	} else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_sprite_block_get_next_block(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+		/* the block is the last */
+		if (node == gsprite[sel].header->prev)
+			return 0;
+
+		return Sprite_Id_To_Hid(sel, node->next->data->id);
+	} else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_sprite_block_get_prio(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	__s32 prio = 0;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		list_head_t *guard = NULL;
+		guard = gsprite[sel].header;
+		if (guard != NULL) {
+			do {
+				if (guard->data->id == id)
+					return prio;
+
+				guard = guard->next;
+				prio++;
+			} while (guard != gsprite[sel].header);
+		}
+		return DIS_FAIL;
+	} else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_sprite_block_open(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+		if (node->data->enable == FALSE) {
+			DE_BE_Sprite_Block_Set_Pos(sel, id,
+						   node->data->scn_win.x,
+						   node->data->scn_win.y);
+			DE_BE_Sprite_Block_Set_Size(sel, id,
+						    node->data->scn_win.width,
+						    node->data->scn_win.height);
+			node->data->enable = TRUE;
+		}
+		gsprite[sel].block_status[id] |= SPRITE_BLOCK_OPENED;
+		return DIS_SUCCESS;
+	} else
+		return DIS_OBJ_NOT_INITED;
+}
+
+__s32 BSP_disp_sprite_block_close(__u32 sel, __u32 hid)
+{
+	__s32 id = 0;
+	list_head_t *node = NULL;
+	__disp_rect_t scn_win;
+
+	id = Sprite_Hid_To_Id(sel, hid);
+	if (gsprite[sel].block_status[id] & SPRITE_BLOCK_USED) {
+		node = List_Find_Sprite_Block(sel, id);
+		if (node->data->enable == TRUE) {
+			scn_win.x = 0;
+			scn_win.y = -2000;
+			scn_win.width = node->data->scn_win.width;
+			scn_win.height = node->data->scn_win.height;
+			DE_BE_Sprite_Block_Set_Pos(sel, id, scn_win.x,
+						   scn_win.y);
+			DE_BE_Sprite_Block_Set_Size(sel, id, scn_win.width,
+						    scn_win.height);
+			node->data->enable = FALSE;
+		}
+		gsprite[sel].block_status[id] &= ~SPRITE_BLOCK_OPENED;
+		return DIS_SUCCESS;
+	} else {
+		return DIS_OBJ_NOT_INITED;
+	}
+}
diff --git a/drivers/video/sunxi/disp/disp_sprite.h b/drivers/video/sunxi/disp/disp_sprite.h
new file mode 100644
index 0000000..a794734
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_sprite.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _DISP_SPRITE_H_
+#define _DISP_SPRITE_H_
+
+#include "disp_display_i.h"
+
+#define SPRITE_OPENED		0x00000001
+#define SPRITE_USED		0x00000002
+
+#define SPRITE_BLOCK_OPENED	0x00000004
+#define SPRITE_BLOCK_USED	0x00000008
+
+typedef struct {
+	__s32 enable;
+	__s32 id; /* 0 - 31 */
+	__disp_rect_t src_win;
+	__disp_rect_t scn_win;
+	__u32 address;
+	__disp_rectsz_t size;
+} sprite_block_data_t;
+
+typedef struct my_list_head {
+	struct my_list_head *next;
+	struct my_list_head *prev;
+	sprite_block_data_t *data;
+} list_head_t;
+
+typedef struct {
+	__u32 status;
+	__u32 block_status[MAX_SPRITE_BLOCKS];
+	__bool enable;
+	__disp_pixel_seq_t pixel_seq; /* 0:argb, 1:bgra */
+	__disp_pixel_fmt_t format; /* 0:32bpp; 1:8bpp */
+	__bool global_alpha_enable;
+	__u8 global_alpha_value;
+	__u8 block_num;
+	__s32 sprite_hid[MAX_SPRITE_BLOCKS];
+	list_head_t *header;
+} sprite_t;
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_tv.c b/drivers/video/sunxi/disp/disp_tv.c
new file mode 100644
index 0000000..8ad85dd
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_tv.c
@@ -0,0 +1,465 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_tv.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_de.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+#include "OSAL_Pin.h"
+
+__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod)
+{
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Init(__u32 sel)
+{
+	__s32 ret = 0, value = 0;
+
+	tve_clk_init(sel);
+	tve_clk_on(sel);
+	TVE_init(sel);
+	tve_clk_off(sel);
+
+	gdisp.screen[sel].dac_source[0] = DISP_TV_DAC_SRC_Y;
+	gdisp.screen[sel].dac_source[1] = DISP_TV_DAC_SRC_PB;
+	gdisp.screen[sel].dac_source[2] = DISP_TV_DAC_SRC_PR;
+	gdisp.screen[sel].dac_source[3] = DISP_TV_DAC_SRC_COMPOSITE;
+
+	ret = script_parser_fetch("tv_out_dac_para", "dac_used", &value, 1);
+	if (ret < 0) {
+		DE_INF("fetch script data tv_out_dac_para.dac_used fail\n");
+	} else {
+		DE_INF("tv_out_dac_para.dac_used=%d\n", value);
+
+		if (value != 0) {
+			__s32 i = 0;
+			char sub_key[20];
+
+			for (i = 0; i < 4; i++) {
+				sprintf(sub_key, "dac%d_src", i);
+
+				ret = script_parser_fetch("tv_out_dac_para",
+							  sub_key, &value, 1);
+				if (ret < 0) {
+					DE_INF("fetch script data "
+					       "tv_out_dac_para.%s fail\n",
+					       sub_key);
+				} else {
+					gdisp.screen[sel].dac_source[i] = value;
+					DE_INF("tv_out_dac_para.%s = %d\n",
+					       sub_key, value);
+				}
+			}
+		}
+	}
+
+	gdisp.screen[sel].tv_mode = DISP_TV_MOD_720P_50HZ;
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Exit(__u32 sel)
+{
+	TVE_exit(sel);
+	tve_clk_exit(sel);
+
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Open(__u32 sel)
+{
+	TVE_open(sel);
+	return DIS_SUCCESS;
+}
+
+__s32 Disp_TVEC_Close(__u32 sel)
+{
+	TVE_dac_disable(sel, 0);
+	TVE_dac_disable(sel, 1);
+	TVE_dac_disable(sel, 2);
+	TVE_dac_disable(sel, 3);
+
+	TVE_close(sel);
+
+	return DIS_SUCCESS;
+}
+
+static void Disp_TVEC_DacCfg(__u32 sel, __u8 mode)
+{
+	__u32 i = 0;
+
+	TVE_dac_disable(sel, 0);
+	TVE_dac_disable(sel, 1);
+	TVE_dac_disable(sel, 2);
+	TVE_dac_disable(sel, 3);
+
+	switch (mode) {
+	case DISP_TV_MOD_NTSC:
+	case DISP_TV_MOD_PAL:
+	case DISP_TV_MOD_PAL_M:
+	case DISP_TV_MOD_PAL_NC:
+		for (i = 0; i < 4; i++) {
+			if (gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_COMPOSITE) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_COMPOSITE);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			}
+		}
+		break;
+
+	case DISP_TV_MOD_NTSC_SVIDEO:
+	case DISP_TV_MOD_PAL_SVIDEO:
+	case DISP_TV_MOD_PAL_M_SVIDEO:
+	case DISP_TV_MOD_PAL_NC_SVIDEO:
+		for (i = 0; i < 4; i++) {
+			if (gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_LUMA) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_LUMA);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			} else if (gdisp.screen[sel].dac_source[i] ==
+				   DISP_TV_DAC_SRC_CHROMA) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_CHROMA);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			}
+		}
+		break;
+
+	case DISP_TV_MOD_480I:
+	case DISP_TV_MOD_576I:
+	case DISP_TV_MOD_480P:
+	case DISP_TV_MOD_576P:
+	case DISP_TV_MOD_720P_50HZ:
+	case DISP_TV_MOD_720P_60HZ:
+	case DISP_TV_MOD_1080I_50HZ:
+	case DISP_TV_MOD_1080I_60HZ:
+	case DISP_TV_MOD_1080P_50HZ:
+	case DISP_TV_MOD_1080P_60HZ:
+		for (i = 0; i < 4; i++) {
+			if (gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_Y) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_Y);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			} else if (gdisp.screen[sel].dac_source[i] ==
+				   DISP_TV_DAC_SRC_PB) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_PB);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			} else if (gdisp.screen[sel].dac_source[i] ==
+				   DISP_TV_DAC_SRC_PR) {
+				TVE_dac_set_source(sel, i,
+						   DISP_TV_DAC_SRC_PR);
+				TVE_dac_enable(sel, i);
+				TVE_dac_sel(sel, i, i);
+			} else if (gdisp.screen[sel].dac_source[i] ==
+				   DISP_TV_DAC_SRC_COMPOSITE) {
+				TVE_dac_set_source(1 - sel, i,
+						   DISP_TV_DAC_SRC_COMPOSITE);
+				TVE_dac_sel(1 - sel, i, i);
+			}
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+__s32 BSP_disp_tv_open(__u32 sel)
+{
+	if (!(gdisp.screen[sel].status & TV_ON)) {
+		__disp_tv_mode_t tv_mod;
+
+		tv_mod = gdisp.screen[sel].tv_mode;
+
+		image_clk_on(sel);
+		/*
+		 * set image normal channel start bit , because every
+		 * de_clk_off( )will reset this bit
+		 */
+		Image_open(sel);
+
+		disp_clk_cfg(sel, DISP_OUTPUT_TYPE_TV, tv_mod);
+		tve_clk_on(sel);
+		lcdc_clk_on(sel);
+
+		BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_TV,
+					gdisp.screen[sel].
+					iep_status & DRC_USED);
+		DE_BE_set_display_size(sel, tv_mode_to_width(tv_mod),
+				       tv_mode_to_height(tv_mod));
+		DE_BE_Output_Select(sel, sel);
+
+		if (sunxi_is_sun5i()) {
+			int scaler_index;
+
+			DE_BE_Set_Outitl_enable(sel,
+					Disp_get_screen_scan_mode(tv_mod));
+
+			for (scaler_index = 0; scaler_index < 2; scaler_index++)
+				if ((gdisp.scaler[scaler_index].
+				     status & SCALER_USED)
+				    && (gdisp.scaler[scaler_index].
+					screen_index == sel)) {
+					/* interlace output */
+					if (Disp_get_screen_scan_mode(tv_mod) ==
+					    1)
+						Scaler_Set_Outitl(scaler_index,
+								  TRUE);
+					else
+						Scaler_Set_Outitl(scaler_index,
+								  FALSE);
+				}
+		}
+
+		TCON1_set_tv_mode(sel, tv_mod);
+		TVE_set_tv_mode(sel, tv_mod);
+		Disp_TVEC_DacCfg(sel, tv_mod);
+
+		TCON1_open(sel);
+		Disp_TVEC_Open(sel);
+
+		Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_TV, tv_mod);
+		Disp_de_flicker_enable(sel, TRUE);
+
+		{
+			user_gpio_set_t gpio_info[1];
+			__hdle gpio_pa_shutdown;
+			__s32 ret;
+
+			memset(gpio_info, 0, sizeof(user_gpio_set_t));
+			ret =
+			    script_parser_fetch("audio_para", "audio_pa_ctrl",
+						(int *)gpio_info,
+						sizeof(user_gpio_set_t) /
+						sizeof(int));
+			if (ret < 0) {
+				DE_WRN("fetch script data "
+				       "audio_para.audio_pa_ctrl fail\n");
+			} else {
+				gpio_pa_shutdown =
+					OSAL_GPIO_Request(gpio_info, 1);
+				if (!gpio_pa_shutdown) {
+					DE_WRN("audio codec_wakeup request "
+					       "gpio fail!\n");
+				} else {
+					OSAL_GPIO_DevWRITE_ONEPIN_DATA
+						(gpio_pa_shutdown, 0,
+						 "audio_pa_ctrl");
+				}
+			}
+		}
+		gdisp.screen[sel].b_out_interlace =
+			Disp_get_screen_scan_mode(tv_mod);
+		gdisp.screen[sel].status |= TV_ON;
+		gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
+
+		Disp_set_out_interlace(sel);
+		Display_set_fb_timing(sel);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_close(__u32 sel)
+{
+	if (gdisp.screen[sel].status & TV_ON) {
+		Image_close(sel);
+		TCON1_close(sel);
+		Disp_TVEC_Close(sel);
+
+		tve_clk_off(sel);
+		image_clk_off(sel);
+		lcdc_clk_off(sel);
+
+		if (sunxi_is_sun5i()) {
+			int scaler_index;
+
+			Disp_de_flicker_enable(sel, 2);
+			/* must close immediately, because vbi may not come */
+			DE_BE_Set_Outitl_enable(sel, FALSE);
+			for (scaler_index = 0; scaler_index < 2; scaler_index++)
+				if ((gdisp.scaler[scaler_index].status &
+				     SCALER_USED) &&
+				    (gdisp.scaler[scaler_index].screen_index ==
+				     sel))
+					Scaler_Set_Outitl(scaler_index, FALSE);
+		}
+
+		{
+			user_gpio_set_t gpio_info[1];
+			__hdle gpio_pa_shutdown;
+			__s32 ret;
+
+			memset(gpio_info, 0, sizeof(user_gpio_set_t));
+			ret =
+			    script_parser_fetch("audio_para", "audio_pa_ctrl",
+						(int *)gpio_info,
+						sizeof(user_gpio_set_t) /
+						sizeof(int));
+			if (ret < 0) {
+				DE_WRN("fetch script data "
+				       "audio_para.audio_pa_ctrl fail\n");
+			} else {
+				gpio_pa_shutdown =
+					OSAL_GPIO_Request(gpio_info, 1);
+				if (!gpio_pa_shutdown) {
+					DE_WRN("audio codec_wakeup request "
+					       "gpio fail!\n");
+				} else {
+					OSAL_GPIO_DevWRITE_ONEPIN_DATA
+						(gpio_pa_shutdown, 1,
+						 "audio_pa_ctrl");
+				}
+			}
+		}
+
+		gdisp.screen[sel].b_out_interlace = 0;
+		gdisp.screen[sel].status &= ~TV_ON;
+		gdisp.screen[sel].lcdc_status &= ~LCDC_TCON1_USED;
+		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &=
+		    ((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED) ?
+		     ~VIDEO_PLL0_USED : ~VIDEO_PLL1_USED);
+
+		Disp_set_out_interlace(sel);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_set_mode(__u32 sel, __disp_tv_mode_t tv_mod)
+{
+	/* tv-out does not support 3d or other special modes */
+	if (tv_mod >= DISP_TV_MOD_1080P_24HZ_3D_FP) {
+		DE_WRN("unsupported tv mode:%d in BSP_disp_tv_set_mode\n",
+		       tv_mod);
+		return DIS_FAIL;
+	}
+
+	gdisp.screen[sel].tv_mode = tv_mod;
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_TV;
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_get_mode(__u32 sel)
+{
+	return gdisp.screen[sel].tv_mode;
+}
+
+__s32 BSP_disp_tv_get_interface(__u32 sel)
+{
+	__u8 dac[4] = { 0 };
+	__s32 i = 0;
+	__u32 ret = DISP_TV_NONE;
+
+	for (i = 0; i < 4; i++) {
+		dac[i] = TVE_get_dac_status(i);
+		if (dac[i] > 1) {
+			DE_WRN("dac %d short to ground\n", i);
+			dac[i] = 0;
+		}
+
+		if ((gdisp.screen[sel].dac_source[i] ==
+		     DISP_TV_DAC_SRC_COMPOSITE) && dac[i] == 1) {
+			ret |= DISP_TV_CVBS;
+		} else if ((gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_Y) && dac[i] == 1) {
+			ret |= DISP_TV_YPBPR;
+		} else if ((gdisp.screen[sel].dac_source[i] ==
+			    DISP_TV_DAC_SRC_LUMA) && dac[i] == 1) {
+			ret |= DISP_TV_SVIDEO;
+		}
+	}
+
+	return ret;
+}
+
+__s32 BSP_disp_tv_get_dac_status(__u32 sel, __u32 index)
+{
+	return TVE_get_dac_status(index);
+}
+
+__s32 BSP_disp_tv_set_dac_source(__u32 sel, __u32 index,
+				 __disp_tv_dac_source source)
+{
+	gdisp.screen[sel].dac_source[index] = source;
+
+	if (gdisp.screen[sel].status & TV_ON)
+		Disp_TVEC_DacCfg(sel, gdisp.screen[sel].tv_mode);
+
+	return 0;
+}
+
+__s32 BSP_disp_tv_get_dac_source(__u32 sel, __u32 index)
+{
+	return (__s32) gdisp.screen[sel].dac_source[index];
+}
+
+__s32 BSP_disp_tv_auto_check_enable(__u32 sel)
+{
+	TVE_dac_autocheck_enable(sel, 0);
+	TVE_dac_autocheck_enable(sel, 1);
+	TVE_dac_autocheck_enable(sel, 2);
+	TVE_dac_autocheck_enable(sel, 3);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_auto_check_disable(__u32 sel)
+{
+	TVE_dac_autocheck_disable(sel, 0);
+	TVE_dac_autocheck_disable(sel, 1);
+	TVE_dac_autocheck_disable(sel, 2);
+	TVE_dac_autocheck_disable(sel, 3);
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_tv_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+	switch (src) {
+	case DISP_LCDC_SRC_DE_CH1:
+		TCON1_select_src(sel, LCDC_SRC_DE1);
+		break;
+
+	case DISP_LCDC_SRC_DE_CH2:
+		TCON1_select_src(sel, LCDC_SRC_DE2);
+		break;
+
+	case DISP_LCDC_SRC_BLUT:
+		TCON1_select_src(sel, LCDC_SRC_BLUE);
+		break;
+
+	default:
+		DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n",
+		       src);
+		return DIS_NOT_SUPPORT;
+	}
+	return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_tv.h b/drivers/video/sunxi/disp/disp_tv.h
new file mode 100644
index 0000000..d986ed9
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_tv.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_TV_H__
+#define __DISP_TV_H__
+
+#include "disp_display_i.h"
+
+__s32 Disp_TVEC_Init(__u32 sel);
+__s32 Disp_TVEC_Exit(__u32 sel);
+__s32 Disp_TVEC_Open(__u32 sel);
+__s32 Disp_TVEC_Close(__u32 sel);
+__s32 Disp_Switch_Dram_Mode(__u32 type, __u8 tv_mod);
+__s32 Disp_TVEC_Event_Proc(void *parg);
+
+#endif
diff --git a/drivers/video/sunxi/disp/disp_ump.c b/drivers/video/sunxi/disp/disp_ump.c
new file mode 100644
index 0000000..85357a2
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_ump.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2012 Henrik Nordstrom <henrik@henriknordstrom.net>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+
+#ifndef CONFIG_FB_SUNXI_UMP
+#error This file should not be built without UMP enabled
+#endif
+
+#include <ump/ump_kernel_interface_ref_drv.h>
+
+#include "drv_disp_i.h"
+#include "dev_disp.h"
+#include "dev_fb.h"
+
+static int _disp_get_ump_secure_id(struct fb_info *info, fb_info_t *g_fbi,
+				   unsigned long arg, int buf)
+{
+	u32 __user *psecureid = (u32 __user *) arg;
+	int buf_len = info->fix.smem_len;
+	ump_secure_id secure_id;
+
+	/* need exactly two buffers and page aligned second buffer */
+	if (info->var.yres * 2 == info->var.yres_virtual && !(buf_len & 8191))
+		buf_len = buf_len >> 1;	/* divide by two */
+	else {
+		__wrn("UMP: Double-buffering not enabled");
+		if (buf == 2) /* GET_UMP_SECURE_ID_BUF2 */
+			buf_len = 0;
+	}
+
+	if (!g_fbi->ump_wrapped_buffer[info->node][buf]) {
+		ump_dd_physical_block ump_memory_description;
+
+		ump_memory_description.addr = info->fix.smem_start;
+		ump_memory_description.size = info->fix.smem_len;
+		if (buf > 0) {
+			ump_memory_description.addr += (buf_len * (buf - 1));
+			ump_memory_description.size = buf_len;
+		}
+		g_fbi->ump_wrapped_buffer[info->node][buf] =
+			ump_dd_handle_create_from_phys_blocks
+			(&ump_memory_description, 1);
+	}
+	secure_id = ump_dd_secure_id_get(g_fbi->
+					 ump_wrapped_buffer[info->node][buf]);
+	return put_user((unsigned int)secure_id, psecureid);
+}
+
+static int __init disp_ump_module_init(void)
+{
+	int ret = 0;
+
+	disp_get_ump_secure_id = _disp_get_ump_secure_id;
+
+	return ret;
+}
+
+static void __exit disp_ump_module_exit(void)
+{
+	disp_get_ump_secure_id = NULL;
+}
+
+module_init(disp_ump_module_init);
+module_exit(disp_ump_module_exit);
+
+MODULE_AUTHOR("Henrik Nordstrom <henrik@henriknordstrom.net>");
+MODULE_DESCRIPTION("sunxi display driver MALI UMP module glue");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/sunxi/disp/disp_vga.c b/drivers/video/sunxi/disp/disp_vga.c
new file mode 100644
index 0000000..a64ebce
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_vga.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_de.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_tv.h"
+#include "disp_lcd.h"
+#include "disp_clk.h"
+
+#ifdef UNUSED
+static __s32
+VGA_Init(void)
+{
+	gdisp.screen[0].vga_mode = DISP_VGA_H1024_V768;
+	gdisp.screen[1].vga_mode = DISP_VGA_H1024_V768;
+
+	return DIS_SUCCESS;
+}
+
+static __s32
+VGA_Exit(void)
+{
+	return DIS_SUCCESS;
+}
+#endif /* UNUSED */
+
+__s32 BSP_disp_vga_open(__u32 sel)
+{
+	if (!(gdisp.screen[sel].status & VGA_ON)) {
+		__disp_vga_mode_t vga_mode;
+		__u32 i = 0;
+
+		vga_mode = gdisp.screen[sel].vga_mode;
+
+		lcdc_clk_on(sel);
+		image_clk_on(sel);
+		/*
+		 * set image normal channel start bit , because every
+		 * de_clk_off( ) will reset this bit
+		 */
+		Image_open(sel);
+		tve_clk_on(sel);
+		disp_clk_cfg(sel, DISP_OUTPUT_TYPE_VGA, vga_mode);
+		Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 1);
+
+		BSP_disp_set_output_csc(sel, DISP_OUTPUT_TYPE_VGA,
+					gdisp.screen[sel].
+					iep_status & DRC_USED);
+		DE_BE_set_display_size(sel, vga_mode_to_width(vga_mode),
+				       vga_mode_to_height(vga_mode));
+		DE_BE_Output_Select(sel, sel);
+		TCON1_set_vga_mode(sel, vga_mode);
+		TVE_set_vga_mode(sel);
+
+		Disp_TVEC_Open(sel);
+		TCON1_open(sel);
+
+		if (!sunxi_is_sun5i()) {
+			for (i = 0; i < 4; i++) {
+				if (gdisp.screen[sel].dac_source[i] ==
+				    DISP_TV_DAC_SRC_COMPOSITE) {
+					TVE_dac_set_source(1 - sel, i,
+						   DISP_TV_DAC_SRC_COMPOSITE);
+					TVE_dac_sel(1 - sel, i, i);
+				}
+			}
+		}
+
+		Disp_Switch_Dram_Mode(DISP_OUTPUT_TYPE_VGA, vga_mode);
+
+		gdisp.screen[sel].b_out_interlace = 0;
+		gdisp.screen[sel].status |= VGA_ON;
+		gdisp.screen[sel].lcdc_status |= LCDC_TCON1_USED;
+		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
+		Display_set_fb_timing(sel);
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_close(__u32 sel)
+{
+	if (gdisp.screen[sel].status & VGA_ON) {
+		Image_close(sel);
+		TCON1_close(sel);
+		Disp_TVEC_Close(sel);
+
+		tve_clk_off(sel);
+		image_clk_off(sel);
+		lcdc_clk_off(sel);
+		Disp_lcdc_pin_cfg(sel, DISP_OUTPUT_TYPE_VGA, 0);
+
+		gdisp.screen[sel].b_out_interlace = 0;
+		gdisp.screen[sel].status &= ~VGA_ON;
+		gdisp.screen[sel].lcdc_status &= ~LCDC_TCON1_USED;
+		gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_NONE;
+		gdisp.screen[sel].pll_use_status &=
+			((gdisp.screen[sel].pll_use_status == VIDEO_PLL0_USED) ?
+			 ~VIDEO_PLL0_USED : ~VIDEO_PLL1_USED);
+	}
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_set_mode(__u32 sel, __disp_vga_mode_t mode)
+{
+	if ((mode >= DISP_VGA_MODE_NUM) || (mode == DISP_VGA_H1440_V900_RB) ||
+	    (mode == DISP_VGA_H1680_V1050_RB)) {
+		DE_WRN("unsupported vga mode:%d in BSP_disp_vga_set_mode\n",
+		       mode);
+		return DIS_FAIL;
+	}
+
+	gdisp.screen[sel].vga_mode = mode; /* save current mode */
+	gdisp.screen[sel].output_type = DISP_OUTPUT_TYPE_VGA;
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_vga_get_mode(__u32 sel)
+{
+	return gdisp.screen[sel].vga_mode;
+}
+
+__s32 BSP_disp_vga_set_src(__u32 sel, __disp_lcdc_src_t src)
+{
+	switch (src) {
+	case DISP_LCDC_SRC_DE_CH1:
+		TCON1_select_src(sel, LCDC_SRC_DE1);
+		break;
+
+	case DISP_LCDC_SRC_DE_CH2:
+		TCON1_select_src(sel, LCDC_SRC_DE2);
+		break;
+
+	case DISP_LCDC_SRC_BLUT:
+		TCON1_select_src(sel, LCDC_SRC_BLUE);
+		break;
+
+	default:
+		DE_WRN("not supported lcdc src:%d in BSP_disp_tv_set_src\n",
+		       src);
+		return DIS_NOT_SUPPORT;
+	}
+	return DIS_SUCCESS;
+}
diff --git a/drivers/video/sunxi/disp/disp_video.c b/drivers/video/sunxi/disp/disp_video.c
new file mode 100644
index 0000000..12bcfd1
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_video.c
@@ -0,0 +1,491 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "disp_video.h"
+#include "disp_display.h"
+#include "disp_event.h"
+#include "disp_scaler.h"
+#include "disp_de.h"
+
+frame_para_t g_video[2][4];
+
+static __s32 video_enhancement_start(__u32 sel, __u32 id)
+{
+	__u32 scaleuprate;
+	__u32 scaler_index;
+	__u32 gamma_tab[256] = {
+		0x00000000, 0x00010101, 0x00020202, 0x00030303, 0x00040404, 0x00050505, 0x00060606, 0x00070707,
+		0x00080808, 0x00090909, 0x000A0A0A, 0x000B0B0B, 0x000C0C0C, 0x000D0D0D, 0x000D0D0D, 0x000E0E0E,
+		0x000F0F0F, 0x00101010, 0x00111111, 0x00111111, 0x00121212, 0x00131313, 0x00141414, 0x00141414,
+		0x00151515, 0x00161616, 0x00161616, 0x00171717, 0x00181818, 0x00191919, 0x00191919, 0x001A1A1A,
+		0x001B1B1B, 0x001B1B1B, 0x001C1C1C, 0x001D1D1D, 0x001E1E1E, 0x001E1E1E, 0x001F1F1F, 0x00202020,
+		0x00212121, 0x00212121, 0x00222222, 0x00232323, 0x00242424, 0x00242424, 0x00252525, 0x00262626,
+		0x00272727, 0x00282828, 0x00292929, 0x00292929, 0x002A2A2A, 0x002B2B2B, 0x002C2C2C, 0x002D2D2D,
+		0x002E2E2E, 0x002F2F2F, 0x00303030, 0x00313131, 0x00313131, 0x00323232, 0x00333333, 0x00343434,
+		0x00353535, 0x00363636, 0x00373737, 0x00383838, 0x00393939, 0x003A3A3A, 0x003B3B3B, 0x003C3C3C,
+		0x003D3D3D, 0x003E3E3E, 0x003F3F3F, 0x00404040, 0x00414141, 0x00424242, 0x00434343, 0x00444444,
+		0x00454545, 0x00464646, 0x00474747, 0x00484848, 0x004A4A4A, 0x004B4B4B, 0x004C4C4C, 0x004D4D4D,
+		0x004E4E4E, 0x004F4F4F, 0x00505050, 0x00515151, 0x00525252, 0x00535353, 0x00555555, 0x00565656,
+		0x00575757, 0x00585858, 0x00595959, 0x005A5A5A, 0x005B5B5B, 0x005C5C5C, 0x005E5E5E, 0x005F5F5F,
+		0x00606060, 0x00616161, 0x00626262, 0x00636363, 0x00656565, 0x00666666, 0x00676767, 0x00686868,
+		0x00696969, 0x006B6B6B, 0x006C6C6C, 0x006D6D6D, 0x006E6E6E, 0x006F6F6F, 0x00717171, 0x00727272,
+		0x00737373, 0x00747474, 0x00757575, 0x00777777, 0x00787878, 0x00797979, 0x007A7A7A, 0x007B7B7B,
+		0x007D7D7D, 0x007E7E7E, 0x007F7F7F, 0x00808080, 0x00828282, 0x00838383, 0x00848484, 0x00858585,
+		0x00868686, 0x00888888, 0x00898989, 0x008A8A8A, 0x008B8B8B, 0x008D8D8D, 0x008E8E8E, 0x008F8F8F,
+		0x00909090, 0x00929292, 0x00939393, 0x00949494, 0x00959595, 0x00979797, 0x00989898, 0x00999999,
+		0x009A9A9A, 0x009B9B9B, 0x009D9D9D, 0x009E9E9E, 0x009F9F9F, 0x00A0A0A0, 0x00A2A2A2, 0x00A3A3A3,
+		0x00A4A4A4, 0x00A5A5A5, 0x00A6A6A6, 0x00A8A8A8, 0x00A9A9A9, 0x00AAAAAA, 0x00ABABAB, 0x00ACACAC,
+		0x00AEAEAE, 0x00AFAFAF, 0x00B0B0B0, 0x00B1B1B1, 0x00B2B2B2, 0x00B4B4B4, 0x00B5B5B5, 0x00B6B6B6,
+		0x00B7B7B7, 0x00B8B8B8, 0x00B9B9B9, 0x00BBBBBB, 0x00BCBCBC, 0x00BDBDBD, 0x00BEBEBE, 0x00BFBFBF,
+		0x00C0C0C0, 0x00C1C1C1, 0x00C3C3C3, 0x00C4C4C4, 0x00C5C5C5, 0x00C6C6C6, 0x00C7C7C7, 0x00C8C8C8,
+		0x00C9C9C9, 0x00CACACA, 0x00CBCBCB, 0x00CDCDCD, 0x00CECECE, 0x00CFCFCF, 0x00D0D0D0, 0x00D1D1D1,
+		0x00D2D2D2, 0x00D3D3D3, 0x00D4D4D4, 0x00D5D5D5, 0x00D6D6D6, 0x00D7D7D7, 0x00D8D8D8, 0x00D9D9D9,
+		0x00DADADA, 0x00DBDBDB, 0x00DCDCDC, 0x00DDDDDD, 0x00DEDEDE, 0x00DFDFDF, 0x00E0E0E0, 0x00E1E1E1,
+		0x00E2E2E2, 0x00E3E3E3, 0x00E4E4E4, 0x00E5E5E5, 0x00E5E5E5, 0x00E6E6E6, 0x00E7E7E7, 0x00E8E8E8,
+		0x00E9E9E9, 0x00EAEAEA, 0x00EBEBEB, 0x00ECECEC, 0x00ECECEC, 0x00EDEDED, 0x00EEEEEE, 0x00EFEFEF,
+		0x00F0F0F0, 0x00F0F0F0, 0x00F1F1F1, 0x00F2F2F2, 0x00F3F3F3, 0x00F3F3F3, 0x00F4F4F4, 0x00F5F5F5,
+		0x00F6F6F6, 0x00F6F6F6, 0x00F7F7F7, 0x00F8F8F8, 0x00F8F8F8, 0x00F9F9F9, 0x00FAFAFA, 0x00FAFAFA,
+		0x00FBFBFB, 0x00FCFCFC, 0x00FCFCFC, 0x00FDFDFD, 0x00FDFDFD, 0x00FEFEFE, 0x00FEFEFE, 0x00FFFFFF
+	};
+
+	if (sunxi_is_sun5i())
+		return 0;
+
+	/* !!! assume open HDMI before video start */
+	if (gdisp.screen[sel].output_type == DISP_OUTPUT_TYPE_HDMI) {
+		scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
+		scaleuprate =
+			gdisp.screen[sel].layer_manage[id].para.scn_win.width *
+			2 /
+			gdisp.screen[sel].layer_manage[id].para.src_win.width;
+
+		switch (scaleuprate) {
+		case 0:	/* scale down, do noting */
+			DE_SCAL_Vpp_Enable(scaler_index, 0);
+			DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
+			break;
+		case 1:
+			DE_SCAL_Vpp_Enable(scaler_index, 1);
+			DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 1);
+			break;
+		case 2:
+			DE_SCAL_Vpp_Enable(scaler_index, 1);
+			DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 2);
+			break;
+		case 3:
+			DE_SCAL_Vpp_Enable(scaler_index, 1);
+			DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 3);
+			break;
+		default:
+			DE_SCAL_Vpp_Enable(scaler_index, 1);
+			DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 4);
+			break;
+		}
+
+		TCON1_set_gamma_Enable(sel, 1);
+		TCON1_set_gamma_table(sel, (__u32) gamma_tab, 1024);
+
+		gdisp.screen[sel].layer_manage[id].video_enhancement_en = 1;
+	}
+
+	return 0;
+}
+
+static __s32 video_enhancement_stop(__u32 sel, __u32 id)
+{
+	__u32 scaler_index;
+
+	if (sunxi_is_sun5i())
+		return 0;
+
+	if (gdisp.screen[sel].layer_manage[id].video_enhancement_en) {
+		scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
+
+		DE_SCAL_Vpp_Enable(scaler_index, 0);
+		DE_SCAL_Vpp_Set_Luma_Sharpness_Level(scaler_index, 0);
+
+		if (gdisp.screen[sel].output_type != DISP_OUTPUT_TYPE_LCD)
+			TCON1_set_gamma_Enable(sel, 0);
+
+		gdisp.screen[sel].layer_manage[id].video_enhancement_en = 0;
+	}
+
+	return 0;
+}
+
+static inline __s32 Hal_Set_Frame(__u32 sel, __u32 tcon_index, __u32 id)
+{
+	__u32 cur_line = 0, start_delay = 0;
+
+	cur_line = LCDC_get_cur_line(sel, tcon_index);
+	start_delay = LCDC_get_start_delay(sel, tcon_index);
+	if (cur_line > start_delay - 5) {
+#if 0
+		DE_INF("cur_line(%d) >= start_delay(%d)-3 in Hal_Set_Frame\n",
+		       cur_line, start_delay);
+#endif
+		return DIS_FAIL;
+	}
+
+	if (g_video[sel][id].display_cnt == 0) {
+		g_video[sel][id].pre_frame_addr0 =
+		    g_video[sel][id].video_cur.addr[0];
+		memcpy(&g_video[sel][id].video_cur, &g_video[sel][id].video_new,
+		       sizeof(__disp_video_fb_t));
+	}
+
+	if (gdisp.screen[sel].layer_manage[id].para.mode ==
+	    DISP_LAYER_WORK_MODE_SCALER) {
+		__u32 status, scaler_index;
+		__scal_buf_addr_t scal_addr;
+		__scal_src_size_t in_size;
+		__scal_out_size_t out_size;
+		__scal_src_type_t in_type;
+		__scal_out_type_t out_type;
+		__scal_scan_mod_t in_scan;
+		__scal_scan_mod_t out_scan;
+		__disp_scaler_t *scaler;
+		__u32 pre_frame_addr = 0;
+		__u32 maf_flag_addr = 0;
+		__u32 maf_linestride = 0;
+
+		scaler_index = gdisp.screen[sel].layer_manage[id].scaler_index;
+
+		scaler = &(gdisp.scaler[scaler_index]);
+
+		if (g_video[sel][id].video_cur.interlace == TRUE) {
+			if ((!sunxi_is_sun5i()) &&
+			    (!(gdisp.screen[sel].de_flicker_status &
+			       DE_FLICKER_USED)) &&
+			    (scaler->in_fb.format == DISP_FORMAT_YUV420 &&
+			     scaler->in_fb.mode == DISP_MOD_MB_UV_COMBINED))
+				g_video[sel][id].dit_enable = TRUE;
+			else
+				g_video[sel][id].dit_enable = FALSE;
+
+			if (!sunxi_is_sun5i())
+				g_video[sel][id].fetch_field = FALSE;
+			else
+				g_video[sel][id].fetch_field = TRUE;
+
+			if (g_video[sel][id].display_cnt == 0) {
+				g_video[sel][id].fetch_bot =
+					(g_video[sel][id].video_cur.
+					 top_field_first) ? 0 : 1;
+			} else {
+				g_video[sel][id].fetch_bot =
+					(g_video[sel][id].video_cur.
+					 top_field_first) ? 1 : 0;
+			}
+
+			if (g_video[sel][id].dit_enable == TRUE) {
+				if (g_video[sel][id].video_cur.maf_valid ==
+				    TRUE) {
+					g_video[sel][id].dit_mode =
+						DIT_MODE_MAF;
+					maf_flag_addr =
+						g_video[sel][id].video_cur.
+						flag_addr;
+					maf_linestride =
+						g_video[sel][id].video_cur.
+						flag_stride;
+				} else {
+					g_video[sel][id].dit_mode =
+						DIT_MODE_MAF_BOB;
+				}
+
+				if (g_video[sel][id].video_cur.
+				    pre_frame_valid == TRUE) {
+					g_video[sel][id].tempdiff_en = TRUE;
+					pre_frame_addr = g_video[sel][id].
+						pre_frame_addr0;
+				} else {
+					g_video[sel][id].tempdiff_en = FALSE;
+				}
+				g_video[sel][id].diagintp_en = TRUE;
+				if (sunxi_is_sun5i()) {
+					g_video[sel][id].fetch_field = FALSE;	//todo
+					g_video[sel][id].fetch_bot = 0;	//todo
+					// todo
+					g_video[sel][id].dit_mode = DIT_MODE_MAF_BOB;
+					g_video[sel][id].diagintp_en = FALSE;	//todo
+				}
+				g_video[sel][id].tempdiff_en = FALSE;	//todo
+			} else {
+				if (sunxi_is_sun5i())
+					g_video[sel][id].fetch_bot = FALSE;
+				g_video[sel][id].dit_mode = DIT_MODE_WEAVE;
+				g_video[sel][id].tempdiff_en = FALSE;
+				g_video[sel][id].diagintp_en = FALSE;
+			}
+		} else {
+			g_video[sel][id].dit_enable = FALSE;
+			g_video[sel][id].fetch_field = FALSE;
+			g_video[sel][id].fetch_bot = FALSE;
+			g_video[sel][id].dit_mode = DIT_MODE_WEAVE;
+			g_video[sel][id].tempdiff_en = FALSE;
+			g_video[sel][id].diagintp_en = FALSE;
+		}
+
+		in_type.fmt = Scaler_sw_para_to_reg1(scaler->in_fb.format);
+		in_type.mod = scaler->in_fb.mode;
+		in_type.ps = Scaler_sw_para_to_reg3(scaler->in_fb.seq);
+		in_type.byte_seq = 0;
+		in_type.sample_method = 0;
+
+		scal_addr.ch0_addr = g_video[sel][id].video_cur.addr[0];
+		scal_addr.ch1_addr = g_video[sel][id].video_cur.addr[1];
+		scal_addr.ch2_addr = g_video[sel][id].video_cur.addr[2];
+
+		in_size.src_width = scaler->in_fb.size.width;
+		in_size.src_height = scaler->in_fb.size.height;
+		in_size.x_off = scaler->src_win.x;
+		in_size.y_off = scaler->src_win.y;
+		in_size.scal_height = scaler->src_win.height;
+		in_size.scal_width = scaler->src_win.width;
+
+		out_type.byte_seq = scaler->out_fb.seq;
+		out_type.fmt = Scaler_sw_para_to_reg4(scaler->out_fb.format);
+
+		out_size.width = scaler->out_size.width;
+		out_size.height = scaler->out_size.height;
+
+		in_scan.field = g_video[sel][id].fetch_field;
+		in_scan.bottom = g_video[sel][id].fetch_bot;
+
+		if (sunxi_is_sun5i())
+			status = gdisp.screen[sel].iep_status;
+		else
+			status = gdisp.screen[sel].de_flicker_status;
+
+		out_scan.field = (status & DE_FLICKER_USED) ?
+			FALSE : gdisp.screen[sel].b_out_interlace;
+
+		if (scaler->out_fb.cs_mode > DISP_VXYCC)
+			scaler->out_fb.cs_mode = DISP_BT601;
+
+		if (scaler->in_fb.b_trd_src) {
+			__scal_3d_inmode_t inmode;
+			__scal_3d_outmode_t outmode = 0;
+			__scal_buf_addr_t scal_addr_right;
+
+			inmode =
+				Scaler_3d_sw_para_to_reg(0,
+							 scaler->in_fb.trd_mode,
+							 0);
+			outmode =
+				Scaler_3d_sw_para_to_reg(1,
+							 scaler->out_trd_mode,
+							 gdisp.screen[sel].
+							 b_out_interlace);
+
+			DE_SCAL_Get_3D_In_Single_Size(inmode, &in_size,
+						      &in_size);
+			if (scaler->b_trd_out) {
+				DE_SCAL_Get_3D_Out_Single_Size(outmode,
+							       &out_size,
+							       &out_size);
+			}
+
+			scal_addr_right.ch0_addr =
+				g_video[sel][id].video_cur.addr_right[0];
+			scal_addr_right.ch1_addr =
+				g_video[sel][id].video_cur.addr_right[1];
+			scal_addr_right.ch2_addr =
+				g_video[sel][id].video_cur.addr_right[2];
+
+			DE_SCAL_Set_3D_Ctrl(scaler_index, scaler->b_trd_out,
+					    inmode, outmode);
+			DE_SCAL_Config_3D_Src(scaler_index, &scal_addr,
+					      &in_size, &in_type, inmode,
+					      &scal_addr_right);
+		} else {
+			DE_SCAL_Config_Src(scaler_index, &scal_addr, &in_size,
+					   &in_type, FALSE, FALSE);
+		}
+
+		DE_SCAL_Set_Init_Phase(scaler_index, &in_scan, &in_size,
+				       &in_type, &out_scan, &out_size,
+				       &out_type, g_video[sel][id].dit_enable);
+		DE_SCAL_Set_Scaling_Factor(scaler_index, &in_scan, &in_size,
+					   &in_type, &out_scan, &out_size,
+					   &out_type);
+		DE_SCAL_Set_Scaling_Coef(scaler_index, &in_scan, &in_size,
+					 &in_type, &out_scan, &out_size,
+					 &out_type, scaler->smooth_mode);
+		DE_SCAL_Set_Out_Size(scaler_index, &out_scan, &out_type,
+				     &out_size);
+		DE_SCAL_Set_Di_Ctrl(scaler_index, g_video[sel][id].dit_enable,
+				    g_video[sel][id].dit_mode,
+				    g_video[sel][id].diagintp_en,
+				    g_video[sel][id].tempdiff_en);
+		DE_SCAL_Set_Di_PreFrame_Addr(scaler_index, pre_frame_addr);
+		DE_SCAL_Set_Di_MafFlag_Src(scaler_index, maf_flag_addr,
+					   maf_linestride);
+
+		DE_SCAL_Set_Reg_Rdy(scaler_index);
+	} else {
+		__layer_man_t *layer_man;
+		__disp_fb_t fb;
+		layer_src_t layer_fb;
+
+		layer_man = &gdisp.screen[sel].layer_manage[id];
+
+		BSP_disp_layer_get_framebuffer(sel, id, &fb);
+		fb.addr[0] = g_video[sel][id].video_cur.addr[0];
+		fb.addr[1] = g_video[sel][id].video_cur.addr[1];
+		fb.addr[2] = g_video[sel][id].video_cur.addr[2];
+
+		if (get_fb_type(fb.format) == DISP_FB_TYPE_YUV) {
+			Yuv_Channel_adjusting(sel, fb.mode, fb.format,
+					      &layer_man->para.src_win.x,
+					      &layer_man->para.scn_win.width);
+			Yuv_Channel_Set_framebuffer(sel, &fb,
+						    layer_man->para.src_win.x,
+						    layer_man->para.src_win.y);
+		} else {
+			layer_fb.fb_addr = fb.addr[0];
+			layer_fb.pixseq = img_sw_para_to_reg(3, 0, fb.seq);
+			layer_fb.br_swap = fb.br_swap;
+			layer_fb.fb_width = fb.size.width;
+			layer_fb.offset_x = layer_man->para.src_win.x;
+			layer_fb.offset_y = layer_man->para.src_win.y;
+			layer_fb.format = fb.format;
+			DE_BE_Layer_Set_Framebuffer(sel, id, &layer_fb);
+		}
+	}
+
+	g_video[sel][id].display_cnt++;
+	gdisp.screen[sel].layer_manage[id].para.fb.addr[0] =
+		g_video[sel][id].video_cur.addr[0];
+	gdisp.screen[sel].layer_manage[id].para.fb.addr[1] =
+		g_video[sel][id].video_cur.addr[1];
+	gdisp.screen[sel].layer_manage[id].para.fb.addr[2] =
+		g_video[sel][id].video_cur.addr[2];
+	gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[0] =
+		g_video[sel][id].video_cur.addr_right[0];
+	gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[1] =
+		g_video[sel][id].video_cur.addr_right[1];
+	gdisp.screen[sel].layer_manage[id].para.fb.trd_right_addr[2] =
+		g_video[sel][id].video_cur.addr_right[2];
+	return DIS_SUCCESS;
+}
+
+__s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index)
+{
+	__u32 id = 0;
+
+	for (id = 0; id < 4; id++) {
+		if ((g_video[sel][id].enable == TRUE) &&
+		    (g_video[sel][id].have_got_frame == TRUE)) {
+			Hal_Set_Frame(sel, tcon_index, id);
+		}
+	}
+
+	return DIS_SUCCESS;
+}
+
+__s32 BSP_disp_video_set_fb(__u32 sel, __u32 hid, __disp_video_fb_t *in_addr)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (g_video[sel][hid].enable) {
+		memcpy(&g_video[sel][hid].video_new, in_addr,
+		       sizeof(__disp_video_fb_t));
+		g_video[sel][hid].have_got_frame = TRUE;
+		g_video[sel][hid].display_cnt = 0;
+
+		return DIS_SUCCESS;
+	} else
+		return DIS_FAIL;
+}
+
+/*
+ * get the current displaying frame id
+ */
+__s32 BSP_disp_video_get_frame_id(__u32 sel, __u32 hid)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (g_video[sel][hid].enable) {
+		if (g_video[sel][hid].have_got_frame == TRUE)
+			return g_video[sel][hid].video_cur.id;
+		else
+			return DIS_FAIL;
+	} else
+		return DIS_FAIL;
+}
+
+__s32 BSP_disp_video_get_dit_info(__u32 sel, __u32 hid,
+				  __disp_dit_info_t *dit_info)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (g_video[sel][hid].enable) {
+		dit_info->maf_enable = FALSE;
+		dit_info->pre_frame_enable = FALSE;
+
+		if (g_video[sel][hid].dit_enable) {
+			if (g_video[sel][hid].dit_mode == DIT_MODE_MAF)
+				dit_info->maf_enable = TRUE;
+
+			if (g_video[sel][hid].tempdiff_en)
+				dit_info->pre_frame_enable = TRUE;
+		}
+		return DIS_SUCCESS;
+	} else
+		return DIS_FAIL;
+}
+
+__s32 BSP_disp_video_start(__u32 sel, __u32 hid)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (gdisp.screen[sel].layer_manage[hid].status & LAYER_USED) {
+		memset(&g_video[sel][hid], 0, sizeof(frame_para_t));
+		g_video[sel][hid].video_cur.id = -1;
+		g_video[sel][hid].enable = TRUE;
+
+		video_enhancement_start(sel, hid);
+
+		return DIS_SUCCESS;
+	} else {
+		return DIS_FAIL;
+	}
+}
+
+__s32 BSP_disp_video_stop(__u32 sel, __u32 hid)
+{
+	hid = HANDTOID(hid);
+	HLID_ASSERT(hid, gdisp.screen[sel].max_layers);
+
+	if (g_video[sel][hid].enable) {
+		memset(&g_video[sel][hid], 0, sizeof(frame_para_t));
+
+		video_enhancement_stop(sel, hid);
+
+		return DIS_SUCCESS;
+	} else {
+		return DIS_FAIL;
+	}
+}
diff --git a/drivers/video/sunxi/disp/disp_video.h b/drivers/video/sunxi/disp/disp_video.h
new file mode 100644
index 0000000..c6fe146
--- /dev/null
+++ b/drivers/video/sunxi/disp/disp_video.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DISP_VIDEO_H_
+#define __DISP_VIDEO_H_
+
+#include "disp_display_i.h"
+
+#define CASE_P_SOURCE 0
+#define CASE_I_SAME_FRAME_RATE 1
+#define CASE_I_DIFF_FRAME_RATE 2
+
+typedef enum {
+	DIT_MODE_WEAVE = 0,
+	DIT_MODE_BOB = 1,
+	DIT_MODE_MAF = 2,
+	DIT_MODE_MAF_BOB = 3,
+} dit_mode_t;
+
+typedef struct frame_para {
+	__bool enable;
+
+	__disp_video_fb_t video_cur;
+	__disp_video_fb_t video_new;
+	__u32 pre_frame_addr0;
+
+	__bool have_got_frame;
+	__bool fetch_field; /* for scaler */
+	__bool fetch_bot; /* for dit if dit enable,else for scaler */
+	__u32 display_cnt;
+	__bool out_field;
+	__bool out_bot;
+	__bool dit_enable;
+	dit_mode_t dit_mode;
+	__bool tempdiff_en;
+	__bool diagintp_en;
+
+} frame_para_t;
+
+typedef struct tv_mode_info {
+	__u8 id;
+	__s32 width;
+	__s32 height;
+	__bool interlace;
+	__s32 frame_rate;
+	__s32 vb_line;
+} tv_mode_info_t;
+
+__s32 Video_Operation_In_Vblanking(__u32 sel, __u32 tcon_index);
+extern frame_para_t g_video[2][4];
+
+#endif
diff --git a/drivers/video/sunxi/disp/drv_disp_i.h b/drivers/video/sunxi/disp/drv_disp_i.h
new file mode 100644
index 0000000..b339aeb
--- /dev/null
+++ b/drivers/video/sunxi/disp/drv_disp_i.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DRV_DISP_I_H__
+#define __DRV_DISP_I_H__
+
+#include "bsp_display.h"
+
+typedef enum {
+	DIS_SUCCESS = 0,
+	DIS_FAIL = -1,
+	DIS_PARA_FAILED = -2,
+	DIS_PRIO_ERROR = -3,
+	DIS_OBJ_NOT_INITED = -4,
+	DIS_NOT_SUPPORT = -5,
+	DIS_NO_RES = -6,
+	DIS_OBJ_COLLISION = -7,
+	DIS_DEV_NOT_INITED = -8,
+	DIS_DEV_SRAM_COLLISION = -9,
+	DIS_TASK_ERROR = -10,
+	DIS_PRIO_COLLSION = -11
+} __disp_return_value;
+
+#define HANDTOID(handle)  ((handle) - 100)
+#define IDTOHAND(ID)  ((ID) + 100)
+
+#define DISP_IO_NUM	9
+
+#define DISP_IO_SCALER0	0
+#define DISP_IO_SCALER1	1
+#define DISP_IO_IMAGE0	2
+#define DISP_IO_IMAGE1	3
+#define DISP_IO_LCDC0	4
+#define DISP_IO_LCDC1	5
+#define DISP_IO_TVEC0	6
+#define DISP_IO_TVEC1	7
+#define DISP_IO_IEP	8
+
+#endif
diff --git a/drivers/video/sunxi/disp/ebios_de.h b/drivers/video/sunxi/disp/ebios_de.h
new file mode 100644
index 0000000..7697c21
--- /dev/null
+++ b/drivers/video/sunxi/disp/ebios_de.h
@@ -0,0 +1,388 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __EBIOS_DE_H__
+#define __EBIOS_DE_H__
+
+#include "bsp_display.h"
+
+#define DE_WB_END_IE		(1<<7)	/* write back end interrupt */
+#define DE_FE_INTEN_ALL         0x1ff	/* front-end all interrupt enable */
+#define DE_IMG_REG_LOAD_FINISH  (1<<1)
+
+/* sync reach flag when capture in process */
+#define SCAL_WB_ERR_SYNC (1<<15)
+/* lose data flag when capture in process */
+#define SCAL_WB_ERR_LOSEDATA (1<<14)
+/* unvalid write back */
+#define SCAL_WB_ERR_STATUS (1<<12)
+
+/* internal layer framebuffer format enum definition */
+typedef enum {
+	DE_IF1BPP = 0,
+	DE_IF2BPP,
+	DE_IF4BPP,
+	DE_IF8BPP
+} de_inter_fbfmt_e;
+
+typedef enum {
+	DE_N32PIXELS = 0,
+	DE_N64PIXELS
+} de_pixels_num_t;
+
+typedef enum {
+	DE_RGB,
+	DE_YUV_TV,
+	DE_YUV_HDMI
+} __csc_t;
+
+typedef enum __SCAL_PS {
+	DE_SCAL_BGRA = 0,	/* rgb */
+	DE_SCAL_ARGB = 1,
+	DE_SCAL_AYUV = 0,
+	DE_SCAL_VUYA = 1,
+	DE_SCAL_UVUV = 0,	/* for uv combined */
+	DE_SCAL_VUVU = 1,
+	DE_SCAL_UYVY = 0,
+	DE_SCAL_YUYV = 1,
+	DE_SCAL_VYUY = 2,
+	DE_SCAL_YVYU = 3,
+} __scal_ps_t;
+
+typedef enum __SCAL_INFMT {
+	DE_SCAL_INYUV444 = 0,
+	DE_SCAL_INYUV422,
+	DE_SCAL_INYUV420,
+	DE_SCAL_INYUV411,
+	DE_SCAL_INCSIRGB,
+	DE_SCAL_INRGB888
+} __scal_infmt_t;
+
+typedef enum __SCAL_OUTFMT {
+	DE_SCAL_OUTPRGB888 = 0,
+	DE_SCAL_OUTI0RGB888,
+	DE_SCAL_OUTI1RGB888,
+	DE_SCAL_OUTPYUV444 = 4,
+	DE_SCAL_OUTPYUV420,
+	DE_SCAL_OUTPYUV422,
+	DE_SCAL_OUTPYUV411
+} __scal_outfmt_t;
+
+/*
+ * for 3D inmod,  source mod must  be DE_SCAL_PLANNAR or DE_SCAL_UVCOMBINEDMB
+ * DE_SCAL_INTER_LEAVED and DE_SCAL_UVCOMBINED maybe supported in future.
+ */
+typedef enum __SCAL_3D_INMODE {
+	DE_SCAL_3DIN_TB = 0,
+	DE_SCAL_3DIN_FP = 1,
+	DE_SCAL_3DIN_SSF = 2,
+	DE_SCAL_3DIN_SSH = 3,
+	DE_SCAL_3DIN_LI = 4,
+} __scal_3d_inmode_t;
+
+typedef enum __SCAL_3D_OUTMODE {
+	DE_SCAL_3DOUT_CI_1 = 0,	/* for lcd */
+	DE_SCAL_3DOUT_CI_2,
+	DE_SCAL_3DOUT_CI_3,
+	DE_SCAL_3DOUT_CI_4,
+	DE_SCAL_3DOUT_LIRGB,
+	DE_SCAL_3DOUT_HDMI_FPP,	/* for hdmi */
+	DE_SCAL_3DOUT_HDMI_FPI,
+	DE_SCAL_3DOUT_HDMI_TB,
+	DE_SCAL_3DOUT_HDMI_FA,
+	DE_SCAL_3DOUT_HDMI_SSH,
+	DE_SCAL_3DOUT_HDMI_SSF,
+	DE_SCAL_3DOUT_HDMI_LI,
+} __scal_3d_outmode_t;
+
+typedef struct layer_input_src {
+	__disp_pixel_fmt_t format;
+	__u8 pixseq;
+	__u8 br_swap;
+	__u32 fb_width;
+	__u32 fb_addr;
+	__u32 offset_x;
+	__u32 offset_y;
+
+	__bool yuv_ch;
+} layer_src_t;
+
+typedef struct yuv_ch_src {
+	__u8 format;
+	__disp_pixel_mod_t mode;
+	__u8 pixseq;
+	__u32 ch0_base;		/* in bits */
+	__u32 ch1_base;		/* in bits */
+	__u32 ch2_base;		/* in bits */
+	__u32 line_width;	/* in bits */
+	__u32 offset_x;
+	__u32 offset_y;
+
+	/*
+	 * 0: DISP_BT601
+	 * 1: DISP_BT709
+	 * 2: DISP_YCC
+	 * 3: DISP_VXYCC
+	 */
+	__disp_cs_mode_t cs_mode;
+} de_yuv_ch_src_t;
+
+typedef struct __SCAL_SRC_TYPE {
+	/*
+	 * for yuv420, 0: uv_hphase=-0.25, uv_vphase=-0.25;
+	 * other : uv_hphase = 0, uv_vphase = -0.25
+	 */
+	__u8 sample_method;
+
+	/*
+	 * 0: byte0, byte1, byte2, byte3;
+	 * 1: byte3, byte2, byte1, byte0
+	 */
+	__u8 byte_seq;
+
+	/*
+	 * 0: planar
+	 * 1: interleaved
+	 * 2: planar uv combined
+	 * 4: planar mb
+	 * 6: uv combined mb
+	 */
+	__disp_pixel_mod_t mod;
+
+	/*
+	 * 0: yuv444
+	 * 1: yuv422
+	 * 2: yuv420
+	 * 3: yuv411
+	 * 4: csi rgb
+	 * 5: rgb888
+	 */
+	__scal_infmt_t fmt;
+	__scal_ps_t ps;
+} __scal_src_type_t;
+
+typedef struct __SCAL_OUT_TYPE {
+	/*
+	 * 0: byte0, byte1, byte2, byte3;
+	 * 1: byte3, byte2, byte1, byte0
+	 */
+	__u8 byte_seq;
+
+	/*
+	 * 0:plannar rgb;
+	 * 1: argb(byte0,byte1, byte2, byte3);
+	 * 2:bgra; 4:yuv444; 5:yuv420; 6:yuv422; 7:yuv411
+	 */
+	__scal_outfmt_t fmt;
+} __scal_out_type_t;
+
+typedef struct __SCAL_SRC_SIZE {
+	__u32 src_width;
+	__u32 src_height;
+	__u32 x_off;
+	__u32 y_off;
+	__u32 scal_width;
+	__u32 scal_height;
+} __scal_src_size_t;
+
+typedef struct __SCAL_OUT_SIZE {
+	__u32 width;
+	/*
+	 * when ouput interlace enable,  the height is the 2x height of scale,
+	 * for example, ouput is 480i, this value is 480
+	 */
+	__u32 height;
+} __scal_out_size_t;
+
+typedef struct _SCAL_BUF_ADDR {
+	__u32 ch0_addr;
+	__u32 ch1_addr;
+	__u32 ch2_addr;
+} __scal_buf_addr_t;
+
+typedef struct _SCAL_SCAN_MOD {
+	__u8 field; /* 0:frame scan; 1:field scan */
+	__u8 bottom; /* 0:top field; 1:bottom field */
+} __scal_scan_mod_t;
+
+__s32 DE_SCAL_Set_Reg_Base(__u8 sel, __u32 base);
+__u32 DE_SCAL_Get_Reg_Base(__u8 sel);
+__s32 DE_SCAL_Config_Src(__u8 sel, __scal_buf_addr_t *addr,
+			 __scal_src_size_t *size, __scal_src_type_t *type,
+			 __u8 field, __u8 dien);
+__s32 DE_SCAL_Set_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr);
+__s32 DE_SCAL_Set_Init_Phase(__u8 sel, __scal_scan_mod_t *in_scan,
+			     __scal_src_size_t *in_size,
+			     __scal_src_type_t *in_type,
+			     __scal_scan_mod_t *out_scan,
+			     __scal_out_size_t *out_size,
+			     __scal_out_type_t *out_type, __u8 dien);
+__s32 DE_SCAL_Set_Scaling_Factor(__u8 sel, __scal_scan_mod_t *in_scan,
+				 __scal_src_size_t *in_size,
+				 __scal_src_type_t *in_type,
+				 __scal_scan_mod_t *out_scan,
+				 __scal_out_size_t *out_size,
+				 __scal_out_type_t *out_type);
+__s32 DE_SCAL_Set_Scaling_Coef(__u8 sel, __scal_scan_mod_t *in_scan,
+			       __scal_src_size_t *in_size,
+			       __scal_src_type_t *in_type,
+			       __scal_scan_mod_t *out_scan,
+			       __scal_out_size_t *out_size,
+			       __scal_out_type_t *out_type, __u32 smth_mode);
+__s32 DE_SCAL_Set_CSC_Coef(__u8 sel, __u8 in_csc_mode, __u8 out_csc_mode,
+			   __u8 incs, __u8 outcs, __u32 in_br_swap,
+			   __u32 out_br_swap);
+__s32 DE_SCAL_Set_Out_Format(__u8 sel, __scal_out_type_t *out_type);
+__s32 DE_SCAL_Set_Out_Size(__u8 sel, __scal_scan_mod_t *out_scan,
+			   __scal_out_type_t *out_type,
+			   __scal_out_size_t *out_size);
+__s32 DE_SCAL_Set_Trig_Line(__u8 sel, __u32 line);
+__s32 DE_SCAL_Set_Int_En(__u8 sel, __u32 int_num);
+__s32 DE_SCAL_Set_Di_Ctrl(__u8 sel, __u8 en, __u8 mode, __u8 diagintp_en,
+			  __u8 tempdiff_en);
+__s32 DE_SCAL_Set_Di_PreFrame_Addr(__u8 sel, __u32 addr);
+__s32 DE_SCAL_Set_Di_MafFlag_Src(__u8 sel, __u32 addr, __u32 stride);
+__s32 DE_SCAL_Set_Filtercoef_Ready(__u8 sel);
+__s32 DE_SCAL_Output_Select(__u8 sel, __u8 out);
+__s32 DE_SCAL_Writeback_Enable(__u8 sel);
+__s32 DE_SCAL_Writeback_Disable(__u8 sel);
+__s32 DE_SCAL_Set_Writeback_Addr(__u8 sel, __scal_buf_addr_t *addr);
+__s32 DE_SCAL_Set_Writeback_Chnl(__u8 sel, __u32 channel);
+__s32 DE_SCAL_Set_CSC_Coef_Enhance(__u8 sel, __u8 in_csc_mode,
+				   __u8 out_csc_mode, __u8 incs, __u8 outcs,
+				   __s32 bright, __s32 contrast,
+				   __s32 saturation, __s32 hue,
+				   __u32 in_br_swap, __u32 out_br_swap);
+__s32 DE_SCAL_Get_3D_In_Single_Size(__scal_3d_inmode_t inmode,
+				    __scal_src_size_t *fullsize,
+				    __scal_src_size_t *singlesize);
+__s32 DE_SCAL_Get_3D_Out_Single_Size(__scal_3d_outmode_t outmode,
+				     __scal_out_size_t *singlesize,
+				     __scal_out_size_t *fullsize);
+__s32 DE_SCAL_Get_3D_Out_Full_Size(__scal_3d_outmode_t outmode,
+				   __scal_out_size_t *singlesize,
+				   __scal_out_size_t *fullsize);
+__s32 DE_SCAL_Set_3D_Fb_Addr(__u8 sel, __scal_buf_addr_t *addr,
+			     __scal_buf_addr_t *addrtrd);
+__s32 DE_SCAL_Set_3D_Ctrl(__u8 sel, __u8 trden, __scal_3d_inmode_t inmode,
+			  __scal_3d_outmode_t outmode);
+__s32 DE_SCAL_Config_3D_Src(__u8 sel, __scal_buf_addr_t *addr,
+			    __scal_src_size_t *size, __scal_src_type_t *type,
+			    __scal_3d_inmode_t trdinmode,
+			    __scal_buf_addr_t *addrtrd);
+__s32 DE_SCAL_Input_Port_Select(__u8 sel, __u8 port);
+
+__s32 DE_SCAL_Vpp_Enable(__u8 sel, __u32 enable);
+__s32 DE_SCAL_Vpp_Set_Luma_Sharpness_Level(__u8 sel, __u32 level);
+__s32 DE_SCAL_Vpp_Set_Chroma_Sharpness_Level(__u8 sel, __u32 level);
+__s32 DE_SCAL_Vpp_Set_White_Level_Extension(__u8 sel, __u32 level);
+__s32 DE_SCAL_Vpp_Set_Black_Level_Extension(__u8 sel, __u32 level);
+__s32 DE_SCAL_Reset(__u8 sel);
+__s32 DE_SCAL_Start(__u8 sel);
+__s32 DE_SCAL_Set_Reg_Rdy(__u8 sel);
+__s32 DE_SCAL_Enable(__u8 sel);
+__s32 DE_SCAL_Disable(__u8 sel);
+__s32 DE_SCAL_Get_Field_Status(__u8 sel);
+__s32 DE_SCAL_EnableINT(__u8 sel, __u32 irqsrc);
+__s32 DE_SCAL_DisableINT(__u8 sel, __u32 irqsrc);
+__u32 DE_SCAL_QueryINT(__u8 sel);
+__u32 DE_SCAL_ClearINT(__u8 sel, __u32 irqsrc);
+__s32 DE_SCAL_Input_Select(__u8 sel, __u32 source);
+
+__s32 DE_Set_Reg_Base(__u32 sel, __u32 address);
+__u32 DE_Get_Reg_Base(__u32 sel);
+__u32 DE_BE_Reg_Init(__u32 sel);
+__s32 DE_BE_Enable(__u32 sel);
+__s32 DE_BE_Disable(__u32 sel);
+__s32 DE_BE_Output_Select(__u32 sel, __u32 out_sel);
+__s32 DE_BE_Set_BkColor(__u32 sel, __disp_color_t bkcolor);
+__s32 DE_BE_Set_ColorKey(__u32 sel, __disp_color_t ck_max,
+			 __disp_color_t ck_min, __u32 ck_red_match,
+			 __u32 ck_green_match, __u32 ck_blue_match);
+__s32 DE_BE_Set_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,
+			      __u32 size);
+__s32 DE_BE_Get_SystemPalette(__u32 sel, __u32 *pbuffer, __u32 offset,
+			      __u32 size);
+__s32 DE_BE_Cfg_Ready(__u32 sel);
+__s32 DE_BE_EnableINT(__u8 sel, __u32 irqsrc);
+__s32 DE_BE_DisableINT(__u8 sel, __u32 irqsrc);
+__u32 DE_BE_QueryINT(__u8 sel);
+__u32 DE_BE_ClearINT(__u8 sel, __u32 irqsrc);
+__s32 DE_BE_reg_auto_load_en(__u32 sel, __u32 en);
+
+__s32 DE_BE_Layer_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Format(__u32 sel, __u8 layidx, __disp_pixel_fmt_t format,
+			     __bool br_swap, __u8 order);
+__s32 DE_BE_Layer_Set_Framebuffer(__u32 sel, __u8 layidx,
+				  layer_src_t *layer_fb);
+__s32 DE_BE_Layer_Set_Screen_Win(__u32 sel, __u8 layidx, __disp_rect_t *win);
+__s32 DE_BE_Layer_Video_Enable(__u32 sel, __u8 layidx, __bool video_en);
+__s32 DE_BE_Layer_Video_Ch_Sel(__u32 sel, __u8 layidx, __bool scaler_index);
+__s32 DE_BE_Layer_Yuv_Ch_Enable(__u32 sel, __u8 layidx, __bool yuv_en);
+__s32 DE_BE_Layer_Set_Prio(__u32 sel, __u8 layidx, __u8 prio);
+__s32 DE_BE_Layer_Set_Pipe(__u32 sel, __u8 layidx, __u8 pipe);
+__s32 DE_BE_Layer_Alpha_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Alpha_Value(__u32 sel, __u8 layidx, __u8 alpha_val);
+__s32 DE_BE_Layer_ColorKey_Enable(__u32 sel, __u8 layidx, __bool enable);
+__s32 DE_BE_Layer_Set_Work_Mode(__u32 sel, __u8 layidx, __u8 mode);
+
+__s32 DE_BE_YUV_CH_Enable(__u32 sel, __bool enable);
+__s32 DE_BE_YUV_CH_Set_Src(__u32 sel, de_yuv_ch_src_t *in_src);
+
+__s32 DE_BE_HWC_Enable(__u32 sel, __bool enable);
+__s32 DE_BE_HWC_Set_Pos(__u32 sel, __disp_pos_t *pos);
+__s32 DE_BE_HWC_Get_Pos(__u32 sel, __disp_pos_t *pos);
+__s32 DE_BE_HWC_Set_Palette(__u32 sel, __u32 address, __u32 offset, __u32 size);
+__s32 DE_BE_HWC_Get_Format(void);
+__s32 DE_BE_HWC_Set_Src(__u32 sel, __disp_hwc_pattern_t *hwc_pat);
+
+__s32 DE_BE_Sprite_Enable(__u32 sel, __bool enable);
+__s32 DE_BE_Sprite_Set_Format(__u32 sel, __u8 pixel_seq, __u8 format);
+__s32 DE_BE_Sprite_Global_Alpha_Enable(__u32 sel, bool enable);
+__s32 DE_BE_Sprite_Set_Global_Alpha(__u32 sel, __u8 alpha_val);
+__s32 DE_BE_Sprite_Block_Set_Pos(__u32 sel, __u8 blk_idx, __s16 x, __s16 y);
+__s32 DE_BE_Sprite_Block_Set_Size(__u32 sel, __u8 blk_idx, __u32 xsize,
+				  __u32 ysize);
+__s32 DE_BE_Sprite_Block_Set_fb(__u32 sel, __u8 blk_idx, __u32 addr,
+				__u32 line_width);
+__s32 DE_BE_Sprite_Block_Set_Next_Id(__u32 sel, __u8 blk_idx, __u8 next_blk_id);
+__s32 DE_BE_Sprite_Set_Palette_Table(__u32 sel, __u32 address, __u32 offset,
+				     __u32 size);
+#ifndef CONFIG_ARCH_SUN5I
+__s32 DE_BE_Set_Enhance_ex(__u8 sel, __csc_t out_csc, __u32 out_color_range,
+			   __u32 enhance_en, __u32 brightness, __u32 contrast,
+			   __u32 saturation, __u32 hue);
+#else
+__s32 DE_BE_Set_Enhance(__u8 sel, __u32 out_csc, __u32 out_color_range,
+			__s32 brightness, __s32 contrast, __s32 saturation,
+			__s32 hue);
+#endif
+__s32 DE_BE_enhance_enable(__u32 sel, bool enable);
+__s32 DE_BE_set_display_size(__u32 sel, __u32 width, __u32 height);
+__s32 DE_BE_get_display_width(__u32 sel);
+__s32 DE_BE_get_display_height(__u32 sel);
+__s32 DE_BE_deflicker_enable(__u32 sel, __bool enable);
+__s32 DE_BE_Set_Outitl_enable(__u32 sel, __bool enable);
+__s32 DE_BE_Format_To_Bpp(__disp_pixel_fmt_t format);
+__u32 DE_BE_Offset_To_Addr(__u32 src_addr, __u32 width, __u32 x, __u32 y,
+			   __u32 bpp);
+__u32 DE_BE_Addr_To_Offset(__u32 src_addr, __u32 off_addr, __u32 width,
+			   __u32 bpp, __disp_pos_t *pos);
+
+#endif /* __EBIOS_DE_H__ */
diff --git a/drivers/video/sunxi/disp/ebios_lcdc_tve.h b/drivers/video/sunxi/disp/ebios_lcdc_tve.h
new file mode 100644
index 0000000..6351c14
--- /dev/null
+++ b/drivers/video/sunxi/disp/ebios_lcdc_tve.h
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LCDC_TVE_H_
+#define _LCDC_TVE_H_
+
+#include "bsp_display.h"
+
+#define LCDC_VBI_LCD_EN		0x80000000
+#define LCDC_VBI_HD_EN		0x40000000
+#define LCDC_LTI_LCD_EN		0x20000000
+#define LCDC_LTI_HD_EN		0x10000000
+#define LCDC_VBI_LCD		0x00008000
+#define LCDC_VBI_HD		0x00004000
+#define LCDC_LTI_LCD_FLAG	0x00002000
+#define LCDC_LTI_HD_FLAG	0x00001000
+
+enum lcdc_src {
+	LCDC_SRC_DE1 = 0,
+	LCDC_SRC_DE2 = 1,
+	LCDC_SRC_DMA = 2,
+	LCDC_SRC_BLACK = 3,
+	LCDC_SRC_WHITE = 4,
+	LCDC_SRC_BLUE = 5,
+};
+
+typedef enum {
+	LCDC_LCDIF_HV = 0,
+	LCDC_LCDIF_CPU = 1,
+	LCDC_LCDIF_TTL = 2,
+	LCDC_LCDIF_LVDS = 3,
+} __lcdc_lcdif_t;
+
+typedef enum {
+	LCDC_FRM_RGB888 = 0,
+	LCDC_FRM_RGB666 = 1,
+	LCDC_FRM_RGB656 = 2,
+} __lcdc_frm_t;
+
+typedef struct {
+	__bool b_interlace;	/* 1=b_interlace, 0=progressive */
+	/* used when TV and VGA output, 0:YUV, 1:RGB */
+	__bool b_rgb_internal_hd;
+	/* used when LCD and HDMI output, 0:YUV, 1:RGB */
+	__bool b_rgb_remap_io;
+	/* used when LCD and HDMI output, 0:LCD, 1:HDMI */
+	__bool b_remap_if;
+	__u16 src_x;		/* tcon1 source width in pixels */
+	__u16 src_y;		/* tcon1 source height in pixels */
+	__u16 scl_x;		/* tcon1 scale output width size */
+	__u16 scl_y;		/* tcon1 scale output height size */
+	__u16 out_x;		/* tcon1 output width in pixels */
+	__u16 out_y;		/* tcon1 output height in pixels */
+	__u16 ht;		/* tcon1 horizontal total time */
+	__u16 hbp;		/* tcon1 back porch */
+	__u16 vt;		/* tcon1 vertical total time */
+	__u16 vbp;		/* tcon1 vertical back porch */
+	__u16 vspw;		/* tcon1 vertical sync pulse width in pixels */
+	__u16 hspw;		/* tcon1 horizontal sync pulse width */
+	__u32 io_pol;		/* tcon1 io polarity, 0=normal, 1=inverse */
+	/*
+	 * tcon1 io output enable.
+	 * 0=enable output
+	 * 1=disable output
+	 * be careful!
+	 */
+	__u32 io_out;
+	__u8 start_delay;
+} __tcon1_cfg_t;
+
+#define TVE_D0ActFlags  (0x01)
+#define TVE_D1ActFlags  (0x01<<1)
+#define TVE_D2ActFlags  (0x01<<2)
+#define TVE_D3ActFlags  (0x01<<3)
+
+typedef enum {
+	TVE_MODE_NTSC = 0,
+	TVE_MODE_PAL,
+	TVE_MODE_480I,
+	TVE_MODE_576I,
+	TVE_MODE_480P,
+	TVE_MODE_576P,
+	TVE_MODE_720P_50HZ,
+	TVE_MODE_720P_60HZ,
+	TVE_MODE_1080I_50HZ,
+	TVE_MODE_1080I_60HZ,
+	TVE_MODE_1080P_50HZ,
+	TVE_MODE_1080P_60HZ,
+	TVE_MODE_VGA
+} __tve_mode_t;
+
+typedef enum tag_TVE_DAC {
+	DAC1 = 1,	/* bit0 */
+	DAC2 = 2,	/* bit1 */
+	DAC3 = 4	/* bit2 */
+} __tve_dac_t;
+
+typedef enum tag_TVE_SRC {
+	CVBS = 0,
+	SVIDEO_Y = 1,
+	SVIDEO_C = 2,
+	COMPONENT_Y = 4,
+	COMPONENT_PB = 5,
+	COMPONENT_PR = 6,
+	VGA_R = 4,
+	VGA_G = 5,
+	VGA_B = 6
+} __tve_src_t;
+
+__s32 LCDC_set_reg_base(__u32 sel, __u32 address);
+__u32 LCDC_get_reg_base(__u32 sel);
+__s32 LCDC_init(__u32 sel);
+__s32 LCDC_exit(__u32 sel);
+void LCDC_open(__u32 sel);
+void LCDC_close(__u32 sel);
+__s32 LCDC_set_int_line(__u32 sel, __u32 tcon_index, __u32 num);
+__s32 LCDC_clear_int(__u32 sel, __u32 irqsrc);
+__s32 LCDC_get_timing(__u32 sel, __u32 index, struct fb_videomode *videomode);
+__s32 LCDC_enable_int(__u32 sel, __u32 irqsrc);
+__s32 LCDC_disable_int(__u32 sel, __u32 irqsrc);
+__u32 LCDC_query_int(__u32 sel);
+__s32 LCDC_set_start_delay(__u32 sel, __u32 tcon_index, __u8 delay);
+__s32 LCDC_get_start_delay(__u32 sel, __u32 tcon_index);
+__u32 LCDC_get_cur_line(__u32 sel, __u32 tcon_index);
+__s32 LCDC_enable_output(__u32 sel);
+__s32 LCDC_disable_output(__u32 sel);
+__s32 LCDC_set_output(__u32 sel, __bool value);
+
+void LCD_CPU_WR(__u32 sel, __u32 index, __u32 data);
+void LCD_CPU_WR_INDEX(__u32 sel, __u32 index);
+void LCD_CPU_WR_DATA(__u32 sel, __u32 data);
+void LCD_CPU_RD(__u32 sel, __u32 index, __u32 *data);
+void LCD_CPU_AUTO_FLUSH(__u32 sel, __u8 en);
+void LCD_CPU_DMA_FLUSH(__u32 sel, __u8 en);
+void LCD_XY_SWAP(__u32 sel);
+__s32 LCD_LVDS_open(__u32 sel);
+__s32 LCD_LVDS_close(__u32 sel);
+
+__s32 TCON0_open(__u32 sel);
+__s32 TCON0_close(__u32 sel);
+void TCON0_cfg(__u32 sel, __panel_para_t *info);
+__s32 TCON0_set_dclk_div(__u32 sel, __u8 div);
+__s32 TCON0_select_src(__u32 sel, enum lcdc_src src);
+__u32 TCON0_get_dclk_div(__u32 sel);
+
+__u32 TCON1_open(__u32 sel);
+__u32 TCON1_close(__u32 sel);
+__u32 TCON1_cfg(__u32 sel, __tcon1_cfg_t *cfg);
+__u32 TCON1_cfg_ex(__u32 sel, __panel_para_t *info);
+__u32 TCON1_set_hdmi_mode(__u32 sel, __u8 mode);
+__u32 TCON1_set_tv_mode(__u32 sel, __u8 mode);
+__s32 TCON1_set_vga_mode(__u32 sel, __u8 mode);
+__s32 TCON1_select_src(__u32 sel, enum lcdc_src src);
+__bool TCON1_in_valid_regn(__u32 sel, __u32 juststd);
+__s32 TCON1_set_gamma_table(__u32 sel, __u32 address, __u32 size);
+__s32 TCON1_set_gamma_Enable(__u32 sel, __bool enable);
+
+__u8 TCON_mux_init(void);
+__u8 TCON_set_hdmi_src(__u8 src);
+__u8 TCON_set_tv_src(__u32 tv_index, __u8 src);
+
+__s32 TVE_set_reg_base(__u32 sel, __u32 address);
+__u32 TVE_get_reg_base(__u32 sel);
+__s32 TVE_init(__u32 sel);
+__s32 TVE_exit(__u32 sel);
+__s32 TVE_open(__u32 sel);
+__s32 TVE_close(__u32 sel);
+__s32 TVE_set_vga_mode(__u32 sel);
+__s32 TVE_set_tv_mode(__u32 sel, __u8 mode);
+__u8 TVE_query_interface(__u32 sel, __u8 index);
+__u8 TVE_query_int(__u32 sel);
+__u8 TVE_clear_int(__u32 sel);
+__u8 TVE_dac_int_enable(__u32 sel, __u8 index);
+__u8 TVE_dac_int_disable(__u32 sel, __u8 index);
+__u8 TVE_dac_autocheck_enable(__u32 sel, __u8 index);
+__u8 TVE_dac_autocheck_disable(__u32 sel, __u8 index);
+__u8 TVE_dac_enable(__u32 sel, __u8 index);
+__u8 TVE_dac_disable(__u32 sel, __u8 index);
+__u8 TVE_dac_set_de_bounce(__u32 sel, __u8 index, __u32 times);
+__u8 TVE_dac_get_de_bounce(__u32 sel, __u8 index);
+__s32 TVE_dac_set_source(__u32 sel, __u32 index, __u32 source);
+__s32 TVE_dac_get_source(__u32 sel, __u32 index);
+__s32 TVE_get_dac_status(__u32 index);
+__u8 TVE_csc_init(__u32 sel, __u8 type);
+__s32 TVE_dac_sel(__u32 sel, __u32 dac, __u32 index);
+
+#endif
diff --git a/drivers/video/sunxi/disp/sunxi_disp_regs.h b/drivers/video/sunxi/disp/sunxi_disp_regs.h
new file mode 100644
index 0000000..583473a
--- /dev/null
+++ b/drivers/video/sunxi/disp/sunxi_disp_regs.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * HDMI
+ */
+#define HDMI_CTRL			(hdmi_base + 0x004)
+#define HDMI_INT_CTRL			(hdmi_base + 0x008)
+#define HDMI_HPD			(hdmi_base + 0x00c) /* INT_STATUS? */
+#define HDMI_VIDEO_CTRL			(hdmi_base + 0x010)
+#define HDMI_VIDEO_H			(hdmi_base + 0x014)
+#define HDMI_VIDEO_V			(hdmi_base + 0x016)
+#define HDMI_VIDEO_HBP			(hdmi_base + 0x018)
+#define HDMI_VIDEO_VBP			(hdmi_base + 0x01a)
+#define HDMI_VIDEO_HFP			(hdmi_base + 0x01c)
+#define HDMI_VIDEO_VFP			(hdmi_base + 0x01e)
+#define HDMI_VIDEO_HSPW			(hdmi_base + 0x020)
+#define HDMI_VIDEO_VPSW			(hdmi_base + 0x022)
+#define HDMI_VIDEO_POLARITY		(hdmi_base + 0x024)
+#define HDMI_TX_CLOCK			(hdmi_base + 0x026)
+#define HDMI_AUDIO_CTRL			(hdmi_base + 0x040)
+#define HDMI_AUDIO_UNKNOWN_0		(hdmi_base + 0x044) /* Unknown */
+#define HDMI_AUDIO_LAYOUT		(hdmi_base + 0x048)
+#define HDMI_AUDIO_UNKNOWN_1		(hdmi_base + 0x04c) /* Unknown */
+#define HDMI_AUDIO_CTS			(hdmi_base + 0x050)
+#define HDMI_AUDIO_ACR_N		(hdmi_base + 0x054)
+#define HDMI_AUDIO_CH_STATUS0		(hdmi_base + 0x058)
+#define HDMI_AUDIO_CH_STATUS1		(hdmi_base + 0x05c)
+#define HDMI_AVI_INFOFRAME		(hdmi_base + 0x080)
+#define HDMI_AUDIO_INFOFRAME		(hdmi_base + 0x0a0)
+#define HDMI_QCP_PACKET			(hdmi_base + 0x0e0)
+#define HDMI_TX_DRIVER			(hdmi_base + 0x200)
+#define HDMI_CEC			(hdmi_base + 0x214)
+#define HDMI_VENDOR_INFOFRAME		(hdmi_base + 0x240)
+#define HDMI_PACKET_CONFIG		(hdmi_base + 0x2f0)
+#define HDMI_UNKNOWN			(hdmi_base + 0x300) /* Unknown */
+
+#define HDMI_I2C_GENERAL		(hdmi_base + 0x500)
+#define HDMI_I2C_ADDR			(hdmi_base + 0x504)
+#define HDMI_I2C_STATUS			(hdmi_base + 0x50C)
+#define HDMI_I2C_GENERAL_2		(hdmi_base + 0x510)
+#define HDMI_I2C_DATA			(hdmi_base + 0x518)
+#define HDMI_I2C_DATA_LENGTH		(hdmi_base + 0x51c)
+#define HDMI_I2C_CMD			(hdmi_base + 0x520)
+#define HDMI_I2C_UNKNOWN_0		(hdmi_base + 0x524) /* Unknown */
+#define HDMI_I2C_CLK			(hdmi_base + 0x528)
+#define HDMI_I2C_LINE_CTRL		(hdmi_base + 0x540)
+#define HDMI_I2C_UNKNOWN_1		(hdmi_base + 0x5f0) /* Unknown */
+
diff --git a/drivers/video/sunxi/hdmi/Makefile b/drivers/video/sunxi/hdmi/Makefile
new file mode 100644
index 0000000..f1bd6f2
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_FB_SUNXI_HDMI) += hdmi.o
+
+#hdmi-objs := anx7150/hdmi_core.o anx7150/hdmi_hal.o anx7150/hdmi_i2c.o\
+#            dev_hdmi.o drv_hdmi.o
+
+hdmi-objs := hdmi_core.o hdmi_edid.o dev_hdmi.o drv_hdmi.o hdmi_i2c.o hdmi_cec.o
+
diff --git a/drivers/video/sunxi/hdmi/dev_hdmi.c b/drivers/video/sunxi/hdmi/dev_hdmi.c
new file mode 100644
index 0000000..2973f2c
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/dev_hdmi.c
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include "dev_hdmi.h"
+#include "drv_hdmi_i.h"
+#include "../disp/dev_disp.h"
+
+static struct cdev *my_cdev;
+static dev_t devid;
+static struct class *hdmi_class;
+
+hdmi_info_t ghdmi;
+
+static struct resource hdmi_resource[1] = {
+	[0] = {
+	       .start = 0x01c16000,
+	       .end = 0x01c165ff,
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+static void
+hdmi_device_release(struct device *dev)
+{
+	/* FILL ME! */
+}
+
+static struct platform_device hdmi_device = {
+	.name = "hdmi",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(hdmi_resource),
+	.resource = hdmi_resource,
+	.dev = {
+		.release = hdmi_device_release,
+	}
+};
+
+static int __devinit hdmi_probe(struct platform_device *pdev)
+{
+	__inf("hdmi_probe call\n");
+
+	memset(&ghdmi, 0, sizeof(hdmi_info_t));
+
+	ghdmi.base_hdmi = 0xf1c16000;
+
+	Hdmi_init(pdev);
+	Fb_Init(SUNXI_HDMI);
+
+	return 0;
+}
+
+static int hdmi_remove(struct platform_device *pdev)
+{
+	__inf("hdmi_remove call\n");
+
+	Hdmi_exit(pdev);
+
+	return 0;
+}
+
+static int
+hdmi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int
+hdmi_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver hdmi_driver = {
+	.probe = hdmi_probe,
+	.remove = hdmi_remove,
+	.suspend = hdmi_suspend,
+	.resume = hdmi_resume,
+	.driver = {
+		   .name = "hdmi",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int hdmi_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int hdmi_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t hdmi_read(struct file *file, char __user *buf, size_t count,
+		  loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+static ssize_t hdmi_write(struct file *file,
+		const char __user *buf, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+static int hdmi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	return 0;
+}
+
+static long hdmi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static const struct file_operations hdmi_fops = {
+	.owner = THIS_MODULE,
+	.open = hdmi_open,
+	.release = hdmi_release,
+	.write = hdmi_write,
+	.read = hdmi_read,
+	.unlocked_ioctl = hdmi_ioctl,
+	.mmap = hdmi_mmap,
+};
+
+static int __init
+hdmi_module_init(void)
+{
+	int ret = 0, err;
+
+	__inf("hdmi_module_init\n");
+
+	alloc_chrdev_region(&devid, 0, 1, "hdmi");
+	my_cdev = cdev_alloc();
+	cdev_init(my_cdev, &hdmi_fops);
+	my_cdev->owner = THIS_MODULE;
+	err = cdev_add(my_cdev, devid, 1);
+	if (err) {
+		__wrn("cdev_add fail.\n");
+		return -1;
+	}
+
+	hdmi_class = class_create(THIS_MODULE, "hdmi");
+	if (IS_ERR(hdmi_class)) {
+		__wrn("class_create fail\n");
+		return -1;
+	}
+
+	ret = platform_device_register(&hdmi_device);
+
+	if (ret == 0)
+		ret = platform_driver_register(&hdmi_driver);
+
+	return ret;
+}
+
+static void __exit hdmi_module_exit(void)
+{
+	__inf("hdmi_module_exit\n");
+
+	platform_driver_unregister(&hdmi_driver);
+	platform_device_unregister(&hdmi_device);
+
+	class_destroy(hdmi_class);
+
+	cdev_del(my_cdev);
+}
+
+late_initcall(hdmi_module_init);
+module_exit(hdmi_module_exit);
+
+MODULE_AUTHOR("danling_xiao");
+MODULE_DESCRIPTION("hdmi driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:hdmi");
diff --git a/drivers/video/sunxi/hdmi/dev_hdmi.h b/drivers/video/sunxi/hdmi/dev_hdmi.h
new file mode 100644
index 0000000..8d62191
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/dev_hdmi.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DEV_DISPLAY_H__
+#define __DEV_DISPLAY_H__
+
+#include "drv_hdmi_i.h"
+
+typedef struct {
+	__bool bopen;
+	__disp_tv_mode_t mode;
+	__u32 base_hdmi;
+} hdmi_info_t;
+
+extern hdmi_info_t ghdmi;
+
+#endif
diff --git a/drivers/video/sunxi/hdmi/drv_hdmi.c b/drivers/video/sunxi/hdmi/drv_hdmi.c
new file mode 100644
index 0000000..a8d3cef
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/drv_hdmi.c
@@ -0,0 +1,377 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Semaphore stuff seems quite broken in here. --libv
+ */
+#include "drv_hdmi_i.h"
+#include "hdmi_core.h"
+#include "dev_hdmi.h"
+#include "../disp/dev_disp.h"
+
+
+/*
+ * Bad separation!
+ * symbol from sound/soc/sun[45]i/hdmiaudio/sndhdmi.c
+ */
+extern void audio_set_hdmi_func(__audio_hdmi_func *hdmi_func);
+
+
+static struct semaphore *run_sem;
+static struct task_struct *HDMI_task;
+void __iomem *hdmi_base;
+
+
+static __s32 Hdmi_enable(__bool enable)
+{
+	if ((video_enable != enable) &&
+	    (hdmi_state >= HDMI_State_Video_config))
+		hdmi_state = HDMI_State_Video_config;
+
+	video_enable = enable;
+
+	return 0;
+}
+
+static __s32 hdmi_wait_edid(void)
+{
+	unsigned long start = jiffies;
+
+	while (time_before(jiffies, start + 10 * HZ)) { /* Wait max 10 sec */
+		if (hdmi_state > HDMI_State_EDID_Parse) {
+			pr_info("waited %ld ms for EDID info\n",
+				(jiffies - start) * 1000 / HZ);
+			if (!Device_Support_VIC[HDMI_EDID]) {
+				pr_warn("No valid EDID mode found\n");
+				return -1;
+			}
+			return 0;
+		}
+		hdmi_delay_ms(1);
+	}
+	pr_warn("Timeout waiting for EDID info\n");
+	return -1;
+}
+
+static __s32 Hdmi_open(void)
+{
+	__inf("[Hdmi_open]\n");
+
+	Hdmi_enable(1);
+
+#if 0
+	if (ghdmi.bopen == 0)
+		up(run_sem);
+#endif
+
+	ghdmi.bopen = 1;
+
+	return 0;
+}
+
+static __s32 Hdmi_close(void)
+{
+	__inf("[Hdmi_close]\n");
+
+	Hdmi_enable(0);
+	ghdmi.bopen = 0;
+
+	return 0;
+}
+
+/* Translate a fex tv-mode into a VIC as used in the hdmi code */
+static __u32 Hdmi_tv_mode_to_hdmi_mode(__disp_tv_mode_t mode)
+{
+	switch (mode) {
+	case DISP_TV_MOD_480I:
+		return HDMI1440_480I;
+	case DISP_TV_MOD_576I:
+		return HDMI1440_576I;
+	case DISP_TV_MOD_480P:
+		return HDMI480P;
+	case DISP_TV_MOD_576P:
+		return HDMI576P;
+	case DISP_TV_MOD_720P_50HZ:
+		return HDMI720P_50;
+	case DISP_TV_MOD_720P_60HZ:
+		return HDMI720P_60;
+	case DISP_TV_MOD_1080I_50HZ:
+		return HDMI1080I_50;
+	case DISP_TV_MOD_1080I_60HZ:
+		return HDMI1080I_60;
+	case DISP_TV_MOD_1080P_24HZ:
+		return HDMI1080P_24;
+	case DISP_TV_MOD_1080P_50HZ:
+		return HDMI1080P_50;
+	case DISP_TV_MOD_1080P_60HZ:
+		return HDMI1080P_60;
+	case DISP_TV_MOD_1080P_24HZ_3D_FP:
+		return HDMI1080P_24_3D_FP;
+	case DISP_TV_MOD_720P_50HZ_3D_FP:
+		return HDMI720P_50_3D_FP;
+	case DISP_TV_MOD_720P_60HZ_3D_FP:
+		return HDMI720P_60_3D_FP;
+	case DISP_TV_MOD_H1360_V768_60HZ:
+		return HDMI1360_768_60;
+	case DISP_TV_MOD_H1280_V1024_60HZ:
+		return HDMI1280_1024_60;
+	case DISP_TV_MODE_EDID:
+		if (!Device_Support_VIC[HDMI_EDID]) {
+			pr_err("EDID mode used without valid EDID info\n");
+			return 0;
+		}
+		return HDMI_EDID;
+	default:
+		__wrn("unsupported video mode %d\n", mode);
+		return 0;
+	}
+}
+
+static __s32 Hdmi_set_display_mode(__disp_tv_mode_t mode)
+{
+	__u32 hdmi_mode;
+
+	__inf("[Hdmi_set_display_mode],mode:%d\n", mode);
+
+	hdmi_mode = Hdmi_tv_mode_to_hdmi_mode(mode);
+	if (!hdmi_mode)
+		return -1;
+
+	ghdmi.mode = mode;
+	if (hdmi_mode != video_mode) {
+		if (hdmi_state >= HDMI_State_Video_config)
+			hdmi_state = HDMI_State_Video_config;
+
+		video_mode = hdmi_mode;
+	}
+	return 0;
+}
+
+static __s32 Hdmi_set_display_videomode(const struct __disp_video_timing *mode)
+{
+	__inf("[Hdmi_set_display_videomode]\n");
+
+	if (video_mode != HDMI_EDID)
+		return -1;
+
+	if (memcmp(mode, &video_timing[video_timing_edid],
+			sizeof(struct __disp_video_timing)) != 0) {
+
+		if (hdmi_state >= HDMI_State_Video_config)
+			hdmi_state = HDMI_State_Video_config;
+
+		memcpy(&video_timing[video_timing_edid], mode,
+			   sizeof(struct __disp_video_timing));
+
+	}
+
+	return 0;
+}
+
+static __s32 Hdmi_Audio_Enable(__u8 mode, __u8 channel)
+{
+	__s32 audio_en = (channel == 0) ? 0 : 1;
+
+	__inf("[Hdmi_Audio_Enable],ch:%d\n", channel);
+
+	if (audio_info.audio_en != audio_en) {
+		audio_info.audio_en = audio_en;
+		if (hdmi_state > HDMI_State_Audio_config)
+			hdmi_state = HDMI_State_Audio_config;
+	}
+
+	return 0;
+}
+
+static __s32 Hdmi_Set_Audio_Para(hdmi_audio_t *audio_para)
+{
+	int change = 0;
+
+	__inf("[Hdmi_Set_Audio_Para]\n");
+
+	if (!audio_para)
+		return -1;
+
+	if (audio_para->sample_rate != audio_info.sample_rate) {
+		audio_info.sample_rate = audio_para->sample_rate;
+		change = audio_info.audio_en;
+
+		__inf("sample_rate:%d in Hdmi_hal_set_audio_para\n",
+		      audio_info.sample_rate);
+	}
+	if (audio_para->channel_num != audio_info.channel_num) {
+		audio_info.channel_num = audio_para->channel_num;
+		change = audio_info.audio_en;
+
+		__inf("channel_num:%d in Hdmi_hal_set_audio_para\n",
+		      audio_info.channel_num);
+	}
+
+	if (change && hdmi_state > HDMI_State_Audio_config)
+		hdmi_state = HDMI_State_Audio_config;
+
+	return 0;
+}
+
+static __s32 Hdmi_mode_support(__disp_tv_mode_t mode)
+{
+	__u32 hdmi_mode = Hdmi_tv_mode_to_hdmi_mode(mode);
+
+	if (hdmi_mode == 0 || Hpd_Check() == 0)
+		return 0;
+
+	while (hdmi_state < HDMI_State_Wait_Video_config)
+		hdmi_delay_ms(1);
+
+	return Device_Support_VIC[hdmi_mode];
+}
+
+static __s32 hdmi_get_video_timing(__disp_tv_mode_t mode,
+	struct __disp_video_timing *video_timing_dest)
+{
+	__u32 hdmi_mode;
+	__s32 vic_tab;
+
+	hdmi_mode = Hdmi_tv_mode_to_hdmi_mode(mode);
+	if (!hdmi_mode)
+		return -1;
+
+	vic_tab = get_video_info(hdmi_mode);
+	if (vic_tab == -1)
+		return -1;
+
+	memcpy(video_timing_dest, &video_timing[vic_tab],
+	       sizeof(struct __disp_video_timing));
+	return 0;
+}
+
+static __s32 Hdmi_get_HPD_status(void)
+{
+	return Hpd_Check();
+}
+
+static __s32
+Hdmi_set_pll(__u32 pll, __u32 clk)
+{
+	hdmi_pll = pll;
+	hdmi_clk = clk;
+	return 0;
+}
+
+static int
+Hdmi_run_thread(void *parg)
+{
+	while (1) {
+		hdmi_main_task_loop();
+
+		if (kthread_should_stop())
+			break;
+
+		if (hdmi_state == HDMI_State_Wait_Hpd ||
+		    hdmi_state == HDMI_State_Playback)
+			hdmi_delay_ms(250);
+		else
+			hdmi_delay_ms(1);
+	}
+
+	return 0;
+}
+
+__s32 Hdmi_init(struct platform_device *dev)
+{
+	__audio_hdmi_func audio_func;
+	__disp_hdmi_func disp_func;
+	int err = 0;
+
+	run_sem = kmalloc(sizeof(struct semaphore), GFP_KERNEL | __GFP_ZERO);
+	sema_init((struct semaphore *)run_sem, 0);
+
+	hdmi_base = (void __iomem *) ghdmi.base_hdmi;
+	hdmi_core_initial();
+	err = hdmi_i2c_sunxi_probe(dev);
+	if (err)
+		return err;
+
+	audio_info.channel_num = 2;
+#if 0
+	{ /* for audio test */
+		hdmi_audio_t audio_para;
+
+		audio_para.ch0_en = 1;
+		audio_para.sample_rate = 44100;
+		Hdmi_hal_set_audio_para(&audio_para);
+
+		Hdmi_hal_audio_enable(0, 1);
+	}
+#endif
+
+
+	/* Run main task once, should give EDID information directly */
+	hdmi_main_task_loop();
+
+	HDMI_task = kthread_create(Hdmi_run_thread, (void *)0, "hdmi proc");
+	if (IS_ERR(HDMI_task)) {
+		__s32 err = 0;
+
+		__wrn("Unable to start kernel thread %s.\n", "hdmi proc");
+		err = PTR_ERR(HDMI_task);
+		HDMI_task = NULL;
+		return err;
+	}
+	/* Launch main task loop */
+	wake_up_process(HDMI_task);
+
+
+	audio_func.hdmi_audio_enable = Hdmi_Audio_Enable;
+	audio_func.hdmi_set_audio_para = Hdmi_Set_Audio_Para;
+#if defined CONFIG_SND_SUNXI_SOC_HDMIAUDIO || \
+    (defined CONFIG_SND_SUNXI_SOC_HDMIAUDIO_MODULE && \
+     defined CONFIG_FB_SUNXI_HDMI_MODULE)
+	audio_set_hdmi_func(&audio_func);
+#endif
+
+	disp_func.hdmi_wait_edid = hdmi_wait_edid;
+	disp_func.Hdmi_open = Hdmi_open;
+	disp_func.Hdmi_close = Hdmi_close;
+	disp_func.hdmi_set_mode = Hdmi_set_display_mode;
+	disp_func.hdmi_set_videomode = Hdmi_set_display_videomode;
+	disp_func.hdmi_mode_support = Hdmi_mode_support;
+	disp_func.hdmi_get_video_timing = hdmi_get_video_timing;
+	disp_func.hdmi_get_HPD_status = Hdmi_get_HPD_status;
+	disp_func.hdmi_set_pll = Hdmi_set_pll;
+	disp_set_hdmi_func(&disp_func);
+
+	return 0;
+}
+
+__s32 Hdmi_exit(struct platform_device *dev)
+{
+
+	kfree(run_sem);
+	run_sem = NULL;
+
+	if (HDMI_task) {
+		kthread_stop(HDMI_task);
+		HDMI_task = NULL;
+	}
+
+	hdmi_i2c_sunxi_remove(dev);
+
+	return 0;
+}
diff --git a/drivers/video/sunxi/hdmi/drv_hdmi_i.h b/drivers/video/sunxi/hdmi/drv_hdmi_i.h
new file mode 100644
index 0000000..35cd837
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/drv_hdmi_i.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  _DRV_HDMI_I_H_
+#define  _DRV_HDMI_I_H_
+
+#include <linux/uaccess.h>
+#include <asm/memory.h>
+#include <linux/unistd.h>
+#include "asm-generic/int-ll64.h"
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h> /* wake_up_process() */
+#include <linux/kthread.h> /* kthread_create(), kthread_run() */
+#include <linux/err.h> /* IS_ERR(), PTR_ERR() */
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+#include <video/sunxi_disp_ioctl.h>
+#include <linux/drv_hdmi.h>
+
+#define __inf(msg, ...) pr_debug("[DISP] " msg, ##__VA_ARGS__)
+#define __wrn(msg, ...) pr_warn("[DISP] " msg, ##__VA_ARGS__)
+
+__s32 Hdmi_init(struct platform_device *dev);
+__s32 Hdmi_exit(struct platform_device *dev);
+
+#endif
diff --git a/drivers/video/sunxi/hdmi/hdmi_cec.c b/drivers/video/sunxi/hdmi/hdmi_cec.c
new file mode 100644
index 0000000..3179cfa
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/hdmi_cec.c
@@ -0,0 +1,827 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <mach/clock.h>
+#include "hdmi_cec.h"
+#include "hdmi_core.h"
+#include "../disp/sunxi_disp_regs.h"
+
+
+__bool cec_enable;
+__bool cec_standby;
+__u32 cec_phy_addr;
+__u32 cec_logical_addr;
+__u8 cec_count = 30;
+
+/* return us */
+static __s32 hdmi_time_diff(unsigned long long time_before,
+		unsigned long long time_after)
+{
+	__u32 time_diff = (__u32)(time_after - time_before);
+	return (__u32)(time_diff / 24);
+}
+
+static void hdmi_delay_us(__u32 us)
+{
+#if 0
+	__u32 cnt = 1;
+	__u32 delay_unit = 0;
+	__u32 CoreClk = 120;
+
+	delay_unit = (CoreClk * 1000 * 1000) / (1000*1000);
+	cnt = Microsecond * delay_unit;
+	while (cnt--)
+		;
+#else
+	unsigned long long t0, t1;
+	pr_debug("==delay %d\n", us);
+	t1 = t0 = aw_clksrc_read(NULL);
+	while (hdmi_time_diff(t0, t1) < us)
+		t1 = aw_clksrc_read(NULL);
+
+	pr_debug("t0=%d,%d\n", (__u32)(t0>>32), (__u32)t0);
+	pr_debug("t1=%d,%d\n", (__u32)(t1>>32), (__u32)t1);
+
+	return;
+#endif
+}
+
+static __s32 hdmi_cec_enable(__bool en)
+{
+	if (en)
+		writel(readl(HDMI_CEC) | 0x800, HDMI_CEC);
+	else
+		writel(readl(HDMI_CEC) & (~0x800), HDMI_CEC);
+
+	cec_enable = en;
+
+	return 0;
+}
+
+static __s32 hdmi_cec_write_reg_bit(__u32 data)    /* 1bit */
+{
+	if (data & 0x1)
+		writel(readl(HDMI_CEC) | 0x200, HDMI_CEC);
+	else
+		writel(readl(HDMI_CEC) & (~0x200), HDMI_CEC);
+
+	return 0;
+}
+
+static __s32 hdmi_cec_read_reg_bit(void)    /* 1bit */
+{
+	return (readl(HDMI_CEC) >> 8) & 0x1;
+}
+
+static __s32 hdmi_cec_start_bit(void)
+{
+	__u32 low_time, whole_time;
+
+	low_time = HDMI_CEC_START_BIT_LOW_TIME;
+	whole_time = HDMI_CEC_START_BIT_WHOLE_TIME;
+
+	pr_debug("hdmi_cec_start_bit ===\n");
+
+	hdmi_cec_write_reg_bit(0);
+
+	hdmi_delay_us(low_time);
+
+	hdmi_cec_write_reg_bit(1);
+
+	hdmi_delay_us(whole_time - low_time);
+
+	pr_debug("start bit end\n");
+
+	return 0;
+}
+
+static __s32 hdmi_cec_send_bit(__u32 data)    /* 1bit */
+{
+	__u32 low_time, whole_time;
+
+	pr_debug("hdmi_cec_send_bit===\n");
+
+	low_time = (data == 1) ?
+			HDMI_CEC_DATA_BIT1_LOW_TIME :
+			HDMI_CEC_DATA_BIT0_LOW_TIIME;
+	whole_time = HDMI_CEC_DATA_BIT_WHOLE_TIME;
+
+	hdmi_cec_write_reg_bit(0);
+
+	hdmi_delay_us(low_time);
+
+	hdmi_cec_write_reg_bit(1);
+
+	hdmi_delay_us(whole_time - low_time);
+
+	pr_debug("one bit over\n");
+
+	return 0;
+
+}
+
+static __s32 hdmi_cec_ack(__u32 data)    /* 1bit */
+{
+	__u32 low_time, whole_time;
+
+	pr_debug("hdmi_cec_ack===\n");
+
+	low_time = (data == 1) ?
+			HDMI_CEC_DATA_BIT1_LOW_TIME :
+			HDMI_CEC_DATA_BIT0_LOW_TIIME;
+	whole_time = HDMI_CEC_DATA_BIT_WHOLE_TIME;
+
+	while (hdmi_cec_read_reg_bit() == 1)
+		;
+
+	hdmi_cec_write_reg_bit(0);
+
+	hdmi_delay_us(low_time);
+
+	hdmi_cec_write_reg_bit(1);
+
+	hdmi_delay_us(whole_time - low_time);
+
+	pr_debug("one bit over\n");
+
+	return 0;
+
+}
+
+/* active: 1: used while send msg; */
+/*         0: used while receive msg */
+static __s32 hdmi_cec_receive_bit(__bool active, __u32 *data)    /*1bit */
+{
+	__s32 ret = 0;
+
+	if (active) {
+		hdmi_cec_write_reg_bit(0);
+		hdmi_delay_us(200);
+		hdmi_cec_write_reg_bit(1);
+		hdmi_delay_us(800);
+	} else {
+		while (hdmi_cec_read_reg_bit() == 1)
+			;
+		hdmi_delay_us(1000);
+	}
+	*data = hdmi_cec_read_reg_bit();
+
+	if (active)
+		hdmi_delay_us(1400);
+	else
+		hdmi_delay_us(1100);
+
+	return ret;
+
+}
+
+#if 0 /* Not used */
+static __s32 hdmi_cec_free(void)
+{
+	pr_info("hdmi_cec_free!===\n");
+	while (hdmi_cec_read_reg_bit() != 0x1)
+		;
+
+	pr_info("loop out!===\n");
+
+	hdmi_start_timer();
+	pr_info("wait 7 data period===\n");
+	while (hdmi_cec_read_reg_bit() == 0x1) {
+		if (hdmi_calc_time() > 7 * 2400)
+			break;
+
+	}
+	pr_info("wait 7 data period end===\n");
+
+	return 0;
+}
+#endif
+
+static __s32 hdmi_cec_send_byte(__u32 data, __u32 eom, __u32 *ack)  /* 1byte */
+{
+	__u32 i;
+
+	pr_debug("hdmi_cec_send_byte!===\n");
+
+	if (cec_enable == 0) {
+		pr_info("cec dont enable\n");
+		return -1;
+	}
+
+	pr_debug("data bit");
+	for (i = 0; i < 8; i++) {
+		if (data & 0x80)
+			hdmi_cec_send_bit(1);
+		else
+			hdmi_cec_send_bit(0);
+
+		data = data << 1;
+	}
+
+	pr_debug("bit eom\n");
+	hdmi_cec_send_bit(eom);
+
+	/* hdmi_cec_send_bit(1); */
+
+	/* todo? */
+	pr_debug("receive ack\n");
+	hdmi_cec_receive_bit(1, ack);
+
+	return 0;
+}
+
+static __s32 hdmi_cec_receive_byte(__u32 *data, __u32 *eom)    /* 1byte */
+{
+	__u32 i;
+	__u32 data_bit = 0;
+	__u32 data_byte = 0;
+
+	for (i = 0; i < 8; i++) {
+		hdmi_cec_receive_bit(0, &data_bit);
+		data_byte = data_byte << 1;
+		data_byte |= data_bit;
+	}
+
+	*data = data_byte;
+
+	hdmi_cec_receive_bit(0, eom);
+
+	return 0;
+}
+
+__s32 hdmi_cec_send_msg(struct __hdmi_cec_msg_t *msg)
+{
+	__u32 header_block;
+	enum __hdmi_cec_msg_eom eom;
+	__u32 real_ack = 0;
+	__u32 i;
+	__u32 ack = (msg->follower_addr == HDMI_CEC_LADDR_BROADCAST) ?
+			HDMI_CEC_BROADCAST_MSG_ACK : HDMI_CEC_NORMAL_MSG_ACK;
+
+	header_block = ((msg->initiator_addr & 0xf) << 4)
+			| (msg->follower_addr & 0xf);
+	eom = (msg->opcode_valid) ? HDMI_CEC_MSG_MORE : HDMI_CEC_MSG_END;
+
+	hdmi_cec_enable(1);
+	hdmi_cec_start_bit();                          /* start bit */
+	hdmi_cec_send_byte(header_block, eom, &real_ack);   /* header block */
+
+	if ((real_ack == ack) && (msg->opcode_valid)) {
+		eom = (msg->para_num != 0) ?
+				HDMI_CEC_MSG_MORE : HDMI_CEC_MSG_END;
+		/* data block: opcode */
+		hdmi_cec_send_byte(msg->opcode, eom, &real_ack);
+
+		if (real_ack == ack) {
+			for (i = 0; i < msg->para_num; i++) {
+				eom = (i == (msg->para_num - 1)) ?
+						HDMI_CEC_MSG_END :
+						HDMI_CEC_MSG_MORE;
+				/* data block: parameters */
+				hdmi_cec_send_byte(msg->para[i], eom,
+						&real_ack);
+			}
+		}
+	}
+	hdmi_cec_enable(0);
+
+	pr_debug("%s ack:%d\n", __func__, real_ack);
+	return real_ack;
+}
+
+static __s32 hdmi_cec_wait_for_start_bit(void)
+{
+	__u32 i;
+	__s32 ret = 0;
+
+	pr_debug("%s wait for stbit\n", __func__);
+	while (1) {
+		while (hdmi_cec_read_reg_bit() == 1)
+			;
+
+		for (i = 0; i < 7; i++) {
+			if (hdmi_cec_read_reg_bit() == 1)
+				break;
+
+			hdmi_delay_us(500);
+		}
+
+		if (i < 7)
+			continue;
+
+		while (hdmi_cec_read_reg_bit() == 0)
+			;
+
+		for (i = 0; i < 4; i++) {
+			if (hdmi_cec_read_reg_bit() == 0)
+				break;
+
+			hdmi_delay_us(100);
+		}
+
+		if (i < 4)
+			continue;
+		else
+			break;
+	}
+
+	return ret;
+}
+
+__s32 hdmi_cec_receive_msg(struct __hdmi_cec_msg_t *msg)
+{
+	__u32 data_byte;
+	__u32 ack;
+	__u32 i;
+	__u32 eom;
+	cec_logical_addr = 0x04;
+
+	memset(msg, 0, sizeof(struct __hdmi_cec_msg_t));
+
+	hdmi_cec_wait_for_start_bit();
+
+	hdmi_cec_receive_byte(&data_byte, &eom);
+
+	msg->initiator_addr = (data_byte >> 4) & 0x0f;
+	msg->follower_addr = data_byte & 0x0f;
+
+	if ((msg->follower_addr == cec_logical_addr)
+			|| (msg->follower_addr == HDMI_CEC_LADDR_BROADCAST)) {
+		ack = (msg->follower_addr == cec_logical_addr) ? 0 : 1;
+		hdmi_cec_ack(ack);
+
+		if (!eom) {
+			hdmi_cec_receive_byte(&data_byte, &eom);
+			msg->opcode = data_byte;
+			msg->opcode_valid = 1;
+
+			hdmi_cec_ack(ack);
+
+			while (!eom) {
+				hdmi_cec_receive_byte(&data_byte, &eom);
+				msg->para[msg->para_num] = data_byte;
+				msg->para_num++;
+
+				hdmi_cec_ack(ack);
+			}
+		}
+
+		pr_debug("%s %d, %d\n", __func__,
+				msg->initiator_addr, msg->follower_addr);
+	} else
+		hdmi_cec_ack(1);
+
+	if (msg->opcode_valid)
+		pr_debug("%s op: 0x%x\n", __func__, msg->opcode);
+
+	for (i = 0; i < msg->para_num; i++)
+		pr_debug("%s para[%d]: 0x%x\n", __func__, i, msg->para[i]);
+
+	return 0;
+}
+
+#if 0 /* Not used */
+static __s32 hdmi_cec_intercept(struct __hdmi_cec_msg_t *msg)
+{
+	__u32 data_bit;
+	__u32 data_byte;
+	__u32 ack;
+	__u32 i;
+	__u32 eom;
+
+	memset(msg, 0, sizeof(struct __hdmi_cec_msg_t));
+
+	hdmi_cec_wait_for_start_bit();
+
+	hdmi_cec_receive_byte(&data_byte, &eom);
+
+	msg->initiator_addr = (data_byte >> 4) & 0x0f;
+	msg->follower_addr = data_byte & 0x0f;
+
+	hdmi_cec_receive_bit(0, &data_bit);   /* skip ack bit */
+
+	if (!eom) {
+		hdmi_cec_receive_byte(&data_byte, &eom);
+		msg->opcode = data_byte;
+		msg->opcode_valid = 1;
+
+		hdmi_cec_receive_bit(0, &data_bit); /* skip ack bit */
+		while (!eom) {
+			hdmi_cec_receive_byte(&data_byte, &eom);
+			msg->para[msg->para_num] = data_byte;
+			msg->para_num++;
+
+			hdmi_cec_receive_bit(0, &data_bit); /* skip ack bit */
+		}
+	}
+
+	pr_info("%d-->%d\n", msg->initiator_addr, msg->follower_addr);
+	if (msg->opcode_valid)
+		pr_info("op: %x\n", msg->opcode);
+
+	for (i = 0; i < msg->para_num; i++)
+		pr_info("para[%d]: %x\n", i, msg->para[i]);
+
+	return 0;
+}
+
+#if 0
+__u32 cec_phy_addr = 0x1000;
+__u32  cec_logical_addr = 0x4; /* 4bit */
+return ack
+#endif
+static __s32 hdmi_cec_ping(__u32 init_addr, __u32 follower_addr)
+{
+	struct __hdmi_cec_msg_t msg;
+
+	memset(&msg, 0, sizeof(struct __hdmi_cec_msg_t));
+	msg.initiator_addr = init_addr;
+	msg.follower_addr = follower_addr;
+	msg.opcode_valid = 0;
+
+	return hdmi_cec_send_msg(&msg);
+}
+
+/* cmd: 0xffffffff(no cmd) */
+static __s32 hdmi_cec_send_cmd(__u32 init_addr, __u32 follower_addr, __u32 cmd,
+		__u32 para, __u32 para_bytes)
+{
+	__u32 header_of_msg = 0x44; /* 8bit */
+	__u32 end_of_msg = 0x1; /* 1bit */
+	__u32 ack = 0x0; /* 1bit */
+	__s32 ret;
+
+	/* broadcast msg */
+	if (follower_addr == 0xf)
+		pr_info("follower_addr == 0xf\n");
+
+	header_of_msg = ((init_addr & 0xf) << 8) | (follower_addr & 0xf);
+
+	hdmi_cec_enable(1);
+
+	hdmi_cec_start_bit();
+
+	if (cmd == 0xffffffff) {
+		hdmi_cec_send_byte(header_of_msg, 1, &ack);
+		if (ack == 1) {
+			pr_info("===hdmi_cec_send_cmd, ok\n");
+			ret = 0;
+		} else {
+			pr_info("###hdmi_cec_send_cmd, fail\n");
+			ret = -1;
+		}
+	} else {
+		hdmi_cec_send_byte(header_of_msg, 0, &ack);
+		if (ack == 0)
+			pr_info("ack == 0\n");
+		else
+			pr_info("ack != 0\n");
+
+	}
+
+	hdmi_cec_enable(0);
+
+	return 0;
+}
+#endif
+
+__s32 hdmi_cec_test(void)
+{
+	__u32 i;
+#if 0
+	__u32 header_of_msg = 0x40; /* 8bit */
+	__u32 end_of_msg = 0x1; /* 1bit */
+	__u32 ack = 0x1; /* 1bit */
+	__u32 cmd = 0x04;
+#endif
+#if 0
+	__u32 data = 0x00036;  /* 0d */
+	__u32 data = 0x00013; /* 04 */
+#endif
+	__u32 data = 0x40013; /* 04 */
+	struct __hdmi_cec_msg_t msg;
+	pr_info("###########################hdmi_cec_test\n");
+#if 0
+	pr_info("===enable\n");
+	hdmi_cec_enable(1);
+
+	pr_info("===start bit\n");
+	hdmi_cec_start_bit();
+
+	for (i = 0; i < 20; i++) {
+		if (data & 0x80000)
+			hdmi_cec_send_bit(1);
+		else
+			hdmi_cec_send_bit(0);
+
+		data = data << 1;
+	}
+#endif
+
+#if 1
+	/*
+	 pr_info("===enable\n");
+	 hdmi_cec_enable(1);
+
+	 pr_info("===start bit\n");
+	 hdmi_cec_start_bit();
+
+	 hdmi_cec_send_byte(0x40, 0, &ack);
+
+	 hdmi_cec_send_byte(0x04, 1,&ack);
+	 */
+#if 1
+	msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	msg.follower_addr = HDMI_CEC_LADDR_TV;
+	msg.opcode_valid = 1;
+	msg.opcode = HDMI_CEC_OP_IMAGE_VIEW_ON;
+	msg.para_num = 0;
+	hdmi_cec_send_msg(&msg);
+
+	hdmi_delay_us(100000);
+	msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	msg.follower_addr = HDMI_CEC_LADDR_TV;
+	msg.opcode_valid = 1;
+	msg.opcode = HDMI_CEC_OP_IMAGE_VIEW_ON;
+	msg.para_num = 0;
+	hdmi_cec_send_msg(&msg);
+
+	hdmi_delay_us(100000);
+	msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	msg.follower_addr = HDMI_CEC_LADDR_TV;
+	msg.opcode_valid = 1;
+	msg.opcode = HDMI_CEC_OP_ACTIVE_SOURCE;
+	msg.para_num = 2;
+	msg.para[0] = (cec_phy_addr >> 8) & 0xff;
+	msg.para[1] = cec_phy_addr & 0xff;
+	hdmi_cec_send_msg(&msg);
+
+	hdmi_delay_us(100000);
+	msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	msg.follower_addr = HDMI_CEC_LADDR_TV;
+	msg.opcode_valid = 1;
+	msg.opcode = HDMI_CEC_OP_ACTIVE_SOURCE;
+	msg.para_num = 2;
+	msg.para[0] = (cec_phy_addr >> 8) & 0xff;
+	msg.para[1] = cec_phy_addr & 0xff;
+	hdmi_cec_send_msg(&msg);
+	/*
+	 msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	 msg.follower_addr = HDMI_CEC_LADDR_BROADCAST;
+	 msg.opcode_valid = 1;
+	 msg.opcode = HDMI_CEC_OP_ACTIVE_SOURCE;
+	 msg.para_num = 2;
+	 msg.para[0] = 0x20;
+	 msg.para[1] = 0x00;
+	 hdmi_cec_send_msg(&msg);
+
+
+	 msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	 msg.follower_addr = HDMI_CEC_LADDR_TV;
+	 msg.opcode_valid = 1;
+	 msg.opcode = HDMI_CEC_OP_SET_OSD_NAME;
+	 msg.para_num = 9;
+	 msg.para[0] = 'A';
+	 msg.para[1] = 'L';
+	 msg.para[2] = 'L';
+	 msg.para[3] = 'W';
+	 msg.para[4] = 'I';
+	 msg.para[5] = 'N';
+	 msg.para[6] = 'N';
+	 msg.para[7] = 'E';
+	 msg.para[8] = 'R';
+	 hdmi_cec_send_msg(&msg);
+
+
+	 msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	 msg.follower_addr = HDMI_CEC_LADDR_TV;
+	 msg.opcode_valid = 1;
+	 msg.opcode = HDMI_CEC_OP_SET_OSD_NAME;
+	 msg.para_num = 9;
+	 msg.para[0] = 'A';
+	 msg.para[1] = 'L';
+	 msg.para[2] = 'L';
+	 msg.para[3] = 'W';
+	 msg.para[4] = 'I';
+	 msg.para[5] = 'N';
+	 msg.para[6] = 'N';
+	 msg.para[7] = 'E';
+	 msg.para[8] = 'R';
+	 hdmi_cec_send_msg(&msg);
+
+
+	 msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	 msg.follower_addr = HDMI_CEC_LADDR_TV;
+	 msg.opcode_valid = 1;
+	 msg.opcode = HDMI_CEC_OP_SET_OSD_NAME;
+	 msg.para_num = 9;
+	 msg.para[0] = 'A';
+	 msg.para[1] = 'L';
+	 msg.para[2] = 'L';
+	 msg.para[3] = 'W';
+	 msg.para[4] = 'I';
+	 msg.para[5] = 'N';
+	 msg.para[6] = 'N';
+	 msg.para[7] = 'E';
+	 msg.para[8] = 'R';
+	 hdmi_cec_send_msg(&msg);
+
+	 */
+	/*hdmi_delay_us(4000000);*/
+#endif
+
+	hdmi_delay_us(100000);
+	msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+	msg.follower_addr = HDMI_CEC_LADDR_TV;
+	msg.opcode_valid = 1;
+	msg.opcode = HDMI_CEC_OP_REQUEST_POWER_STATUS;
+	msg.para_num = 0;
+	hdmi_cec_send_msg(&msg);
+
+	hdmi_delay_us(100000);
+
+	/*while (!hdmi_cec_intercept(&msg));*/
+	/*    i = 0;
+	 while (!hdmi_cec_receive_msg(&msg))  {
+	 i++;
+	 if (i == 30) {
+		hdmi_delay_us(100000);
+		msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+		msg.follower_addr = HDMI_CEC_LADDR_BROADCAST;
+		msg.opcode_valid = 1;
+		msg.opcode = HDMI_CEC_OP_REQUEST_POWER_STATUS;
+		msg.para_num = 0;
+		hdmi_cec_send_msg(&msg);
+		pr_info("==get pwr st\n");
+
+	 i = 0;
+	 }
+	 }
+	 */
+
+#endif
+#if 0
+	pr_info("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+	pr_info("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+	pr_info("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+	hdmi_cec_start_bit();
+	data = 0x103;
+	for (i = 0; i < 10; i++) {
+		if (data & 0x200)
+			hdmi_cec_send_bit(1);
+		else
+			hdmi_cec_send_bit(0);
+
+		data = data << 1;
+	}
+#endif
+
+	pr_info("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+	pr_info("++++++++++++++++  active source ++++++++++++++++++++++++++\n");
+	pr_info("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+	/*data = 0x0f609204; */ /*2*/
+	/*data = 0x0f609404; */ /*4*/
+	data = 0x4f609104;
+	pr_info("===start bit\n");
+	hdmi_cec_start_bit();
+
+	for (i = 0; i < 32; i++) {
+		if (data & 0x80000000)
+			hdmi_cec_send_bit(1);
+		else
+			hdmi_cec_send_bit(0);
+
+		data = data << 1;
+	}
+
+	data = 0x03;
+	for (i = 0; i < 8; i++) {
+		if (data & 0x80)
+			hdmi_cec_send_bit(1);
+		else
+			hdmi_cec_send_bit(0);
+
+		data = data << 1;
+	}
+
+	pr_info("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+	pr_info("++++++++++++++++  active source ++++++++++++++++++++++++++\n");
+	pr_info("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
+
+	/*data = 0x0f609204;*/  /*2*/
+	/*data = 0x0f609404;*/ /*4*/
+	data = 0x4f609104;
+	pr_info("===start bit\n");
+	hdmi_cec_start_bit();
+
+	for (i = 0; i < 32; i++) {
+		if (data & 0x80000000)
+			hdmi_cec_send_bit(1);
+		else
+			hdmi_cec_send_bit(0);
+
+		data = data << 1;
+	}
+
+	data = 0x03;
+	for (i = 0; i < 8; i++) {
+		if (data & 0x80)
+			hdmi_cec_send_bit(1);
+		else
+			hdmi_cec_send_bit(0);
+
+		data = data << 1;
+	}
+
+	hdmi_cec_enable(0);
+
+	return 0;
+
+}
+
+#if 0 /* Not used */
+static __s32 hdmi_cec_init(void)
+{
+	cec_enable = 0;
+	cec_logical_addr = HDMI_CEC_LADDR_PAYER1;
+	return 0;
+}
+#endif
+
+void hdmi_cec_task_loop(void)
+{
+
+	struct __hdmi_cec_msg_t msg;
+	if (!cec_standby) {
+		switch (cec_count % 10) {
+		case 9:
+			msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+			msg.follower_addr = HDMI_CEC_LADDR_TV;
+			msg.opcode_valid = 1;
+			msg.opcode = HDMI_CEC_OP_IMAGE_VIEW_ON;
+			msg.para_num = 0;
+
+			hdmi_cec_send_msg(&msg);
+			pr_debug("################HDMI_CEC_OP_IMAGE_VIEW_ON\n");
+			break;
+		case 7:
+			msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+			msg.follower_addr = HDMI_CEC_LADDR_BROADCAST;
+			msg.opcode_valid = 1;
+			msg.opcode = HDMI_CEC_OP_ACTIVE_SOURCE;
+			msg.para_num = 2;
+			msg.para[0] = (cec_phy_addr >> 8) & 0xff;
+			msg.para[1] = cec_phy_addr & 0xff;
+
+			hdmi_cec_send_msg(&msg);
+
+			pr_debug("#################HDMI_CEC_LADDR_BROADCAST\n");
+			break;
+		default:
+
+			break;
+
+		}
+	} else {
+		switch (cec_count % 10) {
+		case 9:
+			msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+			msg.follower_addr = HDMI_CEC_LADDR_TV;
+			msg.opcode_valid = 1;
+			msg.opcode = HDMI_CEC_OP_INACTIVE_SOURCE;
+			msg.para_num = 2;
+			msg.para[0] = (cec_phy_addr >> 8) & 0xff;
+			msg.para[1] = cec_phy_addr & 0xff;
+			hdmi_cec_send_msg(&msg);
+		case 7:
+			msg.initiator_addr = HDMI_CEC_LADDR_PAYER1;
+			msg.follower_addr = HDMI_CEC_LADDR_BROADCAST;
+			msg.opcode_valid = 1;
+			msg.opcode = HDMI_CEC_OP_STANDBY;
+			msg.para_num = 0;
+
+			hdmi_cec_send_msg(&msg);
+		}
+	}
+	if (cec_count > 1)
+		cec_count--;
+}
+
diff --git a/drivers/video/sunxi/hdmi/hdmi_cec.h b/drivers/video/sunxi/hdmi/hdmi_cec.h
new file mode 100644
index 0000000..8175387
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/hdmi_cec.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "drv_hdmi_i.h"
+
+/* time us */
+#define HDMI_CEC_START_BIT_LOW_TIME 3700
+#define HDMI_CEC_START_BIT_WHOLE_TIME 4500
+
+#define HDMI_CEC_DATA_BIT0_LOW_TIIME 1500
+#define HDMI_CEC_DATA_BIT1_LOW_TIME  600
+#define HDMI_CEC_DATA_BIT_WHOLE_TIME 2400
+/* ack */
+#define HDMI_CEC_NORMAL_MSG_ACK 0X0
+#define HDMI_CEC_BROADCAST_MSG_ACK 0X1
+
+enum __hdmi_cec_opcode {
+	HDMI_CEC_OP_IMAGE_VIEW_ON = 0X04,
+	HDMI_CEC_OP_TEXT_VIEW_ON = 0X0D,
+	HDMI_CEC_OP_STANDBY = 0X36,
+	HDMI_CEC_OP_SET_OSD_NAME = 0X47,
+	HDMI_CEC_OP_ROUTING_CHANGE = 0X80,
+	HDMI_CEC_OP_ACTIVE_SOURCE = 0X82,
+	HDMI_CEC_OP_REPORT_PHY_ADDRESS = 0X84,
+	HDMI_CEC_OP_DEVICE_VENDOR_ID = 0X87,
+	HDMI_CEC_OP_MENU_STATE = 0X8E,
+	HDMI_CEC_OP_REQUEST_POWER_STATUS = 0X8F,
+	HDMI_CEC_OP_REPORT_POWER_STATUS = 0X90,
+	HDMI_CEC_OP_INACTIVE_SOURCE = 0X9D,
+	HDMI_CEC_OP_NUM = 0xff,
+};
+
+enum __hdmi_cec_logical_address {
+	HDMI_CEC_LADDR_TV,
+	HDMI_CEC_LADDR_RECORDER1,
+	HDMI_CEC_LADDR_RECORDER2,
+	HDMI_CEC_LADDR_TUNER1,
+	HDMI_CEC_LADDR_PAYER1,
+	HDMI_CEC_LADDR_AUDIO,
+	HDMI_CEC_LADDR_TUNER2,
+	HDMI_CEC_LADDR_TUNER3,
+	HDMI_CEC_LADDR_PAYER2,
+	HDMI_CEC_LADDR_RECORDER3,
+	HDMI_CEC_LADDR_TUNER4,
+	HDMI_CEC_LADDR_PAYER3,
+	HDMI_CEC_LADDR_RESERVED1,
+	HDMI_CEC_LADDR_RESERVED2,
+	HDMI_CEC_LADDR_SPECIFIC,
+	HDMI_CEC_LADDR_BROADCAST,
+};
+
+enum __hdmi_cec_msg_eom {
+	HDMI_CEC_MSG_MORE, HDMI_CEC_MSG_END,
+};
+
+struct __hdmi_cec_msg_t {
+	enum __hdmi_cec_logical_address initiator_addr;
+	enum __hdmi_cec_logical_address follower_addr;
+	__u32 opcode_valid; /* indicate there is opcode or not */
+	enum __hdmi_cec_opcode opcode;
+	__u32 para[14];   /* byte */
+	__u32 para_num;   /* byte < 16byte */
+};
+
+extern __bool cec_enable;
+extern __bool cec_standby;
+extern __u32 cec_phy_addr;
+extern __u32 cec_logical_addr;
+extern __u8 cec_count;
+extern __u32 cec_phy_addr;
+
+__s32 hdmi_cec_test(void);
+__s32 hdmi_cec_send_msg(struct __hdmi_cec_msg_t *msg);
+__s32 hdmi_cec_receive_msg(struct __hdmi_cec_msg_t *msg);
+void hdmi_cec_task_loop(void);
diff --git a/drivers/video/sunxi/hdmi/hdmi_core.c b/drivers/video/sunxi/hdmi/hdmi_core.c
new file mode 100644
index 0000000..c1c4c9c
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/hdmi_core.c
@@ -0,0 +1,643 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <plat/system.h>
+#include "../disp/sunxi_disp_regs.h"
+#include "../disp/OSAL_Clock.h"
+#include "hdmi_cec.h"
+#include "hdmi_core.h"
+
+static char *audio;
+module_param(audio, charp, 0444);
+MODULE_PARM_DESC(audio,
+	"Enable/disable audio over hdmi: "
+	"\"EDID:0\": get value from EDID, fallback disabled; "
+	"\"EDID:1\": get value from EDID, fallback enabled; "
+	"\"0\": disabled; \"1\": enabled.");
+
+__s32 hdmi_state = HDMI_State_Wait_Hpd;
+__bool video_enable;
+static __bool audio_edid;
+static __bool audio_enable = 1;
+__s32 video_mode = HDMI720P_50;
+HDMI_AUDIO_INFO audio_info;
+__u8 Device_Support_VIC[HDMI_DEVICE_SUPPORT_VIC_SIZE];
+static __s32 HPD;
+static int audio_devs_registered;
+
+__u32 hdmi_pll = AW_SYS_CLK_PLL3;
+__u32 hdmi_clk = 297000000;
+
+struct __disp_video_timing video_timing[] = {
+	/* VIC                 PCLK   AVI_PR INPUTX INPUTY HT   HBP  HFP HPSW  VT  VBP VFP VPSW I HSYNC VSYNC */
+	{ HDMI1440_480I,       13500000,  1,   720,  480,  858, 119,  19, 62,  525, 18,  4,  3, 1,  0,  0 },
+	{ HDMI1440_576I,       13500000,  1,   720,  576,  864, 132,  12, 63,  625, 22,  2,  3, 1,  0,  0 },
+	{ HDMI480P,            27000000,  0,   720,  480,  858, 122,  16, 62,  525, 36,  9,  6, 0,  0,  0 },
+	{ HDMI576P,            27000000,  0,   720,  576,  864, 132,  12, 64,  625, 44,  5,  5, 0,  0,  0 },
+	{ HDMI720P_50,         74250000,  0,  1280,  720, 1980, 260, 440, 40,  750, 25,  5,  5, 0,  1,  1 },
+	{ HDMI720P_60,         74250000,  0,  1280,  720, 1650, 260, 110, 40,  750, 25,  5,  5, 0,  1,  1 },
+	{ HDMI1080I_50,        74250000,  0,  1920, 1080, 2640, 192, 528, 44, 1125, 20,  2,  5, 1,  1,  1 },
+	{ HDMI1080I_60,        74250000,  0,  1920, 1080, 2200, 192,  88, 44, 1125, 20,  2,  5, 1,  1,  1 },
+	{ HDMI1080P_50,       148500000,  0,  1920, 1080, 2640, 192, 528, 44, 1125, 41,  4,  5, 0,  1,  1 },
+	{ HDMI1080P_60,       148500000,  0,  1920, 1080, 2200, 192,  88, 44, 1125, 41,  4,  5, 0,  1,  1 },
+	{ HDMI1080P_24,        74250000,  0,  1920, 1080, 2750, 192, 638, 44, 1125, 41,  4,  5, 0,  1,  1 },
+	{ HDMI1080P_24_3D_FP, 148500000,  0,  1920, 2160, 2750, 192, 638, 44, 1125, 41,  4,  5, 0,  1,  1 },
+	{ HDMI720P_50_3D_FP,  148500000,  0,  1280, 1440, 1980, 260, 440, 40,  750, 25,  5,  5, 0,  1,  1 },
+	{ HDMI720P_60_3D_FP,  148500000,  0,  1280, 1440, 1650, 260, 110, 40,  750, 25,  5,  5, 0,  1,  1 },
+	{ HDMI1360_768_60,     85500000,  0,  1360,  768, 1792, 368, 64, 112,  795, 24,  3,  6, 0,  1,  1 },
+	{ HDMI1280_1024_60,   108000000,  0,  1280, 1024, 1688, 360, 48, 112, 1066, 41,  1,  3, 0,  1,  1 },
+	{ HDMI_EDID, } /* Entry reserved for EDID detected preferred timing */
+};
+
+const int video_timing_edid = ARRAY_SIZE(video_timing) - 1;
+
+static struct platform_device audio_devs[] = {
+	{ .name = "sunxi-sndhdmi" },
+	{ .name = "sunxi-hdmiaudio" },
+	{ .name = "sunxi-hdmiaudio-codec" },
+	{ .name = "sunxi-hdmiaudio-pcm-audio" },
+};
+
+void hdmi_delay_ms(__u32 t)
+{
+	__u32 timeout = t * HZ / 1000;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(timeout);
+}
+
+__s32 hdmi_core_initial(void)
+{
+	if (audio) {
+		if (strncmp(audio, "EDID:", 5) == 0) {
+			audio_edid = 1;
+			audio += 5;
+		}
+		if (strcmp(audio, "0") == 0)
+			audio_enable = 0;
+	}
+
+	hdmi_state = HDMI_State_Wait_Hpd;
+	video_mode = HDMI720P_50;
+	memset(&audio_info, 0, sizeof(HDMI_AUDIO_INFO));
+	memset(Device_Support_VIC, 0, HDMI_DEVICE_SUPPORT_VIC_SIZE);
+
+	writel(0x80000000, HDMI_CTRL); /* start hdmi controller */
+	if (sunxi_is_sun7i())
+		writel(0xe0000000, HDMI_TX_DRIVER); /* power enable */
+
+	return 0;
+}
+
+static __s32
+main_Hpd_Check(void)
+{
+	__s32 i, times;
+	times = 0;
+
+	for (i = 0; i < 3; i++) {
+		hdmi_delay_ms(10);
+		if (readl(HDMI_HPD) & 0x01)
+			times++;
+	}
+	if (times == 3)
+		return 1;
+	else
+		return 0;
+}
+
+__s32 hdmi_main_task_loop(void)
+{
+	int rc, i;
+
+	HPD = main_Hpd_Check();
+	if (!HPD && hdmi_state > HDMI_State_Wait_Hpd) {
+		__inf("plugout\n");
+		hdmi_state = HDMI_State_Wait_Hpd;
+	}
+
+	hdmi_cec_task_loop();
+
+	/* ? where did all the breaks run off to? --libv */
+	switch (hdmi_state) {
+	case HDMI_State_Wait_Hpd:
+		if (HPD) {
+			hdmi_state = HDMI_State_EDID_Parse;
+			__inf("plugin\n");
+		} else
+			return 0;
+
+	case HDMI_State_Rx_Sense:
+
+	case HDMI_State_EDID_Parse:
+		writel(0x80000000, HDMI_CTRL);
+		writel((1 << 31) + (1 << 30) + (1 << 29) +
+			     (3 << 27) + (0 << 26) + (1 << 25) + (0 << 24) +
+			     (0 << 23) + (4 << 20) + (7 << 17) + (15 << 12) +
+			     (7 << 8) + (0x0f << 4) + (8 << 0),
+			     HDMI_TX_DRIVER + 8);
+		writel(0xfe800000, HDMI_TX_DRIVER); /* txen enable */
+		writel(0x00D8C860, HDMI_TX_DRIVER + 4); /* ckss = 1 */
+
+		writel(0 << 21, HDMI_TX_DRIVER + 12);
+
+		ParseEDID();
+		readl(HDMI_I2C_UNKNOWN_1);
+
+		if (!cec_standby)
+			cec_count = 100;
+
+		if (audio_edid && Device_Support_VIC[HDMI_EDID]) {
+			if (audio_info.supported_rates)
+				audio_enable = 1;
+			else
+				audio_enable = 0;
+		}
+		if (audio_enable && !audio_devs_registered) {
+			for (i = 0; i < ARRAY_SIZE(audio_devs); i++) {
+				rc = platform_device_register(audio_devs + i);
+				if (rc < 0)
+					pr_warn("Failed to register %s (%d)\n",
+						audio_devs[i].name, rc);
+			}
+			audio_devs_registered = 1;
+		}
+		hdmi_state = HDMI_State_Wait_Video_config;
+
+	case HDMI_State_Wait_Video_config:
+		if (video_enable)
+			hdmi_state = HDMI_State_Video_config;
+		else
+			return 0;
+
+	case HDMI_State_Video_config:
+		video_config(video_mode);
+		hdmi_state = HDMI_State_Audio_config;
+
+	case HDMI_State_Audio_config:
+		audio_config();
+		hdmi_state = HDMI_State_Playback;
+
+	case HDMI_State_Playback:
+		return 0;
+
+	default:
+		__wrn(" unknown hdmi state, set to idle\n");
+		hdmi_state = HDMI_State_Wait_Hpd;
+		return 0;
+	}
+}
+
+__s32 Hpd_Check(void)
+{
+	if (HPD == 0)
+		return 0;
+	else if (hdmi_state >= HDMI_State_Wait_Video_config)
+		return 1;
+	else
+		return 0;
+}
+
+__s32 get_video_info(__s32 vic)
+{
+	__s32 i, count;
+	count = sizeof(video_timing);
+	for (i = 0; i < count; i++)
+		if (vic == video_timing[i].VIC)
+			return i;
+
+	__wrn("can't find the video timing parameters\n");
+	return -1;
+}
+
+static __s32 get_audio_info(__s32 sample_rate)
+{
+	__s32 vic_tab;
+
+	/*
+	 * ACR_N 32000 44100 48000 88200 96000 176400 192000
+	 *       4096  6272  6144  12544 12288  25088  24576
+	 */
+	__inf("sample_rate:%d in get_audio_info\n", sample_rate);
+
+	switch (sample_rate) {
+	case 32000:
+		audio_info.ACR_N = 4096;
+		audio_info.CH_STATUS0 = (3 << 24);
+		audio_info.CH_STATUS1 = 0x0000000b;
+		break;
+	case 44100:
+		audio_info.ACR_N = 6272;
+		audio_info.CH_STATUS0 = (0 << 24);
+		audio_info.CH_STATUS1 = 0x0000000b;
+		break;
+	case 48000:
+		audio_info.ACR_N = 6144;
+		audio_info.CH_STATUS0 = (2 << 24);
+		audio_info.CH_STATUS1 = 0x0000000b;
+		break;
+	case 88200:
+		audio_info.ACR_N = 12544;
+		audio_info.CH_STATUS0 = (8 << 24);
+		audio_info.CH_STATUS1 = 0x0000000b;
+		break;
+	case 96000:
+		audio_info.ACR_N = 12288;
+		audio_info.CH_STATUS0 = (10 << 24);
+		audio_info.CH_STATUS1 = 0x0000000b;
+		break;
+	case 176400:
+		audio_info.ACR_N = 25088;
+		audio_info.CH_STATUS0 = (12 << 24);
+		audio_info.CH_STATUS1 = 0x0000000b;
+		break;
+	case 192000:
+		audio_info.ACR_N = 24576;
+		audio_info.CH_STATUS0 = (14 << 24);
+		audio_info.CH_STATUS1 = 0x0000000b;
+		break;
+	default:
+		__wrn("un-support sample_rate,value=%d\n", sample_rate);
+		return -1;
+	}
+
+	vic_tab = get_video_info(video_mode);
+	if (vic_tab == -1)
+		return -1;
+
+	audio_info.CTS = ((video_timing[vic_tab].PCLK / 100) *
+			  (audio_info.ACR_N / 128)) / (sample_rate / 100);
+	__inf("audio CTS calc:%d\n", audio_info.CTS);
+
+	return 0;
+}
+
+__s32 video_config(__s32 vic)
+{
+
+	__s32 vic_tab, clk_div, reg_val, dw = 0;
+
+	__inf("video_config, vic:%d\n", vic);
+
+	vic_tab = get_video_info(vic);
+	if (vic_tab == -1)
+		return 0;
+	else
+		video_mode = vic;
+
+	if ((vic == HDMI1440_480I) || (vic == HDMI1440_576I))
+		dw = 1; /* Double Width */
+
+	writel(0x00000000, HDMI_CTRL);
+	writel(0x00000000, HDMI_AUDIO_CTRL); /* disable audio output */
+	writel(0x00000000, HDMI_VIDEO_CTRL); /* disable video output */
+	/* interrupt mask and clear all interrupt */
+	writel(0xffffffff, HDMI_INT_CTRL);
+
+	reg_val = 0x00000000;
+	if (dw)
+		reg_val |= 0x00000001; /* repetition */
+	if (video_timing[vic_tab].I)
+		reg_val |= 0x00000010; /* interlace */
+	writel(reg_val, HDMI_VIDEO_CTRL);
+
+	/* active H */
+	writew((video_timing[vic_tab].INPUTX << dw) - 1, HDMI_VIDEO_H);
+	/* active HBP */
+	writew((video_timing[vic_tab].HBP << dw) - 1, HDMI_VIDEO_HBP);
+	/* active HFP */
+	writew((video_timing[vic_tab].HFP << dw) - 1, HDMI_VIDEO_HFP);
+	/* active HSPW */
+	writew((video_timing[vic_tab].HPSW << dw) - 1, HDMI_VIDEO_HSPW);
+
+	/* set active V */
+	if ((vic == HDMI1080P_24_3D_FP) || (vic == HDMI720P_50_3D_FP) ||
+	    (vic == HDMI720P_60_3D_FP))
+		writew(video_timing[vic_tab].INPUTY +
+			     video_timing[vic_tab].VBP +
+			     video_timing[vic_tab].VFP - 1,
+			     HDMI_VIDEO_V);
+	else if (video_timing[vic_tab].I)
+		writew((video_timing[vic_tab].INPUTY / 2) - 1, HDMI_VIDEO_V);
+	else
+		writew(video_timing[vic_tab].INPUTY - 1, HDMI_VIDEO_V);
+
+	/* active VBP */
+	writew(video_timing[vic_tab].VBP - 1, HDMI_VIDEO_VBP);
+	/* active VFP */
+	writew(video_timing[vic_tab].VFP - 1, HDMI_VIDEO_VFP);
+	/* active VSPW */
+	writew(video_timing[vic_tab].VPSW - 1, HDMI_VIDEO_VPSW);
+
+	reg_val = 0;
+	if (video_timing[vic_tab].HSYNC)
+		reg_val |= 0x01; /* Positive Hsync */
+	if (video_timing[vic_tab].VSYNC)
+		reg_val |= 0x02; /* Positive Vsync */
+	writew(reg_val, HDMI_VIDEO_POLARITY);
+
+	writew(0x03e0, HDMI_TX_CLOCK); /* TX clock sequence */
+
+	/* avi packet */
+	writeb(0x82, HDMI_AVI_INFOFRAME);
+	writeb(0x02, HDMI_AVI_INFOFRAME + 1);
+	writeb(0x0d, HDMI_AVI_INFOFRAME + 2);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 3);
+#ifdef YUV_COLORSPACE /* Fix me */
+	writeb(0x52, HDMI_AVI_INFOFRAME + 4); /* Data Byte 1: 4:4:4 YCbCr */
+#else
+	writeb(0x12, HDMI_AVI_INFOFRAME + 4); /* Data Byte 1: RGB */
+#endif
+	if (video_timing[vic_tab].PCLK <= 27000000)
+		reg_val = 0x40;  /* SD-modes, assume ITU601 colorspace */
+	else
+		reg_val = 0x80;  /* HD-modes, assume ITU709 colorspace */
+	if (video_timing[vic_tab].INPUTX * 100 /
+			video_timing[vic_tab].INPUTY < 156)
+		reg_val |= 0x18; /* 4 : 3 */
+	else
+		reg_val |= 0x28; /* 16 : 9 */
+	writeb(reg_val, HDMI_AVI_INFOFRAME + 5); /* Data Byte 2 */
+#ifdef YUV_COLORSPACE /* Fix me */
+	writeb(0x80, HDMI_AVI_INFOFRAME + 6);
+#else
+	writeb(0x88, HDMI_AVI_INFOFRAME + 6);
+#endif
+	writeb((video_timing[vic_tab].VIC >= HDMI_NON_CEA861D_START) ?
+			   0 : video_timing[vic_tab].VIC,
+			   HDMI_AVI_INFOFRAME + 7);
+	writeb(video_timing[vic_tab].AVI_PR, HDMI_AVI_INFOFRAME + 8);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 9);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 10);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 11);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 12);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 13);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 14);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 15);
+	writeb(0x00, HDMI_AVI_INFOFRAME + 16);
+
+	reg_val = readb(HDMI_AVI_INFOFRAME) +
+		readb(HDMI_AVI_INFOFRAME + 1) +
+		readb(HDMI_AVI_INFOFRAME + 2) +
+		readb(HDMI_AVI_INFOFRAME + 4) +
+		readb(HDMI_AVI_INFOFRAME + 5) +
+		readb(HDMI_AVI_INFOFRAME + 6) +
+		readb(HDMI_AVI_INFOFRAME + 7) +
+		readb(HDMI_AVI_INFOFRAME + 8) +
+		readb(HDMI_AVI_INFOFRAME + 9) +
+		readb(HDMI_AVI_INFOFRAME + 10) +
+		readb(HDMI_AVI_INFOFRAME + 11) +
+		readb(HDMI_AVI_INFOFRAME + 12) +
+		readb(HDMI_AVI_INFOFRAME + 13) +
+		readb(HDMI_AVI_INFOFRAME + 14) +
+		readb(HDMI_AVI_INFOFRAME + 15) +
+		readb(HDMI_AVI_INFOFRAME + 16);
+	reg_val = reg_val & 0xff;
+	if (reg_val != 0)
+		reg_val = 0x100 - reg_val;
+
+	writeb(reg_val, HDMI_AVI_INFOFRAME + 3); /* checksum */
+
+	/* gcp packet */
+	writel(0x00000003, HDMI_QCP_PACKET);
+	writel(0x00000000, HDMI_QCP_PACKET + 4);
+
+	/* vendor infoframe */
+	writeb(0x81, HDMI_VENDOR_INFOFRAME);
+	writeb(0x01, HDMI_VENDOR_INFOFRAME + 1);
+	writeb(6, HDMI_VENDOR_INFOFRAME + 2);	/* length */
+
+	writeb(0x29, HDMI_VENDOR_INFOFRAME + 3); /* pb0:checksum */
+	writeb(0x03, HDMI_VENDOR_INFOFRAME + 4); /* pb1-3:24bit ieee id */
+	writeb(0x0c, HDMI_VENDOR_INFOFRAME + 5);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 6);
+	writeb(0x40, HDMI_VENDOR_INFOFRAME + 7); /* pb4 */
+	/* pb5:3d meta not present, frame packing */
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 8);
+
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 9); /* pb6:extra data for 3d */
+	/* pb7: matadata type=0,len=8 */
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 10);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 11);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 12);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 13);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 14);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 15);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 16);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 17);
+	writeb(0x00, HDMI_VENDOR_INFOFRAME + 18);
+
+	/* packet config */
+	if ((vic != HDMI1080P_24_3D_FP) && (vic != HDMI720P_50_3D_FP) &&
+	    (vic != HDMI720P_60_3D_FP)) {
+		writel(0x0000f321, HDMI_PACKET_CONFIG);
+		writel(0x0000000f, HDMI_PACKET_CONFIG + 4);
+	} else {
+		writel(0x00005321, HDMI_PACKET_CONFIG);
+		writel(0x0000000f, HDMI_PACKET_CONFIG + 4);
+	}
+
+	writel(0x08000000, HDMI_UNKNOWN); /* set input sync enable */
+
+	if (audio_enable)
+		writeb(0xc0, HDMI_VIDEO_CTRL + 3); /* hdmi mode + hdmi audio */
+	else
+		writeb(0x80, HDMI_VIDEO_CTRL + 3); /* hdmi/dvi mode */
+	writel(0x80000000, HDMI_CTRL); /* start hdmi controller */
+
+	if (audio_enable)
+		writeb(0xc0, HDMI_VIDEO_CTRL + 3); /* hdmi mode + hdmi audio */
+	else
+		writeb(0x80, HDMI_VIDEO_CTRL + 3); /* hdmi/dvi mode */
+	writel(0x80000000, HDMI_CTRL); /* start hdmi controller */
+
+	/* hdmi pll setting */
+	if ((vic == HDMI1440_480I) || (vic == HDMI1440_576I)) {
+		clk_div = hdmi_clk / video_timing[vic_tab].PCLK;
+		clk_div /= 2;
+	} else {
+		clk_div = hdmi_clk / video_timing[vic_tab].PCLK;
+	}
+	clk_div &= 0x0f;
+
+	writel((1 << 31) + (1 << 30) + (1 << 29) + (3 << 27) + (0 << 26) +
+	     (1 << 25) + (0 << 24) + (0 << 23) + (4 << 20) + (7 << 17) +
+	     (15 << 12) + (7 << 8) + (clk_div << 4) + (8 << 0),
+	     HDMI_TX_DRIVER + 8);
+
+	/* tx driver setting */
+	writel(0xfe800000, HDMI_TX_DRIVER); /* txen enable */
+
+	/*
+	 * Below are some notes on the use of register 0x204 and register 0x20c
+	 * this is the result of reverse-engineering / trial and error and
+	 * thus not necessarily 100% accurate.
+	 *
+	 * Some notes on register 0x204:
+	 * bit 0:     Setting this bit turns the entire fbcon background blue
+	 * bit 1:     Setting this bit turns the entire fbcon background green
+	 * bit 2:     Setting this bit turns the entire fbcon background red
+	 * bit 3:     Unknown, best left 0
+	 * bit 4-5:   These need to be a specific value otherwise the colors
+	 *            will be wrong and some lines will be noise / distortion.
+	 *            The sunxi source dumps use 10 (2) for sun4i and 01 (1)
+	 *            for sun5i and sun7i. Experimentation has found 11 (3) to
+	 *            be a better value for sun5i and sun7i.
+	 * bit 6:     Selects a pre-scaler for the clock which divides by 2 ?
+	 * bit 7:     Setting this bit causes severe line noise in some cases
+	 * bit 8-11:  These seem to set some fifo prefetch balance, default val
+	 *            1000 (8), in cases where there seem to be fifo underruns
+	 *            (some pixels are yellow / flicker) changing this value
+	 *            helps, ie we use 7 on non sun4i for single pll modes.
+	 * bit 12-13: Setting these causes bad / no video in some cases leave 0
+	 * bit 14-15: Clearing one of these bits causes loss of sync
+	 * bit 16-22: Do not seem to do anything
+	 * bit 23:    Clearing this bit causes inverse video
+	 * bit 24-31: Do not seem to do anything
+	 *
+	 * Some notes on register 0x020c:
+	 * bit 0-15:  Do not seem to do anything
+	 * bit 16:    Setting this bit causes the A10 to lockup, do not set!
+	 * bit 17-20: Do not seem to do anything
+	 * bit 21:    0: PLL3X2 is clocksource 1: PLL7X2 is clocksource
+	 * bit 22-23: Setting these bits causes loss of sync, possibly these
+	 *            work together with b21 to select a different clocksource
+	 * bit 24-31: Do not seem to do anything
+	 *
+	 * About clocksource selection for the hdmi transmitter:
+	 *
+	 * It seems that AW_MOD_CLK_HDMI is unused, atleast giving it a
+	 * different clock-divider does not cause any problems. Instead the
+	 * hdmi transmitter has its own bits to select the sys-clk to use,
+	 * with bit 21 of 0x20c selecting between PLL3X2 and PLL7X2, and
+	 * bit 6 of 0x204 enabling a pre-scaler dividing by 2, in essence
+	 * turning PLL3X2 and PLL7X2 into PLL3 and PLL7. *Or so I believe*,
+	 * It could also be that bit 6 of 0x204 simple causes direct selection
+	 * of PLL3 and PLL7 through bit 21 of 0x20c, but that seems illogical
+	 * since it lives in another register.
+	 */
+
+	if (hdmi_pll == AW_SYS_CLK_PLL3 || hdmi_pll == AW_SYS_CLK_PLL7) {
+		/* non doubled pll */
+		if (sunxi_is_sun4i())
+			writel(0x00D8C860, HDMI_TX_DRIVER + 4);
+		else
+			writel(0x00D8C770, HDMI_TX_DRIVER + 4);
+	} else {
+		/* x2 pll */
+		if (sunxi_is_sun4i()) {
+			writel(0x00D8C820, HDMI_TX_DRIVER + 4);
+		} else {
+			/* HDG: Note 0x00D8C438 also works */ 
+			writel(0x00D8C830, HDMI_TX_DRIVER + 4);
+                }
+	}
+
+	if (hdmi_pll == AW_SYS_CLK_PLL7 || hdmi_pll == AW_SYS_CLK_PLL7X2)
+		writel(1 << 21, HDMI_TX_DRIVER + 12);
+	else
+		writel(0 << 21, HDMI_TX_DRIVER + 12);
+
+	return 0;
+}
+
+__s32 audio_config(void)
+{
+	__s32 i;
+
+	__inf("audio_config, sample_rate:%d\n", audio_info.sample_rate);
+
+	writel(0x00000000, HDMI_AUDIO_CTRL);
+	writel(0x40000000, HDMI_AUDIO_CTRL);
+	while (readl(HDMI_AUDIO_CTRL) != 0)
+		;
+	writel(0x40000000, HDMI_AUDIO_CTRL);
+	while (readl(HDMI_AUDIO_CTRL) != 0)
+		;
+
+	if (!audio_info.audio_en)
+		return 0;
+
+	i = get_audio_info(audio_info.sample_rate);
+	if (i == -1)
+		return 0;
+
+	if (audio_info.channel_num == 1) {
+		/* audio fifo rst and select ddma, 2 ch 16bit pcm */
+		writel(0x00000000, HDMI_AUDIO_UNKNOWN_0);
+		/* ddma,pcm layout0 1ch */
+		writel(0x00000000, HDMI_AUDIO_LAYOUT);
+		writel(0x76543200, HDMI_AUDIO_UNKNOWN_1);
+
+		/* audio infoframe head */
+		writel(0x710a0184, HDMI_AUDIO_INFOFRAME);
+		writel(0x00000000, HDMI_AUDIO_INFOFRAME + 4); /* CA = 0X1F */
+		writel(0x00000000, HDMI_AUDIO_INFOFRAME + 8);
+		writel(0x00000000, HDMI_AUDIO_INFOFRAME + 12);
+	} else if (audio_info.channel_num == 2) {
+		/* audio fifo rst and select ddma, 2 ch 16bit pcm */
+		writel(0x00000000, HDMI_AUDIO_UNKNOWN_0);
+		/* ddma,pcm layout0 2ch */
+		writel(0x00000001, HDMI_AUDIO_LAYOUT);
+		writel(0x76543210, HDMI_AUDIO_UNKNOWN_1);
+
+		/* audio infoframe head */
+		writel(0x710a0184, HDMI_AUDIO_INFOFRAME);
+		writel(0x00000000, HDMI_AUDIO_INFOFRAME + 4); /* CA = 0X1F */
+		writel(0x00000000, HDMI_AUDIO_INFOFRAME + 8);
+		writel(0x00000000, HDMI_AUDIO_INFOFRAME + 12);
+	} else if (audio_info.channel_num == 8) {
+		/* audio fifo rst and select ddma, 2 ch 16bit pcm */
+		writel(0x00000000, HDMI_AUDIO_UNKNOWN_0);
+		/* ddma,pcm layout1 8ch */
+		writel(0x0000000f, HDMI_AUDIO_LAYOUT);
+		writel(0x76543210, HDMI_AUDIO_UNKNOWN_1);
+
+		/* audio infoframe head */
+		writel(0x520a0184, HDMI_AUDIO_INFOFRAME);
+		writel(0x1F000000, HDMI_AUDIO_INFOFRAME + 4); /* CA = 0X1F */
+		writel(0x00000000, HDMI_AUDIO_INFOFRAME + 8);
+		writel(0x00000000, HDMI_AUDIO_INFOFRAME + 12);
+	} else
+		__wrn("unkonwn num_ch:%d\n", audio_info.channel_num);
+
+	writel(audio_info.CTS, HDMI_AUDIO_CTS); /* CTS and N */
+	writel(audio_info.ACR_N, HDMI_AUDIO_ACR_N);
+	writel(audio_info.CH_STATUS0, HDMI_AUDIO_CH_STATUS0);
+	writel(audio_info.CH_STATUS1, HDMI_AUDIO_CH_STATUS1);
+
+	writel(0x80000000, HDMI_AUDIO_CTRL);
+	writel(0x80000000, HDMI_CTRL);
+
+	/* for audio test */
+#if 0
+	/* dedicated dma setting aw1623 env */
+	/* ddma ch5 seting from addr =0x40c00000 */
+	writel(0x40c00000, 0xf1c023a4);
+	writel(0x00000000, 0xf1c023a8); /* des =0 */
+	writel(0x01f00000, 0xf1c023ac); /* byte to trans */
+	writel((31 << 24) + (7 << 16) + (31 << 8) +
+		       (7 << 0), 0xf1c023b8); /* data block and wait cycle */
+	/* from src0 to des1,continous mode */
+	writel(0xa4b80481, 0xf1c023a0);
+#endif
+
+	return 0;
+}
diff --git a/drivers/video/sunxi/hdmi/hdmi_core.h b/drivers/video/sunxi/hdmi/hdmi_core.h
new file mode 100644
index 0000000..50abbd1
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/hdmi_core.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __HDMI_CORE_H__
+#define __HDMI_CORE_H__
+
+#include "drv_hdmi_i.h"
+
+extern void __iomem *hdmi_base;
+
+#define HDMI_DEVICE_SUPPORT_VIC_SIZE	512
+
+#define HDMI_State_Wait_Hpd		0x02
+#define HDMI_State_Rx_Sense		0x03
+#define HDMI_State_EDID_Parse		0x04
+#define HDMI_State_Wait_Video_config	0x05
+#define HDMI_State_Video_config		0x06
+#define HDMI_State_Audio_config		0x07
+#define HDMI_State_Playback		0x09
+
+#define HDMI1440_480I		6
+#define HDMI1440_576I		21
+#define HDMI480P		2
+#define HDMI576P		17
+#define HDMI720P_50		19
+#define HDMI720P_60		4
+#define HDMI1080I_50		20
+#define HDMI1080I_60		5
+#define HDMI1080P_50		31
+#define HDMI1080P_60		16
+#define HDMI1080P_24		32
+#define HDMI1080P_25		33
+#define HDMI1080P_24_3D_FP	(HDMI1080P_24 + 0x80)
+#define HDMI720P_50_3D_FP	(HDMI720P_50  + 0x80)
+#define HDMI720P_60_3D_FP	(HDMI720P_60  + 0x80)
+
+/* Non CEA-861-D modes */
+#define HDMI_NON_CEA861D_START	256
+#define HDMI1360_768_60		(HDMI_NON_CEA861D_START + 0)
+#define HDMI1280_1024_60	(HDMI_NON_CEA861D_START + 1)
+#define HDMI_EDID		(HDMI_DEVICE_SUPPORT_VIC_SIZE - 1) 
+
+#define HDMI_WUINT32(offset, value)	writel(value, HDMI_BASE + offset)
+#define HDMI_RUINT32(offset)		readl(HDMI_BASE + offset)
+#define HDMI_WUINT16(offset, value)	writew(value, HDMI_BASE + offset)
+#define HDMI_RUINT16(offset)		readw(HDMI_BASE + offset)
+#define HDMI_WUINT8(offset, value)	writeb(value, HDMI_BASE + offset)
+#define HDMI_RUINT8(offset)		readb(HDMI_BASE + offset)
+
+#define Abort_Current_Operation			0
+#define Special_Offset_Address_Read		1
+#define Explicit_Offset_Address_Write		2
+#define Implicit_Offset_Address_Write		3
+#define Explicit_Offset_Address_Read		4
+#define Implicit_Offset_Address_Read		5
+#define Explicit_Offset_Address_E_DDC_Read	6
+#define Implicit_Offset_Address_E_DDC_Read	7
+
+typedef struct audio_timing {
+
+	unsigned long supported_rates;
+
+	__s32 audio_en;
+	__s32 sample_rate;
+	__s32 channel_num;
+
+	__s32 CTS;
+	__s32 ACR_N;
+	__s32 CH_STATUS0;
+	__s32 CH_STATUS1;
+
+} HDMI_AUDIO_INFO;
+
+void hdmi_delay_ms(__u32 t);
+__s32 hdmi_core_initial(void);
+__s32 hdmi_core_open(void);
+__s32 hdmi_core_close(void);
+__s32 hdmi_main_task_loop(void);
+__s32 Hpd_Check(void);
+__s32 ParseEDID(void);
+__s32 video_config(__s32 vic);
+__s32 audio_config(void);
+__s32 get_video_info(__s32 vic);
+
+extern __u32 hdmi_pll; /* 0: video pll 0; 1: video pll 1 */
+extern __u32 hdmi_clk;
+extern struct i2c_adapter sunxi_hdmi_i2c_adapter;
+int hdmi_i2c_sunxi_probe(struct platform_device *dev);
+int hdmi_i2c_sunxi_remove(struct platform_device *dev);
+
+extern __u8 Device_Support_VIC[HDMI_DEVICE_SUPPORT_VIC_SIZE];
+
+extern __bool video_enable;
+extern __s32 hdmi_state;
+extern __s32 video_mode;
+extern HDMI_AUDIO_INFO audio_info;
+
+extern struct __disp_video_timing video_timing[];
+extern const int video_timing_edid;
+
+#endif
diff --git a/drivers/video/sunxi/hdmi/hdmi_edid.c b/drivers/video/sunxi/hdmi/hdmi_edid.c
new file mode 100644
index 0000000..226db0b
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/hdmi_edid.c
@@ -0,0 +1,482 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <sound/pcm.h>
+#include <linux/fb.h>
+#include "hdmi_core.h"
+#include "../disp/dev_disp.h"
+#include "../disp/sunxi_disp_regs.h"
+#include "hdmi_cec.h"
+
+
+/*
+ * ParseEDID()
+ * Check EDID check sum and EDID 1.3 extended segment.
+ */
+static __s32
+EDID_CheckSum(__u8 block, __u8 *buf)
+{
+	__s32 i = 0, CheckSum = 0;
+	__u8 *pbuf = buf + 128 * block;
+
+	for (i = 0, CheckSum = 0; i < 128; i++) {
+		CheckSum += pbuf[i];
+		CheckSum &= 0xFF;
+	}
+
+	return CheckSum;
+}
+
+static __s32
+EDID_Header_Check(__u8 *pbuf)
+{
+	if (pbuf[0] != 0x00 || pbuf[1] != 0xFF || pbuf[2] != 0xFF ||
+	    pbuf[3] != 0xFF || pbuf[4] != 0xFF || pbuf[5] != 0xFF ||
+	    pbuf[6] != 0xFF || pbuf[7] != 0x00) {
+		pr_info("EDID block0 header error\n");
+		return -1;
+	}
+	return 0;
+}
+
+static __s32
+EDID_Version_Check(__u8 *pbuf)
+{
+	pr_info("EDID version: %d.%d\n", pbuf[0x12], pbuf[0x13]);
+	if (pbuf[0x12] != 0x01) {
+		pr_info("Unsupport EDID format,EDID parsing exit\n");
+		return -1;
+	}
+	if (pbuf[0x13] < 3 && !(pbuf[0x18] & 0x02)) {
+		pr_info("EDID revision < 3 and preferred timing feature bit "
+			"not set, ignoring EDID info\n");
+		return -1;
+	}
+	return 0;
+}
+
+struct pclk_override {
+	struct __disp_video_timing video_timing;
+	int pclk;
+};
+
+struct pclk_override pclk_override[] = {
+	/* VIC PCLK  AVI_PR INPUTX INPUTY HT   HBP  HFP  HPSW VT   VBP VFP VPSW I  HS VS   override */
+	{ { HDMI_EDID, 146250000, 0, 1680, 1050, 2240, 456, 104, 176, 1089, 36,  3, 6,  0, 0, 1 }, 146000000 },
+	{ { 0, }, -1 }
+};
+
+static __s32
+Parse_DTD_Block(__u8 *pbuf)
+{
+	__u32 i, dummy, pclk, sizex, Hblanking, sizey, Vblanking, Hsync_offset,
+		Hsync_pulsew, Vsync_offset, Vsync_pulsew, H_image_size,
+		V_image_size, H_Border, V_Border, pixels_total, frame_rate,
+		Hsync, Vsync, HT, VT;
+	pclk = (((__u32) pbuf[1] << 8) + pbuf[0]) * 10000;
+	sizex = (((__u32) pbuf[4] << 4) & 0x0f00) + pbuf[2];
+	Hblanking = (((__u32) pbuf[4] << 8) & 0x0f00) + pbuf[3];
+	sizey = (((__u32) pbuf[7] << 4) & 0x0f00) + pbuf[5];
+	Vblanking = (((__u32) pbuf[7] << 8) & 0x0f00) + pbuf[6];
+	Hsync_offset = (((__u32) pbuf[11] << 2) & 0x0300) + pbuf[8];
+	Hsync_pulsew = (((__u32) pbuf[11] << 4) & 0x0300) + pbuf[9];
+	Vsync_offset = (((__u32) pbuf[11] << 2) & 0x0030) + (pbuf[10] >> 4);
+	Vsync_pulsew = (((__u32) pbuf[11] << 4) & 0x0030) + (pbuf[10] & 0x0f);
+	H_image_size = (((__u32) pbuf[14] << 4) & 0x0f00) + pbuf[12];
+	V_image_size = (((__u32) pbuf[14] << 8) & 0x0f00) + pbuf[13];
+	H_Border = pbuf[15];
+	V_Border = pbuf[16];
+	Hsync = (pbuf[17] & 0x02) >> 1;
+	Vsync = (pbuf[17] & 0x04) >> 2;
+	HT = sizex + Hblanking;
+	VT = sizey + Vblanking;
+
+	pixels_total = HT * VT;
+
+	if ((pbuf[0] == 0) && (pbuf[1] == 0) && (pbuf[2] == 0))
+		return 0;
+
+	if (pixels_total == 0)
+		return 0;
+	else
+		frame_rate = pclk / pixels_total;
+
+	if ((frame_rate == 59) || (frame_rate == 60)) {
+		if ((sizex == 720) && (sizey == 240))
+			Device_Support_VIC[HDMI1440_480I] = 1;
+
+		if ((sizex == 720) && (sizey == 480))
+			Device_Support_VIC[HDMI480P] = 1;
+
+		if ((sizex == 1280) && (sizey == 720))
+			Device_Support_VIC[HDMI720P_60] = 1;
+
+		if ((sizex == 1920) && (sizey == 540))
+			Device_Support_VIC[HDMI1080I_60] = 1;
+
+		if ((sizex == 1920) && (sizey == 1080))
+			Device_Support_VIC[HDMI1080P_60] = 1;
+
+	} else if ((frame_rate == 49) || (frame_rate == 50)) {
+		if ((sizex == 720) && (sizey == 288))
+			Device_Support_VIC[HDMI1440_576I] = 1;
+
+		if ((sizex == 720) && (sizey == 576))
+			Device_Support_VIC[HDMI576P] = 1;
+
+		if ((sizex == 1280) && (sizey == 720))
+			Device_Support_VIC[HDMI720P_50] = 1;
+
+		if ((sizex == 1920) && (sizey == 540))
+			Device_Support_VIC[HDMI1080I_50] = 1;
+
+		if ((sizex == 1920) && (sizey == 1080))
+			Device_Support_VIC[HDMI1080P_50] = 1;
+
+	} else if ((frame_rate == 23) || (frame_rate == 24)) {
+		if ((sizex == 1920) && (sizey == 1080))
+			Device_Support_VIC[HDMI1080P_24] = 1;
+	}
+
+	pr_info("PCLK=%d X %d %d %d %d Y %d %d %d %d fr %d %s%s\n", pclk,
+		sizex, sizex + Hsync_offset,
+		sizex + Hsync_offset + Hsync_pulsew, HT,
+		sizey, sizey + Vsync_offset,
+		sizey + Vsync_offset + Vsync_pulsew, VT,
+		frame_rate, Hsync ? "P" : "N", Vsync ? "P" : "N");
+
+	/* Pick the first mode with a width which is a multiple of 8 and
+	   a supported pixel-clock */
+	if (Device_Support_VIC[HDMI_EDID] || (sizex & 7))
+		return 0;
+
+	video_timing[video_timing_edid].PCLK = pclk;
+	video_timing[video_timing_edid].AVI_PR = 0;
+	video_timing[video_timing_edid].INPUTX = sizex;
+	video_timing[video_timing_edid].INPUTY = sizey;
+	video_timing[video_timing_edid].HT = HT;
+	video_timing[video_timing_edid].HBP = Hblanking - Hsync_offset;
+	video_timing[video_timing_edid].HFP = Hsync_offset;
+	video_timing[video_timing_edid].HPSW = Hsync_pulsew;
+	video_timing[video_timing_edid].VT = VT;
+	video_timing[video_timing_edid].VBP = Vblanking - Vsync_offset;
+	video_timing[video_timing_edid].VFP = Vsync_offset;
+	video_timing[video_timing_edid].VPSW = Vsync_pulsew;
+	video_timing[video_timing_edid].I = (pbuf[17] & 0x80) >> 7;
+	video_timing[video_timing_edid].HSYNC = Hsync;
+	video_timing[video_timing_edid].VSYNC = Vsync;
+
+	for (i = 0; pclk_override[i].pclk != -1; i++) {
+		if (memcmp(&video_timing[video_timing_edid],
+			   &pclk_override[i].video_timing,
+			   sizeof(struct __disp_video_timing)) == 0) {
+			pr_info("Patching %d pclk to %d\n", pclk,
+				pclk_override[i].pclk);
+			video_timing[video_timing_edid].PCLK =
+				pclk_override[i].pclk;
+			break;
+		}
+	}
+
+	if (disp_get_pll_freq(video_timing[video_timing_edid].PCLK,
+			      &dummy, &dummy) != 0)
+		return 0;
+
+	if (disp_check_fbmem(-1, sizex, sizey) != 0)
+		return 0;
+
+	pr_info("Using above mode as preferred EDID mode\n");
+
+	if (video_timing[video_timing_edid].I) {
+		video_timing[video_timing_edid].INPUTY *= 2;
+		video_timing[video_timing_edid].VT *= 2;
+
+		/* Should VT be VT * 2 + 1, or VT * 2 ? */
+		frame_rate = (frame_rate + 1) / 2;
+		if ((HT * (VT * 2 + 1) * frame_rate) == pclk)
+			video_timing[video_timing_edid].VT++;
+
+		pr_info("Interlaced VT %d\n",
+			video_timing[video_timing_edid].VT);
+	}
+	Device_Support_VIC[HDMI_EDID] = 1;
+
+	return 0;
+}
+
+static __s32
+Parse_VideoData_Block(__u8 *pbuf, __u8 size)
+{
+	int i = 0;
+	while (i < size) {
+		Device_Support_VIC[pbuf[i] & 0x7f] = 1;
+		pr_info("Parse_VideoData_Block: VIC %d%s support\n",
+			pbuf[i] & 0x7f, (pbuf[i] & 0x80) ? " (native)" : "");
+		i++;
+	}
+	return 0;
+}
+
+static __s32
+Parse_AudioData_Block(__u8 *pbuf, __u8 size)
+{
+	__u8 sum = 0;
+	unsigned long rates = 0;
+
+	while (sum < size) {
+		if ((pbuf[sum] & 0xf8) == 0x08) {
+			int c = (pbuf[sum] & 0x7) + 1;
+			pr_info("Parse_AudioData_Block: max channel=%d\n", c);
+			pr_info("Parse_AudioData_Block: SampleRate code=%x\n",
+			      pbuf[sum + 1]);
+			pr_info("Parse_AudioData_Block: WordLen code=%x\n",
+			      pbuf[sum + 2]);
+			/*
+			 * If >= 2 channels and 16 bit is supported, then
+			 * add the supported rates to our bitmap.
+			 */
+			if ((c >= 2) && (pbuf[sum + 2] & 0x01)) {
+				if (pbuf[sum + 1] & 0x01)
+					rates |= SNDRV_PCM_RATE_32000;
+				if (pbuf[sum + 1] & 0x02)
+					rates |= SNDRV_PCM_RATE_44100;
+				if (pbuf[sum + 1] & 0x04)
+					rates |= SNDRV_PCM_RATE_48000;
+				if (pbuf[sum + 1] & 0x08)
+					rates |= SNDRV_PCM_RATE_88200;
+				if (pbuf[sum + 1] & 0x10)
+					rates |= SNDRV_PCM_RATE_96000;
+				if (pbuf[sum + 1] & 0x20)
+					rates |= SNDRV_PCM_RATE_176400;
+				if (pbuf[sum + 1] & 0x40)
+					rates |= SNDRV_PCM_RATE_192000;
+			}
+		}
+		sum += 3;
+	}
+	audio_info.supported_rates |= rates;
+	return 0;
+}
+
+static __s32
+Parse_HDMI_VSDB(__u8 *pbuf, __u8 size)
+{
+	__u8 index = 8;
+
+	/* check if it's HDMI VSDB */
+	if ((pbuf[0] == 0x03) && (pbuf[1] == 0x0c) && (pbuf[2] == 0x00))
+		pr_info("Find HDMI Vendor Specific DataBlock\n");
+	else
+		return 0;
+
+	cec_phy_addr = (((__u32)pbuf[3]) << 8) | pbuf[4];
+	__inf("my phy addr is %x\n", cec_phy_addr);
+	if (size <= 8)
+		return 0;
+
+	if ((pbuf[7] & 0x20) == 0)
+		return 0;
+	if ((pbuf[7] & 0x40) == 1)
+		index = index + 2;
+	if ((pbuf[7] & 0x80) == 1)
+		index = index + 2;
+
+	/* mandatary format support */
+	if (pbuf[index] & 0x80)	{
+		Device_Support_VIC[HDMI1080P_24_3D_FP] = 1;
+		Device_Support_VIC[HDMI720P_50_3D_FP] = 1;
+		Device_Support_VIC[HDMI720P_60_3D_FP] = 1;
+		pr_info("3D_present\n");
+	} else {
+		return 0;
+	}
+
+	if (((pbuf[index] & 0x60) == 1) || ((pbuf[index] & 0x60) == 2))
+		pr_info("3D_multi_present\n");
+
+	index += (pbuf[index + 1] & 0xe0) + 2;
+	if (index > (size + 1))
+		return 0;
+
+	__inf("3D_multi_present byte(%2.2x,%2.2x)\n", pbuf[index],
+	      pbuf[index + 1]);
+
+	return 0;
+}
+
+static __s32 ParseEDID_CEA861_extension_block(__u32 i, __u8 *EDID_Buf)
+{
+	__u32 offset;
+	if (EDID_Buf[0x80 * i + 3] & 0x40) {
+		audio_info.supported_rates |=
+			SNDRV_PCM_RATE_32000 |
+			SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000;
+	}
+	offset = EDID_Buf[0x80 * i + 2];
+	/* deal with reserved data block */
+	if (offset > 4)	{
+		__u8 bsum = 4;
+		while (bsum < offset) {
+			__u8 tag = EDID_Buf[0x80 * i + bsum] >> 5;
+			__u8 len = EDID_Buf[0x80 * i + bsum] & 0x1f;
+			if ((len > 0) && ((bsum + len + 1) > offset)) {
+				pr_info("len or bsum size error\n");
+				return 0;
+			} else {
+				if (tag == 1) { /* ADB */
+					Parse_AudioData_Block(EDID_Buf + 0x80 * i + bsum + 1, len);
+				} else if (tag == 2) { /* VDB */
+					Parse_VideoData_Block(EDID_Buf + 0x80 * i + bsum + 1, len);
+				} else if (tag == 3) { /* vendor specific */
+					Parse_HDMI_VSDB(EDID_Buf + 0x80 * i + bsum + 1, len);
+				}
+			}
+
+			bsum += (len + 1);
+		}
+	} else {
+		pr_info("no data in block%d\n", i);
+	}
+
+	if (offset >= 4) { /* deal with 18-byte timing block */
+		while (offset < (0x80 - 18)) {
+			Parse_DTD_Block(EDID_Buf + 0x80 * i + offset);
+			offset += 18;
+		}
+	} else {
+		pr_info("no DTD in block%d\n", i);
+	}
+	return 1;
+}
+
+#define DDC_ADDR 0x50
+#define EDID_LENGTH 0x80
+#define TRIES 3
+static int probe_ddc_edid(struct i2c_adapter *adapter,
+		int block, unsigned char *buf)
+{
+	unsigned char start = block * EDID_LENGTH;
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= DDC_ADDR,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= &start,
+		}, {
+			.addr	= DDC_ADDR,
+			.flags	= I2C_M_RD,
+			.len	= EDID_LENGTH,
+			.buf	= buf + start,
+		}
+	};
+
+	if (!buf) {
+		dev_warn(&adapter->dev, "unable to allocate memory for EDID "
+			 "block.\n");
+		return -EIO;
+	}
+
+	if (i2c_transfer(adapter, msgs, 2) == 2)
+		return 0;
+
+	return -EIO;
+}
+
+static int get_edid_block(int block, unsigned char *buf)
+{
+	int i;
+
+	for (i = 1; i <= TRIES; i++) {
+		if (probe_ddc_edid(&sunxi_hdmi_i2c_adapter, block, buf)) {
+			dev_warn(&sunxi_hdmi_i2c_adapter.dev,
+				 "unable to read EDID block %d, try %d/%d\n",
+				 block, i, TRIES);
+			continue;
+		}
+		if (EDID_CheckSum(block, buf) != 0) {
+			dev_warn(&sunxi_hdmi_i2c_adapter.dev,
+				 "EDID block %d checksum error, try %d/%d\n",
+				 block, i, TRIES);
+			continue;
+		}
+		break;
+	}
+	return (i <= TRIES) ? 0 : -EIO;
+}
+
+/*
+ * collect the EDID ucdata of segment 0
+ */
+__s32 ParseEDID(void)
+{
+	__u8 BlockCount;
+	__u32 i;
+	unsigned char *EDID_Buf = kmalloc(EDID_LENGTH*4, GFP_KERNEL);
+	if (!EDID_Buf)
+		return -ENOMEM;
+
+	pr_info("ParseEDID\n");
+
+	if (video_mode == HDMI_EDID) {
+		/* HDMI_DEVICE_SUPPORT_VIC_SIZE - 1 so as to not overwrite
+		   the currently in use timings with a new preferred mode! */
+		memset(Device_Support_VIC, 0,
+		       HDMI_DEVICE_SUPPORT_VIC_SIZE - 1);
+	} else {
+		memset(Device_Support_VIC, 0, HDMI_DEVICE_SUPPORT_VIC_SIZE);
+	}
+
+	if (get_edid_block(0, EDID_Buf) != 0)
+		goto ret;
+
+	if (EDID_Header_Check(EDID_Buf) != 0)
+		goto ret;
+
+	if (EDID_Version_Check(EDID_Buf) != 0)
+		goto ret;
+
+	Parse_DTD_Block(EDID_Buf + 0x36);
+
+	Parse_DTD_Block(EDID_Buf + 0x48);
+
+	BlockCount = EDID_Buf[0x7E] + 1;
+	if (BlockCount > 5)
+		BlockCount = 5;
+
+	for (i = 1; i < BlockCount; i++) {
+		if (get_edid_block(i, EDID_Buf) != 0) {
+			BlockCount = i;
+			break;
+		}
+	}
+
+	hdmi_edid_received(EDID_Buf, BlockCount);
+
+	for (i = 1; i < BlockCount; i++) {
+		if (EDID_Buf[0x80 * i + 0] == 2) {
+			if (!ParseEDID_CEA861_extension_block(i, EDID_Buf))
+				goto ret;
+		}
+	}
+
+ret:
+	kfree(EDID_Buf);
+	return 0;
+}
diff --git a/drivers/video/sunxi/hdmi/hdmi_i2c.c b/drivers/video/sunxi/hdmi/hdmi_i2c.c
new file mode 100644
index 0000000..f0a9d0cf
--- /dev/null
+++ b/drivers/video/sunxi/hdmi/hdmi_i2c.c
@@ -0,0 +1,248 @@
+/*
+ * Copyright (c) 2013 Jari Helaakoski <tekkuli@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include "../disp/sunxi_disp_regs.h"
+#include "hdmi_core.h"
+
+#define Abort_Current_Operation			0
+#define Special_Offset_Address_Read		1
+#define Explicit_Offset_Address_Write		2
+#define Implicit_Offset_Address_Write		3
+#define Explicit_Offset_Address_Read		4
+#define Implicit_Offset_Address_Read		5
+#define Explicit_Offset_Address_E_DDC_Read	6
+#define Implicit_Offset_Address_E_DDC_Read	7
+
+#define Command_Ok 0x11
+
+struct i2c_adapter sunxi_hdmi_i2c_adapter;
+
+static int init_connection(void __iomem *base_addr)
+{
+	/* Make sure that HDMI core functionality is initialized.
+	 Currently support I2C only when HDMI is connected */
+	if (!(readl(HDMI_HPD) & 0x01)) {
+		pr_info("HDMI not connected\n");
+		return -EIO;
+	}
+
+	/* Reset */
+	writel(0, HDMI_I2C_GENERAL_2);
+	writel(0x80000001, HDMI_I2C_GENERAL);
+	hdmi_delay_ms(1);
+
+	if (readl(HDMI_I2C_GENERAL) & 0x1) {
+		pr_info("EDID not ready\n");
+		return -EIO;
+	}
+
+	/* N = 5,M=1 Fscl= Ftmds/2/10/2^N/(M+1) */
+	writel(0x0d, HDMI_I2C_CLK);
+
+	/* ddc address  0x60 */
+	/*writeb(0x60, HDMI_BASE + HDMI_I2C_LINE_CTRL);*/
+
+	/* slave address  0xa0 */
+	/*writeb(0xa0 >> 1, HDMI_BASE + HDMI_I2C_LINE_CTRL);*/
+
+	/* enable analog sda/scl pad */
+	writel((0 << 12) | (3 << 8), HDMI_I2C_LINE_CTRL);
+	return 0;
+}
+
+static int do_command(void __iomem *base_addr,
+		int command, u8 address, u8 len, u8 chip_addr)
+{
+	__u32 begin_ms, end_ms;
+	u8 block = 0;
+
+	 /* set FIFO read */
+	writel(readl(HDMI_I2C_GENERAL) & 0xfffffeff,
+		HDMI_I2C_GENERAL);
+
+	writel((block << 24) | (0x60 << 16) | (chip_addr << 8) |
+			address, HDMI_I2C_ADDR);
+
+	/* FIFO address clear */
+	writel(readl(HDMI_I2C_GENERAL_2) | 0x80000000,
+		HDMI_I2C_GENERAL_2);
+
+	 /* nbyte to access */
+	writel(len, HDMI_I2C_DATA_LENGTH);
+
+	 /* set cmd type */
+	writel(command, HDMI_I2C_CMD);
+
+	 /* start and cmd */
+	writel(readl(HDMI_I2C_GENERAL) | 0x40000000,
+			HDMI_I2C_GENERAL);
+
+	begin_ms = (jiffies * 1000) / HZ;
+	while (readl(HDMI_I2C_GENERAL) & 0x40000000) {
+		end_ms = (jiffies * 1000) / HZ;
+		if ((end_ms - begin_ms) > 1000) {
+			pr_warning("ddc read timeout 0x%X\n",
+				readl(HDMI_I2C_GENERAL));
+			return -ETIMEDOUT;
+		}
+		schedule();
+	}
+
+	if (Command_Ok != readl(HDMI_I2C_STATUS))
+		return -EIO;
+
+	return 0;
+}
+
+static int do_read(void __iomem *base_addr,
+		struct i2c_msg *msg, int command, u8 chip_addr)
+{
+	int i = 0;
+	int err = 0;
+	u8 bufPos = 0;
+
+	while (bufPos < msg->len) {
+		u8 readLen = (msg->len > 16) ? 16 : msg->len;
+
+		err = do_command(base_addr, command,
+				msg->addr, readLen,
+				chip_addr);
+
+		if (err != 0)
+			return err;
+
+		for (i = 0; i < readLen; i++)
+			*msg->buf++ = readb(HDMI_I2C_DATA);
+
+		bufPos += readLen;
+		chip_addr += readLen;
+	}
+	return err;
+}
+
+static int hdmi_i2c_sunxi_xfer(struct i2c_adapter *adap,
+		struct i2c_msg *msgs, int num)
+{
+	int i = 0;
+	int err = 0;
+	u8 chip_addr = 0;
+	int command =  Implicit_Offset_Address_Read;
+	void __iomem *base_addr = (void __iomem *)adap->algo_data;
+
+	if (init_connection(base_addr))
+		return -EIO;
+
+	for (i = 0; i < num; i++) {
+		if (msgs[i].flags & I2C_M_RD) {
+			err = do_read(base_addr, &msgs[i], command, chip_addr);
+		} else {
+			command = Explicit_Offset_Address_Read;
+			chip_addr = *msgs[i].buf;
+			err = do_command(base_addr, command,
+				msgs[i].addr, 0,
+				chip_addr);
+		}
+
+		pr_debug("%s msgs[i].addr:0x%X msgs[i].len:%i"
+				" msgs[i].flags:0x%X err:%i\n",
+				__func__, msgs[i].addr, msgs[i].len,
+				msgs[i].flags, err);
+
+		if (err)
+			break;
+
+	}
+
+	if (err)
+		return err;
+
+	return i;
+}
+
+static unsigned int hdmi_i2c_sunxi_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C|I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm hdmi_i2c_sunxi_algorithm = {
+	.master_xfer	  = hdmi_i2c_sunxi_xfer,
+	.functionality	  = hdmi_i2c_sunxi_functionality,
+};
+
+int hdmi_i2c_sunxi_probe(struct platform_device *dev)
+{
+	int ret;
+	strlcpy(sunxi_hdmi_i2c_adapter.name, "sunxi-hdmi-i2c",
+			sizeof(sunxi_hdmi_i2c_adapter.name));
+	sunxi_hdmi_i2c_adapter.owner   = THIS_MODULE;
+	sunxi_hdmi_i2c_adapter.retries = 2;
+	sunxi_hdmi_i2c_adapter.timeout = 5*HZ;
+	sunxi_hdmi_i2c_adapter.class   = I2C_CLASS_DDC;
+	sunxi_hdmi_i2c_adapter.algo = &hdmi_i2c_sunxi_algorithm;
+	sunxi_hdmi_i2c_adapter.dev.parent = &dev->dev;
+	sunxi_hdmi_i2c_adapter.algo_data  = (void *)0xf1c16000;
+
+
+	ret = i2c_add_adapter(&sunxi_hdmi_i2c_adapter);
+	if (ret < 0) {
+		pr_warning("I2C: Failed to add bus\n");
+		return ret;
+	}
+
+	platform_set_drvdata(dev, &sunxi_hdmi_i2c_adapter);
+
+
+
+	pr_info("I2C: %s: HDMI I2C adapter\n",
+			dev_name(&sunxi_hdmi_i2c_adapter.dev));
+	return 0;
+}
+
+int hdmi_i2c_sunxi_remove(struct platform_device *dev)
+{
+	struct i2c_adapter *i2c = platform_get_drvdata(dev);
+	if (i2c)
+		i2c_del_adapter(i2c);
+
+	return 0;
+}
+
+#if 0 /* Legacy comment */
+void send_ini_sequence()
+{
+	int i, j;
+
+	set_wbit(HDMI_I2C_UNKNOWN_0, BIT3);
+	for (i = 0; i < 9; i++) {
+		for (j = 0; j < 200; j++) /*for simulation, delete it*/
+			;
+		clr_wbit(HDMI_I2C_UNKNOWN_0, BIT2);
+
+		for (j = 0; j < 200; j++) /*for simulation, delete it*/
+			;
+		set_wbit(HDMI_I2C_UNKNOWN_0, BIT2);
+	}
+
+	clr_wbit(HDMI_I2C_UNKNOWN_0, BIT3);
+	clr_wbit(HDMI_I2C_UNKNOWN_0, BIT1);
+}
+#endif
diff --git a/drivers/video/sunxi/lcd/Makefile b/drivers/video/sunxi/lcd/Makefile
new file mode 100644
index 0000000..a012328
--- /dev/null
+++ b/drivers/video/sunxi/lcd/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_FB_SUNXI_LCD) += lcd.o
+
+lcd-objs := lcd_panel_cfg_generic.o dev_lcd.o
+lcd-objs += lcd0_panel_cfg.o
+lcd-objs += lcd1_panel_cfg.o
diff --git a/drivers/video/sunxi/lcd/dev_lcd.c b/drivers/video/sunxi/lcd/dev_lcd.c
new file mode 100644
index 0000000..00b1bce
--- /dev/null
+++ b/drivers/video/sunxi/lcd/dev_lcd.c
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include "dev_lcd.h"
+#include "lcd_panel_cfg.h"
+
+#include "../disp/disp_lcd.h"
+#include "../disp/dev_disp.h"
+
+static struct cdev *my_cdev;
+static dev_t devid;
+static struct class *lcd_class;
+
+static int
+lcd_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int
+lcd_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t
+lcd_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+static ssize_t
+lcd_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+static int
+lcd_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	return 0;
+}
+
+static long
+lcd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	return 0;
+}
+
+static const struct file_operations lcd_fops = {
+	.owner = THIS_MODULE,
+	.open = lcd_open,
+	.release = lcd_release,
+	.write = lcd_write,
+	.read = lcd_read,
+	.unlocked_ioctl = lcd_ioctl,
+	.mmap = lcd_mmap,
+};
+
+static int
+lcd_init(void)
+{
+	static __lcd_panel_fun_t lcd0_cfg;
+	static __lcd_panel_fun_t lcd1_cfg;
+
+	LCD_get_panel_funs_generic(&lcd0_cfg);
+	LCD_get_panel_funs_generic(&lcd1_cfg);
+
+	LCD_get_panel_funs_0(&lcd0_cfg);
+	LCD_get_panel_funs_1(&lcd1_cfg);
+	LCD_set_panel_funs(&lcd0_cfg, &lcd1_cfg);
+
+	Fb_Init(SUNXI_LCD);
+
+	return 0;
+}
+
+static int
+__init lcd_module_init(void)
+{
+	int ret = 0, err;
+
+	__inf("lcd_module_init\n");
+
+	alloc_chrdev_region(&devid, 0, 1, "lcd");
+	my_cdev = cdev_alloc();
+	cdev_init(my_cdev, &lcd_fops);
+	my_cdev->owner = THIS_MODULE;
+	err = cdev_add(my_cdev, devid, 1);
+	if (err) {
+		__wrn("cdev_add fail.\n");
+		return -1;
+	}
+
+	lcd_class = class_create(THIS_MODULE, "sunxi-lcd");
+	if (IS_ERR(lcd_class)) {
+		__wrn("class_create fail\n");
+		return -1;
+	}
+
+	device_create(lcd_class, NULL, devid, NULL, "sunxi-lcd");
+
+	lcd_init();
+
+	return ret;
+}
+
+static void __exit lcd_module_exit(void)
+{
+	__inf("lcd_module_exit\n");
+
+	device_destroy(lcd_class, devid);
+
+	class_destroy(lcd_class);
+
+	cdev_del(my_cdev);
+}
+
+late_initcall(lcd_module_init);
+module_exit(lcd_module_exit);
+
+MODULE_AUTHOR("danling_xiao");
+MODULE_DESCRIPTION("lcd driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lcd");
diff --git a/drivers/video/sunxi/lcd/dev_lcd.h b/drivers/video/sunxi/lcd/dev_lcd.h
new file mode 100644
index 0000000..16834aa
--- /dev/null
+++ b/drivers/video/sunxi/lcd/dev_lcd.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DEV_LCD_H__
+#define __DEV_LCD_H__
+
+#include <linux/uaccess.h>
+#include <asm/memory.h>
+#include <linux/unistd.h>
+#include "asm-generic/int-ll64.h"
+#include "linux/kernel.h"
+#include "linux/mm.h"
+#include "linux/semaphore.h"
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h> /* wake_up_process() */
+#include <linux/kthread.h> /* kthread_create() / kthread_run() */
+#include <linux/err.h> /* IS_ERR() / PTR_ERR() */
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+
+#include <mach/platform.h>
+#include <plat/sys_config.h>
+
+#include <video/sunxi_disp_ioctl.h>
+
+extern void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun);
+extern void LCD_get_panel_funs_1(__lcd_panel_fun_t *fun);
+
+#define __inf(msg, ...) pr_debug("[DISP] " msg, ##__VA_ARGS__)
+#define __wrn(msg, ...) pr_warn("[DISP] " msg, ##__VA_ARGS__)
+
+#endif
diff --git a/drivers/video/sunxi/lcd/lcd0_panel_cfg.c b/drivers/video/sunxi/lcd/lcd0_panel_cfg.c
new file mode 100644
index 0000000..62824e6
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd0_panel_cfg.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+static __u8 g_gamma_tbl[][2] = {
+	/* {input value, corrected value} */
+	{0, 0},
+	{15, 15},
+	{30, 30},
+	{45, 45},
+	{60, 60},
+	{75, 75},
+	{90, 90},
+	{105, 105},
+	{120, 120},
+	{135, 135},
+	{150, 150},
+	{165, 165},
+	{180, 180},
+	{195, 195},
+	{210, 210},
+	{225, 225},
+	{240, 240},
+	{255, 255},
+};
+
+static void lcd_gamma_gen(__panel_para_t *info)
+{
+	__u32 items = sizeof(g_gamma_tbl) / 2;
+	__u32 i, j;
+
+	for (i = 0; i < items - 1; i++) {
+		__u32 num = g_gamma_tbl[i + 1][0] - g_gamma_tbl[i][0];
+
+		for (j = 0; j < num; j++) {
+			__u32 value = 0;
+
+			value = g_gamma_tbl[i][1] +
+				((g_gamma_tbl[i + 1][1] -
+				  g_gamma_tbl[i][1]) * j) / num;
+			info->lcd_gamma_tbl[g_gamma_tbl[i][0] + j] =
+				(value << 16) + (value << 8) + value;
+		}
+	}
+	info->lcd_gamma_tbl[255] = (g_gamma_tbl[items - 1][1] << 16) +
+		(g_gamma_tbl[items - 1][1] << 8) + g_gamma_tbl[items - 1][1];
+}
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 800;
+	info->lcd_y = 480;
+	info->lcd_dclk_freq = 33; /* MHz */
+
+	info->lcd_ht = 1055; /* htotal */
+	info->lcd_hbp = 215; /* h back porch */
+	info->lcd_hv_hspw = 0; /* hsync */
+	info->lcd_vt = 525 * 2; /* vtotal * 2 */
+	info->lcd_vbp = 34; /* v back porch */
+	info->lcd_hv_vspw = 0; /* vsync */
+
+	info->lcd_if = 0; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_hv_if = 0; /* 0:hv parallel; 1:hv serial; 2:ccir656 */
+	info->lcd_hv_smode = 0; /* 0:RGB888 1:CCIR656 */
+	info->lcd_hv_s888_if = 0; /* serial RGB format */
+	info->lcd_hv_syuv_if = 0; /* serial YUV format */
+
+	info->lcd_cpu_if = 0; /* 0:18bit 4:16bit */
+	info->lcd_frm = 0; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_lvds_ch = 0; /* 0:single link; 1:dual link */
+	info->lcd_lvds_mode = 0; /* 0:NS mode; 1:JEIDA mode */
+	info->lcd_lvds_bitwidth = 0; /* 0:24bit; 1:18bit */
+	info->lcd_lvds_io_cross = 0; /* 0:normal; 1:pn cross */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 0;
+	info->lcd_pwm_freq = 10000; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x10000000; /* clock phase */
+
+	info->lcd_gamma_correction_en = 0;
+	if (info->lcd_gamma_correction_en)
+		lcd_gamma_gen(info);
+}
+#endif
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+}
diff --git a/drivers/video/sunxi/lcd/lcd1_panel_cfg.c b/drivers/video/sunxi/lcd/lcd1_panel_cfg.c
new file mode 100644
index 0000000..5b0c93d
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd1_panel_cfg.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+static __u8 g_gamma_tbl[][2] = {
+	/* {input value, corrected value} */
+	{0, 0},
+	{15, 15},
+	{30, 30},
+	{45, 45},
+	{60, 60},
+	{75, 75},
+	{90, 90},
+	{105, 105},
+	{120, 120},
+	{135, 135},
+	{150, 150},
+	{165, 165},
+	{180, 180},
+	{195, 195},
+	{210, 210},
+	{225, 225},
+	{240, 240},
+	{255, 255},
+};
+
+static void lcd_gamma_gen(__panel_para_t *info)
+{
+	__u32 items = sizeof(g_gamma_tbl) / 2;
+	__u32 i, j;
+
+	for (i = 0; i < items - 1; i++) {
+		__u32 num = g_gamma_tbl[i + 1][0] - g_gamma_tbl[i][0];
+
+		for (j = 0; j < num; j++) {
+			__u32 value = 0;
+
+			value = g_gamma_tbl[i][1] +
+				((g_gamma_tbl[i + 1][1] -
+				  g_gamma_tbl[i][1]) * j) / num;
+			info->lcd_gamma_tbl[g_gamma_tbl[i][0] + j] =
+				(value << 16) + (value << 8) + value;
+		}
+	}
+	info->lcd_gamma_tbl[255] = (g_gamma_tbl[items - 1][1] << 16) +
+		(g_gamma_tbl[items - 1][1] << 8) + g_gamma_tbl[items - 1][1];
+}
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 800;
+	info->lcd_y = 480;
+	info->lcd_dclk_freq = 33; /* MHz */
+
+	info->lcd_ht = 1055; /* htotal */
+	info->lcd_hbp = 215; /* h back porch */
+	info->lcd_hv_hspw = 0; /* hsync */
+	info->lcd_vt = 525 * 2; /* vtotal * 2 */
+	info->lcd_vbp = 34; /* v back porch */
+	info->lcd_hv_vspw = 0; /* vsync */
+
+	info->lcd_if = 0; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_hv_if = 0; /* 0:hv parallel; 1:hv serial; 2:ccir656 */
+	info->lcd_hv_smode = 0; /* 0:RGB888 1:CCIR656 */
+	info->lcd_hv_s888_if = 0; /* serial RGB format */
+	info->lcd_hv_syuv_if = 0; /* serial YUV format */
+
+	info->lcd_cpu_if = 0; /* 0:18bit 4:16bit */
+	info->lcd_frm = 0; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_lvds_ch = 0; /* 0:single link; 1:dual link */
+	info->lcd_lvds_mode = 0; /* 0:NS mode; 1:JEIDA mode */
+	info->lcd_lvds_bitwidth = 0; /* 0:24bit; 1:18bit */
+	info->lcd_lvds_io_cross = 0; /* 0:normal; 1:pn cross */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 1;
+	info->lcd_pwm_freq = 10000; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x10000000; /* clock phase */
+
+	info->lcd_gamma_correction_en = 0;
+	if (info->lcd_gamma_correction_en)
+		lcd_gamma_gen(info);
+}
+#endif
+
+void LCD_get_panel_funs_1(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+}
diff --git a/drivers/video/sunxi/lcd/lcd_bak/TC101+tl080wx800-v0.c b/drivers/video/sunxi/lcd/lcd_bak/TC101+tl080wx800-v0.c
new file mode 100644
index 0000000..74b7c47
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_bak/TC101+tl080wx800-v0.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+static __u8 g_gamma_tbl[][2] = {
+	/* {input value, corrected value} */
+	{0, 0},
+	{15, 15},
+	{30, 30},
+	{45, 45},
+	{60, 60},
+	{75, 75},
+	{90, 90},
+	{105, 105},
+	{120, 120},
+	{135, 135},
+	{150, 150},
+	{165, 165},
+	{180, 180},
+	{195, 195},
+	{210, 210},
+	{225, 225},
+	{240, 240},
+	{255, 255},
+};
+
+static void lcd_gamma_gen(__panel_para_t *info)
+{
+	__u32 items = sizeof(g_gamma_tbl) / 2;
+	__u32 i, j;
+
+	for (i = 0; i < items - 1; i++) {
+		__u32 num = g_gamma_tbl[i + 1][0] - g_gamma_tbl[i][0];
+
+		for (j = 0; j < num; j++) {
+			__u32 value = 0;
+
+			value = g_gamma_tbl[i][1] +
+				((g_gamma_tbl[i + 1][1] -
+				  g_gamma_tbl[i][1]) * j) / num;
+			info->lcd_gamma_tbl[g_gamma_tbl[i][0] + j] =
+				(value << 16) + (value << 8) + value;
+		}
+	}
+	info->lcd_gamma_tbl[255] = (g_gamma_tbl[items - 1][1] << 16) +
+		(g_gamma_tbl[items - 1][1] << 8) + g_gamma_tbl[items - 1][1];
+}
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 1280;
+	info->lcd_y = 768;
+	info->lcd_dclk_freq = 68; /* MHz */
+
+	info->lcd_ht = 1440; /* htotal */
+	info->lcd_hbp = 3; /* h back porch */
+	info->lcd_hv_hspw = 0; /* hsync */
+	info->lcd_vt = 790 * 2; /* vtotal * 2 */
+	info->lcd_vbp = 3; /* v back porch */
+	info->lcd_hv_vspw = 0; /* vsync */
+
+	info->lcd_if = 0; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_hv_if = 0; /* 0:hv parallel; 1:hv serial; 2:ccir656 */
+	info->lcd_hv_smode = 0; /* 0:RGB888 1:CCIR656 */
+	info->lcd_hv_s888_if = 0; /* serial RGB format */
+	info->lcd_hv_syuv_if = 0; /* serial YUV format */
+
+	info->lcd_cpu_if = 0; /* 0:18bit 4:16bit */
+	info->lcd_frm = 0; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_lvds_ch = 0; /* 0:single link; 1:dual link */
+	info->lcd_lvds_mode = 0; /* 0:NS mode; 1:JEIDA mode */
+	info->lcd_lvds_bitwidth = 0; /* 0:24bit; 1:18bit */
+	info->lcd_lvds_io_cross = 0; /* 0:normal; 1:pn cross */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 0;
+	info->lcd_pwm_freq = 10000; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x00000000; /* clock phase */
+
+	info->lcd_gamma_correction_en = 0;
+	if (info->lcd_gamma_correction_en)
+		lcd_gamma_gen(info);
+}
+#endif
+
+static void LCD_io_init(__u32 sel);
+static void LCD_io_exit(__u32 sel);
+static void LCD_open_cmd(__u32 sel);
+static void LCD_close_cmd(__u32 sel);
+
+static __s32 LCD_open_flow(__u32 sel)
+{
+	/* open lcd power, and delay 10ms */
+	LCD_OPEN_FUNC(sel, LCD_power_on_generic, 50);
+	/* request and init gpio, and delay 20ms */
+	LCD_OPEN_FUNC(sel, LCD_io_init, 20);
+	/* open lcd controller, and delay 200ms */
+	LCD_OPEN_FUNC(sel, TCON_open, 500);
+	/* use gpio to config lcd module to the  work mode, and delay 10ms */
+	LCD_OPEN_FUNC(sel, LCD_open_cmd, 10);
+	/* open lcd backlight, and delay 0ms */
+	LCD_OPEN_FUNC(sel, LCD_bl_open_generic, 0);
+
+	return 0;
+}
+
+static __s32 LCD_close_flow(__u32 sel)
+{
+	/* close lcd backlight, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_bl_close_generic, 0);
+	/*
+	 * use gpio to config lcd module to the powerdown/sleep mode,
+	 * and delay 0ms
+	 */
+	LCD_CLOSE_FUNC(sel, LCD_close_cmd, 0);
+	/* close lcd controller, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, TCON_close, 0);
+	/* release gpio, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_io_exit, 0);
+	/* close lcd power, and delay 1000ms */
+	LCD_CLOSE_FUNC(sel, LCD_power_off_generic, 1000);
+
+	return 0;
+}
+
+#define IIC_SCLB_LOW()		LCD_GPIO_write(0, 0, 0)
+#define IIC_SCLB_HIGH()		LCD_GPIO_write(0, 0, 1)
+
+#define IIC_SDAB_INPUT_SETUP()	LCD_GPIO_set_attr(0, 1, 0)
+#define IIC_SDAB_OUTPUT_SETUP()	LCD_GPIO_set_attr(0, 1, 1)
+#define CHECK_SDAB_HIGH()	LCD_GPIO_read(0, 1)
+#define IIC_SDAB_LOW()		LCD_GPIO_write(0, 1, 0)
+#define IIC_SDAB_HIGH()		LCD_GPIO_write(0, 1, 1)
+
+static __bool i2cB_clock(void)
+{
+	__bool sample = 0;
+
+	IIC_SCLB_HIGH();
+	LCD_delay_us(5);
+	IIC_SCLB_LOW();
+	LCD_delay_us(5);
+	return sample;
+}
+
+static __bool i2cB_ack(void)
+{
+	IIC_SCLB_HIGH();
+	IIC_SDAB_INPUT_SETUP();
+	LCD_delay_us(5);
+	LCD_delay_us(5);
+	if (CHECK_SDAB_HIGH()) {
+		LCD_delay_us(5);
+		IIC_SDAB_OUTPUT_SETUP();
+		LCD_delay_us(5);
+		IIC_SCLB_LOW();
+		LCD_delay_us(5);
+		IIC_SDAB_HIGH();
+		LCD_delay_us(5);
+		return 1;
+	} else {
+		LCD_delay_us(5);
+		IIC_SDAB_OUTPUT_SETUP();
+		LCD_delay_us(5);
+		IIC_SCLB_LOW();
+		LCD_delay_us(5);
+		IIC_SDAB_HIGH();
+		LCD_delay_us(5);
+		return 0;
+	}
+}
+
+static void i2cBStartA(void)
+{
+	IIC_SCLB_HIGH();
+	IIC_SDAB_HIGH();
+	LCD_delay_us(5);
+	IIC_SDAB_LOW();
+	LCD_delay_us(5);
+	IIC_SCLB_LOW();
+}
+
+static __bool i2cBStart(void)
+{
+	IIC_SDAB_HIGH();
+	IIC_SCLB_HIGH();
+	LCD_delay_us(5);
+	IIC_SDAB_INPUT_SETUP();
+	if (CHECK_SDAB_HIGH()) {
+		IIC_SDAB_OUTPUT_SETUP();
+		i2cBStartA();
+		return 1;
+	}
+	return 0;
+}
+
+static void i2cBStop(void)
+{
+	IIC_SDAB_OUTPUT_SETUP();
+	IIC_SDAB_LOW();
+	LCD_delay_us(5);
+	IIC_SCLB_HIGH();
+	LCD_delay_us(5);
+	IIC_SDAB_HIGH();
+	LCD_delay_us(5);
+}
+
+static __bool i2cBTransmit(__u8 value)
+{
+	register __u8 i;
+
+	for (i = 0; i < 8; i++) {
+		if ((value & 0x80) == 0x80)
+			IIC_SDAB_HIGH();
+		else
+			IIC_SDAB_LOW();
+
+		value = value << 1;
+		i2cB_clock();
+	}
+	return !i2cB_ack();
+}
+
+static __bool i2cBTransmitSubAddr(__u16 value)
+{
+	register __u8 i;
+
+	for (i = 0; i < 8; i++) {
+		if ((value & 0x80) == 0x80)
+			IIC_SDAB_HIGH();
+		else
+			IIC_SDAB_LOW();
+
+		value = value << 1;
+		i2cB_clock();
+	}
+	return !i2cB_ack();
+}
+
+static __bool i2cBLocateSubAddr(__u8 slave_addr, __u16 sub_addr)
+{
+	register __u8 i;
+	__u8 sub_addr_hi, sub_addr_low;
+
+	sub_addr_hi = sub_addr >> 8;
+	sub_addr_low = sub_addr;
+	for (i = 0; i < 3; i++) {
+		/* Start I2C */
+		if (i2cBStart()) {
+			/* Slave address */
+			if (i2cBTransmit(slave_addr)) {
+				if (i2cBTransmitSubAddr(sub_addr_hi)) {
+					if (i2cBTransmitSubAddr(sub_addr_low))
+						return 1;
+				}
+			}
+		}
+		i2cBStop();
+	}
+	return 0;
+}
+
+static __bool IIC_Write(__u8 slave_addr, __u16 sub_addr, __u8 value)
+{
+	if (i2cBLocateSubAddr(slave_addr, sub_addr)) {
+		if (i2cBTransmit(value)) {
+			i2cBStop();
+			return 1;
+		}
+	}
+	i2cBStop();
+	return 0;
+}
+
+static void LCD_io_init(__u32 sel)
+{
+	/* request SCLB gpio, and output high as default */
+	LCD_GPIO_request(sel, 0);
+	LCD_GPIO_set_attr(sel, 0, 1);
+	LCD_GPIO_write(sel, 0, 1);
+
+	/* request SDAB gpio, and output high as default */
+	LCD_GPIO_request(sel, 1);
+	LCD_GPIO_set_attr(sel, 1, 1);
+	LCD_GPIO_write(sel, 1, 1);
+}
+
+static void LCD_io_exit(__u32 sel)
+{
+	/* release SCLB gpio */
+	LCD_GPIO_release(sel, 0);
+
+	/* release SDAB gpio */
+	LCD_GPIO_release(sel, 1);
+}
+
+static void LCD_open_cmd(__u32 sel)
+{
+	IIC_Write(0xfc, 0xf830, 0xb2);
+	IIC_Write(0xfc, 0xf833, 0xc2);
+	IIC_Write(0xfc, 0xf831, 0xf0);
+	IIC_Write(0xfc, 0xf840, 0x80);
+	IIC_Write(0xfc, 0xf881, 0xec);
+}
+
+static void LCD_close_cmd(__u32 sel)
+{
+}
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+	fun->cfg_open_flow = LCD_open_flow;
+	fun->cfg_close_flow = LCD_close_flow;
+}
diff --git a/drivers/video/sunxi/lcd/lcd_bak/TC102.c b/drivers/video/sunxi/lcd/lcd_bak/TC102.c
new file mode 100644
index 0000000..6627930
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_bak/TC102.c
@@ -0,0 +1,470 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+static __u8 g_gamma_tbl[][2] = {
+	/* {input value, corrected value} */
+	{0, 0},
+	{15, 16},
+	{30, 40},
+	{45, 55},
+	{60, 66},
+	{75, 82},
+	{90, 96},
+	{105, 112},
+	{120, 131},
+	{135, 145},
+	{150, 160},
+	{165, 173},
+	{180, 187},
+	{195, 199},
+	{210, 213},
+	{225, 224},
+	{240, 234},
+	{255, 255},
+};
+
+static void lcd_gamma_gen(__panel_para_t *info)
+{
+	__u32 items = sizeof(g_gamma_tbl) / 2;
+	__u32 i, j;
+
+	for (i = 0; i < items - 1; i++) {
+		__u32 num = g_gamma_tbl[i + 1][0] - g_gamma_tbl[i][0];
+
+		for (j = 0; j < num; j++) {
+			__u32 value = 0;
+
+			value = g_gamma_tbl[i][1] +
+				((g_gamma_tbl[i + 1][1] -
+				  g_gamma_tbl[i][1]) * j) / num;
+			info->lcd_gamma_tbl[g_gamma_tbl[i][0] + j] =
+				(value << 16) + (value << 8) + value;
+		}
+	}
+	info->lcd_gamma_tbl[255] = (g_gamma_tbl[items - 1][1] << 16) +
+		(g_gamma_tbl[items - 1][1] << 8) + g_gamma_tbl[items - 1][1];
+}
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 1280;
+	info->lcd_y = 768;
+	info->lcd_dclk_freq = 68; /* MHz */
+
+	info->lcd_ht = 1440; /* htotal */
+	info->lcd_hbp = 3; /* h back porch */
+	info->lcd_hv_hspw = 0; /* hsync */
+	info->lcd_vt = 790 * 2;	/* votal * 2 */
+	info->lcd_vbp = 3; /* v back porch */
+	info->lcd_hv_vspw = 0; /* vsync */
+
+	info->lcd_if = 0; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_hv_if = 0; /* 0:hv parallel; 1:hv serial; 2:ccir656 */
+	info->lcd_hv_smode = 0; /* 0:RGB888 1:CCIR656 */
+	info->lcd_hv_s888_if = 0; /* serial RGB format */
+	info->lcd_hv_syuv_if = 0; /* serial YUV format */
+
+	info->lcd_cpu_if = 0; /* 0:18bit 4:16bit */
+	info->lcd_frm = 1; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_lvds_ch = 0; /* 0:single link; 1:dual link */
+	info->lcd_lvds_mode = 0; /* 0:NS mode; 1:JEIDA mode */
+	info->lcd_lvds_bitwidth = 0; /* 0:24bit; 1:18bit */
+	info->lcd_lvds_io_cross = 0; /* 0:normal; 1:pn cross */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 0;
+	info->lcd_pwm_freq = 10000; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x00000000; /* clock phase */
+
+	info->lcd_gamma_correction_en = 1;
+	if (info->lcd_gamma_correction_en)
+		lcd_gamma_gen(info);
+}
+#endif
+
+static void LCD_io_init(__u32 sel);
+static void LCD_io_exit(__u32 sel);
+static void LCD_open_cmd(__u32 sel);
+static void LCD_close_cmd(__u32 sel);
+static void LCD_vcc_on(__u32 sel);
+static void LCD_vcc_off(__u32 sel);
+
+static __s32 LCD_open_flow(__u32 sel)
+{
+	/* open lcd power, and delay 10ms */
+	LCD_OPEN_FUNC(sel, LCD_vcc_on, 50);
+	/* open lcd vcc, and delay 10ms */
+	LCD_OPEN_FUNC(sel, LCD_power_on_generic, 50);
+	/* request and init gpio, and delay 20ms */
+	LCD_OPEN_FUNC(sel, LCD_io_init, 20);
+	/* open lcd controller, and delay 200ms */
+	LCD_OPEN_FUNC(sel, TCON_open, 500);
+	/* use gpio to config lcd module to the work mode, and delay 10ms */
+	LCD_OPEN_FUNC(sel, LCD_open_cmd, 10);
+	/* open lcd backlight, and delay 0ms */
+	LCD_OPEN_FUNC(sel, LCD_bl_open_generic, 0);
+
+	return 0;
+}
+
+static __s32 LCD_close_flow(__u32 sel)
+{
+	/* close lcd backlight, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_bl_close_generic, 0);
+	/*
+	 * use gpio to config lcd module to the powerdown/sleep mode,
+	 * and delay 0ms
+	 */
+	LCD_CLOSE_FUNC(sel, LCD_close_cmd, 0);
+	/* close lcd controller, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, TCON_close, 0);
+	/* release gpio, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_io_exit, 0);
+	/* close lcd vcc, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_power_off_generic, 0);
+	/* close lcd power, and delay 1000ms */
+	LCD_CLOSE_FUNC(sel, LCD_vcc_off, 1000);
+
+	return 0;
+}
+
+static void LCD_vcc_on(__u32 sel)
+{
+	user_gpio_set_t gpio_list;
+	int hdl;
+
+	gpio_list.port = 8; /* 1:A; 2:B; 3:C; 4:d;5:e;6:f;7:g;8:h... */
+	gpio_list.port_num = 6;
+	gpio_list.mul_sel = 1;
+	gpio_list.pull = 0;
+	gpio_list.drv_level = 0;
+	gpio_list.data = 1;
+
+	hdl = sunxi_gpio_request_array(&gpio_list, 1);
+	gpio_release(hdl, 2);
+}
+
+static void LCD_vcc_off(__u32 sel)
+{
+	user_gpio_set_t gpio_list;
+	int hdl;
+
+	gpio_list.port = 8; /* 1:A; 2:B; 3:C; ... */
+	gpio_list.port_num = 6;
+	gpio_list.mul_sel = 1;
+	gpio_list.pull = 0;
+	gpio_list.drv_level = 0;
+	gpio_list.data = 0;
+
+	hdl = sunxi_gpio_request_array(&gpio_list, 1);
+	gpio_release(hdl, 2);
+}
+
+#define IIC_SCLB_LOW()		LCD_GPIO_write(0, 0, 0)
+#define IIC_SCLB_HIGH()		LCD_GPIO_write(0, 0, 1)
+
+#define IIC_SDAB_INPUT_SETUP()	LCD_GPIO_set_attr(0, 1, 0)
+#define IIC_SDAB_OUTPUT_SETUP()	LCD_GPIO_set_attr(0, 1, 1)
+#define CHECK_SDAB_HIGH()	LCD_GPIO_read(0, 1)
+#define IIC_SDAB_LOW()		LCD_GPIO_write(0, 1, 0)
+#define IIC_SDAB_HIGH()		LCD_GPIO_write(0, 1, 1)
+
+static __bool i2cB_clock(void)
+{
+	__bool sample = 0;
+
+	IIC_SCLB_HIGH();
+	LCD_delay_us(10);
+	IIC_SCLB_LOW();
+	LCD_delay_us(10);
+	return sample;
+}
+
+static __bool i2cB_ack(void)
+{
+	IIC_SCLB_HIGH();
+	IIC_SDAB_INPUT_SETUP();
+	LCD_delay_us(5);
+	LCD_delay_us(5);
+	if (CHECK_SDAB_HIGH()) {
+		LCD_delay_us(5);
+		IIC_SDAB_OUTPUT_SETUP();
+		LCD_delay_us(5);
+		IIC_SCLB_LOW();
+		LCD_delay_us(5);
+		IIC_SDAB_HIGH();
+		LCD_delay_us(5);
+		return 1;
+	} else {
+		LCD_delay_us(5);
+		IIC_SDAB_OUTPUT_SETUP();
+		LCD_delay_us(5);
+		IIC_SCLB_LOW();
+		LCD_delay_us(5);
+		IIC_SDAB_HIGH();
+		LCD_delay_us(5);
+		return 0;
+	}
+}
+
+static void i2cBStartA(void)
+{
+	IIC_SCLB_HIGH();
+	IIC_SDAB_HIGH();
+	LCD_delay_us(10);
+	IIC_SDAB_LOW();
+	LCD_delay_us(10);
+	IIC_SCLB_LOW();
+}
+
+static __bool i2cBStart(void)
+{
+	IIC_SDAB_HIGH();
+	IIC_SCLB_HIGH();
+	LCD_delay_us(10);
+	IIC_SDAB_INPUT_SETUP();
+	if (CHECK_SDAB_HIGH()) {
+		IIC_SDAB_OUTPUT_SETUP();
+		i2cBStartA();
+		return 1;
+	}
+	return 0;
+}
+
+static void i2cBStop(void)
+{
+	IIC_SDAB_OUTPUT_SETUP();
+	IIC_SDAB_LOW();
+	LCD_delay_us(5);
+	IIC_SCLB_HIGH();
+	LCD_delay_us(5);
+	IIC_SDAB_HIGH();
+	LCD_delay_us(5);
+}
+
+static __bool i2cBTransmit(__u8 value)
+{
+	register __u8 i;
+	IIC_SDAB_OUTPUT_SETUP();
+	LCD_delay_us(5);
+	for (i = 0; i < 8; i++) {
+		if ((value & 0x80) == 0x80)
+			IIC_SDAB_HIGH();
+		else
+			IIC_SDAB_LOW();
+
+		value = value << 1;
+		LCD_delay_us(10);
+		i2cB_clock();
+
+	}
+	return !i2cB_ack();
+}
+
+static __bool i2cBTransmitSubAddr(__u8 value)
+{
+	register __u8 i;
+
+	for (i = 0; i < 8; i++) {
+		if ((value & 0x80) == 0x80)
+			IIC_SDAB_HIGH();
+		else
+			IIC_SDAB_LOW();
+
+		value = value << 1;
+		LCD_delay_us(10);
+		i2cB_clock();
+	}
+	return !i2cB_ack();
+}
+
+static __bool i2cBLocateSubAddr(__u8 slave_addr, __u8 sub_addr)
+{
+	register __u8 i;
+
+	for (i = 0; i < 3; i++) {
+		if (i2cBStart()) {
+			if (i2cBTransmit(slave_addr)) {
+				if (i2cBTransmitSubAddr(sub_addr))
+					return 1;
+			}
+		}
+		i2cBStop();
+	}
+
+	return 0;
+}
+
+static __bool IIC_Write_forT101(__u8 slave_addr, __u8 sub_addr, __u8 value)
+{
+	if (i2cBLocateSubAddr(slave_addr, sub_addr)) {
+		if (i2cBTransmit(value)) {
+			i2cBStop();
+			return 1;
+		}
+	}
+	i2cBStop();
+
+	__inf("-------------DATA SEND FAIL-----------\n");
+	return 0;
+}
+
+void i2cREAD(void)
+{
+	register __u8 i;
+	__u8 value = 0;
+
+	IIC_SDAB_INPUT_SETUP();
+
+	for (i = 0; i < 8; i++) {
+		value = value << 1;
+
+		//i2cB_clock();
+		LCD_delay_us(15);
+		IIC_SCLB_HIGH();
+		LCD_delay_us(10);
+		IIC_SCLB_LOW();
+		LCD_delay_us(10);
+
+		LCD_delay_us(10);
+
+		if (CHECK_SDAB_HIGH())
+			value = value + 1;
+	}
+
+	i2cB_ack();
+	i2cBStop();
+
+}
+
+static __bool IIC_Read_forT101(__u8 slave_addr1, __u8 sub_addr1)
+{
+	if (i2cBLocateSubAddr(slave_addr1, sub_addr1))
+		i2cREAD();
+
+#if 0
+	i2cBLocateSubAddr(slave_addr, sub_addr);
+	i2cBStop();
+#endif
+
+	return 0;
+}
+
+static void LCD_io_init(__u32 sel)
+{
+	__inf("------+++++++++++++lcd init*************\n");
+
+	/* request SCLB gpio, and output high as default */
+	LCD_GPIO_request(sel, 0);
+	LCD_GPIO_set_attr(sel, 0, 1);
+	LCD_GPIO_write(sel, 0, 1);
+
+	/* request SDAB gpio, and output high as default */
+	LCD_GPIO_request(sel, 1);
+	LCD_GPIO_set_attr(sel, 1, 1);
+	LCD_GPIO_write(sel, 1, 1);
+}
+
+static void LCD_io_exit(__u32 sel)
+{
+	__inf("------+++++++++++++lcd exit*************\n");
+
+	/* release SCLB gpio */
+	LCD_GPIO_release(sel, 0);
+
+	/* release SDAB gpio */
+	LCD_GPIO_release(sel, 1);
+}
+
+static void LCD_open_cmd(__u32 sel)
+{
+	__inf("------+++++++++++++into  T201_Initialize*************\n");
+
+	IIC_Write_forT101(0x6c, 0x2a, 0xa2);
+	IIC_Write_forT101(0x6c, 0x2d, 0xc2);
+	IIC_Write_forT101(0x6c, 0x33, 0x03);
+	IIC_Write_forT101(0x6c, 0x36, 0x30);
+	IIC_Write_forT101(0x6c, 0x46, 0x49);
+	IIC_Write_forT101(0x6c, 0x47, 0x92);
+	IIC_Write_forT101(0x6c, 0x48, 0x00);
+	IIC_Write_forT101(0x6c, 0x5f, 0x00);
+	IIC_Write_forT101(0x6c, 0x60, 0xa5);
+	IIC_Write_forT101(0x6c, 0x61, 0x08);
+	IIC_Write_forT101(0x6c, 0x62, 0xff);
+	IIC_Write_forT101(0x6c, 0x64, 0x00);
+	IIC_Write_forT101(0x6c, 0x80, 0x01);
+	IIC_Write_forT101(0x6c, 0x81, 0xe4);
+	IIC_Write_forT101(0x6c, 0x34, 0x01);
+
+	__inf("-------------out  T201_Initialize*************\n");
+}
+
+static void LCD_close_cmd(__u32 sel)
+{
+}
+
+/*
+ * sel: 0:lcd0; 1:lcd1
+ * para1 0:inter open 1:inter close 2:lense open 3:lense close
+ */
+static __s32 LCD_user_defined_func(__u32 sel, __u32 para1, __u32 para2,
+				   __u32 para3)
+{
+	switch (para1) {
+	case 0:
+		IIC_Write_forT101(0x6c, 0x48, 0x00);
+		break;
+	case 1:
+		IIC_Write_forT101(0x6c, 0x48, 0x03);
+		break;
+	case 2:
+		IIC_Write_forT101(0x6c, 0x36, 0x30);
+		break;
+	case 3:
+		IIC_Write_forT101(0x6c, 0x36, 0x00);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+	fun->cfg_open_flow = LCD_open_flow;
+	fun->cfg_close_flow = LCD_close_flow;
+}
diff --git a/drivers/video/sunxi/lcd/lcd_bak/cpu_320x240_kgm281i0.c b/drivers/video/sunxi/lcd/lcd_bak/cpu_320x240_kgm281i0.c
new file mode 100644
index 0000000..882d4f0
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_bak/cpu_320x240_kgm281i0.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+#include "../disp/ebios_lcdc_tve.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 320;
+	info->lcd_y = 240;
+	info->lcd_dclk_freq = 6; /* MHz */
+
+	info->lcd_ht = 320 + 30; /* htotal */
+	info->lcd_hbp = 20; /* h back porch */
+	info->lcd_hv_hspw = 10;	/* hsync */
+	info->lcd_vt = (240 + 30) * 2; /* vtotal * 2 */
+	info->lcd_vbp = 20; /* v back porch */
+	info->lcd_hv_vspw = 10;	/* vsync */
+
+	info->lcd_if = 1; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_cpu_if = 0; /* 0:18bit 4:16bit */
+	info->lcd_frm = 1; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 0;
+	info->lcd_pwm_freq = 12500; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x10000000; /* clock phase */
+
+	info->lcd_gamma_correction_en = 0;
+}
+#endif
+
+/*
+ * lcd flow function
+ * CPU Panel:first TCON_open,than lcd_panel_init
+ */
+static __s32 LCD_open_flow(__u32 sel)
+{
+	/* open lcd power, than delay 50ms */
+	LCD_OPEN_FUNC(sel, LCD_power_on_generic, 50);
+	/* open lcd controller, than delay 500ms */
+	LCD_OPEN_FUNC(sel, TCON_open, 500);
+	/* lcd panel initial, than delay 50ms */
+	LCD_OPEN_FUNC(sel, LCD_panel_init, 50);
+	/* open lcd backlight, than delay 0ms */
+	LCD_OPEN_FUNC(sel, LCD_bl_open_generic, 0);
+
+	return 0;
+}
+
+static __s32 LCD_close_flow(__u32 sel)
+{
+	/* close lcd backlight, than delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_bl_close_generic, 0);
+	/* lcd panel exit, than delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_panel_exit, 0);
+	/* close lcd controller, than delay 0ms */
+	LCD_CLOSE_FUNC(sel, TCON_close, 0);
+	/* close lcd power, than delay 1000ms */
+	LCD_CLOSE_FUNC(sel, LCD_power_off_generic, 1000);
+
+	return 0;
+}
+
+/*
+ * lcd panel initial
+ * cpu 8080 bus initial
+ */
+#define kgm281i0_rs(sel, data) LCD_GPIO_write(sel, 0, data)
+
+static void kgm281i0_write_gram_origin(__u32 sel)
+{
+	LCD_CPU_WR(sel, 0x0020, 0); /* GRAM horizontal Address */
+	LCD_CPU_WR(sel, 0x0021, 319); /* GRAM Vertical Address */
+	LCD_CPU_WR_INDEX(sel, 0x22); /* Write Memery Start */
+}
+
+static void kgm281i0_init(__u32 sel)
+{
+	kgm281i0_rs(sel, 1);
+	LCD_delay_ms(50);
+	kgm281i0_rs(sel, 0);
+	LCD_delay_ms(50);
+	kgm281i0_rs(sel, 1);
+
+	LCD_CPU_WR(sel, 0x0000, 0x0001);
+	LCD_CPU_WR(sel, 0x0001, 0x0100);
+	LCD_CPU_WR(sel, 0x0002, 0x0400);
+	LCD_CPU_WR(sel, 0x0003, 0x1018);
+	LCD_CPU_WR(sel, 0x0004, 0x0000);
+	LCD_CPU_WR(sel, 0x0008, 0x0202);
+	LCD_CPU_WR(sel, 0x0009, 0x0000);
+	LCD_CPU_WR(sel, 0x000A, 0x0000);
+	LCD_CPU_WR(sel, 0x000C, 0x0000);
+	LCD_CPU_WR(sel, 0x000D, 0x0000);
+	LCD_CPU_WR(sel, 0x000F, 0x0000);
+	LCD_CPU_WR(sel, 0x0010, 0x0000);
+	LCD_CPU_WR(sel, 0x0011, 0x0007);
+	LCD_CPU_WR(sel, 0x0012, 0x0000);
+	LCD_CPU_WR(sel, 0x0013, 0x0000);
+	LCD_delay_ms(50);
+	LCD_CPU_WR(sel, 0x0010, 0x17B0);
+	LCD_CPU_WR(sel, 0x0011, 0x0001);
+	LCD_delay_ms(50);
+	LCD_CPU_WR(sel, 0x0012, 0x013C);
+	LCD_delay_ms(50);
+	LCD_CPU_WR(sel, 0x0013, 0x1300);
+	LCD_CPU_WR(sel, 0x0029, 0x0012);
+	LCD_delay_ms(50);
+	LCD_CPU_WR(sel, 0x0020, 0x0000);
+	LCD_CPU_WR(sel, 0x0021, 0x0000);
+	LCD_CPU_WR(sel, 0x002B, 0x0020);
+	LCD_CPU_WR(sel, 0x0030, 0x0000);
+	LCD_CPU_WR(sel, 0x0031, 0x0306);
+	LCD_CPU_WR(sel, 0x0032, 0x0200);
+	LCD_CPU_WR(sel, 0x0035, 0x0107);
+	LCD_CPU_WR(sel, 0x0036, 0x0404);
+	LCD_CPU_WR(sel, 0x0037, 0x0606);
+	LCD_CPU_WR(sel, 0x0038, 0x0105);
+	LCD_CPU_WR(sel, 0x0039, 0x0707);
+	LCD_CPU_WR(sel, 0x003C, 0x0600);
+	LCD_CPU_WR(sel, 0x003D, 0x0807);
+	LCD_CPU_WR(sel, 0x0050, 0x0000);
+	LCD_CPU_WR(sel, 0x0051, 0x00EF);
+	LCD_CPU_WR(sel, 0x0052, 0x0000);
+	LCD_CPU_WR(sel, 0x0053, 0x013F);
+	LCD_CPU_WR(sel, 0x0060, 0x2700);
+	LCD_CPU_WR(sel, 0x0061, 0x0001);
+	LCD_CPU_WR(sel, 0x006A, 0x0000);
+	LCD_CPU_WR(sel, 0x0080, 0x0000);
+	LCD_CPU_WR(sel, 0x0081, 0x0000);
+	LCD_CPU_WR(sel, 0x0082, 0x0000);
+	LCD_CPU_WR(sel, 0x0083, 0x0000);
+	LCD_CPU_WR(sel, 0x0084, 0x0000);
+	LCD_CPU_WR(sel, 0x0085, 0x0000);
+	LCD_CPU_WR(sel, 0x0090, 0x0013);
+	LCD_CPU_WR(sel, 0x0092, 0x0000);
+	LCD_CPU_WR(sel, 0x0093, 0x0003);
+	LCD_CPU_WR(sel, 0x0095, 0x0110);
+	LCD_CPU_WR(sel, 0x0097, 0x0000);
+	LCD_CPU_WR(sel, 0x0098, 0x0000);
+	LCD_CPU_WR(sel, 0x0007, 0x0001);
+	LCD_delay_ms(50);
+	LCD_CPU_WR(sel, 0x0007, 0x0021);
+	LCD_CPU_WR(sel, 0x0007, 0x0023);
+	LCD_delay_ms(50);
+	LCD_CPU_WR(sel, 0x0007, 0x0173);
+}
+
+/*
+ * irq func
+ */
+static void Lcd_cpuisr_proc(void)
+{
+	kgm281i0_write_gram_origin(0);
+}
+
+static void LCD_panel_init(__u32 sel)
+{
+	kgm281i0_init(sel); /* initial lcd panel */
+	kgm281i0_write_gram_origin(sel); /* set gram origin */
+	LCD_CPU_register_irq(sel, Lcd_cpuisr_proc); /* register cpu irq func */
+	LCD_CPU_AUTO_FLUSH(sel, 1); /* start sent gram data */
+}
+
+static void LCD_panel_exit(__u32 sel)
+{
+
+}
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+	fun->cfg_open_flow = LCD_open_flow;
+	fun->cfg_close_flow = LCD_close_flow;
+}
diff --git a/drivers/video/sunxi/lcd/lcd_bak/hv_800x480.c b/drivers/video/sunxi/lcd/lcd_bak/hv_800x480.c
new file mode 100644
index 0000000..22b19a3
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_bak/hv_800x480.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 800;
+	info->lcd_y = 480;
+	info->lcd_dclk_freq = 33; /* MHz */
+
+	info->lcd_ht = 1056; /* htotal */
+	info->lcd_hbp = 216; /* h back porch */
+	info->lcd_hv_hspw = 10; /* hsync */
+	info->lcd_vt = 525 * 2; /* vtotal * 2 */
+	info->lcd_vbp = 35; /* h back porch */
+	info->lcd_hv_vspw = 10; /* vsync */
+
+	info->lcd_if = 0; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_hv_if = 0; /* 0:hv parallel; 1:hv serial; 2:ccir656 */
+
+	info->lcd_frm = 0; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 0;
+	info->lcd_pwm_freq = 12500; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x10000000; /* clock phase */
+
+	info->lcd_gamma_correction_en = 0;
+}
+#endif
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+}
diff --git a/drivers/video/sunxi/lcd/lcd_bak/hv_800x480_td043.c b/drivers/video/sunxi/lcd/lcd_bak/hv_800x480_td043.c
new file mode 100644
index 0000000..27f6a76
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_bak/hv_800x480_td043.c
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+static __u8 g_gamma_tbl[][2] = {
+	/* {input value, corrected value} */
+	{0, 0},
+	{15, 15},
+	{30, 30},
+	{45, 45},
+	{60, 60},
+	{75, 75},
+	{90, 90},
+	{105, 105},
+	{120, 120},
+	{135, 135},
+	{150, 150},
+	{165, 165},
+	{180, 180},
+	{195, 195},
+	{210, 210},
+	{225, 225},
+	{240, 240},
+	{255, 255},
+};
+
+static void lcd_gamma_gen(__panel_para_t *info)
+{
+	__u32 items = sizeof(g_gamma_tbl) / 2;
+	__u32 i, j;
+
+	for (i = 0; i < items - 1; i++) {
+		__u32 num = g_gamma_tbl[i + 1][0] - g_gamma_tbl[i][0];
+
+		for (j = 0; j < num; j++) {
+			__u32 value = 0;
+
+			value = g_gamma_tbl[i][1] +
+				((g_gamma_tbl[i + 1][1] -
+				  g_gamma_tbl[i][1]) * j) / num;
+			info->lcd_gamma_tbl[g_gamma_tbl[i][0] + j] =
+				(value << 16) + (value << 8) + value;
+		}
+	}
+	info->lcd_gamma_tbl[255] = (g_gamma_tbl[items - 1][1] << 16) +
+		(g_gamma_tbl[items - 1][1] << 8) + g_gamma_tbl[items - 1][1];
+}
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 800;
+	info->lcd_y = 480;
+	info->lcd_dclk_freq = 33; /* MHz */
+
+	info->lcd_ht = 1056; /* htotal */
+	info->lcd_hbp = 216; /* h back porch */
+	info->lcd_hv_hspw = 10; /* hsync */
+	info->lcd_vt = 525 * 2; /* vtotal * 2 */
+	info->lcd_vbp = 35; /* v back porch */
+	info->lcd_hv_vspw = 10;	/* vsync */
+
+	info->lcd_if = 0; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_hv_if = 0; /* 0:hv parallel; 1:hv serial; 2:ccir656 */
+
+	info->lcd_frm = 0; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 0;
+	info->lcd_pwm_freq = 12500; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x10000000; /* clock phase */
+
+	info->lcd_gamma_correction_en = 0;
+	lcd_gamma_gen(info);
+}
+#endif
+
+/*
+ * lcd flow function
+ * hv panel:first lcd_panel_init,than TCON_open
+ */
+static __s32 LCD_open_flow(__u32 sel)
+{
+	/* open lcd power, than delay 50ms */
+	LCD_OPEN_FUNC(sel, LCD_power_on_generic, 50);
+	/* lcd panel initial, than delay 50ms */
+	LCD_OPEN_FUNC(sel, LCD_panel_init, 50);
+	/* open lcd controller, than delay 500ms */
+	LCD_OPEN_FUNC(sel, TCON_open, 500);
+	/* open lcd backlight, than delay 0ms */
+	LCD_OPEN_FUNC(sel, LCD_bl_open_generic, 0);
+
+	return 0;
+}
+
+static __s32 LCD_close_flow(__u32 sel)
+{
+	/* close lcd backlight, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_bl_close_generic, 0);
+	/* close lcd controller, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, TCON_close, 0);
+	/* lcd panel exit, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_panel_exit, 0);
+	/* close lcd power, and delay 1000ms */
+	LCD_CLOSE_FUNC(sel, LCD_power_off_generic, 1000);
+
+	return 0;
+}
+
+/*
+ * lcd panel initial
+ * serial io initial
+ */
+#define td043_spi_scen(sel, data) LCD_GPIO_write(sel, 2, data)
+#define td043_spi_scl(sel, data) LCD_GPIO_write(sel, 1, data)
+#define td043_spi_sda(sel, data) LCD_GPIO_write(sel, 0, data)
+
+static void td043_spi_wr(__u32 sel, __u32 addr, __u32 value)
+{
+	__u32 i;
+	__u32 data = (addr << 10 | value);
+	td043_spi_scen(sel, 1);
+	td043_spi_scl(sel, 0);
+	td043_spi_scen(sel, 0);
+	for (i = 0; i < 16; i++) {
+		if (data & 0x8000)
+			td043_spi_sda(sel, 1);
+		else
+			td043_spi_sda(sel, 0);
+		data <<= 1;
+		LCD_delay_us(10);
+		td043_spi_scl(sel, 1);
+		LCD_delay_us(10);
+		td043_spi_scl(sel, 0);
+	}
+	td043_spi_scen(sel, 1);
+}
+
+static void td043_init(__u32 sel)
+{
+	td043_spi_wr(sel, 0x02, 0x07);
+	td043_spi_wr(sel, 0x03, 0x5f);
+	td043_spi_wr(sel, 0x04, 0x17);
+	td043_spi_wr(sel, 0x05, 0x20);
+	td043_spi_wr(sel, 0x06, 0x08);
+	td043_spi_wr(sel, 0x07, 0x20);
+	td043_spi_wr(sel, 0x08, 0x20);
+	td043_spi_wr(sel, 0x09, 0x20);
+	td043_spi_wr(sel, 0x0a, 0x20);
+	td043_spi_wr(sel, 0x0b, 0x20);
+	td043_spi_wr(sel, 0x0c, 0x20);
+	td043_spi_wr(sel, 0x0d, 0x20);
+	td043_spi_wr(sel, 0x0e, 0x10);
+	td043_spi_wr(sel, 0x0f, 0x10);
+	td043_spi_wr(sel, 0x10, 0x10);
+	td043_spi_wr(sel, 0x11, 0x15);
+	td043_spi_wr(sel, 0x12, 0xaa);
+	td043_spi_wr(sel, 0x13, 0xff);
+	td043_spi_wr(sel, 0x14, 0x86);
+	td043_spi_wr(sel, 0x15, 0x8e);
+	td043_spi_wr(sel, 0x16, 0xd6);
+	td043_spi_wr(sel, 0x17, 0xfe);
+	td043_spi_wr(sel, 0x18, 0x28);
+	td043_spi_wr(sel, 0x19, 0x52);
+	td043_spi_wr(sel, 0x1a, 0x7c);
+	td043_spi_wr(sel, 0x1b, 0xe9);
+	td043_spi_wr(sel, 0x1c, 0x42);
+	td043_spi_wr(sel, 0x1d, 0x88);
+	td043_spi_wr(sel, 0x1e, 0xb8);
+	td043_spi_wr(sel, 0x1f, 0xff);
+	td043_spi_wr(sel, 0x20, 0xf0);
+}
+
+static void LCD_panel_init(__u32 sel)
+{
+	td043_init(sel);
+}
+
+static void LCD_panel_exit(__u32 sel)
+{
+
+}
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+	fun->cfg_open_flow = LCD_open_flow;
+	fun->cfg_close_flow = LCD_close_flow;
+}
diff --git a/drivers/video/sunxi/lcd/lcd_bak/lvds_1024x600_hds100ifw1.c b/drivers/video/sunxi/lcd/lcd_bak/lvds_1024x600_hds100ifw1.c
new file mode 100644
index 0000000..2dc1416
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_bak/lvds_1024x600_hds100ifw1.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 1024;
+	info->lcd_y = 600;
+	info->lcd_dclk_freq = 52; /* MHz */
+
+	info->lcd_ht = 1344; /* htotal */
+	info->lcd_hbp = 20; /* h back porch */
+	info->lcd_hv_hspw = 10; /* hsync */
+	info->lcd_vt = 635 * 2; /* vtotal * 2 */
+	info->lcd_vbp = 20; /* v back porch */
+	info->lcd_hv_vspw = 10; /* vsync */
+
+	info->lcd_if = 3; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_frm = 1; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_lvds_ch = 0; /* 0:single link; 1:dual link */
+	info->lcd_lvds_bitwidth = 1; /* 0:24bit; 1:18bit */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 0;
+	info->lcd_pwm_freq = 12500; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x00000000;	/* clock phase */
+
+	info->lcd_gamma_correction_en = 0;
+}
+#endif
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+}
diff --git a/drivers/video/sunxi/lcd/lcd_bak/lvds_1080.c b/drivers/video/sunxi/lcd/lcd_bak/lvds_1080.c
new file mode 100644
index 0000000..78c1f94
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_bak/lvds_1080.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+
+/*
+ * comment out this line if you want to use the lcd para define in
+ * sys_config1.fex
+ */
+//#define LCD_PARA_USE_CONFIG
+
+#ifdef LCD_PARA_USE_CONFIG
+static __u8 g_gamma_tbl[][2] = {
+	/* {input value, corrected value} */
+	{0, 0},
+	{15, 15},
+	{30, 30},
+	{45, 45},
+	{60, 60},
+	{75, 75},
+	{90, 90},
+	{105, 105},
+	{120, 120},
+	{135, 135},
+	{150, 150},
+	{165, 165},
+	{180, 180},
+	{195, 195},
+	{210, 210},
+	{225, 225},
+	{240, 240},
+	{255, 255},
+};
+
+static void lcd_gamma_gen(__panel_para_t *info)
+{
+	__u32 items = sizeof(g_gamma_tbl) / 2;
+	__u32 i, j;
+
+	for (i = 0; i < items - 1; i++) {
+		__u32 num = g_gamma_tbl[i + 1][0] - g_gamma_tbl[i][0];
+
+		for (j = 0; j < num; j++) {
+			__u32 value = 0;
+
+			value = g_gamma_tbl[i][1] +
+				((g_gamma_tbl[i + 1][1] -
+				  g_gamma_tbl[i][1]) * j) / num;
+			info->lcd_gamma_tbl[g_gamma_tbl[i][0] + j] =
+				(value << 16) + (value << 8) + value;
+		}
+	}
+	info->lcd_gamma_tbl[255] = (g_gamma_tbl[items - 1][1] << 16) +
+		(g_gamma_tbl[items - 1][1] << 8) + g_gamma_tbl[items - 1][1];
+}
+
+static void LCD_cfg_panel_info(__panel_para_t *info)
+{
+	memset(info, 0, sizeof(__panel_para_t));
+
+	info->lcd_x = 1920;
+	info->lcd_y = 1080;
+	info->lcd_dclk_freq = 142; /* MHz */
+
+	info->lcd_ht = 2160; /* htotal */
+	info->lcd_hbp = 13; /* h back porch */
+	info->lcd_hv_hspw = 0; /* hsync */
+	info->lcd_vt = 1125 * 2; /* vtotal * 2 */
+	info->lcd_vbp = 13; /* v back porch */
+	info->lcd_hv_vspw = 0; /* vsync */
+
+	info->lcd_if = 3; /* 0:hv(sync+de); 1:cpu/8080; 2:ttl; 3:lvds */
+
+	info->lcd_hv_if = 0; /* 0:hv parallel; 1:hv serial; 2:ccir656 */
+	info->lcd_hv_smode = 0; /* 0:RGB888 1:CCIR656 */
+	info->lcd_hv_s888_if = 0; /* serial RGB format */
+	info->lcd_hv_syuv_if = 0; /* serial YUV format */
+
+	info->lcd_cpu_if = 0; /* 0:18bit 4:16bit */
+	info->lcd_frm = 0; /* 0:direct; 1:rgb666 dither; 2:rgb656 dither */
+
+	info->lcd_lvds_ch = 1; /* 0:single link; 1:dual link */
+	info->lcd_lvds_mode = 0; /* 0:NS mode; 1:JEIDA mode */
+	info->lcd_lvds_bitwidth = 0; /* 0:24bit; 1:18bit */
+	info->lcd_lvds_io_cross = 1; /* 0:normal; 1:pn cross */
+
+	info->lcd_pwm_not_used = 0;
+	info->lcd_pwm_ch = 0;
+	info->lcd_pwm_freq = 10000; /* Hz */
+	info->lcd_pwm_pol = 0;
+
+	info->lcd_io_cfg0 = 0x10000000; /* clock phase */
+
+	info->lcd_gamma_correction_en = 0;
+	if (info->lcd_gamma_correction_en)
+		lcd_gamma_gen(info);
+}
+#endif
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun)
+{
+#ifdef LCD_PARA_USE_CONFIG
+	fun->cfg_panel_info = LCD_cfg_panel_info;
+#endif
+}
diff --git a/drivers/video/sunxi/lcd/lcd_panel_cfg.h b/drivers/video/sunxi/lcd/lcd_panel_cfg.h
new file mode 100644
index 0000000..927f88e
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_panel_cfg.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LCD_PANNEL_CFG_H__
+#define __LCD_PANNEL_CFG_H__
+
+#include "dev_lcd.h"
+
+void LCD_power_on_generic(__u32 sel);
+void LCD_power_off_generic(__u32 sel);
+void LCD_bl_open_generic(__u32 sel);
+void LCD_bl_close_generic(__u32 sel);
+__s32 LCD_open_flow_generic(__u32 sel);
+__s32 LCD_close_flow_generic(__u32 sel);
+__s32 LCD_user_defined_func_generic(__u32 sel, __u32 para1, __u32 para2,
+				    __u32 para3);
+void LCD_get_panel_funs_generic(__lcd_panel_fun_t *fun);
+
+void LCD_get_panel_funs_0(__lcd_panel_fun_t *fun);
+void LCD_get_panel_funs_1(__lcd_panel_fun_t *fun);
+
+#define BIT0	0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+#define BIT4	0x00000010
+#define BIT5	0x00000020
+#define BIT6	0x00000040
+#define BIT7	0x00000080
+#define BIT8	0x00000100
+#define BIT9	0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+#endif
diff --git a/drivers/video/sunxi/lcd/lcd_panel_cfg_generic.c b/drivers/video/sunxi/lcd/lcd_panel_cfg_generic.c
new file mode 100644
index 0000000..78efa86
--- /dev/null
+++ b/drivers/video/sunxi/lcd/lcd_panel_cfg_generic.c
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 2007-2012 Allwinner Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "lcd_panel_cfg.h"
+#include "../disp/disp_lcd.h"
+
+#define CMD_WIRTE_DELAY 2
+
+//#define SPI_DATA_PRINT
+
+#ifdef SPI_DATA_PRINT
+#define lcd_spi_dbg(msg, ...) pr_info("[LCD_SPI]" msg, ##__VA_ARGS__)
+#else
+#define lcd_spi_dbg(msg, ...)
+#endif
+
+static __s32 lcd_spi_cs;
+static __s32 lcd_spi_clk;
+static __s32 lcd_spi_mosi;
+static __s32 lcd_spi_used;
+static __s32 lcd_spi_module = -1;
+
+static void
+check_spi_used_value(void)
+{
+	if (SCRIPT_PARSER_OK !=
+	    script_parser_fetch("lcd_spi_para", "lcd_spi_used",
+				&lcd_spi_used, 1))
+		__inf("LCD SPI doesn't use.\n");
+
+	if (!lcd_spi_used)
+		__inf("LCD SPI doesn't use.\n");
+}
+
+static void
+LCD_SPI_Init(__u32 sel)
+{
+	if (SCRIPT_PARSER_OK !=
+	    script_parser_fetch("lcd_spi_para", "lcd_spi_module",
+				&lcd_spi_module, 1)) {
+		__wrn("There is no LCD SPI module input.\n");
+		return;
+	}
+
+	lcd_spi_cs = gpio_request_ex("lcd_spi_para", "lcd_spi_cs");
+	if (!lcd_spi_cs) {
+		__wrn("request gpio lcd_spi_cs error.\n");
+		goto ERR1;
+	}
+	lcd_spi_clk = gpio_request_ex("lcd_spi_para", "lcd_spi_clk");
+	if (!lcd_spi_clk) {
+		__wrn("request gpio lcd_spi_clk error.\n");
+		goto ERR2;
+	}
+	lcd_spi_mosi = gpio_request_ex("lcd_spi_para", "lcd_spi_mosi");
+	if (!lcd_spi_mosi) {
+		__wrn("request gpio lcd_spi_mosi error.\n");
+		goto ERR3;
+	}
+	return;
+
+	lcd_spi_dbg("release GPIO src : lcd_spi_mosi\n");
+	gpio_release(lcd_spi_mosi, 2);
+ERR3:
+	lcd_spi_dbg("release GPIO src : lcd_spi_clk\n");
+	gpio_release(lcd_spi_clk, 2);
+ERR2:
+	lcd_spi_dbg("release GPIO src : lcd_spi_cs\n");
+	gpio_release(lcd_spi_cs, 2);
+ERR1:
+	return;
+}
+
+static void
+LCD_SPI_Write(__u32 sel)
+{
+	int i = 0, j = 0, offset = 0, bit_val = 0, ret = 0;
+	u16 data[9] = {		/* module 0 data */
+		0x0029,		/* reset */
+		0x0025,		/* standby */
+		0x0840,		/* enable normally black */
+		0x0430,		/* enable FRC/dither */
+		0x385f,		/* enter test mode(1) */
+		0x3ca4,		/* enter test mode(2) */
+		0x3409,		/* enable SDRRS, enlarge OE width */
+		0x4041,		/* adopt 2 line / 1 dot */
+		/* wait 100ms */
+		0x00ad,		/* display on */
+	};
+
+	lcd_spi_dbg
+	    ("============ start LCD SPI data write, module = %d============\n",
+	     lcd_spi_module);
+
+	switch (lcd_spi_module) {
+	case 0: /* rili 7inch */
+		for (i = 0; i < 8; i++) {
+			gpio_write_one_pin_value(lcd_spi_cs, 0, "lcd_spi_cs");
+			lcd_spi_dbg("write data[%d]:", i);
+
+			for (j = 0; j < 16; j++) {
+				gpio_write_one_pin_value(lcd_spi_clk, 0,
+							 "lcd_spi_clk");
+				offset = 15 - j;
+				bit_val = 0x0001 & (data[i] >> offset);
+				ret = gpio_write_one_pin_value
+					(lcd_spi_mosi, bit_val, "lcd_spi_mosi");
+#ifdef SPI_DATA_PRINT
+				if (ret == 0)
+					lcd_spi_dbg("%d-", bit_val);
+				else
+					lcd_spi_dbg("write[bit:%d]ERR", j);
+#endif
+				LCD_delay_us(CMD_WIRTE_DELAY);
+				gpio_write_one_pin_value(lcd_spi_clk, 1,
+							 "lcd_spi_clk");
+				LCD_delay_us(CMD_WIRTE_DELAY);
+			}
+
+			lcd_spi_dbg("\n");
+			gpio_write_one_pin_value(lcd_spi_cs, 1, "lcd_spi_cs");
+			gpio_write_one_pin_value(lcd_spi_clk, 1, "lcd_spi_clk");
+			LCD_delay_us(CMD_WIRTE_DELAY);
+		}
+		LCD_delay_ms(50);
+		gpio_write_one_pin_value(lcd_spi_cs, 0, "lcd_spi_cs");
+
+		lcd_spi_dbg("write data[8]:");
+
+		for (j = 0; j < 16; j++) {
+			gpio_write_one_pin_value(lcd_spi_clk, 0, "lcd_spi_clk");
+			offset = 15 - j;
+			bit_val = (0x0001 & (data[i] >> offset));
+			ret = gpio_write_one_pin_value(lcd_spi_mosi, bit_val,
+						       "lcd_spi_mosi");
+#ifdef SPI_DATA_PRINT
+			if (ret == 0)
+				lcd_spi_dbg("%d-", bit_val);
+			else
+				lcd_spi_dbg("write[bit:%d]ERR", j);
+#endif
+			LCD_delay_us(CMD_WIRTE_DELAY);
+			gpio_write_one_pin_value(lcd_spi_clk, 1, "lcd_spi_clk");
+			LCD_delay_us(CMD_WIRTE_DELAY);
+		}
+
+		lcd_spi_dbg("\n");
+		gpio_write_one_pin_value(lcd_spi_cs, 1, "lcd_spi_cs");
+		gpio_write_one_pin_value(lcd_spi_clk, 1, "lcd_spi_clk");
+		LCD_delay_us(CMD_WIRTE_DELAY);
+		lcd_spi_dbg("LCD SPI data translation finished\n");
+		break;
+	default:
+		lcd_spi_dbg("%s Unknow lcd_spi_module\n", __func__);
+		break;
+	}
+}
+
+static void
+LCD_SPI_Dinit(__u32 sel)
+{
+	lcd_spi_dbg("release GPIO src : lcd_spi_mosi\n");
+	if (lcd_spi_mosi)
+		gpio_release(lcd_spi_mosi, 2);
+
+	lcd_spi_dbg("release GPIO src : lcd_spi_clk\n");
+	if (lcd_spi_clk)
+		gpio_release(lcd_spi_clk, 2);
+
+	lcd_spi_dbg("release GPIO src : lcd_spi_cs\n");
+	if (lcd_spi_cs)
+		gpio_release(lcd_spi_cs, 2);
+}
+
+void LCD_power_on_generic(__u32 sel)
+{
+	LCD_POWER_EN(sel, 1); /* config lcd_power pin to open lcd power */
+}
+
+void LCD_power_off_generic(__u32 sel)
+{
+	LCD_POWER_EN(sel, 0); /* config lcd_power pin to close lcd power */
+}
+
+void LCD_bl_open_generic(__u32 sel)
+{
+	LCD_PWM_EN(sel, 1); /* open pwm module */
+	LCD_BL_EN(sel, 1); /* config lcd_bl_en pin to open lcd backlight */
+}
+
+void LCD_bl_close_generic(__u32 sel)
+{
+	LCD_BL_EN(sel, 0); /* config lcd_bl_en pin to close lcd backlight */
+	LCD_PWM_EN(sel, 0); /* close pwm module */
+}
+
+__s32 LCD_open_flow_generic(__u32 sel)
+{
+	check_spi_used_value();
+	/* open lcd power, and delay 50ms */
+	LCD_OPEN_FUNC(sel, LCD_power_on_generic, 50);
+	if (lcd_spi_used) {
+		/* request and init gpio, and delay 20ms */
+		LCD_OPEN_FUNC(sel, LCD_SPI_Init, 20);
+		/*
+		 * use gpio to config lcd module to the work mode,
+		 * and delay 10ms
+		 */
+		LCD_OPEN_FUNC(sel, LCD_SPI_Write, 10);
+	}
+	/* open lcd controller, and delay 500ms */
+	LCD_OPEN_FUNC(sel, TCON_open, 500);
+	/* open lcd backlight, and delay 0ms */
+	LCD_OPEN_FUNC(sel, LCD_bl_open_generic, 0);
+
+	return 0;
+}
+
+__s32 LCD_close_flow_generic(__u32 sel)
+{
+	/* close lcd backlight, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, LCD_bl_close_generic, 0);
+	/* close lcd controller, and delay 0ms */
+	LCD_CLOSE_FUNC(sel, TCON_close, 0);
+	if (lcd_spi_used)
+		/* release gpio, and delay 0ms */
+		LCD_CLOSE_FUNC(sel, LCD_SPI_Dinit, 0);
+
+	/* close lcd power, and delay 1000ms */
+	LCD_CLOSE_FUNC(sel, LCD_power_off_generic, 1000);
+
+	return 0;
+}
+
+/* sel: 0:lcd0; 1:lcd1 */
+__s32 LCD_user_defined_func_generic(__u32 sel, __u32 para1, __u32 para2,
+				    __u32 para3)
+{
+	return 0;
+}
+
+void LCD_get_panel_funs_generic(__lcd_panel_fun_t *fun)
+{
+	/* lcd panel info defined in sys_config1.fex */
+	fun->cfg_panel_info = NULL;
+	fun->cfg_open_flow = LCD_open_flow_generic;
+	fun->cfg_close_flow = LCD_close_flow_generic;
+	fun->lcd_user_defined_func = LCD_user_defined_func_generic;
+}
