diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 7fe19a3..26bec47 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -699,6 +699,53 @@ config ARCH_PICOXCELL
 	  family of Femtocell devices.  The picoxcell support requires device tree
 	  for all boards.
 
+config ARCH_SUN4I
+	bool "AllWinner SUN4I (A10 SoC) Platform"
+	select PLAT_SUNXI
+	select CPU_V7
+	select ARM_AMBA
+	select HAVE_CLK
+	select GENERIC_CLOCKEVENTS
+	select ARCH_HAS_CPUFREQ
+	select ARM_L1_CACHE_SHIFT_6
+	select NEED_MACH_IO_H
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+	help
+	  This enables support for Allwinner Technology Co., Ltd A10 SoC based systems
+
+config ARCH_SUN5I
+	bool "AllWinner SUN5I (A10s/A13 SoC) Platform"
+	select PLAT_SUNXI
+        select CPU_V7
+        select ARM_AMBA
+        select HAVE_CLK
+        select GENERIC_CLOCKEVENTS
+        select ARCH_HAS_CPUFREQ
+        select ARM_L1_CACHE_SHIFT_6
+	select NEED_MACH_IO_H
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+        help
+	  This enables support for Allwinner Technology Co., Ltd A10s/A13 SoC based systems
+
+config ARCH_SUN7I
+	bool "AllWinner SUN7I (A20 SoC) Platform"
+	select PLAT_SUNXI
+	select CPU_V7
+	select ARM_AMBA
+	select ARM_GIC
+	select HAVE_SMP
+	select MIGHT_HAVE_CACHE_L2X0
+	select ARCH_HAS_BARRIERS if SMP
+	select ZONE_DMA
+	select CLKDEV_LOOKUP
+	select GENERIC_CLOCKEVENTS
+	select ARCH_HAS_CPUFREQ
+	select NEED_MACH_IO_H
+	select NEED_MACH_MEMORY_H
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+	help
+	  This enables support for Allwinner Technology Co., Ltd A20 SoC based systems
+
 config ARCH_PNX4008
 	bool "Philips Nexperia PNX4008 Mobile"
 	select CPU_ARM926T
@@ -1109,6 +1156,10 @@ source "arch/arm/mach-s5pc100/Kconfig"
 
 source "arch/arm/mach-s5pv210/Kconfig"
 
+if PLAT_SUNXI
+source "arch/arm/plat-sunxi/Kconfig"
+endif
+
 source "arch/arm/mach-exynos/Kconfig"
 
 source "arch/arm/mach-shmobile/Kconfig"
@@ -1147,6 +1198,9 @@ config PLAT_PXA
 config PLAT_VERSATILE
 	bool
 
+config PLAT_SUNXI
+	bool
+
 config ARM_TIMER_SP804
 	bool
 	select CLKSRC_MMIO
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 1d6402c..7397db6 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -197,6 +197,10 @@ machine-$(CONFIG_MACH_SPEAR310)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR320)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR600)		:= spear6xx
 machine-$(CONFIG_ARCH_ZYNQ)		:= zynq
+machine-$(CONFIG_ARCH_SUN4I)		:= sun4i
+machine-$(CONFIG_ARCH_SUN5I)		:= sun5i
+machine-$(CONFIG_ARCH_SUN6I)		:= sun6i
+machine-$(CONFIG_ARCH_SUN7I)		:= sun7i
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
@@ -210,6 +214,7 @@ plat-$(CONFIG_PLAT_ORION)	:= orion
 plat-$(CONFIG_PLAT_PXA)		:= pxa
 plat-$(CONFIG_PLAT_S3C24XX)	:= s3c24xx samsung
 plat-$(CONFIG_PLAT_S5P)		:= s5p samsung
+plat-$(CONFIG_PLAT_SUNXI)	:= sunxi
 plat-$(CONFIG_PLAT_SPEAR)	:= spear
 plat-$(CONFIG_PLAT_VERSATILE)	:= versatile
 
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 87278fc..adff076 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -767,6 +767,8 @@ proc_types:
 @		b	__arm6_mmu_cache_off
 @		b	__armv3_mmu_cache_flush
 
+#if !defined(CONFIG_CPU_V7)
+		/* This collides with some V7 IDs, preventing correct detection */
 		.word	0x00000000		@ old ARM ID
 		.word	0x0000f000
 		mov	pc, lr
@@ -775,6 +777,7 @@ proc_types:
  THUMB(		nop				)
 		mov	pc, lr
  THUMB(		nop				)
+#endif
 
 		.word	0x41007000		@ ARM7/710
 		.word	0xfff8fe00
diff --git a/arch/arm/configs/a12_defconfig b/arch/arm/configs/a12_defconfig
new file mode 100644
index 0000000..7837483
--- /dev/null
+++ b/arch/arm/configs/a12_defconfig
@@ -0,0 +1,260 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_IKCONFIG=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_BLK_CGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_SGI_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_SUN5I=y
+CONFIG_SW_DEBUG_UART=1
+CONFIG_SWP_EMULATE=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_CMDLINE="mem=448M@0x40000000 console=ttyS0,115200"
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_NET_IPIP=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_NET_PKTGEN=m
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_MAC80211=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_SUNXI_NAND=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_SNAPSHOT=y
+CONFIG_DM_MIRROR=y
+CONFIG_DM_ZERO=y
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_MULTIPATH_QL=y
+CONFIG_DM_MULTIPATH_ST=y
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_SUN4IKEYPAD=m
+CONFIG_KEYBOARD_SUN4I_KEYBOARD=m
+CONFIG_KEYBOARD_HV2605_KEYBOARD=m
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GT801=m
+CONFIG_TOUCHSCREEN_GT811=m
+CONFIG_TOUCHSCREEN_GT818=m
+CONFIG_TOUCHSCREEN_SUN4I_TS=m
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_ZT8031=m
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_SPI=y
+CONFIG_SPI_SUN5I=y
+CONFIG_SUN5I_SPI_NDMA=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SUNXI=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+# CONFIG_HWMON is not set
+CONFIG_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_SUN5I_CEDAR=y
+CONFIG_PA_CONTROL=y
+CONFIG_MALI=m
+# CONFIG_UMP_DEBUG is not set
+CONFIG_FB=y
+CONFIG_FB_SUNXI=y
+CONFIG_FB_SUNXI_LCD=y
+CONFIG_FB_SUNXI_HDMI=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SOUND_SUN4I=y
+CONFIG_SND_SUNXI_SOC_CODEC=y
+CONFIG_SND_SUNXI_SOC_HDMIAUDIO=y
+CONFIG_SND_SUNXI_SOC_SPDIF=m
+CONFIG_SND_SUNXI_SOC_I2S_INTERFACE=m
+CONFIG_HID_KYE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_SW_SUNXI_USB=y
+CONFIG_USB_SW_SUNXI_USB_MANAGER=y
+CONFIG_USB_SW_SUNXI_USB_DEBUG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_SUNXI_POWER_CONTROL=y
+CONFIG_MMC_SUNXI=y
+CONFIG_MMC_SUNXI_DBG=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_SUNXI=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUN5I=y
+CONFIG_STAGING=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_CIFS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LIST=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_SECURITYFS=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ZLIB=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
diff --git a/arch/arm/configs/a12_nuclear_defconfig b/arch/arm/configs/a12_nuclear_defconfig
new file mode 100644
index 0000000..fdf2509
--- /dev/null
+++ b/arch/arm/configs/a12_nuclear_defconfig
@@ -0,0 +1,391 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_BLK_CGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_SGI_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_SUN5I=y
+CONFIG_SW_DEBUG_UART=1
+CONFIG_SWP_EMULATE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_CMDLINE="mem=448M@0x40000000 console=ttyS0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_FANTASY=y
+CONFIG_CPU_FREQ_USR_EVNT_NOTIFY=y
+CONFIG_CPU_FREQ_DVFS=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE_DEMUX=y
+CONFIG_NET_IPGRE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_IPV6=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_MATCH_AH=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_L2TP=y
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=y
+CONFIG_L2TP_ETH=y
+CONFIG_NET_PKTGEN=m
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_SUNXI_NAND=y
+CONFIG_SUNXI_DBGREG=m
+CONFIG_UID_STAT=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_SNAPSHOT=y
+CONFIG_DM_MIRROR=y
+CONFIG_DM_ZERO=y
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_MULTIPATH_QL=y
+CONFIG_DM_MULTIPATH_ST=y
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPTP=y
+CONFIG_PPPOL2TP=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_NET1080 is not set
+CONFIG_USB_NET_MCS7830=m
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_RTL8192CU_SW=m
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_SUN4IKEYPAD=m
+CONFIG_KEYBOARD_SUN4I_KEYBOARD=m
+CONFIG_KEYBOARD_HV2605_KEYBOARD=m
+CONFIG_IR_SUNXI=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GT801=m
+CONFIG_TOUCHSCREEN_GT811=m
+CONFIG_TOUCHSCREEN_GT818=m
+CONFIG_TOUCHSCREEN_SUN4I_TS=m
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_ZT8031=m
+CONFIG_GSENSOR=y
+CONFIG_SENSORS_BMA250=m
+CONFIG_MEMSIC_ECOMPASS=m
+CONFIG_SENSORS_MXC622X=m
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_SPI=y
+CONFIG_SPI_SUN5I=y
+CONFIG_SUN5I_SPI_NDMA=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SUNXI=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+CONFIG_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+# CONFIG_VIDEO_IR_I2C is not set
+# CONFIG_V4L_USB_DRIVERS is not set
+CONFIG_VIDEO_SUN5I_CEDAR=y
+CONFIG_CSI_OV7670=m
+CONFIG_CSI_GT2005=m
+CONFIG_CSI_GC0308=m
+CONFIG_CSI_HI704=m
+CONFIG_CSI_SP0838=m
+CONFIG_CSI_MT9M112=m
+CONFIG_CSI_MT9M113=m
+CONFIG_CSI_OV2655=m
+CONFIG_CSI_HI253=m
+CONFIG_CSI_MT9D112=m
+CONFIG_CSI_GC0307=m
+CONFIG_CSI_OV5640=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_PA_CONTROL=y
+CONFIG_MALI=m
+CONFIG_FB=y
+CONFIG_FB_SUNXI=y
+CONFIG_FB_SUNXI_LCD=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SOUND_SUN4I=y
+CONFIG_SND_SUNXI_SOC_CODEC=y
+CONFIG_SND_SUNXI_SOC_SPDIF=m
+CONFIG_SND_SUNXI_SOC_I2S_INTERFACE=m
+CONFIG_HID_KYE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_SW_SUNXI_USB=y
+CONFIG_USB_SW_SUNXI_USB_MANAGER=y
+CONFIG_USB_SW_SUNXI_USB_DEBUG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_BLOCK_MINORS=16
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_SUNXI_POWER_CONTROL=y
+CONFIG_MMC_SUNXI=y
+CONFIG_MMC_SUNXI_DBG=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_SUNXI=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUN5I=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_CIFS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LIST=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_LL=y
+CONFIG_SECURITYFS=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_ZLIB=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
+CONFIG_AVERAGE=y
diff --git a/arch/arm/configs/a13_defconfig b/arch/arm/configs/a13_defconfig
new file mode 100644
index 0000000..9e266c1
--- /dev/null
+++ b/arch/arm/configs/a13_defconfig
@@ -0,0 +1,267 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_BLK_CGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_SGI_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_SUN5I=y
+CONFIG_SW_DEBUG_UART=1
+CONFIG_SWP_EMULATE=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_CMDLINE="mem=448M@0x40000000 console=ttyS0,115200"
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_NET_IPIP=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_NET_PKTGEN=m
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_MAC80211=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_UB=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_SUNXI_NAND=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_LINEAR=y
+CONFIG_MD_MULTIPATH=y
+CONFIG_MD_FAULTY=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_SNAPSHOT=y
+CONFIG_DM_MIRROR=y
+CONFIG_DM_ZERO=y
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_MULTIPATH_QL=y
+CONFIG_DM_MULTIPATH_ST=y
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+CONFIG_RTL8192CU_SW=m
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_SUN4IKEYPAD=m
+CONFIG_KEYBOARD_SUN4I_KEYBOARD=m
+CONFIG_KEYBOARD_HV2605_KEYBOARD=m
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GT801=m
+CONFIG_TOUCHSCREEN_GT811=m
+CONFIG_TOUCHSCREEN_GT818=m
+CONFIG_TOUCHSCREEN_SUN4I_TS=m
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_ZT8031=m
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_SPI=y
+CONFIG_SPI_SUN5I=y
+CONFIG_SUN5I_SPI_NDMA=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SUNXI=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+# CONFIG_HWMON is not set
+CONFIG_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_SUN5I_CEDAR=y
+CONFIG_PA_CONTROL=y
+CONFIG_MALI=m
+# CONFIG_UMP_DEBUG is not set
+CONFIG_FB=y
+CONFIG_FB_SUNXI=y
+CONFIG_FB_SUNXI_LCD=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SOUND_SUN4I=y
+CONFIG_SND_SUNXI_SOC_CODEC=y
+CONFIG_SND_SUNXI_SOC_SPDIF=m
+CONFIG_SND_SUNXI_SOC_I2S_INTERFACE=m
+CONFIG_HID_KYE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_SW_SUNXI_USB=y
+CONFIG_USB_SW_SUNXI_USB_MANAGER=y
+CONFIG_USB_SW_SUNXI_USB_DEBUG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_SUNXI_POWER_CONTROL=y
+CONFIG_MMC_SUNXI=y
+CONFIG_MMC_SUNXI_DBG=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_SUNXI=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUN5I=y
+CONFIG_STAGING=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_CIFS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LIST=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_LL=y
+CONFIG_SECURITYFS=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ZLIB=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
diff --git a/arch/arm/configs/a13_nuclear_defconfig b/arch/arm/configs/a13_nuclear_defconfig
new file mode 100644
index 0000000..d2e3545
--- /dev/null
+++ b/arch/arm/configs/a13_nuclear_defconfig
@@ -0,0 +1,392 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_BLK_CGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_SGI_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_SUN5I=y
+CONFIG_SW_DEBUG_UART=1
+CONFIG_SWP_EMULATE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_CMDLINE="mem=448M@0x40000000 console=ttyS0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_FANTASY=y
+CONFIG_CPU_FREQ_USR_EVNT_NOTIFY=y
+CONFIG_CPU_FREQ_DVFS=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE_DEMUX=y
+CONFIG_NET_IPGRE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_IPV6=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_MATCH_AH=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_L2TP=y
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=y
+CONFIG_L2TP_ETH=y
+CONFIG_NET_PKTGEN=m
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_SUNXI_NAND=y
+CONFIG_SUN4I_VIBRATOR=m
+CONFIG_SUNXI_DBGREG=m
+CONFIG_UID_STAT=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_SNAPSHOT=y
+CONFIG_DM_MIRROR=y
+CONFIG_DM_ZERO=y
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_MULTIPATH_QL=y
+CONFIG_DM_MULTIPATH_ST=y
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPTP=y
+CONFIG_PPPOL2TP=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_NET1080 is not set
+CONFIG_USB_NET_MCS7830=m
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_RTL8192CU_SW=m
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_SUN4IKEYPAD=m
+CONFIG_KEYBOARD_SUN4I_KEYBOARD=m
+CONFIG_KEYBOARD_HV2605_KEYBOARD=m
+CONFIG_IR_SUNXI=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GT801=m
+CONFIG_TOUCHSCREEN_GT811=m
+CONFIG_TOUCHSCREEN_GT818=m
+CONFIG_TOUCHSCREEN_SUN4I_TS=m
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_ZT8031=m
+CONFIG_GSENSOR=y
+CONFIG_SENSORS_BMA250=m
+CONFIG_MEMSIC_ECOMPASS=m
+CONFIG_SENSORS_MXC622X=m
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_SPI=y
+CONFIG_SPI_SUN5I=y
+CONFIG_SUN5I_SPI_NDMA=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SUNXI=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+CONFIG_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+# CONFIG_VIDEO_IR_I2C is not set
+# CONFIG_V4L_USB_DRIVERS is not set
+CONFIG_CSI_OV7670=m
+CONFIG_CSI_GT2005=m
+CONFIG_CSI_GC0308=m
+CONFIG_CSI_HI704=m
+CONFIG_CSI_SP0838=m
+CONFIG_CSI_MT9M112=m
+CONFIG_CSI_MT9M113=m
+CONFIG_CSI_OV2655=m
+CONFIG_CSI_HI253=m
+CONFIG_CSI_MT9D112=m
+CONFIG_CSI_GC0307=m
+CONFIG_CSI_OV5640=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_PA_CONTROL=y
+CONFIG_MALI=m
+CONFIG_FB=y
+CONFIG_FB_SUNXI=y
+CONFIG_FB_SUNXI_LCD=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SOUND_SUN4I=y
+CONFIG_SND_SUNXI_SOC_CODEC=y
+CONFIG_SND_SUNXI_SOC_SPDIF=m
+CONFIG_SND_SUNXI_SOC_I2S_INTERFACE=m
+CONFIG_HID_KYE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_SW_SUNXI_USB=y
+CONFIG_USB_SW_SUNXI_USB_MANAGER=y
+CONFIG_USB_SW_SUNXI_USB_DEBUG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_BLOCK_MINORS=16
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_SUNXI_POWER_CONTROL=y
+CONFIG_MMC_SUNXI=y
+CONFIG_MMC_SUNXI_DBG=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_SUNXI=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUN5I=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_CIFS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LIST=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_LL=y
+CONFIG_SECURITYFS=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_ZLIB=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
+CONFIG_AVERAGE=y
diff --git a/arch/arm/configs/sun4i_crane_defconfig b/arch/arm/configs/sun4i_crane_defconfig
new file mode 100644
index 0000000..7301d5a
--- /dev/null
+++ b/arch/arm/configs/sun4i_crane_defconfig
@@ -0,0 +1,392 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=2
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_COUNTERS=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_SGI_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_ARCH_SUN4I=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/nandb rw init=/init loglevel=8"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_FANTASY=y
+CONFIG_CPU_FREQ_USR_EVNT_NOTIFY=y
+CONFIG_CPU_FREQ_DVFS=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE_DEMUX=y
+CONFIG_NET_IPGRE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_IPV6=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_MATCH_AH=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_L2TP=y
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=y
+CONFIG_L2TP_ETH=y
+CONFIG_NET_PKTGEN=m
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_RFKILL=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_SUNXI_NAND=y
+CONFIG_SUNXI_NAND_COMPAT_DEV=y
+CONFIG_SUN4I_VIBRATOR=m
+CONFIG_UID_STAT=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_DEBUG=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_SNAPSHOT=y
+CONFIG_DM_MIRROR=y
+CONFIG_DM_ZERO=y
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_MULTIPATH_QL=y
+CONFIG_DM_MULTIPATH_ST=y
+CONFIG_NETDEVICES=y
+CONFIG_SUNXI_EMAC=y
+CONFIG_PHYLIB=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPTP=y
+CONFIG_PPPOL2TP=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_NET1080 is not set
+CONFIG_USB_NET_MCS7830=m
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_RTL8192CU_SW=m
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+CONFIG_KEYBOARD_SUN4IKEYPAD=m
+CONFIG_KEYBOARD_SUN4I_KEYBOARD=y
+CONFIG_KEYBOARD_HV2605_KEYBOARD=m
+CONFIG_IR_SUNXI=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GT801=m
+CONFIG_TOUCHSCREEN_GT811=m
+CONFIG_TOUCHSCREEN_GT818=m
+CONFIG_TOUCHSCREEN_SUN4I_TS=m
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_ZT8031=m
+CONFIG_GSENSOR=y
+CONFIG_SENSORS_BMA250=m
+CONFIG_MEMSIC_ECOMPASS=m
+CONFIG_SENSORS_MXC622X=m
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=8
+CONFIG_SERIAL_8250_RUNTIME_UARTS=8
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SUNXI=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+CONFIG_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_VIDEO_CAPTURE_DRIVERS is not set
+CONFIG_VIDEO_SUN4I_CEDAR=y
+CONFIG_CSI_OV7670=m
+CONFIG_CSI_GT2005=m
+CONFIG_CSI_GC0308=m
+CONFIG_CSI_HI704=m
+CONFIG_CSI_SP0838=m
+CONFIG_CSI_MT9M112=m
+CONFIG_CSI_MT9M113=m
+CONFIG_CSI_OV2655=m
+CONFIG_CSI_HI253=m
+CONFIG_CSI_MT9D112=m
+CONFIG_CSI_GC0307=m
+CONFIG_CSI_OV5640=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_AUDIO_ENGINE=y
+CONFIG_PA_CONTROL=y
+CONFIG_MALI=m
+CONFIG_FB=y
+CONFIG_FB_SUNXI=y
+CONFIG_FB_SUNXI_LCD=y
+CONFIG_FB_SUNXI_HDMI=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SOUND_SUN4I=y
+CONFIG_SND_SUNXI_SOC_CODEC=y
+CONFIG_SND_SUNXI_SOC_HDMIAUDIO=y
+CONFIG_SND_SUNXI_SOC_SPDIF=m
+CONFIG_SND_SUNXI_SOC_I2S_INTERFACE=m
+CONFIG_HID_KYE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_SW_SUNXI_USB=y
+CONFIG_USB_SW_SUNXI_USB_MANAGER=y
+CONFIG_USB_SW_SUNXI_USB_DEBUG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_SUNXI_POWER_CONTROL=y
+CONFIG_MMC_SUNXI=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_SUNXI=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUN4I=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_QFMT_V2=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_CIFS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=7
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_STACK_USAGE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LIST=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_LL=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_ZLIB=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_LIBCRC32C=y
+CONFIG_AVERAGE=y
diff --git a/arch/arm/configs/sun4i_defconfig b/arch/arm/configs/sun4i_defconfig
new file mode 100644
index 0000000..c4b5e88
--- /dev/null
+++ b/arch/arm/configs/sun4i_defconfig
@@ -0,0 +1,328 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_BLK_CGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_SGI_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_SUN4I=y
+CONFIG_SWP_EMULATE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_CMDLINE="mem=448M@0x40000000 console=ttyS0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=m
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_DVFS=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_NET_IPIP=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_NET_PKTGEN=m
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_RFKILL=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_SUNXI_NAND=y
+CONFIG_SUNXI_DBGREG=m
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_ATA=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_SW_SATA_AHCI_PLATFORM=m
+CONFIG_NETDEVICES=y
+CONFIG_SUNXI_EMAC=y
+CONFIG_PHYLIB=y
+CONFIG_RTL8192CU_SW=m
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+CONFIG_KEYBOARD_SUN4IKEYPAD=m
+CONFIG_KEYBOARD_SUN4I_KEYBOARD=m
+CONFIG_KEYBOARD_HV2605_KEYBOARD=m
+CONFIG_IR_SUNXI=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GT801=m
+CONFIG_TOUCHSCREEN_GT811=m
+CONFIG_TOUCHSCREEN_GT818=m
+CONFIG_TOUCHSCREEN_SUN4I_TS=m
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_ZT8031=m
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=8
+CONFIG_SERIAL_8250_RUNTIME_UARTS=8
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SUNXI=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+# CONFIG_HWMON is not set
+CONFIG_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_VIDEO_CAPTURE_DRIVERS is not set
+CONFIG_VIDEO_SUN4I_CEDAR=y
+CONFIG_CSI_OV7670=m
+CONFIG_CSI_GT2005=m
+CONFIG_CSI_GC0308=m
+CONFIG_CSI_HI704=m
+CONFIG_CSI_SP0838=m
+CONFIG_CSI_MT9M112=m
+CONFIG_CSI_MT9M113=m
+CONFIG_CSI_OV2655=m
+CONFIG_CSI_HI253=m
+CONFIG_CSI_MT9D112=m
+CONFIG_CSI_GC0307=m
+CONFIG_CSI_OV5640=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_AUDIO_ENGINE=y
+CONFIG_PA_CONTROL=y
+CONFIG_DRM=m
+CONFIG_DRM_MALI=m
+CONFIG_MALI=m
+CONFIG_FB=y
+CONFIG_FB_SUNXI=y
+CONFIG_FB_SUNXI_LCD=y
+CONFIG_FB_SUNXI_HDMI=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SOUND_SUN4I=y
+CONFIG_SND_SUNXI_SOC_CODEC=y
+CONFIG_SND_SUNXI_SOC_HDMIAUDIO=y
+CONFIG_SND_SUNXI_SOC_SPDIF=m
+CONFIG_SND_SUNXI_SOC_I2S_INTERFACE=m
+CONFIG_HID_KYE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_FILE_STORAGE_TEST=y
+CONFIG_USB_SW_SUNXI_USB=y
+CONFIG_USB_SW_SUNXI_USB_MANAGER=y
+CONFIG_USB_SW_SUNXI_USB_DEBUG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_SUNXI_POWER_CONTROL=y
+CONFIG_MMC_SUNXI=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_SUNXI=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUN4I=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_QFMT_V2=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+CONFIG_CIFS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LIST=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_SECURITYFS=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ZLIB=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_LIBCRC32C=y
+CONFIG_AVERAGE=y
diff --git a/arch/arm/configs/sun5i_defconfig b/arch/arm/configs/sun5i_defconfig
new file mode 100644
index 0000000..b674cb2
--- /dev/null
+++ b/arch/arm/configs/sun5i_defconfig
@@ -0,0 +1,257 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_BLK_CGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_SGI_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_SUN5I=y
+CONFIG_SW_DEBUG_UART=1
+CONFIG_SWP_EMULATE=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_CMDLINE="mem=448M@0x40000000 console=ttyS0,115200"
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_NET_IPIP=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_NET_PKTGEN=m
+CONFIG_CFG80211=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_MAC80211=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_SUNXI_NAND=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_NETDEVICES=y
+CONFIG_SUNXI_EMAC=y
+CONFIG_PHYLIB=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_SUN4IKEYPAD=m
+CONFIG_KEYBOARD_SUN4I_KEYBOARD=m
+CONFIG_KEYBOARD_HV2605_KEYBOARD=m
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GT801=m
+CONFIG_TOUCHSCREEN_GT811=m
+CONFIG_TOUCHSCREEN_GT818=m
+CONFIG_TOUCHSCREEN_SUN4I_TS=m
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_ZT8031=m
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_SPI=y
+CONFIG_SPI_SUN5I=y
+CONFIG_SUN5I_SPI_NDMA=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SUNXI=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+# CONFIG_HWMON is not set
+CONFIG_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_SUN5I_CEDAR=y
+CONFIG_PA_CONTROL=y
+CONFIG_MALI=m
+# CONFIG_UMP_DEBUG is not set
+CONFIG_FB=y
+CONFIG_FB_SUNXI=y
+CONFIG_FB_SUNXI_LCD=y
+CONFIG_FB_SUNXI_HDMI=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SOC=y
+CONFIG_SOUND_SUN4I=y
+CONFIG_SND_SUNXI_SOC_CODEC=y
+CONFIG_SND_SUNXI_SOC_HDMIAUDIO=y
+CONFIG_SND_SUNXI_SOC_SPDIF=m
+CONFIG_SND_SUNXI_SOC_I2S_INTERFACE=m
+CONFIG_HID_KYE=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_FILE_STORAGE_TEST=y
+CONFIG_USB_SW_SUNXI_USB=y
+CONFIG_USB_SW_SUNXI_USB_MANAGER=y
+CONFIG_USB_SW_SUNXI_USB_DEBUG=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_MMC_SUNXI_POWER_CONTROL=y
+CONFIG_MMC_SUNXI=y
+CONFIG_MMC_SUNXI_DBG=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_SUNXI=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUN5I=y
+CONFIG_STAGING=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+CONFIG_CIFS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LIST=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_LL=y
+CONFIG_SECURITYFS=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ZLIB=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
diff --git a/arch/arm/configs/sun7i_defconfig b/arch/arm/configs/sun7i_defconfig
new file mode 100644
index 0000000..169f3e6
--- /dev/null
+++ b/arch/arm/configs/sun7i_defconfig
@@ -0,0 +1,1223 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_IRQ_DOMAIN_DEBUG=y
+CONFIG_RCU_FAST_NO_HZ=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_CGROUP_MEM_RES_CTLR_KMEM=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_COUNTERS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_SGI_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_SUNXI_NAND_PARTITION=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_SUN7I=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_NR_CPUS=2
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/mmc0p1 rw init=/init loglevel=8"
+CONFIG_KEXEC=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=m
+CONFIG_CPU_FREQ_DEFAULT_GOV_FANTASY=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=m
+CONFIG_CPU_FREQ_GOV_USERSPACE=m
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPU_FREQ_USR_EVNT_NOTIFY=y
+CONFIG_CPU_FREQ_DVFS=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_ARPD=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_DIAG=m
+CONFIG_INET_UDP_DIAG=m
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=y
+CONFIG_TCP_CONG_WESTWOOD=y
+CONFIG_TCP_CONG_HTCP=y
+CONFIG_TCP_CONG_HSTCP=y
+CONFIG_TCP_CONG_HYBLA=y
+CONFIG_TCP_CONG_SCALABLE=y
+CONFIG_TCP_CONG_LP=y
+CONFIG_TCP_CONG_VENO=y
+CONFIG_TCP_CONG_YEAH=y
+CONFIG_TCP_CONG_ILLINOIS=y
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_TUNNEL=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NETWORK_PHY_TIMESTAMPING=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_ZONES=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_TIMEOUT=y
+CONFIG_NF_CONNTRACK_TIMESTAMP=y
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_SNMP=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NF_CT_NETLINK_TIMEOUT=m
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XT_SET=m
+CONFIG_NETFILTER_XT_TARGET_AUDIT=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_NFACCT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_SET=m
+CONFIG_IP_SET_BITMAP_IP=m
+CONFIG_IP_SET_BITMAP_IPMAC=m
+CONFIG_IP_SET_BITMAP_PORT=m
+CONFIG_IP_SET_HASH_IP=m
+CONFIG_IP_SET_HASH_IPPORT=m
+CONFIG_IP_SET_HASH_IPPORTIP=m
+CONFIG_IP_SET_HASH_IPPORTNET=m
+CONFIG_IP_SET_HASH_NET=m
+CONFIG_IP_SET_HASH_NETPORT=m
+CONFIG_IP_SET_HASH_NETIFACE=m
+CONFIG_IP_SET_LIST_SET=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_IPV6=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+CONFIG_IP_VS_PROTO_SCTP=y
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_PE_SIP=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RPFILTER=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_L2TP=m
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=m
+CONFIG_L2TP_ETH=m
+CONFIG_BRIDGE=m
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_BATMAN_ADV=m
+CONFIG_OPENVSWITCH=m
+CONFIG_NETPRIO_CGROUP=m
+CONFIG_NET_PKTGEN=m
+CONFIG_IRDA=m
+CONFIG_IRLAN=m
+CONFIG_IRNET=m
+CONFIG_IRCOMM=m
+CONFIG_IRDA_ULTRA=y
+CONFIG_IRTTY_SIR=m
+CONFIG_KINGSUN_DONGLE=m
+CONFIG_KSDAZZLE_DONGLE=m
+CONFIG_KS959_DONGLE=m
+CONFIG_USB_IRDA=m
+CONFIG_SIGMATEL_FIR=m
+CONFIG_MCS_FIR=m
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=m
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_BT_HCIBCM203X=m
+CONFIG_BT_HCIBPA10X=m
+CONFIG_BT_HCIBFUSB=m
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_BT_ATH3K=m
+CONFIG_BT_WILINK=m
+CONFIG_AF_RXRPC=m
+CONFIG_RXKAD=m
+CONFIG_CFG80211=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_CFG80211_ALLOW_RECONNECT=y
+CONFIG_MAC80211=m
+CONFIG_MAC80211_MESH=y
+CONFIG_WIMAX=m
+CONFIG_RFKILL=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_CONNECTOR=y
+CONFIG_MTD=m
+CONFIG_MTD_AFS_PARTS=m
+CONFIG_MTD_AR7_PARTS=m
+CONFIG_MTD_CHAR=m
+CONFIG_MTD_BLOCK=m
+CONFIG_MTD_BLOCK_RO=m
+CONFIG_FTL=m
+CONFIG_NFTL=m
+CONFIG_NFTL_RW=y
+CONFIG_INFTL=m
+CONFIG_RFD_FTL=m
+CONFIG_SSFDC=m
+CONFIG_SM_FTL=m
+CONFIG_MTD_OOPS=m
+CONFIG_MTD_SWAP=m
+CONFIG_MTD_CFI=m
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_MTD_CFI_INTELEXT=m
+CONFIG_MTD_CFI_AMDSTD=m
+CONFIG_MTD_CFI_STAA=m
+CONFIG_MTD_ROM=m
+CONFIG_MTD_ABSENT=m
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+CONFIG_MTD_PHYSMAP=m
+CONFIG_MTD_GPIO_ADDR=m
+CONFIG_MTD_PLATRAM=m
+CONFIG_MTD_LATCH_ADDR=m
+CONFIG_MTD_M25P80=m
+CONFIG_MTD_NAND_ECC_SMC=y
+CONFIG_MTD_NAND=m
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+CONFIG_MTD_NAND_ECC_BCH=y
+CONFIG_MTD_NAND_MUSEUM_IDS=y
+CONFIG_MTD_NAND_GPIO=m
+CONFIG_MTD_NAND_PLATFORM=m
+CONFIG_MTD_ALAUDA=m
+CONFIG_MTD_ONENAND=m
+CONFIG_MTD_ONENAND_VERIFY_WRITE=y
+CONFIG_MTD_ONENAND_OTP=y
+CONFIG_MTD_ONENAND_2X_PROGRAM=y
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=128
+CONFIG_MTD_UBI_GLUEBI=m
+CONFIG_PARPORT=m
+CONFIG_PARPORT_1284=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_DRBD=m
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_ATA_OVER_ETH=m
+CONFIG_SUNXI_DBGREG=m
+CONFIG_TI_DAC7512=m
+CONFIG_EEPROM_AT24=m
+CONFIG_EEPROM_AT25=m
+CONFIG_EEPROM_93XX46=m
+CONFIG_TI_ST=m
+CONFIG_SENSORS_LIS3_SPI=m
+CONFIG_SENSORS_LIS3_I2C=m
+CONFIG_ALTERA_STAPL=m
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_ISCSI_TCP=m
+CONFIG_LIBFCOE=m
+CONFIG_SCSI_OSD_INITIATOR=m
+CONFIG_SCSI_OSD_ULD=m
+CONFIG_ATA=y
+# CONFIG_SATA_PMP is not set
+CONFIG_SW_SATA_AHCI_PLATFORM=y
+# CONFIG_ATA_SFF is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_DEBUG=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_SNAPSHOT=y
+CONFIG_DM_THIN_PROVISIONING=m
+CONFIG_DM_MIRROR=y
+CONFIG_DM_RAID=m
+CONFIG_DM_LOG_USERSPACE=m
+CONFIG_DM_ZERO=y
+CONFIG_DM_MULTIPATH=y
+CONFIG_DM_MULTIPATH_QL=y
+CONFIG_DM_MULTIPATH_ST=y
+CONFIG_DM_DELAY=m
+CONFIG_DM_UEVENT=y
+CONFIG_DM_VERITY=m
+CONFIG_NETDEVICES=y
+CONFIG_NETCONSOLE=y
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_TUN=m
+CONFIG_WEMAC_SUN4I=y
+CONFIG_PHYLIB=y
+CONFIG_MICREL_KS8995MA=m
+CONFIG_PLIP=m
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOE=y
+CONFIG_PPTP=m
+CONFIG_PPPOL2TP=m
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+CONFIG_SLIP_MODE_SLIP6=y
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+# CONFIG_USB_NET_NET1080 is not set
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_CX82310_ETH=m
+CONFIG_USB_NET_KALMIA=m
+CONFIG_USB_NET_QMI_WWAN=m
+CONFIG_USB_HSO=m
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_IPHETH=m
+CONFIG_USB_SIERRA_NET=m
+CONFIG_USB_VL600=m
+CONFIG_LIBERTAS_THINFIRM=m
+CONFIG_LIBERTAS_THINFIRM_USB=m
+CONFIG_AT76C50X_USB=m
+CONFIG_USB_ZD1201=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_RTL8187=m
+CONFIG_WIFI_CONTROL_FUNC=y
+CONFIG_ATH_COMMON=m
+CONFIG_ATH9K=m
+CONFIG_ATH9K_AHB=y
+CONFIG_ATH9K_HTC=m
+CONFIG_CARL9170=m
+CONFIG_ATH6KL=m
+CONFIG_ATH6KL_SDIO=m
+CONFIG_ATH6KL_USB=m
+CONFIG_B43=m
+CONFIG_B43_PHY_N=y
+CONFIG_B43_PHY_HT=y
+CONFIG_B43LEGACY=m
+CONFIG_BCMDHD=m
+CONFIG_BRCMFMAC=m
+CONFIG_BRCMFMAC_USB=y
+CONFIG_HOSTAP=m
+CONFIG_HOSTAP_FIRMWARE=y
+CONFIG_IWM=m
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_USB=m
+CONFIG_LIBERTAS_SDIO=m
+CONFIG_LIBERTAS_SPI=m
+CONFIG_P54_COMMON=m
+CONFIG_P54_USB=m
+CONFIG_P54_SPI=m
+CONFIG_P54_SPI_DEFAULT_EEPROM=y
+CONFIG_RT2X00=m
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_UNKNOWN=y
+CONFIG_RTL8192CU=m
+CONFIG_WL1251=m
+CONFIG_WL1251_SPI=m
+CONFIG_WL1251_SDIO=m
+CONFIG_WL12XX_MENU=m
+CONFIG_WL12XX=m
+CONFIG_WL12XX_SPI=m
+CONFIG_WL12XX_SDIO=m
+CONFIG_ZD1211RW=m
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+CONFIG_RTL8192CU_SW=m
+CONFIG_RTL8188EU=m
+CONFIG_RTL8189ES=m
+CONFIG_RTL8723AS=m
+CONFIG_RTXX7X_SW=m
+CONFIG_WIMAX_I2400M_USB=m
+CONFIG_WIMAX_I2400M_SDIO=m
+CONFIG_WIMAX_IWMC3200_SDIO=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_SUN4IKEYPAD=m
+CONFIG_KEYBOARD_SUN4I_KEYBOARD=m
+CONFIG_KEYBOARD_HV2605_KEYBOARD=y
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_MOUSE_SYNAPTICS_USB=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_DB9=m
+CONFIG_JOYSTICK_GAMECON=m
+CONFIG_JOYSTICK_TURBOGRAFX=m
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_JOYSTICK_WALKERA0701=m
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=m
+CONFIG_TABLET_USB_AIPTEK=m
+CONFIG_TABLET_USB_GTCO=m
+CONFIG_TABLET_USB_HANWANG=m
+CONFIG_TABLET_USB_KBTAB=m
+CONFIG_TABLET_USB_WACOM=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=m
+CONFIG_TOUCHSCREEN_AD7877=m
+CONFIG_TOUCHSCREEN_AD7879=m
+CONFIG_TOUCHSCREEN_AD7879_I2C=m
+CONFIG_TOUCHSCREEN_AD7879_SPI=m
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_TOUCHSCREEN_AUO_PIXCIR=m
+CONFIG_TOUCHSCREEN_BU21013=m
+CONFIG_TOUCHSCREEN_CY8CTMG110=m
+CONFIG_TOUCHSCREEN_CYTTSP_CORE=m
+CONFIG_TOUCHSCREEN_CYTTSP_I2C=m
+CONFIG_TOUCHSCREEN_CYTTSP_SPI=m
+CONFIG_TOUCHSCREEN_DYNAPRO=m
+CONFIG_TOUCHSCREEN_HAMPSHIRE=m
+CONFIG_TOUCHSCREEN_EETI=m
+CONFIG_TOUCHSCREEN_FUJITSU=m
+CONFIG_TOUCHSCREEN_ILI210X=m
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_TOUCHSCREEN_WACOM_W8001=m
+CONFIG_TOUCHSCREEN_MAX11801=m
+CONFIG_TOUCHSCREEN_MCS5000=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_TOUCHSCREEN_INEXIO=m
+CONFIG_TOUCHSCREEN_MK712=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=m
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+CONFIG_TOUCHSCREEN_PIXCIR=m
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_TOUCHSCREEN_TOUCHIT213=m
+CONFIG_TOUCHSCREEN_TSC_SERIO=m
+CONFIG_TOUCHSCREEN_TSC2005=m
+CONFIG_TOUCHSCREEN_TSC2007=m
+CONFIG_TOUCHSCREEN_W90X900=m
+CONFIG_TOUCHSCREEN_ST1232=m
+CONFIG_TOUCHSCREEN_TPS6507X=m
+CONFIG_TOUCHSCREEN_GT801=m
+CONFIG_TOUCHSCREEN_GT811=m
+CONFIG_TOUCHSCREEN_GT818=m
+CONFIG_TOUCHSCREEN_SUN4I_TS=m
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_ZT8031=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_AD714X=m
+CONFIG_INPUT_BMA150=m
+CONFIG_INPUT_MMA8450=m
+CONFIG_INPUT_MPU3050=m
+CONFIG_INPUT_GP2A=m
+CONFIG_INPUT_GPIO_TILT_POLLED=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYCHORD=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+CONFIG_INPUT_KXTJ9=m
+CONFIG_INPUT_KXTJ9_POLLED_MODE=y
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_GPIO=m
+CONFIG_INPUT_PCF8574=m
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+CONFIG_INPUT_ADXL34X=m
+CONFIG_INPUT_CMA3000=m
+CONFIG_INPUT_CMA3000_I2C=m
+CONFIG_GSENSOR=y
+CONFIG_SENSORS_BMA250=m
+CONFIG_MEMSIC_ECOMPASS=m
+CONFIG_SENSORS_MXC622X=m
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=8
+CONFIG_SERIAL_8250_RUNTIME_UARTS=8
+CONFIG_PRINTER=m
+CONFIG_PPDEV=m
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_SUNXI=m
+CONFIG_SPI=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_PPS=m
+CONFIG_PTP_1588_CLOCK=m
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_W1=m
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+CONFIG_HWMON=m
+# CONFIG_SENSORS_MMA7660 is not set
+CONFIG_WATCHDOG=y
+CONFIG_USBPCWATCHDOG=m
+CONFIG_SSB_SDIOHOST=y
+CONFIG_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_DVB_CORE=m
+CONFIG_RC_CORE=m
+CONFIG_RC_ATI_REMOTE=m
+CONFIG_IR_IMON=m
+CONFIG_IR_MCEUSB=m
+CONFIG_IR_REDRAT3=m
+CONFIG_IR_STREAMZAP=m
+CONFIG_MEDIA_ATTACH=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_M5602=m
+CONFIG_USB_STV06XX=m
+CONFIG_USB_GL860=m
+CONFIG_USB_GSPCA_BENQ=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_USB_GSPCA_CPIA1=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_USB_GSPCA_JL2005BCD=m
+CONFIG_USB_GSPCA_KINECT=m
+CONFIG_USB_GSPCA_KONICA=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_USB_GSPCA_NW80X=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_USB_GSPCA_OV534_9=m
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_SE401=m
+CONFIG_USB_GSPCA_SN9C2028=m
+CONFIG_USB_GSPCA_SN9C20X=m
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_USB_GSPCA_SPCA1528=m
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_USB_GSPCA_SQ930X=m
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_USB_GSPCA_STV0680=m
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_USB_GSPCA_TOPRO=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_USB_GSPCA_VICAM=m
+CONFIG_USB_GSPCA_XIRLINK_CIT=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_VIDEO_PVRUSB2=m
+CONFIG_VIDEO_HDPVR=m
+CONFIG_VIDEO_EM28XX=m
+CONFIG_VIDEO_EM28XX_ALSA=m
+CONFIG_VIDEO_EM28XX_DVB=m
+CONFIG_VIDEO_TLG2300=m
+CONFIG_VIDEO_CX231XX=m
+CONFIG_VIDEO_CX231XX_ALSA=m
+CONFIG_VIDEO_CX231XX_DVB=m
+CONFIG_VIDEO_TM6000=m
+CONFIG_VIDEO_TM6000_ALSA=m
+CONFIG_VIDEO_TM6000_DVB=m
+CONFIG_VIDEO_USBVISION=m
+CONFIG_USB_ET61X251=m
+CONFIG_USB_SN9C102=m
+CONFIG_USB_PWC=m
+CONFIG_VIDEO_CPIA2=m
+CONFIG_USB_ZR364XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_USB_S2255=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=m
+CONFIG_SOC_CAMERA_IMX074=m
+CONFIG_SOC_CAMERA_MT9M001=m
+CONFIG_SOC_CAMERA_MT9M111=m
+CONFIG_SOC_CAMERA_MT9T031=m
+CONFIG_SOC_CAMERA_MT9T112=m
+CONFIG_SOC_CAMERA_MT9V022=m
+CONFIG_SOC_CAMERA_RJ54N1=m
+CONFIG_SOC_CAMERA_TW9910=m
+CONFIG_SOC_CAMERA_PLATFORM=m
+CONFIG_SOC_CAMERA_OV2640=m
+CONFIG_SOC_CAMERA_OV5642=m
+CONFIG_SOC_CAMERA_OV6650=m
+CONFIG_SOC_CAMERA_OV772X=m
+CONFIG_SOC_CAMERA_OV9640=m
+CONFIG_SOC_CAMERA_OV9740=m
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_CSI_OV7670=m
+CONFIG_CSI_GT2005=m
+CONFIG_CSI_GC0308=m
+CONFIG_CSI_HI704=m
+CONFIG_CSI_SP0838=m
+CONFIG_CSI_MT9M112=m
+CONFIG_CSI_MT9M113=m
+CONFIG_CSI_OV2655=m
+CONFIG_CSI_HI253=m
+CONFIG_CSI_MT9D112=m
+CONFIG_CSI_GC0307=m
+CONFIG_CSI_OV5640=m
+CONFIG_RADIO_SI470X=y
+CONFIG_USB_SI470X=m
+CONFIG_I2C_SI470X=m
+CONFIG_USB_MR800=m
+CONFIG_USB_DSBR=m
+CONFIG_RADIO_SI4713=m
+CONFIG_USB_KEENE=m
+CONFIG_RADIO_TEA5764=m
+CONFIG_RADIO_SAA7706H=m
+CONFIG_RADIO_TEF6862=m
+CONFIG_RADIO_WL1273=m
+CONFIG_AUDIO_ENGINE=y
+CONFIG_PA_CONTROL=y
+CONFIG_DVB_DYNAMIC_MINORS=y
+CONFIG_DVB_USB=m
+CONFIG_DVB_USB_A800=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+CONFIG_DVB_USB_DIBUSB_MB_FAULTY=y
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_DVB_USB_M920X=m
+CONFIG_DVB_USB_GL861=m
+CONFIG_DVB_USB_AU6610=m
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_DVB_USB_OPERA1=m
+CONFIG_DVB_USB_AF9005=m
+CONFIG_DVB_USB_AF9005_REMOTE=m
+CONFIG_DVB_USB_PCTV452E=m
+CONFIG_DVB_USB_DW2102=m
+CONFIG_DVB_USB_CINERGY_T2=m
+CONFIG_DVB_USB_ANYSEE=m
+CONFIG_DVB_USB_DTV5100=m
+CONFIG_DVB_USB_AF9015=m
+CONFIG_DVB_USB_CE6230=m
+CONFIG_DVB_USB_FRIIO=m
+CONFIG_DVB_USB_EC168=m
+CONFIG_DVB_USB_AZ6007=m
+CONFIG_DVB_USB_AZ6027=m
+CONFIG_DVB_USB_LME2510=m
+CONFIG_DVB_USB_TECHNISAT_USB2=m
+CONFIG_DVB_USB_IT913X=m
+CONFIG_DVB_USB_MXL111SF=m
+CONFIG_DVB_USB_RTL28XXU=m
+CONFIG_SMS_SIANO_MDTV=m
+CONFIG_SMS_USB_DRV=m
+CONFIG_SMS_SDIO_DRV=m
+CONFIG_DVB_B2C2_FLEXCOP=m
+CONFIG_DVB_B2C2_FLEXCOP_USB=m
+CONFIG_DRM=m
+CONFIG_DRM_I2C_CH7006=m
+CONFIG_DRM_I2C_SIL164=m
+CONFIG_DRM_MALI=m
+CONFIG_DRM_UDL=m
+CONFIG_MALI=m
+CONFIG_MALI400_DEBUG=y
+CONFIG_MALI400_GPU_UTILIZATION=y
+CONFIG_FB=y
+CONFIG_FB_SUNXI=y
+CONFIG_FB_SUNXI_LCD=y
+CONFIG_FB_SUNXI_HDMI=y
+CONFIG_HDMI_CEC=m
+CONFIG_FB_SMSCUFX=m
+CONFIG_FB_UDL=m
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_ARM is not set
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_UA101=m
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_USB_CAIAQ_INPUT=y
+CONFIG_SND_USB_6FIRE=m
+CONFIG_SND_SOC=y
+CONFIG_SOUND_SUN4I=y
+CONFIG_SND_SUN4I_SOC_CODEC=y
+CONFIG_SND_SUN4I_SOC_HDMIAUDIO=y
+CONFIG_SND_SUN4I_SOC_SPDIF=m
+CONFIG_HID_PID=y
+CONFIG_HID_ACRUX=m
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_PRODIKEYS=m
+CONFIG_HID_DRAGONRISE=m
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=m
+CONFIG_HID_HOLTEK=m
+CONFIG_HOLTEK_FF=y
+CONFIG_HID_KEYTOUCH=m
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=m
+CONFIG_HID_WALTOP=m
+CONFIG_HID_GYRATION=m
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_LCPOWER=m
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_HID_MULTITOUCH=m
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_PICOLCD=m
+CONFIG_HID_PRIMAX=m
+CONFIG_HID_ROCCAT=m
+CONFIG_HID_SAITEK=m
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_HID_SPEEDLINK=m
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_GREENASIA=m
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=m
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=m
+CONFIG_HID_WIIMOTE=m
+CONFIG_HID_ZEROPLUS=m
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=m
+CONFIG_USB=y
+CONFIG_USB_MON=y
+CONFIG_USB_WUSB_CBAF=m
+CONFIG_USB_WUSB_CBAF_DEBUG=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_PRINTER=m
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_REALTEK=m
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
+CONFIG_USB_STORAGE_ENE_UB6250=m
+CONFIG_USB_MDC800=m
+CONFIG_USB_USS720=m
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_F81232=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_METRO=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7715_PARPORT=y
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_SERIAL_QCAUX=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SIEMENS_MPI=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+CONFIG_USB_SERIAL_VIVOPAY_SERIAL=m
+CONFIG_USB_SERIAL_SSU100=m
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SISUSBVGA=m
+CONFIG_USB_SISUSBVGA_CON=y
+CONFIG_USB_LD=m
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_USB_ISIGHTFW=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_AUDIO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_EEM=y
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FUNCTIONFS=m
+CONFIG_USB_FUNCTIONFS_ETH=y
+CONFIG_USB_FUNCTIONFS_RNDIS=y
+CONFIG_USB_FUNCTIONFS_GENERIC=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_MIDI_GADGET=m
+CONFIG_USB_G_PRINTER=m
+CONFIG_USB_CDC_COMPOSITE=m
+CONFIG_USB_G_ACM_MS=m
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_CDC=y
+CONFIG_USB_G_HID=m
+CONFIG_USB_G_DBGP=m
+CONFIG_USB_G_WEBCAM=m
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+CONFIG_SDIO_UART=m
+CONFIG_MMC_USHC=m
+CONFIG_MMC_SUNXI_POWER_CONTROL=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=m
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SUN4I=y
+CONFIG_AUXDISPLAY=y
+CONFIG_STAGING=y
+CONFIG_USBIP_CORE=m
+CONFIG_USBIP_VHCI_HCD=m
+CONFIG_USBIP_HOST=m
+CONFIG_W35UND=m
+CONFIG_PRISM2_USB=m
+CONFIG_ECHO=m
+CONFIG_PANEL=m
+CONFIG_RTLLIB=m
+CONFIG_R8712U=m
+CONFIG_RTS5139=m
+CONFIG_LINE6_USB=m
+CONFIG_USB_SERIAL_QUATECH2=m
+CONFIG_USB_SERIAL_QUATECH_USB2=m
+CONFIG_IIO=m
+CONFIG_FB_SM7XX=m
+CONFIG_USB_ENESTORAGE=m
+CONFIG_BCM_WIMAX=m
+CONFIG_SPEAKUP=m
+CONFIG_SPEAKUP_SYNTH_SOFT=m
+CONFIG_TOUCHSCREEN_CLEARPAD_TM1217=m
+CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4=m
+CONFIG_STAGING_MEDIA=y
+CONFIG_DVB_AS102=m
+CONFIG_EASYCAP=m
+CONFIG_LIRC_STAGING=y
+CONFIG_LIRC_IGORPLUGUSB=m
+CONFIG_LIRC_IMON=m
+CONFIG_LIRC_SASEM=m
+CONFIG_LIRC_TTUSBIR=m
+CONFIG_LIRC_ZILOG=m
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_USB_WPAN_HCD=m
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_QFMT_V2=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_HFSPLUS_FS=y
+CONFIG_JFFS2_FS=m
+CONFIG_UBIFS_FS=m
+CONFIG_SQUASHFS=m
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_CIFS=y
+CONFIG_CIFS_UPCALL=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+CONFIG_CIFS_DFS_UPCALL=y
+CONFIG_CIFS_ACL=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=7
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SHIRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LIST=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_RCU_CPU_STALL_INFO=y
+CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_USER=m
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_CRYPTD=m
+CONFIG_CRYPTO_CCM=m
+CONFIG_CRYPTO_GCM=m
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_XTS=m
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_VMAC=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_ZLIB=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_LIBCRC32C=y
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 7b787d6..22b0f1e 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_ARM_CPU_SUSPEND)	+= sleep.o suspend.o
 obj-$(CONFIG_SMP)		+= smp.o smp_tlb.o
 obj-$(CONFIG_HAVE_ARM_SCU)	+= smp_scu.o
 obj-$(CONFIG_HAVE_ARM_TWD)	+= smp_twd.o
+obj-$(CONFIG_ARM_ARCH_TIMER)	+= arch_timer.o
 obj-$(CONFIG_DYNAMIC_FTRACE)	+= ftrace.o insn.o
 obj-$(CONFIG_FUNCTION_GRAPH_TRACER)	+= ftrace.o insn.o
 obj-$(CONFIG_JUMP_LABEL)	+= jump_label.o insn.o patch.o
diff --git a/arch/arm/mach-sun4i/Makefile b/arch/arm/mach-sun4i/Makefile
new file mode 100644
index 0000000..7e7c6e3
--- /dev/null
+++ b/arch/arm/mach-sun4i/Makefile
@@ -0,0 +1 @@
+obj-y += clock/
diff --git a/arch/arm/mach-sun4i/Makefile.boot b/arch/arm/mach-sun4i/Makefile.boot
new file mode 100644
index 0000000..b98036e
--- /dev/null
+++ b/arch/arm/mach-sun4i/Makefile.boot
@@ -0,0 +1,3 @@
+
+zreladdr-$(CONFIG_ARCH_SUN4I)	+= 0x40008000
+
diff --git a/arch/arm/mach-sun4i/clock/Makefile b/arch/arm/mach-sun4i/clock/Makefile
new file mode 100644
index 0000000..f72519b
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/Makefile
@@ -0,0 +1,2 @@
+obj-y += ccmu/
+obj-y += clock.o
diff --git a/arch/arm/mach-sun4i/clock/ccmu/Makefile b/arch/arm/mach-sun4i/clock/ccmu/Makefile
new file mode 100644
index 0000000..ca34f89
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/ccmu/Makefile
@@ -0,0 +1,5 @@
+obj-y += ccm_mod_clk.o \
+         ccm_sys_clk.o \
+         ccm.o \
+         pll_cfg_tbl.o \
+         ccu_dbg.o \
diff --git a/arch/arm/mach-sun4i/clock/ccmu/ccm.c b/arch/arm/mach-sun4i/clock/ccmu/ccm.c
new file mode 100644
index 0000000..4de09ef
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/ccmu/ccm.c
@@ -0,0 +1,88 @@
+/*
+ * arch/arm/mach-sun4i/clock/ccmu/ccm.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <mach/platform.h>
+#include <mach/clock.h>
+#include "ccm_i.h"
+
+
+
+__ccmu_reg_list_t   *aw_ccu_reg;
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_init
+*
+*Description: initialise clock mangement unit;
+*
+*Arguments  : none
+*
+*Return     : result,
+*               AW_CCMU_OK,     initialise ccu successed;
+*               AW_CCMU_FAIL,   initialise ccu failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 aw_ccu_init(void)
+{
+    /* initialise the CCU io base */
+    aw_ccu_reg = (__ccmu_reg_list_t *)SW_VA_CCM_IO_BASE;
+
+    /* config the CCU to default status */
+    if (SUNXI_VER_A10C == sw_get_ic_ver()) {
+        /* switch PLL4 to PLL6 */
+        #if(USE_PLL6M_REPLACE_PLL4)
+        aw_ccu_reg->Pll4Ctl.PllSwitch = 1;
+        #else
+        aw_ccu_reg->Pll4Ctl.PllSwitch = 0;
+        #endif
+    }
+
+    return AW_CCU_ERR_NONE;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_exit
+*
+*Description: exit clock managment unit;
+*
+*Arguments  : none
+*
+*Return     : result,
+*               AW_CCMU_OK,     exit ccu successed;
+*               AW_CCMU_FAIL,   exit ccu failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 aw_ccu_exit(void)
+{
+    return AW_CCU_ERR_NONE;
+}
+
diff --git a/arch/arm/mach-sun4i/clock/ccmu/ccm_i.h b/arch/arm/mach-sun4i/clock/ccmu/ccm_i.h
new file mode 100644
index 0000000..0fcf581
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/ccmu/ccm_i.h
@@ -0,0 +1,56 @@
+/*
+ * arch/arm/mach-sun4i/clock/ccmu/ccm_i.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __AW_CCMU_I_H__
+#define __AW_CCMU_I_H__
+
+#include <linux/kernel.h>
+#include <mach/ccmu_regs.h>
+#include <mach/system.h>
+#include <asm/io.h>
+
+extern __ccmu_reg_list_t   *aw_ccu_reg;
+
+
+#undef CCU_DBG
+#undef CCU_ERR
+#if (1)
+    #define CCU_DBG(format,args...)   printk("[ccmu] "format,##args)
+    #define CCU_ERR(format,args...)   printk("[ccmu] "format,##args)
+#else
+    #define CCU_DBG(...)
+    #define CCU_ERR(...)
+#endif
+
+
+struct core_pll_factor_t {
+    __u8    FactorN;
+    __u8    FactorK;
+    __u8    FactorM;
+    __u8    FactorP;
+};
+
+extern int ccm_clk_get_pll_para(struct core_pll_factor_t *factor, __u64 rate);
+
+#endif /* #ifndef __AW_CCMU_I_H__ */
+
diff --git a/arch/arm/mach-sun4i/clock/ccmu/ccm_mod_clk.c b/arch/arm/mach-sun4i/clock/ccmu/ccm_mod_clk.c
new file mode 100644
index 0000000..a7cd6bf
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/ccmu/ccm_mod_clk.c
@@ -0,0 +1,2562 @@
+/*
+ * arch/arm/mach-sun4i/clock/ccmu/ccm_mod_clk.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include "ccm_i.h"
+
+#define make_mod_clk_inf(clk_id, clk_name)  {.id = clk_id, .name = clk_name, }
+
+static __aw_ccu_clk_t aw_ccu_mod_clk[] =
+{
+    make_mod_clk_inf(AW_MOD_CLK_NONE        , "mclk_none"   ),
+    make_mod_clk_inf(AW_MOD_CLK_NFC         , "nfc"         ),
+    make_mod_clk_inf(AW_MOD_CLK_MSC         , "msc"         ),
+    make_mod_clk_inf(AW_MOD_CLK_SDC0        , "sdc0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_SDC1        , "sdc1"        ),
+    make_mod_clk_inf(AW_MOD_CLK_SDC2        , "sdc2"        ),
+    make_mod_clk_inf(AW_MOD_CLK_SDC3        , "sdc3"        ),
+    make_mod_clk_inf(AW_MOD_CLK_TS          , "ts"          ),
+    make_mod_clk_inf(AW_MOD_CLK_SS          , "ss"          ),
+    make_mod_clk_inf(AW_MOD_CLK_SPI0        , "spi0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_SPI1        , "spi1"        ),
+    make_mod_clk_inf(AW_MOD_CLK_SPI2        , "spi2"        ),
+    make_mod_clk_inf(AW_MOD_CLK_PATA        , "pata"        ),
+    make_mod_clk_inf(AW_MOD_CLK_IR0         , "ir0"         ),
+    make_mod_clk_inf(AW_MOD_CLK_IR1         , "ir1"         ),
+    make_mod_clk_inf(AW_MOD_CLK_I2S         , "i2s"         ),
+    make_mod_clk_inf(AW_MOD_CLK_AC97        , "ac97"        ),
+    make_mod_clk_inf(AW_MOD_CLK_SPDIF       , "spdif"       ),
+    make_mod_clk_inf(AW_MOD_CLK_KEYPAD      , "key_pad"     ),
+    make_mod_clk_inf(AW_MOD_CLK_SATA        , "sata"        ),
+    make_mod_clk_inf(AW_MOD_CLK_USBPHY      , "usb_phy"     ),
+    make_mod_clk_inf(AW_MOD_CLK_USBPHY0     , "usb_phy0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_USBPHY1     , "usb_phy1"    ),
+    make_mod_clk_inf(AW_MOD_CLK_USBPHY2     , "usb_phy2"    ),
+    make_mod_clk_inf(AW_MOD_CLK_USBOHCI0    , "usb_ohci0"   ),
+    make_mod_clk_inf(AW_MOD_CLK_USBOHCI1    , "usb_ohci1"   ),
+    make_mod_clk_inf(AW_MOD_CLK_GPS         , "com"         ),
+    make_mod_clk_inf(AW_MOD_CLK_SPI3        , "spi3"        ),
+    make_mod_clk_inf(AW_MOD_CLK_DEBE0       , "de_image0"   ),
+    make_mod_clk_inf(AW_MOD_CLK_DEBE1       , "de_image1"   ),
+    make_mod_clk_inf(AW_MOD_CLK_DEFE0       , "de_scale0"   ),
+    make_mod_clk_inf(AW_MOD_CLK_DEFE1       , "de_scale1"   ),
+    make_mod_clk_inf(AW_MOD_CLK_DEMIX       , "de_mix"      ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD0CH0     , "lcd0_ch0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD1CH0     , "lcd1_ch0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_CSIISP      , "csi_isp"     ),
+    make_mod_clk_inf(AW_MOD_CLK_TVD         , "tvd"         ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD0CH1_S1  , "lcd0_ch1_s1" ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD0CH1_S2  , "lcd0_ch1_s2" ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD1CH1_S1  , "lcd1_ch1_s1" ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD1CH1_S2  , "lcd1_ch1_s2" ),
+    make_mod_clk_inf(AW_MOD_CLK_CSI0        , "csi0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_CSI1        , "csi1"        ),
+    make_mod_clk_inf(AW_MOD_CLK_VE          , "ve"          ),
+    make_mod_clk_inf(AW_MOD_CLK_ADDA        , "audio_codec" ),
+    make_mod_clk_inf(AW_MOD_CLK_AVS         , "avs"         ),
+    make_mod_clk_inf(AW_MOD_CLK_ACE         , "ace"         ),
+    make_mod_clk_inf(AW_MOD_CLK_LVDS        , "lvds"        ),
+    make_mod_clk_inf(AW_MOD_CLK_HDMI        , "hdmi"        ),
+    make_mod_clk_inf(AW_MOD_CLK_MALI        , "mali"        ),
+    make_mod_clk_inf(AW_MOD_CLK_TWI0        , "twi0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_TWI1        , "twi1"        ),
+    make_mod_clk_inf(AW_MOD_CLK_TWI2        , "twi2"        ),
+    make_mod_clk_inf(AW_MOD_CLK_CAN         , "can"         ),
+    make_mod_clk_inf(AW_MOD_CLK_SCR         , "scr"         ),
+    make_mod_clk_inf(AW_MOD_CLK_PS20        , "ps0"         ),
+    make_mod_clk_inf(AW_MOD_CLK_PS21        , "ps1"         ),
+    make_mod_clk_inf(AW_MOD_CLK_UART0       , "uart0"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART1       , "uart1"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART2       , "uart2"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART3       , "uart3"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART4       , "uart4"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART5       , "uart5"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART6       , "uart6"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART7       , "uart7"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AXI_DRAM    , "axi_dram"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_USB0    , "ahb_usb0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_EHCI0   , "ahb_ehci0"   ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_OHCI0   , "ahb_ohci0"   ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SS      , "ahb_ss"      ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DMA     , "ahb_dma"     ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_BIST    , "ahb_bist"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDMMC0  , "ahb_sdc0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDMMC1  , "ahb_sdc1"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDMMC2  , "ahb_sdc2"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDMMC3  , "ahb_sdc3"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_MS      , "ahb_msc"     ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_NAND    , "ahb_nfc"     ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDRAM   , "ahb_sdramc"  ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_ACE     , "ahb_ace"     ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_EMAC    , "ahb_emac"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_TS      , "ahb_ts"      ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SPI0    , "ahb_spi0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SPI1    , "ahb_spi1"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SPI2    , "ahb_spi2"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SPI3    , "ahb_spi3"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_PATA    , "ahb_pata"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SATA    , "ahb_sata"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_GPS     , "ahb_com"     ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_VE      , "ahb_ve"      ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_TVD     , "ahb_tvd"     ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_TVE0    , "ahb_tve0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_TVE1    , "ahb_tve1"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_LCD0    , "ahb_lcd0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_LCD1    , "ahb_lcd1"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_CSI0    , "ahb_csi0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_CSI1    , "ahb_csi1"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_HDMI    , "ahb_hdmi"    ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DEBE0   , "ahb_de_image0"),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DEBE1   , "ahb_de_image1"),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DEFE0   , "ahb_de_scale0"),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DEFE1   , "ahb_de_scale1"),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_MP      , "ahb_de_mix"  ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_MALI    , "ahb_mali"    ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_ADDA    , "apb_audio_codec"),
+    make_mod_clk_inf(AW_MOD_CLK_APB_SPDIF   , "apb_spdif"   ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_AC97    , "apb_ac97"    ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_I2S     , "apb_i2s"     ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_PIO     , "apb_pio"     ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_IR0     , "apb_ir0"     ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_IR1     , "apb_ir1"     ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_KEYPAD  , "apb_key_pad" ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_TWI0    , "apb_twi0"    ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_TWI1    , "apb_twi1"    ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_TWI2    , "apb_twi2"    ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_CAN     , "apb_can"     ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_SCR     , "apb_scr"     ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_PS20    , "apb_ps0"     ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_PS21    , "apb_ps1"     ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART0   , "apb_uart0"   ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART1   , "apb_uart1"   ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART2   , "apb_uart2"   ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART3   , "apb_uart3"   ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART4   , "apb_uart4"   ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART5   , "apb_uart5"   ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART6   , "apb_uart6"   ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART7   , "apb_uart7"   ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_VE    , "sdram_ve"    ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_CSI0  , "sdram_csi0"  ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_CSI1  , "sdram_csi1"  ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_TS    , "sdram_ts"    ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_TVD   , "sdram_tvd"   ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_TVE0  , "sdram_tve0"  ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_TVE1  , "sdram_tve1"  ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEFE0 , "sdram_de_scale0"),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEFE1 , "sdram_de_scale1"),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEBE0 , "sdram_de_image0"),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEBE1 , "sdram_de_image1"),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEMP  , "sdram_de_mix"),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_ACE   , "sdram_ace"   ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_EHCI1   , "ahb_ehci1"   ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_OHCI1   , "ahb_ohci1"   ),
+
+};
+
+
+static __aw_ccu_sys_clk_e mod_clk_get_parent(__aw_ccu_mod_clk_e id);
+static __aw_ccu_clk_onff_e mod_clk_get_status(__aw_ccu_mod_clk_e id);
+static __s64 mod_clk_get_rate(__aw_ccu_mod_clk_e id);
+static __aw_ccu_clk_reset_e mod_clk_get_reset(__aw_ccu_mod_clk_e id);
+
+static __s32 mod_clk_set_parent(__aw_ccu_mod_clk_e id, __aw_ccu_sys_clk_e parent);
+static __s32 mod_clk_set_status(__aw_ccu_mod_clk_e id, __aw_ccu_clk_onff_e status);
+static __s32 mod_clk_set_rate(__aw_ccu_mod_clk_e id, __s64 rate);
+static __s32 mod_clk_set_reset(__aw_ccu_mod_clk_e id, __aw_ccu_clk_reset_e reset);
+
+
+static inline __aw_ccu_sys_clk_e _parse_module0_clk_src(volatile __ccmu_module0_clk_t *reg)
+{
+    switch(reg->ClkSrc)
+    {
+        case 0:
+            return AW_SYS_CLK_HOSC;
+        case 1:
+            return AW_SYS_CLK_PLL62;
+        case 2:
+            return AW_SYS_CLK_PLL5P;
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+    return AW_SYS_CLK_NONE;
+}
+
+
+static inline __aw_ccu_sys_clk_e _parse_defemp_clk_src(volatile __ccmu_fedemp_clk_t *reg)
+{
+    switch(reg->ClkSrc)
+    {
+        case 0:
+            return AW_SYS_CLK_PLL3;
+        case 1:
+            return AW_SYS_CLK_PLL7;
+        case 2:
+            return AW_SYS_CLK_PLL5P;
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+    return AW_SYS_CLK_NONE;
+}
+
+
+static inline __s32 _set_module0_clk_src(volatile __ccmu_module0_clk_t *reg, __aw_ccu_sys_clk_e parent)
+{
+    switch(parent)
+    {
+        case AW_SYS_CLK_HOSC:
+            reg->ClkSrc = 0;
+            break;
+        case AW_SYS_CLK_PLL62:
+            reg->ClkSrc = 1;
+            break;
+        case AW_SYS_CLK_PLL5P:
+            reg->ClkSrc = 2;
+            break;
+        default:
+            return -1;
+    }
+
+    return 0;
+}
+
+
+static inline __s32 _set_defemp_clk_src(volatile __ccmu_fedemp_clk_t *reg, __aw_ccu_sys_clk_e parent)
+{
+    switch(parent)
+    {
+        case AW_SYS_CLK_PLL3:
+            reg->ClkSrc = 0;
+            break;
+        case AW_SYS_CLK_PLL7:
+            reg->ClkSrc = 1;
+            break;
+        case AW_SYS_CLK_PLL5P:
+            reg->ClkSrc = 2;
+            break;
+        default:
+            return -1;
+    }
+
+    return 0;
+}
+
+
+static inline __aw_ccu_clk_onff_e _get_module0_clk_status(volatile __ccmu_module0_clk_t *reg)
+{
+    return reg->SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+}
+
+
+static inline __s32 _set_module0_clk_status(volatile __ccmu_module0_clk_t *reg, __aw_ccu_clk_onff_e status)
+{
+    reg->SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+    return 0;
+}
+
+
+static inline __aw_ccu_clk_onff_e _get_defemp_clk_status(volatile __ccmu_fedemp_clk_t *reg)
+{
+    return reg->SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+}
+
+
+static inline __s32 _set_defemp_clk_status(volatile __ccmu_fedemp_clk_t *reg, __aw_ccu_clk_onff_e status)
+{
+    reg->SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+    return 0;
+}
+
+
+static inline __u32 _get_module0_clk_rate(volatile __ccmu_module0_clk_t *reg)
+{
+    return (1<<reg->ClkPreDiv) * (reg->ClkDiv+1);
+}
+
+
+static inline __s32 _set_module0_clk_rate(volatile __ccmu_module0_clk_t *reg, __u64 rate)
+{
+    if(rate > 16*8)
+    {
+        return -1;
+    }
+    else if(rate > 16*4)
+    {
+        reg->ClkPreDiv = 3;
+        reg->ClkDiv    = (rate>>3)-1;
+    }
+    else if(rate > 16*2)
+    {
+        reg->ClkPreDiv = 2;
+        reg->ClkDiv    = (rate>>2)-1;
+    }
+    else if(rate > 16*1)
+    {
+       reg->ClkPreDiv = 1;
+        reg->ClkDiv    = (rate>>1)-1;
+    }
+    else if(rate > 0)
+    {
+        reg->ClkPreDiv = 0;
+        reg->ClkDiv    = rate-1;
+    }
+    else
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+static __aw_ccu_sys_clk_e mod_clk_get_parent(__aw_ccu_mod_clk_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _parse_module0_clk_src(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _parse_module0_clk_src(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_SDC3:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc3Clk);
+        case AW_MOD_CLK_TS:
+            return _parse_module0_clk_src(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _parse_module0_clk_src(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi2Clk);
+        case AW_MOD_CLK_PATA:
+            return _parse_module0_clk_src(&aw_ccu_reg->PataClk);
+        case AW_MOD_CLK_IR0:
+            return _parse_module0_clk_src(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_IR1:
+            return _parse_module0_clk_src(&aw_ccu_reg->Ir1Clk);
+        case AW_MOD_CLK_I2S:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_AC97:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_SPDIF:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_KEYPAD:
+        {
+            switch(aw_ccu_reg->KeyPadClk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 2:
+                    return AW_SYS_CLK_LOSC;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_SATA:
+        {
+            switch(aw_ccu_reg->SataClk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL6M;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            break;
+        }
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+            return AW_SYS_CLK_PLL62;
+        case AW_MOD_CLK_GPS:
+            return AW_SYS_CLK_AHB;
+        case AW_MOD_CLK_SPI3:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi3Clk);
+        case AW_MOD_CLK_DEBE0:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeBe0Clk);
+        case AW_MOD_CLK_DEBE1:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeBe1Clk);
+        case AW_MOD_CLK_DEFE0:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeFe0Clk);
+        case AW_MOD_CLK_DEFE1:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeFe1Clk);
+        case AW_MOD_CLK_DEMIX:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeMpClk);
+        case AW_MOD_CLK_LCD0CH0:
+        {
+            switch(aw_ccu_reg->Lcd0Ch0Clk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_LCD1CH0:
+        {
+            switch(aw_ccu_reg->Lcd1Ch0Clk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_CSIISP:
+        {
+            switch(aw_ccu_reg->CsiIspClk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL4;
+                case 2:
+                    return AW_SYS_CLK_PLL5P;
+                default:
+                    return AW_SYS_CLK_PLL62;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_TVD:
+            return aw_ccu_reg->TvdClk.ClkSrc? AW_SYS_CLK_PLL7 : AW_SYS_CLK_PLL3;
+        case AW_MOD_CLK_LCD0CH1_S1:
+        case AW_MOD_CLK_LCD0CH1_S2:
+        {
+            switch(aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_LCD1CH1_S1:
+        case AW_MOD_CLK_LCD1CH1_S2:
+        {
+            switch(aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_CSI0:
+        {
+            switch(aw_ccu_reg->Csi0Clk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL3;
+                case 2:
+                    return AW_SYS_CLK_PLL7;
+                case 5:
+                    return AW_SYS_CLK_PLL3X2;
+                case 6:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_CSI1:
+        {
+            switch(aw_ccu_reg->Csi1Clk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL3;
+                case 2:
+                    return AW_SYS_CLK_PLL7;
+                case 5:
+                    return AW_SYS_CLK_PLL3X2;
+                case 6:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_VE:
+            return AW_SYS_CLK_PLL4;
+        case AW_MOD_CLK_ADDA:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_AVS:
+            return AW_SYS_CLK_HOSC;
+        case AW_MOD_CLK_ACE:
+            return aw_ccu_reg->AceClk.ClkSrc? AW_SYS_CLK_PLL5P : AW_SYS_CLK_PLL4;
+        case AW_MOD_CLK_LVDS:
+            return AW_SYS_CLK_NONE;
+        case AW_MOD_CLK_HDMI:
+        {
+            switch(aw_ccu_reg->HdmiClk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_MALI:
+        {
+            switch(aw_ccu_reg->MaliClk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL4;
+                case 2:
+                    return AW_SYS_CLK_PLL5P;
+                default:
+                    return AW_SYS_CLK_PLL7;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_CAN:
+        case AW_MOD_CLK_SCR:
+        case AW_MOD_CLK_PS20:
+        case AW_MOD_CLK_PS21:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+        case AW_MOD_CLK_UART6:
+        case AW_MOD_CLK_UART7:
+            return AW_SYS_CLK_APB1;
+
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_status
+*
+*Description: get module clock on/off status;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : result;
+*               AW_CCU_CLK_OFF, module clock is off;
+*               AW_CCU_CLK_ON,  module clock is on;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_onff_e mod_clk_get_status(__aw_ccu_mod_clk_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _get_module0_clk_status(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _get_module0_clk_status(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_SDC3:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc3Clk);
+        case AW_MOD_CLK_TS:
+            return _get_module0_clk_status(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _get_module0_clk_status(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi2Clk);
+        case AW_MOD_CLK_PATA:
+            return _get_module0_clk_status(&aw_ccu_reg->PataClk);
+        case AW_MOD_CLK_IR0:
+            return _get_module0_clk_status(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_IR1:
+            return _get_module0_clk_status(&aw_ccu_reg->Ir1Clk);
+        case AW_MOD_CLK_I2S:
+            return aw_ccu_reg->I2sClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AC97:
+            return aw_ccu_reg->Ac97Clk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SPDIF:
+            return aw_ccu_reg->SpdifClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_KEYPAD:
+            return aw_ccu_reg->KeyPadClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SATA:
+            return aw_ccu_reg->SataClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY:
+            if (SUNXI_VER_A10C == sw_get_ic_ver())
+                aw_ccu_reg->UsbClk.ClkSwich = 1;
+            return aw_ccu_reg->UsbClk.PhySpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY0:
+            return aw_ccu_reg->UsbClk.UsbPhy0Rst? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY1:
+            return aw_ccu_reg->UsbClk.UsbPhy1Rst? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY2:
+            return aw_ccu_reg->UsbClk.UsbPhy2Rst? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBOHCI0:
+            return aw_ccu_reg->UsbClk.OHCI0SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBOHCI1:
+            return aw_ccu_reg->UsbClk.OHCI0SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_GPS:
+            return aw_ccu_reg->GpsClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SPI3:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi3Clk);
+        case AW_MOD_CLK_DEBE0:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeBe0Clk);
+        case AW_MOD_CLK_DEBE1:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeBe1Clk);
+        case AW_MOD_CLK_DEFE0:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeFe0Clk);
+        case AW_MOD_CLK_DEFE1:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeFe1Clk);
+        case AW_MOD_CLK_DEMIX:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeMpClk);
+        case AW_MOD_CLK_LCD0CH0:
+            return aw_ccu_reg->Lcd0Ch0Clk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD1CH0:
+            return aw_ccu_reg->Lcd1Ch0Clk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSIISP:
+            return aw_ccu_reg->CsiIspClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_TVD:
+            return aw_ccu_reg->TvdClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD0CH1_S2:
+            return aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD1CH1_S1:
+            return aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD1CH1_S2:
+            return aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSI1:
+            return aw_ccu_reg->Csi1Clk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_VE:
+            return aw_ccu_reg->VeClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_ADDA:
+            return aw_ccu_reg->AddaClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AVS:
+            return aw_ccu_reg->AvsClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_ACE:
+            return aw_ccu_reg->AceClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LVDS:
+            return AW_CCU_CLK_ON;
+        case AW_MOD_CLK_HDMI:
+            return aw_ccu_reg->HdmiClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_MALI:
+            return aw_ccu_reg->MaliClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_CAN:
+        case AW_MOD_CLK_SCR:
+        case AW_MOD_CLK_PS20:
+        case AW_MOD_CLK_PS21:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+        case AW_MOD_CLK_UART6:
+        case AW_MOD_CLK_UART7:
+            return AW_CCU_CLK_ON;
+
+        case AW_MOD_CLK_AXI_DRAM:
+            return aw_ccu_reg->AxiGate.SdramGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_USB0:
+            return aw_ccu_reg->AhbGate0.Usb0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_EHCI0:
+            return aw_ccu_reg->AhbGate0.Ehci0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_OHCI0:
+            return aw_ccu_reg->AhbGate0.Ohci0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_EHCI1:
+            return aw_ccu_reg->AhbGate0.Ehci1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_OHCI1:
+            return aw_ccu_reg->AhbGate0.Ohci1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SS:
+            return aw_ccu_reg->AhbGate0.SsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_DMA:
+            return aw_ccu_reg->AhbGate0.DmaGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_BIST:
+            return aw_ccu_reg->AhbGate0.BistGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDMMC0:
+            return aw_ccu_reg->AhbGate0.Sdmmc0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDMMC1:
+            return aw_ccu_reg->AhbGate0.Sdmmc1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDMMC2:
+            return aw_ccu_reg->AhbGate0.Sdmmc2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDMMC3:
+            return aw_ccu_reg->AhbGate0.Sdmmc3Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_MS:
+            return aw_ccu_reg->AhbGate0.MsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_NAND:
+            return aw_ccu_reg->AhbGate0.NandGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDRAM:
+            return aw_ccu_reg->AhbGate0.SdramGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_ACE:
+            return aw_ccu_reg->AhbGate0.AceGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_EMAC:
+            return aw_ccu_reg->AhbGate0.EmacGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_TS:
+            return aw_ccu_reg->AhbGate0.TsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SPI0:
+            return aw_ccu_reg->AhbGate0.Spi0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SPI1:
+            return aw_ccu_reg->AhbGate0.Spi1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SPI2:
+            return aw_ccu_reg->AhbGate0.Spi2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SPI3:
+            return aw_ccu_reg->AhbGate0.Spi3Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_PATA:
+            return aw_ccu_reg->AhbGate0.PataGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SATA:
+            return aw_ccu_reg->AhbGate0.SataGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_GPS:
+            return aw_ccu_reg->AhbGate0.GpsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_VE:
+            return aw_ccu_reg->AhbGate1.VeGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_TVD:
+            return aw_ccu_reg->AhbGate1.TvdGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_TVE0:
+            return aw_ccu_reg->AhbGate1.Tve0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_TVE1:
+            return aw_ccu_reg->AhbGate1.Tve1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_LCD0:
+            return aw_ccu_reg->AhbGate1.Lcd0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_LCD1:
+            return aw_ccu_reg->AhbGate1.Lcd1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_CSI0:
+            return aw_ccu_reg->AhbGate1.Csi0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_CSI1:
+            return aw_ccu_reg->AhbGate1.Csi1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_HDMI:
+            return aw_ccu_reg->AhbGate1.HdmiDGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_DEBE0:
+            return aw_ccu_reg->AhbGate1.DeBe0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_DEBE1:
+            return aw_ccu_reg->AhbGate1.DeBe1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_DEFE0:
+            return aw_ccu_reg->AhbGate1.DeFe0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_DEFE1:
+            return aw_ccu_reg->AhbGate1.DeFe1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_MP:
+            return aw_ccu_reg->AhbGate1.MpGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_MALI:
+            return aw_ccu_reg->AhbGate1.Gpu3DGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_ADDA:
+            return aw_ccu_reg->Apb0Gate.AddaGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_SPDIF:
+            return aw_ccu_reg->Apb0Gate.SpdifGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_AC97:
+            return aw_ccu_reg->Apb0Gate.Ac97Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_I2S:
+            return aw_ccu_reg->Apb0Gate.IisGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_PIO:
+            return aw_ccu_reg->Apb0Gate.PioGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_IR0:
+            return aw_ccu_reg->Apb0Gate.Ir0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_IR1:
+            return aw_ccu_reg->Apb0Gate.Ir1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_KEYPAD:
+            return aw_ccu_reg->Apb0Gate.KeypadGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_TWI0:
+            return aw_ccu_reg->Apb1Gate.Twi0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_TWI1:
+            return aw_ccu_reg->Apb1Gate.Twi1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_TWI2:
+            return aw_ccu_reg->Apb1Gate.Twi2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_CAN:
+            return aw_ccu_reg->Apb1Gate.CanGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_SCR:
+            return aw_ccu_reg->Apb1Gate.ScrGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_PS20:
+            return aw_ccu_reg->Apb1Gate.Ps20Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_PS21:
+            return aw_ccu_reg->Apb1Gate.Ps21Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART0:
+            return aw_ccu_reg->Apb1Gate.Uart0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART1:
+            return aw_ccu_reg->Apb1Gate.Uart1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART2:
+            return aw_ccu_reg->Apb1Gate.Uart2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART3:
+            return aw_ccu_reg->Apb1Gate.Uart3Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART4:
+            return aw_ccu_reg->Apb1Gate.Uart4Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART5:
+            return aw_ccu_reg->Apb1Gate.Uart5Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART6:
+            return aw_ccu_reg->Apb1Gate.Uart6Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART7:
+            return aw_ccu_reg->Apb1Gate.Uart7Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_VE:
+            return aw_ccu_reg->DramGate.VeGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_CSI0:
+            return aw_ccu_reg->DramGate.Csi0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_CSI1:
+            return aw_ccu_reg->DramGate.Csi1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_TS:
+            return aw_ccu_reg->DramGate.TsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_TVD:
+            return aw_ccu_reg->DramGate.TvdGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_TVE0:
+            return aw_ccu_reg->DramGate.Tve0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_TVE1:
+            return aw_ccu_reg->DramGate.Tve1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_DEFE0:
+            return aw_ccu_reg->DramGate.DeFe0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_DEFE1:
+            return aw_ccu_reg->DramGate.DeFe1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_DEBE0:
+            return aw_ccu_reg->DramGate.DeBe0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_DEBE1:
+            return aw_ccu_reg->DramGate.DeBe1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_DEMP:
+            return aw_ccu_reg->DramGate.DeMpGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_ACE:
+            return aw_ccu_reg->DramGate.AceGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        default:
+            return AW_CCU_CLK_ON;
+    }
+    return AW_CCU_CLK_ON;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_rate
+*
+*Description: get module clock rate;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : module clock division;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s64 mod_clk_get_rate(__aw_ccu_mod_clk_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _get_module0_clk_rate(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _get_module0_clk_rate(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_SDC3:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc3Clk);
+        case AW_MOD_CLK_TS:
+            return _get_module0_clk_rate(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _get_module0_clk_rate(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi2Clk);
+        case AW_MOD_CLK_PATA:
+            return _get_module0_clk_rate(&aw_ccu_reg->PataClk);
+        case AW_MOD_CLK_IR0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_IR1:
+            return _get_module0_clk_rate(&aw_ccu_reg->Ir1Clk);
+        case AW_MOD_CLK_I2S:
+            return (1 << aw_ccu_reg->I2sClk.ClkDiv);
+        case AW_MOD_CLK_AC97:
+            return (1 << aw_ccu_reg->Ac97Clk.ClkDiv);
+        case AW_MOD_CLK_SPDIF:
+            return (1 << aw_ccu_reg->SpdifClk.ClkDiv);
+        case AW_MOD_CLK_KEYPAD:
+            return (1 << aw_ccu_reg->KeyPadClk.ClkPreDiv) * (aw_ccu_reg->KeyPadClk.ClkDiv + 1);
+        case AW_MOD_CLK_SATA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+        case AW_MOD_CLK_GPS:
+            return 1;
+        case AW_MOD_CLK_SPI3:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi3Clk);
+        case AW_MOD_CLK_DEBE0:
+            return aw_ccu_reg->DeBe0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEBE1:
+            return aw_ccu_reg->DeBe1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEFE0:
+            return aw_ccu_reg->DeFe0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEFE1:
+            return aw_ccu_reg->DeFe1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEMIX:
+            return aw_ccu_reg->DeMpClk.ClkDiv + 1;
+        case AW_MOD_CLK_LCD0CH0:
+        case AW_MOD_CLK_LCD1CH0:
+            return 1;
+        case AW_MOD_CLK_CSIISP:
+            return aw_ccu_reg->CsiIspClk.ClkDiv + 1;
+        case AW_MOD_CLK_TVD:
+            return 1;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return (aw_ccu_reg->Lcd0Ch1Clk.ClkDiv + 1) * (aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src + 1);
+        case AW_MOD_CLK_LCD0CH1_S2:
+            return aw_ccu_reg->Lcd0Ch1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_LCD1CH1_S1:
+            return (aw_ccu_reg->Lcd1Ch1Clk.ClkDiv + 1) * (aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Src + 1);
+        case AW_MOD_CLK_LCD1CH1_S2:
+            return aw_ccu_reg->Lcd1Ch1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_CSI1:
+            return aw_ccu_reg->Csi1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_VE:
+            return (aw_ccu_reg->VeClk.ClkDiv + 1);
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_AVS:
+            return 1;
+        case AW_MOD_CLK_ACE:
+            return (aw_ccu_reg->AceClk.ClkDiv + 1);
+        case AW_MOD_CLK_LVDS:
+            return 1;
+        case AW_MOD_CLK_HDMI:
+            return (aw_ccu_reg->HdmiClk.ClkDiv + 1);
+        case AW_MOD_CLK_MALI:
+            return (aw_ccu_reg->MaliClk.ClkDiv + 1);
+        default:
+            return 1;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_reset
+*
+*Description: get module clock reset status;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : result,
+*               AW_CCU_CLK_RESET,   module clock reset valid;
+*               AW_CCU_CLK_NRESET,  module clock reset invalid;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_reset_e mod_clk_get_reset(__aw_ccu_mod_clk_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+        case AW_MOD_CLK_MSC:
+        case AW_MOD_CLK_SDC0:
+        case AW_MOD_CLK_SDC1:
+        case AW_MOD_CLK_SDC2:
+        case AW_MOD_CLK_SDC3:
+        case AW_MOD_CLK_TS:
+        case AW_MOD_CLK_SS:
+        case AW_MOD_CLK_SPI0:
+        case AW_MOD_CLK_SPI1:
+        case AW_MOD_CLK_SPI2:
+        case AW_MOD_CLK_PATA:
+        case AW_MOD_CLK_IR0:
+        case AW_MOD_CLK_IR1:
+        case AW_MOD_CLK_I2S:
+        case AW_MOD_CLK_AC97:
+        case AW_MOD_CLK_SPDIF:
+        case AW_MOD_CLK_KEYPAD:
+        case AW_MOD_CLK_SATA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+            return AW_CCU_CLK_NRESET;
+
+        case AW_MOD_CLK_USBOHCI0:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_USBOHCI1:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_GPS:
+            return aw_ccu_reg->GpsClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_SPI3:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_DEBE0:
+            return aw_ccu_reg->DeBe0Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEBE1:
+            return aw_ccu_reg->DeBe1Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEFE0:
+            return aw_ccu_reg->DeFe0Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEFE1:
+            return aw_ccu_reg->DeFe1Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEMIX:
+            return aw_ccu_reg->DeMpClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_LCD0CH0:
+            return aw_ccu_reg->Lcd0Ch0Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_LCD1CH0:
+            return aw_ccu_reg->Lcd1Ch0Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_CSIISP:
+        case AW_MOD_CLK_TVD:
+        case AW_MOD_CLK_LCD0CH1_S1:
+        case AW_MOD_CLK_LCD0CH1_S2:
+        case AW_MOD_CLK_LCD1CH1_S1:
+        case AW_MOD_CLK_LCD1CH1_S2:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_CSI1:
+            return aw_ccu_reg->Csi1Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_VE:
+            return aw_ccu_reg->VeClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_AVS:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_ACE:
+            return aw_ccu_reg->AceClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_LVDS:
+            return aw_ccu_reg->LvdsClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_HDMI:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_MALI:
+            return aw_ccu_reg->MaliClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        default:
+            return AW_CCU_CLK_NRESET;
+    }
+
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_parent
+*
+*Description: set clock parent id for module clock;
+*
+*Arguments  : id        module clock id;
+*             parent    parent clock id;
+*
+*Return     : result;
+*               0,  set parent successed;
+*              !0,  set parent failed;
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_parent(__aw_ccu_mod_clk_e id, __aw_ccu_sys_clk_e parent)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_src(&aw_ccu_reg->NandClk, parent);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_src(&aw_ccu_reg->MsClk, parent);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc0Clk, parent);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc1Clk, parent);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc2Clk, parent);
+        case AW_MOD_CLK_SDC3:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc3Clk, parent);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_src(&aw_ccu_reg->TsClk, parent);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_src(&aw_ccu_reg->SsClk, parent);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi0Clk, parent);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi1Clk, parent);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi2Clk, parent);
+        case AW_MOD_CLK_PATA:
+            return _set_module0_clk_src(&aw_ccu_reg->PataClk, parent);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_src(&aw_ccu_reg->Ir0Clk, parent);
+        case AW_MOD_CLK_IR1:
+            return _set_module0_clk_src(&aw_ccu_reg->Ir1Clk, parent);
+        case AW_MOD_CLK_I2S:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+        case AW_MOD_CLK_AC97:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+        case AW_MOD_CLK_SPDIF:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+        case AW_MOD_CLK_KEYPAD:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->KeyPadClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->KeyPadClk.ClkSrc = 2;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_SATA:
+        {
+            if(parent == AW_SYS_CLK_PLL6M)
+            {
+                aw_ccu_reg->SataClk.ClkSrc = 0;
+                return 0;
+            }
+
+            return -1;
+        }
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+        {
+            if(parent == AW_SYS_CLK_PLL62)
+            {
+                aw_ccu_reg->UsbClk.OHCIClkSrc = 0;
+                return 0;
+            }
+
+            return -1;
+        }
+        case AW_MOD_CLK_SPI3:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi3Clk, parent);
+        case AW_MOD_CLK_DEBE0:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeBe0Clk, parent);
+        case AW_MOD_CLK_DEBE1:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeBe1Clk, parent);
+        case AW_MOD_CLK_DEFE0:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeFe0Clk, parent);
+        case AW_MOD_CLK_DEFE1:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeFe1Clk, parent);
+        case AW_MOD_CLK_DEMIX:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeMpClk, parent);
+        case AW_MOD_CLK_LCD0CH0:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_LCD1CH0:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd1Ch0Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd1Ch0Clk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd1Ch0Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd1Ch0Clk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_CSIISP:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->CsiIspClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL4:
+                    aw_ccu_reg->CsiIspClk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL5:
+                    aw_ccu_reg->CsiIspClk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL62:
+                    aw_ccu_reg->CsiIspClk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_TVD:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->TvdClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->TvdClk.ClkSrc = 1;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S2:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_LCD1CH1_S1:
+            return 0;
+        case AW_MOD_CLK_LCD1CH1_S2:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_CSI0:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 2;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_CSI1:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 5;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 6;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_VE:
+            return (parent == AW_SYS_CLK_PLL4)? 0 : -1;
+        case AW_MOD_CLK_ADDA:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+        case AW_MOD_CLK_AVS:
+            return (parent == AW_SYS_CLK_HOSC)? 0 : -1;
+        case AW_MOD_CLK_ACE:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL4:
+                    aw_ccu_reg->AceClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL5P:
+                    aw_ccu_reg->AceClk.ClkSrc = 1;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_HDMI:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 0;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL3X2:
+                {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 2;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL7:
+                {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 1;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL7X2:
+                {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 3;
+                    return 0;
+                }
+                default:
+                    return -1;
+            }
+        }
+        case AW_MOD_CLK_MALI:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->MaliClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL4:
+                    aw_ccu_reg->MaliClk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL5P:
+                    aw_ccu_reg->MaliClk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->MaliClk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_GPS:
+        {
+            return (parent == AW_SYS_CLK_AHB)? 0 : -1;
+        }
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_CAN:
+        case AW_MOD_CLK_SCR:
+        case AW_MOD_CLK_PS20:
+        case AW_MOD_CLK_PS21:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+        case AW_MOD_CLK_UART6:
+        case AW_MOD_CLK_UART7:
+            return (parent == AW_SYS_CLK_APB1)? 0 : -1;
+
+        case AW_MOD_CLK_LVDS:
+        default:
+            return (parent == AW_SYS_CLK_NONE)? 0 : -1;
+    }
+    return (parent == AW_SYS_CLK_NONE)? 0 : -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_status
+*
+*Description: set module clock on/off status;
+*
+*Arguments  : id        module clock id;
+*             status    module clock on/off status;
+*
+*Return     : result
+*               0,  set module clock on/off status successed;
+*              !0,  set module clock on/off status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_status(__aw_ccu_mod_clk_e id, __aw_ccu_clk_onff_e status)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_status(&aw_ccu_reg->NandClk, status);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_status(&aw_ccu_reg->MsClk, status);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc0Clk, status);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc1Clk, status);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc2Clk, status);
+        case AW_MOD_CLK_SDC3:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc3Clk, status);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_status(&aw_ccu_reg->TsClk, status);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_status(&aw_ccu_reg->SsClk, status);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi0Clk, status);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi1Clk, status);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi2Clk, status);
+        case AW_MOD_CLK_PATA:
+            return _set_module0_clk_status(&aw_ccu_reg->PataClk, status);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_status(&aw_ccu_reg->Ir0Clk, status);
+        case AW_MOD_CLK_IR1:
+            return _set_module0_clk_status(&aw_ccu_reg->Ir1Clk, status);
+        case AW_MOD_CLK_I2S:
+            aw_ccu_reg->I2sClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AC97:
+            aw_ccu_reg->Ac97Clk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SPDIF:
+            aw_ccu_reg->SpdifClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_KEYPAD:
+        {
+            aw_ccu_reg->KeyPadClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_SATA:
+        {
+            aw_ccu_reg->SataClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            aw_ccu_reg->Pll6Ctl.OutputEn = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY:
+        {
+            if (SUNXI_VER_A10C == sw_get_ic_ver())
+                aw_ccu_reg->UsbClk.ClkSwich = 1;
+            aw_ccu_reg->UsbClk.PhySpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY0:
+        {
+            aw_ccu_reg->UsbClk.UsbPhy0Rst = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY1:
+        {
+            aw_ccu_reg->UsbClk.UsbPhy1Rst = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY2:
+        {
+            aw_ccu_reg->UsbClk.UsbPhy2Rst = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+
+        case AW_MOD_CLK_USBOHCI0:
+            aw_ccu_reg->UsbClk.OHCI0SpecClkGate = ((status == AW_CCU_CLK_OFF)? 0 : 1);
+            return 0;
+        case AW_MOD_CLK_USBOHCI1:
+            aw_ccu_reg->UsbClk.OHCI1SpecClkGate = ((status == AW_CCU_CLK_OFF)? 0 : 1);
+            return 0;
+        case AW_MOD_CLK_GPS:
+        {
+            aw_ccu_reg->GpsClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_SPI3:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi3Clk, status);
+        case AW_MOD_CLK_DEBE0:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeBe0Clk, status);
+        case AW_MOD_CLK_DEBE1:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeBe1Clk, status);
+        case AW_MOD_CLK_DEFE0:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeFe0Clk, status);
+        case AW_MOD_CLK_DEFE1:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeFe1Clk, status);
+        case AW_MOD_CLK_DEMIX:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeMpClk, status);
+        case AW_MOD_CLK_LCD0CH0:
+            aw_ccu_reg->Lcd0Ch0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LCD1CH0:
+            aw_ccu_reg->Lcd1Ch0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_CSIISP:
+            aw_ccu_reg->CsiIspClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_TVD:
+            aw_ccu_reg->TvdClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Gate = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S2:
+            aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Gate = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_LCD1CH1_S1:
+            aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Gate = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_LCD1CH1_S2:
+            aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Gate = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_CSI0:
+            aw_ccu_reg->Csi0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_CSI1:
+            aw_ccu_reg->Csi1Clk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_VE:
+            aw_ccu_reg->VeClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_ADDA:
+            aw_ccu_reg->AddaClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AVS:
+            aw_ccu_reg->AvsClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_ACE:
+            aw_ccu_reg->AceClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LVDS:
+            return 0;
+        case AW_MOD_CLK_HDMI:
+            aw_ccu_reg->HdmiClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_MALI:
+            aw_ccu_reg->MaliClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_CAN:
+        case AW_MOD_CLK_SCR:
+        case AW_MOD_CLK_PS20:
+        case AW_MOD_CLK_PS21:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+        case AW_MOD_CLK_UART6:
+        case AW_MOD_CLK_UART7:
+            return 0;
+
+        case AW_MOD_CLK_AXI_DRAM:
+            aw_ccu_reg->AxiGate.SdramGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_USB0:
+            aw_ccu_reg->AhbGate0.Usb0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_EHCI0:
+            aw_ccu_reg->AhbGate0.Ehci0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_OHCI0:
+            aw_ccu_reg->AhbGate0.Ohci0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_EHCI1:
+            aw_ccu_reg->AhbGate0.Ehci1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_OHCI1:
+            aw_ccu_reg->AhbGate0.Ohci1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SS:
+            aw_ccu_reg->AhbGate0.SsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_AHB_DMA:
+            aw_ccu_reg->AhbGate0.DmaGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_BIST:
+            aw_ccu_reg->AhbGate0.BistGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDMMC0:
+            aw_ccu_reg->AhbGate0.Sdmmc0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDMMC1:
+            aw_ccu_reg->AhbGate0.Sdmmc1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDMMC2:
+            aw_ccu_reg->AhbGate0.Sdmmc2Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDMMC3:
+            aw_ccu_reg->AhbGate0.Sdmmc3Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_MS:
+            aw_ccu_reg->AhbGate0.MsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_NAND:
+            aw_ccu_reg->AhbGate0.NandGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDRAM:
+            aw_ccu_reg->AhbGate0.SdramGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_ACE:
+            aw_ccu_reg->AhbGate0.AceGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_EMAC:
+            aw_ccu_reg->AhbGate0.EmacGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_TS:
+            aw_ccu_reg->AhbGate0.TsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SPI0:
+            aw_ccu_reg->AhbGate0.Spi0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SPI1:
+            aw_ccu_reg->AhbGate0.Spi1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SPI2:
+            aw_ccu_reg->AhbGate0.Spi2Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SPI3:
+            aw_ccu_reg->AhbGate0.Spi3Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_PATA:
+            aw_ccu_reg->AhbGate0.PataGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SATA:
+            aw_ccu_reg->AhbGate0.SataGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_GPS:
+            aw_ccu_reg->AhbGate0.GpsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_VE:
+            aw_ccu_reg->AhbGate1.VeGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_TVD:
+            aw_ccu_reg->AhbGate1.TvdGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_TVE0:
+            aw_ccu_reg->AhbGate1.Tve0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_TVE1:
+            aw_ccu_reg->AhbGate1.Tve1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_LCD0:
+            aw_ccu_reg->AhbGate1.Lcd0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_LCD1:
+            aw_ccu_reg->AhbGate1.Lcd1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_CSI0:
+            aw_ccu_reg->AhbGate1.Csi0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_CSI1:
+            aw_ccu_reg->AhbGate1.Csi1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_HDMI:
+            aw_ccu_reg->AhbGate1.HdmiDGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_DEBE0:
+            aw_ccu_reg->AhbGate1.DeBe0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_DEBE1:
+            aw_ccu_reg->AhbGate1.DeBe1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_DEFE0:
+            aw_ccu_reg->AhbGate1.DeFe0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_DEFE1:
+            aw_ccu_reg->AhbGate1.DeFe1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_MP:
+            aw_ccu_reg->AhbGate1.MpGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_MALI:
+            aw_ccu_reg->AhbGate1.Gpu3DGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_APB_ADDA:
+            aw_ccu_reg->Apb0Gate.AddaGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_SPDIF:
+            aw_ccu_reg->Apb0Gate.SpdifGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_AC97:
+            aw_ccu_reg->Apb0Gate.Ac97Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_I2S:
+            aw_ccu_reg->Apb0Gate.IisGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_PIO:
+            aw_ccu_reg->Apb0Gate.PioGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_IR0:
+            aw_ccu_reg->Apb0Gate.Ir0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_IR1:
+            aw_ccu_reg->Apb0Gate.Ir1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_KEYPAD:
+            aw_ccu_reg->Apb0Gate.KeypadGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_TWI0:
+            aw_ccu_reg->Apb1Gate.Twi0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_TWI1:
+            aw_ccu_reg->Apb1Gate.Twi1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_TWI2:
+            aw_ccu_reg->Apb1Gate.Twi2Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_CAN:
+            aw_ccu_reg->Apb1Gate.CanGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_SCR:
+            aw_ccu_reg->Apb1Gate.ScrGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_PS20:
+            aw_ccu_reg->Apb1Gate.Ps20Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_PS21:
+            aw_ccu_reg->Apb1Gate.Ps21Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART0:
+            aw_ccu_reg->Apb1Gate.Uart0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART1:
+            aw_ccu_reg->Apb1Gate.Uart1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART2:
+            aw_ccu_reg->Apb1Gate.Uart2Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART3:
+            aw_ccu_reg->Apb1Gate.Uart3Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART4:
+            aw_ccu_reg->Apb1Gate.Uart4Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART5:
+            aw_ccu_reg->Apb1Gate.Uart5Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART6:
+            aw_ccu_reg->Apb1Gate.Uart6Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART7:
+            aw_ccu_reg->Apb1Gate.Uart7Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_VE:
+            aw_ccu_reg->DramGate.VeGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_CSI0:
+            aw_ccu_reg->DramGate.Csi0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_CSI1:
+            aw_ccu_reg->DramGate.Csi1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_TS:
+            aw_ccu_reg->DramGate.TsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_TVD:
+            aw_ccu_reg->DramGate.TvdGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_TVE0:
+            aw_ccu_reg->DramGate.Tve0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_TVE1:
+            aw_ccu_reg->DramGate.Tve1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_DEFE0:
+            aw_ccu_reg->DramGate.DeFe0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_DEFE1:
+            aw_ccu_reg->DramGate.DeFe1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_DEBE0:
+            aw_ccu_reg->DramGate.DeBe0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_DEBE1:
+            aw_ccu_reg->DramGate.DeBe1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_DEMP:
+            aw_ccu_reg->DramGate.DeMpGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_ACE:
+            aw_ccu_reg->DramGate.AceGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        default:
+            return -1;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_rate
+*
+*Description: set module clock division;
+*
+*Arguments  : id    module clock id;
+*             rate  module clock division;
+*
+*Return     : result
+*               0,  set module clock rate successed;
+*              !0,  set module clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_rate(__aw_ccu_mod_clk_e id, __s64 rate)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_rate(&aw_ccu_reg->NandClk, rate);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_rate(&aw_ccu_reg->MsClk, rate);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc0Clk, rate);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc1Clk, rate);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc2Clk, rate);
+        case AW_MOD_CLK_SDC3:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc3Clk, rate);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_rate(&aw_ccu_reg->TsClk, rate);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_rate(&aw_ccu_reg->SsClk, rate);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi0Clk, rate);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi1Clk, rate);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi2Clk, rate);
+        case AW_MOD_CLK_PATA:
+            return _set_module0_clk_rate(&aw_ccu_reg->PataClk, rate);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_rate(&aw_ccu_reg->Ir0Clk, rate);
+        case AW_MOD_CLK_IR1:
+            return _set_module0_clk_rate(&aw_ccu_reg->Ir1Clk, rate);
+        case AW_MOD_CLK_I2S:
+        {
+            switch(rate)
+            {
+                case 1:
+                    aw_ccu_reg->I2sClk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->I2sClk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->I2sClk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->I2sClk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_AC97:
+        {
+            switch(rate)
+            {
+                case 1:
+                    aw_ccu_reg->Ac97Clk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->Ac97Clk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->Ac97Clk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->Ac97Clk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_SPDIF:
+        {
+            switch(rate)
+            {
+                case 1:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_KEYPAD:
+        {
+            if(rate > 32*8)
+            {
+                return -1;
+            }
+            else if(rate > 32*4)
+            {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 3;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>3)-1;
+            }
+            else if(rate > 32*2)
+            {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 2;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>2)-1;
+            }
+            else if(rate > 32*1)
+            {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 1;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>1)-1;
+            }
+            else if(rate > 32*0)
+            {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 0;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = rate-1;
+            }
+            else
+            {
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_SPI3:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi3Clk, rate);
+        case AW_MOD_CLK_DEBE0:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->DeBe0Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE1:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->DeBe1Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE0:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->DeFe0Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE1:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->DeFe1Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEMIX:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->DeMpClk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSIISP:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->CsiIspClk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH1_S1:
+        {
+            if(rate == (aw_ccu_reg->Lcd0Ch1Clk.ClkDiv+1))
+            {
+                aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src = 0;
+                return 0;
+            }
+            else if(rate == ((aw_ccu_reg->Lcd0Ch1Clk.ClkDiv+1)<<1))
+            {
+                aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src = 1;
+                return 0;
+            }
+
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH1_S2:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->Lcd0Ch1Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD1CH1_S1:
+        {
+            if(rate == (aw_ccu_reg->Lcd1Ch1Clk.ClkDiv+1))
+            {
+                aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Src = 0;
+                return 0;
+            }
+            else if(rate == ((aw_ccu_reg->Lcd1Ch1Clk.ClkDiv+1)<<1))
+            {
+                aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Src = 1;
+                return 0;
+            }
+
+            return 0;
+        }
+        case AW_MOD_CLK_LCD1CH1_S2:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->Lcd1Ch1Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI0:
+        {
+            if((rate < 1) || (rate > 32))
+            {
+                return -1;
+            }
+            aw_ccu_reg->Csi0Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI1:
+        {
+            if((rate < 1) || (rate > 32))
+            {
+                return -1;
+            }
+            aw_ccu_reg->Csi1Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_VE:
+        {
+            if((rate < 1) || (rate > 8))
+            {
+                return -1;
+            }
+            aw_ccu_reg->VeClk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_ACE:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->AceClk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_HDMI:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->HdmiClk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_MALI:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->MaliClk.ClkDiv = rate-1;
+            return 0;
+        }
+
+        case AW_MOD_CLK_LCD0CH0:
+        case AW_MOD_CLK_LCD1CH0:
+        case AW_MOD_CLK_LVDS:
+        case AW_MOD_CLK_TVD:
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_SATA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+        case AW_MOD_CLK_GPS:
+        case AW_MOD_CLK_AVS:
+        default:
+            return (rate == 1)? 0 : -1;
+    }
+    return (rate == 1)? 0 : -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_reset
+*
+*Description: set module clock reset status
+*
+*Arguments  : id    module clock id;
+*             reset module clock reset status;
+*
+*Return     : result;
+*               0,  set module clock reset status successed;
+*              !0,  set module clock reset status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_reset(__aw_ccu_mod_clk_e id, __aw_ccu_clk_reset_e reset)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+        case AW_MOD_CLK_MSC:
+        case AW_MOD_CLK_SDC0:
+        case AW_MOD_CLK_SDC1:
+        case AW_MOD_CLK_SDC2:
+        case AW_MOD_CLK_SDC3:
+        case AW_MOD_CLK_TS:
+        case AW_MOD_CLK_SS:
+        case AW_MOD_CLK_SPI0:
+        case AW_MOD_CLK_SPI1:
+        case AW_MOD_CLK_SPI2:
+        case AW_MOD_CLK_PATA:
+        case AW_MOD_CLK_IR0:
+        case AW_MOD_CLK_IR1:
+        case AW_MOD_CLK_I2S:
+        case AW_MOD_CLK_AC97:
+        case AW_MOD_CLK_SPDIF:
+        case AW_MOD_CLK_KEYPAD:
+        case AW_MOD_CLK_SATA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+            return (reset == AW_CCU_CLK_NRESET)? 0 : -1;
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+            return 0;
+        case AW_MOD_CLK_GPS:
+        {
+            aw_ccu_reg->GpsClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE0:
+        {
+            aw_ccu_reg->DeBe0Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE1:
+        {
+            aw_ccu_reg->DeBe1Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE0:
+        {
+            aw_ccu_reg->DeFe0Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE1:
+        {
+            aw_ccu_reg->DeFe1Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEMIX:
+        {
+            aw_ccu_reg->DeMpClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH0:
+        {
+            aw_ccu_reg->Lcd0Ch0Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD1CH0:
+        {
+            aw_ccu_reg->Lcd1Ch0Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI0:
+        {
+            aw_ccu_reg->Csi0Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI1:
+        {
+            aw_ccu_reg->Csi1Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_VE:
+        {
+            aw_ccu_reg->VeClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_ACE:
+            aw_ccu_reg->AceClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LVDS:
+            aw_ccu_reg->LvdsClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_MALI:
+            aw_ccu_reg->MaliClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_CSIISP:
+        case AW_MOD_CLK_TVD:
+        case AW_MOD_CLK_LCD0CH1_S1:
+        case AW_MOD_CLK_LCD0CH1_S2:
+        case AW_MOD_CLK_LCD1CH1_S1:
+        case AW_MOD_CLK_LCD1CH1_S2:
+        case AW_MOD_CLK_SPI3:
+        case AW_MOD_CLK_AVS:
+        case AW_MOD_CLK_HDMI:
+        default:
+            return (reset == AW_CCU_CLK_NRESET)? 0 : -1;
+    }
+    return (reset == AW_CCU_CLK_NRESET)? 0 : -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get_mod_clk_cnt
+*
+*Description: get the count of the module clock.
+*
+*Arguments  : none
+*
+*Return     : count of the module clock;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 aw_ccu_get_mod_clk_cnt(void)
+{
+    return (__u32)AW_MOD_CLK_CNT;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_rate_hz
+*
+*Description: get module clock rate based on hz;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : module clock division;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s64 mod_clk_get_rate_hz(__aw_ccu_mod_clk_e id)
+{
+    __s64               tmpRate;
+    __aw_ccu_clk_t      *tmpParent;
+
+    tmpRate = mod_clk_get_rate(id);
+    tmpParent = aw_ccu_get_sys_clk(mod_clk_get_parent(id));
+
+    return ccu_clk_uldiv(tmpParent->rate, tmpRate);
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_rate_hz
+*
+*Description: set module clock rate based on hz;
+*
+*Arguments  : id    module clock id;
+*             rate  module clock division;
+*
+*Return     : result
+*               0,  set module clock rate successed;
+*              !0,  set module clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_rate_hz(__aw_ccu_mod_clk_e id, __s64 rate)
+{
+    __aw_ccu_clk_t      *tmpParent;
+
+    tmpParent = aw_ccu_get_sys_clk(mod_clk_get_parent(id));
+    return mod_clk_set_rate(id, ccu_clk_uldiv((tmpParent->rate + (rate>>1)), rate));
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get_mod_clk
+*
+*Description: get module clock information by clock id.
+*
+*Arguments  : id    module clock id;
+*
+*Return     : module clock handle, return NULL if get clock information failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__aw_ccu_clk_t *aw_ccu_get_mod_clk(__aw_ccu_mod_clk_e id)
+{
+    __s32   tmpIdx = (__u32)id;
+
+    /* check if clock id is valid   */
+    if((id < AW_MOD_CLK_NONE) || (id >= AW_MOD_CLK_CNT))
+    {
+        CCU_ERR("ID is invalid when get module clock information!\n");
+        return NULL;
+    }
+
+    /* query module clock information from hardware */
+    aw_ccu_mod_clk[tmpIdx].parent = mod_clk_get_parent(id);
+    aw_ccu_mod_clk[tmpIdx].onoff  = mod_clk_get_status(id);
+    aw_ccu_mod_clk[tmpIdx].rate   = mod_clk_get_rate_hz(id);
+    aw_ccu_mod_clk[tmpIdx].reset  = mod_clk_get_reset(id);
+    aw_ccu_mod_clk[tmpIdx].hash   = ccu_clk_calc_hash(aw_ccu_mod_clk[tmpIdx].name);
+
+    return &aw_ccu_mod_clk[tmpIdx];
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_set_mod_clk
+*
+*Description: set module clock parameters;
+*
+*Arguments  : clk   handle of module clock;
+*
+*Return     : error type.
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__aw_ccu_err_e aw_ccu_set_mod_clk(__aw_ccu_clk_t *clk)
+{
+    __aw_ccu_clk_t  tmpClk;
+
+    if(!clk)
+    {
+        CCU_ERR("Clock handle is NULL when set system clock!\n");
+        return AW_CCU_ERR_PARA_NULL;
+    }
+
+    /* backup old parameter */
+    tmpClk.parent = mod_clk_get_parent(clk->id);
+    tmpClk.onoff  = mod_clk_get_status(clk->id);
+    tmpClk.reset  = mod_clk_get_reset(clk->id);
+    tmpClk.rate   = mod_clk_get_rate_hz(clk->id);
+
+    /* try to set new parameter */
+    if(!mod_clk_set_parent(clk->id, clk->parent))
+    {
+        if(!mod_clk_set_rate_hz(clk->id, clk->rate))
+        {
+            if(!mod_clk_set_status(clk->id, clk->onoff))
+            {
+                if(!mod_clk_set_reset(clk->id, clk->reset))
+                {
+                    /* update managemer parameter  */
+                    aw_ccu_mod_clk[(__u32)clk->id].parent = clk->parent;
+                    aw_ccu_mod_clk[(__u32)clk->id].onoff  = clk->onoff;
+                    aw_ccu_mod_clk[(__u32)clk->id].reset  = clk->reset;
+                    aw_ccu_mod_clk[(__u32)clk->id].rate   = clk->rate;
+
+                    return AW_CCU_ERR_NONE;
+                }
+                else
+                {
+                    CCU_ERR("set %s reset status to %d failed!\n", clk->name, clk->reset);
+                }
+
+                /* resetore on/off status */
+                mod_clk_set_status(clk->id, tmpClk.onoff);
+            }
+            else
+            {
+                CCU_ERR("set %s on/off status to %d failed!\n", clk->name, clk->onoff);
+            }
+
+            /* restore clock rate */
+            mod_clk_set_rate_hz(clk->id, tmpClk.rate);
+        }
+        else
+        {
+            CCU_ERR("set %s clock rate to %lld failed!\n", clk->name, clk->rate);
+        }
+
+        /* restore clock parent */
+        mod_clk_set_parent(clk->id, tmpClk.parent);
+    }
+    else
+    {
+        CCU_ERR("set %s clock parent to (id = %d) failed!\n", clk->name, (__s32)clk->parent);
+    }
+
+    /* update clock manager paremter */
+    aw_ccu_mod_clk[(__u32)clk->id].parent = tmpClk.parent;
+    aw_ccu_mod_clk[(__u32)clk->id].onoff  = tmpClk.onoff;
+    aw_ccu_mod_clk[(__u32)clk->id].reset  = tmpClk.reset;
+    aw_ccu_mod_clk[(__u32)clk->id].rate   = tmpClk.rate;
+
+    return AW_CCU_ERR_PARA_INVALID;
+}
+
diff --git a/arch/arm/mach-sun4i/clock/ccmu/ccm_sys_clk.c b/arch/arm/mach-sun4i/clock/ccmu/ccm_sys_clk.c
new file mode 100644
index 0000000..777ae5a
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/ccmu/ccm_sys_clk.c
@@ -0,0 +1,1299 @@
+/*
+ * arch/arm/mach-sun4i/clock/ccmu/ccm_sys_clk.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include <mach/system.h>
+#include <asm/delay.h>
+#include "ccm_i.h"
+
+
+#define make_sys_clk_inf(clk_id, clk_name)    {.id = clk_id, .name = clk_name,}
+
+
+
+static __aw_ccu_clk_t aw_ccu_sys_clk[] =
+{
+    make_sys_clk_inf(AW_SYS_CLK_NONE,   "sclk_none"     ),
+    make_sys_clk_inf(AW_SYS_CLK_LOSC,   "losc"          ),
+    make_sys_clk_inf(AW_SYS_CLK_HOSC,   "hosc"          ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL1,   "core_pll"      ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL2,   "audio_pll"     ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL2X8, "audio_pllx8"   ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL3,   "video_pll0"    ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL3X2, "video_pll0x2"  ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL4,   "ve_pll"        ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL5,   "sdram_pll"     ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL5M,  "sdram_pll_m"   ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL5P,  "sdram_pll_p"   ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL6,   "sata_pll"      ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL7,   "video_pll1"    ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL7X2, "video_pll1x2"  ),
+    make_sys_clk_inf(AW_SYS_CLK_200M,   "200m_pll"      ),
+    make_sys_clk_inf(AW_SYS_CLK_CPU,    "cpu"           ),
+    make_sys_clk_inf(AW_SYS_CLK_AXI,    "axi"           ),
+    make_sys_clk_inf(AW_SYS_CLK_AHB,    "ahb"           ),
+    make_sys_clk_inf(AW_SYS_CLK_APB0,   "apb"           ),
+    make_sys_clk_inf(AW_SYS_CLK_APB1,   "apb1"          ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL6M,  "sata_pll_m"    ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL62,  "sata_pll_2"    ),
+};
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_parent
+*
+*Description: get parent clock for system clock;
+*
+*Arguments  : id    system clock id;
+*
+*Return     : parent id;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_sys_clk_e sys_clk_get_parent(__aw_ccu_sys_clk_e id)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_PLL2X8:
+        {
+            return AW_SYS_CLK_PLL2;
+        }
+        case AW_SYS_CLK_PLL3X2:
+        {
+            return AW_SYS_CLK_PLL3;
+        }
+        case AW_SYS_CLK_PLL7X2:
+        {
+            return AW_SYS_CLK_PLL7;
+        }
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+        {
+            return AW_SYS_CLK_PLL5;
+        }
+        case AW_SYS_CLK_200M:
+        {
+            return AW_SYS_CLK_PLL62;
+        }
+        case AW_SYS_CLK_CPU:
+        {
+            switch(aw_ccu_reg->SysClkDiv.AC328ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_LOSC;
+                case 1:
+                    return AW_SYS_CLK_HOSC;
+                case 2:
+                    return AW_SYS_CLK_PLL1;
+                case 3:
+                default:
+                    return AW_SYS_CLK_200M;
+            }
+        }
+        case AW_SYS_CLK_AXI:
+        {
+            return AW_SYS_CLK_CPU;
+        }
+        case AW_SYS_CLK_AHB:
+        {
+            return AW_SYS_CLK_AXI;
+        }
+        case AW_SYS_CLK_APB0:
+        {
+            return AW_SYS_CLK_AHB;
+        }
+        case AW_SYS_CLK_APB1:
+        {
+            switch(aw_ccu_reg->Apb1ClkDiv.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL62;
+                case 2:
+                    return AW_SYS_CLK_LOSC;
+                case 3:
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+        }
+        default:
+        {
+            return AW_SYS_CLK_NONE;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_status
+*
+*Description: get system clock on/off status.
+*
+*Arguments  : id    system clock id;
+*
+*Return     : system clock status;
+*               0, clock is off;
+*              !0, clock is on;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_onff_e sys_clk_get_status(__aw_ccu_sys_clk_e id)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return AW_CCU_CLK_ON;
+        case AW_SYS_CLK_HOSC:
+            return aw_ccu_reg->HoscCtl.OSC24MEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_SYS_CLK_PLL1:
+            return aw_ccu_reg->Pll1Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL2:
+        case AW_SYS_CLK_PLL2X8:
+            return aw_ccu_reg->Pll2Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL3X2:
+            return aw_ccu_reg->Pll3Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL4:
+            return aw_ccu_reg->Pll4Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL5:
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+            return aw_ccu_reg->Pll5Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL6:
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62:
+            return aw_ccu_reg->Pll6Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL7X2:
+            return aw_ccu_reg->Pll7Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_200M:
+            return aw_ccu_reg->Pll6Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_SYS_CLK_CPU:
+        case AW_SYS_CLK_AXI:
+        case AW_SYS_CLK_AHB:
+        case AW_SYS_CLK_APB0:
+        case AW_SYS_CLK_APB1:
+        default:
+            return AW_CCU_CLK_ON;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_rate
+*
+*Description: get clock rate for system clock;
+*
+*Arguments  : id    system clock id;
+*
+*Return     : clock rate;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s64 sys_clk_get_rate(__aw_ccu_sys_clk_e id)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_NONE:
+        {
+            return 1;
+        }
+
+        case AW_SYS_CLK_LOSC:
+        {
+            return 32768;
+        }
+        case AW_SYS_CLK_HOSC:
+        {
+            return 24000000;
+        }
+        case AW_SYS_CLK_PLL1:
+        {
+            return ccu_clk_uldiv(((__s64)24000000*aw_ccu_reg->Pll1Ctl.FactorN*(aw_ccu_reg->Pll1Ctl.FactorK + 1)   \
+                >> aw_ccu_reg->Pll1Ctl.PLLDivP), (aw_ccu_reg->Pll1Ctl.FactorM + 1));
+        }
+        case AW_SYS_CLK_PLL2:
+        {
+            enum sw_ic_ver  chip_ver = sw_get_ic_ver();
+
+            if (chip_ver == SUNXI_VER_A10A) {
+                /* chip is version A */
+                if((aw_ccu_reg->Pll2Ctl.VCOBias == 10) &&(aw_ccu_reg->Pll2Ctl.FactorN == 94))
+                {
+                    return 22579200;
+                }
+                else if((aw_ccu_reg->Pll2Ctl.VCOBias == 9) &&(aw_ccu_reg->Pll2Ctl.FactorN == 83))
+                {
+                    return 24576000;
+                }
+                else
+                {
+                    /* set audio pll to default value 24576000 */
+                    aw_ccu_reg->Pll2Ctl.VCOBias = 9;
+                    aw_ccu_reg->Pll2Ctl.FactorN = 83;
+                    return 24576000;
+                }
+            } else if ((chip_ver == SUNXI_VER_A10B) || (chip_ver == SUNXI_VER_A10C)) {
+                /* chip is version B:
+                    FactorN=79, PreDiv=21, PostDiv=4, output=24*79/21/4=22.571mhz, 44.1k series fs
+                    FactorN=86, PreDiv=21, PostDiv=4, output=24*86/21/4=24.571mhz, 48k series fs */
+
+                __u32   tmpReg;
+
+                tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+                if(((tmpReg>>8) & 0x7f) == 79)
+                {
+                    return 22579200;
+                }
+                else if(((tmpReg>>8) & 0x7f) == 86)
+                {
+                    return 24576000;
+                }
+                else
+                {
+                    /* set audio pll to default value 24576000 */
+                    tmpReg &= ~((0x1f<<0)|(0x7f<<8)|(0x0f<<26));
+                    tmpReg |= (21<<0)|(86<<8)|(4<<26);
+                    *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+                    return 24576000;
+                }
+            }
+            else {
+                /* chip version is unknown */
+                return 24576000;
+            }
+        }
+        case AW_SYS_CLK_PLL2X8:
+        {
+            if(sys_clk_get_rate(AW_SYS_CLK_PLL2) == 24576000)
+            {
+                return 24576000 * 18;
+            }
+            else
+            {
+                return 22579200 * 20;
+            }
+        }
+        case AW_SYS_CLK_PLL3:
+        {
+            __s64   tmp_rate;
+
+            if(!aw_ccu_reg->Pll3Ctl.ModeSel)
+            {
+                if(aw_ccu_reg->Pll3Ctl.FracSet)
+                {
+                    return 297000000;
+                }
+                else
+                {
+                    return 270000000;
+                }
+            }
+            else
+            {
+                tmp_rate = 3000000*aw_ccu_reg->Pll3Ctl.FactorM;
+                /* skip 270M and 297M */
+                if(tmp_rate == 270000000)
+                {
+                    return 273000000;
+                }
+                else if(tmp_rate == 297000000)
+                {
+                    return 300000000;
+                }
+
+                return tmp_rate;
+            }
+        }
+        case AW_SYS_CLK_PLL3X2:
+        {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL3) << 1;
+        }
+
+        case AW_SYS_CLK_PLL4:
+        {
+            #if(USE_PLL6M_REPLACE_PLL4)
+            if (SUNXI_VER_A10C == sw_get_ic_ver())
+                return sys_clk_get_rate(AW_SYS_CLK_PLL6);
+            #endif
+
+            return ccu_clk_uldiv(((__s64)24000000*aw_ccu_reg->Pll4Ctl.FactorN * (aw_ccu_reg->Pll4Ctl.FactorK + 1)   \
+                >> aw_ccu_reg->Pll4Ctl.FactorP), (aw_ccu_reg->Pll4Ctl.FactorM + 1));
+        }
+        case AW_SYS_CLK_PLL5:
+        {
+            return (__s64)24000000*aw_ccu_reg->Pll5Ctl.FactorN * (aw_ccu_reg->Pll5Ctl.FactorK + 1);
+        }
+        case AW_SYS_CLK_PLL5M:
+        {
+            return ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_PLL5), (aw_ccu_reg->Pll5Ctl.FactorM + 1));
+        }
+        case AW_SYS_CLK_PLL5P:
+        {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL5) >> aw_ccu_reg->Pll5Ctl.FactorP;
+        }
+        case AW_SYS_CLK_PLL6:
+        {
+            return (__s64)24000000*aw_ccu_reg->Pll6Ctl.FactorN*(aw_ccu_reg->Pll6Ctl.FactorK + 1);
+        }
+        case AW_SYS_CLK_PLL6M:
+        {
+            return ccu_clk_uldiv((__s64)24000000*aw_ccu_reg->Pll6Ctl.FactorN*(aw_ccu_reg->Pll6Ctl.FactorK + 1),   \
+                (aw_ccu_reg->Pll6Ctl.FactorM + 1) * 6);
+        }
+        case AW_SYS_CLK_PLL62:
+        {
+            return (__s64)24000000*aw_ccu_reg->Pll6Ctl.FactorN*(aw_ccu_reg->Pll6Ctl.FactorK + 1)>>1;
+        }
+        case AW_SYS_CLK_PLL7:
+        {
+            if(!aw_ccu_reg->Pll7Ctl.ModeSel)
+            {
+                if(aw_ccu_reg->Pll7Ctl.FracSet)
+                {
+                    return 297000000;
+                }
+                else
+                {
+                    return 270000000;
+                }
+            }
+            else
+            {
+                return (__s64)3000000*aw_ccu_reg->Pll7Ctl.FactorM;
+            }
+        }
+        case AW_SYS_CLK_PLL7X2:
+        {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL7) << 1;
+        }
+        case AW_SYS_CLK_200M:
+        {
+            return 200000000;
+        }
+        case AW_SYS_CLK_CPU:
+        {
+            __u32   tmpCpuRate;
+            switch(aw_ccu_reg->SysClkDiv.AC328ClkSrc)
+            {
+                case 0:
+                    tmpCpuRate = 32768;
+                    break;
+                case 1:
+                    tmpCpuRate = 24000000;
+                    break;
+                case 2:
+                    tmpCpuRate = sys_clk_get_rate(AW_SYS_CLK_PLL1);
+                    break;
+                case 3:
+                default:
+                    tmpCpuRate = 200000000;
+                    break;
+            }
+            return tmpCpuRate;
+        }
+        case AW_SYS_CLK_AXI:
+        {
+            return ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU), (aw_ccu_reg->SysClkDiv.AXIClkDiv + 1));
+        }
+        case AW_SYS_CLK_AHB:
+        {
+            return sys_clk_get_rate(AW_SYS_CLK_AXI) >> aw_ccu_reg->SysClkDiv.AHBClkDiv;
+        }
+        case AW_SYS_CLK_APB0:
+        {
+            __s32   tmpShift = aw_ccu_reg->SysClkDiv.APB0ClkDiv;
+
+            return sys_clk_get_rate(AW_SYS_CLK_AHB) >> (tmpShift? tmpShift : 1);
+        }
+        case AW_SYS_CLK_APB1:
+        {
+            __s64   tmpApb1Rate;
+            switch(aw_ccu_reg->Apb1ClkDiv.ClkSrc)
+            {
+                case 0:
+                    tmpApb1Rate = 24000000;
+                    break;
+                case 1:
+                    tmpApb1Rate = sys_clk_get_rate(AW_SYS_CLK_PLL62);
+                    break;
+                case 2:
+                    tmpApb1Rate = 32768;
+                    break;
+                default:
+                    tmpApb1Rate = 0;
+                    break;
+            }
+            return ccu_clk_uldiv((tmpApb1Rate >> aw_ccu_reg->Apb1ClkDiv.PreDiv), (aw_ccu_reg->Apb1ClkDiv.ClkDiv + 1));
+        }
+        default:
+        {
+            return 0;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_parent
+*
+*Description: set parent clock id for system clock;
+*
+*Arguments  : id        system clock id whose parent need be set;
+*             parent    parent id to be set;
+*
+*Return     : result,
+*               0,  set parent successed;
+*              !0,  set parent failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_parent(__aw_ccu_sys_clk_e id, __aw_ccu_sys_clk_e parent)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_PLL2X8:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+
+        case AW_SYS_CLK_PLL3X2:
+            return (parent == AW_SYS_CLK_PLL3)? 0 : -1;
+
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+            return (parent == AW_SYS_CLK_PLL5)? 0 : -1;
+
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62:
+            return (parent == AW_SYS_CLK_PLL6)? 0 : -1;
+
+        case AW_SYS_CLK_PLL7X2:
+            return (parent == AW_SYS_CLK_PLL7)? 0 : -1;
+
+        case AW_SYS_CLK_200M:
+            return (parent == AW_SYS_CLK_PLL62)? 0 : -1;
+
+        case AW_SYS_CLK_CPU:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->SysClkDiv.AC328ClkSrc = 0;
+                    break;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->SysClkDiv.AC328ClkSrc = 1;
+                    break;
+                case AW_SYS_CLK_PLL1:
+                    aw_ccu_reg->SysClkDiv.AC328ClkSrc = 2;
+                    break;
+                case AW_SYS_CLK_200M:
+                    aw_ccu_reg->SysClkDiv.AC328ClkSrc = 3;
+                    break;
+                default:
+                    return -1;
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_AXI:
+            return (parent == AW_SYS_CLK_CPU)? 0 : -1;
+        case AW_SYS_CLK_AHB:
+            return (parent == AW_SYS_CLK_AXI)? 0 : -1;
+        case AW_SYS_CLK_APB0:
+            return (parent == AW_SYS_CLK_AHB)? 0 : -1;
+        case AW_SYS_CLK_APB1:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 2;
+                    break;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 0;
+                    break;
+                case AW_SYS_CLK_PLL62:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 1;
+                    break;
+                default:
+                    return -1;
+            }
+            return 0;
+        }
+
+        case AW_SYS_CLK_LOSC:
+        case AW_SYS_CLK_HOSC:
+        case AW_SYS_CLK_PLL1:
+        case AW_SYS_CLK_PLL2:
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL4:
+        case AW_SYS_CLK_PLL5:
+        case AW_SYS_CLK_PLL6:
+        case AW_SYS_CLK_PLL7:
+        {
+            return (parent == AW_SYS_CLK_NONE)? 0 : -1;
+        }
+
+        default:
+        {
+            return -1;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_status
+*
+*Description: set on/off status for system clock;
+*
+*Arguments  : id        system clock id;
+*             status    on/off status;
+*                           AW_CCU_CLK_OFF - off
+*                           AW_CCU_CLK_ON - on
+*
+*Return     : result;
+*               0,  set status successed;
+*              !0,  set status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_status(__aw_ccu_sys_clk_e id, __aw_ccu_clk_onff_e status)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return 0;
+        case AW_SYS_CLK_HOSC:
+            aw_ccu_reg->HoscCtl.OSC24MEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL1:
+            aw_ccu_reg->Pll1Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL2:
+            aw_ccu_reg->Pll2Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL2X8:
+        {
+            if(status && !aw_ccu_reg->Pll2Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL3:
+            aw_ccu_reg->Pll3Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL3X2:
+        {
+            if(status && !aw_ccu_reg->Pll3Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL4:
+            aw_ccu_reg->Pll4Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL5:
+            aw_ccu_reg->Pll5Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+        {
+            if(status && !aw_ccu_reg->Pll5Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL6:
+            aw_ccu_reg->Pll6Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62:
+        {
+            if(status && !aw_ccu_reg->Pll6Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL7:
+            aw_ccu_reg->Pll7Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL7X2:
+        {
+            if(status && !aw_ccu_reg->Pll7Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_200M:
+        {
+            if(status && !aw_ccu_reg->Pll6Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_CPU:
+        case AW_SYS_CLK_AXI:
+        case AW_SYS_CLK_AHB:
+        case AW_SYS_CLK_APB0:
+        case AW_SYS_CLK_APB1:
+            return 0;
+
+        default:
+        {
+            return -1;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_rate
+*
+*Description: set clock rate for system clock;
+*
+*Arguments  : id    system clock id;
+*             rate  clock rate for system clock;
+*
+*Return     : result,
+*               0,  set system clock rate successed;
+*              !0,  set system clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_rate(__aw_ccu_sys_clk_e id, __s64 rate)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return (rate == 32768)? 0 : -1;
+
+        case AW_SYS_CLK_HOSC:
+            return (rate == 24000000)? 0 : -1;
+        case AW_SYS_CLK_PLL1:
+        {
+            struct core_pll_factor_t    factor;
+            __ccmu_pll1_core_reg0000_t  tmp_pll;
+
+            /* the setting of pll1 must be called by cpu-freq driver, and adjust pll step by step */
+            ccm_clk_get_pll_para(&factor, rate);
+            /* set factor */
+            tmp_pll = aw_ccu_reg->Pll1Ctl;
+            tmp_pll.FactorN = factor.FactorN;
+            tmp_pll.FactorK = factor.FactorK;
+            tmp_pll.FactorM = factor.FactorM;
+            tmp_pll.PLLDivP = factor.FactorP;
+            aw_ccu_reg->Pll1Ctl = tmp_pll;
+            /* delay 500us for pll be stably */
+            __delay((rate >> 20) * 500 / 2);
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL2:
+        {
+            enum sw_ic_ver  chip_ver = sw_get_ic_ver();
+
+            if(rate == 22579200)
+            {
+                if (chip_ver == SUNXI_VER_A10A) {
+                    /* chip is version A */
+                    aw_ccu_reg->Pll2Ctl.VCOBias = 10;
+                    aw_ccu_reg->Pll2Ctl.FactorN = 94;
+                }
+                else if ((chip_ver == SUNXI_VER_A10B) || (chip_ver == SUNXI_VER_A10C)) {
+                    /* chip is version B, FactorN=79, PreDiv=21, PostDiv=4,
+                       output=24*79/21/4=22.571mhz, 44.1k series fs     */
+                    __u32   tmpReg;
+
+                    tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+                    tmpReg &= ~((0x1f<<0)|(0x7f<<8)|(0x0f<<26));
+                    tmpReg |= (21<<0)|(79<<8)|(4<<26);
+                    *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+                }
+                else{
+                    printk("[ccu] chip version is unknown!\n");
+                    return -1;
+                }
+            }
+            else if(rate == 24576000)
+            {
+                if (chip_ver == SUNXI_VER_A10A) {
+                    /* chip is version A */
+                    aw_ccu_reg->Pll2Ctl.VCOBias = 9;
+                    aw_ccu_reg->Pll2Ctl.FactorN = 83;
+                } else if ((chip_ver == SUNXI_VER_A10B) || (chip_ver == SUNXI_VER_A10C)) {
+                    /* chip is version B, FactorN=86, PreDiv=21, PostDiv=4,
+                       output=24*86/21/4=24.571mhz, 48k series fs       */
+                    __u32   tmpReg;
+
+                    tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+                    tmpReg &= ~((0x1f<<0)|(0x7f<<8)|(0x0f<<26));
+                   tmpReg |= (21<<0)|(86<<8)|(4<<26);
+                    *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+                }
+                else{
+                    printk("[ccu] chip version is unknown!\n");
+                    return -1;
+                }
+            }
+            else
+            {
+                return -1;
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL2X8:
+        {
+            if((sys_clk_get_rate(AW_SYS_CLK_PLL2) == 24576000) && (rate == 24576000 * 18))
+            {
+                return 0;
+            }
+            else if((sys_clk_get_rate(AW_SYS_CLK_PLL2) == 22579200) && (rate == 24576000 * 20))
+
+            {
+                return 0;
+            }
+
+            return -1;
+        }
+        case AW_SYS_CLK_PLL3:
+        {
+            if((rate < 9*3000000) || (rate > (127*3000000)))
+            {
+                CCU_ERR("Rate(%lld) is invalid when set PLL3 rate!\n", rate);
+                return -1;
+            }
+
+            if(rate == 270000000)
+            {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll3Ctl.FracSet = 0;
+            }
+            else if(rate == 297000000)
+            {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll3Ctl.FracSet = 1;
+            }
+            else
+            {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 1;
+                aw_ccu_reg->Pll3Ctl.FactorM = ccu_clk_uldiv(rate + (3000000 - 1), 3000000);
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL3X2:
+        {
+            if(rate == (sys_clk_get_rate(AW_SYS_CLK_PLL3) << 1))
+            {
+                return 0;
+            }
+            return -1;
+        }
+        case AW_SYS_CLK_PLL4:
+        {
+            struct core_pll_factor_t    factor;
+            __u32   tmpDly = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU), 1000000) * 200;
+
+            #if(USE_PLL6M_REPLACE_PLL4)
+            if (SUNXI_VER_A10C == sw_get_ic_ver()) {
+                CCU_ERR("PLL4 clock rate should not be set!\n");
+                return -1;
+            }
+            #endif
+
+            ccm_clk_get_pll_para(&factor, rate);
+
+            /* set the correct parameter for PLL */
+            aw_ccu_reg->Pll4Ctl.FactorN = factor.FactorN;
+            aw_ccu_reg->Pll4Ctl.FactorK = factor.FactorK;
+            aw_ccu_reg->Pll4Ctl.FactorM = factor.FactorM;
+            aw_ccu_reg->Pll4Ctl.FactorP = factor.FactorP;
+            /* delay 200us for pll be stably */
+            __delay(tmpDly);
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5:
+        {
+            __s32   tmpFactorN, tmpFactorK;
+
+            if(rate < 240000000)
+            {
+                CCU_ERR("Rate(%lld) is invalid when set PLL5 rate!\n", rate);
+                return -1;
+            }
+
+            if(rate < 480000000)
+            {
+                tmpFactorK = 0;
+            }
+            else if(rate < 960000000)
+            {
+                tmpFactorK = 1;
+            }
+            else if(rate < 2000000000)
+            {
+                tmpFactorK = 3;
+            }
+            else
+            {
+                CCU_ERR("Rate (%lld) is invaid for PLL5!\n", rate);
+                return -1;
+            }
+
+            tmpFactorN = ccu_clk_uldiv(rate + (((tmpFactorK+1) * 24000000) - 1), ((tmpFactorK+1) * 24000000));
+            if(tmpFactorN > 31)
+            {
+                CCU_ERR("Rate (%lld) is invaid for PLL5!\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Pll5Ctl.FactorN = tmpFactorN;
+            aw_ccu_reg->Pll5Ctl.FactorK = tmpFactorK;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5M:
+        {
+            __u32   tmpFactorM;
+            __s64   tmpPLL5;
+
+            tmpPLL5 = sys_clk_get_rate(AW_SYS_CLK_PLL5);
+            if((rate > tmpPLL5) || (tmpPLL5 > rate*4))
+            {
+                CCU_ERR("PLL5(%lld) rate is invalid for PLL5M(%lld)!\n", tmpPLL5, rate);
+                return -1;
+            }
+
+            tmpFactorM = ccu_clk_uldiv(tmpPLL5 + (rate - 1), rate);
+            aw_ccu_reg->Pll5Ctl.FactorM = tmpFactorM-1;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5P:
+        {
+            __s32   tmpFactorP = -1;
+            __s64   tmpPLL5 = sys_clk_get_rate(AW_SYS_CLK_PLL5);
+
+            if((rate > tmpPLL5) || (tmpPLL5 > rate*8))
+            {
+                CCU_ERR("PLL5(%lld) rate is invalid for PLL5P(%lld)!\n", tmpPLL5, rate);
+                return -1;
+            }
+
+            do{rate <<= 1; tmpFactorP++;}while(rate < tmpPLL5);
+            aw_ccu_reg->Pll5Ctl.FactorP = tmpFactorP;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL6:
+        {
+            __s32   tmpFactorN, tmpFactorK;
+
+            if(rate <= 600000000)
+                tmpFactorK = 0;
+            else if(rate <= 1200000000)
+                tmpFactorK = 1;
+            else
+            {
+                CCU_ERR("Rate (%lld) is invaid for PLL6!\n", rate);
+                return -1;
+            }
+
+            tmpFactorN = ccu_clk_uldiv(rate, ((tmpFactorK+1) * 24000000));
+            if(tmpFactorN > 31)
+            {
+                CCU_ERR("Rate (%lld) is invaid for PLL6!\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Pll6Ctl.FactorN = tmpFactorN;
+            aw_ccu_reg->Pll6Ctl.FactorK = tmpFactorK;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL6M:
+        {
+            __s64   tmpPLL6 = sys_clk_get_rate(AW_SYS_CLK_PLL6);
+            __s32   tmpFactorM = ccu_clk_uldiv(tmpPLL6, rate*6);
+
+            tmpFactorM = tmpFactorM ? tmpFactorM : 1;
+            aw_ccu_reg->Pll6Ctl.FactorM = tmpFactorM - 1;
+            return 0;
+        }
+        case AW_SYS_CLK_PLL62:
+        {
+            /* rate of AW_SYS_CLK_PLL62 is always the half of the rate of AW_SYS_CLK_PLL6 */
+            return 0;
+        }
+        case AW_SYS_CLK_PLL7:
+        {
+            if((rate < 9*3000000) || (rate > (127*3000000)))
+            {
+                CCU_ERR("Rate(%lld) is invalid when set PLL7 rate!\n", rate);
+                return -1;
+            }
+
+            if(rate == 270000000)
+            {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll7Ctl.FracSet = 0;
+            }
+            else if(rate == 297000000)
+            {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll7Ctl.FracSet = 1;
+            }
+            else
+            {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 1;
+                aw_ccu_reg->Pll7Ctl.FactorM = ccu_clk_uldiv(rate + (3000000 - 1), 3000000);
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL7X2:
+        {
+            if(rate == (sys_clk_get_rate(AW_SYS_CLK_PLL7) << 1))
+            {
+                return 0;
+            }
+            return -1;
+        }
+        case AW_SYS_CLK_200M:
+        {
+            if(rate == 200000000)
+            {
+                return 0;
+            }
+            else
+            {
+                return -1;
+            }
+        }
+        case AW_SYS_CLK_CPU:
+        {
+            __s64   tmpRate = sys_clk_get_rate(sys_clk_get_parent(AW_SYS_CLK_CPU));
+
+            if(rate != tmpRate)
+            {
+                CCU_ERR("Rate(%lld) is invalid when set cpu rate(%lld)\n", rate, tmpRate);
+                CCU_ERR("0xf1c20000 = 0x%x\n", *(volatile __u32 *)0xf1c20000);
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_AXI:
+        {
+            __s32   tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU) + (rate - 1), rate);
+            if(tmpDiv > 4)
+            {
+                CCU_ERR("Rate(%lld) is invalid when set axi rate\n", rate);
+                return -1;
+            }
+            tmpDiv = tmpDiv? (tmpDiv-1) : 0;
+            aw_ccu_reg->SysClkDiv.AXIClkDiv = tmpDiv;
+
+            return 0;
+        }
+        case AW_SYS_CLK_AHB:
+        {
+            __s32   tmpVal = -1, tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_AXI) + (rate - 1), rate);
+
+            if(tmpDiv > 8)
+            {
+                CCU_ERR("Rate(%lld) is invalid for set AHB rate!\n", rate);
+                return -1;
+            }
+
+            do{tmpDiv >>= 1; tmpVal++;}while(tmpDiv);
+            aw_ccu_reg->SysClkDiv.AHBClkDiv = tmpVal;
+
+            return 0;
+        }
+        case AW_SYS_CLK_APB0:
+        {
+            __s32   tmpVal = -1, tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_AHB) + (rate - 1), rate);
+
+            if(tmpDiv > 8)
+            {
+                CCU_ERR("Rate(%lld) is invalid for set APB0 rate!\n", rate);
+                return -1;
+            }
+
+            do{tmpDiv >>= 1; tmpVal++;}while(tmpDiv);
+            aw_ccu_reg->SysClkDiv.APB0ClkDiv = tmpVal;
+
+            return 0;
+        }
+        case AW_SYS_CLK_APB1:
+        {
+            __s64   tmpRate = sys_clk_get_rate(sys_clk_get_parent(AW_SYS_CLK_APB1));
+            __s32   tmpDivP, tmpDivM;
+
+            if(tmpRate < rate)
+            {
+                CCU_ERR(" Rate (%lld) is invalid for set APB1 rate, parent is (%lld)!\n", rate, tmpRate);
+                return -1;
+            }
+
+            tmpRate = ccu_clk_uldiv(tmpRate + (rate - 1), rate);
+            if(tmpRate <= 4)
+            {
+                tmpDivP = 0;
+                tmpDivM = tmpRate - 1;
+            }
+            else if(tmpRate <= 8)
+            {
+                tmpDivP = 1;
+                tmpDivM = (tmpRate>>1) - 1;
+            }
+            else if(tmpRate <= 16)
+            {
+                tmpDivP = 2;
+                tmpDivM = (tmpRate>>2) - 1;
+            }
+            else if(tmpRate <= 32)
+            {
+                tmpDivP = 3;
+                tmpDivM = (tmpRate>>3) - 1;
+            }
+            else
+            {
+                CCU_ERR("Rate(%lld) is invalid for set APB1 rate!\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Apb1ClkDiv.PreDiv = tmpDivP;
+            aw_ccu_reg->Apb1ClkDiv.ClkDiv = tmpDivM;
+
+            return 0;
+        }
+        default:
+        {
+            CCU_ERR("clock id(%d) is invaid when set rate!\n", (__s32)id);
+            return -1;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get_sys_clk_cnt
+*
+*Description: get the count of the system clock.
+*
+*Arguments  : none
+*
+*Return     : count of system clock;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 aw_ccu_get_sys_clk_cnt(void)
+{
+    return (__u32)AW_SYS_CLK_CNT;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get_sys_clk
+*
+*Description: get system clock information by clock id.
+*
+*Arguments  : id    system clock id;
+*
+*Return     : system clock handle, return NULL if get clock information failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__aw_ccu_clk_t *aw_ccu_get_sys_clk(__aw_ccu_sys_clk_e id)
+{
+    __s32   tmpIdx = (__u32)id;
+
+    /* check if clock id is valid   */
+    if((id < AW_SYS_CLK_NONE) || (id >= AW_SYS_CLK_CNT))
+    {
+        CCU_ERR("ID is invalid when get system clock information!\n");
+        return NULL;
+    }
+
+    /* query system clock information from hardware */
+    aw_ccu_sys_clk[tmpIdx].parent = sys_clk_get_parent(id);
+    aw_ccu_sys_clk[tmpIdx].onoff  = sys_clk_get_status(id);
+    aw_ccu_sys_clk[tmpIdx].rate   = sys_clk_get_rate(id);
+    aw_ccu_sys_clk[tmpIdx].hash   = ccu_clk_calc_hash(aw_ccu_sys_clk[tmpIdx].name);
+
+    return &aw_ccu_sys_clk[tmpIdx];
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_set_sys_clk
+*
+*Description: set system clock parameters;
+*
+*Arguments  : clk   handle of system clock;
+*
+*Return     : error type.
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__aw_ccu_err_e aw_ccu_set_sys_clk(__aw_ccu_clk_t *clk)
+{
+    __aw_ccu_clk_t  tmpClk;
+
+    if(!clk)
+    {
+        CCU_ERR("Clock handle is NULL when set system clock!\n");
+        return AW_CCU_ERR_PARA_NULL;
+    }
+
+    /* backup old parameter */
+    tmpClk.parent = sys_clk_get_parent(clk->id);
+    tmpClk.rate   = sys_clk_get_rate(clk->id);
+    tmpClk.onoff  = sys_clk_get_status(clk->id);
+
+    /* try to set new parameter */
+    if(tmpClk.parent != clk->parent)
+    {
+        /* update parent */
+        if(sys_clk_set_parent(clk->id, clk->parent))
+        {
+            CCU_ERR("try to set %s parent to %s failed!\n", clk->name, aw_ccu_sys_clk[clk->parent].name);
+            goto _restore_clk_pare;
+        }
+
+        /* update clock parent */
+        clk->parent = sys_clk_get_parent(clk->id);
+        /* update clock rate */
+        clk->rate = sys_clk_get_rate(clk->id);
+        /* update clock status */
+        clk->onoff = sys_clk_get_status(clk->id);
+        return AW_CCU_ERR_NONE;
+    }
+
+    if(tmpClk.rate != clk->rate)
+    {
+        /* update clock rate */
+        if(sys_clk_set_rate(clk->id, clk->rate))
+        {
+            CCU_ERR("try to set %s rate to %lld failed!\n", clk->name, clk->rate);
+            goto _restore_clk_pare;
+        }
+        /* update clock rate */
+        clk->rate = sys_clk_get_rate(clk->id);
+        /* update clock status */
+        clk->onoff = sys_clk_get_status(clk->id);
+        return AW_CCU_ERR_NONE;
+    }
+
+    if(tmpClk.onoff != clk->onoff)
+    {
+        /* update clock rate */
+        if(sys_clk_set_status(clk->id, clk->onoff))
+        {
+            CCU_ERR("try to set %s status to %d failed!\n", clk->name, clk->onoff);
+            goto _restore_clk_pare;
+        }
+        /* update clock status */
+        clk->onoff = sys_clk_get_status(clk->id);
+        return AW_CCU_ERR_NONE;
+    }
+
+    /* nothing is need be updated */
+    return AW_CCU_ERR_NONE;
+
+    _restore_clk_pare:
+
+    /* restore clock parameter  */
+    sys_clk_set_parent(clk->id, tmpClk.parent);
+    sys_clk_set_rate(clk->id, tmpClk.rate);
+    sys_clk_set_status(clk->id, tmpClk.onoff);
+
+    /* update clock manager paremter */
+    clk->parent = tmpClk.parent;
+    clk->onoff  = tmpClk.onoff;
+    clk->rate   = tmpClk.rate;
+
+    return AW_CCU_ERR_PARA_INVALID;
+}
+
diff --git a/arch/arm/mach-sun4i/clock/ccmu/ccu_dbg.c b/arch/arm/mach-sun4i/clock/ccmu/ccu_dbg.c
new file mode 100644
index 0000000..d517b0d
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/ccmu/ccu_dbg.c
@@ -0,0 +1,936 @@
+/*
+ * arch/arm/mach-sun4i/clock/ccmu/ccu_dbg.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include "ccm_i.h"
+
+
+#define print_clk_inf(x, y)     do{printk(#x"."#y":%d\n", aw_ccu_reg->x.y);}while(0)
+
+
+void clk_dbg_inf(void)
+{
+    printk("---------------------------------------------\n");
+    printk("    dump clock information                   \n");
+    printk("---------------------------------------------\n");
+
+    printk("PLL1 infor:\n");
+    print_clk_inf(Pll1Ctl, FactorM      );
+    print_clk_inf(Pll1Ctl, SigmaEn      );
+    print_clk_inf(Pll1Ctl, SigmaIn      );
+    print_clk_inf(Pll1Ctl, FactorK      );
+    print_clk_inf(Pll1Ctl, FactorN      );
+    print_clk_inf(Pll1Ctl, LockTime     );
+    print_clk_inf(Pll1Ctl, PLLDivP      );
+    print_clk_inf(Pll1Ctl, PLLBias      );
+    print_clk_inf(Pll1Ctl, ExchangeEn   );
+    print_clk_inf(Pll1Ctl, VCOBias      );
+    print_clk_inf(Pll1Ctl, VCORstIn     );
+    print_clk_inf(Pll1Ctl, PLLEn        );
+
+    printk("\nPLL2 infor:\n");
+    print_clk_inf(Pll2Ctl, VCOBias      );
+    print_clk_inf(Pll2Ctl, FactorN      );
+    print_clk_inf(Pll2Ctl, PLLBias      );
+    print_clk_inf(Pll2Ctl, SigmaOut     );
+    print_clk_inf(Pll2Ctl, PLLEn        );
+
+    printk("\nPLL3 infor:\n");
+    print_clk_inf(Pll3Ctl, FactorM      );
+    print_clk_inf(Pll3Ctl, PLLBias      );
+    print_clk_inf(Pll3Ctl, FracSet      );
+    print_clk_inf(Pll3Ctl, ModeSel      );
+    print_clk_inf(Pll3Ctl, VCOBias      );
+    print_clk_inf(Pll3Ctl, DampFactor   );
+    print_clk_inf(Pll3Ctl, PLLEn        );
+
+    printk("\nPLL4 infor:\n");
+    print_clk_inf(Pll4Ctl, FactorM      );
+    print_clk_inf(Pll4Ctl, FactorK      );
+    print_clk_inf(Pll4Ctl, FactorN      );
+    print_clk_inf(Pll4Ctl, FactorP      );
+    print_clk_inf(Pll4Ctl, VCOGain      );
+    print_clk_inf(Pll4Ctl, PLLBias      );
+    print_clk_inf(Pll4Ctl, VCOBias      );
+    print_clk_inf(Pll4Ctl, PLLBypass    );
+    print_clk_inf(Pll4Ctl, PLLEn        );
+    if (SUNXI_VER_A10C == sw_get_ic_ver())
+        print_clk_inf(Pll4Ctl, PllSwitch    );
+
+    printk("\nPLL5 infor:\n");
+    print_clk_inf(Pll5Ctl, FactorM      );
+    print_clk_inf(Pll5Ctl, FactorM1     );
+    print_clk_inf(Pll5Ctl, FactorK      );
+    print_clk_inf(Pll5Ctl, LDO2En       );
+    print_clk_inf(Pll5Ctl, FactorN      );
+    print_clk_inf(Pll5Ctl, VCOGain      );
+    print_clk_inf(Pll5Ctl, FactorP      );
+    print_clk_inf(Pll5Ctl, BandWidth    );
+    print_clk_inf(Pll5Ctl, VCOGainEn    );
+    print_clk_inf(Pll5Ctl, PLLBias      );
+    print_clk_inf(Pll5Ctl, VCOBias      );
+    print_clk_inf(Pll5Ctl, OutputEn     );
+    print_clk_inf(Pll5Ctl, PLLBypass    );
+    print_clk_inf(Pll5Ctl, PLLEn        );
+
+    printk("\nPLL6 infor:\n");
+    print_clk_inf(Pll6Ctl, FactorM      );
+    print_clk_inf(Pll6Ctl, FactorK      );
+    print_clk_inf(Pll6Ctl, DampFactor   );
+    print_clk_inf(Pll6Ctl, FactorN      );
+    print_clk_inf(Pll6Ctl, OutputEn     );
+    print_clk_inf(Pll6Ctl, BandWidth    );
+    print_clk_inf(Pll6Ctl, PLLBias      );
+    print_clk_inf(Pll6Ctl, VCOBias      );
+    print_clk_inf(Pll6Ctl, PLLBypass    );
+    print_clk_inf(Pll6Ctl, PLLEn        );
+
+    printk("\nPLL7 infor:\n");
+    print_clk_inf(Pll7Ctl, FactorM      );
+    print_clk_inf(Pll7Ctl, PLLBias      );
+    print_clk_inf(Pll7Ctl, FracSet      );
+    print_clk_inf(Pll7Ctl, ModeSel      );
+    print_clk_inf(Pll7Ctl, VCOBias      );
+    print_clk_inf(Pll7Ctl, DampFactor   );
+    print_clk_inf(Pll7Ctl, PLLEn        );
+
+    printk("\nHOSC infor:\n");
+    print_clk_inf(HoscCtl, OSC24MEn     );
+    print_clk_inf(HoscCtl, OSC24MGsm    );
+    print_clk_inf(HoscCtl, PLLBiasEn    );
+    print_clk_inf(HoscCtl, LDOEn        );
+    print_clk_inf(HoscCtl, PLLInPower   );
+    print_clk_inf(HoscCtl, LDOOutput    );
+    print_clk_inf(HoscCtl, KeyField     );
+
+    printk("\nCPU clk infor:\n");
+    print_clk_inf(SysClkDiv, AXIClkDiv  );
+    print_clk_inf(SysClkDiv, AHBClkDiv  );
+    print_clk_inf(SysClkDiv, APB0ClkDiv );
+    print_clk_inf(SysClkDiv, AC328ClkSrc);
+
+    printk("\nAPB1 clk infor:\n");
+    print_clk_inf(Apb1ClkDiv, ClkDiv    );
+    print_clk_inf(Apb1ClkDiv, PreDiv    );
+    print_clk_inf(Apb1ClkDiv, ClkSrc    );
+
+    printk("\nAxiGate clk infor:\n");
+    print_clk_inf(AxiGate, SdramGate    );
+
+    printk("\nAhbGate0 clk infor:\n");
+    print_clk_inf(AhbGate0, Usb0Gate    );
+    print_clk_inf(AhbGate0, Ehci0Gate   );
+    print_clk_inf(AhbGate0, Ohci0Gate   );
+    print_clk_inf(AhbGate0, Ehci1Gate   );
+    print_clk_inf(AhbGate0, Ohci1Gate   );
+    print_clk_inf(AhbGate0, SsGate      );
+    print_clk_inf(AhbGate0, DmaGate     );
+    print_clk_inf(AhbGate0, BistGate    );
+    print_clk_inf(AhbGate0, Sdmmc0Gate  );
+    print_clk_inf(AhbGate0, Sdmmc1Gate  );
+    print_clk_inf(AhbGate0, Sdmmc2Gate  );
+    print_clk_inf(AhbGate0, Sdmmc3Gate  );
+    print_clk_inf(AhbGate0, MsGate      );
+    print_clk_inf(AhbGate0, NandGate    );
+    print_clk_inf(AhbGate0, SdramGate   );
+    print_clk_inf(AhbGate0, AceGate     );
+    print_clk_inf(AhbGate0, EmacGate    );
+    print_clk_inf(AhbGate0, TsGate      );
+    print_clk_inf(AhbGate0, Spi0Gate    );
+    print_clk_inf(AhbGate0, Spi1Gate    );
+    print_clk_inf(AhbGate0, Spi2Gate    );
+    print_clk_inf(AhbGate0, Spi3Gate    );
+    print_clk_inf(AhbGate0, PataGate    );
+    print_clk_inf(AhbGate0, SataGate    );
+    print_clk_inf(AhbGate0, GpsGate     );
+
+    printk("\nAhbGate1 clk infor:\n");
+    print_clk_inf(AhbGate1, VeGate      );
+    print_clk_inf(AhbGate1, TvdGate     );
+    print_clk_inf(AhbGate1, Tve0Gate    );
+    print_clk_inf(AhbGate1, Tve1Gate    );
+    print_clk_inf(AhbGate1, Lcd0Gate    );
+    print_clk_inf(AhbGate1, Lcd1Gate    );
+    print_clk_inf(AhbGate1, Csi0Gate    );
+    print_clk_inf(AhbGate1, Csi1Gate    );
+    print_clk_inf(AhbGate1, HdmiDGate   );
+    print_clk_inf(AhbGate1, DeBe0Gate   );
+    print_clk_inf(AhbGate1, DeBe1Gate   );
+    print_clk_inf(AhbGate1, DeFe0Gate   );
+    print_clk_inf(AhbGate1, DeFe1Gate   );
+    print_clk_inf(AhbGate1, MpGate      );
+    print_clk_inf(AhbGate1, Gpu3DGate   );
+
+    printk("\nApb0Gate clk infor:\n");
+    print_clk_inf(Apb0Gate, AddaGate    );
+    print_clk_inf(Apb0Gate, SpdifGate   );
+    print_clk_inf(Apb0Gate, Ac97Gate    );
+    print_clk_inf(Apb0Gate, IisGate     );
+    print_clk_inf(Apb0Gate, PioGate     );
+    print_clk_inf(Apb0Gate, Ir0Gate     );
+    print_clk_inf(Apb0Gate, Ir1Gate     );
+    print_clk_inf(Apb0Gate, KeypadGate  );
+
+    printk("\nApb1Gate clk infor:\n");
+    print_clk_inf(Apb1Gate, Twi0Gate    );
+    print_clk_inf(Apb1Gate, Twi1Gate    );
+    print_clk_inf(Apb1Gate, Twi2Gate    );
+    print_clk_inf(Apb1Gate, CanGate     );
+    print_clk_inf(Apb1Gate, ScrGate     );
+    print_clk_inf(Apb1Gate, Ps20Gate    );
+    print_clk_inf(Apb1Gate, Ps21Gate    );
+    print_clk_inf(Apb1Gate, Uart0Gate   );
+    print_clk_inf(Apb1Gate, Uart1Gate   );
+    print_clk_inf(Apb1Gate, Uart2Gate   );
+    print_clk_inf(Apb1Gate, Uart3Gate   );
+    print_clk_inf(Apb1Gate, Uart4Gate   );
+    print_clk_inf(Apb1Gate, Uart5Gate   );
+    print_clk_inf(Apb1Gate, Uart6Gate   );
+    print_clk_inf(Apb1Gate, Uart7Gate   );
+
+    printk("\nNandClk clk infor:\n");
+    print_clk_inf(NandClk, ClkDiv       );
+    print_clk_inf(NandClk, ClkPreDiv    );
+    print_clk_inf(NandClk, ClkSrc       );
+    print_clk_inf(NandClk, SpecClkGate  );
+
+    printk("\nMsClk clk infor:\n");
+    print_clk_inf(MsClk, ClkDiv         );
+    print_clk_inf(MsClk, ClkPreDiv      );
+    print_clk_inf(MsClk, ClkSrc         );
+    print_clk_inf(MsClk, SpecClkGate    );
+
+    printk("\nSdMmc0Clk clk infor:\n");
+    print_clk_inf(SdMmc0Clk, ClkDiv     );
+    print_clk_inf(SdMmc0Clk, ClkPreDiv  );
+    print_clk_inf(SdMmc0Clk, ClkSrc     );
+    print_clk_inf(SdMmc0Clk, SpecClkGate);
+
+    printk("\nSdMmc1Clk clk infor:\n");
+    print_clk_inf(SdMmc1Clk, ClkDiv     );
+    print_clk_inf(SdMmc1Clk, ClkPreDiv  );
+    print_clk_inf(SdMmc1Clk, ClkSrc     );
+    print_clk_inf(SdMmc1Clk, SpecClkGate);
+
+    printk("\nSdMmc2Clk clk infor:\n");
+    print_clk_inf(SdMmc2Clk, ClkDiv     );
+    print_clk_inf(SdMmc2Clk, ClkPreDiv  );
+    print_clk_inf(SdMmc2Clk, ClkSrc     );
+    print_clk_inf(SdMmc2Clk, SpecClkGate);
+
+    printk("\nSdMmc3Clk clk infor:\n");
+    print_clk_inf(SdMmc3Clk, ClkDiv     );
+    print_clk_inf(SdMmc3Clk, ClkPreDiv  );
+    print_clk_inf(SdMmc3Clk, ClkSrc     );
+    print_clk_inf(SdMmc3Clk, SpecClkGate);
+
+    printk("\nTsClk clk infor:\n");
+    print_clk_inf(TsClk, ClkDiv         );
+    print_clk_inf(TsClk, ClkPreDiv      );
+    print_clk_inf(TsClk, ClkSrc         );
+    print_clk_inf(TsClk, SpecClkGate    );
+
+    printk("\nSsClk clk infor:\n");
+    print_clk_inf(SsClk, ClkDiv         );
+    print_clk_inf(SsClk, ClkPreDiv      );
+    print_clk_inf(SsClk, ClkSrc         );
+    print_clk_inf(SsClk, SpecClkGate    );
+
+    printk("\nSpi0Clk clk infor:\n");
+    print_clk_inf(Spi0Clk, ClkDiv       );
+    print_clk_inf(Spi0Clk, ClkPreDiv    );
+    print_clk_inf(Spi0Clk, ClkSrc       );
+    print_clk_inf(Spi0Clk, SpecClkGate  );
+
+    printk("\nSpi1Clk clk infor:\n");
+    print_clk_inf(Spi1Clk, ClkDiv       );
+    print_clk_inf(Spi1Clk, ClkPreDiv    );
+    print_clk_inf(Spi1Clk, ClkSrc       );
+    print_clk_inf(Spi1Clk, SpecClkGate  );
+
+    printk("\nSpi2Clk clk infor:\n");
+    print_clk_inf(Spi2Clk, ClkDiv       );
+    print_clk_inf(Spi2Clk, ClkPreDiv    );
+    print_clk_inf(Spi2Clk, ClkSrc       );
+    print_clk_inf(Spi2Clk, SpecClkGate  );
+
+    printk("\nPataClk clk infor:\n");
+    print_clk_inf(PataClk, ClkDiv       );
+    print_clk_inf(PataClk, ClkPreDiv    );
+    print_clk_inf(PataClk, ClkSrc       );
+    print_clk_inf(PataClk, SpecClkGate  );
+
+    printk("\nIr0Clk clk infor:\n");
+    print_clk_inf(Ir0Clk, ClkDiv        );
+    print_clk_inf(Ir0Clk, ClkPreDiv     );
+    print_clk_inf(Ir0Clk, ClkSrc        );
+    print_clk_inf(Ir0Clk, SpecClkGate   );
+
+    printk("\nIr1Clk clk infor:\n");
+    print_clk_inf(Ir1Clk, ClkDiv        );
+    print_clk_inf(Ir1Clk, ClkPreDiv     );
+    print_clk_inf(Ir1Clk, ClkSrc        );
+    print_clk_inf(Ir1Clk, SpecClkGate   );
+
+    printk("\nI2sClk clk infor:\n");
+    print_clk_inf(I2sClk, ClkDiv        );
+    print_clk_inf(I2sClk, SpecClkGate   );
+
+
+    printk("\nAc97Clk clk infor:\n");
+    print_clk_inf(Ac97Clk, ClkDiv       );
+    print_clk_inf(Ac97Clk, SpecClkGate  );
+
+    printk("\nSpdifClk clk infor:\n");
+    print_clk_inf(SpdifClk, ClkDiv      );
+    print_clk_inf(SpdifClk, SpecClkGate );
+
+    printk("\nKeyPadClk clk infor:\n");
+    print_clk_inf(KeyPadClk, ClkDiv         );
+    print_clk_inf(KeyPadClk, ClkPreDiv      );
+    print_clk_inf(KeyPadClk, ClkSrc         );
+    print_clk_inf(KeyPadClk, SpecClkGate    );
+
+    printk("\nSataClk clk infor:\n");
+    print_clk_inf(SataClk, ClkSrc       );
+    print_clk_inf(SataClk, SpecClkGate  );
+
+    printk("\nUsbClk clk infor:\n");
+    print_clk_inf(UsbClk, UsbPhy0Rst        );
+    print_clk_inf(UsbClk, UsbPhy1Rst        );
+    print_clk_inf(UsbClk, UsbPhy2Rst        );
+    print_clk_inf(UsbClk, OHCIClkSrc        );
+    print_clk_inf(UsbClk, OHCI0SpecClkGate  );
+    print_clk_inf(UsbClk, OHCI1SpecClkGate  );
+    print_clk_inf(UsbClk, PhySpecClkGate    );
+
+    printk("\nGpsClk clk infor:\n");
+    print_clk_inf(GpsClk, Reset         );
+    print_clk_inf(GpsClk, SpecClkGate   );
+
+    printk("\nSpi3Clk clk infor:\n");
+    print_clk_inf(Spi3Clk, ClkDiv       );
+    print_clk_inf(Spi3Clk, ClkPreDiv    );
+    print_clk_inf(Spi3Clk, ClkSrc       );
+    print_clk_inf(Spi3Clk, SpecClkGate  );
+
+    printk("\nDramGate clk infor:\n");
+    print_clk_inf(DramGate, VeGate      );
+    print_clk_inf(DramGate, Csi0Gate    );
+    print_clk_inf(DramGate, Csi1Gate    );
+    print_clk_inf(DramGate, TsGate      );
+    print_clk_inf(DramGate, TvdGate     );
+    print_clk_inf(DramGate, Tve0Gate    );
+    print_clk_inf(DramGate, Tve1Gate    );
+    print_clk_inf(DramGate, ClkOutputEn );
+    print_clk_inf(DramGate, DeFe0Gate   );
+    print_clk_inf(DramGate, DeFe1Gate   );
+    print_clk_inf(DramGate, DeBe0Gate   );
+    print_clk_inf(DramGate, DeBe1Gate   );
+    print_clk_inf(DramGate, DeMpGate    );
+    print_clk_inf(DramGate, AceGate     );
+
+    printk("\nDeBe0Clk clk infor:\n");
+    print_clk_inf(DeBe0Clk, ClkDiv      );
+    print_clk_inf(DeBe0Clk, ClkSrc      );
+    print_clk_inf(DeBe0Clk, Reset       );
+    print_clk_inf(DeBe0Clk, SpecClkGate );
+
+    printk("\nDeBe1Clk clk infor:\n");
+    print_clk_inf(DeBe1Clk, ClkDiv      );
+    print_clk_inf(DeBe1Clk, ClkSrc      );
+    print_clk_inf(DeBe1Clk, Reset       );
+    print_clk_inf(DeBe1Clk, SpecClkGate );
+
+    printk("\nDeFe0Clk clk infor:\n");
+    print_clk_inf(DeFe0Clk, ClkDiv      );
+    print_clk_inf(DeFe0Clk, ClkSrc      );
+    print_clk_inf(DeFe0Clk, Reset       );
+    print_clk_inf(DeFe0Clk, SpecClkGate );
+
+    printk("\nDeFe1Clk clk infor:\n");
+    print_clk_inf(DeFe1Clk, ClkDiv      );
+    print_clk_inf(DeFe1Clk, ClkSrc      );
+    print_clk_inf(DeFe1Clk, Reset       );
+    print_clk_inf(DeFe1Clk, SpecClkGate );
+
+    printk("\nDeMpClk clk infor:\n");
+    print_clk_inf(DeMpClk, ClkDiv       );
+    print_clk_inf(DeMpClk, ClkSrc       );
+    print_clk_inf(DeMpClk, Reset        );
+    print_clk_inf(DeMpClk, SpecClkGate  );
+
+    printk("\nLcd0Ch0Clk clk infor:\n");
+    print_clk_inf(Lcd0Ch0Clk, ClkSrc        );
+    print_clk_inf(Lcd0Ch0Clk, Reset         );
+    print_clk_inf(Lcd0Ch0Clk, SpecClkGate   );
+
+    printk("\nLcd1Ch0Clk clk infor:\n");
+    print_clk_inf(Lcd1Ch0Clk, ClkSrc        );
+    print_clk_inf(Lcd1Ch0Clk, Reset         );
+    print_clk_inf(Lcd1Ch0Clk, SpecClkGate   );
+
+    printk("\nCsiIspClk clk infor:\n");
+    print_clk_inf(CsiIspClk, ClkDiv         );
+    print_clk_inf(CsiIspClk, ClkSrc         );
+    print_clk_inf(CsiIspClk, SpecClkGate    );
+
+    printk("\nTvdClk clk infor:\n");
+    print_clk_inf(TvdClk, ClkSrc        );
+    print_clk_inf(TvdClk, SpecClkGate   );
+
+    printk("\nLcd0Ch1Clk clk infor:\n");
+    print_clk_inf(Lcd0Ch1Clk, ClkDiv        );
+    print_clk_inf(Lcd0Ch1Clk, SpecClk1Src   );
+    print_clk_inf(Lcd0Ch1Clk, SpecClk1Gate  );
+    print_clk_inf(Lcd0Ch1Clk, SpecClk2Src   );
+    print_clk_inf(Lcd0Ch1Clk, SpecClk2Gate  );
+
+    printk("\nLcd1Ch1Clk clk infor:\n");
+    print_clk_inf(Lcd1Ch1Clk, ClkDiv        );
+    print_clk_inf(Lcd1Ch1Clk, SpecClk1Src   );
+    print_clk_inf(Lcd1Ch1Clk, SpecClk1Gate  );
+    print_clk_inf(Lcd1Ch1Clk, SpecClk2Src   );
+    print_clk_inf(Lcd1Ch1Clk, SpecClk2Gate  );
+
+    printk("\nCsi0Clk clk infor:\n");
+    print_clk_inf(Csi0Clk, ClkDiv       );
+    print_clk_inf(Csi0Clk, ClkSrc       );
+    print_clk_inf(Csi0Clk, Reset        );
+    print_clk_inf(Csi0Clk, SpecClkGate  );
+
+    printk("\nCsi1Clk clk infor:\n");
+    print_clk_inf(Csi1Clk, ClkDiv       );
+    print_clk_inf(Csi1Clk, ClkSrc       );
+    print_clk_inf(Csi1Clk, Reset        );
+    print_clk_inf(Csi1Clk, SpecClkGate  );
+
+    printk("\nVeClk clk infor:\n");
+    print_clk_inf(VeClk, Reset          );
+    print_clk_inf(VeClk, ClkDiv         );
+    print_clk_inf(VeClk, SpecClkGate    );
+
+    printk("\nAddaClk clk infor:\n");
+    print_clk_inf(AddaClk, SpecClkGate  );
+
+    printk("\nAvsClk clk infor:\n");
+    print_clk_inf(AvsClk, SpecClkGate   );
+
+    printk("\nAceClk clk infor:\n");
+    print_clk_inf(AceClk, ClkDiv        );
+    print_clk_inf(AceClk, Reset         );
+    print_clk_inf(AceClk, ClkSrc        );
+    print_clk_inf(AceClk, SpecClkGate   );
+
+    printk("\nLvdsClk clk infor:\n");
+    print_clk_inf(LvdsClk, Reset        );
+
+    printk("\nHdmiClk clk infor:\n");
+    print_clk_inf(HdmiClk, ClkDiv       );
+    print_clk_inf(HdmiClk, ClkSrc       );
+    print_clk_inf(HdmiClk, SpecClkGate  );
+
+    printk("\nMaliClk clk infor:\n");
+    print_clk_inf(MaliClk, ClkDiv       );
+    print_clk_inf(MaliClk, ClkSrc       );
+    print_clk_inf(MaliClk, Reset        );
+    print_clk_inf(MaliClk, SpecClkGate  );
+}
+EXPORT_SYMBOL(clk_dbg_inf);
+
+#ifdef CONFIG_PROC_FS
+
+#define sprintf_clk_inf(buf, x, y)     do{seq_printf(buf, "\t"#x"."#y":%d\n", aw_ccu_reg->x.y);}while(0)
+static int ccmu_stats_show(struct seq_file *m, void *unused)
+{
+    seq_printf(m, "---------------------------------------------\n");
+    seq_printf(m, "clock information:                           \n");
+    seq_printf(m, "---------------------------------------------\n");
+
+    seq_printf(m, "\nPLL1 infor:\n");
+    sprintf_clk_inf(m, Pll1Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll1Ctl, SigmaEn      );
+    sprintf_clk_inf(m, Pll1Ctl, SigmaIn      );
+    sprintf_clk_inf(m, Pll1Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll1Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll1Ctl, LockTime     );
+    sprintf_clk_inf(m, Pll1Ctl, PLLDivP      );
+    sprintf_clk_inf(m, Pll1Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll1Ctl, ExchangeEn   );
+    sprintf_clk_inf(m, Pll1Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll1Ctl, VCORstIn     );
+    sprintf_clk_inf(m, Pll1Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL2 infor(0x%x):\n", *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl);
+    sprintf_clk_inf(m, Pll2Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll2Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll2Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll2Ctl, SigmaOut     );
+    sprintf_clk_inf(m, Pll2Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL3 infor:\n");
+    sprintf_clk_inf(m, Pll3Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll3Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll3Ctl, FracSet      );
+    sprintf_clk_inf(m, Pll3Ctl, ModeSel      );
+    sprintf_clk_inf(m, Pll3Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll3Ctl, DampFactor   );
+    sprintf_clk_inf(m, Pll3Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL4 infor:\n");
+    sprintf_clk_inf(m, Pll4Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll4Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll4Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll4Ctl, FactorP      );
+    sprintf_clk_inf(m, Pll4Ctl, VCOGain      );
+    sprintf_clk_inf(m, Pll4Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll4Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll4Ctl, PLLBypass    );
+    sprintf_clk_inf(m, Pll4Ctl, PLLEn        );
+    if (SUNXI_VER_A10C == sw_get_ic_ver())
+        sprintf_clk_inf(m, Pll4Ctl, PllSwitch   );
+
+    seq_printf(m, "\nPLL5 infor:\n");
+    sprintf_clk_inf(m, Pll5Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll5Ctl, FactorM1     );
+    sprintf_clk_inf(m, Pll5Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll5Ctl, LDO2En       );
+    sprintf_clk_inf(m, Pll5Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll5Ctl, VCOGain      );
+    sprintf_clk_inf(m, Pll5Ctl, FactorP      );
+    sprintf_clk_inf(m, Pll5Ctl, BandWidth    );
+    sprintf_clk_inf(m, Pll5Ctl, VCOGainEn    );
+    sprintf_clk_inf(m, Pll5Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll5Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll5Ctl, OutputEn     );
+    sprintf_clk_inf(m, Pll5Ctl, PLLBypass    );
+    sprintf_clk_inf(m, Pll5Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL6 infor:\n");
+    sprintf_clk_inf(m, Pll6Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll6Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll6Ctl, DampFactor   );
+    sprintf_clk_inf(m, Pll6Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll6Ctl, OutputEn     );
+    sprintf_clk_inf(m, Pll6Ctl, BandWidth    );
+    sprintf_clk_inf(m, Pll6Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll6Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll6Ctl, PLLBypass    );
+    sprintf_clk_inf(m, Pll6Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL7 infor:\n");
+    sprintf_clk_inf(m, Pll7Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll7Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll7Ctl, FracSet      );
+    sprintf_clk_inf(m, Pll7Ctl, ModeSel      );
+    sprintf_clk_inf(m, Pll7Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll7Ctl, DampFactor   );
+    sprintf_clk_inf(m, Pll7Ctl, PLLEn        );
+
+    seq_printf(m, "\nHOSC infor:\n");
+    sprintf_clk_inf(m, HoscCtl, OSC24MEn     );
+    sprintf_clk_inf(m, HoscCtl, OSC24MGsm    );
+    sprintf_clk_inf(m, HoscCtl, PLLBiasEn    );
+    sprintf_clk_inf(m, HoscCtl, LDOEn        );
+    sprintf_clk_inf(m, HoscCtl, PLLInPower   );
+    sprintf_clk_inf(m, HoscCtl, LDOOutput    );
+    sprintf_clk_inf(m, HoscCtl, KeyField     );
+
+    seq_printf(m, "\nCPU clk infor:\n");
+    sprintf_clk_inf(m, SysClkDiv, AXIClkDiv  );
+    sprintf_clk_inf(m, SysClkDiv, AHBClkDiv  );
+    sprintf_clk_inf(m, SysClkDiv, APB0ClkDiv );
+    sprintf_clk_inf(m, SysClkDiv, AC328ClkSrc);
+
+    seq_printf(m, "\nAPB1 clk infor:\n");
+    sprintf_clk_inf(m, Apb1ClkDiv, ClkDiv    );
+    sprintf_clk_inf(m, Apb1ClkDiv, PreDiv    );
+    sprintf_clk_inf(m, Apb1ClkDiv, ClkSrc    );
+
+    seq_printf(m, "\nAxiGate clk infor:\n");
+    sprintf_clk_inf(m, AxiGate, SdramGate    );
+
+    seq_printf(m, "\nAhbGate0 clk infor:\n");
+    sprintf_clk_inf(m, AhbGate0, Usb0Gate    );
+    sprintf_clk_inf(m, AhbGate0, Ehci0Gate   );
+    sprintf_clk_inf(m, AhbGate0, Ohci0Gate   );
+    sprintf_clk_inf(m, AhbGate0, Ehci1Gate   );
+    sprintf_clk_inf(m, AhbGate0, Ohci1Gate   );
+    sprintf_clk_inf(m, AhbGate0, SsGate      );
+    sprintf_clk_inf(m, AhbGate0, DmaGate     );
+    sprintf_clk_inf(m, AhbGate0, BistGate    );
+    sprintf_clk_inf(m, AhbGate0, Sdmmc0Gate  );
+    sprintf_clk_inf(m, AhbGate0, Sdmmc1Gate  );
+    sprintf_clk_inf(m, AhbGate0, Sdmmc2Gate  );
+    sprintf_clk_inf(m, AhbGate0, Sdmmc3Gate  );
+    sprintf_clk_inf(m, AhbGate0, MsGate      );
+    sprintf_clk_inf(m, AhbGate0, NandGate    );
+    sprintf_clk_inf(m, AhbGate0, SdramGate   );
+    sprintf_clk_inf(m, AhbGate0, AceGate     );
+    sprintf_clk_inf(m, AhbGate0, EmacGate    );
+    sprintf_clk_inf(m, AhbGate0, TsGate      );
+    sprintf_clk_inf(m, AhbGate0, Spi0Gate    );
+    sprintf_clk_inf(m, AhbGate0, Spi1Gate    );
+    sprintf_clk_inf(m, AhbGate0, Spi2Gate    );
+    sprintf_clk_inf(m, AhbGate0, Spi3Gate    );
+    sprintf_clk_inf(m, AhbGate0, PataGate    );
+    sprintf_clk_inf(m, AhbGate0, SataGate    );
+    sprintf_clk_inf(m, AhbGate0, GpsGate     );
+
+    seq_printf(m, "\nAhbGate1 clk infor:\n");
+    sprintf_clk_inf(m, AhbGate1, VeGate      );
+    sprintf_clk_inf(m, AhbGate1, TvdGate     );
+    sprintf_clk_inf(m, AhbGate1, Tve0Gate    );
+    sprintf_clk_inf(m, AhbGate1, Tve1Gate    );
+    sprintf_clk_inf(m, AhbGate1, Lcd0Gate    );
+    sprintf_clk_inf(m, AhbGate1, Lcd1Gate    );
+    sprintf_clk_inf(m, AhbGate1, Csi0Gate    );
+    sprintf_clk_inf(m, AhbGate1, Csi1Gate    );
+    sprintf_clk_inf(m, AhbGate1, HdmiDGate   );
+    sprintf_clk_inf(m, AhbGate1, DeBe0Gate   );
+    sprintf_clk_inf(m, AhbGate1, DeBe1Gate   );
+    sprintf_clk_inf(m, AhbGate1, DeFe0Gate   );
+    sprintf_clk_inf(m, AhbGate1, DeFe1Gate   );
+    sprintf_clk_inf(m, AhbGate1, MpGate      );
+    sprintf_clk_inf(m, AhbGate1, Gpu3DGate   );
+
+    seq_printf(m, "\nApb0Gate clk infor:\n");
+    sprintf_clk_inf(m, Apb0Gate, AddaGate    );
+    sprintf_clk_inf(m, Apb0Gate, SpdifGate   );
+    sprintf_clk_inf(m, Apb0Gate, Ac97Gate    );
+    sprintf_clk_inf(m, Apb0Gate, IisGate     );
+    sprintf_clk_inf(m, Apb0Gate, PioGate     );
+    sprintf_clk_inf(m, Apb0Gate, Ir0Gate     );
+    sprintf_clk_inf(m, Apb0Gate, Ir1Gate     );
+    sprintf_clk_inf(m, Apb0Gate, KeypadGate  );
+
+    seq_printf(m, "\nApb1Gate clk infor:\n");
+    sprintf_clk_inf(m, Apb1Gate, Twi0Gate    );
+    sprintf_clk_inf(m, Apb1Gate, Twi1Gate    );
+    sprintf_clk_inf(m, Apb1Gate, Twi2Gate    );
+    sprintf_clk_inf(m, Apb1Gate, CanGate     );
+    sprintf_clk_inf(m, Apb1Gate, ScrGate     );
+    sprintf_clk_inf(m, Apb1Gate, Ps20Gate    );
+    sprintf_clk_inf(m, Apb1Gate, Ps21Gate    );
+    sprintf_clk_inf(m, Apb1Gate, Uart0Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart1Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart2Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart3Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart4Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart5Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart6Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart7Gate   );
+
+    seq_printf(m, "\nNandClk clk infor:\n");
+    sprintf_clk_inf(m, NandClk, ClkDiv       );
+    sprintf_clk_inf(m, NandClk, ClkPreDiv    );
+    sprintf_clk_inf(m, NandClk, ClkSrc       );
+    sprintf_clk_inf(m, NandClk, SpecClkGate  );
+
+    seq_printf(m, "\nMsClk clk infor:\n");
+    sprintf_clk_inf(m, MsClk, ClkDiv         );
+    sprintf_clk_inf(m, MsClk, ClkPreDiv      );
+    sprintf_clk_inf(m, MsClk, ClkSrc         );
+    sprintf_clk_inf(m, MsClk, SpecClkGate    );
+
+    seq_printf(m, "\nSdMmc0Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc0Clk, ClkDiv     );
+    sprintf_clk_inf(m, SdMmc0Clk, ClkPreDiv  );
+    sprintf_clk_inf(m, SdMmc0Clk, ClkSrc     );
+    sprintf_clk_inf(m, SdMmc0Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc1Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc1Clk, ClkDiv     );
+    sprintf_clk_inf(m, SdMmc1Clk, ClkPreDiv  );
+    sprintf_clk_inf(m, SdMmc1Clk, ClkSrc     );
+    sprintf_clk_inf(m, SdMmc1Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc2Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc2Clk, ClkDiv     );
+    sprintf_clk_inf(m, SdMmc2Clk, ClkPreDiv  );
+    sprintf_clk_inf(m, SdMmc2Clk, ClkSrc     );
+    sprintf_clk_inf(m, SdMmc2Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc3Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc3Clk, ClkDiv     );
+    sprintf_clk_inf(m, SdMmc3Clk, ClkPreDiv  );
+    sprintf_clk_inf(m, SdMmc3Clk, ClkSrc     );
+    sprintf_clk_inf(m, SdMmc3Clk, SpecClkGate);
+
+    seq_printf(m, "\nTsClk clk infor:\n");
+    sprintf_clk_inf(m, TsClk, ClkDiv         );
+    sprintf_clk_inf(m, TsClk, ClkPreDiv      );
+    sprintf_clk_inf(m, TsClk, ClkSrc         );
+    sprintf_clk_inf(m, TsClk, SpecClkGate    );
+
+    seq_printf(m, "\nSsClk clk infor:\n");
+    sprintf_clk_inf(m, SsClk, ClkDiv         );
+    sprintf_clk_inf(m, SsClk, ClkPreDiv      );
+    sprintf_clk_inf(m, SsClk, ClkSrc         );
+    sprintf_clk_inf(m, SsClk, SpecClkGate    );
+
+    seq_printf(m, "\nSpi0Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi0Clk, ClkDiv       );
+    sprintf_clk_inf(m, Spi0Clk, ClkPreDiv    );
+    sprintf_clk_inf(m, Spi0Clk, ClkSrc       );
+    sprintf_clk_inf(m, Spi0Clk, SpecClkGate  );
+
+    seq_printf(m, "\nSpi1Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi1Clk, ClkDiv       );
+    sprintf_clk_inf(m, Spi1Clk, ClkPreDiv    );
+    sprintf_clk_inf(m, Spi1Clk, ClkSrc       );
+    sprintf_clk_inf(m, Spi1Clk, SpecClkGate  );
+
+    seq_printf(m, "\nSpi2Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi2Clk, ClkDiv       );
+    sprintf_clk_inf(m, Spi2Clk, ClkPreDiv    );
+    sprintf_clk_inf(m, Spi2Clk, ClkSrc       );
+    sprintf_clk_inf(m, Spi2Clk, SpecClkGate  );
+
+    seq_printf(m, "\nPataClk clk infor:\n");
+    sprintf_clk_inf(m, PataClk, ClkDiv       );
+    sprintf_clk_inf(m, PataClk, ClkPreDiv    );
+    sprintf_clk_inf(m, PataClk, ClkSrc       );
+    sprintf_clk_inf(m, PataClk, SpecClkGate  );
+
+    seq_printf(m, "\nIr0Clk clk infor:\n");
+    sprintf_clk_inf(m, Ir0Clk, ClkDiv        );
+    sprintf_clk_inf(m, Ir0Clk, ClkPreDiv     );
+    sprintf_clk_inf(m, Ir0Clk, ClkSrc        );
+    sprintf_clk_inf(m, Ir0Clk, SpecClkGate   );
+
+    seq_printf(m, "\nIr1Clk clk infor:\n");
+    sprintf_clk_inf(m, Ir1Clk, ClkDiv        );
+    sprintf_clk_inf(m, Ir1Clk, ClkPreDiv     );
+    sprintf_clk_inf(m, Ir1Clk, ClkSrc        );
+    sprintf_clk_inf(m, Ir1Clk, SpecClkGate   );
+
+    seq_printf(m, "\nI2sClk clk infor:\n");
+    sprintf_clk_inf(m, I2sClk, ClkDiv        );
+    sprintf_clk_inf(m, I2sClk, SpecClkGate   );
+
+
+    seq_printf(m, "\nAc97Clk clk infor:\n");
+    sprintf_clk_inf(m, Ac97Clk, ClkDiv       );
+    sprintf_clk_inf(m, Ac97Clk, SpecClkGate  );
+
+    seq_printf(m, "\nSpdifClk clk infor:\n");
+    sprintf_clk_inf(m, SpdifClk, ClkDiv      );
+    sprintf_clk_inf(m, SpdifClk, SpecClkGate );
+
+    seq_printf(m, "\nKeyPadClk clk infor:\n");
+    sprintf_clk_inf(m, KeyPadClk, ClkDiv         );
+    sprintf_clk_inf(m, KeyPadClk, ClkPreDiv      );
+    sprintf_clk_inf(m, KeyPadClk, ClkSrc         );
+    sprintf_clk_inf(m, KeyPadClk, SpecClkGate    );
+
+    seq_printf(m, "\nSataClk clk infor:\n");
+    sprintf_clk_inf(m, SataClk, ClkSrc       );
+    sprintf_clk_inf(m, SataClk, SpecClkGate  );
+
+    seq_printf(m, "\nUsbClk clk infor:\n");
+    sprintf_clk_inf(m, UsbClk, UsbPhy0Rst        );
+    sprintf_clk_inf(m, UsbClk, UsbPhy1Rst        );
+    sprintf_clk_inf(m, UsbClk, UsbPhy2Rst        );
+    sprintf_clk_inf(m, UsbClk, OHCIClkSrc        );
+    sprintf_clk_inf(m, UsbClk, OHCI0SpecClkGate  );
+    sprintf_clk_inf(m, UsbClk, OHCI1SpecClkGate  );
+    sprintf_clk_inf(m, UsbClk, PhySpecClkGate    );
+
+    seq_printf(m, "\nGpsClk clk infor:\n");
+    sprintf_clk_inf(m, GpsClk, Reset         );
+    sprintf_clk_inf(m, GpsClk, SpecClkGate   );
+
+    seq_printf(m, "\nSpi3Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi3Clk, ClkDiv       );
+    sprintf_clk_inf(m, Spi3Clk, ClkPreDiv    );
+    sprintf_clk_inf(m, Spi3Clk, ClkSrc       );
+    sprintf_clk_inf(m, Spi3Clk, SpecClkGate  );
+
+    seq_printf(m, "\nDramGate clk infor:\n");
+    sprintf_clk_inf(m, DramGate, VeGate      );
+    sprintf_clk_inf(m, DramGate, Csi0Gate    );
+    sprintf_clk_inf(m, DramGate, Csi1Gate    );
+    sprintf_clk_inf(m, DramGate, TsGate      );
+    sprintf_clk_inf(m, DramGate, TvdGate     );
+    sprintf_clk_inf(m, DramGate, Tve0Gate    );
+    sprintf_clk_inf(m, DramGate, Tve1Gate    );
+    sprintf_clk_inf(m, DramGate, ClkOutputEn );
+    sprintf_clk_inf(m, DramGate, DeFe0Gate   );
+    sprintf_clk_inf(m, DramGate, DeFe1Gate   );
+    sprintf_clk_inf(m, DramGate, DeBe0Gate   );
+    sprintf_clk_inf(m, DramGate, DeBe1Gate   );
+    sprintf_clk_inf(m, DramGate, DeMpGate    );
+    sprintf_clk_inf(m, DramGate, AceGate     );
+
+    seq_printf(m, "\nDeBe0Clk clk infor:\n");
+    sprintf_clk_inf(m, DeBe0Clk, ClkDiv      );
+    sprintf_clk_inf(m, DeBe0Clk, ClkSrc      );
+    sprintf_clk_inf(m, DeBe0Clk, Reset       );
+    sprintf_clk_inf(m, DeBe0Clk, SpecClkGate );
+
+    seq_printf(m, "\nDeBe1Clk clk infor:\n");
+    sprintf_clk_inf(m, DeBe1Clk, ClkDiv      );
+    sprintf_clk_inf(m, DeBe1Clk, ClkSrc      );
+    sprintf_clk_inf(m, DeBe1Clk, Reset       );
+    sprintf_clk_inf(m, DeBe1Clk, SpecClkGate );
+
+    seq_printf(m, "\nDeFe0Clk clk infor:\n");
+    sprintf_clk_inf(m, DeFe0Clk, ClkDiv      );
+    sprintf_clk_inf(m, DeFe0Clk, ClkSrc      );
+    sprintf_clk_inf(m, DeFe0Clk, Reset       );
+    sprintf_clk_inf(m, DeFe0Clk, SpecClkGate );
+
+    seq_printf(m, "\nDeFe1Clk clk infor:\n");
+    sprintf_clk_inf(m, DeFe1Clk, ClkDiv      );
+    sprintf_clk_inf(m, DeFe1Clk, ClkSrc      );
+    sprintf_clk_inf(m, DeFe1Clk, Reset       );
+    sprintf_clk_inf(m, DeFe1Clk, SpecClkGate );
+
+    seq_printf(m, "\nDeMpClk clk infor:\n");
+    sprintf_clk_inf(m, DeMpClk, ClkDiv       );
+    sprintf_clk_inf(m, DeMpClk, ClkSrc       );
+    sprintf_clk_inf(m, DeMpClk, Reset        );
+    sprintf_clk_inf(m, DeMpClk, SpecClkGate  );
+
+    seq_printf(m, "\nLcd0Ch0Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd0Ch0Clk, ClkSrc        );
+    sprintf_clk_inf(m, Lcd0Ch0Clk, Reset         );
+    sprintf_clk_inf(m, Lcd0Ch0Clk, SpecClkGate   );
+
+    seq_printf(m, "\nLcd1Ch0Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd1Ch0Clk, ClkSrc        );
+    sprintf_clk_inf(m, Lcd1Ch0Clk, Reset         );
+    sprintf_clk_inf(m, Lcd1Ch0Clk, SpecClkGate   );
+
+    seq_printf(m, "\nCsiIspClk clk infor:\n");
+    sprintf_clk_inf(m, CsiIspClk, ClkDiv         );
+    sprintf_clk_inf(m, CsiIspClk, ClkSrc         );
+    sprintf_clk_inf(m, CsiIspClk, SpecClkGate    );
+
+    seq_printf(m, "\nTvdClk clk infor:\n");
+    sprintf_clk_inf(m, TvdClk, ClkSrc        );
+    sprintf_clk_inf(m, TvdClk, SpecClkGate   );
+
+    seq_printf(m, "\nLcd0Ch1Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd0Ch1Clk, ClkDiv        );
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk1Src   );
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk1Gate  );
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk2Src   );
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk2Gate  );
+
+    seq_printf(m, "\nLcd1Ch1Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd1Ch1Clk, ClkDiv        );
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk1Src   );
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk1Gate  );
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk2Src   );
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk2Gate  );
+
+    seq_printf(m, "\nCsi0Clk clk infor:\n");
+    sprintf_clk_inf(m, Csi0Clk, ClkDiv       );
+    sprintf_clk_inf(m, Csi0Clk, ClkSrc       );
+    sprintf_clk_inf(m, Csi0Clk, Reset        );
+    sprintf_clk_inf(m, Csi0Clk, SpecClkGate  );
+
+    seq_printf(m, "\nCsi1Clk clk infor:\n");
+    sprintf_clk_inf(m, Csi1Clk, ClkDiv       );
+    sprintf_clk_inf(m, Csi1Clk, ClkSrc       );
+    sprintf_clk_inf(m, Csi1Clk, Reset        );
+    sprintf_clk_inf(m, Csi1Clk, SpecClkGate  );
+
+    seq_printf(m, "\nVeClk clk infor:\n");
+    sprintf_clk_inf(m, VeClk, Reset          );
+    sprintf_clk_inf(m, VeClk, ClkDiv         );
+    sprintf_clk_inf(m, VeClk, SpecClkGate    );
+
+    seq_printf(m, "\nAddaClk clk infor:\n");
+    sprintf_clk_inf(m, AddaClk, SpecClkGate  );
+
+    seq_printf(m, "\nAvsClk clk infor:\n");
+    sprintf_clk_inf(m, AvsClk, SpecClkGate   );
+
+    seq_printf(m, "\nAceClk clk infor:\n");
+    sprintf_clk_inf(m, AceClk, ClkDiv        );
+    sprintf_clk_inf(m, AceClk, Reset         );
+    sprintf_clk_inf(m, AceClk, ClkSrc        );
+    sprintf_clk_inf(m, AceClk, SpecClkGate   );
+
+    seq_printf(m, "\nLvdsClk clk infor:\n");
+    sprintf_clk_inf(m, LvdsClk, Reset        );
+
+    seq_printf(m, "\nHdmiClk clk infor:\n");
+    sprintf_clk_inf(m, HdmiClk, ClkDiv       );
+    sprintf_clk_inf(m, HdmiClk, ClkSrc       );
+    sprintf_clk_inf(m, HdmiClk, SpecClkGate  );
+
+    seq_printf(m, "\nMaliClk clk infor:\n");
+    sprintf_clk_inf(m, MaliClk, ClkDiv       );
+    sprintf_clk_inf(m, MaliClk, ClkSrc       );
+    sprintf_clk_inf(m, MaliClk, Reset        );
+    sprintf_clk_inf(m, MaliClk, SpecClkGate  );
+
+	return 0;
+}
+
+
+static int ccmu_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ccmu_stats_show, NULL);
+}
+
+static const struct file_operations ccmu_dbg_fops = {
+	.owner = THIS_MODULE,
+	.open = ccmu_stats_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int __init ccu_dbg_init(void)
+{
+	proc_create("ccmu", S_IRUGO, NULL, &ccmu_dbg_fops);
+	return 0;
+}
+
+static void  __exit ccu_dbg_exit(void)
+{
+	remove_proc_entry("ccmu", NULL);
+}
+
+core_initcall(ccu_dbg_init);
+module_exit(ccu_dbg_exit);
+#endif
+
diff --git a/arch/arm/mach-sun4i/clock/ccmu/pll_cfg_tbl.c b/arch/arm/mach-sun4i/clock/ccmu/pll_cfg_tbl.c
new file mode 100644
index 0000000..87c8514
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/ccmu/pll_cfg_tbl.c
@@ -0,0 +1,312 @@
+/*
+ * arch/arm/mach-sun4i/clock/ccmu/pll_cfg_tbl.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "ccm_i.h"
+#include <mach/aw_ccu.h>
+
+struct core_pll_freq_tbl{
+    __u8    FactorN;
+    __u8    FactorK;
+    __u8    FactorM;
+    __u8    FactorP;
+    __u32   Pll;
+};
+
+/* core pll parameter table */
+static struct core_pll_freq_tbl    CorePllTbl[] = {
+
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 0   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 1   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 2   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 3   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 4   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 5   */
+    { 12,    0,    0,    3,    36000000  },   /* freq = (6M * 6  ), index = 6   */
+    { 7 ,    1,    0,    3,    42000000  },   /* freq = (6M * 7  ), index = 7   */
+    { 16,    0,    0,    3,    48000000  },   /* freq = (6M * 8  ), index = 8   */
+    { 9 ,    1,    0,    3,    54000000  },   /* freq = (6M * 9  ), index = 9   */
+    { 10,    0,    0,    2,    60000000  },   /* freq = (6M * 10 ), index = 10  */
+    { 11,    0,    0,    2,    66000000  },   /* freq = (6M * 11 ), index = 11  */
+    { 12,    0,    0,    2,    72000000  },   /* freq = (6M * 12 ), index = 12  */
+    { 13,    0,    0,    2,    78000000  },   /* freq = (6M * 13 ), index = 13  */
+    { 14,    0,    0,    2,    84000000  },   /* freq = (6M * 14 ), index = 14  */
+    { 15,    0,    0,    2,    90000000  },   /* freq = (6M * 15 ), index = 15  */
+    { 16,    0,    0,    2,    96000000  },   /* freq = (6M * 16 ), index = 16  */
+    { 17,    0,    0,    2,    102000000 },   /* freq = (6M * 17 ), index = 17  */
+    { 18,    0,    0,    2,    108000000 },   /* freq = (6M * 18 ), index = 18  */
+    { 19,    0,    0,    2,    114000000 },   /* freq = (6M * 19 ), index = 19  */
+    { 10,    0,    0,    1,    120000000 },   /* freq = (6M * 20 ), index = 20  */
+    { 21,    0,    0,    2,    126000000 },   /* freq = (6M * 21 ), index = 21  */
+    { 11,    0,    0,    1,    132000000 },   /* freq = (6M * 22 ), index = 22  */
+    { 23,    0,    0,    2,    138000000 },   /* freq = (6M * 23 ), index = 23  */
+    { 12,    0,    0,    1,    144000000 },   /* freq = (6M * 24 ), index = 24  */
+    { 25,    0,    0,    2,    150000000 },   /* freq = (6M * 25 ), index = 25  */
+    { 13,    0,    0,    1,    156000000 },   /* freq = (6M * 26 ), index = 26  */
+    { 27,    0,    0,    2,    162000000 },   /* freq = (6M * 27 ), index = 27  */
+    { 14,    0,    0,    1,    168000000 },   /* freq = (6M * 28 ), index = 28  */
+    { 29,    0,    0,    2,    174000000 },   /* freq = (6M * 29 ), index = 29  */
+    { 15,    0,    0,    1,    180000000 },   /* freq = (6M * 30 ), index = 30  */
+    { 31,    0,    0,    2,    186000000 },   /* freq = (6M * 31 ), index = 31  */
+    { 16,    0,    0,    1,    192000000 },   /* freq = (6M * 32 ), index = 32  */
+    { 16,    0,    0,    1,    192000000 },   /* freq = (6M * 32 ), index = 33  */
+    { 17,    0,    0,    1,    204000000 },   /* freq = (6M * 34 ), index = 34  */
+    { 17,    0,    0,    1,    204000000 },   /* freq = (6M * 34 ), index = 35  */
+    { 18,    0,    0,    1,    216000000 },   /* freq = (6M * 36 ), index = 36  */
+    { 18,    0,    0,    1,    216000000 },   /* freq = (6M * 36 ), index = 37  */
+    { 19,    0,    0,    1,    228000000 },   /* freq = (6M * 38 ), index = 38  */
+    { 19,    0,    0,    1,    228000000 },   /* freq = (6M * 38 ), index = 39  */
+    { 10,    0,    0,    0,    240000000 },   /* freq = (6M * 40 ), index = 40  */
+    { 10,    0,    0,    0,    240000000 },   /* freq = (6M * 40 ), index = 41  */
+    { 21,    0,    0,    1,    252000000 },   /* freq = (6M * 42 ), index = 42  */
+    { 21,    0,    0,    1,    252000000 },   /* freq = (6M * 42 ), index = 43  */
+    { 11,    0,    0,    0,    264000000 },   /* freq = (6M * 44 ), index = 44  */
+    { 11,    0,    0,    0,    264000000 },   /* freq = (6M * 44 ), index = 45  */
+    { 23,    0,    0,    1,    276000000 },   /* freq = (6M * 46 ), index = 46  */
+    { 23,    0,    0,    1,    276000000 },   /* freq = (6M * 46 ), index = 47  */
+    { 12,    0,    0,    0,    288000000 },   /* freq = (6M * 48 ), index = 48  */
+    { 12,    0,    0,    0,    288000000 },   /* freq = (6M * 48 ), index = 49  */
+    { 25,    0,    0,    1,    300000000 },   /* freq = (6M * 50 ), index = 50  */
+    { 25,    0,    0,    1,    300000000 },   /* freq = (6M * 50 ), index = 51  */
+    { 13,    0,    0,    0,    312000000 },   /* freq = (6M * 52 ), index = 52  */
+    { 13,    0,    0,    0,    312000000 },   /* freq = (6M * 52 ), index = 53  */
+    { 27,    0,    0,    1,    324000000 },   /* freq = (6M * 54 ), index = 54  */
+    { 27,    0,    0,    1,    324000000 },   /* freq = (6M * 54 ), index = 55  */
+    { 14,    0,    0,    0,    336000000 },   /* freq = (6M * 56 ), index = 56  */
+    { 14,    0,    0,    0,    336000000 },   /* freq = (6M * 56 ), index = 57  */
+    { 29,    0,    0,    1,    348000000 },   /* freq = (6M * 58 ), index = 58  */
+    { 29,    0,    0,    1,    348000000 },   /* freq = (6M * 58 ), index = 59  */
+    { 15,    0,    0,    0,    360000000 },   /* freq = (6M * 60 ), index = 60  */
+    { 15,    0,    0,    0,    360000000 },   /* freq = (6M * 60 ), index = 61  */
+    { 31,    0,    0,    1,    372000000 },   /* freq = (6M * 62 ), index = 62  */
+    { 31,    0,    0,    1,    372000000 },   /* freq = (6M * 62 ), index = 63  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 64  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 65  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 66  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 67  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 68  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 69  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 70  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 71  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 72  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 73  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 74  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 75  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 76  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 77  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 78  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 79  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 80  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 81  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 82  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 83  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 84  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 85  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 86  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 87  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 88  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 89  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 90  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 91  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 92  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 93  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 94  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 95  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 96  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 97  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 98  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 99  */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 100 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 101 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 102 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 103 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 104 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 105 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 106 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 107 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 108 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 109 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 110 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 111 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 112 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 113 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 114 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 115 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 116 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 117 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 118 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 119 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 120 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 121 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 122 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 123 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 124 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 125 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 126 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 127 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 128 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 129 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 130 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 131 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 132 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 133 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 134 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 135 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 136 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 137 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 138 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 139 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 140 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 141 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 142 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 143 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 144 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 145 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 146 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 147 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 148 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 149 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 150 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 151 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 152 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 153 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 154 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 155 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 156 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 157 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 158 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 159 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 160 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 161 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 162 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 163 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 164 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 165 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 166 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 167 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 168 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 169 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 170 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 171 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 172 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 173 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 174 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 175 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 176 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 177 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 178 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 179 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 180 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 181 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 182 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 183 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 184 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 185 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 186 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 187 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 188 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 189 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 190 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 191 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 192 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 193 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 194 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 195 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 196 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 197 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 198 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 199 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 200 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 201 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 202 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 203 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 204 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 205 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 206 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 207 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 208 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 209 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 210 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 211 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 212 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 213 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 214 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 215 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 216 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 217 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 218 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 219 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 220 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 221 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 222 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 223 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 224 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 225 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 226 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 227 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 228 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 229 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 230 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 231 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 232 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 233 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 234 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 235 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 236 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 237 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 238 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 239 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 240 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 241 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 242 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 243 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 244 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 245 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 246 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 247 */
+    { 31,    1,    0,    0,    1488000000},   /* freq = (6M * 248), index = 248 */
+};
+
+
+int ccm_clk_get_pll_para(struct core_pll_factor_t *factor, __u64 rate)
+{
+    int     index;
+
+    if(!factor)
+    {
+        return -1;
+    }
+
+    if(rate > 1488000000)
+    {
+        rate = 1488000000;
+    }
+    index = ccu_clk_uldiv(rate, 6000000);
+
+    factor->FactorN = CorePllTbl[index].FactorN;
+    factor->FactorK = CorePllTbl[index].FactorK;
+    factor->FactorM = CorePllTbl[index].FactorM;
+    factor->FactorP = CorePllTbl[index].FactorP;
+
+    return 0;
+}
+
diff --git a/arch/arm/mach-sun4i/clock/clock.c b/arch/arm/mach-sun4i/clock/clock.c
new file mode 100644
index 0000000..0932d9d
--- /dev/null
+++ b/arch/arm/mach-sun4i/clock/clock.c
@@ -0,0 +1,489 @@
+/*
+ * arch/arm/mach-sun4i/clock/clock.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+
+#include <mach/clock.h>
+#include <mach/system.h>
+
+/* we predefine the count here, but it's ugly, maybe malloc is better */
+#define MAX_SYSTEM_CLK_CNT  (32)
+#define MAX_MODULE_CLK_CNT  (200)
+
+#undef CCU_DBG
+#undef CCU_ERR
+#if (0)
+    #define CCU_DBG     printk
+    #define CCU_ERR     printk
+#else
+    #define CCU_DBG(...)
+    #define CCU_ERR(...)
+#endif
+
+
+// alloc memory for store clock informatioin, maybe malloc is better
+static __s32 SysClkCnt;
+static __s32 ModClkCnt;
+static struct clk ccu_sys_clk[MAX_SYSTEM_CLK_CNT];
+static struct clk ccu_mod_clk[MAX_MODULE_CLK_CNT];
+
+// lock for operation protect
+static DEFINE_MUTEX(clocks_mutex);
+static DEFINE_SPINLOCK(clockfw_lock);
+
+
+/*
+*********************************************************************************************************
+*                           clk_init
+*
+*Description: clock management initialise.
+*
+*Arguments  : none
+*
+*Return     : result
+*               0,  initialise successed;
+*              -1,  initialise failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int clk_init(void)
+{
+    __s32           i;
+    struct clk      *tmpSclk;
+
+    CCU_DBG("aw clock manager init!\n");
+
+    //initialise clock controller unit
+    if(AW_CCU_ERR_NONE != aw_ccu_init())
+    {
+        CCU_ERR("csp ccmu initial failed!\n");
+        return -1;
+    }
+
+    //clear the data structure
+    SysClkCnt = 0;
+    memset((void *)&ccu_sys_clk, 0, sizeof(ccu_sys_clk));
+    ModClkCnt = 0;
+    memset((void *)&ccu_mod_clk, 0, sizeof(ccu_mod_clk));
+
+    //get system clock information
+    SysClkCnt = aw_ccu_get_sys_clk_cnt();
+    if(SysClkCnt > MAX_SYSTEM_CLK_CNT)
+    {
+        CCU_ERR("system clock count define (%d) is invalid! actule is:%d\n", MAX_SYSTEM_CLK_CNT, SysClkCnt);
+        return -1;
+    }
+    for(i=0; i<SysClkCnt; i++)
+    {
+        ccu_sys_clk[i].clk = aw_ccu_get_sys_clk((__aw_ccu_sys_clk_e)i);
+        if(ccu_sys_clk[i].clk)
+        {
+            tmpSclk = &ccu_sys_clk[ccu_sys_clk[i].clk->parent];
+            ccu_sys_clk[i].parent = tmpSclk;
+            ccu_sys_clk[i].set_clk = &aw_ccu_set_sys_clk;
+            ccu_sys_clk[i].get_clk = (__aw_ccu_clk_t * (*)(__s32))&aw_ccu_get_sys_clk;
+            ccu_sys_clk[i].hash = ccu_clk_calc_hash(ccu_sys_clk[i].clk->name);
+            if(ccu_sys_clk[i].clk->onoff == AW_CCU_CLK_ON)
+            {
+                tmpSclk->usr_cnt++;
+            }
+        }
+    }
+
+    //get module clock information
+    ModClkCnt = aw_ccu_get_mod_clk_cnt();
+    if(ModClkCnt > MAX_MODULE_CLK_CNT)
+    {
+        CCU_ERR("module clock count define (%d) is invalid! actule is:%d\n", MAX_MODULE_CLK_CNT, ModClkCnt);
+        return -1;
+    }
+    for(i=0; i<ModClkCnt; i++)
+    {
+        ccu_mod_clk[i].clk = aw_ccu_get_mod_clk((__aw_ccu_sys_clk_e)i);
+        if(ccu_mod_clk[i].clk)
+        {
+            tmpSclk = &ccu_sys_clk[ccu_mod_clk[i].clk->parent];
+            ccu_mod_clk[i].parent = tmpSclk;
+            ccu_mod_clk[i].set_clk = &aw_ccu_set_mod_clk;
+            ccu_mod_clk[i].get_clk = (__aw_ccu_clk_t * (*)(__s32))&aw_ccu_get_mod_clk;
+            ccu_mod_clk[i].hash = ccu_clk_calc_hash(ccu_mod_clk[i].clk->name);
+            if(ccu_mod_clk[i].clk->onoff == AW_CCU_CLK_ON)
+            {
+                tmpSclk->usr_cnt++;
+            }
+            if(tmpSclk->child)
+            {
+                ccu_mod_clk[i].right = tmpSclk->child;
+                tmpSclk->child->left = &ccu_mod_clk[i];
+            }
+            tmpSclk->child = &ccu_mod_clk[i];
+        }
+    }
+
+    /* enable pll for use, it need be modified to dynamic */
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL2];
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL3];
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+
+	/* initiate PLL4 */
+#if(USE_PLL6M_REPLACE_PLL4)
+	if (SUNXI_VER_A10C == sw_get_ic_ver()) {
+        tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL4];
+        tmpSclk->clk->onoff = AW_CCU_CLK_OFF;
+        tmpSclk->set_clk(tmpSclk->clk);
+	} else
+#endif
+	{
+        tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL4];
+        tmpSclk->clk->rate  = 960000000;
+        tmpSclk->set_clk(tmpSclk->clk);
+        tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+        tmpSclk->set_clk(tmpSclk->clk);
+	}
+
+	/* initiate PLL6 */
+	tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL6];
+	tmpSclk->clk->rate  = 1200000000;
+	tmpSclk->set_clk(tmpSclk->clk);
+	tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+	tmpSclk->set_clk(tmpSclk->clk);
+
+	tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL6M];
+	tmpSclk->clk->rate  = 100000000;
+	tmpSclk->set_clk(tmpSclk->clk);
+	tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+	tmpSclk->set_clk(tmpSclk->clk);
+
+	tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL62];
+	tmpSclk->clk->rate  = 600000000;
+	tmpSclk->set_clk(tmpSclk->clk);
+	tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+	tmpSclk->set_clk(tmpSclk->clk);
+
+	tmpSclk = clk_get(NULL, "apb1");
+	if (tmpSclk) {
+		struct clk *tmpClk = &ccu_sys_clk[AW_SYS_CLK_HOSC];
+		clk_set_parent(tmpSclk, tmpClk);
+	} else {
+		CCU_ERR("try to get apb1 clock handle failed!\n");
+	}
+
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL7];
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+
+    return 0;
+}
+arch_initcall(clk_init);
+
+
+struct clk * clk_get(struct device *dev, const char *id)
+{
+    __s32   i = 0;
+    __s32   tmpHash = ccu_clk_calc_hash((char *)id);
+
+    CCU_DBG("%s:%d:%s:Get clock %s !\n", __FILE__, __LINE__, __FUNCTION__, id);
+    if(!id)
+    {
+        return NULL;
+    }
+
+    mutex_lock(&clocks_mutex);
+
+    /* search system clock table */
+    for(i=0; i<SysClkCnt; i++)
+    {
+        if(tmpHash == ccu_sys_clk[i].hash)
+        {
+            if(!strcmp(id, ccu_sys_clk[i].clk->name))
+            {
+                ccu_sys_clk[i].usr_cnt++;
+                mutex_unlock(&clocks_mutex);
+                return &ccu_sys_clk[i];
+            }
+        }
+    }
+
+    /* search module clock table */
+    for(i=0; i<ModClkCnt; i++)
+    {
+        if(tmpHash == ccu_mod_clk[i].hash)
+        {
+            if(!strcmp(id, ccu_mod_clk[i].clk->name))
+            {
+                ccu_mod_clk[i].usr_cnt++;
+                mutex_unlock(&clocks_mutex);
+                return &ccu_mod_clk[i];
+            }
+        }
+    }
+    CCU_ERR("%s:%d:%s: (%s) failed!\n", __FILE__, __LINE__, __FUNCTION__, id);
+
+    mutex_unlock(&clocks_mutex);
+
+    return NULL;
+}
+EXPORT_SYMBOL(clk_get);
+
+
+int clk_enable(struct clk *clk)
+{
+    unsigned long flags;
+    int ret = 0;
+
+    if((clk == NULL) || IS_ERR(clk))
+        return -EINVAL;
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    if(clk->clk->onoff == AW_CCU_CLK_OFF)
+    {
+        /* update clock parameter */
+        clk->clk = clk->get_clk(clk->clk->id);
+
+        /* try to enable clock */
+        clk->clk->onoff = AW_CCU_CLK_ON;
+        ret = clk->set_clk(clk->clk);
+    }
+    if(!ret) {
+        clk->enable++;
+    }
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+
+void clk_disable(struct clk *clk)
+{
+    unsigned long flags;
+
+    if(clk == NULL || IS_ERR(clk) || !clk->enable)
+        return;
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    clk->enable--;
+    if(clk->enable){
+        spin_unlock_irqrestore(&clockfw_lock, flags);
+        return;
+    }
+    if(clk->clk->onoff == AW_CCU_CLK_ON)
+    {
+        /* update clock parameter */
+        clk->clk = clk->get_clk(clk->clk->id);
+
+        /* try to disalbe clock */
+        clk->clk->onoff = AW_CCU_CLK_OFF;
+        clk->set_clk(clk->clk);
+    }
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+    unsigned long   flags;
+    unsigned long   ret = 0;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return 0;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+
+    clk->clk = clk->get_clk(clk->clk->id);
+    ret = (unsigned long)clk->clk->rate;
+
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+unsigned long clk_get_rate_nolock(struct clk *clk)
+{
+    unsigned long   ret = 0;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return 0;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    clk->clk = clk->get_clk(clk->clk->id);
+    ret = (unsigned long)clk->clk->rate;
+
+    return ret;
+}
+
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+    unsigned long   flags;
+    int ret = 0;
+
+    if(clk == NULL || IS_ERR(clk))
+        return -1;
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    /* update clock parameter */
+    clk->clk = clk->get_clk(clk->clk->id);
+    clk->clk->rate = rate;
+    ret = clk->set_clk(clk->clk);
+
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+    struct clk *parent = NULL;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return NULL;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+    parent = clk->parent;
+
+    return parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+    unsigned long   flags;
+    int ret = -1;
+    struct clk *old_parent;
+
+    if((clk == NULL) || IS_ERR(parent))
+    {
+        return ret;
+    }
+
+    if (parent == NULL || IS_ERR(parent))
+    {
+        return ret;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+
+    /* update clock parameter */
+    clk->clk = clk->get_clk(clk->clk->id);
+    old_parent = clk->parent;
+    clk->clk->rate = clk_get_rate_nolock(parent) / (clk_get_rate_nolock(old_parent) / clk_get_rate_nolock(clk));
+    clk->clk->parent = parent->clk->id;
+    ret = clk->set_clk(clk->clk);
+    if(ret){
+        clk->clk->parent = old_parent->clk->id;
+    }
+    else{
+        clk->parent = parent;
+    }
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+
+void clk_put(struct clk *clk)
+{
+    unsigned long   flags;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return;
+    }
+
+    if(!clk->usr_cnt)
+    {
+        return;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    clk->usr_cnt--;
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+EXPORT_SYMBOL(clk_put);
+
+
+int clk_reset(struct clk *clk, int reset)
+{
+    unsigned long   flags;
+    int ret = 0;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return -EINVAL;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    /* update clock parameter */
+    clk->clk = clk->get_clk(clk->clk->id);
+    reset? (clk->clk->reset = AW_CCU_CLK_RESET) : (clk->clk->reset = AW_CCU_CLK_NRESET);
+    ret = clk->set_clk(clk->clk);
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_reset);
+
diff --git a/arch/arm/mach-sun4i/include/mach/aw_ccu.h b/arch/arm/mach-sun4i/include/mach/aw_ccu.h
new file mode 100644
index 0000000..98bfe80
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/aw_ccu.h
@@ -0,0 +1,359 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/aw_ccu.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __AW_CCU_H__
+#define __AW_CCU_H__
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/* define if need use pll6 to take the place of pll4,
+   this definition is significative on C ver. only */
+#define USE_PLL6M_REPLACE_PLL4      (0)
+
+
+/* define clock error type      */
+typedef enum __AW_CCU_ERR
+{
+    AW_CCU_ERR_NONE         = 0,
+    AW_CCU_ERR_PARA_NULL    = -1,
+    AW_CCU_ERR_PARA_INVALID = -1,
+
+} __aw_ccu_err_e;
+
+
+typedef enum __AW_CCU_CLK_ONOFF
+{
+    AW_CCU_CLK_OFF,
+    AW_CCU_CLK_ON,
+
+} __aw_ccu_clk_onff_e;
+
+
+typedef enum __AW_CCU_CLK_RESET
+{
+    AW_CCU_CLK_RESET,
+    AW_CCU_CLK_NRESET,
+
+} __aw_ccu_clk_reset_e;
+
+
+/* define system clock id       */
+typedef enum __AW_CCU_SYS_CLK
+{
+    AW_SYS_CLK_NONE,    /* invalid clock id                     */
+
+    AW_SYS_CLK_LOSC,    /* "losc"       ,LOSC, 32768 hz clock   */
+    AW_SYS_CLK_HOSC,    /* "hosc"       ,HOSC, 24Mhz clock      */
+
+    AW_SYS_CLK_PLL1,    /* "core_pll"   ,PLL1 clock             */
+    AW_SYS_CLK_PLL2,    /* "audio_pll"  ,PLL2 clock             */
+    AW_SYS_CLK_PLL2X8,  /* "audio_pllx8"  ,PLL2 8x clock        */
+    AW_SYS_CLK_PLL3,    /* "video_pll0" ,PLL3 clock             */
+    AW_SYS_CLK_PLL3X2,  /* "video_pll0x2" ,PLL3 2x clock        */
+    AW_SYS_CLK_PLL4,    /* "ve_pll"     ,PLL4 clock             */
+    AW_SYS_CLK_PLL5,    /* "sdram_pll"  ,PLL5 clock             */
+    AW_SYS_CLK_PLL5M,   /* "sdram_pll_m",PLL5 M clock           */
+    AW_SYS_CLK_PLL5P,   /* "sdram_pll_p",PLL5 P clock           */
+    AW_SYS_CLK_PLL6,    /* "sata_pll"   ,PLL6 clock, just used
+                           as source of sata_pll_m and sata_pll_2,
+                           users should not use this clock dirctly
+                        */
+    AW_SYS_CLK_PLL7,    /* "video_pll1" ,PLL7 clock             */
+    AW_SYS_CLK_PLL7X2,  /* "video_pll1x2" ,PLL7 2x clock        */
+    AW_SYS_CLK_200M,    /* "200m_pll"   ,200Mhz clock           */
+
+    AW_SYS_CLK_CPU,     /* "cpu"        ,CPU clock              */
+    AW_SYS_CLK_AXI,     /* "axi"        ,AXI clock              */
+    AW_SYS_CLK_AHB,     /* "ahb"        ,AHB clock              */
+    AW_SYS_CLK_APB0,    /* "apb"        ,APB0 clock             */
+    AW_SYS_CLK_APB1,    /* "apb1"       ,APB1 clock             */
+
+    /* add by kevin, 2011-7-21 19:01 */
+    AW_SYS_CLK_PLL6M,   /* "sata_pll_m" ,PLL6 M clock, just for SATA    */
+    AW_SYS_CLK_PLL62,   /* "sata_pll_2" ,PLL6 2 clock, for module       */
+
+    AW_SYS_CLK_CNT      /* invalid id, for calc count           */
+
+} __aw_ccu_sys_clk_e;
+
+
+/* define module clock id       */
+typedef enum __AW_CCU_MOD_CLK
+{
+    AW_MOD_CLK_NONE,/* invalid clock id             */
+
+    AW_MOD_CLK_NFC,         /* "nfc"            */
+    AW_MOD_CLK_MSC,         /* "msc"            */
+    AW_MOD_CLK_SDC0,        /* "sdc0"           */
+    AW_MOD_CLK_SDC1,        /* "sdc1"           */
+    AW_MOD_CLK_SDC2,        /* "sdc2"           */
+    AW_MOD_CLK_SDC3,        /* "sdc3"           */
+    AW_MOD_CLK_TS,          /* "ts"             */
+    AW_MOD_CLK_SS,          /* "ss"             */
+    AW_MOD_CLK_SPI0,        /* "spi0"           */
+    AW_MOD_CLK_SPI1,        /* "spi1"           */
+    AW_MOD_CLK_SPI2,        /* "spi2"           */
+    AW_MOD_CLK_PATA,        /* "pata"           */
+    AW_MOD_CLK_IR0,         /* "ir0"            */
+    AW_MOD_CLK_IR1,         /* "ir1"            */
+    AW_MOD_CLK_I2S,         /* "i2s"            */
+    AW_MOD_CLK_AC97,        /* "ac97"           */
+    AW_MOD_CLK_SPDIF,       /* "spdif"          */
+    AW_MOD_CLK_KEYPAD,      /* "key_pad"        */
+    AW_MOD_CLK_SATA,        /* "sata"           */
+    AW_MOD_CLK_USBPHY,      /* "usb_phy"        */
+    AW_MOD_CLK_USBPHY0,     /* "usb_phy0"       */
+    AW_MOD_CLK_USBPHY1,     /* "usb_phy1"       */
+    AW_MOD_CLK_USBPHY2,     /* "usb_phy2"       */
+    AW_MOD_CLK_USBOHCI0,    /* "usb_ohci0"      */
+    AW_MOD_CLK_USBOHCI1,    /* "usb_ohci1"      */
+    AW_MOD_CLK_GPS,         /* "com"            */
+    AW_MOD_CLK_SPI3,        /* "spi3"           */
+    AW_MOD_CLK_DEBE0,       /* "de_image0"      */
+    AW_MOD_CLK_DEBE1,       /* "de_image1"      */
+    AW_MOD_CLK_DEFE0,       /* "de_scale0"      */
+    AW_MOD_CLK_DEFE1,       /* "de_scale1"      */
+    AW_MOD_CLK_DEMIX,       /* "de_mix"         */
+    AW_MOD_CLK_LCD0CH0,     /* "lcd0_ch0"       */
+    AW_MOD_CLK_LCD1CH0,     /* "lcd1_ch0"       */
+    AW_MOD_CLK_CSIISP,      /* "csi_isp"        */
+    AW_MOD_CLK_TVD,         /* "tvd"            */
+    AW_MOD_CLK_LCD0CH1_S1,  /* "lcd0_ch1_s1"    */
+    AW_MOD_CLK_LCD0CH1_S2,  /* "lcd0_ch1_s2"    */
+    AW_MOD_CLK_LCD1CH1_S1,  /* "lcd1_ch1_s1"    */
+    AW_MOD_CLK_LCD1CH1_S2,  /* "lcd1_ch1_s2"    */
+    AW_MOD_CLK_CSI0,        /* "csi0"           */
+    AW_MOD_CLK_CSI1,        /* "csi1"           */
+    AW_MOD_CLK_VE,          /* "ve"             */
+    AW_MOD_CLK_ADDA,        /* "audio_codec"    */
+    AW_MOD_CLK_AVS,         /* "avs"            */
+    AW_MOD_CLK_ACE,         /* "ace"            */
+    AW_MOD_CLK_LVDS,        /* "lvds"           */
+    AW_MOD_CLK_HDMI,        /* "hdmi"           */
+    AW_MOD_CLK_MALI,        /* "mali"           */
+    AW_MOD_CLK_TWI0,        /* "twi0"           */
+    AW_MOD_CLK_TWI1,        /* "twi1"           */
+    AW_MOD_CLK_TWI2,        /* "twi2"           */
+    AW_MOD_CLK_CAN,         /* "can"            */
+    AW_MOD_CLK_SCR,         /* "scr"            */
+    AW_MOD_CLK_PS20,        /* "ps0"            */
+    AW_MOD_CLK_PS21,        /* "ps1"            */
+    AW_MOD_CLK_UART0,       /* "uart0"          */
+    AW_MOD_CLK_UART1,       /* "uart1"          */
+    AW_MOD_CLK_UART2,       /* "uart2"          */
+    AW_MOD_CLK_UART3,       /* "uart3"          */
+    AW_MOD_CLK_UART4,       /* "uart4"          */
+    AW_MOD_CLK_UART5,       /* "uart5"          */
+    AW_MOD_CLK_UART6,       /* "uart6"          */
+    AW_MOD_CLK_UART7,       /* "uart7"          */
+
+    /* clock gating for hang to AXI bus */
+    AW_MOD_CLK_AXI_DRAM,    /* "axi_dram"       */
+
+    /* clock gating for hang to AHB bus */
+    AW_MOD_CLK_AHB_USB0,    /* "ahb_usb0"       */
+    AW_MOD_CLK_AHB_EHCI0,   /* "ahb_ehci0"      */
+    AW_MOD_CLK_AHB_OHCI0,   /* "ahb_ohci0"      */
+    AW_MOD_CLK_AHB_SS,      /* "ahb_ss"         */
+    AW_MOD_CLK_AHB_DMA,     /* "ahb_dma"        */
+    AW_MOD_CLK_AHB_BIST,    /* "ahb_bist"       */
+    AW_MOD_CLK_AHB_SDMMC0,  /* "ahb_sdc0"       */
+    AW_MOD_CLK_AHB_SDMMC1,  /* "ahb_sdc1"       */
+    AW_MOD_CLK_AHB_SDMMC2,  /* "ahb_sdc2"       */
+    AW_MOD_CLK_AHB_SDMMC3,  /* "ahb_sdc3"       */
+    AW_MOD_CLK_AHB_MS,      /* "ahb_msc"        */
+    AW_MOD_CLK_AHB_NAND,    /* "ahb_nfc"        */
+    AW_MOD_CLK_AHB_SDRAM,   /* "ahb_sdramc"     */
+    AW_MOD_CLK_AHB_ACE,     /* "ahb_ace"        */
+    AW_MOD_CLK_AHB_EMAC,    /* "ahb_emac"       */
+    AW_MOD_CLK_AHB_TS,      /* "ahb_ts"         */
+    AW_MOD_CLK_AHB_SPI0,    /* "ahb_spi0"       */
+    AW_MOD_CLK_AHB_SPI1,    /* "ahb_spi1"       */
+    AW_MOD_CLK_AHB_SPI2,    /* "ahb_spi2"       */
+    AW_MOD_CLK_AHB_SPI3,    /* "ahb_spi3"       */
+    AW_MOD_CLK_AHB_PATA,    /* "ahb_pata"       */
+    AW_MOD_CLK_AHB_SATA,    /* "ahb_sata"       */
+    AW_MOD_CLK_AHB_GPS,     /* "ahb_com"        */
+    AW_MOD_CLK_AHB_VE,      /* "ahb_ve"         */
+    AW_MOD_CLK_AHB_TVD,     /* "ahb_tvd"        */
+    AW_MOD_CLK_AHB_TVE0,    /* "ahb_tve0"       */
+    AW_MOD_CLK_AHB_TVE1,    /* "ahb_tve1"       */
+    AW_MOD_CLK_AHB_LCD0,    /* "ahb_lcd0"       */
+    AW_MOD_CLK_AHB_LCD1,    /* "ahb_lcd1"       */
+    AW_MOD_CLK_AHB_CSI0,    /* "ahb_csi0"       */
+    AW_MOD_CLK_AHB_CSI1,    /* "ahb_csi1"       */
+    AW_MOD_CLK_AHB_HDMI,    /* "ahb_hdmi"       */
+    AW_MOD_CLK_AHB_DEBE0,   /* "ahb_de_image0"  */
+    AW_MOD_CLK_AHB_DEBE1,   /* "ahb_de_image1"  */
+    AW_MOD_CLK_AHB_DEFE0,   /* "ahb_de_scale0"  */
+    AW_MOD_CLK_AHB_DEFE1,   /* "ahb_de_scale1"  */
+    AW_MOD_CLK_AHB_MP,      /* "ahb_de_mix"     */
+    AW_MOD_CLK_AHB_MALI,    /* "ahb_mali"       */
+
+    /* clock gating for hang APB bus */
+    AW_MOD_CLK_APB_ADDA,    /* "apb_audio_codec"    */
+    AW_MOD_CLK_APB_SPDIF,   /* "apb_spdif"          */
+    AW_MOD_CLK_APB_AC97,    /* "apb_ac97"           */
+    AW_MOD_CLK_APB_I2S,     /* "apb_i2s"            */
+    AW_MOD_CLK_APB_PIO,     /* "apb_pio"            */
+    AW_MOD_CLK_APB_IR0,     /* "apb_ir0"            */
+    AW_MOD_CLK_APB_IR1,     /* "apb_ir1"            */
+    AW_MOD_CLK_APB_KEYPAD,  /* "apb_key_pad"        */
+    AW_MOD_CLK_APB_TWI0,    /* "apb_twi0"           */
+    AW_MOD_CLK_APB_TWI1,    /* "apb_twi1"           */
+    AW_MOD_CLK_APB_TWI2,    /* "apb_twi2"           */
+    AW_MOD_CLK_APB_CAN,     /* "apb_can"            */
+    AW_MOD_CLK_APB_SCR,     /* "apb_scr"            */
+    AW_MOD_CLK_APB_PS20,    /* "apb_ps0"            */
+    AW_MOD_CLK_APB_PS21,    /* "apb_ps1"            */
+    AW_MOD_CLK_APB_UART0,   /* "apb_uart0"          */
+    AW_MOD_CLK_APB_UART1,   /* "apb_uart1"          */
+    AW_MOD_CLK_APB_UART2,   /* "apb_uart2"          */
+    AW_MOD_CLK_APB_UART3,   /* "apb_uart3"          */
+    AW_MOD_CLK_APB_UART4,   /* "apb_uart4"          */
+    AW_MOD_CLK_APB_UART5,   /* "apb_uart5"          */
+    AW_MOD_CLK_APB_UART6,   /* "apb_uart6"          */
+    AW_MOD_CLK_APB_UART7,   /* "apb_uart7"          */
+
+    /* clock gating for access dram */
+    AW_MOD_CLK_SDRAM_VE,    /* "sdram_ve"           */
+    AW_MOD_CLK_SDRAM_CSI0,  /* "sdram_csi0"         */
+    AW_MOD_CLK_SDRAM_CSI1,  /* "sdram_csi1"         */
+    AW_MOD_CLK_SDRAM_TS,    /* "sdram_ts"           */
+    AW_MOD_CLK_SDRAM_TVD,   /* "sdram_tvd"          */
+    AW_MOD_CLK_SDRAM_TVE0,  /* "sdram_tve0"         */
+    AW_MOD_CLK_SDRAM_TVE1,  /* "sdram_tve1"         */
+    AW_MOD_CLK_SDRAM_DEFE0, /* "sdram_de_scale0"    */
+    AW_MOD_CLK_SDRAM_DEFE1, /* "sdram_de_scale1"    */
+    AW_MOD_CLK_SDRAM_DEBE0, /* "sdram_de_image0"    */
+    AW_MOD_CLK_SDRAM_DEBE1, /* "sdram_de_image1"    */
+    AW_MOD_CLK_SDRAM_DEMP,  /* "sdram_de_mix"       */
+    AW_MOD_CLK_SDRAM_ACE,   /* "sdram_ace"          */
+
+    AW_MOD_CLK_AHB_EHCI1,   /* "ahb_ehci1"          */
+    AW_MOD_CLK_AHB_OHCI1,   /* "ahb_ohci1"          */
+
+    AW_MOD_CLK_CNT
+
+} __aw_ccu_mod_clk_e;
+
+
+/* define handle for moduel clock   */
+typedef struct __AW_CCU_CLK
+{
+    __s32       id;     /* clock id         */
+    __s32       parent; /* parent clock id  */
+    char        *name;  /* clock name       */
+    __s32       onoff;  /* on/off status    */
+    __s32       reset;  /* reset status     */
+    __u64       rate;   /* clock rate, frequency for system clock, division for module clock */
+    __s32       hash;   /* hash value, for fast search without string compare   */
+
+}__aw_ccu_clk_t;
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_calc_hash
+*
+*Description: calculate hash value of a string;
+*
+*Arguments  : string    string whose hash value need be calculate;
+*
+*Return     : hash value
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline __s32 ccu_clk_calc_hash(char *string)
+{
+    __s32   tmpLen, i, tmpHash = 0;
+
+    if(!string)
+    {
+        return 0;
+    }
+
+    tmpLen = strlen(string);
+    for(i=0; i<tmpLen; i++)
+    {
+        tmpHash += string[i];
+    }
+
+    return tmpHash;
+}
+
+
+static inline __u64 ccu_clk_uldiv(__u64 dividend, __u32 divisior)
+{
+    __u64   tmpDiv = (__u64)divisior;
+    __u64   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return (__u32)dividend/divisior;
+    }
+
+    while(!(tmpDiv & ((__u64)1<<63)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
+
+
+__s32 aw_ccu_init(void);
+__s32 aw_ccu_exit(void);
+
+__s32 aw_ccu_get_sys_clk_cnt(void);
+__aw_ccu_clk_t *aw_ccu_get_sys_clk(__aw_ccu_sys_clk_e id);
+__aw_ccu_err_e aw_ccu_set_sys_clk(__aw_ccu_clk_t *clk);
+
+__s32 aw_ccu_get_mod_clk_cnt(void);
+__aw_ccu_clk_t *aw_ccu_get_mod_clk(__aw_ccu_mod_clk_e id);
+__aw_ccu_err_e aw_ccu_set_mod_clk(__aw_ccu_clk_t *clk);
+
+
+#endif /* #ifndef __AW_CCU_H__ */
+
diff --git a/arch/arm/mach-sun4i/include/mach/ccmu_regs.h b/arch/arm/mach-sun4i/include/mach/ccmu_regs.h
new file mode 100644
index 0000000..b4cac3d
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/ccmu_regs.h
@@ -0,0 +1,653 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/ccmu_regs.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CCMU_REGS_H__
+#define __CCMU_REGS_H__
+
+
+typedef struct ___CCMU_PLL1_CORE_REG0000
+{
+    __u32   FactorM:2;          //bit0,  PLL1 Factor M
+    __u32   SigmaEn:1;          //bit2,  Sigma-delta pattern enable
+    __u32   SigmaIn:1;          //bit3,  Sigma-delta pattern input
+    __u32   FactorK:2;          //bit4,  PLL1 factor K
+    __u32   reserved0:2;        //bit6,  reserved
+    __u32   FactorN:5;          //bit8,  PLL1 Factor N
+    __u32   LockTime:3;         //bit13, PLL1 lock timer control
+    __u32   PLLDivP:2;          //bit16, PLL1 output external divider P
+    __u32   reserved1:2;        //bit18, reserved
+    __u32   PLLBias:5;          //bit20, PLL1 bias current control
+    __u32   ExchangeEn:1;       //bit25, PLL1 exchange with PLL4 Enable
+    __u32   VCOBias:4;          //bit26, PLL1 VCO bias control
+    __u32   VCORstIn:1;         //bit30, VCO reset in
+    __u32   PLLEn:1;            //bit31, 0-disable, 1-enable, (24Mhz*N*K)/(M*P)
+
+} __ccmu_pll1_core_reg0000_t;
+
+typedef struct __CCMU_PLL1_TUNING_REG0004
+{
+    __u32   reserved0:16;       //bit0,  reserved for verify
+    __u32   InitFreq:7;         //bit16, PLL1 initial frequency control
+    __u32   VCOGain:1;          //bit26, VCO Gain Control Enable
+    __u32   BandWidth:1;        //bit27, PLL1 band width control
+    __u32   DampFactor:4;       //bit28, PLL1 damping factor control
+} __ccmu_pll1_tuning_reg0004_t;
+
+
+typedef struct __CCMU_PLL2_AUDIO_REG0008
+{
+    __u32   VCOBias:5;          //bit0,  PLL2 VCO bias current
+    __u32   reserved0:3;        //bit5,  reserved
+    __u32   FactorN:7;          //bit8,  PLL2 factor N
+    __u32   reserved1:1;        //bit15, reserved
+    __u32   PLLBias:5;          //bit16, PLL2 bias current
+    __u32   reserved2:7;        //bit21, reserved
+    __u32   SigmaOut:1;         //bit28, PLL2 sigma delta output
+    __u32   reserved3:2;        //bit29, reserved
+    __u32   PLLEn:1;            //bit31, PLL2 enable
+} __ccmu_pll2_audio_reg0008_t;
+
+
+typedef struct __CCMU_PLL2_TUNING_REG000C
+{
+    __u32   WaveBottom:17;      //bit0,  wave bottom
+    __u32   Frequency:2;        //bit17, frequency, 00-31.5k, 01-32k, 10-32.5k, 11-33k
+    __u32   reserved0:1;        //bit19, reserved
+    __u32   WaveStep:9;         //bit20, wave step
+    __u32   FreqMode:2;         //bit29, Spred frequency mode
+    __u32   SigmaEn:1;          //bit31, Sigma-delta pattern enable
+
+} __ccmu_pll2_tuning_reg000c_t;
+
+
+typedef struct __CCMU_PLL3_VIDEO_REG0010
+{
+    __u32   FactorM:7;          //bit0,  PLL3 FactorM, 9<= M <=127
+    __u32   reserved0:1;        //bit7,  reserved
+    __u32   PLLBias:5;          //bit8,  PLL3 bias control
+    __u32   reserved1:1;        //bit13, reserved
+    __u32   FracSet:1;          //bit14, PLL3 fractional setting, 0-270Mhz, 1-297Mhz
+    __u32   ModeSel:1;          //bit15, PLL3 mode select
+    __u32   VCOBias:5;          //bit16, PLL3 VCO Bias control
+    __u32   reserved2:3;        //bit21, reserved
+    __u32   DampFactor:3;       //bit24, PLL3 damping factor controlf
+    __u32   reserved3:4;        //bit27, reserved
+    __u32   PLLEn:1;            //bit31, PLL3 enable
+} __ccmu_pll3_video_reg0010_t;
+
+
+typedef struct __CCMU_PLL4_VE_REG0018
+{
+    __u32   FactorM:2;          //bit0,  PLL4 factor M
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   FactorK:2;          //bit4,  PLL4 factor K
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   FactorN:5;          //bit8,  PLL4 factor N
+    __u32   reserved2:2;        //bit13, reserved
+    __u32   PllSwitch:1;        //bit15, PLL4 switch, 0-PLL4 source is PLL4, 1-PLL4 source is PLL6
+    __u32   FactorP:2;          //bit16, PLL4 output external divider P
+    __u32   reserved3:1;        //bit18, reserved
+    __u32   VCOGain:1;          //bit19, PLL4 VCO gain control
+    __u32   PLLBias:5;          //bit20, PLL4 Bias control
+    __u32   VCOBias:5;          //bit25, PLL4 VCO bias control
+    __u32   PLLBypass:1;        //bit30, PLL4 output bypass enable
+    __u32   PLLEn:1;            //bit31, PLL4 Enable, 24MHz*N*K/(M*P)
+} __ccmu_pll4_ve_reg0018_t;
+
+
+typedef struct __CCMU_PLL5_DDR_REG0020
+{
+    __u32   FactorM:2;          //bit0,  PLL5 factor M
+    __u32   FactorM1:2;         //bit3,  PLL5 factor M1
+    __u32   FactorK:2;          //bit4,  PLL5 factor K
+    __u32   reserved0:1;        //bit6,  reserved
+    __u32   LDO2En:1;           //bit7,  LDO2 enable
+    __u32   FactorN:5;          //bit8,  PLL5 factor N
+    __u32   VCOGain:3;          //bit13, PLL5 VCO gain control
+    __u32   FactorP:2;          //bit16, PLL5 output external divider P
+    __u32   BandWidth:1;        //bit18, PLL5 band width control, 0-narrow, 1-wide
+    __u32   VCOGainEn:1;        //bit19, PLL5 VCO gain control enable
+    __u32   PLLBias:5;          //bit20, PLL5 bias current control
+    __u32   VCOBias:4;          //bit25, PLL5 VCO bias
+    __u32   OutputEn:1;         //bit29, DDR clock output enable
+    __u32   PLLBypass:1;        //bit30, PLL5 output bypass enable
+    __u32   PLLEn:1;            //bit31, PLL5 Enable
+} __ccmu_pll5_ddr_reg0020_t;
+
+
+typedef struct __CCMU_PLL5_TUNING_REG0024
+{
+    __u32   reserved0:16;       //bit0,  reserved for verify
+    __u32   InitFreq:7;         //bit16, PLL5 initial frequency control
+    __u32   VCORstIn:1;         //bit23, VCO reset in
+    __u32   LockTime:3;         //bit24, PLL5 lock time control
+    __u32   reserved1:1;        //bit27, reserved
+    __u32   Vreg1OutEn:1;       //bit28, vreg1 out enable
+    __u32   DampFactor:3;       //bit29, PLL5 damping factor control
+} __ccmu_pll5_tuning_reg0024_t;
+
+typedef struct __CCMU_PLL6_SATA_REG0028
+{
+    __u32   FactorM:2;          //bit0,  PLL6 factor M
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   FactorK:2;          //bit4,  PLL6 factor K
+    __u32   DampFactor:2;       //bit6,  PLL6 damping factor control
+    __u32   FactorN:5;          //bit8,  PLL6 factor N
+    __u32   reserved1:1;        //bit13, reserved
+    __u32   OutputEn:1;         //bit14, sata clock output enable
+    __u32   BandWidth:1;        //bit15, PLL6 band width control
+    __u32   reserved2:4;        //bit16, reserved
+    __u32   PLLBias:5;          //bit20, PLL6 bias current control
+    __u32   VCOBias:5;          //bit25, PLL6 VCO bias
+    __u32   PLLBypass:1;        //bit30, PLL6 output bypass enable
+    __u32   PLLEn:1;            //bit31, PLL6 enable
+} __ccmu_pll6_sata_reg0028_t;
+
+
+typedef struct __CCMU_PLL7_VIDEO1_REG0030
+{
+    __u32   FactorM:7;          //bit0,  PLL7 factor M
+    __u32   reserved0:1;        //bit7,  reserved
+    __u32   PLLBias:5;          //bit8,  PLL7 bias control
+    __u32   reserved1:1;        //bit13, reserved
+    __u32   FracSet:1;          //bit14, PLL7 fractional setting, 0-270Mhz, 1-297Mhz
+    __u32   ModeSel:1;          //bit15, PLL7 mode select, 0-integer, 1-fractional
+    __u32   VCOBias:5;          //bit16, PLL7 bias control
+    __u32   reserved2:3;        //bit21, reserved
+    __u32   DampFactor:3;       //bit24, PLL7 damping factor control
+    __u32   reserved3:4;        //bit27, reserved
+    __u32   PLLEn:1;            //bit31, PLL7 enable
+} __ccmu_pll7_video1_reg0030_t;
+
+
+typedef struct __CCMU_PLL1_TUNING2_REG0038
+{
+    __u32   WaveBottom:17;      //bit0,  Wave bottom
+    __u32   Frequency:2;        //bit17, frequency, 00-31.5khz, 01-32khz, 10-32.5khz, 11-33khz
+    __u32   reserved0:1;        //bit19, reserved
+    __u32   WaveStep:9;         //bit20, Wave step
+    __u32   FreqMode:2;         //bit29, Spread frequency mode
+    __u32   SigmaEn:1;          //bit31, Sigma-delta pattern enable
+} __ccmu_pll1_tuning2_reg0038_t;
+
+
+typedef struct __CCMU_PLL5_TUNING2_REG003C
+{
+    __u32   WaveBottom:17;      //bit0,  wave bottom
+    __u32   Frequency:2;        //bit17, frequency, 00-31.5khz, 01-32khz, 10-32.5khz, 11-33khz
+    __u32   reserved0:1;        //bit19, reserved
+    __u32   WaveStep:9;         //bit20, wave step
+    __u32   FreqMode:2;         //bit29, Spread frequency mode
+    __u32   SigmaEn:1;          //bit31, sigma-delta pattern enable
+} __ccmu_pll5_tuning2_reg003c_t;
+
+
+typedef struct __CCMU_OSC24M_REG0050
+{
+    __u32   OSC24MEn:1;         //bit0,  OSC24M enable
+    __u32   OSC24MGsm:1;        //bit1,  OSC24M GSM
+    __u32   reserved0:13;       //bit2,  reserved
+    __u32   PLLBiasEn:1;        //bit15, PLL bias enable
+    __u32   LDOEn:1;            //bit16, LDO enable
+    __u32   PLLInPower:1;       //bit17, PLL intput power select, 0-2.5v, 1-3.3v
+    __u32   LDOOutput:3;        //bit18, LDO output control, 100-1.25v for ex.
+    __u32   KeyField:11;        //bit21, key field for LDO enable, 0x538, bit24~bit31 is valid, but "strb" will do nothing
+} __ccmu_osc24m_reg0050_t;
+
+
+typedef struct __CCMU_SYSCLK_RATIO_REG0054
+{
+    __u32   AXIClkDiv:2;        //bit0,  AXI clock divide ratio, 00-1, 01-2, 10-3, 11-4
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   AHBClkDiv:2;        //bit4,  AHB clock divide ration, AHB clock source is AXI clock, 00-1, 01-2, 10-4, 11-8
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   APB0ClkDiv:2;       //bit8,  APB0 clock divide ratio, APB0 clock source is AHB, 00-2, 01-2, 10-4, 11-8
+    __u32   reserved2:6;        //bit10, reserved
+    __u32   AC328ClkSrc:2;      //bit16, AC328 clock source select, 00-LOSC, 01-HOSC, 10-PLL, 11-200M
+    __u32   reserved3:14;       //bit18, reserved
+} __ccmu_sysclkl_ratio_reg0054_t;
+
+typedef struct __CCMU_APB1CLK_RATIO_REG0058
+{
+    __u32   ClkDiv:5;           //bit0,  clock divide ratio, diveded by (m+1), 1~32 ex.
+    __u32   reserved0:11;       //bit5,  reserved
+    __u32   PreDiv:2;           //bit16, clock pre-divide ratio, pre-devided by 2^, 1/2/4/8 ex.
+    __u32   reserved1:6;        //bit18, reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-HOSC, 01-PLL6, 10-LOSC, 11-reserved
+    __u32   reserved2:6;        //bit26, reserved
+} __ccmu_apb1clk_ratio_reg0058_t;
+
+
+typedef struct __CCMU_AXICLK_GATE_REG005c
+{
+    __u32   SdramGate:1;        //bit0,  gating AXI clock for SDRAM, 0-mask, 1-pass
+    __u32   reserved0:31;       //bit1,  reserved
+} __ccmu_axiclk_gate_reg005c_t;
+
+
+typedef struct __CCMU_AHBCLK_GATE0_REG0060
+{
+    __u32   Usb0Gate:1;         //bit0,  gating AHB clock for USB0, 0-mask, 1-pass
+    __u32   Ehci0Gate:1;        //bit1,  gating AHB clock for EHCI0, 0-mask, 1-pass
+    __u32   Ohci0Gate:1;        //bit2,  gating AHB clock for OHCI0, 0-mask, 1-pass
+    __u32   Ehci1Gate:1;        //bit3,  gating AHB clock for EHCI1, 0-mask, 1-pass
+    __u32   Ohci1Gate:1;        //bit4,  gating AHB clock for OHCI1, 0-mask, 1-pass
+    __u32   SsGate:1;           //bit5,  gating AHB clock for SS, 0-mask, 1-pass
+    __u32   DmaGate:1;          //bit6,  gating AHB clock for DMA, 0-mask, 1-pass
+    __u32   BistGate:1;         //bit7,  gating AHB clock for BIST, 0-mask, 1-pass
+    __u32   Sdmmc0Gate:1;       //bit8,  gating AHB clock for SD/MMC0, 0-mask, 1-pass
+    __u32   Sdmmc1Gate:1;       //bit9,  gating AHB clock for SD/MMC1, 0-mask, 1-pass
+    __u32   Sdmmc2Gate:1;       //bit10, gating AHB clock for SD/MMC2, 0-mask, 1-pass
+    __u32   Sdmmc3Gate:1;       //bit11, gating AHB clock for SD/MMC3, 0-mask, 1-pass
+    __u32   MsGate:1;           //bit12, gating AHB clock for MS, 0-mask, 1-pass
+    __u32   NandGate:1;         //bit13, gating AHB clock for NAND, 0-mask, 1-pass
+    __u32   SdramGate:1;        //bit14, gating AHB clock for SDRAM, 0-mask, 1-pass
+    __u32   reserved2:1;        //bit15, reserved
+    __u32   AceGate:1;          //bit16, gating AHB clock for ACE, 0-mask, 1-pass
+    __u32   EmacGate:1;         //bit17, gating AHB clock for EMAC, 0-mask, 1-pass
+    __u32   TsGate:1;           //bit18, gating AHB clock for TS, 0-mask, 1-pass
+    __u32   reserved3:1;        //bit19, reserved
+    __u32   Spi0Gate:1;         //bit20, gating AHB clock for SPI0, 0-mask, 1-pass
+    __u32   Spi1Gate:1;         //bit21, gating AHB clock for SPI1, 0-mask, 1-pass
+    __u32   Spi2Gate:1;         //bit22, gating AHB clock for SPI2, 0-mask, 1-pass
+    __u32   Spi3Gate:1;         //bit23, gating AHB clock for SPI3, 0-mask, 1-pass
+    __u32   PataGate:1;         //bit24, gating AHB clock for PATA, 0-mask, 1-pass
+    __u32   SataGate:1;         //bit25, gating AHB clock for SATA, 0-mask, 1-pass
+    __u32   GpsGate:1;          //bit26, gating AHB clock for GPS, 0-mask, 1-pass
+    __u32   reserved4:5;        //bit27, reserved
+} __ccmu_ahbclk_gate0_reg0060_t;
+
+
+typedef struct __CCMU_AHBCLK_GATE1_REG0064
+{
+    __u32   VeGate:1;           //bit0,  gating AHB clock for VE, 0-mask, 1-pass
+    __u32   TvdGate:1;          //bit1,  gating AHB clock for TVD, 0-mask, 1-pass
+    __u32   Tve0Gate:1;         //bit2,  gating AHB clock for TVE0, 0-mask, 1-pass
+    __u32   Tve1Gate:1;         //bit3,  gating AHB clock for TVE1, 0-mask, 1-pass
+    __u32   Lcd0Gate:1;         //bit4,  gating AHB clock for LCD0, 0-mask, 1-pass
+    __u32   Lcd1Gate:1;         //bit5,  gating AHB clock for LCD1, 0-mask, 1-pass
+    __u32   reserved0:2;        //bit6,  reserved
+    __u32   Csi0Gate:1;         //bit8,  gating AHB clock for CSI0, 0-mask, 1-pass
+    __u32   Csi1Gate:1;         //bit9,  gating AHB clock for CSI1, 0-mask, 1-pass
+    __u32   reserved1:1;        //bit10, reserved
+    __u32   HdmiDGate:1;        //bit11, gating AHB clock for HDMI, 0-mask, 1-pass
+    __u32   DeBe0Gate:1;        //bit12, gating AHB clock for DE-BE0, 0-mask, 1-pass
+    __u32   DeBe1Gate:1;        //bit13, gating AHB clock for DE-BE1, 0-mask, 1-pass
+    __u32   DeFe0Gate:1;        //bit14, gating AHB clock for DE-FE0, 0-mask, 1-pass
+    __u32   DeFe1Gate:1;        //bit15, gating AHB clock for DE-FE1, 0-mask, 1-pass
+    __u32   reserved2:2;        //bit16, reserved
+    __u32   MpGate:1;           //bit18, gating AHB clock for MP, 0-mask, 1-pass
+    __u32   reserved3:1;        //bit19, reserved
+    __u32   Gpu3DGate:1;        //bit20, gating AHB clock for GPU-3D, 0-mask, 1-pass
+    __u32   reserved4:11;       //bit21, reserved
+} __ccmu_ahbclk_gate1_reg0064_t;
+
+
+typedef struct __CCMU_APB0CLK_GATE_REG0068
+{
+    __u32   AddaGate:1;         //bit0,  gating APB clock for audio codec, 0-mask, 1-pass
+    __u32   SpdifGate:1;        //bit1,  gating APB clock for SPDIF, 0-mask, 1-pass
+    __u32   Ac97Gate:1;         //bit2,  gating APB clock for AC97, 0-mask, 1-pass
+    __u32   IisGate:1;          //bit3,  gating APB clock for IIS, 0-mask, 1-pass
+    __u32   reserved0:1;        //bit4,  reserved
+    __u32   PioGate:1;          //bit5,  gating APB clock for PIO, 0-mask, 1-pass
+    __u32   Ir0Gate:1;          //bit6,  gating APB clock for IR0, 0-mask, 1-pass
+    __u32   Ir1Gate:1;          //bit7,  gating APB clock for IR1, 0-mask, 1-pass
+    __u32   reserved1:2;        //bit8,  reserved
+    __u32   KeypadGate:1;       //bit10, gating APB clock for keypad, 0-mask, 1-pass
+    __u32   reserved2:21;       //bit11, reserved
+} __ccmu_apb0clk_gate_reg0068_t;
+
+
+typedef struct __CCMU_APB1CLK_GATE_REG006C
+{
+    __u32   Twi0Gate:1;         //bit0,  gating APB clock for TWI0, 0-mask, 1-pass
+    __u32   Twi1Gate:1;         //bit1,  gating APB clock for TWI1, 0-mask, 1-pass
+    __u32   Twi2Gate:1;         //bit2,  gating APB clock for TWI2, 0-mask, 1-pass
+    __u32   reserved0:1;        //bit3,  reserved
+    __u32   CanGate:1;          //bit4,  gating APB clock for CAN, 0-mask, 1-pass
+    __u32   ScrGate:1;          //bit5,  gating APB clock for SCR, 0-mask, 1-pass
+    __u32   Ps20Gate:1;         //bit6,  gating APB clock for PS2-0, 0-mask, 1-pass
+    __u32   Ps21Gate:1;         //bit7,  gating APB clock for PS2-1, 0-mask, 1-pass
+    __u32   reserved1:8;        //bit8,  reserved
+    __u32   Uart0Gate:1;        //bit16, gating APB clock for UART0, 0-mask, 1-pass
+    __u32   Uart1Gate:1;        //bit17, gating APB clock for UART1, 0-mask, 1-pass
+    __u32   Uart2Gate:1;        //bit18, gating APB clock for UART2, 0-mask, 1-pass
+    __u32   Uart3Gate:1;        //bit19, gating APB clock for UART3, 0-mask, 1-pass
+    __u32   Uart4Gate:1;        //bit20, gating APB clock for UART4, 0-mask, 1-pass
+    __u32   Uart5Gate:1;        //bit21, gating APB clock for UART5, 0-mask, 1-pass
+    __u32   Uart6Gate:1;        //bit22, gating APB clock for UART6, 0-mask, 1-pass
+    __u32   Uart7Gate:1;        //bit23, gating APB clock for UART7, 0-mask, 1-pass
+    __u32   reserved2:8;        //bit24, reserved
+} __ccmu_apb1clk_gate_reg006c_t;
+
+
+/* module clock type 0, used for NAND, MS, SDMMC0/1/2/3, TS, SS, SPI0/1/2/3, PATA, IR0/1, */
+/* register address is 0x0080~0x00B4, 0x00D4 */
+typedef struct __CCMU_MODULE0_CLK
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:12;       //bit4,  reserved
+    __u32   ClkPreDiv:2;        //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex.
+    __u32   reserved1:6;        //bit18, reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-HOSC, 01-PLL6, 10-PLL5, 11-reserved
+    __u32   reserved2:5;        //bit26, reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_module0_clk_t;
+
+
+/* module clock type 1, used for IIS, AC97, SPDIF*/
+/* register address is 0x00B8~0x00C0 */
+typedef struct __CCMU_MODULE1_CLK
+{
+    __u32   reserved0:16;       //bit0,  reserved
+    __u32   ClkDiv:2;           //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex. source is 8xPLL2
+    __u32   reserved1:13;       //bit18, reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+
+} __ccmu_module1_clk_t;
+
+
+typedef struct __CCMU_KEYPAD_CLK_REG00C4
+{
+    __u32   ClkDiv:5;           //bit0,  clock divide ratio
+    __u32   reserved0:11;       //bit5,  reserved
+    __u32   ClkPreDiv:2;        //bit16, clock pre-divide ratio, pre-divided by 2^n, 1/2/4/8 ex.
+    __u32   reserved1:6;        //bit18, reserved
+    __u32   ClkSrc:2;           //bit24, clock select, 00-HOSC, 01-reserved, 10-LOSC, 11-reserved
+    __u32   reserved2:5;        //bit26, reserved
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_keypad_clk_reg00c4_t;
+
+
+typedef struct __CCMU_SATA_CLK_REG00C8
+{
+    __u32   reserved0:24;       //bit0,  reserved
+    __u32   ClkSrc:1;           //bit24, Clock source select, 0-PLL6, 1-External clock
+    __u32   reserved1:6;        //bit25, reserved
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_sata_clk_reg00c8_t;
+
+
+typedef struct __CCMU_USB_CLK_REG00CC
+{
+    __u32   UsbPhy0Rst:1;       //bit0,  USB PHY0 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy1Rst:1;       //bit1,  USB PHY1 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy2Rst:1;       //bit2,  USB PHY2 reset control, 0-reset valid, 1-reset invalid
+    __u32   reserved0:1;        //bit3,  reserved
+    __u32   OHCIClkSrc:1;       //bit4,  0-(PLL6)/25, 1-PLL6 sample 24Mhz to generate 48Mhz
+    __u32   ClkSwich:1;         //bit5,  usb clock switch
+    __u32   OHCI0SpecClkGate:1; //bit6,  gating special clock for OHCI0, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   OHCI1SpecClkGate:1; //bit7,  gating special clock for OHCI1, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   PhySpecClkGate:1;   //bit8,  gating special clock for USB PHY0/1/2, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   reserved2:23;       //bit9,  reserved
+} __ccmu_usb_clk_reg00cc_t;
+
+
+typedef struct __CCMU_GPS_CLK_REG00D0
+{
+    __u32   Reset:1;            //bit0,  GPS reset control, clock source for GPS is AHB clock
+    __u32   SpecClkGate:1;      //bit1,  gating special clock for GPS, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   reserved:30;        //bit2,  reserved
+} __ccmu_gps_clk_reg00d0_t;
+
+
+typedef struct __CCMU_DRAM_GATE_REG0100
+{
+    __u32   VeGate:1;           //bit0,  Gating dram clock for VE, 0-mask, 1-pass
+    __u32   Csi0Gate:1;         //bit1,  Gating dram clock for CSI0, 0-mask, 1-pass
+    __u32   Csi1Gate:1;         //bit2,  Gating dram clock for CSI1, 0-mask, 1-pass
+    __u32   TsGate:1;           //bit3,  Gating dram clock for TS, 0-mask, 1-pass
+    __u32   TvdGate:1;          //bit4,  Gating dram clock for TVD, 0-mask, 1-pass
+    __u32   Tve0Gate:1;         //bit5,  Gating dram clock for TVE0, 0-mask, 1-pass
+    __u32   Tve1Gate:1;         //bit6,  Gating dram clock for TVE1, 0-mask, 1-pass
+    __u32   reserved0:8;        //bit7,  reserved
+    __u32   ClkOutputEn:1;      //bit15, DRAM clock output enable, 0-disable, 1-enable
+    __u32   reserved1:8;        //bit16, reserved
+    __u32   DeFe1Gate:1;        //bit24, Gating dram clock for DE_FE1, 0-mask, 1-pass
+    __u32   DeFe0Gate:1;        //bit25, Gating dram clock for DE_FE0, 0-mask, 1-pass
+    __u32   DeBe0Gate:1;        //bit26, Gating dram clock for DE_BE0, 0-mask, 1-pass
+    __u32   DeBe1Gate:1;        //bit27, Gating dram clock for DE_BE1, 0-mask, 1-pass
+    __u32   DeMpGate:1;         //bit28, Gating dram clock for DE_MP, 0-mask, 1-pass
+    __u32   AceGate:1;          //bit29, Gating dram clock for ACE, 0-mask, 1-pass
+    __u32   reserved2:2;        //bit30, reserved
+} __ccmu_dram_gate_reg0100_t;
+
+
+/* FEBEMP module clock type, used for DE-BE0, DE-BE1, DE-FE0, DE-FE1, DE-MP */
+/* register address is 0x0104~0x0114 */
+typedef struct __CCMU_FEDEMP_CLK
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divied by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-PLL3, 01-PLL7, 10-PLL5, 11-reserved
+    __u32   reserved1:4;        //bit26, reserved
+    __u32   Reset:1;            //bit30, module reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-clock off, 1-clock on
+
+} __ccmu_fedemp_clk_t;
+
+
+/* LCDCH0 module clock type, used for LCD0_CH0, LCD1_CH0 */
+/* register address is 0x0118~0x011C */
+typedef struct __CCMU_LCDCH0_CLK
+{
+    __u32   reserved0:24;       //bit0,  reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved1:4;        //bit26, reserved
+    __u32   Reset:1;            //bit30, module reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-clock off, 1-clock on
+
+} __ccmu_lcdch0_clk_t;
+
+
+typedef struct __CCMU_CSIISP_CLK_REG0120
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:2;           //bit24, special clock2 source select, 00-PLL3(1x), 01-PLL4, 10-PLL5, 11-PLL6
+    __u32   reserved1:5;        //bit26, reserved
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_csiisp_clk_reg0120_t;
+
+typedef struct __CCMU_TVD_CLK_REG0128
+{
+    __u32   reserved0:24;       //bit0,  reserved
+    __u32   ClkSrc:1;           //bit24, clock source select, 0-PLL3, 1-PLL7
+    __u32   reserved1:6;        //bit25, reserved
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_tvd_clk_reg0128_t;
+
+
+/* LCD-CH1 module clock type, used for LCD0_CH1, LCD1_CH1 */
+/* register address is 0x012C~0x0130 */
+typedef struct __CCMU_LCDCH1_CLK
+{
+    __u32   ClkDiv:4;           //bit0,  clock division
+    __u32   reserved0:7;        //bit4,  reserved
+    __u32   SpecClk1Src:1;      //bit11, special clock 1 source select, 0-special clock2,
+    __u32   reserved1:3;        //bit12, reserved
+    __u32   SpecClk1Gate:1;     //bit15, gating special clock1, 0-clock off, 1-clock on
+    __u32   reserved2:8;        //bit16, reserved
+    __u32   SpecClk2Src:2;      //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved3:5;        //bit26, reserved
+    __u32   SpecClk2Gate:1;     //bit31, gating special clock2, 0-clock off, 1-clock on
+
+} __ccmu_lcdch1_clk_t;
+
+
+/* CSI module clock type, used for CSI0/1 */
+/* register address is 0x0134~0x0138 */
+typedef struct __CCMU_CSI_CLK
+{
+    __u32   ClkDiv:5;           //bit0,  clock divide ratio, divided by (m+1), 1~32, ex.
+    __u32   reserved0:19;       //bit5,  reserved
+    __u32   ClkSrc:3;           //bit24, clock source select, 000-HOSC, 001-PLL3(1x), 010-PLL7(1x), 011/100/111-reserved, 101-PLL3(2x), 110:PLL7(2x)
+    __u32   reserved1:3;        //bit27, reserved
+    __u32   Reset:1;            //bit30, CSI reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_csi_clk_t;
+
+
+typedef struct __CCMU_VE_CLK_REG013C
+{
+    __u32   Reset:1;            //bit0,  VE reset, 0-reset valid, 1-reset invalid
+    __u32   reserved0:15;       //bit1,  reserved
+    __u32   ClkDiv:3;           //bit16, Clock pre-divide ratio, divided by (n+1), 1~8 ex.
+    __u32   reserved1:12;       //bit19, reserved
+    __u32   SpecClkGate:1;      //bit31, gating special clock for VE, 0-mask, 1-pass
+}__ccmu_ve_clk_reg013c_t;
+
+typedef struct __CCMU_ADDA_CLK_REG0140
+{
+    __u32   reserved0:31;       //bit0,  reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_adda_clk_reg0140_t;
+
+typedef struct __CCMU_AVS_CLK_REG0144
+{
+    __u32   reserved0:31;       //bit0,  reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_avs_clk_reg0144_t;
+
+
+typedef struct __CCMU_ACE_CLK_REG0148
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:12;       //bit4,  reserved
+    __u32   Reset:1;            //bit16, ACE reset, 0-reset valid, 1-reset invalid
+    __u32   reserved1:7;        //bit17, reserved
+    __u32   ClkSrc:1;           //bit24, Clock source select, 0-PLL4, 1-PLL5
+    __u32   reserved2:6;        //bit25, reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_ace_clk_reg0148_t;
+
+
+typedef struct __CCMU_LVDS_CLK_REG014C
+{
+    __u32   Reset:1;            //bit0,  LVDS reset
+    __u32   reserved:31;        //bit1,  reserved
+} __ccmu_lvds_clk_reg014c_t;
+
+
+typedef struct __CCMU_HDMI_CLK_REG0150
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved1:5;        //bit26, reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_hdmi_clk_reg0150_t;
+
+
+typedef struct __CCMU_MALI400_CLK_REG0154
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:2;           //bit24, clolck source select, 00-PLL3, 01-PLL4, 10-PLL5, 11-PLL7
+    __u32   reserved1:4;        //bit26, reserved
+    __u32   Reset:1;            //bit30, Mali400 reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_mali400_clk_reg0154_t;
+
+
+
+typedef struct __CCMU_REG_LIST
+{
+    volatile __ccmu_pll1_core_reg0000_t     Pll1Ctl;    //0x0000, PLL1 control
+    volatile __ccmu_pll1_tuning_reg0004_t   Pll1Tune;   //0x0004, PLL1 tuning
+    volatile __ccmu_pll2_audio_reg0008_t    Pll2Ctl;    //0x0008, PLL2 control
+    volatile __ccmu_pll2_tuning_reg000c_t   Pll2Tune;   //0x000C, PLL2 tuning
+    volatile __ccmu_pll3_video_reg0010_t    Pll3Ctl;    //0x0010, PLL3 control
+    volatile __u32                          Pll3Tune;   //0x0014, PLL3 tuning
+    volatile __ccmu_pll4_ve_reg0018_t       Pll4Ctl;    //0x0018, PLL4 control
+    volatile __u32                          Pll4Tune;   //0x001C, PLL4 tuning
+    volatile __ccmu_pll5_ddr_reg0020_t      Pll5Ctl;    //0x0020, PLL5 control
+    volatile __ccmu_pll5_tuning_reg0024_t   Pll5Tune;   //0x0024, PLL5 tuning
+    volatile __ccmu_pll6_sata_reg0028_t     Pll6Ctl;    //0x0028, PLL6 control
+    volatile __u32                          Pll6Tune;   //0x002C, PLL6 tuning
+    volatile __ccmu_pll7_video1_reg0030_t   Pll7Ctl;    //0x0030, Pll7 control
+    volatile __u32                          Pll7Tune;   //0x0034, Pll7 tuning
+    volatile __ccmu_pll1_tuning2_reg0038_t  Pll1Tune2;  //0x0038, Pll1 tuning2
+    volatile __ccmu_pll5_tuning2_reg003c_t  Pll5Tune2;  //0x003C, Pll5 tuning2
+    volatile __u32                          reserved[4];//0x0040, reserved
+    volatile __ccmu_osc24m_reg0050_t        HoscCtl;    //0x0050, OSC24M control
+    volatile __ccmu_sysclkl_ratio_reg0054_t SysClkDiv;  //0x0054, AC328/AHB/APB0 divide ratio
+    volatile __ccmu_apb1clk_ratio_reg0058_t Apb1ClkDiv; //0x0058, APB1 clock dividor
+    volatile __ccmu_axiclk_gate_reg005c_t   AxiGate;    //0x005C, AXI module clock gating
+    volatile __ccmu_ahbclk_gate0_reg0060_t  AhbGate0;   //0x0060, AHB module clock gating 0
+    volatile __ccmu_ahbclk_gate1_reg0064_t  AhbGate1;   //0x0064, AHB module clock gating 1
+    volatile __ccmu_apb0clk_gate_reg0068_t  Apb0Gate;   //0x0068, APB0 module clock gating
+    volatile __ccmu_apb1clk_gate_reg006c_t  Apb1Gate;   //0x006C, APB1 module clock gating
+    volatile __u32                          reserved1[4];   //0x0070, reserved
+    volatile __ccmu_module0_clk_t           NandClk;    //0x0080, nand module clock control
+    volatile __ccmu_module0_clk_t           MsClk;      //0x0084, MS module clock control
+    volatile __ccmu_module0_clk_t           SdMmc0Clk;  //0x0088, SD/MMC0 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc1Clk;  //0x008C, SD/MMC1 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc2Clk;  //0x0090, SD/MMC2 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc3Clk;  //0x0094, SD/MMC3 module clock control
+    volatile __ccmu_module0_clk_t           TsClk;      //0x0098, TS module clock control
+    volatile __ccmu_module0_clk_t           SsClk;      //0x009C, SS module clock control
+    volatile __ccmu_module0_clk_t           Spi0Clk;    //0x00A0, SPI0 module clock control
+    volatile __ccmu_module0_clk_t           Spi1Clk;    //0x00A4, SPI1 module clock control
+    volatile __ccmu_module0_clk_t           Spi2Clk;    //0x00A8, SPI2 module clock control
+    volatile __ccmu_module0_clk_t           PataClk;    //0x00AC, PATA module clock control
+    volatile __ccmu_module0_clk_t           Ir0Clk;     //0x00B0, IR0 module clock control
+    volatile __ccmu_module0_clk_t           Ir1Clk;     //0x00B4, IR1 module clock control
+    volatile __ccmu_module1_clk_t           I2sClk;     //0x00B8, IIS module clock control
+    volatile __ccmu_module1_clk_t           Ac97Clk;    //0x00BC, AC97 module clock control
+    volatile __ccmu_module1_clk_t           SpdifClk;   //0x00C0, SPDIF module clock control
+    volatile __ccmu_keypad_clk_reg00c4_t    KeyPadClk;  //0x00C4, KEYPAD module clock control
+    volatile __ccmu_sata_clk_reg00c8_t      SataClk;    //0x00C8, SATA module clock control
+    volatile __ccmu_usb_clk_reg00cc_t       UsbClk;     //0x00CC, USB module clock control
+    volatile __ccmu_gps_clk_reg00d0_t       GpsClk;     //0x00D0, GPS module clock control
+    volatile __ccmu_module0_clk_t           Spi3Clk;    //0x00D4, SPI3 module clock control
+    volatile __u32                          reserved2[10];  //0x00D8, reserved
+    volatile __ccmu_dram_gate_reg0100_t     DramGate;   //0x0100, DRAM gating
+    volatile __ccmu_fedemp_clk_t            DeBe0Clk;   //0x0104, DE-BE 0 module clock control
+    volatile __ccmu_fedemp_clk_t            DeBe1Clk;   //0x0108, DE-BE 1 module clock control
+    volatile __ccmu_fedemp_clk_t            DeFe0Clk;   //0x010C, DE-FE 0 module clock control
+    volatile __ccmu_fedemp_clk_t            DeFe1Clk;   //0x0110, DE-FE 1 module clock control
+    volatile __ccmu_fedemp_clk_t            DeMpClk;    //0x0114, DE-MP module clock control
+    volatile __ccmu_lcdch0_clk_t            Lcd0Ch0Clk; //0x0118, LCD0 CH0 module clock control
+    volatile __ccmu_lcdch0_clk_t            Lcd1Ch0Clk; //0x011C, LCD1 CH0 module clock control
+    volatile __ccmu_csiisp_clk_reg0120_t    CsiIspClk;  //0x0120, CSI-ISP module clock control
+    volatile __u32                          reserved3;  //0x0124, reserved
+    volatile __ccmu_tvd_clk_reg0128_t       TvdClk;     //0x0128, TVD module clock control
+    volatile __ccmu_lcdch1_clk_t            Lcd0Ch1Clk; //0x012C, LCD0 CH1 module clock control
+    volatile __ccmu_lcdch1_clk_t            Lcd1Ch1Clk; //0x0130, LCD1 CH1 module clock control
+    volatile __ccmu_csi_clk_t               Csi0Clk;    //0x0134, CSI0 module clock control
+    volatile __ccmu_csi_clk_t               Csi1Clk;    //0x0138, CSI1 module clock control
+    volatile __ccmu_ve_clk_reg013c_t        VeClk;      //0x013C, VE module clock control
+    volatile __ccmu_adda_clk_reg0140_t      AddaClk;    //0x0140, audio codec clock control
+    volatile __ccmu_avs_clk_reg0144_t       AvsClk;     //0x0144, AVS module clock control
+    volatile __ccmu_ace_clk_reg0148_t       AceClk;     //0x0148, ACE module clock control
+    volatile __ccmu_lvds_clk_reg014c_t      LvdsClk;    //0x014C, LVDS module clock control
+    volatile __ccmu_hdmi_clk_reg0150_t      HdmiClk;    //0x0150, HDMI module clock control
+    volatile __ccmu_mali400_clk_reg0154_t   MaliClk;    //0x0154, MALI400 module clock control
+
+} __ccmu_reg_list_t;
+
+
+#endif  // #ifndef __CCMU_REGS_H__
+
diff --git a/arch/arm/mach-sun4i/include/mach/clock.h b/arch/arm/mach-sun4i/include/mach/clock.h
new file mode 100644
index 0000000..3efeacd
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/clock.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/clock.h
+ */
+
+#include <plat/clock.h>
diff --git a/arch/arm/mach-sun4i/include/mach/debug-macro.S b/arch/arm/mach-sun4i/include/mach/debug-macro.S
new file mode 100644
index 0000000..d71e453
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/debug-macro.S
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/debug-macro.S
+ */
+
+#include <plat/debug-macro.S>
diff --git a/arch/arm/mach-sun4i/include/mach/dma.h b/arch/arm/mach-sun4i/include/mach/dma.h
new file mode 100644
index 0000000..2f19974
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/dma.h
@@ -0,0 +1,688 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/dma.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H __FILE__
+
+#include <linux/device.h>
+#include <mach/hardware.h>
+
+
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#define DMA_CH_VALID		(1<<31)
+#define DMA_CH_NEVER		(1<<30)
+
+/* We use `virtual` dma channels to hide the fact we have only a limited
+ * number of DMA channels, and not of all of them (dependant on the device)
+ * can be attached to any DMA source. We therefore let the DMA core handle
+ * the allocation of hardware channels to clients.
+*/
+enum sw_dma_ch {
+	/*NDMA*/
+	DMACH_NSPI0,
+	DMACH_NSPI1,
+	DMACH_NSPI2,
+	DMACH_NSPI3,
+	DMACH_NUART0,
+	DMACH_NUART1,
+	DMACH_NUART2,
+	DMACH_NUART3,
+	DMACH_NUART4,
+	DMACH_NUART5,
+	DMACH_NUART6,
+	DMACH_NUART7,
+	DMACH_NSRAM,
+	DMACH_NSDRAM,
+	DMACH_NTPAD,
+	DMACH_NADDA_PLAY,//audio play
+	DMACH_NADDA_CAPTURE,//audio capture
+	DMACH_NIIS,
+	DMACH_NIR0,
+	DMACH_NIR1,
+	DMACH_NSPDIF,
+	DMACH_NAC97,
+	DMACH_NHDMI,//HDMI
+	/*DDMA*/
+	DMACH_DSRAM,
+	DMACH_DSDRAM,
+	DMACH_DPATA,
+	DMACH_DNAND,
+	DMACH_DUSB0,
+	DMACH_DEMACR,
+	DMACH_DEMACT,
+	DMACH_DSPI1,
+	DMACH_DSSR,
+	DMACH_DSST,
+	DMACH_TCON0,
+	DMACH_TCON1,
+	DMACH_HDMIAUDIO,//HDMIAUDIO
+	DMACH_DMS,
+	DMACH_DSPI0,
+	DMACH_DSPI2,
+	DMACH_DSPI3,
+	DMACH_MAX,/* 8 NDMAs, 8 DDMAs */
+};
+
+
+#define N_DRQSRC_SHIFT		0
+#define N_DRQDST_SHIFT		16
+#define D_DRQSRC_SHIFT		0
+#define D_DRQDST_SHIFT		16
+#define DRQ_INVALID			0xff
+
+/*normal DMA Source*/
+#define N_DRQSRC_IR0RX		0b00000
+#define N_DRQSRC_IR1RX 		0b00001
+#define N_DRQSRC_SPDIFRX	0b00010
+#define N_DRQSRC_IISRX		0b00011
+#define N_DRQSRC_AC97RX		0b00101
+#define N_DRQSRC_UART0RX	0b01000
+#define N_DRQSRC_UART1RX 	0b01001
+#define N_DRQSRC_UART2RX	0b01010
+#define N_DRQSRC_UART3RX	0b01011
+#define N_DRQSRC_UART4RX	0b01100
+#define N_DRQSRC_UART5RX	0b01101
+#define N_DRQSRC_UART6RX	0b01110
+#define N_DRQSRC_UART7RX	0b01111
+#define N_DRQSRC_HDMIDDCRX	0b10000
+#define N_DRQSRC_AUDIOCDAD	0b10011	//Audio Codec D/A
+#define N_DRQSRC_SRAM		0b10101
+#define N_DRQSRC_SDRAM		0b10110
+#define N_DRQSRC_TPAD		0b10111	//TP A/D
+#define N_DRQSRC_SPI0RX		0b11000
+#define N_DRQSRC_SPI1RX		0b11001
+#define N_DRQSRC_SPI2RX		0b11010
+#define N_DRQSRC_SPI3RX		0b11011
+
+/*normal DMA destination*/
+#define N_DRQDST_IR0TX		0b00000
+#define N_DRQDST_IR1TX 		0b00001
+#define N_DRQDST_SPDIFTX	0b00010
+#define N_DRQDST_IISTX		0b00011
+#define N_DRQDST_AC97TX		0b00101
+#define N_DRQDST_UART0TX	0b01000
+#define N_DRQDST_UART1TX 	0b01001
+#define N_DRQDST_UART2TX	0b01010
+#define N_DRQDST_UART3TX	0b01011
+#define N_DRQDST_UART4TX	0b01100
+#define N_DRQDST_UART5TX	0b01101
+#define N_DRQDST_UART6TX	0b01110
+#define N_DRQDST_UART7TX	0b01111
+#define N_DRQDST_HDMIDDCTX	0b10000	//HDMI DDC TX
+#define N_DRQDST_AUDIOCDAD	0b10011	//Audio Codec D/A
+#define N_DRQDST_SRAM		0b10101
+#define N_DRQDST_SDRAM		0b10110
+#define N_DRQDST_SPI0TX		0b11000
+#define N_DRQDST_SPI1TX		0b11001
+#define N_DRQDST_SPI2TX		0b11010
+#define N_DRQDST_SPI3TX		0b11011
+
+/*Dedicated DMA Source*/
+#define D_DRQSRC_SRAM		0b00000//0x0 SRAM memory
+#define D_DRQSRC_SDRAM		0b00001//0x1 SDRAM memory
+#define D_DRQSRC_PATA		0b00010//0x2 PATA
+#define D_DRQSRC_NAND 		0b00011//0x3 NAND Flash Controller(NFC)
+#define D_DRQSRC_USB0 		0b00100//0x4 USB0
+#define D_DRQSRC_EMACRX		0b00111//0x7 Ethernet MAC Rx
+#define D_DRQSRC_SPI1RX		0b01001//0x9 SPI1 RX
+#define D_DRQSRC_SECRX 		0b01011//0xB Security System Rx
+#define D_DRQSRC_MS 		0b10111//0x17 Memory Stick Controller(MSC)
+#define D_DRQSRC_SPI0RX		0b11011//0x1B SPI0 RX
+#define D_DRQSRC_SPI2RX		0b11101//0x1D SPI2 RX
+#define D_DRQSRC_SPI3RX		0b11111//0x1F SPI3 RX
+
+
+/*Dedicated DMA Destination*/
+#define D_DRQDST_SRAM		0b00000//0x0 SRAM memory
+#define D_DRQDST_SDRAM		0b00001//0x1 SDRAM memory
+#define D_DRQDST_PATA		0b00010//0x2 PATA
+#define D_DRQDST_NAND 		0b00011//0x3 NAND Flash Controller(NFC)
+#define D_DRQDST_USB0 		0b00100//0x4 USB0
+#define D_DRQDST_EMACTX		0b00110//0x6 Ethernet MAC Rx
+#define D_DRQDST_SPI1TX		0b01000//0x8 SPI1 RX
+#define D_DRQDST_SECTX 		0b01010//0xA Security System Rx
+#define D_DRQDST_TCON0 		0b01110//0xE TCON0
+#define D_DRQDST_TCON1 		0b01111//0xF TCON1
+#define D_DRQDST_MS			0b10111//0x17 Memory Stick Controller(MSC)
+#define D_DRQDST_HDMIAUDIO	0b11000//0x18 HDMI Audio
+#define D_DRQDST_SPI0TX		0b11010//0x1A SPI0 TX
+#define D_DRQDST_SPI2TX		0b11100//0x1C SPI2 TX
+#define D_DRQDST_SPI3TX		0b11110//0x1E SPI3 TX
+
+
+enum drq_type {
+		DRQ_TYPE_SRAM,
+		DRQ_TYPE_SDRAM,
+		DRQ_TYPE_PATA,
+		DRQ_TYPE_NAND,
+		DRQ_TYPE_USB0,
+		DRQ_TYPE_EMAC,
+		DRQ_TYPE_SPI1,
+		DRQ_TYPE_SS,//Security System
+		DRQ_TYPE_MS,//Memory Stick Control
+		DRQ_TYPE_SPI0,
+		DRQ_TYPE_SPI2,
+		DRQ_TYPE_SPI3,
+		DRQ_TYPE_TCON0,
+		DRQ_TYPE_TCON1,
+		DRQ_TYPE_HDMI,
+
+		DRQ_TYPE_HDMIAUDIO,
+		DRQ_TYPE_IR0,
+		DRQ_TYPE_IR1,
+		DRQ_TYPE_SPDIF,
+		DRQ_TYPE_IIS,
+		DRQ_TYPE_AC97,
+		DRQ_TYPE_UART0,
+		DRQ_TYPE_UART1,
+		DRQ_TYPE_UART2,
+		DRQ_TYPE_UART3,
+		DRQ_TYPE_UART4,
+		DRQ_TYPE_UART5,
+		DRQ_TYPE_UART6,
+		DRQ_TYPE_UART7,
+		DRQ_TYPE_AUDIO,
+		DRQ_TYPE_TPAD,
+		DRQ_TYPE_MAX,
+};
+
+
+/* DMAXFER_(dist)_(sigle/burst/tippl)_(byte/half/word)_(src)_(sigle/burst/tippl)_(byte/half/word) */
+#define X_SIGLE   0
+#define X_BURST   1
+#define X_TIPPL	  2
+#define X_BYTE    0
+#define X_HALF    1
+#define X_WORD    2
+
+/*data length and burst length combination in DDMA and NDMA */
+enum xferunit {
+	/*des:X_SIGLE  src:X_SIGLE*/
+	DMAXFER_D_SBYTE_S_SBYTE,
+	DMAXFER_D_SBYTE_S_SHALF,
+	DMAXFER_D_SBYTE_S_SWORD,
+	DMAXFER_D_SHALF_S_SBYTE,
+	DMAXFER_D_SHALF_S_SHALF,
+	DMAXFER_D_SHALF_S_SWORD,
+	DMAXFER_D_SWORD_S_SBYTE,
+	DMAXFER_D_SWORD_S_SHALF,
+	DMAXFER_D_SWORD_S_SWORD,
+
+	/*des:X_SIGLE  src:X_BURST*/
+	DMAXFER_D_SBYTE_S_BBYTE,
+	DMAXFER_D_SBYTE_S_BHALF,
+	DMAXFER_D_SBYTE_S_BWORD,
+	DMAXFER_D_SHALF_S_BBYTE,
+	DMAXFER_D_SHALF_S_BHALF,
+	DMAXFER_D_SHALF_S_BWORD,
+	DMAXFER_D_SWORD_S_BBYTE,
+	DMAXFER_D_SWORD_S_BHALF,
+	DMAXFER_D_SWORD_S_BWORD,
+
+	/*des:X_SIGLE   src:X_TIPPL*/
+	DMAXFER_D_SBYTE_S_TBYTE,
+	DMAXFER_D_SBYTE_S_THALF,
+	DMAXFER_D_SBYTE_S_TWORD,
+	DMAXFER_D_SHALF_S_TBYTE,
+	DMAXFER_D_SHALF_S_THALF,
+	DMAXFER_D_SHALF_S_TWORD,
+	DMAXFER_D_SWORD_S_TBYTE,
+	DMAXFER_D_SWORD_S_THALF,
+	DMAXFER_D_SWORD_S_TWORD,
+
+	/*des:X_BURST  src:X_BURST*/
+	DMAXFER_D_BBYTE_S_BBYTE,
+	DMAXFER_D_BBYTE_S_BHALF,
+	DMAXFER_D_BBYTE_S_BWORD,
+	DMAXFER_D_BHALF_S_BBYTE,
+	DMAXFER_D_BHALF_S_BHALF,
+	DMAXFER_D_BHALF_S_BWORD,
+	DMAXFER_D_BWORD_S_BBYTE,
+	DMAXFER_D_BWORD_S_BHALF,
+	DMAXFER_D_BWORD_S_BWORD,
+
+	/*des:X_BURST   src:X_SIGLE*/
+	DMAXFER_D_BBYTE_S_SBYTE,
+	DMAXFER_D_BBYTE_S_SHALF,
+	DMAXFER_D_BBYTE_S_SWORD,
+	DMAXFER_D_BHALF_S_SBYTE,
+	DMAXFER_D_BHALF_S_SHALF,
+	DMAXFER_D_BHALF_S_SWORD,
+	DMAXFER_D_BWORD_S_SBYTE,
+	DMAXFER_D_BWORD_S_SHALF,
+	DMAXFER_D_BWORD_S_SWORD,
+
+	/*des:X_BURST   src:X_TIPPL*/
+	DMAXFER_D_BBYTE_S_TBYTE,
+	DMAXFER_D_BBYTE_S_THALF,
+	DMAXFER_D_BBYTE_S_TWORD,
+	DMAXFER_D_BHALF_S_TBYTE,
+	DMAXFER_D_BHALF_S_THALF,
+	DMAXFER_D_BHALF_S_TWORD,
+	DMAXFER_D_BWORD_S_TBYTE,
+	DMAXFER_D_BWORD_S_THALF,
+	DMAXFER_D_BWORD_S_TWORD,
+
+	/*des:X_TIPPL   src:X_TIPPL*/
+	DMAXFER_D_TBYTE_S_TBYTE,
+	DMAXFER_D_TBYTE_S_THALF,
+	DMAXFER_D_TBYTE_S_TWORD,
+	DMAXFER_D_THALF_S_TBYTE,
+	DMAXFER_D_THALF_S_THALF,
+	DMAXFER_D_THALF_S_TWORD,
+	DMAXFER_D_TWORD_S_TBYTE,
+	DMAXFER_D_TWORD_S_THALF,
+	DMAXFER_D_TWORD_S_TWORD,
+
+	/*des:X_TIPPL   src:X_SIGLE*/
+	DMAXFER_D_TBYTE_S_SBYTE,
+	DMAXFER_D_TBYTE_S_SHALF,
+	DMAXFER_D_TBYTE_S_SWORD,
+	DMAXFER_D_THALF_S_SBYTE,
+	DMAXFER_D_THALF_S_SHALF,
+	DMAXFER_D_THALF_S_SWORD,
+	DMAXFER_D_TWORD_S_SBYTE,
+	DMAXFER_D_TWORD_S_SHALF,
+	DMAXFER_D_TWORD_S_SWORD,
+
+	/*des:X_TIPPL   src:X_BURST*/
+	DMAXFER_D_TBYTE_S_BBYTE,
+	DMAXFER_D_TBYTE_S_BHALF,
+	DMAXFER_D_TBYTE_S_BWORD,
+	DMAXFER_D_THALF_S_BBYTE,
+	DMAXFER_D_THALF_S_BHALF,
+	DMAXFER_D_THALF_S_BWORD,
+	DMAXFER_D_TWORD_S_BBYTE,
+	DMAXFER_D_TWORD_S_BHALF,
+	DMAXFER_D_TWORD_S_BWORD,
+	DMAXFER_MAX
+};
+
+/* DMAADDRT_(dist)_(increase/fix)_(src)_(increase/fix) */
+#define A_INC     0x0
+#define A_FIX     0x1
+#define A_LN      0x0
+#define A_IO      0x1
+#define A_PH      0x2
+#define A_PV      0x3
+
+enum addrt {
+	/*NDMA address type*/
+	DMAADDRT_D_INC_S_INC,
+	DMAADDRT_D_INC_S_FIX,
+	DMAADDRT_D_FIX_S_INC,
+	DMAADDRT_D_FIX_S_FIX,
+
+	/*DDMA address type*/
+	DMAADDRT_D_LN_S_LN,
+	DMAADDRT_D_LN_S_IO,
+	DMAADDRT_D_LN_S_PH,
+	DMAADDRT_D_LN_S_PV,
+
+	DMAADDRT_D_IO_S_LN,
+	DMAADDRT_D_IO_S_IO,
+	DMAADDRT_D_IO_S_PH,
+	DMAADDRT_D_IO_S_PV,
+
+	DMAADDRT_D_PH_S_LN,
+	DMAADDRT_D_PH_S_IO,
+	DMAADDRT_D_PH_S_PH,
+	DMAADDRT_D_PH_S_PV,
+
+	DMAADDRT_D_PV_S_LN,
+	DMAADDRT_D_PV_S_IO,
+	DMAADDRT_D_PV_S_PH,
+	DMAADDRT_D_PV_S_PV,
+
+	DMAADDRT_MAX
+};
+
+/* use this to specifiy hardware channel number */
+#define DMACH_LOW_LEVEL	(1<<28)
+
+/* we have 16 dma channels */
+#define SW_DMA_CHANNELS		(16)
+
+/* types */
+enum sw_dma_state {
+	SW_DMA_IDLE,
+	SW_DMA_RUNNING,
+	SW_DMA_PAUSED
+};
+
+
+/* enum sw_dma_loadst
+ *
+ * This represents the state of the DMA engine, wrt to the loaded / running
+ * transfers. Since we don't have any way of knowing exactly the state of
+ * the DMA transfers, we need to know the state to make decisions on wether
+ * we can
+ *
+ * SW_DMA_NONE
+ *
+ * There are no buffers loaded (the channel should be inactive)
+ *
+ * SW_DMA_1LOADED
+ *
+ * There is one buffer loaded, however it has not been confirmed to be
+ * loaded by the DMA engine. This may be because the channel is not
+ * yet running, or the DMA driver decided that it was too costly to
+ * sit and wait for it to happen.
+ *
+ * SW_DMA_1RUNNING
+ *
+ * The buffer has been confirmed running, and not finisged
+ *
+ * SW_DMA_1LOADED_1RUNNING
+ *
+ * There is a buffer waiting to be loaded by the DMA engine, and one
+ * currently running.
+*/
+
+enum sw_dma_loadst {
+	SW_DMALOAD_NONE,
+	SW_DMALOAD_1LOADED,
+	SW_DMALOAD_1RUNNING,
+	SW_DMALOAD_1LOADED_1RUNNING,
+};
+
+enum sw_dma_buffresult {
+	SW_RES_OK,
+	SW_RES_ERR,
+	SW_RES_ABORT
+};
+
+enum sw_dmadir {
+	SW_DMA_RWNULL,
+	SW_DMA_RDEV,		/* read from dev */
+	SW_DMA_WDEV,		/* write to dev */
+	SW_DMA_M2M,
+//	SW_DMA_RWDEV		/* can r/w dev */
+};
+
+enum dma_hf_irq {
+	SW_DMA_IRQ_NO,
+	SW_DMA_IRQ_HALF,
+	SW_DMA_IRQ_FULL
+};
+/* enum sw_chan_op
+ *
+ * operation codes passed to the DMA code by the user, and also used
+ * to inform the current channel owner of any changes to the system state
+*/
+
+enum sw_chan_op {
+	SW_DMAOP_START,
+	SW_DMAOP_STOP,
+	SW_DMAOP_PAUSE,
+	SW_DMAOP_RESUME,
+	SW_DMAOP_FLUSH,
+	SW_DMAOP_TIMEOUT,		/* internal signal to handler */
+	SW_DMAOP_STARTED,		/* indicate channel started */
+};
+
+/* flags */
+
+#define SW_DMAF_SLOW         (1<<0)   /* slow, so don't worry about
+					    * waiting for reloads */
+#define SW_DMAF_AUTOSTART    (1<<1)   /* auto-start if buffer queued */
+
+/* dma buffer */
+
+struct sw_dma_client {
+	char                *name;
+};
+
+/* sw_dma_buf_s
+ *
+ * internally used buffer structure to describe a queued or running
+ * buffer.
+*/
+
+struct sw_dma_buf;
+struct sw_dma_buf {
+	struct sw_dma_buf	*next;
+	int			 magic;		/* magic */
+	int			 size;		/* buffer size in bytes */
+	dma_addr_t		 data;		/* start of DMA data */
+	dma_addr_t		 ptr;		/* where the DMA got to [1] */
+	void			*id;		/* client's id */
+};
+
+/* [1] is this updated for both recv/send modes? */
+
+struct sw_dma_chan;
+
+/* sw_dma_cbfn_t
+ *
+ * buffer callback routine type
+*/
+
+typedef void (*sw_dma_cbfn_t)(struct sw_dma_chan *,
+				   void *buf, int size,
+				   enum sw_dma_buffresult result);
+
+typedef int  (*sw_dma_opfn_t)(struct sw_dma_chan *,
+				   enum sw_chan_op );
+
+struct sw_dma_stats {
+	unsigned long		loads;
+	unsigned long		timeout_longest;
+	unsigned long		timeout_shortest;
+	unsigned long		timeout_avg;
+	unsigned long		timeout_failed;
+};
+
+struct sw_dma_map;
+
+/* struct sw_dma_chan
+ *
+ * full state information for each DMA channel
+*/
+
+struct sw_dma_chan {
+	/* channel state flags and information */
+	unsigned char		 number;      /* number of this dma channel */
+	unsigned char		 in_use;      /* channel allocated */
+	unsigned char		 irq_claimed; /* irq claimed for channel */
+	unsigned char		 irq_enabled; /* irq enabled for channel */
+
+	/* channel state */
+
+	enum sw_dma_state	 state;
+	enum sw_dma_loadst	 load_state;
+	struct sw_dma_client *client;
+
+	/* channel configuration */
+	unsigned long		 dev_addr;
+	unsigned long		 load_timeout;
+	unsigned int		 flags;		/* channel flags */
+	unsigned int		 hw_cfg;	/* last hw config */
+
+	struct sw_dma_map	*map;		/* channel hw maps */
+
+	/* channel's hardware position and configuration */
+	void __iomem		*regs;		/* channels registers */
+	void __iomem		*addr_reg;	/* data address register */
+	//unsigned int		 irq;		/* channel irq */
+	unsigned long		 dcon;		/* default value of DCON */
+
+	/* driver handles */
+	sw_dma_cbfn_t	 callback_fn;	/* buffer done callback */
+	sw_dma_cbfn_t	 callback_hd;	/* buffer half done callback */
+	sw_dma_opfn_t	 op_fn;		/* channel op callback */
+
+	/* stats gathering */
+	struct sw_dma_stats *stats;
+	struct sw_dma_stats  stats_store;
+
+	/* buffer list and information */
+	struct sw_dma_buf	*curr;		/* current dma buffer */
+	struct sw_dma_buf	*next;		/* next buffer to load */
+	struct sw_dma_buf	*end;		/* end of queue */
+
+	/* system device */
+	struct device	dev;
+	void * dev_id;
+};
+
+/*the channel number of above 8 is DDMA channel.*/
+#define IS_DADECATE_DMA(ch) (ch->number >= 8)
+
+struct dma_hw_conf{
+	unsigned char		drqsrc_type;
+	unsigned char		drqdst_type;
+
+	unsigned char		xfer_type;
+	unsigned char		address_type;
+	unsigned char           dir;
+	unsigned char		hf_irq;
+	unsigned char		reload;
+
+	unsigned long		from;
+	unsigned long		to;
+	unsigned long		cmbk;
+};
+
+extern inline void DMA_COPY_HW_CONF(struct dma_hw_conf *to, struct dma_hw_conf *from);
+
+/* struct sw_dma_map
+ *
+ * this holds the mapping information for the channel selected
+ * to be connected to the specified device
+*/
+struct sw_dma_map {
+	const char		*name;
+	struct dma_hw_conf  user_hw_conf;
+	const struct dma_hw_conf*  default_hw_conf;
+	struct dma_hw_conf* conf_ptr;
+	unsigned long channels[SW_DMA_CHANNELS];
+};
+
+struct sw_dma_selection {
+	struct sw_dma_map	*map;
+	unsigned long		 map_size;
+	unsigned long		 dcon_mask;
+};
+
+/* struct sw_dma_order_ch
+ *
+ * channel map for one of the `enum dma_ch` dma channels. the list
+ * entry contains a set of low-level channel numbers, orred with
+ * DMA_CH_VALID, which are checked in the order in the array.
+*/
+
+struct sw_dma_order_ch {
+	unsigned int	list[SW_DMA_CHANNELS];	/* list of channels */
+	unsigned int	flags;				/* flags */
+};
+
+/* struct s3c24xx_dma_order
+ *
+ * information provided by either the core or the board to give the
+ * dma system a hint on how to allocate channels
+*/
+
+struct sw_dma_order {
+	struct sw_dma_order_ch	channels[DMACH_MAX];
+};
+
+/* the currently allocated channel information */
+extern struct sw_dma_chan sw_chans[];
+
+/* note, we don't really use dma_device_t at the moment */
+typedef unsigned long dma_device_t;
+
+/* functions --------------------------------------------------------------- */
+
+/* sw_dma_request
+ *
+ * request a dma channel exclusivley
+*/
+
+extern int sw_dma_request(unsigned int channel,
+			       struct sw_dma_client *, void *dev);
+
+
+/* sw_dma_ctrl
+ *
+ * change the state of the dma channel
+*/
+
+extern int sw_dma_ctrl(unsigned int channel, enum sw_chan_op op);
+
+/* sw_dma_setflags
+ *
+ * set the channel's flags to a given state
+*/
+
+extern int sw_dma_setflags(unsigned int channel,
+				unsigned int flags);
+
+/* sw_dma_free
+ *
+ * free the dma channel (will also abort any outstanding operations)
+*/
+
+extern int sw_dma_free(unsigned int channel, struct sw_dma_client *);
+
+/* sw_dma_enqueue
+ *
+ * place the given buffer onto the queue of operations for the channel.
+ * The buffer must be allocated from dma coherent memory, or the Dcache/WB
+ * drained before the buffer is given to the DMA system.
+*/
+
+extern int sw_dma_enqueue(unsigned int channel, void *id,
+			       dma_addr_t data, int size);
+
+/* sw_dma_config
+ *
+ * configure the dma channel
+*/
+extern void poll_dma_pending(int chan_nr);
+
+extern int sw_dma_config(unsigned int channel, struct dma_hw_conf* user_conf);
+
+extern int sw15_dma_init(void);
+
+extern int sw_dma_order_set(struct sw_dma_order *ord);
+
+extern int sw_dma_init_map(struct sw_dma_selection *sel);
+
+/* sw_dma_getposition
+ *
+ * get the position that the dma transfer is currently at
+*/
+
+extern int sw_dma_getposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+extern int sw_dma_set_opfn(unsigned int, sw_dma_opfn_t rtn);
+extern int sw_dma_set_buffdone_fn(unsigned int, sw_dma_cbfn_t rtn);
+extern int sw_dma_set_halfdone_fn(unsigned int, sw_dma_cbfn_t rtn);
+extern int sw_dma_getcurposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+#endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-sun4i/include/mach/dram.h b/arch/arm/mach-sun4i/include/mach/dram.h
new file mode 100644
index 0000000..d8af26f
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/dram.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/dram.h
+ */
+
+#include <plat/dram.h>
diff --git a/arch/arm/mach-sun4i/include/mach/entry-macro.S b/arch/arm/mach-sun4i/include/mach/entry-macro.S
new file mode 100644
index 0000000..5d0ffa4
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/entry-macro.S
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/entry-macro.S
+ */
+
+#include <plat/entry-macro.S>
diff --git a/arch/arm/mach-sun4i/include/mach/gpio.h b/arch/arm/mach-sun4i/include/mach/gpio.h
new file mode 100644
index 0000000..19a173a
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/gpio.h
@@ -0,0 +1,4 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/gpio.h
+ */
+#include <plat/gpio.h>
diff --git a/arch/arm/mach-sun4i/include/mach/hardware.h b/arch/arm/mach-sun4i/include/mach/hardware.h
new file mode 100644
index 0000000..b3fb202
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/hardware.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/hardware.h
+ */
+
+#include <plat/hardware.h>
diff --git a/arch/arm/mach-sun4i/include/mach/io.h b/arch/arm/mach-sun4i/include/mach/io.h
new file mode 100644
index 0000000..3cc8e49
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/io.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/io.h
+ */
+
+#include <plat/io.h>
diff --git a/arch/arm/mach-sun4i/include/mach/irqs.h b/arch/arm/mach-sun4i/include/mach/irqs.h
new file mode 100644
index 0000000..a828081
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/irqs.h
@@ -0,0 +1,9 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/irqs.h
+ */
+#ifndef __MACH_IRQS_H__
+#define __MACH_IRQS_H__
+
+#include <plat/irqs.h>
+
+#endif
diff --git a/arch/arm/mach-sun4i/include/mach/memory.h b/arch/arm/mach-sun4i/include/mach/memory.h
new file mode 100644
index 0000000..5b484ed
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/memory.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/memory.h
+ */
+
+#include <plat/memory.h>
diff --git a/arch/arm/mach-sun4i/include/mach/platform.h b/arch/arm/mach-sun4i/include/mach/platform.h
new file mode 100644
index 0000000..cce68bc
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/platform.h
@@ -0,0 +1,4 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/platform.h
+ */
+#include <plat/platform.h>
diff --git a/arch/arm/mach-sun4i/include/mach/spi.h b/arch/arm/mach-sun4i/include/mach/spi.h
new file mode 100644
index 0000000..42059da
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/spi.h
@@ -0,0 +1,258 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/spi.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pan Nan <pannan@allwinnertech.com>
+ * Victor Wei <weiziheng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SUN4I_SPI_H_
+#define _SUN4I_SPI_H_
+
+
+#define SPI_MODULE_NUM      (4)
+#define SPI_FIFO_DEPTH      (64)
+
+#define SPI0_BASE_ADDR      (0x01C05000)
+#define SPI1_BASE_ADDR      (0x01C06000)
+#define SPI2_BASE_ADDR      (0x01C17000)
+#define SPI3_BASE_ADDR      (0x01C1f000)
+
+
+/* SPI Registers offsets from peripheral base address */
+#define SPI_RXDATA_REG		    (0x00) /* rx data register */
+#define SPI_TXDATA_REG		    (0x04) /* tx data register */
+#define SPI_CTL_REG		        (0x08) /* control register */
+#define SPI_INT_CTL_REG         (0x0C) /* interrupt control register */
+#define SPI_STATUS_REG	        (0x10) /* status register */
+#define SPI_DMA_CTL_REG         (0x14) /* dma control register */
+#define SPI_WAIT_REG    	    (0x18) /* wait clock counter register */
+#define SPI_CLK_RATE_REG		(0x1C) /* clock rate control register */
+#define SPI_BC_REG              (0x20) /* burst counter register   */
+#define SPI_TC_REG              (0x24) /* transmit counter register */
+#define SPI_FIFO_STA_REG        (0x28) /* fifo status register */
+
+
+
+/* SPI Rx data register,default value: 0x0000_0000 */
+/* readonly
+8-bits: accessed in   byte    rxFIFO decreased by 1.
+        accessed in half-word rxFIFO decreased by 2.
+        accessed in   word    rxFIFO decreased by 4.
+*/
+/* SPI Tx data register,default value: 0x0000_0000 */
+/* write only
+   same as Rx data register
+*/
+
+
+/* SPI Control Register Bit Fields & Masks,defualt value:0x0002_001C */
+#define SPI_CTL_EN          (0x1 << 0) /* SPI module enable control 1:enable;0:disable;default:0 */
+#define SPI_CTL_FUNC_MODE   (0x1 << 1) /* SPI function mode select 1:master;0:slave;default:0 */
+/* default work mode3: pol = 1,pha = 1; */
+#define SPI_CTL_PHA         (0x1 << 2) /* SPI Clock polarity control,  0: phase0,1: phase1;default:1  */
+#define SPI_CTL_POL         (0x1 << 3) /* SPI Clock/Data phase control,0:low level idle,1:high level idle;default:1 */
+#define SPI_POL_PHA_BIT_POS     (2)
+
+#define SPI_CTL_SSPOL        (0x1 << 4) /* SPI Chip select signal polarity control,default: 1,low effective like this:~~|_____~~ */
+//#define SPI_CTL_TBW          (0x1 << 5) /* SPI transfer bit,0: 8bit, 1:16bit,default:0,8bit */    //modified by yemao, for aw1623, define as below, 2011-5-27 14:02:58
+#define SPI_CTL_DMAMOD       (0x1 << 5) /* SPI dma mode select: 0-NDMA,1-DDMA */
+#define SPI_CTL_LMTF         (0x1 << 6) /* LSB/MSB transfer first select 0:MSB,1:LSB,default 0:MSB first */
+#define SPI_CTL_SSCTL        (0x1 << 7) /* SPI chip select control,default 0:SPI_SSx remains asserted between SPI bursts,1:negate SPI_SSx between SPI bursts */
+#define SPI_CTL_RST_TXFIFO   (0x1 << 8) /* SPI reset rxFIFO write 1 automatic clear 0*/
+#define SPI_CTL_RST_RXFIFO   (0x1 << 9) /* SPI reset txFIFO write 1 automatic clear 0*/
+#define SPI_CTL_XCH          (0x1 << 10) /* Exchange burst default 0:idle,1:start exchange;when BC is zero,this bit cleared by SPI controller*/
+//#define SPI_CTL_SMC          (0x1 << 11) /* Start Mode control,default 0: immediately start a SPI burst;1:XCH bit controls */
+#define SPI_CTL_RAPIDS       (0x1 << 11) /* Rapids transfer mode */ //modified by yemao, for aw1623, define as below, 2011-5-27 14:02:58
+
+#define SPI_CTL_SS_MASK      (0x3 << 12) /* SPI chip select:00-SPI_SS0;01-SPI_SS1;10-SPI_SS2;11-SPI_SS3*/
+#define SPI_SS_BIT_POS          (12)
+
+#define SPI_CTL_DDB          (0x1 << 14) /* Dummy burst Type,default 0: dummy spi burst is zero;1:dummy spi burst is one */
+#define SPI_CTL_DHB          (0x1 << 15) /* Discard Hash Burst,default 0:receiving all spi burst in BC period 1:discard unused,fectch WTC bursts */
+
+#define SPI_CTL_SS_CTRL      (0x1 << 16) /* SS output mode select default is 0:automatic output SS;1:manual output SS */
+#define SPI_CTL_SS_LEVEL     (0x1 << 17) /* defautl is 1:set SS to high;0:set SS to low */
+
+#define SPI_CTL_T_PAUSE_EN   (0x1 << 18) /* Transmit Pause Enable;Master mode: 1-stop when RXFIFO full;0-ignore rxFIFO */
+#define SPI_CTL_MASTER_SDC   (0x1 << 19) /* master sample data control, 1: delay--high speed operation;0:no delay. */
+/* aw1620 control register 31-20bit reserved bit */
+
+
+/* SPI Interrupt Register Bit Fields & Masks,default value:0x0000_0000 */
+#define SPI_INTEN_RR	    (0x1 << 0)  /* rxFIFO Ready Interrupt Enable,---used for immediately received,0:disable;1:enable */
+#define SPI_INTEN_RH	    (0x1 << 1)  /* rxFIFO Half Full Interrupt Enable ---used for IRQ received */
+#define SPI_INTEN_RF	    (0x1 << 2)  /* rxFIFO Full Interrupt Enable ---seldom used */
+#define SPI_INTEN_QTR_RF    (0x1 << 3) /* rxFIFO 1/4 Full Interrupt Enable */
+#define SPI_INTEN_3QTR_RF   (0x1 << 4) /* rxFIFO 3/4 Full Interrupt Enable */
+#define SPI_INTEN_RO	    (0x1 << 5)  /* rxFIFO Overflow Interrupt Enable ---used for error detect */
+#define SPI_INTEN_RU	    (0x1 << 6)  /* rxFIFO Underrun Interrupt Enable ---used for error detect */
+/* 7 bit reserved */
+
+#define SPI_INTEN_TE	    (0x1 << 8)  /* txFIFO Empty Interrupt Enable ---seldom used */
+#define SPI_INTEN_TH	    (0x1 << 9)  /* txFIFO Half Empty Interrupt Enable ---used  for IRQ tx */
+#define SPI_INTEN_TF	    (0x1 << 10) /* txFIFO Full Interrupt Enable ---seldom used */
+#define SPI_INTEN_QTR_TE    (0x1 << 11) /* txFIFO FIFO 1/4 Empty Interrupt Enable;0-disable;1-enable */
+#define SPI_INTEN_3QTR_TE   (0x1 << 12) /* txFIFO FIFO 3/4 Empty Interrupt Enable;0-disable;1-enable */
+#define SPI_INTEN_TO	    (0x1 << 13) /* txFIFO Overflow Interrupt Enable ---used for error detect */
+#define SPI_INTEN_TU	    (0x1 << 14) /* txFIFO Underrun Interrupt Enable ---not happened */
+/* 15 bit reserved */
+
+#define SPI_INTEN_TC    (0x1 << 16) /* Transfer Completed Interrupt Enable  ---used */
+#define SPI_INTEN_SSI   (0x1 << 17) /* SSI interrupt Enable,chip select from valid state to invalid state,for slave used only */
+/* 31:18 bit reserved */
+#define SPI_INTEN_ERR   (SPI_INTEN_TO|SPI_INTEN_RU|SPI_INTEN_RO) //NO txFIFO underrun
+#define SPI_INTEN_MASK  (0x7f|(0x7f<<8)|(0x3<<16))
+
+
+/* SPI Status Register Bit Fields & Masks,default value:0x0000_1B00 all bits are written 1 to clear 0 */
+#define SPI_STAT_RR        (0x1 << 0) /* rxFIFO ready, 0:no valid data;1:more than 1 word in rxfifo */
+#define SPI_STAT_RHF       (0x1 << 1) /* rxFIFO half full,0:less than 4 words;1:four or more than 4 words in rxfifo */
+#define SPI_STAT_RF        (0x1 << 2) /* rxFIFO full,0:not full;1:full */
+#define SPI_STAT_QTR_RF    (0x1 << 3) /* rxFIFO 1/4 Full, 0:not 1/4 full;1:1/4 full */
+#define SPI_STAT_3QTR_RF   (0x1 << 4) /* rxFIFO 3/4 Full, 0:not 1/4 full;1:1/4 full */
+#define SPI_STAT_RO        (0x1 << 5) /* rxFIFO overflow, 0: rxfifo is available;1:rxfifo has overflowed! */
+#define SPI_STAT_RU        (0x1 << 6) /* rxFIFO underrun,fectch data with no data available in FIFO */
+/* 7bit reserved */
+
+#define SPI_STAT_TE        (0x1 << 8)  /* txFIFO empty,0:txfifo contains one or more words;1:txfifo is empty.default value:1 */
+#define SPI_STAT_THE       (0x1 << 9)  /* txFIFO half empty,0:more than half words;1: half or fewer words.defualt value: 1 */
+#define SPI_STAT_TF        (0x1 << 10) /* txFIFO Full */
+#define SPI_STAT_QTR_TE    (0x1 << 11) /* txFIFO 1/4 empty.default is 1:more than 1/4 empty */
+#define SPI_STAT_3QTR_TE   (0x1 << 12) /* txFIFO 3/4 empty.default is 1:more than 3/4 empty */
+#define SPI_STAT_TO        (0x1 << 13) /* txFIFO overflow 0:not overflow;1:overflow */
+#define SPI_STAT_TU        (0x1 << 14) /* txFIFO underrun 0:not underrun;1:undrrun */
+/* 15bit reserved */
+
+#define SPI_STAT_TC        (0x1 << 16) /* Transfer Complete, 0:BUSY;1:transfer completed */
+#define SPI_STAT_SSI       (0x1 << 17) /* SS Invalid Interrupt ,for slave used only */
+/* 31-18bits reserved */
+#define SPI_STAT_MASK (0x7f|(0x7f<<8)|(0x3<<16))
+
+#define SPI_STAT_ERR       (SPI_STAT_TO|SPI_STAT_RU|SPI_STAT_RO) //Slave mode,no SPI_STAT_TU
+
+
+/* SPI DMA Control Register Bit Fields & Masks defuatl:0x0000_0000 */
+#define SPI_DRQEN_RR	  (0x1 << 0)	/* rxFIFO Ready DMA Request Enable,when one or more than one words in RXFIFO */
+#define SPI_DRQEN_RHF	  (0x1 << 1)  /* rXFIFO Half Full DMA Request Enable,when 4 or more than 4 words in RXFIFO */
+#define SPI_DRQEN_RF	  (0x1 << 2)  /* rxFIFO Full DMA Request Enable */
+#define SPI_DRQEN_QTR_RF  (0x1 << 3)  /* rxFIFO 1/4 Full DMA Request Enable */
+#define SPI_DRQEN_3QTR_RF (0x1 << 4)  /* rxFIFO 3/4 Full DMA Request Enable */
+/* 7:5 bit reserved */
+
+#define SPI_DRQEN_TE	  (0x1 << 8)  /* txFIFO Empty DMA Request Enable,when no words in TXFIFO */
+#define SPI_DRQEN_THE	  (0x1 << 9)  /* txFIFO Half Empty DMA Request Enable,when 4 or less than 4 words in TXFIFO */
+#define SPI_DRQEN_TNF	  (0x1 << 10) /* txFIFO Not Full DMA Request Enable,asserted when more than one free room for burst */
+#define SPI_DRQEN_QTR_TE  (0x1 << 11) /* txFIFO 1/4 Empty DMA Request Enable */
+#define SPI_DRQEN_3QTR_TE (0x1 << 12) /* txFIFO 3/4 Empty DMA Request Enable */
+/* 31:13 bits reserved */
+#define SPI_DRQEN_MASK (0x1f|(0x1f<<8))
+
+
+/* SPI Wait Clock Register Bit Fields & Masks,default value:0x0000_0000 */
+#define SPI_WAIT_CLK_MASK   (0xFFFF << 0)	/* used only in master mode: Wait Between Transactions */
+/* 31:16bit reserved */
+
+
+/* SPI Wait Clock Register Bit Fields & Masks,default:0x0000_0002 */
+#define SPI_CLKCTL_CDR2     (0xFF << 0)  /* Clock Divide Rate 2,master mode only : SPI_CLK = AHB_CLK/(2*(n+1)) */
+#define SPI_CLKCTL_CDR1     (0xF  << 8)  /* Clock Divide Rate 1,master mode only : SPI_CLK = AHB_CLK/2^(n+1) */
+#define SPI_CLKCTL_DRS      (0x1  << 12) /* Divide rate select,default,0:rate 1;1:rate 2 */
+#define SPI_CLK_SCOPE     (SPI_CLKCTL_CDR2+1)
+/* 31:13bits reserved */
+
+
+/* SPI Burst Counter Register Bit Fields & Masks,default value: 0x0000_0000 */
+/* master mode: when SMC = 1,BC specifies total burst number, Max length is 16Mbytes */
+#define SPI_BC_BC_MASK    (0xFFFFFF << 0 ) /* Total Burst Counter,tx length + rx length ,SMC=1 */
+#define SPI_TRANSFER_SIZE  (SPI_BC_BC_MASK)
+
+
+/* SPI Transmit Counter reigster default:0x0000_0000,Max length is 16Mbytes */
+#define SPI_TC_WTC_MASK   (0xFFFFFF << 0) /* Write Transmit Counter,tx length, NOT rx length!!! */
+
+
+/* SPI FIFO status register default is 0x0000_0000 */
+#define SPI_FIFO_RXCNT     (0x7F << 0) /* rxFIFO counter,how many bytes in the rxFIFO */
+#define SPI_RXCNT_BIT_POS     (0)
+/* 15:7bits reserved */
+
+#define SPI_FIFO_TXCNT     (0x7F << 16) /* txFIFO counter,how many bytes in the txFIFO */
+#define SPI_TXCNT_BIT_POS     (16)
+
+///////////////////////////////////////////////////////////////////////////////////
+
+
+
+/* configbit */
+/*      **************linuxspi***************
+*       4
+*         0: 0POL=0,PAL=0;
+*         1: 1POL=0,PAL=1;
+*         2: 2POL=1,PAL=0;
+*         3: 3POL=1,PAL=1;
+*/
+#define SPI_PHA_ACTIVE_		    (0x01)
+#define SPI_POL_ACTIVE_		    (0x02)
+
+#define SPI_MODE_0_ACTIVE_		(0|0)
+#define SPI_MODE_1_ACTIVE_		(0|SPI_PHA_ACTIVE_)
+#define SPI_MODE_2_ACTIVE_		(SPI_POL_ACTIVE_|0)
+#define SPI_MODE_3_ACTIVE_		(SPI_POL_ACTIVE_|SPI_PHA_ACTIVE_) /*3*/
+/*  */
+#define SPI_CS_HIGH_ACTIVE_		    (0x04)  /**/
+#define SPI_LSB_FIRST_ACTIVE_		(0x08)  /*MSB*/
+
+#define SPI_DUMMY_ONE_ACTIVE_        (0x10)  /*spi0txFIFO */
+#define SPI_RECEIVE_ALL_ACTIVE_      (0x20)  /*burstrxFIFO */
+
+
+/* can modify to adapt the application */
+#define BULK_DATA_BOUNDARY    64
+
+/* spi controller just suppport 20Mhz */
+#define SPI_MAX_FREQUENCY 80000000
+
+/* distinguish sdram and sram address */
+#define SPI_RAM_BOUNDAY   (0x80000000)
+
+
+
+/* function mode select */
+#define SPI_MASTER_MODE     (0x1)
+#define SPI_SLAVE_MODE      (0x0)
+///////////////////////////////////////////////////////////////////////////////////
+
+#define AW_SPI_OK   0
+#define AW_SPI_FAIL 1
+
+struct sunxi_spi_platform_data {
+    int cs_bitmap; // cs0-0x1,cs1-0x2,cs0&cs1-0x3
+    int num_cs;   // number of cs
+    const char *clk_name; // ahb clk name
+};
+
+/* spi device controller state, alloc */
+struct sunxi_spi_config {
+	int bits_per_word; // 8bit
+	int max_speed_hz;  // 20MHz
+	int mode; // pha,pol,LSB,etc..
+};
+
+#endif
diff --git a/arch/arm/mach-sun4i/include/mach/system.h b/arch/arm/mach-sun4i/include/mach/system.h
new file mode 100644
index 0000000..1854bd0
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/system.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/system.h
+ */
+
+#include <plat/system.h>
diff --git a/arch/arm/mach-sun4i/include/mach/timex.h b/arch/arm/mach-sun4i/include/mach/timex.h
new file mode 100644
index 0000000..df3cfea
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/timex.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/timex.h
+ */
+
+#include <plat/timex.h>
diff --git a/arch/arm/mach-sun4i/include/mach/uncompress.h b/arch/arm/mach-sun4i/include/mach/uncompress.h
new file mode 100644
index 0000000..ddfe147
--- /dev/null
+++ b/arch/arm/mach-sun4i/include/mach/uncompress.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun4i/include/mach/uncompress.h
+ */
+
+#include <plat/uncompress.h>
diff --git a/arch/arm/mach-sun5i/Makefile b/arch/arm/mach-sun5i/Makefile
new file mode 100644
index 0000000..7e7c6e3
--- /dev/null
+++ b/arch/arm/mach-sun5i/Makefile
@@ -0,0 +1 @@
+obj-y += clock/
diff --git a/arch/arm/mach-sun5i/Makefile.boot b/arch/arm/mach-sun5i/Makefile.boot
new file mode 100644
index 0000000..afac71d
--- /dev/null
+++ b/arch/arm/mach-sun5i/Makefile.boot
@@ -0,0 +1,3 @@
+
+zreladdr-$(CONFIG_ARCH_SUN5I)	+= 0x40008000
+
diff --git a/arch/arm/mach-sun5i/clock/Makefile b/arch/arm/mach-sun5i/clock/Makefile
new file mode 100644
index 0000000..f72519b
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/Makefile
@@ -0,0 +1,2 @@
+obj-y += ccmu/
+obj-y += clock.o
diff --git a/arch/arm/mach-sun5i/clock/ccmu/Makefile b/arch/arm/mach-sun5i/clock/ccmu/Makefile
new file mode 100644
index 0000000..0f9d6c7
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/ccmu/Makefile
@@ -0,0 +1,3 @@
+obj-y += ccm_mod_clk.o ccm_sys_clk.o \
+         ccm.o pll_cfg_tbl.o \
+         ccu_dbg.o
diff --git a/arch/arm/mach-sun5i/clock/ccmu/ccm.c b/arch/arm/mach-sun5i/clock/ccmu/ccm.c
new file mode 100644
index 0000000..612ef80
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/ccmu/ccm.c
@@ -0,0 +1,80 @@
+/*
+ * arch/arm/mach-sun5i/clock/ccmu/ccm.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <mach/platform.h>
+#include <mach/clock.h>
+#include "ccm_i.h"
+
+
+
+__ccmu_reg_list_t   *aw_ccu_reg;
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_init
+*
+*Description: initialise clock mangement unit;
+*
+*Arguments  : none
+*
+*Return     : result,
+*               AW_CCMU_OK,     initialise ccu successed;
+*               AW_CCMU_FAIL,   initialise ccu failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 aw_ccu_init(void)
+{
+    /* initialise the CCU io base */
+    aw_ccu_reg = (__ccmu_reg_list_t *)SW_VA_CCM_IO_BASE;
+
+    /* config the CCU to default status */
+
+    return AW_CCU_ERR_NONE;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_exit
+*
+*Description: exit clock managment unit;
+*
+*Arguments  : none
+*
+*Return     : result,
+*               AW_CCMU_OK,     exit ccu successed;
+*               AW_CCMU_FAIL,   exit ccu failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 aw_ccu_exit(void)
+{
+    return AW_CCU_ERR_NONE;
+}
+
diff --git a/arch/arm/mach-sun5i/clock/ccmu/ccm_i.h b/arch/arm/mach-sun5i/clock/ccmu/ccm_i.h
new file mode 100644
index 0000000..5f4b8cf
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/ccmu/ccm_i.h
@@ -0,0 +1,53 @@
+/*
+ * arch/arm/mach-sun5i/clock/ccmu/ccm_i.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __AW_CCMU_I_H__
+#define __AW_CCMU_I_H__
+
+#include <linux/kernel.h>
+#include <mach/ccmu_regs.h>
+#include <asm/io.h>
+
+extern __ccmu_reg_list_t   *aw_ccu_reg;
+
+#undef CCU_DBG
+#undef CCU_ERR
+#if (1)
+    #define CCU_DBG(format,args...)   printk("[ccmu] "format,##args)
+    #define CCU_ERR(format,args...)   printk("[ccmu] "format,##args)
+#else
+    #define CCU_DBG(...)
+    #define CCU_ERR(...)
+#endif
+
+
+struct core_pll_factor_t {
+    __u8    FactorN;
+    __u8    FactorK;
+    __u8    FactorM;
+    __u8    FactorP;
+};
+
+extern int ccm_clk_get_pll_para(struct core_pll_factor_t *factor, __u64 rate);
+
+#endif /* #ifndef __AW_CCMU_I_H__ */
diff --git a/arch/arm/mach-sun5i/clock/ccmu/ccm_mod_clk.c b/arch/arm/mach-sun5i/clock/ccmu/ccm_mod_clk.c
new file mode 100644
index 0000000..10aac59
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/ccmu/ccm_mod_clk.c
@@ -0,0 +1,1867 @@
+/*
+ * arch/arm/mach-sun5i/clock/ccmu/ccm_mod_clk.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include "ccm_i.h"
+
+#define make_mod_clk_inf(clk_id, clk_name)  {.id = clk_id, .name = clk_name, }
+
+static __aw_ccu_clk_t aw_ccu_mod_clk[] =
+{
+    make_mod_clk_inf(AW_MOD_CLK_NONE        , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_NFC         , "nfc"             ),
+    make_mod_clk_inf(AW_MOD_CLK_MSC         , "msc"             ),
+    make_mod_clk_inf(AW_MOD_CLK_SDC0        , "sdc0"            ),
+    make_mod_clk_inf(AW_MOD_CLK_SDC1        , "sdc1"            ),
+    make_mod_clk_inf(AW_MOD_CLK_SDC2        , "sdc2"            ),
+    make_mod_clk_inf(AW_MOD_CLK_SDC3        , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_TS          , "ts"              ),
+    make_mod_clk_inf(AW_MOD_CLK_SS          , "ss"              ),
+    make_mod_clk_inf(AW_MOD_CLK_SPI0        , "spi0"            ),
+    make_mod_clk_inf(AW_MOD_CLK_SPI1        , "spi1"            ),
+    make_mod_clk_inf(AW_MOD_CLK_SPI2        , "spi2"            ),
+    make_mod_clk_inf(AW_MOD_CLK_PATA        , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_IR0         , "ir0"             ),
+    make_mod_clk_inf(AW_MOD_CLK_IR1         , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_I2S         , "i2s"             ),
+    make_mod_clk_inf(AW_MOD_CLK_AC97        , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SPDIF       , "spdif"           ),
+    make_mod_clk_inf(AW_MOD_CLK_KEYPAD      , "key_pad"         ),
+    make_mod_clk_inf(AW_MOD_CLK_SATA        , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_USBPHY      , "usb_phy"     ),
+    make_mod_clk_inf(AW_MOD_CLK_USBPHY0     , "usb_phy0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_USBPHY1     , "usb_phy1"        ),
+    make_mod_clk_inf(AW_MOD_CLK_USBPHY2     , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_USBOHCI0    , "usb_ohci0"       ),
+    make_mod_clk_inf(AW_MOD_CLK_USBOHCI1    , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_GPS         , "com"             ),
+    make_mod_clk_inf(AW_MOD_CLK_SPI3        , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_DEBE0       , "de_image0"       ),
+    make_mod_clk_inf(AW_MOD_CLK_DEBE1       , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_DEFE0       , "de_scale0"       ),
+    make_mod_clk_inf(AW_MOD_CLK_DEFE1       , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_DEMIX       , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD0CH0     , "lcd0_ch0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD1CH0     , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_CSIISP      , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_TVD         , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD0CH1_S1  , "lcd0_ch1_s1"     ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD0CH1_S2  , "lcd0_ch1_s2"     ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD1CH1_S1  , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_LCD1CH1_S2  , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_CSI0        , "csi0"            ),
+    make_mod_clk_inf(AW_MOD_CLK_CSI1        , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_VE          , "ve"              ),
+    make_mod_clk_inf(AW_MOD_CLK_ADDA        , "audio_codec" ),
+    make_mod_clk_inf(AW_MOD_CLK_AVS         , "avs"             ),
+    make_mod_clk_inf(AW_MOD_CLK_ACE         , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_LVDS        , "lvds"            ),
+    make_mod_clk_inf(AW_MOD_CLK_HDMI        , "hdmi"            ),
+    make_mod_clk_inf(AW_MOD_CLK_MALI        , "mali"            ),
+    make_mod_clk_inf(AW_MOD_CLK_TWI0        , "twi0"            ),
+    make_mod_clk_inf(AW_MOD_CLK_TWI1        , "twi1"            ),
+    make_mod_clk_inf(AW_MOD_CLK_TWI2        , "twi2"            ),
+    make_mod_clk_inf(AW_MOD_CLK_CAN         , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SCR         , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_PS20        , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_PS21        , "ps1"             ),
+    make_mod_clk_inf(AW_MOD_CLK_UART0       , "uart0"           ),
+    make_mod_clk_inf(AW_MOD_CLK_UART1       , "uart1"           ),
+    make_mod_clk_inf(AW_MOD_CLK_UART2       , "uart2"           ),
+    make_mod_clk_inf(AW_MOD_CLK_UART3       , "uart3"           ),
+    make_mod_clk_inf(AW_MOD_CLK_UART4       , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART5       , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART6       , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_UART7       , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AXI_DRAM    , "axi_dram"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_USB0    , "ahb_usb0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_EHCI0   , "ahb_ehci0"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_OHCI0   , "ahb_ohci0"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SS      , "ahb_ss"          ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DMA     , "ahb_dma"         ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_BIST    , "ahb_bist"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDMMC0  , "ahb_sdc0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDMMC1  , "ahb_sdc1"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDMMC2  , "ahb_sdc2"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDMMC3  , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_MS      , "ahb_msc"         ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_NAND    , "ahb_nfc"         ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SDRAM   , "ahb_sdramc"      ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_ACE     , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_EMAC    , "ahb_emac"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_TS      , "ahb_ts"          ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SPI0    , "ahb_spi0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SPI1    , "ahb_spi1"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SPI2    , "ahb_spi2"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SPI3    , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_PATA    , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_SATA    , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_GPS     , "ahb_com"         ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_VE      , "ahb_ve"          ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_TVD     , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_TVE0    , "ahb_tve0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_TVE1    , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_LCD0    , "ahb_lcd0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_LCD1    , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_CSI0    , "ahb_csi0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_CSI1    , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_HDMI    , "ahb_hdmi"        ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DEBE0   , "ahb_de_image0"   ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DEBE1   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DEFE0   , "ahb_de_scale0"   ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_DEFE1   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_MP      , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_MALI    , "ahb_mali"        ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_ADDA    , "apb_audio_codec" ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_SPDIF   , "apb_spdif"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_AC97    , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_I2S     , "apb_i2s"         ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_PIO     , "apb_pio"         ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_IR0     , "apb_ir0"         ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_IR1     , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_KEYPAD  , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_TWI0    , "apb_twi0"        ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_TWI1    , "apb_twi1"        ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_TWI2    , "apb_twi2"        ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_CAN     , "apb_can"         ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_SCR     , "apb_scr"         ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_PS20    , "apb_ps0"         ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_PS21    , "apb_ps1"         ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART0   , "apb_uart0"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART1   , "apb_uart1"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART2   , "apb_uart2"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART3   , "apb_uart3"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART4   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART5   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART6   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_APB_UART7   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_VE    , "sdram_ve"        ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_CSI0  , "sdram_csi0"      ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_CSI1  , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_TS    , "sdram_ts"        ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_TVD   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_TVE0  , "sdram_tve0"      ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_TVE1  , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEFE0 , "sdram_de_scale0" ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEFE1 , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEBE0 , "sdram_de_image0" ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEBE1 , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_DEMP  , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_ACE   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_EHCI1   , "mclk_none"       ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_OHCI1   , "mclk_none"       ),
+
+    make_mod_clk_inf(AW_MOD_CLK_IEP         , "iep"             ),
+    make_mod_clk_inf(AW_MOD_CLK_AHB_IEP     , "ahb_iep"         ),
+    make_mod_clk_inf(AW_MOD_CLK_SDRAM_IEP   , "sdram_iep"       ),
+
+};
+
+
+static __aw_ccu_sys_clk_e mod_clk_get_parent(__aw_ccu_mod_clk_e id);
+static __aw_ccu_clk_onff_e mod_clk_get_status(__aw_ccu_mod_clk_e id);
+static __s64 mod_clk_get_rate(__aw_ccu_mod_clk_e id);
+static __aw_ccu_clk_reset_e mod_clk_get_reset(__aw_ccu_mod_clk_e id);
+
+static __s32 mod_clk_set_parent(__aw_ccu_mod_clk_e id, __aw_ccu_sys_clk_e parent);
+static __s32 mod_clk_set_status(__aw_ccu_mod_clk_e id, __aw_ccu_clk_onff_e status);
+static __s32 mod_clk_set_rate(__aw_ccu_mod_clk_e id, __s64 rate);
+static __s32 mod_clk_set_reset(__aw_ccu_mod_clk_e id, __aw_ccu_clk_reset_e reset);
+
+
+static inline __aw_ccu_sys_clk_e _parse_module0_clk_src(volatile __ccmu_module0_clk_t *reg)
+{
+    switch(reg->ClkSrc)
+    {
+        case 0:
+            return AW_SYS_CLK_HOSC;
+        case 1:
+            return AW_SYS_CLK_PLL62;
+        case 2:
+            return AW_SYS_CLK_PLL5P;
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+    return AW_SYS_CLK_NONE;
+}
+
+
+static inline __aw_ccu_sys_clk_e _parse_defemp_clk_src(volatile __ccmu_fedemp_clk_t *reg)
+{
+    switch(reg->ClkSrc)
+    {
+        case 0:
+            return AW_SYS_CLK_PLL3;
+        case 1:
+            return AW_SYS_CLK_PLL7;
+        case 2:
+            return AW_SYS_CLK_PLL5P;
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+    return AW_SYS_CLK_NONE;
+}
+
+
+static inline __s32 _set_module0_clk_src(volatile __ccmu_module0_clk_t *reg, __aw_ccu_sys_clk_e parent)
+{
+    switch(parent)
+    {
+        case AW_SYS_CLK_HOSC:
+            reg->ClkSrc = 0;
+            break;
+        case AW_SYS_CLK_PLL62:
+            reg->ClkSrc = 1;
+            break;
+        case AW_SYS_CLK_PLL5P:
+            reg->ClkSrc = 2;
+            break;
+        default:
+            return -1;
+    }
+
+    return 0;
+}
+
+
+static inline __s32 _set_defemp_clk_src(volatile __ccmu_fedemp_clk_t *reg, __aw_ccu_sys_clk_e parent)
+{
+    switch(parent)
+    {
+        case AW_SYS_CLK_PLL3:
+            reg->ClkSrc = 0;
+            break;
+        case AW_SYS_CLK_PLL7:
+            reg->ClkSrc = 1;
+            break;
+        case AW_SYS_CLK_PLL5P:
+            reg->ClkSrc = 2;
+            break;
+        default:
+            return -1;
+    }
+
+    return 0;
+}
+
+
+static inline __aw_ccu_clk_onff_e _get_module0_clk_status(volatile __ccmu_module0_clk_t *reg)
+{
+    return reg->SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+}
+
+
+static inline __s32 _set_module0_clk_status(volatile __ccmu_module0_clk_t *reg, __aw_ccu_clk_onff_e status)
+{
+    reg->SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+    return 0;
+}
+
+
+static inline __aw_ccu_clk_onff_e _get_defemp_clk_status(volatile __ccmu_fedemp_clk_t *reg)
+{
+    return reg->SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+}
+
+
+static inline __s32 _set_defemp_clk_status(volatile __ccmu_fedemp_clk_t *reg, __aw_ccu_clk_onff_e status)
+{
+    reg->SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+    return 0;
+}
+
+
+static inline __u32 _get_module0_clk_rate(volatile __ccmu_module0_clk_t *reg)
+{
+    return (1<<reg->ClkPreDiv) * (reg->ClkDiv+1);
+}
+
+
+static inline __s32 _set_module0_clk_rate(volatile __ccmu_module0_clk_t *reg, __u64 rate)
+{
+    if(rate > 16*8)
+    {
+        return -1;
+    }
+    else if(rate > 16*4)
+    {
+        reg->ClkPreDiv = 3;
+        reg->ClkDiv    = (rate>>3)-1;
+    }
+    else if(rate > 16*2)
+    {
+        reg->ClkPreDiv = 2;
+        reg->ClkDiv    = (rate>>2)-1;
+    }
+    else if(rate > 16*1)
+    {
+       reg->ClkPreDiv = 1;
+        reg->ClkDiv    = (rate>>1)-1;
+    }
+    else if(rate > 0)
+    {
+        reg->ClkPreDiv = 0;
+        reg->ClkDiv    = rate-1;
+    }
+    else
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+static __aw_ccu_sys_clk_e mod_clk_get_parent(__aw_ccu_mod_clk_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _parse_module0_clk_src(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _parse_module0_clk_src(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_TS:
+            return _parse_module0_clk_src(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _parse_module0_clk_src(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi2Clk);
+        case AW_MOD_CLK_IR0:
+            return _parse_module0_clk_src(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_I2S:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_SPDIF:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_KEYPAD:
+        {
+            switch(aw_ccu_reg->KeyPadClk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 2:
+                    return AW_SYS_CLK_LOSC;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBOHCI0:
+            return AW_SYS_CLK_PLL62;
+        case AW_MOD_CLK_GPS:
+            return AW_SYS_CLK_AHB;
+        case AW_MOD_CLK_DEBE0:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeBe0Clk);
+        case AW_MOD_CLK_DEFE0:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeFe0Clk);
+        case AW_MOD_CLK_LCD0CH0:
+        {
+            switch(aw_ccu_reg->Lcd0Ch0Clk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_LCD0CH1_S1:
+        case AW_MOD_CLK_LCD0CH1_S2:
+        {
+            switch(aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_CSI0:
+        {
+            switch(aw_ccu_reg->Csi0Clk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL3;
+                case 2:
+                    return AW_SYS_CLK_PLL7;
+                case 5:
+                    return AW_SYS_CLK_PLL3X2;
+                case 6:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_VE:
+            return AW_SYS_CLK_PLL4;
+        case AW_MOD_CLK_ADDA:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_AVS:
+            return AW_SYS_CLK_HOSC;
+        case AW_MOD_CLK_LVDS:
+            return AW_SYS_CLK_NONE;
+        case AW_MOD_CLK_HDMI:
+        {
+            switch(aw_ccu_reg->HdmiClk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_MALI:
+        {
+            switch(aw_ccu_reg->MaliClk.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL4;
+                case 2:
+                    return AW_SYS_CLK_PLL5P;
+                default:
+                    return AW_SYS_CLK_PLL7;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+            return AW_SYS_CLK_APB1;
+
+        case AW_MOD_CLK_IEP:
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_status
+*
+*Description: get module clock on/off status;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : result;
+*               AW_CCU_CLK_OFF, module clock is off;
+*               AW_CCU_CLK_ON,  module clock is on;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_onff_e mod_clk_get_status(__aw_ccu_mod_clk_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _get_module0_clk_status(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _get_module0_clk_status(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_TS:
+            return _get_module0_clk_status(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _get_module0_clk_status(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi2Clk);
+        case AW_MOD_CLK_IR0:
+            return _get_module0_clk_status(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_I2S:
+            return aw_ccu_reg->I2sClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SPDIF:
+            return aw_ccu_reg->SpdifClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_KEYPAD:
+            return aw_ccu_reg->KeyPadClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY:
+            return aw_ccu_reg->UsbClk.PhySpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY0:
+            return aw_ccu_reg->UsbClk.UsbPhy0Rst? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY1:
+            return aw_ccu_reg->UsbClk.UsbPhy1Rst? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBOHCI0:
+            return aw_ccu_reg->UsbClk.OHCI0SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_GPS:
+            return aw_ccu_reg->GpsClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_DEBE0:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeBe0Clk);
+        case AW_MOD_CLK_DEFE0:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeFe0Clk);
+        case AW_MOD_CLK_LCD0CH0:
+            return aw_ccu_reg->Lcd0Ch0Clk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD0CH1_S2:
+            return aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_VE:
+            return aw_ccu_reg->VeClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_ADDA:
+            return aw_ccu_reg->AddaClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AVS:
+            return aw_ccu_reg->AvsClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LVDS:
+            return AW_CCU_CLK_ON;
+        case AW_MOD_CLK_HDMI:
+            return aw_ccu_reg->HdmiClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_MALI:
+            return aw_ccu_reg->MaliClk.SpecClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+            return AW_CCU_CLK_ON;
+
+        case AW_MOD_CLK_AXI_DRAM:
+            return aw_ccu_reg->AxiGate.SdramGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_USB0:
+            return aw_ccu_reg->AhbGate0.Usb0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_EHCI0:
+            return aw_ccu_reg->AhbGate0.Ehci0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_OHCI0:
+            return aw_ccu_reg->AhbGate0.Ohci0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SS:
+            return aw_ccu_reg->AhbGate0.SsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_DMA:
+            return aw_ccu_reg->AhbGate0.DmaGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_BIST:
+            return aw_ccu_reg->AhbGate0.BistGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDMMC0:
+            return aw_ccu_reg->AhbGate0.Sdmmc0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDMMC1:
+            return aw_ccu_reg->AhbGate0.Sdmmc1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDMMC2:
+            return aw_ccu_reg->AhbGate0.Sdmmc2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_MS:
+            return aw_ccu_reg->AhbGate0.MsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_NAND:
+            return aw_ccu_reg->AhbGate0.NandGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SDRAM:
+            return aw_ccu_reg->AhbGate0.SdramGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_EMAC:
+            return aw_ccu_reg->AhbGate0.EmacGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_TS:
+            return aw_ccu_reg->AhbGate0.TsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SPI0:
+            return aw_ccu_reg->AhbGate0.Spi0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SPI1:
+            return aw_ccu_reg->AhbGate0.Spi1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_SPI2:
+            return aw_ccu_reg->AhbGate0.Spi2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_GPS:
+            return aw_ccu_reg->AhbGate0.GpsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_VE:
+            return aw_ccu_reg->AhbGate1.VeGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_TVE0:
+            return aw_ccu_reg->AhbGate1.Tve0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_LCD0:
+            return aw_ccu_reg->AhbGate1.Lcd0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_CSI0:
+            return aw_ccu_reg->AhbGate1.Csi0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_HDMI:
+            return aw_ccu_reg->AhbGate1.HdmiDGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_DEBE0:
+            return aw_ccu_reg->AhbGate1.DeBe0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_DEFE0:
+            return aw_ccu_reg->AhbGate1.DeFe0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_MALI:
+            return aw_ccu_reg->AhbGate1.MaliGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_ADDA:
+            return aw_ccu_reg->Apb0Gate.AddaGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_SPDIF:
+            return aw_ccu_reg->Apb0Gate.SpdifGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_I2S:
+            return aw_ccu_reg->Apb0Gate.IisGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_PIO:
+            return aw_ccu_reg->Apb0Gate.PioGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_IR0:
+            return aw_ccu_reg->Apb0Gate.Ir0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_KEYPAD:
+            return aw_ccu_reg->Apb0Gate.KeypadGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_TWI0:
+            return aw_ccu_reg->Apb1Gate.Twi0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_TWI1:
+            return aw_ccu_reg->Apb1Gate.Twi1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_TWI2:
+            return aw_ccu_reg->Apb1Gate.Twi2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART0:
+            return aw_ccu_reg->Apb1Gate.Uart0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART1:
+            return aw_ccu_reg->Apb1Gate.Uart1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART2:
+            return aw_ccu_reg->Apb1Gate.Uart2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_APB_UART3:
+            return aw_ccu_reg->Apb1Gate.Uart3Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_VE:
+            return aw_ccu_reg->DramGate.VeGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_CSI0:
+            return aw_ccu_reg->DramGate.Csi0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_TS:
+            return aw_ccu_reg->DramGate.TsGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_TVE0:
+            return aw_ccu_reg->DramGate.Tve0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_DEFE0:
+            return aw_ccu_reg->DramGate.DeFe0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_DEBE0:
+            return aw_ccu_reg->DramGate.DeBe0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_MOD_CLK_IEP:
+            return aw_ccu_reg->IepClk.ClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AHB_IEP:
+            return aw_ccu_reg->AhbGate1.IepGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SDRAM_IEP:
+            return aw_ccu_reg->DramGate.IepGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        default:
+            return AW_CCU_CLK_ON;
+    }
+    return AW_CCU_CLK_ON;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_rate
+*
+*Description: get module clock rate;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : module clock division;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s64 mod_clk_get_rate(__aw_ccu_mod_clk_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _get_module0_clk_rate(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _get_module0_clk_rate(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_TS:
+            return _get_module0_clk_rate(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _get_module0_clk_rate(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi2Clk);
+        case AW_MOD_CLK_IR0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_I2S:
+            return (1 << aw_ccu_reg->I2sClk.ClkDiv);
+        case AW_MOD_CLK_SPDIF:
+            return (1 << aw_ccu_reg->SpdifClk.ClkDiv);
+        case AW_MOD_CLK_KEYPAD:
+            return (1 << aw_ccu_reg->KeyPadClk.ClkPreDiv) * (aw_ccu_reg->KeyPadClk.ClkDiv + 1);
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_GPS:
+            return 1;
+        case AW_MOD_CLK_DEBE0:
+            return aw_ccu_reg->DeBe0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEFE0:
+            return aw_ccu_reg->DeFe0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_LCD0CH0:
+            return 1;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return (aw_ccu_reg->Lcd0Ch1Clk.ClkDiv + 1) * (aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src + 1);
+        case AW_MOD_CLK_LCD0CH1_S2:
+            return aw_ccu_reg->Lcd0Ch1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_VE:
+            return (aw_ccu_reg->VeClk.ClkDiv + 1);
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_AVS:
+            return 1;
+        case AW_MOD_CLK_LVDS:
+            return 1;
+        case AW_MOD_CLK_HDMI:
+            return (aw_ccu_reg->HdmiClk.ClkDiv + 1);
+        case AW_MOD_CLK_MALI:
+            return (aw_ccu_reg->MaliClk.ClkDiv + 1);
+
+        case AW_MOD_CLK_IEP:
+        default:
+            return 1;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_reset
+*
+*Description: get module clock reset status;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : result,
+*               AW_CCU_CLK_RESET,   module clock reset valid;
+*               AW_CCU_CLK_NRESET,  module clock reset invalid;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_reset_e mod_clk_get_reset(__aw_ccu_mod_clk_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+        case AW_MOD_CLK_MSC:
+        case AW_MOD_CLK_SDC0:
+        case AW_MOD_CLK_SDC1:
+        case AW_MOD_CLK_SDC2:
+        case AW_MOD_CLK_TS:
+        case AW_MOD_CLK_SS:
+        case AW_MOD_CLK_SPI0:
+        case AW_MOD_CLK_SPI1:
+        case AW_MOD_CLK_SPI2:
+        case AW_MOD_CLK_IR0:
+        case AW_MOD_CLK_I2S:
+        case AW_MOD_CLK_SPDIF:
+        case AW_MOD_CLK_KEYPAD:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_USBOHCI0:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_GPS:
+            return aw_ccu_reg->GpsClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEBE0:
+            return aw_ccu_reg->DeBe0Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEFE0:
+            return aw_ccu_reg->DeFe0Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_LCD0CH0:
+            return aw_ccu_reg->Lcd0Ch0Clk.LcdReset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_LCD0CH1_S2:
+            return aw_ccu_reg->Lcd0Ch0Clk.TveReset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_VE:
+            return aw_ccu_reg->VeClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_AVS:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_LVDS:
+            return aw_ccu_reg->LvdsClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_HDMI:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_MALI:
+            return aw_ccu_reg->MaliClk.Reset? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+
+        case AW_MOD_CLK_IEP:
+        default:
+            return AW_CCU_CLK_NRESET;
+    }
+
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_parent
+*
+*Description: set clock parent id for module clock;
+*
+*Arguments  : id        module clock id;
+*             parent    parent clock id;
+*
+*Return     : result;
+*               0,  set parent successed;
+*              !0,  set parent failed;
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_parent(__aw_ccu_mod_clk_e id, __aw_ccu_sys_clk_e parent)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_src(&aw_ccu_reg->NandClk, parent);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_src(&aw_ccu_reg->MsClk, parent);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc0Clk, parent);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc1Clk, parent);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc2Clk, parent);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_src(&aw_ccu_reg->TsClk, parent);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_src(&aw_ccu_reg->SsClk, parent);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi0Clk, parent);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi1Clk, parent);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi2Clk, parent);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_src(&aw_ccu_reg->Ir0Clk, parent);
+        case AW_MOD_CLK_I2S:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+        case AW_MOD_CLK_SPDIF:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+        case AW_MOD_CLK_KEYPAD:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->KeyPadClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->KeyPadClk.ClkSrc = 2;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBOHCI0:
+        {
+            if(parent == AW_SYS_CLK_PLL62)
+            {
+                return 0;
+            }
+
+            return -1;
+        }
+        case AW_MOD_CLK_DEBE0:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeBe0Clk, parent);
+        case AW_MOD_CLK_DEFE0:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeFe0Clk, parent);
+        case AW_MOD_CLK_LCD0CH0:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S2:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_CSI0:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 2;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_VE:
+            return (parent == AW_SYS_CLK_PLL4)? 0 : -1;
+        case AW_MOD_CLK_ADDA:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+        case AW_MOD_CLK_AVS:
+            return (parent == AW_SYS_CLK_HOSC)? 0 : -1;
+        case AW_MOD_CLK_HDMI:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 0;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL3X2:
+                {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 2;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL7:
+                {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 1;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL7X2:
+                {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 3;
+                    return 0;
+                }
+                default:
+                    return -1;
+            }
+        }
+        case AW_MOD_CLK_MALI:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->MaliClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL4:
+                    aw_ccu_reg->MaliClk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL5P:
+                    aw_ccu_reg->MaliClk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->MaliClk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_GPS:
+        {
+            return (parent == AW_SYS_CLK_AHB)? 0 : -1;
+        }
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+            return (parent == AW_SYS_CLK_APB1)? 0 : -1;
+
+        case AW_MOD_CLK_LVDS:
+        case AW_MOD_CLK_IEP:
+        default:
+            return (parent == AW_SYS_CLK_NONE)? 0 : -1;
+    }
+    return (parent == AW_SYS_CLK_NONE)? 0 : -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_status
+*
+*Description: set module clock on/off status;
+*
+*Arguments  : id        module clock id;
+*             status    module clock on/off status;
+*
+*Return     : result
+*               0,  set module clock on/off status successed;
+*              !0,  set module clock on/off status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_status(__aw_ccu_mod_clk_e id, __aw_ccu_clk_onff_e status)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_status(&aw_ccu_reg->NandClk, status);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_status(&aw_ccu_reg->MsClk, status);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc0Clk, status);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc1Clk, status);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc2Clk, status);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_status(&aw_ccu_reg->TsClk, status);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_status(&aw_ccu_reg->SsClk, status);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi0Clk, status);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi1Clk, status);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi2Clk, status);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_status(&aw_ccu_reg->Ir0Clk, status);
+        case AW_MOD_CLK_I2S:
+            aw_ccu_reg->I2sClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SPDIF:
+            aw_ccu_reg->SpdifClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_KEYPAD:
+        {
+            aw_ccu_reg->KeyPadClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY:
+        {
+            aw_ccu_reg->UsbClk.PhySpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY0:
+        {
+            aw_ccu_reg->UsbClk.UsbPhy0Rst = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY1:
+        {
+            aw_ccu_reg->UsbClk.UsbPhy1Rst = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBOHCI0:
+            aw_ccu_reg->UsbClk.OHCI0SpecClkGate = ((status == AW_CCU_CLK_OFF)? 0 : 1);
+            return 0;
+        case AW_MOD_CLK_GPS:
+        {
+            aw_ccu_reg->GpsClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE0:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeBe0Clk, status);
+        case AW_MOD_CLK_DEFE0:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeFe0Clk, status);
+        case AW_MOD_CLK_LCD0CH0:
+            aw_ccu_reg->Lcd0Ch0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Gate = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S2:
+            aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Gate = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_CSI0:
+            aw_ccu_reg->Csi0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_VE:
+            aw_ccu_reg->VeClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_ADDA:
+            aw_ccu_reg->AddaClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AVS:
+            aw_ccu_reg->AvsClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LVDS:
+            return 0;
+        case AW_MOD_CLK_HDMI:
+            aw_ccu_reg->HdmiClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_MALI:
+            aw_ccu_reg->MaliClk.SpecClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+            return 0;
+
+        case AW_MOD_CLK_AXI_DRAM:
+            aw_ccu_reg->AxiGate.SdramGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_USB0:
+            aw_ccu_reg->AhbGate0.Usb0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_EHCI0:
+            aw_ccu_reg->AhbGate0.Ehci0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_OHCI0:
+            aw_ccu_reg->AhbGate0.Ohci0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SS:
+            aw_ccu_reg->AhbGate0.SsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_AHB_DMA:
+            aw_ccu_reg->AhbGate0.DmaGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_BIST:
+            aw_ccu_reg->AhbGate0.BistGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDMMC0:
+            aw_ccu_reg->AhbGate0.Sdmmc0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDMMC1:
+            aw_ccu_reg->AhbGate0.Sdmmc1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDMMC2:
+            aw_ccu_reg->AhbGate0.Sdmmc2Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_MS:
+            aw_ccu_reg->AhbGate0.MsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_NAND:
+            aw_ccu_reg->AhbGate0.NandGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SDRAM:
+            aw_ccu_reg->AhbGate0.SdramGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_EMAC:
+            aw_ccu_reg->AhbGate0.EmacGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_TS:
+            aw_ccu_reg->AhbGate0.TsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SPI0:
+            aw_ccu_reg->AhbGate0.Spi0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SPI1:
+            aw_ccu_reg->AhbGate0.Spi1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_SPI2:
+            aw_ccu_reg->AhbGate0.Spi2Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_GPS:
+            aw_ccu_reg->AhbGate0.GpsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_VE:
+            aw_ccu_reg->AhbGate1.VeGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_TVE0:
+            aw_ccu_reg->AhbGate1.Tve0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_LCD0:
+            aw_ccu_reg->AhbGate1.Lcd0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_CSI0:
+            aw_ccu_reg->AhbGate1.Csi0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_HDMI:
+            aw_ccu_reg->AhbGate1.HdmiDGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_DEBE0:
+            aw_ccu_reg->AhbGate1.DeBe0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_DEFE0:
+            aw_ccu_reg->AhbGate1.DeFe0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_MALI:
+            aw_ccu_reg->AhbGate1.MaliGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_APB_ADDA:
+            aw_ccu_reg->Apb0Gate.AddaGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_SPDIF:
+            aw_ccu_reg->Apb0Gate.SpdifGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_I2S:
+            aw_ccu_reg->Apb0Gate.IisGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_PIO:
+            aw_ccu_reg->Apb0Gate.PioGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_IR0:
+            aw_ccu_reg->Apb0Gate.Ir0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_KEYPAD:
+            aw_ccu_reg->Apb0Gate.KeypadGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_TWI0:
+            aw_ccu_reg->Apb1Gate.Twi0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_TWI1:
+            aw_ccu_reg->Apb1Gate.Twi1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_TWI2:
+            aw_ccu_reg->Apb1Gate.Twi2Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART0:
+            aw_ccu_reg->Apb1Gate.Uart0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART1:
+            aw_ccu_reg->Apb1Gate.Uart1Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART2:
+            aw_ccu_reg->Apb1Gate.Uart2Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_APB_UART3:
+            aw_ccu_reg->Apb1Gate.Uart3Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_VE:
+            aw_ccu_reg->DramGate.VeGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_CSI0:
+            aw_ccu_reg->DramGate.Csi0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_TS:
+            aw_ccu_reg->DramGate.TsGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_TVE0:
+            aw_ccu_reg->DramGate.Tve0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_DEFE0:
+            aw_ccu_reg->DramGate.DeFe0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_DEBE0:
+            aw_ccu_reg->DramGate.DeBe0Gate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_IEP:
+            aw_ccu_reg->IepClk.ClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AHB_IEP:
+            aw_ccu_reg->AhbGate1.IepGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SDRAM_IEP:
+            aw_ccu_reg->DramGate.IepGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+            return 0;
+
+        default:
+            return -1;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_rate
+*
+*Description: set module clock division;
+*
+*Arguments  : id    module clock id;
+*             rate  module clock division;
+*
+*Return     : result
+*               0,  set module clock rate successed;
+*              !0,  set module clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_rate(__aw_ccu_mod_clk_e id, __s64 rate)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_rate(&aw_ccu_reg->NandClk, rate);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_rate(&aw_ccu_reg->MsClk, rate);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc0Clk, rate);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc1Clk, rate);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc2Clk, rate);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_rate(&aw_ccu_reg->TsClk, rate);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_rate(&aw_ccu_reg->SsClk, rate);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi0Clk, rate);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi1Clk, rate);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi2Clk, rate);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_rate(&aw_ccu_reg->Ir0Clk, rate);
+        case AW_MOD_CLK_I2S:
+        {
+            switch(rate)
+            {
+                case 1:
+                    aw_ccu_reg->I2sClk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->I2sClk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->I2sClk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->I2sClk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_SPDIF:
+        {
+            switch(rate)
+            {
+                case 1:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_KEYPAD:
+        {
+            if(rate > 32*8)
+            {
+                return -1;
+            }
+            else if(rate > 32*4)
+            {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 3;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>3)-1;
+            }
+            else if(rate > 32*2)
+            {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 2;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>2)-1;
+            }
+            else if(rate > 32*1)
+            {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 1;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>1)-1;
+            }
+            else if(rate > 32*0)
+            {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 0;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = rate-1;
+            }
+            else
+            {
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE0:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->DeBe0Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE0:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->DeFe0Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH1_S1:
+        {
+            if(rate == (aw_ccu_reg->Lcd0Ch1Clk.ClkDiv+1))
+            {
+                aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src = 0;
+                return 0;
+            }
+            else if(rate == ((aw_ccu_reg->Lcd0Ch1Clk.ClkDiv+1)<<1))
+            {
+                aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src = 1;
+                return 0;
+            }
+
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH1_S2:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->Lcd0Ch1Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI0:
+        {
+            if((rate < 1) || (rate > 32))
+            {
+                return -1;
+            }
+            aw_ccu_reg->Csi0Clk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_VE:
+        {
+            if((rate < 1) || (rate > 8))
+            {
+                return -1;
+            }
+            aw_ccu_reg->VeClk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_HDMI:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->HdmiClk.ClkDiv = rate-1;
+            return 0;
+        }
+        case AW_MOD_CLK_MALI:
+        {
+            if((rate < 1) || (rate > 16))
+            {
+                return -1;
+            }
+            aw_ccu_reg->MaliClk.ClkDiv = rate-1;
+            return 0;
+        }
+
+        case AW_MOD_CLK_LCD0CH0:
+        case AW_MOD_CLK_LVDS:
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_GPS:
+        case AW_MOD_CLK_AVS:
+        case AW_MOD_CLK_IEP:
+        default:
+            return (rate == 1)? 0 : -1;
+    }
+    return (rate == 1)? 0 : -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_reset
+*
+*Description: set module clock reset status
+*
+*Arguments  : id    module clock id;
+*             reset module clock reset status;
+*
+*Return     : result;
+*               0,  set module clock reset status successed;
+*              !0,  set module clock reset status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_reset(__aw_ccu_mod_clk_e id, __aw_ccu_clk_reset_e reset)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NFC:
+        case AW_MOD_CLK_MSC:
+        case AW_MOD_CLK_SDC0:
+        case AW_MOD_CLK_SDC1:
+        case AW_MOD_CLK_SDC2:
+        case AW_MOD_CLK_TS:
+        case AW_MOD_CLK_SS:
+        case AW_MOD_CLK_SPI0:
+        case AW_MOD_CLK_SPI1:
+        case AW_MOD_CLK_SPI2:
+        case AW_MOD_CLK_IR0:
+        case AW_MOD_CLK_I2S:
+        case AW_MOD_CLK_SPDIF:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBOHCI0:
+            return (reset == AW_CCU_CLK_NRESET)? 0 : -1;
+
+        case AW_MOD_CLK_USBPHY0:
+        {
+            aw_ccu_reg->UsbClk.UsbPhy0Rst = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY1:
+        {
+            aw_ccu_reg->UsbClk.UsbPhy1Rst = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_GPS:
+        {
+            aw_ccu_reg->GpsClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE0:
+        {
+            aw_ccu_reg->DeBe0Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE0:
+        {
+            aw_ccu_reg->DeFe0Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH0:
+        {
+            aw_ccu_reg->Lcd0Ch0Clk.LcdReset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI0:
+        {
+            aw_ccu_reg->Csi0Clk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_VE:
+        {
+            aw_ccu_reg->VeClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_LVDS:
+            aw_ccu_reg->LvdsClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_MALI:
+            aw_ccu_reg->MaliClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_IEP:
+            aw_ccu_reg->IepClk.Reset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_LCD0CH1_S2:
+            aw_ccu_reg->Lcd0Ch0Clk.TveReset = (reset == AW_CCU_CLK_RESET)? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_LCD0CH1_S1:
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_AVS:
+        case AW_MOD_CLK_HDMI:
+        default:
+            return (reset == AW_CCU_CLK_NRESET)? 0 : -1;
+    }
+    return (reset == AW_CCU_CLK_NRESET)? 0 : -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get_mod_clk_cnt
+*
+*Description: get the count of the module clock.
+*
+*Arguments  : none
+*
+*Return     : count of the module clock;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 aw_ccu_get_mod_clk_cnt(void)
+{
+    return (__u32)AW_MOD_CLK_CNT;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_rate_hz
+*
+*Description: get module clock rate based on hz;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : module clock division;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s64 mod_clk_get_rate_hz(__aw_ccu_mod_clk_e id)
+{
+    __s64               tmpRate;
+    __aw_ccu_clk_t      *tmpParent;
+
+    tmpRate = mod_clk_get_rate(id);
+    tmpParent = aw_ccu_get_sys_clk(mod_clk_get_parent(id));
+
+    return ccu_clk_uldiv(tmpParent->rate, tmpRate);
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_rate_hz
+*
+*Description: set module clock rate based on hz;
+*
+*Arguments  : id    module clock id;
+*             rate  module clock division;
+*
+*Return     : result
+*               0,  set module clock rate successed;
+*              !0,  set module clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_rate_hz(__aw_ccu_mod_clk_e id, __s64 rate)
+{
+    __aw_ccu_clk_t      *tmpParent;
+
+    tmpParent = aw_ccu_get_sys_clk(mod_clk_get_parent(id));
+    return mod_clk_set_rate(id, ccu_clk_uldiv((tmpParent->rate + (rate>>1)), rate));
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get_mod_clk
+*
+*Description: get module clock information by clock id.
+*
+*Arguments  : id    module clock id;
+*
+*Return     : module clock handle, return NULL if get clock information failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__aw_ccu_clk_t *aw_ccu_get_mod_clk(__aw_ccu_mod_clk_e id)
+{
+    __s32   tmpIdx = (__u32)id;
+
+    /* check if clock id is valid   */
+    if((id < AW_MOD_CLK_NONE) || (id >= AW_MOD_CLK_CNT))
+    {
+        CCU_ERR("ID is invalid when get module clock information!\n");
+        return NULL;
+    }
+
+    /* query module clock information from hardware */
+    aw_ccu_mod_clk[tmpIdx].parent = mod_clk_get_parent(id);
+    aw_ccu_mod_clk[tmpIdx].onoff  = mod_clk_get_status(id);
+    aw_ccu_mod_clk[tmpIdx].rate   = mod_clk_get_rate_hz(id);
+    aw_ccu_mod_clk[tmpIdx].reset  = mod_clk_get_reset(id);
+    aw_ccu_mod_clk[tmpIdx].hash   = ccu_clk_calc_hash(aw_ccu_mod_clk[tmpIdx].name);
+
+    return &aw_ccu_mod_clk[tmpIdx];
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_set_mod_clk
+*
+*Description: set module clock parameters;
+*
+*Arguments  : clk   handle of module clock;
+*
+*Return     : error type.
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__aw_ccu_err_e aw_ccu_set_mod_clk(__aw_ccu_clk_t *clk)
+{
+    __aw_ccu_clk_t  tmpClk;
+
+    if(!clk)
+    {
+        CCU_ERR("Clock handle is NULL when set system clock!\n");
+        return AW_CCU_ERR_PARA_NULL;
+    }
+
+    /* backup old parameter */
+    tmpClk.parent = mod_clk_get_parent(clk->id);
+    tmpClk.onoff  = mod_clk_get_status(clk->id);
+    tmpClk.reset  = mod_clk_get_reset(clk->id);
+    tmpClk.rate   = mod_clk_get_rate_hz(clk->id);
+
+    /* try to set new parameter */
+    if(!mod_clk_set_parent(clk->id, clk->parent))
+    {
+        if(!mod_clk_set_rate_hz(clk->id, clk->rate))
+        {
+            if(!mod_clk_set_status(clk->id, clk->onoff))
+            {
+                if(!mod_clk_set_reset(clk->id, clk->reset))
+                {
+                    /* update managemer parameter  */
+                    aw_ccu_mod_clk[(__u32)clk->id].parent = clk->parent;
+                    aw_ccu_mod_clk[(__u32)clk->id].onoff  = clk->onoff;
+                    aw_ccu_mod_clk[(__u32)clk->id].reset  = clk->reset;
+                    aw_ccu_mod_clk[(__u32)clk->id].rate   = clk->rate;
+
+                    return AW_CCU_ERR_NONE;
+                }
+                else
+                {
+                    CCU_ERR("set %s reset status to %d failed!\n", clk->name, clk->reset);
+                }
+
+                /* resetore on/off status */
+                mod_clk_set_status(clk->id, tmpClk.onoff);
+            }
+            else
+            {
+                CCU_ERR("set %s on/off status to %d failed!\n", clk->name, clk->onoff);
+            }
+
+            /* restore clock rate */
+            mod_clk_set_rate_hz(clk->id, tmpClk.rate);
+        }
+        else
+        {
+            CCU_ERR("set %s clock rate to %lld failed!\n", clk->name, clk->rate);
+        }
+
+        /* restore clock parent */
+        mod_clk_set_parent(clk->id, tmpClk.parent);
+    }
+    else
+    {
+        CCU_ERR("set %s clock parent to (id = %d) failed!\n", clk->name, (__s32)clk->parent);
+    }
+
+    /* update clock manager paremter */
+    aw_ccu_mod_clk[(__u32)clk->id].parent = tmpClk.parent;
+    aw_ccu_mod_clk[(__u32)clk->id].onoff  = tmpClk.onoff;
+    aw_ccu_mod_clk[(__u32)clk->id].reset  = tmpClk.reset;
+    aw_ccu_mod_clk[(__u32)clk->id].rate   = tmpClk.rate;
+
+    return AW_CCU_ERR_PARA_INVALID;
+}
+
diff --git a/arch/arm/mach-sun5i/clock/ccmu/ccm_sys_clk.c b/arch/arm/mach-sun5i/clock/ccmu/ccm_sys_clk.c
new file mode 100644
index 0000000..e22a19c
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/ccmu/ccm_sys_clk.c
@@ -0,0 +1,1239 @@
+/*
+ * arch/arm/mach-sun5i/clock/ccmu/ccm_sys_clk.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include <mach/system.h>
+#include <asm/delay.h>
+#include "ccm_i.h"
+
+
+#define make_sys_clk_inf(clk_id, clk_name)    {.id = clk_id, .name = clk_name,}
+
+
+
+static __aw_ccu_clk_t aw_ccu_sys_clk[] =
+{
+    make_sys_clk_inf(AW_SYS_CLK_NONE,   "sclk_none"     ),
+    make_sys_clk_inf(AW_SYS_CLK_LOSC,   "losc"          ),
+    make_sys_clk_inf(AW_SYS_CLK_HOSC,   "hosc"          ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL1,   "core_pll"      ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL2,   "audio_pll"     ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL2X8, "audio_pllx8"   ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL3,   "video_pll0"    ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL3X2, "video_pll0x2"  ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL4,   "ve_pll"        ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL5,   "sdram_pll"     ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL5M,  "sdram_pll_m"   ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL5P,  "sdram_pll_p"   ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL6,   "sata_pll"      ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL7,   "video_pll1"    ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL7X2, "video_pll1x2"  ),
+    make_sys_clk_inf(AW_SYS_CLK_200M,   "200m_pll"      ),
+    make_sys_clk_inf(AW_SYS_CLK_CPU,    "cpu"           ),
+    make_sys_clk_inf(AW_SYS_CLK_AXI,    "axi"           ),
+    make_sys_clk_inf(AW_SYS_CLK_AHB,    "ahb"           ),
+    make_sys_clk_inf(AW_SYS_CLK_APB0,   "apb"           ),
+    make_sys_clk_inf(AW_SYS_CLK_APB1,   "apb1"          ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL6M,  "sata_pll_m"    ),
+    make_sys_clk_inf(AW_SYS_CLK_PLL62,  "sata_pll_2"    ),
+};
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_parent
+*
+*Description: get parent clock for system clock;
+*
+*Arguments  : id    system clock id;
+*
+*Return     : parent id;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_sys_clk_e sys_clk_get_parent(__aw_ccu_sys_clk_e id)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_PLL2X8:
+        {
+            return AW_SYS_CLK_PLL2;
+        }
+        case AW_SYS_CLK_PLL3X2:
+        {
+            return AW_SYS_CLK_PLL3;
+        }
+        case AW_SYS_CLK_PLL7X2:
+        {
+            return AW_SYS_CLK_PLL7;
+        }
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+        {
+            return AW_SYS_CLK_PLL5;
+        }
+        case AW_SYS_CLK_200M:
+        {
+            return AW_SYS_CLK_PLL62;
+        }
+        case AW_SYS_CLK_CPU:
+        {
+            switch(aw_ccu_reg->SysClkDiv.AC328ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_LOSC;
+                case 1:
+                    return AW_SYS_CLK_HOSC;
+                case 2:
+                    return AW_SYS_CLK_PLL1;
+                case 3:
+                default:
+                    return AW_SYS_CLK_200M;
+            }
+        }
+        case AW_SYS_CLK_AXI:
+        {
+            return AW_SYS_CLK_CPU;
+        }
+        case AW_SYS_CLK_AHB:
+        {
+            return AW_SYS_CLK_AXI;
+        }
+        case AW_SYS_CLK_APB0:
+        {
+            return AW_SYS_CLK_AHB;
+        }
+        case AW_SYS_CLK_APB1:
+        {
+            switch(aw_ccu_reg->Apb1ClkDiv.ClkSrc)
+            {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL62;
+                case 2:
+                    return AW_SYS_CLK_LOSC;
+                case 3:
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+        }
+        default:
+        {
+            return AW_SYS_CLK_NONE;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_status
+*
+*Description: get system clock on/off status.
+*
+*Arguments  : id    system clock id;
+*
+*Return     : system clock status;
+*               0, clock is off;
+*              !0, clock is on;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_onff_e sys_clk_get_status(__aw_ccu_sys_clk_e id)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return AW_CCU_CLK_ON;
+        case AW_SYS_CLK_HOSC:
+            return aw_ccu_reg->HoscCtl.OSC24MEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_SYS_CLK_PLL1:
+            return aw_ccu_reg->Pll1Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL2:
+        case AW_SYS_CLK_PLL2X8:
+            return aw_ccu_reg->Pll2Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL3X2:
+            return aw_ccu_reg->Pll3Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL4:
+            return aw_ccu_reg->Pll4Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL5:
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+            return aw_ccu_reg->Pll5Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL6:
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62:
+            return aw_ccu_reg->Pll6Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL7X2:
+            return aw_ccu_reg->Pll7Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_200M:
+            return aw_ccu_reg->Pll6Ctl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_SYS_CLK_CPU:
+        case AW_SYS_CLK_AXI:
+        case AW_SYS_CLK_AHB:
+        case AW_SYS_CLK_APB0:
+        case AW_SYS_CLK_APB1:
+        default:
+            return AW_CCU_CLK_ON;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_rate
+*
+*Description: get clock rate for system clock;
+*
+*Arguments  : id    system clock id;
+*
+*Return     : clock rate;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s64 sys_clk_get_rate(__aw_ccu_sys_clk_e id)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_NONE:
+        {
+            return 1;
+        }
+
+        case AW_SYS_CLK_LOSC:
+        {
+            return 32768;
+        }
+        case AW_SYS_CLK_HOSC:
+        {
+            return 24000000;
+        }
+        case AW_SYS_CLK_PLL1:
+        {
+            return ccu_clk_uldiv(((__s64)24000000*aw_ccu_reg->Pll1Ctl.FactorN*(aw_ccu_reg->Pll1Ctl.FactorK + 1)   \
+                >> aw_ccu_reg->Pll1Ctl.PLLDivP), (aw_ccu_reg->Pll1Ctl.FactorM + 1));
+        }
+        case AW_SYS_CLK_PLL2:
+        {
+            /* chip is version B:
+                FactorN=79, PreDiv=21, PostDiv=4, output=24*79/21/4=22.571mhz, 44.1k series fs
+                FactorN=86, PreDiv=21, PostDiv=4, output=24*86/21/4=24.571mhz, 48k series fs */
+
+            __u32   tmpReg;
+
+            tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+            if(((tmpReg>>8) & 0x7f) == 79)
+            {
+                return 22579200;
+            }
+            else if(((tmpReg>>8) & 0x7f) == 86)
+            {
+                return 24576000;
+            }
+            else
+            {
+                /* set audio pll to default value 24576000 */
+                tmpReg &= ~((0x1f<<0)|(0x7f<<8)|(0x0f<<26));
+                tmpReg |= (21<<0)|(86<<8)|(3<<26);
+                *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+                return 24576000;
+            }
+        }
+        case AW_SYS_CLK_PLL2X8:
+        {
+            if(sys_clk_get_rate(AW_SYS_CLK_PLL2) == 24576000)
+            {
+                return 24576000 * 18;
+            }
+            else
+            {
+                return 22579200 * 20;
+            }
+        }
+        case AW_SYS_CLK_PLL3:
+        {
+            __s64   tmp_rate;
+
+            if(!aw_ccu_reg->Pll3Ctl.ModeSel)
+            {
+                if(aw_ccu_reg->Pll3Ctl.FracSet)
+                {
+                    return 297000000;
+                }
+                else
+                {
+                    return 270000000;
+                }
+            }
+            else
+            {
+                tmp_rate = 3000000*aw_ccu_reg->Pll3Ctl.FactorM;
+                /* skip 270M and 297M */
+                if(tmp_rate == 270000000)
+                {
+                    return 273000000;
+                }
+                else if(tmp_rate == 297000000)
+                {
+                    return 300000000;
+                }
+
+                return tmp_rate;
+            }
+        }
+        case AW_SYS_CLK_PLL3X2:
+        {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL3) << 1;
+        }
+
+        case AW_SYS_CLK_PLL4:
+        {
+            return ccu_clk_uldiv(((__s64)24000000*aw_ccu_reg->Pll4Ctl.FactorN * (aw_ccu_reg->Pll4Ctl.FactorK + 1)   \
+                >> aw_ccu_reg->Pll4Ctl.FactorP), (aw_ccu_reg->Pll4Ctl.FactorM + 1));
+        }
+        case AW_SYS_CLK_PLL5:
+        {
+            return (__s64)24000000*aw_ccu_reg->Pll5Ctl.FactorN * (aw_ccu_reg->Pll5Ctl.FactorK + 1);
+        }
+        case AW_SYS_CLK_PLL5M:
+        {
+            return ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_PLL5), (aw_ccu_reg->Pll5Ctl.FactorM + 1));
+        }
+        case AW_SYS_CLK_PLL5P:
+        {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL5) >> aw_ccu_reg->Pll5Ctl.FactorP;
+        }
+        case AW_SYS_CLK_PLL6:
+        {
+            return (__s64)24000000*aw_ccu_reg->Pll6Ctl.FactorN*(aw_ccu_reg->Pll6Ctl.FactorK + 1);
+        }
+        case AW_SYS_CLK_PLL6M:
+        {
+            return ccu_clk_uldiv((__s64)24000000*aw_ccu_reg->Pll6Ctl.FactorN*(aw_ccu_reg->Pll6Ctl.FactorK + 1),   \
+                (aw_ccu_reg->Pll6Ctl.FactorM + 1) * 6);
+        }
+        case AW_SYS_CLK_PLL62:
+        {
+            return (__s64)24000000*aw_ccu_reg->Pll6Ctl.FactorN*(aw_ccu_reg->Pll6Ctl.FactorK + 1)>>1;
+        }
+        case AW_SYS_CLK_PLL7:
+        {
+            if(!aw_ccu_reg->Pll7Ctl.ModeSel)
+            {
+                if(aw_ccu_reg->Pll7Ctl.FracSet)
+                {
+                    return 297000000;
+                }
+                else
+                {
+                    return 270000000;
+                }
+            }
+            else
+            {
+                return (__s64)3000000*aw_ccu_reg->Pll7Ctl.FactorM;
+            }
+        }
+        case AW_SYS_CLK_PLL7X2:
+        {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL7) << 1;
+        }
+        case AW_SYS_CLK_200M:
+        {
+            return 200000000;
+        }
+        case AW_SYS_CLK_CPU:
+        {
+            __u32   tmpCpuRate;
+            switch(aw_ccu_reg->SysClkDiv.AC328ClkSrc)
+            {
+                case 0:
+                    tmpCpuRate = 32768;
+                    break;
+                case 1:
+                    tmpCpuRate = 24000000;
+                    break;
+                case 2:
+                    tmpCpuRate = sys_clk_get_rate(AW_SYS_CLK_PLL1);
+                    break;
+                case 3:
+                default:
+                    tmpCpuRate = 200000000;
+                    break;
+            }
+            return tmpCpuRate;
+        }
+        case AW_SYS_CLK_AXI:
+        {
+            return ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU), (aw_ccu_reg->SysClkDiv.AXIClkDiv + 1));
+        }
+        case AW_SYS_CLK_AHB:
+        {
+            return sys_clk_get_rate(AW_SYS_CLK_AXI) >> aw_ccu_reg->SysClkDiv.AHBClkDiv;
+        }
+        case AW_SYS_CLK_APB0:
+        {
+            __s32   tmpShift = aw_ccu_reg->SysClkDiv.APB0ClkDiv;
+
+            return sys_clk_get_rate(AW_SYS_CLK_AHB) >> (tmpShift? tmpShift : 1);
+        }
+        case AW_SYS_CLK_APB1:
+        {
+            __s64   tmpApb1Rate;
+            switch(aw_ccu_reg->Apb1ClkDiv.ClkSrc)
+            {
+                case 0:
+                    tmpApb1Rate = 24000000;
+                    break;
+                case 1:
+                    tmpApb1Rate = sys_clk_get_rate(AW_SYS_CLK_PLL62);
+                    break;
+                case 2:
+                    tmpApb1Rate = 32768;
+                    break;
+                default:
+                    tmpApb1Rate = 0;
+                    break;
+            }
+            return ccu_clk_uldiv((tmpApb1Rate >> aw_ccu_reg->Apb1ClkDiv.PreDiv), (aw_ccu_reg->Apb1ClkDiv.ClkDiv + 1));
+        }
+        default:
+        {
+            return 0;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_parent
+*
+*Description: set parent clock id for system clock;
+*
+*Arguments  : id        system clock id whose parent need be set;
+*             parent    parent id to be set;
+*
+*Return     : result,
+*               0,  set parent successed;
+*              !0,  set parent failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_parent(__aw_ccu_sys_clk_e id, __aw_ccu_sys_clk_e parent)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_PLL2X8:
+            return (parent == AW_SYS_CLK_PLL2)? 0 : -1;
+
+        case AW_SYS_CLK_PLL3X2:
+            return (parent == AW_SYS_CLK_PLL3)? 0 : -1;
+
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+            return (parent == AW_SYS_CLK_PLL5)? 0 : -1;
+
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62:
+            return (parent == AW_SYS_CLK_PLL6)? 0 : -1;
+
+        case AW_SYS_CLK_PLL7X2:
+            return (parent == AW_SYS_CLK_PLL7)? 0 : -1;
+
+        case AW_SYS_CLK_200M:
+            return (parent == AW_SYS_CLK_PLL62)? 0 : -1;
+
+        case AW_SYS_CLK_CPU:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->SysClkDiv.AC328ClkSrc = 0;
+                    break;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->SysClkDiv.AC328ClkSrc = 1;
+                    break;
+                case AW_SYS_CLK_PLL1:
+                    aw_ccu_reg->SysClkDiv.AC328ClkSrc = 2;
+                    break;
+                case AW_SYS_CLK_200M:
+                    aw_ccu_reg->SysClkDiv.AC328ClkSrc = 3;
+                    break;
+                default:
+                    return -1;
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_AXI:
+            return (parent == AW_SYS_CLK_CPU)? 0 : -1;
+        case AW_SYS_CLK_AHB:
+            return (parent == AW_SYS_CLK_AXI)? 0 : -1;
+        case AW_SYS_CLK_APB0:
+            return (parent == AW_SYS_CLK_AHB)? 0 : -1;
+        case AW_SYS_CLK_APB1:
+        {
+            switch(parent)
+            {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 2;
+                    break;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 0;
+                    break;
+                case AW_SYS_CLK_PLL62:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 1;
+                    break;
+                default:
+                    return -1;
+            }
+            return 0;
+        }
+
+        case AW_SYS_CLK_LOSC:
+        case AW_SYS_CLK_HOSC:
+        case AW_SYS_CLK_PLL1:
+        case AW_SYS_CLK_PLL2:
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL4:
+        case AW_SYS_CLK_PLL5:
+        case AW_SYS_CLK_PLL6:
+        case AW_SYS_CLK_PLL7:
+        {
+            return (parent == AW_SYS_CLK_NONE)? 0 : -1;
+        }
+
+        default:
+        {
+            return -1;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_status
+*
+*Description: set on/off status for system clock;
+*
+*Arguments  : id        system clock id;
+*             status    on/off status;
+*                           AW_CCU_CLK_OFF - off
+*                           AW_CCU_CLK_ON - on
+*
+*Return     : result;
+*               0,  set status successed;
+*              !0,  set status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_status(__aw_ccu_sys_clk_e id, __aw_ccu_clk_onff_e status)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return 0;
+        case AW_SYS_CLK_HOSC:
+            aw_ccu_reg->HoscCtl.OSC24MEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL1:
+            aw_ccu_reg->Pll1Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL2:
+            aw_ccu_reg->Pll2Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL2X8:
+        {
+            if(status && !aw_ccu_reg->Pll2Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL3:
+            aw_ccu_reg->Pll3Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL3X2:
+        {
+            if(status && !aw_ccu_reg->Pll3Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL4:
+            aw_ccu_reg->Pll4Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL5:
+            aw_ccu_reg->Pll5Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+        {
+            if(status && !aw_ccu_reg->Pll5Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL6:
+            aw_ccu_reg->Pll6Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62:
+        {
+            if(status && !aw_ccu_reg->Pll6Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL7:
+            aw_ccu_reg->Pll7Ctl.PLLEn = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL7X2:
+        {
+            if(status && !aw_ccu_reg->Pll7Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_200M:
+        {
+            if(status && !aw_ccu_reg->Pll6Ctl.PLLEn)
+            {
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_CPU:
+        case AW_SYS_CLK_AXI:
+        case AW_SYS_CLK_AHB:
+        case AW_SYS_CLK_APB0:
+        case AW_SYS_CLK_APB1:
+            return 0;
+
+        default:
+        {
+            return -1;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_rate
+*
+*Description: set clock rate for system clock;
+*
+*Arguments  : id    system clock id;
+*             rate  clock rate for system clock;
+*
+*Return     : result,
+*               0,  set system clock rate successed;
+*              !0,  set system clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_rate(__aw_ccu_sys_clk_e id, __s64 rate)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return (rate == 32768)? 0 : -1;
+
+        case AW_SYS_CLK_HOSC:
+            return (rate == 24000000)? 0 : -1;
+        case AW_SYS_CLK_PLL1:
+        {
+            struct core_pll_factor_t    factor;
+            __ccmu_pll1_core_reg0000_t  tmp_pll;
+
+            /* the setting of pll1 must be called by cpu-freq driver, and adjust pll step by step */
+            ccm_clk_get_pll_para(&factor, rate);
+            /* set factor */
+            tmp_pll = aw_ccu_reg->Pll1Ctl;
+            tmp_pll.FactorN = factor.FactorN;
+            tmp_pll.FactorK = factor.FactorK;
+            tmp_pll.FactorM = factor.FactorM;
+            tmp_pll.PLLDivP = factor.FactorP;
+            aw_ccu_reg->Pll1Ctl = tmp_pll;
+            /* delay 500us for pll be stably */
+            __delay((rate >> 20) * 500 / 2);
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL2:
+        {
+            if(rate == 22579200)
+            {
+                /* chip is version B, FactorN=79, PreDiv=21, PostDiv=4,
+                   output=24*79/21/4=22.571mhz, 44.1k series fs     */
+                __u32   tmpReg;
+
+                tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+                tmpReg &= ~((0x1f<<0)|(0x7f<<8)|(0x0f<<26));
+                tmpReg |= (21<<0)|(79<<8)|(3<<26);
+                *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+            }
+            else if(rate == 24576000)
+            {
+                /* chip is version B, FactorN=86, PreDiv=21, PostDiv=4,
+                   output=24*86/21/4=24.571mhz, 48k series fs       */
+                __u32   tmpReg;
+
+                tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+                tmpReg &= ~((0x1f<<0)|(0x7f<<8)|(0x0f<<26));
+                tmpReg |= (21<<0)|(86<<8)|(3<<26);
+                *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+            }
+            else
+            {
+                return -1;
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL2X8:
+        {
+            if((sys_clk_get_rate(AW_SYS_CLK_PLL2) == 24576000) && (rate == 24576000 * 18))
+            {
+                return 0;
+            }
+            else if((sys_clk_get_rate(AW_SYS_CLK_PLL2) == 22579200) && (rate == 24576000 * 20))
+
+            {
+                return 0;
+            }
+
+            return -1;
+        }
+        case AW_SYS_CLK_PLL3:
+        {
+            if((rate < 9*3000000) || (rate > (127*3000000)))
+            {
+                CCU_ERR("Rate(%lld) is invalid when set PLL3 rate!\n", rate);
+                return -1;
+            }
+
+            if(rate == 270000000)
+            {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll3Ctl.FracSet = 0;
+            }
+            else if(rate == 297000000)
+            {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll3Ctl.FracSet = 1;
+            }
+            else
+            {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 1;
+                aw_ccu_reg->Pll3Ctl.FactorM = ccu_clk_uldiv(rate + (3000000 - 1), 3000000);
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL3X2:
+        {
+            if(rate == (sys_clk_get_rate(AW_SYS_CLK_PLL3) << 1))
+            {
+                return 0;
+            }
+            return -1;
+        }
+        case AW_SYS_CLK_PLL4:
+        {
+            struct core_pll_factor_t    factor;
+            __u32   tmpDly = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU), 1000000) * 200;
+
+            ccm_clk_get_pll_para(&factor, rate);
+
+            /* set the correct parameter for PLL */
+            aw_ccu_reg->Pll4Ctl.FactorN = factor.FactorN;
+            aw_ccu_reg->Pll4Ctl.FactorK = factor.FactorK;
+            aw_ccu_reg->Pll4Ctl.FactorM = factor.FactorM;
+            aw_ccu_reg->Pll4Ctl.FactorP = factor.FactorP;
+            /* delay 200us for pll be stably */
+            __delay(tmpDly);
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5:
+        {
+            __s32   tmpFactorN, tmpFactorK;
+
+            if(rate < 240000000)
+            {
+                CCU_ERR("Rate(%lld) is invalid when set PLL5 rate!\n", rate);
+                return -1;
+            }
+
+            if(rate < 480000000)
+            {
+                tmpFactorK = 0;
+            }
+            else if(rate < 960000000)
+            {
+                tmpFactorK = 1;
+            }
+            else if(rate < 2000000000)
+            {
+                tmpFactorK = 3;
+            }
+            else
+            {
+                CCU_ERR("Rate (%lld) is invaid for PLL5!\n", rate);
+                return -1;
+            }
+
+            tmpFactorN = ccu_clk_uldiv(rate + (((tmpFactorK+1) * 24000000) - 1), ((tmpFactorK+1) * 24000000));
+            if(tmpFactorN > 31)
+            {
+                CCU_ERR("Rate (%lld) is invaid for PLL5!\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Pll5Ctl.FactorN = tmpFactorN;
+            aw_ccu_reg->Pll5Ctl.FactorK = tmpFactorK;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5M:
+        {
+            __u32   tmpFactorM;
+            __s64   tmpPLL5;
+
+            tmpPLL5 = sys_clk_get_rate(AW_SYS_CLK_PLL5);
+            if((rate > tmpPLL5) || (tmpPLL5 > rate*4))
+            {
+                CCU_ERR("PLL5(%lld) rate is invalid for PLL5M(%lld)!\n", tmpPLL5, rate);
+                return -1;
+            }
+
+            tmpFactorM = ccu_clk_uldiv(tmpPLL5 + (rate - 1), rate);
+            aw_ccu_reg->Pll5Ctl.FactorM = tmpFactorM-1;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5P:
+        {
+            __s32   tmpFactorP = -1;
+            __s64   tmpPLL5 = sys_clk_get_rate(AW_SYS_CLK_PLL5);
+
+            if((rate > tmpPLL5) || (tmpPLL5 > rate*8))
+            {
+                CCU_ERR("PLL5(%lld) rate is invalid for PLL5P(%lld)!\n", tmpPLL5, rate);
+                return -1;
+            }
+
+            do{rate <<= 1; tmpFactorP++;}while(rate < tmpPLL5);
+            aw_ccu_reg->Pll5Ctl.FactorP = tmpFactorP;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL6:
+        {
+            __s32   tmpFactorN, tmpFactorK;
+
+            if(rate <= 600000000)
+                tmpFactorK = 0;
+            else if(rate <= 1200000000)
+                tmpFactorK = 1;
+            else
+            {
+                CCU_ERR("Rate (%lld) is invaid for PLL6!\n", rate);
+                return -1;
+            }
+
+            tmpFactorN = ccu_clk_uldiv(rate, ((tmpFactorK+1) * 24000000));
+            if(tmpFactorN > 31)
+            {
+                CCU_ERR("Rate (%lld) is invaid for PLL6!\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Pll6Ctl.FactorN = tmpFactorN;
+            aw_ccu_reg->Pll6Ctl.FactorK = tmpFactorK;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL6M:
+        {
+            __s64   tmpPLL6 = sys_clk_get_rate(AW_SYS_CLK_PLL6);
+            __s32   tmpFactorM = ccu_clk_uldiv(tmpPLL6, rate*6);
+
+            tmpFactorM = tmpFactorM ? tmpFactorM : 1;
+            aw_ccu_reg->Pll6Ctl.FactorM = tmpFactorM - 1;
+            return 0;
+        }
+        case AW_SYS_CLK_PLL62:
+        {
+            /* rate of AW_SYS_CLK_PLL62 is always the half of the rate of AW_SYS_CLK_PLL6 */
+            return 0;
+        }
+        case AW_SYS_CLK_PLL7:
+        {
+            if((rate < 9*3000000) || (rate > (127*3000000)))
+            {
+                CCU_ERR("Rate(%lld) is invalid when set PLL7 rate!\n", rate);
+                return -1;
+            }
+
+            if(rate == 270000000)
+            {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll7Ctl.FracSet = 0;
+            }
+            else if(rate == 297000000)
+            {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll7Ctl.FracSet = 1;
+            }
+            else
+            {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 1;
+                aw_ccu_reg->Pll7Ctl.FactorM = ccu_clk_uldiv(rate + (3000000 - 1), 3000000);
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL7X2:
+        {
+            if(rate == (sys_clk_get_rate(AW_SYS_CLK_PLL7) << 1))
+            {
+                return 0;
+            }
+            return -1;
+        }
+        case AW_SYS_CLK_200M:
+        {
+            if(rate == 200000000)
+            {
+                return 0;
+            }
+            else
+            {
+                return -1;
+            }
+        }
+        case AW_SYS_CLK_CPU:
+        {
+            __s64   tmpRate = sys_clk_get_rate(sys_clk_get_parent(AW_SYS_CLK_CPU));
+
+            if(rate != tmpRate)
+            {
+                CCU_ERR("Rate(%lld) is invalid when set cpu rate(%lld)\n", rate, tmpRate);
+                CCU_ERR("0xf1c20000 = 0x%x\n", *(volatile __u32 *)0xf1c20000);
+                return -1;
+            }
+            else
+            {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_AXI:
+        {
+            __s32   tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU) + (rate - 1), rate);
+            if(tmpDiv > 4)
+            {
+                CCU_ERR("Rate(%lld) is invalid when set axi rate\n", rate);
+                return -1;
+            }
+            tmpDiv = tmpDiv? (tmpDiv-1) : 0;
+            aw_ccu_reg->SysClkDiv.AXIClkDiv = tmpDiv;
+
+            return 0;
+        }
+        case AW_SYS_CLK_AHB:
+        {
+            __s32   tmpVal = -1, tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_AXI) + (rate - 1), rate);
+
+            if(tmpDiv > 8)
+            {
+                CCU_ERR("Rate(%lld) is invalid for set AHB rate!\n", rate);
+                return -1;
+            }
+
+            do{tmpDiv >>= 1; tmpVal++;}while(tmpDiv);
+            aw_ccu_reg->SysClkDiv.AHBClkDiv = tmpVal;
+
+            return 0;
+        }
+        case AW_SYS_CLK_APB0:
+        {
+            __s32   tmpVal = -1, tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_AHB) + (rate - 1), rate);
+
+            if(tmpDiv > 8)
+            {
+                CCU_ERR("Rate(%lld) is invalid for set APB0 rate!\n", rate);
+                return -1;
+            }
+
+            do{tmpDiv >>= 1; tmpVal++;}while(tmpDiv);
+            aw_ccu_reg->SysClkDiv.APB0ClkDiv = tmpVal;
+
+            return 0;
+        }
+        case AW_SYS_CLK_APB1:
+        {
+            __s64   tmpRate = sys_clk_get_rate(sys_clk_get_parent(AW_SYS_CLK_APB1));
+            __s32   tmpDivP, tmpDivM;
+
+            if(tmpRate < rate)
+            {
+                CCU_ERR(" Rate (%lld) is invalid for set APB1 rate, parent is (%lld)!\n", rate, tmpRate);
+                return -1;
+            }
+
+            tmpRate = ccu_clk_uldiv(tmpRate + (rate - 1), rate);
+            if(tmpRate <= 4)
+            {
+                tmpDivP = 0;
+                tmpDivM = tmpRate - 1;
+            }
+            else if(tmpRate <= 8)
+            {
+                tmpDivP = 1;
+                tmpDivM = (tmpRate>>1) - 1;
+            }
+            else if(tmpRate <= 16)
+            {
+                tmpDivP = 2;
+                tmpDivM = (tmpRate>>2) - 1;
+            }
+            else if(tmpRate <= 32)
+            {
+                tmpDivP = 3;
+                tmpDivM = (tmpRate>>3) - 1;
+            }
+            else
+            {
+                CCU_ERR("Rate(%lld) is invalid for set APB1 rate!\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Apb1ClkDiv.PreDiv = tmpDivP;
+            aw_ccu_reg->Apb1ClkDiv.ClkDiv = tmpDivM;
+
+            return 0;
+        }
+        default:
+        {
+            CCU_ERR("clock id(%d) is invaid when set rate!\n", (__s32)id);
+            return -1;
+        }
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get_sys_clk_cnt
+*
+*Description: get the count of the system clock.
+*
+*Arguments  : none
+*
+*Return     : count of system clock;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 aw_ccu_get_sys_clk_cnt(void)
+{
+    return (__u32)AW_SYS_CLK_CNT;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get_sys_clk
+*
+*Description: get system clock information by clock id.
+*
+*Arguments  : id    system clock id;
+*
+*Return     : system clock handle, return NULL if get clock information failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__aw_ccu_clk_t *aw_ccu_get_sys_clk(__aw_ccu_sys_clk_e id)
+{
+    __s32   tmpIdx = (__u32)id;
+
+    /* check if clock id is valid   */
+    if((id < AW_SYS_CLK_NONE) || (id >= AW_SYS_CLK_CNT))
+    {
+        CCU_ERR("ID is invalid when get system clock information!\n");
+        return NULL;
+    }
+
+    /* query system clock information from hardware */
+    aw_ccu_sys_clk[tmpIdx].parent = sys_clk_get_parent(id);
+    aw_ccu_sys_clk[tmpIdx].onoff  = sys_clk_get_status(id);
+    aw_ccu_sys_clk[tmpIdx].rate   = sys_clk_get_rate(id);
+    aw_ccu_sys_clk[tmpIdx].hash   = ccu_clk_calc_hash(aw_ccu_sys_clk[tmpIdx].name);
+
+    return &aw_ccu_sys_clk[tmpIdx];
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_set_sys_clk
+*
+*Description: set system clock parameters;
+*
+*Arguments  : clk   handle of system clock;
+*
+*Return     : error type.
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__aw_ccu_err_e aw_ccu_set_sys_clk(__aw_ccu_clk_t *clk)
+{
+    __aw_ccu_clk_t  tmpClk;
+
+    if(!clk)
+    {
+        CCU_ERR("Clock handle is NULL when set system clock!\n");
+        return AW_CCU_ERR_PARA_NULL;
+    }
+
+    /* backup old parameter */
+    tmpClk.parent = sys_clk_get_parent(clk->id);
+    tmpClk.rate   = sys_clk_get_rate(clk->id);
+    tmpClk.onoff  = sys_clk_get_status(clk->id);
+
+    /* try to set new parameter */
+    if(tmpClk.parent != clk->parent)
+    {
+        /* update parent */
+        if(sys_clk_set_parent(clk->id, clk->parent))
+        {
+            CCU_ERR("try to set %s parent to %s failed!\n", clk->name, aw_ccu_sys_clk[clk->parent].name);
+            goto _restore_clk_pare;
+        }
+
+        /* update clock parent */
+        clk->parent = sys_clk_get_parent(clk->id);
+        /* update clock rate */
+        clk->rate = sys_clk_get_rate(clk->id);
+        /* update clock status */
+        clk->onoff = sys_clk_get_status(clk->id);
+        return AW_CCU_ERR_NONE;
+    }
+
+    if(tmpClk.rate != clk->rate)
+    {
+        /* update clock rate */
+        if(sys_clk_set_rate(clk->id, clk->rate))
+        {
+            CCU_ERR("try to set %s rate to %lld failed!\n", clk->name, clk->rate);
+            goto _restore_clk_pare;
+        }
+        /* update clock rate */
+        clk->rate = sys_clk_get_rate(clk->id);
+        /* update clock status */
+        clk->onoff = sys_clk_get_status(clk->id);
+        return AW_CCU_ERR_NONE;
+    }
+
+    if(tmpClk.onoff != clk->onoff)
+    {
+        /* update clock rate */
+        if(sys_clk_set_status(clk->id, clk->onoff))
+        {
+            CCU_ERR("try to set %s status to %d failed!\n", clk->name, clk->onoff);
+            goto _restore_clk_pare;
+        }
+        /* update clock status */
+        clk->onoff = sys_clk_get_status(clk->id);
+        return AW_CCU_ERR_NONE;
+    }
+
+    /* nothing is need be updated */
+    return AW_CCU_ERR_NONE;
+
+    _restore_clk_pare:
+
+    /* restore clock parameter  */
+    sys_clk_set_parent(clk->id, tmpClk.parent);
+    sys_clk_set_rate(clk->id, tmpClk.rate);
+    sys_clk_set_status(clk->id, tmpClk.onoff);
+
+    /* update clock manager paremter */
+    clk->parent = tmpClk.parent;
+    clk->onoff  = tmpClk.onoff;
+    clk->rate   = tmpClk.rate;
+
+    return AW_CCU_ERR_PARA_INVALID;
+}
+
diff --git a/arch/arm/mach-sun5i/clock/ccmu/ccu_dbg.c b/arch/arm/mach-sun5i/clock/ccmu/ccu_dbg.c
new file mode 100644
index 0000000..357fea7
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/ccmu/ccu_dbg.c
@@ -0,0 +1,671 @@
+/*
+ * arch/arm/mach-sun5i/clock/ccmu/ccm_dbg.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include "ccm_i.h"
+
+
+#define print_clk_inf(x, y)     do{printk(#x"."#y":%d\n", aw_ccu_reg->x.y);}while(0)
+
+
+void clk_dbg_inf(void)
+{
+    printk("---------------------------------------------\n");
+    printk("    dump clock information                   \n");
+    printk("---------------------------------------------\n");
+
+    printk("PLL1 infor:\n");
+    print_clk_inf(Pll1Ctl, FactorM      );
+    print_clk_inf(Pll1Ctl, SigmaEn      );
+    print_clk_inf(Pll1Ctl, SigmaIn      );
+    print_clk_inf(Pll1Ctl, FactorK      );
+    print_clk_inf(Pll1Ctl, FactorN      );
+    print_clk_inf(Pll1Ctl, LockTime     );
+    print_clk_inf(Pll1Ctl, PLLDivP      );
+    print_clk_inf(Pll1Ctl, PLLBias      );
+    print_clk_inf(Pll1Ctl, VCOBias      );
+    print_clk_inf(Pll1Ctl, VCORstIn     );
+    print_clk_inf(Pll1Ctl, PLLEn        );
+
+    printk("\nPLL2 infor:\n");
+    print_clk_inf(Pll2Ctl, PrevDiv      );
+    print_clk_inf(Pll2Ctl, FactorN      );
+    print_clk_inf(Pll2Ctl, PLLBias      );
+    print_clk_inf(Pll2Ctl, PLLEn        );
+
+    printk("\nPLL3 infor:\n");
+    print_clk_inf(Pll3Ctl, FactorM      );
+    print_clk_inf(Pll3Ctl, PLLBias      );
+    print_clk_inf(Pll3Ctl, FracSet      );
+    print_clk_inf(Pll3Ctl, ModeSel      );
+    print_clk_inf(Pll3Ctl, VCOBias      );
+    print_clk_inf(Pll3Ctl, DampFactor   );
+    print_clk_inf(Pll3Ctl, PLLEn        );
+
+    printk("\nPLL4 infor:\n");
+    print_clk_inf(Pll4Ctl, FactorM      );
+    print_clk_inf(Pll4Ctl, FactorK      );
+    print_clk_inf(Pll4Ctl, FactorN      );
+    print_clk_inf(Pll4Ctl, FactorP      );
+    print_clk_inf(Pll4Ctl, VCOGain      );
+    print_clk_inf(Pll4Ctl, PLLBias      );
+    print_clk_inf(Pll4Ctl, VCOBias      );
+    print_clk_inf(Pll4Ctl, PLLBypass    );
+    print_clk_inf(Pll4Ctl, PLLEn        );
+
+    printk("\nPLL5 infor:\n");
+    print_clk_inf(Pll5Ctl, FactorM      );
+    print_clk_inf(Pll5Ctl, FactorM1     );
+    print_clk_inf(Pll5Ctl, FactorK      );
+    print_clk_inf(Pll5Ctl, LDO2En       );
+    print_clk_inf(Pll5Ctl, FactorN      );
+    print_clk_inf(Pll5Ctl, VCOGain      );
+    print_clk_inf(Pll5Ctl, FactorP      );
+    print_clk_inf(Pll5Ctl, BandWidth    );
+    print_clk_inf(Pll5Ctl, VCOGainEn    );
+    print_clk_inf(Pll5Ctl, PLLBias      );
+    print_clk_inf(Pll5Ctl, VCOBias      );
+    print_clk_inf(Pll5Ctl, OutputEn     );
+    print_clk_inf(Pll5Ctl, PLLBypass    );
+    print_clk_inf(Pll5Ctl, PLLEn        );
+
+    printk("\nPLL6 infor:\n");
+    print_clk_inf(Pll6Ctl, FactorM      );
+    print_clk_inf(Pll6Ctl, FactorK      );
+    print_clk_inf(Pll6Ctl, DampFactor   );
+    print_clk_inf(Pll6Ctl, FactorN      );
+    print_clk_inf(Pll6Ctl, BandWidth    );
+    print_clk_inf(Pll6Ctl, PLLBias      );
+    print_clk_inf(Pll6Ctl, VCOBias      );
+    print_clk_inf(Pll6Ctl, PLLBypass    );
+    print_clk_inf(Pll6Ctl, PLLEn        );
+
+    printk("\nPLL7 infor:\n");
+    print_clk_inf(Pll7Ctl, FactorM      );
+    print_clk_inf(Pll7Ctl, PLLBias      );
+    print_clk_inf(Pll7Ctl, FracSet      );
+    print_clk_inf(Pll7Ctl, ModeSel      );
+    print_clk_inf(Pll7Ctl, VCOBias      );
+    print_clk_inf(Pll7Ctl, DampFactor   );
+    print_clk_inf(Pll7Ctl, PLLEn        );
+
+    printk("\nHOSC infor:\n");
+    print_clk_inf(HoscCtl, OSC24MEn     );
+    print_clk_inf(HoscCtl, OSC24MGsm    );
+    print_clk_inf(HoscCtl, PLLBiasEn    );
+    print_clk_inf(HoscCtl, LDOEn        );
+    print_clk_inf(HoscCtl, PLLInPower   );
+    print_clk_inf(HoscCtl, LDOOutput    );
+    print_clk_inf(HoscCtl, KeyField     );
+
+    printk("\nCPU clk infor:\n");
+    print_clk_inf(SysClkDiv, AXIClkDiv  );
+    print_clk_inf(SysClkDiv, AHBClkDiv  );
+    print_clk_inf(SysClkDiv, APB0ClkDiv );
+    print_clk_inf(SysClkDiv, AC328ClkSrc);
+
+    printk("\nAPB1 clk infor:\n");
+    print_clk_inf(Apb1ClkDiv, ClkDiv    );
+    print_clk_inf(Apb1ClkDiv, PreDiv    );
+    print_clk_inf(Apb1ClkDiv, ClkSrc    );
+
+    printk("\nAxiGate clk infor:\n");
+    print_clk_inf(AxiGate, SdramGate    );
+
+    printk("\nAhbGate0 clk infor:\n");
+    print_clk_inf(AhbGate0, Usb0Gate    );
+    print_clk_inf(AhbGate0, Ehci0Gate   );
+    print_clk_inf(AhbGate0, Ohci0Gate   );
+    print_clk_inf(AhbGate0, SsGate      );
+    print_clk_inf(AhbGate0, DmaGate     );
+    print_clk_inf(AhbGate0, BistGate    );
+    print_clk_inf(AhbGate0, Sdmmc0Gate  );
+    print_clk_inf(AhbGate0, Sdmmc1Gate  );
+    print_clk_inf(AhbGate0, Sdmmc2Gate  );
+    print_clk_inf(AhbGate0, MsGate      );
+    print_clk_inf(AhbGate0, NandGate    );
+    print_clk_inf(AhbGate0, SdramGate   );
+    print_clk_inf(AhbGate0, EmacGate    );
+    print_clk_inf(AhbGate0, TsGate      );
+    print_clk_inf(AhbGate0, Spi0Gate    );
+    print_clk_inf(AhbGate0, Spi1Gate    );
+    print_clk_inf(AhbGate0, Spi2Gate    );
+    print_clk_inf(AhbGate0, GpsGate     );
+
+    printk("\nAhbGate1 clk infor:\n");
+    print_clk_inf(AhbGate1, VeGate      );
+    print_clk_inf(AhbGate1, Tve0Gate    );
+    print_clk_inf(AhbGate1, Lcd0Gate    );
+    print_clk_inf(AhbGate1, Csi0Gate    );
+    print_clk_inf(AhbGate1, HdmiDGate   );
+    print_clk_inf(AhbGate1, DeBe0Gate   );
+    print_clk_inf(AhbGate1, DeFe0Gate   );
+    print_clk_inf(AhbGate1, MaliGate    );
+
+    printk("\nApb0Gate clk infor:\n");
+    print_clk_inf(Apb0Gate, AddaGate    );
+    print_clk_inf(Apb0Gate, SpdifGate   );
+    print_clk_inf(Apb0Gate, IisGate     );
+    print_clk_inf(Apb0Gate, PioGate     );
+    print_clk_inf(Apb0Gate, Ir0Gate     );
+
+    printk("\nApb1Gate clk infor:\n");
+    print_clk_inf(Apb1Gate, Twi0Gate    );
+    print_clk_inf(Apb1Gate, Twi1Gate    );
+    print_clk_inf(Apb1Gate, Twi2Gate    );
+    print_clk_inf(Apb1Gate, Uart0Gate   );
+    print_clk_inf(Apb1Gate, Uart1Gate   );
+    print_clk_inf(Apb1Gate, Uart2Gate   );
+    print_clk_inf(Apb1Gate, Uart3Gate   );
+
+    printk("\nNandClk clk infor:\n");
+    print_clk_inf(NandClk, ClkDiv       );
+    print_clk_inf(NandClk, ClkPreDiv    );
+    print_clk_inf(NandClk, ClkSrc       );
+    print_clk_inf(NandClk, SpecClkGate  );
+
+    printk("\nMsClk clk infor:\n");
+    print_clk_inf(MsClk, ClkDiv         );
+    print_clk_inf(MsClk, ClkPreDiv      );
+    print_clk_inf(MsClk, ClkSrc         );
+    print_clk_inf(MsClk, SpecClkGate    );
+
+    printk("\nSdMmc0Clk clk infor:\n");
+    print_clk_inf(SdMmc0Clk, ClkDiv     );
+    print_clk_inf(SdMmc0Clk, ClkPreDiv  );
+    print_clk_inf(SdMmc0Clk, ClkSrc     );
+    print_clk_inf(SdMmc0Clk, SpecClkGate);
+
+    printk("\nSdMmc1Clk clk infor:\n");
+    print_clk_inf(SdMmc1Clk, ClkDiv     );
+    print_clk_inf(SdMmc1Clk, ClkPreDiv  );
+    print_clk_inf(SdMmc1Clk, ClkSrc     );
+    print_clk_inf(SdMmc1Clk, SpecClkGate);
+
+    printk("\nSdMmc2Clk clk infor:\n");
+    print_clk_inf(SdMmc2Clk, ClkDiv     );
+    print_clk_inf(SdMmc2Clk, ClkPreDiv  );
+    print_clk_inf(SdMmc2Clk, ClkSrc     );
+    print_clk_inf(SdMmc2Clk, SpecClkGate);
+
+    printk("\nTsClk clk infor:\n");
+    print_clk_inf(TsClk, ClkDiv         );
+    print_clk_inf(TsClk, ClkPreDiv      );
+    print_clk_inf(TsClk, ClkSrc         );
+    print_clk_inf(TsClk, SpecClkGate    );
+
+    printk("\nSsClk clk infor:\n");
+    print_clk_inf(SsClk, ClkDiv         );
+    print_clk_inf(SsClk, ClkPreDiv      );
+    print_clk_inf(SsClk, ClkSrc         );
+    print_clk_inf(SsClk, SpecClkGate    );
+
+    printk("\nSpi0Clk clk infor:\n");
+    print_clk_inf(Spi0Clk, ClkDiv       );
+    print_clk_inf(Spi0Clk, ClkPreDiv    );
+    print_clk_inf(Spi0Clk, ClkSrc       );
+    print_clk_inf(Spi0Clk, SpecClkGate  );
+
+    printk("\nSpi1Clk clk infor:\n");
+    print_clk_inf(Spi1Clk, ClkDiv       );
+    print_clk_inf(Spi1Clk, ClkPreDiv    );
+    print_clk_inf(Spi1Clk, ClkSrc       );
+    print_clk_inf(Spi1Clk, SpecClkGate  );
+
+    printk("\nSpi2Clk clk infor:\n");
+    print_clk_inf(Spi2Clk, ClkDiv       );
+    print_clk_inf(Spi2Clk, ClkPreDiv    );
+    print_clk_inf(Spi2Clk, ClkSrc       );
+    print_clk_inf(Spi2Clk, SpecClkGate  );
+
+    printk("\nIr0Clk clk infor:\n");
+    print_clk_inf(Ir0Clk, ClkDiv        );
+    print_clk_inf(Ir0Clk, ClkPreDiv     );
+    print_clk_inf(Ir0Clk, ClkSrc        );
+    print_clk_inf(Ir0Clk, SpecClkGate   );
+
+    printk("\nI2sClk clk infor:\n");
+    print_clk_inf(I2sClk, ClkDiv        );
+    print_clk_inf(I2sClk, SpecClkGate   );
+
+    printk("\nSpdifClk clk infor:\n");
+    print_clk_inf(SpdifClk, ClkDiv      );
+    print_clk_inf(SpdifClk, SpecClkGate );
+
+    printk("\nUsbClk clk infor:\n");
+    print_clk_inf(UsbClk, UsbPhy0Rst    );
+    print_clk_inf(UsbClk, UsbPhy1Rst    );
+    print_clk_inf(UsbClk, OHCI0SpecClkGate  );
+    print_clk_inf(UsbClk, PhySpecClkGate    );
+
+    printk("\nGpsClk clk infor:\n");
+    print_clk_inf(GpsClk, Reset         );
+    print_clk_inf(GpsClk, SpecClkGate   );
+
+    printk("\nDramGate clk infor:\n");
+    print_clk_inf(DramGate, VeGate      );
+    print_clk_inf(DramGate, Csi0Gate    );
+    print_clk_inf(DramGate, TsGate      );
+    print_clk_inf(DramGate, Tve0Gate    );
+    print_clk_inf(DramGate, DeFe0Gate   );
+    print_clk_inf(DramGate, DeBe0Gate   );
+
+    printk("\nDeBe0Clk clk infor:\n");
+    print_clk_inf(DeBe0Clk, ClkDiv      );
+    print_clk_inf(DeBe0Clk, ClkSrc      );
+    print_clk_inf(DeBe0Clk, Reset       );
+    print_clk_inf(DeBe0Clk, SpecClkGate );
+
+    printk("\nDeFe0Clk clk infor:\n");
+    print_clk_inf(DeFe0Clk, ClkDiv      );
+    print_clk_inf(DeFe0Clk, ClkSrc      );
+    print_clk_inf(DeFe0Clk, Reset       );
+    print_clk_inf(DeFe0Clk, SpecClkGate );
+
+    printk("\nLcd0Ch0Clk clk infor:\n");
+    print_clk_inf(Lcd0Ch0Clk, ClkSrc        );
+    print_clk_inf(Lcd0Ch0Clk, LcdReset      );
+    print_clk_inf(Lcd0Ch0Clk, SpecClkGate   );
+
+    printk("\nLcd0Ch1Clk clk infor:\n");
+    print_clk_inf(Lcd0Ch1Clk, ClkDiv        );
+    print_clk_inf(Lcd0Ch1Clk, SpecClk1Src   );
+    print_clk_inf(Lcd0Ch1Clk, SpecClk1Gate  );
+    print_clk_inf(Lcd0Ch1Clk, SpecClk2Src   );
+    print_clk_inf(Lcd0Ch1Clk, SpecClk2Gate  );
+
+    printk("\nCsi0Clk clk infor:\n");
+    print_clk_inf(Csi0Clk, ClkDiv       );
+    print_clk_inf(Csi0Clk, ClkSrc       );
+    print_clk_inf(Csi0Clk, Reset        );
+    print_clk_inf(Csi0Clk, SpecClkGate  );
+
+    printk("\nVeClk clk infor:\n");
+    print_clk_inf(VeClk, Reset          );
+    print_clk_inf(VeClk, SpecClkGate    );
+
+    printk("\nAddaClk clk infor:\n");
+    print_clk_inf(AddaClk, SpecClkGate  );
+
+    printk("\nAvsClk clk infor:\n");
+    print_clk_inf(AvsClk, SpecClkGate   );
+
+    printk("\nLvdsClk clk infor:\n");
+    print_clk_inf(LvdsClk, Reset        );
+
+    printk("\nHdmiClk clk infor:\n");
+    print_clk_inf(HdmiClk, ClkDiv       );
+    print_clk_inf(HdmiClk, ClkSrc       );
+    print_clk_inf(HdmiClk, SpecClkGate  );
+
+    printk("\nMaliClk clk infor:\n");
+    print_clk_inf(MaliClk, ClkDiv       );
+    print_clk_inf(MaliClk, ClkSrc       );
+    print_clk_inf(MaliClk, Reset        );
+    print_clk_inf(MaliClk, SpecClkGate  );
+}
+EXPORT_SYMBOL(clk_dbg_inf);
+
+#ifdef CONFIG_PROC_FS
+
+#define sprintf_clk_inf(buf, x, y)     do{seq_printf(buf, "\t"#x"."#y":%d\n", aw_ccu_reg->x.y);}while(0)
+static int ccmu_stats_show(struct seq_file *m, void *unused)
+{
+    seq_printf(m, "---------------------------------------------\n");
+    seq_printf(m, "clock information:                           \n");
+    seq_printf(m, "---------------------------------------------\n");
+
+    seq_printf(m, "\nPLL1 infor:\n");
+    sprintf_clk_inf(m, Pll1Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll1Ctl, SigmaEn      );
+    sprintf_clk_inf(m, Pll1Ctl, SigmaIn      );
+    sprintf_clk_inf(m, Pll1Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll1Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll1Ctl, LockTime     );
+    sprintf_clk_inf(m, Pll1Ctl, PLLDivP      );
+    sprintf_clk_inf(m, Pll1Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll1Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll1Ctl, VCORstIn     );
+    sprintf_clk_inf(m, Pll1Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL2 infor(0x%x):\n", *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl);
+    sprintf_clk_inf(m, Pll2Ctl, PrevDiv      );
+    sprintf_clk_inf(m, Pll2Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll2Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll2Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL3 infor:\n");
+    sprintf_clk_inf(m, Pll3Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll3Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll3Ctl, FracSet      );
+    sprintf_clk_inf(m, Pll3Ctl, ModeSel      );
+    sprintf_clk_inf(m, Pll3Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll3Ctl, DampFactor   );
+    sprintf_clk_inf(m, Pll3Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL4 infor:\n");
+    sprintf_clk_inf(m, Pll4Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll4Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll4Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll4Ctl, FactorP      );
+    sprintf_clk_inf(m, Pll4Ctl, VCOGain      );
+    sprintf_clk_inf(m, Pll4Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll4Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll4Ctl, PLLBypass    );
+    sprintf_clk_inf(m, Pll4Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL5 infor:\n");
+    sprintf_clk_inf(m, Pll5Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll5Ctl, FactorM1     );
+    sprintf_clk_inf(m, Pll5Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll5Ctl, LDO2En       );
+    sprintf_clk_inf(m, Pll5Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll5Ctl, VCOGain      );
+    sprintf_clk_inf(m, Pll5Ctl, FactorP      );
+    sprintf_clk_inf(m, Pll5Ctl, BandWidth    );
+    sprintf_clk_inf(m, Pll5Ctl, VCOGainEn    );
+    sprintf_clk_inf(m, Pll5Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll5Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll5Ctl, OutputEn     );
+    sprintf_clk_inf(m, Pll5Ctl, PLLBypass    );
+    sprintf_clk_inf(m, Pll5Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL6 infor:\n");
+    sprintf_clk_inf(m, Pll6Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll6Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll6Ctl, DampFactor   );
+    sprintf_clk_inf(m, Pll6Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll6Ctl, BandWidth    );
+    sprintf_clk_inf(m, Pll6Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll6Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll6Ctl, PLLBypass    );
+    sprintf_clk_inf(m, Pll6Ctl, PLLEn        );
+
+    seq_printf(m, "\nPLL7 infor:\n");
+    sprintf_clk_inf(m, Pll7Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll7Ctl, PLLBias      );
+    sprintf_clk_inf(m, Pll7Ctl, FracSet      );
+    sprintf_clk_inf(m, Pll7Ctl, ModeSel      );
+    sprintf_clk_inf(m, Pll7Ctl, VCOBias      );
+    sprintf_clk_inf(m, Pll7Ctl, DampFactor   );
+    sprintf_clk_inf(m, Pll7Ctl, PLLEn        );
+
+    seq_printf(m, "\nHOSC infor:\n");
+    sprintf_clk_inf(m, HoscCtl, OSC24MEn     );
+    sprintf_clk_inf(m, HoscCtl, OSC24MGsm    );
+    sprintf_clk_inf(m, HoscCtl, PLLBiasEn    );
+    sprintf_clk_inf(m, HoscCtl, LDOEn        );
+    sprintf_clk_inf(m, HoscCtl, PLLInPower   );
+    sprintf_clk_inf(m, HoscCtl, LDOOutput    );
+    sprintf_clk_inf(m, HoscCtl, KeyField     );
+
+    seq_printf(m, "\nCPU clk infor:\n");
+    sprintf_clk_inf(m, SysClkDiv, AXIClkDiv  );
+    sprintf_clk_inf(m, SysClkDiv, AHBClkDiv  );
+    sprintf_clk_inf(m, SysClkDiv, APB0ClkDiv );
+    sprintf_clk_inf(m, SysClkDiv, AC328ClkSrc);
+
+    seq_printf(m, "\nAPB1 clk infor:\n");
+    sprintf_clk_inf(m, Apb1ClkDiv, ClkDiv    );
+    sprintf_clk_inf(m, Apb1ClkDiv, PreDiv    );
+    sprintf_clk_inf(m, Apb1ClkDiv, ClkSrc    );
+
+    seq_printf(m, "\nAxiGate clk infor:\n");
+    sprintf_clk_inf(m, AxiGate, SdramGate    );
+
+    seq_printf(m, "\nAhbGate0 clk infor:\n");
+    sprintf_clk_inf(m, AhbGate0, Usb0Gate    );
+    sprintf_clk_inf(m, AhbGate0, Ehci0Gate   );
+    sprintf_clk_inf(m, AhbGate0, Ohci0Gate   );
+    sprintf_clk_inf(m, AhbGate0, SsGate      );
+    sprintf_clk_inf(m, AhbGate0, DmaGate     );
+    sprintf_clk_inf(m, AhbGate0, BistGate    );
+    sprintf_clk_inf(m, AhbGate0, Sdmmc0Gate  );
+    sprintf_clk_inf(m, AhbGate0, Sdmmc1Gate  );
+    sprintf_clk_inf(m, AhbGate0, Sdmmc2Gate  );
+    sprintf_clk_inf(m, AhbGate0, MsGate      );
+    sprintf_clk_inf(m, AhbGate0, NandGate    );
+    sprintf_clk_inf(m, AhbGate0, SdramGate   );
+    sprintf_clk_inf(m, AhbGate0, EmacGate    );
+    sprintf_clk_inf(m, AhbGate0, TsGate      );
+    sprintf_clk_inf(m, AhbGate0, Spi0Gate    );
+    sprintf_clk_inf(m, AhbGate0, Spi1Gate    );
+    sprintf_clk_inf(m, AhbGate0, Spi2Gate    );
+    sprintf_clk_inf(m, AhbGate0, GpsGate     );
+
+    seq_printf(m, "\nAhbGate1 clk infor:\n");
+    sprintf_clk_inf(m, AhbGate1, VeGate      );
+    sprintf_clk_inf(m, AhbGate1, Tve0Gate    );
+    sprintf_clk_inf(m, AhbGate1, Lcd0Gate    );
+    sprintf_clk_inf(m, AhbGate1, Csi0Gate    );
+    sprintf_clk_inf(m, AhbGate1, HdmiDGate   );
+    sprintf_clk_inf(m, AhbGate1, DeBe0Gate   );
+    sprintf_clk_inf(m, AhbGate1, DeFe0Gate   );
+    sprintf_clk_inf(m, AhbGate1, MaliGate    );
+
+    seq_printf(m, "\nApb0Gate clk infor:\n");
+    sprintf_clk_inf(m, Apb0Gate, AddaGate    );
+    sprintf_clk_inf(m, Apb0Gate, SpdifGate   );
+    sprintf_clk_inf(m, Apb0Gate, IisGate     );
+    sprintf_clk_inf(m, Apb0Gate, PioGate     );
+    sprintf_clk_inf(m, Apb0Gate, Ir0Gate     );
+
+    seq_printf(m, "\nApb1Gate clk infor:\n");
+    sprintf_clk_inf(m, Apb1Gate, Twi0Gate    );
+    sprintf_clk_inf(m, Apb1Gate, Twi1Gate    );
+    sprintf_clk_inf(m, Apb1Gate, Twi2Gate    );
+    sprintf_clk_inf(m, Apb1Gate, Uart0Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart1Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart2Gate   );
+    sprintf_clk_inf(m, Apb1Gate, Uart3Gate   );
+
+    seq_printf(m, "\nNandClk clk infor:\n");
+    sprintf_clk_inf(m, NandClk, ClkDiv       );
+    sprintf_clk_inf(m, NandClk, ClkPreDiv    );
+    sprintf_clk_inf(m, NandClk, ClkSrc       );
+    sprintf_clk_inf(m, NandClk, SpecClkGate  );
+
+    seq_printf(m, "\nMsClk clk infor:\n");
+    sprintf_clk_inf(m, MsClk, ClkDiv         );
+    sprintf_clk_inf(m, MsClk, ClkPreDiv      );
+    sprintf_clk_inf(m, MsClk, ClkSrc         );
+    sprintf_clk_inf(m, MsClk, SpecClkGate    );
+
+    seq_printf(m, "\nSdMmc0Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc0Clk, ClkDiv     );
+    sprintf_clk_inf(m, SdMmc0Clk, ClkPreDiv  );
+    sprintf_clk_inf(m, SdMmc0Clk, ClkSrc     );
+    sprintf_clk_inf(m, SdMmc0Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc1Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc1Clk, ClkDiv     );
+    sprintf_clk_inf(m, SdMmc1Clk, ClkPreDiv  );
+    sprintf_clk_inf(m, SdMmc1Clk, ClkSrc     );
+    sprintf_clk_inf(m, SdMmc1Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc2Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc2Clk, ClkDiv     );
+    sprintf_clk_inf(m, SdMmc2Clk, ClkPreDiv  );
+    sprintf_clk_inf(m, SdMmc2Clk, ClkSrc     );
+    sprintf_clk_inf(m, SdMmc2Clk, SpecClkGate);
+
+    seq_printf(m, "\nTsClk clk infor:\n");
+    sprintf_clk_inf(m, TsClk, ClkDiv         );
+    sprintf_clk_inf(m, TsClk, ClkPreDiv      );
+    sprintf_clk_inf(m, TsClk, ClkSrc         );
+    sprintf_clk_inf(m, TsClk, SpecClkGate    );
+
+    seq_printf(m, "\nSsClk clk infor:\n");
+    sprintf_clk_inf(m, SsClk, ClkDiv         );
+    sprintf_clk_inf(m, SsClk, ClkPreDiv      );
+    sprintf_clk_inf(m, SsClk, ClkSrc         );
+    sprintf_clk_inf(m, SsClk, SpecClkGate    );
+
+    seq_printf(m, "\nSpi0Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi0Clk, ClkDiv       );
+    sprintf_clk_inf(m, Spi0Clk, ClkPreDiv    );
+    sprintf_clk_inf(m, Spi0Clk, ClkSrc       );
+    sprintf_clk_inf(m, Spi0Clk, SpecClkGate  );
+
+    seq_printf(m, "\nSpi1Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi1Clk, ClkDiv       );
+    sprintf_clk_inf(m, Spi1Clk, ClkPreDiv    );
+    sprintf_clk_inf(m, Spi1Clk, ClkSrc       );
+    sprintf_clk_inf(m, Spi1Clk, SpecClkGate  );
+
+    seq_printf(m, "\nSpi2Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi2Clk, ClkDiv       );
+    sprintf_clk_inf(m, Spi2Clk, ClkPreDiv    );
+    sprintf_clk_inf(m, Spi2Clk, ClkSrc       );
+    sprintf_clk_inf(m, Spi2Clk, SpecClkGate  );
+
+    seq_printf(m, "\nIr0Clk clk infor:\n");
+    sprintf_clk_inf(m, Ir0Clk, ClkDiv        );
+    sprintf_clk_inf(m, Ir0Clk, ClkPreDiv     );
+    sprintf_clk_inf(m, Ir0Clk, ClkSrc        );
+    sprintf_clk_inf(m, Ir0Clk, SpecClkGate   );
+
+    seq_printf(m, "\nI2sClk clk infor:\n");
+    sprintf_clk_inf(m, I2sClk, ClkDiv        );
+    sprintf_clk_inf(m, I2sClk, SpecClkGate   );
+
+    seq_printf(m, "\nSpdifClk clk infor:\n");
+    sprintf_clk_inf(m, SpdifClk, ClkDiv      );
+    sprintf_clk_inf(m, SpdifClk, SpecClkGate );
+
+    seq_printf(m, "\nUsbClk clk infor:\n");
+    sprintf_clk_inf(m, UsbClk, UsbPhy0Rst    );
+    sprintf_clk_inf(m, UsbClk, UsbPhy1Rst    );
+    sprintf_clk_inf(m, UsbClk, OHCI0SpecClkGate  );
+    sprintf_clk_inf(m, UsbClk, PhySpecClkGate    );
+
+    seq_printf(m, "\nGpsClk clk infor:\n");
+    sprintf_clk_inf(m, GpsClk, Reset         );
+    sprintf_clk_inf(m, GpsClk, SpecClkGate   );
+
+    seq_printf(m, "\nDramGate clk infor:\n");
+    sprintf_clk_inf(m, DramGate, VeGate      );
+    sprintf_clk_inf(m, DramGate, Csi0Gate    );
+    sprintf_clk_inf(m, DramGate, TsGate      );
+    sprintf_clk_inf(m, DramGate, Tve0Gate    );
+    sprintf_clk_inf(m, DramGate, DeFe0Gate   );
+    sprintf_clk_inf(m, DramGate, DeBe0Gate   );
+
+    seq_printf(m, "\nDeBe0Clk clk infor:\n");
+    sprintf_clk_inf(m, DeBe0Clk, ClkDiv      );
+    sprintf_clk_inf(m, DeBe0Clk, ClkSrc      );
+    sprintf_clk_inf(m, DeBe0Clk, Reset       );
+    sprintf_clk_inf(m, DeBe0Clk, SpecClkGate );
+
+    seq_printf(m, "\nDeFe0Clk clk infor:\n");
+    sprintf_clk_inf(m, DeFe0Clk, ClkDiv      );
+    sprintf_clk_inf(m, DeFe0Clk, ClkSrc      );
+    sprintf_clk_inf(m, DeFe0Clk, Reset       );
+    sprintf_clk_inf(m, DeFe0Clk, SpecClkGate );
+
+    seq_printf(m, "\nLcd0Ch0Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd0Ch0Clk, ClkSrc        );
+    sprintf_clk_inf(m, Lcd0Ch0Clk, LcdReset      );
+    sprintf_clk_inf(m, Lcd0Ch0Clk, SpecClkGate   );
+
+    seq_printf(m, "\nLcd0Ch1Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd0Ch1Clk, ClkDiv        );
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk1Src   );
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk1Gate  );
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk2Src   );
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk2Gate  );
+
+    seq_printf(m, "\nCsi0Clk clk infor:\n");
+    sprintf_clk_inf(m, Csi0Clk, ClkDiv       );
+    sprintf_clk_inf(m, Csi0Clk, ClkSrc       );
+    sprintf_clk_inf(m, Csi0Clk, Reset        );
+    sprintf_clk_inf(m, Csi0Clk, SpecClkGate  );
+
+    seq_printf(m, "\nVeClk clk infor:\n");
+    sprintf_clk_inf(m, VeClk, Reset          );
+    sprintf_clk_inf(m, VeClk, SpecClkGate    );
+
+    seq_printf(m, "\nAddaClk clk infor:\n");
+    sprintf_clk_inf(m, AddaClk, SpecClkGate  );
+
+    seq_printf(m, "\nAvsClk clk infor:\n");
+    sprintf_clk_inf(m, AvsClk, SpecClkGate   );
+
+    seq_printf(m, "\nLvdsClk clk infor:\n");
+    sprintf_clk_inf(m, LvdsClk, Reset        );
+
+    seq_printf(m, "\nHdmiClk clk infor:\n");
+    sprintf_clk_inf(m, HdmiClk, ClkDiv       );
+    sprintf_clk_inf(m, HdmiClk, ClkSrc       );
+    sprintf_clk_inf(m, HdmiClk, SpecClkGate  );
+
+    seq_printf(m, "\nMaliClk clk infor:\n");
+    sprintf_clk_inf(m, MaliClk, ClkDiv       );
+    sprintf_clk_inf(m, MaliClk, ClkSrc       );
+    sprintf_clk_inf(m, MaliClk, Reset        );
+    sprintf_clk_inf(m, MaliClk, SpecClkGate  );
+
+	return 0;
+}
+
+
+static int ccmu_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ccmu_stats_show, NULL);
+}
+
+static const struct file_operations ccmu_dbg_fops = {
+	.owner = THIS_MODULE,
+	.open = ccmu_stats_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int __init ccu_dbg_init(void)
+{
+	proc_create("ccmu", S_IRUGO, NULL, &ccmu_dbg_fops);
+	return 0;
+}
+
+static void  __exit ccu_dbg_exit(void)
+{
+	remove_proc_entry("ccmu", NULL);
+}
+
+core_initcall(ccu_dbg_init);
+module_exit(ccu_dbg_exit);
+#endif
diff --git a/arch/arm/mach-sun5i/clock/ccmu/pll_cfg_tbl.c b/arch/arm/mach-sun5i/clock/ccmu/pll_cfg_tbl.c
new file mode 100644
index 0000000..2250309
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/ccmu/pll_cfg_tbl.c
@@ -0,0 +1,311 @@
+/*
+ * arch/arm/mach-sun5i/clock/ccmu/pll_cfg_tbl.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "ccm_i.h"
+#include <mach/aw_ccu.h>
+
+struct core_pll_freq_tbl{
+    __u8    FactorN;
+    __u8    FactorK;
+    __u8    FactorM;
+    __u8    FactorP;
+    __u32   Pll;
+};
+
+/* core pll parameter table */
+static struct core_pll_freq_tbl    CorePllTbl[] = {
+
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 0   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 1   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 2   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 3   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 4   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 5   */
+    { 12,    0,    0,    3,    36000000  },   /* freq = (6M * 6  ), index = 6   */
+    { 7 ,    1,    0,    3,    42000000  },   /* freq = (6M * 7  ), index = 7   */
+    { 16,    0,    0,    3,    48000000  },   /* freq = (6M * 8  ), index = 8   */
+    { 9 ,    1,    0,    3,    54000000  },   /* freq = (6M * 9  ), index = 9   */
+    { 10,    0,    0,    2,    60000000  },   /* freq = (6M * 10 ), index = 10  */
+    { 11,    0,    0,    2,    66000000  },   /* freq = (6M * 11 ), index = 11  */
+    { 12,    0,    0,    2,    72000000  },   /* freq = (6M * 12 ), index = 12  */
+    { 13,    0,    0,    2,    78000000  },   /* freq = (6M * 13 ), index = 13  */
+    { 14,    0,    0,    2,    84000000  },   /* freq = (6M * 14 ), index = 14  */
+    { 15,    0,    0,    2,    90000000  },   /* freq = (6M * 15 ), index = 15  */
+    { 16,    0,    0,    2,    96000000  },   /* freq = (6M * 16 ), index = 16  */
+    { 17,    0,    0,    2,    102000000 },   /* freq = (6M * 17 ), index = 17  */
+    { 18,    0,    0,    2,    108000000 },   /* freq = (6M * 18 ), index = 18  */
+    { 19,    0,    0,    2,    114000000 },   /* freq = (6M * 19 ), index = 19  */
+    { 10,    0,    0,    1,    120000000 },   /* freq = (6M * 20 ), index = 20  */
+    { 21,    0,    0,    2,    126000000 },   /* freq = (6M * 21 ), index = 21  */
+    { 11,    0,    0,    1,    132000000 },   /* freq = (6M * 22 ), index = 22  */
+    { 23,    0,    0,    2,    138000000 },   /* freq = (6M * 23 ), index = 23  */
+    { 12,    0,    0,    1,    144000000 },   /* freq = (6M * 24 ), index = 24  */
+    { 25,    0,    0,    2,    150000000 },   /* freq = (6M * 25 ), index = 25  */
+    { 13,    0,    0,    1,    156000000 },   /* freq = (6M * 26 ), index = 26  */
+    { 27,    0,    0,    2,    162000000 },   /* freq = (6M * 27 ), index = 27  */
+    { 14,    0,    0,    1,    168000000 },   /* freq = (6M * 28 ), index = 28  */
+    { 29,    0,    0,    2,    174000000 },   /* freq = (6M * 29 ), index = 29  */
+    { 15,    0,    0,    1,    180000000 },   /* freq = (6M * 30 ), index = 30  */
+    { 31,    0,    0,    2,    186000000 },   /* freq = (6M * 31 ), index = 31  */
+    { 16,    0,    0,    1,    192000000 },   /* freq = (6M * 32 ), index = 32  */
+    { 16,    0,    0,    1,    192000000 },   /* freq = (6M * 32 ), index = 33  */
+    { 17,    0,    0,    1,    204000000 },   /* freq = (6M * 34 ), index = 34  */
+    { 17,    0,    0,    1,    204000000 },   /* freq = (6M * 34 ), index = 35  */
+    { 18,    0,    0,    1,    216000000 },   /* freq = (6M * 36 ), index = 36  */
+    { 18,    0,    0,    1,    216000000 },   /* freq = (6M * 36 ), index = 37  */
+    { 19,    0,    0,    1,    228000000 },   /* freq = (6M * 38 ), index = 38  */
+    { 19,    0,    0,    1,    228000000 },   /* freq = (6M * 38 ), index = 39  */
+    { 10,    0,    0,    0,    240000000 },   /* freq = (6M * 40 ), index = 40  */
+    { 10,    0,    0,    0,    240000000 },   /* freq = (6M * 40 ), index = 41  */
+    { 21,    0,    0,    1,    252000000 },   /* freq = (6M * 42 ), index = 42  */
+    { 21,    0,    0,    1,    252000000 },   /* freq = (6M * 42 ), index = 43  */
+    { 11,    0,    0,    0,    264000000 },   /* freq = (6M * 44 ), index = 44  */
+    { 11,    0,    0,    0,    264000000 },   /* freq = (6M * 44 ), index = 45  */
+    { 23,    0,    0,    1,    276000000 },   /* freq = (6M * 46 ), index = 46  */
+    { 23,    0,    0,    1,    276000000 },   /* freq = (6M * 46 ), index = 47  */
+    { 12,    0,    0,    0,    288000000 },   /* freq = (6M * 48 ), index = 48  */
+    { 12,    0,    0,    0,    288000000 },   /* freq = (6M * 48 ), index = 49  */
+    { 25,    0,    0,    1,    300000000 },   /* freq = (6M * 50 ), index = 50  */
+    { 25,    0,    0,    1,    300000000 },   /* freq = (6M * 50 ), index = 51  */
+    { 13,    0,    0,    0,    312000000 },   /* freq = (6M * 52 ), index = 52  */
+    { 13,    0,    0,    0,    312000000 },   /* freq = (6M * 52 ), index = 53  */
+    { 27,    0,    0,    1,    324000000 },   /* freq = (6M * 54 ), index = 54  */
+    { 27,    0,    0,    1,    324000000 },   /* freq = (6M * 54 ), index = 55  */
+    { 14,    0,    0,    0,    336000000 },   /* freq = (6M * 56 ), index = 56  */
+    { 14,    0,    0,    0,    336000000 },   /* freq = (6M * 56 ), index = 57  */
+    { 29,    0,    0,    1,    348000000 },   /* freq = (6M * 58 ), index = 58  */
+    { 29,    0,    0,    1,    348000000 },   /* freq = (6M * 58 ), index = 59  */
+    { 15,    0,    0,    0,    360000000 },   /* freq = (6M * 60 ), index = 60  */
+    { 15,    0,    0,    0,    360000000 },   /* freq = (6M * 60 ), index = 61  */
+    { 31,    0,    0,    1,    372000000 },   /* freq = (6M * 62 ), index = 62  */
+    { 31,    0,    0,    1,    372000000 },   /* freq = (6M * 62 ), index = 63  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 64  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 65  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 66  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 67  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 68  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 69  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 70  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 71  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 72  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 73  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 74  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 75  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 76  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 77  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 78  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 79  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 80  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 81  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 82  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 83  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 84  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 85  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 86  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 87  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 88  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 89  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 90  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 91  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 92  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 93  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 94  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 95  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 96  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 97  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 98  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 99  */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 100 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 101 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 102 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 103 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 104 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 105 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 106 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 107 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 108 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 109 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 110 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 111 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 112 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 113 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 114 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 115 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 116 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 117 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 118 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 119 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 120 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 121 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 122 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 123 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 124 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 125 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 126 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 127 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 128 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 129 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 130 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 131 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 132 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 133 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 134 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 135 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 136 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 137 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 138 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 139 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 140 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 141 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 142 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 143 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 144 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 145 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 146 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 147 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 148 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 149 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 150 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 151 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 152 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 153 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 154 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 155 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 156 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 157 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 158 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 159 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 160 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 161 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 162 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 163 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 164 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 165 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 166 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 167 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 168 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 169 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 170 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 171 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 172 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 173 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 174 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 175 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 176 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 177 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 178 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 179 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 180 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 181 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 182 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 183 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 184 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 185 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 186 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 187 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 188 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 189 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 190 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 191 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 192 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 193 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 194 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 195 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 196 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 197 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 198 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 199 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 200 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 201 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 202 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 203 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 204 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 205 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 206 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 207 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 208 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 209 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 210 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 211 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 212 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 213 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 214 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 215 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 216 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 217 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 218 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 219 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 220 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 221 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 222 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 223 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 224 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 225 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 226 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 227 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 228 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 229 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 230 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 231 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 232 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 233 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 234 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 235 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 236 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 237 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 238 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 239 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 240 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 241 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 242 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 243 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 244 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 245 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 246 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 247 */
+    { 31,    1,    0,    0,    1488000000},   /* freq = (6M * 248), index = 248 */
+};
+
+
+int ccm_clk_get_pll_para(struct core_pll_factor_t *factor, __u64 rate)
+{
+    int     index;
+
+    if(!factor)
+    {
+        return -1;
+    }
+
+    if(rate > 1488000000)
+    {
+        rate = 1488000000;
+    }
+    index = ccu_clk_uldiv(rate, 6000000);
+
+    factor->FactorN = CorePllTbl[index].FactorN;
+    factor->FactorK = CorePllTbl[index].FactorK;
+    factor->FactorM = CorePllTbl[index].FactorM;
+    factor->FactorP = CorePllTbl[index].FactorP;
+
+    return 0;
+}
diff --git a/arch/arm/mach-sun5i/clock/clock.c b/arch/arm/mach-sun5i/clock/clock.c
new file mode 100644
index 0000000..9ad13dd
--- /dev/null
+++ b/arch/arm/mach-sun5i/clock/clock.c
@@ -0,0 +1,468 @@
+/*
+ * arch/arm/mach-sun5i/clock/clock.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+
+#include <mach/clock.h>
+
+
+/* we predefine the count here, but it's ugly, maybe malloc is better */
+#define MAX_SYSTEM_CLK_CNT  (32)
+#define MAX_MODULE_CLK_CNT  (200)
+
+#undef CCU_DBG
+#undef CCU_ERR
+#if (0)
+    #define CCU_DBG     printk
+    #define CCU_ERR     printk
+#else
+    #define CCU_DBG(...)
+    #define CCU_ERR(...)
+#endif
+
+
+// alloc memory for store clock informatioin, maybe malloc is better
+static __s32 SysClkCnt;
+static __s32 ModClkCnt;
+static struct clk ccu_sys_clk[MAX_SYSTEM_CLK_CNT];
+static struct clk ccu_mod_clk[MAX_MODULE_CLK_CNT];
+
+// lock for operation protect
+static DEFINE_MUTEX(clocks_mutex);
+static DEFINE_SPINLOCK(clockfw_lock);
+
+
+/*
+*********************************************************************************************************
+*                           clk_init
+*
+*Description: clock management initialise.
+*
+*Arguments  : none
+*
+*Return     : result
+*               0,  initialise successed;
+*              -1,  initialise failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int clk_init(void)
+{
+    __s32           i;
+    struct clk      *tmpSclk;
+
+    CCU_DBG("aw clock manager init!\n");
+
+    //initialise clock controller unit
+    if(AW_CCU_ERR_NONE != aw_ccu_init())
+    {
+        CCU_ERR("csp ccmu initial failed!\n");
+        return -1;
+    }
+
+    //clear the data structure
+    SysClkCnt = 0;
+    memset((void *)&ccu_sys_clk, 0, sizeof(ccu_sys_clk));
+    ModClkCnt = 0;
+    memset((void *)&ccu_mod_clk, 0, sizeof(ccu_mod_clk));
+
+    //get system clock information
+    SysClkCnt = aw_ccu_get_sys_clk_cnt();
+    if(SysClkCnt > MAX_SYSTEM_CLK_CNT)
+    {
+        CCU_ERR("system clock count define (%d) is invalid! actule is:%d\n", MAX_SYSTEM_CLK_CNT, SysClkCnt);
+        return -1;
+    }
+    for(i=0; i<SysClkCnt; i++)
+    {
+        ccu_sys_clk[i].clk = aw_ccu_get_sys_clk((__aw_ccu_sys_clk_e)i);
+        if(ccu_sys_clk[i].clk)
+        {
+            tmpSclk = &ccu_sys_clk[ccu_sys_clk[i].clk->parent];
+            ccu_sys_clk[i].parent = tmpSclk;
+            ccu_sys_clk[i].set_clk = &aw_ccu_set_sys_clk;
+            ccu_sys_clk[i].get_clk = (__aw_ccu_clk_t * (*)(__s32))&aw_ccu_get_sys_clk;
+            ccu_sys_clk[i].hash = ccu_clk_calc_hash(ccu_sys_clk[i].clk->name);
+            if(ccu_sys_clk[i].clk->onoff == AW_CCU_CLK_ON)
+            {
+                tmpSclk->usr_cnt++;
+            }
+        }
+    }
+
+    //get module clock information
+    ModClkCnt = aw_ccu_get_mod_clk_cnt();
+    if(ModClkCnt > MAX_MODULE_CLK_CNT)
+    {
+        CCU_ERR("module clock count define (%d) is invalid! actule is:%d\n", MAX_MODULE_CLK_CNT, ModClkCnt);
+        return -1;
+    }
+    for(i=0; i<ModClkCnt; i++)
+    {
+        ccu_mod_clk[i].clk = aw_ccu_get_mod_clk((__aw_ccu_sys_clk_e)i);
+        if(ccu_mod_clk[i].clk)
+        {
+            tmpSclk = &ccu_sys_clk[ccu_mod_clk[i].clk->parent];
+            ccu_mod_clk[i].parent = tmpSclk;
+            ccu_mod_clk[i].set_clk = &aw_ccu_set_mod_clk;
+            ccu_mod_clk[i].get_clk = (__aw_ccu_clk_t * (*)(__s32))&aw_ccu_get_mod_clk;
+            ccu_mod_clk[i].hash = ccu_clk_calc_hash(ccu_mod_clk[i].clk->name);
+            if(ccu_mod_clk[i].clk->onoff == AW_CCU_CLK_ON)
+            {
+                tmpSclk->usr_cnt++;
+            }
+            if(tmpSclk->child)
+            {
+                ccu_mod_clk[i].right = tmpSclk->child;
+                tmpSclk->child->left = &ccu_mod_clk[i];
+            }
+            tmpSclk->child = &ccu_mod_clk[i];
+        }
+    }
+
+    /* enable pll for use, it need be modified to dynamic */
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL2];
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL3];
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL4];
+    tmpSclk->clk->rate  = 360000000;
+    tmpSclk->set_clk(tmpSclk->clk);
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL6];
+    tmpSclk->clk->rate  = 600000000;
+    tmpSclk->set_clk(tmpSclk->clk);
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL6M];
+    tmpSclk->clk->rate  = 100000000;
+    tmpSclk->set_clk(tmpSclk->clk);
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL62];
+    tmpSclk->clk->rate  = 300000000;
+    tmpSclk->set_clk(tmpSclk->clk);
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+
+    tmpSclk = &ccu_sys_clk[AW_SYS_CLK_PLL7];
+    tmpSclk->clk->onoff = AW_CCU_CLK_ON;
+    tmpSclk->set_clk(tmpSclk->clk);
+
+    return 0;
+}
+arch_initcall(clk_init);
+
+
+struct clk * clk_get(struct device *dev, const char *id)
+{
+    __s32   i = 0;
+    __s32   tmpHash = ccu_clk_calc_hash((char *)id);
+
+    CCU_DBG("%s:%d:%s:Get clock %s !\n", __FILE__, __LINE__, __FUNCTION__, id);
+    if(!id)
+    {
+        return NULL;
+    }
+
+    mutex_lock(&clocks_mutex);
+
+    /* search system clock table */
+    for(i=0; i<SysClkCnt; i++)
+    {
+        if(tmpHash == ccu_sys_clk[i].hash)
+        {
+            if(!strcmp(id, ccu_sys_clk[i].clk->name))
+            {
+                ccu_sys_clk[i].usr_cnt++;
+                mutex_unlock(&clocks_mutex);
+                return &ccu_sys_clk[i];
+            }
+        }
+    }
+
+    /* search module clock table */
+    for(i=0; i<ModClkCnt; i++)
+    {
+        if(tmpHash == ccu_mod_clk[i].hash)
+        {
+            if(!strcmp(id, ccu_mod_clk[i].clk->name))
+            {
+                ccu_mod_clk[i].usr_cnt++;
+                mutex_unlock(&clocks_mutex);
+                return &ccu_mod_clk[i];
+            }
+        }
+    }
+    CCU_ERR("%s:%d:%s: (%s) failed!\n", __FILE__, __LINE__, __FUNCTION__, id);
+
+    mutex_unlock(&clocks_mutex);
+
+    return NULL;
+}
+EXPORT_SYMBOL(clk_get);
+
+
+int clk_enable(struct clk *clk)
+{
+    unsigned long flags;
+    int ret = 0;
+
+    if((clk == NULL) || IS_ERR(clk))
+        return -EINVAL;
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    if(clk->clk->onoff == AW_CCU_CLK_OFF)
+    {
+        /* update clock parameter */
+        clk->clk = clk->get_clk(clk->clk->id);
+
+        /* try to enable clock */
+        clk->clk->onoff = AW_CCU_CLK_ON;
+        ret = clk->set_clk(clk->clk);
+    }
+    if(!ret) {
+        clk->enable++;
+    }
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+
+void clk_disable(struct clk *clk)
+{
+    unsigned long flags;
+
+    if(clk == NULL || IS_ERR(clk) || !clk->enable)
+        return;
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    clk->enable--;
+    if(clk->enable){
+        spin_unlock_irqrestore(&clockfw_lock, flags);
+        return;
+    }
+    if(clk->clk->onoff == AW_CCU_CLK_ON)
+    {
+        /* update clock parameter */
+        clk->clk = clk->get_clk(clk->clk->id);
+
+        /* try to disalbe clock */
+        clk->clk->onoff = AW_CCU_CLK_OFF;
+        clk->set_clk(clk->clk);
+    }
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+    unsigned long   flags;
+    unsigned long   ret = 0;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return 0;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+
+    clk->clk = clk->get_clk(clk->clk->id);
+    ret = (unsigned long)clk->clk->rate;
+
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+unsigned long clk_get_rate_nolock(struct clk *clk)
+{
+    unsigned long   ret = 0;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return 0;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    clk->clk = clk->get_clk(clk->clk->id);
+    ret = (unsigned long)clk->clk->rate;
+
+    return ret;
+}
+
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+    unsigned long   flags;
+    int ret = 0;
+
+    if(clk == NULL || IS_ERR(clk))
+        return -1;
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    /* update clock parameter */
+    clk->clk = clk->get_clk(clk->clk->id);
+    clk->clk->rate = rate;
+    ret = clk->set_clk(clk->clk);
+
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+    struct clk *parent = NULL;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return NULL;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+    parent = clk->parent;
+
+    return parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+    unsigned long   flags;
+    int ret = -1;
+    struct clk *old_parent;
+
+    if((clk == NULL) || IS_ERR(parent))
+    {
+        return ret;
+    }
+
+    if (parent == NULL || IS_ERR(parent))
+    {
+        return ret;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+
+    /* update clock parameter */
+    clk->clk = clk->get_clk(clk->clk->id);
+    old_parent = clk->parent;
+    clk->clk->rate = clk_get_rate_nolock(parent) / (clk_get_rate_nolock(old_parent) / clk_get_rate_nolock(clk));
+    clk->clk->parent = parent->clk->id;
+    ret = clk->set_clk(clk->clk);
+    if(ret){
+        clk->clk->parent = old_parent->clk->id;
+    }
+    else{
+        clk->parent = parent;
+    }
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+
+void clk_put(struct clk *clk)
+{
+    unsigned long   flags;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return;
+    }
+
+    if(!clk->usr_cnt)
+    {
+        return;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    clk->usr_cnt--;
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+EXPORT_SYMBOL(clk_put);
+
+
+int clk_reset(struct clk *clk, int reset)
+{
+    unsigned long   flags;
+    int ret = 0;
+
+    if((clk == NULL) || IS_ERR(clk))
+    {
+        return -EINVAL;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->clk->name);
+
+    spin_lock_irqsave(&clockfw_lock, flags);
+    /* update clock parameter */
+    clk->clk = clk->get_clk(clk->clk->id);
+    reset? (clk->clk->reset = AW_CCU_CLK_RESET) : (clk->clk->reset = AW_CCU_CLK_NRESET);
+    ret = clk->set_clk(clk->clk);
+    spin_unlock_irqrestore(&clockfw_lock, flags);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_reset);
+
diff --git a/arch/arm/mach-sun5i/include/mach/aw_ccu.h b/arch/arm/mach-sun5i/include/mach/aw_ccu.h
new file mode 100644
index 0000000..4579e65
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/aw_ccu.h
@@ -0,0 +1,363 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/aw_ccu.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __AW_CCU_H__
+#define __AW_CCU_H__
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/* define if need use pll6 to take the place of pll4,
+   this definition is significative on C ver. only */
+#define USE_PLL6M_REPLACE_PLL4      (1)
+
+
+/* define clock error type      */
+typedef enum __AW_CCU_ERR
+{
+    AW_CCU_ERR_NONE         = 0,
+    AW_CCU_ERR_PARA_NULL    = -1,
+    AW_CCU_ERR_PARA_INVALID = -1,
+
+} __aw_ccu_err_e;
+
+
+typedef enum __AW_CCU_CLK_ONOFF
+{
+    AW_CCU_CLK_OFF,
+    AW_CCU_CLK_ON,
+
+} __aw_ccu_clk_onff_e;
+
+
+typedef enum __AW_CCU_CLK_RESET
+{
+    AW_CCU_CLK_RESET,
+    AW_CCU_CLK_NRESET,
+
+} __aw_ccu_clk_reset_e;
+
+
+/* define system clock id       */
+typedef enum __AW_CCU_SYS_CLK
+{
+    AW_SYS_CLK_NONE,    /* invalid clock id                     */
+
+    AW_SYS_CLK_LOSC,    /* "losc"       ,LOSC, 32768 hz clock   */
+    AW_SYS_CLK_HOSC,    /* "hosc"       ,HOSC, 24Mhz clock      */
+
+    AW_SYS_CLK_PLL1,    /* "core_pll"   ,PLL1 clock             */
+    AW_SYS_CLK_PLL2,    /* "audio_pll"  ,PLL2 clock             */
+    AW_SYS_CLK_PLL2X8,  /* "audio_pllx8"  ,PLL2 8x clock        */
+    AW_SYS_CLK_PLL3,    /* "video_pll0" ,PLL3 clock             */
+    AW_SYS_CLK_PLL3X2,  /* "video_pll0x2" ,PLL3 2x clock        */
+    AW_SYS_CLK_PLL4,    /* "ve_pll"     ,PLL4 clock             */
+    AW_SYS_CLK_PLL5,    /* "sdram_pll"  ,PLL5 clock             */
+    AW_SYS_CLK_PLL5M,   /* "sdram_pll_m",PLL5 M clock           */
+    AW_SYS_CLK_PLL5P,   /* "sdram_pll_p",PLL5 P clock           */
+    AW_SYS_CLK_PLL6,    /* "sata_pll"   ,PLL6 clock, just used
+                           as source of sata_pll_m and sata_pll_2,
+                           users should not use this clock dirctly
+                        */
+    AW_SYS_CLK_PLL7,    /* "video_pll1" ,PLL7 clock             */
+    AW_SYS_CLK_PLL7X2,  /* "video_pll1x2" ,PLL7 2x clock        */
+    AW_SYS_CLK_200M,    /* "200m_pll"   ,200Mhz clock           */
+
+    AW_SYS_CLK_CPU,     /* "cpu"        ,CPU clock              */
+    AW_SYS_CLK_AXI,     /* "axi"        ,AXI clock              */
+    AW_SYS_CLK_AHB,     /* "ahb"        ,AHB clock              */
+    AW_SYS_CLK_APB0,    /* "apb"        ,APB0 clock             */
+    AW_SYS_CLK_APB1,    /* "apb1"       ,APB1 clock             */
+
+    /* add by kevin, 2011-7-21 19:01 */
+    AW_SYS_CLK_PLL6M,   /* "sata_pll_m" ,PLL6 M clock, just for SATA    */
+    AW_SYS_CLK_PLL62,   /* "sata_pll_2" ,PLL6 2 clock, for module       */
+
+    AW_SYS_CLK_CNT      /* invalid id, for calc count           */
+
+} __aw_ccu_sys_clk_e;
+
+
+/* define module clock id       */
+typedef enum __AW_CCU_MOD_CLK
+{
+    AW_MOD_CLK_NONE,/* invalid clock id             */
+
+    AW_MOD_CLK_NFC,         /* "nfc"            */
+    AW_MOD_CLK_MSC,         /* "msc"            */
+    AW_MOD_CLK_SDC0,        /* "sdc0"           */
+    AW_MOD_CLK_SDC1,        /* "sdc1"           */
+    AW_MOD_CLK_SDC2,        /* "sdc2"           */
+    AW_MOD_CLK_SDC3,        /* "sdc3"           */
+    AW_MOD_CLK_TS,          /* "ts"             */
+    AW_MOD_CLK_SS,          /* "ss"             */
+    AW_MOD_CLK_SPI0,        /* "spi0"           */
+    AW_MOD_CLK_SPI1,        /* "spi1"           */
+    AW_MOD_CLK_SPI2,        /* "spi2"           */
+    AW_MOD_CLK_PATA,        /* "pata"           */
+    AW_MOD_CLK_IR0,         /* "ir0"            */
+    AW_MOD_CLK_IR1,         /* "ir1"            */
+    AW_MOD_CLK_I2S,         /* "i2s"            */
+    AW_MOD_CLK_AC97,        /* "ac97"           */
+    AW_MOD_CLK_SPDIF,       /* "spdif"          */
+    AW_MOD_CLK_KEYPAD,      /* "key_pad"        */
+    AW_MOD_CLK_SATA,        /* "sata"           */
+    AW_MOD_CLK_USBPHY,      /* "usb_phy"        */
+    AW_MOD_CLK_USBPHY0,     /* "usb_phy0"       */
+    AW_MOD_CLK_USBPHY1,     /* "usb_phy1"       */
+    AW_MOD_CLK_USBPHY2,     /* "usb_phy2"       */
+    AW_MOD_CLK_USBOHCI0,    /* "usb_ohci0"      */
+    AW_MOD_CLK_USBOHCI1,    /* "usb_ohci1"      */
+    AW_MOD_CLK_GPS,         /* "com"            */
+    AW_MOD_CLK_SPI3,        /* "spi3"           */
+    AW_MOD_CLK_DEBE0,       /* "de_image0"      */
+    AW_MOD_CLK_DEBE1,       /* "de_image1"      */
+    AW_MOD_CLK_DEFE0,       /* "de_scale0"      */
+    AW_MOD_CLK_DEFE1,       /* "de_scale1"      */
+    AW_MOD_CLK_DEMIX,       /* "de_mix"         */
+    AW_MOD_CLK_LCD0CH0,     /* "lcd0_ch0"       */
+    AW_MOD_CLK_LCD1CH0,     /* "lcd1_ch0"       */
+    AW_MOD_CLK_CSIISP,      /* "csi_isp"        */
+    AW_MOD_CLK_TVD,         /* "tvd"            */
+    AW_MOD_CLK_LCD0CH1_S1,  /* "lcd0_ch1_s1"    */
+    AW_MOD_CLK_LCD0CH1_S2,  /* "lcd0_ch1_s2"    */
+    AW_MOD_CLK_LCD1CH1_S1,  /* "lcd1_ch1_s1"    */
+    AW_MOD_CLK_LCD1CH1_S2,  /* "lcd1_ch1_s2"    */
+    AW_MOD_CLK_CSI0,        /* "csi0"           */
+    AW_MOD_CLK_CSI1,        /* "csi1"           */
+    AW_MOD_CLK_VE,          /* "ve"             */
+    AW_MOD_CLK_ADDA,        /* "audio_codec"    */
+    AW_MOD_CLK_AVS,         /* "avs"            */
+    AW_MOD_CLK_ACE,         /* "ace"            */
+    AW_MOD_CLK_LVDS,        /* "lvds"           */
+    AW_MOD_CLK_HDMI,        /* "hdmi"           */
+    AW_MOD_CLK_MALI,        /* "mali"           */
+    AW_MOD_CLK_TWI0,        /* "twi0"           */
+    AW_MOD_CLK_TWI1,        /* "twi1"           */
+    AW_MOD_CLK_TWI2,        /* "twi2"           */
+    AW_MOD_CLK_CAN,         /* "can"            */
+    AW_MOD_CLK_SCR,         /* "scr"            */
+    AW_MOD_CLK_PS20,        /* "ps0"            */
+    AW_MOD_CLK_PS21,        /* "ps1"            */
+    AW_MOD_CLK_UART0,       /* "uart0"          */
+    AW_MOD_CLK_UART1,       /* "uart1"          */
+    AW_MOD_CLK_UART2,       /* "uart2"          */
+    AW_MOD_CLK_UART3,       /* "uart3"          */
+    AW_MOD_CLK_UART4,       /* "uart4"          */
+    AW_MOD_CLK_UART5,       /* "uart5"          */
+    AW_MOD_CLK_UART6,       /* "uart6"          */
+    AW_MOD_CLK_UART7,       /* "uart7"          */
+
+    /* clock gating for hang to AXI bus */
+    AW_MOD_CLK_AXI_DRAM,    /* "axi_dram"       */
+
+    /* clock gating for hang to AHB bus */
+    AW_MOD_CLK_AHB_USB0,    /* "ahb_usb0"       */
+    AW_MOD_CLK_AHB_EHCI0,   /* "ahb_ehci0"      */
+    AW_MOD_CLK_AHB_OHCI0,   /* "ahb_ohci0"      */
+    AW_MOD_CLK_AHB_SS,      /* "ahb_ss"         */
+    AW_MOD_CLK_AHB_DMA,     /* "ahb_dma"        */
+    AW_MOD_CLK_AHB_BIST,    /* "ahb_bist"       */
+    AW_MOD_CLK_AHB_SDMMC0,  /* "ahb_sdc0"       */
+    AW_MOD_CLK_AHB_SDMMC1,  /* "ahb_sdc1"       */
+    AW_MOD_CLK_AHB_SDMMC2,  /* "ahb_sdc2"       */
+    AW_MOD_CLK_AHB_SDMMC3,  /* "ahb_sdc3"       */
+    AW_MOD_CLK_AHB_MS,      /* "ahb_msc"        */
+    AW_MOD_CLK_AHB_NAND,    /* "ahb_nfc"        */
+    AW_MOD_CLK_AHB_SDRAM,   /* "ahb_sdramc"     */
+    AW_MOD_CLK_AHB_ACE,     /* "ahb_ace"        */
+    AW_MOD_CLK_AHB_EMAC,    /* "ahb_emac"       */
+    AW_MOD_CLK_AHB_TS,      /* "ahb_ts"         */
+    AW_MOD_CLK_AHB_SPI0,    /* "ahb_spi0"       */
+    AW_MOD_CLK_AHB_SPI1,    /* "ahb_spi1"       */
+    AW_MOD_CLK_AHB_SPI2,    /* "ahb_spi2"       */
+    AW_MOD_CLK_AHB_SPI3,    /* "ahb_spi3"       */
+    AW_MOD_CLK_AHB_PATA,    /* "ahb_pata"       */
+    AW_MOD_CLK_AHB_SATA,    /* "ahb_sata"       */
+    AW_MOD_CLK_AHB_GPS,     /* "ahb_com"        */
+    AW_MOD_CLK_AHB_VE,      /* "ahb_ve"         */
+    AW_MOD_CLK_AHB_TVD,     /* "ahb_tvd"        */
+    AW_MOD_CLK_AHB_TVE0,    /* "ahb_tve0"       */
+    AW_MOD_CLK_AHB_TVE1,    /* "ahb_tve1"       */
+    AW_MOD_CLK_AHB_LCD0,    /* "ahb_lcd0"       */
+    AW_MOD_CLK_AHB_LCD1,    /* "ahb_lcd1"       */
+    AW_MOD_CLK_AHB_CSI0,    /* "ahb_csi0"       */
+    AW_MOD_CLK_AHB_CSI1,    /* "ahb_csi1"       */
+    AW_MOD_CLK_AHB_HDMI,    /* "ahb_hdmi"       */
+    AW_MOD_CLK_AHB_DEBE0,   /* "ahb_de_image0"  */
+    AW_MOD_CLK_AHB_DEBE1,   /* "ahb_de_image1"  */
+    AW_MOD_CLK_AHB_DEFE0,   /* "ahb_de_scale0"  */
+    AW_MOD_CLK_AHB_DEFE1,   /* "ahb_de_scale1"  */
+    AW_MOD_CLK_AHB_MP,      /* "ahb_de_mix"     */
+    AW_MOD_CLK_AHB_MALI,    /* "ahb_mali"       */
+
+    /* clock gating for hang APB bus */
+    AW_MOD_CLK_APB_ADDA,    /* "apb_audio_codec"    */
+    AW_MOD_CLK_APB_SPDIF,   /* "apb_spdif"          */
+    AW_MOD_CLK_APB_AC97,    /* "apb_ac97"           */
+    AW_MOD_CLK_APB_I2S,     /* "apb_i2s"            */
+    AW_MOD_CLK_APB_PIO,     /* "apb_pio"            */
+    AW_MOD_CLK_APB_IR0,     /* "apb_ir0"            */
+    AW_MOD_CLK_APB_IR1,     /* "apb_ir1"            */
+    AW_MOD_CLK_APB_KEYPAD,  /* "apb_key_pad"        */
+    AW_MOD_CLK_APB_TWI0,    /* "apb_twi0"           */
+    AW_MOD_CLK_APB_TWI1,    /* "apb_twi1"           */
+    AW_MOD_CLK_APB_TWI2,    /* "apb_twi2"           */
+    AW_MOD_CLK_APB_CAN,     /* "apb_can"            */
+    AW_MOD_CLK_APB_SCR,     /* "apb_scr"            */
+    AW_MOD_CLK_APB_PS20,    /* "apb_ps0"            */
+    AW_MOD_CLK_APB_PS21,    /* "apb_ps1"            */
+    AW_MOD_CLK_APB_UART0,   /* "apb_uart0"          */
+    AW_MOD_CLK_APB_UART1,   /* "apb_uart1"          */
+    AW_MOD_CLK_APB_UART2,   /* "apb_uart2"          */
+    AW_MOD_CLK_APB_UART3,   /* "apb_uart3"          */
+    AW_MOD_CLK_APB_UART4,   /* "apb_uart4"          */
+    AW_MOD_CLK_APB_UART5,   /* "apb_uart5"          */
+    AW_MOD_CLK_APB_UART6,   /* "apb_uart6"          */
+    AW_MOD_CLK_APB_UART7,   /* "apb_uart7"          */
+
+    /* clock gating for access dram */
+    AW_MOD_CLK_SDRAM_VE,    /* "sdram_ve"           */
+    AW_MOD_CLK_SDRAM_CSI0,  /* "sdram_csi0"         */
+    AW_MOD_CLK_SDRAM_CSI1,  /* "sdram_csi1"         */
+    AW_MOD_CLK_SDRAM_TS,    /* "sdram_ts"           */
+    AW_MOD_CLK_SDRAM_TVD,   /* "sdram_tvd"          */
+    AW_MOD_CLK_SDRAM_TVE0,  /* "sdram_tve0"         */
+    AW_MOD_CLK_SDRAM_TVE1,  /* "sdram_tve1"         */
+    AW_MOD_CLK_SDRAM_DEFE0, /* "sdram_de_scale0"    */
+    AW_MOD_CLK_SDRAM_DEFE1, /* "sdram_de_scale1"    */
+    AW_MOD_CLK_SDRAM_DEBE0, /* "sdram_de_image0"    */
+    AW_MOD_CLK_SDRAM_DEBE1, /* "sdram_de_image1"    */
+    AW_MOD_CLK_SDRAM_DEMP,  /* "sdram_de_mix"       */
+    AW_MOD_CLK_SDRAM_ACE,   /* "sdram_ace"          */
+
+    AW_MOD_CLK_AHB_EHCI1,   /* "ahb_ehci1"          */
+    AW_MOD_CLK_AHB_OHCI1,   /* "ahb_ohci1"          */
+
+    AW_MOD_CLK_IEP,         /* "iep"                */
+    AW_MOD_CLK_AHB_IEP,     /* "ahb_iep"            */
+    AW_MOD_CLK_SDRAM_IEP,   /* "sdram_iep"          */
+
+    AW_MOD_CLK_CNT
+
+} __aw_ccu_mod_clk_e;
+
+
+/* define handle for moduel clock   */
+typedef struct __AW_CCU_CLK
+{
+    __s32       id;     /* clock id         */
+    __s32       parent; /* parent clock id  */
+    char        *name;  /* clock name       */
+    __s32       onoff;  /* on/off status    */
+    __s32       reset;  /* reset status     */
+    __u64       rate;   /* clock rate, frequency for system clock, division for module clock */
+    __s32       hash;   /* hash value, for fast search without string compare   */
+
+}__aw_ccu_clk_t;
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_calc_hash
+*
+*Description: calculate hash value of a string;
+*
+*Arguments  : string    string whose hash value need be calculate;
+*
+*Return     : hash value
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline __s32 ccu_clk_calc_hash(char *string)
+{
+    __s32   tmpLen, i, tmpHash = 0;
+
+    if(!string)
+    {
+        return 0;
+    }
+
+    tmpLen = strlen(string);
+    for(i=0; i<tmpLen; i++)
+    {
+        tmpHash += string[i];
+    }
+
+    return tmpHash;
+}
+
+
+static inline __u64 ccu_clk_uldiv(__u64 dividend, __u32 divisior)
+{
+    __u64   tmpDiv = (__u64)divisior;
+    __u64   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return (__u32)dividend/divisior;
+    }
+
+    while(!(tmpDiv & ((__u64)1<<63)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
+
+
+__s32 aw_ccu_init(void);
+__s32 aw_ccu_exit(void);
+
+__s32 aw_ccu_get_sys_clk_cnt(void);
+__aw_ccu_clk_t *aw_ccu_get_sys_clk(__aw_ccu_sys_clk_e id);
+__aw_ccu_err_e aw_ccu_set_sys_clk(__aw_ccu_clk_t *clk);
+
+__s32 aw_ccu_get_mod_clk_cnt(void);
+__aw_ccu_clk_t *aw_ccu_get_mod_clk(__aw_ccu_mod_clk_e id);
+__aw_ccu_err_e aw_ccu_set_mod_clk(__aw_ccu_clk_t *clk);
+
+
+#endif /* #ifndef __AW_CCU_H__ */
+
diff --git a/arch/arm/mach-sun5i/include/mach/ccmu_regs.h b/arch/arm/mach-sun5i/include/mach/ccmu_regs.h
new file mode 100644
index 0000000..1a8a901
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/ccmu_regs.h
@@ -0,0 +1,617 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/ccmu_regs.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CCMU_REGS_H__
+#define __CCMU_REGS_H__
+
+
+typedef struct ___CCMU_PLL1_CORE_REG0000
+{
+    __u32   FactorM:2;          //bit0,  PLL1 Factor M
+    __u32   SigmaEn:1;          //bit2,  Sigma-delta pattern enable
+    __u32   SigmaIn:1;          //bit3,  Sigma-delta pattern input
+    __u32   FactorK:2;          //bit4,  PLL1 factor K
+    __u32   reserved0:2;        //bit6,  reserved
+    __u32   FactorN:5;          //bit8,  PLL1 Factor N
+    __u32   LockTime:3;         //bit13, PLL1 lock timer control
+    __u32   PLLDivP:2;          //bit16, PLL1 output external divider P
+    __u32   reserved1:2;        //bit18, reserved
+    __u32   PLLBias:5;          //bit20, PLL1 bias current control
+    __u32   reserved2:1;        //bit25, reserved
+    __u32   VCOBias:4;          //bit26, PLL1 VCO bias control
+    __u32   VCORstIn:1;         //bit30, VCO reset in
+    __u32   PLLEn:1;            //bit31, 0-disable, 1-enable, (24Mhz*N*K)/(M*P)
+
+} __ccmu_pll1_core_reg0000_t;
+
+typedef struct __CCMU_PLL1_TUNING_REG0004
+{
+    __u32   reserved0:16;       //bit0,  reserved for verify
+    __u32   InitFreq:7;         //bit16, PLL1 initial frequency control
+    __u32   VCOGainCtl:3;       //bit23, VCO Gain control
+    __u32   VCOGain:1;          //bit26, VCO Gain Control Enable
+    __u32   BandWidth:1;        //bit27, PLL1 band width control
+    __u32   DampFactor:4;       //bit28, PLL1 damping factor control
+} __ccmu_pll1_tuning_reg0004_t;
+
+
+typedef struct __CCMU_PLL2_AUDIO_REG0008
+{
+    __u32   PrevDiv:5;          //bit0,  PLL2 prev division
+    __u32   reserved0:3;        //bit5,  reserved
+    __u32   FactorN:7;          //bit8,  PLL2 factor N
+    __u32   reserved1:1;        //bit15, reserved
+    __u32   PLLBias:5;          //bit16, PLL2 bias current
+    __u32   VcoBias:5;          //bit21, PLL2 VCO bias current
+    __u32   PostDiv:4;          //bit26, PLL2 post division
+    __u32   reserved2:1;        //bit30, reserved
+    __u32   PLLEn:1;            //bit31, PLL2 enable
+} __ccmu_pll2_audio_reg0008_t;
+
+
+typedef struct __CCMU_PLL2_TUNING_REG000C
+{
+    __u32   WaveBottom:17;      //bit0,  wave bottom
+    __u32   Frequency:2;        //bit17, frequency, 00-31.5k, 01-32k, 10-32.5k, 11-33k
+    __u32   reserved0:1;        //bit19, reserved
+    __u32   WaveStep:9;         //bit20, wave step
+    __u32   FreqMode:2;         //bit29, Spred frequency mode
+    __u32   SigmaEn:1;          //bit31, Sigma-delta pattern enable
+
+} __ccmu_pll2_tuning_reg000c_t;
+
+
+typedef struct __CCMU_PLL3_VIDEO_REG0010
+{
+    __u32   FactorM:7;          //bit0,  PLL3 FactorM, 9<= M <=127
+    __u32   reserved0:1;        //bit7,  reserved
+    __u32   PLLBias:5;          //bit8,  PLL3 bias control
+    __u32   reserved1:1;        //bit13, reserved
+    __u32   FracSet:1;          //bit14, PLL3 fractional setting, 0-270Mhz, 1-297Mhz
+    __u32   ModeSel:1;          //bit15, PLL3 mode select
+    __u32   VCOBias:5;          //bit16, PLL3 VCO Bias control
+    __u32   reserved2:3;        //bit21, reserved
+    __u32   DampFactor:3;       //bit24, PLL3 damping factor controlf
+    __u32   reserved3:4;        //bit27, reserved
+    __u32   PLLEn:1;            //bit31, PLL3 enable
+} __ccmu_pll3_video_reg0010_t;
+
+
+typedef struct __CCMU_PLL4_VE_REG0018
+{
+    __u32   FactorM:2;          //bit0,  PLL4 factor M
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   FactorK:2;          //bit4,  PLL4 factor K
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   FactorN:5;          //bit8,  PLL4 factor N
+    __u32   reserved2:1;        //bit13, reserved
+    __u32   PllSwitch:2;        //bit14, PLL4 output switch, 00-pll4, 01-pll3x2, 10/11-pll6
+    __u32   FactorP:2;          //bit16, PLL4 output external divider P
+    __u32   reserved3:1;        //bit18, reserved
+    __u32   VCOGain:1;          //bit19, PLL4 VCO gain control
+    __u32   PLLBias:5;          //bit20, PLL4 Bias control
+    __u32   VCOBias:5;          //bit25, PLL4 VCO bias control
+    __u32   PLLBypass:1;        //bit30, PLL4 output bypass enable
+    __u32   PLLEn:1;            //bit31, PLL4 Enable, 24MHz*N*K/(M*P)
+} __ccmu_pll4_ve_reg0018_t;
+
+
+typedef struct __CCMU_PLL5_DDR_REG0020
+{
+    __u32   FactorM:2;          //bit0,  PLL5 factor M
+    __u32   FactorM1:2;         //bit2,  PLL5 factor M1
+    __u32   FactorK:2;          //bit4,  PLL5 factor K
+    __u32   reserved0:1;        //bit6,  reserved
+    __u32   LDO2En:1;           //bit7,  LDO2 enable
+    __u32   FactorN:5;          //bit8,  PLL5 factor N
+    __u32   VCOGain:3;          //bit13, PLL5 VCO gain control
+    __u32   FactorP:2;          //bit16, PLL5 output external divider P
+    __u32   BandWidth:1;        //bit18, PLL5 band width control, 0-narrow, 1-wide
+    __u32   VCOGainEn:1;        //bit19, PLL5 VCO gain control enable
+    __u32   PLLBias:5;          //bit20, PLL5 bias current control
+    __u32   VCOBias:4;          //bit25, PLL5 VCO bias
+    __u32   OutputEn:1;         //bit29, DDR clock output enable
+    __u32   PLLBypass:1;        //bit30, PLL5 output bypass enable
+    __u32   PLLEn:1;            //bit31, PLL5 Enable
+} __ccmu_pll5_ddr_reg0020_t;
+
+
+typedef struct __CCMU_PLL5_TUNING_REG0024
+{
+    __u32   reserved0:16;       //bit0,  reserved for verify
+    __u32   InitFreq:7;         //bit16, PLL5 initial frequency control
+    __u32   VCORstIn:1;         //bit23, VCO reset in
+    __u32   LockTime:3;         //bit24, PLL5 lock time control
+    __u32   reserved1:1;        //bit27, reserved
+    __u32   Vreg1OutEn:1;       //bit28, vreg1 out enable
+    __u32   DampFactor:3;       //bit29, PLL5 damping factor control
+} __ccmu_pll5_tuning_reg0024_t;
+
+typedef struct __CCMU_PLL6_SATA_REG0028
+{
+    __u32   FactorM:2;          //bit0,  PLL6 factor M
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   FactorK:2;          //bit4,  PLL6 factor K
+    __u32   DampFactor:2;       //bit6,  PLL6 damping factor control
+    __u32   FactorN:5;          //bit8,  PLL6 factor N
+    __u32   reserved1:2;        //bit13, reserved
+    __u32   BandWidth:1;        //bit15, PLL6 band width control
+    __u32   reserved2:4;        //bit16, reserved
+    __u32   PLLBias:5;          //bit20, PLL6 bias current control
+    __u32   VCOBias:5;          //bit25, PLL6 VCO bias
+    __u32   PLLBypass:1;        //bit30, PLL6 output bypass enable
+    __u32   PLLEn:1;            //bit31, PLL6 enable
+} __ccmu_pll6_sata_reg0028_t;
+
+
+typedef struct __CCMU_PLL7_VIDEO1_REG0030
+{
+    __u32   FactorM:7;          //bit0,  PLL7 factor M
+    __u32   reserved0:1;        //bit7,  reserved
+    __u32   PLLBias:5;          //bit8,  PLL7 bias control
+    __u32   reserved1:1;        //bit13, reserved
+    __u32   FracSet:1;          //bit14, PLL7 fractional setting, 0-270Mhz, 1-297Mhz
+    __u32   ModeSel:1;          //bit15, PLL7 mode select, 0-integer, 1-fractional
+    __u32   VCOBias:5;          //bit16, PLL7 bias control
+    __u32   reserved2:3;        //bit21, reserved
+    __u32   DampFactor:3;       //bit24, PLL7 damping factor control
+    __u32   reserved3:4;        //bit27, reserved
+    __u32   PLLEn:1;            //bit31, PLL7 enable
+} __ccmu_pll7_video1_reg0030_t;
+
+
+typedef struct __CCMU_PLL1_TUNING2_REG0038
+{
+    __u32   WaveBottom:17;      //bit0,  Wave bottom
+    __u32   Frequency:2;        //bit17, frequency, 00-31.5khz, 01-32khz, 10-32.5khz, 11-33khz
+    __u32   reserved0:1;        //bit19, reserved
+    __u32   WaveStep:9;         //bit20, Wave step
+    __u32   FreqMode:2;         //bit29, Spread frequency mode
+    __u32   SigmaEn:1;          //bit31, Sigma-delta pattern enable
+} __ccmu_pll1_tuning2_reg0038_t;
+
+
+typedef struct __CCMU_PLL5_TUNING2_REG003C
+{
+    __u32   WaveBottom:17;      //bit0,  wave bottom
+    __u32   Frequency:2;        //bit17, frequency, 00-31.5khz, 01-32khz, 10-32.5khz, 11-33khz
+    __u32   reserved0:1;        //bit19, reserved
+    __u32   WaveStep:9;         //bit20, wave step
+    __u32   FreqMode:2;         //bit29, Spread frequency mode
+    __u32   SigmaEn:1;          //bit31, sigma-delta pattern enable
+} __ccmu_pll5_tuning2_reg003c_t;
+
+
+typedef struct __CCMU_OSC24M_REG0050
+{
+    __u32   OSC24MEn:1;         //bit0,  OSC24M enable
+    __u32   OSC24MGsm:1;        //bit1,  OSC24M GSM
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   VregOutEn:1;        //bit4,  vreg out en for verify
+    __u32   reserved1:10;       //bit5,  reserved1
+    __u32   PLLBiasEn:1;        //bit15, PLL bias enable
+    __u32   LDOEn:1;            //bit16, LDO enable
+    __u32   PLLInPower:1;       //bit17, PLL intput power select, 0-2.5v, 1-3.3v
+    __u32   LDOOutput:3;        //bit18, LDO output control, 100-1.25v for ex.
+    __u32   KeyField:11;        //bit21, key field for LDO enable, 0x538,
+                                //spec define is that: 0xA7 for bit24~bit31, but "strb" will do nothing
+                                //so, we modify the bits define from bit21 to bit31 as 0x538
+} __ccmu_osc24m_reg0050_t;
+
+
+typedef struct __CCMU_SYSCLK_RATIO_REG0054
+{
+    __u32   AXIClkDiv:2;        //bit0,  AXI clock divide ratio, 00-1, 01-2, 10-3, 11-4
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   AHBClkDiv:2;        //bit4,  AHB clock divide ration, AHB clock source is AXI clock, 00-1, 01-2, 10-4, 11-8
+    __u32   AHBClkSel:2;        //bit6,  AHB clock source select, 00-AXI, 01-CPUCL, 10-PLL6/2, 11-reserved
+    __u32   APB0ClkDiv:2;       //bit8,  APB0 clock divide ratio, APB0 clock source is AHB, 00-2, 01-2, 10-4, 11-8
+    __u32   reserved1:6;        //bit10, reserved
+    __u32   AC328ClkSrc:2;      //bit16, CPU clock source select, 00-internal LOSC, 01-HOSC, 10-PLL, 11-200M
+    __u32   reserved2:14;       //bit18, reserved
+} __ccmu_sysclkl_ratio_reg0054_t;
+
+typedef struct __CCMU_APB1CLK_RATIO_REG0058
+{
+    __u32   ClkDiv:5;           //bit0,  clock divide ratio, diveded by (m+1), 1~32 ex.
+    __u32   reserved0:11;       //bit5,  reserved
+    __u32   PreDiv:2;           //bit16, clock pre-divide ratio, pre-devided by 2^, 1/2/4/8 ex.
+    __u32   reserved1:6;        //bit18, reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-HOSC, 01-PLL6, 10-LOSC, 11-reserved
+    __u32   reserved2:6;        //bit26, reserved
+} __ccmu_apb1clk_ratio_reg0058_t;
+
+
+typedef struct __CCMU_AXICLK_GATE_REG005c
+{
+    __u32   SdramGate:1;        //bit0,  gating AXI clock for SDRAM, 0-mask, 1-pass
+    __u32   reserved0:31;       //bit1,  reserved
+} __ccmu_axiclk_gate_reg005c_t;
+
+
+typedef struct __CCMU_AHBCLK_GATE0_REG0060
+{
+    __u32   Usb0Gate:1;         //bit0,  gating AHB clock for USB0, 0-mask, 1-pass
+    __u32   Ehci0Gate:1;        //bit1,  gating AHB clock for EHCI0, 0-mask, 1-pass
+    __u32   Ohci0Gate:1;        //bit2,  gating AHB clock for OHCI0, 0-mask, 1-pass
+    __u32   reserved0:2;        //bit3,  reserved
+    __u32   SsGate:1;           //bit5,  gating AHB clock for SS, 0-mask, 1-pass
+    __u32   DmaGate:1;          //bit6,  gating AHB clock for DMA, 0-mask, 1-pass
+    __u32   BistGate:1;         //bit7,  gating AHB clock for BIST, 0-mask, 1-pass
+    __u32   Sdmmc0Gate:1;       //bit8,  gating AHB clock for SD/MMC0, 0-mask, 1-pass
+    __u32   Sdmmc1Gate:1;       //bit9,  gating AHB clock for SD/MMC1, 0-mask, 1-pass
+    __u32   Sdmmc2Gate:1;       //bit10, gating AHB clock for SD/MMC2, 0-mask, 1-pass
+    __u32   reserved1:1;        //bit11, reserved
+    __u32   MsGate:1;           //bit12, gating AHB clock for MS, 0-mask, 1-pass
+    __u32   NandGate:1;         //bit13, gating AHB clock for NAND, 0-mask, 1-pass
+    __u32   SdramGate:1;        //bit14, gating AHB clock for SDRAM, 0-mask, 1-pass
+    __u32   reserved2:2;        //bit15, reserved
+    __u32   EmacGate:1;         //bit17, gating AHB clock for EMAC, 0-mask, 1-pass
+    __u32   TsGate:1;           //bit18, gating AHB clock for TS, 0-mask, 1-pass
+    __u32   reserved3:1;        //bit19, reserved
+    __u32   Spi0Gate:1;         //bit20, gating AHB clock for SPI0, 0-mask, 1-pass
+    __u32   Spi1Gate:1;         //bit21, gating AHB clock for SPI1, 0-mask, 1-pass
+    __u32   Spi2Gate:1;         //bit22, gating AHB clock for SPI2, 0-mask, 1-pass
+    __u32   reserved4:3;        //bit23, reserved
+    __u32   GpsGate:1;          //bit26, gating AHB clock for GPS, 0-mask, 1-pass
+    __u32   reserved5:1;        //bit27, reserved
+    __u32   StmrGate:1;         //bit28, gating AHB clock for STIMER, 0-mask, 1-pass
+    __u32   reserved6:3;        //bit29, reserved
+} __ccmu_ahbclk_gate0_reg0060_t;
+
+
+typedef struct __CCMU_AHBCLK_GATE1_REG0064
+{
+    __u32   VeGate:1;           //bit0,  gating AHB clock for VE, 0-mask, 1-pass
+    __u32   reserved0:1;        //bit1,  reserved
+    __u32   Tve0Gate:1;         //bit2,  gating AHB clock for TVE0, 0-mask, 1-pass
+    __u32   reserved1:1;        //bit3,  reserved
+    __u32   Lcd0Gate:1;         //bit4,  gating AHB clock for LCD0, 0-mask, 1-pass
+    __u32   reserved2:3;        //bit6,  reserved
+    __u32   Csi0Gate:1;         //bit8,  gating AHB clock for CSI0, 0-mask, 1-pass
+    __u32   reserved3:2;        //bit9,  reserved
+    __u32   HdmiDGate:1;        //bit11, gating AHB clock for HDMI, 0-mask, 1-pass
+    __u32   DeBe0Gate:1;        //bit12, gating AHB clock for DE-BE0, 0-mask, 1-pass
+    __u32   reserved4:1;        //bit13, reserved
+    __u32   DeFe0Gate:1;        //bit14, gating AHB clock for DE-FE0, 0-mask, 1-pass
+    __u32   reserved5:4;        //bit15, reserved
+    __u32   IepGate:1;          //bit19, gating AHB clock for IEP, 0-mask, 1-pass
+    __u32   MaliGate:1;         //bit20, gating AHB clock for Mali-400, 0-mask, 1-pass
+    __u32   reserved6:11;       //bit21, reserved
+} __ccmu_ahbclk_gate1_reg0064_t;
+
+
+typedef struct __CCMU_APB0CLK_GATE_REG0068
+{
+    __u32   AddaGate:1;         //bit0,  gating APB clock for audio codec, 0-mask, 1-pass
+    __u32   SpdifGate:1;        //bit1,  gating APB clock for SPDIF, 0-mask, 1-pass
+    __u32   reserved0:1;        //bit2,  reserved
+    __u32   IisGate:1;          //bit3,  gating APB clock for IIS, 0-mask, 1-pass
+    __u32   reserved1:1;        //bit4,  reserved
+    __u32   PioGate:1;          //bit5,  gating APB clock for PIO, 0-mask, 1-pass
+    __u32   Ir0Gate:1;          //bit6,  gating APB clock for IR0, 0-mask, 1-pass
+    __u32   reserved2:3;        //bit7,  reserved
+    __u32   KeypadGate:1;       //bit10, gating APB clock for keypad, 0-mask, 1-pass
+    __u32   reserved3:21;       //bit11,  reserved
+} __ccmu_apb0clk_gate_reg0068_t;
+
+
+typedef struct __CCMU_APB1CLK_GATE_REG006C
+{
+    __u32   Twi0Gate:1;         //bit0,  gating APB clock for TWI0, 0-mask, 1-pass
+    __u32   Twi1Gate:1;         //bit1,  gating APB clock for TWI1, 0-mask, 1-pass
+    __u32   Twi2Gate:1;         //bit2,  gating APB clock for TWI2, 0-mask, 1-pass
+    __u32   reserved0:13;       //bit3,  reserved
+    __u32   Uart0Gate:1;        //bit16, gating APB clock for UART0, 0-mask, 1-pass
+    __u32   Uart1Gate:1;        //bit17, gating APB clock for UART1, 0-mask, 1-pass
+    __u32   Uart2Gate:1;        //bit18, gating APB clock for UART2, 0-mask, 1-pass
+    __u32   Uart3Gate:1;        //bit19, gating APB clock for UART3, 0-mask, 1-pass
+    __u32   reserved1:12;       //bit20, reserved
+} __ccmu_apb1clk_gate_reg006c_t;
+
+
+/* module clock type 0, used for NAND, MS, SDMMC0/1/2/3, TS, SS, SPI0/1/2/3, PATA, IR0/1, */
+/* register address is 0x0080~0x00B4, 0x00D4 */
+typedef struct __CCMU_MODULE0_CLK
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:12;       //bit4,  reserved
+    __u32   ClkPreDiv:2;        //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex.
+    __u32   reserved1:6;        //bit18, reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-HOSC, 01-PLL6, 10-PLL5, 11-reserved
+    __u32   reserved2:5;        //bit26, reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_module0_clk_t;
+
+
+/* module clock type 1, used for IIS, AC97, SPDIF*/
+/* register address is 0x00B8~0x00C0 */
+typedef struct __CCMU_MODULE1_CLK
+{
+    __u32   reserved0:16;       //bit0,  reserved
+    __u32   ClkDiv:2;           //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex. source is 8xPLL2
+    __u32   reserved1:13;       //bit18, reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+
+} __ccmu_module1_clk_t;
+
+
+typedef struct __CCMU_KEYPAD_CLK_REG00C4
+{
+    __u32   ClkDiv:5;           //bit0,  clock divide ratio
+    __u32   reserved0:11;       //bit5,  reserved
+    __u32   ClkPreDiv:2;        //bit16, clock pre-divide ratio, pre-divided by 2^n, 1/2/4/8 ex.
+    __u32   reserved1:6;        //bit18, reserved
+    __u32   ClkSrc:2;           //bit24, clock select, 00-HOSC, 01-reserved, 10-LOSC, 11-reserved
+    __u32   reserved2:5;        //bit26, reserved
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_keypad_clk_reg00c4_t;
+
+
+typedef struct __CCMU_USB_CLK_REG00CC
+{
+    __u32   UsbPhy0Rst:1;       //bit0,  USB PHY0 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy1Rst:1;       //bit1,  USB PHY1 reset control, 0-reset valid, 1-reset invalid
+    __u32   reserved0:4;        //bit2,  reserved
+    __u32   OHCI0SpecClkGate:1; //bit6,  gating special clock for OHCI0, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   reserved1:1;        //bit7,  reserved
+    __u32   PhySpecClkGate:1;   //bit8,  gating special clock for USB PHY, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   reserved2:23;       //bit9,  reserved
+} __ccmu_usb_clk_reg00cc_t;
+
+
+typedef struct __CCMU_GPS_CLK_REG00D0
+{
+    __u32   DivM:3;             //bit0,  GPS clock prev-division
+    __u32   reserved0:21;       //bit3,  reserved
+    __u32   ClkSrc:2;           //bit24, GPS clock source select, 00-OSC24M, 01-PLL6, 10-PLL7, 11-PLL4
+    __u32   reserved1:4;        //bit26, reserved
+    __u32   Reset:1;            //bit30, GPS clock reset control
+    __u32   SpecClkGate:1;      //bit31, Gating special clock for GPS
+} __ccmu_gps_clk_reg00d0_t;
+
+
+typedef struct __CCMU_DRAM_GATE_REG0100
+{
+    __u32   VeGate:1;           //bit0,  Gating dram clock for VE, 0-mask, 1-pass
+    __u32   Csi0Gate:1;         //bit1,  Gating dram clock for CSI0, 0-mask, 1-pass
+    __u32   reserved0:1;        //bit2,  reserved
+    __u32   TsGate:1;           //bit3,  Gating dram clock for TS, 0-mask, 1-pass
+    __u32   reserved1:1;        //bit4,  reserved
+    __u32   Tve0Gate:1;         //bit5,  Gating dram clock for TVE0, 0-mask, 1-pass
+    __u32   reserved2:19;       //bit6,  reserved
+    __u32   DeFe0Gate:1;        //bit25, Gating dram clock for DE_FE0, 0-mask, 1-pass
+    __u32   DeBe0Gate:1;        //bit26, Gating dram clock for DE_BE0, 0-mask, 1-pass
+    __u32   reserved3:4;        //bit27, reserved
+    __u32   IepGate:1;          //bit31, Gating dram clock for IEP
+} __ccmu_dram_gate_reg0100_t;
+
+
+/* FEBEMP module clock type, used for DE-BE0, DE-BE1, DE-FE0, DE-FE1, DE-MP */
+/* register address is 0x0104~0x0114 */
+typedef struct __CCMU_FEDEMP_CLK
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divied by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-PLL3, 01-PLL7, 10-PLL5, 11-reserved
+    __u32   reserved1:4;        //bit26, reserved
+    __u32   Reset:1;            //bit30, module reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-clock off, 1-clock on
+
+} __ccmu_fedemp_clk_t;
+
+
+/* LCDCH0 module clock type, used for LCD0_CH0, LCD1_CH0 */
+/* register address is 0x0118~0x011C */
+typedef struct __CCMU_LCDCH0_CLK
+{
+    __u32   reserved0:24;       //bit0,  reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved1:3;        //bit26, reserved
+    __u32   TveReset:1;         //bit29, TVE reset, 0-reset valid, 1-reset invalid
+    __u32   LcdReset:1;         //bit30, LCD reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate:1;      //bit31, gating special clock, 0-clock off, 1-clock on
+
+} __ccmu_lcdch0_clk_t;
+
+
+/* LCD-CH1 module clock type, used for LCD0_CH1, LCD1_CH1 */
+/* register address is 0x012C~0x0130 */
+typedef struct __CCMU_LCDCH1_CLK
+{
+    __u32   ClkDiv:4;           //bit0,  clock division
+    __u32   reserved0:7;        //bit4,  reserved
+    __u32   SpecClk1Src:1;      //bit11, special clock 1 source select, 0-special clock2,
+    __u32   reserved1:3;        //bit12, reserved
+    __u32   SpecClk1Gate:1;     //bit15, gating special clock1, 0-clock off, 1-clock on
+    __u32   reserved2:8;        //bit16, reserved
+    __u32   SpecClk2Src:2;      //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved3:5;        //bit26, reserved
+    __u32   SpecClk2Gate:1;     //bit31, gating special clock2, 0-clock off, 1-clock on
+
+} __ccmu_lcdch1_clk_t;
+
+
+/* CSI module clock type, used for CSI0/1 */
+/* register address is 0x0134~0x0138 */
+typedef struct __CCMU_CSI_CLK
+{
+    __u32   ClkDiv:5;           //bit0,  clock divide ratio, divided by (m+1), 1~32, ex.
+    __u32   reserved0:19;       //bit5,  reserved
+    __u32   ClkSrc:3;           //bit24, clock source select, 000-HOSC, 001-PLL3(1x), 010-PLL7(1x), 011/100/111-reserved, 101-PLL3(2x), 110:PLL7(2x)
+    __u32   reserved1:3;        //bit27, reserved
+    __u32   Reset:1;            //bit30, CSI reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_csi_clk_t;
+
+
+typedef struct __CCMU_VE_CLK_REG013C
+{
+    __u32   Reset:1;            //bit0,  VE reset, 0-reset valid, 1-reset invalid
+    __u32   reserved0:15;       //bit1,  reserved
+    __u32   ClkDiv:3;           //bit16, Clock pre-divide ratio, divided by (n+1), 1~8 ex.
+    __u32   reserved1:12;       //bit19, reserved
+    __u32   SpecClkGate:1;      //bit31, gating special clock for VE, 0-mask, 1-pass
+}__ccmu_ve_clk_reg013c_t;
+
+typedef struct __CCMU_ADDA_CLK_REG0140
+{
+    __u32   reserved0:31;       //bit0,  reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_adda_clk_reg0140_t;
+
+typedef struct __CCMU_AVS_CLK_REG0144
+{
+    __u32   reserved0:31;       //bit0,  reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_avs_clk_reg0144_t;
+
+
+typedef struct __CCMU_LVDS_CLK_REG014C
+{
+    __u32   Reset:1;            //bit0,  LVDS reset
+    __u32   reserved:31;        //bit1,  reserved
+} __ccmu_lvds_clk_reg014c_t;
+
+
+typedef struct __CCMU_HDMI_CLK_REG0150
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved1:5;        //bit26, reserved
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_hdmi_clk_reg0150_t;
+
+
+typedef struct __CCMU_MALI400_CLK_REG0154
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:3;           //bit24, clolck source select, 000-PLL3, 001-PLL4, 010-PLL5, 011-PLL7(1x), 100-PLL7(2x)
+    __u32   reserved1:3;        //bit27, reserved
+    __u32   Reset:1;            //bit30, Mali400 reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate:1;      //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_mali400_clk_reg0154_t;
+
+
+typedef struct __CCMU_MBUS_CLK_REG015C
+{
+    __u32   ClkDiv:4;           //bit0,  MBUS clock divide ratio
+    __u32   reserved0:12;       //bit4,  reserved
+    __u32   PreDiv:2;           //bit16, MBUS clock pre-divide ratio
+    __u32   reserved1:6;        //bit18, reserved
+    __u32   ClkSrc:2;           //bit24, MBUS clock source select, 00-HOSC, 01-PLL6, 10-PLL5, 11-reserved
+    __u32   reserved2:5;        //bit16, reserved
+    __u32   ClkGate:1;          //bit31, Gating clock for MBUS, max clock = 300Mhz, 0-clock is OFF, 1-clock is ON,
+                                //       MBUS_CLOCK = clock-source/Divider-N/Divider-M
+} __ccmu_mbus_clk_reg015c_t;
+
+
+typedef struct __CCMU_IEP_CLK_REG0160
+{
+    __u32   reserved:30;        //bit0,  reserved
+    __u32   Reset:1;            //bit30, IEP reset, 0-reset valid, 1-reset invalid
+    __u32   ClkGate:1;          //bit31, Gating clock for IEP
+
+} __ccmu_iep_clk_reg0160_t;
+
+typedef struct __CCMU_REG_LIST
+{
+    volatile __ccmu_pll1_core_reg0000_t     Pll1Ctl;    //0x0000, PLL1 control
+    volatile __ccmu_pll1_tuning_reg0004_t   Pll1Tune;   //0x0004, PLL1 tuning
+    volatile __ccmu_pll2_audio_reg0008_t    Pll2Ctl;    //0x0008, PLL2 control
+    volatile __ccmu_pll2_tuning_reg000c_t   Pll2Tune;   //0x000C, PLL2 tuning
+    volatile __ccmu_pll3_video_reg0010_t    Pll3Ctl;    //0x0010, PLL3 control
+    volatile __u32                          reserved0;  //0x0014, reserved
+    volatile __ccmu_pll4_ve_reg0018_t       Pll4Ctl;    //0x0018, PLL4 control
+    volatile __u32                          reserved1;  //0x001C, reserved
+    volatile __ccmu_pll5_ddr_reg0020_t      Pll5Ctl;    //0x0020, PLL5 control
+    volatile __ccmu_pll5_tuning_reg0024_t   Pll5Tune;   //0x0024, PLL5 tuning
+    volatile __ccmu_pll6_sata_reg0028_t     Pll6Ctl;    //0x0028, PLL6 control
+    volatile __u32                          reserved2;  //0x002C, reserved
+    volatile __ccmu_pll7_video1_reg0030_t   Pll7Ctl;    //0x0030, Pll7 control
+    volatile __u32                          reserved3;  //0x0034, reserved
+    volatile __ccmu_pll1_tuning2_reg0038_t  Pll1Tune2;  //0x0038, Pll1 tuning2
+    volatile __ccmu_pll5_tuning2_reg003c_t  Pll5Tune2;  //0x003C, Pll5 tuning2
+    volatile __u32                          reserved4[4];//0x0040, reserved
+    volatile __ccmu_osc24m_reg0050_t        HoscCtl;    //0x0050, OSC24M control
+    volatile __ccmu_sysclkl_ratio_reg0054_t SysClkDiv;  //0x0054, AC328/AHB/APB0 divide ratio
+    volatile __ccmu_apb1clk_ratio_reg0058_t Apb1ClkDiv; //0x0058, APB1 clock dividor
+    volatile __ccmu_axiclk_gate_reg005c_t   AxiGate;    //0x005C, AXI module clock gating
+    volatile __ccmu_ahbclk_gate0_reg0060_t  AhbGate0;   //0x0060, AHB module clock gating 0
+    volatile __ccmu_ahbclk_gate1_reg0064_t  AhbGate1;   //0x0064, AHB module clock gating 1
+    volatile __ccmu_apb0clk_gate_reg0068_t  Apb0Gate;   //0x0068, APB0 module clock gating
+    volatile __ccmu_apb1clk_gate_reg006c_t  Apb1Gate;   //0x006C, APB1 module clock gating
+    volatile __u32                          reserved5[4];   //0x0070, reserved
+    volatile __ccmu_module0_clk_t           NandClk;    //0x0080, nand module clock control
+    volatile __ccmu_module0_clk_t           MsClk;      //0x0084, MS module clock control
+    volatile __ccmu_module0_clk_t           SdMmc0Clk;  //0x0088, SD/MMC0 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc1Clk;  //0x008C, SD/MMC1 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc2Clk;  //0x0090, SD/MMC2 module clock control
+    volatile __u32                          reserved6;  //0x0094, reserved
+    volatile __ccmu_module0_clk_t           TsClk;      //0x0098, TS module clock control
+    volatile __ccmu_module0_clk_t           SsClk;      //0x009C, SS module clock control
+    volatile __ccmu_module0_clk_t           Spi0Clk;    //0x00A0, SPI0 module clock control
+    volatile __ccmu_module0_clk_t           Spi1Clk;    //0x00A4, SPI1 module clock control
+    volatile __ccmu_module0_clk_t           Spi2Clk;    //0x00A8, SPI2 module clock control
+    volatile __u32                          reserved7;  //0x00AC, reserved
+    volatile __ccmu_module0_clk_t           Ir0Clk;     //0x00B0, IR0 module clock control
+    volatile __u32                          reserved8;  //0x00B4, reserved
+    volatile __ccmu_module1_clk_t           I2sClk;     //0x00B8, IIS module clock control
+    volatile __u32                          reserved9;  //0x00BC, reserved
+    volatile __ccmu_module1_clk_t           SpdifClk;   //0x00C0, SPDIF module clock control
+    volatile __ccmu_keypad_clk_reg00c4_t    KeyPadClk;  //0x00C4, KEYPAD module clock control
+    volatile __u32                          reserved11; //0x00C8, reserved
+    volatile __ccmu_usb_clk_reg00cc_t       UsbClk;     //0x00CC, USB module clock control
+    volatile __ccmu_gps_clk_reg00d0_t       GpsClk;     //0x00D0, GPS module clock control
+    volatile __u32                          reserved12; //0x00D4, reserved
+    volatile __u32                          reserved13[10]; //0x00D8, reserved
+    volatile __ccmu_dram_gate_reg0100_t     DramGate;   //0x0100, DRAM gating
+    volatile __ccmu_fedemp_clk_t            DeBe0Clk;   //0x0104, DE-BE 0 module clock control
+    volatile __u32                          reserved14; //0x0108, reserved
+    volatile __ccmu_fedemp_clk_t            DeFe0Clk;   //0x010C, DE-FE 0 module clock control
+    volatile __u32                          reserved15;   //0x0110, reserved
+    volatile __u32                          reserved16;   //0x0114, reserved
+    volatile __ccmu_lcdch0_clk_t            Lcd0Ch0Clk; //0x0118, LCD0 CH0 module clock control
+    volatile __u32                          reserved17[4];   //0x011C, reserved
+    volatile __ccmu_lcdch1_clk_t            Lcd0Ch1Clk; //0x012C, LCD0 CH1 module clock control
+    volatile __u32                          reserved18;  //0x0130, reserved
+    volatile __ccmu_csi_clk_t               Csi0Clk;    //0x0134, CSI0 module clock control
+    volatile __u32                          reserved19;  //0x0138, reserved
+    volatile __ccmu_ve_clk_reg013c_t        VeClk;      //0x013C, VE module clock control
+    volatile __ccmu_adda_clk_reg0140_t      AddaClk;    //0x0140, audio codec clock control
+    volatile __ccmu_avs_clk_reg0144_t       AvsClk;     //0x0144, AVS module clock control
+    volatile __u32                          reserved20;  //0x0148, reserved
+    volatile __ccmu_lvds_clk_reg014c_t      LvdsClk;    //0x014C, LVDS module clock control
+    volatile __ccmu_hdmi_clk_reg0150_t      HdmiClk;    //0x0150, HDMI module clock control
+    volatile __ccmu_mali400_clk_reg0154_t   MaliClk;    //0x0154, MALI400 module clock control
+    volatile __u32                          reserved21; //0x0158, reserved
+    volatile __ccmu_mbus_clk_reg015c_t      MbusClk;    //0x015c, MBUS clock control
+    volatile __ccmu_iep_clk_reg0160_t       IepClk;     //0x0160, IEP clock control
+
+} __ccmu_reg_list_t;
+
+
+#endif  // #ifndef __CCMU_REGS_H__
+
diff --git a/arch/arm/mach-sun5i/include/mach/clock.h b/arch/arm/mach-sun5i/include/mach/clock.h
new file mode 100644
index 0000000..689be1b
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/clock.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/clock.h
+ */
+
+#include <plat/clock.h>
diff --git a/arch/arm/mach-sun5i/include/mach/debug-macro.S b/arch/arm/mach-sun5i/include/mach/debug-macro.S
new file mode 100644
index 0000000..5314af0
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/debug-macro.S
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/debug-macro.S
+ */
+
+#include <plat/debug-macro.S>
diff --git a/arch/arm/mach-sun5i/include/mach/dma.h b/arch/arm/mach-sun5i/include/mach/dma.h
new file mode 100644
index 0000000..8ab1cc5
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/dma.h
@@ -0,0 +1,669 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/dma.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H __FILE__
+
+#include <linux/device.h>
+#include <mach/hardware.h>
+
+
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#define DMA_CH_VALID		(1<<31)
+#define DMA_CH_NEVER		(1<<30)
+
+/* We use `virtual` dma channels to hide the fact we have only a limited
+ * number of DMA channels, and not of all of them (dependant on the device)
+ * can be attached to any DMA source. We therefore let the DMA core handle
+ * the allocation of hardware channels to clients.
+*/
+enum sw_dma_ch {
+	/*NDMA*/
+	DMACH_NSPI0,
+	DMACH_NSPI1,
+	DMACH_NSPI2,
+	DMACH_NUART0,
+	DMACH_NUART1,
+	DMACH_NUART2,
+	DMACH_NUART3,
+	DMACH_NSRAM,
+	DMACH_NSDRAM,
+	DMACH_NTPAD,
+	DMACH_NADDA_PLAY,//audio play
+	DMACH_NADDA_CAPTURE,//audio capture
+	DMACH_NIIS,
+	DMACH_NIIS_CAPTURE,
+	DMACH_NIR,
+	DMACH_NSPDIF,
+	DMACH_NHDMI,//HDMI
+	DMACH_NUSBEP1,
+	DMACH_NUSBEP2,
+	DMACH_NUSBEP3,
+	DMACH_NUSBEP4,
+	DMACH_NUSBEP5,
+	/*DDMA*/
+	DMACH_DSRAM,
+	DMACH_DSDRAM,
+	DMACH_DNAND,
+	DMACH_DUSB0,
+	DMACH_DEMACR,
+	DMACH_DEMACT,
+	DMACH_DSPI1,
+	DMACH_DSSR,
+	DMACH_DSST,
+	DMACH_TCON0,
+	DMACH_HDMIAUDIO,//HDMIAUDIO
+	DMACH_DMS,
+	DMACH_DSPI0,
+	DMACH_DSPI2,
+	DMACH_MAX,/* 8 NDMAs, 8 DDMAs */
+};
+
+
+#define N_DRQSRC_SHIFT		0
+#define N_DRQDST_SHIFT		16
+#define D_DRQSRC_SHIFT		0
+#define D_DRQDST_SHIFT		16
+#define DRQ_INVALID			0xff
+
+/*normal DMA Source*/
+#define N_DRQSRC_IRRX		0b00000
+#define N_DRQSRC_SPDIFRX	0b00010
+#define N_DRQSRC_IISRX		0b00011
+#define N_DRQSRC_UART0RX	0b01000
+#define N_DRQSRC_UART1RX 	0b01001
+#define N_DRQSRC_UART2RX	0b01010
+#define N_DRQSRC_UART3RX	0b01011
+#define N_DRQSRC_HDMIDDCRX	0b10000
+#define N_DRQSRC_AUDIOCDAD	0b10011	//Audio Codec D/A
+#define N_DRQSRC_SRAM		0b10101
+#define N_DRQSRC_SDRAM		0b10110
+#define N_DRQSRC_TPAD		0b10111	//TP A/D
+#define N_DRQSRC_SPI0RX		0b11000
+#define N_DRQSRC_SPI1RX		0b11001
+#define N_DRQSRC_SPI2RX		0b11010
+#define N_DRQSRC_USBEP1		0b11011
+#define N_DRQSRC_USBEP2		0b11100
+#define N_DRQSRC_USBEP3		0b11101
+#define N_DRQSRC_USBEP4		0b11110
+#define N_DRQSRC_USBEP5		0b11111
+
+/*normal DMA destination*/
+#define N_DRQDST_IRTX		0b00000
+#define N_DRQDST_SPDIFTX	0b00010
+#define N_DRQDST_IISTX		0b00011
+#define N_DRQDST_UART0TX	0b01000
+#define N_DRQDST_UART1TX 	0b01001
+#define N_DRQDST_UART2TX	0b01010
+#define N_DRQDST_UART3TX	0b01011
+#define N_DRQDST_HDMIDDCTX	0b10000//HDMI DDC TX
+#define N_DRQDST_AUDIOCDAD	0b10011//Audio Codec D/A
+#define N_DRQDST_SRAM		0b10101
+#define N_DRQDST_SDRAM		0b10110
+#define N_DRQDST_SPI0TX		0b11000
+#define N_DRQDST_SPI1TX		0b11001
+#define N_DRQDST_SPI2TX		0b11010
+#define N_DRQDST_USBEP1		0b11011
+#define N_DRQDST_USBEP2		0b11100
+#define N_DRQDST_USBEP3		0b11101
+#define N_DRQDST_USBEP4		0b11110
+#define N_DRQDST_USBEP5		0b11111
+
+/*Dedicated DMA Source*/
+#define D_DRQSRC_SRAM		0b00000//0x0 SRAM memory
+#define D_DRQSRC_SDRAM		0b00001//0x1 SDRAM memory
+#define D_DRQSRC_NAND 		0b00011//0x3 NAND Flash Controller(NFC)
+#define D_DRQSRC_USB0 		0b00100//0x4 USB0
+#define D_DRQSRC_EMACRX		0b00111//0x7 Ethernet MAC Rx
+#define D_DRQSRC_SPI1RX		0b01001//0x9 SPI1 RX
+#define D_DRQSRC_SECRX 		0b01011//0xB Security System Rx
+#define D_DRQSRC_MS 		0b10111//0x17 Memory Stick Controller(MSC)
+#define D_DRQSRC_SPI0RX		0b11011//0x1B SPI0 RX
+#define D_DRQSRC_SPI2RX		0b11101//0x1D SPI2 RX
+
+/*Dedicated DMA Destination*/
+#define D_DRQDST_SRAM		0b00000//0x0 SRAM memory
+#define D_DRQDST_SDRAM		0b00001//0x1 SDRAM memory
+#define D_DRQDST_NAND 		0b00011//0x3 NAND Flash Controller(NFC)
+#define D_DRQDST_USB0 		0b00100//0x4 USB0
+#define D_DRQDST_EMACTX		0b00110//0x6 Ethernet MAC Rx
+#define D_DRQDST_SPI1TX		0b01000//0x8 SPI1 RX
+#define D_DRQDST_SECTX 		0b01010//0xA Security System Tx
+#define D_DRQDST_TCON0 		0b01110//0xE TCON0
+#define D_DRQDST_MS			0b10111//0x17 Memory Stick Controller(MSC)
+#define D_DRQDST_HDMIAUDIO	0b11000//0x18 HDMI Audio
+#define D_DRQDST_SPI0TX		0b11010//0x1A SPI0 TX
+#define D_DRQDST_SPI2TX		0b11100//0x1C SPI2 TX
+
+enum drq_type {
+		DRQ_TYPE_SRAM,
+		DRQ_TYPE_SDRAM,
+		DRQ_TYPE_NAND,
+		DRQ_TYPE_USB0,
+		DRQ_TYPE_EMAC,
+		DRQ_TYPE_SPI1,
+		DRQ_TYPE_SS,//Security System
+		DRQ_TYPE_MS,//Memory Stick Control
+		DRQ_TYPE_SPI0,
+		DRQ_TYPE_SPI2,
+		DRQ_TYPE_TCON0,
+		DRQ_TYPE_HDMIAUDIO,
+
+		DRQ_TYPE_HDMI,
+		DRQ_TYPE_IR,
+		DRQ_TYPE_SPDIF,
+		DRQ_TYPE_IIS,
+		DRQ_TYPE_UART0,
+		DRQ_TYPE_UART1,
+		DRQ_TYPE_UART2,
+		DRQ_TYPE_UART3,
+		DRQ_TYPE_AUDIO,
+		DRQ_TYPE_TPAD,
+		DRQ_TYPE_USBEP1,
+		DRQ_TYPE_USBEP2,
+		DRQ_TYPE_USBEP3,
+		DRQ_TYPE_USBEP4,
+		DRQ_TYPE_USBEP5,
+		DRQ_TYPE_MAX,
+};
+
+
+/* DMAXFER_(dist)_(sigle/burst/tippl)_(byte/half/word)_(src)_(sigle/burst/tippl)_(byte/half/word) */
+#define X_SIGLE   0
+#define X_BURST   1
+#define X_TIPPL	  2
+#define X_BYTE    0
+#define X_HALF    1
+#define X_WORD    2
+
+/*data length and burst length combination in DDMA and NDMA */
+enum xferunit {
+	/*des:X_SIGLE  src:X_SIGLE*/
+	DMAXFER_D_SBYTE_S_SBYTE,
+	DMAXFER_D_SBYTE_S_SHALF,
+	DMAXFER_D_SBYTE_S_SWORD,
+	DMAXFER_D_SHALF_S_SBYTE,
+	DMAXFER_D_SHALF_S_SHALF,
+	DMAXFER_D_SHALF_S_SWORD,
+	DMAXFER_D_SWORD_S_SBYTE,
+	DMAXFER_D_SWORD_S_SHALF,
+	DMAXFER_D_SWORD_S_SWORD,
+
+	/*des:X_SIGLE  src:X_BURST*/
+	DMAXFER_D_SBYTE_S_BBYTE,
+	DMAXFER_D_SBYTE_S_BHALF,
+	DMAXFER_D_SBYTE_S_BWORD,
+	DMAXFER_D_SHALF_S_BBYTE,
+	DMAXFER_D_SHALF_S_BHALF,
+	DMAXFER_D_SHALF_S_BWORD,
+	DMAXFER_D_SWORD_S_BBYTE,
+	DMAXFER_D_SWORD_S_BHALF,
+	DMAXFER_D_SWORD_S_BWORD,
+
+	/*des:X_SIGLE   src:X_TIPPL*/
+	DMAXFER_D_SBYTE_S_TBYTE,
+	DMAXFER_D_SBYTE_S_THALF,
+	DMAXFER_D_SBYTE_S_TWORD,
+	DMAXFER_D_SHALF_S_TBYTE,
+	DMAXFER_D_SHALF_S_THALF,
+	DMAXFER_D_SHALF_S_TWORD,
+	DMAXFER_D_SWORD_S_TBYTE,
+	DMAXFER_D_SWORD_S_THALF,
+	DMAXFER_D_SWORD_S_TWORD,
+
+	/*des:X_BURST  src:X_BURST*/
+	DMAXFER_D_BBYTE_S_BBYTE,
+	DMAXFER_D_BBYTE_S_BHALF,
+	DMAXFER_D_BBYTE_S_BWORD,
+	DMAXFER_D_BHALF_S_BBYTE,
+	DMAXFER_D_BHALF_S_BHALF,
+	DMAXFER_D_BHALF_S_BWORD,
+	DMAXFER_D_BWORD_S_BBYTE,
+	DMAXFER_D_BWORD_S_BHALF,
+	DMAXFER_D_BWORD_S_BWORD,
+
+	/*des:X_BURST   src:X_SIGLE*/
+	DMAXFER_D_BBYTE_S_SBYTE,
+	DMAXFER_D_BBYTE_S_SHALF,
+	DMAXFER_D_BBYTE_S_SWORD,
+	DMAXFER_D_BHALF_S_SBYTE,
+	DMAXFER_D_BHALF_S_SHALF,
+	DMAXFER_D_BHALF_S_SWORD,
+	DMAXFER_D_BWORD_S_SBYTE,
+	DMAXFER_D_BWORD_S_SHALF,
+	DMAXFER_D_BWORD_S_SWORD,
+
+	/*des:X_BURST   src:X_TIPPL*/
+	DMAXFER_D_BBYTE_S_TBYTE,
+	DMAXFER_D_BBYTE_S_THALF,
+	DMAXFER_D_BBYTE_S_TWORD,
+	DMAXFER_D_BHALF_S_TBYTE,
+	DMAXFER_D_BHALF_S_THALF,
+	DMAXFER_D_BHALF_S_TWORD,
+	DMAXFER_D_BWORD_S_TBYTE,
+	DMAXFER_D_BWORD_S_THALF,
+	DMAXFER_D_BWORD_S_TWORD,
+
+	/*des:X_TIPPL   src:X_TIPPL*/
+	DMAXFER_D_TBYTE_S_TBYTE,
+	DMAXFER_D_TBYTE_S_THALF,
+	DMAXFER_D_TBYTE_S_TWORD,
+	DMAXFER_D_THALF_S_TBYTE,
+	DMAXFER_D_THALF_S_THALF,
+	DMAXFER_D_THALF_S_TWORD,
+	DMAXFER_D_TWORD_S_TBYTE,
+	DMAXFER_D_TWORD_S_THALF,
+	DMAXFER_D_TWORD_S_TWORD,
+
+	/*des:X_TIPPL   src:X_SIGLE*/
+	DMAXFER_D_TBYTE_S_SBYTE,
+	DMAXFER_D_TBYTE_S_SHALF,
+	DMAXFER_D_TBYTE_S_SWORD,
+	DMAXFER_D_THALF_S_SBYTE,
+	DMAXFER_D_THALF_S_SHALF,
+	DMAXFER_D_THALF_S_SWORD,
+	DMAXFER_D_TWORD_S_SBYTE,
+	DMAXFER_D_TWORD_S_SHALF,
+	DMAXFER_D_TWORD_S_SWORD,
+
+	/*des:X_TIPPL   src:X_BURST*/
+	DMAXFER_D_TBYTE_S_BBYTE,
+	DMAXFER_D_TBYTE_S_BHALF,
+	DMAXFER_D_TBYTE_S_BWORD,
+	DMAXFER_D_THALF_S_BBYTE,
+	DMAXFER_D_THALF_S_BHALF,
+	DMAXFER_D_THALF_S_BWORD,
+	DMAXFER_D_TWORD_S_BBYTE,
+	DMAXFER_D_TWORD_S_BHALF,
+	DMAXFER_D_TWORD_S_BWORD,
+	DMAXFER_MAX
+};
+
+/* DMAADDRT_(dist)_(increase/fix)_(src)_(increase/fix) */
+#define A_INC     0x0
+#define A_FIX     0x1
+#define A_LN      0x0
+#define A_IO      0x1
+#define A_PH      0x2
+#define A_PV      0x3
+
+enum addrt {
+	/*NDMA address type*/
+	DMAADDRT_D_INC_S_INC,
+	DMAADDRT_D_INC_S_FIX,
+	DMAADDRT_D_FIX_S_INC,
+	DMAADDRT_D_FIX_S_FIX,
+
+	/*DDMA address type*/
+	DMAADDRT_D_LN_S_LN,
+	DMAADDRT_D_LN_S_IO,
+	DMAADDRT_D_LN_S_PH,
+	DMAADDRT_D_LN_S_PV,
+
+	DMAADDRT_D_IO_S_LN,
+	DMAADDRT_D_IO_S_IO,
+	DMAADDRT_D_IO_S_PH,
+	DMAADDRT_D_IO_S_PV,
+
+	DMAADDRT_D_PH_S_LN,
+	DMAADDRT_D_PH_S_IO,
+	DMAADDRT_D_PH_S_PH,
+	DMAADDRT_D_PH_S_PV,
+
+	DMAADDRT_D_PV_S_LN,
+	DMAADDRT_D_PV_S_IO,
+	DMAADDRT_D_PV_S_PH,
+	DMAADDRT_D_PV_S_PV,
+
+	DMAADDRT_MAX
+};
+
+/* use this to specifiy hardware channel number */
+#define DMACH_LOW_LEVEL	(1<<28)
+
+/* we have 16 dma channels */
+#define SW_DMA_CHANNELS		(16)
+
+/* types */
+enum sw_dma_state {
+	SW_DMA_IDLE,
+	SW_DMA_RUNNING,
+	SW_DMA_PAUSED
+};
+
+
+/* enum sw_dma_loadst
+ *
+ * This represents the state of the DMA engine, wrt to the loaded / running
+ * transfers. Since we don't have any way of knowing exactly the state of
+ * the DMA transfers, we need to know the state to make decisions on wether
+ * we can
+ *
+ * SW_DMA_NONE
+ *
+ * There are no buffers loaded (the channel should be inactive)
+ *
+ * SW_DMA_1LOADED
+ *
+ * There is one buffer loaded, however it has not been confirmed to be
+ * loaded by the DMA engine. This may be because the channel is not
+ * yet running, or the DMA driver decided that it was too costly to
+ * sit and wait for it to happen.
+ *
+ * SW_DMA_1RUNNING
+ *
+ * The buffer has been confirmed running, and not finisged
+ *
+ * SW_DMA_1LOADED_1RUNNING
+ *
+ * There is a buffer waiting to be loaded by the DMA engine, and one
+ * currently running.
+*/
+
+enum sw_dma_loadst {
+	SW_DMALOAD_NONE,
+	SW_DMALOAD_1LOADED,
+	SW_DMALOAD_1RUNNING,
+	SW_DMALOAD_1LOADED_1RUNNING,
+};
+
+enum sw_dma_buffresult {
+	SW_RES_OK,
+	SW_RES_ERR,
+	SW_RES_ABORT
+};
+
+enum sw_dmadir {
+	SW_DMA_RWNULL,
+	SW_DMA_RDEV,		/* read from dev */
+	SW_DMA_WDEV,		/* write to dev */
+	SW_DMA_M2M,
+//	SW_DMA_RWDEV		/* can r/w dev */
+};
+
+enum dma_hf_irq {
+	SW_DMA_IRQ_NO,
+	SW_DMA_IRQ_HALF,
+	SW_DMA_IRQ_FULL
+};
+/* enum sw_chan_op
+ *
+ * operation codes passed to the DMA code by the user, and also used
+ * to inform the current channel owner of any changes to the system state
+*/
+
+enum sw_chan_op {
+	SW_DMAOP_START,
+	SW_DMAOP_STOP,
+	SW_DMAOP_PAUSE,
+	SW_DMAOP_RESUME,
+	SW_DMAOP_FLUSH,
+	SW_DMAOP_TIMEOUT,		/* internal signal to handler */
+	SW_DMAOP_STARTED,		/* indicate channel started */
+};
+
+/* flags */
+
+#define SW_DMAF_SLOW         (1<<0)   /* slow, so don't worry about
+					    * waiting for reloads */
+#define SW_DMAF_AUTOSTART    (1<<1)   /* auto-start if buffer queued */
+
+/* dma buffer */
+
+struct sw_dma_client {
+	char                *name;
+};
+
+/* sw_dma_buf_s
+ *
+ * internally used buffer structure to describe a queued or running
+ * buffer.
+*/
+
+struct sw_dma_buf;
+struct sw_dma_buf {
+	struct sw_dma_buf	*next;
+	int			 magic;		/* magic */
+	int			 size;		/* buffer size in bytes */
+	dma_addr_t		 data;		/* start of DMA data */
+	dma_addr_t		 ptr;		/* where the DMA got to [1] */
+	void			*id;		/* client's id */
+};
+
+/* [1] is this updated for both recv/send modes? */
+
+struct sw_dma_chan;
+
+/* sw_dma_cbfn_t
+ *
+ * buffer callback routine type
+*/
+
+typedef void (*sw_dma_cbfn_t)(struct sw_dma_chan *,
+				   void *buf, int size,
+				   enum sw_dma_buffresult result);
+
+typedef int  (*sw_dma_opfn_t)(struct sw_dma_chan *,
+				   enum sw_chan_op );
+
+struct sw_dma_stats {
+	unsigned long		loads;
+	unsigned long		timeout_longest;
+	unsigned long		timeout_shortest;
+	unsigned long		timeout_avg;
+	unsigned long		timeout_failed;
+};
+
+struct sw_dma_map;
+
+/* struct sw_dma_chan
+ *
+ * full state information for each DMA channel
+*/
+
+struct sw_dma_chan {
+	/* channel state flags and information */
+	unsigned char		 number;      /* number of this dma channel */
+	unsigned char		 in_use;      /* channel allocated */
+	unsigned char		 irq_claimed; /* irq claimed for channel */
+	unsigned char		 irq_enabled; /* irq enabled for channel */
+
+	/* channel state */
+
+	enum sw_dma_state	 state;
+	enum sw_dma_loadst	 load_state;
+	struct sw_dma_client *client;
+
+	/* channel configuration */
+	unsigned long		 dev_addr;
+	unsigned long		 load_timeout;
+	unsigned int		 flags;		/* channel flags */
+	unsigned int		 hw_cfg;	/* last hw config */
+
+	struct sw_dma_map	*map;		/* channel hw maps */
+
+	/* channel's hardware position and configuration */
+	void __iomem		*regs;		/* channels registers */
+	void __iomem		*addr_reg;	/* data address register */
+	//unsigned int		 irq;		/* channel irq */
+	unsigned long		 dcon;		/* default value of DCON */
+
+	/* driver handles */
+	sw_dma_cbfn_t	 callback_fn;	/* buffer done callback */
+	sw_dma_cbfn_t	 callback_hd;	/* buffer half done callback */
+	sw_dma_opfn_t	 op_fn;		/* channel op callback */
+
+	/* stats gathering */
+	struct sw_dma_stats *stats;
+	struct sw_dma_stats  stats_store;
+
+	/* buffer list and information */
+	struct sw_dma_buf	*curr;		/* current dma buffer */
+	struct sw_dma_buf	*next;		/* next buffer to load */
+	struct sw_dma_buf	*end;		/* end of queue */
+
+	/* system device */
+	struct device	dev;
+	void * dev_id;
+};
+
+/*the channel number of above 8 is DDMA channel.*/
+#define IS_DADECATE_DMA(ch) (ch->number >= 8)
+
+struct dma_hw_conf{
+	unsigned char		drqsrc_type;
+	unsigned char		drqdst_type;
+
+	unsigned char		xfer_type;
+	unsigned char		address_type;
+	unsigned char           dir;
+	unsigned char		hf_irq;
+	unsigned char		reload;
+
+	unsigned long		from;
+	unsigned long		to;
+	unsigned long		cmbk;
+};
+
+extern inline void DMA_COPY_HW_CONF(struct dma_hw_conf *to, struct dma_hw_conf *from);
+
+/* struct sw_dma_map
+ *
+ * this holds the mapping information for the channel selected
+ * to be connected to the specified device
+*/
+struct sw_dma_map {
+	const char		*name;
+	struct dma_hw_conf  user_hw_conf;
+	const struct dma_hw_conf*  default_hw_conf;
+	struct dma_hw_conf* conf_ptr;
+	unsigned long channels[SW_DMA_CHANNELS];
+};
+
+struct sw_dma_selection {
+	struct sw_dma_map	*map;
+	unsigned long		 map_size;
+	unsigned long		 dcon_mask;
+};
+
+/* struct sw_dma_order_ch
+ *
+ * channel map for one of the `enum dma_ch` dma channels. the list
+ * entry contains a set of low-level channel numbers, orred with
+ * DMA_CH_VALID, which are checked in the order in the array.
+*/
+
+struct sw_dma_order_ch {
+	unsigned int	list[SW_DMA_CHANNELS];	/* list of channels */
+	unsigned int	flags;				/* flags */
+};
+
+/* struct s3c24xx_dma_order
+ *
+ * information provided by either the core or the board to give the
+ * dma system a hint on how to allocate channels
+*/
+
+struct sw_dma_order {
+	struct sw_dma_order_ch	channels[DMACH_MAX];
+};
+
+/* the currently allocated channel information */
+extern struct sw_dma_chan sw_chans[];
+
+/* note, we don't really use dma_device_t at the moment */
+typedef unsigned long dma_device_t;
+
+/* functions --------------------------------------------------------------- */
+
+/* sw_dma_request
+ *
+ * request a dma channel exclusivley
+*/
+
+extern int sw_dma_request(unsigned int channel,
+			       struct sw_dma_client *, void *dev);
+
+
+/* sw_dma_ctrl
+ *
+ * change the state of the dma channel
+*/
+
+extern int sw_dma_ctrl(unsigned int channel, enum sw_chan_op op);
+
+/* sw_dma_setflags
+ *
+ * set the channel's flags to a given state
+*/
+
+extern int sw_dma_setflags(unsigned int channel,
+				unsigned int flags);
+
+/* sw_dma_free
+ *
+ * free the dma channel (will also abort any outstanding operations)
+*/
+
+extern int sw_dma_free(unsigned int channel, struct sw_dma_client *);
+
+/* sw_dma_enqueue
+ *
+ * place the given buffer onto the queue of operations for the channel.
+ * The buffer must be allocated from dma coherent memory, or the Dcache/WB
+ * drained before the buffer is given to the DMA system.
+*/
+
+extern int sw_dma_enqueue(unsigned int channel, void *id,
+			       dma_addr_t data, int size);
+
+/* sw_dma_config
+ *
+ * configure the dma channel
+*/
+extern void poll_dma_pending(int chan_nr);
+
+extern int sw_dma_config(unsigned int channel, struct dma_hw_conf* user_conf);
+
+extern int sw15_dma_init(void);
+
+extern int sw_dma_order_set(struct sw_dma_order *ord);
+
+extern int sw_dma_init_map(struct sw_dma_selection *sel);
+
+/* sw_dma_getposition
+ *
+ * get the position that the dma transfer is currently at
+*/
+
+extern int sw_dma_getposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+extern int sw_dma_set_opfn(unsigned int, sw_dma_opfn_t rtn);
+extern int sw_dma_set_buffdone_fn(unsigned int, sw_dma_cbfn_t rtn);
+extern int sw_dma_set_halfdone_fn(unsigned int, sw_dma_cbfn_t rtn);
+extern int sw_dma_getcurposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+#endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-sun5i/include/mach/dram.h b/arch/arm/mach-sun5i/include/mach/dram.h
new file mode 100644
index 0000000..53c9eff
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/dram.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/dram.h
+ */
+
+#include <plat/dram.h>
diff --git a/arch/arm/mach-sun5i/include/mach/entry-macro.S b/arch/arm/mach-sun5i/include/mach/entry-macro.S
new file mode 100644
index 0000000..7857f3d
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/entry-macro.S
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/entry-macro.S
+ */
+
+#include <plat/entry-macro.S>
diff --git a/arch/arm/mach-sun5i/include/mach/gpio.h b/arch/arm/mach-sun5i/include/mach/gpio.h
new file mode 100644
index 0000000..7cd54e8
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/gpio.h
@@ -0,0 +1,4 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/gpio.h
+ */
+#include <plat/gpio.h>
diff --git a/arch/arm/mach-sun5i/include/mach/hardware.h b/arch/arm/mach-sun5i/include/mach/hardware.h
new file mode 100644
index 0000000..de2052e
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/hardware.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/hardware.h
+ */
+
+#include <plat/hardware.h>
diff --git a/arch/arm/mach-sun5i/include/mach/io.h b/arch/arm/mach-sun5i/include/mach/io.h
new file mode 100644
index 0000000..1087aa4
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/io.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/io.h
+ */
+
+#include <plat/io.h>
diff --git a/arch/arm/mach-sun5i/include/mach/irqs.h b/arch/arm/mach-sun5i/include/mach/irqs.h
new file mode 100644
index 0000000..73c556f
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/irqs.h
@@ -0,0 +1,9 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/irqs.h
+ */
+#ifndef __MACH_IRQS_H__
+#define __MACH_IRQS_H__
+
+#include <plat/irqs.h>
+
+#endif
diff --git a/arch/arm/mach-sun5i/include/mach/memory.h b/arch/arm/mach-sun5i/include/mach/memory.h
new file mode 100644
index 0000000..476669c
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/memory.h
@@ -0,0 +1,4 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/memory.h
+ */
+#include <plat/memory.h>
diff --git a/arch/arm/mach-sun5i/include/mach/platform.h b/arch/arm/mach-sun5i/include/mach/platform.h
new file mode 100644
index 0000000..7310a5c
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/platform.h
@@ -0,0 +1,4 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/platform.h
+ */
+#include <plat/platform.h>
diff --git a/arch/arm/mach-sun5i/include/mach/spi.h b/arch/arm/mach-sun5i/include/mach/spi.h
new file mode 100644
index 0000000..f5d89b2
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/spi.h
@@ -0,0 +1,259 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/spi.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Pan Nan <pannan@allwinnertech.com>
+ * Victor Wei <weiziheng@allwinnertech.com>
+ *
+ * SUN5I SPI reg definition
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SUN5I_SPI_H_
+#define _SUN5I_SPI_H_
+
+
+#define SPI_MODULE_NUM      (3)
+#define SPI_FIFO_DEPTH      (64)
+
+#define SPI0_BASE_ADDR      (0x01C05000)
+#define SPI1_BASE_ADDR      (0x01C06000)
+#define SPI2_BASE_ADDR      (0x01C17000)
+
+
+/* SPI Registers offsets from peripheral base address */
+#define SPI_RXDATA_REG		    (0x00) /* rx data register */
+#define SPI_TXDATA_REG		    (0x04) /* tx data register */
+#define SPI_CTL_REG		        (0x08) /* control register */
+#define SPI_INT_CTL_REG         (0x0C) /* interrupt control register */
+#define SPI_STATUS_REG	        (0x10) /* status register */
+#define SPI_DMA_CTL_REG         (0x14) /* dma control register */
+#define SPI_WAIT_REG    	    (0x18) /* wait clock counter register */
+#define SPI_CLK_RATE_REG		(0x1C) /* clock rate control register */
+#define SPI_BC_REG              (0x20) /* burst counter register   */
+#define SPI_TC_REG              (0x24) /* transmit counter register */
+#define SPI_FIFO_STA_REG        (0x28) /* fifo status register */
+
+
+
+/* SPI Rx data register,default value: 0x0000_0000 */
+/* readonly
+8-bits: accessed in   byte    rxFIFO decreased by 1.
+        accessed in half-word rxFIFO decreased by 2.
+        accessed in   word    rxFIFO decreased by 4.
+*/
+/* SPI Tx data register,default value: 0x0000_0000 */
+/* write only
+   same as Rx data register
+*/
+
+
+/* SPI Control Register Bit Fields & Masks,defualt value:0x0002_001C */
+#define SPI_CTL_EN          (0x1 << 0) /* SPI module enable control 1:enable;0:disable;default:0 */
+#define SPI_CTL_FUNC_MODE   (0x1 << 1) /* SPI function mode select 1:master;0:slave;default:0 */
+/* default work mode3: pol = 1,pha = 1; */
+#define SPI_CTL_PHA         (0x1 << 2) /* SPI Clock polarity control,  0: phase0,1: phase1;default:1  */
+#define SPI_CTL_POL         (0x1 << 3) /* SPI Clock/Data phase control,0:low level idle,1:high level idle;default:1 */
+#define SPI_POL_PHA_BIT_POS     (2)
+
+#define SPI_CTL_SSPOL        (0x1 << 4) /* SPI Chip select signal polarity control,default: 1,low effective like this:~~|_____~~ */
+//#define SPI_CTL_TBW          (0x1 << 5) /* SPI transfer bit,0: 8bit, 1:16bit,default:0,8bit */    //modified by yemao, for aw1623, define as below, 2011-5-27 14:02:58
+#define SPI_CTL_DMAMOD       (0x1 << 5) /* SPI dma mode select: 0-NDMA,1-DDMA */
+#define SPI_CTL_LMTF         (0x1 << 6) /* LSB/MSB transfer first select 0:MSB,1:LSB,default 0:MSB first */
+#define SPI_CTL_SSCTL        (0x1 << 7) /* SPI chip select control,default 0:SPI_SSx remains asserted between SPI bursts,1:negate SPI_SSx between SPI bursts */
+#define SPI_CTL_RST_TXFIFO   (0x1 << 8) /* SPI reset rxFIFO write 1 automatic clear 0*/
+#define SPI_CTL_RST_RXFIFO   (0x1 << 9) /* SPI reset txFIFO write 1 automatic clear 0*/
+#define SPI_CTL_XCH          (0x1 << 10) /* Exchange burst default 0:idle,1:start exchange;when BC is zero,this bit cleared by SPI controller*/
+//#define SPI_CTL_SMC          (0x1 << 11) /* Start Mode control,default 0: immediately start a SPI burst;1:XCH bit controls */
+#define SPI_CTL_RAPIDS       (0x1 << 11) /* Rapids transfer mode */ //modified by yemao, for aw1623, define as below, 2011-5-27 14:02:58
+
+#define SPI_CTL_SS_MASK      (0x3 << 12) /* SPI chip select:00-SPI_SS0;01-SPI_SS1;10-SPI_SS2;11-SPI_SS3*/
+#define SPI_SS_BIT_POS          (12)
+
+#define SPI_CTL_DDB          (0x1 << 14) /* Dummy burst Type,default 0: dummy spi burst is zero;1:dummy spi burst is one */
+#define SPI_CTL_DHB          (0x1 << 15) /* Discard Hash Burst,default 0:receiving all spi burst in BC period 1:discard unused,fectch WTC bursts */
+
+#define SPI_CTL_SS_CTRL      (0x1 << 16) /* SS output mode select default is 0:automatic output SS;1:manual output SS */
+#define SPI_CTL_SS_LEVEL     (0x1 << 17) /* defautl is 1:set SS to high;0:set SS to low */
+
+#define SPI_CTL_T_PAUSE_EN   (0x1 << 18) /* Transmit Pause Enable;Master mode: 1-stop when RXFIFO full;0-ignore rxFIFO */
+#define SPI_CTL_MASTER_SDC   (0x1 << 19) /* master sample data control, 1: delay--high speed operation;0:no delay. */
+/* aw1620 control register 31-20bit reserved bit */
+
+
+/* SPI Interrupt Register Bit Fields & Masks,default value:0x0000_0000 */
+#define SPI_INTEN_RR	    (0x1 << 0)  /* rxFIFO Ready Interrupt Enable,---used for immediately received,0:disable;1:enable */
+#define SPI_INTEN_RH	    (0x1 << 1)  /* rxFIFO Half Full Interrupt Enable ---used for IRQ received */
+#define SPI_INTEN_RF	    (0x1 << 2)  /* rxFIFO Full Interrupt Enable ---seldom used */
+#define SPI_INTEN_QTR_RF    (0x1 << 3) /* rxFIFO 1/4 Full Interrupt Enable */
+#define SPI_INTEN_3QTR_RF   (0x1 << 4) /* rxFIFO 3/4 Full Interrupt Enable */
+#define SPI_INTEN_RO	    (0x1 << 5)  /* rxFIFO Overflow Interrupt Enable ---used for error detect */
+#define SPI_INTEN_RU	    (0x1 << 6)  /* rxFIFO Underrun Interrupt Enable ---used for error detect */
+/* 7 bit reserved */
+
+#define SPI_INTEN_TE	    (0x1 << 8)  /* txFIFO Empty Interrupt Enable ---seldom used */
+#define SPI_INTEN_TH	    (0x1 << 9)  /* txFIFO Half Empty Interrupt Enable ---used  for IRQ tx */
+#define SPI_INTEN_TF	    (0x1 << 10) /* txFIFO Full Interrupt Enable ---seldom used */
+#define SPI_INTEN_QTR_TE    (0x1 << 11) /* txFIFO FIFO 1/4 Empty Interrupt Enable;0-disable;1-enable */
+#define SPI_INTEN_3QTR_TE   (0x1 << 12) /* txFIFO FIFO 3/4 Empty Interrupt Enable;0-disable;1-enable */
+#define SPI_INTEN_TO	    (0x1 << 13) /* txFIFO Overflow Interrupt Enable ---used for error detect */
+#define SPI_INTEN_TU	    (0x1 << 14) /* txFIFO Underrun Interrupt Enable ---not happened */
+/* 15 bit reserved */
+
+#define SPI_INTEN_TC    (0x1 << 16) /* Transfer Completed Interrupt Enable  ---used */
+#define SPI_INTEN_SSI   (0x1 << 17) /* SSI interrupt Enable,chip select from valid state to invalid state,for slave used only */
+/* 31:18 bit reserved */
+#define SPI_INTEN_ERR   (SPI_INTEN_TO|SPI_INTEN_RU|SPI_INTEN_RO) //NO txFIFO underrun
+#define SPI_INTEN_MASK  (0x7f|(0x7f<<8)|(0x3<<16))
+
+
+/* SPI Status Register Bit Fields & Masks,default value:0x0000_1B00 all bits are written 1 to clear 0 */
+#define SPI_STAT_RR        (0x1 << 0) /* rxFIFO ready, 0:no valid data;1:more than 1 word in rxfifo */
+#define SPI_STAT_RHF       (0x1 << 1) /* rxFIFO half full,0:less than 4 words;1:four or more than 4 words in rxfifo */
+#define SPI_STAT_RF        (0x1 << 2) /* rxFIFO full,0:not full;1:full */
+#define SPI_STAT_QTR_RF    (0x1 << 3) /* rxFIFO 1/4 Full, 0:not 1/4 full;1:1/4 full */
+#define SPI_STAT_3QTR_RF   (0x1 << 4) /* rxFIFO 3/4 Full, 0:not 1/4 full;1:1/4 full */
+#define SPI_STAT_RO        (0x1 << 5) /* rxFIFO overflow, 0: rxfifo is available;1:rxfifo has overflowed! */
+#define SPI_STAT_RU        (0x1 << 6) /* rxFIFO underrun,fectch data with no data available in FIFO */
+/* 7bit reserved */
+
+#define SPI_STAT_TE        (0x1 << 8)  /* txFIFO empty,0:txfifo contains one or more words;1:txfifo is empty.default value:1 */
+#define SPI_STAT_THE       (0x1 << 9)  /* txFIFO half empty,0:more than half words;1: half or fewer words.defualt value: 1 */
+#define SPI_STAT_TF        (0x1 << 10) /* txFIFO Full */
+#define SPI_STAT_QTR_TE    (0x1 << 11) /* txFIFO 1/4 empty.default is 1:more than 1/4 empty */
+#define SPI_STAT_3QTR_TE   (0x1 << 12) /* txFIFO 3/4 empty.default is 1:more than 3/4 empty */
+#define SPI_STAT_TO        (0x1 << 13) /* txFIFO overflow 0:not overflow;1:overflow */
+#define SPI_STAT_TU        (0x1 << 14) /* txFIFO underrun 0:not underrun;1:undrrun */
+/* 15bit reserved */
+
+#define SPI_STAT_TC        (0x1 << 16) /* Transfer Complete, 0:BUSY;1:transfer completed */
+#define SPI_STAT_SSI       (0x1 << 17) /* SS Invalid Interrupt ,for slave used only */
+/* 31-18bits reserved */
+#define SPI_STAT_MASK (0x7f|(0x7f<<8)|(0x3<<16))
+
+#define SPI_STAT_ERR       (SPI_STAT_TO|SPI_STAT_RU|SPI_STAT_RO) //Slave mode,no SPI_STAT_TU
+
+
+/* SPI DMA Control Register Bit Fields & Masks defuatl:0x0000_0000 */
+#define SPI_DRQEN_RR	  (0x1 << 0)	/* rxFIFO Ready DMA Request Enable,when one or more than one words in RXFIFO */
+#define SPI_DRQEN_RHF	  (0x1 << 1)  /* rXFIFO Half Full DMA Request Enable,when 4 or more than 4 words in RXFIFO */
+#define SPI_DRQEN_RF	  (0x1 << 2)  /* rxFIFO Full DMA Request Enable */
+#define SPI_DRQEN_QTR_RF  (0x1 << 3)  /* rxFIFO 1/4 Full DMA Request Enable */
+#define SPI_DRQEN_3QTR_RF (0x1 << 4)  /* rxFIFO 3/4 Full DMA Request Enable */
+/* 7:5 bit reserved */
+
+#define SPI_DRQEN_TE	  (0x1 << 8)  /* txFIFO Empty DMA Request Enable,when no words in TXFIFO */
+#define SPI_DRQEN_THE	  (0x1 << 9)  /* txFIFO Half Empty DMA Request Enable,when 4 or less than 4 words in TXFIFO */
+#define SPI_DRQEN_TNF	  (0x1 << 10) /* txFIFO Not Full DMA Request Enable,asserted when more than one free room for burst */
+#define SPI_DRQEN_QTR_TE  (0x1 << 11) /* txFIFO 1/4 Empty DMA Request Enable */
+#define SPI_DRQEN_3QTR_TE (0x1 << 12) /* txFIFO 3/4 Empty DMA Request Enable */
+/* 31:13 bits reserved */
+#define SPI_DRQEN_MASK (0x1f|(0x1f<<8))
+
+
+/* SPI Wait Clock Register Bit Fields & Masks,default value:0x0000_0000 */
+#define SPI_WAIT_CLK_MASK   (0xFFFF << 0)	/* used only in master mode: Wait Between Transactions */
+/* 31:16bit reserved */
+
+
+/* SPI Wait Clock Register Bit Fields & Masks,default:0x0000_0002 */
+#define SPI_CLKCTL_CDR2     (0xFF << 0)  /* Clock Divide Rate 2,master mode only : SPI_CLK = AHB_CLK/(2*(n+1)) */
+#define SPI_CLKCTL_CDR1     (0xF  << 8)  /* Clock Divide Rate 1,master mode only : SPI_CLK = AHB_CLK/2^(n+1) */
+#define SPI_CLKCTL_DRS      (0x1  << 12) /* Divide rate select,default,0:rate 1;1:rate 2 */
+#define SPI_CLK_SCOPE     (SPI_CLKCTL_CDR2+1)
+/* 31:13bits reserved */
+
+
+/* SPI Burst Counter Register Bit Fields & Masks,default value: 0x0000_0000 */
+/* master mode: when SMC = 1,BC specifies total burst number, Max length is 16Mbytes */
+#define SPI_BC_BC_MASK    (0xFFFFFF << 0 ) /* Total Burst Counter,tx length + rx length ,SMC=1 */
+#define SPI_TRANSFER_SIZE  (SPI_BC_BC_MASK)
+
+
+/* SPI Transmit Counter reigster default:0x0000_0000,Max length is 16Mbytes */
+#define SPI_TC_WTC_MASK   (0xFFFFFF << 0) /* Write Transmit Counter,tx length, NOT rx length!!! */
+
+
+/* SPI FIFO status register default is 0x0000_0000 */
+#define SPI_FIFO_RXCNT     (0x7F << 0) /* rxFIFO counter,how many bytes in the rxFIFO */
+#define SPI_RXCNT_BIT_POS     (0)
+/* 15:7bits reserved */
+
+#define SPI_FIFO_TXCNT     (0x7F << 16) /* txFIFO counter,how many bytes in the txFIFO */
+#define SPI_TXCNT_BIT_POS     (16)
+
+///////////////////////////////////////////////////////////////////////////////////
+
+
+
+/* configbit */
+/*      **************linuxspi***************
+*       4
+*         0: 0POL=0,PAL=0;
+*         1: 1POL=0,PAL=1;
+*         2: 2POL=1,PAL=0;
+*         3: 3POL=1,PAL=1;
+*/
+#define SPI_PHA_ACTIVE_		    (0x01)
+#define SPI_POL_ACTIVE_		    (0x02)
+
+#define SPI_MODE_0_ACTIVE_		(0|0)
+#define SPI_MODE_1_ACTIVE_		(0|SPI_PHA_ACTIVE_)
+#define SPI_MODE_2_ACTIVE_		(SPI_POL_ACTIVE_|0)
+#define SPI_MODE_3_ACTIVE_		(SPI_POL_ACTIVE_|SPI_PHA_ACTIVE_) /*3*/
+/*  */
+#define SPI_CS_HIGH_ACTIVE_		    (0x04)  /**/
+#define SPI_LSB_FIRST_ACTIVE_		(0x08)  /*MSB*/
+
+#define SPI_DUMMY_ONE_ACTIVE_        (0x10)  /*spi0txFIFO */
+#define SPI_RECEIVE_ALL_ACTIVE_      (0x20)  /*burstrxFIFO */
+
+
+/* can modify to adapt the application */
+#define BULK_DATA_BOUNDARY    64
+
+/* spi controller just suppport 20Mhz */
+#define SPI_MAX_FREQUENCY 80000000
+
+/* distinguish sdram and sram address */
+#define SPI_RAM_BOUNDAY   (0x80000000)
+
+
+
+/* function mode select */
+#define SPI_MASTER_MODE     (0x1)
+#define SPI_SLAVE_MODE      (0x0)
+///////////////////////////////////////////////////////////////////////////////////
+
+#define AW_SPI_OK   0
+#define AW_SPI_FAIL 1
+
+struct sunxi_spi_platform_data {
+    int cs_bitmap; // cs0-0x1,cs1-0x2,cs0&cs1-0x3
+    int num_cs;   // number of cs
+    const char *clk_name; // ahb clk name
+};
+
+/* spi device controller state, alloc */
+struct sunxi_spi_config {
+	int bits_per_word; // 8bit
+	int max_speed_hz;  // 20MHz
+	int mode; // pha,pol,LSB,etc..
+};
+
+#endif
\ No newline at end of file
diff --git a/arch/arm/mach-sun5i/include/mach/system.h b/arch/arm/mach-sun5i/include/mach/system.h
new file mode 100644
index 0000000..0167749
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/system.h
@@ -0,0 +1,4 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/system.h
+ */
+#include <plat/system.h>
diff --git a/arch/arm/mach-sun5i/include/mach/timex.h b/arch/arm/mach-sun5i/include/mach/timex.h
new file mode 100644
index 0000000..76dc125
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/timex.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/timex.h
+ */
+
+#include <plat/timex.h>
diff --git a/arch/arm/mach-sun5i/include/mach/uncompress.h b/arch/arm/mach-sun5i/include/mach/uncompress.h
new file mode 100644
index 0000000..6a06fdd
--- /dev/null
+++ b/arch/arm/mach-sun5i/include/mach/uncompress.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun5i/include/mach/uncompress.h
+ */
+
+#include <plat/uncompress.h>
diff --git a/arch/arm/mach-sun7i/Makefile b/arch/arm/mach-sun7i/Makefile
new file mode 100755
index 0000000..08abf40
--- /dev/null
+++ b/arch/arm/mach-sun7i/Makefile
@@ -0,0 +1,22 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y = clock/
+obj-y += dma/
+obj-$(CONFIG_CPU_FREQ)			+= cpu-freq/
+obj-$(CONFIG_PM) += pm/
+obj-$(CONFIG_AW_TIME_DELAY)	+= delay.o
+ifeq ($(CONFIG_SMP),y)
+obj-y += platsmp.o headsmp.o
+obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
+
+
+ifeq ($(CONFIG_LOCAL_TIMERS),y)
+obj-y += localtimer.o
+endif
+
+
+endif
+
+
diff --git a/arch/arm/mach-sun7i/Makefile.boot b/arch/arm/mach-sun7i/Makefile.boot
new file mode 100644
index 0000000..449994d
--- /dev/null
+++ b/arch/arm/mach-sun7i/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	+= 0x40008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
diff --git a/arch/arm/mach-sun7i/clock/Makefile b/arch/arm/mach-sun7i/clock/Makefile
new file mode 100644
index 0000000..0aaffeb
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y=clock.o ccm.o mod_clk.o sys_clk.o pll_cfg.o ccu_dbg.o ccu_sysfs.o
+
+
diff --git a/arch/arm/mach-sun7i/clock/ccm.c b/arch/arm/mach-sun7i/clock/ccm.c
new file mode 100644
index 0000000..7a62d3a
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/ccm.c
@@ -0,0 +1,278 @@
+/*
+ * arch/arm/mach-sun7i/clock/ccm.c
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include "ccm_i.h"
+
+#define make_aw_clk_inf(clk_id, clk_name)   {.id = clk_id, .name = clk_name}
+__ccmu_reg_list_t *aw_ccu_reg;
+
+__aw_ccu_clk_t aw_ccu_clk_tbl[] =
+{
+    make_aw_clk_inf(AW_SYS_CLK_NONE,        "sys_none"          ),
+    make_aw_clk_inf(AW_SYS_CLK_LOSC,        CLK_SYS_LOSC        ),
+    make_aw_clk_inf(AW_SYS_CLK_HOSC,        CLK_SYS_HOSC        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL1,        CLK_SYS_PLL1        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL2,        CLK_SYS_PLL2        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL2X8,      CLK_SYS_PLL2X8      ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL3,        CLK_SYS_PLL3        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL3X2,      CLK_SYS_PLL3X2      ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL4,        CLK_SYS_PLL4        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL5,        CLK_SYS_PLL5        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL5M,       CLK_SYS_PLL5M       ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL5P,       CLK_SYS_PLL5P       ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL6,        CLK_SYS_PLL6        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL6M,       CLK_SYS_PLL6M       ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL62,       CLK_SYS_PLL62       ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL6X2,      CLK_SYS_PLL6X2      ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL7,        CLK_SYS_PLL7        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL7X2,      CLK_SYS_PLL7X2      ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL8,        CLK_SYS_PLL8        ),
+    make_aw_clk_inf(AW_SYS_CLK_CPU,         CLK_SYS_CPU         ),
+    make_aw_clk_inf(AW_SYS_CLK_AXI,         CLK_SYS_AXI         ),
+    make_aw_clk_inf(AW_SYS_CLK_ATB,         CLK_SYS_ATB         ),
+    make_aw_clk_inf(AW_SYS_CLK_AHB,         CLK_SYS_AHB         ),
+    make_aw_clk_inf(AW_SYS_CLK_APB0,        CLK_SYS_APB0        ),
+    make_aw_clk_inf(AW_SYS_CLK_APB1,        CLK_SYS_APB1        ),
+    make_aw_clk_inf(AW_CCU_CLK_NULL,        "null"              ),
+    make_aw_clk_inf(AW_MOD_CLK_NFC,         CLK_MOD_NFC         ),
+    make_aw_clk_inf(AW_MOD_CLK_MSC,         CLK_MOD_MSC         ),
+    make_aw_clk_inf(AW_MOD_CLK_SDC0,        CLK_MOD_SDC0        ),
+    make_aw_clk_inf(AW_MOD_CLK_SDC1,        CLK_MOD_SDC1        ),
+    make_aw_clk_inf(AW_MOD_CLK_SDC2,        CLK_MOD_SDC2        ),
+    make_aw_clk_inf(AW_MOD_CLK_SDC3,        CLK_MOD_SDC3        ),
+    make_aw_clk_inf(AW_MOD_CLK_TS,          CLK_MOD_TS          ),
+    make_aw_clk_inf(AW_MOD_CLK_SS,          CLK_MOD_SS          ),
+    make_aw_clk_inf(AW_MOD_CLK_SPI0,        CLK_MOD_SPI0        ),
+    make_aw_clk_inf(AW_MOD_CLK_SPI1,        CLK_MOD_SPI1        ),
+    make_aw_clk_inf(AW_MOD_CLK_SPI2,        CLK_MOD_SPI2        ),
+    make_aw_clk_inf(AW_MOD_CLK_PATA,        CLK_MOD_PATA        ),
+    make_aw_clk_inf(AW_MOD_CLK_IR0,         CLK_MOD_IR0         ),
+    make_aw_clk_inf(AW_MOD_CLK_IR1,         CLK_MOD_IR1         ),
+    make_aw_clk_inf(AW_MOD_CLK_I2S0,        CLK_MOD_I2S0        ),
+    make_aw_clk_inf(AW_MOD_CLK_I2S1,        CLK_MOD_I2S1        ),
+    make_aw_clk_inf(AW_MOD_CLK_I2S2,        CLK_MOD_I2S2        ),
+    make_aw_clk_inf(AW_MOD_CLK_AC97,        CLK_MOD_AC97        ),
+    make_aw_clk_inf(AW_MOD_CLK_SPDIF,       CLK_MOD_SPDIF       ),
+    make_aw_clk_inf(AW_MOD_CLK_KEYPAD,      CLK_MOD_KEYPAD      ),
+    make_aw_clk_inf(AW_MOD_CLK_SATA,        CLK_MOD_SATA        ),
+    make_aw_clk_inf(AW_MOD_CLK_USBPHY,      CLK_MOD_USBPHY      ),
+    make_aw_clk_inf(AW_MOD_CLK_USBPHY0,     CLK_MOD_USBPHY0     ),
+    make_aw_clk_inf(AW_MOD_CLK_USBPHY1,     CLK_MOD_USBPHY1     ),
+    make_aw_clk_inf(AW_MOD_CLK_USBPHY2,     CLK_MOD_USBPHY2     ),
+    make_aw_clk_inf(AW_MOD_CLK_USBOHCI0,    CLK_MOD_USBOHCI0    ),
+    make_aw_clk_inf(AW_MOD_CLK_USBOHCI1,    CLK_MOD_USBOHCI1    ),
+    make_aw_clk_inf(AW_MOD_CLK_GPS,         CLK_MOD_GPS         ),
+    make_aw_clk_inf(AW_MOD_CLK_SPI3,        CLK_MOD_SPI3        ),
+    make_aw_clk_inf(AW_MOD_CLK_DEBE0,       CLK_MOD_DEBE0       ),
+    make_aw_clk_inf(AW_MOD_CLK_DEBE1,       CLK_MOD_DEBE1       ),
+    make_aw_clk_inf(AW_MOD_CLK_DEFE0,       CLK_MOD_DEFE0       ),
+    make_aw_clk_inf(AW_MOD_CLK_DEFE1,       CLK_MOD_DEFE1       ),
+    make_aw_clk_inf(AW_MOD_CLK_DEMIX,       CLK_MOD_DEMIX       ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD0CH0,     CLK_MOD_LCD0CH0     ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD1CH0,     CLK_MOD_LCD1CH0     ),
+    make_aw_clk_inf(AW_MOD_CLK_CSIISP,      CLK_MOD_CSIISP      ),
+    make_aw_clk_inf(AW_MOD_CLK_TVDMOD1,     CLK_MOD_TVDMOD1     ),
+    make_aw_clk_inf(AW_MOD_CLK_TVDMOD2,     CLK_MOD_TVDMOD2     ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD0CH1_S1,  CLK_MOD_LCD0CH1_S1  ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD0CH1_S2,  CLK_MOD_LCD0CH1_S2  ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD1CH1_S1,  CLK_MOD_LCD1CH1_S1  ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD1CH1_S2,  CLK_MOD_LCD1CH1_S2  ),
+    make_aw_clk_inf(AW_MOD_CLK_CSI0,        CLK_MOD_CSI0        ),
+    make_aw_clk_inf(AW_MOD_CLK_CSI1,        CLK_MOD_CSI1        ),
+    make_aw_clk_inf(AW_MOD_CLK_VE,          CLK_MOD_VE          ),
+    make_aw_clk_inf(AW_MOD_CLK_ADDA,        CLK_MOD_ADDA        ),
+    make_aw_clk_inf(AW_MOD_CLK_AVS,         CLK_MOD_AVS         ),
+    make_aw_clk_inf(AW_MOD_CLK_ACE,         CLK_MOD_ACE         ),
+    make_aw_clk_inf(AW_MOD_CLK_LVDS,        CLK_MOD_LVDS        ),
+    make_aw_clk_inf(AW_MOD_CLK_HDMI,        CLK_MOD_HDMI        ),
+    make_aw_clk_inf(AW_MOD_CLK_MALI,        CLK_MOD_MALI        ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI0,        CLK_MOD_TWI0        ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI1,        CLK_MOD_TWI1        ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI2,        CLK_MOD_TWI2        ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI3,        CLK_MOD_TWI3        ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI4,        CLK_MOD_TWI4        ),
+    make_aw_clk_inf(AW_MOD_CLK_CAN,         CLK_MOD_CAN         ),
+    make_aw_clk_inf(AW_MOD_CLK_SCR,         CLK_MOD_SCR         ),
+    make_aw_clk_inf(AW_MOD_CLK_PS20,        CLK_MOD_PS20        ),
+    make_aw_clk_inf(AW_MOD_CLK_PS21,        CLK_MOD_PS21        ),
+    make_aw_clk_inf(AW_MOD_CLK_UART0,       CLK_MOD_UART0       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART1,       CLK_MOD_UART1       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART2,       CLK_MOD_UART2       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART3,       CLK_MOD_UART3       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART4,       CLK_MOD_UART4       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART5,       CLK_MOD_UART5       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART6,       CLK_MOD_UART6       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART7,       CLK_MOD_UART7       ),
+    make_aw_clk_inf(AW_MOD_CLK_SMPTWD,      CLK_MOD_SMPTWD      ),
+    make_aw_clk_inf(AW_MOD_CLK_MBUS,        CLK_MOD_MBUS        ),
+    make_aw_clk_inf(AW_MOD_CLK_OUTA,        CLK_MOD_OUTA        ),
+    make_aw_clk_inf(AW_MOD_CLK_OUTB,        CLK_MOD_OUTB        ),
+    make_aw_clk_inf(AW_AHB_CLK_USB0,        CLK_AHB_USB0        ),
+    make_aw_clk_inf(AW_AHB_CLK_EHCI0,       CLK_AHB_EHCI0       ),
+    make_aw_clk_inf(AW_AHB_CLK_OHCI0,       CLK_AHB_OHCI0       ),
+    make_aw_clk_inf(AW_AHB_CLK_SS,          CLK_AHB_SS          ),
+    make_aw_clk_inf(AW_AHB_CLK_DMA,         CLK_AHB_DMA         ),
+    make_aw_clk_inf(AW_AHB_CLK_BIST,        CLK_AHB_BIST        ),
+    make_aw_clk_inf(AW_AHB_CLK_SDMMC0,      CLK_AHB_SDMMC0      ),
+    make_aw_clk_inf(AW_AHB_CLK_SDMMC1,      CLK_AHB_SDMMC1      ),
+    make_aw_clk_inf(AW_AHB_CLK_SDMMC2,      CLK_AHB_SDMMC2      ),
+    make_aw_clk_inf(AW_AHB_CLK_SDMMC3,      CLK_AHB_SDMMC3      ),
+    make_aw_clk_inf(AW_AHB_CLK_MS,          CLK_AHB_MS          ),
+    make_aw_clk_inf(AW_AHB_CLK_NAND,        CLK_AHB_NAND        ),
+    make_aw_clk_inf(AW_AHB_CLK_SDRAM,       CLK_AHB_SDRAM       ),
+    make_aw_clk_inf(AW_AHB_CLK_ACE,         CLK_AHB_ACE         ),
+    make_aw_clk_inf(AW_AHB_CLK_EMAC,        CLK_AHB_EMAC        ),
+    make_aw_clk_inf(AW_AHB_CLK_TS,          CLK_AHB_TS          ),
+    make_aw_clk_inf(AW_AHB_CLK_SPI0,        CLK_AHB_SPI0        ),
+    make_aw_clk_inf(AW_AHB_CLK_SPI1,        CLK_AHB_SPI1        ),
+    make_aw_clk_inf(AW_AHB_CLK_SPI2,        CLK_AHB_SPI2        ),
+    make_aw_clk_inf(AW_AHB_CLK_SPI3,        CLK_AHB_SPI3        ),
+    make_aw_clk_inf(AW_AHB_CLK_PATA,        CLK_AHB_PATA        ),
+    make_aw_clk_inf(AW_AHB_CLK_SATA,        CLK_AHB_SATA        ),
+    make_aw_clk_inf(AW_AHB_CLK_GPS,         CLK_AHB_GPS         ),
+    make_aw_clk_inf(AW_AHB_CLK_VE,          CLK_AHB_VE          ),
+    make_aw_clk_inf(AW_AHB_CLK_TVD,         CLK_AHB_TVD         ),
+    make_aw_clk_inf(AW_AHB_CLK_TVE0,        CLK_AHB_TVE0        ),
+    make_aw_clk_inf(AW_AHB_CLK_TVE1,        CLK_AHB_TVE1        ),
+    make_aw_clk_inf(AW_AHB_CLK_LCD0,        CLK_AHB_LCD0        ),
+    make_aw_clk_inf(AW_AHB_CLK_LCD1,        CLK_AHB_LCD1        ),
+    make_aw_clk_inf(AW_AHB_CLK_CSI0,        CLK_AHB_CSI0        ),
+    make_aw_clk_inf(AW_AHB_CLK_CSI1,        CLK_AHB_CSI1        ),
+    make_aw_clk_inf(AW_AHB_CLK_HDMI1,       CLK_AHB_HDMI1       ),
+    make_aw_clk_inf(AW_AHB_CLK_HDMI,        CLK_AHB_HDMI        ),
+    make_aw_clk_inf(AW_AHB_CLK_DEBE0,       CLK_AHB_DEBE0       ),
+    make_aw_clk_inf(AW_AHB_CLK_DEBE1,       CLK_AHB_DEBE1       ),
+    make_aw_clk_inf(AW_AHB_CLK_DEFE0,       CLK_AHB_DEFE0       ),
+    make_aw_clk_inf(AW_AHB_CLK_DEFE1,       CLK_AHB_DEFE1       ),
+    make_aw_clk_inf(AW_AHB_CLK_GMAC,        CLK_AHB_GMAC        ),
+    make_aw_clk_inf(AW_AHB_CLK_MP,          CLK_AHB_MP          ),
+    make_aw_clk_inf(AW_AHB_CLK_MALI,        CLK_AHB_MALI        ),
+    make_aw_clk_inf(AW_AHB_CLK_EHCI1,       CLK_AHB_EHCI1       ),
+    make_aw_clk_inf(AW_AHB_CLK_OHCI1,       CLK_AHB_OHCI1       ),
+    make_aw_clk_inf(AW_AHB_CLK_STMR,        CLK_AHB_STMR        ),
+    make_aw_clk_inf(AW_APB_CLK_ADDA,        CLK_APB_ADDA        ),
+    make_aw_clk_inf(AW_APB_CLK_SPDIF,       CLK_APB_SPDIF       ),
+    make_aw_clk_inf(AW_APB_CLK_AC97,        CLK_APB_AC97        ),
+    make_aw_clk_inf(AW_APB_CLK_I2S0,        CLK_APB_I2S0        ),
+    make_aw_clk_inf(AW_APB_CLK_I2S1,        CLK_APB_I2S1        ),
+    make_aw_clk_inf(AW_APB_CLK_I2S2,        CLK_APB_I2S2        ),
+    make_aw_clk_inf(AW_APB_CLK_PIO,         CLK_APB_PIO         ),
+    make_aw_clk_inf(AW_APB_CLK_IR0,         CLK_APB_IR0         ),
+    make_aw_clk_inf(AW_APB_CLK_IR1,         CLK_APB_IR1         ),
+    make_aw_clk_inf(AW_APB_CLK_KEYPAD,      CLK_APB_KEYPAD      ),
+    make_aw_clk_inf(AW_APB_CLK_TWI0,        CLK_APB_TWI0        ),
+    make_aw_clk_inf(AW_APB_CLK_TWI1,        CLK_APB_TWI1        ),
+    make_aw_clk_inf(AW_APB_CLK_TWI2,        CLK_APB_TWI2        ),
+    make_aw_clk_inf(AW_APB_CLK_TWI3,        CLK_APB_TWI3        ),
+    make_aw_clk_inf(AW_APB_CLK_TWI4,        CLK_APB_TWI4        ),
+    make_aw_clk_inf(AW_APB_CLK_CAN,         CLK_APB_CAN         ),
+    make_aw_clk_inf(AW_APB_CLK_SCR,         CLK_APB_SCR         ),
+    make_aw_clk_inf(AW_APB_CLK_PS20,        CLK_APB_PS20        ),
+    make_aw_clk_inf(AW_APB_CLK_PS21,        CLK_APB_PS21        ),
+    make_aw_clk_inf(AW_APB_CLK_UART0,       CLK_APB_UART0       ),
+    make_aw_clk_inf(AW_APB_CLK_UART1,       CLK_APB_UART1       ),
+    make_aw_clk_inf(AW_APB_CLK_UART2,       CLK_APB_UART2       ),
+    make_aw_clk_inf(AW_APB_CLK_UART3,       CLK_APB_UART3       ),
+    make_aw_clk_inf(AW_APB_CLK_UART4,       CLK_APB_UART4       ),
+    make_aw_clk_inf(AW_APB_CLK_UART5,       CLK_APB_UART5       ),
+    make_aw_clk_inf(AW_APB_CLK_UART6,       CLK_APB_UART6       ),
+    make_aw_clk_inf(AW_APB_CLK_UART7,       CLK_APB_UART7       ),
+    make_aw_clk_inf(AW_DRAM_CLK_VE,         CLK_DRAM_VE         ),
+    make_aw_clk_inf(AW_DRAM_CLK_CSI0,       CLK_DRAM_CSI0       ),
+    make_aw_clk_inf(AW_DRAM_CLK_CSI1,       CLK_DRAM_CSI1       ),
+    make_aw_clk_inf(AW_DRAM_CLK_TS,         CLK_DRAM_TS         ),
+    make_aw_clk_inf(AW_DRAM_CLK_TVD,        CLK_DRAM_TVD        ),
+    make_aw_clk_inf(AW_DRAM_CLK_TVE0,       CLK_DRAM_TVE0       ),
+    make_aw_clk_inf(AW_DRAM_CLK_TVE1,       CLK_DRAM_TVE1       ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEFE0,      CLK_DRAM_DEFE0      ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEFE1,      CLK_DRAM_DEFE1      ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEBE0,      CLK_DRAM_DEBE0      ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEBE1,      CLK_DRAM_DEBE1      ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEMP,       CLK_DRAM_DEMP       ),
+    make_aw_clk_inf(AW_DRAM_CLK_ACE,        CLK_DRAM_ACE        ),
+    make_aw_clk_inf(AW_CCU_CLK_CNT,         "count"             ),
+};
+
+/*
+ * aw ccu unit init.
+ *
+ * Return 0.
+ */
+int aw_ccu_init(void)
+{
+    CCU_INF("%s\n", __func__);
+
+    /* initialise the CCU io base */
+    aw_ccu_reg = (__ccmu_reg_list_t *)SW_VA_CCM_IO_BASE;
+
+    return 0;
+}
+
+/*
+ * aw ccu unit exit.
+ *
+ * Return 0.
+ */
+int aw_ccu_exit(void)
+{
+    CCU_INF("%s\n", __func__);
+
+    aw_ccu_reg = NULL;
+
+    return 0;
+}
+
+/*
+ * Get clock information by clock id.
+ *
+ * @id:     clock id
+ * @clk:    clock information
+ *
+ * Returns 0 if success, -1 indicates invalid clock id.
+ */
+int aw_ccu_get_clk(__aw_ccu_clk_id_e id, __ccu_clk_t *clk)
+{
+    __aw_ccu_clk_t *tmp_clk;
+
+    if (clk && (id < AW_CCU_CLK_NULL)) {
+        tmp_clk = &aw_ccu_clk_tbl[id];
+
+        /* set clock operation handle */
+        clk->ops = &sys_clk_ops;
+        clk->aw_clk = tmp_clk;
+
+        /* query system clock information from hardware */
+        tmp_clk->parent = sys_clk_ops.get_parent(id);
+        tmp_clk->onoff  = sys_clk_ops.get_status(id);
+        tmp_clk->rate   = sys_clk_ops.get_rate(id);
+        tmp_clk->hash   = ccu_clk_calc_hash(tmp_clk->name);
+    } else if (clk && (id < AW_CCU_CLK_CNT)) {
+        tmp_clk = &aw_ccu_clk_tbl[id];
+
+        /* set clock operation handle */
+        clk->ops = &mod_clk_ops;
+        clk->aw_clk = tmp_clk;
+
+        /* query system clock information from hardware */
+        tmp_clk->parent = mod_clk_ops.get_parent(id);
+        tmp_clk->onoff  = mod_clk_ops.get_status(id);
+        tmp_clk->reset  = mod_clk_ops.get_reset(id);
+        tmp_clk->rate   = mod_clk_ops.get_rate(id);
+        tmp_clk->hash   = ccu_clk_calc_hash(tmp_clk->name);
+    } else {
+        CCU_ERR("%s: invalid clock id\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
diff --git a/arch/arm/mach-sun7i/clock/ccm_i.h b/arch/arm/mach-sun7i/clock/ccm_i.h
new file mode 100644
index 0000000..3212931
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/ccm_i.h
@@ -0,0 +1,325 @@
+/*
+ * arch/arm/mach-sun7i/clock/ccm_i.h
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __AW_CCMU_I_H__
+#define __AW_CCMU_I_H__
+
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+#include <mach/includes.h>
+
+#define CCU_DEBUG_LEVEL 2
+
+#if (CCU_DEBUG_LEVEL == 1)
+    #define CCU_DBG(format,args...)     do {} while (0)
+    #define CCU_INF(format,args...)     do {} while (0)
+    #define CCU_ERR(format,args...)     printk(KERN_ERR "[ccu-err] "format,##args)
+#elif (CCU_DEBUG_LEVEL == 2)
+    #define CCU_DBG(format,args...)     do {} while (0)
+    #define CCU_INF(format,args...)     printk(KERN_INFO"[ccu-inf] "format,##args)
+    #define CCU_ERR(format,args...)     printk(KERN_ERR "[ccu-err] "format,##args)
+#elif (CCU_DEBUG_LEVEL == 3)
+    #define CCU_DBG(format,args...)     printk(KERN_INFO"[ccu-dbg] "format,##args)
+    #define CCU_INF(format,args...)     printk(KERN_INFO"[ccu-inf] "format,##args)
+    #define CCU_ERR(format,args...)     printk(KERN_ERR "[ccu-err] "format,##args)
+#endif
+
+/* define system clock id */
+typedef enum __AW_CCU_CLK_ID
+{
+    AW_SYS_CLK_NONE,        /* invalid clock id                                 */
+
+    /* system clock defile */
+    AW_SYS_CLK_LOSC,        /* "losc"           ,LOSC, 32768 hz clock           */
+    AW_SYS_CLK_HOSC,        /* "hosc"           ,HOSC, 24Mhz clock              */
+    AW_SYS_CLK_PLL1,        /* "core_pll"       ,PLL1 clock                     */
+    AW_SYS_CLK_PLL2,        /* "audio_pll"      ,PLL2 clock                     */
+    AW_SYS_CLK_PLL2X8,      /* "audio_pllx8"    ,PLL2 8x clock                  */
+    AW_SYS_CLK_PLL3,        /* "video_pll0"     ,PLL3 clock                     */
+    AW_SYS_CLK_PLL3X2,      /* "video_pll0x2"   ,PLL3 2x clock                  */
+    AW_SYS_CLK_PLL4,        /* "ve_pll"         ,PLL4 clock                     */
+    AW_SYS_CLK_PLL5,        /* "sdram_pll"      ,PLL5 clock                     */
+    AW_SYS_CLK_PLL5M,       /* "sdram_pll_m"    ,PLL5 M clock                   */
+    AW_SYS_CLK_PLL5P,       /* "sdram_pll_p"    ,PLL5 P clock                   */
+    AW_SYS_CLK_PLL6,        /* "sata_pll"       ,PLL6 clock                     */
+    AW_SYS_CLK_PLL6M,       /* "sata_pll_m"     ,PLL6 M clock, just for SATA    */
+    AW_SYS_CLK_PLL62,       /* "sata_pll_2"     ,PLL6 2 clock, for module       */
+    AW_SYS_CLK_PLL6X2,      /* "sata_pllx2"     ,PLL6 2x clock, for module      */
+    AW_SYS_CLK_PLL7,        /* "video_pll1"     ,PLL7 clock                     */
+    AW_SYS_CLK_PLL7X2,      /* "video_pll1x2"   ,PLL7 2x clock                  */
+    AW_SYS_CLK_PLL8,        /* "gpu_pll"        ,PLL8 clock                     */
+    AW_SYS_CLK_CPU,         /* "cpu"            ,CPU clock                      */
+    AW_SYS_CLK_AXI,         /* "axi"            ,AXI clock                      */
+    AW_SYS_CLK_ATB,         /* "atb"            ,ATB clock                      */
+    AW_SYS_CLK_AHB,         /* "ahb"            ,AHB clock                      */
+    AW_SYS_CLK_APB0,        /* "apb"            ,APB0 clock                     */
+    AW_SYS_CLK_APB1,        /* "apb1"           ,APB1 clock                     */
+
+    AW_CCU_CLK_NULL,        /* invalid clock id                                 */
+
+    /* module clock define */
+    AW_MOD_CLK_NFC,         /* "nfc"                                            */
+    AW_MOD_CLK_MSC,         /* "msc"                                            */
+    AW_MOD_CLK_SDC0,        /* "sdc0"                                           */
+    AW_MOD_CLK_SDC1,        /* "sdc1"                                           */
+    AW_MOD_CLK_SDC2,        /* "sdc2"                                           */
+    AW_MOD_CLK_SDC3,        /* "sdc3"                                           */
+    AW_MOD_CLK_TS,          /* "ts"                                             */
+    AW_MOD_CLK_SS,          /* "ss"                                             */
+    AW_MOD_CLK_SPI0,        /* "spi0"                                           */
+    AW_MOD_CLK_SPI1,        /* "spi1"                                           */
+    AW_MOD_CLK_SPI2,        /* "spi2"                                           */
+    AW_MOD_CLK_PATA,        /* "pata"                                           */
+    AW_MOD_CLK_IR0,         /* "ir0"                                            */
+    AW_MOD_CLK_IR1,         /* "ir1"                                            */
+    AW_MOD_CLK_I2S0,        /* "i2s0"                                           */
+    AW_MOD_CLK_I2S1,        /* "i2s1"                                           */
+    AW_MOD_CLK_I2S2,        /* "i2s2"                                           */
+    AW_MOD_CLK_AC97,        /* "ac97"                                           */
+    AW_MOD_CLK_SPDIF,       /* "spdif"                                          */
+    AW_MOD_CLK_KEYPAD,      /* "key_pad"                                        */
+    AW_MOD_CLK_SATA,        /* "sata"                                           */
+    AW_MOD_CLK_USBPHY,      /* "usb_phy"                                        */
+    AW_MOD_CLK_USBPHY0,     /* "usb_phy0"                                       */
+    AW_MOD_CLK_USBPHY1,     /* "usb_phy1"                                       */
+    AW_MOD_CLK_USBPHY2,     /* "usb_phy2"                                       */
+    AW_MOD_CLK_USBOHCI0,    /* "usb_ohci0"                                      */
+    AW_MOD_CLK_USBOHCI1,    /* "usb_ohci1"                                      */
+    AW_MOD_CLK_GPS,         /* "com"                                            */
+    AW_MOD_CLK_SPI3,        /* "spi3"                                           */
+    AW_MOD_CLK_DEBE0,       /* "de_image0"                                      */
+    AW_MOD_CLK_DEBE1,       /* "de_image1"                                      */
+    AW_MOD_CLK_DEFE0,       /* "de_scale0"                                      */
+    AW_MOD_CLK_DEFE1,       /* "de_scale1"                                      */
+    AW_MOD_CLK_DEMIX,       /* "de_mix"                                         */
+    AW_MOD_CLK_LCD0CH0,     /* "lcd0_ch0"                                       */
+    AW_MOD_CLK_LCD1CH0,     /* "lcd1_ch0"                                       */
+    AW_MOD_CLK_CSIISP,      /* "csi_isp"                                        */
+    AW_MOD_CLK_TVDMOD1,     /* "tvdmod1"                                        */
+    AW_MOD_CLK_TVDMOD2,     /* "tvdmod2"                                        */
+    AW_MOD_CLK_LCD0CH1_S1,  /* "lcd0_ch1_s1"                                    */
+    AW_MOD_CLK_LCD0CH1_S2,  /* "lcd0_ch1_s2"                                    */
+    AW_MOD_CLK_LCD1CH1_S1,  /* "lcd1_ch1_s1"                                    */
+    AW_MOD_CLK_LCD1CH1_S2,  /* "lcd1_ch1_s2"                                    */
+    AW_MOD_CLK_CSI0,        /* "csi0"                                           */
+    AW_MOD_CLK_CSI1,        /* "csi1"                                           */
+    AW_MOD_CLK_VE,          /* "ve"                                             */
+    AW_MOD_CLK_ADDA,        /* "audio_codec"                                    */
+    AW_MOD_CLK_AVS,         /* "avs"                                            */
+    AW_MOD_CLK_ACE,         /* "ace"                                            */
+    AW_MOD_CLK_LVDS,        /* "lvds"                                           */
+    AW_MOD_CLK_HDMI,        /* "hdmi"                                           */
+    AW_MOD_CLK_MALI,        /* "mali"                                           */
+    AW_MOD_CLK_TWI0,        /* "twi0"                                           */
+    AW_MOD_CLK_TWI1,        /* "twi1"                                           */
+    AW_MOD_CLK_TWI2,        /* "twi2"                                           */
+    AW_MOD_CLK_TWI3,        /* "twi3"                                           */
+    AW_MOD_CLK_TWI4,        /* "twi4"                                           */
+    AW_MOD_CLK_CAN,         /* "can"                                            */
+    AW_MOD_CLK_SCR,         /* "scr"                                            */
+    AW_MOD_CLK_PS20,        /* "ps0"                                            */
+    AW_MOD_CLK_PS21,        /* "ps1"                                            */
+    AW_MOD_CLK_UART0,       /* "uart0"                                          */
+    AW_MOD_CLK_UART1,       /* "uart1"                                          */
+    AW_MOD_CLK_UART2,       /* "uart2"                                          */
+    AW_MOD_CLK_UART3,       /* "uart3"                                          */
+    AW_MOD_CLK_UART4,       /* "uart4"                                          */
+    AW_MOD_CLK_UART5,       /* "uart5"                                          */
+    AW_MOD_CLK_UART6,       /* "uart6"                                          */
+    AW_MOD_CLK_UART7,       /* "uart7"                                          */
+    AW_MOD_CLK_SMPTWD,      /* "smp_twd"                                        */
+    AW_MOD_CLK_MBUS,        /* "mbus"                                           */
+    AW_MOD_CLK_OUTA,        /* "clkout_a"                                       */
+    AW_MOD_CLK_OUTB,        /* "clkout_b"                                       */
+
+    /* clock gating for hang to AHB bus */
+    AW_AHB_CLK_USB0,        /* "ahb_usb0"                                       */
+    AW_AHB_CLK_EHCI0,       /* "ahb_ehci0"                                      */
+    AW_AHB_CLK_OHCI0,       /* "ahb_ohci0"                                      */
+    AW_AHB_CLK_SS,          /* "ahb_ss"                                         */
+    AW_AHB_CLK_DMA,         /* "ahb_dma"                                        */
+    AW_AHB_CLK_BIST,        /* "ahb_bist"                                       */
+    AW_AHB_CLK_SDMMC0,      /* "ahb_sdc0"                                       */
+    AW_AHB_CLK_SDMMC1,      /* "ahb_sdc1"                                       */
+    AW_AHB_CLK_SDMMC2,      /* "ahb_sdc2"                                       */
+    AW_AHB_CLK_SDMMC3,      /* "ahb_sdc3"                                       */
+    AW_AHB_CLK_MS,          /* "ahb_msc"                                        */
+    AW_AHB_CLK_NAND,        /* "ahb_nfc"                                        */
+    AW_AHB_CLK_SDRAM,       /* "ahb_sdramc"                                     */
+    AW_AHB_CLK_ACE,         /* "ahb_ace"                                        */
+    AW_AHB_CLK_EMAC,        /* "ahb_emac"                                       */
+    AW_AHB_CLK_TS,          /* "ahb_ts"                                         */
+    AW_AHB_CLK_SPI0,        /* "ahb_spi0"                                       */
+    AW_AHB_CLK_SPI1,        /* "ahb_spi1"                                       */
+    AW_AHB_CLK_SPI2,        /* "ahb_spi2"                                       */
+    AW_AHB_CLK_SPI3,        /* "ahb_spi3"                                       */
+    AW_AHB_CLK_PATA,        /* "ahb_pata"                                       */
+    AW_AHB_CLK_SATA,        /* "ahb_sata"                                       */
+    AW_AHB_CLK_GPS,         /* "ahb_com"                                        */
+    AW_AHB_CLK_VE,          /* "ahb_ve"                                         */
+    AW_AHB_CLK_TVD,         /* "ahb_tvd"                                        */
+    AW_AHB_CLK_TVE0,        /* "ahb_tve0"                                       */
+    AW_AHB_CLK_TVE1,        /* "ahb_tve1"                                       */
+    AW_AHB_CLK_LCD0,        /* "ahb_lcd0"                                       */
+    AW_AHB_CLK_LCD1,        /* "ahb_lcd1"                                       */
+    AW_AHB_CLK_CSI0,        /* "ahb_csi0"                                       */
+    AW_AHB_CLK_CSI1,        /* "ahb_csi1"                                       */
+    AW_AHB_CLK_HDMI1,       /* "ahb_hdmi1"                                      */
+    AW_AHB_CLK_HDMI,        /* "ahb_hdmi"                                       */
+    AW_AHB_CLK_DEBE0,       /* "ahb_de_image0"                                  */
+    AW_AHB_CLK_DEBE1,       /* "ahb_de_image1"                                  */
+    AW_AHB_CLK_DEFE0,       /* "ahb_de_scale0"                                  */
+    AW_AHB_CLK_DEFE1,       /* "ahb_de_scale1"                                  */
+    AW_AHB_CLK_GMAC,        /* "ahb_gmac" */
+    AW_AHB_CLK_MP,          /* "ahb_de_mix"                                     */
+    AW_AHB_CLK_MALI,        /* "ahb_mali"                                       */
+    AW_AHB_CLK_EHCI1,       /* "ahb_ehci1"                                      */
+    AW_AHB_CLK_OHCI1,       /* "ahb_ohci1"                                      */
+    AW_AHB_CLK_STMR,        /* "ahb_stmr"                                       */
+
+    /* clock gating for hang APB bus */
+    AW_APB_CLK_ADDA,        /* "apb_audio_codec"                                */
+    AW_APB_CLK_SPDIF,       /* "apb_spdif"                                      */
+    AW_APB_CLK_AC97,        /* "apb_ac97"                                       */
+    AW_APB_CLK_I2S0,        /* "apb_i2s0"                                       */
+    AW_APB_CLK_I2S1,        /* "apb_i2s1"                                       */
+    AW_APB_CLK_I2S2,        /* "apb_i2s2"                                       */
+    AW_APB_CLK_PIO,         /* "apb_pio"                                        */
+    AW_APB_CLK_IR0,         /* "apb_ir0"                                        */
+    AW_APB_CLK_IR1,         /* "apb_ir1"                                        */
+    AW_APB_CLK_KEYPAD,      /* "apb_key_pad"                                    */
+    AW_APB_CLK_TWI0,        /* "apb_twi0"                                       */
+    AW_APB_CLK_TWI1,        /* "apb_twi1"                                       */
+    AW_APB_CLK_TWI2,        /* "apb_twi2"                                       */
+    AW_APB_CLK_TWI3,        /* "apb_twi3"                                       */
+    AW_APB_CLK_TWI4,        /* "apb_twi4"                                       */
+    AW_APB_CLK_CAN,         /* "apb_can"                                        */
+    AW_APB_CLK_SCR,         /* "apb_scr"                                        */
+    AW_APB_CLK_PS20,        /* "apb_ps0"                                        */
+    AW_APB_CLK_PS21,        /* "apb_ps1"                                        */
+    AW_APB_CLK_UART0,       /* "apb_uart0"                                      */
+    AW_APB_CLK_UART1,       /* "apb_uart1"                                      */
+    AW_APB_CLK_UART2,       /* "apb_uart2"                                      */
+    AW_APB_CLK_UART3,       /* "apb_uart3"                                      */
+    AW_APB_CLK_UART4,       /* "apb_uart4"                                      */
+    AW_APB_CLK_UART5,       /* "apb_uart5"                                      */
+    AW_APB_CLK_UART6,       /* "apb_uart6"                                      */
+    AW_APB_CLK_UART7,       /* "apb_uart7"                                      */
+
+    /* clock gating for access dram */
+    AW_DRAM_CLK_VE,         /* "sdram_ve"                                       */
+    AW_DRAM_CLK_CSI0,       /* "sdram_csi0"                                     */
+    AW_DRAM_CLK_CSI1,       /* "sdram_csi1"                                     */
+    AW_DRAM_CLK_TS,         /* "sdram_ts"                                       */
+    AW_DRAM_CLK_TVD,        /* "sdram_tvd"                                      */
+    AW_DRAM_CLK_TVE0,       /* "sdram_tve0"                                     */
+    AW_DRAM_CLK_TVE1,       /* "sdram_tve1"                                     */
+    AW_DRAM_CLK_DEFE0,      /* "sdram_de_scale0"                                */
+    AW_DRAM_CLK_DEFE1,      /* "sdram_de_scale1"                                */
+    AW_DRAM_CLK_DEBE0,      /* "sdram_de_image0"                                */
+    AW_DRAM_CLK_DEBE1,      /* "sdram_de_image1"                                */
+    AW_DRAM_CLK_DEMP,       /* "sdram_de_mix"                                   */
+    AW_DRAM_CLK_ACE,        /* "sdram_ace"                                      */
+
+    AW_CCU_CLK_CNT,         /* invalid clock id                                 */
+
+} __aw_ccu_clk_id_e;
+
+/* define handle for moduel clock */
+typedef struct __AW_CCU_CLK {
+    __aw_ccu_clk_id_e       id;     /* clock id         */
+    __aw_ccu_clk_id_e       parent; /* parent clock id  */
+    char                    *name;  /* clock name       */
+    __aw_ccu_clk_onff_e     onoff;  /* on/off status    */
+    __aw_ccu_clk_reset_e    reset;  /* reset status     */
+    __u64                   rate;   /* clock rate, frequency for system clock,
+                                     * division for module clock
+                                     */
+    __s32                   hash;   /* hash value, for fast search without
+                                     * string compare
+                                     */
+} __aw_ccu_clk_t;
+
+typedef struct clk_ops {
+    int                  (*set_status)(__aw_ccu_clk_id_e id, __aw_ccu_clk_onff_e status);
+    __aw_ccu_clk_onff_e  (*get_status)(__aw_ccu_clk_id_e id                            );
+    int                  (*set_parent)(__aw_ccu_clk_id_e id, __aw_ccu_clk_id_e parent  );
+    __aw_ccu_clk_id_e    (*get_parent)(__aw_ccu_clk_id_e id                            );
+    int                  (*set_rate  )(__aw_ccu_clk_id_e id, __u64 rate                );
+    __u64                (*round_rate)(__aw_ccu_clk_id_e id, __u64 rate                );
+    __u64                (*get_rate  )(__aw_ccu_clk_id_e id                            );
+    int                  (*set_reset )(__aw_ccu_clk_id_e id, __aw_ccu_clk_reset_e      );
+    __aw_ccu_clk_reset_e (*get_reset )(__aw_ccu_clk_id_e id                            );
+} __clk_ops_t;
+
+/*
+ * calculate hash value of a string.
+ *
+ * @string: string
+ *
+ * Return hash value.
+ */
+static inline __s32 ccu_clk_calc_hash(char *string)
+{
+    __s32 tmpLen, i, tmpHash = 0;
+
+    if (!string) {
+        return 0;
+    }
+
+    tmpLen = strlen(string);
+    for (i = 0; i < tmpLen; i++) {
+        tmpHash += string[i];
+    }
+
+    return tmpHash;
+}
+
+static inline __u64 ccu_clk_uldiv(__u64 dividend, __u32 divisior)
+{
+    __u32 rem = 0;
+
+    /* quotient stored in dividend */
+    rem = do_div(dividend, divisior);
+    if (0 != rem)
+        dividend += 1;
+
+    return dividend;
+}
+
+
+extern __aw_ccu_clk_t aw_ccu_clk_tbl[];
+extern __ccu_clk_t    aw_clock[];
+
+extern __ccmu_reg_list_t *aw_ccu_reg;
+
+/* clock operations */
+extern __clk_ops_t sys_clk_ops;
+extern __clk_ops_t mod_clk_ops;
+
+int aw_ccu_init(void);
+int aw_ccu_exit(void);
+int aw_ccu_get_clk(__aw_ccu_clk_id_e id, __ccu_clk_t *clk);
+
+struct core_pll_factor_t {
+    __u8 FactorN;
+    __u8 FactorK;
+    __u8 FactorM;
+    __u8 FactorP;
+};
+
+int ccm_clk_get_pll_para(struct core_pll_factor_t *factor, __u64 rate);
+
+#endif
diff --git a/arch/arm/mach-sun7i/clock/ccu_dbg.c b/arch/arm/mach-sun7i/clock/ccu_dbg.c
new file mode 100644
index 0000000..1527d50
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/ccu_dbg.c
@@ -0,0 +1,1046 @@
+/*
+ * arch/arm/mach-sun7i/clock/ccu_dbg.c
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include "ccm_i.h"
+
+
+#define print_clk_inf(x, y) do { printk(#x"."#y":%d\n", aw_ccu_reg->x.y); } while (0)
+
+void clk_dbg_inf(void)
+{
+    printk("---------------------------------------------\n");
+    printk("    dump clock information                   \n");
+    printk("---------------------------------------------\n");
+
+    printk("PLL1 infor:\n");
+    print_clk_inf(Pll1Ctl, FactorM);
+    print_clk_inf(Pll1Ctl, SigmaEn);
+    print_clk_inf(Pll1Ctl, SigmaIn);
+    print_clk_inf(Pll1Ctl, FactorK);
+    print_clk_inf(Pll1Ctl, FactorN);
+    print_clk_inf(Pll1Ctl, LockTime);
+    print_clk_inf(Pll1Ctl, PLLDivP);
+    print_clk_inf(Pll1Ctl, PLLBias);
+    print_clk_inf(Pll1Ctl, ExchangeEn);
+    print_clk_inf(Pll1Ctl, VCOBias);
+    print_clk_inf(Pll1Ctl, VCORstIn);
+    print_clk_inf(Pll1Ctl, PLLEn);
+
+    printk("\nPLL2 infor:\n");
+    print_clk_inf(Pll2Ctl, PrevDiv);
+    print_clk_inf(Pll2Ctl, FactorN);
+    print_clk_inf(Pll2Ctl, PLLBias);
+    print_clk_inf(Pll2Ctl, VcoBias);
+    print_clk_inf(Pll2Ctl, PostDiv);
+    print_clk_inf(Pll2Ctl, PLLEn);
+
+    printk("\nPLL3 infor:\n");
+    print_clk_inf(Pll3Ctl, FactorM);
+    print_clk_inf(Pll3Ctl, PLLBias);
+    print_clk_inf(Pll3Ctl, FracSet);
+    print_clk_inf(Pll3Ctl, ModeSel);
+    print_clk_inf(Pll3Ctl, VCOBias);
+    print_clk_inf(Pll3Ctl, DampFactor);
+    print_clk_inf(Pll3Ctl, PLLEn);
+
+    printk("\nPLL4 infor:\n");
+    print_clk_inf(Pll4Ctl, FactorM);
+    print_clk_inf(Pll4Ctl, FactorK);
+    print_clk_inf(Pll4Ctl, DampFactor);
+    print_clk_inf(Pll4Ctl, FactorN);
+    print_clk_inf(Pll4Ctl, BandWidth);
+    print_clk_inf(Pll4Ctl, PLLBias);
+    print_clk_inf(Pll4Ctl, VCOBias);
+    print_clk_inf(Pll4Ctl, PLLBypass);
+    print_clk_inf(Pll4Ctl, PLLEn);
+
+    printk("\nPLL5 infor:\n");
+    print_clk_inf(Pll5Ctl, FactorM);
+    print_clk_inf(Pll5Ctl, FactorM1);
+    print_clk_inf(Pll5Ctl, FactorK);
+    print_clk_inf(Pll5Ctl, LDO2En);
+    print_clk_inf(Pll5Ctl, FactorN);
+    print_clk_inf(Pll5Ctl, VCOGain);
+    print_clk_inf(Pll5Ctl, FactorP);
+    print_clk_inf(Pll5Ctl, BandWidth);
+    print_clk_inf(Pll5Ctl, VCOGainEn);
+    print_clk_inf(Pll5Ctl, PLLBias);
+    print_clk_inf(Pll5Ctl, VCOBias);
+    print_clk_inf(Pll5Ctl, OutputEn);
+    print_clk_inf(Pll5Ctl, PLLBypass);
+    print_clk_inf(Pll5Ctl, PLLEn);
+
+    printk("\nPLL6 infor:\n");
+    print_clk_inf(Pll6Ctl, FactorM);
+    print_clk_inf(Pll6Ctl, FactorK);
+    print_clk_inf(Pll6Ctl, DampFactor);
+    print_clk_inf(Pll6Ctl, FactorN);
+    print_clk_inf(Pll6Ctl, OutputEn);
+    print_clk_inf(Pll6Ctl, BandWidth);
+    print_clk_inf(Pll6Ctl, PLLBias);
+    print_clk_inf(Pll6Ctl, VCOBias);
+    print_clk_inf(Pll6Ctl, PLLBypass);
+    print_clk_inf(Pll6Ctl, PLLEn);
+
+    printk("\nPLL7 infor:\n");
+    print_clk_inf(Pll7Ctl, FactorM);
+    print_clk_inf(Pll7Ctl, PLLBias);
+    print_clk_inf(Pll7Ctl, FracSet);
+    print_clk_inf(Pll7Ctl, ModeSel);
+    print_clk_inf(Pll7Ctl, VCOBias);
+    print_clk_inf(Pll7Ctl, DampFactor);
+    print_clk_inf(Pll7Ctl, PLLEn);
+
+    printk("\nPLL8 infor:\n");
+    print_clk_inf(Pll8Ctl, FactorM);
+    print_clk_inf(Pll8Ctl, FactorK);
+    print_clk_inf(Pll8Ctl, DampFactor);
+    print_clk_inf(Pll8Ctl, FactorN);
+    print_clk_inf(Pll8Ctl, BandWidth);
+    print_clk_inf(Pll8Ctl, PLLBias);
+    print_clk_inf(Pll8Ctl, VCOBias);
+    print_clk_inf(Pll8Ctl, PLLBypass);
+    print_clk_inf(Pll8Ctl, PLLEn);
+
+    printk("\nHOSC infor:\n");
+    print_clk_inf(HoscCtl, OSC24MEn);
+    print_clk_inf(HoscCtl, OSC24MGsm);
+    print_clk_inf(HoscCtl, PLLBiasEn);
+    print_clk_inf(HoscCtl, LDOEn);
+    print_clk_inf(HoscCtl, PLLInPower);
+    print_clk_inf(HoscCtl, LDOOutput);
+    print_clk_inf(HoscCtl, KeyField);
+
+    printk("\nCPU clk infor:\n");
+    print_clk_inf(SysClkDiv, AXIClkDiv);
+    print_clk_inf(SysClkDiv, AHBClkDiv);
+    print_clk_inf(SysClkDiv, AHBClkSrc);
+    print_clk_inf(SysClkDiv, APB0ClkDiv);
+    print_clk_inf(SysClkDiv, AtbApbClkDiv);
+    print_clk_inf(SysClkDiv, AC327ClkSrc);
+    print_clk_inf(SysClkDiv, DVFSStart);
+
+    printk("\nAPB1 clk infor:\n");
+    print_clk_inf(Apb1ClkDiv, ClkDiv);
+    print_clk_inf(Apb1ClkDiv, PreDiv);
+    print_clk_inf(Apb1ClkDiv, ClkSrc);
+
+    printk("\nAhbGate0 clk infor:\n");
+    print_clk_inf(AhbGate0, Usb0Gate);
+    print_clk_inf(AhbGate0, Ehci0Gate);
+    print_clk_inf(AhbGate0, Ohci0Gate);
+    print_clk_inf(AhbGate0, Ehci1Gate);
+    print_clk_inf(AhbGate0, Ohci1Gate);
+    print_clk_inf(AhbGate0, SsGate);
+    print_clk_inf(AhbGate0, DmaGate);
+    print_clk_inf(AhbGate0, BistGate);
+    print_clk_inf(AhbGate0, Sdmmc0Gate);
+    print_clk_inf(AhbGate0, Sdmmc1Gate);
+    print_clk_inf(AhbGate0, Sdmmc2Gate);
+    print_clk_inf(AhbGate0, Sdmmc3Gate);
+    print_clk_inf(AhbGate0, MsGate);
+    print_clk_inf(AhbGate0, NandGate);
+    print_clk_inf(AhbGate0, SdramGate);
+    print_clk_inf(AhbGate0, AceGate);
+    print_clk_inf(AhbGate0, EmacGate);
+    print_clk_inf(AhbGate0, TsGate);
+    print_clk_inf(AhbGate0, Spi0Gate);
+    print_clk_inf(AhbGate0, Spi1Gate);
+    print_clk_inf(AhbGate0, Spi2Gate);
+    print_clk_inf(AhbGate0, Spi3Gate);
+    /* REMOVED */
+    //print_clk_inf(AhbGate0, PataGate);
+    print_clk_inf(AhbGate0, SataGate);
+    /* REMOVED */
+    //print_clk_inf(AhbGate0, GpsGate);
+    print_clk_inf(AhbGate0, StmrGate);
+
+    printk("\nAhbGate1 clk infor:\n");
+    print_clk_inf(AhbGate1, VeGate);
+    print_clk_inf(AhbGate1, TvdGate);
+    print_clk_inf(AhbGate1, Tve0Gate);
+    print_clk_inf(AhbGate1, Tve1Gate);
+    print_clk_inf(AhbGate1, Lcd0Gate);
+    print_clk_inf(AhbGate1, Lcd1Gate);
+    print_clk_inf(AhbGate1, Csi0Gate);
+    print_clk_inf(AhbGate1, Csi1Gate);
+    print_clk_inf(AhbGate1, Hdmi1Gate);
+    print_clk_inf(AhbGate1, HdmiDGate);
+    print_clk_inf(AhbGate1, DeBe0Gate);
+    print_clk_inf(AhbGate1, DeBe1Gate);
+    print_clk_inf(AhbGate1, DeFe0Gate);
+    print_clk_inf(AhbGate1, DeFe1Gate);
+    print_clk_inf(AhbGate1, MpGate);
+    print_clk_inf(AhbGate1, Gpu3DGate);
+
+    printk("\nApb0Gate clk infor:\n");
+    print_clk_inf(Apb0Gate, AddaGate);
+    print_clk_inf(Apb0Gate, SpdifGate);
+    print_clk_inf(Apb0Gate, Ac97Gate);
+    print_clk_inf(Apb0Gate, Iis0Gate);
+    print_clk_inf(Apb0Gate, Iis1Gate);
+    print_clk_inf(Apb0Gate, PioGate);
+    print_clk_inf(Apb0Gate, Ir0Gate);
+    print_clk_inf(Apb0Gate, Ir1Gate);
+    print_clk_inf(Apb0Gate, Iis2Gate);
+    print_clk_inf(Apb0Gate, KeypadGate);
+
+    printk("\nApb1Gate clk infor:\n");
+    print_clk_inf(Apb1Gate, Twi0Gate);
+    print_clk_inf(Apb1Gate, Twi1Gate);
+    print_clk_inf(Apb1Gate, Twi2Gate);
+    print_clk_inf(Apb1Gate, Twi3Gate);
+    print_clk_inf(Apb1Gate, CanGate);
+    print_clk_inf(Apb1Gate, ScrGate);
+    print_clk_inf(Apb1Gate, Ps20Gate);
+    print_clk_inf(Apb1Gate, Ps21Gate);
+    print_clk_inf(Apb1Gate, Twi4Gate);
+    print_clk_inf(Apb1Gate, Uart0Gate);
+    print_clk_inf(Apb1Gate, Uart1Gate);
+    print_clk_inf(Apb1Gate, Uart2Gate);
+    print_clk_inf(Apb1Gate, Uart3Gate);
+    print_clk_inf(Apb1Gate, Uart4Gate);
+    print_clk_inf(Apb1Gate, Uart5Gate);
+    print_clk_inf(Apb1Gate, Uart6Gate);
+    print_clk_inf(Apb1Gate, Uart7Gate);
+
+    printk("\nNandClk clk infor:\n");
+    print_clk_inf(NandClk, ClkDiv);
+    print_clk_inf(NandClk, ClkPreDiv);
+    print_clk_inf(NandClk, ClkSrc);
+    print_clk_inf(NandClk, SpecClkGate);
+
+    printk("\nMsClk clk infor:\n");
+    print_clk_inf(MsClk, ClkDiv);
+    print_clk_inf(MsClk, ClkPreDiv);
+    print_clk_inf(MsClk, ClkSrc);
+    print_clk_inf(MsClk, SpecClkGate);
+
+    printk("\nSdMmc0Clk clk infor:\n");
+    print_clk_inf(SdMmc0Clk, ClkDiv);
+    print_clk_inf(SdMmc0Clk, ClkPreDiv);
+    print_clk_inf(SdMmc0Clk, ClkSrc);
+    print_clk_inf(SdMmc0Clk, SpecClkGate);
+
+    printk("\nSdMmc1Clk clk infor:\n");
+    print_clk_inf(SdMmc1Clk, ClkDiv);
+    print_clk_inf(SdMmc1Clk, ClkPreDiv);
+    print_clk_inf(SdMmc1Clk, ClkSrc);
+    print_clk_inf(SdMmc1Clk, SpecClkGate);
+
+    printk("\nSdMmc2Clk clk infor:\n");
+    print_clk_inf(SdMmc2Clk, ClkDiv);
+    print_clk_inf(SdMmc2Clk, ClkPreDiv);
+    print_clk_inf(SdMmc2Clk, ClkSrc);
+    print_clk_inf(SdMmc2Clk, SpecClkGate);
+
+    printk("\nSdMmc3Clk clk infor:\n");
+    print_clk_inf(SdMmc3Clk, ClkDiv);
+    print_clk_inf(SdMmc3Clk, ClkPreDiv);
+    print_clk_inf(SdMmc3Clk, ClkSrc);
+    print_clk_inf(SdMmc3Clk, SpecClkGate);
+
+    printk("\nTsClk clk infor:\n");
+    print_clk_inf(TsClk, ClkDiv);
+    print_clk_inf(TsClk, ClkPreDiv);
+    print_clk_inf(TsClk, ClkSrc);
+    print_clk_inf(TsClk, SpecClkGate);
+
+    printk("\nSsClk clk infor:\n");
+    print_clk_inf(SsClk, ClkDiv);
+    print_clk_inf(SsClk, ClkPreDiv);
+    print_clk_inf(SsClk, ClkSrc);
+    print_clk_inf(SsClk, SpecClkGate);
+
+    printk("\nSpi0Clk clk infor:\n");
+    print_clk_inf(Spi0Clk, ClkDiv);
+    print_clk_inf(Spi0Clk, ClkPreDiv);
+    print_clk_inf(Spi0Clk, ClkSrc);
+    print_clk_inf(Spi0Clk, SpecClkGate);
+
+    printk("\nSpi1Clk clk infor:\n");
+    print_clk_inf(Spi1Clk, ClkDiv);
+    print_clk_inf(Spi1Clk, ClkPreDiv);
+    print_clk_inf(Spi1Clk, ClkSrc);
+    print_clk_inf(Spi1Clk, SpecClkGate);
+
+    printk("\nSpi2Clk clk infor:\n");
+    print_clk_inf(Spi2Clk, ClkDiv);
+    print_clk_inf(Spi2Clk, ClkPreDiv);
+    print_clk_inf(Spi2Clk, ClkSrc);
+    print_clk_inf(Spi2Clk, SpecClkGate);
+
+    printk("\nPataClk clk infor:\n");
+    print_clk_inf(PataClk, ClkDiv);
+    print_clk_inf(PataClk, ClkPreDiv);
+    print_clk_inf(PataClk, ClkSrc);
+    print_clk_inf(PataClk, SpecClkGate);
+
+    printk("\nIr0Clk clk infor:\n");
+    print_clk_inf(Ir0Clk, ClkDiv);
+    print_clk_inf(Ir0Clk, ClkPreDiv);
+    print_clk_inf(Ir0Clk, ClkSrc);
+    print_clk_inf(Ir0Clk, SpecClkGate);
+
+    printk("\nIr1Clk clk infor:\n");
+    print_clk_inf(Ir1Clk, ClkDiv);
+    print_clk_inf(Ir1Clk, ClkPreDiv);
+    print_clk_inf(Ir1Clk, ClkSrc);
+    print_clk_inf(Ir1Clk, SpecClkGate);
+
+    printk("\nI2s0Clk clk infor:\n");
+    print_clk_inf(I2s0Clk, ClkDiv);
+    print_clk_inf(I2s0Clk, SpecClkGate);
+
+    printk("\nAc97Clk clk infor:\n");
+    print_clk_inf(Ac97Clk, ClkDiv);
+    print_clk_inf(Ac97Clk, SpecClkGate);
+
+    printk("\nSpdifClk clk infor:\n");
+    print_clk_inf(SpdifClk, ClkDiv);
+    print_clk_inf(SpdifClk, SpecClkGate);
+
+    printk("\nKeyPadClk clk infor:\n");
+    print_clk_inf(KeyPadClk, ClkDiv);
+    print_clk_inf(KeyPadClk, ClkPreDiv);
+    print_clk_inf(KeyPadClk, ClkSrc);
+    print_clk_inf(KeyPadClk, SpecClkGate);
+
+    printk("\nSataClk clk infor:\n");
+    print_clk_inf(SataClk, ClkSrc);
+    print_clk_inf(SataClk, SpecClkGate);
+
+    printk("\nUsbClk clk infor:\n");
+    print_clk_inf(UsbClk, UsbPhy0Rst);
+    print_clk_inf(UsbClk, UsbPhy1Rst);
+    print_clk_inf(UsbClk, UsbPhy2Rst);
+    /* REMOVED */
+    //print_clk_inf(UsbClk, OHCIClkSrc);
+    print_clk_inf(UsbClk, OHCI0SpecClkGate);
+    print_clk_inf(UsbClk, OHCI1SpecClkGate);
+    print_clk_inf(UsbClk, PhySpecClkGate);
+
+    /* REMOVED */
+    //printk("\nGpsClk clk infor:\n");
+    //print_clk_inf(GpsClk, ClkDivRatio);
+    //print_clk_inf(GpsClk, ClkSrc);
+    //print_clk_inf(GpsClk, Reset);
+    //print_clk_inf(GpsClk, SpecClkGate);
+
+    printk("\nSpi3Clk clk infor:\n");
+    print_clk_inf(Spi3Clk, ClkDiv);
+    print_clk_inf(Spi3Clk, ClkPreDiv);
+    print_clk_inf(Spi3Clk, ClkSrc);
+    print_clk_inf(Spi3Clk, SpecClkGate);
+
+    printk("\nI2s1Clk clk infor:\n");
+    print_clk_inf(I2s1Clk, ClkDiv);
+    print_clk_inf(I2s1Clk, SpecClkGate);
+
+    printk("\nI2s2Clk clk infor:\n");
+    print_clk_inf(I2s2Clk, ClkDiv);
+    print_clk_inf(I2s2Clk, SpecClkGate);
+
+    printk("\nDramGate clk infor:\n");
+    print_clk_inf(DramGate, VeGate);
+    print_clk_inf(DramGate, Csi0Gate);
+    print_clk_inf(DramGate, Csi1Gate);
+    print_clk_inf(DramGate, TsGate);
+    print_clk_inf(DramGate, TvdGate);
+    print_clk_inf(DramGate, Tve0Gate);
+    print_clk_inf(DramGate, Tve1Gate);
+    print_clk_inf(DramGate, ClkOutputEn);
+    print_clk_inf(DramGate, DeFe0Gate);
+    print_clk_inf(DramGate, DeFe1Gate);
+    print_clk_inf(DramGate, DeBe0Gate);
+    print_clk_inf(DramGate, DeBe1Gate);
+    print_clk_inf(DramGate, DeMpGate);
+    print_clk_inf(DramGate, AceGate);
+
+    printk("\nDeBe0Clk clk infor:\n");
+    print_clk_inf(DeBe0Clk, ClkDiv);
+    print_clk_inf(DeBe0Clk, ClkSrc);
+    print_clk_inf(DeBe0Clk, Reset);
+    print_clk_inf(DeBe0Clk, SpecClkGate);
+
+    printk("\nDeBe1Clk clk infor:\n");
+    print_clk_inf(DeBe1Clk, ClkDiv);
+    print_clk_inf(DeBe1Clk, ClkSrc);
+    print_clk_inf(DeBe1Clk, Reset);
+    print_clk_inf(DeBe1Clk, SpecClkGate);
+
+    printk("\nDeFe0Clk clk infor:\n");
+    print_clk_inf(DeFe0Clk, ClkDiv);
+    print_clk_inf(DeFe0Clk, ClkSrc);
+    print_clk_inf(DeFe0Clk, Reset);
+    print_clk_inf(DeFe0Clk, SpecClkGate);
+
+    printk("\nDeFe1Clk clk infor:\n");
+    print_clk_inf(DeFe1Clk, ClkDiv);
+    print_clk_inf(DeFe1Clk, ClkSrc);
+    print_clk_inf(DeFe1Clk, Reset);
+    print_clk_inf(DeFe1Clk, SpecClkGate);
+
+    printk("\nDeMpClk clk infor:\n");
+    print_clk_inf(DeMpClk, ClkDiv);
+    print_clk_inf(DeMpClk, ClkSrc);
+    print_clk_inf(DeMpClk, Reset);
+    print_clk_inf(DeMpClk, SpecClkGate);
+
+    printk("\nLcd0Ch0Clk clk infor:\n");
+    print_clk_inf(Lcd0Ch0Clk, ClkSrc);
+    print_clk_inf(Lcd0Ch0Clk, Reset);
+    print_clk_inf(Lcd0Ch0Clk, SpecClkGate);
+
+    printk("\nLcd1Ch0Clk clk infor:\n");
+    print_clk_inf(Lcd1Ch0Clk, ClkSrc);
+    print_clk_inf(Lcd1Ch0Clk, Reset);
+    print_clk_inf(Lcd1Ch0Clk, SpecClkGate);
+
+    printk("\nCsiIspClk clk infor:\n");
+    print_clk_inf(CsiIspClk, ClkDiv);
+    print_clk_inf(CsiIspClk, ClkSrc);
+    print_clk_inf(CsiIspClk, SpecClkGate);
+
+    printk("\nTvdClk clk infor:\n");
+    print_clk_inf(TvdClk, Clk1Div);
+    print_clk_inf(TvdClk, Clk1Src);
+    print_clk_inf(TvdClk, Clk1Gate);
+    print_clk_inf(TvdClk, Clk2Div);
+    print_clk_inf(TvdClk, Clk2Src);
+    print_clk_inf(TvdClk, Clk2Gate);
+
+    printk("\nLcd0Ch1Clk clk infor:\n");
+    print_clk_inf(Lcd0Ch1Clk, ClkDiv);
+    print_clk_inf(Lcd0Ch1Clk, SpecClk1Src);
+    print_clk_inf(Lcd0Ch1Clk, SpecClk1Gate);
+    print_clk_inf(Lcd0Ch1Clk, SpecClk2Src);
+    print_clk_inf(Lcd0Ch1Clk, SpecClk2Gate);
+
+    printk("\nLcd1Ch1Clk clk infor:\n");
+    print_clk_inf(Lcd1Ch1Clk, ClkDiv);
+    print_clk_inf(Lcd1Ch1Clk, SpecClk1Src);
+    print_clk_inf(Lcd1Ch1Clk, SpecClk1Gate);
+    print_clk_inf(Lcd1Ch1Clk, SpecClk2Src);
+    print_clk_inf(Lcd1Ch1Clk, SpecClk2Gate);
+
+    printk("\nCsi0Clk clk infor:\n");
+    print_clk_inf(Csi0Clk, ClkDiv);
+    print_clk_inf(Csi0Clk, ClkSrc);
+    print_clk_inf(Csi0Clk, Reset);
+    print_clk_inf(Csi0Clk, SpecClkGate);
+
+    printk("\nCsi1Clk clk infor:\n");
+    print_clk_inf(Csi1Clk, ClkDiv);
+    print_clk_inf(Csi1Clk, ClkSrc);
+    print_clk_inf(Csi1Clk, Reset);
+    print_clk_inf(Csi1Clk, SpecClkGate);
+
+    printk("\nVeClk clk infor:\n");
+    print_clk_inf(VeClk, Reset);
+    print_clk_inf(VeClk, ClkDiv);
+    print_clk_inf(VeClk, SpecClkGate);
+
+    printk("\nAddaClk clk infor:\n");
+    print_clk_inf(AddaClk, SpecClkGate);
+
+    printk("\nAvsClk clk infor:\n");
+    print_clk_inf(AvsClk, SpecClkGate);
+
+    printk("\nAceClk clk infor:\n");
+    print_clk_inf(AceClk, ClkDiv);
+    print_clk_inf(AceClk, Reset);
+    print_clk_inf(AceClk, ClkSrc);
+    print_clk_inf(AceClk, SpecClkGate);
+
+    printk("\nLvdsClk clk infor:\n");
+    print_clk_inf(LvdsClk, Reset);
+
+    printk("\nHdmiClk clk infor:\n");
+    print_clk_inf(HdmiClk, ClkDiv);
+    print_clk_inf(HdmiClk, ClkSrc);
+    print_clk_inf(HdmiClk, SpecClkGate);
+
+    printk("\nMaliClk clk infor:\n");
+    print_clk_inf(MaliClk, ClkDiv);
+    print_clk_inf(MaliClk, ClkSrc);
+    print_clk_inf(MaliClk, Reset);
+    print_clk_inf(MaliClk, SpecClkGate);
+
+    printk("\nMBusClk clk infor:\n");
+    print_clk_inf(MBusClk, ClkDivM);
+    print_clk_inf(MBusClk, ClkDivN);
+    print_clk_inf(MBusClk, ClkSrc);
+    print_clk_inf(MBusClk, ClkGate);
+
+    printk("\nGmacClk clk infor:\n");
+    print_clk_inf(GmacClk, TxClkSrc);
+    print_clk_inf(GmacClk, PhyIT);
+    print_clk_inf(GmacClk, TxClkInv);
+    print_clk_inf(GmacClk, RxClkInv);
+    print_clk_inf(GmacClk, RxDlyChain);
+    print_clk_inf(GmacClk, ClkDiv);
+
+    printk("\nClkOutA clk infor:\n");
+    print_clk_inf(ClkOutA, ClkDivM);
+    print_clk_inf(ClkOutA, ClkDivN);
+    print_clk_inf(ClkOutA, ClkSrc);
+    print_clk_inf(ClkOutA, ClkEn);
+
+    printk("\nClkOutB clk infor:\n");
+    print_clk_inf(ClkOutB, ClkDivM);
+    print_clk_inf(ClkOutB, ClkDivN);
+    print_clk_inf(ClkOutB, ClkSrc);
+    print_clk_inf(ClkOutB, ClkEn);
+}
+EXPORT_SYMBOL(clk_dbg_inf);
+
+#ifdef CONFIG_PROC_FS
+
+#define sprintf_clk_inf(buf, x, y) do { seq_printf(buf, "\t"#x"."#y":%d\n", aw_ccu_reg->x.y); } while(0)
+static int ccmu_stats_show(struct seq_file *m, void *unused)
+{
+    seq_printf(m, "---------------------------------------------\n");
+    seq_printf(m, "clock information:                           \n");
+    seq_printf(m, "---------------------------------------------\n");
+
+    seq_printf(m, "\nPLL1 infor:\n");
+    sprintf_clk_inf(m, Pll1Ctl, FactorM);
+    sprintf_clk_inf(m, Pll1Ctl, SigmaEn);
+    sprintf_clk_inf(m, Pll1Ctl, SigmaIn);
+    sprintf_clk_inf(m, Pll1Ctl, FactorK);
+    sprintf_clk_inf(m, Pll1Ctl, FactorN);
+    sprintf_clk_inf(m, Pll1Ctl, LockTime);
+    sprintf_clk_inf(m, Pll1Ctl, PLLDivP);
+    sprintf_clk_inf(m, Pll1Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll1Ctl, ExchangeEn);
+    sprintf_clk_inf(m, Pll1Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll1Ctl, VCORstIn);
+    sprintf_clk_inf(m, Pll1Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL2 infor(0x%x):\n", *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl);
+    sprintf_clk_inf(m, Pll2Ctl, PrevDiv);
+    sprintf_clk_inf(m, Pll2Ctl, FactorN);
+    sprintf_clk_inf(m, Pll2Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll2Ctl, VcoBias);
+    sprintf_clk_inf(m, Pll2Ctl, PostDiv);
+    sprintf_clk_inf(m, Pll2Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL3 infor:\n");
+    sprintf_clk_inf(m, Pll3Ctl, FactorM);
+    sprintf_clk_inf(m, Pll3Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll3Ctl, FracSet);
+    sprintf_clk_inf(m, Pll3Ctl, ModeSel);
+    sprintf_clk_inf(m, Pll3Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll3Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll3Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL4 infor:\n");
+    sprintf_clk_inf(m, Pll4Ctl, FactorM);
+    sprintf_clk_inf(m, Pll4Ctl, FactorK);
+    sprintf_clk_inf(m, Pll4Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll4Ctl, FactorN);
+    sprintf_clk_inf(m, Pll4Ctl, BandWidth);
+    sprintf_clk_inf(m, Pll4Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll4Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll4Ctl, PLLBypass);
+    sprintf_clk_inf(m, Pll4Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL5 infor:\n");
+    sprintf_clk_inf(m, Pll5Ctl, FactorM);
+    sprintf_clk_inf(m, Pll5Ctl, FactorM1);
+    sprintf_clk_inf(m, Pll5Ctl, FactorK);
+    sprintf_clk_inf(m, Pll5Ctl, LDO2En);
+    sprintf_clk_inf(m, Pll5Ctl, FactorN);
+    sprintf_clk_inf(m, Pll5Ctl, VCOGain);
+    sprintf_clk_inf(m, Pll5Ctl, FactorP);
+    sprintf_clk_inf(m, Pll5Ctl, BandWidth);
+    sprintf_clk_inf(m, Pll5Ctl, VCOGainEn);
+    sprintf_clk_inf(m, Pll5Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll5Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll5Ctl, OutputEn);
+    sprintf_clk_inf(m, Pll5Ctl, PLLBypass);
+    sprintf_clk_inf(m, Pll5Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL6 infor:\n");
+    sprintf_clk_inf(m, Pll6Ctl, FactorM);
+    sprintf_clk_inf(m, Pll6Ctl, FactorK);
+    sprintf_clk_inf(m, Pll6Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll6Ctl, FactorN);
+    sprintf_clk_inf(m, Pll6Ctl, OutputEn);
+    sprintf_clk_inf(m, Pll6Ctl, BandWidth);
+    sprintf_clk_inf(m, Pll6Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll6Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll6Ctl, PLLBypass);
+    sprintf_clk_inf(m, Pll6Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL7 infor:\n");
+    sprintf_clk_inf(m, Pll7Ctl, FactorM);
+    sprintf_clk_inf(m, Pll7Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll7Ctl, FracSet);
+    sprintf_clk_inf(m, Pll7Ctl, ModeSel);
+    sprintf_clk_inf(m, Pll7Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll7Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll7Ctl, PLLEn);
+
+    seq_printf(m, "\nPLL8 infor:\n");
+    sprintf_clk_inf(m, Pll8Ctl, FactorM);
+    sprintf_clk_inf(m, Pll8Ctl, FactorK);
+    sprintf_clk_inf(m, Pll8Ctl, DampFactor);
+    sprintf_clk_inf(m, Pll8Ctl, FactorN);
+    sprintf_clk_inf(m, Pll8Ctl, BandWidth);
+    sprintf_clk_inf(m, Pll8Ctl, PLLBias);
+    sprintf_clk_inf(m, Pll8Ctl, VCOBias);
+    sprintf_clk_inf(m, Pll8Ctl, PLLBypass);
+    sprintf_clk_inf(m, Pll8Ctl, PLLEn);
+
+    seq_printf(m, "\nHOSC infor:\n");
+    sprintf_clk_inf(m, HoscCtl, OSC24MEn);
+    sprintf_clk_inf(m, HoscCtl, OSC24MGsm);
+    sprintf_clk_inf(m, HoscCtl, PLLBiasEn);
+    sprintf_clk_inf(m, HoscCtl, LDOEn);
+    sprintf_clk_inf(m, HoscCtl, PLLInPower);
+    sprintf_clk_inf(m, HoscCtl, LDOOutput);
+    sprintf_clk_inf(m, HoscCtl, KeyField);
+
+    seq_printf(m, "\nCPU clk infor:\n");
+    sprintf_clk_inf(m, SysClkDiv, AXIClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AHBClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AHBClkSrc);
+    sprintf_clk_inf(m, SysClkDiv, APB0ClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AtbApbClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AC327ClkSrc);
+    sprintf_clk_inf(m, SysClkDiv, DVFSStart);
+
+    seq_printf(m, "\nAPB1 clk infor:\n");
+    sprintf_clk_inf(m, Apb1ClkDiv, ClkDiv);
+    sprintf_clk_inf(m, Apb1ClkDiv, PreDiv);
+    sprintf_clk_inf(m, Apb1ClkDiv, ClkSrc);
+
+    seq_printf(m, "\nAhbGate0 clk infor:\n");
+    sprintf_clk_inf(m, AhbGate0, Usb0Gate);
+    sprintf_clk_inf(m, AhbGate0, Ehci0Gate);
+    sprintf_clk_inf(m, AhbGate0, Ohci0Gate);
+    sprintf_clk_inf(m, AhbGate0, Ehci1Gate);
+    sprintf_clk_inf(m, AhbGate0, Ohci1Gate);
+    sprintf_clk_inf(m, AhbGate0, SsGate);
+    sprintf_clk_inf(m, AhbGate0, DmaGate);
+    sprintf_clk_inf(m, AhbGate0, BistGate);
+    sprintf_clk_inf(m, AhbGate0, Sdmmc0Gate);
+    sprintf_clk_inf(m, AhbGate0, Sdmmc1Gate);
+    sprintf_clk_inf(m, AhbGate0, Sdmmc2Gate);
+    sprintf_clk_inf(m, AhbGate0, Sdmmc3Gate);
+    sprintf_clk_inf(m, AhbGate0, MsGate);
+    sprintf_clk_inf(m, AhbGate0, NandGate);
+    sprintf_clk_inf(m, AhbGate0, SdramGate);
+    sprintf_clk_inf(m, AhbGate0, AceGate);
+    sprintf_clk_inf(m, AhbGate0, EmacGate);
+    sprintf_clk_inf(m, AhbGate0, TsGate);
+    sprintf_clk_inf(m, AhbGate0, Spi0Gate);
+    sprintf_clk_inf(m, AhbGate0, Spi1Gate);
+    sprintf_clk_inf(m, AhbGate0, Spi2Gate);
+    sprintf_clk_inf(m, AhbGate0, Spi3Gate);
+    /* REMOVED */
+    //sprintf_clk_inf(m, AhbGate0, PataGate);
+    sprintf_clk_inf(m, AhbGate0, SataGate);
+    /* REMOVED */
+    //sprintf_clk_inf(m, AhbGate0, GpsGate);
+    sprintf_clk_inf(m, AhbGate0, StmrGate);
+
+    seq_printf(m, "\nAhbGate1 clk infor:\n");
+    sprintf_clk_inf(m, AhbGate1, VeGate);
+    sprintf_clk_inf(m, AhbGate1, TvdGate);
+    sprintf_clk_inf(m, AhbGate1, Tve0Gate);
+    sprintf_clk_inf(m, AhbGate1, Tve1Gate);
+    sprintf_clk_inf(m, AhbGate1, Lcd0Gate);
+    sprintf_clk_inf(m, AhbGate1, Lcd1Gate);
+    sprintf_clk_inf(m, AhbGate1, Csi0Gate);
+    sprintf_clk_inf(m, AhbGate1, Csi1Gate);
+    sprintf_clk_inf(m, AhbGate1, Hdmi1Gate);
+    sprintf_clk_inf(m, AhbGate1, HdmiDGate);
+    sprintf_clk_inf(m, AhbGate1, DeBe0Gate);
+    sprintf_clk_inf(m, AhbGate1, DeBe1Gate);
+    sprintf_clk_inf(m, AhbGate1, DeFe0Gate);
+    sprintf_clk_inf(m, AhbGate1, DeFe1Gate);
+    sprintf_clk_inf(m, AhbGate1, GmacGate);
+    sprintf_clk_inf(m, AhbGate1, MpGate);
+    sprintf_clk_inf(m, AhbGate1, Gpu3DGate);
+
+    seq_printf(m, "\nApb0Gate clk infor:\n");
+    sprintf_clk_inf(m, Apb0Gate, AddaGate);
+    sprintf_clk_inf(m, Apb0Gate, SpdifGate);
+    sprintf_clk_inf(m, Apb0Gate, Ac97Gate);
+    sprintf_clk_inf(m, Apb0Gate, Iis0Gate);
+    sprintf_clk_inf(m, Apb0Gate, Iis1Gate);
+    sprintf_clk_inf(m, Apb0Gate, PioGate);
+    sprintf_clk_inf(m, Apb0Gate, Ir0Gate);
+    sprintf_clk_inf(m, Apb0Gate, Ir1Gate);
+    sprintf_clk_inf(m, Apb0Gate, Iis2Gate);
+    sprintf_clk_inf(m, Apb0Gate, KeypadGate);
+
+    seq_printf(m, "\nApb1Gate clk infor:\n");
+    sprintf_clk_inf(m, Apb1Gate, Twi0Gate);
+    sprintf_clk_inf(m, Apb1Gate, Twi1Gate);
+    sprintf_clk_inf(m, Apb1Gate, Twi2Gate);
+    sprintf_clk_inf(m, Apb1Gate, Twi3Gate);
+    sprintf_clk_inf(m, Apb1Gate, CanGate);
+    sprintf_clk_inf(m, Apb1Gate, ScrGate);
+    sprintf_clk_inf(m, Apb1Gate, Ps20Gate);
+    sprintf_clk_inf(m, Apb1Gate, Ps21Gate);
+    sprintf_clk_inf(m, Apb1Gate, Twi4Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart0Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart1Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart2Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart3Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart4Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart5Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart6Gate);
+    sprintf_clk_inf(m, Apb1Gate, Uart7Gate);
+
+    seq_printf(m, "\nNandClk clk infor:\n");
+    sprintf_clk_inf(m, NandClk, ClkDiv);
+    sprintf_clk_inf(m, NandClk, ClkPreDiv);
+    sprintf_clk_inf(m, NandClk, ClkSrc);
+    sprintf_clk_inf(m, NandClk, SpecClkGate);
+
+    seq_printf(m, "\nMsClk clk infor:\n");
+    sprintf_clk_inf(m, MsClk, ClkDiv);
+    sprintf_clk_inf(m, MsClk, ClkPreDiv);
+    sprintf_clk_inf(m, MsClk, ClkSrc);
+    sprintf_clk_inf(m, MsClk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc0Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc0Clk, ClkDiv);
+    sprintf_clk_inf(m, SdMmc0Clk, ClkPreDiv);
+    sprintf_clk_inf(m, SdMmc0Clk, ClkSrc);
+    sprintf_clk_inf(m, SdMmc0Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc1Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc1Clk, ClkDiv);
+    sprintf_clk_inf(m, SdMmc1Clk, ClkPreDiv);
+    sprintf_clk_inf(m, SdMmc1Clk, ClkSrc);
+    sprintf_clk_inf(m, SdMmc1Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc2Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc2Clk, ClkDiv);
+    sprintf_clk_inf(m, SdMmc2Clk, ClkPreDiv);
+    sprintf_clk_inf(m, SdMmc2Clk, ClkSrc);
+    sprintf_clk_inf(m, SdMmc2Clk, SpecClkGate);
+
+    seq_printf(m, "\nSdMmc3Clk clk infor:\n");
+    sprintf_clk_inf(m, SdMmc3Clk, ClkDiv);
+    sprintf_clk_inf(m, SdMmc3Clk, ClkPreDiv);
+    sprintf_clk_inf(m, SdMmc3Clk, ClkSrc);
+    sprintf_clk_inf(m, SdMmc3Clk, SpecClkGate);
+
+    seq_printf(m, "\nTsClk clk infor:\n");
+    sprintf_clk_inf(m, TsClk, ClkDiv);
+    sprintf_clk_inf(m, TsClk, ClkPreDiv);
+    sprintf_clk_inf(m, TsClk, ClkSrc);
+    sprintf_clk_inf(m, TsClk, SpecClkGate);
+
+    seq_printf(m, "\nSsClk clk infor:\n");
+    sprintf_clk_inf(m, SsClk, ClkDiv);
+    sprintf_clk_inf(m, SsClk, ClkPreDiv);
+    sprintf_clk_inf(m, SsClk, ClkSrc);
+    sprintf_clk_inf(m, SsClk, SpecClkGate);
+
+    seq_printf(m, "\nSpi0Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi0Clk, ClkDiv);
+    sprintf_clk_inf(m, Spi0Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Spi0Clk, ClkSrc);
+    sprintf_clk_inf(m, Spi0Clk, SpecClkGate);
+
+    seq_printf(m, "\nSpi1Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi1Clk, ClkDiv);
+    sprintf_clk_inf(m, Spi1Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Spi1Clk, ClkSrc);
+    sprintf_clk_inf(m, Spi1Clk, SpecClkGate);
+
+    seq_printf(m, "\nSpi2Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi2Clk, ClkDiv);
+    sprintf_clk_inf(m, Spi2Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Spi2Clk, ClkSrc);
+    sprintf_clk_inf(m, Spi2Clk, SpecClkGate);
+
+    seq_printf(m, "\nPataClk clk infor:\n");
+    sprintf_clk_inf(m, PataClk, ClkDiv);
+    sprintf_clk_inf(m, PataClk, ClkPreDiv);
+    sprintf_clk_inf(m, PataClk, ClkSrc);
+    sprintf_clk_inf(m, PataClk, SpecClkGate);
+
+    seq_printf(m, "\nIr0Clk clk infor:\n");
+    sprintf_clk_inf(m, Ir0Clk, ClkDiv);
+    sprintf_clk_inf(m, Ir0Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Ir0Clk, ClkSrc);
+    sprintf_clk_inf(m, Ir0Clk, SpecClkGate);
+
+    seq_printf(m, "\nIr1Clk clk infor:\n");
+    sprintf_clk_inf(m, Ir1Clk, ClkDiv);
+    sprintf_clk_inf(m, Ir1Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Ir1Clk, ClkSrc);
+    sprintf_clk_inf(m, Ir1Clk, SpecClkGate);
+
+    seq_printf(m, "\nI2sClk clk infor:\n");
+    sprintf_clk_inf(m, I2s0Clk, ClkDiv);
+    sprintf_clk_inf(m, I2s0Clk, SpecClkGate);
+
+
+    seq_printf(m, "\nAc97Clk clk infor:\n");
+    sprintf_clk_inf(m, Ac97Clk, ClkDiv);
+    sprintf_clk_inf(m, Ac97Clk, SpecClkGate);
+
+    seq_printf(m, "\nSpdifClk clk infor:\n");
+    sprintf_clk_inf(m, SpdifClk, ClkDiv);
+    sprintf_clk_inf(m, SpdifClk, SpecClkGate);
+
+    seq_printf(m, "\nKeyPadClk clk infor:\n");
+    sprintf_clk_inf(m, KeyPadClk, ClkDiv);
+    sprintf_clk_inf(m, KeyPadClk, ClkPreDiv);
+    sprintf_clk_inf(m, KeyPadClk, ClkSrc);
+    sprintf_clk_inf(m, KeyPadClk, SpecClkGate);
+
+    seq_printf(m, "\nSataClk clk infor:\n");
+    sprintf_clk_inf(m, SataClk, ClkSrc);
+    sprintf_clk_inf(m, SataClk, SpecClkGate);
+
+    seq_printf(m, "\nUsbClk clk infor:\n");
+    sprintf_clk_inf(m, UsbClk, UsbPhy0Rst);
+    sprintf_clk_inf(m, UsbClk, UsbPhy1Rst);
+    sprintf_clk_inf(m, UsbClk, UsbPhy2Rst);
+    /* REMOVED */
+    //sprintf_clk_inf(m, UsbClk, OHCIClkSrc);
+    sprintf_clk_inf(m, UsbClk, OHCI0SpecClkGate);
+    sprintf_clk_inf(m, UsbClk, OHCI1SpecClkGate);
+    sprintf_clk_inf(m, UsbClk, PhySpecClkGate);
+
+    /* REMOVED */
+    //seq_printf(m, "\nGpsClk clk infor:\n");
+    //sprintf_clk_inf(m, GpsClk, ClkDivRatio);
+    //sprintf_clk_inf(m, GpsClk, ClkSrc);
+    //sprintf_clk_inf(m, GpsClk, Reset);
+    //sprintf_clk_inf(m, GpsClk, SpecClkGate);
+
+    seq_printf(m, "\nSpi3Clk clk infor:\n");
+    sprintf_clk_inf(m, Spi3Clk, ClkDiv);
+    sprintf_clk_inf(m, Spi3Clk, ClkPreDiv);
+    sprintf_clk_inf(m, Spi3Clk, ClkSrc);
+    sprintf_clk_inf(m, Spi3Clk, SpecClkGate);
+
+    seq_printf(m, "\nI2s1Clk clk infor:\n");
+    sprintf_clk_inf(m, I2s1Clk, ClkDiv);
+    sprintf_clk_inf(m, I2s1Clk, SpecClkGate);
+
+    seq_printf(m, "\nI2s2Clk clk infor:\n");
+    sprintf_clk_inf(m, I2s2Clk, ClkDiv);
+    sprintf_clk_inf(m, I2s2Clk, SpecClkGate);
+
+    seq_printf(m, "\nDramGate clk infor:\n");
+    sprintf_clk_inf(m, DramGate, VeGate);
+    sprintf_clk_inf(m, DramGate, Csi0Gate);
+    sprintf_clk_inf(m, DramGate, Csi1Gate);
+    sprintf_clk_inf(m, DramGate, TsGate);
+    sprintf_clk_inf(m, DramGate, TvdGate);
+    sprintf_clk_inf(m, DramGate, Tve0Gate);
+    sprintf_clk_inf(m, DramGate, Tve1Gate);
+    sprintf_clk_inf(m, DramGate, ClkOutputEn);
+    sprintf_clk_inf(m, DramGate, DeFe0Gate);
+    sprintf_clk_inf(m, DramGate, DeFe1Gate);
+    sprintf_clk_inf(m, DramGate, DeBe0Gate);
+    sprintf_clk_inf(m, DramGate, DeBe1Gate);
+    sprintf_clk_inf(m, DramGate, DeMpGate);
+    sprintf_clk_inf(m, DramGate, AceGate);
+
+    seq_printf(m, "\nDeBe0Clk clk infor:\n");
+    sprintf_clk_inf(m, DeBe0Clk, ClkDiv);
+    sprintf_clk_inf(m, DeBe0Clk, ClkSrc);
+    sprintf_clk_inf(m, DeBe0Clk, Reset);
+    sprintf_clk_inf(m, DeBe0Clk, SpecClkGate);
+
+    seq_printf(m, "\nDeBe1Clk clk infor:\n");
+    sprintf_clk_inf(m, DeBe1Clk, ClkDiv);
+    sprintf_clk_inf(m, DeBe1Clk, ClkSrc);
+    sprintf_clk_inf(m, DeBe1Clk, Reset);
+    sprintf_clk_inf(m, DeBe1Clk, SpecClkGate);
+
+    seq_printf(m, "\nDeFe0Clk clk infor:\n");
+    sprintf_clk_inf(m, DeFe0Clk, ClkDiv);
+    sprintf_clk_inf(m, DeFe0Clk, ClkSrc);
+    sprintf_clk_inf(m, DeFe0Clk, Reset);
+    sprintf_clk_inf(m, DeFe0Clk, SpecClkGate);
+
+    seq_printf(m, "\nDeFe1Clk clk infor:\n");
+    sprintf_clk_inf(m, DeFe1Clk, ClkDiv);
+    sprintf_clk_inf(m, DeFe1Clk, ClkSrc);
+    sprintf_clk_inf(m, DeFe1Clk, Reset);
+    sprintf_clk_inf(m, DeFe1Clk, SpecClkGate);
+
+    seq_printf(m, "\nDeMpClk clk infor:\n");
+    sprintf_clk_inf(m, DeMpClk, ClkDiv);
+    sprintf_clk_inf(m, DeMpClk, ClkSrc);
+    sprintf_clk_inf(m, DeMpClk, Reset);
+    sprintf_clk_inf(m, DeMpClk, SpecClkGate);
+
+    seq_printf(m, "\nLcd0Ch0Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd0Ch0Clk, ClkSrc);
+    sprintf_clk_inf(m, Lcd0Ch0Clk, Reset);
+    sprintf_clk_inf(m, Lcd0Ch0Clk, SpecClkGate);
+
+    seq_printf(m, "\nLcd1Ch0Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd1Ch0Clk, ClkSrc);
+    sprintf_clk_inf(m, Lcd1Ch0Clk, Reset);
+    sprintf_clk_inf(m, Lcd1Ch0Clk, SpecClkGate);
+
+    seq_printf(m, "\nCsiIspClk clk infor:\n");
+    sprintf_clk_inf(m, CsiIspClk, ClkDiv);
+    sprintf_clk_inf(m, CsiIspClk, ClkSrc);
+    sprintf_clk_inf(m, CsiIspClk, SpecClkGate);
+
+    seq_printf(m, "\nTvdClk clk infor:\n");
+    sprintf_clk_inf(m, TvdClk, Clk1Div);
+    sprintf_clk_inf(m, TvdClk, Clk1Src);
+    sprintf_clk_inf(m, TvdClk, Clk1Gate);
+    sprintf_clk_inf(m, TvdClk, Clk2Div);
+    sprintf_clk_inf(m, TvdClk, Clk2Src);
+    sprintf_clk_inf(m, TvdClk, Clk2Gate);
+
+    seq_printf(m, "\nLcd0Ch1Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd0Ch1Clk, ClkDiv);
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk1Src);
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk1Gate);
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk2Src);
+    sprintf_clk_inf(m, Lcd0Ch1Clk, SpecClk2Gate);
+
+    seq_printf(m, "\nLcd1Ch1Clk clk infor:\n");
+    sprintf_clk_inf(m, Lcd1Ch1Clk, ClkDiv);
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk1Src);
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk1Gate);
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk2Src);
+    sprintf_clk_inf(m, Lcd1Ch1Clk, SpecClk2Gate);
+
+    seq_printf(m, "\nCsi0Clk clk infor:\n");
+    sprintf_clk_inf(m, Csi0Clk, ClkDiv);
+    sprintf_clk_inf(m, Csi0Clk, ClkSrc);
+    sprintf_clk_inf(m, Csi0Clk, Reset);
+    sprintf_clk_inf(m, Csi0Clk, SpecClkGate);
+
+    seq_printf(m, "\nCsi1Clk clk infor:\n");
+    sprintf_clk_inf(m, Csi1Clk, ClkDiv);
+    sprintf_clk_inf(m, Csi1Clk, ClkSrc);
+    sprintf_clk_inf(m, Csi1Clk, Reset);
+    sprintf_clk_inf(m, Csi1Clk, SpecClkGate);
+
+    seq_printf(m, "\nVeClk clk infor:\n");
+    sprintf_clk_inf(m, VeClk, Reset);
+    sprintf_clk_inf(m, VeClk, ClkDiv);
+    sprintf_clk_inf(m, VeClk, SpecClkGate);
+
+    seq_printf(m, "\nAddaClk clk infor:\n");
+    sprintf_clk_inf(m, AddaClk, SpecClkGate);
+
+    seq_printf(m, "\nAvsClk clk infor:\n");
+    sprintf_clk_inf(m, AvsClk, SpecClkGate);
+
+    seq_printf(m, "\nAceClk clk infor:\n");
+    sprintf_clk_inf(m, AceClk, ClkDiv);
+    sprintf_clk_inf(m, AceClk, Reset);
+    sprintf_clk_inf(m, AceClk, ClkSrc);
+    sprintf_clk_inf(m, AceClk, SpecClkGate);
+
+    seq_printf(m, "\nLvdsClk clk infor:\n");
+    sprintf_clk_inf(m, LvdsClk, Reset);
+
+    seq_printf(m, "\nHdmiClk clk infor:\n");
+    sprintf_clk_inf(m, HdmiClk, ClkDiv);
+    sprintf_clk_inf(m, HdmiClk, ClkSrc);
+    sprintf_clk_inf(m, HdmiClk, SpecClkGate);
+
+    seq_printf(m, "\nMaliClk clk infor:\n");
+    sprintf_clk_inf(m, MaliClk, ClkDiv);
+    sprintf_clk_inf(m, MaliClk, ClkSrc);
+    sprintf_clk_inf(m, MaliClk, Reset);
+    sprintf_clk_inf(m, MaliClk, SpecClkGate);
+
+    seq_printf(m, "\nMBusClk clk infor:\n");
+    sprintf_clk_inf(m, MBusClk, ClkDivM);
+    sprintf_clk_inf(m, MBusClk, ClkDivN);
+    sprintf_clk_inf(m, MBusClk, ClkSrc);
+    sprintf_clk_inf(m, MBusClk, ClkGate);
+
+    seq_printf(m, "\nGmacClk clk infor:\n");
+    sprintf_clk_inf(m, GmacClk, TxClkSrc);
+    sprintf_clk_inf(m, GmacClk, PhyIT);
+    sprintf_clk_inf(m, GmacClk, TxClkInv);
+    sprintf_clk_inf(m, GmacClk, RxClkInv);
+    sprintf_clk_inf(m, GmacClk, RxDlyChain);
+    sprintf_clk_inf(m, GmacClk, ClkDiv);
+
+    seq_printf(m, "\nClkOutA clk infor:\n");
+    sprintf_clk_inf(m, ClkOutA, ClkDivM);
+    sprintf_clk_inf(m, ClkOutA, ClkDivN);
+    sprintf_clk_inf(m, ClkOutA, ClkSrc);
+    sprintf_clk_inf(m, ClkOutA, ClkEn);
+
+    seq_printf(m, "\nClkOutB clk infor:\n");
+    sprintf_clk_inf(m, ClkOutB, ClkDivM);
+    sprintf_clk_inf(m, ClkOutB, ClkDivN);
+    sprintf_clk_inf(m, ClkOutB, ClkSrc);
+    sprintf_clk_inf(m, ClkOutB, ClkEn);
+
+    return 0;
+}
+
+
+static int ccmu_stats_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, ccmu_stats_show, NULL);
+}
+
+static const struct file_operations ccmu_dbg_fops = {
+    .owner = THIS_MODULE,
+    .open = ccmu_stats_open,
+    .read = seq_read,
+    .llseek = seq_lseek,
+    .release = single_release,
+};
+
+static int __init ccu_dbg_init(void)
+{
+    /* create /proc/ccmu */
+    proc_create("ccmu", S_IRUGO, NULL, &ccmu_dbg_fops);
+    return 0;
+}
+
+static void  __exit ccu_dbg_exit(void)
+{
+    remove_proc_entry("ccmu", NULL);
+}
+
+core_initcall(ccu_dbg_init);
+module_exit(ccu_dbg_exit);
+
+#endif
diff --git a/arch/arm/mach-sun7i/clock/ccu_sysfs.c b/arch/arm/mach-sun7i/clock/ccu_sysfs.c
new file mode 100644
index 0000000..0297465
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/ccu_sysfs.c
@@ -0,0 +1,477 @@
+/*
+ * arch/arm/mach-sun6i/clock/ccu_sysfs.c
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+
+#include "ccm_i.h"
+#include "ccu_sysfs.h"
+
+/* __ccu_export/export_store/ccu_attr_group/clk_get */
+
+static DEFINE_MUTEX(sysfs_lock);
+
+/* clock handle for sunxi clock */
+struct ccu_sysfs_handle {
+    bool                exported;
+    char                name[256];
+    __aw_ccu_clk_id_e   id;
+    struct clk          *clk;
+};
+
+static struct ccu_sysfs_handle g_clk_handle[AW_CCU_CLK_CNT];
+
+ssize_t ccu_export_store(struct class *class,
+                         struct class_attribute *attr,
+                         const char *buf, size_t len);
+ssize_t ccu_unexport_store(struct class *class,
+                           struct class_attribute *attr,
+                           const char *buf, size_t len);
+
+static struct class_attribute ccu_class_attrs[] = {
+    __ATTR(export, 0200, NULL, ccu_export_store),
+    __ATTR(unexport, 0200, NULL, ccu_unexport_store),
+    __ATTR_NULL,
+};
+
+static struct class ccu_class = {
+    .name =         "ccu",
+    .owner =        THIS_MODULE,
+    .class_attrs =  ccu_class_attrs,
+};
+
+static __aw_ccu_clk_id_e __get_clock_id(char *clock_name)
+{
+    u32 i = 0;
+
+    for (i = 0; i < (u32)AW_CCU_CLK_CNT; i++)
+        if (true == sysfs_streq(aw_ccu_clk_tbl[i].name, (const char *)clock_name))
+            return aw_ccu_clk_tbl[i].id;
+
+    CCU_ERR("%s: could not find id for clock %s\n", __func__, clock_name);
+    return AW_SYS_CLK_NONE;
+}
+
+static int __match_export(struct device *dev, void *data)
+{
+    return dev_get_drvdata(dev) == data;
+}
+
+static ssize_t ccu_rate_show(struct device *dev,
+                             struct device_attribute *attr, char *buf)
+{
+    unsigned long rate = 0;
+    struct ccu_sysfs_handle *pclk_handle = dev_get_drvdata(dev);
+
+    if (NULL == pclk_handle->clk) {
+        CCU_ERR("%s: clk is NULL\n", __func__);
+        return -EINVAL;
+    }
+
+    rate = clk_get_rate(pclk_handle->clk);
+    CCU_DBG("%s: get rate %d\n", __func__, (int)rate);
+
+    return sprintf(buf, "%d\n", (int)rate);
+}
+
+static ssize_t ccu_rate_store(struct device *dev,
+                              struct device_attribute *attr, const char *buf, size_t size)
+{
+    u32 usign = 0;
+    long itemp = 0;
+    struct ccu_sysfs_handle *pclk_handle = dev_get_drvdata(dev);
+
+    CCU_ASSERT_GOTO(NULL != pclk_handle->clk, usign, end);
+
+    CCU_ASSERT_GOTO(strict_strtol(buf, 0, &itemp) >= 0, usign, end);
+    CCU_DBG("%s: rate to set is %d\n", __func__, (int)itemp);
+
+    CCU_ASSERT_GOTO(0 == clk_set_rate(pclk_handle->clk, itemp), usign, end);
+    CCU_DBG("%s: clk_set_rate success\n", __func__);
+
+end:
+    if (0 != usign) {
+        CCU_ERR("%s: line %d\n", __func__, usign);
+        return -EINVAL;
+    }
+    return size;
+}
+static DEVICE_ATTR(rate, 0666, ccu_rate_show, ccu_rate_store);
+
+static ssize_t ccu_reset_store(struct device *dev,
+                               struct device_attribute *attr, const char *buf, size_t size)
+{
+    u32 usign = 0;
+    long itemp = 0;
+    struct ccu_sysfs_handle *pclk_handle = dev_get_drvdata(dev);
+
+    CCU_ASSERT_GOTO(NULL != pclk_handle->clk, usign, end);
+
+    CCU_ASSERT_GOTO(strict_strtol(buf, 0, &itemp) >= 0, usign, end);
+    CCU_DBG("%s: para itemp is %d\n", __func__, (int)itemp);
+
+    switch (itemp) {
+        case 1: /* reset */
+            CCU_ASSERT_GOTO(0 == clk_reset(pclk_handle->clk, 1), usign, end);
+            CCU_DBG("%s: clk_reset - RESET success\n", __func__);
+            break;
+        case 0: /* nreset */
+            CCU_ASSERT_GOTO(0 == clk_reset(pclk_handle->clk, 0), usign, end);
+            CCU_DBG("%s: clk_reset - NRESET success\n", __func__);
+            break;
+        default:
+            usign = __LINE__;
+            break;
+    }
+
+end:
+    if (0 != usign) {
+        CCU_ERR("%s: line %d\n", __func__, (int)usign);
+        return -EINVAL;
+    }
+
+    return size;
+}
+static DEVICE_ATTR(reset, 0222, NULL, ccu_reset_store);
+
+static ssize_t ccu_enable_store(struct device *dev,
+                                struct device_attribute *attr, const char *buf, size_t size)
+{
+    u32 usign = 0;
+    long itemp = 0;
+    struct ccu_sysfs_handle *pclk_handle = dev_get_drvdata(dev);
+
+    CCU_ASSERT_GOTO(NULL != pclk_handle->clk, usign, end);
+
+    CCU_ASSERT_GOTO(strict_strtol(buf, 0, &itemp) >= 0, usign, end);
+    CCU_DBG("%s: para itemp is %d\n", __func__, (int)itemp);
+
+    switch (itemp) {
+        case 1: /* enable clock */
+            CCU_ASSERT_GOTO(0 == clk_enable(pclk_handle->clk), usign, end);
+            CCU_DBG("%s: clk_enable success\n", __func__);
+            break;
+        case 0: /* disable clock */
+            clk_disable(pclk_handle->clk);
+            break;
+        default:
+            usign = __LINE__;
+            break;
+    }
+
+end:
+    if (0 != usign) {
+        CCU_ERR("%s: line %d\n", __func__, (int)usign);
+        return -EINVAL;
+    }
+    return size;
+}
+static DEVICE_ATTR(enable, 0222, NULL, ccu_enable_store);
+
+static ssize_t ccu_parent_show(struct device *dev,
+                               struct device_attribute *attr, char *buf)
+{
+    u32 usign = 0;
+    struct clk *clk_parent = NULL;
+    struct ccu_sysfs_handle *pclk_handle = dev_get_drvdata(dev);
+
+    if (NULL == pclk_handle->clk) {
+        usign = __LINE__;
+        goto err;
+    }
+
+    clk_parent = clk_get_parent(pclk_handle->clk);
+    if (NULL == clk_parent) {
+        usign = __LINE__;
+        goto err;
+    }
+    CCU_DBG("%s: get parent name %s\n", __func__, clk_parent->aw_clk->name);
+
+    return sprintf(buf, "%s\n", clk_parent->aw_clk->name);
+
+err:
+    CCU_ERR("%s: line %d\n", __func__, (int)usign);
+    return -EINVAL;
+}
+
+static ssize_t ccu_parent_store(struct device *dev,
+                                struct device_attribute *attr, const char *buf, size_t size)
+{
+    u32 usign = 0;
+    struct clk  *parent = NULL;
+    __aw_ccu_clk_id_e   clk_id = AW_SYS_CLK_NONE;
+    struct ccu_sysfs_handle *pclk_handle = dev_get_drvdata(dev);
+
+    if (NULL == pclk_handle->clk) {
+        usign = __LINE__;
+        goto end;
+    }
+
+    clk_id = __get_clock_id((char *)buf);
+    if (AW_SYS_CLK_NONE == clk_id) {
+        usign = __LINE__;
+        goto end;
+    }
+    CCU_DBG("%s: parent name %s, id %d\n", __func__, buf, (int)clk_id);
+
+    parent = &aw_clock[clk_id];
+    if (0 != clk_set_parent(pclk_handle->clk, parent)) {
+        usign = __LINE__;
+        goto end;
+    }
+    CCU_DBG("%s: clk_set_parent success\n", __func__);
+
+end:
+    if (0 != usign) {
+        CCU_ERR("%s: line %d\n", __func__, (int)usign);
+        return -EINVAL;
+    }
+    return size;
+}
+static DEVICE_ATTR(parent, 0666, ccu_parent_show, ccu_parent_store);
+
+static ssize_t ccu_get_store(struct device *dev,
+                             struct device_attribute *attr, const char *buf, size_t size)
+{
+    int i = -1;
+    struct ccu_sysfs_handle *pclk_handle = dev_get_drvdata(dev);
+
+    if (strict_strtol(buf, 0, (long *)&i) < 0) {
+        CCU_ERR("%s: strict_strtol %s failed\n", __func__, buf);
+        return -EINVAL;
+    }
+
+    if (0 == i) { /* to clk_put */
+        if (NULL == pclk_handle->clk) {
+            CCU_ERR("%s: clock %s not got yet\n", __func__, pclk_handle->name);
+            return -EINVAL;
+        } else {
+            clk_put(pclk_handle->clk);
+            pclk_handle->clk = NULL;
+        }
+    } else if (1 == i) { /* to clk_get */
+        if (NULL != pclk_handle->clk) {
+            CCU_ERR("%s: clock %s already got, handle 0x%08x\n", __func__,
+                    pclk_handle->name, (u32)pclk_handle->clk);
+            return -EINVAL;
+        } else {
+            pclk_handle->clk = clk_get(NULL, pclk_handle->name);
+            if (IS_ERR(pclk_handle->clk)) {
+                CCU_ERR("%s: get clock %s failed\n", __func__, pclk_handle->name);
+                return -EINVAL;
+            }
+        }
+    } else {
+        CCU_ERR("%s: para %s invalid\n", __func__, buf);
+        return -EINVAL;
+    }
+
+    return size;
+}
+static DEVICE_ATTR(get, 0222, NULL, ccu_get_store);
+
+static const struct attribute *ccu_attrs[] = {
+    &dev_attr_get.attr,
+    &dev_attr_parent.attr,
+    &dev_attr_rate.attr,
+    &dev_attr_enable.attr,
+    &dev_attr_reset.attr,
+    NULL,
+};
+
+static const struct attribute_group ccu_attr_group = {
+    .attrs = (struct attribute **)ccu_attrs,
+};
+
+bool __ccu_export(char *clock_name, __aw_ccu_clk_id_e clock_id)
+{
+    int status = -EINVAL;
+    struct device   *dev = NULL;
+
+    /* get clock id and name for g_clk_handle[i] */
+    g_clk_handle[clock_id].id = clock_id;
+    strcpy(g_clk_handle[clock_id].name, clock_name);
+    CCU_DBG("%s: g_clk_handle[i] - id %d, name %s\n", __func__,
+            (int)clock_id, g_clk_handle[clock_id].name);
+
+    /* create device dir */
+    dev = device_create(&ccu_class, NULL, MKDEV(0, 0), (void *)&g_clk_handle[clock_id], clock_name);
+    if (!IS_ERR(dev)) {
+        status = sysfs_create_group(&dev->kobj, &ccu_attr_group);
+        if (status != 0) {
+            device_unregister(dev);
+            CCU_ERR("%s: sysfs_create_group failed, status %d\n", __func__, status);
+        }
+    } else
+        status = PTR_ERR(dev);
+
+    if (status) {
+        CCU_ERR("%s: %s, status %d\n", __func__, clock_name, status);
+        return false;
+    }
+
+    CCU_DBG("%s: %s success\n", __func__, clock_name);
+    return true;
+}
+
+bool __ccu_unexport(char *clk_name, __aw_ccu_clk_id_e clk_id)
+{
+    u32     usign = 0;
+    struct device   *dev = NULL;
+
+    /* must release clock handle first, echo 0 > get */
+    CCU_ASSERT_GOTO(NULL == g_clk_handle[clk_id].clk, usign, end);
+
+    dev = class_find_device(&ccu_class, NULL, &g_clk_handle[clk_id], __match_export);
+    if (dev) {
+        CCU_DBG("%s: class_find_device success\n", __func__);
+        put_device(dev);
+        device_unregister(dev);
+    } else {
+        usign = __LINE__;
+        goto end;
+    }
+
+end:
+    if (0 != usign) {
+        CCU_ERR("%s: line %d\n", __func__, (int)usign);
+        return false;
+    }
+    return true;
+}
+
+/**
+ * sysfs_to_str - convert sysfs buf string to standard string
+ * @old_str:    old sysf string, end up with '\n'
+ * @new_str:    store the new string converted.
+ * @new_buf_size: length of new_str buffer.
+ *
+ * return true if success, false if failed.
+ */
+bool inline sysfs_to_str(const char *old_str, char *new_str, int new_buf_size)
+{
+    int i = 0;
+
+    while ('\0' != *old_str && '\n' != *old_str) {
+        *new_str++ = *old_str++;
+        if (++i >= new_buf_size)
+            return false;
+    }
+    *new_str = '\0';
+    return true;
+}
+
+ssize_t ccu_export_store(struct class *class,
+                         struct class_attribute *attr,
+                         const char *buf, size_t len)
+{
+    char buf_temp[256] = {0};
+    __aw_ccu_clk_id_e clk_id = AW_SYS_CLK_NONE;
+
+    /* get clock id and name(convert from sysfs str) */
+    if (false == sysfs_to_str(buf, buf_temp, sizeof(buf_temp))) {
+        CCU_ERR("%s: sysfs_to_str failed, buf %s\n", __func__, buf);
+        return -EINVAL;
+    }
+    clk_id = __get_clock_id(buf_temp);
+    if (AW_SYS_CLK_NONE == clk_id) {
+        CCU_ERR("%s: invalid clock name %s\n", __func__, buf_temp);
+        return -EINVAL;
+    }
+    CCU_DBG("%s: clock name %s, clock id %d\n", __func__, buf_temp, (int)clk_id);
+
+    mutex_lock(&sysfs_lock);
+
+    /* check if exported */
+    if (true == g_clk_handle[clk_id].exported) {
+        mutex_unlock(&sysfs_lock);
+        CCU_ERR("%s: clock %s already exported\n", __func__, buf_temp);
+        return -EINVAL;
+    }
+
+    /* export clock */
+    if (false == __ccu_export(buf_temp, clk_id)) {
+        mutex_unlock(&sysfs_lock);
+        CCU_ERR("%s: __ccu_export clock %s err\n", __func__, buf_temp);
+        return -EINVAL;
+    }
+
+    /* change exported flag to true */
+    g_clk_handle[clk_id].exported = true;
+
+    mutex_unlock(&sysfs_lock);
+    CCU_DBG("%s %s success\n", __func__, buf_temp);
+    return len;
+}
+
+ssize_t ccu_unexport_store(struct class *class,
+                           struct class_attribute *attr,
+                           const char *buf, size_t len)
+{
+    char buf_temp[256] = {0};
+    __aw_ccu_clk_id_e clk_id = AW_SYS_CLK_NONE;
+
+    /* get clock id and name(convert from sysfs str) */
+    if (false == sysfs_to_str(buf, buf_temp, sizeof(buf_temp))) {
+        CCU_ERR("%s: sysfs_to_str failed, buf %s\n", __func__, buf);
+        return -EINVAL;
+    }
+    clk_id = __get_clock_id(buf_temp);
+    if (AW_SYS_CLK_NONE == clk_id) {
+        CCU_ERR("%s: invalid clock name %s\n", __func__, buf_temp);
+        return -EINVAL;
+    }
+    CCU_DBG("%s: clock name %s, clock id %d\n", __func__, buf_temp, (int)clk_id);
+
+    mutex_lock(&sysfs_lock);
+
+    /* check if unexported */
+    if (false == g_clk_handle[clk_id].exported) {
+        mutex_unlock(&sysfs_lock);
+        CCU_ERR("%s: clock %s already un-exported\n", __func__, buf_temp);
+        return -EINVAL;
+    }
+
+    /* unexport clock */
+    if (false == __ccu_unexport(buf_temp, clk_id)) {
+        mutex_unlock(&sysfs_lock);
+        CCU_ERR("%s: __ccu_unexport clock %s err\n", __func__, buf_temp);
+        return -EINVAL;
+    }
+
+    /* change exported flag to false */
+    g_clk_handle[clk_id].exported = false;
+
+    mutex_unlock(&sysfs_lock);
+    CCU_DBG("%s: clock %s success\n", __func__, buf_temp);
+    return len;
+}
+
+static int __init ccu_sysfs_init(void)
+{
+    int status;
+
+    /* create /sys/class/ccu/ */
+    status = class_register(&ccu_class);
+    if (status < 0)
+        CCU_ERR("%s: status %d\n", __func__, status);
+    else
+        CCU_DBG("%s successfully\n", __func__);
+
+    return status;
+}
+postcore_initcall(ccu_sysfs_init);
diff --git a/arch/arm/mach-sun7i/clock/ccu_sysfs.h b/arch/arm/mach-sun7i/clock/ccu_sysfs.h
new file mode 100644
index 0000000..a4811fd
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/ccu_sysfs.h
@@ -0,0 +1,19 @@
+/*
+ * arch/arm/mach-sun6i/clock/ccu_sysfs.h
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __CCU_SYSFS_H
+#define __CCU_SYSFS_H
+
+#define CCU_ASSERT_GOTO(x, errline, pos) if (!(x)) {errline = __LINE__; goto pos;}
+
+#endif
diff --git a/arch/arm/mach-sun7i/clock/clock.c b/arch/arm/mach-sun7i/clock/clock.c
new file mode 100644
index 0000000..26fe462
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/clock.c
@@ -0,0 +1,301 @@
+/*
+ * arch/arm/mach-sun7i/clock/clock.c
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <mach/includes.h>
+#include <plat/sys_config.h>
+
+#include "ccm_i.h"
+
+__ccu_clk_t aw_clock[AW_CCU_CLK_CNT];
+
+static struct clk_lookup lookups[AW_CCU_CLK_CNT];
+
+/*
+ * clock manage initialize.
+ *
+ * Returns 0.
+ */
+int clk_init(void)
+{
+    int i, val;
+    struct clk *clk;
+
+    CCU_INF("aw clock manager init\n");
+
+    /* initialize clock controller unit */
+    aw_ccu_init();
+
+    /* clear the data structure */
+    memset((void *)aw_clock, 0, sizeof(aw_clock));
+    memset((void *)lookups, 0, sizeof(lookups));
+
+    for (i = 0; i < AW_CCU_CLK_CNT; i++) {
+        /* initiate clock */
+        if (aw_ccu_get_clk(i, &aw_clock[i]) != 0) {
+            CCU_ERR("try to get clock %d informaiton failed\n", i);
+        }
+
+        /* init clock spin lock */
+        CCU_LOCK_INIT(&aw_clock[i].lock);
+
+        /* register clk device */
+        lookups[i].con_id = aw_clock[i].aw_clk->name;
+        lookups[i].clk    = &aw_clock[i];
+        clkdev_add(&lookups[i]);
+    }
+
+    /* initiate some clocks */
+    lookups[AW_MOD_CLK_SMPTWD].dev_id = "smp_twd";
+
+    /* config plls */
+    if (script_parser_fetch("clock", "pll3", &val, sizeof(int)) == 0) {
+        CCU_INF("script config pll3 to %dMHz\n", val);
+        if (val >= 27 && val <= 381) {
+            clk = &aw_clock[AW_SYS_CLK_PLL3];
+            clk_enable(clk);
+            clk_set_rate(clk, val * 1000000);
+        } else {
+            CCU_ERR("    invalid value, must in 27MHz ~ 381MHz\n");
+        }
+    }
+
+    if (script_parser_fetch("clock", "pll4", &val, sizeof(int)) == 0) {
+        CCU_INF("script config pll4 to %dMHz\n", val);
+        if (val >= 240 && val <= 2000) {
+            clk = &aw_clock[AW_SYS_CLK_PLL4];
+            clk_enable(clk);
+            clk_set_rate(clk, val * 1000000);
+        } else {
+            CCU_ERR("    invalid value, must in 240MHz ~ 2GHz\n");
+        }
+    }
+
+    clk = &aw_clock[AW_SYS_CLK_PLL6];
+    if (script_parser_fetch("clock", "pll6", &val, sizeof(int)) == 0) {
+        CCU_INF("script config pll6 to %dMHz\n", val);
+        if (val < 240 || val > 2000) {
+            CCU_ERR("    invalid value, must in 240MHz ~ 2GHz\n");
+            val = 600;
+            CCU_INF("    change to %dMHz\n", val);
+        }
+    } else {
+        val = 600;
+    }
+    clk_enable(clk);
+    clk_set_rate(clk, val * 1000000);
+
+    if (script_parser_fetch("clock", "pll7", &val, sizeof(int)) == 0) {
+        CCU_INF("script config pll7 to %dMHz\n", val);
+        if (val >= 27 && val <= 381) {
+            clk = &aw_clock[AW_SYS_CLK_PLL7];
+            clk_enable(clk);
+            clk_set_rate(clk, val * 1000000);
+        } else {
+            CCU_ERR("    invalid value, must in 27MHz ~ 381MHz\n");
+        }
+    }
+
+    if (script_parser_fetch("clock", "pll8", &val, sizeof(int)) == 0) {
+        CCU_INF("script config pll8 to %dMHz\n", val);
+        if (val >= 240 && val <= 2000) {
+            clk = &aw_clock[AW_SYS_CLK_PLL8];
+            clk_enable(clk);
+            clk_set_rate(clk, val * 1000000);
+        } else {
+            CCU_ERR("    invalid value, must in 240MHz ~ 2GHz\n");
+        }
+    }
+
+    return 0;
+}
+arch_initcall(clk_init);
+
+int clk_enable(struct clk *clk)
+{
+    DEFINE_FLAGS(flags);
+
+    if ((clk == NULL) || IS_ERR(clk)) {
+        CCU_ERR("%s: invalid handle\n", __func__);
+        return -EINVAL;
+    }
+
+    CCU_LOCK(&clk->lock, flags);
+    if (0 == clk->enable) {
+        clk->ops->set_status(clk->aw_clk->id, AW_CCU_CLK_ON);
+    }
+    clk->enable++;
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_DBG("%s: %s is enabled, count #%d\n", __func__, clk->aw_clk->name, clk->enable);
+
+    return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+    DEFINE_FLAGS(flags);
+
+    if (clk == NULL || IS_ERR(clk)) {
+        CCU_ERR("%s: invalid handle\n", __func__);
+        return;
+    }
+
+    CCU_LOCK(&clk->lock, flags);
+    if (clk->enable)
+        clk->enable--;
+    if (clk->enable) {
+        CCU_UNLOCK(&clk->lock, flags);
+        CCU_DBG("%s: %s is disabled, count #%d\n", __func__, clk->aw_clk->name, clk->enable);
+        return;
+    }
+    clk->ops->set_status(clk->aw_clk->id, AW_CCU_CLK_OFF);
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_DBG("%s: %s is disabled, count #%d\n", __func__, clk->aw_clk->name, clk->enable);
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+    unsigned long ret = 0;
+    DEFINE_FLAGS(flags);
+
+    if ((clk == NULL) || IS_ERR(clk)) {
+        CCU_ERR("%s: invalid handle\n", __func__);
+        return 0;
+    }
+
+    CCU_LOCK(&clk->lock, flags);
+    clk->aw_clk->rate = clk->ops->get_rate(clk->aw_clk->id);
+    ret = (unsigned long)clk->aw_clk->rate;
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_DBG("%s: %s current rate is %llu\n", __func__, clk->aw_clk->name, clk->aw_clk->rate);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+    DEFINE_FLAGS(flags);
+
+    if (clk == NULL || IS_ERR(clk)) {
+        CCU_ERR("%s: invalid handle\n", __func__);
+        return -EINVAL;
+    }
+
+    CCU_LOCK(&clk->lock, flags);
+    if (clk->ops->set_rate(clk->aw_clk->id, rate) == 0) {
+        clk->aw_clk->rate = clk->ops->get_rate(clk->aw_clk->id);
+        CCU_UNLOCK(&clk->lock, flags);
+        CCU_DBG("%s: set %s rate to %lu, actual rate is %llu\n", __func__,
+                clk->aw_clk->name, rate, clk->aw_clk->rate);
+        return 0;
+    }
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_ERR("%s: set %s rate to %lu failed\n", __func__,
+            clk->aw_clk->name, rate);
+
+    return -1;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+    struct clk *clk_ret = NULL;
+    DEFINE_FLAGS(flags);
+
+    if ((clk == NULL) || IS_ERR(clk)) {
+        CCU_ERR("%s: invalid handle\n", __func__);
+        return NULL;
+    }
+
+    CCU_LOCK(&clk->lock, flags);
+    clk_ret = &aw_clock[clk->aw_clk->parent];
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_DBG("%s: %s's parent is %s\n", __func__, clk->aw_clk->name,
+            clk_ret->aw_clk->name);
+
+    return clk_ret;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+    DEFINE_FLAGS(flags);
+
+    if ((clk == NULL) || IS_ERR(clk) ||
+        (parent == NULL) || IS_ERR(parent)) {
+        CCU_ERR("%s: invalid handle\n", __func__);
+        return -EINVAL;
+    }
+
+    CCU_LOCK(&clk->lock, flags);
+    if (clk->ops->set_parent(clk->aw_clk->id, parent->aw_clk->id) == 0) {
+        clk->aw_clk->parent = clk->ops->get_parent(clk->aw_clk->id);
+        clk->aw_clk->rate   = clk->ops->get_rate(clk->aw_clk->id);
+        CCU_UNLOCK(&clk->lock, flags);
+        CCU_DBG("%s: set %s parent to %s, actual parent is %s, current rate is %llu\n",
+                __func__, clk->aw_clk->name, parent->aw_clk->name,
+                aw_clock[clk->aw_clk->parent].aw_clk->name, clk->aw_clk->rate);
+        return 0;
+    }
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_ERR("%s: set %s parent to %s failed\n", __func__,
+            clk->aw_clk->name, parent->aw_clk->name);
+
+    return -1;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+int clk_reset(struct clk *clk, int reset)
+{
+    DEFINE_FLAGS(flags);
+
+    if ((clk == NULL) || IS_ERR(clk)) {
+        CCU_ERR("%s: invalid handle\n", __func__);
+        return -EINVAL;
+    }
+
+    CCU_LOCK(&clk->lock, flags);
+    reset = reset ? AW_CCU_CLK_RESET : AW_CCU_CLK_NRESET;
+    clk->ops->set_reset(clk->aw_clk->id, reset);
+    clk->aw_clk->reset = reset;
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_DBG("%s: %s reset done\n", __func__, clk->aw_clk->name);
+
+    return 0;
+}
+EXPORT_SYMBOL(clk_reset);
+
+const char *clk_name(struct clk *clk)
+{
+	return clk->aw_clk->name;
+}
+EXPORT_SYMBOL(clk_name);
diff --git a/arch/arm/mach-sun7i/clock/mod_clk.c b/arch/arm/mach-sun7i/clock/mod_clk.c
new file mode 100644
index 0000000..27107ea
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/mod_clk.c
@@ -0,0 +1,2422 @@
+/*
+ * arch/arm/mach-sun7i/clock/ccmu/pll_cfg.c
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/includes.h>
+#include <asm/delay.h>
+
+#include "ccm_i.h"
+
+static __aw_ccu_clk_id_e    mod_clk_get_parent(__aw_ccu_clk_id_e id);
+static __aw_ccu_clk_onff_e  mod_clk_get_status(__aw_ccu_clk_id_e id);
+static __s64                mod_clk_get_rate  (__aw_ccu_clk_id_e id);
+static __aw_ccu_clk_reset_e mod_clk_get_reset (__aw_ccu_clk_id_e id);
+
+static __s32 mod_clk_set_parent(__aw_ccu_clk_id_e id, __aw_ccu_clk_id_e parent  );
+static __s32 mod_clk_set_status(__aw_ccu_clk_id_e id, __aw_ccu_clk_onff_e status);
+static __s32 mod_clk_set_rate  (__aw_ccu_clk_id_e id, __s64 rate                );
+static __s32 mod_clk_set_reset (__aw_ccu_clk_id_e id, __aw_ccu_clk_reset_e reset);
+
+static inline __aw_ccu_clk_id_e _parse_module0_clk_src(volatile __ccmu_module0_clk_t *reg)
+{
+    switch (reg->ClkSrc) {
+        case 0:
+            return AW_SYS_CLK_HOSC;
+        case 1:
+            return AW_SYS_CLK_PLL6;
+        case 2:
+            return AW_SYS_CLK_PLL5P;
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+    return AW_SYS_CLK_NONE;
+}
+
+static inline __aw_ccu_clk_id_e _parse_defemp_clk_src(volatile __ccmu_fedemp_clk_t *reg)
+{
+    switch (reg->ClkSrc) {
+        case 0:
+            return AW_SYS_CLK_PLL3;
+        case 1:
+            return AW_SYS_CLK_PLL7;
+        case 2:
+            return AW_SYS_CLK_PLL5P;
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+    return AW_SYS_CLK_NONE;
+}
+
+static inline __s32 _set_module0_clk_src(volatile __ccmu_module0_clk_t *reg, __aw_ccu_clk_id_e parent)
+{
+    switch (parent) {
+        case AW_SYS_CLK_HOSC:
+            reg->ClkSrc = 0;
+            break;
+        case AW_SYS_CLK_PLL6:
+            reg->ClkSrc = 1;
+            break;
+        case AW_SYS_CLK_PLL5P:
+            reg->ClkSrc = 2;
+            break;
+        default:
+            return -1;
+    }
+
+    return 0;
+}
+
+static inline __s32 _set_defemp_clk_src(volatile __ccmu_fedemp_clk_t *reg, __aw_ccu_clk_id_e parent)
+{
+    switch (parent) {
+        case AW_SYS_CLK_PLL3:
+            reg->ClkSrc = 0;
+            break;
+        case AW_SYS_CLK_PLL7:
+            reg->ClkSrc = 1;
+            break;
+        case AW_SYS_CLK_PLL5P:
+            reg->ClkSrc = 2;
+            break;
+        default:
+            return -1;
+    }
+
+    return 0;
+}
+
+static inline __aw_ccu_clk_onff_e _get_module0_clk_status(volatile __ccmu_module0_clk_t *reg)
+{
+    return reg->SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+}
+
+static inline __s32 _set_module0_clk_status(volatile __ccmu_module0_clk_t *reg, __aw_ccu_clk_onff_e status)
+{
+    reg->SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+    return 0;
+}
+
+static inline __aw_ccu_clk_onff_e _get_defemp_clk_status(volatile __ccmu_fedemp_clk_t *reg)
+{
+    return reg->SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+}
+
+static inline __s32 _set_defemp_clk_status(volatile __ccmu_fedemp_clk_t *reg, __aw_ccu_clk_onff_e status)
+{
+    reg->SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+    return 0;
+}
+
+static inline __u32 _get_module0_clk_rate(volatile __ccmu_module0_clk_t *reg)
+{
+    return (1 << reg->ClkPreDiv) * (reg->ClkDiv + 1);
+}
+
+static inline __s32 _set_module0_clk_rate(volatile __ccmu_module0_clk_t *reg, __u64 rate)
+{
+    if (rate > 16 * 8) {
+        return -1;
+    } else if (rate > 16 * 4) {
+        reg->ClkPreDiv = 3;
+        //reg->ClkDiv    = (rate>>3)-1;
+        reg->ClkDiv    = ((rate + 7) >> 3) - 1;
+    } else if (rate > 16 * 2) {
+        reg->ClkPreDiv = 2;
+        //reg->ClkDiv    = (rate>>2)-1;
+        reg->ClkDiv    = ((rate + 3) >> 2) - 1;
+    } else if (rate > 16 * 1) {
+        reg->ClkPreDiv = 1;
+        //reg->ClkDiv    = (rate>>1)-1;
+        reg->ClkDiv    = ((rate + 1) >> 1) - 1;
+    } else if (rate > 0) {
+        reg->ClkPreDiv = 0;
+        reg->ClkDiv    = rate - 1;
+    } else {
+        CCU_ERR("clock (reg:0x%08x) rate %d invlid\n", (__u32)reg, (__u32)rate);
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Get clock parent for module clock.
+ *
+ * @id:     module clock id.
+ *
+ */
+static __aw_ccu_clk_id_e mod_clk_get_parent(__aw_ccu_clk_id_e id)
+{
+    switch (id) {
+        case AW_MOD_CLK_NFC:
+            return _parse_module0_clk_src(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _parse_module0_clk_src(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_SDC3:
+            return _parse_module0_clk_src(&aw_ccu_reg->SdMmc3Clk);
+        case AW_MOD_CLK_TS:
+            return _parse_module0_clk_src(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _parse_module0_clk_src(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi2Clk);
+        case AW_MOD_CLK_PATA:
+            return _parse_module0_clk_src(&aw_ccu_reg->PataClk);
+        case AW_MOD_CLK_IR0:
+            return _parse_module0_clk_src(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_IR1:
+            return _parse_module0_clk_src(&aw_ccu_reg->Ir1Clk);
+        case AW_MOD_CLK_I2S0:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_I2S1:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_I2S2:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_AC97:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_SPDIF:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_KEYPAD: {
+            switch (aw_ccu_reg->KeyPadClk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 2:
+                    return AW_SYS_CLK_LOSC;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_SATA: {
+            switch (aw_ccu_reg->SataClk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_PLL6M;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            break;
+        }
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+            return AW_SYS_CLK_PLL62;
+        /* REMOVED */
+        //case AW_MOD_CLK_GPS: {
+        //    switch (aw_ccu_reg->GpsClk.ClkSrc) {
+        //        case 0:
+        //            return AW_SYS_CLK_HOSC;
+        //        case 1:
+        //            return AW_SYS_CLK_PLL6;
+        //        case 2:
+        //            return AW_SYS_CLK_PLL7;
+        //        default:
+        //            return AW_SYS_CLK_PLL4;
+        //    }
+        //}
+        case AW_MOD_CLK_SPI3:
+            return _parse_module0_clk_src(&aw_ccu_reg->Spi3Clk);
+        case AW_MOD_CLK_DEBE0:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeBe0Clk);
+        case AW_MOD_CLK_DEBE1:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeBe1Clk);
+        case AW_MOD_CLK_DEFE0:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeFe0Clk);
+        case AW_MOD_CLK_DEFE1:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeFe1Clk);
+        case AW_MOD_CLK_DEMIX:
+            return _parse_defemp_clk_src(&aw_ccu_reg->DeMpClk);
+        case AW_MOD_CLK_LCD0CH0: {
+            switch (aw_ccu_reg->Lcd0Ch0Clk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL62;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_LCD1CH0: {
+            switch (aw_ccu_reg->Lcd1Ch0Clk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_CSIISP: {
+            switch (aw_ccu_reg->CsiIspClk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL4;
+                case 2:
+                    return AW_SYS_CLK_PLL5P;
+                default:
+                    return AW_SYS_CLK_PLL62;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_TVDMOD1:
+            return aw_ccu_reg->TvdClk.Clk1Src ? AW_SYS_CLK_PLL7 : AW_SYS_CLK_PLL3;
+        case AW_MOD_CLK_TVDMOD2:
+            return aw_ccu_reg->TvdClk.Clk2Src ? AW_SYS_CLK_PLL7 : AW_SYS_CLK_PLL3;
+
+        case AW_MOD_CLK_LCD0CH1_S1:
+        case AW_MOD_CLK_LCD0CH1_S2: {
+            switch (aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src) {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_LCD1CH1_S1:
+        case AW_MOD_CLK_LCD1CH1_S2: {
+            switch (aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src) {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_CSI0: {
+            switch (aw_ccu_reg->Csi0Clk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL3;
+                case 2:
+                    return AW_SYS_CLK_PLL7;
+                case 5:
+                    return AW_SYS_CLK_PLL3X2;
+                case 6:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_CSI1: {
+            switch (aw_ccu_reg->Csi1Clk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL3;
+                case 2:
+                    return AW_SYS_CLK_PLL7;
+                case 5:
+                    return AW_SYS_CLK_PLL3X2;
+                case 6:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_VE:
+            return AW_SYS_CLK_PLL4;
+        case AW_MOD_CLK_ADDA:
+            return AW_SYS_CLK_PLL2;
+        case AW_MOD_CLK_AVS:
+            return AW_SYS_CLK_HOSC;
+        case AW_MOD_CLK_ACE:
+            return aw_ccu_reg->AceClk.ClkSrc ? AW_SYS_CLK_PLL5P : AW_SYS_CLK_PLL4;
+        case AW_MOD_CLK_LVDS:
+            return AW_SYS_CLK_NONE;
+        case AW_MOD_CLK_HDMI: {
+            switch (aw_ccu_reg->HdmiClk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL7;
+                case 2:
+                    return AW_SYS_CLK_PLL3X2;
+                case 3:
+                    return AW_SYS_CLK_PLL7X2;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+            return AW_SYS_CLK_NONE;
+        }
+        case AW_MOD_CLK_MALI: {
+            switch (aw_ccu_reg->MaliClk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_PLL3;
+                case 1:
+                    return AW_SYS_CLK_PLL4;
+                case 2:
+                    return AW_SYS_CLK_PLL5P;
+                case 3:
+                    return AW_SYS_CLK_PLL7;
+                case 4:
+                    return AW_SYS_CLK_PLL8;
+                default:
+                    aw_ccu_reg->MaliClk.ClkSrc = 4;
+                    return AW_SYS_CLK_PLL8;
+            }
+        }
+        case AW_MOD_CLK_MBUS: {
+            switch (aw_ccu_reg->MBusClk.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL6X2;
+                case 2:
+                    return AW_SYS_CLK_PLL5P;
+                default:
+                    aw_ccu_reg->MBusClk.ClkSrc = 2;
+                    return AW_SYS_CLK_PLL5P;
+            }
+        }
+        case AW_MOD_CLK_OUTA: {
+            if ((aw_ccu_reg->ClkOutA.ClkSrc == 0) || (aw_ccu_reg->ClkOutA.ClkSrc == 2))
+                return AW_SYS_CLK_HOSC;
+            else if (aw_ccu_reg->ClkOutA.ClkSrc == 1)
+                return AW_SYS_CLK_LOSC;
+            else {
+                aw_ccu_reg->ClkOutA.ClkSrc = 1;
+                return AW_SYS_CLK_LOSC;
+            }
+        }
+        case AW_MOD_CLK_OUTB: {
+            if ((aw_ccu_reg->ClkOutB.ClkSrc == 0) || (aw_ccu_reg->ClkOutB.ClkSrc == 2))
+                return AW_SYS_CLK_HOSC;
+            else if (aw_ccu_reg->ClkOutB.ClkSrc == 1)
+                return AW_SYS_CLK_LOSC;
+            else {
+                aw_ccu_reg->ClkOutB.ClkSrc = 1;
+                return AW_SYS_CLK_LOSC;
+            }
+        }
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_TWI3:
+        case AW_MOD_CLK_TWI4:
+        case AW_MOD_CLK_CAN:
+        case AW_MOD_CLK_SCR:
+        case AW_MOD_CLK_PS20:
+        case AW_MOD_CLK_PS21:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+        case AW_MOD_CLK_UART6:
+        case AW_MOD_CLK_UART7:
+            return AW_SYS_CLK_APB1;
+
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+}
+
+/*
+ * Get module clock on/off status.
+ *
+ * @id:     module clock id.
+ *
+ */
+static __aw_ccu_clk_onff_e mod_clk_get_status(__aw_ccu_clk_id_e id)
+{
+    switch (id) {
+        case AW_MOD_CLK_NFC:
+            return _get_module0_clk_status(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _get_module0_clk_status(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_SDC3:
+            return _get_module0_clk_status(&aw_ccu_reg->SdMmc3Clk);
+        case AW_MOD_CLK_TS:
+            return _get_module0_clk_status(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _get_module0_clk_status(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi2Clk);
+        /* REMOVED */
+        //case AW_MOD_CLK_PATA:
+        //    return _get_module0_clk_status(&aw_ccu_reg->PataClk);
+        case AW_MOD_CLK_IR0:
+            return _get_module0_clk_status(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_IR1:
+            return _get_module0_clk_status(&aw_ccu_reg->Ir1Clk);
+        case AW_MOD_CLK_I2S0:
+            return aw_ccu_reg->I2s0Clk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_I2S1:
+            return aw_ccu_reg->I2s1Clk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_I2S2:
+            return aw_ccu_reg->I2s2Clk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AC97:
+            return aw_ccu_reg->Ac97Clk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SPDIF:
+            return aw_ccu_reg->SpdifClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_KEYPAD:
+            return aw_ccu_reg->KeyPadClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SATA:
+            return aw_ccu_reg->SataClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY:
+            return aw_ccu_reg->UsbClk.PhySpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY0:
+            return aw_ccu_reg->UsbClk.UsbPhy0Rst ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY1:
+            return aw_ccu_reg->UsbClk.UsbPhy1Rst ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY2:
+            return aw_ccu_reg->UsbClk.UsbPhy2Rst ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBOHCI0:
+            return aw_ccu_reg->UsbClk.OHCI0SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBOHCI1:
+            return aw_ccu_reg->UsbClk.OHCI0SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        /* REMOVED */
+        //case AW_MOD_CLK_GPS:
+        //    return aw_ccu_reg->GpsClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_SPI3:
+            return _get_module0_clk_status(&aw_ccu_reg->Spi3Clk);
+        case AW_MOD_CLK_DEBE0:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeBe0Clk);
+        case AW_MOD_CLK_DEBE1:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeBe1Clk);
+        case AW_MOD_CLK_DEFE0:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeFe0Clk);
+        case AW_MOD_CLK_DEFE1:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeFe1Clk);
+        case AW_MOD_CLK_DEMIX:
+            return _get_defemp_clk_status(&aw_ccu_reg->DeMpClk);
+        case AW_MOD_CLK_LCD0CH0:
+            return aw_ccu_reg->Lcd0Ch0Clk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD1CH0:
+            return aw_ccu_reg->Lcd1Ch0Clk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSIISP:
+            return aw_ccu_reg->CsiIspClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_TVDMOD1:
+            return aw_ccu_reg->TvdClk.Clk1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_TVDMOD2:
+            return aw_ccu_reg->TvdClk.Clk2Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD0CH1_S2:
+            return aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD1CH1_S1:
+            return aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LCD1CH1_S2:
+            return aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSI1:
+            return aw_ccu_reg->Csi1Clk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_VE:
+            return aw_ccu_reg->VeClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_ADDA:
+            return aw_ccu_reg->AddaClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_AVS:
+            return aw_ccu_reg->AvsClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_ACE:
+            return aw_ccu_reg->AceClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_LVDS:
+            return AW_CCU_CLK_ON;
+        case AW_MOD_CLK_HDMI:
+            return aw_ccu_reg->HdmiClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_MALI:
+            return aw_ccu_reg->MaliClk.SpecClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_MBUS:
+            return aw_ccu_reg->MBusClk.ClkGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_OUTA:
+            return aw_ccu_reg->ClkOutA.ClkEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_OUTB:
+            return aw_ccu_reg->ClkOutA.ClkEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_TWI3:
+        case AW_MOD_CLK_TWI4:
+        case AW_MOD_CLK_CAN:
+        case AW_MOD_CLK_SCR:
+        case AW_MOD_CLK_PS20:
+        case AW_MOD_CLK_PS21:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+        case AW_MOD_CLK_UART6:
+        case AW_MOD_CLK_UART7:
+            return AW_CCU_CLK_ON;
+
+        case AW_AHB_CLK_USB0:
+            return aw_ccu_reg->AhbGate0.Usb0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_EHCI0:
+            return aw_ccu_reg->AhbGate0.Ehci0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_OHCI0:
+            return aw_ccu_reg->AhbGate0.Ohci0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_EHCI1:
+            return aw_ccu_reg->AhbGate0.Ehci1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_OHCI1:
+            return aw_ccu_reg->AhbGate0.Ohci1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SS:
+            return aw_ccu_reg->AhbGate0.SsGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DMA:
+            return aw_ccu_reg->AhbGate0.DmaGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_BIST:
+            return aw_ccu_reg->AhbGate0.BistGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDMMC0:
+            return aw_ccu_reg->AhbGate0.Sdmmc0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDMMC1:
+            return aw_ccu_reg->AhbGate0.Sdmmc1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDMMC2:
+            return aw_ccu_reg->AhbGate0.Sdmmc2Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDMMC3:
+            return aw_ccu_reg->AhbGate0.Sdmmc3Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_MS:
+            return aw_ccu_reg->AhbGate0.MsGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_NAND:
+            return aw_ccu_reg->AhbGate0.NandGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDRAM:
+            return aw_ccu_reg->AhbGate0.SdramGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_ACE:
+            return aw_ccu_reg->AhbGate0.AceGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_EMAC:
+            return aw_ccu_reg->AhbGate0.EmacGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_TS:
+            return aw_ccu_reg->AhbGate0.TsGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPI0:
+            return aw_ccu_reg->AhbGate0.Spi0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPI1:
+            return aw_ccu_reg->AhbGate0.Spi1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPI2:
+            return aw_ccu_reg->AhbGate0.Spi2Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPI3:
+            return aw_ccu_reg->AhbGate0.Spi3Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        /* REMOVED */
+        //case AW_AHB_CLK_PATA:
+        //    return aw_ccu_reg->AhbGate0.PataGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SATA:
+            return aw_ccu_reg->AhbGate0.SataGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        /* REMOVED */
+        //case AW_AHB_CLK_GPS:
+        //    return aw_ccu_reg->AhbGate0.GpsGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_VE:
+            return aw_ccu_reg->AhbGate1.VeGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_TVD:
+            return aw_ccu_reg->AhbGate1.TvdGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_TVE0:
+            return aw_ccu_reg->AhbGate1.Tve0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_TVE1:
+            return aw_ccu_reg->AhbGate1.Tve1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_LCD0:
+            return aw_ccu_reg->AhbGate1.Lcd0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_LCD1:
+            return aw_ccu_reg->AhbGate1.Lcd1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_CSI0:
+            return aw_ccu_reg->AhbGate1.Csi0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_CSI1:
+            return aw_ccu_reg->AhbGate1.Csi1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_HDMI1:
+            return aw_ccu_reg->AhbGate1.Hdmi1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_HDMI:
+            return aw_ccu_reg->AhbGate1.HdmiDGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEBE0:
+            return aw_ccu_reg->AhbGate1.DeBe0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEBE1:
+            return aw_ccu_reg->AhbGate1.DeBe1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEFE0:
+            return aw_ccu_reg->AhbGate1.DeFe0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEFE1:
+            return aw_ccu_reg->AhbGate1.DeFe1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_GMAC:
+            return aw_ccu_reg->AhbGate1.GmacGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_MP:
+            return aw_ccu_reg->AhbGate1.MpGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_MALI:
+            return aw_ccu_reg->AhbGate1.Gpu3DGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_ADDA:
+            return aw_ccu_reg->Apb0Gate.AddaGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_SPDIF:
+            return aw_ccu_reg->Apb0Gate.SpdifGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_AC97:
+            return aw_ccu_reg->Apb0Gate.Ac97Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_I2S0:
+            return aw_ccu_reg->Apb0Gate.Iis0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_I2S1:
+            return aw_ccu_reg->Apb0Gate.Iis1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_I2S2:
+            return aw_ccu_reg->Apb0Gate.Iis2Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_PIO:
+            return aw_ccu_reg->Apb0Gate.PioGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_IR0:
+            return aw_ccu_reg->Apb0Gate.Ir0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_IR1:
+            return aw_ccu_reg->Apb0Gate.Ir1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_KEYPAD:
+            return aw_ccu_reg->Apb0Gate.KeypadGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI0:
+            return aw_ccu_reg->Apb1Gate.Twi0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI1:
+            return aw_ccu_reg->Apb1Gate.Twi1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI2:
+            return aw_ccu_reg->Apb1Gate.Twi2Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI3:
+            return aw_ccu_reg->Apb1Gate.Twi3Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI4:
+            return aw_ccu_reg->Apb1Gate.Twi4Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_CAN:
+            return aw_ccu_reg->Apb1Gate.CanGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_SCR:
+            return aw_ccu_reg->Apb1Gate.ScrGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_PS20:
+            return aw_ccu_reg->Apb1Gate.Ps20Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_PS21:
+            return aw_ccu_reg->Apb1Gate.Ps21Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART0:
+            return aw_ccu_reg->Apb1Gate.Uart0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART1:
+            return aw_ccu_reg->Apb1Gate.Uart1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART2:
+            return aw_ccu_reg->Apb1Gate.Uart2Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART3:
+            return aw_ccu_reg->Apb1Gate.Uart3Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART4:
+            return aw_ccu_reg->Apb1Gate.Uart4Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART5:
+            return aw_ccu_reg->Apb1Gate.Uart5Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART6:
+            return aw_ccu_reg->Apb1Gate.Uart6Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART7:
+            return aw_ccu_reg->Apb1Gate.Uart7Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_VE:
+            return aw_ccu_reg->DramGate.VeGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_CSI0:
+            return aw_ccu_reg->DramGate.Csi0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_CSI1:
+            return aw_ccu_reg->DramGate.Csi1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_TS:
+            return aw_ccu_reg->DramGate.TsGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_TVD:
+            return aw_ccu_reg->DramGate.TvdGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_TVE0:
+            return aw_ccu_reg->DramGate.Tve0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_TVE1:
+            return aw_ccu_reg->DramGate.Tve1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEFE0:
+            return aw_ccu_reg->DramGate.DeFe0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEFE1:
+            return aw_ccu_reg->DramGate.DeFe1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEBE0:
+            return aw_ccu_reg->DramGate.DeBe0Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEBE1:
+            return aw_ccu_reg->DramGate.DeBe1Gate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEMP:
+            return aw_ccu_reg->DramGate.DeMpGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_ACE:
+            return aw_ccu_reg->DramGate.AceGate ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        default:
+            return AW_CCU_CLK_ON;
+    }
+    return AW_CCU_CLK_ON;
+}
+
+/*
+ * Get module clock rate.
+ *
+ * @id:     module clock id.
+ *
+ */
+static __s64 mod_clk_get_rate(__aw_ccu_clk_id_e id)
+{
+    switch (id) {
+        case AW_MOD_CLK_NFC:
+            return _get_module0_clk_rate(&aw_ccu_reg->NandClk);
+        case AW_MOD_CLK_MSC:
+            return _get_module0_clk_rate(&aw_ccu_reg->MsClk);
+        case AW_MOD_CLK_SDC0:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc0Clk);
+        case AW_MOD_CLK_SDC1:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc1Clk);
+        case AW_MOD_CLK_SDC2:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc2Clk);
+        case AW_MOD_CLK_SDC3:
+            return _get_module0_clk_rate(&aw_ccu_reg->SdMmc3Clk);
+        case AW_MOD_CLK_TS:
+            return _get_module0_clk_rate(&aw_ccu_reg->TsClk);
+        case AW_MOD_CLK_SS:
+            return _get_module0_clk_rate(&aw_ccu_reg->SsClk);
+        case AW_MOD_CLK_SPI0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi0Clk);
+        case AW_MOD_CLK_SPI1:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi1Clk);
+        case AW_MOD_CLK_SPI2:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi2Clk);
+        case AW_MOD_CLK_PATA:
+            return _get_module0_clk_rate(&aw_ccu_reg->PataClk);
+        case AW_MOD_CLK_IR0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Ir0Clk);
+        case AW_MOD_CLK_IR1:
+            return _get_module0_clk_rate(&aw_ccu_reg->Ir1Clk);
+        case AW_MOD_CLK_I2S0:
+            return (1 << aw_ccu_reg->I2s0Clk.ClkDiv);
+        case AW_MOD_CLK_I2S1:
+            return (1 << aw_ccu_reg->I2s1Clk.ClkDiv);
+        case AW_MOD_CLK_I2S2:
+            return (1 << aw_ccu_reg->I2s2Clk.ClkDiv);
+        case AW_MOD_CLK_AC97:
+            return (1 << aw_ccu_reg->Ac97Clk.ClkDiv);
+        case AW_MOD_CLK_SPDIF:
+            return (1 << aw_ccu_reg->SpdifClk.ClkDiv);
+        case AW_MOD_CLK_KEYPAD:
+            return (1 << aw_ccu_reg->KeyPadClk.ClkPreDiv) * (aw_ccu_reg->KeyPadClk.ClkDiv + 1);
+        case AW_MOD_CLK_SATA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+        /* REMOVED */
+        //case AW_MOD_CLK_GPS:
+        //    return aw_ccu_reg->GpsClk.ClkDivRatio + 1;
+        case AW_MOD_CLK_SPI3:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi3Clk);
+        case AW_MOD_CLK_DEBE0:
+            return aw_ccu_reg->DeBe0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEBE1:
+            return aw_ccu_reg->DeBe1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEFE0:
+            return aw_ccu_reg->DeFe0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEFE1:
+            return aw_ccu_reg->DeFe1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_DEMIX:
+            return aw_ccu_reg->DeMpClk.ClkDiv + 1;
+        case AW_MOD_CLK_LCD0CH0:
+        case AW_MOD_CLK_LCD1CH0:
+            return 1;
+        case AW_MOD_CLK_CSIISP:
+            return aw_ccu_reg->CsiIspClk.ClkDiv + 1;
+        case AW_MOD_CLK_TVDMOD1:
+            return aw_ccu_reg->TvdClk.Clk1Div + 1;
+        case AW_MOD_CLK_TVDMOD2:
+            return aw_ccu_reg->TvdClk.Clk2Div + 1;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return (aw_ccu_reg->Lcd0Ch1Clk.ClkDiv + 1) * (aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src + 1);
+        case AW_MOD_CLK_LCD0CH1_S2:
+            return aw_ccu_reg->Lcd0Ch1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_LCD1CH1_S1:
+            return (aw_ccu_reg->Lcd1Ch1Clk.ClkDiv + 1) * (aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Src + 1);
+        case AW_MOD_CLK_LCD1CH1_S2:
+            return aw_ccu_reg->Lcd1Ch1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.ClkDiv + 1;
+        case AW_MOD_CLK_CSI1:
+            return aw_ccu_reg->Csi1Clk.ClkDiv + 1;
+        case AW_MOD_CLK_VE:
+            return (aw_ccu_reg->VeClk.ClkDiv + 1);
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_AVS:
+            return 1;
+        case AW_MOD_CLK_ACE:
+            return (aw_ccu_reg->AceClk.ClkDiv + 1);
+        case AW_MOD_CLK_LVDS:
+            return 1;
+        case AW_MOD_CLK_HDMI:
+            return (aw_ccu_reg->HdmiClk.ClkDiv + 1);
+        case AW_MOD_CLK_MALI:
+            return (aw_ccu_reg->MaliClk.ClkDiv + 1);
+        case AW_MOD_CLK_MBUS:
+            return (aw_ccu_reg->MBusClk.ClkDivM + 1) * (1 << aw_ccu_reg->MBusClk.ClkDivN);
+        case AW_MOD_CLK_OUTA: {
+            if (aw_ccu_reg->ClkOutA.ClkSrc == 0)
+                return (aw_ccu_reg->ClkOutA.ClkDivM + 1) * (1 << aw_ccu_reg->ClkOutA.ClkDivN) * 750;
+            else
+                return (aw_ccu_reg->ClkOutA.ClkDivM + 1) * (1 << aw_ccu_reg->ClkOutA.ClkDivN);
+        }
+        case AW_MOD_CLK_OUTB: {
+            if (aw_ccu_reg->ClkOutB.ClkSrc == 0)
+                return (aw_ccu_reg->ClkOutB.ClkDivM + 1) * (1 << aw_ccu_reg->ClkOutB.ClkDivN) * 750;
+            else
+                return (aw_ccu_reg->ClkOutB.ClkDivM + 1) * (1 << aw_ccu_reg->ClkOutB.ClkDivN);
+        }
+        default:
+            return 1;
+    }
+}
+
+/*
+ * Set clock parent id for module clock.
+ *
+ * @id:     module clock id
+ * @parent: parent clock id
+ *
+ */
+static __s32 mod_clk_set_parent(__aw_ccu_clk_id_e id, __aw_ccu_clk_id_e parent)
+{
+    switch (id) {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_src(&aw_ccu_reg->NandClk, parent);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_src(&aw_ccu_reg->MsClk, parent);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc0Clk, parent);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc1Clk, parent);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc2Clk, parent);
+        case AW_MOD_CLK_SDC3:
+            return _set_module0_clk_src(&aw_ccu_reg->SdMmc3Clk, parent);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_src(&aw_ccu_reg->TsClk, parent);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_src(&aw_ccu_reg->SsClk, parent);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi0Clk, parent);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi1Clk, parent);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi2Clk, parent);
+        case AW_MOD_CLK_PATA:
+            return _set_module0_clk_src(&aw_ccu_reg->PataClk, parent);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_src(&aw_ccu_reg->Ir0Clk, parent);
+        case AW_MOD_CLK_IR1:
+            return _set_module0_clk_src(&aw_ccu_reg->Ir1Clk, parent);
+        case AW_MOD_CLK_I2S0:
+            return (parent == AW_SYS_CLK_PLL2) ? 0 : -1;
+        case AW_MOD_CLK_I2S1:
+            return (parent == AW_SYS_CLK_PLL2) ? 0 : -1;
+        case AW_MOD_CLK_I2S2:
+            return (parent == AW_SYS_CLK_PLL2) ? 0 : -1;
+        case AW_MOD_CLK_AC97:
+            return (parent == AW_SYS_CLK_PLL2) ? 0 : -1;
+        case AW_MOD_CLK_SPDIF:
+            return (parent == AW_SYS_CLK_PLL2) ? 0 : -1;
+        case AW_MOD_CLK_KEYPAD: {
+            switch (parent) {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->KeyPadClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->KeyPadClk.ClkSrc = 2;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_SATA: {
+            if (parent == AW_SYS_CLK_PLL6M) {
+                aw_ccu_reg->SataClk.ClkSrc = 0;
+                return 0;
+            }
+
+            return -1;
+        }
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1: {
+            /* REMOVED */
+            //if (parent == AW_SYS_CLK_PLL62) {
+            //    aw_ccu_reg->UsbClk.OHCIClkSrc = 0;
+            //    return 0;
+            //}
+
+            return -1;
+        }
+        case AW_MOD_CLK_SPI3:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi3Clk, parent);
+        case AW_MOD_CLK_DEBE0:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeBe0Clk, parent);
+        case AW_MOD_CLK_DEBE1:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeBe1Clk, parent);
+        case AW_MOD_CLK_DEFE0:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeFe0Clk, parent);
+        case AW_MOD_CLK_DEFE1:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeFe1Clk, parent);
+        case AW_MOD_CLK_DEMIX:
+            return _set_defemp_clk_src(&aw_ccu_reg->DeMpClk, parent);
+        case AW_MOD_CLK_LCD0CH0: {
+            switch (parent) {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL6X2:
+                    aw_ccu_reg->Lcd0Ch0Clk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_LCD1CH0: {
+            switch (parent) {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd1Ch0Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd1Ch0Clk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd1Ch0Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd1Ch0Clk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_CSIISP: {
+            switch (parent) {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->CsiIspClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL4:
+                    aw_ccu_reg->CsiIspClk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL5:
+                    aw_ccu_reg->CsiIspClk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL62:
+                    aw_ccu_reg->CsiIspClk.ClkSrc = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_TVDMOD1: {
+            if (parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->TvdClk.Clk1Src = 0;
+            else if (parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->TvdClk.Clk1Src = 1;
+            else
+                return -1;
+            return 0;
+        }
+        case AW_MOD_CLK_TVDMOD2: {
+            if (parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->TvdClk.Clk2Src = 0;
+            else if (parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->TvdClk.Clk2Src = 1;
+            else
+                return -1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH1_S1:
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S2: {
+            switch (parent) {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Src = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_LCD1CH1_S1:
+            return 0;
+        case AW_MOD_CLK_LCD1CH1_S2: {
+            switch (parent) {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Src = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_CSI0: {
+            switch (parent) {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 5;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Csi0Clk.ClkSrc = 6;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_CSI1: {
+            switch (parent) {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL3X2:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 5;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7X2:
+                    aw_ccu_reg->Csi1Clk.ClkSrc = 6;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_VE:
+            return (parent == AW_SYS_CLK_PLL4) ? 0 : -1;
+        case AW_MOD_CLK_ADDA:
+            return (parent == AW_SYS_CLK_PLL2) ? 0 : -1;
+        case AW_MOD_CLK_AVS:
+            return (parent == AW_SYS_CLK_HOSC) ? 0 : -1;
+        case AW_MOD_CLK_ACE: {
+            switch (parent) {
+                case AW_SYS_CLK_PLL4:
+                    aw_ccu_reg->AceClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL5P:
+                    aw_ccu_reg->AceClk.ClkSrc = 1;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_HDMI: {
+            switch (parent) {
+                case AW_SYS_CLK_PLL3: {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 0;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL3X2: {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 2;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL7: {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 1;
+                    return 0;
+                }
+                case AW_SYS_CLK_PLL7X2: {
+                    aw_ccu_reg->HdmiClk.ClkSrc = 3;
+                    return 0;
+                }
+                default:
+                    return -1;
+            }
+        }
+        case AW_MOD_CLK_MALI: {
+            switch (parent) {
+                case AW_SYS_CLK_PLL3:
+                    aw_ccu_reg->MaliClk.ClkSrc = 0;
+                    return 0;
+                case AW_SYS_CLK_PLL4:
+                    aw_ccu_reg->MaliClk.ClkSrc = 1;
+                    return 0;
+                case AW_SYS_CLK_PLL5P:
+                    aw_ccu_reg->MaliClk.ClkSrc = 2;
+                    return 0;
+                case AW_SYS_CLK_PLL7:
+                    aw_ccu_reg->MaliClk.ClkSrc = 3;
+                    return 0;
+                case AW_SYS_CLK_PLL8:
+                    aw_ccu_reg->MaliClk.ClkSrc = 4;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_MBUS: {
+            switch (parent) {
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->MBusClk.ClkSrc = 0;
+                    break;
+                case AW_SYS_CLK_PLL6X2:
+                    aw_ccu_reg->MBusClk.ClkSrc = 1;
+                    break;
+                case AW_SYS_CLK_PLL5P:
+                    aw_ccu_reg->MBusClk.ClkSrc = 2;
+                    break;
+                default:
+                    return -1;
+            }
+            return 0;
+        }
+
+        case AW_MOD_CLK_OUTA: {
+            if (parent == AW_SYS_CLK_HOSC)
+                aw_ccu_reg->ClkOutA.ClkSrc = 2;
+            else if (parent == AW_SYS_CLK_LOSC)
+                aw_ccu_reg->ClkOutA.ClkSrc = 1;
+            else
+                return -1;
+            return 0;
+        }
+        case AW_MOD_CLK_OUTB: {
+            if (parent == AW_SYS_CLK_HOSC)
+                aw_ccu_reg->ClkOutB.ClkSrc = 2;
+            else if (parent == AW_SYS_CLK_LOSC)
+                aw_ccu_reg->ClkOutB.ClkSrc = 1;
+            else
+                return -1;
+            return 0;
+        }
+        /* REMOVED */
+        //case AW_MOD_CLK_GPS: {
+        //    switch (parent) {
+        //        case AW_SYS_CLK_HOSC:
+        //            aw_ccu_reg->GpsClk.ClkSrc = 0;
+        //            break;
+        //        case AW_SYS_CLK_PLL6:
+        //            aw_ccu_reg->GpsClk.ClkSrc = 1;
+        //            break;
+        //        case AW_SYS_CLK_PLL7:
+        //            aw_ccu_reg->GpsClk.ClkSrc = 2;
+        //            break;
+        //        case AW_SYS_CLK_PLL4:
+        //            aw_ccu_reg->GpsClk.ClkSrc = 3;
+        //            break;
+        //        default:
+        //            return -1;
+        //    }
+        //    return 0;
+        //}
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_TWI3:
+        case AW_MOD_CLK_TWI4:
+        case AW_MOD_CLK_CAN:
+        case AW_MOD_CLK_SCR:
+        case AW_MOD_CLK_PS20:
+        case AW_MOD_CLK_PS21:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+        case AW_MOD_CLK_UART6:
+        case AW_MOD_CLK_UART7:
+            return (parent == AW_SYS_CLK_APB1) ? 0 : -1;
+
+        case AW_MOD_CLK_LVDS:
+        default:
+            return (parent == AW_SYS_CLK_NONE) ? 0 : -1;
+    }
+    return (parent == AW_SYS_CLK_NONE) ? 0 : -1;
+}
+
+/*
+ * Set module clock on/off status.
+ *
+ * @id:     module clock id
+ * @status: module clock on/off status
+ *
+ */
+static __s32 mod_clk_set_status(__aw_ccu_clk_id_e id, __aw_ccu_clk_onff_e status)
+{
+    switch (id) {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_status(&aw_ccu_reg->NandClk, status);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_status(&aw_ccu_reg->MsClk, status);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc0Clk, status);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc1Clk, status);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc2Clk, status);
+        case AW_MOD_CLK_SDC3:
+            return _set_module0_clk_status(&aw_ccu_reg->SdMmc3Clk, status);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_status(&aw_ccu_reg->TsClk, status);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_status(&aw_ccu_reg->SsClk, status);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi0Clk, status);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi1Clk, status);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi2Clk, status);
+        case AW_MOD_CLK_PATA:
+            return _set_module0_clk_status(&aw_ccu_reg->PataClk, status);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_status(&aw_ccu_reg->Ir0Clk, status);
+        case AW_MOD_CLK_IR1:
+            return _set_module0_clk_status(&aw_ccu_reg->Ir1Clk, status);
+        case AW_MOD_CLK_I2S0:
+            aw_ccu_reg->I2s0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_I2S1:
+            aw_ccu_reg->I2s1Clk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_I2S2:
+            aw_ccu_reg->I2s2Clk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AC97:
+            aw_ccu_reg->Ac97Clk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_SPDIF:
+            aw_ccu_reg->SpdifClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_KEYPAD: {
+            aw_ccu_reg->KeyPadClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_SATA: {
+            aw_ccu_reg->SataClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            aw_ccu_reg->Pll6Ctl.OutputEn = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY: {
+            aw_ccu_reg->UsbClk.PhySpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY0: {
+            aw_ccu_reg->UsbClk.UsbPhy0Rst = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY1: {
+            aw_ccu_reg->UsbClk.UsbPhy1Rst = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_USBPHY2: {
+            aw_ccu_reg->UsbClk.UsbPhy2Rst = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        }
+
+        case AW_MOD_CLK_USBOHCI0:
+            aw_ccu_reg->UsbClk.OHCI0SpecClkGate = ((status == AW_CCU_CLK_OFF) ? 0 : 1);
+            return 0;
+        case AW_MOD_CLK_USBOHCI1:
+            aw_ccu_reg->UsbClk.OHCI1SpecClkGate = ((status == AW_CCU_CLK_OFF) ? 0 : 1);
+            return 0;
+        /* REMOVED */
+        //case AW_MOD_CLK_GPS: {
+        //    aw_ccu_reg->GpsClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+        //    return 0;
+        //}
+        case AW_MOD_CLK_SPI3:
+            return _set_module0_clk_status(&aw_ccu_reg->Spi3Clk, status);
+        case AW_MOD_CLK_DEBE0:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeBe0Clk, status);
+        case AW_MOD_CLK_DEBE1:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeBe1Clk, status);
+        case AW_MOD_CLK_DEFE0:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeFe0Clk, status);
+        case AW_MOD_CLK_DEFE1:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeFe1Clk, status);
+        case AW_MOD_CLK_DEMIX:
+            return _set_defemp_clk_status(&aw_ccu_reg->DeMpClk, status);
+        case AW_MOD_CLK_LCD0CH0:
+            aw_ccu_reg->Lcd0Ch0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LCD1CH0:
+            aw_ccu_reg->Lcd1Ch0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_CSIISP:
+            aw_ccu_reg->CsiIspClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_TVDMOD1:
+            aw_ccu_reg->TvdClk.Clk1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_TVDMOD2:
+            aw_ccu_reg->TvdClk.Clk2Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S1:
+            aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Gate = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_LCD0CH1_S2:
+            aw_ccu_reg->Lcd0Ch1Clk.SpecClk2Gate = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_LCD1CH1_S1:
+            aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Gate = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_LCD1CH1_S2:
+            aw_ccu_reg->Lcd1Ch1Clk.SpecClk2Gate = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_MOD_CLK_CSI0:
+            aw_ccu_reg->Csi0Clk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_CSI1:
+            aw_ccu_reg->Csi1Clk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_VE:
+            aw_ccu_reg->VeClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_ADDA:
+            aw_ccu_reg->AddaClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_AVS:
+            aw_ccu_reg->AvsClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_ACE:
+            aw_ccu_reg->AceClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LVDS:
+            return 0;
+        case AW_MOD_CLK_HDMI:
+            aw_ccu_reg->HdmiClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_MALI:
+            aw_ccu_reg->MaliClk.SpecClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_MBUS:
+            aw_ccu_reg->MBusClk.ClkGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_OUTA:
+            aw_ccu_reg->ClkOutA.ClkEn = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_OUTB:
+            aw_ccu_reg->ClkOutB.ClkEn = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_TWI3:
+        case AW_MOD_CLK_TWI4:
+        case AW_MOD_CLK_CAN:
+        case AW_MOD_CLK_SCR:
+        case AW_MOD_CLK_PS20:
+        case AW_MOD_CLK_PS21:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+        case AW_MOD_CLK_UART6:
+        case AW_MOD_CLK_UART7:
+            return 0;
+
+        case AW_AHB_CLK_USB0:
+            aw_ccu_reg->AhbGate0.Usb0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_EHCI0:
+            aw_ccu_reg->AhbGate0.Ehci0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_OHCI0:
+            aw_ccu_reg->AhbGate0.Ohci0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_EHCI1:
+            aw_ccu_reg->AhbGate0.Ehci1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_OHCI1:
+            aw_ccu_reg->AhbGate0.Ohci1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SS:
+            aw_ccu_reg->AhbGate0.SsGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+
+        case AW_AHB_CLK_DMA:
+            aw_ccu_reg->AhbGate0.DmaGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_BIST:
+            aw_ccu_reg->AhbGate0.BistGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SDMMC0:
+            aw_ccu_reg->AhbGate0.Sdmmc0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SDMMC1:
+            aw_ccu_reg->AhbGate0.Sdmmc1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SDMMC2:
+            aw_ccu_reg->AhbGate0.Sdmmc2Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SDMMC3:
+            aw_ccu_reg->AhbGate0.Sdmmc3Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_MS:
+            aw_ccu_reg->AhbGate0.MsGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_NAND:
+            aw_ccu_reg->AhbGate0.NandGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SDRAM:
+            aw_ccu_reg->AhbGate0.SdramGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_ACE:
+            aw_ccu_reg->AhbGate0.AceGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_EMAC:
+            aw_ccu_reg->AhbGate0.EmacGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_TS:
+            aw_ccu_reg->AhbGate0.TsGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SPI0:
+            aw_ccu_reg->AhbGate0.Spi0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SPI1:
+            aw_ccu_reg->AhbGate0.Spi1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SPI2:
+            aw_ccu_reg->AhbGate0.Spi2Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_SPI3:
+            aw_ccu_reg->AhbGate0.Spi3Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        /* REMOVED */
+        //case AW_AHB_CLK_PATA:
+        //    aw_ccu_reg->AhbGate0.PataGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+        //    return 0;
+        case AW_AHB_CLK_SATA:
+            aw_ccu_reg->AhbGate0.SataGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        /* REMOVED */
+        //case AW_AHB_CLK_GPS:
+        //    aw_ccu_reg->AhbGate0.GpsGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+        //    return 0;
+        case AW_AHB_CLK_STMR:
+            aw_ccu_reg->AhbGate0.StmrGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_VE:
+            aw_ccu_reg->AhbGate1.VeGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_TVD:
+            aw_ccu_reg->AhbGate1.TvdGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_TVE0:
+            aw_ccu_reg->AhbGate1.Tve0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_TVE1:
+            aw_ccu_reg->AhbGate1.Tve1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_LCD0:
+            aw_ccu_reg->AhbGate1.Lcd0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_LCD1:
+            aw_ccu_reg->AhbGate1.Lcd1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_CSI0:
+            aw_ccu_reg->AhbGate1.Csi0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_CSI1:
+            aw_ccu_reg->AhbGate1.Csi1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_HDMI1:
+            aw_ccu_reg->AhbGate1.Hdmi1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_HDMI:
+            aw_ccu_reg->AhbGate1.HdmiDGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_DEBE0:
+            aw_ccu_reg->AhbGate1.DeBe0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_DEBE1:
+            aw_ccu_reg->AhbGate1.DeBe1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_DEFE0:
+            aw_ccu_reg->AhbGate1.DeFe0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_DEFE1:
+            aw_ccu_reg->AhbGate1.DeFe1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_GMAC:
+            aw_ccu_reg->AhbGate1.GmacGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_MP:
+            aw_ccu_reg->AhbGate1.MpGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_AHB_CLK_MALI:
+            aw_ccu_reg->AhbGate1.Gpu3DGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+
+        case AW_APB_CLK_ADDA:
+            aw_ccu_reg->Apb0Gate.AddaGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_SPDIF:
+            aw_ccu_reg->Apb0Gate.SpdifGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_AC97:
+            aw_ccu_reg->Apb0Gate.Ac97Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_I2S0:
+            aw_ccu_reg->Apb0Gate.Iis0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_I2S1:
+            aw_ccu_reg->Apb0Gate.Iis1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_I2S2:
+            aw_ccu_reg->Apb0Gate.Iis2Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_PIO:
+            aw_ccu_reg->Apb0Gate.PioGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_IR0:
+            aw_ccu_reg->Apb0Gate.Ir0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_IR1:
+            aw_ccu_reg->Apb0Gate.Ir1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_KEYPAD:
+            aw_ccu_reg->Apb0Gate.KeypadGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_TWI0:
+            aw_ccu_reg->Apb1Gate.Twi0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_TWI1:
+            aw_ccu_reg->Apb1Gate.Twi1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_TWI2:
+            aw_ccu_reg->Apb1Gate.Twi2Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_TWI3:
+            aw_ccu_reg->Apb1Gate.Twi3Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_TWI4:
+            aw_ccu_reg->Apb1Gate.Twi4Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_CAN:
+            aw_ccu_reg->Apb1Gate.CanGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_SCR:
+            aw_ccu_reg->Apb1Gate.ScrGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_PS20:
+            aw_ccu_reg->Apb1Gate.Ps20Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_PS21:
+            aw_ccu_reg->Apb1Gate.Ps21Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_UART0:
+            aw_ccu_reg->Apb1Gate.Uart0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_UART1:
+            aw_ccu_reg->Apb1Gate.Uart1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_UART2:
+            aw_ccu_reg->Apb1Gate.Uart2Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_UART3:
+            aw_ccu_reg->Apb1Gate.Uart3Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_UART4:
+            aw_ccu_reg->Apb1Gate.Uart4Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_UART5:
+            aw_ccu_reg->Apb1Gate.Uart5Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_UART6:
+            aw_ccu_reg->Apb1Gate.Uart6Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_APB_CLK_UART7:
+            aw_ccu_reg->Apb1Gate.Uart7Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_VE:
+            aw_ccu_reg->DramGate.VeGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_CSI0:
+            aw_ccu_reg->DramGate.Csi0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_CSI1:
+            aw_ccu_reg->DramGate.Csi1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_TS:
+            aw_ccu_reg->DramGate.TsGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_TVD:
+            aw_ccu_reg->DramGate.TvdGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_TVE0:
+            aw_ccu_reg->DramGate.Tve0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_TVE1:
+            aw_ccu_reg->DramGate.Tve1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_DEFE0:
+            aw_ccu_reg->DramGate.DeFe0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_DEFE1:
+            aw_ccu_reg->DramGate.DeFe1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_DEBE0:
+            aw_ccu_reg->DramGate.DeBe0Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_DEBE1:
+            aw_ccu_reg->DramGate.DeBe1Gate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_DEMP:
+            aw_ccu_reg->DramGate.DeMpGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+        case AW_DRAM_CLK_ACE:
+            aw_ccu_reg->DramGate.AceGate = (status == AW_CCU_CLK_OFF) ? 0 : 1;
+            return 0;
+
+        default:
+            return -1;
+    }
+}
+
+/*
+ * Set module clock division.
+ *
+ * @id:     module clock id
+ * @rate:   module clock division
+ *
+ */
+static __s32 mod_clk_set_rate(__aw_ccu_clk_id_e id, __s64 rate)
+{
+    switch (id) {
+        case AW_MOD_CLK_NFC:
+            return _set_module0_clk_rate(&aw_ccu_reg->NandClk, rate);
+        case AW_MOD_CLK_MSC:
+            return _set_module0_clk_rate(&aw_ccu_reg->MsClk, rate);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc0Clk, rate);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc1Clk, rate);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc2Clk, rate);
+        case AW_MOD_CLK_SDC3:
+            return _set_module0_clk_rate(&aw_ccu_reg->SdMmc3Clk, rate);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_rate(&aw_ccu_reg->TsClk, rate);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_rate(&aw_ccu_reg->SsClk, rate);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi0Clk, rate);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi1Clk, rate);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi2Clk, rate);
+        case AW_MOD_CLK_PATA:
+            return _set_module0_clk_rate(&aw_ccu_reg->PataClk, rate);
+        case AW_MOD_CLK_IR0:
+            return _set_module0_clk_rate(&aw_ccu_reg->Ir0Clk, rate);
+        case AW_MOD_CLK_IR1:
+            return _set_module0_clk_rate(&aw_ccu_reg->Ir1Clk, rate);
+        case AW_MOD_CLK_I2S0: {
+            switch (rate) {
+                case 1:
+                    aw_ccu_reg->I2s0Clk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->I2s0Clk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->I2s0Clk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->I2s0Clk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_I2S1: {
+            switch (rate) {
+                case 1:
+                    aw_ccu_reg->I2s1Clk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->I2s1Clk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->I2s1Clk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->I2s1Clk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_I2S2: {
+            switch (rate) {
+                case 1:
+                    aw_ccu_reg->I2s2Clk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->I2s2Clk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->I2s2Clk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->I2s2Clk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_AC97: {
+            switch (rate) {
+                case 1:
+                    aw_ccu_reg->Ac97Clk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->Ac97Clk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->Ac97Clk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->Ac97Clk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_SPDIF: {
+            switch (rate) {
+                case 1:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 0;
+                    return 0;
+                case 2:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 1;
+                    return 0;
+                case 4:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 2;
+                    return 0;
+                case 8:
+                    aw_ccu_reg->SpdifClk.ClkDiv = 3;
+                    return 0;
+                default:
+                    return -1;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_KEYPAD: {
+            if (rate > 32 * 8) {
+                return -1;
+            } else if (rate > 32 * 4) {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 3;
+                //aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>3)-1;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = ((rate + 7) >> 3) - 1;
+            } else if (rate > 32 * 2) {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 2;
+                //aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>2)-1;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = ((rate + 3) >> 2) - 1;
+            } else if (rate > 32 * 1) {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 1;
+                //aw_ccu_reg->KeyPadClk.ClkDiv    = (rate>>1)-1;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = ((rate + 1) >> 1) - 1;
+            } else if (rate > 32 * 0) {
+                aw_ccu_reg->KeyPadClk.ClkPreDiv = 0;
+                aw_ccu_reg->KeyPadClk.ClkDiv    = rate - 1;
+            } else {
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_SPI3:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi3Clk, rate);
+        case AW_MOD_CLK_DEBE0: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->DeBe0Clk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE1: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->DeBe1Clk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE0: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->DeFe0Clk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE1: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->DeFe1Clk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEMIX: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->DeMpClk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSIISP: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->CsiIspClk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH1_S1: {
+            if (rate == (aw_ccu_reg->Lcd0Ch1Clk.ClkDiv + 1)) {
+                aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src = 0;
+                return 0;
+            } else if (rate == ((aw_ccu_reg->Lcd0Ch1Clk.ClkDiv + 1) << 1)) {
+                aw_ccu_reg->Lcd0Ch1Clk.SpecClk1Src = 1;
+                return 0;
+            }
+
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH1_S2: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->Lcd0Ch1Clk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD1CH1_S1: {
+            if (rate == (aw_ccu_reg->Lcd1Ch1Clk.ClkDiv + 1)) {
+                aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Src = 0;
+                return 0;
+            } else if (rate == ((aw_ccu_reg->Lcd1Ch1Clk.ClkDiv + 1) << 1)) {
+                aw_ccu_reg->Lcd1Ch1Clk.SpecClk1Src = 1;
+                return 0;
+            }
+
+            return 0;
+        }
+        case AW_MOD_CLK_LCD1CH1_S2: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->Lcd1Ch1Clk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI0: {
+            if ((rate < 1) || (rate > 32)) {
+                return -1;
+            }
+            aw_ccu_reg->Csi0Clk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI1: {
+            if ((rate < 1) || (rate > 32)) {
+                return -1;
+            }
+            aw_ccu_reg->Csi1Clk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_VE: {
+            if ((rate < 1) || (rate > 8)) {
+                return -1;
+            }
+            aw_ccu_reg->VeClk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_ACE: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->AceClk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_HDMI: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->HdmiClk.ClkDiv = rate - 1;
+            return 0;
+        }
+        case AW_MOD_CLK_MALI: {
+            if ((rate < 1) || (rate > 16)) {
+                return -1;
+            }
+            aw_ccu_reg->MaliClk.ClkDiv = rate - 1;
+            return 0;
+        }
+        /* REMOVED */
+        //case AW_MOD_CLK_GPS: {
+        //    if ((rate > 0) && (rate < 9)) {
+        //        aw_ccu_reg->GpsClk.ClkDivRatio = rate - 1;
+        //        return 0;
+        //    }
+        //    return -1;
+        //}
+        case AW_MOD_CLK_TVDMOD1: {
+            if ((rate > 0) && (rate < 17)) {
+                aw_ccu_reg->TvdClk.Clk1Div = rate - 1;
+                return 0;
+            }
+            return -1;
+        }
+        case AW_MOD_CLK_TVDMOD2: {
+            if ((rate > 0) && (rate < 17)) {
+                aw_ccu_reg->TvdClk.Clk2Div = rate - 1;
+                return 0;
+            }
+            return -1;
+        }
+
+        case AW_MOD_CLK_MBUS: {
+#if 0
+            if (rate > 16 * 8) {
+                return -1;
+            } else if (rate > 16 * 4) {
+                aw_ccu_reg->MBusClk.ClkDivN = 3;
+                //aw_ccu_reg->MBusClk.ClkDivM = (rate>>3)-1;
+                aw_ccu_reg->MBusClk.ClkDivM = ((rate + 7) >> 3) - 1;
+            } else if (rate > 16 * 2) {
+                aw_ccu_reg->MBusClk.ClkDivN = 2;
+                //aw_ccu_reg->MBusClk.ClkDivM = (rate>>2)-1;
+                aw_ccu_reg->MBusClk.ClkDivM = ((rate + 3) >> 2) - 1;
+            } else if (rate > 16 * 1) {
+                aw_ccu_reg->MBusClk.ClkDivN = 1;
+                //aw_ccu_reg->MBusClk.ClkDivM = (rate>>1)-1;
+                aw_ccu_reg->MBusClk.ClkDivM = ((rate + 1) >> 1) - 1;
+            } else if (rate > 16 * 0) {
+                aw_ccu_reg->MBusClk.ClkDivN = 0;
+                aw_ccu_reg->MBusClk.ClkDivM = rate - 1;
+            } else {
+                return -1;
+            }
+#else
+            /* valid frequency of mbus:
+             *  200M: N=1, M=2, rate = 6
+             *  300M: N=1, M=1, rate = 4
+             *  400M: N=0, M=2, rate = 3
+             *
+             *  FIXME
+             *  mbus will up to 400M when cpu@1008M, sys vdd@1.3V
+             *  delay 20us util mbus stable.
+             */
+            __ccmu_mbus_clk_reg015c_t mbusclk = aw_ccu_reg->MBusClk;
+            if (6 == rate) {
+                mbusclk.ClkDivN = 1;
+                mbusclk.ClkDivM = 2;
+                aw_ccu_reg->MBusClk = mbusclk;
+                __delay((1008000000 >> 20) * 20);
+            } else if (4 == rate) {
+                mbusclk.ClkDivN = 1;
+                mbusclk.ClkDivM = 1;
+                aw_ccu_reg->MBusClk = mbusclk;
+                __delay((1008000000 >> 20) * 20);
+            } else if (3 == rate) {
+                mbusclk.ClkDivN = 0;
+                mbusclk.ClkDivM = 2;
+                aw_ccu_reg->MBusClk = mbusclk;
+                __delay((1008000000 >> 20) * 20);
+            } else {
+                return -1;
+            }
+#endif
+            return 0;
+        }
+
+        case AW_MOD_CLK_OUTA: {
+            __u32 tmp_rate = rate;
+            if (!(tmp_rate % 750)) {
+                aw_ccu_reg->ClkOutA.ClkSrc = 0;
+                rate = tmp_rate / 750;
+            }
+
+            if (rate > 32 * 8) {
+                return -1;
+            } else if (rate > 32 * 4) {
+                aw_ccu_reg->ClkOutA.ClkDivN = 3;
+                //aw_ccu_reg->ClkOutA.ClkDivM = (rate>>3)-1;
+                aw_ccu_reg->ClkOutA.ClkDivM = ((rate + 7) >> 3) - 1;
+            } else if (rate > 32 * 2) {
+                aw_ccu_reg->ClkOutA.ClkDivN = 2;
+                //aw_ccu_reg->ClkOutA.ClkDivM = (rate>>2)-1;
+                aw_ccu_reg->ClkOutA.ClkDivM = ((rate + 3) >> 2) - 1;
+            } else if (rate > 32 * 1) {
+                aw_ccu_reg->ClkOutA.ClkDivN = 1;
+                //aw_ccu_reg->ClkOutA.ClkDivM = (rate>>1)-1;
+                aw_ccu_reg->ClkOutA.ClkDivM = ((rate + 1) >> 1) - 1;
+            } else if (rate > 32 * 0) {
+                aw_ccu_reg->ClkOutA.ClkDivN = 0;
+                aw_ccu_reg->ClkOutA.ClkDivM = rate - 1;
+            } else {
+                return -1;
+            }
+            return 0;
+        }
+
+        case AW_MOD_CLK_OUTB: {
+            __u32 tmp_rate = rate;
+
+            if (!(tmp_rate % 750)) {
+                aw_ccu_reg->ClkOutB.ClkSrc = 0;
+                rate = tmp_rate / 750;
+            }
+
+            if (rate > 32 * 8) {
+                return -1;
+            } else if (rate > 32 * 4) {
+                aw_ccu_reg->ClkOutB.ClkDivN = 3;
+                //aw_ccu_reg->ClkOutB.ClkDivM = (rate>>3)-1;
+                aw_ccu_reg->ClkOutB.ClkDivM = ((rate + 7) >> 3) - 1;
+            } else if (rate > 32 * 2) {
+                aw_ccu_reg->ClkOutB.ClkDivN = 2;
+                //aw_ccu_reg->ClkOutB.ClkDivM = (rate>>2)-1;
+                aw_ccu_reg->ClkOutB.ClkDivM = ((rate + 3) >> 2) - 1;
+            } else if (rate > 32 * 1) {
+                aw_ccu_reg->ClkOutB.ClkDivN = 1;
+                //aw_ccu_reg->ClkOutB.ClkDivM = (rate>>1)-1;
+                aw_ccu_reg->ClkOutB.ClkDivM = ((rate + 1) >> 1) - 1;
+            } else if (rate > 32 * 0) {
+                aw_ccu_reg->ClkOutB.ClkDivN = 0;
+                aw_ccu_reg->ClkOutB.ClkDivM = rate - 1;
+            } else {
+                return -1;
+            }
+            return 0;
+        }
+
+        case AW_MOD_CLK_LCD0CH0:
+        case AW_MOD_CLK_LCD1CH0:
+        case AW_MOD_CLK_LVDS:
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_SATA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+        case AW_MOD_CLK_AVS:
+        default:
+            return (rate == 1) ? 0 : -1;
+    }
+    return (rate == 1) ? 0 : -1;
+}
+
+/*
+ * Get module clock rate based on hz.
+ *
+ * @id:     module clock id
+ *
+ */
+static __u64 mod_clk_get_rate_hz(__aw_ccu_clk_id_e id)
+{
+    return ccu_clk_uldiv(sys_clk_ops.get_rate(mod_clk_get_parent(id)), mod_clk_get_rate(id));
+}
+
+/*
+ * Set module clock rate based on hz.
+ *
+ * @id:     module clock id
+ * @rate:   module clock division
+ *
+ */
+static int mod_clk_set_rate_hz(__aw_ccu_clk_id_e id, __u64 rate)
+{
+    __u64   parent_rate = sys_clk_ops.get_rate(mod_clk_get_parent(id));
+
+    rate = ccu_clk_uldiv(parent_rate, rate);
+
+    return mod_clk_set_rate(id, rate);
+}
+
+/*
+ * Get module clock reset status.
+ *
+ * @id:     module clock id.
+ *
+ */
+static __aw_ccu_clk_reset_e mod_clk_get_reset(__aw_ccu_clk_id_e id)
+{
+    switch (id) {
+        case AW_MOD_CLK_NFC:
+        case AW_MOD_CLK_MSC:
+        case AW_MOD_CLK_SDC0:
+        case AW_MOD_CLK_SDC1:
+        case AW_MOD_CLK_SDC2:
+        case AW_MOD_CLK_SDC3:
+        case AW_MOD_CLK_TS:
+        case AW_MOD_CLK_SS:
+        case AW_MOD_CLK_SPI0:
+        case AW_MOD_CLK_SPI1:
+        case AW_MOD_CLK_SPI2:
+        case AW_MOD_CLK_PATA:
+        case AW_MOD_CLK_IR0:
+        case AW_MOD_CLK_IR1:
+        case AW_MOD_CLK_I2S0:
+        case AW_MOD_CLK_I2S1:
+        case AW_MOD_CLK_I2S2:
+        case AW_MOD_CLK_AC97:
+        case AW_MOD_CLK_SPDIF:
+        case AW_MOD_CLK_KEYPAD:
+        case AW_MOD_CLK_SATA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+            return AW_CCU_CLK_NRESET;
+
+        case AW_MOD_CLK_USBOHCI0:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_USBOHCI1:
+            return AW_CCU_CLK_NRESET;
+        /* REMOVED */
+        //case AW_MOD_CLK_GPS:
+        //    return aw_ccu_reg->GpsClk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_SPI3:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_DEBE0:
+            return aw_ccu_reg->DeBe0Clk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEBE1:
+            return aw_ccu_reg->DeBe1Clk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEFE0:
+            return aw_ccu_reg->DeFe0Clk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEFE1:
+            return aw_ccu_reg->DeFe1Clk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_DEMIX:
+            return aw_ccu_reg->DeMpClk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_LCD0CH0:
+            return aw_ccu_reg->Lcd0Ch0Clk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_LCD1CH0:
+            return aw_ccu_reg->Lcd1Ch0Clk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_CSIISP:
+        case AW_MOD_CLK_TVDMOD1:
+        case AW_MOD_CLK_TVDMOD2:
+        case AW_MOD_CLK_LCD0CH1_S1:
+        case AW_MOD_CLK_LCD0CH1_S2:
+        case AW_MOD_CLK_LCD1CH1_S1:
+        case AW_MOD_CLK_LCD1CH1_S2:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_CSI0:
+            return aw_ccu_reg->Csi0Clk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_CSI1:
+            return aw_ccu_reg->Csi1Clk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_VE:
+            return aw_ccu_reg->VeClk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_AVS:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_ACE:
+            return aw_ccu_reg->AceClk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_LVDS:
+            return aw_ccu_reg->LvdsClk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        case AW_MOD_CLK_HDMI:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_MALI:
+            return aw_ccu_reg->MaliClk.Reset ? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET;
+        default:
+            return AW_CCU_CLK_NRESET;
+    }
+
+}
+
+/*
+ * Set module clock reset status.
+ *
+ * @id:     module clock id
+ * @reset:  reset status
+ *
+ */
+static __s32 mod_clk_set_reset(__aw_ccu_clk_id_e id, __aw_ccu_clk_reset_e reset)
+{
+    switch (id) {
+        case AW_MOD_CLK_NFC:
+        case AW_MOD_CLK_MSC:
+        case AW_MOD_CLK_SDC0:
+        case AW_MOD_CLK_SDC1:
+        case AW_MOD_CLK_SDC2:
+        case AW_MOD_CLK_SDC3:
+        case AW_MOD_CLK_TS:
+        case AW_MOD_CLK_SS:
+        case AW_MOD_CLK_SPI0:
+        case AW_MOD_CLK_SPI1:
+        case AW_MOD_CLK_SPI2:
+        case AW_MOD_CLK_PATA:
+        case AW_MOD_CLK_IR0:
+        case AW_MOD_CLK_IR1:
+        case AW_MOD_CLK_I2S0:
+        case AW_MOD_CLK_I2S1:
+        case AW_MOD_CLK_I2S2:
+        case AW_MOD_CLK_AC97:
+        case AW_MOD_CLK_SPDIF:
+        case AW_MOD_CLK_KEYPAD:
+        case AW_MOD_CLK_SATA:
+        case AW_MOD_CLK_USBPHY:
+        case AW_MOD_CLK_USBOHCI0:
+        case AW_MOD_CLK_USBOHCI1:
+            return (reset == AW_CCU_CLK_NRESET) ? 0 : -1;
+        case AW_MOD_CLK_USBPHY0:
+        case AW_MOD_CLK_USBPHY1:
+        case AW_MOD_CLK_USBPHY2:
+            return 0;
+        /* REMOVED */
+        //case AW_MOD_CLK_GPS: {
+        //    aw_ccu_reg->GpsClk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+        //    return 0;
+        //}
+        case AW_MOD_CLK_DEBE0: {
+            aw_ccu_reg->DeBe0Clk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE1: {
+            aw_ccu_reg->DeBe1Clk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE0: {
+            aw_ccu_reg->DeFe0Clk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEFE1: {
+            aw_ccu_reg->DeFe1Clk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_DEMIX: {
+            aw_ccu_reg->DeMpClk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD0CH0: {
+            aw_ccu_reg->Lcd0Ch0Clk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_LCD1CH0: {
+            aw_ccu_reg->Lcd1Ch0Clk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI0: {
+            aw_ccu_reg->Csi0Clk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_CSI1: {
+            aw_ccu_reg->Csi1Clk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_VE: {
+            aw_ccu_reg->VeClk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        }
+        case AW_MOD_CLK_ACE:
+            aw_ccu_reg->AceClk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_LVDS:
+            aw_ccu_reg->LvdsClk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+        case AW_MOD_CLK_MALI:
+            aw_ccu_reg->MaliClk.Reset = (reset == AW_CCU_CLK_RESET) ? 0 : 1;
+            return 0;
+
+        case AW_MOD_CLK_ADDA:
+        case AW_MOD_CLK_CSIISP:
+        case AW_MOD_CLK_TVDMOD1:
+        case AW_MOD_CLK_TVDMOD2:
+        case AW_MOD_CLK_LCD0CH1_S1:
+        case AW_MOD_CLK_LCD0CH1_S2:
+        case AW_MOD_CLK_LCD1CH1_S1:
+        case AW_MOD_CLK_LCD1CH1_S2:
+        case AW_MOD_CLK_SPI3:
+        case AW_MOD_CLK_AVS:
+        case AW_MOD_CLK_HDMI:
+        default:
+            return (reset == AW_CCU_CLK_NRESET) ? 0 : -1;
+    }
+    return (reset == AW_CCU_CLK_NRESET) ? 0 : -1;
+}
+
+__clk_ops_t mod_clk_ops = {
+    .set_status = mod_clk_set_status,
+    .get_status = mod_clk_get_status,
+    .set_parent = mod_clk_set_parent,
+    .get_parent = mod_clk_get_parent,
+    .get_rate = mod_clk_get_rate_hz,
+    .set_rate = mod_clk_set_rate_hz,
+    .round_rate = 0,
+    .get_reset = mod_clk_get_reset,
+    .set_reset = mod_clk_set_reset,
+};
diff --git a/arch/arm/mach-sun7i/clock/pll_cfg.c b/arch/arm/mach-sun7i/clock/pll_cfg.c
new file mode 100644
index 0000000..3e661c5
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/pll_cfg.c
@@ -0,0 +1,297 @@
+/*
+ * arch/arm/mach-sun7i/clock/ccmu/pll_cfg.c
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include "ccm_i.h"
+
+struct pll1_freq_cfg_tbl {
+    __u8  FactorN;
+    __u8  FactorK;
+    __u8  FactorM;
+    __u8  FactorP;
+    __u32 Pll;
+};
+
+/* core pll parameter table */
+static struct pll1_freq_cfg_tbl CorePllTbl[] = {
+
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 0   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 1   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 2   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 3   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 4   */
+    { 10,    0,    0,    3,    30000000  },   /* freq = (6M * 5  ), index = 5   */
+    { 12,    0,    0,    3,    36000000  },   /* freq = (6M * 6  ), index = 6   */
+    { 7 ,    1,    0,    3,    42000000  },   /* freq = (6M * 7  ), index = 7   */
+    { 16,    0,    0,    3,    48000000  },   /* freq = (6M * 8  ), index = 8   */
+    { 9 ,    1,    0,    3,    54000000  },   /* freq = (6M * 9  ), index = 9   */
+    { 10,    0,    0,    2,    60000000  },   /* freq = (6M * 10 ), index = 10  */
+    { 11,    0,    0,    2,    66000000  },   /* freq = (6M * 11 ), index = 11  */
+    { 12,    0,    0,    2,    72000000  },   /* freq = (6M * 12 ), index = 12  */
+    { 13,    0,    0,    2,    78000000  },   /* freq = (6M * 13 ), index = 13  */
+    { 14,    0,    0,    2,    84000000  },   /* freq = (6M * 14 ), index = 14  */
+    { 15,    0,    0,    2,    90000000  },   /* freq = (6M * 15 ), index = 15  */
+    { 16,    0,    0,    2,    96000000  },   /* freq = (6M * 16 ), index = 16  */
+    { 17,    0,    0,    2,    102000000 },   /* freq = (6M * 17 ), index = 17  */
+    { 18,    0,    0,    2,    108000000 },   /* freq = (6M * 18 ), index = 18  */
+    { 19,    0,    0,    2,    114000000 },   /* freq = (6M * 19 ), index = 19  */
+    { 10,    0,    0,    1,    120000000 },   /* freq = (6M * 20 ), index = 20  */
+    { 21,    0,    0,    2,    126000000 },   /* freq = (6M * 21 ), index = 21  */
+    { 11,    0,    0,    1,    132000000 },   /* freq = (6M * 22 ), index = 22  */
+    { 23,    0,    0,    2,    138000000 },   /* freq = (6M * 23 ), index = 23  */
+    { 12,    0,    0,    1,    144000000 },   /* freq = (6M * 24 ), index = 24  */
+    { 25,    0,    0,    2,    150000000 },   /* freq = (6M * 25 ), index = 25  */
+    { 13,    0,    0,    1,    156000000 },   /* freq = (6M * 26 ), index = 26  */
+    { 27,    0,    0,    2,    162000000 },   /* freq = (6M * 27 ), index = 27  */
+    { 14,    0,    0,    1,    168000000 },   /* freq = (6M * 28 ), index = 28  */
+    { 29,    0,    0,    2,    174000000 },   /* freq = (6M * 29 ), index = 29  */
+    { 15,    0,    0,    1,    180000000 },   /* freq = (6M * 30 ), index = 30  */
+    { 31,    0,    0,    2,    186000000 },   /* freq = (6M * 31 ), index = 31  */
+    { 16,    0,    0,    1,    192000000 },   /* freq = (6M * 32 ), index = 32  */
+    { 16,    0,    0,    1,    192000000 },   /* freq = (6M * 32 ), index = 33  */
+    { 17,    0,    0,    1,    204000000 },   /* freq = (6M * 34 ), index = 34  */
+    { 17,    0,    0,    1,    204000000 },   /* freq = (6M * 34 ), index = 35  */
+    { 18,    0,    0,    1,    216000000 },   /* freq = (6M * 36 ), index = 36  */
+    { 18,    0,    0,    1,    216000000 },   /* freq = (6M * 36 ), index = 37  */
+    { 19,    0,    0,    1,    228000000 },   /* freq = (6M * 38 ), index = 38  */
+    { 19,    0,    0,    1,    228000000 },   /* freq = (6M * 38 ), index = 39  */
+    { 10,    0,    0,    0,    240000000 },   /* freq = (6M * 40 ), index = 40  */
+    { 10,    0,    0,    0,    240000000 },   /* freq = (6M * 40 ), index = 41  */
+    { 21,    0,    0,    1,    252000000 },   /* freq = (6M * 42 ), index = 42  */
+    { 21,    0,    0,    1,    252000000 },   /* freq = (6M * 42 ), index = 43  */
+    { 11,    0,    0,    0,    264000000 },   /* freq = (6M * 44 ), index = 44  */
+    { 11,    0,    0,    0,    264000000 },   /* freq = (6M * 44 ), index = 45  */
+    { 23,    0,    0,    1,    276000000 },   /* freq = (6M * 46 ), index = 46  */
+    { 23,    0,    0,    1,    276000000 },   /* freq = (6M * 46 ), index = 47  */
+    { 12,    0,    0,    0,    288000000 },   /* freq = (6M * 48 ), index = 48  */
+    { 12,    0,    0,    0,    288000000 },   /* freq = (6M * 48 ), index = 49  */
+    { 25,    0,    0,    1,    300000000 },   /* freq = (6M * 50 ), index = 50  */
+    { 25,    0,    0,    1,    300000000 },   /* freq = (6M * 50 ), index = 51  */
+    { 13,    0,    0,    0,    312000000 },   /* freq = (6M * 52 ), index = 52  */
+    { 13,    0,    0,    0,    312000000 },   /* freq = (6M * 52 ), index = 53  */
+    { 27,    0,    0,    1,    324000000 },   /* freq = (6M * 54 ), index = 54  */
+    { 27,    0,    0,    1,    324000000 },   /* freq = (6M * 54 ), index = 55  */
+    { 14,    0,    0,    0,    336000000 },   /* freq = (6M * 56 ), index = 56  */
+    { 14,    0,    0,    0,    336000000 },   /* freq = (6M * 56 ), index = 57  */
+    { 29,    0,    0,    1,    348000000 },   /* freq = (6M * 58 ), index = 58  */
+    { 29,    0,    0,    1,    348000000 },   /* freq = (6M * 58 ), index = 59  */
+    { 15,    0,    0,    0,    360000000 },   /* freq = (6M * 60 ), index = 60  */
+    { 15,    0,    0,    0,    360000000 },   /* freq = (6M * 60 ), index = 61  */
+    { 31,    0,    0,    1,    372000000 },   /* freq = (6M * 62 ), index = 62  */
+    { 31,    0,    0,    1,    372000000 },   /* freq = (6M * 62 ), index = 63  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 64  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 65  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 66  */
+    { 16,    0,    0,    0,    384000000 },   /* freq = (6M * 64 ), index = 67  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 68  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 69  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 70  */
+    { 17,    0,    0,    0,    408000000 },   /* freq = (6M * 68 ), index = 71  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 72  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 73  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 74  */
+    { 18,    0,    0,    0,    432000000 },   /* freq = (6M * 72 ), index = 75  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 76  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 77  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 78  */
+    { 19,    0,    0,    0,    456000000 },   /* freq = (6M * 76 ), index = 79  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 80  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 81  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 82  */
+    { 20,    0,    0,    0,    480000000 },   /* freq = (6M * 80 ), index = 83  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 84  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 85  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 86  */
+    { 21,    0,    0,    0,    504000000 },   /* freq = (6M * 84 ), index = 87  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 88  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 89  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 90  */
+    { 22,    0,    0,    0,    528000000 },   /* freq = (6M * 88 ), index = 91  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 92  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 93  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 94  */
+    { 23,    0,    0,    0,    552000000 },   /* freq = (6M * 92 ), index = 95  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 96  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 97  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 98  */
+    { 24,    0,    0,    0,    576000000 },   /* freq = (6M * 96 ), index = 99  */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 100 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 101 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 102 */
+    { 25,    0,    0,    0,    600000000 },   /* freq = (6M * 100), index = 103 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 104 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 105 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 106 */
+    { 26,    0,    0,    0,    624000000 },   /* freq = (6M * 104), index = 107 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 108 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 109 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 110 */
+    { 27,    0,    0,    0,    648000000 },   /* freq = (6M * 108), index = 111 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 112 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 113 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 114 */
+    { 28,    0,    0,    0,    672000000 },   /* freq = (6M * 112), index = 115 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 116 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 117 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 118 */
+    { 29,    0,    0,    0,    696000000 },   /* freq = (6M * 116), index = 119 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 120 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 121 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 122 */
+    { 30,    0,    0,    0,    720000000 },   /* freq = (6M * 120), index = 123 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 124 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 125 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 126 */
+    { 31,    0,    0,    0,    744000000 },   /* freq = (6M * 124), index = 127 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 128 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 129 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 130 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 131 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 132 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 133 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 134 */
+    { 16,    1,    0,    0,    768000000 },   /* freq = (6M * 128), index = 135 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 136 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 137 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 138 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 139 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 140 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 141 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 142 */
+    { 17,    1,    0,    0,    816000000 },   /* freq = (6M * 136), index = 143 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 144 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 145 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 146 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 147 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 148 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 149 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 150 */
+    { 18,    1,    0,    0,    864000000 },   /* freq = (6M * 144), index = 151 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 152 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 153 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 154 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 155 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 156 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 157 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 158 */
+    { 19,    1,    0,    0,    912000000 },   /* freq = (6M * 152), index = 159 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 160 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 161 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 162 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 163 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 164 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 165 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 166 */
+    { 20,    1,    0,    0,    960000000 },   /* freq = (6M * 160), index = 167 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 168 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 169 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 170 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 171 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 172 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 173 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 174 */
+    { 21,    1,    0,    0,    1008000000},   /* freq = (6M * 168), index = 175 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 176 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 177 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 178 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 179 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 180 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 181 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 182 */
+    { 22,    1,    0,    0,    1056000000},   /* freq = (6M * 176), index = 183 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 184 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 185 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 186 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 187 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 188 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 189 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 190 */
+    { 23,    1,    0,    0,    1104000000},   /* freq = (6M * 184), index = 191 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 192 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 193 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 194 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 195 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 196 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 197 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 198 */
+    { 24,    1,    0,    0,    1152000000},   /* freq = (6M * 192), index = 199 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 200 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 201 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 202 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 203 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 204 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 205 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 206 */
+    { 25,    1,    0,    0,    1200000000},   /* freq = (6M * 200), index = 207 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 208 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 209 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 210 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 211 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 212 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 213 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 214 */
+    { 26,    1,    0,    0,    1248000000},   /* freq = (6M * 208), index = 215 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 216 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 217 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 218 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 219 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 220 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 221 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 222 */
+    { 27,    1,    0,    0,    1296000000},   /* freq = (6M * 216), index = 223 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 224 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 225 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 226 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 227 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 228 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 229 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 230 */
+    { 28,    1,    0,    0,    1344000000},   /* freq = (6M * 224), index = 231 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 232 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 233 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 234 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 235 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 236 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 237 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 238 */
+    { 29,    1,    0,    0,    1392000000},   /* freq = (6M * 232), index = 239 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 240 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 241 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 242 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 243 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 244 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 245 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 246 */
+    { 30,    1,    0,    0,    1440000000},   /* freq = (6M * 240), index = 247 */
+    { 31,    1,    0,    0,    1488000000},   /* freq = (6M * 248), index = 248 */
+};
+
+int ccm_clk_get_pll_para(struct core_pll_factor_t *factor, __u64 rate)
+{
+    int index;
+
+    if (!factor) {
+        return -1;
+    }
+
+    if (rate > 1488000000) {
+        rate = 1488000000;
+    }
+    index = ccu_clk_uldiv(rate, 6000000);
+
+    factor->FactorN = CorePllTbl[index].FactorN;
+    factor->FactorK = CorePllTbl[index].FactorK;
+    factor->FactorM = CorePllTbl[index].FactorM;
+    factor->FactorP = CorePllTbl[index].FactorP;
+
+    return 0;
+}
diff --git a/arch/arm/mach-sun7i/clock/sys_clk.c b/arch/arm/mach-sun7i/clock/sys_clk.c
new file mode 100644
index 0000000..0928935
--- /dev/null
+++ b/arch/arm/mach-sun7i/clock/sys_clk.c
@@ -0,0 +1,924 @@
+/*
+ * arch/arm/mach-sun7i/clock/ccmu/ccm_sys_clk.c
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/includes.h>
+#include <asm/delay.h>
+#include "ccm_i.h"
+
+/*
+ * Get parent clock for system clock.
+ *
+ * @id:     system clock id.
+ *
+ */
+static __aw_ccu_clk_id_e sys_clk_get_parent(__aw_ccu_clk_id_e id)
+{
+    switch (id) {
+        case AW_SYS_CLK_PLL2X8: {
+            return AW_SYS_CLK_PLL2;
+        }
+        case AW_SYS_CLK_PLL3X2: {
+            return AW_SYS_CLK_PLL3;
+        }
+        case AW_SYS_CLK_PLL7X2: {
+            return AW_SYS_CLK_PLL7;
+        }
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P: {
+            return AW_SYS_CLK_PLL5;
+        }
+        case AW_SYS_CLK_CPU: {
+            switch (aw_ccu_reg->SysClkDiv.AC327ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_LOSC;
+                case 1:
+                    return AW_SYS_CLK_HOSC;
+                case 2:
+                    return AW_SYS_CLK_PLL1;
+                case 3:
+                    return AW_SYS_CLK_PLL6;
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+        }
+        case AW_SYS_CLK_AXI: {
+            return AW_SYS_CLK_CPU;
+        }
+        case AW_SYS_CLK_ATB: {
+            return AW_SYS_CLK_CPU;
+        }
+        case AW_SYS_CLK_AHB: {
+            switch (aw_ccu_reg->SysClkDiv.AHBClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_AXI;
+                case 1:
+                    return AW_SYS_CLK_PLL62;
+                case 2:
+                    return AW_SYS_CLK_PLL6;
+                default:
+                    aw_ccu_reg->SysClkDiv.AHBClkSrc = 0;
+                    return AW_SYS_CLK_AXI;
+            }
+        }
+        case AW_SYS_CLK_APB0: {
+            return AW_SYS_CLK_AHB;
+        }
+        case AW_SYS_CLK_APB1: {
+            switch (aw_ccu_reg->Apb1ClkDiv.ClkSrc) {
+                case 0:
+                    return AW_SYS_CLK_HOSC;
+                case 1:
+                    return AW_SYS_CLK_PLL62;
+                case 2:
+                    return AW_SYS_CLK_LOSC;
+                case 3:
+                default:
+                    return AW_SYS_CLK_NONE;
+            }
+        }
+        default: {
+            return AW_SYS_CLK_NONE;
+        }
+    }
+}
+
+/*
+ * Get system clock on/off status.
+ *
+ * @id:     system clock id.
+ *
+ */
+static __aw_ccu_clk_onff_e sys_clk_get_status(__aw_ccu_clk_id_e id)
+{
+    switch (id) {
+        case AW_SYS_CLK_LOSC:
+            return AW_CCU_CLK_ON;
+        case AW_SYS_CLK_HOSC:
+            return aw_ccu_reg->HoscCtl.OSC24MEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_SYS_CLK_PLL1:
+            return aw_ccu_reg->Pll1Ctl.PLLEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL2:
+        case AW_SYS_CLK_PLL2X8:
+            return aw_ccu_reg->Pll2Ctl.PLLEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL3X2:
+            return aw_ccu_reg->Pll3Ctl.PLLEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL4:
+            return aw_ccu_reg->Pll4Ctl.PLLEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL5:
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+            return aw_ccu_reg->Pll5Ctl.PLLEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL6:
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62:
+            return aw_ccu_reg->Pll6Ctl.PLLEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL7X2:
+            return aw_ccu_reg->Pll7Ctl.PLLEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL8:
+            return aw_ccu_reg->Pll8Ctl.PLLEn ? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_CPU:
+        case AW_SYS_CLK_AXI:
+        case AW_SYS_CLK_ATB:
+        case AW_SYS_CLK_AHB:
+            return sys_clk_get_status(sys_clk_get_parent(id));
+        case AW_SYS_CLK_APB0:
+        case AW_SYS_CLK_APB1:
+        default:
+            return AW_CCU_CLK_ON;
+    }
+}
+
+/*
+ * Get clock rate for system clock.
+ *
+ * @id:     system clock id.
+ *
+ */
+static __u64 sys_clk_get_rate(__aw_ccu_clk_id_e id)
+{
+    switch (id) {
+        case AW_SYS_CLK_NONE: {
+            return 1;
+        }
+
+        case AW_SYS_CLK_LOSC: {
+            return 32768;
+        }
+        case AW_SYS_CLK_HOSC: {
+            return 24000000;
+        }
+        case AW_SYS_CLK_PLL1: {
+            return ccu_clk_uldiv(((__s64)24000000 * aw_ccu_reg->Pll1Ctl.FactorN * (aw_ccu_reg->Pll1Ctl.FactorK + 1)   \
+                                  >> aw_ccu_reg->Pll1Ctl.PLLDivP), (aw_ccu_reg->Pll1Ctl.FactorM + 1));
+        }
+        case AW_SYS_CLK_PLL2: {
+            __u32   tmpReg;
+
+            /*  FactorN=79, PreDiv=21, PostDiv=4, output=24*79/21/4=22.571mhz, 44.1k series fs
+                FactorN=86, PreDiv=21, PostDiv=4, output=24*86/21/4=24.571mhz, 48k series fs */
+            tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+            if (((tmpReg >> 8) & 0x7f) == 79) {
+                return 22579200; /* 22.571mhz ~= 22579200, 22579200*2/1024=44100 */
+            } else if (((tmpReg >> 8) & 0x7f) == 86) {
+                return 24576000; /* 24.571mhz ~= 24576000, 24576000*2/1024=48000 */
+            } else {
+                /* set audio pll to default value 24576000 */
+                tmpReg &= ~((0x1f << 0) | (0x7f << 8) | (0x0f << 26));
+                tmpReg |= (21 << 0) | (86 << 8) | (4 << 26);
+                *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+                return 24576000;
+            }
+        }
+        case AW_SYS_CLK_PLL2X8: {
+            if (sys_clk_get_rate(AW_SYS_CLK_PLL2) == 24576000) {
+                return 24576000 * 18; /* why not 24576000 * 8? */
+            } else {
+                return 22579200 * 20; /* why not 22579200 * 8? */
+            }
+        }
+        case AW_SYS_CLK_PLL3: {
+            __s64   tmp_rate;
+
+            if (!aw_ccu_reg->Pll3Ctl.ModeSel) {
+                if (aw_ccu_reg->Pll3Ctl.FracSet) {
+                    return 297000000;
+                } else {
+                    return 270000000;
+                }
+            } else {
+                tmp_rate = 3000000 * aw_ccu_reg->Pll3Ctl.FactorM;
+                /* skip 270M and 297M */
+                if (tmp_rate == 270000000) {
+                    return 273000000;
+                } else if (tmp_rate == 297000000) {
+                    return 300000000;
+                }
+
+                return tmp_rate;
+            }
+        }
+        case AW_SYS_CLK_PLL3X2: {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL3) << 1;
+        }
+
+        case AW_SYS_CLK_PLL4: {
+            return (__s64)24000000 * aw_ccu_reg->Pll4Ctl.FactorN * (aw_ccu_reg->Pll4Ctl.FactorK + 1);
+        }
+        case AW_SYS_CLK_PLL5: {
+            return (__s64)24000000 * aw_ccu_reg->Pll5Ctl.FactorN * (aw_ccu_reg->Pll5Ctl.FactorK + 1);
+        }
+        case AW_SYS_CLK_PLL5M: {
+            return ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_PLL5), (aw_ccu_reg->Pll5Ctl.FactorM + 1));
+        }
+        case AW_SYS_CLK_PLL5P: {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL5) >> aw_ccu_reg->Pll5Ctl.FactorP;
+        }
+        case AW_SYS_CLK_PLL6: {
+            return (__s64)24000000 * aw_ccu_reg->Pll6Ctl.FactorN * (aw_ccu_reg->Pll6Ctl.FactorK + 1) >> 1;
+        }
+        case AW_SYS_CLK_PLL6M: {
+            return ccu_clk_uldiv((__s64)24000000 * aw_ccu_reg->Pll6Ctl.FactorN * (aw_ccu_reg->Pll6Ctl.FactorK + 1),   \
+                                 (aw_ccu_reg->Pll6Ctl.FactorM + 1) * 6);
+        }
+        case AW_SYS_CLK_PLL62: {
+            return (__s64)24000000 * aw_ccu_reg->Pll6Ctl.FactorN * (aw_ccu_reg->Pll6Ctl.FactorK + 1) >> 2;
+        }
+        case AW_SYS_CLK_PLL6X2: {
+            return (__s64)24000000 * aw_ccu_reg->Pll6Ctl.FactorN * (aw_ccu_reg->Pll6Ctl.FactorK + 1);
+        }
+        case AW_SYS_CLK_PLL7: {
+            if (!aw_ccu_reg->Pll7Ctl.ModeSel) {
+                if (aw_ccu_reg->Pll7Ctl.FracSet) {
+                    return 297000000;
+                } else {
+                    return 270000000;
+                }
+            } else {
+                return (__s64)3000000 * aw_ccu_reg->Pll7Ctl.FactorM;
+            }
+        }
+        case AW_SYS_CLK_PLL7X2: {
+            return sys_clk_get_rate(AW_SYS_CLK_PLL7) << 1;
+        }
+        case AW_SYS_CLK_PLL8: {
+            return (__s64)24000000 * aw_ccu_reg->Pll8Ctl.FactorN * (aw_ccu_reg->Pll8Ctl.FactorK + 1);
+        }
+        case AW_SYS_CLK_CPU: {
+            __u32   tmpCpuRate;
+            switch (aw_ccu_reg->SysClkDiv.AC327ClkSrc) {
+                case 0:
+                    tmpCpuRate = 32768;
+                    break;
+                case 1:
+                    tmpCpuRate = 24000000;
+                    break;
+                case 2:
+                    tmpCpuRate = sys_clk_get_rate(AW_SYS_CLK_PLL1);
+                    break;
+                case 3:
+                default:
+                    tmpCpuRate = 200000000;
+                    break;
+            }
+            return tmpCpuRate;
+        }
+        case AW_SYS_CLK_AXI: {
+            return ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU), (aw_ccu_reg->SysClkDiv.AXIClkDiv + 1));
+        }
+        case AW_SYS_CLK_ATB: {
+            __u32   div;
+            switch (aw_ccu_reg->SysClkDiv.AtbApbClkDiv) {
+                case 0:
+                    div = 1;
+                    break;
+                case 1:
+                    div = 2;
+                    break;
+                default:
+                    div = 4;
+            }
+            return ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU), div);
+        }
+        case AW_SYS_CLK_AHB: {
+            return sys_clk_get_rate(sys_clk_get_parent(AW_SYS_CLK_AHB)) >> aw_ccu_reg->SysClkDiv.AHBClkDiv;
+        }
+        case AW_SYS_CLK_APB0: {
+            __s32   tmpShift = aw_ccu_reg->SysClkDiv.APB0ClkDiv;
+
+            return sys_clk_get_rate(AW_SYS_CLK_AHB) >> (tmpShift ? tmpShift : 1);
+        }
+        case AW_SYS_CLK_APB1: {
+            __s64   tmpApb1Rate;
+            switch (aw_ccu_reg->Apb1ClkDiv.ClkSrc) {
+                case 0:
+                    tmpApb1Rate = 24000000;
+                    break;
+                case 1:
+                    tmpApb1Rate = sys_clk_get_rate(AW_SYS_CLK_PLL62);
+                    break;
+                case 2:
+                    tmpApb1Rate = 32768;
+                    break;
+                default:
+                    tmpApb1Rate = 0;
+                    break;
+            }
+            return ccu_clk_uldiv((tmpApb1Rate >> aw_ccu_reg->Apb1ClkDiv.PreDiv), (aw_ccu_reg->Apb1ClkDiv.ClkDiv + 1));
+        }
+        default: {
+            return 0;
+        }
+    }
+}
+
+/*
+ * Set parent clock id for system clock.
+ *
+ * @id:     system clock id whose parent need to be set.
+ * @parent: parent id.
+ *
+ */
+static __s32 sys_clk_set_parent(__aw_ccu_clk_id_e id, __aw_ccu_clk_id_e parent)
+{
+    switch (id) {
+        case AW_SYS_CLK_PLL2X8:
+            return (parent == AW_SYS_CLK_PLL2) ? 0 : -1;
+
+        case AW_SYS_CLK_PLL3X2:
+            return (parent == AW_SYS_CLK_PLL3) ? 0 : -1;
+
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P:
+            return (parent == AW_SYS_CLK_PLL5) ? 0 : -1;
+
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62:
+            return (parent == AW_SYS_CLK_PLL6) ? 0 : -1;
+
+        case AW_SYS_CLK_PLL7X2:
+            return (parent == AW_SYS_CLK_PLL7) ? 0 : -1;
+
+        case AW_SYS_CLK_CPU: {
+            switch (parent) {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->SysClkDiv.AC327ClkSrc = 0;
+                    break;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->SysClkDiv.AC327ClkSrc = 1;
+                    break;
+                case AW_SYS_CLK_PLL1:
+                    aw_ccu_reg->SysClkDiv.AC327ClkSrc = 2;
+                    break;
+                default:
+                    return -1;
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_AXI:
+            return (parent == AW_SYS_CLK_CPU) ? 0 : -1;
+        case AW_SYS_CLK_ATB:
+            return (parent == AW_SYS_CLK_CPU) ? 0 : -1;
+        case AW_SYS_CLK_AHB: {
+            switch (parent) {
+                case AW_SYS_CLK_AXI:
+                    aw_ccu_reg->SysClkDiv.AHBClkSrc = 0;
+                    break;
+                case AW_SYS_CLK_PLL62:
+                    aw_ccu_reg->SysClkDiv.AHBClkSrc = 1;
+                    break;
+                case AW_SYS_CLK_PLL6:
+                    aw_ccu_reg->SysClkDiv.AHBClkSrc = 2;
+                    break;
+                default:
+                    return -1;
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_APB0:
+            return (parent == AW_SYS_CLK_AHB) ? 0 : -1;
+        case AW_SYS_CLK_APB1: {
+            switch (parent) {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 2;
+                    break;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 0;
+                    break;
+                case AW_SYS_CLK_PLL62:
+                    aw_ccu_reg->Apb1ClkDiv.ClkSrc = 1;
+                    break;
+                default:
+                    return -1;
+            }
+            return 0;
+        }
+
+        case AW_SYS_CLK_LOSC:
+        case AW_SYS_CLK_HOSC:
+        case AW_SYS_CLK_PLL1:
+        case AW_SYS_CLK_PLL2:
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL4:
+        case AW_SYS_CLK_PLL5:
+        case AW_SYS_CLK_PLL6:
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL8: {
+            return (parent == AW_SYS_CLK_NONE) ? 0 : -1;
+        }
+
+        default: {
+            return -1;
+        }
+    }
+}
+
+/*
+ * Set on/off status for system clock.
+ *
+ * @id:     System clock id.
+ * @status: AW_CCU_CLK_OFF/AW_CCU_CLK_ON.
+ *
+ */
+static __s32 sys_clk_set_status(__aw_ccu_clk_id_e id, __aw_ccu_clk_onff_e status)
+{
+    switch (id) {
+        case AW_SYS_CLK_LOSC:
+            return 0;
+        case AW_SYS_CLK_HOSC:
+            aw_ccu_reg->HoscCtl.OSC24MEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL1:
+            aw_ccu_reg->Pll1Ctl.PLLEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL2:
+            aw_ccu_reg->Pll2Ctl.PLLEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL2X8: {
+            if (status && !aw_ccu_reg->Pll2Ctl.PLLEn) {
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL3:
+            aw_ccu_reg->Pll3Ctl.PLLEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL3X2: {
+            if (status && !aw_ccu_reg->Pll3Ctl.PLLEn) {
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL4:
+            aw_ccu_reg->Pll4Ctl.PLLEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL5:
+            aw_ccu_reg->Pll5Ctl.PLLEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL5M:
+        case AW_SYS_CLK_PLL5P: {
+            if (status && !aw_ccu_reg->Pll5Ctl.PLLEn) {
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL6:
+            aw_ccu_reg->Pll6Ctl.PLLEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL6M:
+        case AW_SYS_CLK_PLL62: {
+            if (status && !aw_ccu_reg->Pll6Ctl.PLLEn) {
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL7:
+            aw_ccu_reg->Pll7Ctl.PLLEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL7X2: {
+            if (status && !aw_ccu_reg->Pll7Ctl.PLLEn) {
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL8:
+            aw_ccu_reg->Pll8Ctl.PLLEn = (status == AW_CCU_CLK_ON) ? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_CPU:
+        case AW_SYS_CLK_AXI:
+        case AW_SYS_CLK_ATB:
+        case AW_SYS_CLK_AHB:
+        case AW_SYS_CLK_APB0:
+        case AW_SYS_CLK_APB1:
+            return 0;
+
+        default: {
+            return -1;
+        }
+    }
+}
+
+/*
+ * Set clock rate for system clock.
+ *
+ * @id:     system clock id
+ * @rate:   clock rate for system clock
+ *
+ */
+static int sys_clk_set_rate(__aw_ccu_clk_id_e id, __u64 rate)
+{
+    switch (id) {
+        case AW_SYS_CLK_LOSC:
+            return (rate == 32768) ? 0 : -1;
+
+        case AW_SYS_CLK_HOSC:
+            return (rate == 24000000) ? 0 : -1;
+        case AW_SYS_CLK_PLL1: {
+            struct core_pll_factor_t    factor;
+            __ccmu_pll1_core_reg0000_t  tmp_pll;
+
+            /* the setting of pll1 must be called by cpu-freq driver, and adjust pll step by step */
+            ccm_clk_get_pll_para(&factor, rate);
+            /* set factor */
+            tmp_pll = aw_ccu_reg->Pll1Ctl;
+            if (tmp_pll.PLLDivP < factor.FactorP) {
+                tmp_pll.PLLDivP = factor.FactorP;
+                aw_ccu_reg->Pll1Ctl = tmp_pll;
+                __delay(rate >> 20);
+
+                tmp_pll.FactorN = factor.FactorN;
+                tmp_pll.FactorK = factor.FactorK;
+                tmp_pll.FactorM = factor.FactorM;
+                aw_ccu_reg->Pll1Ctl = tmp_pll;
+                /* delay 500us for pll be stably */
+                __delay((rate >> 20) * 500);
+            } else if (tmp_pll.PLLDivP == factor.FactorP) {
+                tmp_pll.FactorN = factor.FactorN;
+                tmp_pll.FactorK = factor.FactorK;
+                tmp_pll.FactorM = factor.FactorM;
+                tmp_pll.PLLDivP = factor.FactorP;
+                aw_ccu_reg->Pll1Ctl = tmp_pll;
+                /* delay 500us for pll be stably */
+                __delay((rate >> 20) * 500);
+            } else {
+                tmp_pll.FactorN = factor.FactorN;
+                tmp_pll.FactorK = factor.FactorK;
+                tmp_pll.FactorM = factor.FactorM;
+                aw_ccu_reg->Pll1Ctl = tmp_pll;
+                /* delay 500us for pll be stably */
+                __delay((rate >> 20) * 500);
+
+                tmp_pll.PLLDivP = factor.FactorP;
+                aw_ccu_reg->Pll1Ctl = tmp_pll;
+                __delay(rate >> 20);
+            }
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL2: {
+            if (rate == 22579200) {
+                /* FactorN=79, PreDiv=21, PostDiv=4,
+                   output=24*79/21/4=22.571mhz, 44.1k series fs */
+                __u32   tmpReg;
+
+                tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+                tmpReg &= ~((0x1f << 0) | (0x7f << 8) | (0x0f << 26));
+                tmpReg |= (21 << 0) | (79 << 8) | (4 << 26);
+                *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+            } else if (rate == 24576000) {
+                /* FactorN=86, PreDiv=21, PostDiv=4,
+                   output=24*86/21/4=24.571mhz, 48k series fs   */
+                __u32   tmpReg;
+
+                tmpReg = *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl;
+                tmpReg &= ~((0x1f << 0) | (0x7f << 8) | (0x0f << 26));
+                tmpReg |= (21 << 0) | (86 << 8) | (4 << 26);
+                *(volatile __u32 *)&aw_ccu_reg->Pll2Ctl = tmpReg;
+            } else {
+                return -1;
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL2X8: {
+            if ((sys_clk_get_rate(AW_SYS_CLK_PLL2) == 24576000) && (rate == 24576000 * 18)) {
+                return 0;
+            } else if ((sys_clk_get_rate(AW_SYS_CLK_PLL2) == 22579200) && (rate == 24576000 * 20)) {
+                return 0;
+            }
+
+            return -1;
+        }
+        case AW_SYS_CLK_PLL3: {
+            if ((rate < 9 * 3000000) || (rate > (127 * 3000000))) {
+                CCU_ERR("rate (%llu) is invalid when set PLL3 rate\n", rate);
+                return -1;
+            }
+
+            if (rate == 270000000) {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll3Ctl.FracSet = 0;
+            } else if (rate == 297000000) {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll3Ctl.FracSet = 1;
+            } else {
+                aw_ccu_reg->Pll3Ctl.ModeSel = 1;
+                aw_ccu_reg->Pll3Ctl.FactorM = ccu_clk_uldiv(rate, 3000000);
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL3X2: {
+            if (rate == (sys_clk_get_rate(AW_SYS_CLK_PLL3) << 1)) {
+                return 0;
+            }
+            return -1;
+        }
+        case AW_SYS_CLK_PLL4: {
+            __s32   tmpFactorN, tmpFactorK;
+
+            if (rate <= 600000000)
+                tmpFactorK = 0;
+            else if (rate <= 1200000000)
+                tmpFactorK = 1;
+            else {
+                CCU_ERR("rate (%llu) is invaid for PLL4\n", rate);
+                return -1;
+            }
+
+            tmpFactorN = ccu_clk_uldiv(rate, ((tmpFactorK + 1) * 24000000));
+            if (tmpFactorN > 31) {
+                CCU_ERR("rate (%llu) is invaid for PLL4\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Pll4Ctl.FactorN = tmpFactorN;
+            aw_ccu_reg->Pll4Ctl.FactorK = tmpFactorK;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5: {
+            __s32   tmpFactorN, tmpFactorK;
+
+            if (rate < 240000000) {
+                CCU_ERR("rate (%llu) is invalid when set PLL5 rate\n", rate);
+                return -1;
+            }
+
+            if (rate < 480000000) {
+                tmpFactorK = 0;
+            } else if (rate < 960000000) {
+                tmpFactorK = 1;
+            } else if (rate < 2000000000) {
+                tmpFactorK = 3;
+            } else {
+                CCU_ERR("rate (%llu) is invaid for PLL5\n", rate);
+                return -1;
+            }
+
+            tmpFactorN = ccu_clk_uldiv(rate, ((tmpFactorK + 1) * 24000000));
+            if (tmpFactorN > 31) {
+                CCU_ERR("rate (%llu) is invaid for PLL5\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Pll5Ctl.FactorN = tmpFactorN;
+            aw_ccu_reg->Pll5Ctl.FactorK = tmpFactorK;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5M: {
+            __u32   tmpFactorM;
+            __s64   tmpPLL5;
+
+            tmpPLL5 = sys_clk_get_rate(AW_SYS_CLK_PLL5);
+            if ((rate > tmpPLL5) || (tmpPLL5 > rate * 4)) {
+                CCU_ERR("PLL5 (%llu) rate is invalid for PLL5M(%lld)!\n", tmpPLL5, rate);
+                return -1;
+            }
+
+            tmpFactorM = ccu_clk_uldiv(tmpPLL5, rate);
+            aw_ccu_reg->Pll5Ctl.FactorM = tmpFactorM - 1;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL5P: {
+            __s32   tmpFactorP = -1;
+            __s64   tmpPLL5 = sys_clk_get_rate(AW_SYS_CLK_PLL5);
+
+            if ((rate > tmpPLL5) || (tmpPLL5 > rate * 8)) {
+                CCU_ERR("PLL5 (%llu) rate is invalid for PLL5P(%lld)!\n", tmpPLL5, rate);
+                return -1;
+            }
+
+            do {
+                rate <<= 1;
+                tmpFactorP++;
+            } while (rate < tmpPLL5);
+            aw_ccu_reg->Pll5Ctl.FactorP = tmpFactorP;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL6: {
+            __s32   tmpFactorN, tmpFactorK;
+
+            if (rate <= 600000000)
+                tmpFactorK = 1;
+            else if (rate <= 1200000000)
+                tmpFactorK = 2;
+            else {
+                CCU_ERR("rate (%llu) is invaid for PLL6\n", rate);
+                return -1;
+            }
+
+            tmpFactorN = ccu_clk_uldiv(rate, ((tmpFactorK + 1) * 24000000) >> 1);
+            if (tmpFactorN > 31) {
+                CCU_ERR("rate (%llu) is invaid for PLL6\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Pll6Ctl.FactorN = tmpFactorN;
+            aw_ccu_reg->Pll6Ctl.FactorK = tmpFactorK;
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL6M: {
+            __s64   tmpPLL6 = sys_clk_get_rate(AW_SYS_CLK_PLL6);
+            __s32   tmpFactorM = ccu_clk_uldiv(tmpPLL6, rate * 6);
+
+            tmpFactorM = tmpFactorM ? tmpFactorM : 1;
+            aw_ccu_reg->Pll6Ctl.FactorM = tmpFactorM - 1;
+            return 0;
+        }
+        case AW_SYS_CLK_PLL62: {
+            return 0;
+        }
+        case AW_SYS_CLK_PLL6X2: {
+            return 0;
+        }
+        case AW_SYS_CLK_PLL7: {
+            if ((rate < 9 * 3000000) || (rate > (127 * 3000000))) {
+                CCU_ERR("rate (%llu) is invalid when set PLL7 rate\n", rate);
+                return -1;
+            }
+
+            if (rate == 270000000) {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll7Ctl.FracSet = 0;
+            } else if (rate == 297000000) {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 0;
+                aw_ccu_reg->Pll7Ctl.FracSet = 1;
+            } else {
+                aw_ccu_reg->Pll7Ctl.ModeSel = 1;
+                aw_ccu_reg->Pll7Ctl.FactorM = ccu_clk_uldiv(rate, 3000000);
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_PLL7X2: {
+            if (rate == (sys_clk_get_rate(AW_SYS_CLK_PLL7) << 1)) {
+                return 0;
+            }
+            return -1;
+        }
+        case AW_SYS_CLK_PLL8: {
+            __s32   tmpFactorN, tmpFactorK;
+
+            if (rate <= 600000000)
+                tmpFactorK = 0;
+            else if (rate <= 1200000000)
+                tmpFactorK = 1;
+            else {
+                CCU_ERR("rate (%llu) is invaid for PLL8\n", rate);
+                return -1;
+            }
+
+            tmpFactorN = ccu_clk_uldiv(rate, ((tmpFactorK + 1) * 24000000));
+            if (tmpFactorN > 31) {
+                CCU_ERR("rate (%llu) is invaid for PLL8\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Pll8Ctl.FactorN = tmpFactorN;
+            aw_ccu_reg->Pll8Ctl.FactorK = tmpFactorK;
+
+            return 0;
+        }
+        case AW_SYS_CLK_CPU: {
+            __s64   tmpRate = sys_clk_get_rate(sys_clk_get_parent(AW_SYS_CLK_CPU));
+
+            if (rate != tmpRate) {
+                CCU_ERR("rate (%llu) is invalid when set cpu rate (%lld)\n", rate, tmpRate);
+                CCU_ERR("0xf1c20000 = 0x%x\n", *(volatile __u32 *)0xf1c20000);
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_AXI: {
+            __s32   tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU), rate);
+            if (tmpDiv > 4) {
+                CCU_ERR("rate (%llu) is invalid when set axi rate\n", rate);
+                return -1;
+            }
+            tmpDiv = tmpDiv ? (tmpDiv - 1) : 0;
+            aw_ccu_reg->SysClkDiv.AXIClkDiv = tmpDiv;
+
+            return 0;
+        }
+        case AW_SYS_CLK_ATB: {
+            __s32   tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_CPU), rate);
+            if (tmpDiv > 4) {
+                CCU_ERR("rate (%llu) is invalid when set atb rate\n", rate);
+                return -1;
+            } else if ((tmpDiv == 4) || (tmpDiv == 3)) {
+                aw_ccu_reg->SysClkDiv.AtbApbClkDiv = 2;
+            } else if (tmpDiv == 2) {
+                aw_ccu_reg->SysClkDiv.AtbApbClkDiv = 1;
+            } else {
+                aw_ccu_reg->SysClkDiv.AtbApbClkDiv = 0;
+            }
+
+            return 0;
+        }
+        case AW_SYS_CLK_AHB: {
+            __s32   tmpVal = -1, tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(sys_clk_get_parent(AW_SYS_CLK_AHB)), rate);
+
+            if (tmpDiv > 8) {
+                CCU_ERR("rate (%llu) is invalid for set AHB rate\n", rate);
+                return -1;
+            }
+
+            do {
+                tmpDiv >>= 1;
+                tmpVal++;
+            } while (tmpDiv);
+            aw_ccu_reg->SysClkDiv.AHBClkDiv = tmpVal;
+
+            return 0;
+        }
+        case AW_SYS_CLK_APB0: {
+            __s32   tmpVal = -1, tmpDiv = ccu_clk_uldiv(sys_clk_get_rate(AW_SYS_CLK_AHB), rate);
+
+            if (tmpDiv > 8) {
+                CCU_ERR("rate (%llu) is invalid for set APB0 rate\n", rate);
+                return -1;
+            }
+
+            do {
+                tmpDiv >>= 1;
+                tmpVal++;
+            } while (tmpDiv);
+            aw_ccu_reg->SysClkDiv.APB0ClkDiv = tmpVal;
+
+            return 0;
+        }
+        case AW_SYS_CLK_APB1: {
+            __s64   tmpRate = sys_clk_get_rate(sys_clk_get_parent(AW_SYS_CLK_APB1));
+            __s32   tmpDivP, tmpDivM;
+
+            if (tmpRate < rate) {
+                CCU_ERR("rate (%llu) is invalid for set APB1 rate, parent is (%llu)\n", rate, tmpRate);
+                return -1;
+            }
+
+            tmpRate = ccu_clk_uldiv(tmpRate, rate);
+            if (tmpRate <= 4) {
+                tmpDivP = 0;
+                tmpDivM = tmpRate - 1;
+            } else if (tmpRate <= 8) {
+                tmpDivP = 1;
+                tmpDivM = (tmpRate >> 1) - 1;
+            } else if (tmpRate <= 16) {
+                tmpDivP = 2;
+                tmpDivM = (tmpRate >> 2) - 1;
+            } else if (tmpRate <= 32) {
+                tmpDivP = 3;
+                tmpDivM = (tmpRate >> 3) - 1;
+            } else {
+                CCU_ERR("rate (%llu) is invalid for set APB1 rate\n", rate);
+                return -1;
+            }
+
+            aw_ccu_reg->Apb1ClkDiv.PreDiv = tmpDivP;
+            aw_ccu_reg->Apb1ClkDiv.ClkDiv = tmpDivM;
+
+            return 0;
+        }
+        default: {
+            return -1;
+        }
+    }
+}
+
+__clk_ops_t sys_clk_ops = {
+    .set_status = sys_clk_set_status,
+    .get_status = sys_clk_get_status,
+    .set_parent = sys_clk_set_parent,
+    .get_parent = sys_clk_get_parent,
+    .get_rate = sys_clk_get_rate,
+    .set_rate = sys_clk_set_rate,
+    .round_rate = 0,
+    .set_reset  = 0,
+    .get_reset  = 0,
+};
diff --git a/arch/arm/mach-sun7i/core.h b/arch/arm/mach-sun7i/core.h
new file mode 100644
index 0000000..0dced28
--- /dev/null
+++ b/arch/arm/mach-sun7i/core.h
@@ -0,0 +1,32 @@
+/*
+ *  linux/arch/arm/mach-sun7i/core.h
+ *
+ *  Copyright (C) 2012 - 2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SUN7I_H
+#define __ASM_ARCH_SUN7I_H
+
+#include <linux/amba/bus.h>
+#include <linux/io.h>
+
+#include <asm/setup.h>
+
+extern struct platform_device sun7i_uart_debug_port;
+
+#endif
diff --git a/arch/arm/mach-sun7i/cpu-freq/Makefile b/arch/arm/mach-sun7i/cpu-freq/Makefile
new file mode 100755
index 0000000..ef9df35
--- /dev/null
+++ b/arch/arm/mach-sun7i/cpu-freq/Makefile
@@ -0,0 +1,2 @@
+
+obj-y  += cpu-freq.o cpu-freq-table.o
diff --git a/arch/arm/mach-sun7i/cpu-freq/cpu-freq-table.c b/arch/arm/mach-sun7i/cpu-freq/cpu-freq-table.c
new file mode 100755
index 0000000..a0e2612
--- /dev/null
+++ b/arch/arm/mach-sun7i/cpu-freq/cpu-freq-table.c
@@ -0,0 +1,87 @@
+/*
+ *  arch/arm/mach-sun7i/cpu-freq/cpu-freq-table.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include "cpu-freq.h"
+
+struct cpufreq_frequency_table sunxi_freq_tbl[] = {
+
+    { .frequency = 30000,   .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 48000,   .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 60000,   .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 72000,   .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 84000,   .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 96000,   .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 96000,   .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    //{ .frequency = 108000,  .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 120000,  .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 132000,  .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 144000,  .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 156000,  .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 168000,  .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 180000,  .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 192000,  .index = SUNXI_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 204000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 216000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 240000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 264000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 288000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 288000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    //{ .frequency = 300000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 336000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 360000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 384000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 408000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 408000,  .index = SUNXI_CLK_DIV(1, 1, 2, 2), },
+    //{ .frequency = 432000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 480000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 528000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 528000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    //{ .frequency = 576000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 600000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 648000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 672000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 696000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 720000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 744000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 768000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 816000,  .index = SUNXI_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 864000,  .index = SUNXI_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 912000,  .index = SUNXI_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 960000,  .index = SUNXI_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1008000, .index = SUNXI_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1056000, .index = SUNXI_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1104000, .index = SUNXI_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1152000, .index = SUNXI_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1200000, .index = SUNXI_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1248000, .index = SUNXI_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1296000, .index = SUNXI_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1344000, .index = SUNXI_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1392000, .index = SUNXI_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1440000, .index = SUNXI_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1488000, .index = SUNXI_CLK_DIV(1, 4, 2, 2), },
+
+    /* table end */
+    { .frequency = CPUFREQ_TABLE_END,  .index = 0,              },
+};
+
diff --git a/arch/arm/mach-sun7i/cpu-freq/cpu-freq.c b/arch/arm/mach-sun7i/cpu-freq/cpu-freq.c
new file mode 100755
index 0000000..aa36893
--- /dev/null
+++ b/arch/arm/mach-sun7i/cpu-freq/cpu-freq.c
@@ -0,0 +1,1012 @@
+/*
+ *  arch/arm/mach-sun7i/cpu-freq/cpu-freq.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <plat/sys_config.h>
+#include <linux/cpu.h>
+#include <asm/cpu.h>
+
+#include "cpu-freq.h"
+#include <linux/pm.h>
+#include <linux/regulator/consumer.h>
+#include <mach/includes.h>
+
+#define AHB_APB_CLK_ASYNC
+
+static struct sunxi_cpu_freq_t  cpu_cur;    /* current cpu frequency configuration  */
+static unsigned int last_target = ~0;       /* backup last target frequency         */
+
+static struct clk *clk_pll; /* pll clock handler */
+static struct clk *clk_cpu; /* cpu clock handler */
+static struct clk *clk_axi; /* axi clock handler */
+static struct clk *clk_ahb; /* ahb clock handler */
+static struct clk *clk_apb; /* apb clock handler */
+#ifdef AHB_APB_CLK_ASYNC
+static struct clk *clk_sata_pll; /* apb clock handler */
+#endif
+
+static DEFINE_MUTEX(sunxi_cpu_lock);
+
+static unsigned int cpu_freq_max = SUNXI_CPUFREQ_MAX / 1000;
+static unsigned int cpu_freq_min = SUNXI_CPUFREQ_MIN / 1000;
+
+#ifdef CONFIG_SMP
+static struct cpumask sunxi_cpumask;
+static int cpus_initialized;
+#endif
+
+int setgetfreq_debug = 0;
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+unsigned long long setfreq_time_usecs = 0;
+unsigned long long getfreq_time_usecs = 0;
+#endif
+#ifdef CONFIG_CPU_FREQ_DVFS
+#define TABLE_LENGTH (16)
+struct cpufreq_dvfs {
+    unsigned int    freq;   /* cpu frequency    */
+    unsigned int    volt;   /* voltage for the frequency    */
+};
+static struct cpufreq_dvfs dvfs_table[] = {
+    {.freq = 1008000000, .volt = 1450}, /* core vdd is 1.40v if cpu frequency is (912Mhz,  1008Mhz] */
+    {.freq = 912000000,  .volt = 1400}, /* core vdd is 1.40v if cpu frequency is (864Mhz,   912Mhz] */
+    {.freq = 864000000,  .volt = 1300}, /* core vdd is 1.30v if cpu frequency is (720Mhz,   864Mhz] */
+    {.freq = 720000000,  .volt = 1200}, /* core vdd is 1.20v if cpu frequency is (528Mhz,   720Mhz] */
+    {.freq = 528000000,  .volt = 1100}, /* core vdd is 1.10v if cpu frequency is (336Mhz,   528Mhz] */
+    {.freq = 312000000,  .volt = 1000}, /* core vdd is 1.00v if cpu frequency is (144Mhz,   312Mhz] */
+    {.freq = 144000000,  .volt = 900},  /* core vdd is 0.90v if cpu frequency is (  0Mhz,   144Mhz] */
+    {.freq = 0,          .volt = 900},  /* end of cpu dvfs table                                    */
+};
+static struct cpufreq_dvfs dvfs_table_syscfg[TABLE_LENGTH];
+static unsigned int table_length_syscfg = 0;
+static int use_default_table = 0;
+static struct regulator *corevdd;
+static unsigned int last_vdd    = 1400;     /* backup last target voltage, default is 1.4v  */
+#endif
+
+/*
+ *check if the cpu frequency policy is valid;
+ */
+static int sunxi_cpufreq_verify(struct cpufreq_policy *policy)
+{
+    return 0;
+}
+
+
+/*
+ *show cpu frequency information;
+ */
+static void sunxi_cpufreq_show(const char *pfx, struct sunxi_cpu_freq_t *cfg)
+{
+#ifndef AHB_APB_CLK_ASYNC
+	CPUFREQ_DBG("%s: pll=%u, cpudiv=%u, axidiv=%u, ahbdiv=%u, apb=%u\n",
+        pfx, cfg->pll, cfg->div.cpu_div, cfg->div.axi_div, cfg->div.ahb_div, cfg->div.apb_div);
+#else
+    CPUFREQ_DBG("%s: pll=%u, cpudiv=%u, axidiv=%u\n", pfx, cfg->pll, cfg->div.cpu_div, cfg->div.axi_div);
+#endif
+}
+
+
+#ifdef CONFIG_CPU_FREQ_DVFS
+/*
+*********************************************************************************************************
+*                           __init_vftable_syscfg
+*
+*Description: init vftable from sysconfig.
+*
+*Arguments  : none;
+*
+*Return     : result, 0 - init vftable successed, !0 - init vftable failed;
+*
+*Notes      : LV1: core vdd is 1.50v if cpu frequency is (1008Mhz, 1056Mhz]
+*             LV2: core vdd is 1.40v if cpu frequency is (912Mhz,  1008Mhz]
+*             LV3: core vdd is 1.35v if cpu frequency is (864Mhz,   912Mhz]
+*             LV4: core vdd is 1.30v if cpu frequency is (624Mhz,   864Mhz]
+*             LV5: core vdd is 1.25v if cpu frequency is (60Mhz,    624Mhz]
+*
+*********************************************************************************************************
+*/
+static int __init_vftable_syscfg(void)
+{
+	int i, level_freq, level_volt, ret = 0;
+	char name[16] = {0};
+
+	if (script_parser_fetch("dvfs_table", "LV_count", &table_length_syscfg,
+				sizeof(int)) != 0) {
+		CPUFREQ_DBG("get LV_count from sysconfig failed\n");
+		use_default_table = 1;
+		ret = -1;
+		goto fail;
+	}
+
+	/* table_length_syscfg must be < TABLE_LENGTH */
+	if(table_length_syscfg >= TABLE_LENGTH){
+		CPUFREQ_ERR("LV_count from sysconfig is out of bounder\n");
+		use_default_table = 1;
+		ret = -1;
+		goto fail;
+	}
+
+	for (i = 1; i <= table_length_syscfg; i++){
+		sprintf(name, "LV%d_freq", i);
+		if (script_parser_fetch("dvfs_table", name, &level_freq,
+					sizeof(int)) != 0) {
+			CPUFREQ_ERR("get LV%d_freq from sysconfig failed\n", i);
+			use_default_table = 1;
+			ret = -1;
+			goto fail;
+		}
+
+		sprintf(name, "LV%d_volt", i);
+		if (script_parser_fetch("dvfs_table", name, &level_volt,
+					sizeof(int)) != 0) {
+			CPUFREQ_ERR("get LV%d_freq from sysconfig failed\n", i);
+			use_default_table = 1;
+			ret = -1;
+			goto fail;
+		}
+
+		dvfs_table_syscfg[i-1].freq = level_freq;
+		dvfs_table_syscfg[i-1].volt = level_volt;
+	}
+
+	/* end of cpu dvfs table */
+	dvfs_table_syscfg[table_length_syscfg].freq = 0;
+	dvfs_table_syscfg[table_length_syscfg].volt = 1000;
+
+fail:
+	return ret;
+}
+
+/*
+*********************************************************************************************************
+*                           __vftable_show
+*
+*Description: show vftable information
+*
+*Arguments  : none;
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void __vftable_show(void)
+{
+	int i;
+
+	CPUFREQ_INF("-------------------V-F Table-------------------\n");
+	if(use_default_table){
+		for(i = 0; i < sizeof(dvfs_table)/sizeof(dvfs_table[0]); i++){
+			CPUFREQ_INF("\tvoltage = %4dmv \tfrequency = %4dMHz\n", dvfs_table[i].volt,
+					dvfs_table[i].freq/1000000);
+		}
+	}
+	else{
+		for(i = 0; i <= table_length_syscfg; i++){
+			CPUFREQ_INF("\tvoltage = %4dmv \tfrequency = %4dMHz\n", dvfs_table_syscfg[i].volt,
+					dvfs_table_syscfg[i].freq/1000000);
+		}
+	}
+	CPUFREQ_INF("-----------------------------------------------\n");
+}
+
+/*
+*********************************************************************************************************
+*                           __get_vdd_value
+*
+*Description: get vdd with cpu frequency.
+*
+*Arguments  : freq  cpu frequency;
+*
+*Return     : vdd value;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline unsigned int __get_vdd_value(unsigned int freq)
+{
+    struct cpufreq_dvfs *dvfs_inf = NULL;
+	if(use_default_table)
+		dvfs_inf = &dvfs_table[0];
+	else
+		dvfs_inf = &dvfs_table_syscfg[0];
+
+    while((dvfs_inf+1)->freq >= freq) dvfs_inf++;
+
+    return dvfs_inf->volt;
+}
+#endif
+
+
+/*
+*********************************************************************************************************
+*                           __set_cpufreq_hw
+*
+*Description: set cpu frequency configuration to hardware.
+*
+*Arguments  : freq  frequency configuration;
+*
+*Return     : result
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline int __set_cpufreq_hw(struct sunxi_cpu_freq_t *freq)
+{
+    int             ret;
+    unsigned int    frequency;
+
+    /* try to adjust pll frequency */
+    ret = clk_set_rate(clk_pll, freq->pll);
+    /* try to adjust cpu frequency */
+    frequency = freq->pll / freq->div.cpu_div;
+    ret |= clk_set_rate(clk_cpu, frequency);
+    /* try to adjuxt axi frequency */
+    frequency /= freq->div.axi_div;
+    ret |= clk_set_rate(clk_axi, frequency);
+#ifndef AHB_APB_CLK_ASYNC
+    /* try to adjust ahb frequency */
+    frequency /= freq->div.ahb_div;
+    ret |= clk_set_rate(clk_ahb, frequency);
+    /* try to adjust apb frequency */
+    frequency /= freq->div.apb_div;
+    ret |= clk_set_rate(clk_apb, frequency);
+#endif
+
+    return ret;
+}
+
+
+/*
+*********************************************************************************************************
+*                           __set_cpufreq_target
+*
+*Description: set target frequency, the frequency limitation of axi is 450Mhz, the frequency
+*             limitation of ahb is 250Mhz, and the limitation of apb is 150Mhz. for usb connecting,
+*             the frequency of ahb must not lower than 60Mhz.
+*
+*Arguments  : old   cpu/axi/ahb/apb frequency old configuration.
+*             new   cpu/axi/ahb/apb frequency new configuration.
+*
+*Return     : result, 0 - set frequency successed, !0 - set frequency failed;
+*
+*Notes      : we check two frequency point: 204Mhz, 408Mhz, 816Mhz and 1200Mhz.
+*             if increase cpu frequency, the flow should be:
+*               low(1:1:1:2) -> 204Mhz(1:1:1:2) -> 204Mhz(1:1:2:2) -> 408Mhz(1:1:2:2)
+*               -> 408Mhz(1:2:2:2) -> 816Mhz(1:2:2:2) -> 816Mhz(1:3:2:2) -> 1200Mhz(1:3:2:2)
+*               -> 1200Mhz(1:4:2:2) -> target(1:4:2:2) -> target(x:x:x:x)
+*             if decrease cpu frequency, the flow should be:
+*               high(x:x:x:x) -> target(1:4:2:2) -> 1200Mhz(1:4:2:2) -> 1200Mhz(1:3:2:2)
+*               -> 816Mhz(1:3:2:2) -> 816Mhz(1:2:2:2) -> 408Mhz(1:2:2:2) -> 408Mhz(1:1:2:2)
+*               -> 204Mhz(1:1:2:2) -> 204Mhz(1:1:1:2) -> target(1:1:1:2)
+*********************************************************************************************************
+*/
+static int __set_cpufreq_target(struct sunxi_cpu_freq_t *old, struct sunxi_cpu_freq_t *new)
+{
+    int     ret = 0;
+    struct sunxi_cpu_freq_t old_freq, new_freq;
+
+    if(!old || !new) {
+        return -EINVAL;
+    }
+
+    old_freq = *old;
+    new_freq = *new;
+
+    CPUFREQ_DBG("cpu: %dMhz->%dMhz\n", old_freq.pll/1000000, new_freq.pll/1000000);
+
+    if(new_freq.pll > old_freq.pll) {
+        if((old_freq.pll <= 204000000) && (new_freq.pll >= 204000000)) {
+            /* set to 204Mhz (1:1:1:2) */
+            old_freq.pll = 204000000;
+            old_freq.div.cpu_div = 1;
+            old_freq.div.axi_div = 1;
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 1;
+            old_freq.div.apb_div = 2;
+#endif
+            ret |= __set_cpufreq_hw(&old_freq);
+#ifndef AHB_APB_CLK_ASYNC
+            /* set to 204Mhz (1:1:2:2) */
+            old_freq.div.ahb_div = 2;
+            ret |= __set_cpufreq_hw(&old_freq);
+#endif
+        }
+        if((old_freq.pll <= 408000000) && (new_freq.pll >= 408000000)) {
+            /* set to 408Mhz (1:1:2:2) */
+            old_freq.pll = 408000000;
+            old_freq.div.cpu_div = 1;
+            old_freq.div.axi_div = 1;
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 2;
+            old_freq.div.apb_div = 2;
+#endif
+            ret |= __set_cpufreq_hw(&old_freq);
+            /* set to 408Mhz (1:2:2:2) */
+            old_freq.div.axi_div = 2;
+            ret |= __set_cpufreq_hw(&old_freq);
+        }
+        if((old_freq.pll <= 816000000) && (new_freq.pll >= 816000000)) {
+            /* set to 816Mhz (1:2:2:2) */
+            old_freq.pll = 816000000;
+            old_freq.div.cpu_div = 1;
+            old_freq.div.axi_div = 2;
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 2;
+            old_freq.div.apb_div = 2;
+#endif
+            ret |= __set_cpufreq_hw(&old_freq);
+            /* set to 816Mhz (1:3:2:2) */
+            old_freq.div.axi_div = 3;
+            ret |= __set_cpufreq_hw(&old_freq);
+        }
+        if((old_freq.pll <= 1200000000) && (new_freq.pll >= 1200000000)) {
+            /* set to 1200Mhz (1:3:2:2) */
+            old_freq.pll = 1200000000;
+            old_freq.div.cpu_div = 1;
+            old_freq.div.axi_div = 3;
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 2;
+            old_freq.div.apb_div = 2;
+#endif
+            ret |= __set_cpufreq_hw(&old_freq);
+            /* set to 1200Mhz (1:4:2:2) */
+            old_freq.div.axi_div = 4;
+            ret |= __set_cpufreq_hw(&old_freq);
+        }
+
+        /* adjust to target frequency */
+        ret |= __set_cpufreq_hw(&new_freq);
+    }
+    else if(new_freq.pll < old_freq.pll) {
+        if((old_freq.pll > 1200000000) && (new_freq.pll <= 1200000000)) {
+            /* set to 1200Mhz (1:3:2:2) */
+            old_freq.pll = 1200000000;
+            old_freq.div.cpu_div = 1;
+            old_freq.div.axi_div = 3;
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 2;
+            old_freq.div.apb_div = 2;
+#endif
+            ret |= __set_cpufreq_hw(&old_freq);
+        }
+        if((old_freq.pll > 816000000) && (new_freq.pll <= 816000000)) {
+            /* set to 816Mhz (1:3:2:2) */
+            old_freq.pll = 816000000;
+            old_freq.div.cpu_div = 1;
+            old_freq.div.axi_div = 3;
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 2;
+            old_freq.div.apb_div = 2;
+#endif
+            ret |= __set_cpufreq_hw(&old_freq);
+            /* set to 816Mhz (1:2:2:2) */
+            old_freq.div.axi_div = 2;
+            ret |= __set_cpufreq_hw(&old_freq);
+        }
+        if((old_freq.pll > 408000000) && (new_freq.pll <= 408000000)) {
+            /* set to 408Mhz (1:2:2:2) */
+            old_freq.pll = 408000000;
+            old_freq.div.cpu_div = 1;
+            old_freq.div.axi_div = 2;
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 2;
+            old_freq.div.apb_div = 2;
+#endif
+            ret |= __set_cpufreq_hw(&old_freq);
+            /* set to 816Mhz (1:1:2:2) */
+            old_freq.div.axi_div = 1;
+            ret |= __set_cpufreq_hw(&old_freq);
+        }
+        if((old_freq.pll > 204000000) && (new_freq.pll <= 204000000)) {
+            /* set to 204Mhz (1:1:2:2) */
+            old_freq.pll = 204000000;
+            old_freq.div.cpu_div = 1;
+            old_freq.div.axi_div = 1;
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 2;
+            old_freq.div.apb_div = 2;
+#endif
+            ret |= __set_cpufreq_hw(&old_freq);
+            /* set to 204Mhz (1:1:1:2) */
+#ifndef AHB_APB_CLK_ASYNC
+            old_freq.div.ahb_div = 1;
+            ret |= __set_cpufreq_hw(&old_freq);
+#endif
+        }
+
+        /* adjust to target frequency */
+        ret |= __set_cpufreq_hw(&new_freq);
+    }
+
+    if(ret) {
+        unsigned int    frequency;
+
+        CPUFREQ_ERR("try to set target frequency failed!\n");
+
+        /* try to restore frequency configuration */
+        frequency = clk_get_rate(clk_cpu);
+        frequency /= 4;
+        clk_set_rate(clk_axi, frequency);
+#ifndef AHB_APB_CLK_ASYNC
+        frequency /= 2;
+        clk_set_rate(clk_ahb, frequency);
+        frequency /= 2;
+        clk_set_rate(clk_apb, frequency);
+#endif
+
+        clk_set_rate(clk_pll, old->pll);
+        frequency = old->pll / old->div.cpu_div;
+        clk_set_rate(clk_cpu, frequency);
+        frequency /= old->div.axi_div;
+        clk_set_rate(clk_axi, frequency);
+#ifndef AHB_APB_CLK_ASYNC
+        frequency /= old->div.ahb_div;
+        clk_set_rate(clk_ahb, frequency);
+        frequency /= old->div.apb_div;
+        clk_set_rate(clk_apb, frequency);
+#endif
+
+        CPUFREQ_ERR("no compatible settings cpu freq for %d\n", new_freq.pll);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sunxi_cpufreq_settarget
+*
+*Description: adjust cpu frequency;
+*
+*Arguments  : policy    cpu frequency policy, to mark if need notify;
+*             cpu_freq  new cpu frequency configuration;
+*
+*Return     : return 0 if set successed, otherwise, return -EINVAL
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int sunxi_cpufreq_settarget(struct cpufreq_policy *policy, struct sunxi_cpu_freq_t *cpu_freq)
+{
+    struct cpufreq_freqs    freqs;
+    struct sunxi_cpu_freq_t cpu_new;
+    int                     i;
+
+    #ifdef CONFIG_CPU_FREQ_DVFS
+    unsigned int    new_vdd;
+    #endif
+
+    /* show current cpu frequency configuration, just for debug */
+	sunxi_cpufreq_show("cur", &cpu_cur);
+
+    /* get new cpu frequency configuration */
+	cpu_new = *cpu_freq;
+	sunxi_cpufreq_show("new", &cpu_new);
+
+    /* notify that cpu clock will be adjust if needed */
+	if (policy) {
+        freqs.cpu = policy->cpu;
+	    freqs.old = cpu_cur.pll / 1000;
+	    freqs.new = cpu_new.pll / 1000;
+#ifdef CONFIG_SMP
+        /* notifiers */
+        for_each_cpu(i, policy->cpus) {
+            freqs.cpu = i;
+            cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+        }
+#else
+        cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+#endif
+	}
+
+    #ifdef CONFIG_CPU_FREQ_DVFS
+    /* get vdd value for new frequency */
+    new_vdd = __get_vdd_value(cpu_new.pll);
+
+    if(corevdd && (new_vdd > last_vdd)) {
+        CPUFREQ_DBG("set core vdd to %d\n", new_vdd);
+        if(regulator_set_voltage(corevdd, new_vdd*1000, new_vdd*1000)) {
+            CPUFREQ_ERR("try to set voltage failed!\n");
+
+            /* notify everyone that clock transition finish */
+    	    if (policy) {
+                freqs.cpu = policy->cpu;
+	            freqs.old = freqs.new;
+	            freqs.new = cpu_cur.pll / 1000;
+		        cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	        }
+            return -EINVAL;
+        }
+    }
+    #endif
+
+    if(__set_cpufreq_target(&cpu_cur, &cpu_new)){
+
+        /* try to set cpu frequency failed */
+
+        #ifdef CONFIG_CPU_FREQ_DVFS
+        if(corevdd && (new_vdd > last_vdd)) {
+            CPUFREQ_DBG("set core vdd to %d\n", last_vdd);
+            if(regulator_set_voltage(corevdd, last_vdd*1000, last_vdd*1000)){
+                CPUFREQ_ERR("try to set voltage failed!\n");
+                last_vdd = new_vdd;
+            }
+        }
+        #endif
+
+        /* notify everyone that clock transition finish */
+    	if (policy) {
+            freqs.cpu = policy->cpu;
+	        freqs.old = freqs.new;
+	        freqs.new = cpu_cur.pll / 1000;
+#ifdef CONFIG_SMP
+            /* notifiers */
+            for_each_cpu(i, policy->cpus) {
+                freqs.cpu = i;
+                cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+            }
+#else
+            cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+#endif
+	    }
+
+        return -EINVAL;
+    }
+
+    #ifdef CONFIG_CPU_FREQ_DVFS
+    if(corevdd && (new_vdd < last_vdd)) {
+        CPUFREQ_DBG("set core vdd to %d\n", new_vdd);
+        if(regulator_set_voltage(corevdd, new_vdd*1000, new_vdd*1000)) {
+            CPUFREQ_ERR("try to set voltage failed!\n");
+            new_vdd = last_vdd;
+        }
+    }
+    last_vdd = new_vdd;
+    #endif
+
+	/* update our current settings */
+	cpu_cur = cpu_new;
+
+	/* notify everyone we've done this */
+	if (policy) {
+#ifdef CONFIG_SMP
+        /*
+         * Note that loops_per_jiffy is not updated on SMP systems in
+         * cpufreq driver. So, update the per-CPU loops_per_jiffy value
+         * on frequency transition. We need to update all dependent cpus
+         */
+        for_each_cpu(i, policy->cpus) {
+            per_cpu(cpu_data, i).loops_per_jiffy =
+                 cpufreq_scale(per_cpu(cpu_data, i).loops_per_jiffy, freqs.old, freqs.new);
+            freqs.cpu = i;
+            cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+        }
+#else
+        cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+#endif
+	}
+
+	CPUFREQ_DBG("%s: finished\n", __func__);
+	return 0;
+}
+
+
+/*
+ * adjust the frequency that cpu is currently running;
+ * policy:  cpu frequency policy;
+ * freq:    target frequency to be set, based on khz;
+ * relation:    method for selecting the target requency;
+ * return:  result, return 0 if set target frequency successed, else, return -EINVAL;
+ * notes:   this function is called by the cpufreq core;
+ */
+static int sunxi_cpufreq_target(struct cpufreq_policy *policy, __u32 freq, __u32 relation)
+{
+    int                     ret = 0;
+    unsigned int            index;
+    struct sunxi_cpu_freq_t freq_cfg;
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+	ktime_t calltime = ktime_set(0, 0), delta, rettime;
+
+	if (unlikely(setgetfreq_debug)) {
+		calltime = ktime_get();
+	}
+#endif
+
+    mutex_lock(&sunxi_cpu_lock);
+
+#ifdef CONFIG_SMP
+    /* Wait untill all CPU's are initialized */
+    if (unlikely(cpus_initialized < num_online_cpus())) {
+        ret = -EINVAL;
+        goto out;
+    }
+#endif
+
+    /* avoid repeated calls which cause a needless amout of duplicated
+     * logging output (and CPU time as the calculation process is
+     * done) */
+	if (freq == last_target) {
+        goto out;
+	}
+
+    /* try to look for a valid frequency value from cpu frequency table */
+    if (cpufreq_frequency_table_target(policy, sunxi_freq_tbl, freq, relation, &index)) {
+        CPUFREQ_ERR("try to look for a valid frequency for %u failed!\n", freq);
+        ret = -EINVAL;
+        goto out;
+    }
+
+    /* frequency is same as the value last set, need not adjust */
+	if (sunxi_freq_tbl[index].frequency == last_target) {
+        goto out;
+	}
+    freq = sunxi_freq_tbl[index].frequency;
+
+    /* update the target frequency */
+    freq_cfg.pll = sunxi_freq_tbl[index].frequency * 1000;
+    freq_cfg.div = *(struct sunxi_clk_div_t *)&sunxi_freq_tbl[index].index;
+    CPUFREQ_DBG("target frequency find is %u, entry %u\n", freq_cfg.pll, index);
+
+    /* try to set target frequency */
+    ret = sunxi_cpufreq_settarget(policy, &freq_cfg);
+    if(!ret) {
+        last_target = freq;
+    }
+out:
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+	if (unlikely(setgetfreq_debug)) {
+		rettime = ktime_get();
+		delta = ktime_sub(rettime, calltime);
+		setfreq_time_usecs = ktime_to_ns(delta) >> 10;
+		printk("[setfreq]: %Ld usecs\n", setfreq_time_usecs);
+	}
+#endif
+    mutex_unlock(&sunxi_cpu_lock);
+
+    return ret;
+}
+
+
+/*
+ * get the frequency that cpu currently is running;
+ * cpu:    cpu number, all cpus use the same clock;
+ * return: cpu frequency, based on khz;
+ */
+static unsigned int sunxi_cpufreq_get(unsigned int cpu)
+{
+	unsigned int current_freq = 0;
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+	ktime_t calltime = ktime_set(0, 0), delta, rettime;
+
+	if (unlikely(setgetfreq_debug)) {
+		calltime = ktime_get();
+	}
+#endif
+
+	current_freq = clk_get_rate(clk_cpu) / 1000;
+
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+	if (unlikely(setgetfreq_debug)) {
+		rettime = ktime_get();
+		delta = ktime_sub(rettime, calltime);
+		getfreq_time_usecs = ktime_to_ns(delta) >> 10;
+		printk("[getfreq]: %Ld usecs\n", getfreq_time_usecs);
+	}
+#endif
+
+	return current_freq;
+}
+
+
+/*
+ * get the frequency that cpu average is running;
+ * cpu:    cpu number, all cpus use the same clock;
+ * return: cpu frequency, based on khz;
+ */
+static unsigned int sunxi_cpufreq_getavg(struct cpufreq_policy *policy, unsigned int cpu)
+{
+    return clk_get_rate(clk_cpu) / 1000;
+}
+
+
+/*
+ * get a valid frequency from cpu frequency table;
+ * target_freq:	target frequency to be judge, based on KHz;
+ * return: cpu frequency, based on khz;
+ */
+static unsigned int __get_valid_freq(unsigned int target_freq)
+{
+    struct cpufreq_frequency_table *tmp = &sunxi_freq_tbl[0];
+
+    while(tmp->frequency != CPUFREQ_TABLE_END){
+        if((tmp+1)->frequency <= target_freq)
+            tmp++;
+        else
+            break;
+    }
+
+    return tmp->frequency;
+}
+
+
+/*
+ * init cpu max/min frequency from sysconfig;
+ * return: 0 - init cpu max/min successed, !0 - init cpu max/min failed;
+ */
+static int __init_freq_syscfg(void)
+{
+    int val, ret = 0;
+
+    if (script_parser_fetch("dvfs_table", "max_freq", &val, sizeof(int))) {
+        CPUFREQ_ERR("get cpu max frequency from sysconfig failed\n");
+        ret = -1;
+        goto fail;
+    }
+    cpu_freq_max = val;
+
+    if (script_parser_fetch("dvfs_table", "min_freq", &val, sizeof(int))) {
+        CPUFREQ_ERR("get cpu min frequency from sysconfig failed\n");
+        ret = -1;
+        goto fail;
+    }
+    cpu_freq_min = val;
+
+    if(cpu_freq_max > SUNXI_CPUFREQ_MAX || cpu_freq_max < SUNXI_CPUFREQ_MIN
+        || cpu_freq_min < SUNXI_CPUFREQ_MIN || cpu_freq_min > SUNXI_CPUFREQ_MAX){
+        CPUFREQ_ERR("cpu max or min frequency from sysconfig is more than range\n");
+        ret = -1;
+        goto fail;
+    }
+
+    if(cpu_freq_min > cpu_freq_max){
+        CPUFREQ_ERR("cpu min frequency can not be more than cpu max frequency\n");
+        ret = -1;
+        goto fail;
+    }
+
+    /* get valid max/min frequency from cpu frequency table */
+    cpu_freq_max = __get_valid_freq(cpu_freq_max / 1000);
+    cpu_freq_min = __get_valid_freq(cpu_freq_min / 1000);
+
+    return 0;
+
+fail:
+    /* use default cpu max/min frequency */
+    cpu_freq_max = SUNXI_CPUFREQ_MAX / 1000;
+    cpu_freq_min = SUNXI_CPUFREQ_MIN / 1000;
+
+    return ret;
+}
+
+
+/*
+ * cpu frequency initialise a policy;
+ * policy:  cpu frequency policy;
+ * result:  return 0 if init ok, else, return -EINVAL;
+ */
+static int sunxi_cpufreq_init(struct cpufreq_policy *policy)
+{
+    policy->cur = sunxi_cpufreq_get(0);
+    policy->min = policy->cpuinfo.min_freq = cpu_freq_min;
+    policy->max = policy->cpuinfo.max_freq = cpu_freq_max;
+    policy->cpuinfo.max_freq = SUNXI_CPUFREQ_MAX / 1000;
+    policy->cpuinfo.min_freq = SUNXI_CPUFREQ_MIN / 1000;
+    policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+    /* feed the latency information from the cpu driver */
+    policy->cpuinfo.transition_latency = SUNXI_FREQTRANS_LATENCY;
+    cpufreq_frequency_table_get_attr(sunxi_freq_tbl, policy->cpu);
+
+#ifdef CONFIG_SMP
+    /*
+     * both processors share the same voltage and the same clock,
+     * but have dedicated power domains. So both cores needs to be
+     * scaled together and hence needs software co-ordination.
+     * Use cpufreq affected_cpus interface to handle this scenario.
+     */
+    policy->shared_type = CPUFREQ_SHARED_TYPE_ANY;
+    cpumask_or(&sunxi_cpumask, cpumask_of(policy->cpu), &sunxi_cpumask);
+    cpumask_copy(policy->cpus, &sunxi_cpumask);
+    cpus_initialized++;
+#endif
+
+    return 0;
+}
+
+
+/*
+ * get current cpu frequency configuration;
+ * cfg:     cpu frequency cofniguration;
+ * return:  result;
+ */
+static int sunxi_cpufreq_getcur(struct sunxi_cpu_freq_t *cfg)
+{
+    unsigned int    freq, freq0;
+
+    if(!cfg) {
+        return -EINVAL;
+    }
+
+	cfg->pll = clk_get_rate(clk_pll);
+    freq = clk_get_rate(clk_cpu);
+    cfg->div.cpu_div = cfg->pll / freq;
+    freq0 = clk_get_rate(clk_axi);
+    cfg->div.axi_div = freq / freq0;
+#ifndef AHB_APB_CLK_ASYNC
+    freq = clk_get_rate(clk_ahb);
+    cfg->div.ahb_div = freq0 / freq;
+    freq0 = clk_get_rate(clk_apb);
+    cfg->div.apb_div = freq /freq0;
+#endif
+
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+/*
+ * cpu frequency configuration suspend;
+ */
+static int sunxi_cpufreq_suspend(struct cpufreq_policy *policy)
+{
+    CPUFREQ_DBG("%s\n", __func__);
+    return 0;
+}
+
+/*
+ * cpu frequency configuration resume;
+ */
+static int sunxi_cpufreq_resume(struct cpufreq_policy *policy)
+{
+    /* invalidate last_target setting */
+    last_target = ~0;
+    CPUFREQ_DBG("%s\n", __func__);
+    return 0;
+}
+
+
+#else   /* #ifdef CONFIG_PM */
+
+#define sunxi_cpufreq_suspend   NULL
+#define sunxi_cpufreq_resume    NULL
+
+#endif  /* #ifdef CONFIG_PM */
+
+static ssize_t show_debug_mask(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", setgetfreq_debug);	
+}
+static ssize_t store_debug_mask	(struct cpufreq_policy *policy, const char *buf, size_t count)		
+{									
+	unsigned int ret = -EINVAL;	
+    int debug_mask = 0;
+									
+	ret = sscanf(buf, "%u", &debug_mask);
+	if (ret != 1)	
+		return -EINVAL;	
+	setgetfreq_debug = debug_mask;
+	return ret ? ret : count;
+}
+cpufreq_freq_attr_rw(debug_mask);
+
+
+static struct freq_attr *platform_attrs[] = {
+	&debug_mask,
+    NULL
+};
+static struct cpufreq_driver sunxi_cpufreq_driver = {
+    .name       = "sunxi",
+    .flags      = CPUFREQ_STICKY,
+    .init       = sunxi_cpufreq_init,
+    .verify     = sunxi_cpufreq_verify,
+    .target     = sunxi_cpufreq_target,
+    .get        = sunxi_cpufreq_get,
+    .getavg     = sunxi_cpufreq_getavg,
+    .suspend    = sunxi_cpufreq_suspend,
+    .resume     = sunxi_cpufreq_resume,
+    .attr       = platform_attrs,
+};
+
+
+/*
+ * cpu frequency driver init
+ */
+static int __init sunxi_cpufreq_initcall(void)
+{
+	int ret = 0;
+
+    clk_pll = clk_get(NULL, "core_pll");
+    clk_cpu = clk_get(NULL, "cpu");
+    clk_axi = clk_get(NULL, "axi");
+    clk_ahb = clk_get(NULL, "ahb");
+    clk_apb = clk_get(NULL, "apb");
+
+	if (IS_ERR(clk_pll) || IS_ERR(clk_cpu) || IS_ERR(clk_axi) ||
+	    IS_ERR(clk_ahb) || IS_ERR(clk_apb)) {
+		CPUFREQ_ERR("%s: could not get clock(s)\n", __func__);
+		return -ENOENT;
+	}
+
+#ifdef AHB_APB_CLK_ASYNC
+    CPUFREQ_DBG("set ahb apb clock async\n");
+    clk_sata_pll = clk_get(NULL, "sata_pll");
+    if (IS_ERR(clk_sata_pll)) {
+        CPUFREQ_ERR("%s: could not get clock(s)\n", __func__);
+		return -ENOENT;
+    }
+    clk_set_parent(clk_ahb, clk_sata_pll);
+    clk_set_rate(clk_ahb, 150000000);
+    clk_set_rate(clk_apb,  75000000);
+#endif
+
+	CPUFREQ_DBG("%s: clocks pll=%lu,cpu=%lu,axi=%lu,ahp=%lu,apb=%lu\n", __func__,
+	       clk_get_rate(clk_pll), clk_get_rate(clk_cpu), clk_get_rate(clk_axi),
+	       clk_get_rate(clk_ahb), clk_get_rate(clk_apb));
+
+#ifdef CONFIG_CPU_FREQ_DVFS
+    corevdd = regulator_get(NULL, "Vcore");
+    if(IS_ERR(corevdd)) {
+        CPUFREQ_ERR("try to get regulator failed, core vdd will not changed!\n");
+        corevdd = NULL;
+    }
+    else {
+        CPUFREQ_DBG("try to get regulator(0x%x) successed.\n", (__u32)corevdd);
+        last_vdd = regulator_get_voltage(corevdd) / 1000;
+    }
+	ret = __init_vftable_syscfg();
+	if (ret)
+		CPUFREQ_INF("use default V-F Table\n");
+	else
+		__vftable_show();
+#endif
+
+    /* init cpu frequency from sysconfig */
+    if(__init_freq_syscfg()) {
+        CPUFREQ_ERR("%s, use default cpu max/min frequency, max freq: %uMHz, min freq: %uMHz\n",
+                    __func__, cpu_freq_max/1000, cpu_freq_min/1000);
+    }else{
+        CPUFREQ_INF("%s, get cpu frequency from sysconfig, max freq: %uMHz, min freq: %uMHz\n",
+                    __func__, cpu_freq_max/1000, cpu_freq_min/1000);
+    }
+
+    /* initialise current frequency configuration */
+	sunxi_cpufreq_getcur(&cpu_cur);
+	sunxi_cpufreq_show("cur", &cpu_cur);
+
+    /* register cpu frequency driver */
+    ret = cpufreq_register_driver(&sunxi_cpufreq_driver);
+
+    return ret;
+}
+late_initcall(sunxi_cpufreq_initcall);
diff --git a/arch/arm/mach-sun7i/cpu-freq/cpu-freq.h b/arch/arm/mach-sun7i/cpu-freq/cpu-freq.h
new file mode 100755
index 0000000..37a2457
--- /dev/null
+++ b/arch/arm/mach-sun7i/cpu-freq/cpu-freq.h
@@ -0,0 +1,66 @@
+/*
+ *  arch/arm/mach-sun7i/cpu-freq/cpu-freq.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __sunxi_CPU_FREQ_H__
+#define __sunxi_CPU_FREQ_H__
+
+#include <linux/types.h>
+#include <linux/cpufreq.h>
+
+#undef CPUFREQ_DBG
+#undef CPUFREQ_ERR
+#if (0)
+    #define CPUFREQ_DBG(format,args...)   printk("[cpu_freq] DBG:"format,##args)
+#else
+    #define CPUFREQ_DBG(format,args...)   do{}while(0)
+#endif
+
+#define CPUFREQ_INF(format,args...)   pr_info("[cpu_freq] INF:"format,##args)
+#define CPUFREQ_ERR(format,args...)   pr_err("[cpu_freq] ERR:"format,##args)
+
+
+#define SUNXI_CPUFREQ_MAX       (1008000000)    /* config the maximum frequency of sunxi core */
+#define SUNXI_CPUFREQ_MIN       (60000000)      /* config the minimum frequency of sunxi core */
+#define SUNXI_FREQTRANS_LATENCY (2000000)       /* config the transition latency, based on ns */
+
+struct sunxi_clk_div_t {
+    __u32   cpu_div:4;      /* division of cpu clock, divide core_pll */
+    __u32   axi_div:4;      /* division of axi clock, divide cpu clock*/
+    __u32   ahb_div:4;      /* division of ahb clock, divide axi clock*/
+    __u32   apb_div:4;      /* division of apb clock, divide ahb clock*/
+    __u32   reserved:16;
+};
+
+
+struct sunxi_cpu_freq_t {
+    __u32                   pll;    /* core pll frequency value */
+    struct sunxi_clk_div_t  div;    /* division configuration   */
+};
+
+
+#define SUNXI_CLK_DIV(cpu_div, axi_div, ahb_div, apb_div)       \
+                ((cpu_div<<0)|(axi_div<<4)|(ahb_div<<8)|(apb_div<<12))
+
+extern struct cpufreq_frequency_table sunxi_freq_tbl[];
+
+#endif  /* #ifndef __sunxi_CPU_FREQ_H__ */
+
+
diff --git a/arch/arm/mach-sun7i/delay.c b/arch/arm/mach-sun7i/delay.c
new file mode 100755
index 0000000..d8f7315
--- /dev/null
+++ b/arch/arm/mach-sun7i/delay.c
@@ -0,0 +1,75 @@
+#include <asm/delay.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <mach/timer.h>
+#include <linux/export.h>
+#include <linux/jiffies.h>
+#include <linux/notifier.h>
+#include <linux/suspend.h>
+
+/*
+ * Since we calibrate only once at boot, this
+ * function should be set once at boot and not changed
+ */
+#define TIME_INDEX		1
+#define MAX_COUNTER		0xffffffff
+#define CYCLE_NSEC		42
+#define TIMER_INTERVAL(x)	(0x14 + (x) * 0x10)
+#define TIMER_CURRENTVAL(x)	(0x18 + (x) * 0x10)
+#define TIMER_CTL(x)		(0x10 + (x) * 0x10)
+
+static void aw_delay(unsigned long);
+static unsigned long read_cur_counter(void);
+
+void (*delay_fn)(unsigned long n) = __udelay;
+EXPORT_SYMBOL(delay_fn);
+
+/*
+ * Read the timer counter.
+ */
+static inline unsigned long read_cur_counter(void)
+{
+	return readl(SW_VA_TIMERC_IO_BASE + TIMER_CURRENTVAL(TIME_INDEX));
+}
+
+static void aw_delay(unsigned long usec)
+{
+	unsigned long old, new, cur = 0;
+	unsigned long loops_nsec = 1000 * usec;
+
+	/*
+	 * Time currentval is down-counter.
+	 */
+	old = read_cur_counter();
+	for (;;) {
+		new = read_cur_counter();
+		if (new > old){
+			cur += (MAX_COUNTER - new + old);
+		} else {
+			cur += (old - new);
+		}
+		old = new;
+		if ((cur * CYCLE_NSEC) >= loops_nsec)
+			break;
+	}
+}
+
+void use_time_delay(void)
+{
+#if (TIME_INDEX != 0)
+	unsigned long irq_reg;
+
+	irq_reg = readl(SW_VA_TIMERC_IO_BASE + 0x00);
+	//writel(irq_reg & (~0x02), SW_VA_TIMERC_IO_BASE + 0x00);
+	writel(irq_reg & ~(1<<TIME_INDEX), SW_VA_TIMERC_IO_BASE + 0x00);
+
+	writel(MAX_COUNTER, SW_VA_TIMERC_IO_BASE + TIMER_INTERVAL(TIME_INDEX));
+	writel(0x07, SW_VA_TIMERC_IO_BASE + TIMER_CTL(TIME_INDEX));
+#endif
+
+	delay_fn = aw_delay;
+	printk("[aw_delay]: It is use use_time_delay function!\n");
+}
+
diff --git a/arch/arm/mach-sun7i/dma/Makefile b/arch/arm/mach-sun7i/dma/Makefile
new file mode 100755
index 0000000..ff5fd04
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/Makefile
@@ -0,0 +1,2 @@
+
+obj-y += dma.o dma_interface.o dma_csp.o dma_core.o
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/dma/dma.c b/arch/arm/mach-sun7i/dma/dma.c
new file mode 100755
index 0000000..7b4301f
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma.c
@@ -0,0 +1,211 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma driver interface
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+#include <linux/pm.h>
+
+struct kmem_cache *g_buf_cache;
+
+/**
+ * handle_dma_irq - dma irq handle
+ * @pchan:	dma channel handle
+ * @upend_bits:	irq pending for the channel
+ *
+ */
+void handle_dma_irq(dma_channel_t *pchan, u32 upend_bits)
+{
+	u32	irq_spt = 0;
+
+	WARN_ON(0 == upend_bits);
+	irq_spt = pchan->irq_spt;
+
+	/* deal half done */
+	if(upend_bits & CHAN_IRQ_HD) {
+		csp_dma_clear_irqpend(pchan, CHAN_IRQ_HD);
+		if((irq_spt & CHAN_IRQ_HD) && NULL != pchan->hd_cb.func)
+			pchan->hd_cb.func((dma_hdl_t)pchan, pchan->hd_cb.parg);
+	}
+	/* deal queue done */
+	if(upend_bits & CHAN_IRQ_FD) {
+		csp_dma_clear_irqpend(pchan, CHAN_IRQ_FD);
+		if(irq_spt & CHAN_IRQ_FD)
+			dma_hdl_irq_fd(pchan);
+	}
+}
+
+/**
+ * __dma_irq_hdl - dma irq process function
+ * @irq:	dma physical irq num
+ * @dev:	para passed in request_irq function
+ *
+ * we cannot lock __dma_irq_hdl through,
+ * because sw_dma_enqueue maybe called in cb,
+ * which will result in deadlock
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+irqreturn_t __dma_irq_hdl(int irq, void *dev)
+{
+	u32 i = 0;
+	u32 pend_bits = 0;
+	dma_channel_t *pchan = NULL;
+	struct dma_mgr_t *pdma_mgr = NULL;
+
+	DMA_DBG("%s(%d), dma en 0x%08x, pd 0x%08x\n", __func__, __LINE__, DMA_READ_REG(DMA_IRQ_EN_REG), DMA_READ_REG(DMA_IRQ_PEND_REG));
+
+	pdma_mgr = (struct dma_mgr_t *)dev;
+	for(i = 0; i < DMA_CHAN_TOTAL; i++) {
+		pchan = &pdma_mgr->chnl[i];
+		pend_bits = csp_dma_get_irqpend(pchan);
+		if(0 == pend_bits)
+			continue;
+
+		handle_dma_irq(pchan, pend_bits);
+	}
+	return IRQ_HANDLED;
+}
+
+static void __dma_cache_ctor(void *p)
+{
+	memset(p, 0, sizeof(buf_item));
+}
+
+/**
+ * __dma_init - initial the dma manager, request irq
+ * @device:	platform device pointer
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+int __dma_init(struct platform_device *device)
+{
+	int ret = 0;
+	int i = 0;
+	dma_channel_t *pchan = NULL;
+
+	/* init dma controller */
+	csp_dma_init();
+
+	/* initial the dma manager */
+	memset(&g_dma_mgr, 0, sizeof(g_dma_mgr));
+	for(i = 0; i < DMA_CHAN_TOTAL; i++) {
+		pchan 		= &g_dma_mgr.chnl[i];
+		pchan->used 	= 0;
+		pchan->id 	= i;
+		pchan->reg_base = (u32)DMA_CTRL_REG(i);
+		pchan->irq_spt 	= CHAN_IRQ_NO;
+		pchan->bconti_mode = false;
+		DMA_CHAN_LOCK_INIT(&pchan->lock);
+		pchan->state = CHAN_STA_IDLE;
+	}
+
+	/* alloc dma pool for des list */
+	g_buf_cache = kmem_cache_create("dma_desc", sizeof(buf_item), 0, SLAB_HWCACHE_ALIGN, __dma_cache_ctor);
+	if(NULL == g_buf_cache) {
+		ret = __LINE__;
+		goto end;
+	}
+	DMA_INF("%s(%d): g_buf_cache 0x%08x\n", __func__, __LINE__, (u32)g_buf_cache);
+
+	/* register dma interrupt */
+	ret = request_irq(SW_INT_IRQNO_DMA, __dma_irq_hdl, IRQF_DISABLED,
+			"dma_irq", (void *)&g_dma_mgr);
+	if(ret) {
+		DMA_ERR("%s err: request_irq return %d\n", __func__, ret);
+		ret = __LINE__;
+		goto end;
+	}
+	DMA_INF("%s success\n", __func__);
+
+end:
+	if(0 != ret) {
+		DMA_ERR("%s err, line %d\n", __func__, ret);
+		if (NULL != g_buf_cache) {
+			kmem_cache_destroy(g_buf_cache);
+			g_buf_cache = NULL;
+		}
+		for(i = 0; i < DMA_CHAN_TOTAL; i++)
+			DMA_CHAN_LOCK_DEINIT(&g_dma_mgr.chnl[i].lock);
+	}
+	return ret;
+}
+
+/**
+ * __dma_deinit - deinit the dma manager, free irq
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+int __dma_deinit(void)
+{
+	u32 	i = 0;
+
+	DMA_INF("%s, line %d\n", __func__, __LINE__);
+	/* free dma irq */
+	free_irq(SW_INT_IRQNO_DMA, (void *)&g_dma_mgr);
+	/* free kcache */
+	if (NULL != g_buf_cache) {
+		kmem_cache_destroy(g_buf_cache);
+		g_buf_cache = NULL;
+	}
+	for(i = 0; i < DMA_CHAN_TOTAL; i++)
+		DMA_CHAN_LOCK_DEINIT(&g_dma_mgr.chnl[i].lock);
+	/* clear dma manager */
+	memset(&g_dma_mgr, 0, sizeof(g_dma_mgr));
+	return 0;
+}
+
+/**
+ * dma_drv_probe - dma driver inital function.
+ * @dev:	platform device pointer
+ *
+ * Returns 0 if success, otherwise return the err line number.
+ */
+static int __devinit dma_drv_probe(struct platform_device *dev)
+{
+	return __dma_init(dev);
+}
+
+/**
+ * dma_drv_remove - dma driver deinital function.
+ * @dev:	platform device pointer
+ *
+ * Returns 0 if success, otherwise means err.
+ */
+static int __devexit dma_drv_remove(struct platform_device *dev)
+{
+	return __dma_deinit();
+}
+
+static struct platform_driver sw_dmac_driver = {
+	.probe          = dma_drv_probe,
+	.remove         = __devexit_p(dma_drv_remove),
+	.driver         = {
+		.name   = "sw_dmac",
+		.owner  = THIS_MODULE,
+		},
+};
+
+/**
+ * drv_dma_init - dma driver register function
+ *
+ * Returns 0 if success, otherwise means err.
+ */
+static int __init drv_dma_init(void)
+{
+	if(platform_driver_register(&sw_dmac_driver))
+		printk("%s(%d) err: platform_driver_register failed\n", __func__, __LINE__);
+	return 0;
+}
+arch_initcall(drv_dma_init);
+
diff --git a/arch/arm/mach-sun7i/dma/dma_common.h b/arch/arm/mach-sun7i/dma/dma_common.h
new file mode 100755
index 0000000..a9feb52
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_common.h
@@ -0,0 +1,137 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma_common.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma common header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_COMMON_H
+#define __DMA_COMMON_H
+
+#include <linux/spinlock.h>
+
+/* dma print macro */
+#define DMA_DBG_LEVEL		3
+
+#if (DMA_DBG_LEVEL == 1)
+	#define DMA_DBG(format,args...)   printk("[dma-dbg] "format,##args)
+	#define DMA_INF(format,args...)   printk("[dma-inf] "format,##args)
+	#define DMA_ERR(format,args...)   printk("[dma-err] "format,##args)
+#elif (DMA_DBG_LEVEL == 2)
+	#define DMA_DBG(format,args...)   do{}while(0)
+	#define DMA_INF(format,args...)   printk("[dma-inf] "format,##args)
+	#define DMA_ERR(format,args...)   printk("[dma-err] "format,##args)
+#elif (DMA_DBG_LEVEL == 3)
+	#define DMA_DBG(format,args...)   do{}while(0)
+	#define DMA_INF(format,args...)   do{}while(0)
+	#define DMA_ERR(format,args...)   printk("[dma-err] "format,##args)
+#endif
+
+/* dma channel number */
+#define NR_CHAN_NORMAL		(8)
+#define NR_CHAN_DEDICATE	(8)
+#define DMA_CHAN_TOTAL		(NR_CHAN_NORMAL + NR_CHAN_DEDICATE)
+
+typedef struct {
+	u32 src_drq 		: 5; /* ndma src drq type */
+	u32 src_addr_type 	: 1; /* ndma src address type */
+	u32 src_sec 		: 1; /* dma src security */
+	u32 src_bst_len 	: 2; /* dma src burst length */
+	u32 src_data_width 	: 2; /* ndma src data width */
+	u32 rsv0 		: 4; /* reserve */
+	u32 bc_mod 		: 1; /* bc mode select */
+	u32 dst_drq 		: 5; /* ndma dst drq type */
+	u32 dst_addr_type 	: 1; /* ndma dst address type */
+	u32 dst_sec 		: 1; /* dma dst security */
+	u32 dst_bst_len 	: 2; /* dma dst burst length */
+	u32 dst_data_width 	: 2; /* ndma dst data width */
+	u32 wait_state 		: 3; /* dma wait state */
+	u32 conti 		: 1; /* dma continuous mode enable */
+	u32 loading 		: 1; /* dma loading */
+}ndma_ctrl_t;
+
+typedef struct {
+	u32 src_drq 		: 5; /* ddma src drq type */
+	u32 src_addr_mode 	: 2; /* dma src address mode */
+	u32 src_bst_len 	: 2; /* dma src burst length */
+	u32 src_data_width 	: 2; /* dma src data width */
+	u32 rsv0 		: 1; /* reserve */
+	u32 src_sec 		: 1; /* dma src security */
+	u32 rsv1 		: 2; /* reserve */
+	u32 bc_mod 		: 1; /* bc mode select */
+	u32 dst_drq 		: 5; /* ddma dst drq type */
+	u32 dst_addr_mode 	: 2; /* dma dst address mode */
+	u32 dst_bst_len 	: 2; /* dma dst burst length */
+	u32 dst_data_width 	: 2; /* dma dst data width */
+	u32 rsv2 		: 1; /* reserve */
+	u32 dst_sec 		: 1; /* dma dst security */
+	u32 conti 		: 1; /* dma continuous mode enable */
+	u32 busy 		: 1; /* dma busy status */
+	u32 loading 		: 1; /* dma loading */
+}ddma_ctrl_t;
+
+typedef union {
+	ndma_ctrl_t	n;
+	ddma_ctrl_t	d;
+}dma_ctrl_u;
+
+/* dam channel state for single mode */
+typedef enum {
+	CHAN_STA_IDLE,  	/* maybe before start or after stop */
+	CHAN_STA_RUNING,	/* transferring */
+	CHAN_STA_LAST_DONE	/* the last buffer has done, in this state, sw_dma_enqueue will start dma */
+}chan_state_e;
+
+/* buf item define */
+typedef struct {
+	u32	saddr;		/* src phys address */
+	u32	daddr;		/* dst phys address */
+	u32	bcnt;		/* bytes cnt to transfer */
+	struct list_head list;	/* list node */
+}buf_item;
+
+/* dma channel owner name max len */
+#define MAX_NAME_LEN	32
+
+/* define dma channel struct */
+typedef struct {
+	u32		used;     	/* 1 used, 0 unuse */
+	u32		id;     	/* channel id, 0~15 */
+	char 		owner[MAX_NAME_LEN]; /* dma chnnnel owner name */
+	u32		reg_base;	/* ctrl reg virtual addr */
+	dma_ctrl_u 	ctrl;		/* ctrl reg setting */
+	dma_cb_t	hd_cb;		/* half done call back func */
+	dma_cb_t	fd_cb;		/* full done call back func */
+	chan_state_e	state;		/* channel state, in software */
+	u32 		irq_spt;	/* channel irq support, used for irq handler, only enabled
+					 * then can call irq callback
+					 */
+	u32		bconti_mode;	/* cotinue mode, same in ctrl, add here in order easy to use */
+	spinlock_t 	lock;		/* channel lock for buf list and reg ops */
+	buf_item	*pcur_buf;	/* cur buf in transferring */
+	struct list_head buf_list;	/* buf list head */
+}dma_channel_t;
+
+/* dma manager struct */
+struct dma_mgr_t {
+	dma_channel_t chnl[DMA_CHAN_TOTAL];
+};
+extern struct dma_mgr_t g_dma_mgr;
+extern struct kmem_cache *g_buf_cache;
+
+/* dma channel lock */
+#define DMA_CHAN_LOCK_INIT(lock)	spin_lock_init((lock))
+#define DMA_CHAN_LOCK_DEINIT(lock)	do{}while(0)
+#define DMA_CHAN_LOCK(lock, flag)	spin_lock_irqsave((lock), (flag))
+#define DMA_CHAN_UNLOCK(lock, flag)	spin_unlock_irqrestore((lock), (flag))
+
+#endif  /* __DMA_COMMON_H */
+
diff --git a/arch/arm/mach-sun7i/dma/dma_core.c b/arch/arm/mach-sun7i/dma/dma_core.c
new file mode 100755
index 0000000..bdbba99
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_core.c
@@ -0,0 +1,490 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma_core.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+
+/**
+ * __dma_start - start dma
+ * @dma_hdl:	dma handle
+ *
+ * find the first buf in list, remove it, and start it.
+ *
+ * Returns 0 if sucess, otherwise failed.
+ */
+u32 __dma_start(dma_hdl_t dma_hdl)
+{
+	buf_item *pbuf = NULL;
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+
+	if(unlikely(list_empty(&pchan->buf_list))) {
+		BUG();
+		return -EPERM;
+	}
+
+	/* remove from list */
+	pbuf = list_entry(pchan->buf_list.next, buf_item, list);
+	list_del(&pbuf->list); /* only remove from list, not free it */
+	/* set src addr */
+	csp_dma_set_saddr(pchan, pbuf->saddr);
+	/* set dst addr */
+	csp_dma_set_daddr(pchan, pbuf->daddr);
+	/* set byte cnt */
+	csp_dma_set_bcnt(pchan, pbuf->bcnt);
+	/* irq enable */
+	csp_dma_irq_enable(pchan, pchan->irq_spt);
+	/* set ctrl reg */
+	csp_dma_set_ctrl(pchan, *(u32 *)&pchan->ctrl);
+
+	/* start dma */
+	csp_dma_start(pchan);
+	pchan->state = CHAN_STA_RUNING;
+	pchan->pcur_buf = pbuf;
+
+	return 0;
+}
+
+/**
+ * __dma_free_buflist - free buf in list, not include cur buf
+ * @pchan:	dma handle
+ */
+void __dma_free_buflist(dma_channel_t *pchan)
+{
+	buf_item *pbuf = NULL;
+
+	while (!list_empty(&pchan->buf_list)) {
+		pbuf = list_entry(pchan->buf_list.next, buf_item, list);
+		list_del(&pbuf->list);
+		kmem_cache_free(g_buf_cache, pbuf);
+	}
+}
+
+/**
+ * __dma_free_buflist - free all buf, include cur buf
+ * @pchan:	dma handle
+ */
+void __dma_free_allbuf(dma_channel_t *pchan)
+{
+	if(NULL != pchan->pcur_buf) {
+		kmem_cache_free(g_buf_cache, pchan->pcur_buf);
+		pchan->pcur_buf = NULL;
+	}
+	__dma_free_buflist(pchan);
+}
+
+/**
+ * __dma_stop - stop dma and free all buf
+ * @dma_hdl:	dma handle
+ *
+ */
+void __dma_stop(dma_hdl_t dma_hdl)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+
+	DMA_INF("%s: state %d, buf chain: \n", __func__, (u32)pchan->state);
+	//dma_dump_chain(pchan); /* for debug */
+
+	/* check state, for debug */
+	switch(pchan->state) {
+	case CHAN_STA_IDLE:
+		DMA_INF("%s: state idle, maybe before start or after stop, so stop the channel, free all buf list\n", __func__);
+		WARN_ON(NULL != pchan->pcur_buf);
+		break;
+	case CHAN_STA_RUNING:
+		DMA_INF("%s: state running, so stop the channel, abort the cur buf, and free extra buf\n", __func__);
+		WARN_ON(NULL == pchan->pcur_buf);
+		break;
+	case CHAN_STA_LAST_DONE:
+		DMA_INF("%s: state last done, so stop the channel, buffer already freed all, to check\n", __func__);
+		WARN_ON(NULL != pchan->pcur_buf || !list_empty(&pchan->buf_list));
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	/* stop dma channle and clear irq pending */
+	csp_dma_stop(pchan);
+	csp_dma_clear_irqpend(pchan, CHAN_IRQ_HD | CHAN_IRQ_FD);
+	/* free buffer list */
+	__dma_free_allbuf(pchan);
+
+	/* change channel state to idle */
+	pchan->state = CHAN_STA_IDLE;
+}
+
+void __dma_set_hd_cb(dma_hdl_t dma_hdl, dma_cb_t *pcb)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+
+	WARN_ON(CHAN_STA_IDLE != pchan->state);
+	pchan->hd_cb.func = pcb->func;
+	pchan->hd_cb.parg = pcb->parg;
+}
+
+void __dma_set_fd_cb(dma_hdl_t dma_hdl, dma_cb_t *pcb)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+
+	WARN_ON(CHAN_STA_IDLE != pchan->state);
+	pchan->fd_cb.func = pcb->func;
+	pchan->fd_cb.parg = pcb->parg;
+}
+
+/**
+ * __dma_enqueue - add buf to channel buf list
+ * @dma_hdl:	dma handle
+ * @src_addr:	src phys addr
+ * @dst_addr:	dst phys addr
+ * @byte_cnt:	buffer length
+ *
+ * Returns 0 if sucess, otherwise failed.
+ */
+u32 __dma_enqueue(dma_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+	buf_item *pbuf_item = NULL;
+	u32 uret = 0;
+
+	pbuf_item = (buf_item *)kmem_cache_alloc(g_buf_cache, GFP_ATOMIC);
+	if(NULL == pbuf_item) {
+		uret = __LINE__;
+		goto end;
+	}
+	pbuf_item->saddr = src_addr;
+	pbuf_item->daddr = dst_addr;
+	pbuf_item->bcnt = byte_cnt;
+
+	/* add to list end */
+	list_add_tail(&pbuf_item->list, &pchan->buf_list);
+	/* start it if state is last done*/
+	if(CHAN_STA_LAST_DONE == pchan->state) {
+		DMA_INF("%s(%d): last done\n", __func__, __LINE__);
+		if(0 != __dma_start(dma_hdl)) {
+			uret = __LINE__;
+			goto end;
+		}
+	}
+end:
+	if(0 != uret) {
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+		if(pbuf_item)
+			kmem_cache_free(g_buf_cache, pbuf_item);
+	}
+	return uret;
+}
+
+/**
+ * dma_hdl_irq_fd - full done irq handler
+ * @pchan:	dma handle
+ *
+ * firstly, call full done callback; then, if state running, start the next buf in list,
+ * or change state to CHAN_STA_LAST_DONE if have no buffer to transfer.
+ *
+ * Returns 0 if sucess, otherwise failed.
+ */
+u32 dma_hdl_irq_fd(dma_channel_t *pchan)
+{
+	chan_state_e cur_state = 0;
+	unsigned long flags = 0;
+	u32 uret = 0;
+
+	/*
+	 * cannot lock fd_cb function, in case sw_dma_enqueue called in callback and lock again,
+	 * lead to deadlock
+	 */
+	if(NULL != pchan->fd_cb.func)
+		pchan->fd_cb.func((dma_hdl_t)pchan, pchan->fd_cb.parg);
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+	cur_state = pchan->state;
+	switch(cur_state) {
+	case CHAN_STA_IDLE: /* stopped in hd_cb/fd_cb/somewhere? */
+		DMA_INF("%s: state idle, stopped in cb before? just return ok!\n", __func__);
+		//WARN_ON(!list_empty(&pchan->buf_list)); /* maybe new enqueue after stopped */
+		goto end;
+	case CHAN_STA_RUNING:
+		WARN_ON(NULL == pchan->pcur_buf);
+		if(unlikely(true == pchan->bconti_mode)) /* hw restart, not need soft start */
+			break;
+		/* for no-continue mode, free cur buf and start the next buf in chain */
+		kmem_cache_free(g_buf_cache, pchan->pcur_buf);
+		pchan->pcur_buf = NULL;
+		/* start next if there is, or change to last done */
+		if(!list_empty(&pchan->buf_list)) {
+			uret = __dma_start((dma_hdl_t)pchan);
+			goto end;
+		} else {
+			DMA_INF("%s(%d), all buf done, change state to last done\n", __func__, __LINE__);
+			pchan->state = CHAN_STA_LAST_DONE; /* change state to done */
+		}
+		break;
+	default:
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+/**
+ * dma_dump_chain - dump channel struct
+ * @pchan:	dma handle
+ */
+void dma_dump_chain(dma_channel_t *pchan)
+{
+	buf_item *pitem = NULL;
+
+	if(NULL == pchan) {
+		DMA_ERR("%s(%d) err, para is NULL\n", __func__, __LINE__);
+		return;
+	}
+	printk("+++++++++++%s+++++++++++\n", __func__);
+	printk("  channel id:        %d\n", pchan->id);
+	printk("  channel used:      %d\n", pchan->used);
+	printk("  channel owner:     %s\n", pchan->owner);
+	printk("  bconti_mode:       %d\n", pchan->bconti_mode);
+	printk("  channel irq_spt:   0x%08x\n", pchan->irq_spt);
+	printk("  channel reg_base:  0x%08x\n", pchan->reg_base);
+	printk("        irq_en:  0x%08x\n", readl(DMA_IRQ_EN_REG));
+	printk("        irq_pd:  0x%08x\n", readl(DMA_IRQ_PEND_REG));
+	printk("     auto_gate:  0x%08x\n", readl(NDMA_AUTO_GAT_REG));
+	printk("        config:  0x%08x\n", readl(pchan->reg_base + DMA_OFF_REG_CTRL));
+	printk("        config:  0x%08x\n", readl(pchan->reg_base + DMA_OFF_REG_CTRL));
+	printk("           src:  0x%08x\n", readl(pchan->reg_base + DMA_OFF_REG_SADR));
+	printk("           dst:  0x%08x\n", readl(pchan->reg_base + DMA_OFF_REG_DADR));
+	printk("         bycnt:  0x%08x\n", readl(pchan->reg_base + DMA_OFF_REG_BC));
+	if(IS_DEDICATE(pchan->id))
+		printk("  	  para:  0x%08x\n", readl(pchan->reg_base + DMA_OFF_REG_PARA));
+	printk("  channel state:     0x%08x\n", (u32)pchan->state);
+	printk("  channel hd_cb:     0x%08x\n", (u32)pchan->hd_cb.func);
+	printk("  channel fd_cb:     0x%08x\n", (u32)pchan->fd_cb.func);
+	printk("  ctrl reg:          0x%08x\n", *(u32 *)&pchan->ctrl);
+	printk("  pcur_buf:          0x%08x\n", (u32)pchan->pcur_buf);
+	printk("  buf list:\n");
+	list_for_each_entry(pitem, &pchan->buf_list, list) {
+		printk("         saddr: 0x%08x, daddr 0x%08x, bcnt 0x%08x\n", pitem->saddr, pitem->daddr, pitem->bcnt);
+	}
+	printk("-----------%s-----------\n", __func__);
+}
+
+/**
+ * dma_request_init - init some member after requested
+ * @pchan:	dma handle
+ */
+void dma_request_init(dma_channel_t *pchan)
+{
+	INIT_LIST_HEAD(&pchan->buf_list);
+	pchan->state = CHAN_STA_IDLE;
+	pchan->pcur_buf = NULL;
+}
+
+/**
+ * dma_release - release dma channel, for single mode
+ * @dma_hdl:	dma handle
+ *
+ * return 0 if success, the err line number if not
+ */
+void dma_release(dma_hdl_t dma_hdl)
+{
+	unsigned long 	flags = 0;
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	/* if not idle, call stop first */
+	if(CHAN_STA_IDLE != pchan->state) {
+		DMA_INF("%s(%d) maybe err: state(%d) not idle, call stop dma first!\n", __func__, __LINE__, pchan->state);
+		__dma_stop(dma_hdl);
+	}
+
+	//memset(pchan, 0, sizeof(*pchan)); /* donot do that, because id...should not be cleared */
+	pchan->used = 0;
+	memset(pchan->owner, 0, sizeof(pchan->owner));
+	pchan->irq_spt = CHAN_IRQ_NO;
+	pchan->bconti_mode = false;
+	memset(&pchan->ctrl, 0, sizeof(pchan->ctrl));
+	memset(&pchan->hd_cb, 0, sizeof(pchan->hd_cb));
+	memset(&pchan->fd_cb, 0, sizeof(pchan->fd_cb));
+	/* maybe enqueued but not started, so free buf */
+	WARN_ON(NULL != pchan->pcur_buf);
+	__dma_free_buflist(pchan);
+
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+}
+
+/**
+ * dma_ctrl - dma ctrl, for single mode
+ * @dma_hdl:	dma handle
+ * @op:		dma operation type
+ * @parg:	arg for the op
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 dma_ctrl(dma_hdl_t dma_hdl, dma_op_type_e op, void *parg)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+	unsigned long flags = 0;
+	u32 uret = 0;
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	switch(op) {
+	case DMA_OP_START:
+		if(unlikely(CHAN_STA_IDLE != pchan->state)) {
+			DMA_ERR("%s(%d): start when state is not idle, to check!\n", __func__, __LINE__);
+			goto end;
+		}
+		uret = __dma_start(dma_hdl);
+		break;
+	case DMA_OP_STOP:
+		__dma_stop(dma_hdl);
+		break;
+	case DMA_OP_GET_STATUS: /* only for dedicate dma */
+		*(u32 *)parg = csp_dma_get_status(pchan);
+		break;
+	case DMA_OP_GET_BYTECNT_LEFT: /* bc_mode 1, so readback is left bytes */
+		*(u32 *)parg = csp_dma_get_bcnt(pchan);
+		break;
+	case DMA_OP_SET_HD_CB:
+		BUG_ON(NULL == parg);
+		__dma_set_hd_cb(dma_hdl, (dma_cb_t *)parg);
+		break;
+	case DMA_OP_SET_FD_CB:
+		BUG_ON(NULL == parg);
+		__dma_set_fd_cb(dma_hdl, (dma_cb_t *)parg);
+		break;
+	case DMA_OP_SET_PARA_REG:
+		BUG_ON(NULL == parg);
+		csp_dma_set_para(pchan, *(dma_para_t *)parg);
+		break;
+	case DMA_OP_SET_WAIT_STATE: /* para is 0~7 */
+		BUG_ON(NULL == parg);
+		csp_ndma_set_wait_state(pchan, *(u32 *)parg);
+		break;
+	case DMA_OP_SET_SECURITY:
+		BUG_ON(NULL == parg);
+		csp_dma_set_security(pchan, *(u32 *)parg);
+		break;
+	default:
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d, dma_hdl 0x%08x\n", __func__, uret, (u32)dma_hdl);
+	return uret;
+}
+
+/**
+ * dma_config - config dma hardware paras
+ * @dma_hdl:	dma handle
+ * @pcfg:	dma cofig para
+ *
+ */
+void dma_config(dma_hdl_t dma_hdl, dma_config_t *pcfg)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+	bool dedicate;
+	dma_ctrl_u ctrl;
+
+	BUG_ON(unlikely(NULL == pchan));
+	/* get cfg from hw reg */
+	ctrl = csp_dma_get_ctrl(pchan);
+	dedicate = IS_DEDICATE(pchan->id);
+	if(dedicate) {
+		/*
+		 * BC mode select, 0: normal mode(BC reg readback is bytes already transferred),
+		 * 1: remain mode(BC reg readback is bytes to be transferred)
+		 */
+		ctrl.d.bc_mod = 1;
+		ctrl.d.conti = pcfg->bconti_mode;
+		ctrl.d.dst_addr_mode = pcfg->address_type.dst_addr_mode;
+		ctrl.d.dst_bst_len = pcfg->xfer_type.dst_bst_len;
+		ctrl.d.dst_data_width = pcfg->xfer_type.dst_data_width;
+		ctrl.d.dst_drq = pcfg->dst_drq_type;
+		//ctrl.d.dst_sec = pcfg->dst_secu;
+		ctrl.d.dst_sec = 0;
+		ctrl.d.src_addr_mode = pcfg->address_type.src_addr_mode;
+		ctrl.d.src_bst_len = pcfg->xfer_type.src_bst_len;
+		ctrl.d.src_data_width = pcfg->xfer_type.src_data_width;
+		ctrl.d.src_drq = pcfg->src_drq_type;
+		//ctrl.d.src_sec = pcfg->src_secu;
+		ctrl.d.src_sec = 0;
+		ctrl.d.loading = 0; /* not start */
+	} else {
+		ctrl.n.bc_mod = 1;
+		ctrl.n.conti = pcfg->bconti_mode;
+		ctrl.n.dst_addr_type = pcfg->address_type.dst_addr_mode;
+		ctrl.n.dst_bst_len = pcfg->xfer_type.dst_bst_len;
+		ctrl.n.dst_data_width = pcfg->xfer_type.dst_data_width;
+		ctrl.n.dst_drq = pcfg->dst_drq_type;
+		//ctrl.n.dst_sec = pcfg->dst_secu;
+		ctrl.n.dst_sec = 0;
+		ctrl.n.src_addr_type = pcfg->address_type.src_addr_mode;
+		ctrl.n.src_bst_len = pcfg->xfer_type.src_bst_len;
+		ctrl.n.src_data_width = pcfg->xfer_type.src_data_width;
+		ctrl.n.src_drq = pcfg->src_drq_type;
+		//ctrl.n.src_sec = pcfg->src_secu;
+		ctrl.n.src_sec = 0;
+		//ctrl.n.wait_state = pcfg->wait_state;
+		ctrl.n.wait_state = 0;
+		ctrl.n.loading = 0; /* not start */
+	}
+	pchan->ctrl = ctrl;
+	pchan->bconti_mode = pcfg->bconti_mode;
+	pchan->irq_spt = pcfg->irq_spt;
+}
+
+/**
+ * sw_dma_enqueue - add buf to list
+ * @dma_hdl:	dma handle
+ * @src_addr:	buffer src phys addr
+ * @dst_addr:	buffer dst phys addr
+ * @byte_cnt:	buffer byte cnt
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 dma_enqueue(dma_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt)
+{
+	u32 uret = 0;
+	unsigned long flags = 0;
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	/* cannot enqueue more than one buffer in single_continue mode */
+	if(true == pchan->bconti_mode
+		&& !list_empty(&pchan->buf_list)) {
+		uret = __LINE__;
+		goto end;
+	}
+	if(0 != __dma_enqueue(dma_hdl, src_addr, dst_addr, byte_cnt)) {
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
diff --git a/arch/arm/mach-sun7i/dma/dma_core.h b/arch/arm/mach-sun7i/dma/dma_core.h
new file mode 100755
index 0000000..d37876c
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_core.h
@@ -0,0 +1,28 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_core.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_CORE_H
+#define __DMA_CORE_H
+
+u32 dma_enqueue(dma_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt);
+void dma_config(dma_hdl_t dma_hdl, dma_config_t *pcfg);
+u32 dma_ctrl(dma_hdl_t dma_hdl, dma_op_type_e op, void *parg);
+void dma_release(dma_hdl_t dma_hdl);
+void dma_request_init(dma_channel_t *pchan);
+void dma_dump_chain(dma_channel_t *pchan);
+u32 dma_hdl_irq_fd(dma_channel_t *pchan);
+
+#endif  /* __DMA_CORE_H */
+
diff --git a/arch/arm/mach-sun7i/dma/dma_csp.c b/arch/arm/mach-sun7i/dma/dma_csp.c
new file mode 100755
index 0000000..83f70d7
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_csp.c
@@ -0,0 +1,320 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma_csp.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma csp functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+
+struct clk 	*g_dma_ahb_clk = NULL;
+
+/**
+ * dma_clk_init - init dma clock
+ *
+ * Returns 0 if sucess, otherwise failed.
+ */
+u32 dma_clk_init(void)
+{
+	/* config dma ahb clock */
+	WARN_ON(g_dma_ahb_clk);
+	g_dma_ahb_clk = clk_get(NULL, CLK_AHB_DMA);
+	DMA_DBG("%s: get g_dma_ahb_clk 0x%08x\n", __func__, (u32)g_dma_ahb_clk);
+	if(NULL == g_dma_ahb_clk || IS_ERR(g_dma_ahb_clk)) {
+		printk("%s err: clk_get %s failed\n", __func__, CLK_AHB_DMA);
+		return -EPERM;
+	} else {
+		if(0 != clk_enable(g_dma_ahb_clk)) {
+			DMA_ERR("%s err: clk_enable failed, line %d\n", __func__, __LINE__);
+			return -EPERM;
+		}
+		DMA_DBG("%s: clk_enable g_dma_ahb_clk success\n", __func__);
+	}
+
+	DMA_DBG("%s success\n", __func__);
+	return 0;
+}
+
+/**
+ * dma_clk_deinit - deinit dma clock
+ *
+ * Returns 0 if sucess, otherwise failed.
+ */
+u32 dma_clk_deinit(void)
+{
+	/* release dma ahb clock */
+	DMA_DBG("%s: g_dma_ahb_clk 0x%08x\n", __func__, (u32)g_dma_ahb_clk);
+	if(NULL == g_dma_ahb_clk || IS_ERR(g_dma_ahb_clk)) {
+		DMA_INF("%s err: g_dma_ahb_clk 0x%08x invalid\n", __func__, (u32)g_dma_ahb_clk);
+		return 0;
+	} else {
+		clk_disable(g_dma_ahb_clk);
+		clk_put(g_dma_ahb_clk);
+		g_dma_ahb_clk = NULL;
+	}
+
+	DMA_DBG("%s success\n", __func__);
+	return 0;
+}
+
+/**
+ * csp_dma_init - dma reg init, clear irq pending, disable irq
+ */
+void csp_dma_init(void)
+{
+	u32 	i = 0;
+
+	/* init dma clock */
+	if(0 != dma_clk_init())
+		DMA_ERR("%s err, dma_clk_init failed, line %d\n", __func__, __LINE__);
+
+	/* Disable & clear all interrupts */
+	DMA_WRITE_REG(0, DMA_IRQ_EN_REG);
+	DMA_WRITE_REG(0xffffffff, DMA_IRQ_PEND_REG);
+	/* init enable reg */
+	for(i = 0; i < DMA_CHAN_TOTAL; i++)
+		DMA_WRITE_REG(0, DMA_CTRL_REG(i));
+}
+
+/**
+ * csp_dma_start - start dma channel
+ * @pchan:	dma channel handle
+ */
+void inline csp_dma_start(dma_channel_t * pchan)
+{
+	u32 temp = DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CTRL);
+	temp |= (1<<31);
+	DMA_WRITE_REG(temp, pchan->reg_base + DMA_OFF_REG_CTRL);
+}
+
+/**
+ * csp_dma_stop - stop dma channel
+ * @pchan:	dma channel handle
+ */
+void inline csp_dma_stop(dma_channel_t * pchan)
+{
+	u32 temp = DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CTRL);
+	temp &= ~(1<<31);
+	DMA_WRITE_REG(temp, pchan->reg_base + DMA_OFF_REG_CTRL);
+}
+
+/* if ndma work in continous mode, auto clock should disable */
+void inline csp_ndma_autoclk_enable(void)
+{
+	u32 val = DMA_READ_REG(NDMA_AUTO_GAT_REG);
+	val &= ~(1<<16);
+	DMA_WRITE_REG(val, NDMA_AUTO_GAT_REG);
+}
+
+void inline csp_ndma_autoclk_disable(void)
+{
+	u32 val = DMA_READ_REG(NDMA_AUTO_GAT_REG);
+	val |= (1<<16);
+	DMA_WRITE_REG(val, NDMA_AUTO_GAT_REG);
+}
+
+/* set wate state, for ndma only. state: 0~7, from spec */
+void inline csp_ndma_set_wait_state(dma_channel_t * pchan, u32 state)
+{
+	ndma_ctrl_t ctrl;
+	u32 val;
+
+	BUG_ON(unlikely(pchan->id >= 8));
+	val = DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CTRL);
+	ctrl = *(ndma_ctrl_t *)&val;
+	ctrl.wait_state = state;
+	DMA_WRITE_REG(*(u32 *)&ctrl, pchan->reg_base + DMA_OFF_REG_CTRL);
+	/* refresh ctrl val, set on next start */
+	pchan->ctrl.n.wait_state = state;
+}
+
+/* set security, both for ndma and ddma */
+void inline csp_dma_set_security(dma_channel_t * pchan, u32 para)
+{
+	dma_ctrl_u ctrl;
+	u32 val;
+
+	val = DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CTRL);
+	ctrl = *(dma_ctrl_u *)&val;
+	switch(para) {
+	case SRC_SECU_DST_SECU:
+		IS_DEDICATE(pchan->id) ? (ctrl.d.src_sec = 0, ctrl.d.dst_sec = 0)
+					: (ctrl.n.src_sec = 0, ctrl.n.dst_sec = 0);
+		/* refresh ctrl val, set on next start */
+		IS_DEDICATE(pchan->id) ? (pchan->ctrl.d.src_sec = 0, pchan->ctrl.d.dst_sec = 0)
+					: (pchan->ctrl.n.src_sec = 0, pchan->ctrl.n.dst_sec = 0);
+		break;
+	case SRC_SECU_DST_NON_SECU:
+		IS_DEDICATE(pchan->id) ? (ctrl.d.src_sec = 0, ctrl.d.dst_sec = 1)
+					: (ctrl.n.src_sec = 0, ctrl.n.dst_sec = 1);
+		IS_DEDICATE(pchan->id) ? (pchan->ctrl.d.src_sec = 0, pchan->ctrl.d.dst_sec = 1)
+					: (pchan->ctrl.n.src_sec = 0, pchan->ctrl.n.dst_sec = 1);
+		break;
+	case SRC_NON_SECU_DST_SECU:
+		IS_DEDICATE(pchan->id) ? (ctrl.d.src_sec = 1, ctrl.d.dst_sec = 0)
+					: (ctrl.n.src_sec = 1, ctrl.n.dst_sec = 0);
+		IS_DEDICATE(pchan->id) ? (pchan->ctrl.d.src_sec = 1, pchan->ctrl.d.dst_sec = 0)
+					: (pchan->ctrl.n.src_sec = 1, pchan->ctrl.n.dst_sec = 0);
+		break;
+	case SRC_NON_SECU_DST_NON_SECU:
+		IS_DEDICATE(pchan->id) ? (ctrl.d.src_sec = 1, ctrl.d.dst_sec = 1)
+					: (ctrl.n.src_sec = 1, ctrl.n.dst_sec = 1);
+		IS_DEDICATE(pchan->id) ? (pchan->ctrl.d.src_sec = 1, pchan->ctrl.d.dst_sec = 1)
+					: (pchan->ctrl.n.src_sec = 1, pchan->ctrl.n.dst_sec = 1);
+		break;
+	default:
+		BUG();
+		break;
+	}
+	DMA_WRITE_REG(*(u32 *)&ctrl, pchan->reg_base + DMA_OFF_REG_CTRL);
+}
+
+void inline csp_dma_set_saddr(dma_channel_t * pchan, u32 ustart_addr)
+{
+	DMA_WRITE_REG(ustart_addr, pchan->reg_base + DMA_OFF_REG_SADR);
+}
+
+void inline csp_dma_set_daddr(dma_channel_t * pchan, u32 ustart_addr)
+{
+	DMA_WRITE_REG(ustart_addr, pchan->reg_base + DMA_OFF_REG_DADR);
+}
+
+void inline csp_dma_set_bcnt(dma_channel_t * pchan, u32 byte_cnt)
+{
+	DMA_WRITE_REG(byte_cnt, pchan->reg_base + DMA_OFF_REG_BC);
+}
+
+/* set para reg, for ddma only */
+void inline csp_dma_set_para(dma_channel_t * pchan, dma_para_t para)
+{
+	BUG_ON(pchan->id < 8);
+	DMA_WRITE_REG(*(u32 *)&para, pchan->reg_base + DMA_OFF_REG_PARA);
+}
+
+void inline csp_dma_set_ctrl(dma_channel_t * pchan, u32 val)
+{
+	DMA_WRITE_REG(val, pchan->reg_base + DMA_OFF_REG_CTRL);
+}
+
+/**
+ * csp_dma_get_status - get dma channel status, for ddma only
+ * @pchan:	dma channel handle
+ *
+ * Returns 1 indicate channel is busy, 0 idle
+ */
+u32 inline csp_dma_get_status(dma_channel_t * pchan)
+{
+	u32 temp = DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CTRL);
+	BUG_ON(!IS_DEDICATE(pchan->id));
+	return !!(temp & (1<<30));
+}
+
+/**
+ * csp_dma_get_saddr - get start src addr reg
+ * @pchan:	dma channel handle
+ *
+ * Returns the channel's start src addr reg
+ */
+u32 inline csp_dma_get_saddr(dma_channel_t * pchan)
+{
+	return DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_SADR);
+}
+
+/**
+ * csp_dma_get_daddr - get start dst addr reg
+ * @pchan:	dma channel handle
+ *
+ * Returns the channel's start dst addr reg
+ */
+u32 inline csp_dma_get_daddr(dma_channel_t * pchan)
+{
+	return DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_DADR);
+}
+
+/**
+ * csp_dma_get_bcnt - get left byte cnt
+ * @pchan:	dma channel handle
+ *
+ * Returns the channel's left byte cnt
+ */
+u32 inline csp_dma_get_bcnt(dma_channel_t * pchan)
+{
+	return DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_BC);
+}
+
+/**
+ * csp_dma_get_para - get para reg value, for ddma only
+ * @pchan:	dma channel handle
+ *
+ * Returns the dma channel's para reg value
+ */
+dma_para_t inline csp_dma_get_para(dma_channel_t *pchan)
+{
+	u32 reg_val;
+
+	BUG_ON(!IS_DEDICATE(pchan->id));
+	reg_val = DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_PARA);
+	return *(dma_para_t *)&reg_val;
+}
+
+/**
+ * csp_dma_get_ctrl - get ctrl reg value
+ * @pchan:	dma channel handle
+ *
+ * Returns the dma channel's ctrl reg value
+ */
+dma_ctrl_u inline csp_dma_get_ctrl(dma_channel_t * pchan)
+{
+	u32 val = DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CTRL);
+	return *(dma_ctrl_u *)&val;
+}
+
+/**
+ * csp_dma_irq_enable - enable dma channel irq
+ * @pchan:	dma channel handle
+ * @irq_type:	irq type that will be enabled
+ */
+void inline csp_dma_irq_enable(dma_channel_t * pchan, u32 irq_type)
+{
+	u32 	uTemp = 0;
+
+	uTemp = DMA_READ_REG(DMA_IRQ_EN_REG);
+	uTemp &= (~(0x3 << (pchan->id << 1)));
+	uTemp |= (irq_type << (pchan->id << 1));
+	DMA_WRITE_REG(uTemp, DMA_IRQ_EN_REG);
+}
+
+/**
+ * csp_dma_get_status - get dma channel irq pending val
+ * @pchan:	dma channel handle
+ *
+ * Returns the irq pend value, eg: 0b11
+ */
+u32 inline csp_dma_get_irqpend(dma_channel_t * pchan)
+{
+	u32 	utemp = 0;
+	utemp = DMA_READ_REG(DMA_IRQ_PEND_REG);
+	return (utemp >> (pchan->id << 1)) & 0x3;
+}
+
+/**
+ * csp_dma_clear_irqpend - clear the dma channel irq pending
+ * @pchan:	dma channel handle
+ * @irq_type:	irq type that willbe cleared, eg: CHAN_IRQ_HD|CHAN_IRQ_FD
+ */
+void inline csp_dma_clear_irqpend(dma_channel_t * pchan, u32 irq_type)
+{
+	u32 	utemp = 0;
+	utemp = DMA_READ_REG(DMA_IRQ_PEND_REG);
+	utemp &= (irq_type << (pchan->id << 1));
+	DMA_WRITE_REG(utemp, DMA_IRQ_PEND_REG);
+}
+
diff --git a/arch/arm/mach-sun7i/dma/dma_csp.h b/arch/arm/mach-sun7i/dma/dma_csp.h
new file mode 100755
index 0000000..146ebaf
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_csp.h
@@ -0,0 +1,48 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma_csp.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma csp header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_CSP_H
+#define __DMA_CSP_H
+
+extern struct clk *g_dma_ahb_clk;
+extern struct clk *g_dma_mod_clk;
+
+u32 dma_clk_init(void);
+u32 dma_clk_deinit(void);
+
+void csp_dma_init(void);
+void csp_ndma_autoclk_enable(void);
+void csp_ndma_autoclk_disable(void);
+void csp_ndma_set_wait_state(dma_channel_t * pchan, u32 state);
+void csp_dma_set_saddr(dma_channel_t * pchan, u32 ustart_addr);
+void csp_dma_set_daddr(dma_channel_t * pchan, u32 ustart_addr);
+void csp_dma_set_bcnt(dma_channel_t * pchan, u32 byte_cnt);
+void csp_dma_set_para(dma_channel_t * pchan, dma_para_t para);
+void csp_dma_start(dma_channel_t * pchan);
+void csp_dma_stop(dma_channel_t * pchan);
+u32 csp_dma_get_status(dma_channel_t * pchan);
+u32 csp_dma_get_saddr(dma_channel_t * pchan);
+u32 csp_dma_get_daddr(dma_channel_t * pchan);
+u32 csp_dma_get_bcnt(dma_channel_t * pchan);
+dma_para_t csp_dma_get_para(dma_channel_t *pchan);
+void csp_dma_irq_enable(dma_channel_t * pchan, u32 irq_type);
+u32 csp_dma_get_irqpend(dma_channel_t * pchan);
+void csp_dma_clear_irqpend(dma_channel_t * pchan, u32 irq_type);
+void csp_dma_set_security(dma_channel_t * pchan, u32 para);
+void csp_dma_set_ctrl(dma_channel_t * pchan, u32 val);
+dma_ctrl_u csp_dma_get_ctrl(dma_channel_t * pchan);
+
+#endif  /* __DMA_CSP_H */
+
diff --git a/arch/arm/mach-sun7i/dma/dma_include.h b/arch/arm/mach-sun7i/dma/dma_include.h
new file mode 100755
index 0000000..b290e40
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_include.h
@@ -0,0 +1,48 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma_include.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_INCLUDE_H
+#define __DMA_INCLUDE_H
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/pm.h>
+
+#include <mach/dma.h>
+#include <mach/clock.h>
+#include <mach/platform.h>
+
+#include "dma_regs.h"
+#include "dma_common.h"
+#include "dma_csp.h"
+#include "dma_interface.h"
+#include "dma_core.h"
+
+#ifdef DBG_DMA
+#include <linux/delay.h>
+#endif /* DBG_DMA */
+
+#endif  /* __DMA_INCLUDE_H */
+
diff --git a/arch/arm/mach-sun7i/dma/dma_interface.c b/arch/arm/mach-sun7i/dma/dma_interface.c
new file mode 100755
index 0000000..7076115
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_interface.c
@@ -0,0 +1,247 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma_interface.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+
+/* dma manager */
+struct dma_mgr_t g_dma_mgr; /* compile warning if "g_dma_mgr = {0}" */
+
+/* dma channel request lock */
+static DEFINE_MUTEX(dma_mutex);
+
+/**
+ * dma_handle_is_valid - check if dma handle is valid
+ * @dma_hdl:	dma handle
+ *
+ * return true if vaild, false otherwise
+ */
+bool inline dma_handle_is_valid(dma_hdl_t dma_hdl)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+	return pchan && pchan->used && pchan->id < DMA_CHAN_TOTAL;
+}
+
+/**
+ * __chan_is_free - check if channel is free
+ * @pchan:	dma handle
+ *
+ * return true if channel is free, false if not
+ *
+ * NOTE: can only be called in sw_dma_request recently, becase
+ * should be locked
+ */
+static bool __chan_is_free(dma_channel_t *pchan)
+{
+	if(0 == pchan->used
+		&& 0 == pchan->owner[0]
+		//&& CHAN_IRQ_NO == pchan->irq_spt /* maybe not use dma irq? */
+		&& NULL == pchan->hd_cb.func
+		&& NULL == pchan->fd_cb.func
+		&& CHAN_STA_IDLE == pchan->state
+		)
+		return true;
+	else {
+		dma_dump_chain(pchan);
+		return false;
+	}
+}
+
+/**
+ * __dma_channel_already_exist - check if channel already requested by others
+ * @name:	channel name
+ *
+ * return true if channel already requested, false if not
+ */
+bool __dma_channel_already_exist(char *name)
+{
+	u32 i = 0;
+
+	if(NULL == name)
+		return false;
+	for(i = 0; i < DMA_CHAN_TOTAL; i++) {
+		if(1 == g_dma_mgr.chnl[i].used && !strcmp(g_dma_mgr.chnl[i].owner, name))
+			return true;
+	}
+	return false;
+}
+
+/**
+ * sw_dma_request - request a dma channel
+ * @name:	dma channel name
+ * @type:	channel type, normal or dedicate
+ *
+ * Returns handle to the channel if success, NULL if failed.
+ */
+dma_hdl_t sw_dma_request(char * name, dma_chan_type_e type)
+{
+	u32 i, num;
+	u32 usign = 0;
+	dma_channel_t *pchan = NULL;
+
+	DMA_DBG("%s: name %s, chan type %d\n", __func__, name, (u32)type);
+	if((name && strlen(name) >= MAX_NAME_LEN) || (type != CHAN_NORMAL && type != CHAN_DEDICATE)) {
+		DMA_ERR("%s: para err, name %s, type %d\n", __func__, name, (u32)type);
+		return NULL;
+	}
+
+	mutex_lock(&dma_mutex);
+	/* check if already exist */
+	if(NULL != name && __dma_channel_already_exist(name)) {
+		usign = __LINE__;
+		goto end;
+	}
+	/* get a free channel */
+	if(CHAN_NORMAL == type)
+		i = 0;
+	else
+		i = 8;
+	num = i + 8;
+	for(; i < num ; i++) {
+		if(0 == g_dma_mgr.chnl[i].used) {
+			WARN_ON(!__chan_is_free(&g_dma_mgr.chnl[i]));
+			break;
+		}
+	}
+	if(num == i) {
+		usign = __LINE__;
+		goto end;
+	}
+
+	/* init channel */
+	pchan = &g_dma_mgr.chnl[i];
+	pchan->used = 1;
+	dma_request_init(pchan);
+	if(NULL != name)
+		strcpy(pchan->owner, name);
+
+end:
+	mutex_unlock(&dma_mutex);
+	if(0 != usign)
+		DMA_ERR("%s err, line %d\n", __func__, usign);
+	else
+		DMA_DBG("%s: success, channel id %d\n", __func__, i);
+	return (dma_hdl_t)pchan;
+}
+EXPORT_SYMBOL(sw_dma_request);
+
+/**
+ * sw_dma_release - free a dma channel
+ * @dma_hdl:	dma handle
+ *
+ * Returns 0 if sucess, otherwise failed
+ */
+u32 sw_dma_release(dma_hdl_t dma_hdl)
+{
+	BUG_ON(unlikely(!dma_handle_is_valid(dma_hdl)));
+	dma_release(dma_hdl);
+	return 0;
+}
+EXPORT_SYMBOL(sw_dma_release);
+
+/**
+ * sw_dma_ctl - dma ctrl operation
+ * @dma_hdl:	dma handle
+ * @op:		dma operation type
+ * @parg:	arg for the op
+ *
+ * Returns 0 if sucess, otherwise failed
+ */
+u32 sw_dma_ctl(dma_hdl_t dma_hdl, dma_op_type_e op, void *parg)
+{
+	BUG_ON(unlikely(!dma_handle_is_valid(dma_hdl)));
+	return dma_ctrl(dma_hdl, op, parg);
+}
+EXPORT_SYMBOL(sw_dma_ctl);
+
+/**
+ * sw_dma_config - config dma hardware paras
+ * @dma_hdl:	dma handle
+ * @pcfg:	dma cofig para
+ *
+ * Returns 0 if sucess, otherwise failed
+ */
+u32 sw_dma_config(dma_hdl_t dma_hdl, dma_config_t *pcfg)
+{
+	BUG_ON(unlikely(!dma_handle_is_valid(dma_hdl)));
+	dma_config(dma_hdl, pcfg);
+	return 0;
+}
+EXPORT_SYMBOL(sw_dma_config);
+
+/**
+ * sw_dma_enqueue - add buf to list
+ * @dma_hdl:	dma handle
+ * @src_addr:	buffer src phys addr
+ * @dst_addr:	buffer dst phys addr
+ * @byte_cnt:	buffer byte cnt
+ *
+ * Returns 0 if sucess, otherwise failed
+ */
+u32 sw_dma_enqueue(dma_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt)
+{
+	BUG_ON(unlikely(!dma_handle_is_valid(dma_hdl)));
+	return dma_enqueue(dma_hdl, src_addr, dst_addr, byte_cnt);
+}
+EXPORT_SYMBOL(sw_dma_enqueue);
+
+/**
+ * sw_dma_getposition - get src and dst position
+ * @dma_hdl:	dma handle
+ * @psrc:	stored the src addr got
+ * @pdst:	stored the dst addr got
+ *
+ * Returns 0 if sucess, otherwise failed
+ */
+int sw_dma_getposition(dma_hdl_t dma_hdl, u32 *psrc, u32 *pdst)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+	unsigned long flags;
+	u32 saddr, daddr, reamin;
+
+	BUG_ON(unlikely(!dma_handle_is_valid(dma_hdl)));
+	BUG_ON(unlikely(NULL == psrc || NULL == pdst));
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+	/* get src/dst start addr */
+	saddr = csp_dma_get_saddr(pchan);
+	daddr = csp_dma_get_daddr(pchan);
+	/* get remain bytes */
+	reamin = csp_dma_get_bcnt(pchan);
+	/* note: tha caller use "period - reamin" to get transferred bytes */
+	*psrc = saddr - reamin;
+	*pdst = daddr - reamin;
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	DMA_DBG("%s: get *psrc 0x%08x, *pdst 0x%08x\n", __func__, *psrc, *pdst);
+	return 0;
+}
+EXPORT_SYMBOL(sw_dma_getposition);
+
+/**
+ * sw_dma_dump_chan - dump dma chain
+ * @dma_hdl:	dma handle
+ */
+void sw_dma_dump_chan(dma_hdl_t dma_hdl)
+{
+	dma_channel_t *pchan = (dma_channel_t *)dma_hdl;
+	unsigned long	flags = 0;
+
+	BUG_ON(unlikely(!dma_handle_is_valid(dma_hdl)));
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+	dma_dump_chain(pchan);
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+}
+EXPORT_SYMBOL(sw_dma_dump_chan);
+
diff --git a/arch/arm/mach-sun7i/dma/dma_interface.h b/arch/arm/mach-sun7i/dma/dma_interface.h
new file mode 100755
index 0000000..a1cf7ca
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_interface.h
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma_interface.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_INTERFACE_H
+#define __DMA_INTERFACE_H
+
+bool dma_handle_is_valid(dma_hdl_t dma_hdl);
+
+#endif  /* __DMA_INTERFACE_H */
+
diff --git a/arch/arm/mach-sun7i/dma/dma_regs.h b/arch/arm/mach-sun7i/dma/dma_regs.h
new file mode 100755
index 0000000..a0ee480
--- /dev/null
+++ b/arch/arm/mach-sun7i/dma/dma_regs.h
@@ -0,0 +1,57 @@
+/*
+ * arch/arm/mach-sun7i/dma/dma_regs.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma regs defination
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_REGS_H
+#define __DMA_REGS_H
+
+/* dma reg offset */
+#define DMA_IRQ_EN_REG_OFF            		( 0x0000                        )
+#define DMA_IRQ_PEND_REG_OFF            	( 0x0004                        )
+#define NDMA_AUTO_GAT_REG_OFF            	( 0x0008                        )
+#define N_DMA_CTRL_OFF(chan)            	( 0x100 + ((chan) << 5) + 0x0  )
+#define N_DMA_SADR_OFF(chan)            	( 0x100 + ((chan) << 5) + 0x4  )
+#define N_DMA_DADR_OFF(chan)            	( 0x100 + ((chan) << 5) + 0x8  )
+#define N_DMA_BC_OFF(chan)                      ( 0x100 + ((chan) << 5) + 0xc  )
+#define D_DMA_CFG_OFF(chan)            		( 0x300 + (((chan)-8) << 5) + 0x0 )
+#define D_DMA_SRC_STADDR_OFF(chan)            	( 0x300 + (((chan)-8) << 5) + 0x4 )
+#define D_DMA_DST_STADDR_OFF(chan)            	( 0x300 + (((chan)-8) << 5) + 0x8 )
+#define D_DMA_BC_OFF(chan)            		( 0x300 + (((chan)-8) << 5) + 0xc )
+#define D_DMA_PARA_OFF(chan)            	( 0x300 + (((chan)-8) << 5) + 0x18)
+
+/* reg offset from channel base */
+#define DMA_OFF_REG_CTRL           		( 0x0000                       )
+#define DMA_OFF_REG_SADR            		( 0x0004                       )
+#define DMA_OFF_REG_DADR            		( 0x0008                       )
+#define DMA_OFF_REG_BC            		( 0x000C                       )
+#define DMA_OFF_REG_PARA            		( 0x0018                       )
+
+#define IS_DEDICATE(chan)			((chan) >= 8)
+
+/* dma reg addr */
+#define DMA_IRQ_EN_REG            		( SW_VA_DMAC_IO_BASE + DMA_IRQ_EN_REG_OFF  	)
+#define DMA_IRQ_PEND_REG            		( SW_VA_DMAC_IO_BASE + DMA_IRQ_PEND_REG_OFF  	)
+#define NDMA_AUTO_GAT_REG            		( SW_VA_DMAC_IO_BASE + NDMA_AUTO_GAT_REG_OFF  	)
+#define DMA_CTRL_REG(chan)            		( SW_VA_DMAC_IO_BASE + (IS_DEDICATE(chan) ? D_DMA_CFG_OFF(chan) : N_DMA_CTRL_OFF(chan)))
+#define DMA_SADR_REG(chan)            		( SW_VA_DMAC_IO_BASE + (IS_DEDICATE(chan) ? D_DMA_SRC_STADDR_OFF(chan) : N_DMA_SADR_OFF(chan)))
+#define DMA_DADR_REG(chan)            		( SW_VA_DMAC_IO_BASE + (IS_DEDICATE(chan) ? D_DMA_DST_STADDR_OFF(chan) : N_DMA_DADR_OFF(chan)))
+#define DMA_BC_REG(chan)                      	( SW_VA_DMAC_IO_BASE + (IS_DEDICATE(chan) ? D_DMA_BC_OFF(chan) : N_DMA_BC_OFF(chan)))
+#define DMA_PARA_REG(chan)            		( SW_VA_DMAC_IO_BASE + (IS_DEDICATE(chan) ? D_DMA_PARA_OFF(chan) : ))
+
+/* dma reg rw */
+#define DMA_READ_REG(reg)			readl(reg)
+#define DMA_WRITE_REG(val, reg)			writel(val, reg)
+
+#endif  /* __DMA_REGS_H */
+
diff --git a/arch/arm/mach-sun7i/headsmp.S b/arch/arm/mach-sun7i/headsmp.S
new file mode 100644
index 0000000..72fb3cd
--- /dev/null
+++ b/arch/arm/mach-sun7i/headsmp.S
@@ -0,0 +1,12 @@
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+        .section ".text.head", "ax"
+	__CPUINIT
+
+ENTRY(sun7i_secondary_startup)
+	msr	cpsr_fsxc, #0xd3
+	mov r0, #0
+	ldr r1, =0xf35
+        b       secondary_startup
+ENDPROC(sun7i_secondary_startup)
diff --git a/arch/arm/mach-sun7i/hotplug.c b/arch/arm/mach-sun7i/hotplug.c
new file mode 100755
index 0000000..df42283
--- /dev/null
+++ b/arch/arm/mach-sun7i/hotplug.c
@@ -0,0 +1,124 @@
+/*
+ *  linux/arch/arm/mach-sun7i/hotplug.c
+ *
+ *  Copyright (C) 2012-2016 Allwinner Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+#include <mach/platform.h>
+#include <mach/hardware.h>
+
+
+
+static cpumask_t dead_cpus;
+
+#define IS_WFI_MODE(cpu)    (readl(IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + CPUX_STATUS(cpu)) & (1<<2))
+
+int platform_cpu_kill(unsigned int cpu)
+{
+    int k;
+    u32 pwr_reg;
+    int tmp_cpu;
+
+    if (cpu == 0)
+    {
+        pr_err("[hotplug]: try to kill cpu:%d failed!\n", cpu);
+        return 0;
+    }
+    tmp_cpu = get_cpu();
+    put_cpu();
+    pr_info("[hotplug]: cpu(%d) try to kill cpu(%d)\n", tmp_cpu, cpu);
+
+    for (k = 0; k < 1000; k++) {
+        if (cpumask_test_cpu(cpu, &dead_cpus) && IS_WFI_MODE(cpu)) {
+
+            /* step8: deassert cpu core reset */
+            writel(0, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + CPUX_RESET_CTL(cpu));
+
+            /* step8: deassert DBGPWRDUP signal */
+            pwr_reg = readl(IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_DBGCTL1);
+            pwr_reg &= ~(1<<cpu);
+            writel(pwr_reg, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_DBGCTL1);
+
+            /* step9: set up power-off signal */
+            pwr_reg = readl(IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWROFF_REG);
+            pwr_reg |= 1;
+            writel(pwr_reg, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWROFF_REG);
+            mdelay(1);
+
+            /* step10: active the power output clamp */
+            writel(0x01, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+            writel(0x03, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+            writel(0x07, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+            writel(0x0f, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+            writel(0x1f, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+            writel(0x3f, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+            writel(0x7f, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+            writel(0xff, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+            pr_info("[hotplug]: cpu%d is killed!\n", cpu);
+
+            return 1;
+        }
+
+        mdelay(1);
+    }
+
+    pr_err("[hotplug]: try to kill cpu:%d failed!\n", cpu);
+
+    return 0;
+}
+
+void platform_cpu_die(unsigned int cpu)
+{
+    unsigned long actlr;
+
+    /* notify platform_cpu_kill() that hardware shutdown is finished */
+    cpumask_set_cpu(cpu, &dead_cpus);
+
+    /* step1: disable cache */
+    asm("mrc    p15, 0, %0, c1, c0, 0" : "=r" (actlr) );
+    actlr &= ~(1<<2);
+    asm("mcr    p15, 0, %0, c1, c0, 0\n" : : "r" (actlr));
+
+    /* step2: clean and ivalidate L1 cache */
+    flush_cache_all();
+
+    /* step3: execute a CLREX instruction */
+    asm("clrex" : : : "memory", "cc");
+
+    /* step4: switch cpu from SMP mode to AMP mode, aim is to disable cache coherency */
+    asm("mrc    p15, 0, %0, c1, c0, 1" : "=r" (actlr) );
+    actlr &= ~(1<<6);
+    asm("mcr    p15, 0, %0, c1, c0, 1\n" : : "r" (actlr));
+
+    /* step5: execute an ISB instruction */
+    isb();
+    /* step6: execute a DSB instruction  */
+    dsb();
+
+    /* step7: execute a WFI instruction */
+    while(1) {
+        asm("wfi" : : : "memory", "cc");
+    }
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+    cpumask_clear_cpu(cpu, &dead_cpus);
+    /*
+     * we don't allow CPU 0 to be shutdown (it is still too special
+     * e.g. clock tick interrupts)
+     */
+    return cpu == 0 ? -EPERM : 0;
+}
+
diff --git a/arch/arm/mach-sun7i/include/mach/ar100_cp.h b/arch/arm/mach-sun7i/include/mach/ar100_cp.h
new file mode 100755
index 0000000..7535315
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/ar100_cp.h
@@ -0,0 +1,101 @@
+/*
+ *  arch/arm/mach-xxx/include/ar100_cp.h
+ *
+ * Copyright 2012 (c) Allwinner
+ * kevin (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+typedef int (*ar100_cb_t)(void *arg);
+
+
+
+/*
+ * get value from axp register.
+ * addr:  register address;
+ * value: value get from axp;
+ * return: result, 0 - get register successed, !0 - get register failed;
+ */
+int ar100_axp_readreg(unsigned long addr, unsigned long *value);
+
+
+/*
+ *set value for axp register.
+ *addr:  register address;
+ *value: value to be set;
+ *return: result, 0 - set register successed, !0 - set register failed;
+ */
+int ar100_axp_writereg(unsigned long addr, unsigned long *value);
+
+
+/*
+ * axp get battery paramter.
+ * para:  battery parameter;
+ * return: result, 0 - get battery successed, !0 - get battery failed;
+ */
+int ar100_axp_getbat(void *para);
+
+
+/*
+ * axp set battery paramter.
+ * para:  battery parameter;
+ * return: result, 0 - set battery successed, !0 - set battery failed;
+ */
+int ar100_axp_setbat(void *para);
+
+
+/*
+ * set target frequency.
+ * freq:  target frequency to be set, based on KHZ.
+ * return: result, 0 - set frequency successed, !0 - set frequency failed;
+ */
+int ar100_dvfs_setcpufreq(unsigned long freq);
+
+
+/*
+ * enter normal standby.
+ * para:  parameter for enter normal standby.
+ * return: result, 0 - normal standby successed, !0 - normal standby failed;
+ */
+int ar100_standby_normal(void *para);
+
+
+/*
+ * enter super standby.
+ * para:  parameter for enter normal standby.
+ * return: result, 0 - super standby successed, !0 - super standby failed;
+ */
+int ar100_standby_super(void *para);
+
+
+/*
+ * register call-back function, call-back function is for ar100 notify some event to ac327,
+ * axp interrupt for ex.
+ * func:  call-back function;
+ * para:  parameter for call-back function;
+ * return: result, 0 - register call-back function successed;
+ *                !0 - register call-back function failed;
+ * NOTE: the function is like "int callback(void *para)";
+ */
+int ar100_cb_register(ar100_cb_t *func, void *para);
+
+
+/*
+ * unregister call-back function.
+ * func:  call-back function which need be unregister;
+ */
+void ar100_cb_unregister(ar100_cb_t *func);
+
diff --git a/arch/arm/mach-sun7i/include/mach/barriers.h b/arch/arm/mach-sun7i/include/mach/barriers.h
new file mode 100644
index 0000000..fc4374c
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/barriers.h
@@ -0,0 +1,4 @@
+#define mb()		dsb()
+#define rmb()		dsb()
+#define wmb()		mb()
+
diff --git a/arch/arm/mach-sun7i/include/mach/ccmu.h b/arch/arm/mach-sun7i/include/mach/ccmu.h
new file mode 100644
index 0000000..f141ac7
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/ccmu.h
@@ -0,0 +1,620 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/ccmu.h
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __CCMU_REGS_H__
+#define __CCMU_REGS_H__
+
+/*
+ * TODO:
+ *
+ * 1. Update Description of clock register bit.
+ *
+ */
+
+typedef struct ___CCMU_PLL1_CORE_REG0000 {
+    __u32   FactorM: 2;         //bit0,  PLL1 Factor M
+    __u32   SigmaEn: 1;         //bit2,  Sigma-delta pattern enable
+    __u32   SigmaIn: 1;         //bit3,  Sigma-delta pattern input
+    __u32   FactorK: 2;         //bit4,  PLL1 factor K
+    __u32   reserved0: 2;       //bit6,  reserved
+    __u32   FactorN: 5;         //bit8,  PLL1 Factor N
+    __u32   LockTime: 3;        //bit13, PLL1 lock timer control
+    __u32   PLLDivP: 2;         //bit16, PLL1 output external divider P
+    __u32   reserved1: 2;       //bit18, reserved
+    __u32   PLLBias: 5;         //bit20, PLL1 bias current control
+    __u32   ExchangeEn: 1;      //bit25, PLL1 exchange with PLL4 Enable
+    __u32   VCOBias: 4;         //bit26, PLL1 VCO bias control
+    __u32   VCORstIn: 1;        //bit30, VCO reset in
+    __u32   PLLEn: 1;           //bit31, 0-disable, 1-enable, (24Mhz*N*K)/(M*P)
+} __ccmu_pll1_core_reg0000_t;
+
+typedef struct __CCMU_PLL2_AUDIO_REG0008 {
+    __u32   PrevDiv: 5;         //bit0,  PLL2 prev division
+    __u32   reserved0: 3;       //bit5,  reserved
+    __u32   FactorN: 7;         //bit8,  PLL2 factor N
+    __u32   reserved1: 1;       //bit15, reserved
+    __u32   PLLBias: 5;         //bit16, PLL2 bias current
+    __u32   VcoBias: 5;         //bit21, PLL2 VCO bias current
+    __u32   PostDiv: 4;         //bit26, PLL2 post division
+    __u32   reserved2: 1;       //bit30, reserved
+    __u32   PLLEn: 1;           //bit31, PLL2 enable
+} __ccmu_pll2_audio_reg0008_t;
+
+typedef struct __CCMU_PLL3_VIDEO_REG0010 {
+    __u32   FactorM: 7;         //bit0,  PLL3 FactorM, 9<= M <=127
+    __u32   reserved0: 1;       //bit7,  reserved
+    __u32   PLLBias: 5;         //bit8,  PLL3 bias control
+    __u32   reserved1: 1;       //bit13, reserved
+    __u32   FracSet: 1;         //bit14, PLL3 fractional setting, 0-270Mhz, 1-297Mhz
+    __u32   ModeSel: 1;         //bit15, PLL3 mode select
+    __u32   VCOBias: 5;         //bit16, PLL3 VCO Bias control
+    __u32   reserved2: 3;       //bit21, reserved
+    __u32   DampFactor: 3;      //bit24, PLL3 damping factor controlf
+    __u32   reserved3: 4;       //bit27, reserved
+    __u32   PLLEn: 1;           //bit31, PLL3 enable
+} __ccmu_pll3_video_reg0010_t;
+
+typedef struct __CCMU_PLL4_VE_REG0018 {
+    __u32   FactorM: 2;         //bit0,  PLL4 factor M
+    __u32   reserved0: 2;       //bit2,  reserved
+    __u32   FactorK: 2;         //bit4,  PLL4 factor K
+    __u32   DampFactor: 2;      //bit6,  PLL4 damping factor control
+    __u32   FactorN: 5;         //bit8,  PLL4 factor N
+    __u32   reserved1: 2;       //bit13, reserved
+    __u32   BandWidth: 1;       //bit15, PLL4 band width control
+    __u32   reserved2: 4;       //bit16, reserved
+    __u32   PLLBias: 5;         //bit20, PLL4 Bias control
+    __u32   VCOBias: 5;         //bit25, PLL4 VCO bias control
+    __u32   PLLBypass: 1;       //bit30, PLL4 output bypass enable
+    __u32   PLLEn: 1;           //bit31, PLL4 Enable, 24MHz*N*K
+} __ccmu_pll4_ve_reg0018_t;
+
+typedef struct __CCMU_PLL5_DDR_REG0020 {
+    __u32   FactorM: 2;         //bit0,  PLL5 factor M
+    __u32   FactorM1: 2;        //bit3,  PLL5 factor M1
+    __u32   FactorK: 2;         //bit4,  PLL5 factor K
+    __u32   reserved0: 1;       //bit6,  reserved
+    __u32   LDO2En: 1;          //bit7,  LDO2 enable
+    __u32   FactorN: 5;         //bit8,  PLL5 factor N
+    __u32   VCOGain: 3;         //bit13, PLL5 VCO gain control
+    __u32   FactorP: 2;         //bit16, PLL5 output external divider P
+    __u32   BandWidth: 1;       //bit18, PLL5 band width control, 0-narrow, 1-wide
+    __u32   VCOGainEn: 1;       //bit19, PLL5 VCO gain control enable
+    __u32   PLLBias: 5;         //bit20, PLL5 bias current control
+    __u32   VCOBias: 4;         //bit25, PLL5 VCO bias
+    __u32   OutputEn: 1;        //bit29, DDR clock output enable
+    __u32   PLLBypass: 1;       //bit30, PLL5 output bypass enable
+    __u32   PLLEn: 1;           //bit31, PLL5 Enable
+} __ccmu_pll5_ddr_reg0020_t;
+
+typedef struct __CCMU_PLL6_SATA_REG0028 {
+    __u32   FactorM: 2;         //bit0,  PLL6 factor M
+    __u32   reserved0: 2;       //bit2,  reserved
+    __u32   FactorK: 2;         //bit4,  PLL6 factor K
+    __u32   DampFactor: 2;      //bit6,  PLL6 damping factor control
+    __u32   FactorN: 5;         //bit8,  PLL6 factor N
+    __u32   reserved1: 1;       //bit13, reserved
+    __u32   OutputEn: 1;        //bit14, sata clock output enable
+    __u32   BandWidth: 1;       //bit15, PLL6 band width control
+    __u32   reserved2: 4;       //bit16, reserved
+    __u32   PLLBias: 5;         //bit20, PLL6 bias current control
+    __u32   VCOBias: 5;         //bit25, PLL6 VCO bias
+    __u32   PLLBypass: 1;       //bit30, PLL6 output bypass enable
+    __u32   PLLEn: 1;           //bit31, PLL6 enable
+} __ccmu_pll6_sata_reg0028_t;
+
+typedef struct __CCMU_PLL7_VIDEO1_REG0030 {
+    __u32   FactorM: 7;         //bit0,  PLL7 factor M
+    __u32   reserved0: 1;       //bit7,  reserved
+    __u32   PLLBias: 5;         //bit8,  PLL7 bias control
+    __u32   reserved1: 1;       //bit13, reserved
+    __u32   FracSet: 1;         //bit14, PLL7 fractional setting, 0-270Mhz, 1-297Mhz
+    __u32   ModeSel: 1;         //bit15, PLL7 mode select, 0-integer, 1-fractional
+    __u32   VCOBias: 5;         //bit16, PLL7 bias control
+    __u32   reserved2: 3;       //bit21, reserved
+    __u32   DampFactor: 3;      //bit24, PLL7 damping factor control
+    __u32   reserved3: 4;       //bit27, reserved
+    __u32   PLLEn: 1;           //bit31, PLL7 enable
+} __ccmu_pll7_video1_reg0030_t;
+
+typedef struct __CCMU_PLL8_GPU_REG0040 {
+    __u32   FactorM: 2;         //bit0,  PLL8 factor M
+    __u32   reserved0: 2;       //bit2,  reserved
+    __u32   FactorK: 2;         //bit4,  PLL8 factor K
+    __u32   DampFactor: 2;      //bit6,  PLL8 damping factor control
+    __u32   FactorN: 5;         //bit8,  PLL8 factor N
+    __u32   reserved1: 2;       //bit13, reserved
+    __u32   BandWidth: 1;       //bit15, PLL8 band width control
+    __u32   reserved2: 4;       //bit16, reserved
+    __u32   PLLBias: 5;         //bit20, PLL8 bias current control
+    __u32   VCOBias: 5;         //bit25, PLL8 VCO bias
+    __u32   PLLBypass: 1;       //bit30, PLL8 output bypass enable
+    __u32   PLLEn: 1;           //bit31, PLL8 enable
+} __ccmu_pll8_gpu_reg0040_t;
+
+/*
+ * TODO - Check again.
+ */
+typedef struct __CCMU_OSC24M_REG0050 {
+    __u32   OSC24MEn: 1;        //bit0,  OSC24M enable
+    __u32   OSC24MGsm: 1;       //bit1,  OSC24M GSM
+    __u32   reserved0: 13;      //bit2,  reserved
+    __u32   PLLBiasEn: 1;       //bit15, PLL bias enable
+    __u32   LDOEn: 1;           //bit16, LDO enable
+    __u32   PLLInPower: 1;      //bit17, PLL intput power select, 0-2.5v, 1-3.3v
+    __u32   LDOOutput: 3;       //bit18, LDO output control, 100-1.25v for ex.
+    __u32   reserved1: 3;       //bit21, reserved
+    __u32   KeyField: 8;        //bit24, key field for LDO enable, 0xa7, bit24~bit31 is valid
+} __ccmu_osc24m_reg0050_t;
+
+typedef struct __CCMU_SYSCLK_RATIO_REG0054 {
+    __u32   AXIClkDiv: 2;       //bit0,  AXI clock divide ratio, 00-1, 01-2, 10-3, 11-4
+    __u32   reserved0: 2;       //bit2,  reserved
+    __u32   AHBClkDiv: 2;       //bit4,  AHB clock divide ration, 00-1, 01-2, 10-4, 11-8
+    __u32   AHBClkSrc: 2;       //bit6,  AHB clock source select
+    __u32   APB0ClkDiv: 2;      //bit8,  APB0 clock divide ratio, APB0 clock source is AHB, 00-2, 01-2, 10-4, 11-8
+    __u32   reserved1: 1;       //bit10, reserved
+    __u32   AtbApbClkDiv: 2;    //bit11, ATB/APB clock div, 00-1, 01-2, 1x-4
+    __u32   reserved2: 3;       //bit13, reserved
+    __u32   AC327ClkSrc: 2;     //bit16, CPU1/2 clock source select, 00-internal LOSC, 01-HOSC, 10-PLL1, 11-200MHz
+    __u32   reserved3: 13;      //bit18, reserved
+    __u32   DVFSStart: 1;       //bit31, DVFS start
+} __ccmu_sysclkl_ratio_reg0054_t;
+
+typedef struct __CCMU_APB1CLK_RATIO_REG0058 {
+    __u32   ClkDiv: 5;          //bit0,  clock divide ratio, diveded by (m+1), 1~32 ex.
+    __u32   reserved0: 11;      //bit5,  reserved
+    __u32   PreDiv: 2;          //bit16, clock pre-divide ratio, pre-devided by 2^, 1/2/4/8 ex.
+    __u32   reserved1: 6;       //bit18, reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-HOSC, 01-PLL6, 10-LOSC, 11-reserved
+    __u32   reserved2: 6;       //bit26, reserved
+} __ccmu_apb1clk_ratio_reg0058_t;
+
+typedef struct __CCMU_AHBCLK_GATE0_REG0060 {
+    __u32   Usb0Gate: 1;        //bit0,  gating AHB clock for USB0, 0-mask, 1-pass
+    __u32   Ehci0Gate: 1;       //bit1,  gating AHB clock for EHCI0, 0-mask, 1-pass
+    __u32   Ohci0Gate: 1;       //bit2,  gating AHB clock for OHCI0, 0-mask, 1-pass
+    __u32   Ehci1Gate: 1;       //bit3,  gating AHB clock for EHCI1, 0-mask, 1-pass
+    __u32   Ohci1Gate: 1;       //bit4,  gating AHB clock for OHCI1, 0-mask, 1-pass
+    __u32   SsGate: 1;          //bit5,  gating AHB clock for SS, 0-mask, 1-pass
+    __u32   DmaGate: 1;         //bit6,  gating AHB clock for DMA, 0-mask, 1-pass
+    __u32   BistGate: 1;        //bit7,  gating AHB clock for BIST, 0-mask, 1-pass
+    __u32   Sdmmc0Gate: 1;      //bit8,  gating AHB clock for SD/MMC0, 0-mask, 1-pass
+    __u32   Sdmmc1Gate: 1;      //bit9,  gating AHB clock for SD/MMC1, 0-mask, 1-pass
+    __u32   Sdmmc2Gate: 1;      //bit10, gating AHB clock for SD/MMC2, 0-mask, 1-pass
+    __u32   Sdmmc3Gate: 1;      //bit11, gating AHB clock for SD/MMC3, 0-mask, 1-pass
+    __u32   MsGate: 1;          //bit12, gating AHB clock for MS, 0-mask, 1-pass
+    __u32   NandGate: 1;        //bit13, gating AHB clock for NAND, 0-mask, 1-pass
+    __u32   SdramGate: 1;       //bit14, gating AHB clock for SDRAM, 0-mask, 1-pass
+    __u32   reserved0: 1;       //bit15, reserved
+    __u32   AceGate: 1;         //bit16, gating AHB clock for ACE, 0-mask, 1-pass
+    __u32   EmacGate: 1;        //bit17, gating AHB clock for EMAC, 0-mask, 1-pass
+    __u32   TsGate: 1;          //bit18, gating AHB clock for TS, 0-mask, 1-pass
+    __u32   reserved1: 1;       //bit19, reserved
+    __u32   Spi0Gate: 1;        //bit20, gating AHB clock for SPI0, 0-mask, 1-pass
+    __u32   Spi1Gate: 1;        //bit21, gating AHB clock for SPI1, 0-mask, 1-pass
+    __u32   Spi2Gate: 1;        //bit22, gating AHB clock for SPI2, 0-mask, 1-pass
+    __u32   Spi3Gate: 1;        //bit23, gating AHB clock for SPI3, 0-mask, 1-pass
+    __u32   reserved2: 1;       //bit24, reserved
+    __u32   SataGate: 1;        //bit25, gating AHB clock for SATA, 0-mask, 1-pass
+    __u32   reserved3: 2;       //bit26, reserved
+    __u32   StmrGate: 1;        //bit28, gating AHB clock for Sync timer
+    __u32   reserved4: 3;       //bit29, reserved
+} __ccmu_ahbclk_gate0_reg0060_t;
+
+typedef struct __CCMU_AHBCLK_GATE1_REG0064 {
+    __u32   VeGate: 1;          //bit0,  gating AHB clock for VE, 0-mask, 1-pass
+    __u32   TvdGate: 1;         //bit1,  gating AHB clock for TVD, 0-mask, 1-pass
+    __u32   Tve0Gate: 1;        //bit2,  gating AHB clock for TVE0, 0-mask, 1-pass
+    __u32   Tve1Gate: 1;        //bit3,  gating AHB clock for TVE1, 0-mask, 1-pass
+    __u32   Lcd0Gate: 1;        //bit4,  gating AHB clock for LCD0, 0-mask, 1-pass
+    __u32   Lcd1Gate: 1;        //bit5,  gating AHB clock for LCD1, 0-mask, 1-pass
+    __u32   reserved0: 2;       //bit6,  reserved
+    __u32   Csi0Gate: 1;        //bit8,  gating AHB clock for CSI0, 0-mask, 1-pass
+    __u32   Csi1Gate: 1;        //bit9,  gating AHB clock for CSI1, 0-mask, 1-pass
+    __u32   Hdmi1Gate: 1;       //bit10, gating AHB clock for HDMI1
+    __u32   HdmiDGate: 1;       //bit11, gating AHB clock for HDMI, 0-mask, 1-pass
+    __u32   DeBe0Gate: 1;       //bit12, gating AHB clock for DE-BE0, 0-mask, 1-pass
+    __u32   DeBe1Gate: 1;       //bit13, gating AHB clock for DE-BE1, 0-mask, 1-pass
+    __u32   DeFe0Gate: 1;       //bit14, gating AHB clock for DE-FE0, 0-mask, 1-pass
+    __u32   DeFe1Gate: 1;       //bit15, gating AHB clock for DE-FE1, 0-mask, 1-pass
+    __u32   reserved1: 1;       //bit16, reserved
+    __u32   GmacGate: 1;        //bit17, gating AHB clock for GMAC, 0-mask, 1:pass
+    __u32   MpGate: 1;          //bit18, gating AHB clock for MP, 0-mask, 1-pass
+    __u32   reserved2: 1;       //bit19, reserved
+    __u32   Gpu3DGate: 1;       //bit20, gating AHB clock for GPU-3D, 0-mask, 1-pass
+    __u32   reserved3: 11;      //bit21, reserved
+} __ccmu_ahbclk_gate1_reg0064_t;
+
+typedef struct __CCMU_APB0CLK_GATE_REG0068 {
+    __u32   AddaGate: 1;        //bit0,  gating APB clock for audio codec, 0-mask, 1-pass
+    __u32   SpdifGate: 1;       //bit1,  gating APB clock for SPDIF, 0-mask, 1-pass
+    __u32   Ac97Gate: 1;        //bit2,  gating APB clock for AC97, 0-mask, 1-pass
+    __u32   Iis0Gate: 1;        //bit3,  gating APB clock for IIS0, 0-mask, 1-pass
+    __u32   Iis1Gate: 1;        //bit4,  gating APB clock for IIS1, 0-mask, 1-pass
+    __u32   PioGate: 1;         //bit5,  gating APB clock for PIO, 0-mask, 1-pass
+    __u32   Ir0Gate: 1;         //bit6,  gating APB clock for IR0, 0-mask, 1-pass
+    __u32   Ir1Gate: 1;         //bit7,  gating APB clock for IR1, 0-mask, 1-pass
+    __u32   Iis2Gate: 1;        //bit8,  gating APB clock for IIS2, 0-mask, 1-pass
+    __u32   reserved0: 1;       //bit9,  reserved
+    __u32   KeypadGate: 1;      //bit10, gating APB clock for keypad, 0-mask, 1-pass
+    __u32   reserved1: 21;      //bit11, reserved
+} __ccmu_apb0clk_gate_reg0068_t;
+
+typedef struct __CCMU_APB1CLK_GATE_REG006C {
+    __u32   Twi0Gate: 1;        //bit0,  gating APB clock for TWI0, 0-mask, 1-pass
+    __u32   Twi1Gate: 1;        //bit1,  gating APB clock for TWI1, 0-mask, 1-pass
+    __u32   Twi2Gate: 1;        //bit2,  gating APB clock for TWI2, 0-mask, 1-pass
+    __u32   Twi3Gate: 1;        //bit3,  gating APB clock for TWI3, 0-mask, 1-pass
+    __u32   CanGate: 1;         //bit4,  gating APB clock for CAN, 0-mask, 1-pass
+    __u32   ScrGate: 1;         //bit5,  gating APB clock for SCR, 0-mask, 1-pass
+    __u32   Ps20Gate: 1;        //bit6,  gating APB clock for PS2-0, 0-mask, 1-pass
+    __u32   Ps21Gate: 1;        //bit7,  gating APB clock for PS2-1, 0-mask, 1-pass
+    __u32   reserved0: 7;       //bit8,  reserved
+    __u32   Twi4Gate: 1;        //bit15, gating AHB clock for TWI4, 0-mask, 1-pass
+    __u32   Uart0Gate: 1;       //bit16, gating APB clock for UART0, 0-mask, 1-pass
+    __u32   Uart1Gate: 1;       //bit17, gating APB clock for UART1, 0-mask, 1-pass
+    __u32   Uart2Gate: 1;       //bit18, gating APB clock for UART2, 0-mask, 1-pass
+    __u32   Uart3Gate: 1;       //bit19, gating APB clock for UART3, 0-mask, 1-pass
+    __u32   Uart4Gate: 1;       //bit20, gating APB clock for UART4, 0-mask, 1-pass
+    __u32   Uart5Gate: 1;       //bit21, gating APB clock for UART5, 0-mask, 1-pass
+    __u32   Uart6Gate: 1;       //bit22, gating APB clock for UART6, 0-mask, 1-pass
+    __u32   Uart7Gate: 1;       //bit23, gating APB clock for UART7, 0-mask, 1-pass
+    __u32   reserved1: 8;       //bit24, reserved
+} __ccmu_apb1clk_gate_reg006c_t;
+
+/* module clock type 0, used for NAND, MS, SDMMC0/1/2/3, TS, SS, SPI0/1/2/3, PATA, IR0/1, */
+/* register address is 0x0080~0x00B4, 0x00D4 */
+typedef struct __CCMU_MODULE0_CLK {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 4;       //bit4,  reserved
+    __u32   OutClkPhase: 3;     //bit8,  Just for SDMMC0/1/2/3, Output Clock Phase Control
+    __u32   reserved1: 5;       //bit11, reserved
+    __u32   ClkPreDiv: 2;       //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex.
+    __u32   reserved2: 2;       //bit18, reserved
+    __u32   SampleClkPhase: 3;  //bit20, Just for SDMMC0/1/2/3, Sample Clock Phase Control.
+    __u32   reserved3: 1;       //bit23, reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-HOSC, 01-PLL6, 10-PLL5, 11-reserved(LOSC,just for IR0/1)
+    __u32   reserved4: 5;       //bit26, reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_module0_clk_t;
+
+/* module clock type 1, used for IIS, AC97, SPDIF*/
+/* register address is 0x00B8~0x00C0 */
+typedef struct __CCMU_MODULE1_CLK {
+    __u32   reserved0: 16;      //bit0,  reserved
+    __u32   ClkDiv: 2;          //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex. source is 8xPLL2
+    __u32   reserved1: 13;      //bit18, reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_module1_clk_t;
+
+typedef struct __CCMU_KEYPAD_CLK_REG00C4 {
+    __u32   ClkDiv: 5;          //bit0,  clock divide ratio
+    __u32   reserved0: 11;      //bit5,  reserved
+    __u32   ClkPreDiv: 2;       //bit16, clock pre-divide ratio, pre-divided by 2^n, 1/2/4/8 ex.
+    __u32   reserved1: 6;       //bit18, reserved
+    __u32   ClkSrc: 2;          //bit24, clock select, 00-HOSC, 01-reserved, 10-LOSC, 11-reserved
+    __u32   reserved2: 5;       //bit26, reserved
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_keypad_clk_reg00c4_t;
+
+typedef struct __CCMU_SATA_CLK_REG00C8 {
+    __u32   reserved0: 24;      //bit0,  reserved
+    __u32   ClkSrc: 1;          //bit24, Clock source select, 0-PLL6, 1-External clock
+    __u32   reserved1: 6;       //bit25, reserved
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_sata_clk_reg00c8_t;
+
+typedef struct __CCMU_USB_CLK_REG00CC {
+    __u32   UsbPhy0Rst: 1;      //bit0,  USB PHY0 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy1Rst: 1;      //bit1,  USB PHY1 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy2Rst: 1;      //bit2,  USB PHY2 reset control, 0-reset valid, 1-reset invalid
+    __u32   reserved0: 3;       //bit3,  reserved
+    __u32   OHCI0SpecClkGate: 1; //bit6,  gating special clock for OHCI0, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   OHCI1SpecClkGate: 1; //bit7,  gating special clock for OHCI1, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   PhySpecClkGate: 1;  //bit8,  gating special clock for USB PHY0/1/2, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   reserved2: 23;      //bit9,  reserved
+} __ccmu_usb_clk_reg00cc_t;
+
+/* REMOVED */
+//typedef struct __CCMU_GPS_CLK_REG00D0 {
+//    __u32   ClkDivRatio: 3;     //bit0,  clock divide ratio(m)
+//    __u32   reserved0: 21;      //bit3,  reserved
+//    __u32   ClkSrc: 2;          //bit24, GPU Clock Source Select: 00-osc24M, 01-PLL6, 10-PLL7, 11-PLL4.
+//    __u32   reserved1: 4;       //bit26, reserved
+//    __u32   Reset: 1;           //bit30, GPS reset control
+//    __u32   SpecClkGate: 1;     //bit31, gating special clock for GPS, 0-CLK OFF, 1-CLK ON
+//} __ccmu_gps_clk_reg00d0_t;
+
+typedef struct __CCMU_DRAM_GATE_REG0100 {
+    __u32   VeGate: 1;          //bit0,  Gating dram clock for VE, 0-mask, 1-pass
+    __u32   Csi0Gate: 1;        //bit1,  Gating dram clock for CSI0, 0-mask, 1-pass
+    __u32   Csi1Gate: 1;        //bit2,  Gating dram clock for CSI1, 0-mask, 1-pass
+    __u32   TsGate: 1;          //bit3,  Gating dram clock for TS, 0-mask, 1-pass
+    __u32   TvdGate: 1;         //bit4,  Gating dram clock for TVD, 0-mask, 1-pass
+    __u32   Tve0Gate: 1;        //bit5,  Gating dram clock for TVE0, 0-mask, 1-pass
+    __u32   Tve1Gate: 1;        //bit6,  Gating dram clock for TVE1, 0-mask, 1-pass
+    __u32   reserved0: 8;       //bit7,  reserved
+    __u32   ClkOutputEn: 1;     //bit15, DRAM clock output enable, 0-disable, 1-enable
+    __u32   reserved1: 8;       //bit16, reserved
+    __u32   DeFe1Gate: 1;       //bit24, Gating dram clock for DE_FE1, 0-mask, 1-pass
+    __u32   DeFe0Gate: 1;       //bit25, Gating dram clock for DE_FE0, 0-mask, 1-pass
+    __u32   DeBe0Gate: 1;       //bit26, Gating dram clock for DE_BE0, 0-mask, 1-pass
+    __u32   DeBe1Gate: 1;       //bit27, Gating dram clock for DE_BE1, 0-mask, 1-pass
+    __u32   DeMpGate: 1;        //bit28, Gating dram clock for DE_MP, 0-mask, 1-pass
+    __u32   AceGate: 1;         //bit29, Gating dram clock for ACE, 0-mask, 1-pass
+    __u32   reserved2: 2;       //bit30, reserved
+} __ccmu_dram_gate_reg0100_t;
+
+/* FEBEMP module clock type, used for DE-BE0, DE-BE1, DE-FE0, DE-FE1, DE-MP */
+/* register address is 0x0104~0x0114 */
+typedef struct __CCMU_FEDEMP_CLK {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divied by (m+1), 1~16 ex.
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-PLL3, 01-PLL7, 10-PLL5, 11-reserved
+    __u32   reserved1: 4;       //bit26, reserved
+    __u32   Reset: 1;           //bit30, module reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_fedemp_clk_t;
+
+/* LCDCH0 module clock type, used for LCD0_CH0, LCD1_CH0 */
+/* register address is 0x0118~0x011C */
+typedef struct __CCMU_LCDCH0_CLK {
+    __u32   reserved0: 24;      //bit0,  reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)(PLL6*2 Just for LCD0_CH0)
+    __u32   reserved1: 4;       //bit26, reserved
+    __u32   Reset: 1;           //bit30, module reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_lcdch0_clk_t;
+
+typedef struct __CCMU_CSIISP_CLK_REG0120 {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 2;          //bit24, special clock2 source select, 00-PLL3(1x), 01-PLL4, 10-PLL5, 11-PLL6
+    __u32   reserved1: 5;       //bit26, reserved
+    __u32   SpecClkGate: 1;     //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_csiisp_clk_reg0120_t;
+
+typedef struct __CCMU_TVD_CLK_REG0128 {
+    __u32   Clk1Div: 4;         //bit0, Clock divide ratio1(M)
+    __u32   reserved0: 4;       //bit4, reserved
+    __u32   Clk1Src: 1;         //bit8, clock1 source select, 0-PLL3, 1-PLL7
+    __u32   reserved1: 6;       //bit9, reserved
+    __u32   Clk1Gate: 1;        //bit15, gating special clock, 0-clock off, 1-clock on
+    __u32   Clk2Div: 4;         //bit16, Clock divide ratio2(M)
+    __u32   reserved2: 4;       //bit20, reserved
+    __u32   Clk2Src: 1;         //bit24, clock2 source select, 0-PLL3, 1-PLL7
+    __u32   reserved3: 6;       //bit25, reserved
+    __u32   Clk2Gate: 1;        //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_tvd_clk_reg0128_t;
+
+/* LCD-CH1 module clock type, used for LCD0_CH1, LCD1_CH1 */
+/* register address is 0x012C~0x0130 */
+typedef struct __CCMU_LCDCH1_CLK {
+    __u32   ClkDiv: 4;          //bit0,  clock division
+    __u32   reserved0: 7;       //bit4,  reserved
+    __u32   SpecClk1Src: 1;     //bit11, special clock 1 source select, 0-special clock2,
+    __u32   reserved1: 3;       //bit12, reserved
+    __u32   SpecClk1Gate: 1;    //bit15, gating special clock1, 0-clock off, 1-clock on
+    __u32   reserved2: 8;       //bit16, reserved
+    __u32   SpecClk2Src: 2;     //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved3: 5;       //bit26, reserved
+    __u32   SpecClk2Gate: 1;    //bit31, gating special clock2, 0-clock off, 1-clock on
+} __ccmu_lcdch1_clk_t;
+
+/* CSI module clock type, used for CSI0/1 */
+/* register address is 0x0134~0x0138 */
+typedef struct __CCMU_CSI_CLK {
+    __u32   ClkDiv: 5;          //bit0,  clock divide ratio, divided by (m+1), 1~32, ex.
+    __u32   reserved0: 19;      //bit5,  reserved
+    __u32   ClkSrc: 3;          //bit24, clock source select, 000-HOSC, 001-PLL3(1x), 010-PLL7(1x), 011/100/111-reserved, 101-PLL3(2x), 110:PLL7(2x)
+    __u32   reserved1: 3;       //bit27, reserved
+    __u32   Reset: 1;           //bit30, CSI reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_csi_clk_t;
+
+typedef struct __CCMU_VE_CLK_REG013C {
+    __u32   Reset: 1;           //bit0,  VE reset, 0-reset valid, 1-reset invalid
+    __u32   reserved0: 15;      //bit1,  reserved
+    __u32   ClkDiv: 3;          //bit16, Clock pre-divide ratio, divided by (n+1), 1~8 ex.
+    __u32   reserved1: 12;      //bit19, reserved
+    __u32   SpecClkGate: 1;     //bit31, gating special clock for VE, 0-mask, 1-pass
+} __ccmu_ve_clk_reg013c_t;
+
+typedef struct __CCMU_ADDA_CLK_REG0140 {
+    __u32   reserved0: 31;      //bit0,  reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_adda_clk_reg0140_t;
+
+typedef struct __CCMU_AVS_CLK_REG0144 {
+    __u32   reserved0: 31;      //bit0,  reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_avs_clk_reg0144_t;
+
+typedef struct __CCMU_ACE_CLK_REG0148 {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 12;      //bit4,  reserved
+    __u32   Reset: 1;           //bit16, ACE reset, 0-reset valid, 1-reset invalid
+    __u32   reserved1: 7;       //bit17, reserved
+    __u32   ClkSrc: 1;          //bit24, Clock source select, 0-PLL4, 1-PLL5
+    __u32   reserved2: 6;       //bit25, reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_ace_clk_reg0148_t;
+
+typedef struct __CCMU_LVDS_CLK_REG014C {
+    __u32   Reset: 1;           //bit0,  LVDS reset
+    __u32   reserved0: 31;      //bit1,  reserved
+} __ccmu_lvds_clk_reg014c_t;
+
+typedef struct __CCMU_HDMI_CLK_REG0150 {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 2;          //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved1: 5;       //bit26, reserved
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_hdmi_clk_reg0150_t;
+
+typedef struct __CCMU_MALI400_CLK_REG0154 {
+    __u32   ClkDiv: 4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 3;          //bit24, clolck source select, 000-PLL3, 001-PLL4, 010-PLL5, 011-PLL7, 100-pll8, 101~111-reserved
+    __u32   reserved1: 3;       //bit27, reserved
+    __u32   Reset: 1;           //bit30, Mali400 reset, 0-reset valid, 1-reset invalid
+    __u32   SpecClkGate: 1;     //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_mali400_clk_reg0154_t;
+
+typedef struct __CCMU_MBUS_CLK_REG015C {
+    __u32   ClkDivM: 4;         //bit0,  clock divide ratioM
+    __u32   reserved0: 12;      //bit4,  reserved
+    __u32   ClkDivN: 2;         //bit16, clock pre-divide ratio, pre-divided by 2^n, 1/2/4/8 ex.
+    __u32   reserved1: 6;       //bit18, reserved
+    __u32   ClkSrc: 2;          //bit24, clock select, 00-HOSC, 01-PLL6*2, 10-PLL5, 11-reserved
+    __u32   reserved2: 5;       //bit26, reserved
+    __u32   ClkGate: 1;         //bit31, gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_mbus_clk_reg015c_t;
+
+typedef struct __CCMU_GMAC_CLK_REG0164 {
+    __u32   TxClkSrc: 2;        //bit0,  GMAC Transmit Clock Source
+    __u32   PhyIT: 1;           //bit2,  GMAC Phy Interface Type
+    __u32   TxClkInv: 1;        //bit3,  Enable GMAC Transmit Clock Invertor, 0-Disable, 1-Enable
+    __u32   RxClkInv: 1;        //bit4,  Enable GMAC Receive Clock Invertor
+    __u32   RxDlyChain: 3;      //bit5,  Configure GMAC Receive Clock Delay Chain
+    __u32   ClkDiv: 2;          //bit8,  Clock pre-divide ratio(n)
+    __u32   reserved0: 22;      //bit10, reserved
+} __ccmu_gmac_clk_reg0164_t;
+
+typedef struct __CCMU_HDMI1_RST_REG0170 {
+    __u32   hrst: 1;            //bit0,  hreset
+    __u32   sysrst: 1;          //bit1,  HDMI1 system reset
+    __u32   AudioDmaRst: 1;     //bit2,  Audio dma reset
+    __u32   reserved0: 29;      //bit3,  reserved
+} __ccmu_hdmi1_rst_reg0170_t;
+
+typedef struct __CCMU_HDMI1_CTL_REG0174 {
+    __u32   ctl;                //bit0,  HDMI1 System Control Register
+} __ccmu_hdmi1_ctl_reg0174_t;
+
+typedef struct __CCMU_HDMI1_SHW_CLK_REG0178 {
+    __u32   reserved0: 31;      //bit0,  reserved
+    __u32   ClkEn: 1;           //bit31, Clock Output Enable
+} __ccmu_hdmi1_shw_clk_reg0178_t;
+
+typedef struct __CCMU_HDMI1_RPT_CLK_REG017C {
+    __u32   ClkDiv: 4;          //bit0,  Clock divide ratio(m)
+    __u32   reserved0: 20;      //bit4,  reserved
+    __u32   ClkSrc: 2;          //bit24, Clock Source Select
+    __u32   reserved1: 5;       //bit26, reserved
+    __u32   ClkEn: 1;           //bit31, Clock Output Enable
+} __ccmu_hdmi1_rpt_clk_reg017c_t;
+
+/* Clock output, used for clock outA/clock outB */
+/* register address is 0x01F0, 0x01F4 */
+typedef struct __CCMU_CLKOUT {
+    __u32   reserved0: 8;       //bit0,  reserved
+    __u32   ClkDivM: 5;         //bit8,  clock output divide Factor M (1~31)
+    __u32   reserved1: 7;       //bit13, reserved
+    __u32   ClkDivN: 2;         //bit20, Clock Output Divede FactorN, pre-divided by 2^n, 1/2/4/8 ex.
+    __u32   reserved2: 2;       //bit22, reserved
+    __u32   ClkSrc: 2;          //bit24, clock select, 00-HOSC/750=32K, 01-Ext.Losc(32768), 10-HOSC, 11-reserved
+    __u32   reserved3: 5;       //bit26, reserved
+    __u32   ClkEn: 1;           //bit31, Clock Output Enable, 0-Disable, 1-Enable
+} __ccmu_clkout_t;
+
+typedef struct __CCMU_REG_LIST {
+    volatile __ccmu_pll1_core_reg0000_t     Pll1Ctl;    //0x0000, PLL1 control
+    volatile __u32                          reserved0;  //0x0004, reserved
+    volatile __ccmu_pll2_audio_reg0008_t    Pll2Ctl;    //0x0008, PLL2 control
+    volatile __u32                          reserved1;  //0x000C, reserved
+    volatile __ccmu_pll3_video_reg0010_t    Pll3Ctl;    //0x0010, PLL3 control
+    volatile __u32                          reserved2;  //0x0014, reserved
+    volatile __ccmu_pll4_ve_reg0018_t       Pll4Ctl;    //0x0018, PLL4 control
+    volatile __u32                          reserved3;  //0x001C, reserved
+    volatile __ccmu_pll5_ddr_reg0020_t      Pll5Ctl;    //0x0020, PLL5 control
+    volatile __u32                          reserved4;  //0x0024, reserved
+    volatile __ccmu_pll6_sata_reg0028_t     Pll6Ctl;    //0x0028, PLL6 control
+    volatile __u32                          reserved5;  //0x002C, reserved
+    volatile __ccmu_pll7_video1_reg0030_t   Pll7Ctl;    //0x0030, Pll7 control
+    volatile __u32                          reserved6[3];   //0x0034, reserved
+    volatile __ccmu_pll8_gpu_reg0040_t      Pll8Ctl;    //0x0040, pll8 control
+    volatile __u32                          reserved7[3];   //0x0044, reserved
+    volatile __ccmu_osc24m_reg0050_t        HoscCtl;    //0x0050, OSC24M control
+    volatile __ccmu_sysclkl_ratio_reg0054_t SysClkDiv;  //0x0054, AC328/AHB/APB0 divide ratio
+    volatile __ccmu_apb1clk_ratio_reg0058_t Apb1ClkDiv; //0x0058, APB1 clock dividor
+    volatile __u32                          reserved8;  //0x005C, reserved
+    volatile __ccmu_ahbclk_gate0_reg0060_t  AhbGate0;   //0x0060, AHB module clock gating 0
+    volatile __ccmu_ahbclk_gate1_reg0064_t  AhbGate1;   //0x0064, AHB module clock gating 1
+    volatile __ccmu_apb0clk_gate_reg0068_t  Apb0Gate;   //0x0068, APB0 module clock gating
+    volatile __ccmu_apb1clk_gate_reg006c_t  Apb1Gate;   //0x006C, APB1 module clock gating
+    volatile __u32                          reserved9[4];   //0x0070, reserved
+    volatile __ccmu_module0_clk_t           NandClk;    //0x0080, nand module clock control
+    volatile __ccmu_module0_clk_t           MsClk;      //0x0084, MS module clock control
+    volatile __ccmu_module0_clk_t           SdMmc0Clk;  //0x0088, SD/MMC0 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc1Clk;  //0x008C, SD/MMC1 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc2Clk;  //0x0090, SD/MMC2 module clock control
+    volatile __ccmu_module0_clk_t           SdMmc3Clk;  //0x0094, SD/MMC3 module clock control
+    volatile __ccmu_module0_clk_t           TsClk;      //0x0098, TS module clock control
+    volatile __ccmu_module0_clk_t           SsClk;      //0x009C, SS module clock control
+    volatile __ccmu_module0_clk_t           Spi0Clk;    //0x00A0, SPI0 module clock control
+    volatile __ccmu_module0_clk_t           Spi1Clk;    //0x00A4, SPI1 module clock control
+    volatile __ccmu_module0_clk_t           Spi2Clk;    //0x00A8, SPI2 module clock control
+    volatile __ccmu_module0_clk_t           PataClk;    //0x00AC, PATA module clock control
+    volatile __ccmu_module0_clk_t           Ir0Clk;     //0x00B0, IR0 module clock control
+    volatile __ccmu_module0_clk_t           Ir1Clk;     //0x00B4, IR1 module clock control
+    volatile __ccmu_module1_clk_t           I2s0Clk;    //0x00B8, IIS0 module clock control
+    volatile __ccmu_module1_clk_t           Ac97Clk;    //0x00BC, AC97 module clock control
+    volatile __ccmu_module1_clk_t           SpdifClk;   //0x00C0, SPDIF module clock control
+    volatile __ccmu_keypad_clk_reg00c4_t    KeyPadClk;  //0x00C4, KEYPAD module clock control
+    volatile __ccmu_sata_clk_reg00c8_t      SataClk;    //0x00C8, SATA module clock control
+    volatile __ccmu_usb_clk_reg00cc_t       UsbClk;     //0x00CC, USB module clock control
+    volatile __u32                          reserved10; //0x00D0, reserved
+    volatile __ccmu_module0_clk_t           Spi3Clk;    //0x00D4, SPI3 module clock control
+    volatile __ccmu_module1_clk_t           I2s1Clk;    //0x00D8, IIS1 module clock control
+    volatile __ccmu_module1_clk_t           I2s2Clk;    //0x00DC, IIS2 module clock control
+    volatile __u32                          reserved11[8];  //0x00E0, reserved
+    volatile __ccmu_dram_gate_reg0100_t     DramGate;   //0x0100, DRAM gating
+    volatile __ccmu_fedemp_clk_t            DeBe0Clk;   //0x0104, DE-BE 0 module clock control
+    volatile __ccmu_fedemp_clk_t            DeBe1Clk;   //0x0108, DE-BE 1 module clock control
+    volatile __ccmu_fedemp_clk_t            DeFe0Clk;   //0x010C, DE-FE 0 module clock control
+    volatile __ccmu_fedemp_clk_t            DeFe1Clk;   //0x0110, DE-FE 1 module clock control
+    volatile __ccmu_fedemp_clk_t            DeMpClk;    //0x0114, DE-MP module clock control
+    volatile __ccmu_lcdch0_clk_t            Lcd0Ch0Clk; //0x0118, LCD0 CH0 module clock control
+    volatile __ccmu_lcdch0_clk_t            Lcd1Ch0Clk; //0x011C, LCD1 CH0 module clock control
+    volatile __ccmu_csiisp_clk_reg0120_t    CsiIspClk;  //0x0120, CSI-ISP module clock control
+    volatile __u32                          reserved12; //0x0124, reserved
+    volatile __ccmu_tvd_clk_reg0128_t       TvdClk;     //0x0128, TVD module clock control
+    volatile __ccmu_lcdch1_clk_t            Lcd0Ch1Clk; //0x012C, LCD0 CH1 module clock control
+    volatile __ccmu_lcdch1_clk_t            Lcd1Ch1Clk; //0x0130, LCD1 CH1 module clock control
+    volatile __ccmu_csi_clk_t               Csi0Clk;    //0x0134, CSI0 module clock control
+    volatile __ccmu_csi_clk_t               Csi1Clk;    //0x0138, CSI1 module clock control
+    volatile __ccmu_ve_clk_reg013c_t        VeClk;      //0x013C, VE module clock control
+    volatile __ccmu_adda_clk_reg0140_t      AddaClk;    //0x0140, audio codec clock control
+    volatile __ccmu_avs_clk_reg0144_t       AvsClk;     //0x0144, AVS module clock control
+    volatile __ccmu_ace_clk_reg0148_t       AceClk;     //0x0148, ACE module clock control
+    volatile __ccmu_lvds_clk_reg014c_t      LvdsClk;    //0x014C, LVDS module clock control
+    volatile __ccmu_hdmi_clk_reg0150_t      HdmiClk;    //0x0150, HDMI module clock control
+    volatile __ccmu_mali400_clk_reg0154_t   MaliClk;    //0x0154, MALI400 module clock control
+    volatile __u32                          reserved13; //0x0158, reserved
+    volatile __ccmu_mbus_clk_reg015c_t      MBusClk;    //0x015C, MBus module clock control
+    volatile __u32                          reserved14; //0x0160, reserved
+    volatile __ccmu_gmac_clk_reg0164_t      GmacClk;    //0x0164, GMAC module clock control
+    volatile __u32                          reserved15[2];  //0x0168, reserved
+    volatile __ccmu_hdmi1_rst_reg0170_t     Hdmi1Rst;   //0x0170, HDMI1 Reset Register
+    volatile __ccmu_hdmi1_ctl_reg0174_t     Hdmi1Ctl;   //0x0174, HDMI1 Control Register
+    volatile __ccmu_hdmi1_shw_clk_reg0178_t Hdmi1ShwClk;//0x0178, HDMI1 Show Clock Register
+    volatile __ccmu_hdmi1_rpt_clk_reg017c_t Hdmi1RptClk;//0x017C, HDMI1 Repeat Clock Register
+    volatile __u32                          reserved16[28]; //0x0180, reserved
+    volatile __ccmu_clkout_t                ClkOutA;    //0x01F0, Clock output A control
+    volatile __ccmu_clkout_t                ClkOutB;    //0x01F4, Clock output B control
+} __ccmu_reg_list_t;
+
+#endif
diff --git a/arch/arm/mach-sun7i/include/mach/clock.h b/arch/arm/mach-sun7i/include/mach/clock.h
new file mode 100644
index 0000000..ef3f6a7
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/clock.h
@@ -0,0 +1,259 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/clock.h
+ * (c) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * James Deng <csjamesdeng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __AW_CLOCK_H__
+#define __AW_CLOCK_H__
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/clocksource.h>
+
+#define CCU_LOCK_INIT(lock)     spin_lock_init(lock)
+#define CCU_LOCK_DEINIT(lock)   do{} while(0)
+#define CCU_LOCK(lock, flags)   spin_lock_irqsave((lock), (flags))
+#define CCU_UNLOCK(lock, flags) spin_unlock_irqrestore((lock), (flags))
+#define DEFINE_FLAGS(x)         unsigned long x
+
+/* define clock error type      */
+typedef enum __AW_CCU_ERR {
+    AW_CCU_ERR_NONE     =  0,
+    AW_CCU_ERR_PARA_NUL = -1,
+    AW_CCU_ERR_PARA_INV = -2,
+
+} __aw_ccu_err_e;
+
+
+typedef enum __AW_CCU_CLK_ONOFF {
+    AW_CCU_CLK_OFF      = 0,
+    AW_CCU_CLK_ON       = 1,
+
+} __aw_ccu_clk_onff_e;
+
+
+typedef enum __AW_CCU_CLK_RESET {
+    AW_CCU_CLK_RESET    = 0,
+    AW_CCU_CLK_NRESET   = 1,
+
+} __aw_ccu_clk_reset_e;
+
+/*
+ * We encourage you use macro rather than clock name directly.
+ * This macro making driver porting more convenience in
+ * different platform.
+ */
+/* define system clock name */
+#define CLK_SYS_LOSC            "losc"
+#define CLK_SYS_HOSC            "hosc"
+#define CLK_SYS_PLL1            "core_pll"
+#define CLK_SYS_PLL2            "audio_pll"
+#define CLK_SYS_PLL2X8          "audio_pllx8"
+#define CLK_SYS_PLL3            "video_pll0"
+#define CLK_SYS_PLL3X2          "video_pll0x2"
+#define CLK_SYS_PLL4            "ve_pll"
+#define CLK_SYS_PLL5            "sdram_pll"
+#define CLK_SYS_PLL5M           "sdram_pll_m"
+#define CLK_SYS_PLL5P           "sdram_pll_p"
+#define CLK_SYS_PLL6            "sata_pll"
+#define CLK_SYS_PLL6M           "sata_pll_m"
+#define CLK_SYS_PLL62           "sata_pll_2"
+#define CLK_SYS_PLL6X2          "sata_pllx2"
+#define CLK_SYS_PLL7            "video_pll1"
+#define CLK_SYS_PLL7X2          "video_pll1x2"
+#define CLK_SYS_PLL8            "gpu_pll"
+#define CLK_SYS_CPU             "cpu"
+#define CLK_SYS_AXI             "axi"
+#define CLK_SYS_ATB             "atb"
+#define CLK_SYS_AHB             "ahb"
+#define CLK_SYS_APB0            "apb"
+#define CLK_SYS_APB1            "apb1"
+
+/* define module clock name */
+#define CLK_MOD_NFC             "nfc"
+#define CLK_MOD_MSC             "msc"
+#define CLK_MOD_SDC0            "sdc0"
+#define CLK_MOD_SDC1            "sdc1"
+#define CLK_MOD_SDC2            "sdc2"
+#define CLK_MOD_SDC3            "sdc3"
+#define CLK_MOD_TS              "ts"
+#define CLK_MOD_SS              "ss"
+#define CLK_MOD_SPI0            "spi0"
+#define CLK_MOD_SPI1            "spi1"
+#define CLK_MOD_SPI2            "spi2"
+#define CLK_MOD_PATA            "pata"
+#define CLK_MOD_IR0             "ir0"
+#define CLK_MOD_IR1             "ir1"
+#define CLK_MOD_I2S0            "i2s0"
+#define CLK_MOD_I2S1            "i2s1"
+#define CLK_MOD_I2S2            "i2s2"
+#define CLK_MOD_AC97            "ac97"
+#define CLK_MOD_SPDIF           "spdif"
+#define CLK_MOD_KEYPAD          "key_pad"
+#define CLK_MOD_SATA            "sata"
+#define CLK_MOD_USBPHY          "usb_phy"
+#define CLK_MOD_USBPHY0         "usb_phy0"
+#define CLK_MOD_USBPHY1         "usb_phy1"
+#define CLK_MOD_USBPHY2         "usb_phy2"
+#define CLK_MOD_USBOHCI0        "usb_ohci0"
+#define CLK_MOD_USBOHCI1        "usb_ohci1"
+#define CLK_MOD_GPS             "com"
+#define CLK_MOD_SPI3            "spi3"
+#define CLK_MOD_DEBE0           "de_image0"
+#define CLK_MOD_DEBE1           "de_image1"
+#define CLK_MOD_DEFE0           "de_scale0"
+#define CLK_MOD_DEFE1           "de_scale1"
+#define CLK_MOD_DEMIX           "de_mix"
+#define CLK_MOD_LCD0CH0         "lcd0_ch0"
+#define CLK_MOD_LCD1CH0         "lcd1_ch0"
+#define CLK_MOD_CSIISP          "csi_isp"
+#define CLK_MOD_TVDMOD1         "tvdmod1"
+#define CLK_MOD_TVDMOD2         "tvdmod2"
+#define CLK_MOD_LCD0CH1_S1      "lcd0_ch1_s1"
+#define CLK_MOD_LCD0CH1_S2      "lcd0_ch1_s2"
+#define CLK_MOD_LCD1CH1_S1      "lcd1_ch1_s1"
+#define CLK_MOD_LCD1CH1_S2      "lcd1_ch1_s2"
+#define CLK_MOD_CSI0            "csi0"
+#define CLK_MOD_CSI1            "csi1"
+#define CLK_MOD_VE              "ve"
+#define CLK_MOD_ADDA            "audio_codec"
+#define CLK_MOD_AVS             "avs"
+#define CLK_MOD_ACE             "ace"
+#define CLK_MOD_LVDS            "lvds"
+#define CLK_MOD_HDMI            "hdmi"
+#define CLK_MOD_MALI            "mali"
+#define CLK_MOD_TWI0            "twi0"
+#define CLK_MOD_TWI1            "twi1"
+#define CLK_MOD_TWI2            "twi2"
+#define CLK_MOD_TWI3            "twi3"
+#define CLK_MOD_TWI4            "twi4"
+#define CLK_MOD_CAN             "can"
+#define CLK_MOD_SCR             "scr"
+#define CLK_MOD_PS20            "ps0"
+#define CLK_MOD_PS21            "ps1"
+#define CLK_MOD_UART0           "uart0"
+#define CLK_MOD_UART1           "uart1"
+#define CLK_MOD_UART2           "uart2"
+#define CLK_MOD_UART3           "uart3"
+#define CLK_MOD_UART4           "uart4"
+#define CLK_MOD_UART5           "uart5"
+#define CLK_MOD_UART6           "uart6"
+#define CLK_MOD_UART7           "uart7"
+#define CLK_MOD_SMPTWD          "smp_twd"
+#define CLK_MOD_MBUS            "mbus"
+#define CLK_MOD_OUTA            "clkout_a"
+#define CLK_MOD_OUTB            "clkout_b"
+
+/* define ahb module gating clock */
+#define CLK_AHB_USB0            "ahb_usb0"
+#define CLK_AHB_EHCI0           "ahb_ehci0"
+#define CLK_AHB_OHCI0           "ahb_ohci0"
+#define CLK_AHB_SS              "ahb_ss"
+#define CLK_AHB_DMA             "ahb_dma"
+#define CLK_AHB_BIST            "ahb_bist"
+#define CLK_AHB_SDMMC0          "ahb_sdc0"
+#define CLK_AHB_SDMMC1          "ahb_sdc1"
+#define CLK_AHB_SDMMC2          "ahb_sdc2"
+#define CLK_AHB_SDMMC3          "ahb_sdc3"
+#define CLK_AHB_MS              "ahb_msc"
+#define CLK_AHB_NAND            "ahb_nfc"
+#define CLK_AHB_SDRAM           "ahb_sdramc"
+#define CLK_AHB_ACE             "ahb_ace"
+#define CLK_AHB_EMAC            "ahb_emac"
+#define CLK_AHB_TS              "ahb_ts"
+#define CLK_AHB_SPI0            "ahb_spi0"
+#define CLK_AHB_SPI1            "ahb_spi1"
+#define CLK_AHB_SPI2            "ahb_spi2"
+#define CLK_AHB_SPI3            "ahb_spi3"
+#define CLK_AHB_PATA            "ahb_pata"
+#define CLK_AHB_SATA            "ahb_sata"
+#define CLK_AHB_GPS             "ahb_com"
+#define CLK_AHB_VE              "ahb_ve"
+#define CLK_AHB_TVD             "ahb_tvd"
+#define CLK_AHB_TVE0            "ahb_tve0"
+#define CLK_AHB_TVE1            "ahb_tve1"
+#define CLK_AHB_LCD0            "ahb_lcd0"
+#define CLK_AHB_LCD1            "ahb_lcd1"
+#define CLK_AHB_CSI0            "ahb_csi0"
+#define CLK_AHB_CSI1            "ahb_csi1"
+#define CLK_AHB_HDMI1           "ahb_hdmi1"
+#define CLK_AHB_HDMI            "ahb_hdmi"
+#define CLK_AHB_DEBE0           "ahb_de_image0"
+#define CLK_AHB_DEBE1           "ahb_de_image1"
+#define CLK_AHB_DEFE0           "ahb_de_scale0"
+#define CLK_AHB_DEFE1           "ahb_de_scale1"
+#define CLK_AHB_GMAC            "ahb_gmac"
+#define CLK_AHB_MP              "ahb_de_mix"
+#define CLK_AHB_MALI            "ahb_mali"
+#define CLK_AHB_EHCI1           "ahb_ehci1"
+#define CLK_AHB_OHCI1           "ahb_ohci1"
+#define CLK_AHB_STMR            "ahb_stmr"
+
+/* define apb module gatine clock */
+#define CLK_APB_ADDA            "apb_audio_codec"
+#define CLK_APB_SPDIF           "apb_spdif"
+#define CLK_APB_AC97            "apb_ac97"
+#define CLK_APB_I2S0            "apb_i2s0"
+#define CLK_APB_I2S1            "apb_i2s1"
+#define CLK_APB_I2S2            "apb_i2s2"
+#define CLK_APB_PIO             "apb_pio"
+#define CLK_APB_IR0             "apb_ir0"
+#define CLK_APB_IR1             "apb_ir1"
+#define CLK_APB_KEYPAD          "apb_key_pad"
+#define CLK_APB_TWI0            "apb_twi0"
+#define CLK_APB_TWI1            "apb_twi1"
+#define CLK_APB_TWI2            "apb_twi2"
+#define CLK_APB_TWI3            "apb_twi3"
+#define CLK_APB_TWI4            "apb_twi4"
+#define CLK_APB_CAN             "apb_can"
+#define CLK_APB_SCR             "apb_scr"
+#define CLK_APB_PS20            "apb_ps0"
+#define CLK_APB_PS21            "apb_ps1"
+#define CLK_APB_UART0           "apb_uart0"
+#define CLK_APB_UART1           "apb_uart1"
+#define CLK_APB_UART2           "apb_uart2"
+#define CLK_APB_UART3           "apb_uart3"
+#define CLK_APB_UART4           "apb_uart4"
+#define CLK_APB_UART5           "apb_uart5"
+#define CLK_APB_UART6           "apb_uart6"
+#define CLK_APB_UART7           "apb_uart7"
+
+/* define dram module gating clock */
+#define CLK_DRAM_VE             "sdram_ve"
+#define CLK_DRAM_CSI0           "sdram_csi0"
+#define CLK_DRAM_CSI1           "sdram_csi1"
+#define CLK_DRAM_TS             "sdram_ts"
+#define CLK_DRAM_TVD            "sdram_tvd"
+#define CLK_DRAM_TVE0           "sdram_tve0"
+#define CLK_DRAM_TVE1           "sdram_tve1"
+#define CLK_DRAM_DEFE0          "sdram_de_scale0"
+#define CLK_DRAM_DEFE1          "sdram_de_scale1"
+#define CLK_DRAM_DEBE0          "sdram_de_image0"
+#define CLK_DRAM_DEBE1          "sdram_de_image1"
+#define CLK_DRAM_DEMP           "sdram_de_mix"
+#define CLK_DRAM_ACE            "sdram_ace"
+
+struct __AW_CCU_CLK;
+struct clk_ops;
+
+typedef struct clk {
+    struct __AW_CCU_CLK *aw_clk;    /* clock handle from ccu csp */
+    struct clk_ops      *ops;       /* clock operation handle */
+    int                 enable;     /* enable count, when it down to 0, it will be disalbe */
+    spinlock_t          lock;       /* to synchronize the clock setting */
+} __ccu_clk_t;
+
+int clk_reset(struct clk *clk, int reset);
+const char *clk_name(struct clk *clk);
+cycle_t aw_clksrc_read(struct clocksource *cs);
+
+#endif
diff --git a/arch/arm/mach-sun7i/include/mach/debug-macro.S b/arch/arm/mach-sun7i/include/mach/debug-macro.S
new file mode 100755
index 0000000..9472423
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/debug-macro.S
@@ -0,0 +1,5 @@
+/*
+   arch/arm/mach-sun7i/include/mach/debug-macro.S
+ */
+
+#include <plat/debug-macro.S>
diff --git a/arch/arm/mach-sun7i/include/mach/dma.h b/arch/arm/mach-sun7i/include/mach/dma.h
new file mode 100755
index 0000000..0b99a92
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/dma.h
@@ -0,0 +1,251 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/dma.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun7i dma driver header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SW_DMA_H
+#define __SW_DMA_H
+
+#include <mach/hardware.h>
+
+/* dma channel irq type */
+typedef enum {
+	CHAN_IRQ_NO 	= (0b000	),	/* none irq */
+	CHAN_IRQ_HD	= (0b001	),	/* buf half done irq */
+	CHAN_IRQ_FD	= (0b010	),	/* buf full done irq */
+}dma_chan_irq_type;
+
+/* wait clock cycles and data block size */
+typedef struct {
+	u32 src_wait_cyc 	: 8; /* bit0~7: source wait clock cycles n */
+	u32 src_blk_sz 		: 8; /* bit8~15: source data block size n */
+	u32 dst_wait_cyc 	: 8; /* bit16~23: dest wait clock cycles n */
+	u32 dst_blk_sz 		: 8; /* bit24~31: dest data block size n */
+}dma_para_t;
+
+/* data width and burst */
+#define DATA_WIDTH_8BIT		0
+#define DATA_WIDTH_16BIT	1
+#define DATA_WIDTH_32BIT	2
+#define DATA_BRST_1 		0
+#define DATA_BRST_4		1
+#define DATA_BRST_8		2
+typedef struct {
+	u8 src_data_width;	/* src data width */
+	u8 src_bst_len;		/* src burst length */
+	u8 dst_data_width;	/* dst data width */
+	u8 dst_bst_len;		/* dst burst length */
+}xferunit_t;
+
+/* address mode */
+#define NDMA_ADDR_INCREMENT	0
+#define NDMA_ADDR_NOCHANGE	1
+#define DDMA_ADDR_LINEAR	0
+#define DDMA_ADDR_IO		1
+#define DDMA_ADDR_HORI_PAGE	2
+#define DDMA_ADDR_VERT_PAGE	3
+typedef struct {
+	u16 src_addr_mode;	/* src address mode */
+	u16 dst_addr_mode;	/* dst address mode */
+}addrtype_t;
+
+/* normal channel src drq type */
+#define N_SRC_IR0_RX		0b00000
+#define N_SRC_IR1_RX		0b00001
+#define N_SRC_SPDIF_RX		0b00010
+#define N_SRC_IIS0_RX		0b00011
+#define N_SRC_IIS1_RX		0b00100
+#define N_SRC_AC97_RX		0b00101
+#define N_SRC_IIS2_RX		0b00110
+/* resv: 1 */
+#define N_SRC_UART0_RX		0b01000
+#define N_SRC_UART1_RX		0b01001
+#define N_SRC_UART2_RX		0b01010
+#define N_SRC_UART3_RX		0b01011
+#define N_SRC_UART4_RX		0b01100
+#define N_SRC_UART5_RX		0b01101
+#define N_SRC_UART6_RX		0b01110
+#define N_SRC_UART7_RX		0b01111
+#define N_SRC_HDMI_DDC_RX	0b10000
+#define N_SRC_USB_EP1		0b10001
+/* resv: 1 */
+#define N_SRC_AUDIO_CODEC_AD	0b10011
+/* resv: 1 */
+#define N_SRC_SRAM		0b10101
+#define N_SRC_SDRAM		0b10110
+#define N_SRC_TP_AD		0b10111
+#define N_SRC_SPI0_RX		0b11000
+#define N_SRC_SPI1_RX		0b11001
+#define N_SRC_SPI2_RX		0b11010
+#define N_SRC_SPI3_RX		0b11011
+#define N_SRC_USB_EP2		0b11100
+#define N_SRC_USB_EP3		0b11101
+#define N_SRC_USB_EP4		0b11110
+#define N_SRC_USB_EP5		0b11111
+
+/* normal channel dst drq type */
+#define N_DST_IR0_TX		0b00000
+#define N_DST_IR1_TX		0b00001
+#define N_DST_SPDIF_TX		0b00010
+#define N_DST_IIS0_TX		0b00011
+#define N_DST_IIS1_TX		0b00100
+#define N_DST_AC97_TX		0b00101
+#define N_DST_IIS2_TX		0b00110
+/* resv: 1 */
+#define N_DST_UART0_TX		0b01000
+#define N_DST_UART1_TX		0b01001
+#define N_DST_UART2_TX		0b01010
+#define N_DST_UART3_TX		0b01011
+#define N_DST_UART4_TX		0b01100
+#define N_DST_UART5_TX		0b01101
+#define N_DST_UART6_TX		0b01110
+#define N_DST_UART7_TX		0b01111
+#define N_DST_HDMI_DDC_TX	0b10000
+#define N_DST_USB_EP1		0b10001
+/* resv: 1 */
+#define N_DST_AUDIO_CODEC_DA	0b10011
+/* resv: 1 */
+#define N_DST_SRAM		0b10101
+#define N_DST_SDRAM		0b10110
+#define N_DST_TP_AD		0b10111
+#define N_DST_SPI0_TX		0b11000
+#define N_DST_SPI1_TX		0b11001
+#define N_DST_SPI2_TX		0b11010
+#define N_DST_SPI3_TX		0b11011
+#define N_DST_USB_EP2		0b11100
+#define N_DST_USB_EP3		0b11101
+#define N_DST_USB_EP4		0b11110
+#define N_DST_USB_EP5		0b11111
+
+/* dedicate channel src drq type */
+#define D_SRC_SRAM		0b00000
+#define D_SRC_SDRAM		0b00001
+/* resv: 1 */
+#define D_SRC_NAND		0b00011
+#define D_SRC_USB0		0b00100
+/* resv: 2 */
+#define D_SRC_EMAC_RX		0b00111
+/* resv: 1 */
+#define D_SRC_SPI1_RX		0b01001
+/* resv: 1 */
+#define D_SRC_SS_RX		0b01011 /* security system rx */
+/* resv: 15 */
+#define D_SRC_SPI0_RX		0b11011
+/* resv: 1 */
+#define D_SRC_SPI2_RX		0b11101
+/* resv: 1 */
+#define D_SRC_SPI3_RX		0b11111
+
+/* dedicate channel dst drq type */
+#define D_DST_SRAM		0b00000
+#define D_DST_SDRAM		0b00001
+/* resv: 1 */
+#define D_DST_NAND		0b00011
+#define D_DST_USB0		0b00100
+/* resv: 1 */
+#define D_DST_EMAC_TX		0b00110
+/* resv: 1 */
+#define D_DST_SPI1_TX		0b01000
+/* resv: 1 */
+#define D_DST_SS_TX		0b01010 /* security system tx */
+/* resv: 3 */
+#define D_DST_TCON0		0b01110
+#define D_DST_TCON1		0b01111
+/* resv: 7 */
+#define D_DST_MSC		0b10111
+#define D_DST_HDMI_AUD		0b11000
+/* resv: 1 */
+#define D_DST_SPI0_TX		0b11010
+/* resv: 1 */
+#define D_DST_SPI2_TX		0b11100
+/* resv: 1 */
+#define D_DST_SPI3_TX		0b11110
+/* resv: 1 */
+
+/* security define */
+#define SRC_SECU_DST_SECU		0
+#define SRC_SECU_DST_NON_SECU		1
+#define SRC_NON_SECU_DST_SECU		2
+#define SRC_NON_SECU_DST_NON_SECU	3
+
+/* dma config para */
+typedef struct {
+	/*
+	 * paras for dma ctrl reg
+	 */
+	xferunit_t	xfer_type;	/* dsta width and burst length */
+	addrtype_t	address_type;	/* address type */
+	bool		bconti_mode;	/* continue mode, true is continue mode, false not */
+	u8		src_drq_type;	/* src drq type */
+	u8		dst_drq_type;	/* dst drq type */
+	/*
+	 * other paras
+	 */
+	u32 		irq_spt;	/* channel irq supported, eg: CHAN_IRQ_HD | CHAN_IRQ_FD */
+	/*
+	 * these not always need set, so move to sw_dma_ctl
+	 */
+	//u8 		src_secu;	/* dma src security, 0: secure, 1: non-secure */
+	//u8 		dst_secu;	/* dma dst security, 0: secure, 1: non-secure */
+	//u16		wait_state;	/* for normal dma only */
+	//dma_para_t	para;		/* dma para reg */
+}dma_config_t;
+
+/* dma operation type */
+typedef enum {
+	DMA_OP_START,  			/* start dma */
+	DMA_OP_STOP,  			/* stop dma */
+	DMA_OP_GET_BYTECNT_LEFT,  	/* get byte cnt left */
+	DMA_OP_SET_SECURITY,  		/* set security */
+	DMA_OP_SET_HD_CB,		/* set half done callback */
+	DMA_OP_SET_FD_CB,		/* set full done callback */
+	/*
+	 * only for dedicate dma below
+	 */
+	DMA_OP_GET_STATUS,  		/* get channel status: idle/busy */
+	DMA_OP_SET_PARA_REG,  		/* set para reg */
+	/*
+	 * only for normal dma below
+	 */
+	DMA_OP_SET_WAIT_STATE,  	/* set wait state status, 0~7 */
+}dma_op_type_e;
+
+/* dma handle type defination */
+typedef void * dma_hdl_t;
+
+/* irq callback func defination */
+typedef void (* dma_cb)(dma_hdl_t dma_hdl, void *parg);
+
+/* dma callback struct */
+typedef struct {
+	dma_cb 		func;	/* callback fuction */
+	void 		*parg;	/* args of func */
+}dma_cb_t;
+
+/* dma channel type */
+typedef enum {
+	CHAN_NORMAL,		/* normal channel, id 0~7 */
+	CHAN_DEDICATE,		/* dedicate channel, id 8~15 */
+}dma_chan_type_e;
+
+/* dma export fuction */
+dma_hdl_t sw_dma_request(char * name, dma_chan_type_e type);
+u32 sw_dma_release(dma_hdl_t dma_hdl);
+u32 sw_dma_enqueue(dma_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt);
+u32 sw_dma_config(dma_hdl_t dma_hdl, dma_config_t *pcfg);
+u32 sw_dma_ctl(dma_hdl_t dma_hdl, dma_op_type_e op, void *parg);
+int sw_dma_getposition(dma_hdl_t dma_hdl, u32 *psrc, u32 *pdst);
+void sw_dma_dump_chan(dma_hdl_t dma_hdl);
+
+#endif /* __SW_DMA_H */
+
diff --git a/arch/arm/mach-sun7i/include/mach/dram.h b/arch/arm/mach-sun7i/include/mach/dram.h
new file mode 100755
index 0000000..ec8b127
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/dram.h
@@ -0,0 +1,116 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/dram.h
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Kevin <kevin@reuuimllatech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __DRAM_H__
+#define __DRAM_H__
+
+#include <linux/kernel.h>
+
+struct dram_para_t
+{
+    unsigned int    dram_baseaddr;
+    unsigned int    dram_clk;
+    unsigned int    dram_type;
+    unsigned int    dram_rank_num;
+    unsigned int    dram_chip_density;
+    unsigned int    dram_io_width;
+    unsigned int    dram_bus_width;
+    unsigned int    dram_cas;
+    unsigned int    dram_zq;
+    unsigned int    dram_odt_en;
+    unsigned int    dram_size;
+    unsigned int    dram_tpr0;
+    unsigned int    dram_tpr1;
+    unsigned int    dram_tpr2;
+    unsigned int    dram_tpr3;
+    unsigned int    dram_tpr4;
+    unsigned int    dram_tpr5;
+    unsigned int    dram_emr1;
+    unsigned int    dram_emr2;
+    unsigned int    dram_emr3;
+};
+
+int dram_init(void);
+int dram_exit(void);
+int dram_get_size(void);
+void dram_set_clock(int clk);
+void dram_set_drive(void);
+void dram_set_autorefresh_cycle(unsigned int clk);
+int  dram_scan_readpipe(void);
+void dram_enter_selfrefresh(void);
+void dram_exit_selfrefresh(void);
+void dram_enter_power_down(void);
+void dram_exit_power_down(void);
+void dram_hostport_on_off(unsigned int port_idx, unsigned int on);
+unsigned int dram_hostport_check_ahb_fifo_status(unsigned int port_idx);
+void dram_hostport_setup(unsigned int port, unsigned int prio, unsigned int wait_cycle, unsigned int cmd_num);
+int dram_power_save_process(int standby_mode);
+unsigned int dram_power_up_process(void);
+
+
+#if defined(CONFIG_ARCH_SUN4I)
+    #define HOST_PORT_SIZE 21
+#elif defined(CONFIG_ARCH_SUN5I) || defined(CONFIG_ARCH_SUN7I)
+    #define HOST_PORT_SIZE 14
+#endif
+
+#define DRAM_HOST_CFG_BASE  (SW_VA_DRAM_IO_BASE + 0x250)
+#define DRAM_HOST_CFG_PORT  ((__dram_host_cfg_reg_t *)(DRAM_HOST_CFG_BASE + 4*port))
+
+#define HOST_PORT_ATTR(_name)       \
+{									\
+	.attr = { .name = #_name,.mode = 0644 },    \
+	.show =  _name##_show,          \
+	.store = _name##_store,         \
+}
+
+typedef struct __DRAM_HOST_CFG_REG{
+    unsigned int    AcsEn:1;    //bit0, host port access enable
+    unsigned int    reserved0:1;    //bit1
+    unsigned int    PrioLevel:2;    //bit2, host port poriority level
+    unsigned int    WaitState:4;    //bit4, host port wait state
+    unsigned int    CmdNum:8;       //bit8, host port command number
+    unsigned int    reserved1:14;   //bit16
+    unsigned int    WrCntEn:1;      //bit30, host port write counter enable
+    unsigned int    RdCntEn:1;      //bit31, host port read counter enable
+} __dram_host_cfg_reg_t;
+
+typedef enum __DRAM_HOST_PORT{
+    DRAM_HOST_CPU   = 16,
+    DRAM_HOST_GPU   = 17,
+    DRAM_HOST_BE    = 18,
+    DRAM_HOST_FE    = 19,
+    DRAM_HOST_CSI   = 20,
+    DRAM_HOST_TSDM  = 21,
+    DRAM_HOST_VE    = 22,
+    DRAM_HOST_USB1  = 24,
+    DRAM_HOST_NDMA  = 25,
+    DRAM_HOST_ATH   = 26,
+    DRAM_HOST_IEP   = 27,
+    DRAM_HOST_SDHC  = 28,
+    DRAM_HOST_DDMA  = 29,
+    DRAM_HOST_GPS   = 30,
+} __dram_host_port_e;
+
+
+int dram_host_port_cmd_num_set(__dram_host_port_e port, unsigned int num);
+int dram_host_port_cmd_num_get(__dram_host_port_e port);
+int dram_host_port_wait_state_set(__dram_host_port_e port, unsigned int state);
+int dram_host_port_wait_state_get(__dram_host_port_e port);
+int dram_host_port_prio_level_set(__dram_host_port_e port, unsigned int level);
+int dram_host_port_prio_level_get(__dram_host_port_e port);
+int dram_host_port_acs_enable(__dram_host_port_e port);
+int dram_host_port_acs_disable(__dram_host_port_e port);
+int dram_host_port_acs_get(__dram_host_port_e port);
+
+#endif  /* __DRAM_H__ */
+
diff --git a/arch/arm/mach-sun7i/include/mach/entry-macro.S b/arch/arm/mach-sun7i/include/mach/entry-macro.S
new file mode 100755
index 0000000..d590649
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/entry-macro.S
@@ -0,0 +1,17 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for sun7i platforms
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
diff --git a/arch/arm/mach-sun7i/include/mach/gpio.h b/arch/arm/mach-sun7i/include/mach/gpio.h
new file mode 100644
index 0000000..f498f63
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/gpio.h
@@ -0,0 +1,4 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/gpio.h
+ */
+#include <plat/gpio.h>
diff --git a/arch/arm/mach-sun7i/include/mach/hardware.h b/arch/arm/mach-sun7i/include/mach/hardware.h
new file mode 100644
index 0000000..8d1850f
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/hardware.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/hardware.h
+ */
+
+#include <plat/hardware.h>
diff --git a/arch/arm/mach-sun7i/include/mach/i2c.h b/arch/arm/mach-sun7i/include/mach/i2c.h
new file mode 100755
index 0000000..f8eb227
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/i2c.h
@@ -0,0 +1,202 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/i2c.h
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ *
+ * SUN7I TWI Register Definition
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <mach/platform.h>
+
+#ifndef _SUN7I_I2C_H_
+#define _SUN7I_I2C_H_
+
+#define TWI_MODULE_NUM                  (5)
+
+/* TWI Register Offset */
+#define TWI_ADDR_REG    	        (0x00) 	/*  31:8bit reserved,7-1bit for slave addr,0 bit for GCE */
+#define TWI_XADDR_REG   	        (0x04) 	/*  31:8bit reserved,7-0bit for second addr in 10bit addr */
+#define TWI_DATA_REG    	        (0x08) 	/*  31:8bit reserved, 7-0bit send or receive data byte */
+#define TWI_CTL_REG     	        (0x0C) 	/*  INT_EN,BUS_EN,M_STA,INT_FLAG,A_ACK */
+#define TWI_STAT_REG    	        (0x10) 	/*  28 interrupt types + 0xF8 normal type = 29  */
+#define TWI_CLK_REG     	        (0x14) 	/*  31:7bit reserved,6-3bit,CLK_M,2-0bit CLK_N */
+#define TWI_SRST_REG    	        (0x18) 	/*  31:1bit reserved;0bit,write 1 to clear 0. */
+#define TWI_EFR_REG     	        (0x1C) 	/*  31:2bit reserved,1:0 bit data byte follow read comand */
+#define TWI_LCR_REG     	        (0x20) 	/*  31:6bits reserved  5:0bit for sda&scl control*/
+#define TWI_DVFS_REG                    (0x24)  /*  31:3bits reserved  2:0bit for dvfs control */
+
+/* TWI address register */
+#define TWI_GCE_EN      	        (0x1 <<0) /* general call address enable for slave mode */
+#define TWI_ADDR_MASK   	        (0x7f<<1) /* 7:1bits */
+/* 31:8bits reserved */
+
+
+/* TWI extend address register */
+#define TWI_XADDR_MASK                  (0xff) /* 7:0bits for extend slave address */
+/* 31:8bits reserved */
+
+
+/* TWI Data register default is 0x0000_0000 */
+#define TWI_DATA_MASK                   (0xff) /* 7:0bits for send or received */
+
+/* TWI Control Register Bit Fields & Masks, default value: 0x0000_0000*/
+/* 1:0 bits reserved */
+#define TWI_CTL_ACK		        (0x1<<2) /* set 1 to send A_ACK,then low level on SDA */
+#define TWI_CTL_INTFLG	                (0x1<<3) /* INT_FLAG,interrupt status flag: set '1' when interrupt coming */
+#define TWI_CTL_STP		        (0x1<<4) /* M_STP,Automatic clear 0 */
+#define TWI_CTL_STA		        (0x1<<5) /* M_STA,atutomatic clear 0 */
+#define TWI_CTL_BUSEN	                (0x1<<6) /* BUS_EN, master mode should be set 1.*/
+#define TWI_CTL_INTEN	                (0x1<<7) /* INT_EN */
+/* 31:8 bit reserved */
+
+
+/* TWI Clock Register Bit Fields & Masks,default value:0x0000_0000 */
+/*
+Fin is APB CLOCK INPUT;
+Fsample = F0 = Fin/2^CLK_N; 
+          F1 = F0/(CLK_M+1);
+          
+Foscl = F1/10 = Fin/(2^CLK_N * (CLK_M+1)*10); 
+Foscl is clock SCL;standard mode:100KHz or fast mode:400KHz        
+*/
+#define TWI_CLK_DIV_M		        (0xF<<3) /* 6:3bit  */
+#define TWI_CLK_DIV_N		        (0x7<<0) /* 2:0bit */
+
+
+/* TWI Soft Reset Register Bit Fields & Masks  */
+#define TWI_SRST_SRST		        (0x1<<0) /* write 1 to clear 0, when complete soft reset clear 0 */
+
+
+/* TWI Enhance Feature Register Bit Fields & Masks  */
+/* default -- 0x0 */
+#define TWI_EFR_MASK                    (0x3<<0)/* 00:no,01: 1byte, 10:2 bytes, 11: 3bytes */
+#define TWI_EFR_WARC_0                  (0x0<<0)
+#define TWI_EFR_WARC_1                  (0x1<<0)
+#define TWI_EFR_WARC_2                  (0x2<<0)
+#define TWI_EFR_WARC_3                  (0x3<<0)
+
+
+/* twi line control register -default value: 0x0000_003a */
+#define TWI_LCR_SDA_EN                  (0x01<<0) 	/* SDA line state control enable ,1:enable;0:disable */
+#define TWI_LCR_SDA_CTL                 (0x01<<1) 	/* SDA line state control bit, 1:high level;0:low level */
+#define TWI_LCR_SCL_EN                  (0x01<<2) 	/* SCL line state control enable ,1:enable;0:disable */
+#define TWI_LCR_SCL_CTL                 (0x01<<3) 	/* SCL line state control bit, 1:high level;0:low level */
+#define TWI_LCR_SDA_STATE_MASK          (0x01<<4)   /* current state of SDA,readonly bit */
+#define TWI_LCR_SCL_STATE_MASK          (0x01<<5)   /* current state of SCL,readonly bit */
+/* 31:6bits reserved */
+#define TWI_LCR_IDLE_STATUS             (0x3a)
+
+
+/* TWI Status Register Bit Fields & Masks  */
+#define TWI_STAT_MASK                   (0xff)
+/* 7:0 bits use only,default is 0xF8 */
+#define TWI_STAT_BUS_ERR                (0x00) 	/* BUS ERROR */
+/* Master mode use only */
+#define TWI_STAT_TX_STA	                (0x08) 	/* START condition transmitted */
+#define TWI_STAT_TX_RESTA               (0x10) 	/* Repeated START condition transmitted */
+#define TWI_STAT_TX_AW_ACK              (0x18) 	/* Address+Write bit transmitted, ACK received */
+#define TWI_STAT_TX_AW_NAK              (0x20) 	/* Address+Write bit transmitted, ACK not received */
+#define TWI_STAT_TXD_ACK                (0x28) 	/* data byte transmitted in master mode,ack received */
+#define TWI_STAT_TXD_NAK                (0x30) 	/* data byte transmitted in master mode ,ack not received */
+#define TWI_STAT_ARBLOST                (0x38) 	/* arbitration lost in address or data byte */
+#define TWI_STAT_TX_AR_ACK              (0x40) 	/* Address+Read bit transmitted, ACK received */
+#define TWI_STAT_TX_AR_NAK              (0x48) 	/* Address+Read bit transmitted, ACK not received */
+#define TWI_STAT_RXD_ACK                (0x50) 	/* data byte received in master mode ,ack transmitted */
+#define TWI_STAT_RXD_NAK                (0x58) 	/* date byte received in master mode,not ack transmitted */
+/* Slave mode use only */
+#define TWI_STAT_RXWS_ACK               (0x60) 	/* Slave address+Write bit received, ACK transmitted */
+#define TWI_STAT_ARBLOST_RXWS_ACK       (0x68)
+#define TWI_STAT_RXGCAS_ACK             (0x70) 	/* General Call address received, ACK transmitted */
+#define TWI_STAT_ARBLOST_RXGCAS_ACK     (0x78)
+#define TWI_STAT_RXDS_ACK               (0x80)
+#define TWI_STAT_RXDS_NAK               (0x88)
+#define TWI_STAT_RXDGCAS_ACK            (0x90)
+#define TWI_STAT_RXDGCAS_NAK            (0x98)
+#define TWI_STAT_RXSTPS_RXRESTAS        (0xA0)
+#define TWI_STAT_RXRS_ACK               (0xA8)
+
+#define TWI_STAT_ARBLOST_SLAR_ACK       (0xB0)
+
+/* 10bit Address, second part of address */
+#define TWI_STAT_TX_SAW_ACK             (0xD0) 	/* Second Address byte+Write bit transmitted,ACK received */
+#define TWI_STAT_TX_SAW_NAK             (0xD8) 	/* Second Address byte+Write bit transmitted,ACK not received */
+
+#define TWI_STAT_IDLE	                (0xF8) 	/* No relevant status infomation,INT_FLAG = 0 */
+
+
+/* status or interrupt source */
+/*------------------------------------------------------------------------------
+* Code   Status
+* 00h    Bus error
+* 08h    START condition transmitted
+* 10h    Repeated START condition transmitted
+* 18h    Address + Write bit transmitted, ACK received
+* 20h    Address + Write bit transmitted, ACK not received
+* 28h    Data byte transmitted in master mode, ACK received
+* 30h    Data byte transmitted in master mode, ACK not received
+* 38h    Arbitration lost in address or data byte
+* 40h    Address + Read bit transmitted, ACK received
+* 48h    Address + Read bit transmitted, ACK not received
+* 50h    Data byte received in master mode, ACK transmitted
+* 58h    Data byte received in master mode, not ACK transmitted
+* 60h    Slave address + Write bit received, ACK transmitted
+* 68h    Arbitration lost in address as master, slave address + Write bit received, ACK transmitted
+* 70h    General Call address received, ACK transmitted
+* 78h    Arbitration lost in address as master, General Call address received, ACK transmitted
+* 80h    Data byte received after slave address received, ACK transmitted
+* 88h    Data byte received after slave address received, not ACK transmitted
+* 90h    Data byte received after General Call received, ACK transmitted
+* 98h    Data byte received after General Call received, not ACK transmitted
+* A0h    STOP or repeated START condition received in slave mode
+* A8h    Slave address + Read bit received, ACK transmitted
+* B0h    Arbitration lost in address as master, slave address + Read bit received, ACK transmitted
+* B8h    Data byte transmitted in slave mode, ACK received
+* C0h    Data byte transmitted in slave mode, ACK not received
+* C8h    Last byte transmitted in slave mode, ACK received
+* D0h    Second Address byte + Write bit transmitted, ACK received
+* D8h    Second Address byte + Write bit transmitted, ACK not received
+* F8h    No relevant status information or no interrupt
+*-----------------------------------------------------------------------------*/
+
+/* TWI mode select */
+#define TWI_MASTER_MODE                 (1)
+#define TWI_SLAVE_MODE                  (0)	/* seldom use */
+
+#define SUN7I_TWI_ADDR_SIZE		0x3FF
+
+#define TWI0_BASE_ADDR_START  (SW_PA_TWI0_IO_BASE )
+#define TWI0_BASE_ADDR_END    (TWI0_BASE_ADDR_START + SUN7I_TWI_ADDR_SIZE)
+
+#define TWI1_BASE_ADDR_START  (SW_PA_TWI1_IO_BASE )
+#define TWI1_BASE_ADDR_END    (TWI1_BASE_ADDR_START + SUN7I_TWI_ADDR_SIZE)
+
+#define TWI2_BASE_ADDR_START  (SW_PA_TWI2_IO_BASE )
+#define TWI2_BASE_ADDR_END    (TWI2_BASE_ADDR_START + SUN7I_TWI_ADDR_SIZE)
+
+#define TWI3_BASE_ADDR_START  (SW_PA_TWI3_IO_BASE )
+#define TWI3_BASE_ADDR_END    (TWI3_BASE_ADDR_START + SUN7I_TWI_ADDR_SIZE)
+
+#define TWI4_BASE_ADDR_START  (SW_PA_TWI4_IO_BASE )
+#define TWI4_BASE_ADDR_END    (TWI4_BASE_ADDR_START + SUN7I_TWI_ADDR_SIZE)
+
+#define TWI0_TRANSFER_SPEED     (200000)
+#define TWI1_TRANSFER_SPEED     (200000)
+#define TWI2_TRANSFER_SPEED     (400000)
+#define TWI3_TRANSFER_SPEED     (200000)
+#define TWI4_TRANSFER_SPEED     (200000)
+
+
+#define SUN7I_IRQ_TWI0	34
+
+
+struct sun7i_i2c_platform_data {
+	int 		 bus_num;
+	unsigned int frequency;
+};
+
+#endif
diff --git a/arch/arm/mach-sun7i/include/mach/includes.h b/arch/arm/mach-sun7i/include/mach/includes.h
new file mode 100755
index 0000000..a85c326
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/includes.h
@@ -0,0 +1,43 @@
+/*
+ *  arch/arm/mach-sun7i/include/mach/includes.h
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * liugang (liugang@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __SUN7I_MACH_INCLUDES_H
+#define __SUN7I_MACH_INCLUDES_H
+
+#include "hardware.h"
+#include "memory.h"
+#include "platform.h"
+#include "system.h"
+#include "dram.h"
+
+#include "ar100_cp.h"
+#include "ccmu.h"
+#include "clock.h"
+#include "dma.h"
+#include "gpio.h"
+#include "i2c.h"
+#include "io.h"
+#include "irqs.h"
+#include "spi.h"
+#include "sunxi_dump_reg.h"
+#include "uart.h"
+
+#endif /* __SUN7I_MACH_INCLUDES_H */
+
diff --git a/arch/arm/mach-sun7i/include/mach/io.h b/arch/arm/mach-sun7i/include/mach/io.h
new file mode 100644
index 0000000..448d15f
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/io.h
@@ -0,0 +1,29 @@
+/*
+ *  arch/arm/mach-sun7i/include/mach/io.h
+ *
+ *  Copyright (C) 2012-2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		__typesafe_io(a)
+#define __mem_pci(a)	(a)
+
+#endif
diff --git a/arch/arm/mach-sun7i/include/mach/irqs.h b/arch/arm/mach-sun7i/include/mach/irqs.h
new file mode 100644
index 0000000..bfa74d7
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/irqs.h
@@ -0,0 +1,33 @@
+/*
+ *  arch/arm/mach-sun7i/include/mach/irqs.h
+ *
+ *  Copyright (C) 2012-2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __MACH_IRQS_H__
+#define __MACH_IRQS_H__
+
+#include <plat/irqs.h>
+
+#define IRQ_GIC_START AW_IRQ_GIC_START
+
+#ifndef NR_IRQS
+#error "NR_IRQS not defined by the board-specific files"
+#endif
+
+#endif /* __MACH_IRQS_H__ */
diff --git a/arch/arm/mach-sun7i/include/mach/memory.h b/arch/arm/mach-sun7i/include/mach/memory.h
new file mode 100755
index 0000000..339a55b
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/memory.h
@@ -0,0 +1,25 @@
+/*
+ *  arch/arm/mach-sun7i/include/mach/memory.h
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __MACH_MEMORY_H
+#define __MACH_MEMORY_H
+
+#include <plat/memory.h>
+#endif
diff --git a/arch/arm/mach-sun7i/include/mach/platform.h b/arch/arm/mach-sun7i/include/mach/platform.h
new file mode 100644
index 0000000..c4f647e
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/platform.h
@@ -0,0 +1,4 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/platform.h
+ */
+#include <plat/platform.h>
diff --git a/arch/arm/mach-sun7i/include/mach/spi.h b/arch/arm/mach-sun7i/include/mach/spi.h
new file mode 100644
index 0000000..9251b06
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/spi.h
@@ -0,0 +1,234 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/spi.h
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ * James Deng <csjamesdeng@reuuimllatech.com>
+ *
+ * SUN7I SPI Register Definition
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef _SUN7I_SPI_H_
+#define _SUN7I_SPI_H_
+
+#define SPI_MODULE_NUM      (4)
+#define SPI_FIFO_DEPTH      (64)
+
+#define SPI0_BASE_ADDR      (0x01C05000)
+#define SPI1_BASE_ADDR      (0x01C06000)
+#define SPI2_BASE_ADDR      (0x01C17000)
+#define SPI3_BASE_ADDR      (0x01C1f000)
+
+/* SPI Registers offsets from peripheral base address */
+#define SPI_RXDATA_REG          (0x00) /* rx data register */
+#define SPI_TXDATA_REG          (0x04) /* tx data register */
+#define SPI_CTL_REG             (0x08) /* control register */
+#define SPI_INT_CTL_REG         (0x0C) /* interrupt control register */
+#define SPI_STATUS_REG          (0x10) /* status register */
+#define SPI_DMA_CTL_REG         (0x14) /* dma control register */
+#define SPI_WAIT_REG            (0x18) /* wait clock counter register */
+#define SPI_CLK_RATE_REG        (0x1C) /* clock rate control register */
+#define SPI_BC_REG              (0x20) /* burst counter register   */
+#define SPI_TC_REG              (0x24) /* transmit counter register */
+#define SPI_FIFO_STA_REG        (0x28) /* fifo status register */
+
+/* SPI Rx data register,default value: 0x0000_0000 */
+/* readonly
+ * 8-bits: accessed in   byte    rxFIFO decreased by 1.
+ *         accessed in half-word rxFIFO decreased by 2.
+ *         accessed in   word    rxFIFO decreased by 4.
+ */
+/* SPI Tx data register,default value: 0x0000_0000 */
+/* write only
+ * same as Rx data register
+ */
+
+/* SPI Control Register Bit Fields & Masks,defualt value:0x0002_001C */
+#define SPI_CTL_EN          (0x1 << 0)  /* SPI module enable control 1:enable;0:disable;default:0 */
+#define SPI_CTL_FUNC_MODE   (0x1 << 1)  /* SPI function mode select 1:master;0:slave;default:0 */
+/* default work mode3: pol = 1,pha = 1; */
+#define SPI_CTL_PHA         (0x1 << 2)  /* SPI Clock polarity control,  0: phase0,1: phase1;default:1  */
+#define SPI_CTL_POL         (0x1 << 3)  /* SPI Clock/Data phase control,0:low level idle,1:high level idle;default:1 */
+#define SPI_POL_PHA_BIT_POS (2)
+
+#define SPI_CTL_SSPOL       (0x1 << 4)  /* SPI Chip select signal polarity control,default: 1,low effective like this:~~|_____~~ */
+#define SPI_CTL_DMAMOD      (0x1 << 5)  /* SPI dma mode select: 0-NDMA,1-DDMA */
+#define SPI_CTL_LMTF        (0x1 << 6)  /* LSB/MSB transfer first select 0:MSB,1:LSB,default 0:MSB first */
+#define SPI_CTL_SSCTL       (0x1 << 7)  /* SPI chip select control,default 0:SPI_SSx remains asserted between SPI bursts,1:negate SPI_SSx between SPI bursts */
+#define SPI_CTL_RST_TXFIFO  (0x1 << 8)  /* SPI reset rxFIFO write 1 automatic clear 0*/
+#define SPI_CTL_RST_RXFIFO  (0x1 << 9)  /* SPI reset txFIFO write 1 automatic clear 0*/
+#define SPI_CTL_XCH         (0x1 << 10) /* Exchange burst default 0:idle,1:start exchange;when BC is zero,this bit cleared by SPI controller*/
+#define SPI_CTL_RAPIDS      (0x1 << 11) /* Rapids transfer mode */ // modified by yemao, for aw1623, define as below, 2011-5-27 14:02:58
+
+#define SPI_CTL_SS_MASK     (0x3 << 12) /* SPI chip select:00-SPI_SS0;01-SPI_SS1;10-SPI_SS2;11-SPI_SS3*/
+#define SPI_SS_BIT_POS      (12)
+
+#define SPI_CTL_DDB         (0x1 << 14) /* Dummy burst Type,default 0: dummy spi burst is zero;1:dummy spi burst is one */
+#define SPI_CTL_DHB         (0x1 << 15) /* Discard Hash Burst,default 0:receiving all spi burst in BC period 1:discard unused,fectch WTC bursts */
+
+#define SPI_CTL_SS_CTRL     (0x1 << 16) /* SS output mode select default is 0:automatic output SS;1:manual output SS */
+#define SPI_CTL_SS_LEVEL    (0x1 << 17) /* defautl is 1:set SS to high;0:set SS to low */
+
+#define SPI_CTL_T_PAUSE_EN  (0x1 << 18) /* Transmit Pause Enable;Master mode: 1-stop when RXFIFO full;0-ignore rxFIFO */
+#define SPI_CTL_MASTER_SDC  (0x1 << 19) /* master sample data control, 1: delay--high speed operation;0:no delay. */
+#define SPI_CTL_MASTER_SDM  (0x1 << 20) /* master sample data mode, 1: normal sample mode; 0:delay sample mode */
+/* aw1620 control register 31-20bit reserved bit */
+
+/* SPI Interrupt Register Bit Fields & Masks,default value:0x0000_0000 */
+#define SPI_INTEN_RR        (0x1 << 0)  /* rxFIFO Ready Interrupt Enable,---used for immediately received,0:disable;1:enable */
+#define SPI_INTEN_RH        (0x1 << 1)  /* rxFIFO Half Full Interrupt Enable ---used for IRQ received */
+#define SPI_INTEN_RF        (0x1 << 2)  /* rxFIFO Full Interrupt Enable ---seldom used */
+#define SPI_INTEN_QTR_RF    (0x1 << 3)  /* rxFIFO 1/4 Full Interrupt Enable */
+#define SPI_INTEN_3QTR_RF   (0x1 << 4)  /* rxFIFO 3/4 Full Interrupt Enable */
+#define SPI_INTEN_RO        (0x1 << 5)  /* rxFIFO Overflow Interrupt Enable ---used for error detect */
+#define SPI_INTEN_RU        (0x1 << 6)  /* rxFIFO Underrun Interrupt Enable ---used for error detect */
+/* 7 bit reserved */
+
+#define SPI_INTEN_TE        (0x1 << 8)  /* txFIFO Empty Interrupt Enable ---seldom used */
+#define SPI_INTEN_TH        (0x1 << 9)  /* txFIFO Half Empty Interrupt Enable ---used  for IRQ tx */
+#define SPI_INTEN_TF        (0x1 << 10) /* txFIFO Full Interrupt Enable ---seldom used */
+#define SPI_INTEN_QTR_TE    (0x1 << 11) /* txFIFO FIFO 1/4 Empty Interrupt Enable;0-disable;1-enable */
+#define SPI_INTEN_3QTR_TE   (0x1 << 12) /* txFIFO FIFO 3/4 Empty Interrupt Enable;0-disable;1-enable */
+#define SPI_INTEN_TO        (0x1 << 13) /* txFIFO Overflow Interrupt Enable ---used for error detect */
+#define SPI_INTEN_TU        (0x1 << 14) /* txFIFO Underrun Interrupt Enable ---not happened */
+/* 15 bit reserved */
+
+#define SPI_INTEN_TC        (0x1 << 16) /* Transfer Completed Interrupt Enable  ---used */
+#define SPI_INTEN_SSI       (0x1 << 17) /* SSI interrupt Enable,chip select from valid state to invalid state,for slave used only */
+/* 31:18 bit reserved */
+#define SPI_INTEN_ERR       (SPI_INTEN_TO|SPI_INTEN_RU|SPI_INTEN_RO) //NO txFIFO underrun
+#define SPI_INTEN_MASK      (0x7f|(0x7f<<8)|(0x3<<16))
+
+/* SPI Status Register Bit Fields & Masks,default value:0x0000_1B00 all bits are written 1 to clear 0 */
+#define SPI_STAT_RR         (0x1 << 0)  /* rxFIFO ready, 0:no valid data;1:more than 1 word in rxfifo */
+#define SPI_STAT_RHF        (0x1 << 1)  /* rxFIFO half full,0:less than 4 words;1:four or more than 4 words in rxfifo */
+#define SPI_STAT_RF         (0x1 << 2)  /* rxFIFO full,0:not full;1:full */
+#define SPI_STAT_QTR_RF     (0x1 << 3)  /* rxFIFO 1/4 Full, 0:not 1/4 full;1:1/4 full */
+#define SPI_STAT_3QTR_RF    (0x1 << 4)  /* rxFIFO 3/4 Full, 0:not 1/4 full;1:1/4 full */
+#define SPI_STAT_RO         (0x1 << 5)  /* rxFIFO overflow, 0: rxfifo is available;1:rxfifo has overflowed! */
+#define SPI_STAT_RU         (0x1 << 6)  /* rxFIFO underrun,fectch data with no data available in FIFO */
+/* 7bit reserved */
+
+#define SPI_STAT_TE         (0x1 << 8)  /* txFIFO empty,0:txfifo contains one or more words;1:txfifo is empty.default value:1 */
+#define SPI_STAT_THE        (0x1 << 9)  /* txFIFO half empty,0:more than half words;1: half or fewer words.defualt value: 1 */
+#define SPI_STAT_TF         (0x1 << 10) /* txFIFO Full */
+#define SPI_STAT_QTR_TE     (0x1 << 11) /* txFIFO 1/4 empty.default is 1:more than 1/4 empty */
+#define SPI_STAT_3QTR_TE    (0x1 << 12) /* txFIFO 3/4 empty.default is 1:more than 3/4 empty */
+#define SPI_STAT_TO         (0x1 << 13) /* txFIFO overflow 0:not overflow;1:overflow */
+#define SPI_STAT_TU         (0x1 << 14) /* txFIFO underrun 0:not underrun;1:undrrun */
+/* 15bit reserved */
+
+#define SPI_STAT_TC         (0x1 << 16) /* Transfer Complete, 0:BUSY;1:transfer completed */
+#define SPI_STAT_SSI        (0x1 << 17) /* SS Invalid Interrupt ,for slave used only */
+/* 31-18bits reserved */
+#define SPI_STAT_MASK       (0x7f|(0x7f<<8)|(0x3<<16))
+
+#define SPI_STAT_ERR        (SPI_STAT_TO|SPI_STAT_RU|SPI_STAT_RO) //Slave mode,no SPI_STAT_TU
+
+/* SPI DMA Control Register Bit Fields & Masks defuatl:0x0000_0000 */
+#define SPI_DRQEN_RR        (0x1 << 0)  /* rxFIFO Ready DMA Request Enable,when one or more than one words in RXFIFO */
+#define SPI_DRQEN_RHF       (0x1 << 1)  /* rXFIFO Half Full DMA Request Enable,when 4 or more than 4 words in RXFIFO */
+#define SPI_DRQEN_RF        (0x1 << 2)  /* rxFIFO Full DMA Request Enable */
+#define SPI_DRQEN_QTR_RF    (0x1 << 3)  /* rxFIFO 1/4 Full DMA Request Enable */
+#define SPI_DRQEN_3QTR_RF   (0x1 << 4)  /* rxFIFO 3/4 Full DMA Request Enable */
+/* 7:5 bit reserved */
+
+#define SPI_DRQEN_TE        (0x1 << 8)  /* txFIFO Empty DMA Request Enable,when no words in TXFIFO */
+#define SPI_DRQEN_THE       (0x1 << 9)  /* txFIFO Half Empty DMA Request Enable,when 4 or less than 4 words in TXFIFO */
+#define SPI_DRQEN_TNF       (0x1 << 10) /* txFIFO Not Full DMA Request Enable,asserted when more than one free room for burst */
+#define SPI_DRQEN_QTR_TE    (0x1 << 11) /* txFIFO 1/4 Empty DMA Request Enable */
+#define SPI_DRQEN_3QTR_TE   (0x1 << 12) /* txFIFO 3/4 Empty DMA Request Enable */
+/* 31:13 bits reserved */
+#define SPI_DRQEN_MASK      (0x1f|(0x1f<<8))
+
+
+/* SPI Wait Clock Register Bit Fields & Masks,default value:0x0000_0000 */
+#define SPI_WAIT_CLK_MASK   (0xFFFF << 0)   /* used only in master mode: Wait Between Transactions */
+/* 31:16bit reserved */
+
+
+/* SPI Wait Clock Register Bit Fields & Masks,default:0x0000_0002 */
+#define SPI_CLKCTL_CDR2     (0xFF << 0)  /* Clock Divide Rate 2,master mode only : SPI_CLK = AHB_CLK/(2*(n+1)) */
+#define SPI_CLKCTL_CDR1     (0xF  << 8)  /* Clock Divide Rate 1,master mode only : SPI_CLK = AHB_CLK/2^(n+1) */
+#define SPI_CLKCTL_DRS      (0x1  << 12) /* Divide rate select,default,0:rate 1;1:rate 2 */
+#define SPI_CLK_SCOPE       (SPI_CLKCTL_CDR2+1)
+/* 31:13bits reserved */
+
+/* SPI Burst Counter Register Bit Fields & Masks,default value: 0x0000_0000 */
+/* master mode: when SMC = 1,BC specifies total burst number, Max length is 16Mbytes */
+#define SPI_BC_BC_MASK      (0xFFFFFF << 0) /* Total Burst Counter,tx length + rx length ,SMC=1 */
+#define SPI_TRANSFER_SIZE   (SPI_BC_BC_MASK)
+
+/* SPI Transmit Counter reigster default:0x0000_0000,Max length is 16Mbytes */
+#define SPI_TC_WTC_MASK     (0xFFFFFF << 0) /* Write Transmit Counter,tx length, NOT rx length!!! */
+
+
+/* SPI FIFO status register default is 0x0000_0000 */
+#define SPI_FIFO_RXCNT      (0x7F << 0)     /* rxFIFO counter,how many bytes in the rxFIFO */
+#define SPI_RXCNT_BIT_POS   (0)
+/* 15:7bits reserved */
+
+#define SPI_FIFO_TXCNT      (0x7F << 16)    /* txFIFO counter,how many bytes in the txFIFO */
+#define SPI_TXCNT_BIT_POS   (16)
+
+
+/* configbit
+ * linuxspi
+ * 4
+ * 0: 0POL=0,PAL=0;
+ * 1: 1POL=0,PAL=1;
+ * 2: 2POL=1,PAL=0;
+ * 3: 3POL=1,PAL=1;
+ */
+#define SPI_PHA_ACTIVE_         (0x01)
+#define SPI_POL_ACTIVE_         (0x02)
+
+#define SPI_MODE_0_ACTIVE_      (0|0)
+#define SPI_MODE_1_ACTIVE_      (0|SPI_PHA_ACTIVE_)
+#define SPI_MODE_2_ACTIVE_      (SPI_POL_ACTIVE_|0)
+#define SPI_MODE_3_ACTIVE_      (SPI_POL_ACTIVE_|SPI_PHA_ACTIVE_)   /*3*/
+/*  */
+#define SPI_CS_HIGH_ACTIVE_     (0x04)  /**/
+#define SPI_LSB_FIRST_ACTIVE_   (0x08)  /*MSB*/
+
+#define SPI_DUMMY_ONE_ACTIVE_   (0x10)  /*spi0txFIFO */
+#define SPI_RECEIVE_ALL_ACTIVE_ (0x20)  /*burstrxFIFO */
+
+/* can modify to adapt the application */
+#define BULK_DATA_BOUNDARY      64
+
+/* spi controller just suppport 20Mhz */
+#define SPI_MAX_FREQUENCY       80000000
+
+/* distinguish sdram and sram address */
+#define SPI_RAM_BOUNDAY         (0x80000000)
+
+/* function mode select */
+#define SPI_MASTER_MODE         (0x1)
+#define SPI_SLAVE_MODE          (0x0)
+
+struct sun7i_spi_platform_data {
+    int cs_bitmap;          // cs0-0x1,cs1-0x2,cs0&cs1-0x3
+    int num_cs;             // number of cs
+    const char *clk_name;   // ahb clk name
+};
+
+/* spi device controller state, alloc */
+struct sun7i_spi_config {
+    int bits_per_word;      // 8bit
+    int max_speed_hz;       // 80MHz
+    int mode;               // pha,pol,LSB,etc..
+};
+
+/* spi device data, used in dual spi mode */
+struct sun7i_dual_mode_dev_data {
+    int dual_mode;          // dual SPI mode, 0-single mode, 1-dual mode
+    int single_cnt;         // single mode transmit counter
+    int dummy_cnt;          // dummy counter should be sent before receive in dual mode
+};
+
+#endif
diff --git a/arch/arm/mach-sun7i/include/mach/sunxi_dump_reg.h b/arch/arm/mach-sun7i/include/mach/sunxi_dump_reg.h
new file mode 100755
index 0000000..a4abfe1
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/sunxi_dump_reg.h
@@ -0,0 +1,68 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/sunxi_dump_reg.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sunxi dump reg head file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_DUMP_REG_H
+#define __SUNXI_DUMP_REG_H
+
+#define MAX_COMPARE_ITEM 	256
+#define MAX_WRITE_ITEM 		256
+
+/**
+ * compare_item - reg compare item struct
+ * @reg_addr:	reg physical address.
+ * @val_expect: expected value, provided by caller.
+ * @val_mask:   mask value, provided by caller. only mask bits will be compared.
+ */
+struct compare_item {
+	u32 	reg_addr;
+	u32	val_expect;
+	u32	val_mask;
+};
+
+/**
+ * compare_group - reg compare group struct
+ * @num:	pitem element count. cannot exceed MAX_COMPARE_ITEM.
+ * @pitem: 	items that will be compared, provided by caller.
+ */
+struct compare_group {
+	u32	num;
+	struct compare_item *pitem;
+};
+
+/**
+ * write_item - reg write item struct
+ * @reg_addr:	reg physical address.
+ * @val: 	value to write
+ */
+struct write_item {
+	u32 	reg_addr;
+	u32	val;
+};
+
+/**
+ * write_group - reg write group struct
+ * @num:	pitem element count. cannot exceed MAX_WRITE_ITEM.
+ * @pitem: 	items that will be write, provided by caller.
+ */
+struct write_group {
+	u32	num;
+	struct write_item *pitem;
+};
+
+void sunxi_dump_regs(u32 start_reg, u32 end_reg);
+void sunxi_compare_regs(struct compare_group *pgroup);
+void sunxi_write_regs(struct write_group *pgroup);
+
+#endif /* __SUNXI_DUMP_REG_H */
diff --git a/arch/arm/mach-sun7i/include/mach/sys_config.h b/arch/arm/mach-sun7i/include/mach/sys_config.h
new file mode 120000
index 0000000..937811b
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/sys_config.h
@@ -0,0 +1 @@
+../plat/sys_config.h
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/include/mach/system.h b/arch/arm/mach-sun7i/include/mach/system.h
new file mode 100644
index 0000000..57dc534
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/system.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/system.h
+ */
+
+#include <plat/system.h>
diff --git a/arch/arm/mach-sun7i/include/mach/timex.h b/arch/arm/mach-sun7i/include/mach/timex.h
new file mode 100755
index 0000000..cba6bff
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/timex.h
@@ -0,0 +1,26 @@
+/*
+ *  arch/arm/mach-sun7i/include/mach/timex.h
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __MACH_TIMEX_H
+#define __MACH_TIMEX_H
+#include <plat/timex.h>
+#endif
+
diff --git a/arch/arm/mach-sun7i/include/mach/uart.h b/arch/arm/mach-sun7i/include/mach/uart.h
new file mode 100644
index 0000000..974229d
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/uart.h
@@ -0,0 +1,46 @@
+/*
+ * arch/arch/mach-sun7i/include/mach/uart.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * liugang <liugang@allwinnertech.com>
+ * csjamesdeng <csjamesdeng@allwinnertech.com>
+ *
+ * uart head file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SW_UART_H
+#define __SW_UART_H
+
+#define AW_UART_RBR 		0x00 /* Receive Buffer Register */
+#define AW_UART_THR 		0x00 /* Transmit Holding Register */
+#define AW_UART_DLL 		0x00 /* Divisor Latch Low Register */
+#define AW_UART_DLH 		0x04 /* Diviso Latch High Register */
+#define AW_UART_IER 		0x04 /* Interrupt Enable Register */
+#define AW_UART_IIR 		0x08 /* Interrrupt Identity Register */
+#define AW_UART_FCR 		0x08 /* FIFO Control Register */
+#define AW_UART_LCR 		0x0c /* Line Control Register */
+#define AW_UART_MCR 		0x10 /* Modem Control Register */
+#define AW_UART_LSR 		0x14 /* Line Status Register */
+#define AW_UART_MSR 		0x18 /* Modem Status Register */
+#define AW_UART_SCH 		0x1c /* Scratch Register */
+#define AW_UART_USR 		0x7c /* Status Register */
+#define AW_UART_TFL 		0x80 /* Transmit FIFO Level */
+#define AW_UART_RFL 		0x84 /* RFL */
+#define AW_UART_HALT		0xa4 /* Halt TX Register */
+
+#define UART_USR            (AW_UART_USR >> 2)
+#define UART_HALT           (AW_UART_HALT >> 2)
+#define UART_SCH            (AW_UART_SCH >> 2)
+#define UART_FORCE_CFG      (1 << 1)
+#define UART_FORCE_UPDATE   (1 << 2)
+
+#define AW_UART_LOG(fmt, args...) do{} while(0)
+
+#endif
+
diff --git a/arch/arm/mach-sun7i/include/mach/uncompress.h b/arch/arm/mach-sun7i/include/mach/uncompress.h
new file mode 100644
index 0000000..d6fe881
--- /dev/null
+++ b/arch/arm/mach-sun7i/include/mach/uncompress.h
@@ -0,0 +1,5 @@
+/*
+ * arch/arm/mach-sun7i/include/mach/uncompress.h
+ */
+
+#include <plat/uncompress.h>
diff --git a/arch/arm/mach-sun7i/localtimer.c b/arch/arm/mach-sun7i/localtimer.c
new file mode 100755
index 0000000..00fdbd1
--- /dev/null
+++ b/arch/arm/mach-sun7i/localtimer.c
@@ -0,0 +1,26 @@
+/*
+ *  linux/arch/arm/plat-versatile/localtimer.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clockchips.h>
+
+#include <asm/smp_twd.h>
+#include <asm/localtimer.h>
+#include <mach/includes.h>
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+int __cpuinit local_timer_setup(struct clock_event_device *evt)
+{
+	pr_debug("[%s] Not Implemented!\n", __func__);
+	return -1;
+}
diff --git a/arch/arm/mach-sun7i/platsmp.c b/arch/arm/mach-sun7i/platsmp.c
new file mode 100755
index 0000000..b74bbff
--- /dev/null
+++ b/arch/arm/mach-sun7i/platsmp.c
@@ -0,0 +1,136 @@
+/*
+ *  linux/arch/arm/mach-sun7i/platsmp.c
+ *
+ *  Copyright (C) 2012-2016 Allwinner Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/smp.h>
+
+#include <mach/includes.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/smp_scu.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+
+#include "core.h"
+
+extern void sun7i_secondary_startup(void);
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit enable_aw_cpu(int cpu)
+{
+    long paddr;
+    u32 pwr_reg;
+
+    paddr = virt_to_phys(sun7i_secondary_startup);
+    writel(paddr, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_P_REG0);
+
+    /* step1: Assert nCOREPORESET LOW and hold L1RSTDISABLE LOW.
+              Ensure DBGPWRDUP is held LOW to prevent any external
+              debug access to the processor.
+    */
+    /* assert cpu core reset */
+    writel(0, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + CPUX_RESET_CTL(cpu));
+    /* L1RSTDISABLE hold low */
+    pwr_reg = readl(IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_GENCTL);
+    pwr_reg &= ~(1<<cpu);
+    writel(pwr_reg, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_GENCTL);
+    /* DBGPWRDUP hold low */
+    pwr_reg = readl(IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_DBGCTL1);
+    pwr_reg &= ~(1<<cpu);
+    writel(pwr_reg, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_DBGCTL1);
+
+    /* step2: release power clamp */
+    writel(0xff, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    writel(0x7f, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    writel(0x3f, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    writel(0x1f, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    writel(0x0f, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    writel(0x07, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    writel(0x03, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    writel(0x01, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    writel(0x00, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWR_CLAMP);
+    mdelay(10);
+
+    /* step3: clear power-off gating */
+    pwr_reg = readl(IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWROFF_REG);
+    pwr_reg &= ~(1);
+    writel(pwr_reg, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPU1_PWROFF_REG);
+    mdelay(1);
+
+    /* step4: de-assert core reset */
+    writel(3, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + CPUX_RESET_CTL(cpu));
+
+    /* step5: assert DBGPWRDUP signal */
+    pwr_reg = readl(IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_DBGCTL1);
+    pwr_reg |= (1<<cpu);
+    writel(pwr_reg, IO_ADDRESS(SW_PA_CPUCFG_IO_BASE) + AW_CPUCFG_DBGCTL1);
+}
+
+void __init smp_init_cpus(void)
+{
+    unsigned int i, ncores;
+
+
+	/* HDG: we do not use scu_get_core_count() here as that does not
+	   work on the A20 ? */
+
+	/* Read current CP15 Cache Size ID Register */
+	asm volatile ("mrc p15, 1, %0, c9, c0, 2" : "=r" (ncores));
+	ncores = ((ncores >> 24) & 0x3) + 1;
+
+    pr_debug("[%s] ncores=%d\n", __FUNCTION__, ncores);
+
+    for (i = 0; i < ncores; i++) {
+        set_cpu_possible(i, true);
+    }
+
+    set_smp_cross_call(gic_raise_softirq);
+}
+
+/*
+ * for arch/arm/kernel/smp.c:smp_prepare_cpus(unsigned int max_cpus)
+ */
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	/*
+	 * HDG: we do not call scu_enable() here as the sun6i source dump has
+	 * a modified arch/arm/kernel/smp_scu.c, where scu_enable() is a nop.
+	 */
+}
+
+/*
+ * for linux/arch/arm/kernel/smp.c:secondary_start_kernel(void)
+ */
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+    pr_debug("[%s] enter, cpu:%d\n", __FUNCTION__, cpu);
+    gic_secondary_init(0);
+}
+
+/*
+ * for linux/arch/arm/kernel/smp.c:__cpu_up(..)
+ */
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+    pr_debug("[%s] enter\n", __FUNCTION__);
+    spin_lock(&boot_lock);
+    enable_aw_cpu(cpu);
+    spin_unlock(&boot_lock);
+    return 0;
+}
+
+
diff --git a/arch/arm/mach-sun7i/pm/Makefile b/arch/arm/mach-sun7i/pm/Makefile
new file mode 100755
index 0000000..7694b45
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/Makefile
@@ -0,0 +1,8 @@
+obj-y	 += pm.o standby.o mem_tmr.o mem_timing.o mem_divlibc.o
+
+KBUILD_CFLAGS += -I$(srctree)/arch/arm/mach-sun7i/pm/standby
+
+$(obj)/standby.o: $(obj)/standby/standby.bin
+
+$(obj)/standby/standby.bin: FORCE
+	$(Q)$(MAKE) $(build)=$(obj)/standby
diff --git a/arch/arm/mach-sun7i/pm/mem_divlibc.c b/arch/arm/mach-sun7i/pm/mem_divlibc.c
new file mode 100755
index 0000000..2664ac0
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/mem_divlibc.c
@@ -0,0 +1,48 @@
+#ifdef __STANDBY_MODULE__
+#include "pm_types.h" 
+#include "pm.h"
+
+void __div0(void)
+{
+	printk("Attempting division by 0!");
+}
+
+#elif defined(__KERNEL__)
+#include <linux/module.h>
+#endif
+
+__u32 raw_lib_udiv(__u32 dividend, __u32 divisior)
+{
+    __u32   tmpDiv = (__u32)divisior;
+    __u32   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return 0;
+    }
+
+    while(!(tmpDiv & ((__u32)1<<31)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
diff --git a/arch/arm/mach-sun7i/pm/mem_divlibc.h b/arch/arm/mach-sun7i/pm/mem_divlibc.h
new file mode 100755
index 0000000..fe1cee8
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/mem_divlibc.h
@@ -0,0 +1,13 @@
+#ifndef _MEM_MISC_H
+#define _MEM_MISC_H
+
+#include "pm_types.h" 
+
+void __div0(void);
+__u32 raw_lib_udiv(__u32 dividend, __u32 divisior);
+extern void __aeabi_idiv(void);
+extern void __aeabi_idivmod(void);
+extern void __aeabi_uidiv(void);
+extern void __aeabi_uidivmod(void);
+
+#endif /*_MEM_MISC_H*/
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/pm/mem_timing.c b/arch/arm/mach-sun7i/pm/mem_timing.c
new file mode 100755
index 0000000..3354d3d
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/mem_timing.c
@@ -0,0 +1,289 @@
+#include "pm.h"
+#include "pm_types.h"
+
+static __u32 cpu_freq = 0;
+static __u32 overhead = 0;
+static __u32 backup_perf_counter_ctrl_reg = 0;
+static __u32 backup_perf_counter_enable_reg = 0;
+
+static __u32 match_event_counter(enum counter_type_e type);
+
+void init_perfcounters (__u32 do_reset, __u32 enable_divider)
+{
+	// in general enable all counters (including cycle counter)
+	__u32 value = 1;
+
+	// peform reset:
+	if (do_reset)
+	{
+		value |= 2;     // reset all counters to zero.
+		value |= 4;     // reset cycle counter to zero.
+	}
+
+	if (enable_divider)
+		value |= 8;     // enable "by 64" divider for CCNT.
+
+	value |= 16;
+
+	// program the performance-counter control-register:
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(value));
+
+	// enable all counters:
+	value = 0x8000000f;
+	asm volatile ("mcr p15, 0, %0, c9, c12, 1" : : "r"(value));
+
+	// clear overflows:
+	asm volatile ("MCR p15, 0, %0, c9, c12, 3" : : "r"(value));
+
+	return;
+}
+
+void backup_perfcounter(void)
+{
+	//backup performance-counter ctrl reg
+	asm volatile ("MRC p15, 0, %0, c9, c12, 0\t\n": "=r"(backup_perf_counter_ctrl_reg)); 
+	
+	//backup enable reg
+	asm volatile ("MRC p15, 0, %0, c9, c12, 1\t\n": "=r"(backup_perf_counter_enable_reg)); 
+
+}
+
+void restore_perfcounter(void)
+{
+	
+	// restore performance-counter control-register:
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(backup_perf_counter_ctrl_reg));
+
+	// restore enable reg
+	asm volatile ("mcr p15, 0, %0, c9, c12, 1" : : "r"(backup_perf_counter_enable_reg));
+	
+}
+	
+__u32 get_cyclecount (void)
+{
+	__u32 value;
+	// Read CCNT Register
+	asm volatile ("MRC p15, 0, %0, c9, c13, 0\t\n": "=r"(value));  
+	return value;
+}
+
+void reset_counter(void)
+{
+	__u32 value = 0;
+
+	asm volatile ("mrc p15, 0, %0, c9, c12, 0" : : "r"(value));
+	value |= 4;     // reset cycle counter to zero.
+	// program the performance-counter control-register:
+	//__asm {MCR p15, 0, value, c9, c12, 0}
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(value));
+}
+
+void change_runtime_env(__u32 mmu_flag)
+{
+	__u32 factor_n = 0;
+	__u32 factor_k = 0;
+	__u32 factor_m = 0;
+	__u32 factor_p = 0;
+	__u32 start = 0;
+	__u32 reg_val = 0; 
+	volatile __ccmu_reg_list_t *cmu_reg;
+	__ccmu_pll1_core_reg0000_t pll1Ctrl;
+
+	if(mmu_flag){
+		cmu_reg = (__ccmu_reg_list_t * )SW_VA_CCM_IO_BASE;
+	}else{
+		cmu_reg = (__ccmu_reg_list_t * )SW_PA_CCM_IO_BASE;
+	}
+	//init counters:
+	//init_perfcounters (1, 0);
+	// measure the counting overhead:
+	start = get_cyclecount();
+	overhead = get_cyclecount() - start;
+	//busy_waiting();
+	//get runtime freq: clk src + divider ratio
+	//src selection
+	reg_val = (cmu_reg->SysClkDiv).AC327ClkSrc;
+	if(0 == reg_val){
+		//32khz osc
+		cpu_freq = 32;
+		
+	}else if(1 == reg_val){
+		//hosc, 24Mhz
+		cpu_freq = 24000; 			//unit is khz
+	}else if(2 == reg_val){
+		//get pll_factor
+		pll1Ctrl = cmu_reg->Pll1Ctl;
+		factor_p = pll1Ctrl.PLLDivP;
+		factor_p = 1 << factor_p;		//1/2/4/8
+		factor_n = pll1Ctrl.FactorN;		//the range is 0-31
+		factor_k = pll1Ctrl.FactorK + 1;		//the range is 1-4
+		factor_m = pll1Ctrl.FactorM + 1;		//the range is 1-4
+		
+		//cpu_freq = (24000*factor_n*factor_k)/(factor_p*factor_m);
+		cpu_freq = raw_lib_udiv(24000*factor_n*factor_k, factor_p*factor_m);
+		//msg("cpu_freq = dec(%d). \n", cpu_freq);
+		//busy_waiting();
+	}
+	
+}
+
+/*
+ * input para range: 1-1000 us, so the max us_cnt equal = 1008*1000;
+ */	
+void delay_us(__u32 us)
+{
+	__u32 us_cnt = 0;
+	__u32 cur = 0;
+	__u32 target = 0;
+	//__u32 cnt = 0;
+
+
+	if(cpu_freq > 1000){
+		us_cnt = ((raw_lib_udiv(cpu_freq, 1000)) + 1)*us;
+	}else{
+		//32 <--> 32k, 1cycle = 1s/32k =32us 
+		return;
+	}
+	
+	cur = get_cyclecount();
+	target = cur - overhead + us_cnt;
+
+#if 1
+	while(!counter_after_eq(cur, target)){
+		cur = get_cyclecount();
+		//cnt++;
+	}
+#endif
+	
+
+#if 0
+	__s32 s_cur = 0;
+	__s32 s_target = 0;
+	__s32 result = 0;
+
+	s_cur = (__s32)(cur);
+	s_target = (__s32)(target);
+	result = s_cur - s_target;
+	if(s_cur - s_target >= 0){
+		cnt++;
+	}
+	while((typecheck(__u32, cur) && \
+			typecheck(__u32, target) && \
+			((__s32)(cur) - (__s32)(target) >= 0))){
+		
+			s_cur = (__s32)(cur);
+			s_target = (__s32)(target);
+			if(s_cur - s_target >= 0){
+				cnt++;				
+			}
+			cur = get_cyclecount();
+	}
+#endif
+	//busy_waiting();
+
+	
+	return;
+}
+
+void delay_ms(__u32 ms)
+{
+	delay_us(ms*1000);
+	
+	return;
+}
+
+/*============================================== event counter ==========================*/
+static __u32 match_event_counter(enum counter_type_e type)
+{
+	int cnter = 0;
+	
+	switch(type){
+		case I_CACHE_MISS: 
+			cnter = 0;
+			break;
+		case I_TLB_MISS: 
+			cnter = 1;
+			break;
+		case D_CACHE_MISS: 
+			cnter = 2;
+			break;
+		case D_TLB_MISS: 
+			cnter = 3;
+			break;
+
+		default:
+			break;
+	
+	}
+	return cnter;
+
+}
+
+void init_event_counter (__u32 do_reset, __u32 enable_divider)
+{
+	// in general enable all counters (including cycle counter)
+	__u32 value = 1;
+
+	// peform reset:
+	if (do_reset)
+	{
+		value |= 2;     // reset all counters to zero.
+		value |= 4;     // reset cycle counter to zero.
+	}
+
+	if (enable_divider)
+		value |= 8;     // enable "by 64" divider for CCNT.
+
+	value |= 16;
+
+	// program the performance-counter control-register:
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(value));
+
+	// enable all counters:
+	value = 0x8000000f;
+	asm volatile ("mcr p15, 0, %0, c9, c12, 1" : : "r"(value));
+
+	// clear overflows:
+	asm volatile ("MCR p15, 0, %0, c9, c12, 3" : : "r"(value));
+
+	return;
+}
+
+void set_event_counter(enum counter_type_e type)
+{
+	
+	__u32 cnter = 0;
+	cnter = match_event_counter(type);
+
+	//set counter selection reg
+	asm volatile ("MCR p15, 0, %0, c9, c12, 5" : : "r"(cnter));
+
+	//set event type
+	asm volatile ("MCR p15, 0, %0, c9, c13, 1" : : "r"(type));
+
+	asm volatile ("dsb");
+	asm volatile ("isb");
+
+	return;
+}
+
+
+int get_event_counter(enum counter_type_e type)
+{
+	int cnter = 0;
+	int event_cnt = 0;
+	cnter = match_event_counter(type);
+
+	//set counter selection reg
+	asm volatile ("MCR p15, 0, %0, c9, c12, 5" : : "r"(cnter));
+
+	//read event counter
+	asm volatile ("MRC p15, 0, %0, c9, c13, 2\t\n": "=r"(event_cnt)); 
+	
+	asm volatile ("dsb");
+	asm volatile ("isb");
+
+	return event_cnt;
+}
+
+
diff --git a/arch/arm/mach-sun7i/pm/mem_timing.h b/arch/arm/mach-sun7i/pm/mem_timing.h
new file mode 100755
index 0000000..a1e2a85
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/mem_timing.h
@@ -0,0 +1,37 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, gq.yang China
+*                                             All Rights Reserved
+*
+* File    : mem_timing.h
+* By      : 
+* Version : v1.0
+* Date    : 2012-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_TIMING_H__
+#define __MEM_TIMING_H__
+
+#include "pm_debug.h"
+#include "pm_types.h" 
+
+__u32 get_cyclecount (void);
+void backup_perfcounter(void);
+void init_perfcounters (__u32 do_reset, __u32 enable_divider);
+void restore_perfcounter(void);
+void reset_counter(void);
+void change_runtime_env(__u32 mmu_flag);
+void delay_us(__u32 us);
+void delay_ms(__u32 ms);
+
+void init_event_counter (__u32 do_reset, __u32 enable_divider);
+void set_event_counter(enum counter_type_e type);
+int get_event_counter(enum counter_type_e type);
+
+#endif  /* __MEM_TIMING_H__ */
diff --git a/arch/arm/mach-sun7i/pm/mem_tmr.c b/arch/arm/mach-sun7i/pm/mem_tmr.c
new file mode 100755
index 0000000..4272d1f
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/mem_tmr.c
@@ -0,0 +1,159 @@
+#include <plat/hardware.h>
+#include <plat/platform.h>
+#include "mem_tmr.h"
+
+/*
+*********************************************************************************************************
+*                                     TIMER save
+*
+* Description: save timer for mem.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 mem_tmr_save(struct tmr_state *ptmr_state)
+{
+	__mem_tmr_reg_t  *TmrReg;
+	/* set timer register base */
+	ptmr_state->TmrReg = TmrReg = (__mem_tmr_reg_t *)IO_ADDRESS(SW_PA_TIMERC_IO_BASE);
+	
+	/* backup timer registers */
+	ptmr_state->TmrIntCtl   = TmrReg->IntCtl;
+	ptmr_state->Tmr0Ctl     = TmrReg->Tmr0Ctl;
+	ptmr_state->Tmr0IntVal  = TmrReg->Tmr0IntVal;
+	ptmr_state->Tmr0CntVal  = TmrReg->Tmr0CntVal;
+	ptmr_state->Tmr1Ctl     = TmrReg->Tmr1Ctl;
+	ptmr_state->Tmr1IntVal  = TmrReg->Tmr1IntVal;
+	ptmr_state->Tmr1CntVal  = TmrReg->Tmr1CntVal;
+	
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     TIMER restore
+*
+* Description: restore timer for mem.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 mem_tmr_restore(struct tmr_state *ptmr_state)
+{
+	__mem_tmr_reg_t  *TmrReg;
+
+	/* set timer register base */
+	TmrReg = ptmr_state->TmrReg;
+	/* restore timer0 parameters */
+	TmrReg->Tmr0IntVal  = ptmr_state->Tmr0IntVal;
+	TmrReg->Tmr0CntVal  = ptmr_state->Tmr0CntVal;
+	TmrReg->Tmr0Ctl     = ptmr_state->Tmr0Ctl;
+	TmrReg->Tmr1IntVal  = ptmr_state->Tmr1IntVal;
+	TmrReg->Tmr1CntVal  = ptmr_state->Tmr1CntVal;
+	TmrReg->Tmr1Ctl     = ptmr_state->Tmr1Ctl;
+	TmrReg->IntCtl      = ptmr_state->TmrIntCtl;
+	
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                     enable watchdog
+*
+* Description: enable watchdog.
+*
+* Arguments  : none
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+#define MEM_WATCHDOG_ENABLE_MASK 1
+#define PM_WATCHDOG_ENABLE 1
+
+#ifdef PM_WATCHDOG_ENABLE
+__u32 pm_enable_watchdog(void)
+{
+	__mem_tmr_reg_t  *TmrReg;
+    volatile __u32   dogMode;
+	/* set timer register base */
+	TmrReg = (__mem_tmr_reg_t *)IO_ADDRESS(SW_PA_TIMERC_IO_BASE);
+    dogMode = TmrReg->DogMode;
+    
+    /* set watch-dog reset, timeout is 10 seconds */
+    TmrReg->DogMode = (8<<3) | (1<<1);
+    /* enable watch-dog */
+    TmrReg->DogMode |= MEM_WATCHDOG_ENABLE_MASK;
+    TmrReg->DogCtl = 1;  /*restart watchdog*/
+    return dogMode;
+}
+
+void pm_feed_watchdog(void)
+{
+	__mem_tmr_reg_t  *TmrReg;
+	/* set timer register base */
+	TmrReg = (__mem_tmr_reg_t *)IO_ADDRESS(SW_PA_TIMERC_IO_BASE);
+    TmrReg->DogCtl = 1;  /*restart watchdog*/
+}
+
+/*
+*********************************************************************************************************
+*                                     enable watchdog
+*
+* Description: enable watchdog.
+*
+* Arguments  : none
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+void pm_disable_watchdog(__u32 dogMode)
+{
+	__mem_tmr_reg_t  *TmrReg;
+	/* set timer register base */
+	TmrReg = (__mem_tmr_reg_t *)IO_ADDRESS(SW_PA_TIMERC_IO_BASE);
+    if (dogMode)
+    {
+        TmrReg->DogMode = dogMode;
+        if (dogMode & MEM_WATCHDOG_ENABLE_MASK)
+        {
+            TmrReg->DogCtl = 1;  /*restart watchdog*/
+        }
+    }
+    else
+    {
+        /* disable watch-dog reset */
+        TmrReg->DogMode &= ~(1<<1);
+        /* disable watch-dog */
+        TmrReg->DogMode &= ~(1<<0);
+    }
+}
+#else
+__u32 pm_enable_watchdog(void)
+{
+    return 0;
+}
+
+void pm_feed_watchdog(void)
+{
+}
+
+/*
+*********************************************************************************************************
+*                                     enable watchdog
+*
+* Description: enable watchdog.
+*
+* Arguments  : none
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+void pm_disable_watchdog(__u32 dogMode)
+{
+}
+#endif
diff --git a/arch/arm/mach-sun7i/pm/mem_tmr.h b/arch/arm/mach-sun7i/pm/mem_tmr.h
new file mode 100755
index 0000000..d8899e4
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/mem_tmr.h
@@ -0,0 +1,80 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2011-2015, gq.yang China
+*                                             All Rights Reserved
+*
+* File    : mem_tmr.h
+* By      : gq.yang
+* Version : v1.0
+* Date    : 2012-11-31 15:23
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_TMR_H__
+#define __MEM_TMR_H__
+
+#include "pm_types.h" 
+
+typedef struct __MEM_TMR_REG
+{
+	// offset:0x00
+	volatile __u32   IntCtl;
+	volatile __u32   IntSta;
+	volatile __u32   reserved0[2];
+	// offset:0x10
+	volatile __u32   Tmr0Ctl;
+	volatile __u32   Tmr0IntVal;
+	volatile __u32   Tmr0CntVal;
+	volatile __u32   reserved1;
+	// offset:0x20
+	volatile __u32   Tmr1Ctl;
+	volatile __u32   Tmr1IntVal;
+	volatile __u32   Tmr1CntVal;
+	volatile __u32   reserved2;
+	// offset:0x30
+	volatile __u32   Tmr2Ctl;
+	volatile __u32   Tmr2IntVal;
+	volatile __u32   Tmr2CntVal;
+	volatile __u32   reserved3;
+	// offset:0x40
+	volatile __u32   Tmr3Ctl;
+	volatile __u32   Tmr3IntVal;
+	volatile __u32   reserved4[2];
+	// offset:0x50
+	volatile __u32   Tmr4Ctl;
+	volatile __u32   Tmr4IntVal;
+	volatile __u32   Tmr4CntVal;
+	volatile __u32   reserved5;
+	// offset:0x60
+	volatile __u32   Tmr5Ctl;
+	volatile __u32   Tmr5IntVal;
+	volatile __u32   Tmr5CntVal;
+	volatile __u32   reserved6[5];
+	// offset:0x80
+	volatile __u32   AvsCtl;
+	volatile __u32   Avs0Cnt;
+	volatile __u32   Avs1Cnt;
+	volatile __u32   AvsDiv;
+
+	// offset:0x90
+	volatile __u32	 DogCtl;
+	volatile __u32	 DogMode;
+	volatile __u32	 reserved7[2];
+
+} __mem_tmr_reg_t;
+
+struct tmr_state{
+	__mem_tmr_reg_t  *TmrReg;
+	__u32 TmrIntCtl, Tmr0Ctl, Tmr0IntVal, Tmr0CntVal, Tmr1Ctl, Tmr1IntVal, Tmr1CntVal;
+};
+__s32 mem_tmr_save(struct tmr_state *ptmr_state);
+__s32 mem_tmr_restore(struct tmr_state *ptmr_state);
+__u32 pm_enable_watchdog(void);
+void pm_disable_watchdog(__u32 dogMode);
+
+#endif  //__MEM_TMR_H__
diff --git a/arch/arm/mach-sun7i/pm/pm.c b/arch/arm/mach-sun7i/pm/pm.c
new file mode 100755
index 0000000..1261cfe
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/pm.c
@@ -0,0 +1,652 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : pm.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-27 14:08
+* Descript: power manager for allwinners chips platform.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#include <linux/module.h>
+#include <linux/suspend.h>
+#include <linux/cpufreq.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/syscalls.h>
+#include <linux/slab.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/tlbflush.h>
+#include <linux/power/aw_pm.h>
+#include <asm/mach/map.h>
+#include <asm/cacheflush.h>
+#include "pm.h"
+
+#include <plat/sys_config.h>
+#include <mach/system.h>
+
+//#define CROSS_MAPPING_STANDBY
+
+#define AW_PM_DBG   1
+#undef PM_DBG
+#if(AW_PM_DBG)
+    #define PM_DBG(format,args...)   printk("[pm]"format,##args)
+#else
+    #define PM_DBG(format,args...)   do{}while(0)
+#endif
+
+#ifdef RETURN_FROM_RESUME0_WITH_NOMMU
+#define PRE_DISABLE_MMU    //actually, mean ,prepare condition to disable mmu
+#endif
+
+#ifdef RETURN_FROM_RESUME0_WITH_MMU
+#undef PRE_DISABLE_MMU
+#endif
+
+#ifdef WATCH_DOG_RESET
+#define PRE_DISABLE_MMU    //actually, mean ,prepare condition to disable mmu
+#endif
+
+//#define VERIFY_RESTORE_STATUS
+
+/* define major number for power manager */
+#define AW_PMU_MAJOR    267
+
+static int debug_mask = PM_STANDBY_PRINT_STANDBY | PM_STANDBY_PRINT_RESUME;
+
+static int standby_axp_enable = 1;
+static int standby_timeout = 0;
+
+static int suspend_freq = SUSPEND_FREQ;
+
+extern char *standby_bin_start;
+extern char *standby_bin_end;
+
+static void show_reg(unsigned long addr, int nbytes, const char *name);
+
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+extern void cpufreq_user_event_notify(void);
+#endif
+
+static struct aw_pm_info standby_info = {
+    .standby_para = {
+        .event_enable  = SUSPEND_WAKEUP_SRC_EXINT,
+        .axp_src = AXP_MEM_WAKEUP,
+    },
+    .pmu_arg = {
+        .twi_port = 0,
+        .dev_addr = 10,
+    },
+};
+
+static volatile __u32   dogMode;
+
+#ifdef GET_CYCLE_CNT
+static int start = 0;
+static int resume0_period = 0;
+static int resume1_period = 0;
+
+static int pm_start = 0;
+static int invalidate_data_time = 0;
+static int invalidate_instruct_time = 0;
+static int before_restore_processor = 0;
+static int after_restore_process = 0;
+//static int restore_runtime_peroid = 0;
+
+//late_resume timing
+static int late_resume_start = 0;
+static int backup_area_start = 0;
+static int backup_area1_start = 0;
+static int backup_area2_start = 0;
+static int clk_restore_start = 0;
+static int gpio_restore_start = 0;
+static int twi_restore_start = 0;
+static int int_restore_start = 0;
+static int tmr_restore_start = 0;
+static int sram_restore_start = 0;
+static int late_resume_end = 0;
+#endif
+
+EXPORT_SYMBOL(pm_disable_watchdog);
+EXPORT_SYMBOL(pm_enable_watchdog);
+
+/*
+*********************************************************************************************************
+*                           aw_pm_valid
+*
+*Description: determine if given system sleep state is supported by the platform;
+*
+*Arguments  : state     suspend state;
+*
+*Return     : if the state is valid, return 1, else return 0;
+*
+*Notes      : this is a call-back function, registered into PM core;
+*
+*********************************************************************************************************
+*/
+static int aw_pm_valid(suspend_state_t state)
+{
+    if(!((state > PM_SUSPEND_ON) && (state < PM_SUSPEND_MAX))){
+        PM_DBG("state (%d) invalid!\n", state);
+        return 0;
+    }
+
+#ifdef GET_CYCLE_CNT
+        // init counters:
+        init_perfcounters (1, 0);
+#endif
+
+    return 1;
+
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_begin
+*
+*Description: Initialise a transition to given system sleep state;
+*
+*Arguments  : state     suspend state;
+*
+*Return     : return 0 for process successed;
+*
+*Notes      : this is a call-back function, registered into PM core, and this function
+*             will be called before devices suspened;
+*********************************************************************************************************
+*/
+unsigned int backup_max_freq = 0;
+unsigned int backup_min_freq = 0;
+
+int aw_pm_begin(suspend_state_t state)
+{
+    struct cpufreq_policy *policy;
+
+    PM_DBG("%d state begin:%d\n", state,debug_mask);
+
+    //set freq max
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+    //cpufreq_user_event_notify();
+#endif
+    
+    backup_max_freq = 0;
+    backup_min_freq = 0;
+    policy = cpufreq_cpu_get(0);
+    if (!policy)
+    {
+        PM_DBG("line:%d cpufreq_cpu_get failed!\n", __LINE__);
+        goto out;
+    }
+
+    backup_max_freq = policy->max;
+    backup_min_freq = policy->min;
+    policy->user_policy.max= suspend_freq;
+    policy->user_policy.min = suspend_freq;
+    cpufreq_cpu_put(policy);
+    cpufreq_update_policy(0);
+
+    /*must init perfcounter, because delay_us and delay_ms is depandant perf counter*/
+#ifndef GET_CYCLE_CNT
+    backup_perfcounter();
+    init_perfcounters (1, 0);
+#endif
+
+    if(unlikely(debug_mask&PM_STANDBY_PRINT_REG)){
+        printk("before dev suspend , line:%d\n", __LINE__);
+        show_reg(SW_VA_CCM_IO_BASE, (CCU_REG_LENGTH)*4, "ccu");
+        show_reg(SW_VA_PORTC_IO_BASE, GPIO_REG_LENGTH*4, "gpio");
+        show_reg(SW_VA_TIMERC_IO_BASE, TMR_REG_LENGTH*4, "timer");
+        show_reg(SW_VA_TWI0_IO_BASE, TWI0_REG_LENGTH*4, "twi0");
+        show_reg(SW_VA_SRAM_IO_BASE, SRAM_REG_LENGTH*4, "sram");
+    }
+    return 0;
+
+out:
+    return -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_prepare
+*
+*Description: Prepare the platform for entering the system sleep state.
+*
+*Arguments  : none;
+*
+*Return     : return 0 for process successed, and negative code for error;
+*
+*Notes      : this is a call-back function, registered into PM core, this function
+*             will be called after devices suspended, and before device late suspend
+*             call-back functions;
+*********************************************************************************************************
+*/
+int aw_pm_prepare(void)
+{
+    PM_DBG("prepare\n");
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_prepare_late
+*
+*Description: Finish preparing the platform for entering the system sleep state.
+*
+*Arguments  : none;
+*
+*Return     : return 0 for process successed, and negative code for error;
+*
+*Notes      : this is a call-back function, registered into PM core.
+*             prepare_late is called before disabling nonboot CPUs and after
+*              device drivers' late suspend callbacks have been executed;
+*********************************************************************************************************
+*/
+int aw_pm_prepare_late(void)
+{
+    PM_DBG("prepare_late\n");
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_enter
+*
+*Description: Enter the system sleep state;
+*
+*Arguments  : state     system sleep state;
+*
+*Return     : return 0 is process successed;
+*
+*Notes      : this function is the core function for platform sleep.
+*********************************************************************************************************
+*/
+static int aw_pm_enter(suspend_state_t state)
+{
+//  asm volatile ("stmfd sp!, {r1-r12, lr}" );
+    normal_standby_func standby;
+    
+    PM_DBG("enter state %d\n", state);
+
+    if(unlikely(debug_mask&PM_STANDBY_PRINT_REG)){
+        printk("after cpu suspend , line:%d\n", __LINE__);
+        show_reg(SW_VA_CCM_IO_BASE, (CCU_REG_LENGTH)*4, "ccu");
+        show_reg(SW_VA_PORTC_IO_BASE, GPIO_REG_LENGTH*4, "gpio");
+        show_reg(SW_VA_TIMERC_IO_BASE, TMR_REG_LENGTH*4, "timer");
+        show_reg(SW_VA_TWI0_IO_BASE, TWI0_REG_LENGTH*4, "twi0");
+        show_reg(SW_VA_SRAM_IO_BASE, SRAM_REG_LENGTH*4, "sram");
+    }
+
+    standby_info.standby_para.axp_enable = standby_axp_enable;
+    
+        standby = (int (*)(struct aw_pm_info *arg))SRAM_FUNC_START;
+        //move standby code to sram
+        memcpy((void *)SRAM_FUNC_START, (void *)&standby_bin_start, (int)&standby_bin_end - (int)&standby_bin_start);
+        /* config system wakeup evetn type */
+        if(PM_SUSPEND_MEM == state || PM_SUSPEND_STANDBY == state){
+            standby_info.standby_para.axp_src = AXP_MEM_WAKEUP;
+        }else if(PM_SUSPEND_BOOTFAST == state){
+            standby_info.standby_para.axp_src = AXP_BOOTFAST_WAKEUP;
+        }
+        standby_info.standby_para.event_enable = (SUSPEND_WAKEUP_SRC_EXINT | SUSPEND_WAKEUP_SRC_ALARM);
+
+        if (standby_timeout != 0)
+        {
+            standby_info.standby_para.event_enable = (SUSPEND_WAKEUP_SRC_EXINT | SUSPEND_WAKEUP_SRC_ALARM | SUSPEND_WAKEUP_SRC_TIMEOFF);
+            standby_info.standby_para.time_off = standby_timeout;
+        }
+        /* goto sram and run */
+        standby(&standby_info);
+
+    dogMode = pm_enable_watchdog();
+
+    if(unlikely(debug_mask&PM_STANDBY_PRINT_REG)){
+        printk("after cpu suspend , line:%d\n", __LINE__);
+        show_reg(SW_VA_CCM_IO_BASE, (CCU_REG_LENGTH)*4, "ccu");
+        show_reg(SW_VA_PORTC_IO_BASE, GPIO_REG_LENGTH*4, "gpio");
+        show_reg(SW_VA_TIMERC_IO_BASE, TMR_REG_LENGTH*4, "timer");
+        show_reg(SW_VA_TWI0_IO_BASE, TWI0_REG_LENGTH*4, "twi0");
+        show_reg(SW_VA_SRAM_IO_BASE, SRAM_REG_LENGTH*4, "sram");
+    }
+//  asm volatile ("ldmfd sp!, {r1-r12, lr}" );
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_wake
+*
+*Description: platform wakeup;
+*
+*Arguments  : none;
+*
+*Return     : none;
+*
+*Notes      : This function called when the system has just left a sleep state, right after
+*             the nonboot CPUs have been enabled and before device drivers' early resume
+*             callbacks are executed. This function is opposited to the aw_pm_prepare_late;
+*********************************************************************************************************
+*/
+static void aw_pm_wake(void)
+{
+    PM_DBG("platform wakeup, wakesource is:0x%x\n", standby_info.standby_para.event);
+}
+
+/*
+*********************************************************************************************************
+*                           aw_pm_finish
+*
+*Description: Finish wake-up of the platform;
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      : This function is called right prior to calling device drivers' regular suspend
+*              callbacks. This function is opposited to the aw_pm_prepare function.
+*********************************************************************************************************
+*/
+void aw_pm_finish(void)
+{
+    PM_DBG("platform wakeup finish\n");
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_end
+*
+*Description: Notify the platform that system is in work mode now.
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      : This function is called by the PM core right after resuming devices, to indicate to
+*             the platform that the system has returned to the working state or
+*             the transition to the sleep state has been aborted. This function is opposited to
+*             aw_pm_begin function.
+*********************************************************************************************************
+*/
+void aw_pm_end(void)
+{
+    struct cpufreq_policy *policy;
+
+#ifndef GET_CYCLE_CNT
+    #ifndef IO_MEASURE
+            restore_perfcounter();
+    #endif
+#endif
+    if (backup_max_freq != 0 && backup_min_freq != 0)
+    {
+        policy = cpufreq_cpu_get(0);
+        if (!policy)
+        {
+            printk("cpufreq_cpu_get err! check it! aw_pm_end:%d\n", __LINE__);
+            return;
+        }
+        
+        policy->user_policy.max = backup_max_freq;
+        policy->user_policy.min = backup_min_freq;
+        cpufreq_cpu_put(policy);
+        cpufreq_update_policy(0);
+    }
+    pm_disable_watchdog(dogMode);
+    
+    if(unlikely(debug_mask&PM_STANDBY_PRINT_REG)){
+        printk("after dev suspend, line:%d\n", __LINE__);
+        show_reg(SW_VA_CCM_IO_BASE, (CCU_REG_LENGTH)*4, "ccu");
+        show_reg(SW_VA_PORTC_IO_BASE, GPIO_REG_LENGTH*4, "gpio");
+        show_reg(SW_VA_TIMERC_IO_BASE, TMR_REG_LENGTH*4, "timer");
+        show_reg(SW_VA_TWI0_IO_BASE, TWI0_REG_LENGTH*4, "twi0");
+        show_reg(SW_VA_SRAM_IO_BASE, SRAM_REG_LENGTH*4, "sram");
+    }
+
+    PM_DBG("aw_pm_end!\n");
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_recover
+*
+*Description: Recover platform from a suspend failure;
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      : This function alled by the PM core if the suspending of devices fails.
+*             This callback is optional and should only be implemented by platforms
+*             which require special recovery actions in that situation.
+*********************************************************************************************************
+*/
+void aw_pm_recover(void)
+{
+    PM_DBG("aw_pm_recover\n");
+}
+
+
+/*
+    define platform_suspend_ops which is registered into PM core.
+*/
+static struct platform_suspend_ops aw_pm_ops = {
+    .valid = aw_pm_valid,
+    .begin = aw_pm_begin,
+    .prepare = aw_pm_prepare,
+    .prepare_late = aw_pm_prepare_late,
+    .enter = aw_pm_enter,
+    .wake = aw_pm_wake,
+    .finish = aw_pm_finish,
+    .end = aw_pm_end,
+    .recover = aw_pm_recover,
+};
+
+static int dram_para_script_fetch(char *sub, u32 *val)
+{
+	if (script_parser_fetch("dram_para", sub, val, sizeof(int))) {
+		pr_err("dram para %s fetch err\n", sub);
+		return -1;
+	}
+	pr_debug("dram config [dram_para] [%s] : %d\n", sub, *val);
+	return 0;
+}
+
+static int fetch_and_save_dram_para(standy_dram_para_t *pstandby_dram_para)
+{
+	int ret;
+
+	ret = dram_para_script_fetch( "dram_baseaddr", &pstandby_dram_para->dram_baseaddr);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_clk", &pstandby_dram_para->dram_clk);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_type", &pstandby_dram_para->dram_type);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_rank_num", &pstandby_dram_para->dram_rank_num);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_chip_density", &pstandby_dram_para->dram_chip_density);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_io_width", &pstandby_dram_para->dram_io_width);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_bus_width", &pstandby_dram_para->dram_bus_width);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_cas", &pstandby_dram_para->dram_cas);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_zq", &pstandby_dram_para->dram_zq);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_odt_en", &pstandby_dram_para->dram_odt_en);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_size", &pstandby_dram_para->dram_size);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_tpr0", &pstandby_dram_para->dram_tpr0);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_tpr1", &pstandby_dram_para->dram_tpr1);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_tpr2", &pstandby_dram_para->dram_tpr2);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_tpr3", &pstandby_dram_para->dram_tpr3);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_tpr4", &pstandby_dram_para->dram_tpr4);
+	if (ret)
+		return -1;
+    
+	ret = dram_para_script_fetch( "dram_tpr5", &pstandby_dram_para->dram_tpr5);
+	if (ret)
+		return -1;
+    
+	ret = dram_para_script_fetch( "dram_emr1", &pstandby_dram_para->dram_emr1);
+	if (ret)
+		return -1;
+    
+	ret = dram_para_script_fetch( "dram_emr2", &pstandby_dram_para->dram_emr2);
+	if (ret)
+		return -1;
+
+	ret = dram_para_script_fetch( "dram_emr3", &pstandby_dram_para->dram_emr3);
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           aw_pm_init
+*
+*Description: initial pm sub-system for platform;
+*
+*Arguments  : none;
+*
+*Return     : result;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int __init aw_pm_init(void)
+{
+	if (fetch_and_save_dram_para(&standby_info.dram_para) != 0) {
+		memset(&standby_info.dram_para, 0,
+		       sizeof(standby_info.dram_para));
+		pr_err("%s: fetch_and_save_dram_para err.\n", __func__);
+	}
+
+    suspend_set_ops(&aw_pm_ops);
+
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           aw_pm_exit
+*
+*Description: exit pm sub-system on platform;
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void __exit aw_pm_exit(void)
+{
+    PM_DBG("aw_pm_exit!\n");
+    suspend_set_ops(NULL);
+}
+
+
+/*
+ * dump a block of reg from around the given address
+ */
+static void show_reg(unsigned long addr, int nbytes, const char *name)
+{
+#if(AW_PM_DBG)
+    int i, j;
+    int nlines;
+    u32 *p;
+
+    printk("\n========%s: %#lx(%d)========\n", name, addr, nbytes);
+
+    /*
+     * round address down to a 32 bit boundary
+     * and always dump a multiple of 32 bytes
+     */
+    p = (u32 *)(addr & ~(sizeof(u32) - 1));
+    nbytes += (addr & (sizeof(u32) - 1));
+    nlines = (nbytes + 31) / 32;
+
+    for (i = 0; i < nlines; i++) {
+        /*
+         * just display low 16 bits of address to keep
+         * each line of the dump < 80 characters
+         */
+        printk("%04lx ", (unsigned long)p & 0xffff);
+        for (j = 0; j < 8; j++) {
+            printk(" %08x", *p);
+            ++p;
+        }
+        printk("\n");
+    }
+#endif
+}
+
+
+
+
+module_param_named(standby_axp_enable, standby_axp_enable, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_param_named(standby_timeout, standby_timeout, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_param_named(suspend_freq, suspend_freq, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_init(aw_pm_init);
+module_exit(aw_pm_exit);
diff --git a/arch/arm/mach-sun7i/pm/pm.h b/arch/arm/mach-sun7i/pm/pm.h
new file mode 100755
index 0000000..460c441
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/pm.h
@@ -0,0 +1,152 @@
+#ifndef _PM_H
+#define _PM_H
+
+/*
+ * Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include "pm_config.h"
+#include "pm_errcode.h"
+#include "mach/platform.h"
+#include "mem_divlibc.h"
+#include "mem_tmr.h"
+#include <mach/ccmu.h>
+#include "mem_timing.h"
+#include <linux/power/aw_pm.h>
+
+#define AXP_IICBUS      (0)
+#define TWI_CHECK_TIMEOUT       (0xf2ff)
+
+#define PM_STANDBY_PRINT_STANDBY        (1U << 0)
+#define PM_STANDBY_PRINT_RESUME         (1U << 1)
+#define PM_STANDBY_PRINT_CACHE_TLB_MISS (1U << 2)
+#define PM_STANDBY_PRINT_REG            (1U << 3)
+#define PM_STANDBY_PRINT_CHECK_CRC            (1U << 4)
+
+#ifdef CONFIG_ARCH_SUN4I
+#define INT_REG_LENGTH	((0x90+0x4)>>2)
+#define GPIO_REG_LENGTH	((0x218+0x4)>>2)
+#define SRAM_REG_LENGTH	((0x94+0x4)>>2)
+#elif defined CONFIG_ARCH_SUN5I
+#define INT_REG_LENGTH	((0x94+0x4)>>2)
+#define GPIO_REG_LENGTH	((0x218+0x4)>>2)
+#define SRAM_REG_LENGTH	((0x94+0x4)>>2)
+#elif defined CONFIG_ARCH_SUN6I
+#define GPIO_REG_LENGTH	((0x278+0x4)>>2)
+#define SRAM_REG_LENGTH	((0x94+0x4)>>2)
+#define CCU_REG_LENGTH	((0x308+0x4)>>2)
+#elif defined CONFIG_ARCH_SUN7I
+#define GPIO_REG_LENGTH	((0x218+0x4)>>2)
+#define SRAM_REG_LENGTH	((0x94+0x4)>>2)
+#define CCU_REG_LENGTH	((0x1f4+0x4)>>2)
+#define TMR_REG_LENGTH	((0x170+0x4)>>2)
+#define TWI0_REG_LENGTH ((0x20+0x4)>>2)
+#endif
+
+
+
+struct clk_div_t {
+    __u32   cpu_div:4;      /* division of cpu clock, divide core_pll */
+    __u32   axi_div:4;      /* division of axi clock, divide cpu clock*/
+    __u32   ahb_div:4;      /* division of ahb clock, divide axi clock*/
+    __u32   apb_div:4;      /* division of apb clock, divide ahb clock*/
+    __u32   reserved:16;
+};
+struct pll_factor_t {
+    __u8    FactorN;
+    __u8    FactorK;
+    __u8    FactorM;
+    __u8    FactorP;
+    __u32   Pll;
+};
+
+struct mmu_state {
+	/* CR0 */
+	__u32 cssr;	/* Cache Size Selection */
+	/* CR1 */
+	__u32 cr;		/* Control */
+	__u32 cacr;	/* Coprocessor Access Control */
+	/* CR2 */
+	__u32  ttb_0r;	/* Translation Table Base 0 */
+	__u32  ttb_1r;	/* Translation Table Base 1 */
+	__u32  ttbcr;	/* Translation Talbe Base Control */
+	
+	/* CR3 */
+	__u32 dacr;	/* Domain Access Control */
+
+	/*cr10*/
+	__u32 prrr;	/* Primary Region Remap Register */
+	__u32 nrrr;	/* Normal Memory Remap Register */
+};
+
+/**
+*@brief struct of super mem
+*/
+struct aw_mem_para{
+	void **resume_pointer;
+	__u32 mem_flag;
+	//__s32 suspend_vdd;
+	__s32 suspend_dcdc2;
+	__s32 suspend_dcdc3;
+	__u32 suspend_freq;
+	__u32 axp_enable;
+	__u32 axp_event;
+	__u32 sys_event;
+	__u32 cpus_gpio_wakeup;
+	__u32 debug_mask;
+	__u32 suspend_delay_ms;
+	__u32 saved_runtime_context_svc[RUNTIME_CONTEXT_SIZE];
+	struct clk_div_t clk_div;
+	struct pll_factor_t pll_factor;
+	struct mmu_state saved_mmu_state;
+//	struct saved_context saved_cpu_context;
+    standy_dram_para_t      dram_para;
+};
+
+typedef  int (*super_standby_func)(void);
+typedef  int (*normal_standby_func)(struct aw_pm_info *arg);
+
+/*mem_mmu_pc_asm.S*/
+extern unsigned int save_sp_nommu(void);
+extern unsigned int save_sp(void);
+extern void clear_reg_context(void);
+extern void restore_sp(unsigned int sp);
+
+//cache
+extern void invalidate_dcache(void);
+extern void flush_icache(void);
+extern void flush_dcache(void);
+extern void disable_cache(void);
+extern void disable_dcache(void);
+extern void disable_l2cache(void);
+extern void enable_cache(void);
+extern void enable_icache(void);
+
+extern void disable_program_flow_prediction(void);
+extern void invalidate_branch_predictor(void);
+extern void enable_program_flow_prediction(void);
+
+extern void mem_flush_tlb(void);
+extern void mem_preload_tlb(void);
+extern void mem_preload_tlb_nommu(void);
+
+void disable_mmu(void);
+void enable_mmu(void);
+
+extern int jump_to_resume(void* pointer, __u32 *addr);
+extern int jump_to_resume0(void* pointer);
+void jump_to_suspend(__u32 ttbr1, super_standby_func p);
+extern int jump_to_resume0_nommu(void* pointer);
+
+/*mmu_pc.c*/
+extern void save_mmu_state(struct mmu_state *saved_mmu_state);
+extern void restore_mmu_state(struct mmu_state *saved_mmu_state);
+void set_ttbr0(void);
+extern void invalidate_dcache(void);
+
+#endif /*_PM_H*/
+
diff --git a/arch/arm/mach-sun7i/pm/pm_config.h b/arch/arm/mach-sun7i/pm/pm_config.h
new file mode 100755
index 0000000..ec51dc4
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/pm_config.h
@@ -0,0 +1,67 @@
+#ifndef _PM_CONFIG_H
+#define _PM_CONFIG_H
+
+#include <generated/autoconf.h> /* liugang,for CONFIG_AW_FPGA_PLATFORM,2013-1-22 */
+#include "mach/memory.h"
+#include "asm-generic/sizes.h"
+
+/*
+ * Copyright (c) 2011-2015 yanggq.young@newbietech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+ #ifdef CONFIG_ARCH_SUN7I
+ #undef CONFIG_ARCH_SUN7I
+ #endif
+ 
+#define CONFIG_ARCH_SUN7I
+//#define SUN7I_FPGA_SIM
+//#define CHECK_IC_VERSION
+ 
+ //#define RETURN_FROM_RESUME0_WITH_MMU    //suspend: 0xf000, resume0: 0xc010, resume1: 0xf000
+//#define RETURN_FROM_RESUME0_WITH_NOMMU // suspend: 0x0000, resume0: 0x4010, resume1: 0x0000
+//#define DIRECT_RETURN_FROM_SUSPEND //not support yet
+//#define WATCH_DOG_RESET
+
+/**start address for function run in sram*/
+#define SRAM_FUNC_START     SW_VA_SRAM_BASE
+#define SRAM_FUNC_START_PA (0x00000000)
+
+#define DRAM_BASE_ADDR      0xc0000000
+#define DRAM_BASE_ADDR_PA   0x40000000
+#define DRAM_TRANING_SIZE   (64)	//64bytes == 16 words.
+
+#define RUNTIME_CONTEXT_SIZE (14) 	//note: r0-r13, 14*4 bytes
+
+#define DRAM_COMPARE_DATA_ADDR (0xc0100000) //1Mbytes offset
+#define DRAM_COMPARE_SIZE (0x10000) //?
+
+
+//for mem mapping
+#define MEM_SW_VA_SRAM_BASE (0x00000000)
+#define MEM_SW_PA_SRAM_BASE (0x00000000)
+
+#define AXP_WAKEUP_KEY          (1<<0)
+#define AXP_WAKEUP_LOWBATT      (1<<1)
+#define AXP_WAKEUP_USB          (1<<2)
+#define AXP_WAKEUP_AC           (1<<3)
+#define AXP_WAKEUP_ASCEND       (1<<4)
+#define AXP_WAKEUP_DESCEND      (1<<5)
+#define AXP_WAKEUP_SHORT_KEY    (1<<6)
+#define AXP_WAKEUP_LONG_KEY     (1<<7)
+ 
+#define AXP_MEM_WAKEUP              (AXP_WAKEUP_LOWBATT | AXP_WAKEUP_USB | AXP_WAKEUP_AC | AXP_WAKEUP_DESCEND | AXP_WAKEUP_ASCEND)
+#define AXP_BOOTFAST_WAKEUP         (AXP_WAKEUP_LOWBATT | AXP_WAKEUP_LONG_KEY)
+#define __AC(X,Y)	(X##Y)
+#define _AC(X,Y)	__AC(X,Y)
+#define _AT(T,X)	((T)(X))
+#define UL(x) _AC(x, UL)
+#define IO_ADDRESS(x)		((x) + 0xf0000000)
+#define MEM_ADDRESS(x)		((x) + 0x80000000)
+
+#define SUSPEND_FREQ (720000)	//720M
+#define SUSPEND_DELAY_MS (10)
+
+#endif /*_PM_CONFIG_H*/
diff --git a/arch/arm/mach-sun7i/pm/pm_debug.h b/arch/arm/mach-sun7i/pm/pm_debug.h
new file mode 120000
index 0000000..e0e6857
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/pm_debug.h
@@ -0,0 +1 @@
+standby/pm_debug.h
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/pm/pm_errcode.h b/arch/arm/mach-sun7i/pm/pm_errcode.h
new file mode 100755
index 0000000..80de78e
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/pm_errcode.h
@@ -0,0 +1,22 @@
+#ifndef _PM_ERR_CODE_H
+#define _PM_ERR_CODE_H
+
+/*
+ * Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+ #define BEFORE_EARLY_SUSPEND	(0x0001)
+ #define EARLY_SUSPEND_START		(0x1000)
+#define  STANDBY_START			(0x2000)
+ #define SUSPEND_START			(0x3000)
+ #define TWI_TRANSFER_STATUS		(0x4000)
+ #define RUSUME0_START			(0x5000)
+ #define RESUME1_START			(0x7000)
+ #define BEFORE_LATE_RESUME		(0x8000)
+ #define LATE_RESUME_START		(0x9000)
+
+#endif /*_PM_ERR_CODE_H*/
diff --git a/arch/arm/mach-sun7i/pm/pm_types.h b/arch/arm/mach-sun7i/pm/pm_types.h
new file mode 100755
index 0000000..8613d01
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/pm_types.h
@@ -0,0 +1,36 @@
+#ifndef _PM_TYPES_H
+#define _PM_TYPES_H
+
+/*
+ * Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+ 
+#ifndef __uxx_sxx_name
+#define __uxx_sxx_name
+typedef signed char         __s8;
+typedef unsigned char       __u8;
+typedef signed short        __s16;
+typedef unsigned short      __u16;
+typedef signed int          __s32;
+typedef unsigned int        __u32;
+typedef signed long long    __s64;
+typedef unsigned long long  __u64;
+
+typedef unsigned int		size_t;
+//typedef unsigned int		ptrdiff_t;
+//------------------------------------------------------------------------------
+//return value defines
+//------------------------------------------------------------------------------
+#define	OK		(0)
+#define	FAIL	(-1)
+#define TRUE	(1)
+#define	FALSE	(0)
+
+
+#endif 
+
+#endif /*_PM_TYPES_H*/
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/pm/standby.S b/arch/arm/mach-sun7i/pm/standby.S
new file mode 100755
index 0000000..3c8b680
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby.S
@@ -0,0 +1,6 @@
+	.globl	standby_bin_start
+standby_bin_start:
+	.incbin	"arch/arm/mach-sun7i/pm/standby/standby.bin"
+	.globl	standby_bin_end
+standby_bin_end:
+	.align	2
diff --git a/arch/arm/mach-sun7i/pm/standby/Makefile b/arch/arm/mach-sun7i/pm/standby/Makefile
new file mode 100755
index 0000000..00b1de0
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/Makefile
@@ -0,0 +1,27 @@
+always	:= standby.bin
+targets := standby.elf
+
+standby-y := common.o standby.o standby_clock.o standby_ir.o standby_key.o \
+	standby_power.o standby_tmr.o standby_twi.o standby_usb.o \
+	standby_delay.o dram.o dram_init.o \
+	pm_debug.o mem_delay.o mem_mmu_pc_asm.o mem_serial.o mem_printk.o \
+	mem_divlibc.o mem_int.o	mem_timing.o mem_divlib.o
+
+targets	+= $(standby-y)
+STANDBY_OBJS = $(addprefix $(obj)/,$(standby-y))
+
+LD_FILE = standby.xn
+
+KBUILD_CFLAGS := $(LINUXINCLUDE) -I$(srctree)/arch/arm/mach-sun7i/pm -Os -g -c
+KBUILD_CFLAGS += -nostdlib -march=armv7-a -marm -mlittle-endian -D__STANDBY_MODULE__
+KBUILD_CFLAGS += -fno-unwind-tables -fno-asynchronous-unwind-tables
+KBUILD_AFLAGS := $(KBUILD_CFLAGS) -D__ASSEMBLY__
+
+LDFLAGS_standby.elf := -T
+OBJCOPYFLAGS_standby.bin := -O binary
+
+$(obj)/standby.elf: $(src)/$(LD_FILE) $(STANDBY_OBJS) FORCE
+	$(call if_changed,ld)
+
+$(obj)/standby.bin: $(obj)/standby.elf FORCE
+	$(call if_changed,objcopy)
diff --git a/arch/arm/mach-sun7i/pm/standby/common.c b/arch/arm/mach-sun7i/pm/standby/common.c
new file mode 100755
index 0000000..c46b176
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/common.c
@@ -0,0 +1,71 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : common.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 19:38
+* Descript: common lib for standby
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+
+/*
+*********************************************************************************************************
+*                           standby_memcpy
+*
+*Description: memory copy function for standby.
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_memcpy(void *dest, void *src, int n)
+{
+    char    *tmp_src = (char *)src;
+    char    *tmp_dst = (char *)dest;
+
+    if(!dest || !src){
+        /* parameter is invalid */
+        return;
+    }
+
+    for( ; n > 0; n--){
+        *tmp_dst ++ = *tmp_src ++;
+    }
+
+    return;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mdelay
+*
+*Description: mdelay function
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_mdelay(int ms)
+{
+    standby_delay(ms * cpu_ms_loopcnt);
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/common.h b/arch/arm/mach-sun7i/pm/standby/common.h
new file mode 100755
index 0000000..c9a91cc
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/common.h
@@ -0,0 +1,67 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : common.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 17:21
+* Descript: common lib for standby.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+
+
+static inline __u64 standby_uldiv(__u64 dividend, __u32 divisior)
+{
+    __u64   tmpDiv = (__u64)divisior;
+    __u64   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return 0;
+    }
+
+    while(!(tmpDiv & ((__u64)1<<63)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
+
+
+
+void standby_memcpy(void *dest, void *src, int n);
+void standby_mdelay(int ms);
+void standby_delay(int cycle);
+void standby_delay_cycle(int cycle);
+
+#endif  //__COMMON_H__
+
diff --git a/arch/arm/mach-sun7i/pm/standby/dram.c b/arch/arm/mach-sun7i/pm/standby/dram.c
new file mode 100755
index 0000000..6020d47
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/dram.c
@@ -0,0 +1,532 @@
+/*
+*********************************************************************************************************
+* File	  : dram_i.h
+* By	  : Berg.Xing
+* Date	  : 2011-12-07
+* Descript: dram for AW1625 chipset
+* Update  : date				auther		ver 	notes
+*			2011-12-07			Berg		1.0 	create file from aw1623
+*			2011-12-31			Berg		1.1 	create file from aw1623
+*			2013-03-06			CPL			1.2		modify for A20
+*********************************************************************************************************
+*/
+#include "dram_i.h"
+
+static __s32 backup_dram_cal_val(int standby_mode);
+
+/*
+*********************************************************************************************************
+*				  DRAM ENTER SELF REFRESH
+*
+* Description: dram enter/exit self-refresh;
+*
+* Arguments  : none
+*
+* Returns	 : none
+*
+* Note		 :
+*********************************************************************************************************
+*/
+void mctl_precharge_all(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x15U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	mem_delay(0x100);
+}
+
+extern void serial_put_char(char c);
+void DRAMC_enter_selfrefresh(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+//	//disable all port
+//	for(i=0; i<31; i++)
+//	{
+//		DRAMC_hostport_on_off(i, 0x0);
+//	}
+
+//	for(i=0; i<8; i++)
+//	{
+//		mctl_write_w(SDR_HPCR + (i<<2), 0);
+//	}
+//
+//	for(i=16; i<28; i++)
+//	{
+//		mctl_write_w(SDR_HPCR + (i<<2), 0);
+//	}
+//
+//	mctl_write_w(SDR_HPCR + (29<<2), 0);
+//	mctl_write_w(SDR_HPCR + (31<<2), 0);
+
+/*
+	//disable auto-fresh
+	reg_val = mctl_read_w(SDR_DRR);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DRR, reg_val);
+*/
+	//issue prechage all command
+//	mctl_precharge_all();
+
+    //1T MODE
+    //reg_val = mctl_read_w(SDR_CCR);
+    //reg_val |= 0x1U<<14;
+    //reg_val &= ~(0x1U<<17);
+    //reg_val |= 0x1<<5;
+    //mctl_write_w(SDR_CCR, reg_val);
+
+    //printk_nommu("[DRAM]before selfrefresh ccr register = %x\n", mctl_read_w(SDR_CCR));
+
+	//enter into self-refresh
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x12U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	mem_delay(0x100);
+	
+	reg_val = mctl_read_w(SDR_CR);
+	reg_val &= ~(0x3<<28);
+	reg_val |= 0x2<<28;
+	mctl_write_w(SDR_CR, reg_val);
+
+	//dram pad odt hold
+	mctl_write_w(SDR_DPCR, 0x16510001);
+	
+	while(!((i = mctl_read_w(SDR_DPCR)) & 0x1));
+    //printk("SDR_DPCR:%d\n",(*((volatile unsigned int *)(SDR_DPCR))));
+    //printk_nommu("SDR_DPCR = %d\n", i);
+	mem_delay(0x100);
+	
+}
+void mctl_mode_exit(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x17U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	mem_delay(0x100);
+}
+
+void DRAMC_exit_selfrefresh(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	//exit self-refresh state
+	mctl_mode_exit();
+
+	//issue a refresh command
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x13U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	mem_delay(0x100);
+
+	//enable auto-fresh
+	reg_val = mctl_read_w(SDR_DRR);
+	reg_val &= ~(0x1U<<31);
+	mctl_write_w(SDR_DRR, reg_val);
+
+	//enable all port
+	for(i=0; i<31; i++)
+	{
+		DRAMC_hostport_on_off(i, 0x1);
+	}
+}
+
+/*
+*********************************************************************************************************
+*				  DRAM POWER DOWN
+*
+* Description: enter/exit dram power down state
+*
+* Arguments  :
+*
+* Returns	 : none;
+*
+* Note		 :
+*********************************************************************************************************
+*/
+void DRAMC_enter_power_down(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x1eU<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	mem_delay(0x100);
+}
+
+void DRAMC_exit_power_down(void)
+{
+	mctl_mode_exit();
+}
+
+/*
+**********************************************************************************************************************
+*				  DRAM HOSTPORT CONTROL
+*
+* Description: dram host port enable/ disable
+*
+* Arguments  : __u32 port_idx		host port index   (0,1,...31)
+*				__u32 on		enable or disable (0: diable, 1: enable)
+*
+* Returns	 :
+*
+* Notes 	 :
+*
+**********************************************************************************************************************
+*/
+void DRAMC_hostport_on_off(__u32 port_idx, __u32 on)
+{
+	__u32	reg_val;
+
+	if(port_idx<=31)
+	{
+		reg_val = mctl_read_w(SDR_HPCR + (port_idx<<2));
+		if(on)
+			reg_val |= 0x1;
+		else
+			reg_val &= ~(0x1);
+		mctl_write_w(SDR_HPCR + (port_idx<<2), reg_val);
+	}
+}
+/*
+**********************************************************************************************************************
+*				  DRAM GET HOSTPORT STATUS
+*
+* Description: dram get AHB FIFO status
+*
+* Arguments  : __u32 port_idx		host port index 	(0,1,...31)
+*
+* Returns	 : __u32 ret_val		AHB FIFO status 	(0: FIFO not empty ,1: FIFO empty)
+*
+* Notes 	 :
+*
+**********************************************************************************************************************
+*/
+__u32 DRAMC_hostport_check_ahb_fifo_status(__u32 port_idx)
+{
+	__u32	reg_val;
+
+	if(port_idx<=31)
+	{
+		reg_val = mctl_read_w(SDR_CFSR);
+		return ( (reg_val>>port_idx)&0x1 );
+	}
+	else
+	{
+		return 0;
+	}
+}
+/*
+**********************************************************************************************************************
+*				  DRAM GET HOSTPORT STATUS
+*
+* Description: dram get AHB FIFO status
+*
+* Arguments  :	__u32 port_idx				host port index 	(0,1,...31)
+*				__u32 port_pri_level		priority level		(0,1,2,3)
+*
+* Returns	 :
+*
+* Notes 	 :
+*
+**********************************************************************************************************************
+*/
+void DRAMC_hostport_setup(__u32 port_idx, __u32 port_pri_level, __u32 port_wait_cycle, __u32 cmd_num)
+{
+	__u32	reg_val;
+
+	if(port_idx<=31)
+	{
+		reg_val = mctl_read_w(SDR_HPCR + (port_idx<<2));
+		reg_val &= ~(0x3<<2);
+		reg_val |= (port_pri_level&0x3)<<2;
+		reg_val &= ~(0xf<<4);
+		reg_val |= (port_wait_cycle&0xf)<<4;
+		reg_val &= ~(0xff<<8);
+		reg_val |= (cmd_num&0x3)<<8;
+		mctl_write_w(SDR_HPCR + (port_idx<<2), reg_val);
+	}
+}
+/*
+*********************************************************************************************************
+*				  DRAM power save process
+*
+* Description: We can save power by disable DRAM PLL.
+*
+* Arguments  : none
+*
+* Returns	 : none
+*
+* Note		 :
+*********************************************************************************************************
+*/
+__u32 mctl_ahb_reset(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+	reg_val &=~(0x3<<14);
+	mctl_write_w(DRAM_CCM_AHB_GATE_REG,reg_val);
+	mem_delay(0x10);
+
+	reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+	reg_val |=(0x3<<14);
+	mctl_write_w(DRAM_CCM_AHB_GATE_REG,reg_val);
+}
+
+/*
+__s32 DRAMC_retraining(void)
+{
+	__u32 i;
+	__u32 reg_val;
+	__u32 ret_val;
+	__u32 reg_dcr, reg_drr, reg_tpr0, reg_tpr1, reg_tpr2, reg_mr, reg_emr, reg_emr2, reg_emr3;
+	__u32 reg_zqcr0, reg_iocr, reg_ccr, reg_zqsr;
+
+	//remember register value
+	reg_dcr = mctl_read_w(SDR_DCR);
+	reg_drr = mctl_read_w(SDR_DRR);
+	reg_tpr0 = mctl_read_w(SDR_TPR0);
+	reg_tpr1 = mctl_read_w(SDR_TPR1);
+	reg_tpr2 = mctl_read_w(SDR_TPR2);
+	reg_mr = mctl_read_w(SDR_MR);
+	reg_emr = mctl_read_w(SDR_EMR);
+	reg_emr2 = mctl_read_w(SDR_EMR2);
+	reg_emr3 = mctl_read_w(SDR_EMR3);
+	reg_zqcr0 = mctl_read_w(SDR_ZQCR0);
+	reg_iocr = mctl_read_w(SDR_IOCR);
+	reg_ccr = mctl_read_w(SDR_CCR);
+	reg_zqsr = mctl_read_w(SDR_ZQSR);
+	while(1){
+		mctl_ahb_reset();
+
+		mctl_ddr3_reset();
+		mctl_set_drive();
+
+		mctl_itm_disable();
+
+		mctl_enable_dll0();
+
+		//set CCR value
+		mctl_write_w(SDR_CCR, reg_ccr);
+
+		//configure external DRAM
+		mctl_write_w(SDR_DCR, reg_dcr);
+
+		//set ZQ value
+		reg_val = reg_zqsr&0xfffff;
+		reg_val |= 0x1<<30;
+		reg_val |= 0x1<<28;
+		reg_val |= reg_zqcr0&(0xff<<20);
+		reg_val |= reg_zqcr0&(0x1<<29);
+		mctl_write_w(SDR_ZQCR0, reg_val);
+
+		//dram clock on
+		DRAMC_clock_output_en(1);
+
+		mem_delay(0x10);
+		while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+		mctl_enable_dllx();
+
+		//set I/O configure register
+		mctl_write_w(SDR_IOCR, reg_iocr);
+
+		//set refresh period
+		mctl_write_w(SDR_DRR, reg_drr);
+
+		//set timing parameters
+		mctl_write_w(SDR_TPR0, reg_tpr0);
+		mctl_write_w(SDR_TPR1, reg_tpr1);
+		mctl_write_w(SDR_TPR2, reg_tpr2);
+
+		//set mode register
+		mctl_write_w(SDR_MR, reg_mr);
+		mctl_write_w(SDR_EMR, reg_emr);
+		mctl_write_w(SDR_EMR2, reg_emr2);
+		mctl_write_w(SDR_EMR3, reg_emr3);
+
+		//initial external DRAM
+		reg_val = mctl_read_w(SDR_CCR);
+		reg_val |= 0x1U<<31;
+		mctl_write_w(SDR_CCR, reg_val);
+		while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+		//dram pad hold release
+		mctl_write_w(SDR_DPCR, 0x16510000);
+		mem_delay(0x10000);
+
+		//scan read pipe value
+		mctl_itm_enable();
+		ret_val = DRAMC_scan_readpipe();
+
+		//configure all host port
+		mctl_configure_hostport();
+
+		if(ret_val == 0)
+			return 0;
+	}
+}
+*/
+#define SAVE_SDR_ZQSR_TO_RTC
+
+/*
+ * backup dram calibration value
+ */
+static __s32 backup_dram_cal_val(int standby_mode)
+{
+#ifdef SAVE_SDR_ZQSR_TO_RTC
+	__u32 reg_val;
+	//save memc ZQ value into RTC GP register
+	reg_val = mctl_read_w(SDR_ZQSR)&0xfffff;
+    if (standby_mode != 0)
+    {
+        reg_val |= 0x1<<20;             //super standby flag
+    }
+	mctl_write_w(SDR_GP_REG0, reg_val);
+    
+	reg_val = mctl_read_w(SDR_RSLR0);
+	mctl_write_w(SDR_GP_REG1, reg_val);
+    
+	reg_val = mctl_read_w(SDR_RDQSGR);
+	mctl_write_w(SDR_GP_REG2, reg_val);
+	return 0;
+	
+#elif defined(SAVE_SDR_ZQSR_TO_AXP)
+
+	__u32 value;
+	__u8 reg_addr_1st = 0x0a;
+	__u8 reg_addr_2nd = 0x0b;
+	__u8 reg_addr_3rd = 0x0c;
+	__u8 reg_val;
+
+	
+	value = mctl_read_w(SDR_ZQSR) & 0xfffff;
+	//busy_waiting();
+
+	reg_val = value&0xff;
+	if(twi_byte_rw(TWI_OP_WR, AXP_ADDR,reg_addr_1st, &reg_val)){
+		return -1;
+	}
+
+	reg_val = (value>>8)&0xff;
+	if(twi_byte_rw(TWI_OP_WR, AXP_ADDR,reg_addr_2nd, &reg_val)){
+		return -1;
+	}
+
+	reg_val = (value>>16)&0x0f;
+	if(twi_byte_rw(TWI_OP_WR, AXP_ADDR,reg_addr_3rd, &reg_val)){
+		return -1;
+	}
+
+	return 0;
+#else 
+#error "super standby has not save SDR_ZQSR"
+#endif
+}
+
+__s32 dram_power_save_process(int standby_mode)
+{
+    __u32 reg_val;
+    
+	#define MAX_RETRY_TIMES (5)
+	
+	__s32 retry = MAX_RETRY_TIMES;
+	
+	while((-1 == backup_dram_cal_val(standby_mode)) && --retry){
+		;
+	}
+	if(0 == retry){
+		return -1;
+	}else{
+		retry = MAX_RETRY_TIMES;
+	}	
+	
+	//put external SDRAM into self-fresh state
+	DRAMC_enter_selfrefresh();
+
+//	//disable ITM
+//	mctl_itm_disable();
+//
+//	//disable and reset all DLL
+//	mctl_disable_dll();
+
+    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+    reg_val &= ~(0x3<<14);
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+
+	return 0;
+}
+/*__u32 dram_power_up_process(void)
+{
+	return DRAMC_retraining();
+}
+*/
+
+
+void dram_enter_selfrefresh(void)
+{
+	DRAMC_enter_selfrefresh();
+}
+
+
+void dram_exit_selfrefresh(void)
+{
+	DRAMC_exit_selfrefresh();
+}
+
+
+void dram_enter_power_down(void)
+{
+	DRAMC_enter_power_down();
+}
+
+
+void dram_exit_power_down(void)
+{
+	DRAMC_exit_power_down();
+}
+
+
+void dram_hostport_on_off(__u32 port_idx, __u32 on)
+{
+	DRAMC_hostport_on_off(port_idx, on);
+}
+
+
+__u32 dram_hostport_check_ahb_fifo_status(__u32 port_idx)
+{
+	return DRAMC_hostport_check_ahb_fifo_status(port_idx);
+}
+
+
+void dram_hostport_setup(__u32 port, __u32 prio, __u32 wait_cycle, __u32 cmd_num)
+{
+	DRAMC_hostport_setup(port, prio, wait_cycle, cmd_num);
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/dram_i.h b/arch/arm/mach-sun7i/pm/standby/dram_i.h
new file mode 100755
index 0000000..bc100ac
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/dram_i.h
@@ -0,0 +1,105 @@
+/*
+*********************************************************************************************************
+* File    : dram_i.h
+* By      : Berg.Xing
+* Date    : 2011-12-07
+* Descript: dram for AW1625 chipset
+* Update  : date                auther      ver     notes
+*			2011-12-07			Berg        1.0     create file from aw1623
+*********************************************************************************************************
+*/
+#ifndef __DRAM_I_H__
+#define __DRAM_I_H__
+
+#include <mach/dram.h>
+#include "../pm_types.h" 
+#include "../pm.h"
+#include "mem_int.h"
+
+#define DRAMC_IO_BASE       SW_PA_DRAM_IO_BASE
+#define DRAMC_MEM_SIZE      0x400
+
+#define SDR_CCR				(DRAMC_IO_BASE + 0x00)
+#define SDR_DCR				(DRAMC_IO_BASE + 0x04)
+#define SDR_IOCR			(DRAMC_IO_BASE + 0x08)
+#define SDR_CSR				(DRAMC_IO_BASE + 0x0c)
+#define SDR_DRR				(DRAMC_IO_BASE + 0x10)
+#define SDR_TPR0			(DRAMC_IO_BASE + 0x14)
+#define SDR_TPR1			(DRAMC_IO_BASE + 0x18)
+#define SDR_TPR2			(DRAMC_IO_BASE + 0x1c)
+#define SDR_RSLR0			(DRAMC_IO_BASE + 0x4c)
+#define SDR_RSLR1			(DRAMC_IO_BASE + 0x50)
+#define SDR_RDQSGR			(DRAMC_IO_BASE + 0x5c)
+#define SDR_ODTCR			(DRAMC_IO_BASE + 0x98)
+#define SDR_DTR0			(DRAMC_IO_BASE + 0x9c)
+#define SDR_DTR1			(DRAMC_IO_BASE + 0xa0)
+#define SDR_DTAR			(DRAMC_IO_BASE + 0xa4)
+#define SDR_ZQCR0			(DRAMC_IO_BASE + 0xa8)
+#define SDR_ZQCR1			(DRAMC_IO_BASE + 0xac)
+#define SDR_ZQSR			(DRAMC_IO_BASE + 0xb0)
+#define SDR_IDCR			(DRAMC_IO_BASE + 0xb4)
+#define SDR_MR				(DRAMC_IO_BASE + 0x1f0)
+#define SDR_EMR				(DRAMC_IO_BASE + 0x1f4)
+#define SDR_EMR2			(DRAMC_IO_BASE + 0x1f8)
+#define SDR_EMR3  			(DRAMC_IO_BASE + 0x1fc)
+#define SDR_DLLCR			(DRAMC_IO_BASE + 0x200)
+#define SDR_DLLCR0			(DRAMC_IO_BASE + 0x204)
+#define SDR_DLLCR1			(DRAMC_IO_BASE + 0x208)
+#define SDR_DLLCR2			(DRAMC_IO_BASE + 0x20c)
+#define SDR_DLLCR3			(DRAMC_IO_BASE + 0x210)
+#define SDR_DLLCR4			(DRAMC_IO_BASE + 0x214)
+#define SDR_DQTR0			(DRAMC_IO_BASE + 0x218)
+#define SDR_DQTR1			(DRAMC_IO_BASE + 0x21c)
+#define SDR_DQTR2			(DRAMC_IO_BASE + 0x220)
+#define SDR_DQTR3			(DRAMC_IO_BASE + 0x224)
+#define SDR_DQSTR0			(DRAMC_IO_BASE + 0x228)
+#define SDR_DQSTR1			(DRAMC_IO_BASE + 0x22c)
+#define SDR_CR				(DRAMC_IO_BASE + 0x230)
+#define SDR_CFSR			(DRAMC_IO_BASE + 0x234)
+#define SDR_DPCR			(DRAMC_IO_BASE + 0x23c)
+#define SDR_APR  			(DRAMC_IO_BASE + 0x240)
+#define SDR_LTR	  			(DRAMC_IO_BASE + 0x244)
+#define SDR_HPCR			(DRAMC_IO_BASE + 0x250)
+#define SDR_SCSR			(DRAMC_IO_BASE + 0x2e0)
+
+#define RTC_BASE			SW_PA_TIMERC_IO_BASE
+#define SDR_GP_REG0				(RTC_BASE + 0x120)
+#define SDR_GP_REG1				(RTC_BASE + 0x124)
+#define SDR_GP_REG2				(RTC_BASE + 0x128)
+
+
+#define mctl_read_w(n)      (*((volatile unsigned int *)(n)))
+#define mctl_write_w(n,c)   (*((volatile unsigned int *)(n)) = (c))
+
+
+//CCM register for dram
+#define DRAM_CCM_BASE       SW_PA_CCM_IO_BASE
+#define DRAM_CCM_MEMSIZE    0x400
+
+#define DRAM_CCM_SDRAM_PLL_REG    (DRAM_CCM_BASE + 0x20)
+#define DRAM_CCM_AHB_GATE_REG     (DRAM_CCM_BASE + 0x60)
+#define DRAM_CCM_GPS_CLK_REG      (DRAM_CCM_BASE + 0xd0)
+#define DRAM_CCM_SDRAM_CLK_REG    (DRAM_CCM_BASE + 0x100)
+#define DRAM_CCM_MUS_CLK_REG      (DRAM_CCM_BASE + 0x15c)
+
+//TIMER register for system
+#define DRAM_TIMER_BASE     SW_PA_TIMERC_IO_BASE
+#define TIMER_CPU_CFG_REG   (DRAM_TIMER_BASE + 0x13c)
+
+
+extern void 	DRAMC_clock_output_en(__u32 on);
+extern void 	DRAMC_set_autorefresh_cycle(__u32 clk);
+extern int  	DRAMC_scan_readpipe(void);
+extern unsigned DRAMC_get_dram_size(void);
+
+extern void mctl_itm_disable(void);
+extern void mctl_itm_enable(void);
+extern void mctl_enable_dll0(__u32 phase);
+extern void mctl_enable_dllx(__u32 phase);
+extern void mctl_disable_dll(void);
+extern void DRAMC_hostport_on_off(__u32 port_idx, __u32 on);
+extern __s32 init_DRAM(standy_dram_para_t *boot0_para);
+
+
+#endif  //__DRAM_REG_H__
+
diff --git a/arch/arm/mach-sun7i/pm/standby/dram_init.c b/arch/arm/mach-sun7i/pm/standby/dram_init.c
new file mode 100755
index 0000000..797e33f
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/dram_init.c
@@ -0,0 +1,759 @@
+/*
+*********************************************************************************************************
+* File    : dram_init.c
+* By      : Berg.Xing
+* Date    : 2011-12-07
+* Descript: dram for AW1625 chipset
+* Update  : date                auther      ver     notes
+*           2011-12-07          Berg        1.0     create file from A10
+*           2012-01-11          Berg        1.1     kill bug for 1/2 rank decision
+*           2012-01-31          Berg        1.2     kill bug for clock frequency > 600MHz
+*           2013-03-06          CPL         1.3     modify for A20
+*********************************************************************************************************
+*/
+#include "dram_i.h"
+
+/******************************************************************************/
+/*                              file head of Boot                             */
+/******************************************************************************/
+typedef struct _Boot_file_head
+{
+        __u32  jump_instruction;   // one intruction jumping to real code
+        __u8   magic[8];           // ="eGON.BT0" or "eGON.BT1",  not C-style string.
+        __u32  check_sum;          // generated by PC
+        __u32  length;             // generated by PC
+        __u32  pub_head_size;      // the size of boot_file_head_t
+        __u8   pub_head_vsn[4];    // the version of boot_file_head_t
+        __u8   file_head_vsn[4];   // the version of boot0_file_head_t or boot1_file_head_t
+        __u8   Boot_vsn[4];        // Boot version
+        __u8   eGON_vsn[4];        // eGON version
+        __u8   platform[8];        // platform information
+}boot_file_head_t;
+
+
+typedef struct _boot_para_info_t
+{
+    __u8   blkmagic[16];          // "ePDK-Magic-Block", not C-style string.
+    __u8   magic[8];
+    __u8   eGON_vsn[4];           // eGON version
+        __u8   Boot_vsn[4];           // Boot version
+    __u32  reserved[20];
+}boot_para_info_t;
+
+//???oGPIO?1??y?Y?11
+typedef struct _normal_gpio_cfg
+{
+    __u8      port;                       //???o?
+    __u8      port_num;                   //????o?
+    __s8      mul_sel;                    //1|?o?
+    __s8      pull;                       //??
+    __s8      drv_level;                  //?y??y??|
+    __s8      data;                       //?3????
+    __u8      reserved[2];                //?????????
+}
+normal_gpio_cfg;
+
+/******************************************************************************/
+/*                              file head of Boot0                            */
+/******************************************************************************/
+typedef struct _boot0_private_head_t
+{
+        __u32                       prvt_head_size;
+        char                        prvt_head_vsn[4];       // the version of boot0_private_head_t
+        standy_dram_para_t          dram_para;              // DRAM patameters for initialising dram. Original values is arbitrary,
+        __s32                                           uart_port;              // UART?????o?
+        normal_gpio_cfg             uart_ctrl[2];           // UART?????(???)y?YD??
+        __s32                       enable_jtag;            // 1 : enable,  0 : disable
+    normal_gpio_cfg                 jtag_gpio[5];           // ?JTAG??2?GPIOD??
+    normal_gpio_cfg             storage_gpio[32];       // ?? GPIOD??
+    char                        storage_data[512 - sizeof(normal_gpio_cfg) * 32];      // ???y?YD??
+    //boot_nand_connect_info_t    nand_connect_info;
+}boot0_private_head_t;
+
+
+typedef struct _boot0_file_head_t
+{
+        boot_file_head_t      boot_head;
+        boot0_private_head_t  prvt_head;
+}boot0_file_head_t;
+
+typedef  standy_dram_para_t               __dram_para_t;
+
+
+
+/*
+*********************************************************************************************************
+*                                   DRAM INIT
+*
+* Description: dram init function
+*
+* Arguments  : para     dram config parameter
+*
+*
+* Returns    : result
+*
+* Note       :
+*********************************************************************************************************
+*/
+void mctl_ddr3_reset(void)
+{
+    __u32 reg_val;
+
+    reg_val = mctl_read_w(SDR_CR);
+    reg_val &= ~(0x1<<12);
+    mctl_write_w(SDR_CR, reg_val);
+    mem_delay(0x100);
+    reg_val = mctl_read_w(SDR_CR);
+    reg_val |= (0x1<<12);
+    mctl_write_w(SDR_CR, reg_val);
+}
+
+void mctl_set_drive(void)
+{
+    __u32 reg_val;
+
+    reg_val = mctl_read_w(SDR_CR);
+    reg_val |= (0x6<<12);
+    reg_val |= 0xFFC;
+    reg_val &= ~0x3;
+    reg_val &= ~(0x3<<28);
+    //  reg_val |= 0x7<<20;
+    mctl_write_w(SDR_CR, reg_val);
+}
+
+void mctl_itm_disable(void)
+{
+    __u32 reg_val = 0x0;
+
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1<<28;
+    reg_val &= ~(0x1U<<31);          //danielwang, 2012-05-18
+    mctl_write_w(SDR_CCR, reg_val);
+}
+
+void mctl_itm_enable(void)
+{
+    __u32 reg_val = 0x0;
+
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val &= ~(0x1<<28);
+    mctl_write_w(SDR_CCR, reg_val);
+}
+
+void mctl_enable_dll0(__u32 phase)
+{
+    mctl_write_w(SDR_DLLCR0, (mctl_read_w(SDR_DLLCR0) & ~(0x3f<<6)) | (((phase>>16)&0x3f)<<6));
+    mctl_write_w(SDR_DLLCR0, (mctl_read_w(SDR_DLLCR0) & ~0x40000000) | 0x80000000);
+
+    //mctl_delay(0x100);
+    delay_us(10);
+
+    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0xC0000000);
+
+    //mctl_delay(0x1000);
+    delay_us(10);
+
+    mctl_write_w(SDR_DLLCR0, (mctl_read_w(SDR_DLLCR0) & ~0x80000000) | 0x40000000);
+    //mctl_delay(0x1000);
+    delay_us(100);
+}
+
+void mctl_enable_dllx(__u32 phase)
+{
+    __u32 i = 0;
+    __u32 reg_val;
+    __u32 dll_num;
+    __u32   dqs_phase = phase;
+
+    reg_val = mctl_read_w(SDR_DCR);
+    reg_val >>=6;
+    reg_val &= 0x7;
+    if(reg_val == 3)
+        dll_num = 5;
+    else
+        dll_num = 3;
+
+    for(i=1; i<dll_num; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), (mctl_read_w(SDR_DLLCR0+(i<<2)) & ~(0xf<<14)) | ((dqs_phase&0xf)<<14));
+        mctl_write_w(SDR_DLLCR0+(i<<2), (mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x40000000) | 0x80000000);
+        dqs_phase = dqs_phase>>4;
+    }
+
+    //mctl_delay(0x100);
+    delay_us(10);
+
+    for(i=1; i<dll_num; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0xC0000000);
+    }
+
+    //mctl_delay(0x1000);
+    delay_us(10);
+
+    for(i=1; i<dll_num; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), (mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x80000000) | 0x40000000);
+    }
+    //mctl_delay(0x1000);
+    delay_us(100);
+}
+
+void mctl_disable_dll(void)
+{
+    __u32 reg_val;
+
+    reg_val = mctl_read_w(SDR_DLLCR0);
+    reg_val &= ~(0x1<<30);
+    reg_val |= 0x1U<<31;
+    mctl_write_w(SDR_DLLCR0, reg_val);
+
+    reg_val = mctl_read_w(SDR_DLLCR1);
+    reg_val &= ~(0x1<<30);
+    reg_val |= 0x1U<<31;
+    mctl_write_w(SDR_DLLCR1, reg_val);
+
+    reg_val = mctl_read_w(SDR_DLLCR2);
+    reg_val &= ~(0x1<<30);
+    reg_val |= 0x1U<<31;
+    mctl_write_w(SDR_DLLCR2, reg_val);
+
+    reg_val = mctl_read_w(SDR_DLLCR3);
+    reg_val &= ~(0x1<<30);
+    reg_val |= 0x1U<<31;
+    mctl_write_w(SDR_DLLCR3, reg_val);
+
+    reg_val = mctl_read_w(SDR_DLLCR4);
+    reg_val &= ~(0x1<<30);
+    reg_val |= 0x1U<<31;
+    mctl_write_w(SDR_DLLCR4, reg_val);
+}
+
+__u32 hpcr_value[32] = {
+    0x00000301,0x00000301,0x00000301,0x00000301,
+    0x00000301,0x00000301,0x00000301,0x00000301,
+    0x0,       0x0,       0x0,       0x0,
+    0x0,       0x0,       0x0,       0x0,
+    0x00001031,0x00001031,0x00000735,0x00001035,
+    0x00001035,0x00000731,0x00001031,0x00000735,
+    0x00001035,0x00001031,0x00000731,0x00001035,
+    0x00001031,0x00000301,0x00000301,0x00000731,
+};
+void mctl_configure_hostport(void)
+{
+    __u32 i;
+
+    for(i=0; i<8; i++)
+    {
+        mctl_write_w(SDR_HPCR + (i<<2), hpcr_value[i]);
+    }
+    
+    for(i=16; i<28; i++)
+    {
+        mctl_write_w(SDR_HPCR + (i<<2), hpcr_value[i]);
+    }   
+    
+    mctl_write_w(SDR_HPCR + (29<<2), hpcr_value[i]);
+    mctl_write_w(SDR_HPCR + (31<<2), hpcr_value[i]);
+}
+
+
+void mctl_setup_dram_clock(__u32 clk)
+{
+    __u32 reg_val;
+
+    //setup DRAM PLL
+    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
+    reg_val &= ~0x3;
+    reg_val |= 0x1;                                             //m factor
+    reg_val &= ~(0x3<<4);
+    reg_val |= 0x1<<4;                                          //k factor
+    reg_val &= ~(0x1f<<8);
+    reg_val |= ((clk/24)&0x1f)<<8;                              //n factor
+    reg_val &= ~(0x3<<16);
+    reg_val |= 0x1<<16;                                         //p factor
+    reg_val &= ~(0x1<<29);                                      //clock output disable
+    reg_val |= (__u32)0x1<<31;                                  //PLL En
+    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
+    //mctl_delay(0x100000);
+    delay_us(10000);
+    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
+    reg_val |= 0x1<<29;
+    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
+
+    //setup MBUS clock
+    reg_val = (0x1U<<31) | (0x1<<24) | (0x1<<0) | (0x1<<16);
+    mctl_write_w(DRAM_CCM_MUS_CLK_REG, reg_val);
+
+    //open DRAMC AHB & DLL register clock
+    //close it first
+    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+    reg_val &= ~(0x3<<14);
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+    delay_us(10);
+    //then open it
+    reg_val |= 0x3<<14;
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+    delay_us(10);
+    
+}
+
+__s32 DRAMC_init(__dram_para_t *para)
+{
+    __u32 reg_val;
+	__u32 hold_flag = 0;
+    __u8  reg_value;
+    __s32 ret_val;  
+
+    //check input dram parameter structure
+    if(!para)
+    {
+        //dram parameter is invalid
+        return 0;
+    }
+
+    //setup DRAM relative clock
+    mctl_setup_dram_clock(para->dram_clk);
+
+
+    mctl_set_drive();
+
+    //dram clock off
+    DRAMC_clock_output_en(0);
+
+
+    mctl_itm_disable();
+    mctl_enable_dll0(para->dram_tpr3);
+
+    //configure external DRAM
+    reg_val = 0;
+    if(para->dram_type == 3)
+        reg_val |= 0x1;
+    reg_val |= (para->dram_io_width>>3) <<1;
+
+    if(para->dram_chip_density == 256)
+        reg_val |= 0x0<<3;
+    else if(para->dram_chip_density == 512)
+        reg_val |= 0x1<<3;
+    else if(para->dram_chip_density == 1024)
+        reg_val |= 0x2<<3;
+    else if(para->dram_chip_density == 2048)
+        reg_val |= 0x3<<3;
+    else if(para->dram_chip_density == 4096)
+        reg_val |= 0x4<<3;
+    else if(para->dram_chip_density == 8192)
+        reg_val |= 0x5<<3;
+    else
+        reg_val |= 0x0<<3;
+    reg_val |= ((para->dram_bus_width>>3) - 1)<<6;
+    reg_val |= (para->dram_rank_num -1)<<10;
+    reg_val |= 0x1<<12;
+    reg_val |= ((0x1)&0x3)<<13;
+    mctl_write_w(SDR_DCR, reg_val);
+
+    //SDR_ZQCR1 set bit24 to 1
+    reg_val  = mctl_read_w(SDR_ZQCR1);
+    reg_val |= (0x1<<24) | (0x1<<1);
+    if(para->dram_tpr4 & 0x2)
+    {
+        reg_val &= ~((0x1<<24) | (0x1<<1));
+    }    
+    mctl_write_w(SDR_ZQCR1, reg_val);
+
+    //dram clock on
+    DRAMC_clock_output_en(1);
+    
+    hold_flag = mctl_read_w(SDR_DPCR);
+    if(hold_flag == 0) //normal branch
+    {
+        //set odt impendance divide ratio
+        reg_val=((para->dram_zq)>>8)&0xfffff;
+        reg_val |= ((para->dram_zq)&0xff)<<20;
+        reg_val |= (para->dram_zq)&0xf0000000;
+        reg_val |= (0x1u<<31);
+        mctl_write_w(SDR_ZQCR0, reg_val);
+        
+        while( !((mctl_read_w(SDR_ZQSR)&(0x1u<<31))) );
+
+	}            
+        //Set CKE Delay to about 1ms
+        reg_val = mctl_read_w(SDR_IDCR);
+        reg_val |= 0x1ffff;
+        mctl_write_w(SDR_IDCR, reg_val);
+	
+//      //dram clock on
+//      DRAMC_clock_output_en(1);
+    //reset external DRAM when CKE is Low
+    //reg_val = mctl_read_w(SDR_DPCR);
+    if(hold_flag == 0) //normal branch
+    {
+        //reset ddr3
+        mctl_ddr3_reset();
+    }
+    else
+    {
+        //setup the DDR3 reset pin to high level
+        reg_val = mctl_read_w(SDR_CR);
+        reg_val |= (0x1<<12);
+        mctl_write_w(SDR_CR, reg_val);
+    }
+    
+    mem_delay(0x10);
+    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+    mctl_enable_dllx(para->dram_tpr3);
+    //set I/O configure register
+//    reg_val = 0x00cc0000;
+//   reg_val |= (para->dram_odt_en)&0x3;
+//  reg_val |= ((para->dram_odt_en)&0x3)<<30;
+//    mctl_write_w(SDR_IOCR, reg_val);
+
+    //set refresh period
+    DRAMC_set_autorefresh_cycle(para->dram_clk);
+
+    //set timing parameters
+    mctl_write_w(SDR_TPR0, para->dram_tpr0);
+    mctl_write_w(SDR_TPR1, para->dram_tpr1);
+    mctl_write_w(SDR_TPR2, para->dram_tpr2);
+
+    //set mode register
+    if(para->dram_type==3)                          //ddr3
+    {
+        reg_val = 0x1<<12;
+        reg_val |= (para->dram_cas - 4)<<4;
+        reg_val |= 0x5<<9;
+    }
+    else if(para->dram_type==2)                 //ddr2
+    {
+        reg_val = 0x2;
+        reg_val |= para->dram_cas<<4;
+        reg_val |= 0x5<<9;
+    }
+    mctl_write_w(SDR_MR, reg_val);
+
+    mctl_write_w(SDR_EMR, para->dram_emr1);
+    mctl_write_w(SDR_EMR2, para->dram_emr2);
+    mctl_write_w(SDR_EMR3, para->dram_emr3);
+
+    //set DQS window mode
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1U<<14;
+    reg_val &= ~(0x1U<<17);
+        //2T & 1T mode 
+    if(para->dram_tpr4 & 0x1)
+    {
+        reg_val |= 0x1<<5;
+    }
+    mctl_write_w(SDR_CCR, reg_val);
+
+    //initial external DRAM
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1U<<31;
+    mctl_write_w(SDR_CCR, reg_val);
+
+    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+    
+//  while(1);
+
+    //setup zq calibration manual
+    //reg_val = mctl_read_w(SDR_DPCR);
+    if(hold_flag == 1)
+    {
+
+//      super_standby_flag = 1;
+
+        reg_val = mctl_read_w(SDR_GP_REG0);
+        reg_val &= 0x000fffff;
+        mctl_write_w(SDR_GP_REG0, reg_val);
+        //reg_val |= 0x17b00000;
+        reg_val |= (0x1<<28) | (para->dram_zq<<20);
+        mctl_write_w(SDR_ZQCR0, reg_val);
+        
+        //03-08
+        reg_val = mctl_read_w(SDR_DCR);
+        reg_val &= ~(0x1fU<<27);
+        reg_val |= 0x12U<<27;
+        mctl_write_w(SDR_DCR, reg_val);
+        while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+        
+        mem_delay(0x100);
+
+        //dram pad hold off
+        mctl_write_w(SDR_DPCR, 0x16510000);
+        
+        while(mctl_read_w(SDR_DPCR) & 0x1){}        
+                
+        //exit self-refresh state
+        reg_val = mctl_read_w(SDR_DCR);
+        reg_val &= ~(0x1fU<<27);
+        reg_val |= 0x17U<<27;
+        mctl_write_w(SDR_DCR, reg_val);
+    
+        //check whether command has been executed
+        while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+        mem_delay(0x100);;
+    
+//        //issue a refresh command
+//        reg_val = mctl_read_w(SDR_DCR);
+//        reg_val &= ~(0x1fU<<27);
+//        reg_val |= 0x13U<<27;
+//        mctl_write_w(SDR_DCR, reg_val);
+//        
+//        while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+//
+//        mem_delay(0x100);
+    }
+
+    //scan read pipe value
+    mctl_itm_enable();
+    
+    if(hold_flag == 0)//normal branch
+    {
+    	ret_val = DRAMC_scan_readpipe();
+    	
+    	if(ret_val < 0)
+	    {
+	        return 0;
+	    }
+    
+    }else	//super standby branch
+    {
+    	//write back dqs gating value
+        reg_val = mctl_read_w(SDR_GP_REG1);
+        mctl_write_w(SDR_RSLR0, reg_val);
+
+        reg_val = mctl_read_w(SDR_GP_REG2);
+        mctl_write_w(SDR_RDQSGR, reg_val);
+
+      //mctl_write_w(SDR_RSLR0, dqs_value_save[0]);
+	  //mctl_write_w(SDR_RDQSGR, dqs_value_save[1]);
+    }
+    
+    //configure all host port
+    mctl_configure_hostport();
+
+    return DRAMC_get_dram_size();
+}
+
+
+
+__s32 DRAMC_scan_readpipe(void)
+{
+    __u32 reg_val;
+
+    //Clear Error Flag
+    reg_val = mctl_read_w(SDR_CSR);
+    reg_val &= ~(0x1<<20);
+    mctl_write_w(SDR_CSR, reg_val);
+    
+    //data training trigger
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1<<30;
+    mctl_write_w(SDR_CCR, reg_val);
+
+    //check whether data training process is end
+    while(mctl_read_w(SDR_CCR) & (0x1<<30)) {};
+
+    //check data training result
+    reg_val = mctl_read_w(SDR_CSR);
+    if(reg_val & (0x1<<20))
+    {
+        return -1;
+    }
+
+    return (0);
+}
+
+/*
+*********************************************************************************************************
+*                                   DRAM SCAN READ PIPE
+*
+* Description: dram scan read pipe
+*
+* Arguments  : none
+*
+* Returns    : result, 0:fail, 1:success;
+*
+* Note       :
+*********************************************************************************************************
+*/
+
+
+/*
+*********************************************************************************************************
+*                                   DRAM CLOCK CONTROL
+*
+* Description: dram get clock
+*
+* Arguments  : on   dram clock output (0: disable, 1: enable)
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+void DRAMC_clock_output_en(__u32 on)
+{
+    __u32 reg_val;
+
+    reg_val = mctl_read_w(SDR_CR);
+
+    if(on)
+        reg_val |= 0x1<<16;
+    else
+        reg_val &= ~(0x1<<16);
+
+    mctl_write_w(SDR_CR, reg_val);
+}
+/*
+*********************************************************************************************************
+* Description: Set autorefresh cycle
+*
+* Arguments  : clock value in MHz unit
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+void DRAMC_set_autorefresh_cycle(__u32 clk)
+{
+    __u32 reg_val;
+//  __u32 dram_size;
+    __u32 tmp_val;
+
+//  dram_size = mctl_read_w(SDR_DCR);
+//  dram_size >>=3;
+//  dram_size &= 0x7;
+
+//  if(clk < 600)
+    {
+//      if(dram_size<=0x2)
+//          tmp_val = (131*clk)>>10;
+//      else
+//          tmp_val = (336*clk)>>10;
+        reg_val = 0x83;
+        tmp_val = (7987*clk)>>10;
+        tmp_val = tmp_val*9 - 200;
+        reg_val |= tmp_val<<8;
+        reg_val |= 0x8<<24;
+        mctl_write_w(SDR_DRR, reg_val);
+    }
+//  else
+//   {
+//      mctl_write_w(SDR_DRR, 0x0);
+//   }
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               GET DRAM SIZE
+*
+* Description: Get DRAM Size in MB unit;
+*
+* Arguments  : None
+*
+* Returns    : 32/64/128
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__u32 DRAMC_get_dram_size(void)
+{
+    __u32 reg_val;
+    __u32 dram_size;
+    __u32 chip_den;
+
+    reg_val = mctl_read_w(SDR_DCR);
+    chip_den = (reg_val>>3)&0x7;
+    if(chip_den == 0)
+        dram_size = 32;
+    else if(chip_den == 1)
+        dram_size = 64;
+    else if(chip_den == 2)
+        dram_size = 128;
+    else if(chip_den == 3)
+        dram_size = 256;
+    else if(chip_den == 4)
+        dram_size = 512;
+    else
+        dram_size = 1024;
+
+    if( ((reg_val>>1)&0x3) == 0x1)
+        dram_size<<=1;
+    if( ((reg_val>>6)&0x7) == 0x3)
+        dram_size<<=1;
+    if( ((reg_val>>10)&0x3) == 0x1)
+        dram_size<<=1;
+
+    return dram_size;
+}
+
+
+__s32 dram_init(void)
+{
+    /* do nothing for dram init */
+    return 0;
+}
+
+
+void save_mem_status(volatile __u32 val)
+{
+    //*(volatile __u32 *)(STATUS_REG  + 0x04) = val;
+    return;
+}
+
+__s32 init_DRAM(standy_dram_para_t *boot0_para)
+{
+    __u32 i;
+    __s32 ret_val;
+
+    if(boot0_para->dram_clk > 2000)
+    {
+//          boot0_para->dram_clk = mem_uldiv(boot0_para->dram_clk, 1000000);
+            //boot0_para.dram_clk /= 1000000;
+    }
+
+    ret_val = 0;
+    i = 0;
+    while( (ret_val == 0) && (i<4) )
+    {
+            ret_val = DRAMC_init(boot0_para);
+            i++;
+    }
+    return ret_val;
+}
+
+
+__s32 dram_exit(void)
+{
+    return 0;
+}
+
+__s32 dram_get_size(void)
+{
+    return DRAMC_get_dram_size();
+}
+
+void dram_set_clock(int clk)
+{
+    return mctl_setup_dram_clock(clk);
+}
+
+void dram_set_drive(void)
+{
+    mctl_set_drive();
+}
+
+void dram_set_autorefresh_cycle(__u32 clk)
+{
+    DRAMC_set_autorefresh_cycle(clk);
+}
+
+__s32 dram_scan_readpipe(void)
+{
+    return DRAMC_scan_readpipe();
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/include/all.h b/arch/arm/mach-sun7i/pm/standby/include/all.h
new file mode 100755
index 0000000..df6cf4a
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/all.h
@@ -0,0 +1,22 @@
+/*
+ * all.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Administrator
+ */
+
+#ifndef ALL_H_
+#define ALL_H_
+
+#include "type.h"
+#include "io.h"
+#include "ccu.h"
+#include "irq.h"
+#include "timer.h"
+#include "uart.h"
+#include "utils.h"
+#include "platform.h"
+#include <generated/autoconf.h> 
+
+
+#endif /* ALL_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/include/ccu.h b/arch/arm/mach-sun7i/pm/standby/include/ccu.h
new file mode 100755
index 0000000..31a4184
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/ccu.h
@@ -0,0 +1,15 @@
+/*
+ * ccu.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Benn Huang (benn@allwinnertech.com)
+ */
+
+#ifndef CCU_H_
+#define CCU_H_
+
+#define AW_PLL6_CFG_REG          0x0028
+#define AW_APB1_GATING_REG       0x006c
+
+
+#endif /* CCU_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/include/io.h b/arch/arm/mach-sun7i/pm/standby/include/io.h
new file mode 100755
index 0000000..884920d
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/io.h
@@ -0,0 +1,18 @@
+/*
+ * io.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Benn Huang (benn@allwinnertech.com)
+ */
+
+#ifndef IO_H_
+#define IO_H_
+
+#define readb(addr)		(*((volatile unsigned char  *)(addr)))
+#define readw(addr)		(*((volatile unsigned short *)(addr)))
+#define readl(addr)		(*((volatile unsigned long  *)(addr)))
+#define writeb(v, addr)	(*((volatile unsigned char  *)(addr)) = (unsigned char)(v))
+#define writew(v, addr)	(*((volatile unsigned short *)(addr)) = (unsigned short)(v))
+#define writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+
+#endif /* IO_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/include/irq.h b/arch/arm/mach-sun7i/pm/standby/include/irq.h
new file mode 100755
index 0000000..bee42e2
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/irq.h
@@ -0,0 +1,115 @@
+/*
+ * irq.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Benn Huang (benn@allwinnertech.com)
+ */
+
+#ifndef IRQ_H_
+#define IRQ_H_
+
+#define IRQ_SGI0       0
+#define IRQ_SGI15      15
+#define IRQ_PPI0       16
+#define IRQ_PPI15      31
+
+#define IRQ_UART0      32
+#define IRQ_UART1      33
+#define IRQ_UART2      34
+#define IRQ_UART3      35
+#define IRQ_UART4      36
+#define IRQ_UART5      37
+#define IRQ_TWI0       38
+#define IRQ_TWI1       39
+#define IRQ_TWI2       40
+#define IRQ_TWI3       41
+#define IRQ_42         42
+#define IRQ_PA_EINT    43
+#define IRQ_SPDIF      44
+#define IRQ_DAUDIO0    45
+#define IRQ_DAUDIO1    46
+#define IRQ_PB_EINT    47
+#define IRQ_PE_EINT    48
+#define IRQ_PG_EINT    49
+#define IRQ_TIMER0     50
+#define IRQ_TIMER1     51
+#define IRQ_TIMER2     52
+#define IRQ_TIMER3     53
+#define IRQ_TIMER4     54
+#define IRQ_TIMER5     55
+#define IRQ_56         56
+#define IRQ_WDOG1      57
+#define IRQ_WDOG2      58
+#define IRQ_59         59
+#define IRQ_TP         60
+#define IRQ_AUDIOC     61
+#define IRQ_LRADC      62
+#define IRQ_63         63
+#define IRQ_ENMI       64
+#define IRQ_R_TIMER0   65
+#define IRQ_R_TIMER1   66
+#define IRQ_67         67
+#define IRQ_R_WDOG     68
+#define IRQ_R_CIR      69
+#define IRQ_R_UART     70
+#define IRQ_R_P2TWI    71
+#define IRQ_R_ALARM0   72
+#define IRQ_R_ALARM1   73
+#define IRQ_74         74
+#define IRQ_R_1WIRE    75
+#define IRQ_R_TWI      76
+#define IRQ_R_PH_EINT  77
+#define IRQ_R_PI_EINT  78
+#define IRQ_79         79
+#define IRQ_SPINLOCK   80
+#define IRQ_MBOX       81
+#define IRQ_DMA        82
+#define IRQ_HRTMR0     83
+#define IRQ_HRTMR1     84
+#define IRQ_HRTMR2     85
+#define IRQ_HRTMR3     86
+#define IRQ_87         87
+#define IRQ_TZASC      88
+#define IRQ_89         89
+#define IRQ_VE         90
+#define IRQ_91         91
+#define IRQ_SDMMC0     92
+#define IRQ_SDMMC1     93
+#define IRQ_SDMMC2     94
+#define IRQ_SDMMC3     95
+#define IRQ_96         96
+#define IRQ_SPI0       97
+#define IRQ_SPI1       98
+#define IRQ_SPI2       99
+#define IRQ_SPI3       100
+#define IRQ_NAND1      101
+#define IRQ_NAND0      102
+#define IRQ_USB_OTG    103
+#define IRQ_USB_EHCI0  104
+#define IRQ_USB_OHCI0  105
+#define IRQ_USB_EHCI1  106
+#define IRQ_USB_OHCI1  107
+#define IRQ_108        108
+#define IRQ_USB_OHCI2  109
+#define IRQ_110        110
+#define IRQ_111        111
+#define IRQ_SS         112
+#define IRQ_TS         113
+#define IRQ_GMAC       114
+#define IRQ_115        115
+#define IRQ_CSI0       116
+#define IRQ_CSI1       117
+#define IRQ_LCD0       118
+#define IRQ_LCD1       119
+#define IRQ_HDMI       120
+#define IRQ_MIPI_DSI   121
+#define IRQ_MIPI_CSI   122
+#define IRQ_DRC        123
+#define IRQ_DEU        124
+#define IRQ_DE_FE0     125
+#define IRQ_DE_FE1     126
+#define IRQ_DE_BE0     127
+#define IRQ_DE_BE1     128
+#define IRQ_GPU        129
+
+#endif /* IRQ_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/include/platform.h b/arch/arm/mach-sun7i/pm/standby/include/platform.h
new file mode 100755
index 0000000..8730872
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/platform.h
@@ -0,0 +1,68 @@
+/*
+ * platform.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Benn Huang (benn@allwinnertech.com)
+ */
+
+#ifndef PLATFORM_H_
+#define PLATFORM_H_
+
+
+#define AW_SRAM_A1_BASE             0x00000000  /*32KB*/
+#define AW_SRAM_A2_BASE             0x00040000  /*32KB*/
+#define AW_SRAN_D_BASE              0x00010000  /*4K*/
+#define AW_SRAM_B_BASE              0x00020000  /*64KB*/
+
+#define AW_DMA_BASE                 0x01c02000
+#define AW_NFC0_BASE                0x01c03000
+#define AW_TS_BASE                  0x01c04000
+#define AW_NFC1_BASE                0x01c05000
+#define AW_LCD0_BASE                0x01c0c000
+#define AW_LCD1_BASE                0x01c0d000
+#define AW_VE_BASE                  0x01c0e000
+#define AW_SDMMC0_BASE              0x01c0f000
+#define AW_SDMMC1_BASE              0x01c10000
+#define AW_SDMMC2_BASE              0x01c11000
+#define AW_SDMMC3_BASE              0x01c12000
+
+#define AW_SS_BASE                  0x01c15000
+#define AW_HDMI_BASE                0x01c06000
+#define AW_MSGBOX_BASE              0x01c17000
+#define AW_SPINLOCK_BASE            0x01c18000
+#define AW_TZASC_BASE               0x01c1e000
+#define AW_CCM_BASE                 0x01c20000
+#define AW_PIO_BASE                 0x01c20800
+#define AW_TIMER_BASE               0x01c20c00
+#define AW_SPDIF_BASE               0x01c21000
+#define AW_PWM_BASE                 0x01c21400
+
+#define AW_UART0_BASE               0x01c28000
+#define AW_UART1_BASE               0x01c28400
+#define AW_UART2_BASE               0x01c28800
+
+#define AW_GMAC_BASE                0x01c30000
+#define AW_GPU_BASE                 0x01c40000
+#define AW_HSTMR_BASE               0x01c60000
+#define AW_DRAMCOM_BASE             0x01c62000
+#define AW_DRAMCTL0_BASE            0x01c63000
+#define AW_DRAMCTL1_BASE            0x01c64000
+#define AW_DRAMPHY0_BASE            0x01c65000
+#define AW_DRAMPHY1_BASE            0x01c66000
+
+#define AW_SCU_BASE                 0x01c80000
+#define AW_GIC_BASE                 0x01c80100
+
+
+/* The following register cannot access by cpu0 */
+#define AW_G_TIMER_BASE             0x01c80200
+#define AW_L_TIMER_BASE             0x01c80600
+#define AW_INT_DIST_BASE            0x01c81000
+
+#define AW_CPUCFG_BASE            	0x01c25C00
+
+#define AW_DRAM_BASE                0x40000000
+#define AW_BROM_BASE                0xffff0000    /*32KB*/
+
+
+#endif /* PLATFORM_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/include/timer.h b/arch/arm/mach-sun7i/pm/standby/include/timer.h
new file mode 100755
index 0000000..e084a68
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/timer.h
@@ -0,0 +1,24 @@
+/*
+ * timer.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Benn Huang (benn@allwinnertech.com)
+ */
+
+#ifndef TIMER_H_
+#define TIMER_H_
+
+/*
+ * Timer
+ */
+#define AW_TMR_IRQ_EN_REG           0x0000
+#define AW_TMR_IRQ_STA_REG          0x0004
+#define AW_TMR0_CTRL_REG            0x0010
+#define AW_TMR0_INTV_VALUE_REG      0x0014
+#define AW_TMR0_CUR_VALUE_REG       0x0018
+#define AW_AVS_CNT_CTL_REG          0x0080
+#define AW_AVS_CNT0_REG             0x0084
+#define AW_AVS_CNT1_REG             0x0088
+#define AW_AVS_CNT_DIV_REG          0x008c
+
+#endif /* TIMER_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/include/type.h b/arch/arm/mach-sun7i/pm/standby/include/type.h
new file mode 100755
index 0000000..568ded6
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/type.h
@@ -0,0 +1,15 @@
+/*
+ * type.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Benn Huang (benn@allwinnertech.com)
+ */
+
+#ifndef TYPE_H_
+#define TYPE_H_
+
+typedef unsigned long    u32;
+typedef signed long      s32;
+typedef unsigned int     size_t;
+
+#endif /* TYPE_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/include/uart.h b/arch/arm/mach-sun7i/pm/standby/include/uart.h
new file mode 100755
index 0000000..57f5049
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/uart.h
@@ -0,0 +1,31 @@
+/*
+ * uart.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Benn Huang (benn@allwinnertech.com)
+ */
+
+#ifndef UART_H_
+#define UART_H_
+
+/*
+ * UART
+ */
+#define AW_UART_RBR                 0x00 /* Receive Buffer Register */
+#define AW_UART_THR                 0x00 /* Transmit Holding Register */
+#define AW_UART_DLL                 0x00 /* Divisor Latch Low Register */
+#define AW_UART_DLH                 0x04 /* Diviso Latch High Register */
+#define AW_UART_IER                 0x04 /* Interrupt Enable Register */
+#define AW_UART_IIR                 0x08 /* Interrrupt Identity Register */
+#define AW_UART_FCR                 0x08 /* FIFO Control Register */
+#define AW_UART_LCR                 0x0c /* Line Control Register */
+#define AW_UART_MCR                 0x10 /* Modem Control Register */
+#define AW_UART_LSR                 0x14 /* Line Status Register */
+#define AW_UART_MSR                 0x18 /* Modem Status Register */
+#define AW_UART_SCH                 0x1c /* Scratch Register */
+#define AW_UART_USR                 0x7c /* Status Register */
+#define AW_UART_TFL                 0x80 /* Transmit FIFO Level */
+#define AW_UART_RFL                 0x84 /* RFL */
+#define AW_UART_HALT                0xa4 /* Halt TX Register */
+
+#endif /* UART_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/include/utils.h b/arch/arm/mach-sun7i/pm/standby/include/utils.h
new file mode 100755
index 0000000..44ddeb34
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/include/utils.h
@@ -0,0 +1,13 @@
+/*
+ * utils.h
+ *
+ *  Created on: 2012-4-25
+ *      Author: Administrator
+ */
+
+#ifndef UTILS_H_
+#define UTILS_H_
+
+extern void wait(int cycle);
+
+#endif /* UTILS_H_ */
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_delay.S b/arch/arm/mach-sun7i/pm/standby/mem_delay.S
new file mode 100755
index 0000000..390a232
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_delay.S
@@ -0,0 +1,26 @@
+#include "./pm_config.h"
+
+#define ENABLE_SUPER_STANDBY
+
+#ifdef ENABLE_SUPER_STANDBY
+#define STANDBY_COEFFICIENT (17)
+#else
+#define STANDBY_COEFFICIENT (1)
+#endif
+
+    .text
+    .globl mem_delay
+mem_delay:
+	push    {r0-r3}
+	ldr  	r1, =STANDBY_COEFFICIENT
+	mov	r3, r0
+loop2:
+	subs    r0, r0, #1
+	bhi	loop2
+	mov	r0, r3
+	subs	r1, r1, #1
+	bhi	loop2
+	
+	pop     {r0-r3}
+	mov     pc, lr
+	
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_divlib.S b/arch/arm/mach-sun7i/pm/standby/mem_divlib.S
new file mode 100755
index 0000000..d358706
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_divlib.S
@@ -0,0 +1,180 @@
+/*
+ * linux/arch/arm/lib/lib1funcs.S: Optimized ARM division routines
+ *
+ * Author: Nicolas Pitre <nico@fluxnic.net>
+ *   - contributed to gcc-3.4 on Sep 30, 2003
+ *   - adapted for the Linux kernel on Oct 2, 2003
+ */
+
+
+.macro ARM_DIV_BODY dividend, divisor, result, curbit
+
+	clz	\curbit, \divisor
+	clz	\result, \dividend
+	sub	\result, \curbit, \result
+	mov	\curbit, #1
+	mov	\divisor, \divisor, lsl \result
+	mov	\curbit, \curbit, lsl \result
+	mov	\result, #0
+	
+	@ Division loop
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	orrhs	\result,   \result,   \curbit
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	orrhs	\result,   \result,   \curbit,  lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	orrhs	\result,   \result,   \curbit,  lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	orrhs	\result,   \result,   \curbit,  lsr #3
+	cmp	\dividend, #0			@ Early termination?
+	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	movne	\divisor,  \divisor, lsr #4
+	bne	1b
+
+.endm
+
+
+.macro ARM_DIV2_ORDER divisor, order
+	clz	\order, \divisor
+	rsb	\order, \order, #31
+.endm
+
+
+.macro ARM_MOD_BODY dividend, divisor, order, spare
+	clz	\order, \divisor
+	clz	\spare, \dividend
+	sub	\order, \order, \spare
+	mov	\divisor, \divisor, lsl \order
+
+	@ Perform all needed substractions to keep only the reminder.
+	@ Do comparisons in batch of 4 first.
+	subs	\order, \order, #3		@ yes, 3 is intended here
+	blt	2f
+
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	cmp	\dividend, #1
+	mov	\divisor, \divisor, lsr #4
+	subges	\order, \order, #4
+	bge	1b
+
+	tst	\order, #3
+	teqne	\dividend, #0
+	beq	5f
+
+	@ Either 1, 2 or 3 comparison/substractions are left.
+2:	cmn	\order, #2
+	blt	4f
+	beq	3f
+	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+3:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+4:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+5:
+.endm
+
+    .text
+    .globl Ldiv0
+Ldiv0:
+	str	lr, [sp, #-8]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #8
+
+    .text
+    .globl __aeabi_uidiv
+__aeabi_uidiv:
+	subs	r2, r1, #1
+	moveq	pc, lr
+	bcc	Ldiv0
+	cmp	r0, r1
+	bls	11f
+	tst	r1, r2
+	beq	12f
+
+	ARM_DIV_BODY r0, r1, r2, r3
+
+	mov	r0, r2
+	mov	pc, lr
+
+11:	moveq	r0, #1
+	movne	r0, #0
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	mov	r0, r0, lsr r2
+	mov	pc, lr
+
+
+    .text
+    .globl __aeabi_idiv
+__aeabi_idiv:
+	cmp	r1, #0
+	eor	ip, r0, r1			@ save the sign of the result.
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	subs	r2, r1, #1			@ division by 1 or -1 ?
+	beq	10f
+	movs	r3, r0
+	rsbmi	r3, r0, #0			@ positive dividend value
+	cmp	r3, r1
+	bls	11f
+	tst	r1, r2				@ divisor is power of 2 ?
+	beq	12f
+
+	ARM_DIV_BODY r3, r1, r0, r2
+
+	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+10:	teq	ip, r0				@ same sign ?
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+11:	movlo	r0, #0
+	moveq	r0, ip, asr #31
+	orreq	r0, r0, #1
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	cmp	ip, #0
+	mov	r0, r3, lsr r2
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+    .text
+    .globl __aeabi_uidivmod
+__aeabi_uidivmod:
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_uidiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+    .text
+    .globl __aeabi_idivmod
+__aeabi_idivmod:
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_idiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_divlibc.c b/arch/arm/mach-sun7i/pm/standby/mem_divlibc.c
new file mode 120000
index 0000000..5d3b1b1
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_divlibc.c
@@ -0,0 +1 @@
+../mem_divlibc.c
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_int.c b/arch/arm/mach-sun7i/pm/standby/mem_int.c
new file mode 100755
index 0000000..dc5787d
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_int.c
@@ -0,0 +1,173 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : mem_int.c
+* By      : gq.yang
+* Version : v1.0
+* Date    : 2012-11-3 20:13
+* Descript: interrupt for platform mem
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifdef __STANDBY_MODULE__
+#include "pm_types.h" 
+#include "pm.h"
+#elif defined(__KERNEL__)
+#include <linux/module.h>
+#endif
+
+#include "mem_int.h"
+
+/*
+*********************************************************************************************************
+*                                       STANDBY INTERRUPT INITIALISE
+*
+* Description: mem interrupt initialise.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_int_init(void)
+{
+	__u32 i = 0; 
+    void *GicDDisc;
+    void *GicCDisc;
+	GicDDisc = (void *)IO_ADDRESS(AW_GIC_DIST_BASE);
+	GicCDisc = (void *)IO_ADDRESS(AW_GIC_CPU_BASE);
+	
+	//printk("gic iar == 0x%x. \n", *(volatile __u32	 *)(IO_ADDRESS(AW_GIC_CPU_BASE)+0x0c));
+
+	/* initialise interrupt enable and mask for mem */
+	
+	/*
+	 * Disable all interrupts.  Leave the PPI and SGIs alone
+	 * as these enables are banked registers.
+	 */
+	for (i = 4; i < (GIC_400_ENABLE_LEN); i += 4)
+		*(volatile __u32 *)(GicDDisc + GIC_DIST_ENABLE_CLEAR + i) = 0xffffffff;
+
+	/*config cpu interface*/
+#if 0
+	*(volatile __u32 *)(GicCDisc + GIC_CPU_PRIMASK) = 0xf0;
+	*(volatile __u32 *)(GicCDisc + GIC_CPU_CTRL) = 0x1;
+#endif
+
+#if 1
+	/* clear external irq pending: needed */
+	for (i = 4; i < (GIC_400_ENABLE_LEN); i += 4)
+		*(volatile __u32 *)(GicDDisc + GIC_DIST_PENDING_CLEAR + i) = 0xffffffff;
+#endif
+	//the print info just to check the pending state, actually, after u read iar, u need to access end of interrupt reg;
+	i = *(volatile __u32   *)(GicCDisc + 0x0c);
+
+	if(i != 0x3ff){
+		//u need to 
+		*(volatile __u32 *)(GicCDisc + 0x10) = i;
+		printk("notice: gic iar == 0x%x. \n", i);
+	}
+	
+	
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       STANDBY INTERRUPT INITIALISE
+*
+* Description: mem interrupt exit.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_int_exit(void)
+{
+	int i = 0;
+	volatile __u32 enable_bit = 0;
+    void *GicDDisc;
+    void *GicCDisc;
+	GicDDisc = (void *)IO_ADDRESS(AW_GIC_DIST_BASE);
+	GicCDisc = (void *)IO_ADDRESS(AW_GIC_CPU_BASE);
+	
+	//all the disable-int-src pending, need to be clear
+	for(i = 0; i < GIC_400_ENABLE_LEN; i += 4){
+		enable_bit = *(volatile __u32 *)(GicDDisc + GIC_DIST_ENABLE_SET + i);
+		*(volatile __u32 *)(GicDDisc + GIC_DIST_PENDING_CLEAR + i) &= (~enable_bit);
+	}
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       QUERY INTERRUPT
+*
+* Description: enable interrupt.
+*
+* Arguments  : src  interrupt source number.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_enable_int(enum interrupt_source_e src)
+{
+	__u32   tmpGrp = (__u32)src >> 5;
+	__u32   tmpSrc = (__u32)src & 0x1f;
+    void *GicDDisc;
+    void *GicCDisc;
+
+	GicDDisc = (void *)IO_ADDRESS(AW_GIC_DIST_BASE);
+	GicCDisc = (void *)IO_ADDRESS(AW_GIC_CPU_BASE);
+
+	//enable interrupt source
+	*(volatile __u32 *)(GicDDisc + GIC_DIST_ENABLE_SET + tmpGrp*4) |= (1<<tmpSrc);
+	//printk("GicDDisc + GIC_DIST_ENABLE_SET + tmpGrp*4 = 0x%x. tmpGrp = 0x%x.\n", GicDDisc + GIC_DIST_ENABLE_SET + tmpGrp*4, tmpGrp);
+	//printk("tmpSrc = 0x%x. \n", tmpSrc);
+
+	//need to care mask or priority?
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       QUERY INTERRUPT
+*
+* Description: query interrupt.
+*
+* Arguments  : src  interrupt source number.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_query_int(enum interrupt_source_e src)
+{
+	__s32   result = 0;
+	__u32   tmpGrp = (__u32)src >> 5;
+	__u32   tmpSrc = (__u32)src & 0x1f;
+    void *GicDDisc;
+    void *GicCDisc;
+
+	GicDDisc = (void *)IO_ADDRESS(AW_GIC_DIST_BASE);
+	GicCDisc = (void *)IO_ADDRESS(AW_GIC_CPU_BASE);
+
+	result = *(volatile __u32 *)(GicDDisc + GIC_DIST_PENDING_SET + tmpGrp*4) & (1<<tmpSrc);
+
+	//printk("GicDDisc + GIC_DIST_PENDING_SET + tmpGrp*4 = 0x%x. tmpGrp = 0x%x.\n", GicDDisc + GIC_DIST_PENDING_SET + tmpGrp*4, tmpGrp);
+	//printk("tmpSrc = 0x%x. result = 0x%x. \n", tmpSrc, result);
+
+	return result? 0:-1;
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_int.h b/arch/arm/mach-sun7i/pm/standby/mem_int.h
new file mode 100755
index 0000000..8253353
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_int.h
@@ -0,0 +1,72 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_int.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 19:50
+* Descript: intterupt bsp for platform standby.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_INT_H__
+#define __MEM_INT_H__
+
+#include "pm_config.h"
+#include <mach/irqs.h>
+#define GIC_400_ENABLE_LEN (0x40) //unit is byte. so in 32bit unit, the reg offset is 0-0x3c
+
+enum interrupt_source_e{
+    INT_SOURCE_EXTNMI   = SW_INT_IRQNO_NMI,
+    INT_SOURCE_IR0      = SW_INT_IRQNO_IR0,
+    INT_SOURCE_IR1      = SW_INT_IRQNO_IR1,
+    INT_SOURCE_KEYPAD   = SW_INT_IRQNO_KEYPAD,
+    INT_SOURCE_TIMER0   = SW_INT_IRQNO_TIMER0,
+    INT_SOURCE_TIMER1   = SW_INT_IRQNO_TIMER1,
+    INT_SOURCE_ALARM    = SW_INT_IRQNO_TIMER2,
+    INT_SOURCE_TOUCHPNL = SW_INT_IRQNO_TOUCH_PANEL,
+    INT_SOURCE_LRADC    = SW_INT_IRQNO_LRADC,
+    INT_SOURCE_USB0     = SW_INT_IRQNO_USB0,
+    INT_SOURCE_USB1     = SW_INT_IRQNO_USB1,
+    INT_SOURCE_USB2     = SW_INT_IRQNO_USB2,
+    INT_SOURCE_USB3     = SW_INT_IRQNO_USB3,
+    INT_SOURCE_USB4     = SW_INT_IRQNO_USB4,
+    INT_SOURCE_GPIO     = SW_INT_IRQNO_PIO,
+};
+
+#define GIC_CPU_CTRL			0x00
+#define GIC_CPU_PRIMASK			0x04
+#define GIC_CPU_BINPOINT		0x08
+#define GIC_CPU_INTACK			0x0c
+#define GIC_CPU_EOI			0x10
+#define GIC_CPU_RUNNINGPRI		0x14
+#define GIC_CPU_HIGHPRI			0x18
+
+#define GIC_DIST_CTRL			0x000
+#define GIC_DIST_CTR			0x004
+#define GIC_DIST_ENABLE_SET		0x100
+#define GIC_DIST_ENABLE_CLEAR		0x180
+#define GIC_DIST_PENDING_SET		0x200
+#define GIC_DIST_PENDING_CLEAR		0x280
+#define GIC_DIST_ACTIVE_BIT		0x300
+#define GIC_DIST_PRI			0x400
+#define GIC_DIST_TARGET			0x800
+#define GIC_DIST_CONFIG			0xc00
+#define GIC_DIST_SOFTINT		0xf00
+/*
+*/
+
+extern __s32 mem_int_init(void);
+extern __s32 mem_int_exit(void);
+extern __s32 mem_enable_int(enum interrupt_source_e src);
+extern __s32 mem_query_int(enum interrupt_source_e src);
+
+
+#endif  //__MEM_INT_H__
+
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_mmu_pc_asm.S b/arch/arm/mach-sun7i/pm/standby/mem_mmu_pc_asm.S
new file mode 100755
index 0000000..1efbb1e
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_mmu_pc_asm.S
@@ -0,0 +1,444 @@
+#include <mach/platform.h>
+#include "./pm_config.h"
+
+/**-----------------------------stack point address in sram-----------------------------------------*/
+#define SP_IN_SRAM	0xf000b3fc //32k
+#define SP_IN_SRAM_PA   0x0000b3fc //32k
+/*save_sp*/
+/*save_sp_nommu*/
+/*restore_sp*/
+/*get_sp*/
+
+    .text
+    .globl save_sp
+save_sp:
+    mov r0, r13
+    ldr  r13, =SP_IN_SRAM
+    mov pc,lr
+
+    .text
+    .globl save_sp_nommu
+save_sp_nommu:
+    mov r0, r13
+    ldr  r13, =SP_IN_SRAM_PA
+    mov pc,lr
+    
+    .text
+    .globl restore_sp
+restore_sp:
+    mov r13, r0
+    mov pc,lr
+    
+    .text
+    .globl get_sp
+get_sp:
+    mov r0, r13
+    mov pc,lr
+    
+/*--------------------------------cache related api: ----------------------------------------------- */
+/*invalidate_dcache*/
+/*invalidate_icache*/
+/*flush_dcache*/
+/*flush_icache*/
+/*disable_cache*/
+/*disable_dcache*/
+/*disable_icache*/
+/*disable_l2cache*/
+/*enable_cache*/
+/*enable_icache*/
+
+	.align	4  
+	.text
+	.globl invalidate_dcache	        /*can not use push and pop, because inval will discard the data in the stack*/
+invalidate_dcache:
+	/* Corrupted registers: r0-r7, r9-r11 (r6 only in Thumb mode) */
+	dmb					/* ensure ordering with previous memory accesses */
+	MRC     p15, 1, r0, c0, c0, 1       /*read clidr                              */
+	ANDS    r3, r0, #0x7000000          /*extract loc from clidr                  */
+	MOV     r3, r3, lsr #23             /*left align loc bit field                */
+	BEQ     inv_finished                    /*if loc is 0, then no need to clean      */
+	mov     r10, #0                     /*start clean at cache level 0            */
+inv_loop1:                                   
+	ADD     r2, r10, r10, lsr #1        /*work out 3x current cache level         */
+	MOV     r1, r0, lsr r2              /*extract cache type bits from clidr      */
+	AND     r1, r1, #7                  /*mask of the bits for current cache only */
+	CMP     r1, #2                      /*see what cache we have at this level    */
+	BLT     inv_skip                        /*skip if no cache, or just i-cache       */
+	MCR     p15, 2, r10, c0, c0, 0      /*select current cache level in cssr      */
+	ISB                                 /*isb to sych the new cssr&csidr          */
+	MRC     p15, 1, r1, c0, c0, 0       /*read the new csidr                      */
+	AND     r2, r1, #7                  /*extract the length of the cache lines   */
+	ADD     r2, r2, #4                  /*add 4 (line length offset)              */
+	LDR     r4, =0x3ff                  
+	ANDS    r4, r4, r1, lsr #3          /*find maximum number on the way size     */
+	CLZ     r5, r4                      /*find bit position of way size increment */
+	LDR     r7, =0x7fff               
+	ANDS    r7, r7, r1, lsr #13         /*extract max number of the index size    */
+inv_loop2:                                  
+	MOV     r9, r4                      /*create working copy of max way size     */
+inv_loop3:                                  
+	ORR     r11, r10, r9, lsl r5        /*factor way and cache number into r11    */
+	ORR     r11, r11, r7, lsl r2        /*factor index number into r11            */
+	MCR     p15, 0, r11, c7, c6, 2	      /*invalidate by set/way                  */
+	SUBS    r9, r9, #1                  /*decrement the way                       */
+	BGE     inv_loop3                       /*                                        */
+	SUBS    r7, r7, #1                  /*decrement the index                     */
+	BGE     inv_loop2                       /*                                        */
+inv_skip:                                   /*                                        */
+	ADD     r10, r10, #2                /*increment cache number                  */
+	CMP     r3, r10                     /*                                        */
+	BGT     inv_loop1                       /*                                        */
+inv_finished:                                /*                                        */
+	MOV     r10, #0                     /*swith back to cache level 0             */
+	
+	MCR     p15, 2, r10, c0, c0, 0      /*select current cache level in cssr      */
+	dsb
+	ISB                                 /*                                        */
+	
+	MOV     pc, lr                      /*                                        */
+    
+    	.text                                                                        
+	.globl invalidate_icache                                                          
+invalidate_icache:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c1, 0		@ invalidate I-cache inner shareable
+	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
+	dsb
+	ISB  
+	mov	pc, lr
+	
+    .text
+    .globl flush_dcache
+flush_dcache:
+    push    {r0-r12} 
+    dmb					/* ensure ordering with previous memory accesses */
+    MRC     p15, 1, r0, c0, c0, 1       /*read clidr                              */
+    ANDS    r3, r0, #0x7000000          /*extract loc from clidr                  */
+    MOV     r3, r3, lsr #23             /*left align loc bit field                */
+    BEQ     finished                    /*if loc is 0, then no need to clean      */
+    mov     r10, #0                     /*start clean at cache level 0            */
+loop1:                                   
+    ADD     r2, r10, r10, lsr #1        /*work out 3x current cache level         */
+    MOV     r1, r0, lsr r2              /*extract cache type bits from clidr      */
+    AND     r1, r1, #7                  /*mask of the bits for current cache only */
+    CMP     r1, #2                      /*see what cache we have at this level    */
+    BLT     skip                        /*skip if no cache, or just i-cache       */
+    MCR     p15, 2, r10, c0, c0, 0      /*select current cache level in cssr      */
+    ISB                                 /*isb to sych the new cssr&csidr          */
+    MRC     p15, 1, r1, c0, c0, 0       /*read the new csidr                      */
+    AND     r2, r1, #7                  /*extract the length of the cache lines   */
+    ADD     r2, r2, #4                  /*add 4 (line length offset)              */
+    LDR     r4, =0x3ff                  
+    ANDS    r4, r4, r1, lsr #3          /*find maximum number on the way size     */
+    CLZ     r5, r4                      /*find bit position of way size increment */
+    LDR     r7, =0x7fff               
+    ANDS    r7, r7, r1, lsr #13         /*extract max number of the index size    */
+loop2:                                  
+    MOV     r9, r4                      /*create working copy of max way size     */
+loop3:                                  
+    ORR     r11, r10, r9, lsl r5        /*factor way and cache number into r11    */
+    ORR     r11, r11, r7, lsl r2        /*factor index number into r11            */
+    MCR     p15, 0, r11, c7, c14, 2	      /*clean & invalidate by set/way                  */
+    SUBS    r9, r9, #1                  /*decrement the way                       */
+    BGE     loop3                       /*                                        */
+    SUBS    r7, r7, #1                  /*decrement the index                     */
+    BGE     loop2                       /*                                        */
+skip:                                   /*                                        */
+    ADD     r10, r10, #2                /*increment cache number                  */
+    CMP     r3, r10                     /*                                        */
+    BGT     loop1                       /*                                        */
+finished:                                /*                                        */
+    MOV     r10, #0                     /*swith back to cache level 0             */
+
+    MCR     p15, 2, r10, c0, c0, 0      /*select current cache level in cssr      */
+    dsb
+    ISB                                 /*                                        */
+    pop    {r0-r12} 
+    MOV     pc, lr                      /*                                        */
+   
+                                     
+    .text                                                                        
+    .globl flush_icache                                                          
+flush_icache:
+    push    {r0-r3}                                                                    
+    MOV     r0, #0                                                               
+    MCR     p15, 0, r0, c7, c5, 0       /*Instruction cache invalidate all to PoU    */
+    MCR     p15, 0, r0, c7, c1, 0 	/*Instruction cache invalidate all to PoUa Inner Shareable*/
+    MCR     p15, 0, r0, c7, c1, 6	/*Branch predictor invalidate all Inner Shareable*/
+    ISB
+    dsb
+    pop     {r0-r3}
+    MOV     pc, lr
+    
+    .text                                                                        
+    .globl disable_cache                                                          
+disable_cache:  
+    push    {r0-r3}                                                                   
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    BIC	    r0, r0, #0x1 << 12
+    BIC	    r0, r0, #0x1 << 2
+    MCR     p15, 0, r0, c1, c0, 0       /*disable cache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text                                                                        
+    .globl disable_dcache                                                          
+disable_dcache: 
+    push    {r0-r3}                                                                    
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    BIC	    r0, r0, #(0x1 << 2)
+    MCR     p15, 0, r0, c1, c0, 0       /*disable dcache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text                                                                        
+    .globl disable_icache                                                          
+disable_icache: 
+    push    {r0-r3}                                                                    
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    BIC	    r0, r0, #(0x1 << 12)
+    MCR     p15, 0, r0, c1, c0, 0       /*disable icache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+  
+    .text                                                                        
+    .globl disable_l2cache                                                          
+disable_l2cache:  
+    push    {r0-r3}                                                                   
+    MRC     p15, 0, r0, c1, c0, 1       /*read acr                  */
+    BIC	    r0, r0, #0x1 << 1
+    MCR     p15, 0, r0, c1, c0, 1       /*disable l2cache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text                                                                        
+    .globl enable_cache                                                          
+enable_cache:           
+    push    {r0-r3}                                                          
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    ORR	    r0, r0, #0x1 << 12
+    ORR	    r0, r0, #0x1 << 2
+    MCR     p15, 0, r0, c1, c0, 0       /*enable cache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+        
+    .text                                                                        
+    .globl enable_icache                                                          
+enable_icache: 
+    push    {r0-r3}                                                                    
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    ORR	    r0, r0, #(0x1 << 12)
+    MCR     p15, 0, r0, c1, c0, 0       /*disable dcache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+/*--------------------------------------prediction----------------------------------------*/
+/*invalidate_branch_predictor*/
+/*disable_program_flow_prediction*/
+/*enable_program_flow_prediction*/
+
+    .text                                                                        
+    .globl invalidate_branch_predictor                                                          
+invalidate_branch_predictor:
+    push    {r0-r3} 
+    MOV	    r0, #0                                                                    
+    MCR     p15, 0, r0, c7, c5, 6       /*(invalidate entire branch predictor array)*/
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+       
+         
+    .text                                                                        
+    .globl disable_program_flow_prediction                                                          
+disable_program_flow_prediction:    
+    push    {r0-r3}                                                                 
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    BIC	    r0, r0, #0x800
+    MCR     p15, 0, r0, c1, c0, 0       /*disable  program_flow_prediction                 */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text                                                                        
+    .globl enable_program_flow_prediction                                                          
+enable_program_flow_prediction:  
+    push    {r0-r3}                                                                   
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    ORR	    r0, r0, #0x800
+    MCR     p15, 0, r0, c1, c0, 0       /*disable  program_flow_prediction                 */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+        
+/*-------------------------------------tlb related api:----------------------------------------*/
+/*mem_flush_tlb*/
+/*mem_preload_tlb*/
+
+	.text
+	.globl mem_flush_tlb
+mem_flush_tlb:
+	push    {r0-r3}
+	MOV     r0, #0 
+	/*instruction entire instruction tlb*/
+	mcr p15, 0, r0, c8, c5, 0
+	/* invalid entire data tlb */
+	mcr p15, 0, r0, c8, c6, 0
+	/*invalidate entire unified TLB inner shareable*/
+	mcr p15, 0, r0, c8, c7, 0
+	dsb
+    ISB      
+	pop     {r0-r3}
+	mov pc,lr
+	
+    .text
+    .globl mem_preload_tlb
+mem_preload_tlb:
+	push    {r0-r3}
+	/*16k*/
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A1_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A1_BASE + 0x1000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A1_BASE + 0x2000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A1_BASE + 0x3000)
+	ldr r1, [r0]
+	
+	/*16k*/
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A2_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A2_BASE + 0x1000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A2_BASE + 0x2000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A2_BASE + 0x3000)
+	ldr r1, [r0]
+	
+	/*16k*/
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A3_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A3_BASE + 0x1000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A3_BASE + 0x2000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_SRAM_A3_BASE + 0x3000)
+	ldr r1, [r0]
+
+	ldr r0, =IO_ADDRESS(SW_PA_PORTC_IO_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_UART0_IO_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(SW_PA_TIMERC_IO_BASE)
+	ldr r1, [r0]
+	
+	dsb
+	isb
+	
+	pop     {r0-r3}
+	mov pc,lr
+	           
+/*--------------------------------------mmu----------------------------------------*/
+/*disable_mmu*/
+/*enable_mmu*/
+
+    .text
+    .globl disable_mmu
+disable_mmu:
+		/*read cr*/
+                MRC p15,0,r1,c1,c0,0
+                BIC r1, #0x1000
+                BIC r1, #0x0005
+                b __turn_mmu_off
+                .align 5
+                
+                .type __turn_mmu_off, %function
+__turn_mmu_off:
+                /*write cr: disable cache and mmu*/
+                MCR p15,0,r1,c1,c0,0
+		/*read id reg*/
+                mrc p15, 0, r3, c0, c0, 0 
+                mov r3, r3
+                mov r3, r3 
+                /*return*/
+                mov pc, lr
+
+    .text
+    .globl enable_mmu
+enable_mmu:
+		/*read cr*/
+                MRC p15,0,r1,c1,c0,0
+                ORR r1, #0x1000
+                ORR r1, #0x0005
+                b __turn_mmu_on
+                .align 5
+                
+                .type __turn_mmu_on, %function
+__turn_mmu_on:
+                /*write cr: enable cache and mmu*/
+                MCR p15,0,r1,c1,c0,0
+		/*read id reg*/
+                mrc p15, 0, r3, c0, c0, 0 
+                mov r3, r3
+                mov r3, r3 
+                /*return*/
+                mov pc, lr
+                
+/*----------------------------------------pc related api:---------------------------------------*/
+/*jump_to_suspend*/
+/*jump_to_resume*/
+/*jump_to_resume0*/
+/*jump_to_resume0_nommu*/
+
+	.text 
+	.globl jump_to_suspend  
+jump_to_suspend:
+	/*enable 0x0000 <-->  0x0000 mapping */
+	/*write ttbr0*/  
+	mcr p15, 0, r0, c2, c0, 0
+        bl mem_flush_tlb
+	dsb
+	isb
+	
+	mov pc, r1
+	
+	.align	4  
+	.text
+	.globl jump_to_resume
+jump_to_resume:
+	/*before jump to resume:
+	 * 1st: invalidate the data
+	 * 2nd: restore r0-r13.
+	 * 3rd: jump (para 1).
+	 */                                                                          
+	/* Set the return pointer */                                                 
+	mov     r12, r0
+	mov 	r8, r1
+	bl	invalidate_dcache
+	mov	r1, r8
+	mov	lr, r12
+	ldmia   r1, {r0 - r13}                                                   
+        mov     pc, lr
+
+	.align	4  
+	.globl jump_to_resume0
+jump_to_resume0: 
+        /* Set the return pointer */                                                        
+	mov     lr, r0
+	mov     pc, lr
+
+	.align	4  
+
+    .text
+    .globl mem_preload_tlb_nommu
+mem_preload_tlb_nommu:
+    push    {r0-r3}
+ 
+    pop     {r0-r3}
+    mov pc,lr
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_printk.c b/arch/arm/mach-sun7i/pm/standby/mem_printk.c
new file mode 100755
index 0000000..357d7d5
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_printk.c
@@ -0,0 +1,480 @@
+/**
+ * common.c - common operations
+ * date:    2012-2-13 8:42:56
+ * author:  Aaron<leafy.myeh@allwinnertech.com>
+ * history: V0.1
+ */
+
+#include <stdarg.h>
+#include "pm_types.h"
+#include "pm.h"
+#include "mem_printk.h"
+
+#define NUM_TYPE long long
+
+#define ZEROPAD	1		/* pad with zero */
+#define SIGN	2		/* unsigned/signed long */
+#define PLUS	4		/* show plus */
+#define SPACE	8		/* space if plus */
+#define LEFT	16		/* left justified */
+#define SMALL	32		/* Must be 32 == 0x20 */
+#define SPECIAL	64		/* 0x */
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+
+
+/* Basic string functions */
+
+/*
+  s t r l e n
+
+  returns number of characters in s (not including terminating null character)
+*/
+size_t strlen(const char *s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+	{
+		/* nothing */
+		;
+	}
+	return sc - s;
+}
+
+/*
+  s t r c p y
+
+  Copy 'src' to 'dest'. Strings may not overlap.
+*/
+char *strcpy(char *dest, const char *src)
+{
+	char *tmp = dest;
+
+	while ((*dest++ = *src++) != '\0')
+	{
+		/* nothing */
+		;
+	}
+	return tmp;
+}
+
+char *strncpy(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	while (count)
+	{
+		if ((*tmp = *src) != 0)
+		{
+			src++;
+		}
+		tmp++;
+		count--;
+	}
+	return dest;
+}
+
+
+char *strcat(char *dest, const char *src)
+{
+	char *tmp = dest;
+
+	while (*dest)
+	{
+		dest++;
+	}
+	while ((*dest++ = *src++) != '\0')
+	{
+		;
+	}
+	return tmp;
+}
+
+
+char *strncat(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	if (count)
+	{
+		while (*dest)
+		{
+			dest++;
+		}
+		while ((*dest++ = *src++) != 0)
+		{
+			if (--count == 0)
+			{
+				*dest = '\0';
+				break;
+			}
+		}
+	}
+	return tmp;
+}
+
+int strcmp(const char *cs, const char *ct)
+{
+	unsigned char c1, c2;
+
+	while (1)
+	{
+		c1 = *cs++;
+		c2 = *ct++;
+		if (c1 != c2)
+		{
+			return c1 < c2 ? -1 : 1;
+		}
+		if (!c1)
+		{
+			break;
+		}
+	}
+	return 0;
+}
+
+
+int strncmp(const char *cs, const char *ct, size_t count)
+{
+	unsigned char c1, c2;
+
+	while (count) {
+		c1 = *cs++;
+		c2 = *ct++;
+		if (c1 != c2)
+			return c1 < c2 ? -1 : 1;
+		if (!c1)
+			break;
+		count--;
+	}
+	return 0;
+}
+
+static int skip_atoi(const char **s)
+{
+	int i=0;
+
+	while (is_digit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+char *itoa(int value, char *string, int radix)
+{
+	char stack[16];
+	int  negative = 0;			//defualt is positive value
+	int  i;
+	int  j;
+	char digit_string[] = "0123456789ABCDEF";	
+	
+	if(value == 0)
+	{
+		//zero
+		string[0] = '0';
+		string[1] = '\0';
+		return string;
+	}
+	
+	if(value < 0)
+	{
+		//'value' is negative, convert to postive first
+		negative = 1;
+		value = -value ;
+	}
+	
+	for(i = 0; value > 0; ++i)
+	{
+		// characters in reverse order are put in 'stack'.
+		stack[i] = digit_string[value % radix];
+		value /= radix;
+	}
+	
+	//restore reversed order result to user string
+    j = 0;
+	if(negative)
+	{
+		//add sign at first charset.
+		string[j++] = '-';
+	}
+	for(--i; i >= 0; --i, ++j)
+	{
+		string[j] = stack[i];
+	}
+	//must end with '\0'.
+	string[j] = '\0';
+	
+	return string;
+}
+
+char *utoa(unsigned int value, char *string, int radix)
+{
+	char stack[16];
+	int  i;
+	int  j;
+	char digit_string[] = "0123456789ABCDEF";	
+	
+	if(value == 0)
+	{
+		//zero
+		string[0] = '0';
+		string[1] = '\0';
+		return string;
+	}
+	
+	for(i = 0; value > 0; ++i)
+	{
+		// characters in reverse order are put in 'stack'.
+		stack[i] = digit_string[value % radix];
+		value /= radix;
+	}
+	
+	//restore reversed order result to user string
+    for(--i, j = 0; i >= 0; --i, ++j)
+	{
+		string[j] = stack[i];
+	}
+	//must end with '\0'.
+	string[j] = '\0';
+	
+	return string;
+}
+
+/*
+*********************************************************************************************************
+*                                       	FORMATTED PRINTF
+*
+* Description: 	print out a formatted string, similar to ANSI-C function printf().
+*				This function can support and only support the following conversion specifiers:
+*              	%d	signed decimal integer.
+*              	%u	unsigned decimal integer.
+*              	%x	unsigned hexadecimal integer, using hex digits 0x.
+*              	%c	single character.
+*              	%s	character string.
+*
+* Arguments  : 	format	: format control.
+*				...		: arguments.
+*
+* Returns    : 	the number of characters printed out.
+*
+* Note		 : 	the usage refer to ANSI-C function printf().
+*********************************************************************************************************
+*/
+char debugger_buffer[DEBUG_BUFFER_SIZE];
+__s32 printk(const char *format, ...)
+{
+	va_list args;
+	char 	string[16];	//align by cpu word
+	char 	*pdest;
+	char 	*psrc;
+	__s32 	align;
+	__s32		len = 0;
+	
+	//dump current timestemp
+	//print_current_time();
+	
+	pdest = debugger_buffer;
+	va_start(args, format);
+	while(*format)
+	{
+		if(*format == '%')
+		{
+			++format;
+			if (('0' < (*format)) && ((*format) <= '9'))
+			{
+				//we just suport wide from 1 to 9.
+				align = *format - '0';
+				++format;
+			}
+			else
+			{
+				align = 0;
+			}
+			switch(*format)
+			{
+				case 'd':
+				{
+					//int
+					itoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'x': 
+				case 'p':
+				{
+					//hex
+					utoa(va_arg(args, int), string, 16);
+					len = strlen(string);
+					len += print_align(string, len, align);
+					strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'u': 
+				{
+					//unsigned int
+					utoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+					pdest += len;
+					break;
+				}
+				case 'c': 
+				{
+					//charset, aligned by cpu word
+					*pdest = (char)va_arg(args, int);
+					break;
+				}
+				case 's':
+				{
+					//string
+					psrc = va_arg(args, char *);
+					strcpy(pdest, psrc);
+					pdest += strlen(psrc);
+					break;
+				}
+				default : 
+				{
+					//no-conversion
+					*pdest++ = '%';
+					*pdest++ = *format;
+				}
+			}
+		}
+		else
+		{
+			*pdest++ = *format;
+		}
+		//parse next token
+		++format;
+	}
+	va_end(args);
+	
+	//must end with '\0'
+	*pdest = '\0';
+	pdest++;
+	serial_puts(debugger_buffer);
+	
+	return (pdest - debugger_buffer);
+}
+
+
+__s32 print_align(char *string, __s32 len, __s32 align)
+{
+	//fill with space ' ' when align request,
+	//the max align length is 16 byte.
+	char fill_ch[] = "                ";
+	if (len < align)
+	{
+		//fill at right
+		strncat(string, fill_ch, align - len);
+		return align - len;
+	}
+	//not fill anything
+	return 0;
+}
+
+__s32 printk_nommu(const char *format, ...)
+{
+	va_list args;
+	char 	string[16];	//align by cpu word
+	char 	*pdest;
+	char 	*psrc;
+	__s32 	align;
+	__s32		len = 0;
+	
+	//dump current timestemp
+	//print_current_time();
+	
+	pdest = debugger_buffer;
+	va_start(args, format);
+	while(*format)
+	{
+		if(*format == '%')
+		{
+			++format;
+			if (('0' < (*format)) && ((*format) <= '9'))
+			{
+				//we just suport wide from 1 to 9.
+				align = *format - '0';
+				++format;
+			}
+			else
+			{
+				align = 0;
+			}
+			switch(*format)
+			{
+				case 'd':
+				{
+					//int
+					itoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'x': 
+				case 'p':
+				{
+					//hex
+					utoa(va_arg(args, int), string, 16);
+					len = strlen(string);
+					len += print_align(string, len, align);
+					strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'u': 
+				{
+					//unsigned int
+					utoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+					pdest += len;
+					break;
+				}
+				case 'c': 
+				{
+					//charset, aligned by cpu word
+					*pdest = (char)va_arg(args, int);
+					break;
+				}
+				case 's':
+				{
+					//string
+					psrc = va_arg(args, char *);
+					strcpy(pdest, psrc);
+					pdest += strlen(psrc);
+					break;
+				}
+				default : 
+				{
+					//no-conversion
+					*pdest++ = '%';
+					*pdest++ = *format;
+				}
+			}
+		}
+		else
+		{
+			*pdest++ = *format;
+		}
+		//parse next token
+		++format;
+	}
+	va_end(args);
+	
+	//must end with '\0'
+	*pdest = '\0';
+	pdest++;
+	serial_puts_nommu(debugger_buffer);
+	
+	return (pdest - debugger_buffer);
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_printk.h b/arch/arm/mach-sun7i/pm/standby/mem_printk.h
new file mode 100755
index 0000000..78f4651
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_printk.h
@@ -0,0 +1,35 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2012-2015,  China
+*                                             All Rights Reserved
+*
+* File    : mem_printk.h
+* By      : young
+* Version : v1.0
+* Date    : 2011-5-30 19:50
+* Descript: intterupt bsp for platform standby.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_PRINTK_H__
+#define __MEM_PRINTK_H__
+
+#define DEBUG_BUFFER_SIZE (256)
+__s32 printk(const char *format, ...);
+__s32 printk_nommu(const char *format, ...);
+
+#define  print_call_info_nommu(...)({										\
+		do{															\
+			printk_nommu("%s, %s, %d. \n" , __FILE__, __func__, __LINE__);\
+		}while(0);})
+
+#define  print_call_info(...)({										\
+		do{															\
+			printk("%s, %s, %d. \n" , __FILE__, __func__, __LINE__);\
+		}while(0);})
+
+#endif  //__MEM_PRINTK_H__
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_serial.c b/arch/arm/mach-sun7i/pm/standby/mem_serial.c
new file mode 100755
index 0000000..a7a2c68
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_serial.c
@@ -0,0 +1,236 @@
+/**
+ * serial.c - common operations
+ * date:    2012-2-13 8:42:56
+ * author:  Aaron<leafy.myeh@allwinnertech.com>
+ * history: V0.1
+ */
+
+#include "pm.h"
+#include "pm_types.h"
+#include "mem_serial.h"
+
+#define readb(addr)		(*((volatile unsigned char  *)(addr)))
+#define readw(addr)		(*((volatile unsigned short *)(addr)))
+#define readl(addr)		(*((volatile unsigned long  *)(addr)))
+#define writeb(v, addr)	(*((volatile unsigned char  *)(addr)) = (unsigned char)(v))
+#define writew(v, addr)	(*((volatile unsigned short *)(addr)) = (unsigned short)(v))
+#define writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+
+#define USE_FIFO
+
+void serial_init_nommu(void)
+{
+#if 0
+	__u32 p2clk;
+	__u32 df;
+	__u32 lcr;
+	volatile unsigned int *reg;
+	__u32 port = 0;
+	__u32 i = 0;
+
+	p2clk = (24000000);
+
+	//config uart clk
+	reg = (volatile unsigned int *)(CCU_UART_PA);
+	*reg &= ~(1 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (1 << (16 + port));
+	// config uart gpio
+	// config tx gpio
+	//fpga not need care gpio config;
+	
+	/* set baudrate */
+	df = (p2clk + (SUART_BAUDRATE<<3))/(SUART_BAUDRATE<<4);
+	lcr = readl(SUART_LCR_PA);
+	writel(1, SUART_HALT_PA);
+	writel(lcr|0x80, SUART_LCR_PA);
+	writel(df>>8, SUART_DLH_PA);
+	writel(df&0xff, SUART_DLL_PA);
+	writel(lcr&(~0x80), SUART_LCR_PA);
+	writel(0, SUART_HALT_PA);
+
+	/* set mode, Set Lin Control Register*/
+	writel(3, SUART_LCR_PA);
+#endif
+
+#ifdef USE_FIFO
+	/* enable fifo */
+	writel(0xe1, SUART_FCR_PA);
+#endif
+
+}
+
+#if 0
+static void serial_put_char_nommu(char c)
+{
+#ifdef USE_FIFO
+		while (!(readb(SUART_USR_PA) & 2));
+		//writeb(readb(SUART_TX_FIFO_LEVEL_PA), SUART_THR_PA); //fifo level;
+		writeb(c, SUART_THR_PA);
+
+#else
+		while (!(readb(SUART_LSR_PA) & ( 1 << 6 )));
+		writeb(c, SUART_THR_PA);
+#endif
+
+
+}
+#endif
+
+static char serial_get_char_nommu(void)
+{
+	__u32 time = 0xffff;
+	while(!(readb(SUART_USR_PA)&0x08) && time);
+	if (!time)
+		return 0;
+	return readb(SUART_RBR_PA);
+}
+
+#if 0
+__s32 serial_puts_nommu(const char *string)
+{
+	//ASSERT(string != NULL);
+	
+	while(*string != '\0')
+	{
+		if(*string == '\n')
+		{
+			// if current character is '\n', 
+			// insert output with '\r'.
+			serial_put_char_nommu('\r');
+		}
+		serial_put_char_nommu(*string++);
+	}
+	
+	return OK;
+}
+#else
+__s32 serial_puts_nommu(const char *string)
+{
+	return OK;
+}
+#endif
+
+__u32 serial_gets_nommu(char* buf, __u32 n)
+{
+	__u32 i;
+	char c;
+	
+	for (i=0; i<n; i++) {
+		c = serial_get_char_nommu();
+		if (c == 0)
+			break;
+		buf[i] = c;
+	}
+	return i+1;
+}
+
+void serial_init(void)
+{
+	__u32 p2clk;
+	__u32 df;
+	__u32 lcr;
+	volatile unsigned int *reg;
+	__u32 port = 0;
+	__u32 i = 0;
+
+	p2clk = (24000000);
+
+	//config uart clk
+	reg = (volatile unsigned int *)(CCU_UART_VA);
+	*reg &= ~(1 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (1 << (16 + port));
+	// config uart gpio
+	// config tx gpio
+	//fpga not need care gpio config;
+
+	/* set baudrate */
+	df = (p2clk + (SUART_BAUDRATE<<3))/(SUART_BAUDRATE<<4);
+	lcr = readl(SUART_LCR);
+	writel(1, SUART_HALT);
+	writel(lcr|0x80, SUART_LCR);
+	writel(df>>8, SUART_DLH);
+	writel(df&0xff, SUART_DLL);
+	writel(lcr&(~0x80), SUART_LCR);
+	writel(0, SUART_HALT);
+
+	/* set mode, Set Lin Control Register*/
+	writel(3, SUART_LCR);
+	/* enable fifo */
+	writel(0xe1, SUART_FCR);
+#if 0
+#endif
+
+
+}
+
+
+static void serial_put_char(char c)
+{
+#ifdef USE_FIFO
+	//while (!(readb(SUART_USR) & 2));
+	//while (!(readb(SUART_USR) & 4));
+	//writeb(readb(SUART_TX_FIFO_LEVEL_VA), SUART_THR); //fifo level;
+	while (!(readb(SUART_TX_FIFO_LEVEL_VA) < 48))
+		;	
+	writeb(c, SUART_THR);
+#else
+	while (!(readb(SUART_LSR) & ( 1 << 6 )));
+	writeb(c, SUART_THR);
+#endif
+}
+
+static char serial_get_char(void)
+{
+	__u32 time = 0xffff;
+	while(!(readb(SUART_USR)&0x08) && time);
+	if (!time)
+		return 0;
+	return readb(SUART_RBR);
+}
+
+
+/*
+*********************************************************************************************************
+*                                       	PUT A STRING
+*
+* Description: 	put out a string.
+*
+* Arguments  : 	string	: the string which we want to put out.
+*
+* Returns    : 	OK if put out string succeeded, others if failed.
+*********************************************************************************************************
+*/
+__s32 serial_puts(const char *string)
+{
+	//ASSERT(string != NULL);
+	
+	while(*string != '\0')
+	{
+		if(*string == '\n')
+		{
+			// if current character is '\n', 
+			// insert output with '\r'.
+			serial_put_char('\r');
+		}
+		serial_put_char(*string++);
+	}
+	
+	return OK;
+}
+
+
+__u32 serial_gets(char* buf, __u32 n)
+{
+	__u32 i;
+	char c;
+	
+	for (i=0; i<n; i++) {
+		c = serial_get_char();
+		if (c == 0)
+			break;
+		buf[i] = c;
+	}
+	return i+1;
+}
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_serial.h b/arch/arm/mach-sun7i/pm/standby/mem_serial.h
new file mode 100755
index 0000000..948c25e
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_serial.h
@@ -0,0 +1,63 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : mem_serial.h
+* By      : 
+* Version : v1.0
+* Date    : 2011-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_SERIAL_H__
+#define __MEM_SERIAL_H__
+#include "pm.h"
+
+
+#define SUART_BASE_PA	SW_PA_UART0_IO_BASE
+#define SUART_BASE_VA	SW_VA_UART0_IO_BASE
+
+#define SUART_RBR_PA	(SUART_BASE_PA + 0x00)
+#define SUART_THR_PA	(SUART_BASE_PA + 0x00)
+#define SUART_DLL_PA	(SUART_BASE_PA + 0x00)
+#define SUART_DLH_PA	(SUART_BASE_PA + 0x04)
+#define SUART_FCR_PA	(SUART_BASE_PA + 0x08)
+#define SUART_LCR_PA	(SUART_BASE_PA + 0x0c)
+#define SUART_LSR_PA	(SUART_BASE_PA + 0x14)
+#define SUART_USR_PA	(SUART_BASE_PA + 0x7c)
+#define SUART_TX_FIFO_LEVEL_PA	(SUART_BASE_PA + 0x80)
+
+#define SUART_HALT_PA	(SUART_BASE_PA + 0xa4)
+
+#define SUART_RBR	(SUART_BASE_VA + 0x00)
+#define SUART_THR	(SUART_BASE_VA + 0x00)
+#define SUART_DLL	(SUART_BASE_VA + 0x00)
+#define SUART_DLH	(SUART_BASE_VA + 0x04)
+#define SUART_FCR	(SUART_BASE_VA + 0x08)
+#define SUART_LCR	(SUART_BASE_VA + 0x0c)
+#define SUART_LSR	(SUART_BASE_VA + 0x14)
+#define SUART_USR	(SUART_BASE_VA + 0x7c)
+#define SUART_TX_FIFO_LEVEL_VA	(SUART_BASE_VA + 0x80)
+
+#define SUART_HALT	(SUART_BASE_VA + 0xa4)
+
+#define SUART_BAUDRATE	(115200)
+#define CCU_UART_PA		(0x01c2006C)
+#define CCU_UART_VA		(0xF1c2006C)
+
+void serial_init(void);
+__s32 serial_puts(const char *string);
+__u32 serial_gets(char* buf, __u32 n);
+void serial_init_nommu(void);
+__s32 serial_puts_nommu(const char *string);
+__u32 serial_gets_nommu(char* buf, __u32 n);
+
+
+#endif  /* __MEM_SERIAL_H__ */
+
diff --git a/arch/arm/mach-sun7i/pm/standby/mem_timing.c b/arch/arm/mach-sun7i/pm/standby/mem_timing.c
new file mode 120000
index 0000000..f9b5885
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/mem_timing.c
@@ -0,0 +1 @@
+../mem_timing.c
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/pm/standby/pm_debug.c b/arch/arm/mach-sun7i/pm/standby/pm_debug.c
new file mode 100755
index 0000000..20b3797
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/pm_debug.c
@@ -0,0 +1,129 @@
+#include "pm_types.h"
+#include "pm.h"
+
+//for io-measure time
+#define PORT_E_CONFIG (SW_VA_PORTC_IO_BASE + 0x90)
+#define PORT_E_DATA (SW_VA_PORTC_IO_BASE + 0xa0)
+#define PORT_CONFIG PORT_E_CONFIG
+#define PORT_DATA PORT_E_DATA
+
+volatile int  print_flag = 0;
+
+void busy_waiting(void)
+{
+#if 1
+	volatile __u32 loop_flag = 1;
+	while(1 == loop_flag);
+	
+#endif
+	return;
+}
+
+void fake_busy_waiting(void)
+{
+#if 1
+	volatile __u32 loop_flag = 2;
+	while(1 == loop_flag);
+	
+#endif
+	return;
+}
+
+
+#define RTC_DATA_REG(x)				(SW_VA_TIMERC_IO_BASE + 0x120 + 4*(x))
+#define lread(n)                    (*((volatile unsigned int *)(n)))
+#define lwrite(addr,value)   (*((volatile unsigned int *)(addr)) = (value))
+
+/*flag: 0 -- save to rtc; 1 -- check crc*/
+void standby_dram_crc(int flag)
+{
+    int i, j;
+    int *tmp = (int *)0x40000000;
+    int crc = 0;
+    int crc_offset_words = 0;
+    crc_offset_words = lread(RTC_DATA_REG(7));
+    crc_offset_words = crc_offset_words & 7;
+    tmp += crc_offset_words;
+    if (flag == 1)
+    {
+        lwrite(RTC_DATA_REG(7), crc_offset_words + 1);
+    }
+    for(i = 0; i < 8; i++)
+    {
+        crc = 0;
+        for(j = 0; j < 128 * 1024 * 1024; j+=32)
+        {
+            crc += *tmp;
+            tmp += 8;
+        }
+        if (flag == 0)
+        {
+            lwrite(RTC_DATA_REG(8 + i), crc);
+        }
+        else
+        {
+            if (crc != lread(RTC_DATA_REG(8 + i)))
+            {
+                printk("[%dM - %dM) dram crc err!\n", i*128, (i + 1)*128);
+            }
+            else
+            {
+                printk("[%dM - %dM) dram crc ok!\n", i*128, (i + 1)*128);
+            }
+        }
+    }
+}
+
+
+/*
+ * notice: dependant with perf counter to delay.
+ */
+void io_init(void)
+{
+	//config port output
+	*(volatile unsigned int *)(PORT_CONFIG)  = 0x111111;
+	
+	return;
+}
+
+void io_init_high(void)
+{
+	__u32 data;
+	
+	//set port to high
+	data = *(volatile unsigned int *)(PORT_DATA);
+	data |= 0x3f;
+	*(volatile unsigned int *)(PORT_DATA) = data;
+
+	return;
+}
+
+void io_init_low(void)
+{
+	__u32 data;
+
+	data = *(volatile unsigned int *)(PORT_DATA);
+	//set port to low
+	data &= 0xffffffc0;
+	*(volatile unsigned int *)(PORT_DATA) = data;
+
+	return;
+}
+
+/*
+ * set pa port to high, num range is 0-7;	
+ */
+void io_high(int num)
+{
+	__u32 data;
+	data = *(volatile unsigned int *)(PORT_DATA);
+	//pull low 10ms
+	data &= (~(1<<num));
+	*(volatile unsigned int *)(PORT_DATA) = data;
+	delay_us(10000);
+	//pull high
+	data |= (1<<num);
+	*(volatile unsigned int *)(PORT_DATA) = data;
+
+	return;
+}
diff --git a/arch/arm/mach-sun7i/pm/standby/pm_debug.h b/arch/arm/mach-sun7i/pm/standby/pm_debug.h
new file mode 100755
index 0000000..64e6bd5
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/pm_debug.h
@@ -0,0 +1,102 @@
+#ifndef _PM_DEBUG_H
+#define _PM_DEBUG_H
+
+#include "pm_config.h"
+/*
+ * Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+ 
+#ifdef CONFIG_ARCH_SUN4I 
+	#define PERMANENT_REG (0xf1c20d20)
+	#define PERMANENT_REG_PA (0x01c20d20)
+	#define STATUS_REG (0xf1c20d20)
+	#define STATUS_REG_PA (0x01c20d20)
+#elif defined(CONFIG_ARCH_SUN5I)
+	#define PERMANENT_REG (0xF1c0123c)
+	#define PERMANENT_REG_PA (0x01c0123c)
+	#define STATUS_REG (0xf0000740)
+	#define STATUS_REG_PA (0x00000740)
+	//notice: the address is located in the last word of (DRAM_BACKUP_BASE_ADDR + DRAM_BACKUP_SIZE)
+	#define SUN5I_STATUS_REG (DRAM_BACKUP_BASE_ADDR + (DRAM_BACKUP_SIZE<<2) -0x4)
+	#define SUN5I_STATUS_REG_PA (DRAM_BACKUP_BASE_ADDR_PA + (DRAM_BACKUP_SIZE<<2) -0x4)
+#elif defined(CONFIG_ARCH_SUN6I)
+	#define STATUS_REG (0xf1f00100)
+	#define STATUS_REG_PA (0x01f00100)
+
+#endif
+
+
+
+//#define GET_CYCLE_CNT
+//#define IO_MEASURE
+extern volatile int print_flag;
+
+enum counter_type_e{
+	I_CACHE_MISS = 0X01,
+	I_TLB_MISS = 0X02,
+	D_CACHE_MISS = 0X03,
+	D_TLB_MISS = 0X05,
+};
+
+void set_event_counter(enum counter_type_e type);
+int get_event_counter(enum counter_type_e type);
+void init_event_counter (__u32 do_reset, __u32 enable_divider);
+
+/*
+ * Check at compile time that something is of a particular type.
+ * Always evaluates to 1 so you may use it easily in comparisons.
+ */
+#define typecheck(type,x) \
+({	type __dummy; \
+	typeof(x) __dummy2; \
+	(void)(&__dummy == &__dummy2); \
+	1; \
+})
+
+/*
+ * if return true, means a is after b;
+ */	
+#define counter_after(a,b) \
+(typecheck(__u32, a) && \
+typecheck(__u32, b) && \
+((__s32)(b) - (__s32)(a) < 0))
+#define counter_before(a,b) counter_after(b,a)
+
+#define counter_after_eq(a,b) \
+(typecheck(__u32, a) && \
+typecheck(__u32, b) && \
+((__s32)(a) - (__s32)(b) >= 0))
+#define counter_before_eq(a,b) counter_after_eq(b,a)
+
+
+void busy_waiting(void);
+/*
+ * notice: when resume, boot0 need to clear the flag, 
+ * in case the data in dram be destoryed result in the system is re-resume in cycle.
+*/
+void save_mem_flag(void);
+void clear_mem_flag(void);
+void save_mem_status(volatile __u32 val);
+void save_mem_status_nommu(volatile __u32 val);
+__u32 get_mem_status(void);
+__u32 save_sun5i_mem_status_nommu(volatile __u32 val);
+__u32 save_sun5i_mem_status(volatile __u32 val);
+
+void io_init(void);
+void io_init_high(void);
+void io_init_low(void);
+void io_high(int num);
+
+
+void standby_enable_crc(int enabled);
+void standby_set_crc(void *addr, int size);
+unsigned int standby_get_crc(void);
+void standby_dram_crc(int flag);
+
+
+#endif /*_PM_DEBUG_H*/
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby.c b/arch/arm/mach-sun7i/pm/standby/standby.c
new file mode 100755
index 0000000..42267cd
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby.c
@@ -0,0 +1,307 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 18:34
+* Descript: platform standby fucntion.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+
+extern unsigned int save_sp(void);
+extern void restore_sp(unsigned int sp);
+extern void mem_flush_tlb(void);
+extern void mem_preload_tlb(void);
+extern char *__bss_start;
+extern char *__bss_end;
+extern char *__standby_start;
+extern char *__standby_end;
+
+static __u32 sp_backup;
+static void standby(void);
+static __u32 dcdc2, dcdc3;
+static struct pll_factor_t orig_pll;
+static struct pll_factor_t local_pll;
+
+static struct sun4i_clk_div_t  clk_div;
+static struct sun4i_clk_div_t  tmp_clk_div;
+
+/* parameter for standby, it will be transfered from sys_pwm module */
+struct aw_pm_info  pm_info;
+
+#define DRAM_BASE_ADDR      0xc0000000
+static __u8 dram_traning_area_back[DRAM_TRANING_SIZE];
+
+/*
+*********************************************************************************************************
+*                                   STANDBY MAIN PROCESS ENTRY
+*
+* Description: standby main process entry.
+*
+* Arguments  : arg  pointer to the parameter that transfered from sys_pwm module.
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+int main(struct aw_pm_info *arg)
+{
+    char    *tmpPtr;
+
+    tmpPtr = (char *)&__bss_start;
+    printk("normal standby start!\n");
+    printk("__bss_start:%x!\n",&__bss_start);
+    if(!arg){
+        /* standby parameter is invalid */
+        return -1;
+    }
+
+    /* flush data and instruction tlb, there is 32 items of data tlb and 32 items of instruction tlb,
+       The TLB is normally allocated on a rotating basis. The oldest entry is always the next allocated */
+    mem_flush_tlb();
+    /* preload tlb for standby */
+    mem_preload_tlb();
+
+    /* clear bss segment */
+    do{*tmpPtr ++ = 0;}while(tmpPtr <= (char *)&__bss_end);
+
+    /* copy standby parameter from dram */
+    standby_memcpy(&pm_info, arg, sizeof(pm_info));
+    pm_info.standby_para.event = 0;
+    /* copy standby code & data to load tlb */
+    //standby_memcpy((char *)&__standby_end, (char *)&__standby_start, (char *)&__bss_end - (char *)&__bss_start);
+    /* backup dram traning area */
+    standby_memcpy((char *)dram_traning_area_back, (char *)DRAM_BASE_ADDR, DRAM_TRANING_SIZE);
+
+    /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
+    /* init module before dram enter selfrefresh */
+    /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
+
+    /* initialise standby modules */
+    standby_clk_init();
+    standby_clk_apbinit();
+    mem_int_init();
+    standby_tmr_init();
+    standby_power_init(pm_info.standby_para.axp_src);
+    /* init some system wake source */
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_EXINT){
+        mem_enable_int(INT_SOURCE_EXTNMI);
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_KEY){
+        standby_key_init();
+        mem_enable_int(INT_SOURCE_LRADC);
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_IR){
+        standby_ir_init();
+        mem_enable_int(INT_SOURCE_IR0);
+        mem_enable_int(INT_SOURCE_IR1);
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_ALARM){
+        //standby_alarm_init();???
+        mem_enable_int(INT_SOURCE_ALARM);
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_USB){
+        standby_usb_init();
+        mem_enable_int(INT_SOURCE_USB0);
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_TIMEOFF){
+        /* set timer for power off */
+        if(pm_info.standby_para.time_off) {
+            standby_tmr_set(pm_info.standby_para.time_off);
+            mem_enable_int(INT_SOURCE_TIMER0);
+        }
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_PIO){
+        mem_enable_int(INT_SOURCE_GPIO);
+    }
+
+    /* save stack pointer registger, switch stack to sram */
+    sp_backup = save_sp();
+    /* enable dram enter into self-refresh */
+    dram_power_save_process(0);
+	//mctl_self_refresh_entry();
+    
+    /* process standby */
+    standby();
+
+    /* enable watch-dog to preserve dram training failed */
+    standby_tmr_enable_watchdog();
+    /* restore dram */
+    //dram_power_up_process();
+	//mctl_self_refresh_exit();
+    init_DRAM(&pm_info.dram_para);
+    
+    /* disable watch-dog    */
+    standby_tmr_disable_watchdog();
+
+    /* restore stack pointer register, switch stack back to dram */
+    restore_sp(sp_backup);
+
+    /* exit standby module */
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_USB){
+        standby_usb_exit();
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_IR){
+        standby_ir_exit();
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_ALARM){
+        //standby_alarm_exit();
+    }
+    if(pm_info.standby_para.event_enable & SUSPEND_WAKEUP_SRC_KEY){
+        standby_key_exit();
+    }
+    standby_power_exit(pm_info.standby_para.event_enable);
+    standby_tmr_exit();
+    mem_int_exit();
+    standby_clk_apbexit();
+    standby_clk_exit();
+
+    /* restore dram traning area */
+    standby_memcpy((char *)DRAM_BASE_ADDR, (char *)dram_traning_area_back, DRAM_TRANING_SIZE);
+
+    /* report which wake source wakeup system */
+    arg->standby_para.event = pm_info.standby_para.event;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     SYSTEM PWM ENTER STANDBY MODE
+*
+* Description: enter standby mode.
+*
+* Arguments  : none
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+static void standby(void)
+{
+    /* gating off dram clock */
+    standby_clk_dramgating(0);
+
+	/* backup cpu freq */
+	standby_clk_get_pll_factor(&orig_pll);
+
+	/*lower freq from 1008M to 384M*/
+	local_pll.FactorN = 16;
+	local_pll.FactorK = 0;
+	local_pll.FactorM = 0;
+	local_pll.FactorP = 0;
+	standby_clk_set_pll_factor(&local_pll);
+	change_runtime_env(1);
+	delay_ms(10);
+	
+    /* switch cpu clock to HOSC, and disable pll */
+    standby_clk_core2hosc();
+	change_runtime_env(1);
+	delay_us(1);
+
+    if (pm_info.standby_para.axp_enable)
+    {
+        /* backup voltages */
+        dcdc2 = standby_get_voltage(POWER_VOL_DCDC2);
+        dcdc3 = standby_get_voltage(POWER_VOL_DCDC3);
+        printk("dcdc2:%d, dcdc3:%d!\n", dcdc2, dcdc3);
+        
+        /* adjust voltage */
+        standby_set_voltage(POWER_VOL_DCDC3, STANDBY_DCDC3_VOL);
+        standby_set_voltage(POWER_VOL_DCDC2, STANDBY_DCDC2_VOL);
+        printk("adjust dcdc2:%d, dcdc3:%d!\n", standby_get_voltage(POWER_VOL_DCDC2), standby_get_voltage(POWER_VOL_DCDC3));
+    }
+
+    /* set clock division cpu:axi:ahb:apb = 2:2:2:1 */
+    standby_clk_ahb_2pll();
+    standby_clk_getdiv(&clk_div);
+    tmp_clk_div.axi_div = 0;
+    tmp_clk_div.ahb_div = 0;
+    tmp_clk_div.apb_div = 0;
+    standby_clk_setdiv(&tmp_clk_div);
+    
+    /* swtich apb1 to losc */
+    standby_clk_apb2losc();
+	change_runtime_env(1);
+	//delay_ms(1);
+    standby_clk_plldisable();
+	
+    /* switch cpu to 32k */
+    standby_clk_core2losc();
+    #if(ALLOW_DISABLE_HOSC)
+    // disable HOSC, and disable LDO
+    standby_clk_hoscdisable();
+    standby_clk_ldodisable();
+    #endif
+
+    /* cpu enter sleep, wait wakeup by interrupt */
+    asm("WFI");
+
+    #if(ALLOW_DISABLE_HOSC)
+    /* enable LDO, enable HOSC */
+    standby_clk_ldoenable();
+    /* delay 1ms for power be stable */
+	//3ms
+    standby_delay_cycle(1);
+    standby_clk_hoscenable();
+	//3ms
+    standby_delay_cycle(1);
+    #endif
+
+	/* switch clock to hosc */
+    standby_clk_core2hosc();
+
+    /* swtich apb1 to hosc */
+    standby_clk_apb2hosc();
+
+    /* restore clock division */
+    standby_clk_setdiv(&clk_div);
+
+    /* check system wakeup event */
+    pm_info.standby_para.event |= mem_query_int(INT_SOURCE_EXTNMI)? 0:SUSPEND_WAKEUP_SRC_EXINT;
+    pm_info.standby_para.event |= mem_query_int(INT_SOURCE_USB0)? 0:SUSPEND_WAKEUP_SRC_USB;
+    pm_info.standby_para.event |= mem_query_int(INT_SOURCE_LRADC)? 0:SUSPEND_WAKEUP_SRC_KEY;
+    pm_info.standby_para.event |= mem_query_int(INT_SOURCE_IR0)? 0:SUSPEND_WAKEUP_SRC_IR;
+    pm_info.standby_para.event |= mem_query_int(INT_SOURCE_ALARM)? 0:SUSPEND_WAKEUP_SRC_ALARM;
+    pm_info.standby_para.event |= mem_query_int(INT_SOURCE_TIMER0)? 0:SUSPEND_WAKEUP_SRC_TIMEOFF;
+
+    if (pm_info.standby_para.axp_enable)
+    {
+        /* restore voltage for exit standby */
+        standby_set_voltage(POWER_VOL_DCDC2, dcdc2);
+        standby_set_voltage(POWER_VOL_DCDC3, dcdc3);
+    }
+
+    /* enable pll */
+    standby_clk_pllenable();
+	change_runtime_env(1);
+	delay_ms(10);
+
+    standby_clk_ahb_restore();
+    /* switch cpu clock to core pll */
+    standby_clk_core2pll();
+	change_runtime_env(1);
+	delay_ms(10);
+
+	/*restore freq from 384 to 1008M*/
+	standby_clk_set_pll_factor(&orig_pll);
+	change_runtime_env(1);
+	delay_ms(5);
+	
+    /* gating on dram clock */
+    standby_clk_dramgating(1);
+
+    return;
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby.xn b/arch/arm/mach-sun7i/pm/standby/standby.xn
new file mode 100755
index 0000000..30a9fdd
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby.xn
@@ -0,0 +1,22 @@
+
+OUTPUT_ARCH(arm)
+ENTRY(main)
+
+SECTIONS
+{
+	__standby_start = . ;
+	.text 0xf0000000 :
+	{
+		arch/arm/mach-sun7i/pm/standby/standby.o(.text.startup)
+		*(.text)
+		*(.rodata)
+	}
+	
+	.data   : { *(.data) }
+	
+	__bss_start = . ;
+	.bss : { *(.sbss) *(.scommon) *(.bss) *(COMMON) }
+	__bss_end = .;
+	__standby_end = . ;
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_cfg.h b/arch/arm/mach-sun7i/pm/standby/standby_cfg.h
new file mode 100755
index 0000000..9b59dd8
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_cfg.h
@@ -0,0 +1,35 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_cfg.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:29
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_CFG_H__
+#define __STANDBY_CFG_H__
+
+
+//config wakeup source for standby
+#define ALLOW_DISABLE_HOSC          (1)     // if allow disable hosc
+
+#define STANDBY_LDO1_VOL            (1300)  //LDO1 voltage value
+#define STANDBY_LDO2_VOL            (3000)  //LDO2 voltage value
+#define STANDBY_LDO3_VOL            (2800)  //LDO3 voltage value
+#define STANDBY_LDO4_VOL            (3300)  //LDO4 voltage value
+#define STANDBY_DCDC2_VOL           (700)   //DCDC2 voltage value
+#define STANDBY_DCDC3_VOL           (1000)  //DCDC3 voltage value
+
+
+#endif  /* __STANDBY_CFG_H__ */
+
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_clock.c b/arch/arm/mach-sun7i/pm/standby/standby_clock.c
new file mode 100755
index 0000000..85ad983
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_clock.c
@@ -0,0 +1,529 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_clock.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 13:40
+* Descript: ccmu process for platform standby;
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#include "standby_i.h"
+
+
+static __ccmu_reg_list_t   *CmuReg;;
+static __u32    ccu_reg_back[7];
+__u32   cpu_ms_loopcnt;
+
+//==============================================================================
+// CLOCK SET FOR SYSTEM STANDBY
+//==============================================================================
+
+
+
+
+/*
+*********************************************************************************************************
+*                           standby_clk_init
+*
+*Description: ccu init for platform standby
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_clk_init(void)
+{
+    CmuReg = (__ccmu_reg_list_t *)SW_VA_CCM_IO_BASE;
+
+    /* backup pll registers */
+    ccu_reg_back[0] = *(volatile __u32 *)&CmuReg->Pll1Ctl;
+    ccu_reg_back[1] = *(volatile __u32 *)&CmuReg->Pll2Ctl;
+    ccu_reg_back[2] = *(volatile __u32 *)&CmuReg->Pll3Ctl;
+    ccu_reg_back[3] = *(volatile __u32 *)&CmuReg->Pll4Ctl;
+    ccu_reg_back[4] = *(volatile __u32 *)&CmuReg->Pll5Ctl;
+    ccu_reg_back[5] = *(volatile __u32 *)&CmuReg->Pll6Ctl;
+    ccu_reg_back[6] = *(volatile __u32 *)&CmuReg->Pll7Ctl;
+
+    /* cpu frequency is 60mhz now */
+    cpu_ms_loopcnt = 3000;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_clk_exit
+*
+*Description: ccu exit for platform standby
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_clk_exit(void)
+{
+    /* restore pll registers */
+    *(volatile __u32 *)&CmuReg->Pll1Ctl = ccu_reg_back[0];
+    *(volatile __u32 *)&CmuReg->Pll2Ctl = ccu_reg_back[1];
+    *(volatile __u32 *)&CmuReg->Pll3Ctl = ccu_reg_back[2];
+    *(volatile __u32 *)&CmuReg->Pll4Ctl = ccu_reg_back[3];
+   // *(volatile __u32 *)&CmuReg->Pll5Ctl = ccu_reg_back[4];
+    *(volatile __u32 *)&CmuReg->Pll6Ctl = ccu_reg_back[5];
+    *(volatile __u32 *)&CmuReg->Pll7Ctl = ccu_reg_back[6];
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_core2losc
+*
+* Description: switch core clock to 32k low osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_core2losc(void)
+{
+    CmuReg->SysClkDiv.AC327ClkSrc = 0;
+    /* cpu frequency is 32k hz */
+    cpu_ms_loopcnt = 1;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_core2hosc
+*
+* Description: switch core clock to 24M high osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_core2hosc(void)
+{
+    CmuReg->SysClkDiv.AC327ClkSrc = 1;
+    /* cpu frequency is 24M hz */
+    cpu_ms_loopcnt = 600;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_core2pll
+*
+* Description: switch core clock to core pll.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_core2pll(void)
+{
+    CmuReg->SysClkDiv.AC327ClkSrc = 2;
+    /* cpu frequency is 60M hz */
+    cpu_ms_loopcnt = 2000;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_plldisable
+*
+* Description: disable dram pll.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_plldisable(void)
+{
+    CmuReg->Pll1Ctl.PLLEn = 0;
+    CmuReg->Pll2Ctl.PLLEn = 0;
+    CmuReg->Pll3Ctl.PLLEn = 0;
+    CmuReg->Pll4Ctl.PLLEn = 0;
+    CmuReg->Pll5Ctl.PLLEn = 0;
+    CmuReg->Pll6Ctl.PLLEn = 0;
+    CmuReg->Pll7Ctl.PLLEn = 0;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_pllenable
+*
+* Description: enable dram pll.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_pllenable(void)
+{
+    CmuReg->Pll1Ctl.PLLEn = 1;
+    CmuReg->Pll2Ctl.PLLEn = 1;
+    CmuReg->Pll3Ctl.PLLEn = 1;
+    CmuReg->Pll4Ctl.PLLEn = 1;
+    CmuReg->Pll5Ctl.PLLEn = 1;
+    CmuReg->Pll6Ctl.PLLEn = 1;
+    CmuReg->Pll7Ctl.PLLEn = 1;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_hoscdisable
+*
+* Description: disable HOSC.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_hoscdisable(void)
+{
+    CmuReg->HoscCtl.OSC24MEn = 0;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_hoscenable
+*
+* Description: enable HOSC.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_hoscenable(void)
+{
+    CmuReg->HoscCtl.OSC24MEn = 1;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_ldodisable
+*
+* Description: disable LDO.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_ldodisable(void)
+{
+    CmuReg->HoscCtl.KeyField = 0xA7;
+    CmuReg->HoscCtl.LDOEn = 0;
+    CmuReg->Pll5Ctl.LDO2En = 0;
+    CmuReg->HoscCtl.KeyField = 0x00;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_ldoenable
+*
+* Description: enable LDO.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_ldoenable(void)
+{
+    CmuReg->HoscCtl.KeyField = 0xA7;
+    CmuReg->HoscCtl.LDOEn = 1;
+    CmuReg->Pll5Ctl.LDO2En = 1;
+    CmuReg->HoscCtl.KeyField = 0x00;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_setdiv
+*
+* Description: switch core clock to 32k low osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_setdiv(struct sun4i_clk_div_t  *clk_div)
+{
+    if(!clk_div)
+    {
+        return -1;
+    }
+
+    CmuReg->SysClkDiv.AXIClkDiv = clk_div->axi_div;
+    CmuReg->SysClkDiv.AHBClkDiv = clk_div->ahb_div;
+    CmuReg->SysClkDiv.APB0ClkDiv = clk_div->apb_div;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_getdiv
+*
+* Description: switch core clock to 32k low osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_getdiv(struct sun4i_clk_div_t  *clk_div)
+{
+    if(!clk_div)
+    {
+        return -1;
+    }
+
+    clk_div->axi_div = CmuReg->SysClkDiv.AXIClkDiv;
+    clk_div->ahb_div = CmuReg->SysClkDiv.AHBClkDiv;
+    clk_div->apb_div = CmuReg->SysClkDiv.APB0ClkDiv;
+
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_set_pll_factor
+*
+* Description: set pll factor, target cpu freq is 384M hz
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+
+__s32 standby_clk_set_pll_factor(struct pll_factor_t *pll_factor)
+{
+    if(!pll_factor)
+    {
+        return -1;
+    }
+
+	CmuReg->Pll1Ctl.FactorN = pll_factor->FactorN;
+	CmuReg->Pll1Ctl.FactorK = pll_factor->FactorK;
+	CmuReg->Pll1Ctl.FactorM = pll_factor->FactorM;
+	CmuReg->Pll1Ctl.PLLDivP = pll_factor->FactorP;
+	
+	//busy_waiting();
+	
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_get_pll_factor
+*
+* Description: 
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+
+__s32 standby_clk_get_pll_factor(struct pll_factor_t *pll_factor)
+{
+    if(!pll_factor)
+    {
+        return -1;
+    }
+
+	pll_factor->FactorN = CmuReg->Pll1Ctl.FactorN;
+	pll_factor->FactorK = CmuReg->Pll1Ctl.FactorK;
+	pll_factor->FactorM = CmuReg->Pll1Ctl.FactorM;
+	pll_factor->FactorP = CmuReg->Pll1Ctl.PLLDivP;
+	
+	//busy_waiting();
+	
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_dramgating
+*
+* Description: gating dram clock.
+*
+* Arguments  : onoff    dram clock gating on or off;
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+void standby_clk_dramgating(int onoff)
+{
+    if(onoff) {
+        CmuReg->Pll5Ctl.OutputEn = 1;
+    }
+    else {
+        CmuReg->Pll5Ctl.OutputEn = 0;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_apb2losc
+*
+* Description: switch apb1 clock to 32k low osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_apb2losc(void)
+{
+    CmuReg->Apb1ClkDiv.ClkSrc = 2;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_apb2hosc
+*
+* Description: switch apb1 clock to 24M hosc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_apb2hosc(void)
+{
+    CmuReg->Apb1ClkDiv.ClkSrc = 0;
+    return 0;
+}
+
+
+static __ccmu_apb1clk_ratio_reg0058_t  apbclkbak;
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_apb2hosc
+*
+* Description: switch apb1 clock to 24M hosc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_apbinit(void)
+{
+    apbclkbak = CmuReg->Apb1ClkDiv;
+    /* change apb1 clock to hosc */
+    CmuReg->Apb1ClkDiv.ClkSrc = 0;
+    CmuReg->Apb1ClkDiv.ClkDiv = 0;
+    CmuReg->Apb1ClkDiv.PreDiv = 0;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_apb2hosc
+*
+* Description: switch apb1 clock to 24M hosc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_apbexit(void)
+{
+    /* restore clock division */
+    CmuReg->Apb1ClkDiv.ClkDiv = apbclkbak.ClkDiv;
+    CmuReg->Apb1ClkDiv.PreDiv = apbclkbak.PreDiv;
+    /* restore clock source */
+    CmuReg->Apb1ClkDiv.ClkSrc = apbclkbak.ClkSrc;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_apb_save
+*
+* Description: switch apb1 clock to 24M hosc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__ccmu_sysclkl_ratio_reg0054_t sysclk_bak;
+
+__s32 standby_clk_ahb_2pll(void)
+{
+    sysclk_bak = CmuReg->SysClkDiv;
+    /* change ahb clock to axi */
+    CmuReg->SysClkDiv.AHBClkSrc = 0;
+    printk("sysclk_bak, %x!\n", sysclk_bak);
+    return 0;
+}
+
+__s32 standby_clk_ahb_restore(void)
+{
+    //sysclk_bak = CmuReg->SysClkDiv;
+    /* restore ahb clock */
+    CmuReg->SysClkDiv.AHBClkSrc = sysclk_bak.AHBClkSrc;
+    return 0;
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_clock.h b/arch/arm/mach-sun7i/pm/standby/standby_clock.h
new file mode 100755
index 0000000..9520f35
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_clock.h
@@ -0,0 +1,56 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_clock.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 21:05
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_CLOCK_H__
+#define __STANDBY_CLOCK_H__
+
+#include "standby_cfg.h"
+#include <mach/ccmu.h>
+
+
+struct sun4i_clk_div_t {
+    __u32   cpu_div:4;      /* division of cpu clock, divide core_pll */
+    __u32   axi_div:4;      /* division of axi clock, divide cpu clock*/
+    __u32   ahb_div:4;      /* division of ahb clock, divide axi clock*/
+    __u32   apb_div:4;      /* division of apb clock, divide ahb clock*/
+    __u32   reserved:16;
+};
+
+
+__s32 standby_clk_init(void);
+__s32 standby_clk_exit(void);
+__s32 standby_clk_core2losc(void);
+__s32 standby_clk_core2hosc(void);
+__s32 standby_clk_core2pll(void);
+__s32 standby_clk_plldisable(void);
+__s32 standby_clk_pllenable(void);
+__s32 standby_clk_hoscdisable(void);
+__s32 standby_clk_hoscenable(void);
+__s32 standby_clk_ldodisable(void);
+__s32 standby_clk_ldoenable(void);
+__s32 standby_clk_setdiv(struct sun4i_clk_div_t  *clk_div);
+__s32 standby_clk_getdiv(struct sun4i_clk_div_t  *clk_div);
+void standby_clk_dramgating(int onoff);
+__s32 standby_clk_apbinit(void);
+__s32 standby_clk_apbexit(void);
+__s32 standby_clk_apb2losc(void);
+__s32 standby_clk_apb2hosc(void);
+
+extern __u32   cpu_ms_loopcnt;
+
+#endif  /* __STANDBY_CLOCK_H__ */
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_delay.S b/arch/arm/mach-sun7i/pm/standby/standby_delay.S
new file mode 100755
index 0000000..c5e95b8
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_delay.S
@@ -0,0 +1,28 @@
+//for 1008M
+#define STANDBY_COEFFICIENT (17)
+
+    .text
+    .globl standby_delay
+standby_delay:
+	push    {r0-r3}
+	ldr  	r1, =STANDBY_COEFFICIENT
+	mov	r3, r0
+loop2:
+	subs    r0, r0, #1
+	bhi	loop2
+	mov	r0, r3
+	subs	r1, r1, #1
+	bhi	loop2
+	
+	pop     {r0-r3}
+	mov     pc, lr
+
+    .text
+    .globl standby_delay_cycle
+standby_delay_cycle:
+loop3:
+	subs    r0, r0, #1
+	bhi	loop3
+	mov     pc, lr
+	
+	
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_i.h b/arch/arm/mach-sun7i/pm/standby/standby_i.h
new file mode 100755
index 0000000..67ea37f
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_i.h
@@ -0,0 +1,59 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_i.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 17:21
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_I_H__
+#define __STANDBY_I_H__
+
+#include "../pm_types.h" 
+#include "../pm.h"
+#include "mem_int.h"
+
+#include <linux/power/aw_pm.h>
+#include <mach/platform.h>
+
+#include "standby_cfg.h"
+#include "common.h"
+#include "standby_clock.h"
+#include "standby_key.h"
+#include "standby_power.h"
+#include "standby_usb.h"
+#include "standby_twi.h"
+#include "standby_ir.h"
+#include "standby_tmr.h"
+
+
+#define readb(addr)		(*((volatile unsigned char  *)(addr)))
+#define readw(addr)		(*((volatile unsigned short *)(addr)))
+#define readl(addr)		(*((volatile unsigned long  *)(addr)))
+#define writeb(v, addr)	(*((volatile unsigned char  *)(addr)) = (unsigned char)(v))
+#define writew(v, addr)	(*((volatile unsigned short *)(addr)) = (unsigned short)(v))
+#define writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+extern struct aw_pm_info  pm_info;
+
+#ifdef CHECK_CACHE_TLB_MISS
+extern int d_cache_miss_start;
+extern int d_tlb_miss_start;
+extern int i_tlb_miss_start;
+extern int i_cache_miss_start;
+extern int d_cache_miss_end;
+extern int d_tlb_miss_end;
+extern int i_tlb_miss_end;
+extern int i_cache_miss_end;
+#endif
+
+#endif  //__STANDBY_I_H__
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_ir.c b/arch/arm/mach-sun7i/pm/standby/standby_ir.c
new file mode 100755
index 0000000..efab28a
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_ir.c
@@ -0,0 +1,95 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_ir.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:36
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include  "standby_i.h"
+
+
+
+/*
+*********************************************************************************************************
+*                           INIT IR FOR STANDBY
+*
+*Description: init ir for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    init ir successed;
+*               EPDK_FAIL,  init ir failed;
+*********************************************************************************************************
+*/
+__s32  standby_ir_init(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           EXIT IR FOR STANDBY
+*
+*Description: exit ir for standby;
+*
+*Arguments  : none;
+*
+*Return     : result.
+*               EPDK_OK,    exit ir successed;
+*               EPDK_FAIL,  exit ir failed;
+*********************************************************************************************************
+*/
+__s32 standby_ir_exit(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           DETECT IR FOR STANDBY
+*
+*Description: detect ir for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    receive some signal;
+*               EPDK_FAIL,  no signal;
+*********************************************************************************************************
+*/
+__s32 standby_ir_detect(void)
+{
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           VERIFY IR SIGNAL FOR STANDBY
+*
+*Description: verify ir signal for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    valid ir signal;
+*               EPDK_FAIL,  invalid ir signal;
+*********************************************************************************************************
+*/
+__s32 standby_ir_verify(void)
+{
+    return -1;
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_ir.h b/arch/arm/mach-sun7i/pm/standby/standby_ir.h
new file mode 100755
index 0000000..ff4f746
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_ir.h
@@ -0,0 +1,29 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_ir.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:15
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#ifndef __STANDBY_IR_H__
+#define __STANDBY_IR_H__
+
+#include "standby_cfg.h"
+
+extern __s32 standby_ir_init(void);
+extern __s32 standby_ir_exit(void);
+extern __s32 standby_ir_detect(void);
+extern __s32 standby_ir_verify(void);
+
+#endif  /*__STANDBY_IR_H__*/
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_key.c b/arch/arm/mach-sun7i/pm/standby/standby_key.c
new file mode 100755
index 0000000..1dc9a3a
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_key.c
@@ -0,0 +1,96 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_key.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:16
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+static __standby_key_reg_t  *KeyReg;
+static __u32 KeyCtrl, KeyIntc, KeyInts, KeyData0, KeyData1;
+
+//==============================================================================
+// QUERRY KEY FOR WAKE UP SYSTEM FROM STANDBY
+//==============================================================================
+
+
+/*
+*********************************************************************************************************
+*                                     INIT KEY FOR STANDBY
+*
+* Description: init key for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_OK;
+*********************************************************************************************************
+*/
+__s32 standby_key_init(void)
+{
+    /* set key register base */
+    KeyReg = (__standby_key_reg_t *)SW_VA_LRADC_IO_BASE;
+
+    /* backup LRADC registers */
+    KeyCtrl = KeyReg->Lradc_Ctrl;
+    KeyIntc = KeyReg->Lradc_Intc;
+    KeyReg->Lradc_Ctrl = 0;
+    standby_mdelay(10);
+    KeyReg->Lradc_Ctrl = (0x1<<6)|(0x1<<0);
+    KeyReg->Lradc_Intc = (0x1<<1);
+    KeyReg->Lradc_Ints = (0x1<<1);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     EXIT KEY FOR STANDBY
+*
+* Description: exit key for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_OK;
+*********************************************************************************************************
+*/
+__s32 standby_key_exit(void)
+{
+    KeyReg->Lradc_Ctrl =  KeyCtrl;
+    KeyReg->Lradc_Intc =  KeyIntc;
+    return 0;
+}
+/*
+*********************************************************************************************************
+*                                     QUERY KEY FOR WAKEUP STANDBY
+*
+* Description: query key for wakeup standby.
+*
+* Arguments  : none
+*
+* Returns    : result;
+*               EPDK_TRUE,      get a key;
+*               EPDK_FALSE,     no key;
+*********************************************************************************************************
+*/
+__s32 standby_query_key(void)
+{
+    if(KeyReg->Lradc_Ints & 0x2)
+    {
+        KeyReg->Lradc_Ints = 0x2;
+        return 0;
+    }
+    return -1;
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_key.h b/arch/arm/mach-sun7i/pm/standby/standby_key.h
new file mode 100755
index 0000000..90b7187
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_key.h
@@ -0,0 +1,39 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_key.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:16
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_KEY_H__
+#define __STANDBY_KEY_H__
+
+#include "standby_cfg.h"
+//define key controller registers
+typedef struct __STANDBY_KEY_REG
+{
+    // offset:0x00
+    volatile __u32   Lradc_Ctrl;
+    volatile __u32   Lradc_Intc;
+    volatile __u32   Lradc_Ints;
+    volatile __u32   Lradc_Data0;
+    volatile __u32   Lradc_Data1;
+} __standby_key_reg_t;
+
+extern __s32 standby_key_init(void);
+extern __s32 standby_key_exit(void);
+extern __s32 standby_query_key(void);
+
+
+#endif  /* __STANDBY_KEY_H__ */
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_power.c b/arch/arm/mach-sun7i/pm/standby/standby_power.c
new file mode 100755
index 0000000..f46e2b0
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_power.c
@@ -0,0 +1,340 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_power.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+#ifdef  CONFIG_ARCH_SUN7I
+#define NMI_CTL_REG            (0xf1c00030)
+#define NMI_IRG_PENDING_REG    (0xf1c00034)
+#define NMI_INT_ENABLE_REG     (0xf1c00038)
+#endif
+#define writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+
+
+//==============================================================================
+// POWER CHECK FOR SYSTEM STANDBY
+//==============================================================================
+
+
+/*
+*********************************************************************************************************
+*                           standby_power_init
+*
+* Description: init power for standby.
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*********************************************************************************************************
+*/
+__s32 standby_power_init(__u32 wakeup_src)
+{
+	__u8	reg_val;
+
+	standby_twi_init(AXP_IICBUS);
+
+	if(wakeup_src & AXP_WAKEUP_KEY){
+		/* enable pek long/short */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+		reg_val |= 0x03;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+	}
+
+	if(wakeup_src & AXP_WAKEUP_LONG_KEY){
+		/* enable pek long */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+		reg_val |= 0x01;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+		/*pek long period setting: 1s*/
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_PEK, &reg_val);
+		reg_val &= 0xcf;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_PEK, &reg_val);
+	}
+	
+	if(wakeup_src & AXP_WAKEUP_SHORT_KEY){
+		/* enable pek short */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+		reg_val |= 0x02;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+	}
+
+	if(wakeup_src & AXP_WAKEUP_DESCEND){
+		/* enable pek desend trigger */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN5, &reg_val);
+		reg_val |= 0x20;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN5, &reg_val);
+	}
+
+	if(wakeup_src & AXP_WAKEUP_ASCEND){
+		/* enable pek ascend trigger */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN5, &reg_val);
+		reg_val |= 0x40;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN5, &reg_val);
+	}
+	
+	if(wakeup_src & AXP_WAKEUP_LOWBATT){
+		/* enable low voltage warning */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN4, &reg_val);
+		reg_val |= 0x03;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN4, &reg_val);
+		/* clear pending */
+		reg_val |= 0x03;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQ4, &reg_val);
+	}
+	
+	if(wakeup_src & AXP_WAKEUP_USB){
+		/* enable usb plug-in / plug-out */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN1, &reg_val);
+		reg_val |= 0x03<<2;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN1, &reg_val);
+	}
+
+	if(wakeup_src & AXP_WAKEUP_AC){
+		/* enable ac plug-in / plug-out */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN1, &reg_val);
+		reg_val |= 0x03<<5;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN1, &reg_val);
+	}
+
+#ifdef CONFIG_ARCH_SUN7I
+    writel(0x1,NMI_INT_ENABLE_REG);
+#endif
+    
+    
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_power_exit
+*
+* Description: exit power for standby.
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*********************************************************************************************************
+*/
+__s32 standby_power_exit(__u32 wakeup_src)
+{
+	__u8    reg_val;
+
+	twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQ4, &reg_val);
+	twi_byte_rw(TWI_OP_WR, AXP_ADDR,0x0E, &reg_val);
+
+	if(wakeup_src & AXP_WAKEUP_KEY){
+		/* disable pek long/short */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+		reg_val &= ~0x03;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+	}
+	
+	if(wakeup_src & AXP_WAKEUP_LONG_KEY){
+		/* enable pek long/short */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+		reg_val &= ~0x01;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+	}
+	
+	if(wakeup_src & AXP_WAKEUP_SHORT_KEY){
+		/* enable pek long/short */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+		reg_val &= ~0x02;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+	}
+
+	if(wakeup_src & AXP_WAKEUP_DESCEND){
+		/* disable pek desend trigger */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN5, &reg_val);
+		reg_val &= ~0x20;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN5, &reg_val);
+	}
+
+	if(wakeup_src & AXP_WAKEUP_ASCEND){
+		/* disable pek desend trigger */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN5, &reg_val);
+		reg_val &= ~0x40;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN5, &reg_val);
+	}
+	
+	if(wakeup_src & AXP_WAKEUP_LOWBATT){
+		/* disable low voltage warning */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN4, &reg_val);
+		reg_val &= ~0x03;
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN4, &reg_val);
+	}
+
+	if(wakeup_src & AXP_WAKEUP_USB){
+		/* disable usb plug-in / plug-out */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN1, &reg_val);
+		reg_val &= ~(0x03<<2);
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN1, &reg_val);
+	}
+
+	if(wakeup_src & AXP_WAKEUP_AC){
+		/* disable ac plug-in / plug-out */
+		twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN1, &reg_val);
+		reg_val &= ~(0x03<<5);
+		twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN1, &reg_val);
+	}
+
+#ifdef CONFIG_ARCH_SUN7I
+    writel(0x0,NMI_INT_ENABLE_REG);
+#endif
+    standby_twi_exit();
+    return 0;
+}
+
+
+static inline int check_range(struct axp_info *info,__s32 voltage)
+{
+	if (voltage < info->min_uV || voltage > info->max_uV)
+		return -1;
+
+	return 0;
+}
+
+static int axp20_ldo4_data[] = {
+    1250, 1300, 1400, 1500, 1600, 1700,
+    1800, 1900, 2000, 2500, 2700, 2800,
+    3000, 3100, 3200, 3300
+};
+
+static struct axp_info axp20_info[] = {
+	AXP(POWER_VOL_LDO1,	 AXP20LDO1,	AXP20LDO1,	  0, AXP20_LDO1,  0, 0),//ldo1 for rtc
+	AXP(POWER_VOL_LDO2,	      1800,      3300,  100, AXP20_LDO2,  4, 4),//ldo2 for analog1
+	AXP(POWER_VOL_LDO3,	       700,      3500,   25, AXP20_LDO3,  0, 7),//ldo3 for digital
+	AXP(POWER_VOL_LDO4,	      1250,      3300,  100, AXP20_LDO4,  0, 4),//ldo4 for analog2
+	AXP(POWER_VOL_DCDC2,       700,      2275,   25, AXP20_BUCK2, 0, 6),//buck2 for core
+	AXP(POWER_VOL_DCDC3,       700,      3500,   25, AXP20_BUCK3, 0, 7),//buck3 for memery
+};
+
+static inline struct axp_info *find_info(int id)
+{
+	struct axp_info *ri;
+	int i;
+
+	for (i = 0; i < sizeof(axp20_info)/sizeof(struct axp_info); i++) {
+		ri = &axp20_info[i];
+		if (ri->id == id)
+			return ri;
+	}
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           standby_set_voltage
+*
+*Description: set voltage for standby;
+*
+*Arguments  : type      voltage type, defined as "enum power_vol_type_e";
+*             voltage   voltage value, based on "mv";
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void  standby_set_voltage(enum power_vol_type_e type, __s32 voltage)
+{
+	struct axp_info *info = 0;
+	__u8 val, mask, reg_val;
+
+	info = find_info(type);
+	if (info == 0) {
+		return;
+	}
+
+	if (check_range(info, voltage)) {
+		return;
+	}
+
+	if (type != POWER_VOL_LDO4)
+		val = raw_lib_udiv((voltage-info->min_uV+info->step_uV-1), info->step_uV);
+	else{
+		if(voltage == 1250000 ){
+			val = 0;
+		}
+		else{
+			val = raw_lib_udiv((voltage-1200000+info->step_uV-1), info->step_uV);
+			if(val > 16){
+				val = val - 6;
+			}
+			else if(val > 13){
+				val = val - 5;
+			}
+			else if(val > 12){
+				val = val - 4;
+			}
+			else if(val > 8)
+				val = 8;
+		}
+	}
+
+
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	twi_byte_rw(TWI_OP_RD,AXP_ADDR,info->vol_reg, &reg_val);
+
+	if ((reg_val & mask) != val) {
+		reg_val = (reg_val & ~mask) | val;
+		twi_byte_rw(TWI_OP_WR,AXP_ADDR,info->vol_reg, &reg_val);
+	}
+
+	return;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_get_voltage
+*
+*Description: get voltage for standby;
+*
+*Arguments  : type  voltage type, defined as "enum power_vol_type_e";
+*
+*Return     : voltage value, based on "mv";
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__u32 standby_get_voltage(enum power_vol_type_e type)
+{
+	struct axp_info *info = 0;
+	__u8 val, mask;
+
+	info = find_info(type);
+	if (info == 0) {
+		return -1;
+	}
+
+	twi_byte_rw(TWI_OP_RD,AXP_ADDR,info->vol_reg, &val);
+
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+	if (type != POWER_VOL_LDO4)
+		return info->min_uV + info->step_uV * val;
+	else
+		return axp20_ldo4_data[val]*1000;
+}
+
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_power.h b/arch/arm/mach-sun7i/pm/standby/standby_power.h
new file mode 100755
index 0000000..60a435d
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_power.h
@@ -0,0 +1,89 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_power.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_POWER_H__
+#define __STANDBY_POWER_H__
+
+#include "standby_cfg.h"
+
+enum power_vol_type_e{
+
+    POWER_VOL_DCDC1,
+    POWER_VOL_DCDC2,
+    POWER_VOL_DCDC3,
+    POWER_VOL_LDO1,
+    POWER_VOL_LDO2,
+    POWER_VOL_LDO3,
+    POWER_VOL_LDO4,
+
+};
+
+#define AXP_ADDR        (0x34)
+#define AXP_IICBUS      (0)
+#define AXP20_LDO1      (0x00)
+#define AXP20_LDO2      (0x28)
+#define AXP20_LDO3      (0x29)
+#define AXP20_LDO4      (0x28)
+#define AXP20_BUCK2     (0x23)
+#define AXP20_BUCK3     (0x27)
+
+#define AXP20_PEK    	(0x36)
+#define AXP20_IRQEN1    (0x40)
+#define AXP20_IRQEN2    (0x41)
+#define AXP20_IRQEN3    (0x42)
+#define AXP20_IRQEN4    (0x43)
+#define AXP20_IRQEN5    (0x44)
+
+#define AXP20_IRQ1      (0x48)
+#define AXP20_IRQ2      (0x49)
+#define AXP20_IRQ3      (0x4A)
+#define AXP20_IRQ4      (0x4B)
+#define AXP20_IRQ5      (0x4C)
+
+#define AXP20LDO1       1300
+
+
+#define AXP(_id, min, max, step, vreg, shift, nbits)    \
+{                               \
+    .id = _id,                  \
+    .min_uV        = (min),     \
+    .max_uV        = (max),     \
+    .step_uV    = (step),       \
+    .vol_reg    =  (vreg),      \
+    .vol_shift    = (shift),    \
+    .vol_nbits    = (nbits),    \
+}
+
+struct axp_info {
+    enum    power_vol_type_e id;
+    int     min_uV;
+    int     max_uV;
+    int     step_uV;
+    int     vol_reg;
+    int     vol_shift;
+    int     vol_nbits;
+};
+
+extern __s32 standby_power_init(__u32 wakeup_src);
+extern __s32 standby_power_exit(__u32 wakeup_src);
+extern void  standby_set_voltage(enum power_vol_type_e type, __s32 voltage);
+extern __u32 standby_get_voltage(enum power_vol_type_e type);
+
+
+#endif  /* __STANDBY_POWER_H__ */
+
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_tmr.c b/arch/arm/mach-sun7i/pm/standby/standby_tmr.c
new file mode 100755
index 0000000..de77d41
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_tmr.c
@@ -0,0 +1,236 @@
+/*
+*********************************************************************************************************
+*                                                    eMOD
+*                                   the Easy Portable/Player Operation System
+*                                            power manager sub-system
+*
+*                                     (c) Copyright 2008-2009, kevin.z China
+*                                              All Rights Reserved
+*
+* File   : standby_tmr.c
+* Version: V1.0
+* By     : kevin.z
+* Date   : 2009-7-22 18:31
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+
+static __mem_tmr_reg_t  *TmrReg;
+static __u32 TmrIntCtl, Tmr0Ctl, Tmr0IntVal, Tmr0CntVal, Tmr1Ctl, Tmr1IntVal, Tmr1CntVal;
+
+/*
+*********************************************************************************************************
+*                                     TIMER INIT
+*
+* Description: initialise timer for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 standby_tmr_init(void)
+{
+    __s32       i;
+
+    /* set timer register base */
+    TmrReg = (__mem_tmr_reg_t *)SW_VA_TIMERC_IO_BASE;
+
+    /* backup timer registers */
+    TmrIntCtl   = TmrReg->IntCtl;
+    Tmr0Ctl     = TmrReg->Tmr0Ctl;
+    Tmr0IntVal  = TmrReg->Tmr0IntVal;
+    Tmr0CntVal  = TmrReg->Tmr0CntVal;
+    Tmr1Ctl     = TmrReg->Tmr1Ctl;
+    Tmr1IntVal  = TmrReg->Tmr1IntVal;
+    Tmr1CntVal  = TmrReg->Tmr1CntVal;
+
+    /* config timer interrrupt */
+    TmrReg->IntCtl   = 0;
+    TmrReg->IntSta   = 1;
+
+    /* config timer1 for process udelay */
+    TmrReg->Tmr1Ctl  = 0;
+    standby_delay(1000);
+    TmrReg->Tmr1Ctl  = (1<<7)|(5<<4);
+    standby_delay(1000);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     TIMER EXIT
+*
+* Description: exit timer for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 standby_tmr_exit(void)
+{
+    __s32   i;
+
+    /* restore timer0 parameters */
+    TmrReg->Tmr0IntVal  = Tmr0IntVal;
+    TmrReg->Tmr0CntVal  = Tmr0CntVal;
+    TmrReg->Tmr0Ctl     = Tmr0Ctl;
+    TmrReg->Tmr1IntVal  = Tmr1IntVal;
+    TmrReg->Tmr1CntVal  = Tmr1CntVal;
+    TmrReg->Tmr1Ctl     = Tmr1Ctl;
+    TmrReg->IntCtl      = TmrIntCtl;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_tmr_set
+*
+*Description: set timer for wakeup system.
+*
+*Arguments  : second    time value for wakeup system.
+*
+*Return     : result, 0 - successed, -1 - failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_tmr_set(__u32 second)
+{
+    /* config timer interrrupt */
+    TmrReg->IntSta     = 1;
+    TmrReg->IntCtl     = 1;
+
+    /* config timer0 for standby */
+    TmrReg->Tmr0Ctl    = 0;
+    TmrReg->Tmr0IntVal = second << 10;
+    TmrReg->Tmr0Ctl    = (1<<7) | (5<<4);
+    TmrReg->Tmr0Ctl   |= (1<<1);
+    TmrReg->Tmr0Ctl   |= (1<<0);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_tmr_enable_watchdog
+*
+*Description: enable watch-dog.
+*
+*Arguments  : none.
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_tmr_enable_watchdog(void)
+{
+    /* set watch-dog reset, timeout is 2 seconds */
+    TmrReg->DogMode = (2<<3) | (1<<1);
+    /* enable watch-dog */
+    TmrReg->DogMode |= (1<<0);
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_tmr_disable_watchdog
+*
+*Description: disable watch-dog.
+*
+*Arguments  : none.
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_tmr_disable_watchdog(void)
+{
+    /* disable watch-dog reset */
+    TmrReg->DogMode &= ~(1<<1);
+    /* disable watch-dog */
+    TmrReg->DogMode &= ~(1<<0);
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               standby_tmr_query
+*
+* Description:
+*
+* Arguments  :
+*
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32 standby_tmr_query(enum tmr_event_type_e type)
+{
+    __s32   result;
+
+    switch(type)
+    {
+        case TMR_EVENT_POWEROFF:
+        {
+            if(TmrReg->IntSta & 1)
+            {
+                TmrReg->IntSta = 1;
+                return 0;
+            }
+            return -1;
+        }
+
+        case TMR_EVENT_ALARM:
+        default:
+            return -1;
+    }
+
+    return -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_tmr_mdlay
+*
+*Description: delay ms
+*
+*Arguments  : ms    time for delay;
+*
+*Return     : none
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_tmr_mdlay(int ms)
+{
+    int     i;
+
+    if(ms < 30){
+        ms = 30;
+    }
+
+    TmrReg->Tmr1IntVal = ms;
+    TmrReg->Tmr1Ctl   |= (1<<1);
+    TmrReg->Tmr1Ctl   |= (1<<0);
+    standby_delay(3000);
+    while(TmrReg->Tmr1CntVal);
+
+    return;
+}
\ No newline at end of file
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_tmr.h b/arch/arm/mach-sun7i/pm/standby/standby_tmr.h
new file mode 100755
index 0000000..d0ec28b
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_tmr.h
@@ -0,0 +1,37 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_tmr.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:23
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_TMR_H__
+#define __STANDBY_TMR_H__
+
+#include "standby_cfg.h"
+
+enum tmr_event_type_e{
+    TMR_EVENT_POWEROFF,
+    TMR_EVENT_ALARM,
+};
+
+
+__s32 standby_tmr_init(void);
+__s32 standby_tmr_exit(void);
+__s32 standby_tmr_query(enum tmr_event_type_e type);
+void standby_tmr_mdlay(int ms);
+void standby_tmr_enable_watchdog(void);
+void standby_tmr_disable_watchdog(void);
+
+#endif  //__STANDBY_TMR_H__
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_twi.c b/arch/arm/mach-sun7i/pm/standby/standby_twi.c
new file mode 100755
index 0000000..93bc079
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_twi.c
@@ -0,0 +1,284 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_twi.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:22
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+static __twic_reg_t*   TWI_REG_BASE[3] = {
+    (__twic_reg_t*)SW_VA_TWI0_IO_BASE,
+    (__twic_reg_t*)SW_VA_TWI1_IO_BASE,
+    (__twic_reg_t*)SW_VA_TWI2_IO_BASE
+};
+
+static __u32 TwiClkRegBak = 0;
+static __u32 TwiCtlRegBak = 0;
+static __twic_reg_t *twi_reg  = 0;
+
+
+
+/*
+*********************************************************************************************************
+*                                   standby_twi_init
+*
+*Description: init twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+__s32 standby_twi_init(int group)
+{
+	twi_reg  = TWI_REG_BASE[group];
+	TwiClkRegBak = twi_reg->reg_clkr;
+	TwiCtlRegBak = 0x80&twi_reg->reg_ctl;/* backup INT_EN;no need for BUS_EN(0xc0)  */
+	//twi_reg->reg_clkr = (2<<3)|3; //100k
+	twi_reg->reg_clkr = (5<<3)|0; //400k, M = 5, N=0;
+
+	twi_reg->reg_reset |= 0x1;
+	while(twi_reg->reg_reset&0x1);
+	
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   standby_twi_exit
+*
+*Description: exit twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+__s32 standby_twi_exit(void)
+{
+    /* softreset twi module  */
+    twi_reg->reg_reset |= 0x1;
+    /* delay */
+    standby_mdelay(10);
+
+    /* restore clock division */
+    twi_reg->reg_clkr = TwiClkRegBak;
+    /* restore INT_EN */
+    twi_reg->reg_ctl |= TwiCtlRegBak;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   _standby_twi_stop
+*
+*Description: stop current twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+static int _standby_twi_stop(void)
+{
+    unsigned int   nop_read;
+    unsigned int   timeout = TWI_CHECK_TIMEOUT;
+
+    twi_reg->reg_ctl = (twi_reg->reg_ctl & 0xc0) | 0x10;/* set stop+clear int flag */
+
+    nop_read = twi_reg->reg_ctl;/* apbstop bit, */
+    nop_read = nop_read;
+    // 1. stop bit is zero.
+    while((twi_reg->reg_ctl & 0x10)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+    // 2. twi fsm is idle(0xf8).
+    timeout = TWI_CHECK_TIMEOUT;
+    while((0xf8 != twi_reg->reg_status)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+    // 3. twi scl & sda must high level.
+    timeout = TWI_CHECK_TIMEOUT;
+    while((0x3a != twi_reg->reg_lctl)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   twi_byte_rw
+*
+*Description: twi byte read and write.
+*
+*Arguments  : op        operation read or write;
+*             saddr     slave address;
+*             baddr     byte address;
+*             data      pointer to the data to be read or write;
+*
+*Return     : result;
+*               = EPDK_OK,      byte read or write successed;
+*               = EPDK_FAIL,    btye read or write failed!
+*********************************************************************************************************
+*/
+__s32 twi_byte_rw(enum twi_op_type_e op, __u8 saddr, __u8 baddr, __u8 *data)
+{
+    unsigned char state_tmp;
+    unsigned int   timeout;
+    int   ret = -1;
+
+    twi_reg->reg_efr = 0;/* 0 */
+
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0xf8)
+    {
+        goto stop_out;
+    }
+
+    /* control registser bitmap
+         7      6       5     4       3       2    1    0
+      INT_EN  BUS_EN  START  STOP  INT_FLAG  ACK  NOT  NOT
+    */
+
+    //1.Send Start
+    twi_reg->reg_ctl |= 0x20;
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x08)
+    {
+        goto stop_out;
+    }
+
+    //2.Send Slave Address
+    twi_reg->reg_data = (saddr<<1) | 0; /* slave address + write */
+    twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x18)
+    {
+        goto stop_out;
+    }
+
+    //3.Send Byte Address
+    twi_reg->reg_data = baddr;
+    twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x28)
+    {
+        goto stop_out;
+    }
+
+    if(op == TWI_OP_WR)
+    {
+        //4.Send Data to be write
+        twi_reg->reg_data = *data;
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x28)
+        {
+            goto stop_out;
+        }
+    }
+    else
+    {
+        //4. Send restart for read
+        twi_reg->reg_ctl = (twi_reg->reg_ctl & 0xc0) | 0x20;/* set start+clear int flag */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x10)
+        {
+            goto stop_out;
+        }
+
+        //5.Send Slave Address
+        twi_reg->reg_data = (saddr<<1) | 1;/* slave address+ read */
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag then 0x40 come in */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x40)
+        {
+            goto stop_out;
+        }
+
+        //6.Get data
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag then data come in */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        *data = twi_reg->reg_data;
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x58)
+        {
+          goto stop_out;
+        }
+    }
+
+    ret = 0;
+
+stop_out:
+    //WRITE: step 5; READ: step 7
+    //Send Stop
+    _standby_twi_stop();
+
+    return ret;
+}
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_twi.h b/arch/arm/mach-sun7i/pm/standby/standby_twi.h
new file mode 100755
index 0000000..403d612
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_twi.h
@@ -0,0 +1,54 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_twi.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:22
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#ifndef __STANDBY_TWI_H__
+#define __STANDBY_TWI_H__
+
+#include "standby_cfg.h"
+
+
+typedef struct tag_twic_reg
+{
+    volatile unsigned int reg_saddr;
+    volatile unsigned int reg_xsaddr;
+    volatile unsigned int reg_data;
+    volatile unsigned int reg_ctl;
+    volatile unsigned int reg_status;
+    volatile unsigned int reg_clkr;
+    volatile unsigned int reg_reset;
+    volatile unsigned int reg_efr;
+    volatile unsigned int reg_lctl;
+
+}__twic_reg_t;
+
+
+
+enum twi_op_type_e{
+    TWI_OP_RD,
+    TWI_OP_WR,
+};
+
+
+extern __s32 standby_twi_init(int group);
+extern __s32 standby_twi_exit(void);
+extern __s32 twi_byte_rw(enum twi_op_type_e op, __u8 saddr, __u8 baddr, __u8 *data);
+
+
+
+#endif  /* __STANDBY_TWI_H__ */
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_usb.c b/arch/arm/mach-sun7i/pm/standby/standby_usb.c
new file mode 100755
index 0000000..ee7db4d
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_usb.c
@@ -0,0 +1,99 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_usb.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:18
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+
+
+//==============================================================================
+// USB CHECK FOR WAKEUP SYSTEM FROM STANDBY
+//==============================================================================
+
+
+/*
+*********************************************************************************************************
+*                                     standby_usb_init
+*
+* Description: init usb for standby.
+*
+* Arguments  : none;
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+__s32 standby_usb_init(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_usb_exit
+*
+* Description: exit usb for standby.
+*
+* Arguments  : none;
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+__s32 standby_usb_exit(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_is_usb_status_change
+*
+*Description: check if usb status is change.
+*
+*Arguments  : port  usb port number;
+*
+*Return     : result, 0 status not change, !0 status changed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_is_usb_status_change(__u32 port)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_query_usb_event
+*
+* Description: query usb event for wakeup system from standby.
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*               EPDK_TRUE,  some usb event happenned;
+*               EPDK_FALSE, none usb event;
+*********************************************************************************************************
+*/
+__s32 standby_query_usb_event(void)
+{
+    return -1;
+}
+
+
diff --git a/arch/arm/mach-sun7i/pm/standby/standby_usb.h b/arch/arm/mach-sun7i/pm/standby/standby_usb.h
new file mode 100755
index 0000000..bdfc5a5
--- /dev/null
+++ b/arch/arm/mach-sun7i/pm/standby/standby_usb.h
@@ -0,0 +1,29 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        newbie Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_usb.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:17
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_USB_H__
+#define __STANDBY_USB_H__
+
+#include "standby_cfg.h"
+
+
+extern __s32 standby_usb_init(void);
+extern __s32 standby_usb_exit(void);
+extern __s32 standby_query_usb_event(void);
+
+#endif  /* __STANDBY_USB_H__ */
+
diff --git a/arch/arm/plat-sunxi/Kconfig b/arch/arm/plat-sunxi/Kconfig
new file mode 100644
index 0000000..67aac27
--- /dev/null
+++ b/arch/arm/plat-sunxi/Kconfig
@@ -0,0 +1,30 @@
+menu "Allwinner's sunxi options"
+
+config SW_DEBUG_UART
+	int "UART to use for low-level debug"
+	depends on DEBUG_LL
+	default 0
+	help
+	  Choose the UART on which kernel low-level debug messages should be
+	  output.
+
+config SUNXI_MULTIPLATFORM
+	bool "enable sunxi_is_foo() even for other mach-sunNi"
+	default y
+
+config SUNXI_MALI_RESERVED_MEM
+	bool
+	depends on MALI
+	default y
+
+config SUNXI_SCALING_MIN
+	int "Minimum clockspeed for the cpu governor"
+	default "60"
+	help
+	  The (default) minimum clockspeed the cpu scaling governor may use,
+	  the lowest the sunxi cpu core can go is 60 MHz, which is quite slow,
+	  so you may wish to set a somewhat higher minimum speed. 408 Mhz is
+	  the last speed at the lowest voltage setting and as such is a good
+	  value to use.
+
+endmenu
diff --git a/arch/arm/plat-sunxi/Makefile b/arch/arm/plat-sunxi/Makefile
new file mode 100644
index 0000000..9e0b71c
--- /dev/null
+++ b/arch/arm/plat-sunxi/Makefile
@@ -0,0 +1,13 @@
+obj-y += sys_config.o
+obj-y += core.o soc-detect.o
+obj-y += script.o
+obj-y += clocksrc.o
+obj-y += devices.o
+
+ifeq ($(CONFIG_ARCH_SUN7I),)
+
+obj-y += dma.o
+obj-$(CONFIG_CPU_FREQ) += cpu-freq/
+obj-$(CONFIG_PM) += pm/
+
+endif
diff --git a/arch/arm/plat-sunxi/clocksrc.c b/arch/arm/plat-sunxi/clocksrc.c
new file mode 100644
index 0000000..e0066ef
--- /dev/null
+++ b/arch/arm/plat-sunxi/clocksrc.c
@@ -0,0 +1,439 @@
+/*
+ * arch/arm/plat-sunxi/clocksrc.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <mach/clock.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <plat/system.h>
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include "clocksrc.h"
+
+#undef CLKSRC_DBG
+#undef CLKSRC_ERR
+#if (0)
+    #define CLKSRC_DBG(format,args...)  printk("[CLKSRC] "format,##args)
+    #define CLKSRC_ERR(format,args...)  printk("[CLKSRC] "format,##args)
+#else
+    #define CLKSRC_DBG(...)
+    #define CLKSRC_ERR(...)
+#endif
+
+static DEFINE_SPINLOCK(clksrc_lock);
+static spinlock_t tmr_spin_lock[2];
+static const int tmr_div[2] = { SYS_TIMER_SCAL, 1 };
+
+static irqreturn_t aw_clkevt_irq(int irq, void *handle);
+static void aw_set_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev);
+static int aw_set_next_clkevt(unsigned long delta, struct clock_event_device *dev);
+
+static struct clocksource aw_clocksrc =
+{
+    .name = "aw_64bits_counter",
+    .list = {NULL, NULL},
+    .rating = 300,                  /* perfect clock source             */
+    .read = aw_clksrc_read,         /* read clock counter               */
+    .enable = 0,                    /* not define                       */
+    .disable = 0,                   /* not define                       */
+    .mask = CLOCKSOURCE_MASK(64),   /* 64bits mask                      */
+    .mult = 0,                      /* it will be calculated by shift   */
+    .shift = 10,                    /* 32bit shift for                  */
+    .max_idle_ns = 1000000000000ULL,
+    .flags = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static struct clock_event_device timer0_clockevent = {
+	.name = "timer0",
+	.shift = 32,
+	.rating = 100,
+	.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode = aw_set_clkevt_mode,
+	.set_next_event = aw_set_next_clkevt,
+	.irq = SW_INT_IRQNO_TIMER0,
+};
+
+static struct irqaction sw_timer_irq = {
+	.name = "timer0",
+	.flags = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler = aw_clkevt_irq,
+	.dev_id = &timer0_clockevent,
+	.irq = SW_INT_IRQNO_TIMER0,
+};
+
+#ifdef CONFIG_HIGH_RES_TIMERS
+static struct clock_event_device aw_clock_event =
+{
+    .name = "aw_clock_event",
+    .features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+    .max_delta_ns = 100000000000ULL,
+    .min_delta_ns = (1000000000 + AW_HPET_CLOCK_EVENT_HZ - 1) / AW_HPET_CLOCK_EVENT_HZ,
+    .mult = 100,                    /* will be calculate when init      */
+    .shift = 32,
+    .rating = 300,                  /* clock event is perfect           */
+    .irq = SW_INT_IRQNO_TIMER1,
+    .cpumask = 0,                   /* will be set when init            */
+    .set_next_event = aw_set_next_clkevt,
+    .set_mode = aw_set_clkevt_mode, /* set clock event mode             */
+    .event_handler = 0,             /* be alloced by system framework   */
+};
+
+static struct irqaction aw_clkevt_irqact =
+{
+    .handler = aw_clkevt_irq,
+    .flags = IRQF_TIMER | IRQF_DISABLED,
+    .name = "aw_clock_event",
+    .dev_id = &aw_clock_event,
+    .irq = SW_INT_IRQNO_TIMER1,
+};
+#endif
+
+
+/*
+*********************************************************************************************************
+*                           aw_clksrc_read
+*
+*Description: read cycle count of the clock source;
+*
+*Arguments  : cs    clock source handle.
+*
+*Return     : cycle count;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+cycle_t aw_clksrc_read(struct clocksource *cs)
+{
+    unsigned long   flags;
+    __u32           lower, upper;
+
+	spin_lock_irqsave(&clksrc_lock, flags);
+
+    /* latch 64bit counter and wait ready for read */
+    TMR_REG_CNT64_CTL |= (1<<1);
+    while(TMR_REG_CNT64_CTL & (1<<1));
+
+    /* read the 64bits counter */
+    lower = TMR_REG_CNT64_LO;
+    upper = TMR_REG_CNT64_HI;
+
+	spin_unlock_irqrestore(&clksrc_lock, flags);
+
+    return (((__u64)upper)<<32) | lower;
+}
+EXPORT_SYMBOL(aw_clksrc_read);
+
+u32 aw_sched_clock_read(void)
+{
+	u32 lower;
+	unsigned long flags;
+
+	spin_lock_irqsave(&clksrc_lock, flags);
+
+	/* latch 64bit counter and wait ready for read */
+	TMR_REG_CNT64_CTL |= (1 << 1);
+	while (TMR_REG_CNT64_CTL & (1 << 1)) {}
+
+	/* read the low 32bits counter */
+	lower = TMR_REG_CNT64_LO;
+	spin_unlock_irqrestore(&clksrc_lock, flags);
+
+	return lower;
+}
+
+/*
+*********************************************************************************************************
+*                           aw_set_clkevt_mode
+*
+*Description: set clock event work mode.
+*
+*Arguments  : mode  mode for clock event work;
+*             dev   clock event device;
+*
+*Return     : none
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void aw_set_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
+{
+	int nr = dev->irq - SW_INT_IRQNO_TIMER0;
+	unsigned long flags;
+
+	CLKSRC_DBG("aw_set_clkevt_mode(%d): %u\n", nr, mode);
+
+	spin_lock_irqsave(&tmr_spin_lock[nr], flags);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		/* set timer work with continueous mode */
+		TMR_REG_TMR_CTL(nr) &= ~(1<<0);
+		/* wait hardware synchronization, 2 clock cycles at least */
+		__delay(50 * tmr_div[nr]);
+		TMR_REG_TMR_CTL(nr) &= ~(1<<7);
+		TMR_REG_TMR_CTL(nr) |= (1<<0);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* set timer work with onshot mode */
+		TMR_REG_TMR_CTL(nr) &= ~(1<<0);
+		/* wait hardware synchronization, 2 clock cycles at least */
+		__delay(50 * tmr_div[nr]);
+		TMR_REG_TMR_CTL(nr) |= (1<<7);
+		TMR_REG_TMR_CTL(nr) |= (1<<0);
+		break;
+	default:
+		/* disable clock event device */
+		TMR_REG_TMR_CTL(nr) &= ~(1<<0);
+		/* wait hardware synchronization, 2 clock cycles at least */
+		__delay(50 * tmr_div[nr]);
+	}
+	spin_unlock_irqrestore(&tmr_spin_lock[nr], flags);
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_set_next_clkevt
+*
+*Description: set next clock event.
+*
+*Arguments  : delta     cycle count for next clock event.
+*             dev       clock event device.
+*
+*Return     : result,
+*               0,  set next event successed;
+*              !0,  set next event failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int aw_set_next_clkevt(unsigned long delta, struct clock_event_device *dev)
+{
+	int nr = dev->irq - SW_INT_IRQNO_TIMER0;
+	unsigned long flags;
+
+	CLKSRC_DBG("aw_set_next_clkevt(%d): %u\n", nr, (unsigned int)delta);
+
+	spin_lock_irqsave(&tmr_spin_lock[nr], flags);
+	/* disable timer and clear pending first */
+	TMR_REG_TMR_CTL(nr) &= ~(1<<0);
+	/* wait hardware synchronization, 2 cycles of the hardware work clock at least  */
+	udelay(1);
+
+	/* set timer intervalue */
+	TMR_REG_TMR_INTV(nr) = delta;
+	/* reload the timer intervalue  */
+	TMR_REG_TMR_CTL(nr) |= (1<<1);
+
+	/* enable timer */
+	TMR_REG_TMR_CTL(nr) |= (1<<0);
+	spin_unlock_irqrestore(&tmr_spin_lock[nr], flags);
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                   aw_clkevt_irq
+*
+*Description: clock event interrupt handler.
+*
+*Arguments  : irq       interrupt number of current processed;
+*             handle    device handle registered when setup irq;
+*
+*Return     : result,
+*               IRQ_HANDLED,    irq is processed successed;
+*               IRQ_NONE,       irq is not setup by us;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static irqreturn_t aw_clkevt_irq(int irq, void *handle)
+{
+	int nr = irq - SW_INT_IRQNO_TIMER0;
+	struct clock_event_device *clk_dev = handle;
+
+	if (TMR_REG_IRQ_STAT & (1 << nr)) {
+		CLKSRC_DBG("aw_clkevt_irq!\n");
+
+		/* clear pending */
+		TMR_REG_IRQ_STAT = (1 << nr);
+
+		/* clock event interrupt handled */
+		if (likely(clk_dev->event_handler != NULL))
+			clk_dev->event_handler(clk_dev);
+
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_clksrc_init
+*
+*Description: clock source initialise.
+*
+*Arguments  : none
+*
+*Return     : result,
+*               0,  initiate successed;
+*              !0,  initiate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int __init aw_clksrc_init(void)
+{
+	CLKSRC_DBG("all-winners clock source init!\n");
+
+	/*
+	 * The sun7i has separate 64 bits counters per osc, see clocksrc.h, so
+	 * there is no need to set the clock source for the counter on sun7i.
+	 * Moreover these counters share some logic with the arch_timer.c
+	 * counters and mucking with them makes arch_timer.c unhappy.
+	 */
+	if (!sunxi_is_sun7i()) {
+		TMR_REG_CNT64_CTL = 0;
+		__delay(50);
+
+		/* config clock source for 64bits counter */
+#if(AW_HPET_CLK_SRC == TMR_CLK_SRC_24MHOSC)
+		TMR_REG_CNT64_CTL |= (0 << 2);
+#else	
+		TMR_REG_CNT64_CTL |= (1 << 2);
+#endif
+		__delay(50);
+
+		/* clear 64bits counter */
+		TMR_REG_CNT64_CTL |= (1 << 0);
+		while (TMR_REG_CNT64_CTL & (1 << 0)) {}
+	}
+
+	CLKSRC_DBG("register all-winners clock source!\n");
+	/* calculate the mult by shift  */
+	aw_clocksrc.mult = clocksource_hz2mult(AW_HPET_CLOCK_SOURCE_HZ,
+					       aw_clocksrc.shift);
+	/* register clock source */
+	clocksource_register(&aw_clocksrc);
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           aw_clkevt_init
+*
+*Description: clock event initialise.
+*
+*Arguments  : none
+*
+*Return     : result,
+*               0,  initiate successed;
+*              !0,  initiate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void register_clk_dev(struct clock_event_device *clk_dev, int freq)
+{
+	clk_dev->mult = div_sc(freq, NSEC_PER_SEC, clk_dev->shift);
+	/* time value timer must larger than 50 cycles at least,
+	   suggested by david 2011-5-25 11:41 */
+	clk_dev->min_delta_ns = clockevent_delta2ns(0x1, clk_dev) + 100000;
+	clk_dev->max_delta_ns = clockevent_delta2ns(0x80000000, clk_dev);
+	clk_dev->cpumask = cpu_all_mask;
+	clockevents_register_device(clk_dev);
+}
+
+int __init aw_clkevt_init(void)
+{
+	u32 val = 0;
+
+	/* disable & clear all timers */
+	TMR_REG_IRQ_EN = 0x00;
+	TMR_REG_IRQ_STAT = 0x1ff;
+
+	/* init timer0 */
+	CLKSRC_DBG("set up timer0\n");
+	spin_lock_init(&tmr_spin_lock[0]);
+	/* clear timer0 setting */
+	TMR_REG_TMR_CTL(0) = 0;
+	/* initialise timer0 interval value */
+	TMR_REG_TMR_INTV(0) = TMR_INTER_VAL;
+	/* set clock source to HOSC, 16 pre-division, auto-reload */
+	val = 0 << 7; /* continuous mode */
+	val |= 0b100 << 4; /* pre-scale: 16 */
+	val |= 0b01 << 2; /* src: osc24M */
+	val |= 1 << 1; /* auto-reload interval value */
+	TMR_REG_TMR_CTL(0) = val;
+
+	/* install timer0 irq */
+	setup_irq(SW_INT_IRQNO_TIMER0, &sw_timer_irq);
+	/* enable timer0 irq */
+	TMR_REG_IRQ_EN |= (1 << 0);
+
+	/* register timer0 */
+	CLKSRC_DBG("register timer0\n");
+	register_clk_dev(&timer0_clockevent, SYS_TIMER_CLKSRC/SYS_TIMER_SCAL);
+
+#ifdef CONFIG_HIGH_RES_TIMERS
+	CLKSRC_DBG("set up timer1 / aw clock event device (high res timer)\n");
+	spin_lock_init(&tmr_spin_lock[1]);
+	/* clear timer1 setting */
+	TMR_REG_TMR_CTL(1) = 0;
+	/* initialise timer1 interval value to 1 tick */
+	TMR_REG_TMR_INTV(1) = AW_HPET_CLOCK_EVENT_HZ/HZ;
+
+	/* config clock source for timer1 */
+#if(AW_HPET_CLK_EVT == TMR_CLK_SRC_24MHOSC)
+	TMR_REG_TMR_CTL(1) |= (1<<2);
+#else
+	TMR_REG_TMR_CTL(1) |= (0<<2);
+#endif
+	/* reload inter value */
+	TMR_REG_TMR_CTL(1) |= (1<<1);
+	/* install timer irq */
+	setup_irq(SW_INT_IRQNO_TIMER1, &aw_clkevt_irqact);
+	/* enable timer1 irq */
+	TMR_REG_IRQ_EN |= (1<<1);
+
+	/* register clock event device  */
+	CLKSRC_DBG("register all-winners clock event device!\n");
+	register_clk_dev(&aw_clock_event, AW_HPET_CLOCK_EVENT_HZ);
+#endif
+
+	return 0;
+}
diff --git a/arch/arm/plat-sunxi/clocksrc.h b/arch/arm/plat-sunxi/clocksrc.h
new file mode 100644
index 0000000..66f7f24
--- /dev/null
+++ b/arch/arm/plat-sunxi/clocksrc.h
@@ -0,0 +1,94 @@
+/*
+ * arch/arm/plat-sunxi/clocksrc.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __AW_CLOCKSRC_H__
+#define __AW_CLOCKSRC_H__
+
+#define __cnt_reg(off) (*(volatile __u32 *)((SW_VA_CPUCFG_IO_BASE) + (off)))
+#define __tmr_reg(off) (*(volatile __u32 *)((SW_VA_TIMERC_IO_BASE) + (off)))
+#define __tmr_x_reg(x, off) __tmr_reg(0x10 + (x) * 0x10 + (off))
+
+/* define timer io register value */
+#define TMR_REG_IRQ_EN		__tmr_reg(0x00)
+#define TMR_REG_IRQ_STAT	__tmr_reg(0x04)
+#define TMR_REG_TMR_CTL(x)	__tmr_x_reg((x), 0x00)
+#define TMR_REG_TMR_INTV(x)	__tmr_x_reg((x), 0x04)
+#define TMR_REG_TMR_CUR(x)	__tmr_x_reg((x), 0x08)
+
+#ifndef CONFIG_ARCH_SUN7I
+#define TMR_REG_CNT64_CTL       __tmr_reg(0xa0)
+#define TMR_REG_CNT64_LO        __tmr_reg(0xa4)
+#define TMR_REG_CNT64_HI        __tmr_reg(0xa8)
+#endif
+
+/* define timer clock source */
+#define TMR_CLK_SRC_32KLOSC     (0)
+#define TMR_CLK_SRC_24MHOSC     (1)
+#define TMR_CLK_SRC_PLL         (2)
+
+
+/* config clock frequency   */
+#define AW_HPET_CLK_SRC     TMR_CLK_SRC_24MHOSC
+#define AW_HPET_CLK_EVT     TMR_CLK_SRC_24MHOSC
+
+
+/* aw HPET clock source frequency */
+#if(AW_HPET_CLK_SRC == TMR_CLK_SRC_24MHOSC)
+    #define AW_HPET_CLOCK_SOURCE_HZ         (24000000)
+#else
+    #error "AW_HPET_CLK_SRC config is invalid!!"
+#endif
+
+
+/* aw HPET clock eventy frequency */
+#if(AW_HPET_CLK_EVT == TMR_CLK_SRC_32KLOSC)
+
+#define AW_HPET_CLOCK_EVENT_HZ          (32768)
+
+#ifdef CONFIG_ARCH_SUN7I
+/* Make the TMR_REG_CNT64 macros point to the 32KLOSC 64bit counter */
+#define TMR_REG_CNT64_CTL       __cnt_reg(0x0290)
+#define TMR_REG_CNT64_LO        __cnt_reg(0x0294)
+#define TMR_REG_CNT64_HI        __cnt_reg(0x0298)
+#endif
+
+#elif(AW_HPET_CLK_EVT == TMR_CLK_SRC_24MHOSC)
+
+#define AW_HPET_CLOCK_EVENT_HZ          (24000000)
+
+#ifdef CONFIG_ARCH_SUN7I
+/* Make the TMR_REG_CNT64 macros point to 24MHOSC 64bit counter */
+#define TMR_REG_CNT64_CTL       __cnt_reg(0x0280)
+#define TMR_REG_CNT64_LO        __cnt_reg(0x0284)
+#define TMR_REG_CNT64_HI        __cnt_reg(0x0288)
+#endif
+
+#else
+#error "AW_HPET_CLK_EVT config is invalid!!"
+#endif
+
+u32 aw_sched_clock_read(void);
+int aw_clksrc_init(void);
+int aw_clkevt_init(void);
+
+#endif  /* #ifndef __AW_CLOCKSRC_H__ */
diff --git a/arch/arm/plat-sunxi/core.c b/arch/arm/plat-sunxi/core.c
new file mode 100644
index 0000000..f448b3d
--- /dev/null
+++ b/arch/arm/plat-sunxi/core.c
@@ -0,0 +1,496 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/amba/pl061.h>
+#include <linux/amba/mmci.h>
+#include <linux/amba/pl022.h>
+#include <linux/io.h>
+#include <linux/gfp.h>
+#include <linux/clockchips.h>
+#include <linux/memblock.h>
+#include <linux/bootmem.h>
+#include <linux/export.h>
+#include <linux/clkdev.h>
+
+#include <asm/arch_timer.h>
+#include <asm/sched_clock.h>
+#include <asm/setup.h>
+#include <asm/sizes.h>
+#include <asm/mach-types.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/delay.h>
+#include <asm/mach/map.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <asm/hardware/arm_timer.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/icst.h>
+#include <asm/hardware/vic.h>
+
+#include <plat/core.h>
+#include <plat/hardware.h>
+#include <plat/memory.h>
+#include <plat/platform.h>
+#include <plat/system.h>
+#include <plat/sys_config.h>
+
+#include "clocksrc.h"
+
+int arch_timer_common_register(void);
+void sw_pdev_init(void);
+
+/*
+ * Only reserve certain important memory blocks if there are actually
+ * drivers which use them.
+ */
+static int reserved_mali_mem;
+static unsigned long reserved_start;
+static unsigned long reserved_max;
+
+#ifdef CONFIG_SUNXI_MALI_RESERVED_MEM
+void __init sunxi_mali_core_fixup(struct tag *tags, char **cmdline,
+				  struct meminfo *mi)
+{
+	struct tag *t;
+	u32 bank = 0;
+
+	for (t = tags; t->hdr.size; t = tag_next(t)) {
+		if (t->hdr.tag != ATAG_CMDLINE)
+			continue;
+		if (strstr(t->u.cmdline.cmdline, "sunxi_no_mali_mem_reserve"))
+			return;
+	}
+
+	for (t = tags; t->hdr.size; t = tag_next(t)) {
+		if (t->hdr.tag != ATAG_MEM)
+			continue;
+		if (bank) {
+			mi->nr_banks++;
+			mi->bank[bank].start = t->u.mem.start;
+			mi->bank[bank].size = t->u.mem.size;
+		} else { /* first bank */
+			u32 size = t->u.mem.size / SZ_1M;
+			mi->nr_banks = 1;
+			mi->bank[0].start = t->u.mem.start;
+			if (size < 512) {
+				mi->bank[0].size = SZ_1M * size;
+
+				pr_err("MALI: not enough memory in first bank to make reserve.\n");
+			} else {
+				mi->bank[0].size = SZ_1M * (512 - 64);
+				reserved_mali_mem = 1;
+				size -= 512;
+				if (size) {
+					bank++;
+					mi->nr_banks++;
+					mi->bank[1].start = t->u.mem.start + (512 * SZ_1M);
+					mi->bank[1].size = SZ_1M * size;
+				}
+
+				pr_info("Memory cut off:\n");
+				pr_reserve_info("MALI", t->u.mem.start + SZ_512M - SZ_64M,
+						SZ_64M);
+			}
+		}
+		bank++;
+	}
+}
+#endif
+
+/**
+ * Machine Implementations
+ *
+ */
+
+/* sun4i / sun5i io-map */
+static struct map_desc sw_io_desc[] __initdata = {
+	{ SW_VA_SRAM_BASE, __phys_to_pfn(SW_PA_SRAM_BASE),  (SZ_128K + SZ_64K), MT_MEMORY_ITCM  },
+	{ SW_VA_IO_BASE,   __phys_to_pfn(SW_PA_IO_BASE),    (SZ_1M + SZ_2M),    MT_DEVICE       },
+	{ SW_VA_BROM_BASE, __phys_to_pfn(SW_PA_BROM_BASE),  (SZ_64K),           MT_MEMORY_ITCM  },
+};
+static void __init sw_core_map_io(void)
+{
+	iotable_init(sw_io_desc, ARRAY_SIZE(sw_io_desc));
+
+	sunxi_pr_chip_id();
+}
+
+/* sun7i io-map */
+static struct map_desc sun7i_io_desc[] __initdata = {
+	{IO_ADDRESS(SW_PA_IO_BASE), __phys_to_pfn(SW_PA_IO_BASE),  SW_IO_SIZE, MT_DEVICE_NONSHARED},
+	{IO_ADDRESS(SW_PA_SRAM_A1_BASE), __phys_to_pfn(SW_PA_SRAM_A1_BASE),  SW_SRAM_A1_SIZE, MT_MEMORY_ITCM},
+	{IO_ADDRESS(SW_PA_SRAM_A2_BASE), __phys_to_pfn(SW_PA_SRAM_A2_BASE),  SW_SRAM_A2_SIZE, MT_MEMORY_ITCM},
+	{IO_ADDRESS(SW_PA_SRAM_A3_BASE), __phys_to_pfn(SW_PA_SRAM_A3_BASE),  SW_SRAM_A3_SIZE + SW_SRAM_A4_SIZE, MT_MEMORY_ITCM},
+	//{IO_ADDRESS(SW_PA_SRAM_A4_BASE), __phys_to_pfn(SW_PA_SRAM_A4_BASE),  SW_SRAM_A4_SIZE, MT_MEMORY_ITCM}, /* not page align, cause sun7i_map_io err,2013-1-10 */
+	{IO_ADDRESS(SW_PA_BROM_START), __phys_to_pfn(SW_PA_BROM_START), SW_BROM_SIZE, MT_DEVICE_NONSHARED},
+};
+static void __init sun7i_map_io(void)
+{
+	iotable_init(sun7i_io_desc, ARRAY_SIZE(sun7i_io_desc));
+	sunxi_pr_chip_id();
+}
+
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+/* The FB block is used by:
+ *
+ * - the sun4i framebuffer driver, drivers/video/sun4i/disp.
+ *
+ * fb_start, fb_size are used in a vast number of other places but for
+ * for platform-specific drivers, so we don't have to worry about them.
+ */
+
+unsigned long fb_start;
+unsigned long fb_size = SZ_32M;
+EXPORT_SYMBOL(fb_start);
+EXPORT_SYMBOL(fb_size);
+
+static int __init reserve_fb_param(char *s)
+{
+	unsigned long size;
+	if (kstrtoul(s, 0, &size) == 0)
+		fb_size = size * SZ_1M;
+	return 0;
+}
+early_param("sunxi_fb_mem_reserve", reserve_fb_param);
+#endif
+
+#if defined CONFIG_SUN4I_G2D || defined CONFIG_SUN4I_G2D_MODULE
+/* The G2D block is used by:
+ *
+ * - the G2D engine, drivers/char/sun4i_g2d
+ */
+
+unsigned long g2d_start;
+unsigned long g2d_size = SZ_1M * 16;
+EXPORT_SYMBOL(g2d_start);
+EXPORT_SYMBOL(g2d_size);
+
+static int __init reserve_g2d_param(char *s)
+{
+	unsigned long size;
+	if (kstrtoul(s, 0, &size) == 0)
+		g2d_size = size * SZ_1M;
+	return 0;
+}
+early_param("sunxi_g2d_mem_reserve", reserve_g2d_param);
+#endif
+
+#if defined CONFIG_VIDEO_DECODER_SUN4I || \
+	defined CONFIG_VIDEO_DECODER_SUN4I_MODULE || \
+	defined CONFIG_VIDEO_DECODER_SUN5I || \
+	defined CONFIG_VIDEO_DECODER_SUN5I_MODULE
+/* The VE block is used by:
+ *
+ * - the Cedar video engine, drivers/media/video/sun4i
+ */
+
+#define RESERVE_VE_MEM 1
+
+unsigned long ve_start;
+unsigned long ve_size = (SZ_64M + SZ_16M);
+EXPORT_SYMBOL(ve_start);
+EXPORT_SYMBOL(ve_size);
+
+static int __init reserve_ve_param(char *s)
+{
+	unsigned long size;
+	if (kstrtoul(s, 0, &size) == 0)
+		ve_size = size * SZ_1M;
+	return 0;
+}
+early_param("sunxi_ve_mem_reserve", reserve_ve_param);
+#endif
+
+static void reserve_sys(void)
+{
+	memblock_reserve(SYS_CONFIG_MEMBASE, SYS_CONFIG_MEMSIZE);
+	pr_reserve_info("SYS ", SYS_CONFIG_MEMBASE, SYS_CONFIG_MEMSIZE);
+}
+
+#if defined RESERVE_VE_MEM || defined CONFIG_SUN4I_G2D || \
+	defined CONFIG_SUN4I_G2D_MODULE || defined CONFIG_FB_SUNXI_RESERVED_MEM
+static void reserve_mem(unsigned long *start, unsigned long *size,
+			const char *desc)
+{
+	if (*size == 0) {
+		*start = 0;
+		return;
+	}
+
+	if ((reserved_start + *size) > reserved_max) {
+		pr_warn("Not enough memory to reserve memory for %s\n", desc);
+		*start = 0;
+		*size = 0;
+		return;
+	}
+	*start = reserved_start;
+	memblock_reserve(*start, *size);
+	pr_reserve_info(desc, *start, *size);
+	reserved_start += *size;
+}
+#endif
+
+static void __init sw_core_reserve(void)
+{
+	pr_info("Memory Reserved:\n");
+	reserve_sys();
+	/* 0 - 64M is used by reserve_sys */
+	reserved_start = meminfo.bank[0].start + SZ_64M;
+	reserved_max   = meminfo.bank[0].start + meminfo.bank[0].size;
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+	if (reserved_mali_mem) {
+		/* The stupid mali blob expects the fb at a fixed address :( */
+		fb_start = meminfo.bank[0].start + SZ_512M - SZ_64M - SZ_32M;
+		if (fb_start < reserved_max)
+			reserved_max = fb_start;
+	}
+#endif
+#ifdef RESERVE_VE_MEM
+	reserve_mem(&ve_start, &ve_size, "VE  ");
+#endif
+#if defined CONFIG_SUN4I_G2D || defined CONFIG_SUN4I_G2D_MODULE
+	reserve_mem(&g2d_start, &g2d_size, "G2D ");
+#endif
+#ifdef CONFIG_FB_SUNXI_RESERVED_MEM
+	if (reserved_mali_mem) {
+		/* Give the mali blob the fb at its expected address */
+		reserved_start = fb_start;
+		reserved_max   = meminfo.bank[0].start + meminfo.bank[0].size;
+	}
+	reserve_mem(&fb_start, &fb_size, "LCD ");
+#endif
+	/* Ensure this is set before any arch_init funcs call script_foo */
+	sunxi_script_init((void *)__va(SYS_CONFIG_MEMBASE));
+}
+
+void sw_irq_ack(struct irq_data *irqd)
+{
+	unsigned int irq = irqd->irq;
+
+	if (irq < 32){
+		writel(readl(SW_INT_ENABLE_REG0) & ~(1<<irq), SW_INT_ENABLE_REG0);
+		writel(readl(SW_INT_MASK_REG0) | (1 << irq), SW_INT_MASK_REG0);
+		writel(readl(SW_INT_IRQ_PENDING_REG0) | (1<<irq), SW_INT_IRQ_PENDING_REG0);
+	} else if(irq < 64){
+		irq -= 32;
+		writel(readl(SW_INT_ENABLE_REG1) & ~(1<<irq), SW_INT_ENABLE_REG1);
+		writel(readl(SW_INT_MASK_REG1) | (1 << irq), SW_INT_MASK_REG1);
+		writel(readl(SW_INT_IRQ_PENDING_REG1) | (1<<irq), SW_INT_IRQ_PENDING_REG1);
+	} else if(irq < 96){
+		irq -= 64;
+		writel(readl(SW_INT_ENABLE_REG2) & ~(1<<irq), SW_INT_ENABLE_REG2);
+		writel(readl(SW_INT_MASK_REG2) | (1 << irq), SW_INT_MASK_REG2);
+		writel(readl(SW_INT_IRQ_PENDING_REG2) | (1<<irq), SW_INT_IRQ_PENDING_REG2);
+	}
+}
+
+/* Mask an IRQ line, which means disabling the IRQ line */
+static void sw_irq_mask(struct irq_data *irqd)
+{
+	unsigned int irq = irqd->irq;
+
+	if(irq < 32){
+		writel(readl(SW_INT_ENABLE_REG0) & ~(1<<irq), SW_INT_ENABLE_REG0);
+		writel(readl(SW_INT_MASK_REG0) | (1 << irq), SW_INT_MASK_REG0);
+	} else if(irq < 64){
+		irq -= 32;
+		writel(readl(SW_INT_ENABLE_REG1) & ~(1<<irq), SW_INT_ENABLE_REG1);
+		writel(readl(SW_INT_MASK_REG1) | (1 << irq), SW_INT_MASK_REG1);
+	} else if(irq < 96){
+		irq -= 64;
+		writel(readl(SW_INT_ENABLE_REG2) & ~(1<<irq), SW_INT_ENABLE_REG2);
+		writel(readl(SW_INT_MASK_REG2) | (1 << irq), SW_INT_MASK_REG2);
+	}
+}
+
+static void sw_irq_unmask(struct irq_data *irqd)
+{
+	unsigned int irq = irqd->irq;
+
+	if(irq < 32){
+		writel(readl(SW_INT_ENABLE_REG0) | (1<<irq), SW_INT_ENABLE_REG0);
+		writel(readl(SW_INT_MASK_REG0) & ~(1 << irq), SW_INT_MASK_REG0);
+		if(irq == SW_INT_IRQNO_ENMI) /* must clear pending bit when enabled */
+			writel((1 << SW_INT_IRQNO_ENMI), SW_INT_IRQ_PENDING_REG0);
+	} else if(irq < 64){
+		irq -= 32;
+		writel(readl(SW_INT_ENABLE_REG1) | (1<<irq), SW_INT_ENABLE_REG1);
+		writel(readl(SW_INT_MASK_REG1) & ~(1 << irq), SW_INT_MASK_REG1);
+	} else if(irq < 96){
+		irq -= 64;
+		writel(readl(SW_INT_ENABLE_REG2) | (1<<irq), SW_INT_ENABLE_REG2);
+		writel(readl(SW_INT_MASK_REG2) & ~(1 << irq), SW_INT_MASK_REG2);
+	}
+}
+
+static struct irq_chip sw_vic_chip = {
+	.name       = "sw_vic",
+	.irq_ack    = sw_irq_ack,
+	.irq_mask   = sw_irq_mask,
+	.irq_unmask = sw_irq_unmask,
+};
+
+void __init sw_core_init_irq(void)
+{
+	u32 i = 0;
+
+	/* Disable & clear all interrupts */
+	writel(0, SW_INT_ENABLE_REG0);
+	writel(0, SW_INT_ENABLE_REG1);
+	writel(0, SW_INT_ENABLE_REG2);
+
+	writel(0xffffffff, SW_INT_MASK_REG0);
+	writel(0xffffffff, SW_INT_MASK_REG1);
+	writel(0xffffffff, SW_INT_MASK_REG2);
+
+	writel(0xffffffff, SW_INT_IRQ_PENDING_REG0);
+	writel(0xffffffff, SW_INT_IRQ_PENDING_REG1);
+	writel(0xffffffff, SW_INT_IRQ_PENDING_REG2);
+	writel(0xffffffff, SW_INT_FIQ_PENDING_REG0);
+	writel(0xffffffff, SW_INT_FIQ_PENDING_REG1);
+	writel(0xffffffff, SW_INT_FIQ_PENDING_REG2);
+
+	/*enable protection mode*/
+	writel(0x01, SW_INT_PROTECTION_REG);
+	/*config the external interrupt source type*/
+	writel(0x00, SW_INT_NMI_CTRL_REG);
+
+	for (i = SW_INT_START; i < SW_INT_END; i++) {
+		irq_set_chip(i, &sw_vic_chip);
+		irq_set_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+}
+
+static void __init gic_init_irq(void)
+{
+/*
+ * HdG: note to anyone trying to make it possible to build a single sunxi image
+ * for all of sun4i/sun5i/sun7i, selecting CONFIG_ARM_GIC automatically selects
+ * CONFIG_MULTI_IRQ_HANDLER, at which point we need to provide a handle_irq
+ * function for the sun4i and sun5i machine definitions, vic_handle_irq is
+ * probably a good start for this / maybe we can even use all of the common
+ * vic handling code?
+ */
+#ifdef CONFIG_ARM_GIC
+	gic_init(0, 29, (void *)IO_ADDRESS(AW_GIC_DIST_BASE),
+		 (void *)IO_ADDRESS(AW_GIC_CPU_BASE));
+#endif
+}
+
+
+/*
+ * Global vars definitions
+ *
+ */
+static void sun4i_restart(char mode, const char *cmd)
+{
+	/* use watch-dog to reset system */
+	#define WATCH_DOG_CTRL_REG  (SW_VA_TIMERC_IO_BASE + 0x0090)
+	#define WATCH_DOG_MODE_REG  (SW_VA_TIMERC_IO_BASE + 0x0094)
+	writel(3, WATCH_DOG_MODE_REG);
+	writel(((0xA57 << 1) | (1 << 0)), WATCH_DOG_CTRL_REG);
+	while(1);
+}
+
+static void __init sw_timer_init(void)
+{
+	aw_clkevt_init();
+	aw_clksrc_init();
+#ifdef CONFIG_ARM_ARCH_TIMER
+	if (sunxi_is_sun7i()) {
+		arch_timer_common_register();
+		arch_timer_sched_clock_init();
+	} else
+#endif
+	setup_sched_clock(aw_sched_clock_read, 32, AW_HPET_CLOCK_SOURCE_HZ);
+}
+
+struct sys_timer sw_sys_timer = {
+	.init = sw_timer_init,
+};
+
+void __init sw_core_init(void)
+{
+	sw_pdev_init();
+}
+
+MACHINE_START(SUN4I, "sun4i")
+	.atag_offset	= 0x100,
+	.timer          = &sw_sys_timer,
+#ifdef CONFIG_SUNXI_MALI_RESERVED_MEM
+	.fixup          = sunxi_mali_core_fixup,
+#endif
+	.map_io         = sw_core_map_io,
+	.init_early     = NULL,
+	.init_irq       = sw_core_init_irq,
+	.init_machine   = sw_core_init,
+	.reserve        = sw_core_reserve,
+	.restart	= sun4i_restart,
+MACHINE_END
+
+MACHINE_START(SUN5I, "sun5i")
+	.atag_offset	= 0x100,
+	.timer          = &sw_sys_timer,
+#ifdef CONFIG_SUNXI_MALI_RESERVED_MEM
+	.fixup          = sunxi_mali_core_fixup,
+#endif
+	.map_io         = sw_core_map_io,
+	.init_early     = NULL,
+	.init_irq       = sw_core_init_irq,
+	.init_machine   = sw_core_init,
+	.reserve        = sw_core_reserve,
+	.restart	= sun4i_restart,
+MACHINE_END
+
+MACHINE_START(SUN7I, "sun7i")
+	.atag_offset	= 0x100,
+	.timer          = &sw_sys_timer,
+#ifdef CONFIG_SUNXI_MALI_RESERVED_MEM
+	.fixup          = sunxi_mali_core_fixup,
+#endif
+	.map_io         = sun7i_map_io,
+	.init_early     = NULL,
+	.init_irq	= gic_init_irq,
+	.init_machine   = sw_core_init,
+	.reserve        = sw_core_reserve,
+	.restart	= sun4i_restart,
+#ifdef CONFIG_MULTI_IRQ_HANDLER
+	.handle_irq	= gic_handle_irq,
+#endif
+#ifdef CONFIG_ZONE_DMA
+	.dma_zone_size	= SZ_256M,
+#endif
+MACHINE_END
diff --git a/arch/arm/plat-sunxi/cpu-freq/Makefile b/arch/arm/plat-sunxi/cpu-freq/Makefile
new file mode 100644
index 0000000..dc5d307
--- /dev/null
+++ b/arch/arm/plat-sunxi/cpu-freq/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_CPU_FREQ) += cpu-freq.o cpu-freq-table.o
+
diff --git a/arch/arm/plat-sunxi/cpu-freq/cpu-freq-table.c b/arch/arm/plat-sunxi/cpu-freq/cpu-freq-table.c
new file mode 100644
index 0000000..f34abe7
--- /dev/null
+++ b/arch/arm/plat-sunxi/cpu-freq/cpu-freq-table.c
@@ -0,0 +1,134 @@
+/*
+ * arch/arm/mach-sun4i/cpu-freq/cpu-freq-table.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <plat/system.h>
+#include "cpu-freq.h"
+
+static struct cpufreq_frequency_table sun4i_freq_tbl[] = {
+
+    { .frequency = 30000,   .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 48000,   .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 60000,   .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 72000,   .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 84000,   .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 96000,   .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 108000,  .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 120000,  .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 132000,  .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 144000,  .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 156000,  .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 168000,  .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 180000,  .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 192000,  .index = SUN4I_CLK_DIV(1, 1, 1, 2), },
+    { .frequency = 204000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 216000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 240000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 264000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 288000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 300000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 336000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 360000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 384000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 408000,  .index = SUN4I_CLK_DIV(1, 1, 2, 2), },
+    { .frequency = 432000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 480000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 528000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 576000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 600000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 648000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 672000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 696000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 720000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 744000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 768000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 816000,  .index = SUN4I_CLK_DIV(1, 2, 2, 2), },
+    { .frequency = 864000,  .index = SUN4I_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 912000,  .index = SUN4I_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 960000,  .index = SUN4I_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1008000, .index = SUN4I_CLK_DIV(1, 3, 2, 2), },
+    #if(1)
+    { .frequency = 1056000, .index = SUN4I_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1104000, .index = SUN4I_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1152000, .index = SUN4I_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1200000, .index = SUN4I_CLK_DIV(1, 3, 2, 2), },
+    { .frequency = 1248000, .index = SUN4I_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1296000, .index = SUN4I_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1344000, .index = SUN4I_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1392000, .index = SUN4I_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1440000, .index = SUN4I_CLK_DIV(1, 4, 2, 2), },
+    { .frequency = 1488000, .index = SUN4I_CLK_DIV(1, 4, 2, 2), },
+    #endif
+
+    /* table end */
+    { .frequency = CPUFREQ_TABLE_END,  .index = 0,              },
+};
+
+/* div, pll (Hz) table */
+static struct cpufreq_div_order sun4i_div_order_tbl[] = {
+    { .div = SUN4I_CLK_DIV(1, 1, 1, 2), .pll = 204000000,  },
+    { .div = SUN4I_CLK_DIV(1, 1, 2, 2), .pll = 408000000,  },
+    { .div = SUN4I_CLK_DIV(1, 2, 2, 2), .pll = 816000000,  },
+    { .div = SUN4I_CLK_DIV(1, 3, 2, 2), .pll = 1200000000, },
+    { .div = SUN4I_CLK_DIV(1, 4, 2, 2), .pll = 1248000000, },
+};
+
+#ifdef CONFIG_CPU_FREQ_DVFS
+static struct cpufreq_dvfs sun4i_dvfs_table[] = {
+    {.freq = 1056000000, .volt = 1500}, /* core vdd is 1.50v if cpu frequency is (1008Mhz, xxxxMhz] */
+    {.freq = 1008000000, .volt = 1400}, /* core vdd is 1.40v if cpu frequency is (912Mhz,  1008Mhz] */
+    {.freq = 912000000,  .volt = 1350}, /* core vdd is 1.35v if cpu frequency is (864Mhz,   912Mhz] */
+    {.freq = 864000000,  .volt = 1300}, /* core vdd is 1.30v if cpu frequency is (624Mhz,   864Mhz] */
+    {.freq = 624000000,  .volt = 1250}, /* core vdd is 1.25v if cpu frequency is (60Mhz,    624Mhz] */
+    {.freq = 0,          .volt = 1000}, /* end of cpu dvfs table                                    */
+};
+
+static struct cpufreq_dvfs sun5i_dvfs_table[] = {
+    {.freq = 1104000000, .volt = 1500}, /* core vdd is 1.50v if cpu frequency is (1008Mhz, xxxxMhz] */
+    {.freq = 1008000000, .volt = 1400}, /* core vdd is 1.40v if cpu frequency is (912Mhz,  1008Mhz] */
+    {.freq = 912000000,  .volt = 1350}, /* core vdd is 1.35v if cpu frequency is (864Mhz,   912Mhz] */
+    {.freq = 864000000,  .volt = 1300}, /* core vdd is 1.30v if cpu frequency is (624Mhz,   864Mhz] */
+    {.freq = 624000000,  .volt = 1200}, /* core vdd is 1.20v if cpu frequency is (576Mhz,   624Mhz] */
+    {.freq = 576000000,  .volt = 1100}, /* core vdd is 1.10v if cpu frequency is (432Mhz,   576Mhz] */
+    {.freq = 432000000,  .volt = 1000}, /* core vdd is 1.00v if cpu frequency is (60Mhz,    432Mhz] */
+    {.freq = 0,          .volt = 700 }, /* end of cpu dvfs table                                    */
+};
+#endif
+
+struct cpufreq_frequency_table * sunxi_cpufreq_table(void) {
+    return sun4i_freq_tbl;
+}
+
+struct cpufreq_div_order * sunxi_div_order_table(int *length) {
+    *length = ARRAY_SIZE(sun4i_div_order_tbl);
+    return sun4i_div_order_tbl;
+}
+
+#ifdef CONFIG_CPU_FREQ_DVFS
+struct cpufreq_dvfs * sunxi_dvfs_table(void) {
+    return sunxi_is_sun4i() ? sun4i_dvfs_table : sun5i_dvfs_table;
+}
+#endif
diff --git a/arch/arm/plat-sunxi/cpu-freq/cpu-freq.c b/arch/arm/plat-sunxi/cpu-freq/cpu-freq.c
new file mode 100644
index 0000000..420e5cb
--- /dev/null
+++ b/arch/arm/plat-sunxi/cpu-freq/cpu-freq.c
@@ -0,0 +1,732 @@
+/*
+ * arch/arm/mach-sun4i/cpu-freq/cpu-freq.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/regulator/consumer.h>
+#include "cpu-freq.h"
+
+
+static struct sun4i_cpu_freq_t  cpu_cur;    /* current cpu frequency configuration  */
+static unsigned int last_target = ~0;       /* backup last target frequency         */
+
+static struct clk *clk_pll; /* pll clock handler */
+static struct clk *clk_cpu; /* cpu clock handler */
+static struct clk *clk_axi; /* axi clock handler */
+static struct clk *clk_ahb; /* ahb clock handler */
+static struct clk *clk_apb; /* apb clock handler */
+
+
+#ifdef CONFIG_CPU_FREQ_DVFS
+static struct regulator *corevdd;
+static unsigned int last_vdd    = 1400;     /* backup last target voltage, default is 1.4v  */
+#endif
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_verify
+*
+*Description: check if the cpu frequency policy is valid;
+*
+*Arguments  : policy    cpu frequency policy;
+*
+*Return     : result, return if verify ok, else return -EINVAL;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int sun4i_cpufreq_verify(struct cpufreq_policy *policy)
+{
+    if (policy->cpu != 0)
+        return -EINVAL;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_show
+*
+*Description: show cpu frequency information;
+*
+*Arguments  : pfx   name;
+*
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void sun4i_cpufreq_show(const char *pfx, struct sun4i_cpu_freq_t *cfg)
+{
+    CPUFREQ_DBG("%s: pll=%u, cpudiv=%u, axidiv=%u, ahbdiv=%u, apb=%u\n",
+        pfx, cfg->pll, cfg->div.s.cpu_div, cfg->div.s.axi_div, cfg->div.s.ahb_div, cfg->div.s.apb_div);
+}
+
+
+#ifdef CONFIG_CPU_FREQ_DVFS
+/*
+*********************************************************************************************************
+*                           __get_vdd_value
+*
+*Description: get vdd with cpu frequency.
+*
+*Arguments  : freq  cpu frequency;
+*
+*Return     : vdd value;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline unsigned int __get_vdd_value(unsigned int freq)
+{
+    static struct cpufreq_dvfs *dvfs = NULL;
+    struct cpufreq_dvfs *dvfs_inf;
+
+    if (unlikely(dvfs == NULL))
+        dvfs = sunxi_dvfs_table();
+
+    dvfs_inf = dvfs;
+    while((dvfs_inf+1)->freq >= freq) dvfs_inf++;
+
+    return dvfs_inf->volt;
+}
+#endif
+
+
+/*
+*********************************************************************************************************
+*                           __set_cpufreq_hw
+*
+*Description: set cpu frequency configuration to hardware.
+*
+*Arguments  : freq  frequency configuration;
+*
+*Return     : result
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline int __set_cpufreq_hw(struct sun4i_cpu_freq_t *freq)
+{
+    int             ret;
+    unsigned int    frequency;
+
+    /* try to adjust pll frequency */
+    ret = clk_set_rate(clk_pll, freq->pll);
+    /* try to adjust cpu frequency */
+    frequency = freq->pll / freq->div.s.cpu_div;
+    ret |= clk_set_rate(clk_cpu, frequency);
+    /* try to adjuxt axi frequency */
+    frequency /= freq->div.s.axi_div;
+    ret |= clk_set_rate(clk_axi, frequency);
+    /* try to adjust ahb frequency */
+    frequency /= freq->div.s.ahb_div;
+    ret |= clk_set_rate(clk_ahb, frequency);
+    /* try to adjust apb frequency */
+    frequency /= freq->div.s.apb_div;
+    ret |= clk_set_rate(clk_apb, frequency);
+
+    return ret;
+}
+
+
+/*
+*********************************************************************************************************
+*                           __set_cpufreq_target
+*
+*Description: set target frequency, the frequency limitation of axi is 450Mhz, the frequency
+*             limitation of ahb is 250Mhz, and the limitation of apb is 150Mhz. for usb connecting,
+*             the frequency of ahb must not lower than 60Mhz.
+*
+*Arguments  : old   cpu/axi/ahb/apb frequency old configuration.
+*             new   cpu/axi/ahb/apb frequency new configuration.
+*
+*Return     : result, 0 - set frequency successed, !0 - set frequency failed;
+*
+*Notes      : we check two frequency point: 204Mhz, 408Mhz, 816Mhz and 1200Mhz.
+*             if increase cpu frequency, the flow should be:
+*               low(1:1:1:2) -> 204Mhz(1:1:1:2) -> 204Mhz(1:1:2:2) -> 408Mhz(1:1:2:2)
+*               -> 408Mhz(1:2:2:2) -> 816Mhz(1:2:2:2) -> 816Mhz(1:3:2:2) -> 1200Mhz(1:3:2:2)
+*               -> 1200Mhz(1:4:2:2) -> target(1:4:2:2) -> target(x:x:x:x)
+*             if decrease cpu frequency, the flow should be:
+*               high(x:x:x:x) -> target(1:4:2:2) -> 1200Mhz(1:4:2:2) -> 1200Mhz(1:3:2:2)
+*               -> 816Mhz(1:3:2:2) -> 816Mhz(1:2:2:2) -> 408Mhz(1:2:2:2) -> 408Mhz(1:1:2:2)
+*               -> 204Mhz(1:1:2:2) -> 204Mhz(1:1:1:2) -> target(1:1:1:2)
+*********************************************************************************************************
+*/
+static int __set_cpufreq_target(struct sun4i_cpu_freq_t *old, struct sun4i_cpu_freq_t *new)
+{
+    int ret = 0;
+    int div_table_len;
+    unsigned int i = 0;
+    unsigned int j = 0;
+    struct sun4i_cpu_freq_t old_freq, new_freq;
+    static struct cpufreq_div_order *div_order_tbl = NULL;
+
+    if (unlikely(div_order_tbl == NULL))
+        div_order_tbl = sunxi_div_order_table(&div_table_len);
+
+    if (!old || !new)
+        return -EINVAL;
+
+    old_freq = *old;
+    new_freq = *new;
+
+    CPUFREQ_INF("cpu: %dMhz->%dMhz\n", old_freq.pll/1000000, new_freq.pll/1000000);
+
+    /* We're raising our clock */
+    if (new_freq.pll > old_freq.pll) {
+        /* We have a div table, the old and the new divs,
+         * let's change them in order */
+
+        /* Figure out old one */
+        while (i < div_table_len-1 &&
+              div_order_tbl[i].pll < old_freq.pll) i++;
+
+        /* Figure out new one */
+        j = i; /* it's either the same or bigger */
+        while (j < div_table_len-1 &&
+              div_order_tbl[j].pll < new_freq.pll) j++;
+
+        for (; i < div_table_len-1 && i < j; i++) {
+            old_freq.pll = div_order_tbl[i].pll;
+            old_freq.div.i = div_order_tbl[i].div;
+            ret |= __set_cpufreq_hw(&old_freq);
+
+            old_freq.div.i = div_order_tbl[i+1].div;
+            ret |= __set_cpufreq_hw(&old_freq);
+        }
+    /* We're lowering our clock */
+    } else if (new_freq.pll < old_freq.pll) {
+        /* We have a div table, the old and the new divs, let's change them in order */
+
+        /* Figure out new one*/
+        while (i < div_table_len-1 &&
+              div_order_tbl[i].pll < new_freq.pll) i++;
+
+        /* Figure out old one */
+        j = i; /* it's either the same or bigger */
+        while (j < div_table_len-1 &&
+              div_order_tbl[j].pll < old_freq.pll) j++;
+
+        for (; j > 0 && i < j; j--) {
+            old_freq.pll = div_order_tbl[j-1].pll;
+            old_freq.div.i = div_order_tbl[j].div;
+            ret |= __set_cpufreq_hw(&old_freq);
+
+            old_freq.div.i = div_order_tbl[j-1].div;
+            ret |= __set_cpufreq_hw(&old_freq);
+        }
+    }
+
+    /* adjust to target frequency */
+    ret |= __set_cpufreq_hw(&new_freq);
+
+    if (ret) {
+        unsigned int frequency;
+
+        CPUFREQ_ERR("try to set target frequency failed!\n");
+
+        /* try to restore frequency configuration */
+        frequency = clk_get_rate(clk_cpu);
+        frequency /= 4;
+        clk_set_rate(clk_axi, frequency);
+        frequency /= 2;
+        clk_set_rate(clk_ahb, frequency);
+        frequency /= 2;
+        clk_set_rate(clk_apb, frequency);
+
+        clk_set_rate(clk_pll, old->pll);
+        frequency = old->pll / old->div.s.cpu_div;
+        clk_set_rate(clk_cpu, frequency);
+        frequency /= old->div.s.axi_div;
+        clk_set_rate(clk_axi, frequency);
+        frequency /= old->div.s.ahb_div;
+        clk_set_rate(clk_ahb, frequency);
+        frequency /= old->div.s.apb_div;
+        clk_set_rate(clk_apb, frequency);
+
+        CPUFREQ_ERR(KERN_ERR "no compatible settings cpu freq for %d\n", new_freq.pll);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_settarget
+*
+*Description: adjust cpu frequency;
+*
+*Arguments  : policy    cpu frequency policy, to mark if need notify;
+*             cpu_freq  new cpu frequency configuration;
+*
+*Return     : return 0 if set successed, otherwise, return -EINVAL
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int sun4i_cpufreq_settarget(struct cpufreq_policy *policy, struct sun4i_cpu_freq_t *cpu_freq)
+{
+    struct cpufreq_freqs    freqs;
+    struct sun4i_cpu_freq_t cpu_new;
+
+    #ifdef CONFIG_CPU_FREQ_DVFS
+    unsigned int    new_vdd;
+    #endif
+
+    /* show current cpu frequency configuration, just for debug */
+    sun4i_cpufreq_show("cur", &cpu_cur);
+
+    /* get new cpu frequency configuration */
+    cpu_new = *cpu_freq;
+    sun4i_cpufreq_show("new", &cpu_new);
+
+    /* notify that cpu clock will be adjust if needed */
+    if (policy) {
+        freqs.cpu = 0;
+        freqs.old = cpu_cur.pll / 1000;
+        freqs.new = cpu_new.pll / 1000;
+        cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+    }
+
+    #ifdef CONFIG_CPU_FREQ_DVFS
+    /* get vdd value for new frequency */
+    new_vdd = __get_vdd_value(cpu_new.pll);
+
+    if(corevdd && (new_vdd > last_vdd)) {
+        CPUFREQ_INF("set core vdd to %d\n", new_vdd);
+        if(regulator_set_voltage(corevdd, new_vdd*1000, new_vdd*1000)) {
+            CPUFREQ_INF("try to set voltage failed!\n");
+
+            /* notify everyone that clock transition finish */
+    	    if (policy) {
+                freqs.cpu = 0;
+                freqs.old = freqs.new;
+                freqs.new = cpu_cur.pll / 1000;
+                cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+            }
+            return -EINVAL;
+        }
+    }
+    #endif
+
+    if(__set_cpufreq_target(&cpu_cur, &cpu_new)){
+
+        /* try to set cpu frequency failed */
+
+        #ifdef CONFIG_CPU_FREQ_DVFS
+        if(corevdd && (new_vdd > last_vdd)) {
+            CPUFREQ_INF("set core vdd to %d\n", last_vdd);
+            if(regulator_set_voltage(corevdd, last_vdd*1000, last_vdd*1000)){
+                CPUFREQ_INF("try to set voltage failed!\n");
+                last_vdd = new_vdd;
+            }
+        }
+        #endif
+
+        /* notify everyone that clock transition finish */
+    	if (policy) {
+            freqs.cpu = 0;
+            freqs.old = freqs.new;
+            freqs.new = cpu_cur.pll / 1000;
+            cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+        }
+
+        return -EINVAL;
+    }
+
+    #ifdef CONFIG_CPU_FREQ_DVFS
+    if(corevdd && (new_vdd < last_vdd)) {
+        CPUFREQ_INF("set core vdd to %d\n", new_vdd);
+        if(regulator_set_voltage(corevdd, new_vdd*1000, new_vdd*1000)) {
+            CPUFREQ_INF("try to set voltage failed!\n");
+            new_vdd = last_vdd;
+        }
+    }
+    last_vdd = new_vdd;
+    #endif
+
+    /* update our current settings */
+    cpu_cur = cpu_new;
+
+    /* notify everyone we've done this */
+    if (policy) {
+        cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+    }
+
+    CPUFREQ_DBG("%s: finished\n", __func__);
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_target
+*
+*Description: adjust the frequency that cpu is currently running;
+*
+*Arguments  : policy    cpu frequency policy;
+*             freq      target frequency to be set, based on khz;
+*             relation  method for selecting the target requency;
+*
+*Return     : result, return 0 if set target frequency successed,
+*                     else, return -EINVAL;
+*
+*Notes      : this function is called by the cpufreq core;
+*
+*********************************************************************************************************
+*/
+static int sun4i_cpufreq_target(struct cpufreq_policy *policy, __u32 freq, __u32 relation)
+{
+    int                     ret;
+    unsigned int            index;
+    struct sun4i_cpu_freq_t freq_cfg;
+    static struct cpufreq_frequency_table *sun4i_freq_tbl = NULL;
+
+    if (unlikely(sun4i_freq_tbl == NULL))
+        sun4i_freq_tbl = sunxi_cpufreq_table();
+
+    /* avoid repeated calls which cause a needless amout of duplicated
+     * logging output (and CPU time as the calculation process is
+     * done) */
+    if (freq == last_target) {
+        return 0;
+    }
+
+    /* try to look for a valid frequency value from cpu frequency table */
+    if (cpufreq_frequency_table_target(policy, sun4i_freq_tbl, freq, relation, &index)) {
+        CPUFREQ_ERR("%s: try to look for a valid frequency for %u failed!\n", __func__, freq);
+        return -EINVAL;
+    }
+
+    if (sun4i_freq_tbl[index].frequency == last_target) {
+        /* frequency is same as the value last set, need not adjust */
+        return 0;
+    }
+    freq = sun4i_freq_tbl[index].frequency;
+
+    /* update the target frequency */
+    freq_cfg.pll = sun4i_freq_tbl[index].frequency * 1000;
+    freq_cfg.div.i = sun4i_freq_tbl[index].index;
+    CPUFREQ_DBG("%s: target frequency find is %u, entry %u\n", __func__, freq_cfg.pll, index);
+
+    /* try to set target frequency */
+    ret = sun4i_cpufreq_settarget(policy, &freq_cfg);
+    if(!ret) {
+        last_target = freq;
+    }
+
+    return ret;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_get
+*
+*Description: get the frequency that cpu currently is running;
+*
+*Arguments  : cpu   cpu number;
+*
+*Return     : cpu frequency, based on khz;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static unsigned int sun4i_cpufreq_get(unsigned int cpu)
+{
+    return clk_get_rate(clk_cpu) / 1000;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_init
+*
+*Description: cpu frequency initialise a policy;
+*
+*Arguments  : policy    cpu frequency policy;
+*
+*Return     : result, return 0 if init ok, else, return -EINVAL;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int sun4i_cpufreq_init(struct cpufreq_policy *policy)
+{
+	CPUFREQ_DBG(KERN_INFO "%s: initialize policy %p\n", __func__, policy);
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->cur = sun4i_cpufreq_get(0);
+	policy->min = SUN4I_SCALING_MIN / 1000;
+	policy->max = SUN4I_SCALING_MAX / 1000;
+	policy->cpuinfo.min_freq = SUN4I_CPUFREQ_MIN / 1000;
+	policy->cpuinfo.max_freq = SUN4I_CPUFREQ_MAX / 1000;
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	/* feed the latency information from the cpu driver */
+	policy->cpuinfo.transition_latency = SUN4I_FREQTRANS_LATENCY;
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_getcur
+*
+*Description: get current cpu frequency configuration;
+*
+*Arguments  : cfg   cpu frequency cofniguration;
+*
+*Return     : result;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int sun4i_cpufreq_getcur(struct sun4i_cpu_freq_t *cfg)
+{
+    unsigned int    freq, freq0;
+
+    if(!cfg) {
+        return -EINVAL;
+    }
+
+    cfg->pll = clk_get_rate(clk_pll);
+    freq = clk_get_rate(clk_cpu);
+    cfg->div.s.cpu_div = cfg->pll / freq;
+    freq0 = clk_get_rate(clk_axi);
+    cfg->div.s.axi_div = freq / freq0;
+    freq = clk_get_rate(clk_ahb);
+    cfg->div.s.ahb_div = freq0 / freq;
+    freq0 = clk_get_rate(clk_apb);
+    cfg->div.s.apb_div = freq /freq0;
+
+    return 0;
+}
+
+
+
+#ifdef CONFIG_PM
+
+/* variable for backup cpu frequency configuration */
+static struct sun4i_cpu_freq_t suspend_freq;
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_suspend
+*
+*Description: back up cpu frequency configuration for suspend;
+*
+*Arguments  : policy    cpu frequency policy;
+*             pmsg      power management message;
+*
+*Return     : return 0,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int sun4i_cpufreq_suspend(struct cpufreq_policy *policy)
+{
+    struct sun4i_cpu_freq_t suspend;
+
+    CPUFREQ_DBG("%s, set cpu frequency to 60Mhz to prepare enter standby\n", __func__);
+
+    sun4i_cpufreq_getcur(&suspend_freq);
+
+    /* set cpu frequency to 60M hz for standby */
+    suspend.pll = 60000000;
+    suspend.div.s.cpu_div = 1;
+    suspend.div.s.axi_div = 1;
+    suspend.div.s.ahb_div = 1;
+    suspend.div.s.apb_div = 2;
+    __set_cpufreq_target(&suspend_freq, &suspend);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_resume
+*
+*Description: cpu frequency configuration resume;
+*
+*Arguments  : policy    cpu frequency policy;
+*
+*Return     : result;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int sun4i_cpufreq_resume(struct cpufreq_policy *policy)
+{
+    struct sun4i_cpu_freq_t suspend;
+
+    /* invalidate last_target setting */
+    last_target = ~0;
+
+    CPUFREQ_DBG("%s: resuming with policy %p\n", __func__, policy);
+    sun4i_cpufreq_getcur(&suspend);
+
+    /* restore cpu frequency configuration */
+    __set_cpufreq_target(&suspend, &suspend_freq);
+
+    CPUFREQ_DBG("%s: resuming done\n", __func__);
+    return 0;
+}
+
+
+#else   /* #ifdef CONFIG_PM */
+
+#define sun4i_cpufreq_suspend   NULL
+#define sun4i_cpufreq_resume    NULL
+
+#endif  /* #ifdef CONFIG_PM */
+
+static struct freq_attr *sun4i_cpufreq_attr[] = {
+    &cpufreq_freq_attr_scaling_available_freqs,
+    NULL,
+};
+
+static struct cpufreq_driver sun4i_cpufreq_driver = {
+    .flags		= CPUFREQ_STICKY,
+    .verify		= sun4i_cpufreq_verify,
+    .target		= sun4i_cpufreq_target,
+    .get		= sun4i_cpufreq_get,
+    .init		= sun4i_cpufreq_init,
+    .suspend	= sun4i_cpufreq_suspend,
+    .resume		= sun4i_cpufreq_resume,
+    .name		= "sun4i",
+    .attr		= sun4i_cpufreq_attr,
+};
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_initclks
+*
+*Description: init cpu frequency clock resource;
+*
+*Arguments  : none
+*
+*Return     : result;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __init int sun4i_cpufreq_initclks(void)
+{
+    clk_pll = clk_get(NULL, "core_pll");
+    clk_cpu = clk_get(NULL, "cpu");
+    clk_axi = clk_get(NULL, "axi");
+    clk_ahb = clk_get(NULL, "ahb");
+    clk_apb = clk_get(NULL, "apb");
+
+    if (IS_ERR(clk_pll) || IS_ERR(clk_cpu) || IS_ERR(clk_axi) ||
+        IS_ERR(clk_ahb) || IS_ERR(clk_apb)) {
+        CPUFREQ_INF(KERN_ERR "%s: could not get clock(s)\n", __func__);
+        return -ENOENT;
+    }
+
+    CPUFREQ_INF("%s: clocks pll=%lu,cpu=%lu,axi=%lu,ahp=%lu,apb=%lu\n", __func__,
+           clk_get_rate(clk_pll), clk_get_rate(clk_cpu), clk_get_rate(clk_axi),
+           clk_get_rate(clk_ahb), clk_get_rate(clk_apb));
+
+    #ifdef CONFIG_CPU_FREQ_DVFS
+    corevdd = regulator_get(NULL, "Vcore");
+    if (IS_ERR(corevdd)) {
+        CPUFREQ_INF("try to get regulator failed, core vdd will not changed!\n");
+        corevdd = NULL;
+    } else {
+        CPUFREQ_INF("try to get regulator(0x%x) successed.\n", (__u32)corevdd);
+        last_vdd = regulator_get_voltage(corevdd) / 1000;
+    }
+    #endif
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           sun4i_cpufreq_initcall
+*
+*Description: cpu frequency driver initcall
+*
+*Arguments  : none
+*
+*Return     : result
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int __init sun4i_cpufreq_initcall(void)
+{
+    int ret = 0;
+    struct cpufreq_frequency_table *sun4i_freq_tbl = sunxi_cpufreq_table();
+
+    /* initialise some clock resource */
+    ret = sun4i_cpufreq_initclks();
+    if(ret) {
+        return ret;
+    }
+
+    /* initialise current frequency configuration */
+    sun4i_cpufreq_getcur(&cpu_cur);
+    sun4i_cpufreq_show("cur", &cpu_cur);
+
+    /* register cpu frequency driver */
+    ret = cpufreq_register_driver(&sun4i_cpufreq_driver);
+    /* register cpu frequency table to cpufreq core */
+    cpufreq_frequency_table_get_attr(sun4i_freq_tbl, 0);
+    /* update policy for boot cpu */
+    cpufreq_update_policy(0);
+
+    return ret;
+}
+late_initcall(sun4i_cpufreq_initcall);
diff --git a/arch/arm/plat-sunxi/cpu-freq/cpu-freq.h b/arch/arm/plat-sunxi/cpu-freq/cpu-freq.h
new file mode 100644
index 0000000..41d3184
--- /dev/null
+++ b/arch/arm/plat-sunxi/cpu-freq/cpu-freq.h
@@ -0,0 +1,91 @@
+/*
+ * arch/arm/mach-sun4i/cpu-freq/cpu-freq.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SUN4I_CPU_FREQ_H__
+#define __SUN4I_CPU_FREQ_H__
+
+#include <linux/types.h>
+#include <linux/cpufreq.h>
+
+#undef CPUFREQ_DBG
+#undef CPUFREQ_ERR
+#if (0)
+    #define CPUFREQ_DBG(format,args...)   printk("[cpu_freq] DBG:"format,##args)
+    #define CPUFREQ_ERR(format,args...)   printk("[cpu_freq] ERR:"format,##args)
+    #define CPUFREQ_INF(format,args...)   printk("[cpu_freq] INF:"format,##args)
+#else
+    #define CPUFREQ_DBG(format,args...)   do{}while(0)
+    #define CPUFREQ_ERR(format,args...)   do{}while(0)
+    #define CPUFREQ_INF(format,args...)   do{}while(0)
+#endif
+
+
+/* Absolute minimum and maximum */
+#define SUN4I_CPUFREQ_MAX       (1008000000)    /* config the maximum frequency of sun4i core */
+#define SUN4I_CPUFREQ_MIN       (60000000)      /* config the minimum frequency of sun4i core */
+/* Defaults limits for the scaling governor */
+#define SUN4I_SCALING_MIN	(CONFIG_SUNXI_SCALING_MIN * 1000000)
+#define SUN4I_SCALING_MAX	(1008000000)
+#define SUN4I_FREQTRANS_LATENCY (2000000)       /* config the transition latency, based on ns */
+
+struct sun4i_clk_div_t {
+    __u32   cpu_div:4;      /* division of cpu clock, divide core_pll */
+    __u32   axi_div:4;      /* division of axi clock, divide cpu clock*/
+    __u32   ahb_div:4;      /* division of ahb clock, divide axi clock*/
+    __u32   apb_div:4;      /* division of apb clock, divide ahb clock*/
+    __u32   reserved:16;
+};
+
+struct sun4i_cpu_freq_t {
+    __u32                   pll;    /* core pll frequency value */
+    union {
+        struct sun4i_clk_div_t s;    /* division configuration   */
+        __u32 i;
+    } div;
+};
+
+#define SUN4I_CLK_DIV(cpu_div, axi_div, ahb_div, apb_div)       \
+                ((cpu_div<<0)|(axi_div<<4)|(ahb_div<<8)|(apb_div<<12))
+
+#ifdef CONFIG_CPU_FREQ_DVFS
+struct cpufreq_dvfs {
+    unsigned int    freq;   /* cpu frequency    */
+    unsigned int    volt;   /* voltage for the frequency    */
+};
+#endif
+
+struct cpufreq_div_order {
+    __u32 div;
+    __u32 pll;
+};
+
+/* Table fetchers */
+struct cpufreq_frequency_table *sunxi_cpufreq_table(void);
+struct cpufreq_div_order *sunxi_div_order_table(int *length);
+#ifdef CONFIG_CPU_FREQ_DVFS
+struct cpufreq_dvfs *sunxi_dvfs_table(void);
+#endif
+
+#endif  /* #ifndef __SUN4I_CPU_FREQ_H__ */
+
+
diff --git a/arch/arm/plat-sunxi/devices.c b/arch/arm/plat-sunxi/devices.c
new file mode 100644
index 0000000..fdddc56
--- /dev/null
+++ b/arch/arm/plat-sunxi/devices.c
@@ -0,0 +1,158 @@
+/*
+ * arch/arm/plat-sunxi/devices.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/pda_power.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/setup.h>
+#include <asm/pmu.h>
+#include <mach/hardware.h>
+#include <plat/i2c.h>
+#include <plat/platform.h>
+
+#if 0
+/* uart */
+static struct plat_serial8250_port debug_uart_platform_data[] = {
+	{
+		.membase	= (void __iomem *)SW_VA_UART0_IO_BASE,
+		.mapbase	= (resource_size_t)SW_PA_UART0_IO_BASE,
+		.irq		= SW_INT_IRQNO_UART0,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= 24000000,
+	}, {
+		.flags		= 0
+	}
+};
+
+static struct platform_device debug_uart = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data = debug_uart_platform_data,
+	},
+};
+#endif
+
+/* dma */
+#ifdef CONFIG_ARCH_SUN7I
+static u64 sw_dmac_dmamask = DMA_BIT_MASK(32);
+
+static struct resource sw_dmac_resources[] = {
+	[0] = {
+		.start 	= SW_PA_DMAC_IO_BASE,
+		.end 	= SW_PA_DMAC_IO_BASE + 0xfff,
+		.flags 	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= SW_INT_IRQNO_DMA,
+		.end 	= SW_INT_IRQNO_DMA,
+		.flags 	= IORESOURCE_IRQ
+	}
+};
+#endif
+
+static struct platform_device sw_pdev_dmac = {
+	.name		= "sw_dmac",
+	.id 		= 0,
+#ifdef CONFIG_ARCH_SUN7I
+	.num_resources 	= ARRAY_SIZE(sw_dmac_resources),
+	.resource 	= sw_dmac_resources,
+	.dev 		= {
+		.dma_mask = &sw_dmac_dmamask,
+		/* validate dma_pool_alloc */
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+#endif
+};
+
+static struct resource sw_res_nand =
+{
+	.start = SW_PA_NANDFLASHC_IO_BASE,
+	.end = SW_PA_NANDFLASHC_IO_BASE + 0xfff,
+	.flags = IORESOURCE_MEM,
+};
+
+struct platform_device sw_pdev_nand =
+{
+	.name = "sw_nand",
+	.id = -1,
+	.num_resources = 1,
+	.resource = &sw_res_nand,
+	.dev = {}
+};
+
+#ifndef CONFIG_ARCH_SUN7I
+static struct resource sunxi_pmu_resources[] = {
+	{
+		.start	= SW_INT_IRQNO_PLE_PFM,
+		.end	= SW_INT_IRQNO_PLE_PFM,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device sunxi_pmu_device = {
+	.name		= "arm-pmu",
+	.id		= ARM_PMU_DEVICE_CPU,
+	.resource	= sunxi_pmu_resources,
+	.num_resources	= ARRAY_SIZE(sunxi_pmu_resources),
+};
+#endif
+
+#if defined(CONFIG_MALI_DRM) || defined(CONFIG_MALI_DRM_MODULE)
+static struct platform_device sunxi_device_mali_drm = {
+	.name = "mali_drm",
+	.id   = -1,
+};
+#endif
+
+static struct platform_device *sw_pdevs[] __initdata = {
+#if 0
+	&debug_uart,
+#endif
+	&sw_pdev_dmac,
+	&sw_pdev_nand,
+#ifndef CONFIG_ARCH_SUN7I
+	&sunxi_pmu_device,
+#endif
+#if defined(CONFIG_MALI_DRM) || defined(CONFIG_MALI_DRM_MODULE)
+	&sunxi_device_mali_drm,
+#endif
+
+};
+
+void __init sw_pdev_init(void)
+{
+	platform_add_devices(sw_pdevs, ARRAY_SIZE(sw_pdevs));
+}
diff --git a/arch/arm/plat-sunxi/dma.c b/arch/arm/plat-sunxi/dma.c
new file mode 100644
index 0000000..4bc9107
--- /dev/null
+++ b/arch/arm/plat-sunxi/dma.c
@@ -0,0 +1,1525 @@
+/*
+ * arch/arm/plat-sunxi/dma/dma.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <asm/memory.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <plat/dma.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+
+#include <mach/platform.h>
+#include "dma_regs.h"
+#if defined CONFIG_ARCH_SUN4I
+#include "dma_route_sun4i.h"
+#elif defined CONFIG_ARCH_SUN5I
+#include "dma_route_sun5i.h"
+#endif 
+
+
+#undef DEBUG
+
+/* io map for dma */
+static void __iomem *dma_base;
+static struct kmem_cache *dma_kmem;
+
+static int dma_channels;
+
+static struct sw_dma_selection dma_sel;
+
+/* dma channel state information */
+struct sw_dma_chan sw_chans[SW_DMA_CHANNELS];
+
+/* debugging functions */
+
+#define BUF_MAGIC (0xcefabdba)
+
+#define dmawarn(fmt...) printk(KERN_DEBUG fmt)
+
+#define dma_regaddr(chan, reg) ((chan)->regs + (reg))
+
+#define dma_wrreg(chan, reg, val) writel((val), (chan)->regs + (reg))
+
+#define dma_rdreg(chan, reg) readl((chan)->regs + (reg))
+
+/* captured register state for debug */
+
+struct sw_dma_regstate {
+	unsigned long         dirqen;		/* irq enable bits */
+	unsigned long         dirqpd;		/* irq pending bits */
+	unsigned long         dconf;		/* dma config bits */
+	unsigned long         dsrc;			/* dma src (not shadow) */
+	unsigned long         ddst;			/* dma dst (not shadow) */
+	unsigned long         dcnt;			/* dma count (not shadow) */
+};
+
+#ifdef CONFIG_SW_DMA_DEBUG
+static void
+pr_debug_capture(struct sw_dma_chan *chan, struct sw_dma_regstate *regs)
+{
+	regs->dirqen  = readl(dma_base + SW_DMA_DIRQEN);
+	regs->dirqpd  = readl(dma_base + SW_DMA_DIRQPD);
+	regs->dsrc    = dma_rdreg(chan, SW_DMA_DSRC);
+	regs->ddst    = dma_rdreg(chan, SW_DMA_DDST);
+	regs->dcnt    = dma_rdreg(chan, SW_DMA_DCNT);
+	regs->dconf   = dma_rdreg(chan, SW_DMA_DCONF);
+}
+
+static void
+pr_debug_dumpregs(const char *fname, int line, struct sw_dma_chan *chan,
+		 struct sw_dma_regstate *regs)
+{
+	pr_debug("dma%d: %s:%d: IRQEN=%08lx, IRQPD=%08lx, SRC=%08lx "
+		        "DST=%08lx, DCNT=%lx, DCONF=%08lx\n",
+	       chan->number, fname, line, regs->dirqen, regs->dirqpd,
+	       		regs->dsrc, regs->ddst, regs->dcnt, regs->dconf
+	       );
+}
+
+static void
+pr_debug_showchan(const char *fname, int line, struct sw_dma_chan *chan)
+{
+	struct sw_dma_regstate state;
+	struct sw_dma_buf  *buf;
+
+	pr_debug_capture(chan, &state);
+
+	pr_debug("dma%d: %s:%d: ls=%d, queue ->",
+	       chan->number, fname, line, chan->load_state);
+	for(buf=chan->curr; !!(buf); buf=buf->next)
+		pr_debug(" %x", buf->data);
+	pr_debug(" <-\n");
+
+	pr_debug_dumpregs(fname, line, chan, &state);
+}
+
+static void
+pr_debug_showregs(const char *fname, int line, struct sw_dma_chan *chan)
+{
+	struct sw_dma_regstate state;
+
+	pr_debug_capture(chan, &state);
+	pr_debug_dumpregs(fname, line, chan, &state);
+}
+
+#define dbg_showregs(chan) pr_debug_showregs(__func__, __LINE__, (chan))
+#define dbg_showchan(chan) pr_debug_showchan(__func__, __LINE__, (chan))
+#else
+#define dbg_showregs(chan) do { } while(0)
+#define dbg_showchan(chan) do { } while(0)
+#endif /* CONFIG_SW_DMA_DEBUG */
+
+static struct sw_dma_chan *dma_chan_map[DMACH_MAX];
+
+/* lookup_dma_channel
+ *
+ * change the dma channel number given into a real dma channel id
+*/
+
+static struct sw_dma_chan *lookup_dma_channel(unsigned int channel)
+{
+	if (channel & DMACH_LOW_LEVEL)
+		return &sw_chans[channel & ~DMACH_LOW_LEVEL];
+	else
+		return dma_chan_map[channel];
+}
+
+inline void DMA_COPY_HW_CONF(struct dma_hw_conf *to, struct dma_hw_conf *from)
+{
+	to->xfer_type    = from->xfer_type;
+	to->drqsrc_type  = from->drqsrc_type;
+	to->drqdst_type  = from->drqdst_type;
+	to->address_type = from->address_type;
+	to->dir          = from->dir;
+	to->reload       = from->reload;
+	to->hf_irq       = from->hf_irq;
+	to->from         = from->from;
+	to->to           = from->to;
+	to->cmbk         = from->cmbk;
+}
+
+/* sw_dma_stats_timeout
+ *
+ * Update DMA stats from timeout info
+*/
+
+static void
+sw_dma_stats_timeout(struct sw_dma_stats *stats, int val)
+{
+	if (stats == NULL)
+		return;
+
+	if (val > stats->timeout_longest)
+		stats->timeout_longest = val;
+	if (val < stats->timeout_shortest)
+		stats->timeout_shortest = val;
+
+	stats->timeout_avg += val;
+}
+
+/* sw_dma_waitforload
+ *
+ * wait for the DMA engine to load a buffer, and update the state accordingly
+*/
+
+static int sw_dma_waitforload(struct sw_dma_chan *chan, int line)
+{
+	int timeout = chan->load_timeout;
+	int took;
+
+	if (chan->load_state != SW_DMALOAD_1LOADED) {
+		printk(KERN_ERR "dma%d: sw_dma_waitforload() called in loadstate %d from line %d\n", chan->number, chan->load_state, line);
+		return 0;
+	}
+
+	if (chan->stats != NULL)
+		chan->stats->loads++;
+
+	while (--timeout > 0) {
+		if (dma_rdreg(chan, SW_DMA_DCONF) & (1<<31) || /* runing */
+			readl(dma_base + SW_DMA_DIRQPD) & (2 << (chan->number<<1)) /* pending */ ) {
+			took = chan->load_timeout - timeout;
+
+			sw_dma_stats_timeout(chan->stats, took);
+
+			switch (chan->load_state) {
+			case SW_DMALOAD_1LOADED:
+				chan->load_state = SW_DMALOAD_1RUNNING;
+				pr_debug("L%d(from %d), loadstate SW_DMALOAD_1LOADED -> SW_DMALOAD_1RUNNING\n", __LINE__, line);
+				break;
+
+			default:
+				printk(KERN_ERR "dma%d: unknown load_state in sw_dma_waitforload() %d\n", chan->number, chan->load_state);
+			}
+
+			return 1;
+		}
+	}
+
+	if (chan->stats != NULL) {
+		chan->stats->timeout_failed++;
+	}
+
+	return 0;
+}
+
+
+
+/* sw_dma_loadbuffer
+ *
+ * load a buffer, and update the channel state
+*/
+
+static inline int sw_dma_loadbuffer(struct sw_dma_chan *chan, struct sw_dma_buf *buf)
+{
+	pr_debug("sw_chan_loadbuffer: loading buff %p (0x%08lx,0x%06x)\n",
+		 buf, (unsigned long)buf->data, buf->size);
+
+	if (buf == NULL) {
+		dmawarn("buffer is NULL\n");
+		return -EINVAL;
+	}
+
+	/* check the state of the channel before we do anything */
+
+	if (chan->load_state == SW_DMALOAD_1LOADED) {
+		dmawarn("load_state is SW_DMALOAD_1LOADED\n");
+	}
+
+	if (chan->load_state == SW_DMALOAD_1LOADED_1RUNNING) {
+		dmawarn("state is SW_DMALOAD_1LOADED_1RUNNING\n");
+	}
+
+	if(chan->dcon & SW_NDMA_CONF_CONTI || chan->dcon & SW_DDMA_CONF_CONTI || chan->load_state == SW_DMALOAD_NONE){
+		writel(__virt_to_bus(buf->data), chan->addr_reg);
+		dma_wrreg(chan, SW_DMA_DCNT, buf->size);
+	}
+
+	chan->next = buf->next;
+
+	/* update the state of the channel */
+
+	switch (chan->load_state) {
+	case SW_DMALOAD_NONE:
+		pr_debug("L%d, loadstate SW_DMALOAD_NONE -> SW_DMALOAD_1LOADED\n", __LINE__);
+		chan->load_state = SW_DMALOAD_1LOADED;
+		break;
+
+	case SW_DMALOAD_1RUNNING:
+		pr_debug("L%d, loadstate SW_DMALOAD_1RUNNING -> SW_DMALOAD_1LOADED_1RUNNING\n", __LINE__);
+		chan->load_state = SW_DMALOAD_1LOADED_1RUNNING;
+		break;
+
+	default:
+		dmawarn("dmaload: unknown state %d in loadbuffer\n",
+			chan->load_state);
+		break;
+	}
+
+	return 0;
+}
+
+/* sw_dma_call_op
+ *
+ * small routine to call the op routine with the given op if it has been
+ * registered
+*/
+
+static void sw_dma_call_op(struct sw_dma_chan *chan, enum sw_chan_op op)
+{
+	if (chan->op_fn != NULL) {
+		(chan->op_fn)(chan, op);
+	}
+}
+
+/* sw_dma_buffdone
+ *
+ * small wrapper to check if callback routine needs to be called, and
+ * if so, call it
+*/
+
+static inline void sw_dma_buffdone(struct sw_dma_chan *chan, struct sw_dma_buf *buf,
+		     enum sw_dma_buffresult result)
+{
+	if (chan->callback_fn != NULL) {
+		(chan->callback_fn)(chan, buf->id, buf->size, result);
+	}
+}
+
+static inline void sw_dma_halfdone(struct sw_dma_chan *chan, struct sw_dma_buf *buf,
+		     enum sw_dma_buffresult result)
+{
+	if (chan->callback_hd != NULL) {
+		(chan->callback_hd)(chan, buf->id, buf->size, result);
+	}
+}
+
+/* sw_dma_start
+ *
+ * start a dma channel going
+*/
+
+static int sw_dma_start(struct sw_dma_chan *chan)
+{
+	unsigned long flags;
+
+	//pr_debug("sw_start_dma: channel=%d\n", chan->number);
+
+	local_irq_save(flags);
+
+	if (chan->state == SW_DMA_RUNNING) {
+		pr_debug("sw_start_dma: already running (%d)\n", chan->state);
+		local_irq_restore(flags);
+		return 0;
+	}
+
+	chan->state = SW_DMA_RUNNING;
+
+	/* check wether there is anything to load, and if not, see
+	 * if we can find anything to load
+	 */
+
+	if (chan->load_state == SW_DMALOAD_NONE) {
+		if (chan->next == NULL) {
+			printk(KERN_ERR "dma%d: channel has nothing loaded\n",
+			       chan->number);
+			chan->state = SW_DMA_IDLE;
+			local_irq_restore(flags);
+			return -EINVAL;
+		}
+
+		sw_dma_loadbuffer(chan, chan->next);
+	}
+
+	dbg_showchan(chan);
+
+	//printk("[%s] dcon=0x%08x\n", __FUNCTION__, (unsigned int)chan->dcon);
+	dma_wrreg(chan, SW_DMA_DCONF, SW_DCONF_LOADING | chan->dcon);
+
+
+	sw_dma_call_op(chan, SW_DMAOP_START);
+
+	dbg_showchan(chan);
+
+	/* if we've only loaded one buffer onto the channel, then chec
+	 * to see if we have another, and if so, try and load it so when
+	 * the first buffer is finished, the new one will be loaded onto
+	 * the channel */
+
+	if (chan->next != NULL) {
+		if (chan->load_state == SW_DMALOAD_1LOADED) {
+
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				pr_debug("%s: buff not yet loaded, no more todo\n",
+					 __func__);
+			} else {
+		        pr_debug("L%d, loadstate %d -> SW_DMALOAD_1RUNNING\n", __LINE__, chan->load_state);
+				chan->load_state = SW_DMALOAD_1RUNNING;
+				sw_dma_loadbuffer(chan, chan->next);
+			}
+
+		} else if (chan->load_state == SW_DMALOAD_1RUNNING) {
+			sw_dma_loadbuffer(chan, chan->next);
+		}
+	}
+
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/* sw_dma_canload
+ *
+ * work out if we can queue another buffer into the DMA engine
+*/
+
+static int
+sw_dma_canload(struct sw_dma_chan *chan)
+{
+	if (chan->load_state == SW_DMALOAD_NONE ||
+	    chan->load_state == SW_DMALOAD_1RUNNING)
+		return 1;
+
+	return 0;
+}
+
+/* sw_dma_enqueue
+ *
+ * queue an given buffer for dma transfer.
+ *
+ * id         the device driver's id information for this buffer
+ * data       the physical address of the buffer data
+ * size       the size of the buffer in bytes
+ *
+ * If the channel is not running, then the flag SW_DMAF_AUTOSTART
+ * is checked, and if set, the channel is started. If this flag isn't set,
+ * then an error will be returned.
+ *
+ * It is possible to queue more than one DMA buffer onto a channel at
+ * once, and the code will deal with the re-loading of the next buffer
+ * when necessary.
+*/
+
+int sw_dma_enqueue(unsigned int channel, void *id,
+			dma_addr_t data, int size)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	struct sw_dma_buf *buf;
+	unsigned long flags;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: id=%p, data=%08x, size=%d\n",
+		 __func__, id, (unsigned int)data, size);
+
+	buf = kmem_cache_alloc(dma_kmem, GFP_ATOMIC);
+	if (buf == NULL) {
+		pr_debug("%s: out of memory (%ld alloc)\n",
+			 __func__, (long)sizeof(*buf));
+		return -ENOMEM;
+	}
+
+	buf->next  = NULL;
+	buf->id    = id;
+	buf->magic = BUF_MAGIC;
+	buf->data  = buf->ptr = data;
+	buf->size  = size;
+
+	local_irq_save(flags);
+
+	if (chan->curr == NULL) {
+		/* we've got nothing loaded... */
+		pr_debug("%s: buffer %p queued onto empty channel\n",
+			 __func__, buf);
+
+		chan->curr = buf;
+		chan->end  = buf;
+		chan->next = NULL;
+	} else {
+		pr_debug("dma%d: %s: buffer %p queued onto non-empty channel\n",
+			 chan->number, __func__, buf);
+
+		if (chan->end == NULL)
+			pr_debug("dma%d: %s: %p not empty, and chan->end==NULL?\n",
+				 chan->number, __func__, chan);
+
+		chan->end->next = buf;
+		chan->end = buf;
+	}
+
+	/* if necessary, update the next buffer field */
+	if (chan->next == NULL)
+		chan->next = buf;
+
+	/* check to see if we can load a buffer */
+	if (chan->state == SW_DMA_RUNNING) {
+		if (chan->load_state == SW_DMALOAD_1LOADED && 1) {
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				printk(KERN_ERR "dma%d: loadbuffer:"
+				       "timeout loading buffer\n",
+				       chan->number);
+				dbg_showchan(chan);
+				local_irq_restore(flags);
+				return -EINVAL;
+			}
+		}
+
+		while (sw_dma_canload(chan) && chan->next != NULL) {
+			sw_dma_loadbuffer(chan, chan->next);
+		}
+	} else if (chan->state == SW_DMA_IDLE) {
+		if (chan->flags & SW_DMAF_AUTOSTART) {
+			sw_dma_ctrl(chan->number | DMACH_LOW_LEVEL,
+					 SW_DMAOP_START);
+		}
+	}
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_enqueue);
+
+static inline void
+sw_dma_freebuf(struct sw_dma_buf *buf)
+{
+	int magicok = (buf->magic == BUF_MAGIC);
+
+	buf->magic = -1;
+
+	if (magicok) {
+		kmem_cache_free(dma_kmem, buf);
+	} else {
+		printk("sw_dma_freebuf: buff %p with bad magic\n", buf);
+	}
+}
+
+/* sw_dma_lastxfer
+ *
+ * called when the system is out of buffers, to ensure that the channel
+ * is prepared for shutdown.
+*/
+
+static inline void
+sw_dma_lastxfer(struct sw_dma_chan *chan)
+{
+	//printk("[%s] enter\n", __FUNCTION__);
+
+	switch (chan->load_state) {
+	case SW_DMALOAD_NONE:
+		break;
+
+	case SW_DMALOAD_1LOADED:
+		if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				/* flag error? */
+			printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
+			       chan->number, __func__);
+			return;
+		}
+		break;
+
+	case SW_DMALOAD_1LOADED_1RUNNING:
+		/* I belive in this case we do not have anything to do
+		 * until the next buffer comes along, and we turn off the
+		 * reload */
+		return;
+
+	default:
+		pr_debug("dma%d: lastxfer: unhandled load_state %d with no next\n",
+			 chan->number, chan->load_state);
+		return;
+
+	}
+}
+
+
+#define pr_debug2(x...)
+
+void exec_pending_chan(int chan_nr, unsigned long pend_bits)
+{
+	struct sw_dma_chan *chan;
+	struct sw_dma_buf  *buf;
+	unsigned long tmp;
+	unsigned long flags;
+
+	writel(pend_bits, dma_base + SW_DMA_DIRQPD);
+
+	chan = &sw_chans[chan_nr];
+	buf = chan->curr;
+
+	/* Check me */
+	if (chan->map == NULL) {
+		pr_warning("Unexpected pending interrupt detected, pend_bits=0x%08x\n", (unsigned int)pend_bits);
+		return;
+	}
+
+	tmp = chan->map->conf_ptr->hf_irq & (pend_bits >> (chan_nr << 1));
+	if( tmp  & SW_DMA_IRQ_HALF ){
+		if(chan->state != SW_DMA_IDLE)     //if dma is stopped by app, app may not want callback
+			sw_dma_halfdone(chan, buf, SW_RES_OK);
+	}
+	if (!(tmp & SW_DMA_IRQ_FULL))
+		return;
+
+	dbg_showchan(chan);
+	/* modify the channel state */
+	switch (chan->load_state) {
+	case SW_DMALOAD_1RUNNING:
+		/* TODO - if we are running only one buffer, we probably
+		 * want to reload here, and then worry about the buffer
+		 * callback */
+
+		pr_debug("L%d, loadstate SW_DMALOAD_1RUNNING -> SW_DMALOAD_NONE\n", __LINE__);
+		chan->load_state = SW_DMALOAD_NONE;
+		break;
+
+	case SW_DMALOAD_1LOADED:
+		/* iirc, we should go back to NONE loaded here, we
+		 * had a buffer, and it was never verified as being
+		 * loaded.
+		 */
+
+		pr_debug("L%d, loadstate SW_DMALOAD_1LOADED -> SW_DMALOAD_NONE\n", __LINE__);
+		chan->load_state = SW_DMALOAD_NONE;
+		break;
+
+	case SW_DMALOAD_1LOADED_1RUNNING:
+		/* we'll worry about checking to see if another buffer is
+		 * ready after we've called back the owner. This should
+		 * ensure we do not wait around too long for the DMA
+		 * engine to start the next transfer
+		 */
+
+		pr_debug("L%d, loadstate SW_DMALOAD_1LOADED_1RUNNING -> SW_DMALOAD_1LOADED\n", __LINE__);
+		chan->load_state = SW_DMALOAD_1LOADED;
+
+		if(!(( chan->dcon & SW_NDMA_CONF_CONTI) || (chan->dcon & SW_DDMA_CONF_CONTI))){
+			struct sw_dma_buf  *next = chan->curr->next;
+
+			writel(__virt_to_bus(next->data), chan->addr_reg);
+			dma_wrreg(chan, SW_DMA_DCNT, next->size);
+			tmp = SW_DCONF_LOADING | chan->dcon;
+			dma_wrreg(chan, SW_DMA_DCONF, tmp);
+			tmp = dma_rdreg(chan, SW_DMA_DCONF);
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
+				       chan->number, __func__);
+				return;
+			}
+		}
+
+		break;
+
+	case SW_DMALOAD_NONE:
+		printk(KERN_ERR "dma%d: IRQ with no loaded buffer?\n",
+		       chan->number);
+		break;
+
+	default:
+		printk(KERN_ERR "dma%d: IRQ in invalid load_state %d\n",
+		       chan->number, chan->load_state);
+		break;
+	}
+
+	if (buf != NULL) {
+		/* update the chain to make sure that if we load any more
+		 * buffers when we call the callback function, things should
+		 * work properly */
+
+		chan->curr = buf->next;
+		buf->next  = NULL;
+
+		if (buf->magic != BUF_MAGIC) {
+			printk(KERN_ERR "dma%d: %s: buf %p incorrect magic\n",
+			       chan->number, __func__, buf);
+			return;
+		}
+
+		if(chan->state != SW_DMA_IDLE)     //if dma is stopped by app, app may not want callback
+			sw_dma_buffdone(chan, buf, SW_RES_OK);
+
+		/* free resouces */
+		sw_dma_freebuf(buf);
+		/* modify by yemao, 2011-07-28
+		 * check load state after call dma callback, because some relative states may be changed
+		 * in callback operation. if there is another buffer loaded in dma queue, run it and
+		 * change relative state for next transfer.
+		 * waitforload operation must follow dma loading to update dma load state
+		 */
+		if(chan->load_state == SW_DMALOAD_1LOADED && !((chan->dcon & SW_NDMA_CONF_CONTI)||(chan->dcon & SW_DDMA_CONF_CONTI))){
+			writel(__virt_to_bus(chan->curr->data), chan->addr_reg);
+			dma_wrreg(chan, SW_DMA_DCNT, chan->curr->size);
+			tmp = SW_DCONF_LOADING | chan->dcon;
+			dma_wrreg(chan, SW_DMA_DCONF, tmp);
+			tmp = dma_rdreg(chan, SW_DMA_DCONF);
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				/* flag error? */
+				printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
+				       chan->number, __func__);
+				return;
+			}
+		}
+	} else {
+	}
+	/* only reload if the channel is still running... our buffer done
+	 * routine may have altered the state by requesting the dma channel
+	 * to stop or shutdown... */
+
+	/* todo: check that when the channel is shut-down from inside this
+	 * function, we cope with unsetting reload, etc */
+
+	if (chan->next != NULL && chan->state != SW_DMA_IDLE) {
+
+		switch (chan->load_state) {
+		case SW_DMALOAD_1RUNNING:
+			/* don't need to do anything for this state */
+			break;
+
+		case SW_DMALOAD_NONE:
+			/* can load buffer immediately */
+			break;
+
+		case SW_DMALOAD_1LOADED:
+			break;
+
+		case SW_DMALOAD_1LOADED_1RUNNING:
+			return;
+
+		default:
+			printk(KERN_ERR "dma%d: unknown load_state in irq, %d\n",
+			       chan->number, chan->load_state);
+			return;
+		}
+
+		local_irq_save(flags);
+		sw_dma_loadbuffer(chan, chan->next);
+		local_irq_restore(flags);
+	} else {
+		sw_dma_lastxfer(chan);
+
+		/* see if we can stop this channel.. */
+		if (chan->load_state == SW_DMALOAD_NONE) {
+			pr_debug("dma%d: end of transfer, stopping channel (%ld)\n",
+				 chan->number, jiffies);
+			sw_dma_ctrl(chan->number | DMACH_LOW_LEVEL,
+					 SW_DMAOP_STOP);
+		}
+	}
+}
+
+static irqreturn_t
+sw_dma_irq(int irq, void *dma_pending)
+{
+	unsigned long pend_reg;
+	unsigned long pend_bits;
+	int i;
+
+	pr_debug("sw_dma_irq\n");
+
+	pend_reg = readl(dma_base + SW_DMA_DIRQPD);
+
+	for(i=0; i<16; i++){
+		pend_bits = pend_reg & ( 3 <<  (i<<1) );
+		if(pend_bits){
+			exec_pending_chan(i, pend_bits);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ * helper for dma pending check in irq disabled env.
+ * it dose fully like the dma irq triggled.
+ * mostly you can check if dma finished by using flags set within
+ * bufferdone call back function.
+ */
+void poll_dma_pending(int chan_nr)
+{
+	unsigned long pend_bits;
+
+	if (chan_nr & DMACH_LOW_LEVEL)
+		chan_nr = chan_nr & ~DMACH_LOW_LEVEL;
+	else
+		chan_nr = (lookup_dma_channel(chan_nr))->number;
+
+	pend_bits = readl(dma_base + SW_DMA_DIRQPD)  & (3 << (chan_nr << 1));
+	if(pend_bits){
+		exec_pending_chan(chan_nr, pend_bits);
+	}
+}
+EXPORT_SYMBOL(poll_dma_pending);
+
+static struct sw_dma_chan *sw_dma_map_channel(int channel);
+
+/* sw_request_dma
+ *
+ * get control of an dma channel
+*/
+
+int sw_dma_request(unsigned int channel,
+			struct sw_dma_client *client,
+			void *dev)
+{
+	struct sw_dma_chan *chan;
+	unsigned long flags, temp;
+
+	pr_debug("dma%d: sw_request_dma: client=%s, dev=%p\n",
+		 channel, client->name, dev);
+
+	local_irq_save(flags);
+
+	chan = sw_dma_map_channel(channel);
+	if (chan == NULL) {
+		local_irq_restore(flags);
+		return -EBUSY;
+	}
+
+	dbg_showchan(chan);
+
+	chan->client = client;
+	chan->in_use = 1;
+
+	temp = readl(dma_base + SW_DMA_DIRQPD);
+	temp &= (3 << (chan->number<<1));
+	writel(temp, dma_base + SW_DMA_DIRQPD);
+
+	local_irq_restore(flags);
+
+	chan->dev_id = dev;
+
+	/* need to setup */
+
+	pr_debug("%s: channel initialised, %p\n", __func__, chan);
+
+	return chan->number | DMACH_LOW_LEVEL;
+}
+
+EXPORT_SYMBOL(sw_dma_request);
+
+/* sw_dma_free
+ *
+ * release the given channel back to the system, will stop and flush
+ * any outstanding transfers, and ensure the channel is ready for the
+ * next claimant.
+ *
+ * Note, although a warning is currently printed if the freeing client
+ * info is not the same as the registrant's client info, the free is still
+ * allowed to go through.
+*/
+
+int sw_dma_free(unsigned int channel, struct sw_dma_client *client)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	unsigned long flags;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	if (chan->client != client) {
+		printk(KERN_WARNING "dma%d: possible free from different client (channel %p, passed %p)\n",
+		       channel, chan->client, client);
+	}
+
+	/* sort out stopping and freeing the channel */
+
+	if (chan->state != SW_DMA_IDLE) {
+		pr_debug("%s: need to stop dma channel %p\n",
+		       __func__, chan);
+
+		/* possibly flush the channel */
+		sw_dma_ctrl(channel, SW_DMAOP_STOP);
+	}
+
+	chan->client = NULL;
+	chan->in_use = 0;
+
+	if (!(channel & DMACH_LOW_LEVEL))
+		dma_chan_map[channel] = NULL;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_free);
+
+static int sw_dma_dostop(struct sw_dma_chan *chan)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	pr_debug("%s:\n", __func__);
+
+	dbg_showchan(chan);
+
+	local_irq_save(flags);
+
+	sw_dma_call_op(chan,  SW_DMAOP_STOP);
+
+	tmp = dma_rdreg(chan, SW_DMA_DCONF);
+	tmp &= ~SW_DCONF_LOADING;
+	dma_wrreg(chan, SW_DMA_DCONF, tmp);
+
+	/* should stop do this, or should we wait for flush? */
+	chan->state      = SW_DMA_IDLE;
+	pr_debug("L%d, loadstate %d -> SW_DMALOAD_NONE\n", __LINE__, chan->load_state);
+	chan->load_state = SW_DMALOAD_NONE;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void sw_dma_waitforstop(struct sw_dma_chan *chan)
+{
+	unsigned long tmp;
+	unsigned int timeout = 0x10000;
+
+	while (timeout-- > 0) {
+		tmp = dma_rdreg(chan, SW_DMA_DCONF);
+
+		if (!(tmp & SW_DCONF_LOADING))
+			return;
+	}
+
+	pr_debug("dma%d: failed to stop?\n", chan->number);
+}
+
+
+/* sw_dma_flush
+ *
+ * stop the channel, and remove all current and pending transfers
+*/
+
+static int sw_dma_flush(struct sw_dma_chan *chan)
+{
+	struct sw_dma_buf *buf, *next;
+	unsigned long flags;
+
+	pr_debug("%s: chan %p (%d)\n", __func__, chan, chan->number);
+
+	dbg_showchan(chan);
+
+	local_irq_save(flags);
+
+	if (chan->state != SW_DMA_IDLE) {
+		pr_debug("%s: stopping channel...\n", __func__ );
+		sw_dma_ctrl(chan->number, SW_DMAOP_STOP);
+	}
+
+	buf = chan->curr;
+	if (buf == NULL)
+		buf = chan->next;
+
+	chan->curr = chan->next = chan->end = NULL;
+
+	if (buf != NULL) {
+		for ( ; buf != NULL; buf = next) {
+			next = buf->next;
+
+			pr_debug("%s: free buffer %p, next %p\n",
+			       __func__, buf, buf->next);
+
+			sw_dma_buffdone(chan, buf, SW_RES_ABORT);
+			sw_dma_freebuf(buf);
+		}
+	}
+
+	dbg_showregs(chan);
+
+	sw_dma_waitforstop(chan);
+
+	dbg_showregs(chan);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int sw_dma_started(struct sw_dma_chan *chan)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	dbg_showchan(chan);
+
+	/* if we've only loaded one buffer onto the channel, then chec
+	 * to see if we have another, and if so, try and load it so when
+	 * the first buffer is finished, the new one will be loaded onto
+	 * the channel */
+
+	if (chan->next != NULL) {
+		if (chan->load_state == SW_DMALOAD_1LOADED) {
+
+			if (sw_dma_waitforload(chan, __LINE__) == 0) {
+				pr_debug("%s: buff not yet loaded, no more todo\n",
+					 __func__);
+			} else {
+	            pr_debug("L%d, loadstate %d -> SW_DMALOAD_NONE\n", __LINE__, chan->load_state);
+				chan->load_state = SW_DMALOAD_1RUNNING;
+				sw_dma_loadbuffer(chan, chan->next);
+			}
+
+		} else if (chan->load_state == SW_DMALOAD_1RUNNING) {
+			sw_dma_loadbuffer(chan, chan->next);
+		}
+	}
+
+
+	local_irq_restore(flags);
+
+	return 0;
+
+}
+
+int sw_dma_ctrl(unsigned int channel, enum sw_chan_op op)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	switch (op) {
+	case SW_DMAOP_START:
+		return sw_dma_start(chan);
+
+	case SW_DMAOP_STOP:
+		return sw_dma_dostop(chan);
+
+	case SW_DMAOP_PAUSE:
+	case SW_DMAOP_RESUME:
+		return -ENOENT;
+
+	case SW_DMAOP_FLUSH:
+		return sw_dma_flush(chan);
+
+	case SW_DMAOP_STARTED:
+		return sw_dma_started(chan);
+
+	case SW_DMAOP_TIMEOUT:
+		return 0;
+
+	}
+
+	return -ENOENT;      /* unknown, don't bother */
+}
+
+EXPORT_SYMBOL(sw_dma_ctrl);
+
+/* DMA configuration for each channel
+ *
+ * DISRCC -> source of the DMA (AHB,APB)
+ * DISRC  -> source address of the DMA
+ * DIDSTC -> destination of the DMA (AHB,APD)
+ * DIDST  -> destination address of the DMA
+*/
+
+/* sw_dma_config
+ *
+ * x:            transfer unit type
+ * dir:          1 - to dev / 0 - from dev
+ * dcon:         base value of the DCONx register
+*/
+
+int sw_dma_config(unsigned int channel, struct dma_hw_conf* user_conf)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	struct dma_hw_conf* hw_conf;
+	volatile unsigned long temp, dcon = 0;
+	unsigned char drqdst, drqsrc;
+
+	pr_debug("%s: chan=%p, user_conf=%p\n", __func__, chan, user_conf);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	if(user_conf){
+		pr_debug("%s: user_conf is used.\n", __func__);
+		DMA_COPY_HW_CONF(&(chan->map->user_hw_conf), user_conf);
+		hw_conf = chan->map->conf_ptr = &(chan->map->user_hw_conf);
+	} else {
+		hw_conf = chan->map->conf_ptr = (struct dma_hw_conf*)chan->map->default_hw_conf;
+	}
+
+	switch (hw_conf->dir) {
+		case SW_DMA_RDEV:
+			if(IS_DADECATE_DMA(chan)) {
+				drqsrc = d_drqsrc_arr[hw_conf->drqsrc_type];
+				drqdst = D_DRQDST_SDRAM;
+			}
+			else {
+
+				drqsrc = n_drqsrc_arr[hw_conf->drqsrc_type];
+				drqdst = N_DRQDST_SDRAM;
+			}
+
+			chan->addr_reg = dma_regaddr(chan, SW_DMA_DDST);
+			dma_wrreg(chan, SW_DMA_DSRC,  hw_conf->from);
+			break;
+
+		case SW_DMA_WDEV:
+			if(IS_DADECATE_DMA(chan)) {
+				drqdst = d_drqdst_arr[hw_conf->drqdst_type];
+				drqsrc = D_DRQSRC_SDRAM;
+			}
+			else {
+				drqdst = n_drqdst_arr[hw_conf->drqdst_type];
+				drqsrc = N_DRQSRC_SDRAM;
+			}
+
+			chan->addr_reg = dma_regaddr(chan, SW_DMA_DSRC);
+			dma_wrreg(chan, SW_DMA_DDST,  hw_conf->to);
+			break;
+
+		case SW_DMA_M2M:
+			if(IS_DADECATE_DMA(chan)) {
+				drqdst = d_drqdst_arr[hw_conf->drqdst_type];
+				drqsrc = D_DRQSRC_SDRAM;
+			}
+			else {
+				drqdst = n_drqdst_arr[hw_conf->drqdst_type];
+				drqsrc = N_DRQSRC_SDRAM;
+			}
+
+			chan->addr_reg = dma_regaddr(chan, SW_DMA_DSRC);
+			dma_wrreg(chan, SW_DMA_DDST,  hw_conf->to);
+			break;
+
+		default:
+			printk(KERN_ERR "dma %s: invalid r/w direction (%x)\n",chan->map->name, hw_conf->dir);
+			return -EINVAL;
+	}
+
+	if (drqsrc == DRQ_INVALID || drqdst == DRQ_INVALID){
+		printk(KERN_ERR "dma %s: invalid drq type\n",chan->map->name);
+		return -EINVAL;
+	}
+
+	if(IS_DADECATE_DMA(chan))
+		dcon |= drqsrc << D_DRQSRC_SHIFT | drqdst << D_DRQDST_SHIFT;
+	else
+		dcon |= drqsrc << N_DRQSRC_SHIFT | drqdst << N_DRQDST_SHIFT;
+
+	dcon |= xfer_arr[hw_conf->xfer_type];
+	dcon |= addrtype_arr[hw_conf->address_type];
+	if(IS_DADECATE_DMA(chan)){
+		dcon |= hw_conf->reload ? SW_DDMA_CONF_CONTI : 0;
+	}
+	else{
+		dcon |= hw_conf->reload ? SW_NDMA_CONF_CONTI : 0;
+	}
+	dcon |= (1 << 15);   //backdoor: byte counter register shows the remain bytes for transfer
+	chan->dcon = dcon;
+
+	if( hw_conf->hf_irq < 2 ){
+		printk(KERN_ERR "irq type is not suppoted yet.\n");
+		return -EINVAL;
+	}
+
+	temp = readl(dma_base + SW_DMA_DIRQEN);
+	temp &= ~(3 << (chan->number<<1));
+	temp |= hw_conf->hf_irq << (chan->number<<1);
+	writel(temp, dma_base + SW_DMA_DIRQEN);
+
+	if( IS_DADECATE_DMA(chan)){
+		dma_wrreg(chan, SW_DMA_DCMBK,  hw_conf->cmbk);
+	}
+
+	dbg_showchan(chan);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_config);
+
+int sw_dma_setflags(unsigned int channel, unsigned int flags)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+//	pr_debug("%s: chan=%p, flags=%08x\n", __func__, chan, flags);
+
+	chan->flags = flags;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_setflags);
+
+
+/* do we need to protect the settings of the fields from
+ * irq?
+*/
+
+int sw_dma_set_opfn(unsigned int channel, sw_dma_opfn_t rtn)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, op rtn=%p\n", __func__, chan, rtn);
+
+	chan->op_fn = rtn;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_set_opfn);
+
+int sw_dma_set_buffdone_fn(unsigned int channel, sw_dma_cbfn_t rtn)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, callback rtn=%p\n", __func__, chan, rtn);
+
+	chan->callback_fn = rtn;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_set_buffdone_fn);
+
+int sw_dma_set_halfdone_fn(unsigned int channel, sw_dma_cbfn_t rtn)
+{
+	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	chan->callback_hd = rtn;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_set_halfdone_fn);
+
+/* sw_dma_getposition
+ *
+ * returns the current transfer points for the dma source and destination
+*/
+
+int sw_dma_getposition(unsigned int channel, dma_addr_t *src, dma_addr_t *dst)
+{
+ 	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	dma_addr_t s,d;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	s = dma_rdreg(chan, SW_DMA_DSRC);
+	d = dma_rdreg(chan, SW_DMA_DDST);
+
+	if( chan->map->conf_ptr->dir == SW_DMA_RDEV ){
+		*src = s;
+		*dst = d;
+	} else {
+		*src = s;
+		*dst = d;
+	}
+
+ 	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_getposition);
+
+int sw_dma_getcurposition(unsigned int channel, dma_addr_t *src, dma_addr_t *dst)
+{
+ 	struct sw_dma_chan *chan = lookup_dma_channel(channel);
+	//dma_addr_t s,d,count,countleft;
+	dma_addr_t s,d,count;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	s = dma_rdreg(chan, SW_DMA_DSRC);
+	d = dma_rdreg(chan, SW_DMA_DDST);
+	count = dma_rdreg(chan, SW_DMA_DCNT);
+
+	/* FIXME: check */
+#if 0
+	temp = dma_rdreg(chan, SW_DMA_DCONF);
+	temp |= (1<<15);
+	dma_wrreg(chan, SW_DMA_DCONF, temp);
+#endif
+
+	//countleft = dma_rdreg(chan, SW_DMA_DCNT);
+
+#if 0
+	temp = dma_rdreg(chan, SW_DMA_DCONF);
+	temp &= ~(1<<15);
+	dma_wrreg(chan, SW_DMA_DCONF, temp);
+#endif
+
+        //printk("src = %x, count = %x , countleft = %x\n",s,count,countleft);
+	//*src = s + (count - countleft);
+	*src = s - count;
+	*dst = d - count;
+
+
+ 	return 0;
+}
+
+EXPORT_SYMBOL(sw_dma_getcurposition);
+
+/* kmem cache implementation */
+
+static void sw_dma_cache_ctor(void *p)
+{
+	memset(p, 0, sizeof(struct sw_dma_buf));
+}
+
+/* initialisation code */
+
+int __devinit sw_dma_init(unsigned int channels, unsigned int irq,
+			    unsigned int stride)
+{
+	struct sw_dma_chan *cp;
+	int channel;
+	int ret;
+
+	printk("SOFTWINNER DMA Driver, (c) 2003-2004,2006 Simtec Electronics\n");
+
+	dma_channels = channels;
+	//dma_base = ioremap(SOFTWINNER_DMA_BASE, 4096);
+	dma_base = (void __iomem *)SW_VA_DMAC_IO_BASE;
+	dma_kmem = kmem_cache_create("dma_desc", sizeof(struct sw_dma_buf), 0,
+				     SLAB_HWCACHE_ALIGN, sw_dma_cache_ctor);
+
+	if (dma_kmem == NULL) {
+		printk(KERN_ERR "dma failed to make kmem cache\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	/* Disable & clear all interrupts */
+	//writel(0x0, SW_VA_DMAC_IO_BASE);
+	writel(0x0, dma_base);
+	//writel(0xffffffff, SW_VA_DMAC_IO_BASE + 0x4);
+	writel(0xffffffff, dma_base + 0x4);
+
+	writel(1<<16, dma_base + 0x8);
+	pr_debug("%s,%d,%x,%p\n",__func__,__LINE__,*(volatile int *)(dma_base + 0x8),dma_base + 0x8);
+	for (channel = 0; channel < channels;  channel++) {
+		cp = &sw_chans[channel];
+
+		memset(cp, 0, sizeof(struct sw_dma_chan));
+
+		cp->number = channel;
+
+		if ((channel & 0xff) < 8) {
+			cp->regs   = dma_base + 0x100 + (channel * stride);
+		} else {
+			cp->regs   = dma_base + 0x300 + ((channel - 8) * stride);
+		}
+
+		writel(0x0, cp->regs);
+		writel(0x0, cp->regs + 0x4);
+		writel(0x0, cp->regs + 0x8);
+		writel(0x0, cp->regs + 0xc);
+
+		dma_wrreg(cp, SW_DMA_DCONF, 0);
+
+		/* point current stats somewhere */
+		cp->stats  = &cp->stats_store;
+		cp->stats_store.timeout_shortest = LONG_MAX;
+
+		/* basic channel configuration */
+
+		cp->load_timeout = 1<<18;
+	}
+
+	ret = request_irq(irq, sw_dma_irq, IRQF_DISABLED,
+			  "dma_irq", dma_base + SW_DMA_DIRQPD);
+	if(ret) {
+		pr_err("Failed to require irq for DMA at %d\n", irq);
+		goto err;
+	}
+
+	return 0;
+
+ err:
+	kmem_cache_destroy(dma_kmem);
+ err2:
+	dma_base = NULL;
+	return ret;
+}
+
+int __devinit sw15_dma_init(void)
+{
+	return sw_dma_init(SW_DMA_CHANNELS, SW_INT_IRQNO_DMA, 0x20);
+}
+
+static inline int is_channel_valid(unsigned int channel)
+{
+	return (channel & DMA_CH_VALID);
+}
+
+
+/* sw_dma_map_channel()
+ *
+ * turn the virtual channel number into a real, and un-used hardware
+ * channel.
+ *
+ * first, try the dma ordering given to us by either the relevant
+ * dma code, or the board. Then just find the first usable free
+ * channel
+*/
+
+static struct sw_dma_chan *sw_dma_map_channel(int channel)
+{
+	struct sw_dma_map *ch_map;
+	struct sw_dma_chan *dmach;
+	int ch;
+
+	if (dma_sel.map == NULL || channel > dma_sel.map_size)
+		return NULL;
+
+	ch_map = dma_sel.map + channel;
+
+	for (ch = 0; ch < dma_channels; ch++) {
+		if (!is_channel_valid(ch_map->channels[ch]))
+			continue;
+
+		if (sw_chans[ch].in_use == 0) {
+			break;
+		}
+	}
+
+	if (ch >= dma_channels)
+		return NULL;
+
+	/* update our channel mapping */
+
+	dmach = &sw_chans[ch];
+	dmach->map = ch_map;
+	dma_chan_map[channel] = dmach;
+
+	return dmach;
+}
+
+static int sw_dma_check_entry(struct sw_dma_map *map, int ch)
+{
+	return 0;
+}
+
+int __devinit sw_dma_init_map(struct sw_dma_selection *sel)
+{
+	struct sw_dma_map *nmap;
+	size_t map_sz = sizeof(*nmap) * sel->map_size;
+	int ptr;
+
+	nmap = kmalloc(map_sz, GFP_KERNEL);
+	if (nmap == NULL)
+		return -ENOMEM;
+
+	memcpy(nmap, sel->map, map_sz);
+	memcpy(&dma_sel, sel, sizeof(*sel));
+
+	dma_sel.map = nmap;
+
+	for (ptr = 0; ptr < sel->map_size; ptr++) {
+		sw_dma_check_entry(nmap+ptr, ptr);
+	}
+
+	return 0;
+}
+
+static struct sw_dma_selection __refdata sw_dma_sel = {
+	.dcon_mask	= 0xffffffff,
+	.map		= sw_dma_mappings,
+	.map_size	= ARRAY_SIZE(sw_dma_mappings),
+};
+
+static int __devinit sw_dmac_probe(struct platform_device *dev)
+{
+	int ret;
+
+	sw15_dma_init();
+
+	ret = sw_dma_init_map(&sw_dma_sel);
+
+	if (ret) {
+		early_printk("DMAC: failed to init map\n");
+	} else {
+		pr_info("Initialize DMAC OK\n");
+	}
+
+	return ret;
+}
+static int __devexit sw_dmac_remove(struct platform_device *dev)
+{
+        early_printk("[%s] enter\n", __FUNCTION__);
+        return 0;
+}
+static int sw_dmac_suspend(struct platform_device *dev, pm_message_t state)
+{
+        early_printk("[%s] enter\n", __FUNCTION__);
+        return 0;
+}
+
+static int sw_dmac_resume(struct platform_device *dev)
+{
+        early_printk("[%s] enter\n", __FUNCTION__);
+        return 0;
+}
+
+static struct platform_driver sw_dmac_driver = {
+        .probe          = sw_dmac_probe,
+        .remove         = __devexit_p(sw_dmac_remove),
+        .suspend        = sw_dmac_suspend,
+        .resume         = sw_dmac_resume,
+        .driver         = {
+                .name   = "sw_dmac",
+                .owner  = THIS_MODULE,
+        },
+};
+
+static int __init sw_dma_drvinit(void)
+{
+        platform_driver_register(&sw_dmac_driver);
+	return 0;
+}
+
+arch_initcall(sw_dma_drvinit);
diff --git a/arch/arm/plat-sunxi/dma_regs.h b/arch/arm/plat-sunxi/dma_regs.h
new file mode 100644
index 0000000..c2d73b3
--- /dev/null
+++ b/arch/arm/plat-sunxi/dma_regs.h
@@ -0,0 +1,107 @@
+/*
+ * arch/arm/mach-sun5i/dma/dma_regs.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _DMA_REGS_
+#define _DMA_REGS_
+
+/* DMA */
+#define SOFTWINNER_DMA_BASE             0x01c02000
+
+/* DMA Register definitions */
+#define SW_DMA_DIRQEN      		(0x0000)	//	DMA_IRQ_EN_REG(0x0000)
+#define SW_DMA_DIRQPD      		(0x0004)	//	DMA_IRQ_PEND_STA_REG(0x0004)
+#define SW_DMA_DCONF       		(0x00)		//	NDMA_CTRL_REG(0x100+N*0x20) and DDMA_CFG_REG(0x300+N*0x20) config
+#define SW_DMA_DSRC        		(0x04)		//	NDMA_SRC_ADDR_REG(0x100+N*0x20+4) and DDMA_SRC_START_ADDR_REG(0x300+N*0x20+4)
+#define SW_DMA_DDST        		(0x08)		//	NDMA_DEST_ADDR_REG(0x100+N*0x20+8) and DDMA_DEST_START_ADDR_REG(0x300+N*0x20+8)
+#define SW_DMA_DCNT        		(0x0C)		//	NDMA_BC_REG(0x100+N*0x20+C) and DDMA_BC_REG(0x300+N*0x20+C)
+
+/* For F23: DDMA parameter register */
+#define SW_DMA_DCMBK       		(0x18)		//	DDMA_PARA_REG(0x300+N*0x20+0x18)
+
+/* For F23: NDMA and DDMA */
+#define SW_DCONF_LOADING	   	(1<<31)		// 	DMA Loading 				have used
+
+/*NDMA Configuration Register*/
+#define SW_NDMA_CONF_CONTI   	(1<<30)		// 	DMA Continuous Mode			have used
+#define SW_NDMA_CONF_WAIT  		(7<<27)		// 	DMA Wait Status				not used yet
+#define SW_NDMA_CONF_DSTDW 		(3<<25)		// 	destination data width		not used yet
+#define SW_NDMA_CONF_DWBYTE    	(0<<25)		//	8-Bit						not used yet
+#define SW_NDMA_CONF_DWHWORD   	(1<<25)		//	16-Bit						not used yet
+#define SW_NDMA_CONF_DWWORD    	(2<<25)		//	32-Bit						not used yet
+#define SW_NDMA_CONF_DSTBL 		(3<<23) 	//	destination burst lenght	not used yet
+#define SW_NDMA_CONF_DSTBL0 	(0<<23)		//	1							not used yet
+#define SW_NDMA_CONF_DSTBL1 	(1<<23)		//	4							not used yet
+#define SW_NDMA_CONF_DSTBL2 	(2<<23)		//	8							not used yet
+#define SW_NDMA_CONF_DSTSEC 	(1<<22)		//	DMA Destination Secutity	not used yet
+#define SW_NDMA_CONF_DSTAT 		(1<<21)    	// 	destination address type	not used yet
+#define SW_NDMA_CONF_DSTTP 		(31<<16)    //	destination DRQ type		not used yet
+
+#define SW_NDMA_CONF_SRCDW 		(3<<9)		//	source data width			not used yet
+#define SW_NDMA_CONF_SWBYTE    	(0<<9)		//	8-Bit						not used yet
+#define SW_NDMA_CONF_SWHWORD   	(1<<9)		//	16-Bit						not used yet
+#define SW_NDMA_CONF_SWWORD    	(2<<9)		//	32-Bit						not used yet
+#define SW_NDMA_CONF_SRCBL 		(3<<7)		//	source burst lenght			not used yet
+#define SW_NDMA_CONF_SRCBL0 	(0<<7)		//	1							not used yet
+#define SW_NDMA_CONF_SRCBL1 	(1<<7)		//	4							not used yet
+#define SW_NDMA_CONF_SRCBL2 	(2<<7)		//	8							not used yet
+#define SW_NDMA_CONF_SRCSEC 	(1<<6)		//	DMA Source Secutity			not used yet
+#define SW_NDMA_CONF_SRCAT 		(1<<5)		//	source address type			not used yet
+#define SW_NDMA_CONF_SRCTP 		(31<<0)		//	normal source DRQ type		not used yet
+
+/*DDMA Configuration Register*/
+#define SW_DDMA_CONF_BUSY   	(1<<30)		// 	DMA BUSY Mode				not used yet
+#define SW_DDMA_CONF_CONTI   	(1<<29)		// 	DMA Continuous Mode			have used
+#define SW_DDMA_CONF_DSEC  		(1<<28)		// 	DMA Destination Security	not used yet
+#define SW_DDMA_CONF_DSTDW 		(3<<25)		// 	destination data width		not used yet
+#define SW_DDMA_CONF_DWBYTE    	(0<<25)		//	8-Bit						not used yet
+#define SW_DDMA_CONF_DWHWORD   	(1<<25)		//	16-Bit						not used yet
+#define SW_DDMA_CONF_DWWORD    	(2<<25)		//	32-Bit						not used yet
+#define SW_DDMA_CONF_DSTBL 		(3<<23) 	//	destination burst lenght	not used yet
+#define SW_DDMA_CONF_DSTBL0 	(0<<23)		//	1							not used yet
+#define SW_DDMA_CONF_DSTBL1 	(1<<23)		//	4							not used yet
+#define SW_DDMA_CONF_DSTBL2 	(2<<23)		//	8							not used yet
+#define SW_DDMA_CONF_DSTADDR	(3<<21)    	// 	destination address type	not used yet
+#define SW_DDMA_CONF_DSTADDR0	(0<<21)		//	Linear Mode					not used yet
+#define SW_DDMA_CONF_DSTADDR1	(1<<21)		//	IO Mode						not used yet
+#define SW_DDMA_CONF_DSTADDR2	(2<<21)		//	Horizontal Page Mode		not used yet
+#define SW_DDMA_CONF_DSTADDR3	(3<<21)		//	Vertical Page Mode			not used yet
+#define SW_DDMA_CONF_DSTTP 		(31<<16)    //	destination DRQ type		not used yet
+
+#define SW_DDMA_CONF_BC			(1<<15)		//	BC mode select				not used yet
+#define SW_DDMA_CONF_SSEC		(1<<12)		//	DMA Source Security			not used yet
+#define SW_NDMA_CONF_SRCDW 		(3<<9)		//	source data width			not used yet
+#define SW_NDMA_CONF_SWBYTE    	(0<<9)		//	8-Bit						not used yet
+#define SW_NDMA_CONF_SWHWORD   	(1<<9)		//	16-Bit						not used yet
+#define SW_NDMA_CONF_SWWORD    	(2<<9)		//	32-Bit						not used yet
+#define SW_NDMA_CONF_SRCBL 		(3<<7)		//	source burst lenght			not used yet
+#define SW_NDMA_CONF_SRCBL0 	(0<<7)		//	1							not used yet
+#define SW_NDMA_CONF_SRCBL1 	(1<<7)		//	4							not used yet
+#define SW_NDMA_CONF_SRCBL2 	(2<<7)		//	8							not used yet
+#define SW_NDMA_CONF_SRCADDR 	(3<<5)		//	DMA Source Address Mode		not used yet
+#define SW_NDMA_CONF_SRCADDR0 	(0<<5)		//	Linear Mode					not used yet
+#define SW_NDMA_CONF_SRCADDR1 	(1<<5)		//	IO Mode						not used yet
+#define SW_NDMA_CONF_SRCADDR2 	(2<<5)		//	Horizontal Page Mode		not used yet
+#define SW_NDMA_CONF_SRCADDR3 	(3<<5)		//	Vertical Page Mode			not used yet
+#define SW_NDMA_CONF_SRCTP 		(31<<0)		//	normal source DRQ type		not used yet
+
+#endif    // #ifndef _DMA_REGS_
diff --git a/arch/arm/plat-sunxi/dma_route_sun4i.h b/arch/arm/plat-sunxi/dma_route_sun4i.h
new file mode 100644
index 0000000..669a2ae
--- /dev/null
+++ b/arch/arm/plat-sunxi/dma_route_sun4i.h
@@ -0,0 +1,519 @@
+/*
+ * sun4i accepted dma routes
+ * dma private header
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ * (C) Copyright 2013
+ * Alexsey Shestacov <wingrimen@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __DMA_ROUTES__
+#define __DMA_ROUTES__
+#include <plat/dma.h>
+#include <plat/dma_defs.h>
+
+static struct sw_dma_map __initdata sw_dma_mappings[DMACH_MAX] = {
+	[DMACH_NSPI0] = {
+		.name		= "spi0",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSPI1] = {
+		.name		= "spi1",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+				0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSPI2] = {
+		.name		= "spi2",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSPI3] = {
+		.name		= "spi3",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART0] = {
+		.name		= "uart0",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART1] = {
+		.name		= "uart1",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART2] = {
+		.name		= "uart2",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART3] = {
+		.name		= "uart3",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART4] = {
+		.name		= "uart4",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART5] = {
+		.name		= "uart5",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART6] = {
+		.name		= "uart6",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART7] = {
+		.name		= "uart7",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSRAM] = {
+		.name		= "nsram",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,0,0,0,0,0,0,0,0},
+	},
+	[DMACH_NSDRAM] = {
+		.name		= "nsdram",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,0,0,0,0,0,0,0,0},
+	},
+	[DMACH_NTPAD] = {
+		.name		= "tpadc",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,0,0,0,0,0,0,0,0},
+	},
+	[DMACH_NADDA_PLAY] = {
+		.name		= "adda_play",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+				0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NADDA_CAPTURE] = {
+		.name		= "adda_capture",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+				0,0,0,0,0,0,0,0,},
+	},
+  	[DMACH_NIIS] = {
+		.name		= "iis",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NIR0] = {
+		.name		= "ir0",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NIR1] = {
+		.name		= "ir1",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSPDIF] = {
+		.name		= "spdif",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NAC97] = {
+		.name		= "ac97",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NHDMI] = {
+		.name		= "hdmi",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_DSRAM] = {
+		.name		= "dsram",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSDRAM] = {
+		.name		= "dsdram",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DPATA] = {
+		.name		= "dpata",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+		},
+	[DMACH_DNAND] = {
+		.name		= "dnand",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DUSB0] = {
+		.name		= "usb0",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DEMACR] = {
+		.name		= "EMACRX_DMA",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DEMACT] = {
+		.name		= "EMACTX_DMA",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSSR] = {
+		.name		= "dssr",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSST] = {
+		.name		= "dsst",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_TCON0] = {
+		.name		= "tcon0",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_TCON1] = {
+		.name		= "tcon1",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_HDMIAUDIO] = {
+		.name		= "hdmiaudio",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DMS] = {
+		.name		= "dms",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI0_TX] = {
+		.name		= "dspi0_tx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI0_RX] = {
+		.name		= "dspi0_rx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI1_TX] = {
+		.name		= "dspi1_tx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI1_RX] = {
+		.name		= "dspi1_rx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI2_TX] = {
+		.name		= "dspi2_tx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI2_RX] = {
+		.name		= "dspi2_rx",
+ 		.channels = {0,0,0,0,0,0,0,0,
+ 			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+ 	},
+	[DMACH_DSPI3_TX] = {
+		.name		= "dspi3_tx",
+ 		.channels = {0,0,0,0,0,0,0,0,
+ 			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+ 	},
+	[DMACH_DSPI3_RX] = {
+		.name		= "dspi3_rx",
+ 		.channels = {0,0,0,0,0,0,0,0,
+ 			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+ 	},
+};
+
+
+unsigned long xfer_arr[DMAXFER_MAX]={
+	/*des:X_SIGLE  src:X_SIGLE*/
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/*des:X_SIGLE   src:X_BURST*/
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+
+	/*des:X_SIGLE   src:X_TIPPL*/
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/*des:X_BURST  src:X_BURST*/
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+
+	/*des:X_BURST   src:X_SIGLE*/
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/*des:X_BURST   src:X_TIPPL*/
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/*des:X_TIPPL   src:X_TIPPL*/
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/*des:X_TIPPL   src:X_SIGLE*/
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/*des:X_TIPPL   src:X_BURST*/
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+};
+
+unsigned long addrtype_arr[DMAADDRT_MAX]={
+	(A_INC << 21) | (A_INC << 5),
+	(A_INC << 21) | (A_FIX << 5),
+	(A_FIX << 21) | (A_INC << 5),
+	(A_FIX << 21) | (A_FIX << 5),
+
+	(A_LN  << 21) | (A_LN  << 5),
+	(A_LN  << 21) | (A_IO  << 5),
+	(A_LN  << 21) | (A_PH  << 5),
+	(A_LN  << 21) | (A_PV  << 5),
+
+	(A_IO  << 21) | (A_LN  << 5),
+	(A_IO  << 21) | (A_IO  << 5),
+	(A_IO  << 21) | (A_PH  << 5),
+	(A_IO  << 21) | (A_PV  << 5),
+
+	(A_PH  << 21) | (A_LN  << 5),
+	(A_PH  << 21) | (A_IO  << 5),
+	(A_PH  << 21) | (A_PH  << 5),
+	(A_PH  << 21) | (A_PV  << 5),
+
+	(A_PV  << 21) | (A_LN  << 5),
+	(A_PV  << 21) | (A_IO  << 5),
+	(A_PV  << 21) | (A_PH  << 5),
+	(A_PV  << 21) | (A_PV  << 5),
+};
+
+unsigned long n_drqsrc_arr[DRQ_TYPE_MAX]={
+	N_DRQSRC_SRAM,       		//DRQ_TYPE_SRAM
+	N_DRQSRC_SDRAM,      		//DRQ_TYPE_SDRAM
+	DRQ_INVALID, 	  			//DRQ_TYPE_PATA,
+	DRQ_INVALID,         		//DRQ_TYPE_NAND,
+	DRQ_INVALID,         		//DRQ_TYPE_USB0,
+	DRQ_INVALID,         		//DRQ_TYPE_EMAC,
+	N_DRQSRC_SPI1RX,         	//DRQ_TYPE_SPI1,
+	DRQ_INVALID,         		//DRQ_TYPE_SS,
+	DRQ_INVALID,         		//DRQ_TYPE_MS,
+	N_DRQSRC_SPI0RX,       		//DRQ_TYPE_SPI0,
+	N_DRQSRC_SPI2RX,       		//DRQ_TYPE_SPI2,
+	N_DRQSRC_SPI3RX,       		//DRQ_TYPE_SPI3,
+	DRQ_INVALID,				//DRQ_TYPE_TCON0
+	DRQ_INVALID,				//DRQ_TYPE_TCON1
+	N_DRQSRC_HDMIDDCRX,			//DRQ_TYPE_HDMI
+	DRQ_INVALID,				//DRQ_TYPE_HDMIAUDIO
+
+	N_DRQSRC_IR0RX,       		//DRQ_TYPE_IR0,
+	N_DRQSRC_IR1RX,    			//DRQ_TYPE_IR1,
+	N_DRQSRC_SPDIFRX,      		//DRQ_TYPE_SPDIF,
+	N_DRQSRC_IISRX,     		//DRQ_TYPE_IIS,
+	N_DRQSRC_AC97RX,     		//DRQ_TYPE_AC97,
+	N_DRQSRC_UART0RX,     		//DRQ_TYPE_UART0,
+	N_DRQSRC_UART1RX,			//DRQ_TYPE_UART1
+	N_DRQSRC_UART2RX,    		//DRQ_TYPE_UART2,
+	N_DRQSRC_UART3RX,    		//DRQ_TYPE_UART3,
+	N_DRQSRC_UART4RX,    		//DRQ_TYPE_UART4,
+	N_DRQSRC_UART5RX,    		//DRQ_TYPE_UART5,
+	N_DRQSRC_UART6RX,    		//DRQ_TYPE_UART6,
+	N_DRQSRC_UART7RX,       	//DRQ_TYPE_UART7,
+	N_DRQSRC_AUDIOCDAD,    		//DRQ_TYPE_AUDIO,
+	N_DRQSRC_TPAD,	    		//DRQ_TYPE_TPAD
+};
+
+unsigned long n_drqdst_arr[DRQ_TYPE_MAX]={
+	N_DRQDST_SRAM,       	//DRQ_TYPE_SRAM
+	N_DRQDST_SDRAM,      	//DRQ_TYPE_SDRAM
+	DRQ_INVALID, 	  		//DRQ_TYPE_PATA,
+	DRQ_INVALID,         	//DRQ_TYPE_NAND,
+	DRQ_INVALID,         	//DRQ_TYPE_USB0,
+	DRQ_INVALID,         	//DRQ_TYPE_EMAC,
+	N_DRQDST_SPI1TX,       	//DRQ_TYPE_SPI1,
+	DRQ_INVALID,         	//DRQ_TYPE_SS,
+	DRQ_INVALID,         	//DRQ_TYPE_MS,
+	N_DRQDST_SPI0TX,       	//DRQ_TYPE_SPI0,
+	N_DRQDST_SPI2TX,       	//DRQ_TYPE_SPI2,
+	N_DRQDST_SPI3TX,       	//DRQ_TYPE_SPI3,
+	DRQ_INVALID,			//DRQ_TYPE_TCON0
+	DRQ_INVALID,			//DRQ_TYPE_TCON1
+	N_DRQDST_HDMIDDCTX,		//DRQ_TYPE_HDMI
+	DRQ_INVALID,			//DRQ_TYPE_HDMIAUDIO
+
+	N_DRQDST_IR0TX,       	//DRQ_TYPE_IR0,
+	N_DRQDST_IR1TX,    		//DRQ_TYPE_IR1,
+	N_DRQDST_SPDIFTX,      	//DRQ_TYPE_SPDIF,
+	N_DRQDST_IISTX,     	//DRQ_TYPE_IIS,
+	N_DRQDST_AC97TX,     	//DRQ_TYPE_AC97,
+	N_DRQDST_UART0TX,     	//DRQ_TYPE_UART0,
+	N_DRQDST_UART1TX,		//DRQ_TYPE_UART1,
+	N_DRQDST_UART2TX,    	//DRQ_TYPE_UART2,
+	N_DRQDST_UART3TX,    	//DRQ_TYPE_UART3,
+	N_DRQDST_UART4TX,    	//DRQ_TYPE_UART4,
+	N_DRQDST_UART5TX,    	//DRQ_TYPE_UART5,
+	N_DRQDST_UART6TX,    	//DRQ_TYPE_UART6,
+	N_DRQDST_UART7TX,       //DRQ_TYPE_UART7,
+	N_DRQDST_AUDIOCDAD,    	//DRQ_TYPE_AUDIO,
+	DRQ_INVALID,	    	//DRQ_TYPE_TPAD
+};
+
+unsigned long d_drqsrc_arr[DRQ_TYPE_MAX]={
+	D_DRQSRC_SRAM,       	//DRQ_TYPE_SRAM
+	D_DRQSRC_SDRAM,      	//DRQ_TYPE_SDRAM
+	D_DRQSRC_PATA, 	  		//DRQ_TYPE_PATA,
+	D_DRQSRC_NAND,         	//DRQ_TYPE_NAND,
+	D_DRQSRC_USB0,         	//DRQ_TYPE_USB0,
+	D_DRQSRC_EMACRX,       	//DRQ_TYPE_EMAC,
+	D_DRQSRC_SPI1RX,       	//DRQ_TYPE_SPI1,
+	D_DRQSRC_SECRX,       	//DRQ_TYPE_SS,
+	D_DRQSRC_MS,         	//DRQ_TYPE_MS,
+	D_DRQSRC_SPI0RX,       	//DRQ_TYPE_SPI0,
+	D_DRQSRC_SPI2RX,       	//DRQ_TYPE_SPI2,
+	D_DRQSRC_SPI3RX,       	//DRQ_TYPE_SPI3,
+	DRQ_INVALID,			//DRQ_TYPE_TCON0,
+	DRQ_INVALID,			//DRQ_TYPE_TCON1,
+	DRQ_INVALID,			//DRQ_TYPE_HDMI,
+	DRQ_INVALID,			//DRQ_TYPE_HDMIAUDIO
+
+	DRQ_INVALID,       		//DRQ_TYPE_IR0,
+	DRQ_INVALID,    		//DRQ_TYPE_IR1,
+	DRQ_INVALID,      		//DRQ_TYPE_SPDIF,
+	DRQ_INVALID,     		//DRQ_TYPE_IIS,
+	DRQ_INVALID,     		//DRQ_TYPE_AC97,
+	DRQ_INVALID,     		//DRQ_TYPE_UART0,
+	DRQ_INVALID,			//DRQ_TYPE_UART1,
+	DRQ_INVALID,    		//DRQ_TYPE_UART2,
+	DRQ_INVALID,    		//DRQ_TYPE_UART3,
+	DRQ_INVALID,    		//DRQ_TYPE_UART4,
+	DRQ_INVALID,    		//DRQ_TYPE_UART5,
+	DRQ_INVALID,    		//DRQ_TYPE_UART6,
+	DRQ_INVALID,       		//DRQ_TYPE_UART7,
+	DRQ_INVALID,    		//DRQ_TYPE_AUDIO,
+	DRQ_INVALID,	    	//DRQ_TYPE_TPAD
+};
+unsigned long d_drqdst_arr[DRQ_TYPE_MAX]={
+	D_DRQDST_SRAM,       	//DRQ_TYPE_SRAM
+	D_DRQDST_SDRAM,      	//DRQ_TYPE_SDRAM
+	D_DRQDST_PATA, 	  		//DRQ_TYPE_PATA,
+	D_DRQDST_NAND,         	//DRQ_TYPE_NAND,
+	D_DRQDST_USB0,         	//DRQ_TYPE_USB0,
+	D_DRQDST_EMACTX,       	//DRQ_TYPE_EMAC,
+	D_DRQDST_SPI1TX,       	//DRQ_TYPE_SPI1,
+	D_DRQDST_SECTX,       	//DRQ_TYPE_SS,
+	D_DRQDST_MS,         	//DRQ_TYPE_MS,
+	D_DRQDST_SPI0TX,       	//DRQ_TYPE_SPI0,
+	D_DRQDST_SPI2TX,       	//DRQ_TYPE_SPI2,
+	D_DRQDST_SPI3TX,       	//DRQ_TYPE_SPI3,
+	DRQ_INVALID,			//DRQ_TYPE_TCON0,
+	DRQ_INVALID,			//DRQ_TYPE_TCON1,
+	DRQ_INVALID,			//DRQ_TYPE_HDMI,
+	D_DRQDST_HDMIAUDIO,		//DRQ_TYPE_HDMIAUDIO,
+
+	DRQ_INVALID,       		//DRQ_TYPE_IR0,
+	DRQ_INVALID,    		//DRQ_TYPE_IR1,
+	DRQ_INVALID,      		//DRQ_TYPE_SPDIF,
+	DRQ_INVALID,     		//DRQ_TYPE_IIS,
+	DRQ_INVALID,     		//DRQ_TYPE_AC97,
+	DRQ_INVALID,     		//DRQ_TYPE_UART0,
+	DRQ_INVALID,			//DRQ_TYPE_UART1,
+	DRQ_INVALID,    		//DRQ_TYPE_UART2,
+	DRQ_INVALID,    		//DRQ_TYPE_UART3,
+	DRQ_INVALID,    		//DRQ_TYPE_UART4,
+	DRQ_INVALID,    		//DRQ_TYPE_UART5,
+	DRQ_INVALID,    		//DRQ_TYPE_UART6,
+	DRQ_INVALID,       		//DRQ_TYPE_UART7,
+	DRQ_INVALID,    		//DRQ_TYPE_AUDIO,
+	DRQ_INVALID,	    	//DRQ_TYPE_TPAD
+
+};
+
+#endif  
diff --git a/arch/arm/plat-sunxi/dma_route_sun5i.h b/arch/arm/plat-sunxi/dma_route_sun5i.h
new file mode 100644
index 0000000..c65c77f
--- /dev/null
+++ b/arch/arm/plat-sunxi/dma_route_sun5i.h
@@ -0,0 +1,477 @@
+/*
+ * sun5i accepted dma routes
+ * dma private header
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ * (C) Copyright 2013
+ * Alexsey Shestacov <wingrimen@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __DMA_ROUTES__
+#define __DMA_ROUTES__
+#include <plat/dma_defs.h>
+
+
+static struct sw_dma_map __initdata sw_dma_mappings[DMACH_MAX] = {
+	[DMACH_NSPI0] = {
+		.name		= "spi0",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSPI1] = {
+		.name		= "spi1",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSPI2] = {
+		.name		= "spi2",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART0] = {
+		.name		= "uart0",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART1] = {
+		.name		= "uart1",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART2] = {
+		.name		= "uart2",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUART3] = {
+		.name		= "uart3",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSRAM] = {
+		.name		= "nsram",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,0,0,0,0,0,0,0,0},
+	},
+	[DMACH_NSDRAM] = {
+		.name		= "nsdram",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,0,0,0,0,0,0,0,0},
+	},
+	[DMACH_NTPAD] = {
+		.name		= "tpadc",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,0,0,0,0,0,0,0,0},
+	},
+	[DMACH_NADDA_PLAY] = {
+		.name		= "adda_play",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NADDA_CAPTURE] = {
+		.name		= "adda_capture",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+  	[DMACH_NIIS] = {
+		.name		= "iis",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NIIS_CAPTURE] = {
+		.name		= "iis_capture",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NIR] = {
+		.name		= "ir",
+		.channels = {DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NSPDIF] = {
+		.name		= "spdif",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NHDMI] = {
+		.name		= "hdmi",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUSBEP1] = {
+		.name		= "usbep1",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUSBEP2] = {
+		.name		= "usbep2",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUSBEP3] = {
+		.name		= "usbep3",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUSBEP4] = {
+		.name		= "usbep4",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_NUSBEP5] = {
+		.name		= "usbep5",
+		.channels = {DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,DMA_CH_VALID,
+			     0,0,0,0,0,0,0,0,},
+	},
+	[DMACH_DSRAM] = {
+		.name		= "dsram",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSDRAM] = {
+		.name		= "dsdram",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DNAND] = {
+		.name		= "dnand",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DUSB0] = {
+		.name		= "usb0",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DEMACR] = {
+		.name		= "EMACRX_DMA",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DEMACT] = {
+		.name		= "EMACTX_DMA",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSSR] = {
+		.name		= "dssr",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSST] = {
+		.name		= "dsst",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_TCON0] = {
+		.name		= "tcon0",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_HDMIAUDIO] = {
+		.name		= "hdmiaudio",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DMS] = {
+		.name		= "dms",
+		.channels = {0,0,0,0,0,0,0,0,
+			     DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI0_TX] = {
+		.name		= "dspi0_tx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI0_RX] = {
+		.name		= "dspi0_rx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI1_TX] = {
+		.name		= "dspi1_tx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI1_RX] = {
+		.name		= "dspi1_rx",
+		.channels = {0,0,0,0,0,0,0,0,
+			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+	},
+	[DMACH_DSPI2_TX] = {
+		.name		= "dspi2_tx",
+ 		.channels = {0,0,0,0,0,0,0,0,
+ 			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+ 	},
+	[DMACH_DSPI2_RX] = {
+		.name		= "dspi2_rx",
+ 		.channels = {0,0,0,0,0,0,0,0,
+ 			DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID, DMA_CH_VALID},
+ 	},
+};
+
+
+unsigned long xfer_arr[DMAXFER_MAX]={
+	/*des:X_SIGLE  src:X_SIGLE*/
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/*des:X_SIGLE   src:X_BURST*/
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+
+	/*des:X_SIGLE   src:X_TIPPL*/
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/*des:X_BURST  src:X_BURST*/
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+
+	/*des:X_BURST   src:X_SIGLE*/
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/*des:X_BURST   src:X_TIPPL*/
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/*des:X_TIPPL   src:X_TIPPL*/
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/*des:X_TIPPL   src:X_SIGLE*/
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/*des:X_TIPPL   src:X_BURST*/
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+};
+
+unsigned long addrtype_arr[DMAADDRT_MAX]={
+	(A_INC << 21) | (A_INC << 5),
+	(A_INC << 21) | (A_FIX << 5),
+	(A_FIX << 21) | (A_INC << 5),
+	(A_FIX << 21) | (A_FIX << 5),
+
+	(A_LN  << 21) | (A_LN  << 5),
+	(A_LN  << 21) | (A_IO  << 5),
+	(A_LN  << 21) | (A_PH  << 5),
+	(A_LN  << 21) | (A_PV  << 5),
+
+	(A_IO  << 21) | (A_LN  << 5),
+	(A_IO  << 21) | (A_IO  << 5),
+	(A_IO  << 21) | (A_PH  << 5),
+	(A_IO  << 21) | (A_PV  << 5),
+
+	(A_PH  << 21) | (A_LN  << 5),
+	(A_PH  << 21) | (A_IO  << 5),
+	(A_PH  << 21) | (A_PH  << 5),
+	(A_PH  << 21) | (A_PV  << 5),
+
+	(A_PV  << 21) | (A_LN  << 5),
+	(A_PV  << 21) | (A_IO  << 5),
+	(A_PV  << 21) | (A_PH  << 5),
+	(A_PV  << 21) | (A_PV  << 5),
+};
+
+unsigned long n_drqsrc_arr[DRQ_TYPE_MAX]={
+	N_DRQSRC_SRAM,       		//DRQ_TYPE_SRAM
+	N_DRQSRC_SDRAM,      		//DRQ_TYPE_SDRAM
+	DRQ_INVALID,         		//DRQ_TYPE_NAND
+	DRQ_INVALID,         		//DRQ_TYPE_USB0
+	DRQ_INVALID,         		//DRQ_TYPE_EMAC
+	N_DRQSRC_SPI1RX,         	//DRQ_TYPE_SPI1
+	DRQ_INVALID,         		//DRQ_TYPE_SS
+	DRQ_INVALID,         		//DRQ_TYPE_MS
+	N_DRQSRC_SPI0RX,       		//DRQ_TYPE_SPI0
+	N_DRQSRC_SPI2RX,       		//DRQ_TYPE_SPI2
+	DRQ_INVALID,				//DRQ_TYPE_TCON0
+	DRQ_INVALID,				//DRQ_TYPE_HDMIAUDIO
+	N_DRQSRC_HDMIDDCRX,			//DRQ_TYPE_HDMI
+
+	N_DRQSRC_IRRX,       		//DRQ_TYPE_IR
+	N_DRQSRC_SPDIFRX,      		//DRQ_TYPE_SPDIF
+	N_DRQSRC_IISRX,     		//DRQ_TYPE_IIS
+	N_DRQSRC_UART0RX,     		//DRQ_TYPE_UART0
+	N_DRQSRC_UART1RX,			//DRQ_TYPE_UART1
+	N_DRQSRC_UART2RX,    		//DRQ_TYPE_UART2
+	N_DRQSRC_UART3RX,    		//DRQ_TYPE_UART3
+	N_DRQSRC_AUDIOCDAD,    		//DRQ_TYPE_AUDIO
+	N_DRQSRC_TPAD,	    		//DRQ_TYPE_TPAD
+	N_DRQSRC_USBEP1,			//DRQ_TYPE_USBEP1
+	N_DRQSRC_USBEP2,			//DRQ_TYPE_USBEP2
+	N_DRQSRC_USBEP3,			//DRQ_TYPE_USBEP3
+	N_DRQSRC_USBEP4,			//DRQ_TYPE_USBEP4
+	N_DRQSRC_USBEP5,			//DRQ_TYPE_USBEP5
+};
+
+unsigned long n_drqdst_arr[DRQ_TYPE_MAX]={
+	N_DRQDST_SRAM,       	//DRQ_TYPE_SRAM
+	N_DRQDST_SDRAM,      	//DRQ_TYPE_SDRAM
+	DRQ_INVALID,         	//DRQ_TYPE_NAND
+	DRQ_INVALID,         	//DRQ_TYPE_USB0
+	DRQ_INVALID,         	//DRQ_TYPE_EMAC
+	N_DRQDST_SPI1TX,       	//DRQ_TYPE_SPI1
+	DRQ_INVALID,         	//DRQ_TYPE_SS
+	DRQ_INVALID,         	//DRQ_TYPE_MS
+	N_DRQDST_SPI0TX,       	//DRQ_TYPE_SPI0
+	N_DRQDST_SPI2TX,       	//DRQ_TYPE_SPI2
+	DRQ_INVALID,			//DRQ_TYPE_TCON0
+	DRQ_INVALID,			//DRQ_TYPE_HDMIAUDIO
+	N_DRQDST_HDMIDDCTX,		//DRQ_TYPE_HDMI
+
+	N_DRQDST_IRTX,       	//DRQ_TYPE_IR
+	N_DRQDST_SPDIFTX,      	//DRQ_TYPE_SPDIF
+	N_DRQDST_IISTX,     	//DRQ_TYPE_IIS
+	N_DRQDST_UART0TX,     	//DRQ_TYPE_UART0
+	N_DRQDST_UART1TX,		//DRQ_TYPE_UART1
+	N_DRQDST_UART2TX,    	//DRQ_TYPE_UART2
+	N_DRQDST_UART3TX,    	//DRQ_TYPE_UART3
+	N_DRQDST_AUDIOCDAD,    	//DRQ_TYPE_AUDIO
+	DRQ_INVALID,	    	//DRQ_TYPE_TPAD
+	N_DRQDST_USBEP1,		//DRQ_TYPE_USBEP1
+	N_DRQDST_USBEP2,		//DRQ_TYPE_USBEP2
+	N_DRQDST_USBEP3,		//DRQ_TYPE_USBEP3
+	N_DRQDST_USBEP4,		//DRQ_TYPE_USBEP4
+	N_DRQDST_USBEP5,		//DRQ_TYPE_USBEP5
+};
+
+unsigned long d_drqsrc_arr[DRQ_TYPE_MAX]={
+	D_DRQSRC_SRAM,       	//DRQ_TYPE_SRAM
+	D_DRQSRC_SDRAM,      	//DRQ_TYPE_SDRAM
+	D_DRQSRC_NAND,         	//DRQ_TYPE_NAND
+	D_DRQSRC_USB0,         	//DRQ_TYPE_USB0
+	D_DRQSRC_EMACRX,       	//DRQ_TYPE_EMAC
+	D_DRQSRC_SPI1RX,       	//DRQ_TYPE_SPI1
+	D_DRQSRC_SECRX,       	//DRQ_TYPE_SS
+	D_DRQSRC_MS,         	//DRQ_TYPE_MS
+	D_DRQSRC_SPI0RX,       	//DRQ_TYPE_SPI0
+	D_DRQSRC_SPI2RX,       	//DRQ_TYPE_SPI2
+	DRQ_INVALID,			//DRQ_TYPE_TCON0
+	DRQ_INVALID,			//DRQ_TYPE_HDMIAUDIO
+	DRQ_INVALID,			//DRQ_TYPE_HDMI
+
+	DRQ_INVALID,       		//DRQ_TYPE_IR
+	DRQ_INVALID,      		//DRQ_TYPE_SPDIF
+	DRQ_INVALID,     		//DRQ_TYPE_IIS
+	DRQ_INVALID,     		//DRQ_TYPE_UART0
+	DRQ_INVALID,			//DRQ_TYPE_UART1
+	DRQ_INVALID,    		//DRQ_TYPE_UART2
+	DRQ_INVALID,    		//DRQ_TYPE_UART3
+	DRQ_INVALID,    		//DRQ_TYPE_AUDIO
+	DRQ_INVALID,	    	//DRQ_TYPE_TPAD
+	DRQ_INVALID,			//DRQ_TYPE_USBEP1
+	DRQ_INVALID,			//DRQ_TYPE_USBEP2
+	DRQ_INVALID,			//DRQ_TYPE_USBEP3
+	DRQ_INVALID,			//DRQ_TYPE_USBEP4
+	DRQ_INVALID,			//DRQ_TYPE_USBEP5
+};
+unsigned long d_drqdst_arr[DRQ_TYPE_MAX]={
+	D_DRQDST_SRAM,       	//DRQ_TYPE_SRAM
+	D_DRQDST_SDRAM,      	//DRQ_TYPE_SDRAM
+	D_DRQDST_NAND,         	//DRQ_TYPE_NAND
+	D_DRQDST_USB0,         	//DRQ_TYPE_USB0
+	D_DRQDST_EMACTX,       	//DRQ_TYPE_EMAC
+	D_DRQDST_SPI1TX,       	//DRQ_TYPE_SPI1
+	D_DRQDST_SECTX,       	//DRQ_TYPE_SS
+	D_DRQDST_MS,         	//DRQ_TYPE_MS
+	D_DRQDST_SPI0TX,       	//DRQ_TYPE_SPI0
+	D_DRQDST_SPI2TX,       	//DRQ_TYPE_SPI2
+	DRQ_INVALID,			//DRQ_TYPE_TCON0
+	D_DRQDST_HDMIAUDIO,		//DRQ_TYPE_HDMIAUDIO
+	DRQ_INVALID,			//DRQ_TYPE_HDMI
+
+	DRQ_INVALID,       		//DRQ_TYPE_IR
+	DRQ_INVALID,      		//DRQ_TYPE_SPDIF
+	DRQ_INVALID,     		//DRQ_TYPE_IIS
+	DRQ_INVALID,     		//DRQ_TYPE_UART0
+	DRQ_INVALID,			//DRQ_TYPE_UART1
+	DRQ_INVALID,    		//DRQ_TYPE_UART2
+	DRQ_INVALID,    		//DRQ_TYPE_UART3
+	DRQ_INVALID,    		//DRQ_TYPE_AUDIO
+	DRQ_INVALID,	    	//DRQ_TYPE_TPAD
+	DRQ_INVALID,			//DRQ_TYPE_USBEP1
+	DRQ_INVALID,			//DRQ_TYPE_USBEP2
+	DRQ_INVALID,			//DRQ_TYPE_USBEP3
+	DRQ_INVALID,			//DRQ_TYPE_USBEP4
+	DRQ_INVALID,			//DRQ_TYPE_USBEP5
+};
+
+#endif  
diff --git a/arch/arm/plat-sunxi/include/plat/clock.h b/arch/arm/plat-sunxi/include/plat/clock.h
new file mode 100644
index 0000000..7dbdf0d
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/clock.h
@@ -0,0 +1,74 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/clock.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_CLOCK_H__
+#define __SW_CLOCK_H__
+
+#include <linux/kernel.h>
+#include <linux/clocksource.h>
+#include <mach/aw_ccu.h>
+
+/* define clock type            */
+typedef enum __CCU_CLK_TYPE
+{
+    CCU_CLK_TYPE_SYS,
+    CCU_CLK_TYPE_MOD,
+
+} __ccu_clk_type_e;
+
+typedef enum __CCU_CLK_CHANGE
+{
+    CCU_CLK_CHANGE_NONE,
+    CCU_CLK_CHANGE_PREPARE,
+    CCU_CLK_CHANGE_DONE,
+
+} __ccu_clk_change_e;
+
+
+typedef struct clk
+{
+    __aw_ccu_clk_t  *clk;       /* clock handle from ccu csp                            */
+    __s32           usr_cnt;    /* user count                                           */
+    __s32           enable;     /* enable count, when it down to 0, it will be disalbe  */
+    __s32           hash;       /* hash value, for fast search without string compare   */
+
+    __aw_ccu_clk_t  *(*get_clk)(__s32 id);
+                                /* set clock                                            */
+    __aw_ccu_err_e  (*set_clk)(__aw_ccu_clk_t *clk);
+                                /* get clock                                            */
+    struct clk      *parent;    /* parent clock node pointer                            */
+    struct clk      *child;     /* child clock node pinter                              */
+    struct clk      *left;      /* left brother node pointer                            */
+    struct clk      *right;     /* right bother node pointer                            */
+
+} __ccu_clk_t;
+
+static inline const char *clk_name(struct clk *clk)
+{
+	return clk->clk->name;
+}
+
+extern int clk_reset(struct clk *clk, int reset);
+cycle_t aw_clksrc_read(struct clocksource *cs);
+
+#endif  /* #ifndef __SW_CLOCK_H__ */
diff --git a/arch/arm/plat-sunxi/include/plat/core.h b/arch/arm/plat-sunxi/include/plat/core.h
new file mode 100644
index 0000000..63b9d8f
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/core.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2012  Alejandro Mery <amery@geeks.cl>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _SUNXI_CORE_H
+#define _SUNXI_CORE_H
+
+#define pr_reserve_info(L, START, SIZE) \
+	pr_info("\t%s : 0x%08x - 0x%08x  (%4d %s)\n", L, \
+		(u32)(START), (u32)((START) + (SIZE) - 1), \
+		(u32)((SIZE) < SZ_1M ? (SIZE) / SZ_1K : (SIZE) / SZ_1M), \
+		(SIZE) < SZ_1M ? "kB" : "MB")
+
+#ifdef CONFIG_SUNXI_MALI_RESERVED_MEM
+struct meminfo;
+struct tag;
+
+void __init sunxi_mali_core_fixup(struct tag *t, char **cmdline,
+				  struct meminfo *mi);
+#endif
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/debug-macro.S b/arch/arm/plat-sunxi/include/plat/debug-macro.S
new file mode 100644
index 0000000..449f692
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/debug-macro.S
@@ -0,0 +1,36 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/debug-macro.S
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <mach/platform.h>
+
+	.macro	addruart, rp, rv, tmp
+	ldr	\rp, =SW_PA_UART0_IO_BASE
+	ldr	\rv, =SW_VA_UART0_IO_BASE
+#if CONFIG_SW_DEBUG_UART != 0
+	add	\rp, \rp, #(0x400 * CONFIG_SW_DEBUG_UART)
+	add	\rv, \rv, #(0x400 * CONFIG_SW_DEBUG_UART)
+#endif
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/plat-sunxi/include/plat/dma.h b/arch/arm/plat-sunxi/include/plat/dma.h
new file mode 100644
index 0000000..cd5cb3e
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/dma.h
@@ -0,0 +1,523 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H__
+#define __ASM_ARCH_DMA_H__
+
+#include <linux/device.h>
+#include <mach/hardware.h>
+/* sun[45]i depending defines*/
+#include <plat/dma_defs.h>
+#define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
+
+#define DMA_CH_VALID		(1<<31)
+#define DMA_CH_NEVER		(1<<30)
+
+#define N_DRQSRC_SHIFT		0
+#define N_DRQDST_SHIFT		16
+#define D_DRQSRC_SHIFT		0
+#define D_DRQDST_SHIFT		16
+#define DRQ_INVALID			0xff
+
+
+#define X_SIGLE   0
+#define X_BURST   1
+#define X_TIPPL	  2
+#define X_BYTE    0
+#define X_HALF    1
+#define X_WORD    2
+
+/* DMAADDRT_(dist)_(increase/fix)_(src)_(increase/fix) */
+#define A_INC     0x0
+#define A_FIX     0x1
+#define A_LN      0x0
+#define A_IO      0x1
+#define A_PH      0x2
+#define A_PV      0x3
+
+
+/* use this to specifiy hardware channel number */
+#define DMACH_LOW_LEVEL	(1<<28)
+
+/* we have 16 dma channels */
+#define SW_DMA_CHANNELS		(16)
+
+
+
+
+
+/*data length and burst length combination in DDMA and NDMA */
+enum xferunit {
+	/*des:X_SIGLE  src:X_SIGLE*/
+	DMAXFER_D_SBYTE_S_SBYTE,
+	DMAXFER_D_SBYTE_S_SHALF,
+	DMAXFER_D_SBYTE_S_SWORD,
+	DMAXFER_D_SHALF_S_SBYTE,
+	DMAXFER_D_SHALF_S_SHALF,
+	DMAXFER_D_SHALF_S_SWORD,
+	DMAXFER_D_SWORD_S_SBYTE,
+	DMAXFER_D_SWORD_S_SHALF,
+	DMAXFER_D_SWORD_S_SWORD,
+
+	/*des:X_SIGLE  src:X_BURST*/
+	DMAXFER_D_SBYTE_S_BBYTE,
+	DMAXFER_D_SBYTE_S_BHALF,
+	DMAXFER_D_SBYTE_S_BWORD,
+	DMAXFER_D_SHALF_S_BBYTE,
+	DMAXFER_D_SHALF_S_BHALF,
+	DMAXFER_D_SHALF_S_BWORD,
+	DMAXFER_D_SWORD_S_BBYTE,
+	DMAXFER_D_SWORD_S_BHALF,
+	DMAXFER_D_SWORD_S_BWORD,
+
+	/*des:X_SIGLE   src:X_TIPPL*/
+	DMAXFER_D_SBYTE_S_TBYTE,
+	DMAXFER_D_SBYTE_S_THALF,
+	DMAXFER_D_SBYTE_S_TWORD,
+	DMAXFER_D_SHALF_S_TBYTE,
+	DMAXFER_D_SHALF_S_THALF,
+	DMAXFER_D_SHALF_S_TWORD,
+	DMAXFER_D_SWORD_S_TBYTE,
+	DMAXFER_D_SWORD_S_THALF,
+	DMAXFER_D_SWORD_S_TWORD,
+
+	/*des:X_BURST  src:X_BURST*/
+	DMAXFER_D_BBYTE_S_BBYTE,
+	DMAXFER_D_BBYTE_S_BHALF,
+	DMAXFER_D_BBYTE_S_BWORD,
+	DMAXFER_D_BHALF_S_BBYTE,
+	DMAXFER_D_BHALF_S_BHALF,
+	DMAXFER_D_BHALF_S_BWORD,
+	DMAXFER_D_BWORD_S_BBYTE,
+	DMAXFER_D_BWORD_S_BHALF,
+	DMAXFER_D_BWORD_S_BWORD,
+
+	/*des:X_BURST   src:X_SIGLE*/
+	DMAXFER_D_BBYTE_S_SBYTE,
+	DMAXFER_D_BBYTE_S_SHALF,
+	DMAXFER_D_BBYTE_S_SWORD,
+	DMAXFER_D_BHALF_S_SBYTE,
+	DMAXFER_D_BHALF_S_SHALF,
+	DMAXFER_D_BHALF_S_SWORD,
+	DMAXFER_D_BWORD_S_SBYTE,
+	DMAXFER_D_BWORD_S_SHALF,
+	DMAXFER_D_BWORD_S_SWORD,
+
+	/*des:X_BURST   src:X_TIPPL*/
+	DMAXFER_D_BBYTE_S_TBYTE,
+	DMAXFER_D_BBYTE_S_THALF,
+	DMAXFER_D_BBYTE_S_TWORD,
+	DMAXFER_D_BHALF_S_TBYTE,
+	DMAXFER_D_BHALF_S_THALF,
+	DMAXFER_D_BHALF_S_TWORD,
+	DMAXFER_D_BWORD_S_TBYTE,
+	DMAXFER_D_BWORD_S_THALF,
+	DMAXFER_D_BWORD_S_TWORD,
+
+	/*des:X_TIPPL   src:X_TIPPL*/
+	DMAXFER_D_TBYTE_S_TBYTE,
+	DMAXFER_D_TBYTE_S_THALF,
+	DMAXFER_D_TBYTE_S_TWORD,
+	DMAXFER_D_THALF_S_TBYTE,
+	DMAXFER_D_THALF_S_THALF,
+	DMAXFER_D_THALF_S_TWORD,
+	DMAXFER_D_TWORD_S_TBYTE,
+	DMAXFER_D_TWORD_S_THALF,
+	DMAXFER_D_TWORD_S_TWORD,
+
+	/*des:X_TIPPL   src:X_SIGLE*/
+	DMAXFER_D_TBYTE_S_SBYTE,
+	DMAXFER_D_TBYTE_S_SHALF,
+	DMAXFER_D_TBYTE_S_SWORD,
+	DMAXFER_D_THALF_S_SBYTE,
+	DMAXFER_D_THALF_S_SHALF,
+	DMAXFER_D_THALF_S_SWORD,
+	DMAXFER_D_TWORD_S_SBYTE,
+	DMAXFER_D_TWORD_S_SHALF,
+	DMAXFER_D_TWORD_S_SWORD,
+
+	/*des:X_TIPPL   src:X_BURST*/
+	DMAXFER_D_TBYTE_S_BBYTE,
+	DMAXFER_D_TBYTE_S_BHALF,
+	DMAXFER_D_TBYTE_S_BWORD,
+	DMAXFER_D_THALF_S_BBYTE,
+	DMAXFER_D_THALF_S_BHALF,
+	DMAXFER_D_THALF_S_BWORD,
+	DMAXFER_D_TWORD_S_BBYTE,
+	DMAXFER_D_TWORD_S_BHALF,
+	DMAXFER_D_TWORD_S_BWORD,
+	DMAXFER_MAX
+};
+
+
+enum addrt {
+	/*NDMA address type*/
+	DMAADDRT_D_INC_S_INC,
+	DMAADDRT_D_INC_S_FIX,
+	DMAADDRT_D_FIX_S_INC,
+	DMAADDRT_D_FIX_S_FIX,
+
+	/*DDMA address type*/
+	DMAADDRT_D_LN_S_LN,
+	DMAADDRT_D_LN_S_IO,
+	DMAADDRT_D_LN_S_PH,
+	DMAADDRT_D_LN_S_PV,
+
+	DMAADDRT_D_IO_S_LN,
+	DMAADDRT_D_IO_S_IO,
+	DMAADDRT_D_IO_S_PH,
+	DMAADDRT_D_IO_S_PV,
+
+	DMAADDRT_D_PH_S_LN,
+	DMAADDRT_D_PH_S_IO,
+	DMAADDRT_D_PH_S_PH,
+	DMAADDRT_D_PH_S_PV,
+
+	DMAADDRT_D_PV_S_LN,
+	DMAADDRT_D_PV_S_IO,
+	DMAADDRT_D_PV_S_PH,
+	DMAADDRT_D_PV_S_PV,
+
+	DMAADDRT_MAX
+};
+
+/* types */
+enum sw_dma_state {
+	SW_DMA_IDLE,
+	SW_DMA_RUNNING,
+	SW_DMA_PAUSED
+};
+
+
+/* enum sw_dma_loadst
+ *
+ * This represents the state of the DMA engine, wrt to the loaded / running
+ * transfers. Since we don't have any way of knowing exactly the state of
+ * the DMA transfers, we need to know the state to make decisions on wether
+ * we can
+ *
+ * SW_DMA_NONE
+ *
+ * There are no buffers loaded (the channel should be inactive)
+ *
+ * SW_DMA_1LOADED
+ *
+ * There is one buffer loaded, however it has not been confirmed to be
+ * loaded by the DMA engine. This may be because the channel is not
+ * yet running, or the DMA driver decided that it was too costly to
+ * sit and wait for it to happen.
+ *
+ * SW_DMA_1RUNNING
+ *
+ * The buffer has been confirmed running, and not finisged
+ *
+ * SW_DMA_1LOADED_1RUNNING
+ *
+ * There is a buffer waiting to be loaded by the DMA engine, and one
+ * currently running.
+*/
+
+enum sw_dma_loadst {
+	SW_DMALOAD_NONE,
+	SW_DMALOAD_1LOADED,
+	SW_DMALOAD_1RUNNING,
+	SW_DMALOAD_1LOADED_1RUNNING,
+};
+
+enum sw_dma_buffresult {
+	SW_RES_OK,
+	SW_RES_ERR,
+	SW_RES_ABORT
+};
+
+enum sw_dmadir {
+	SW_DMA_RWNULL,
+	SW_DMA_RDEV,		/* read from dev */
+	SW_DMA_WDEV,		/* write to dev */
+	SW_DMA_M2M,
+//	SW_DMA_RWDEV		/* can r/w dev */
+};
+
+enum dma_hf_irq {
+	SW_DMA_IRQ_NO,
+	SW_DMA_IRQ_HALF,
+	SW_DMA_IRQ_FULL
+};
+/* enum sw_chan_op
+ *
+ * operation codes passed to the DMA code by the user, and also used
+ * to inform the current channel owner of any changes to the system state
+*/
+
+enum sw_chan_op {
+	SW_DMAOP_START,
+	SW_DMAOP_STOP,
+	SW_DMAOP_PAUSE,
+	SW_DMAOP_RESUME,
+	SW_DMAOP_FLUSH,
+	SW_DMAOP_TIMEOUT,		/* internal signal to handler */
+	SW_DMAOP_STARTED,		/* indicate channel started */
+};
+
+/* flags */
+
+#define SW_DMAF_SLOW         (1<<0)   /* slow, so don't worry about
+					    * waiting for reloads */
+#define SW_DMAF_AUTOSTART    (1<<1)   /* auto-start if buffer queued */
+
+/* dma buffer */
+
+struct sw_dma_client {
+	char                *name;
+};
+
+/* sw_dma_buf_s
+ *
+ * internally used buffer structure to describe a queued or running
+ * buffer.
+*/
+
+struct sw_dma_buf;
+struct sw_dma_buf {
+	struct sw_dma_buf	*next;
+	int			 magic;		/* magic */
+	int			 size;		/* buffer size in bytes */
+	dma_addr_t		 data;		/* start of DMA data */
+	dma_addr_t		 ptr;		/* where the DMA got to [1] */
+	void			*id;		/* client's id */
+};
+
+/* [1] is this updated for both recv/send modes? */
+
+struct sw_dma_chan;
+
+/* sw_dma_cbfn_t
+ *
+ * buffer callback routine type
+*/
+
+typedef void (*sw_dma_cbfn_t)(struct sw_dma_chan *,
+				   void *buf, int size,
+				   enum sw_dma_buffresult result);
+
+typedef int  (*sw_dma_opfn_t)(struct sw_dma_chan *,
+				   enum sw_chan_op );
+
+struct sw_dma_stats {
+	unsigned long		loads;
+	unsigned long		timeout_longest;
+	unsigned long		timeout_shortest;
+	unsigned long		timeout_avg;
+	unsigned long		timeout_failed;
+};
+
+struct sw_dma_map;
+
+/* struct sw_dma_chan
+ *
+ * full state information for each DMA channel
+*/
+
+struct sw_dma_chan {
+	/* channel state flags and information */
+	unsigned char		 number;      /* number of this dma channel */
+	unsigned char		 in_use;      /* channel allocated */
+	unsigned char		 irq_claimed; /* irq claimed for channel */
+	unsigned char		 irq_enabled; /* irq enabled for channel */
+
+	/* channel state */
+
+	enum sw_dma_state	 state;
+	enum sw_dma_loadst	 load_state;
+	struct sw_dma_client *client;
+
+	/* channel configuration */
+	unsigned long		 dev_addr;
+	unsigned long		 load_timeout;
+	unsigned int		 flags;		/* channel flags */
+	unsigned int		 hw_cfg;	/* last hw config */
+
+	struct sw_dma_map	*map;		/* channel hw maps */
+
+	/* channel's hardware position and configuration */
+	void __iomem		*regs;		/* channels registers */
+	void __iomem		*addr_reg;	/* data address register */
+	//unsigned int		 irq;		/* channel irq */
+	unsigned long		 dcon;		/* default value of DCON */
+
+	/* driver handles */
+	sw_dma_cbfn_t	 callback_fn;	/* buffer done callback */
+	sw_dma_cbfn_t	 callback_hd;	/* buffer half done callback */
+	sw_dma_opfn_t	 op_fn;		/* channel op callback */
+
+	/* stats gathering */
+	struct sw_dma_stats *stats;
+	struct sw_dma_stats  stats_store;
+
+	/* buffer list and information */
+	struct sw_dma_buf	*curr;		/* current dma buffer */
+	struct sw_dma_buf	*next;		/* next buffer to load */
+	struct sw_dma_buf	*end;		/* end of queue */
+
+	/* system device */
+	struct device	dev;
+	void * dev_id;
+};
+
+/*the channel number of above 8 is DDMA channel.*/
+#define IS_DADECATE_DMA(ch) (ch->number >= 8)
+
+struct dma_hw_conf{
+	unsigned char		drqsrc_type;
+	unsigned char		drqdst_type;
+
+	unsigned char		xfer_type;
+	unsigned char		address_type;
+	unsigned char           dir;
+	unsigned char		hf_irq;
+	unsigned char		reload;
+
+	unsigned long		from;
+	unsigned long		to;
+	unsigned long		cmbk;
+};
+
+extern inline void DMA_COPY_HW_CONF(struct dma_hw_conf *to, struct dma_hw_conf *from);
+
+/* struct sw_dma_map
+ *
+ * this holds the mapping information for the channel selected
+ * to be connected to the specified device
+*/
+struct sw_dma_map {
+	const char		*name;
+	struct dma_hw_conf  user_hw_conf;
+	const struct dma_hw_conf*  default_hw_conf;
+	struct dma_hw_conf* conf_ptr;
+	unsigned long channels[SW_DMA_CHANNELS];
+};
+
+struct sw_dma_selection {
+	struct sw_dma_map	*map;
+	unsigned long		 map_size;
+	unsigned long		 dcon_mask;
+};
+
+/* struct sw_dma_order_ch
+ *
+ * channel map for one of the `enum dma_ch` dma channels. the list
+ * entry contains a set of low-level channel numbers, orred with
+ * DMA_CH_VALID, which are checked in the order in the array.
+*/
+
+struct sw_dma_order_ch {
+	unsigned int	list[SW_DMA_CHANNELS];	/* list of channels */
+	unsigned int	flags;				/* flags */
+};
+
+/* struct s3c24xx_dma_order
+ *
+ * information provided by either the core or the board to give the
+ * dma system a hint on how to allocate channels
+*/
+
+struct sw_dma_order {
+	struct sw_dma_order_ch	channels[DMACH_MAX];
+};
+
+/* the currently allocated channel information */
+extern struct sw_dma_chan sw_chans[];
+
+/* note, we don't really use dma_device_t at the moment */
+typedef unsigned long dma_device_t;
+
+/* functions --------------------------------------------------------------- */
+
+/* sw_dma_request
+ *
+ * request a dma channel exclusivley
+*/
+
+extern int sw_dma_request(unsigned int channel,
+			       struct sw_dma_client *, void *dev);
+
+
+/* sw_dma_ctrl
+ *
+ * change the state of the dma channel
+*/
+
+extern int sw_dma_ctrl(unsigned int channel, enum sw_chan_op op);
+
+/* sw_dma_setflags
+ *
+ * set the channel's flags to a given state
+*/
+
+extern int sw_dma_setflags(unsigned int channel,
+				unsigned int flags);
+
+/* sw_dma_free
+ *
+ * free the dma channel (will also abort any outstanding operations)
+*/
+
+extern int sw_dma_free(unsigned int channel, struct sw_dma_client *);
+
+/* sw_dma_enqueue
+ *
+ * place the given buffer onto the queue of operations for the channel.
+ * The buffer must be allocated from dma coherent memory, or the Dcache/WB
+ * drained before the buffer is given to the DMA system.
+*/
+
+extern int sw_dma_enqueue(unsigned int channel, void *id,
+			       dma_addr_t data, int size);
+
+/* sw_dma_config
+ *
+ * configure the dma channel
+*/
+extern void poll_dma_pending(int chan_nr);
+
+extern int sw_dma_config(unsigned int channel, struct dma_hw_conf* user_conf);
+
+extern int sw15_dma_init(void);
+
+extern int sw_dma_order_set(struct sw_dma_order *ord);
+
+extern int sw_dma_init_map(struct sw_dma_selection *sel);
+
+/* sw_dma_getposition
+ *
+ * get the position that the dma transfer is currently at
+*/
+
+extern int sw_dma_getposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+extern int sw_dma_set_opfn(unsigned int, sw_dma_opfn_t rtn);
+extern int sw_dma_set_buffdone_fn(unsigned int, sw_dma_cbfn_t rtn);
+extern int sw_dma_set_halfdone_fn(unsigned int, sw_dma_cbfn_t rtn);
+extern int sw_dma_getcurposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+#endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/plat-sunxi/include/plat/dma_compat.h b/arch/arm/plat-sunxi/include/plat/dma_compat.h
new file mode 100644
index 0000000..d99c184
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/dma_compat.h
@@ -0,0 +1,183 @@
+/*
+ * dma_compat.h helper code for mixing sun4i/sun5i and sun7i dma code
+ *
+ * Copyright 2013 Hans de Goede <hdegoede@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __PLAT_DMA_COMPAT_H__
+#define __PLAT_DMA_COMPAT_H__
+
+#include <mach/dma.h>
+
+#ifdef CONFIG_ARCH_SUN7I
+struct sw_dma_client {
+	char *name;
+};
+#endif
+
+struct sunxi_dma_params {
+	struct sw_dma_client client;
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	unsigned int channel;	/* Channel ID */
+#else
+	dma_hdl_t  dma_hdl;
+	dma_cb_t   dma_cb;
+#endif	
+	dma_addr_t dma_addr;
+	void (*callback)(struct sunxi_dma_params *, void *);
+	void *callback_arg;
+};
+
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+static void sunxi_dma_callback(struct sw_dma_chan *channel, void *dev_id,
+	int size, enum sw_dma_buffresult result)
+{
+	struct sunxi_dma_params *dma = dev_id;
+
+	if (result == SW_RES_ABORT || result == SW_RES_ERR)
+		return;
+
+	dma->callback(dma, dma->callback_arg);
+}
+#else
+static void sunxi_dma_callback(dma_hdl_t dma_hdl, void *parg)
+{
+	struct sunxi_dma_params *dma = parg;
+
+	dma->callback(dma, dma->callback_arg);
+}
+#endif
+
+static inline int sunxi_dma_set_callback(struct sunxi_dma_params *dma,
+	void (*callback)(struct sunxi_dma_params *, void *),
+	void *callback_arg)
+{
+	dma->callback = callback;
+	dma->callback_arg = callback_arg;
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	sw_dma_set_buffdone_fn(dma->channel, sunxi_dma_callback);
+	return 0;
+#else
+	dma->dma_cb.func = sunxi_dma_callback;
+	dma->dma_cb.parg = dma;
+	/* use the full buffer cb, maybe we should use the half buffer cb? */
+	return sw_dma_ctl(dma->dma_hdl, DMA_OP_SET_FD_CB,
+			  (void *)&dma->dma_cb);
+#endif
+}
+
+static inline int sunxi_dma_enqueue(struct sunxi_dma_params *dma,
+	dma_addr_t pos, unsigned long len, int read)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	return sw_dma_enqueue(dma->channel, dma, __bus_to_virt(pos),  len);
+#else
+	if (read)
+		return sw_dma_enqueue(dma->dma_hdl, dma->dma_addr, pos, len);
+	else
+		return sw_dma_enqueue(dma->dma_hdl, pos, dma->dma_addr, len);
+#endif
+}
+
+static inline int sunxi_dma_config(struct sunxi_dma_params *dma,
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	struct dma_hw_conf *config,
+#else
+	dma_config_t *config,
+#endif
+	unsigned int cmbk)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	config->cmbk = cmbk;
+	return sw_dma_config(dma->channel, config);
+#else
+	int ret = sw_dma_config(dma->dma_hdl, config);
+	if (ret || cmbk == 0)
+		return ret;
+	return sw_dma_ctl(dma->dma_hdl, DMA_OP_SET_PARA_REG, &cmbk);
+#endif
+}
+
+
+static inline int sunxi_dma_start(struct sunxi_dma_params *dma)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	return sw_dma_ctrl(dma->channel, SW_DMAOP_START);
+#else
+	return sw_dma_ctl(dma->dma_hdl, DMA_OP_START, NULL);
+#endif
+}
+
+static inline int sunxi_dma_stop(struct sunxi_dma_params *dma)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	return sw_dma_ctrl(dma->channel, SW_DMAOP_STOP);
+#else
+	return sw_dma_ctl(dma->dma_hdl, DMA_OP_STOP, NULL);
+#endif
+}
+
+static inline int sunxi_dma_flush(struct sunxi_dma_params *dma)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	sw_dma_ctrl(dma->channel, SW_DMAOP_FLUSH);
+	return 0;
+#else
+	return -EINVAL; /* No flush in the sun7i dma code */
+#endif
+}
+
+static inline void sunxi_dma_started(struct sunxi_dma_params *dma)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	sw_dma_ctrl(dma->channel, SW_DMAOP_STARTED);
+#endif
+}
+
+static inline int sunxi_dma_getcurposition(struct sunxi_dma_params *dma,
+	dma_addr_t *src, dma_addr_t *dest)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	return sw_dma_getcurposition(dma->channel, src, dest);
+#else
+	return sw_dma_getposition(dma->dma_hdl, src, dest);
+#endif
+}
+
+static inline int sunxi_dma_request(struct sunxi_dma_params *dma,
+	int dedicated)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	return sw_dma_request(dma->channel, &dma->client, NULL);
+#else
+	dma->dma_hdl = sw_dma_request(dma->client.name,
+				dedicated ? CHAN_DEDICATE : CHAN_NORMAL);
+	return (dma->dma_hdl != NULL) ? 0 : -EIO;
+#endif
+}
+
+static inline void sunxi_dma_release(struct sunxi_dma_params *dma)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	sw_dma_free(dma->channel, &dma->client);
+#else
+	sw_dma_release(dma->dma_hdl);
+	dma->dma_hdl = NULL;
+#endif
+}
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/dma_defs.h b/arch/arm/plat-sunxi/include/plat/dma_defs.h
new file mode 100644
index 0000000..bcf4455
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/dma_defs.h
@@ -0,0 +1,360 @@
+/*
+ * sunxi:hw des/src bit masks depending on sun4i/sun5i soc
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ * (C) Copyright 2013
+ * Alexsey Shestacov <wingrimen@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __SUNXI_DMA_DEFS__
+#define __SUNXI_DMA_DEFS__
+/* DRQSRC and DRQDST are slightly different on sun4i and sun5i*/
+#if defined CONFIG_ARCH_SUN4I
+/*normal DMA Source*/
+#define N_DRQSRC_IR0RX		0b00000
+#define N_DRQSRC_IR1RX 		0b00001
+#define N_DRQSRC_SPDIFRX	0b00010
+#define N_DRQSRC_IISRX		0b00011
+#define N_DRQSRC_AC97RX		0b00101
+#define N_DRQSRC_UART0RX	0b01000
+#define N_DRQSRC_UART1RX 	0b01001
+#define N_DRQSRC_UART2RX	0b01010
+#define N_DRQSRC_UART3RX	0b01011
+#define N_DRQSRC_UART4RX	0b01100
+#define N_DRQSRC_UART5RX	0b01101
+#define N_DRQSRC_UART6RX	0b01110
+#define N_DRQSRC_UART7RX	0b01111
+#define N_DRQSRC_HDMIDDCRX	0b10000
+#define N_DRQSRC_AUDIOCDAD	0b10011	//Audio Codec D/A
+#define N_DRQSRC_SRAM		0b10101
+#define N_DRQSRC_SDRAM		0b10110
+#define N_DRQSRC_TPAD		0b10111	//TP A/D
+#define N_DRQSRC_SPI0RX		0b11000
+#define N_DRQSRC_SPI1RX		0b11001
+#define N_DRQSRC_SPI2RX		0b11010
+#define N_DRQSRC_SPI3RX		0b11011
+
+/*normal DMA destination*/
+#define N_DRQDST_IR0TX		0b00000
+#define N_DRQDST_IR1TX 		0b00001
+#define N_DRQDST_SPDIFTX	0b00010
+#define N_DRQDST_IISTX		0b00011
+#define N_DRQDST_AC97TX		0b00101
+#define N_DRQDST_UART0TX	0b01000
+#define N_DRQDST_UART1TX 	0b01001
+#define N_DRQDST_UART2TX	0b01010
+#define N_DRQDST_UART3TX	0b01011
+#define N_DRQDST_UART4TX	0b01100
+#define N_DRQDST_UART5TX	0b01101
+#define N_DRQDST_UART6TX	0b01110
+#define N_DRQDST_UART7TX	0b01111
+#define N_DRQDST_HDMIDDCTX	0b10000	//HDMI DDC TX
+#define N_DRQDST_AUDIOCDAD	0b10011	//Audio Codec D/A
+#define N_DRQDST_SRAM		0b10101
+#define N_DRQDST_SDRAM		0b10110
+#define N_DRQDST_SPI0TX		0b11000
+#define N_DRQDST_SPI1TX		0b11001
+#define N_DRQDST_SPI2TX		0b11010
+#define N_DRQDST_SPI3TX		0b11011
+
+/*Dedicated DMA Source*/
+#define D_DRQSRC_SRAM		0b00000//0x0 SRAM memory
+#define D_DRQSRC_SDRAM		0b00001//0x1 SDRAM memory
+#define D_DRQSRC_PATA		0b00010//0x2 PATA
+#define D_DRQSRC_NAND 		0b00011//0x3 NAND Flash Controller(NFC)
+#define D_DRQSRC_USB0 		0b00100//0x4 USB0
+#define D_DRQSRC_EMACRX		0b00111//0x7 Ethernet MAC Rx
+#define D_DRQSRC_SPI1RX		0b01001//0x9 SPI1 RX
+#define D_DRQSRC_SECRX 		0b01011//0xB Security System Rx
+#define D_DRQSRC_MS 		0b10111//0x17 Memory Stick Controller(MSC)
+#define D_DRQSRC_SPI0RX		0b11011//0x1B SPI0 RX
+#define D_DRQSRC_SPI2RX		0b11101//0x1D SPI2 RX
+#define D_DRQSRC_SPI3RX		0b11111//0x1F SPI3 RX
+
+
+/*Dedicated DMA Destination*/
+#define D_DRQDST_SRAM		0b00000//0x0 SRAM memory
+#define D_DRQDST_SDRAM		0b00001//0x1 SDRAM memory
+#define D_DRQDST_PATA		0b00010//0x2 PATA
+#define D_DRQDST_NAND 		0b00011//0x3 NAND Flash Controller(NFC)
+#define D_DRQDST_USB0 		0b00100//0x4 USB0
+#define D_DRQDST_EMACTX		0b00110//0x6 Ethernet MAC Rx
+#define D_DRQDST_SPI1TX		0b01000//0x8 SPI1 RX
+#define D_DRQDST_SECTX 		0b01010//0xA Security System Rx
+#define D_DRQDST_TCON0 		0b01110//0xE TCON0
+#define D_DRQDST_TCON1 		0b01111//0xF TCON1
+#define D_DRQDST_MS		0b10111//0x17 Memory Stick Controller(MSC)
+#define D_DRQDST_HDMIAUDIO	0b11000//0x18 HDMI Audio
+#define D_DRQDST_SPI0TX		0b11010//0x1A SPI0 TX
+#define D_DRQDST_SPI2TX		0b11100//0x1C SPI2 TX
+#define D_DRQDST_SPI3TX		0b11110//0x1E SPI3 TX
+
+
+
+#elif defined CONFIG_ARCH_SUN5I
+
+/*normal DMA Source*/
+#define N_DRQSRC_IRRX		0b00000
+#define N_DRQSRC_SPDIFRX	0b00010
+#define N_DRQSRC_IISRX		0b00011
+#define N_DRQSRC_UART0RX	0b01000
+#define N_DRQSRC_UART1RX 	0b01001
+#define N_DRQSRC_UART2RX	0b01010
+#define N_DRQSRC_UART3RX	0b01011
+#define N_DRQSRC_HDMIDDCRX	0b10000
+#define N_DRQSRC_AUDIOCDAD	0b10011	//Audio Codec D/A
+#define N_DRQSRC_SRAM		0b10101
+#define N_DRQSRC_SDRAM		0b10110
+#define N_DRQSRC_TPAD		0b10111	//TP A/D
+#define N_DRQSRC_SPI0RX		0b11000
+#define N_DRQSRC_SPI1RX		0b11001
+#define N_DRQSRC_SPI2RX		0b11010
+#define N_DRQSRC_USBEP1		0b11011
+#define N_DRQSRC_USBEP2		0b11100
+#define N_DRQSRC_USBEP3		0b11101
+#define N_DRQSRC_USBEP4		0b11110
+#define N_DRQSRC_USBEP5		0b11111
+
+/*normal DMA destination*/
+#define N_DRQDST_IRTX		0b00000
+#define N_DRQDST_SPDIFTX	0b00010
+#define N_DRQDST_IISTX		0b00011
+#define N_DRQDST_UART0TX	0b01000
+#define N_DRQDST_UART1TX 	0b01001
+#define N_DRQDST_UART2TX	0b01010
+#define N_DRQDST_UART3TX	0b01011
+#define N_DRQDST_HDMIDDCTX	0b10000//HDMI DDC TX
+#define N_DRQDST_AUDIOCDAD	0b10011//Audio Codec D/A
+#define N_DRQDST_SRAM		0b10101
+#define N_DRQDST_SDRAM		0b10110
+#define N_DRQDST_SPI0TX		0b11000
+#define N_DRQDST_SPI1TX		0b11001
+#define N_DRQDST_SPI2TX		0b11010
+#define N_DRQDST_USBEP1		0b11011
+#define N_DRQDST_USBEP2		0b11100
+#define N_DRQDST_USBEP3		0b11101
+#define N_DRQDST_USBEP4		0b11110
+#define N_DRQDST_USBEP5		0b11111
+
+/*Dedicated DMA Source*/
+#define D_DRQSRC_SRAM		0b00000//0x0 SRAM memory
+#define D_DRQSRC_SDRAM		0b00001//0x1 SDRAM memory
+#define D_DRQSRC_NAND 		0b00011//0x3 NAND Flash Controller(NFC)
+#define D_DRQSRC_USB0 		0b00100//0x4 USB0
+#define D_DRQSRC_EMACRX		0b00111//0x7 Ethernet MAC Rx
+#define D_DRQSRC_SPI1RX		0b01001//0x9 SPI1 RX
+#define D_DRQSRC_SECRX 		0b01011//0xB Security System Rx
+#define D_DRQSRC_MS 		0b10111//0x17 Memory Stick Controller(MSC)
+#define D_DRQSRC_SPI0RX		0b11011//0x1B SPI0 RX
+#define D_DRQSRC_SPI2RX		0b11101//0x1D SPI2 RX
+
+/*Dedicated DMA Destination*/
+#define D_DRQDST_SRAM		0b00000//0x0 SRAM memory
+#define D_DRQDST_SDRAM		0b00001//0x1 SDRAM memory
+#define D_DRQDST_NAND 		0b00011//0x3 NAND Flash Controller(NFC)
+#define D_DRQDST_USB0 		0b00100//0x4 USB0
+#define D_DRQDST_EMACTX		0b00110//0x6 Ethernet MAC Rx
+#define D_DRQDST_SPI1TX		0b01000//0x8 SPI1 RX
+#define D_DRQDST_SECTX 		0b01010//0xA Security System Tx
+#define D_DRQDST_TCON0 		0b01110//0xE TCON0
+#define D_DRQDST_MS			0b10111//0x17 Memory Stick Controller(MSC)
+#define D_DRQDST_HDMIAUDIO	0b11000//0x18 HDMI Audio
+#define D_DRQDST_SPI0TX		0b11010//0x1A SPI0 TX
+#define D_DRQDST_SPI2TX		0b11100//0x1C SPI2 TX
+
+
+#endif 
+
+
+#if defined CONFIG_ARCH_SUN4I
+
+enum drq_type {
+		DRQ_TYPE_SRAM,
+		DRQ_TYPE_SDRAM,
+		DRQ_TYPE_PATA,
+		DRQ_TYPE_NAND,
+		DRQ_TYPE_USB0,
+		DRQ_TYPE_EMAC,
+		DRQ_TYPE_SPI1,
+		DRQ_TYPE_SS,//Security System
+		DRQ_TYPE_MS,//Memory Stick Control
+		DRQ_TYPE_SPI0,
+		DRQ_TYPE_SPI2,
+		DRQ_TYPE_SPI3,
+		DRQ_TYPE_TCON0,
+		DRQ_TYPE_TCON1,
+		DRQ_TYPE_HDMI,
+
+		DRQ_TYPE_HDMIAUDIO,
+		DRQ_TYPE_IR0,
+		DRQ_TYPE_IR1,
+		DRQ_TYPE_SPDIF,
+		DRQ_TYPE_IIS,
+		DRQ_TYPE_AC97,
+		DRQ_TYPE_UART0,
+		DRQ_TYPE_UART1,
+		DRQ_TYPE_UART2,
+		DRQ_TYPE_UART3,
+		DRQ_TYPE_UART4,
+		DRQ_TYPE_UART5,
+		DRQ_TYPE_UART6,
+		DRQ_TYPE_UART7,
+		DRQ_TYPE_AUDIO,
+		DRQ_TYPE_TPAD,
+		DRQ_TYPE_MAX,
+};
+
+/* We use `virtual` dma channels to hide the fact we have only a limited
+ * number of DMA channels, and not of all of them (dependant on the device)
+ * can be attached to any DMA source. We therefore let the DMA core handle
+ * the allocation of hardware channels to clients.
+*/
+enum sw_dma_ch {
+	/*NDMA*/
+	DMACH_NSPI0,
+	DMACH_NSPI1,
+	DMACH_NSPI2,
+	DMACH_NSPI3,
+	DMACH_NUART0,
+	DMACH_NUART1,
+	DMACH_NUART2,
+	DMACH_NUART3,
+	DMACH_NUART4,
+	DMACH_NUART5,
+	DMACH_NUART6,
+	DMACH_NUART7,
+	DMACH_NSRAM,
+	DMACH_NSDRAM,
+	DMACH_NTPAD,
+	DMACH_NADDA_PLAY,//audio play
+	DMACH_NADDA_CAPTURE,//audio capture
+	DMACH_NIIS,
+	DMACH_NIR0,
+	DMACH_NIR1,
+	DMACH_NSPDIF,
+	DMACH_NAC97,
+	DMACH_NHDMI,//HDMI
+	/*DDMA*/
+	DMACH_DSRAM,
+	DMACH_DSDRAM,
+	DMACH_DPATA,
+	DMACH_DNAND,
+	DMACH_DUSB0,
+	DMACH_DEMACR,
+	DMACH_DEMACT,
+	DMACH_DSSR,
+	DMACH_DSST,
+	DMACH_TCON0,
+	DMACH_TCON1,
+	DMACH_HDMIAUDIO,//HDMIAUDIO
+	DMACH_DMS,
+	DMACH_DSPI0_TX,
+	DMACH_DSPI0_RX,
+	DMACH_DSPI1_TX,
+	DMACH_DSPI1_RX,
+	DMACH_DSPI2_TX,
+	DMACH_DSPI2_RX,
+	DMACH_DSPI3_TX,
+	DMACH_DSPI3_RX,
+	DMACH_MAX,/* 8 NDMAs, 8 DDMAs */
+
+};
+#elif defined CONFIG_ARCH_SUN5I
+enum drq_type {	
+		DRQ_TYPE_SRAM,
+		DRQ_TYPE_SDRAM,		
+		DRQ_TYPE_NAND,
+		DRQ_TYPE_USB0,
+		DRQ_TYPE_EMAC,
+		DRQ_TYPE_SPI1,
+		DRQ_TYPE_SS,//Security System 
+		DRQ_TYPE_MS,//Memory Stick Control
+		DRQ_TYPE_SPI0,
+		DRQ_TYPE_SPI2,		
+		DRQ_TYPE_TCON0,		
+		DRQ_TYPE_HDMIAUDIO,
+		
+		DRQ_TYPE_HDMI,				
+		DRQ_TYPE_IR,		
+		DRQ_TYPE_SPDIF,
+		DRQ_TYPE_IIS,		
+		DRQ_TYPE_UART0,
+		DRQ_TYPE_UART1,
+		DRQ_TYPE_UART2,
+		DRQ_TYPE_UART3,
+		DRQ_TYPE_AUDIO,
+		DRQ_TYPE_TPAD,	
+		DRQ_TYPE_USBEP1,
+		DRQ_TYPE_USBEP2,
+		DRQ_TYPE_USBEP3,
+		DRQ_TYPE_USBEP4,
+		DRQ_TYPE_USBEP5,
+		DRQ_TYPE_MAX,
+};
+/* We use `virtual` dma channels to hide the fact we have only a limited
+ * number of DMA channels, and not of all of them (dependant on the device)
+ * can be attached to any DMA source. We therefore let the DMA core handle
+ * the allocation of hardware channels to clients.
+*/
+enum sw_dma_ch {
+	/*NDMA*/
+	DMACH_NSPI0,
+	DMACH_NSPI1,
+	DMACH_NSPI2,		
+	DMACH_NUART0,
+	DMACH_NUART1,
+	DMACH_NUART2,
+	DMACH_NUART3,	
+	DMACH_NSRAM,
+	DMACH_NSDRAM,
+	DMACH_NTPAD,
+	DMACH_NADDA_PLAY,//audio play
+	DMACH_NADDA_CAPTURE,//audio capture
+	DMACH_NIIS,
+	DMACH_NIIS_CAPTURE,
+	DMACH_NIR,	
+	DMACH_NSPDIF,
+	DMACH_NHDMI,//HDMI
+	DMACH_NUSBEP1,
+	DMACH_NUSBEP2,
+	DMACH_NUSBEP3,
+	DMACH_NUSBEP4,
+	DMACH_NUSBEP5,
+	/*DDMA*/	
+	DMACH_DSRAM,
+	DMACH_DSDRAM,	
+	DMACH_DNAND,
+	DMACH_DUSB0,
+	DMACH_DEMACR,
+	DMACH_DEMACT,
+	DMACH_DSSR,
+	DMACH_DSST,
+	DMACH_TCON0,	
+	DMACH_HDMIAUDIO,//HDMIAUDIO	
+	DMACH_DMS,
+	DMACH_DSPI0_TX,
+	DMACH_DSPI0_RX,
+	DMACH_DSPI1_TX,
+	DMACH_DSPI1_RX,
+	DMACH_DSPI2_TX,
+	DMACH_DSPI2_RX,
+	DMACH_MAX,
+};
+#endif
+
+#endif 
diff --git a/arch/arm/plat-sunxi/include/plat/dram.h b/arch/arm/plat-sunxi/include/plat/dram.h
new file mode 100644
index 0000000..afab284
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/dram.h
@@ -0,0 +1,101 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/dram.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __AW_DRAM_H__
+#define __AW_DRAM_H__
+
+#include <linux/kernel.h>
+
+struct dram_para_t
+{
+    unsigned int    dram_baseaddr;
+    unsigned int    dram_clk;
+    unsigned int    dram_type;
+    unsigned int    dram_rank_num;
+    unsigned int    dram_chip_density;
+    unsigned int    dram_io_width;
+    unsigned int    dram_bus_width;
+    unsigned int    dram_cas;
+    unsigned int    dram_zq;
+    unsigned int    dram_odt_en;
+    unsigned int    dram_size;
+    unsigned int    dram_tpr0;
+    unsigned int    dram_tpr1;
+    unsigned int    dram_tpr2;
+    unsigned int    dram_tpr3;
+    unsigned int    dram_tpr4;
+    unsigned int    dram_tpr5;
+    unsigned int    dram_emr1;
+    unsigned int    dram_emr2;
+    unsigned int    dram_emr3;
+};
+
+int dram_init(void);
+int dram_exit(void);
+int dram_get_size(void);
+void dram_set_clock(int clk);
+void dram_set_drive(void);
+void dram_set_autorefresh_cycle(unsigned int clk);
+int  dram_scan_readpipe(void);
+void dram_enter_selfrefresh(void);
+void dram_exit_selfrefresh(void);
+void dram_enter_power_down(void);
+void dram_exit_power_down(void);
+void dram_hostport_on_off(unsigned int port_idx, unsigned int on);
+unsigned int dram_hostport_check_ahb_fifo_status(unsigned int port_idx);
+void dram_hostport_setup(unsigned int port, unsigned int prio, unsigned int wait_cycle, unsigned int cmd_num);
+void dram_power_save_process(void);
+unsigned int dram_power_up_process(void);
+
+#ifdef CONFIG_MACH_SUN5I
+#define DRAM_HOST_CFG_BASE          (SW_VA_DRAM_IO_BASE + 0x250)
+typedef struct __DRAM_HOST_CFG_REG{
+    unsigned int    AcsEn:1;    //bit0, host port access enable
+    unsigned int    reserved0:1;    //bit1
+    unsigned int    PrioLevel:2;    //bit2, host port poriority level
+    unsigned int    WaitState:4;    //bit4, host port wait state
+    unsigned int    CmdNum:8;       //bit8, host port command number
+    unsigned int    reserved1:14;   //bit16
+    unsigned int    WrCntEn:1;      //bit30, host port write counter enable
+    unsigned int    RdCntEn:1;      //bit31, host port read counter enable
+} __dram_host_cfg_reg_t;
+
+typedef enum __DRAM_HOST_PORT{
+    DRAM_HOST_CPU   = 16,
+    DRAM_HOST_GPU   = 17,
+    DRAM_HOST_BE    = 18,
+    DRAM_HOST_FE    = 19,
+    DRAM_HOST_CSI   = 20,
+    DRAM_HOST_TSDM  = 21,
+    DRAM_HOST_VE    = 22,
+    DRAM_HOST_USB   = 24,
+    DRAM_HOST_NDMA  = 25,
+    DRAM_HOST_ATH   = 26,
+    DRAM_HOST_IEP   = 27,
+    DRAM_HOST_SDHC  = 28,
+    DRAM_HOST_DDMA  = 29,
+    DRAM_HOST_GPS   = 30,
+} __dram_host_port_e;
+#endif
+
+#endif  /* __AW_DRAM_H__ */
diff --git a/arch/arm/plat-sunxi/include/plat/entry-macro.S b/arch/arm/plat-sunxi/include/plat/entry-macro.S
new file mode 100644
index 0000000..1550e7e
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/entry-macro.S
@@ -0,0 +1,98 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/entry-macro.S
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <mach/io.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <asm/hardware/vic.h>
+
+	.macro getioaddr, rp, rv
+	ldr	\rp, =SW_IO_PHYS
+	ldr	\rv, =SW_IO_VIRT
+	.endm
+
+        .macro  disable_fiq
+        .endm
+
+        .macro  get_irqnr_preamble, base, tmp
+        ldr \base, =SW_VA_INT_IO_BASE
+        .endm
+
+        .macro  arch_ret_to_user, tmp1, tmp2
+        .endm
+
+        .macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+        ldr \irqstat, [\base, #0x10]    @ get pending status
+        mov \irqnr, #0
+        teq \irqstat, #0
+        beq 1003f
+
+1001:   tst \irqstat, #15
+        bne 1002f
+        add \irqnr, \irqnr, #4
+        movs    \irqstat, \irqstat, lsr #4
+        bne 1001b
+1002:   tst \irqstat, #1
+        bne 5000f
+        add \irqnr, \irqnr, #1
+        movs    \irqstat, \irqstat, lsr #1
+        bne 1002b
+1003:   /* EQ will be set if no irqs pending */
+
+        ldr \irqstat, [\base, #0x14]    @ get pending status
+        teq \irqstat, #0
+        beq 3000f
+
+        mov \irqnr, #32
+2001:       tst \irqstat, #15
+        bne 2002f
+        add \irqnr, \irqnr, #4
+        movs    \irqstat, \irqstat, lsr #4
+        bne 2001b
+2002:       tst \irqstat, #1
+        bne 5000f
+        add \irqnr, \irqnr, #1
+        movs    \irqstat, \irqstat, lsr #1
+        bne 2002b
+
+3000:   /* EQ will be set if no irqs pending */
+
+        ldr \irqstat, [\base, #0x18]    @ get pending status
+        teq \irqstat, #0
+        beq 5000f
+
+        mov \irqnr, #64
+4001:       tst \irqstat, #15
+        bne 4002f
+        add \irqnr, \irqnr, #4
+        movs    \irqstat, \irqstat, lsr #4
+        bne 4001b
+4002:       tst \irqstat, #1
+        bne 5000f
+        add \irqnr, \irqnr, #1
+        movs    \irqstat, \irqstat, lsr #1
+        bne 4002b
+
+5000:
+        .endm
+
diff --git a/arch/arm/plat-sunxi/include/plat/gpio.h b/arch/arm/plat-sunxi/include/plat/gpio.h
new file mode 100644
index 0000000..fc3c665
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/gpio.h
@@ -0,0 +1,29 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __SUNXI_GPIO_H
+#define __SUNXI_GPIO_H
+
+#include <asm-generic/gpio.h>
+
+#define gpio_get_value	__gpio_get_value
+#define gpio_set_value	__gpio_set_value
+#define gpio_cansleep	__gpio_cansleep
+#define gpio_to_irq	__gpio_to_irq
+
+#endif /* __SUNXI_GPIO_H */
diff --git a/arch/arm/plat-sunxi/include/plat/hardware.h b/arch/arm/plat-sunxi/include/plat/hardware.h
new file mode 100644
index 0000000..2dd6558
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/hardware.h
@@ -0,0 +1,36 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/hardware.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_HARDWARE_H
+#define __SW_HARDWARE_H
+
+#include <asm/sizes.h>
+
+/* macro to get at IO space when running virtually */
+#define IO_ADDRESS(x)           ((x) + 0xf0000000)
+
+#define __io_address(n)         __io(IO_ADDRESS(n))
+
+#endif
+
+
diff --git a/arch/arm/plat-sunxi/include/plat/i2c.h b/arch/arm/plat-sunxi/include/plat/i2c.h
new file mode 100644
index 0000000..be8fe41
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/i2c.h
@@ -0,0 +1,207 @@
+/*
+ * arch/arm/mach-sunxi/include/plat/i2c.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tanglaing@allwinnertech.com>
+ * Victor Wei <weiziheng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SUNXI_I2C_PRIVATE_H_
+#define _SUNXI_I2C_PRIVATE_H_
+
+#define TWI_MODULE_NUM    (3)
+
+/* TWI Register Offset */
+#define TWI_ADDR_REG    	(0x00) 	/*  31:8bit reserved,7-1bit for slave addr,0 bit for GCE */
+#define TWI_XADDR_REG   	(0x04) 	/*  31:8bit reserved,7-0bit for second addr in 10bit addr */
+#define TWI_DATA_REG    	(0x08) 	/*  31:8bit reserved, 7-0bit send or receive data byte */
+#define TWI_CTL_REG     	(0x0C) 	/*  INT_EN,BUS_EN,M_STA,INT_FLAG,A_ACK */
+#define TWI_STAT_REG    	(0x10) 	/*  28 interrupt types + 0xF8 normal type = 29  */
+#define TWI_CLK_REG     	(0x14) 	/*  31:7bit reserved,6-3bit,CLK_M,2-0bit CLK_N */
+#define TWI_SRST_REG    	(0x18) 	/*  31:1bit reserved;0bit,write 1 to clear 0. */
+#define TWI_EFR_REG     	(0x1C) 	/*  31:2bit reserved,1:0 bit data byte follow read comand */
+#define TWI_LCR_REG     	(0x20) 	/*  31:6bits reserved  5:0bit for sda&scl control*/
+#define TWI_DVFS_REG		(0x24)  /*  31:3bits reserved  2:0bit for dvfs control */
+
+/* TWI address register */
+#define TWI_GCE_EN      	(0x1 <<0) /* general call address enable for slave mode */
+#define TWI_ADDR_MASK   	(0x7f<<1) /* 7:1bits */
+/* 31:8bits reserved */
+
+
+/* TWI extend address register */
+#define TWI_XADDR_MASK  (0xff) /* 7:0bits for extend slave address */
+/* 31:8bits reserved */
+
+
+/* TWI Data register default is 0x0000_0000 */
+#define TWI_DATA_MASK   (0xff) /* 7:0bits for send or received */
+
+/* TWI Control Register Bit Fields & Masks, default value: 0x0000_0000*/
+/* 1:0 bits reserved */
+#define TWI_CTL_ACK		(0x1<<2) /* set 1 to send A_ACK,then low level on SDA */
+#define TWI_CTL_INTFLG	(0x1<<3) /* INT_FLAG,interrupt status flag: set '1' when interrupt coming */
+#define TWI_CTL_STP		(0x1<<4) /* M_STP,Automatic clear 0 */
+#define TWI_CTL_STA		(0x1<<5) /* M_STA,atutomatic clear 0 */
+#define TWI_CTL_BUSEN	(0x1<<6) /* BUS_EN, master mode should be set 1.*/
+#define TWI_CTL_INTEN	(0x1<<7) /* INT_EN */
+/* 31:8 bit reserved */
+
+
+/* TWI Clock Register Bit Fields & Masks,default value:0x0000_0000 */
+/*
+Fin is APB CLOCK INPUT;
+Fsample = F0 = Fin/2^CLK_N;
+          F1 = F0/(CLK_M+1);
+
+Foscl = F1/10 = Fin/(2^CLK_N * (CLK_M+1)*10);
+Foscl is clock SCL;standard mode:100KHz or fast mode:400KHz
+*/
+#define TWI_CLK_DIV_M		(0xF<<3) /* 6:3bit  */
+#define TWI_CLK_DIV_N		(0x7<<0) /* 2:0bit */
+
+
+/* TWI Soft Reset Register Bit Fields & Masks  */
+#define TWI_SRST_SRST		(0x1<<0) /* write 1 to clear 0, when complete soft reset clear 0 */
+
+
+/* TWI Enhance Feature Register Bit Fields & Masks  */
+/* default -- 0x0 */
+#define TWI_EFR_MASK        (0x3<<0)/* 00:no,01: 1byte, 10:2 bytes, 11: 3bytes */
+#define TWI_EFR_WARC_0      (0x0<<0)
+#define TWI_EFR_WARC_1      (0x1<<0)
+#define TWI_EFR_WARC_2      (0x2<<0)
+#define TWI_EFR_WARC_3      (0x3<<0)
+
+
+/* twi line control register -default value: 0x0000_003a */
+#define TWI_LCR_SDA_EN          (0x01<<0) 	/* SDA line state control enable ,1:enable;0:disable */
+#define TWI_LCR_SDA_CTL         (0x01<<1) 	/* SDA line state control bit, 1:high level;0:low level */
+#define TWI_LCR_SCL_EN          (0x01<<2) 	/* SCL line state control enable ,1:enable;0:disable */
+#define TWI_LCR_SCL_CTL         (0x01<<3) 	/* SCL line state control bit, 1:high level;0:low level */
+#define TWI_LCR_SDA_STATE_MASK  (0x01<<4)   /* current state of SDA,readonly bit */
+#define TWI_LCR_SCL_STATE_MASK  (0x01<<5)   /* current state of SCL,readonly bit */
+/* 31:6bits reserved */
+#define TWI_LCR_IDLE_STATUS     (0x3a)
+
+
+/* TWI Status Register Bit Fields & Masks  */
+#define TWI_STAT_MASK                   (0xff)
+/* 7:0 bits use only,default is 0xF8 */
+#define TWI_STAT_BUS_ERR				(0x00) 	/* BUS ERROR */
+/* Master mode use only */
+#define TWI_STAT_TX_STA					(0x08) 	/* START condition transmitted */
+#define TWI_STAT_TX_RESTA				(0x10) 	/* Repeated START condition transmitted */
+#define TWI_STAT_TX_AW_ACK				(0x18) 	/* Address+Write bit transmitted, ACK received */
+#define TWI_STAT_TX_AW_NAK				(0x20) 	/* Address+Write bit transmitted, ACK not received */
+#define TWI_STAT_TXD_ACK				(0x28) 	/* data byte transmitted in master mode,ack received */
+#define TWI_STAT_TXD_NAK				(0x30) 	/* data byte transmitted in master mode ,ack not received */
+#define TWI_STAT_ARBLOST				(0x38) 	/* arbitration lost in address or data byte */
+#define TWI_STAT_TX_AR_ACK				(0x40) 	/* Address+Read bit transmitted, ACK received */
+#define TWI_STAT_TX_AR_NAK				(0x48) 	/* Address+Read bit transmitted, ACK not received */
+#define TWI_STAT_RXD_ACK				(0x50) 	/* data byte received in master mode ,ack transmitted */
+#define TWI_STAT_RXD_NAK				(0x58) 	/* date byte received in master mode,not ack transmitted */
+/* Slave mode use only */
+#define TWI_STAT_RXWS_ACK				(0x60) 	/* Slave address+Write bit received, ACK transmitted */
+#define TWI_STAT_ARBLOST_RXWS_ACK		(0x68)
+#define TWI_STAT_RXGCAS_ACK				(0x70) 	/* General Call address received, ACK transmitted */
+#define TWI_STAT_ARBLOST_RXGCAS_ACK		(0x78)
+#define TWI_STAT_RXDS_ACK				(0x80)
+#define TWI_STAT_RXDS_NAK				(0x88)
+#define TWI_STAT_RXDGCAS_ACK			(0x90)
+#define TWI_STAT_RXDGCAS_NAK			(0x98)
+#define TWI_STAT_RXSTPS_RXRESTAS		(0xA0)
+#define TWI_STAT_RXRS_ACK				(0xA8)
+
+#define TWI_STAT_ARBLOST_SLAR_ACK       (0xB0)
+
+/* 10bit Address, second part of address */
+#define TWI_STAT_TX_SAW_ACK             (0xD0) 	/* Second Address byte+Write bit transmitted,ACK received */
+#define TWI_STAT_TX_SAW_NAK             (0xD8) 	/* Second Address byte+Write bit transmitted,ACK not received */
+
+#define TWI_STAT_IDLE					(0xF8) 	/* No relevant status infomation,INT_FLAG = 0 */
+
+
+/* status or interrupt source */
+/*------------------------------------------------------------------------------
+* Code   Status
+* 00h    Bus error
+* 08h    START condition transmitted
+* 10h    Repeated START condition transmitted
+* 18h    Address + Write bit transmitted, ACK received
+* 20h    Address + Write bit transmitted, ACK not received
+* 28h    Data byte transmitted in master mode, ACK received
+* 30h    Data byte transmitted in master mode, ACK not received
+* 38h    Arbitration lost in address or data byte
+* 40h    Address + Read bit transmitted, ACK received
+* 48h    Address + Read bit transmitted, ACK not received
+* 50h    Data byte received in master mode, ACK transmitted
+* 58h    Data byte received in master mode, not ACK transmitted
+* 60h    Slave address + Write bit received, ACK transmitted
+* 68h    Arbitration lost in address as master, slave address + Write bit received, ACK transmitted
+* 70h    General Call address received, ACK transmitted
+* 78h    Arbitration lost in address as master, General Call address received, ACK transmitted
+* 80h    Data byte received after slave address received, ACK transmitted
+* 88h    Data byte received after slave address received, not ACK transmitted
+* 90h    Data byte received after General Call received, ACK transmitted
+* 98h    Data byte received after General Call received, not ACK transmitted
+* A0h    STOP or repeated START condition received in slave mode
+* A8h    Slave address + Read bit received, ACK transmitted
+* B0h    Arbitration lost in address as master, slave address + Read bit received, ACK transmitted
+* B8h    Data byte transmitted in slave mode, ACK received
+* C0h    Data byte transmitted in slave mode, ACK not received
+* C8h    Last byte transmitted in slave mode, ACK received
+* D0h    Second Address byte + Write bit transmitted, ACK received
+* D8h    Second Address byte + Write bit transmitted, ACK not received
+* F8h    No relevant status information or no interrupt
+*-----------------------------------------------------------------------------*/
+
+/* TWI mode select */
+#define TWI_MASTER_MODE     (1)
+#define TWI_SLAVE_MODE      (0)	/* seldom use */
+
+#define AW_TWI_ADDR_SIZE		0x3ff
+
+#define TWI0_BASE_ADDR_START  (SW_PA_TWI0_IO_BASE )
+#define TWI0_BASE_ADDR_END    (TWI0_BASE_ADDR_START + AW_TWI_ADDR_SIZE)
+
+#define TWI1_BASE_ADDR_START  (SW_PA_TWI1_IO_BASE )
+#define TWI1_BASE_ADDR_END    (TWI1_BASE_ADDR_START + AW_TWI_ADDR_SIZE)
+
+#define TWI2_BASE_ADDR_START  (SW_PA_TWI2_IO_BASE )
+#define TWI2_BASE_ADDR_END    (TWI2_BASE_ADDR_START + AW_TWI_ADDR_SIZE)
+
+#define TWI3_BASE_ADDR_START  (SW_PA_TWI3_IO_BASE )
+#define TWI3_BASE_ADDR_END    (TWI3_BASE_ADDR_START + AW_TWI_ADDR_SIZE)
+
+#define TWI4_BASE_ADDR_START  (SW_PA_TWI4_IO_BASE )
+#define TWI4_BASE_ADDR_END    (TWI4_BASE_ADDR_START + AW_TWI_ADDR_SIZE)
+
+#define I2C0_TRANSFER_SPEED     (400000)
+#define I2C1_TRANSFER_SPEED     (200000)
+#define I2C2_TRANSFER_SPEED     (200000)
+#define I2C3_TRANSFER_SPEED     (200000)
+#define I2C4_TRANSFER_SPEED     (200000)
+
+struct sunxi_i2c_platform_data {
+	int 		 bus_num;
+	unsigned int frequency;
+};
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/io.h b/arch/arm/plat-sunxi/include/plat/io.h
new file mode 100644
index 0000000..c44016a
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/io.h
@@ -0,0 +1,35 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/io.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_IO_H
+#define __SW_IO_H
+
+#define IO_SPACE_LIMIT 0x1ffffff
+
+#define SW_IO_PHYS      0x01c00000
+#define SW_IO_VIRT      0xf1c00000
+
+#define __mem_pci(a) (a)
+#define __io(a)         __typesafe_io(a)
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/irqs.h b/arch/arm/plat-sunxi/include/plat/irqs.h
new file mode 100644
index 0000000..fb3ea55
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/irqs.h
@@ -0,0 +1,189 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/irqs.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __PLAT_IRQS_H
+#define __PLAT_IRQS_H
+
+#ifndef __MACH_IRQS_H__
+#error plat/irqs.h may only be included from arch/irqs.h
+#endif
+
+#include <mach/platform.h>
+
+/*----------- interrupt register list -------------------------------------------*/
+
+
+/* registers */
+
+/* mask */
+#ifdef CONFIG_ARCH_SUN7I
+#define AW_IRQ_GIC_START	32
+#define SW_INT_START		AW_IRQ_GIC_START
+#define NR_IRQS			(AW_IRQ_GIC_START + 128)
+#define MAX_GIC_NR		1
+#else
+#define SW_INT_START		0
+#define NR_IRQS			(96+32)
+#endif
+
+/*
+ * sgi and ppi irq sources
+ */
+#ifdef CONFIG_ARCH_SUN7I
+
+#define IRQ_SGI0		0
+#define IRQ_SGI1		1
+#define IRQ_SGI2		2
+#define IRQ_SGI3		3
+#define IRQ_SGI4		4
+#define IRQ_SGI5		5
+#define IRQ_SGI6		6
+#define IRQ_SGI7		7
+#define IRQ_SGI8		8
+#define IRQ_SGI9		9
+#define IRQ_SGI10		10
+#define IRQ_SGI11		11
+#define IRQ_SGI12		12
+#define IRQ_SGI13		13
+#define IRQ_SGI14		14
+#define IRQ_SGI15		15
+#define IRQ_PPI0		0
+#define IRQ_PPI1		1
+#define IRQ_PPI2		2
+#define IRQ_PPI3		3
+#define IRQ_PPI4		4
+#define IRQ_PPI5		5
+#define IRQ_PPI6		6
+#define IRQ_PPI7		7
+#define IRQ_PPI8		8
+#define IRQ_PPI9		9
+#define IRQ_PPI10		10
+#define IRQ_PPI11		11
+#define IRQ_PPI12		12
+#define IRQ_PPI13		13
+#define IRQ_PPI14		14
+#define IRQ_PPI15		15
+
+#endif /* CONFIG_ARCH_SUN7I */
+
+#define SW_INT_IRQNO_ENMI		(0 + SW_INT_START)
+#define SW_INT_IRQNO_NMI		(0 + SW_INT_START)
+#define SW_INT_IRQNO_UART0		(1 + SW_INT_START)
+#define SW_INT_IRQNO_UART1		(2 + SW_INT_START)
+#define SW_INT_IRQNO_UART2		(3 + SW_INT_START)
+#define SW_INT_IRQNO_UART3		(4 + SW_INT_START)
+#define SW_INT_IRQNO_IR0		(5 + SW_INT_START)
+#define SW_INT_IRQNO_IR1		(6 + SW_INT_START)
+#define SW_INT_IRQNO_TWI0		(7 + SW_INT_START)
+#define SW_INT_IRQNO_TWI1		(8 + SW_INT_START)
+#define SW_INT_IRQNO_TWI2		(9 + SW_INT_START)
+#define SW_INT_IRQNO_SPI00		(10 + SW_INT_START)
+#define SW_INT_IRQNO_SPI01		(11 + SW_INT_START)
+#define SW_INT_IRQNO_SPI02		(12 + SW_INT_START)
+#define SW_INT_IRQNO_SPDIF		(13 + SW_INT_START)
+#define SW_INT_IRQNO_AC97		(14 + SW_INT_START)
+#define SW_INT_IRQNO_TS			(15 + SW_INT_START)
+#define SW_INT_IRQNO_I2S		(16 + SW_INT_START)
+#define SW_INT_IRQNO_UART4		(17 + SW_INT_START)
+#define SW_INT_IRQNO_UART5		(18 + SW_INT_START)
+#define SW_INT_IRQNO_UART6		(19 + SW_INT_START)
+#define SW_INT_IRQNO_UART7		(20 + SW_INT_START)
+#define SW_INT_IRQNO_KEYPAD		(21 + SW_INT_START)
+#define SW_INT_IRQNO_TIMER0		(22 + SW_INT_START)
+#define SW_INT_IRQNO_TIMER1		(23 + SW_INT_START)
+#define SW_INT_IRQNO_ALARM		(24 + SW_INT_START)
+#define SW_INT_IRQNO_TIMER2		(24 + SW_INT_START)
+#define SW_INT_IRQNO_TIMER3		(25 + SW_INT_START)
+#define SW_INT_IRQNO_CAN		(26 + SW_INT_START)
+#define SW_INT_IRQNO_DMA		(27 + SW_INT_START)
+#define SW_INT_IRQNO_PIO		(28 + SW_INT_START)
+#define SW_INT_IRQNO_TOUCH_PANEL	(29 + SW_INT_START)
+#define SW_INT_IRQNO_AUDIO_CODEC	(30 + SW_INT_START)
+#define SW_INT_IRQNO_LRADC		(31 + SW_INT_START)
+#define SW_INT_IRQNO_SDMC0		(32 + SW_INT_START)
+#define SW_INT_IRQNO_SDMC1		(33 + SW_INT_START)
+#define SW_INT_IRQNO_SDMC2		(34 + SW_INT_START)
+#define SW_INT_IRQNO_SDMC3		(35 + SW_INT_START)
+#define SW_INT_IRQNO_MEMSTICK		(36 + SW_INT_START)
+#define SW_INT_IRQNO_NAND		(37 + SW_INT_START)
+
+#define SW_INT_IRQNO_USB0		(38 + SW_INT_START)
+#define SW_INT_IRQNO_USB1		(39 + SW_INT_START)
+#define SW_INT_IRQNO_USB2		(40 + SW_INT_START)
+#define SW_INTC_IRQNO_SCR		(41 + SW_INT_START)
+#define SW_INTC_IRQNO_CSI0		(42 + SW_INT_START)
+#define SW_INTC_IRQNO_CSI1		(43 + SW_INT_START)
+
+#define SW_INT_IRQNO_LCDCTRL0		(44 + SW_INT_START)
+#define SW_INT_IRQNO_LCDCTRL1		(45 + SW_INT_START)
+#define SW_INT_IRQNO_MP			(46 + SW_INT_START)
+#define SW_INT_IRQNO_DEFEBE0		(47 + SW_INT_START)
+#define SW_INT_IRQNO_DEFEBE1		(48 + SW_INT_START)
+#define SW_INT_IRQNO_PMU		(49 + SW_INT_START)
+#define SW_INT_IRQNO_SPI3		(50 + SW_INT_START)
+#define SW_INT_IRQNO_TZASC		(51 + SW_INT_START)
+#define SW_INT_IRQNO_PATA		(52 + SW_INT_START)
+#define SW_INT_IRQNO_VE			(53 + SW_INT_START)
+#define SW_INT_IRQNO_SS			(54 + SW_INT_START)
+#define SW_INT_IRQNO_EMAC		(55 + SW_INT_START)
+#define SW_INT_IRQNO_SATA		(56 + SW_INT_START)
+#define SW_INT_IRQNO_GPS		(57 + SW_INT_START)
+#define SW_INT_IRQNO_HDMI		(58 + SW_INT_START)
+#define SW_INT_IRQNO_TVE		(59 + SW_INT_START)
+#define SW_INT_IRQNO_ACE		(60 + SW_INT_START)
+#define SW_INT_IRQNO_TVD		(61 + SW_INT_START)
+#define SW_INT_IRQNO_PS2_0		(62 + SW_INT_START)
+#define SW_INT_IRQNO_PS2_1		(63 + SW_INT_START)
+#define SW_INT_IRQNO_USB3		(64 + SW_INT_START)
+#define SW_INT_IRQNO_USB4		(65 + SW_INT_START)
+#define SW_INT_IRQNO_PLE_PFM		(66 + SW_INT_START)
+#define SW_INT_IRQNO_TIMER4		(67 + SW_INT_START)
+#define SW_INT_IRQNO_TIMER5		(68 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_GP		(69 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_GPMMU		(70 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_PP0		(71 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_PPMMU0		(72 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_PMU		(73 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_RSV0		(74 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_RSV1		(75 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_RSV2		(76 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_RSV3		(77 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_RSV4		(78 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_RSV5		(79 + SW_INT_START)
+#define SW_INT_IRQNO_GPU_RSV6		(80 + SW_INT_START)
+
+/* sun5i only */
+#define SW_INT_IRQNO_SYNC_TIMER0	(82 + SW_INT_START)
+#define SW_INT_IRQNO_SYNC_TIMER1	(83 + SW_INT_START)
+
+/* sun7i only */
+#define SW_INT_IRQNO_TWI3		(88 + SW_INT_START)
+#define SW_INT_IRQNO_TWI4		(89 + SW_INT_START)
+
+#ifdef CONFIG_ARCH_SUN7I
+#define SW_INT_END				  (127 + SW_INT_START)
+#else
+#define SW_INT_END				  (95 + SW_INT_START)
+#endif /* sun7i */
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/mbr311.h b/arch/arm/plat-sunxi/include/plat/mbr311.h
new file mode 100644
index 0000000..bf6e255
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/mbr311.h
@@ -0,0 +1,74 @@
+/*
+ * drivers/block/sunxi_nand/nfd/mbr.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef    __MBR311_H__
+#define    __MBR311_H__
+
+#include <linux/kernel.h>
+
+#define MAX_PART_COUNT		15	 		//max part count
+#define MBR_COPY_NUM		4    			//mbr backup count
+
+#define MBR_START_ADDRESS	0x0			//mbr start address
+#define MBR_SIZE		1024UL			//mbr size
+#define MBR_PART_SIZE		sizeof(struct tag_PARTITION)
+#define MBR_RESERVED		(MBR_SIZE - sizeof(struct tag_MBR) - \
+					(MAX_PART_COUNT * MBR_PART_SIZE))
+#define MBR_VERSION		0x100
+#define MBR_MAGIC		"softw311"
+
+struct nand_disk{
+	unsigned long size;
+	unsigned long offset;
+	unsigned char type;
+};
+
+/* part info */
+struct tag_PARTITION {
+	__u32 addrhi;				//start address high 32 bit
+	__u32 addrlo;				//start address low 32 bit
+	__u32 lenhi;				//size high 32 bit
+	__u32 lenlo;				//size low 32 bit
+	__u8  classname[12];		//major device name
+	__u8  name[12];				//minor device name
+	unsigned  int       user_type;          //
+	unsigned  int       ro;                 //
+	__u8  res[16];				//reserved
+};
+
+/* mbr info */
+struct tag_MBR {
+	__u32 crc32;					// crc, from byte 4 to mbr tail
+	__u32 version;					// version
+	__u8  magic[8];					// magic number
+	__u8  copy;						// mbr backup count
+	__u8  index;					// current part	no
+	__u16   PartCount;				// part counter
+};
+
+struct MBR {
+	struct tag_MBR tag;
+	struct tag_PARTITION array[MAX_PART_COUNT];// part info
+	__u8 res[MBR_RESERVED];         // reserved space
+};
+
+#endif    //__MBR311_H__
diff --git a/arch/arm/plat-sunxi/include/plat/mbr411.h b/arch/arm/plat-sunxi/include/plat/mbr411.h
new file mode 100644
index 0000000..0b7d42f
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/mbr411.h
@@ -0,0 +1,76 @@
+/*
+ * drivers/block/sunxi_nand/nfd/mbr.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef    __MBR411_H__
+#define    __MBR411_H__
+
+#include <linux/kernel.h>
+
+#define MAX_PART_COUNT		120			//max part count
+#define MBR_COPY_NUM		4			//mbr backup count
+
+#define MBR_START_ADDRESS	0x0			//mbr start address
+#define MBR_SIZE		1024UL*16UL		//mbr size
+#define MBR_PART_SIZE		sizeof(struct tag_PARTITION)
+#define MBR_RESERVED		(MBR_SIZE - sizeof(struct tag_MBR) - \
+					(MAX_PART_COUNT * MBR_PART_SIZE))
+#define MBR_VERSION		0x200
+#define MBR_MAGIC		"softw411"
+
+struct nand_disk{
+	unsigned long size;
+	unsigned long offset;
+	unsigned char type;
+};
+
+/* part info */
+struct tag_PARTITION {
+	__u32 addrhi;				//start address high 32 bit
+	__u32 addrlo;				//start address low 32 bit
+	__u32 lenhi;				//size high 32 bit
+	__u32 lenlo;				//size low 32 bit
+	__u8  classname[16];			//major device name
+	__u8  name[16];				//minor device name
+	__u32 user_type;			//
+	__u32 keydata;				//
+	__u32 ro;				//
+	__u8  res[68];				//reserved
+} __attribute__((packed));
+
+/* mbr info */
+struct tag_MBR {
+	__u32		crc32;				// crc, from byte 4 to mbr tail
+	__u32		version;			// version
+	__u8		magic[8];			// magic number
+	__u32		copy;				// mbr backup count
+	__u32		index;				// current part no
+	__u32		PartCount;			// part counter
+	__u32		stamp[1];			// 
+} __attribute__((packed));
+
+struct MBR {
+	struct tag_MBR tag;
+	struct tag_PARTITION	array[MAX_PART_COUNT];		// part info
+	__u8		res[MBR_RESERVED];		// reserved space
+} __attribute__((packed));
+
+#endif    //__MBR411_H__
diff --git a/arch/arm/plat-sunxi/include/plat/memory.h b/arch/arm/plat-sunxi/include/plat/memory.h
new file mode 100644
index 0000000..a7f692f
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/memory.h
@@ -0,0 +1,33 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/memory.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_MEMORY_H
+#define __SW_MEMORY_H
+
+/* physical offset of RAM */
+#define PLAT_PHYS_OFFSET		UL(0x40000000)
+
+/* default ATAG_MEM size */
+#define MEM_SIZE	(512*1024*1024)
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/platform.h b/arch/arm/plat-sunxi/include/plat/platform.h
new file mode 100644
index 0000000..f180a1d
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/platform.h
@@ -0,0 +1,335 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/platform.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_PLATFORM_H
+#define __SW_PLATFORM_H
+
+/* Physical Address */
+#define SW_PA_BROM_START                  0xffff0000
+#define SW_PA_BROM_END                    0xffff7fff   /* 32KB */
+
+#define SW_PA_SRAM_BASE                   0x00000000
+
+/* sun7i sram addresses */
+#define SW_PA_SRAM_A1_BASE                0x00000000
+#define SW_PA_SRAM_A2_BASE                0x00004000
+#define SW_PA_SRAM_A3_BASE                0x00008000
+#define SW_PA_SRAM_A4_BASE                0x0000b400
+#define SW_PA_SRAM_D_BASE                 0x00010000
+#define SW_PA_SRAM_B_BASE                 0x00020000
+
+#define SW_PA_SDRAM_START                 0x40000000
+#define SW_PA_IO_BASE                     0x01c00000
+#define SW_PA_SRAM_IO_BASE                0x01c00000   /* 4KB */
+#define SW_PA_DRAM_IO_BASE                0x01c01000
+#define SW_PA_DMAC_IO_BASE                0x01c02000
+#define SW_PA_NANDFLASHC_IO_BASE          0x01c03000
+#define SW_PA_TSI_IO_BASE                 0x01c04000
+#define SW_PA_SPI0_IO_BASE                0x01c05000
+#define SW_PA_SPI1_IO_BASE                0x01c06000
+#define SW_PA_MSCC_IO_BASE                0x01c07000
+#define SW_PA_TVD_IO_BASE                 0x01c08000
+#define SW_PA_CSI0_IO_BASE                0x01c09000
+#define SW_PA_TVE_IO_BASE                 0x01c0a000
+#define SW_PA_EMAC_IO_BASE                0x01c0b000
+#define SW_PA_TCON0_IO_BASE               0x01c0c000
+#define SW_PA_TCON1_IO_BASE               0x01c0d000
+#define SW_PA_VE_IO_BASE                  0x01c0e000
+#define SW_PA_SDC0_IO_BASE                0x01c0f000
+#define SW_PA_SDC1_IO_BASE                0x01c10000
+#define SW_PA_SDC2_IO_BASE                0x01c11000
+#define SW_PA_SDC3_IO_BASE                0x01c12000
+#define SW_PA_USB0_IO_BASE                0x01c13000
+#define SW_PA_USB1_IO_BASE                0x01c14000
+#define SW_PA_SSE_IO_BASE                 0x01c15000
+#define SW_PA_HDMI_IO_BASE                0x01c16000
+#define SW_PA_SPI2_IO_BASE                0x01c17000
+#define SW_PA_SATA_IO_BASE                0x01c18000
+#define SW_PA_PATA_IO_BASE                0x01c19000
+#define SW_PA_ACE_IO_BASE                 0x01c1a000
+#define SW_PA_TVE1_IO_BASE                0x01c1b000
+#define SW_PA_USB2_IO_BASE                0x01c1c000
+#define SW_PA_CSI1_IO_BASE                0x01c1d000
+#define SW_PA_TZASC_IO_BASE               0x01c1e000
+#define SW_PA_SPI3_IO_BASE                0x01c1f000
+#define SW_PA_CCM_IO_BASE                 0x01c20000
+#define SW_PA_INT_IO_BASE                 0x01c20400
+#define SW_PA_PORTC_IO_BASE               0x01c20800
+#define SW_PA_TIMERC_IO_BASE              0x01c20c00
+#define SW_PA_SPDIF_IO_BASE               0x01c21000
+#define SW_PA_AC97_IO_BASE                0x01c21400
+#define SW_PA_IR0_IO_BASE                 0x01c21800
+#define SW_PA_IR1_IO_BASE                 0x01c21c00
+#define SW_PA_IIS1_IO_BASE                0x01c22000
+#define SW_PA_IIS_IO_BASE                 0x01c22400
+#define SW_PA_LRADC_IO_BASE               0x01c22800
+#define SW_PA_ADDA_IO_BASE                0x01c22c00
+#define SW_PA_KEYPAD_IO_BASE              0x01c23000
+#define SW_PA_TZPC_IO_BASE                0x01c23400
+#define SW_PA_SID_IO_BASE                 0x01c23800
+#define SW_PA_SJTAG_IO_BASE               0x01c23c00
+#define SW_PA_IIS2_IO_BASE                0x01c24400
+#define SW_PA_TP_IO_BASE                  0x01c25000
+#define SW_PA_PMU_IO_BASE                 0x01c25400
+#define SW_PA_CPUCFG_IO_BASE              0x01c25c00
+#define SW_PA_UART0_IO_BASE               0x01c28000
+#define SW_PA_UART1_IO_BASE               0x01c28400
+#define SW_PA_UART2_IO_BASE               0x01c28800
+#define SW_PA_UART3_IO_BASE               0x01c28c00
+#define SW_PA_UART4_IO_BASE               0x01c29000
+#define SW_PA_UART5_IO_BASE               0x01c29400
+#define SW_PA_UART6_IO_BASE               0x01c29800
+#define SW_PA_UART7_IO_BASE               0x01c29c00
+#define SW_PA_PS20_IO_BASE                0x01c2a000
+#define SW_PA_PS21_IO_BASE                0x01c2a400
+#define SW_PA_TWI0_IO_BASE                0x01c2ac00
+#define SW_PA_TWI1_IO_BASE                0x01c2b000
+#define SW_PA_TWI2_IO_BASE                0x01c2b400
+#define SW_PA_TWI3_IO_BASE                0x01c2b800
+#define SW_PA_CAN0_IO_BASE                0x01c2bc00
+#define SW_PA_CAN1_IO_BASE                0x01c2c000 /* sun4i */
+#define SW_PA_TWI4_IO_BASE                0x01c2c000 /* sun7i */
+#define SW_PA_SCR_IO_BASE                 0x01c2c400
+#define SW_PA_GPS_IO_BASE                 0x01c30000
+#define SW_PA_MALI_IO_BASE                0x01c40000
+#define SW_PA_GMAC_IO_BASE                0x01c50000
+#define SW_PA_HSTIMER_IO_BASE             0x01c60000
+#define SW_PA_GIC_IO_BASE                 0x01c80000
+#define SW_PA_GIC_DIST_IO_BASE            0x01c81000
+#define SW_PA_GIC_CPU_IO_BASE             0x01c82000
+#define SW_PA_SCU_IO_BASE                 0x01c80000
+#define SW_PA_TIMER_G_IO_BASE             0x01c80200 /* CPU global timer, not used */
+#define SW_PA_TIMER_P_IO_BASE             0x01c80600 /* CPU private timer, not used */
+#define SW_PA_HDMI1_IO_BASE               0x01ce0000
+#define SW_PA_SRAM_C_IO_BASE              0x01d00000
+#define SW_PA_DEFE0_IO_BASE               0x01e00000
+#define SW_PA_DEFE1_IO_BASE               0x01e20000
+#define SW_PA_DEBE0_IO_BASE               0x01e60000
+#define SW_PA_DEBE1_IO_BASE               0x01e40000
+#define SW_PA_MP_IO_BASE                  0x01e80000
+#define SW_PA_AVG_IO_BASE                 0x01ea0000
+#define SW_PA_CPUBIST_IO_BASE             0x3f501000
+#define SW_PA_BROM_BASE                   0xffff0000
+
+/* Virtual Address */
+#define SW_VA_SRAM_BASE                   0xf0000000	/*16KB*/
+
+/* sun7i sram addresses */
+#define SW_VA_SRAM_A1_BASE                0xf0000000
+#define SW_VA_SRAM_A2_BASE                0xf0004000
+#define SW_VA_SRAM_A3_BASE                0xf0008000
+#define SW_VA_SRAM_A4_BASE                0xf000b400
+#define SW_VA_SRAM_D_BASE                 0xf0010000
+#define SW_VA_SRAM_B_BASE                 0xf0020000
+
+#define SW_VA_BROM_BASE                   0xf0100000	/*64KB*/
+#define SW_VA_BROM_START                  0xf0100000
+#define SW_VA_BROM_END                    0xf0107fff
+
+#define SW_VA_IO_BASE                     0xf1c00000
+#define SW_VA_SRAM_IO_BASE                0xf1c00000   /* 4KB */
+#define SW_VA_DRAM_IO_BASE                0xf1c01000
+#define SW_VA_DMAC_IO_BASE                0xf1c02000
+#define SW_VA_NANDFLASHC_IO_BASE          0xf1c03000
+#define SW_VA_TSI_IO_BASE                 0xf1c04000
+#define SW_VA_SPI0_IO_BASE                0xf1c05000
+#define SW_VA_SPI1_IO_BASE                0xf1c06000
+#define SW_VA_MSCC_IO_BASE                0xf1c07000
+#define SW_VA_TVD_IO_BASE                 0xf1c08000
+#define SW_VA_CSI0_IO_BASE                0xf1c09000
+#define SW_VA_TVE_IO_BASE                 0xf1c0a000
+#define SW_VA_EMAC_IO_BASE                0xf1c0b000
+#define SW_VA_TCON0_IO_BASE               0xf1c0c000
+#define SW_VA_TCON1_IO_BASE               0xf1c0d000
+#define SW_VA_VE_IO_BASE                  0xf1c0e000
+#define SW_VA_SDC0_IO_BASE                0xf1c0f000
+#define SW_VA_SDC1_IO_BASE                0xf1c10000
+#define SW_VA_SDC2_IO_BASE                0xf1c11000
+#define SW_VA_SDC3_IO_BASE                0xf1c12000
+#define SW_VA_USB0_IO_BASE                0xf1c13000
+#define SW_VA_USB1_IO_BASE                0xf1c14000
+#define SW_VA_SSE_IO_BASE                 0xf1c15000
+#define SW_VA_HDMI_IO_BASE                0xf1c16000
+#define SW_VA_SPI2_IO_BASE                0xf1c17000
+#define SW_VA_SATA_IO_BASE                0xf1c18000
+#define SW_VA_PATA_IO_BASE                0xf1c19000
+#define SW_VA_ACE_IO_BASE                 0xf1c1a000
+#define SW_VA_TVE1_IO_BASE                0xf1c1b000
+#define SW_VA_USB2_IO_BASE                0xf1c1c000
+#define SW_VA_CSI1_IO_BASE                0xf1c1d000
+#define SW_VA_TZASC_IO_BASE               0xf1c1e000
+#define SW_VA_SPI3_IO_BASE                0xf1c1f000
+#define SW_VA_CCM_IO_BASE                 0xf1c20000
+#define SW_VA_INT_IO_BASE                 0xf1c20400
+#define SW_VA_PORTC_IO_BASE               0xf1c20800
+#define SW_VA_TIMERC_IO_BASE              0xf1c20c00
+#define SW_VA_SPDIF_IO_BASE               0xf1c21000
+#define SW_VA_AC97_IO_BASE                0xf1c21400
+#define SW_VA_IR0_IO_BASE                 0xf1c21800
+#define SW_VA_IR1_IO_BASE                 0xf1c21c00
+#define SW_VA_IIS1_IO_BASE                0xf1c22000
+#define SW_VA_IIS_IO_BASE                 0xf1c22400
+#define SW_VA_LRADC_IO_BASE               0xf1c22800
+#define SW_VA_ADDA_IO_BASE                0xf1c22c00
+#define SW_VA_KEYPAD_IO_BASE              0xf1c23000
+#define SW_VA_TZPC_IO_BASE                0xf1c23400
+#define SW_VA_SID_IO_BASE                 0xf1c23800
+#define SW_VA_SJTAG_IO_BASE               0xf1c23c00
+#define SW_VA_IIS2_IO_BASE                0xf1c24400
+#define SW_VA_TP_IO_BASE                  0xf1c25000
+#define SW_VA_PMU_IO_BASE                 0xf1c25400
+#define SW_VA_CPUCFG_IO_BASE              0xf1c25c00
+#define SW_VA_UART0_IO_BASE               0xf1c28000
+#define SW_VA_UART1_IO_BASE               0xf1c28400
+#define SW_VA_UART2_IO_BASE               0xf1c28800
+#define SW_VA_UART3_IO_BASE               0xf1c28c00
+#define SW_VA_UART4_IO_BASE               0xf1c29000
+#define SW_VA_UART5_IO_BASE               0xf1c29400
+#define SW_VA_UART6_IO_BASE               0xf1c29800
+#define SW_VA_UART7_IO_BASE               0xf1c29c00
+#define SW_VA_PS20_IO_BASE                0xf1c2a000
+#define SW_VA_PS21_IO_BASE                0xf1c2a400
+#define SW_VA_TWI0_IO_BASE                0xf1c2ac00
+#define SW_VA_TWI1_IO_BASE                0xf1c2b000
+#define SW_VA_TWI2_IO_BASE                0xf1c2b400
+#define SW_VA_TWI3_IO_BASE                0xf1c2b800
+#define SW_VA_CAN0_IO_BASE                0xf1c2bc00
+#define SW_VA_CAN1_IO_BASE                0xf1c2c000 /* sun4i */
+#define SW_VA_TWI4_IO_BASE                0xf1c2c000 /* sun7i */
+#define SW_VA_SCR_IO_BASE                 0xf1c2c400
+#define SW_VA_GPS_IO_BASE                 0xf1c30000
+#define SW_VA_MALI_IO_BASE                0xf1c40000
+#define SW_VA_GMAC_IO_BASE                0xf1c50000
+#define SW_VA_HSTIMER_IO_BASE             0xf1c60000
+#define SW_VA_GIC_IO_BASE                 0xf1c80000
+#define SW_VA_GIC_DIST_IO_BASE            0xf1c81000
+#define SW_VA_GIC_CPU_IO_BASE             0xf1c82000
+#define SW_VA_SCU_IO_BASE                 0xf1c80000
+#define SW_VA_TIMER_G_IO_BASE             0xf1c80200 /* CPU global timer, not used */
+#define SW_VA_TIMER_P_IO_BASE             0xf1c80600 /* CPU private timer, not used */
+#define SW_VA_HDMI1_IO_BASE               0xf1ce0000
+#define SW_VA_SRAM_C_IO_BASE              0xf1d00000
+#define SW_VA_DEFE0_IO_BASE               0xf1e00000
+#define SW_VA_DEFE1_IO_BASE               0xf1e20000
+#define SW_VA_DEBE0_IO_BASE               0xf1e60000
+#define SW_VA_DEBE1_IO_BASE               0xf1e40000
+#define SW_VA_MP_IO_BASE                  0xf1e80000
+#define SW_VA_AVG_IO_BASE                 0xf1ea0000
+
+/* memory size */
+#define SW_IO_SIZE                        0x00400000 /* 4MB(Max) */
+#define SW_SRAM_A1_SIZE                   0x00004000 /* 16k */
+#define SW_SRAM_A2_SIZE                   0x00004000 /* 16k */
+#define SW_SRAM_A3_SIZE                   0x00003400 /* 13k */
+#define SW_SRAM_A4_SIZE                   0x00000c00 /* 3k */
+#define SW_SRAM_D_SIZE                    0x00001000 /* 4k */
+#define SW_SRAM_B_SIZE                    0x00010000 /* 64k */
+#define SW_BROM_SIZE                      0x00008000 /* 32k */
+
+/**
+ * Interrupt controller registers
+ *
+ */
+#define SW_INT_VECTOR_REG                 (SW_VA_INT_IO_BASE + 0x00)
+#define SW_INT_BASE_ADR_REG               (SW_VA_INT_IO_BASE + 0x04)
+#define SW_INT_PROTECTION_REG             (SW_VA_INT_IO_BASE + 0x08)
+#define SW_INT_NMI_CTRL_REG               (SW_VA_INT_IO_BASE + 0x0c)
+#define SW_INT_IRQ_PENDING_REG0           (SW_VA_INT_IO_BASE + 0x10)
+#define SW_INT_IRQ_PENDING_REG1           (SW_VA_INT_IO_BASE + 0x14)
+#define SW_INT_IRQ_PENDING_REG2           (SW_VA_INT_IO_BASE + 0x18)
+
+#define SW_INT_FIQ_PENDING_REG0           (SW_VA_INT_IO_BASE + 0x20)
+#define SW_INT_FIQ_PENDING_REG1           (SW_VA_INT_IO_BASE + 0x24)
+#define SW_INT_FIQ_PENDING_REG2           (SW_VA_INT_IO_BASE + 0x28)
+
+#define SW_INT_SELECT_REG0                (SW_VA_INT_IO_BASE + 0x30)
+#define SW_INT_SELECT_REG1                (SW_VA_INT_IO_BASE + 0x34)
+#define SW_INT_SELECT_REG2                (SW_VA_INT_IO_BASE + 0x38)
+
+#define SW_INT_ENABLE_REG0                (SW_VA_INT_IO_BASE + 0x40)
+#define SW_INT_ENABLE_REG1                (SW_VA_INT_IO_BASE + 0x44)
+#define SW_INT_ENABLE_REG2                (SW_VA_INT_IO_BASE + 0x48)
+
+#define SW_INT_MASK_REG0                  (SW_VA_INT_IO_BASE + 0x50)
+#define SW_INT_MASK_REG1                  (SW_VA_INT_IO_BASE + 0x54)
+#define SW_INT_MASK_REG2                  (SW_VA_INT_IO_BASE + 0x58)
+
+#define SW_INT_RESP_REG0                  (SW_VA_INT_IO_BASE + 0x60)
+#define SW_INT_RESP_REG1                  (SW_VA_INT_IO_BASE + 0x64)
+#define SW_INT_RESP_REG2                  (SW_VA_INT_IO_BASE + 0x68)
+
+#define SW_INT_FASTFORCE_REG0             (SW_VA_INT_IO_BASE + 0x70)
+#define SW_INT_FASTFORCE_REG1             (SW_VA_INT_IO_BASE + 0x74)
+#define SW_INT_FASTFORCE_REG2             (SW_VA_INT_IO_BASE + 0x78)
+
+#define SW_INT_SRCPRIO_REG0               (SW_VA_INT_IO_BASE + 0x80)
+#define SW_INT_SRCPRIO_REG1               (SW_VA_INT_IO_BASE + 0x84)
+#define SW_INT_SRCPRIO_REG2               (SW_VA_INT_IO_BASE + 0x88)
+#define SW_INT_SRCPRIO_REG3               (SW_VA_INT_IO_BASE + 0x8c)
+#define SW_INT_SRCPRIO_REG4               (SW_VA_INT_IO_BASE + 0x90)
+#ifdef CONFIG_ARCH_SUN5I
+#define SW_INT_SRCPRIO_REG5               (SW_VA_INT_IO_BASE + 0x94)
+#endif
+
+#define SW_UART0_THR                      (*(volatile unsigned int *)(SW_VA_UART0_IO_BASE + 0x00))
+#define SW_UART0_LSR                      (*(volatile unsigned int *)(SW_VA_UART0_IO_BASE + 0x14))
+#define SW_UART0_USR                      (*(volatile unsigned int *)(SW_VA_UART0_IO_BASE + 0x7c))
+
+#define SW_UART1_THR                      (*(volatile unsigned int *)(SW_VA_UART1_IO_BASE + 0x00))
+#define SW_UART1_LSR                      (*(volatile unsigned int *)(SW_VA_UART1_IO_BASE + 0x14))
+#define SW_UART1_USR                      (*(volatile unsigned int *)(SW_VA_UART1_IO_BASE + 0x7c))
+
+#define PA_VIC_BASE                       0x01c20400
+#define VA_VIC_BASE                       IO_ADDRESS(PA_VIC_BASE)
+#define PIO_BASE                          SW_PA_PORTC_IO_BASE
+
+/**
+*@name DRAM controller register address
+*@{
+*/
+#define SW_DRAM_SDR_CTL_REG               (SW_VA_DRAM_IO_BASE + 0x0C)
+#define SW_DRAM_SDR_DCR                   (SW_VA_DRAM_IO_BASE + 0x04)
+
+/*
+ * other reg defination, not found in spec
+ */
+#define AW_GIC_DIST_BASE                  0x01c81000
+#define AW_GIC_CPU_BASE                   0x01c82000
+#define AW_TIMER_G_BASE                   0x01c80200 /* CPU global timer, not used */
+#define AW_TIMER_P_BASE                   0x01c80600 /* CPU private timer, not used */
+
+/*
+ * CPUCFG
+ */
+#define AW_CPUCFG_P_REG0            0x01a4
+#define CPUX_RESET_CTL(x) (0x40 + (x)*0x40)
+#define CPUX_CONTROL(x)   (0x44 + (x)*0x40)
+#define CPUX_STATUS(x)    (0x48 + (x)*0x40)
+#define AW_CPUCFG_GENCTL            0x0184
+#define AW_CPUCFG_DBGCTL0           0x01e0
+#define AW_CPUCFG_DBGCTL1           0x01e4
+
+#define AW_CPU1_PWR_CLAMP         0x01b0
+#define AW_CPU1_PWROFF_REG        0x01b4
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/script.h b/arch/arm/plat-sunxi/include/plat/script.h
new file mode 100644
index 0000000..1d4d8aa
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/script.h
@@ -0,0 +1,238 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/script.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _SUNXI_PLAT_SCRIPT_H
+#define _SUNXI_PLAT_SCRIPT_H
+
+#define SYS_CONFIG_MEMBASE	(PLAT_PHYS_OFFSET + SZ_32M + SZ_16M)
+#define SYS_CONFIG_MEMSIZE	(SZ_64K)
+
+extern const struct sunxi_script *sunxi_script_base;
+
+struct sunxi_section {
+	char name[32];
+	u32 count;
+	u32 offset;
+};
+
+struct sunxi_property {
+	char name[32];
+	u32 offset;
+	u32 pattern;
+};
+
+struct sunxi_script {
+	u32 count;
+	u32 version[3];
+	struct sunxi_section section[];
+};
+
+struct sunxi_property_gpio_value {
+	u32 port;
+	u32 port_num;
+	s32 mul_sel;
+	s32 pull;
+	s32 drv_level;
+	s32 data;
+};
+
+enum sunxi_property_type {
+	SUNXI_PROP_TYPE_INVALID = 0,
+	SUNXI_PROP_TYPE_U32,
+	SUNXI_PROP_TYPE_STRING,
+	SUNXI_PROP_TYPE_U32_ARRAY,
+	SUNXI_PROP_TYPE_GPIO,
+	SUNXI_PROP_TYPE_NULL,
+};
+
+/* local helpers, will undef */
+#define PTR(B, OFF)	(void*)((char*)(B)+((OFF)<<2))
+
+void sunxi_script_init(const struct sunxi_script *);
+
+/* counts */
+static inline int sunxi_get_section_count(void)
+{
+	return sunxi_script_base->count;
+}
+static inline int sunxi_get_property_count(const struct sunxi_section *sp)
+{
+	return sp ? sp->count : 0;
+}
+
+/* first element */
+static inline const struct sunxi_section *sunxi_get_first_section(void)
+{
+	return (sunxi_script_base->count > 0) ?
+		sunxi_script_base->section : NULL;
+}
+static inline const struct sunxi_property *sunxi_get_first_property(
+		const struct sunxi_section *sp)
+{
+	return (sp->count > 0) ? PTR(sunxi_script_base, sp->offset) : NULL;
+}
+
+/* property details */
+static inline u32 sunxi_property_type(const struct sunxi_property *o)
+{
+	return o ? (o->pattern >> 16) & 0xffff : SUNXI_PROP_TYPE_INVALID;
+}
+static inline u32 sunxi_property_size(const struct sunxi_property *o)
+{
+	return o ? (o->pattern & 0xffff) << 2 : 0;
+}
+static inline void *sunxi_property_value(const struct sunxi_property *o)
+{
+	return o ? PTR(sunxi_script_base, o->offset) : NULL;
+}
+#undef PTR
+
+/* iterators */
+#define sunxi_for_each_section(SV, CV)	\
+	for (CV = sunxi_get_section_count(), \
+	     SV = sunxi_get_first_section(); \
+	     CV--; SV++)
+#define sunxi_for_each_property(SP, PV, CV) \
+	for (CV = sunxi_get_property_count(SP), \
+	     PV = sunxi_get_first_property(SP); \
+	     CV--; PV++)
+
+/**
+ * sunxi_find_section() - search for a section by name
+ */
+static inline const struct sunxi_section *sunxi_find_section(const char *name)
+{
+	int i;
+	const struct sunxi_section *section;
+	sunxi_for_each_section(section, i)
+		if (strncmp(name, section->name, sizeof(section->name)) == 0)
+			return section;
+	return NULL;
+}
+
+/**
+ * sunxi_find_property() - search for a property by name in a section
+ */
+static inline const struct sunxi_property *sunxi_find_property(
+		const struct sunxi_section *sp,
+		const char *name)
+{
+	int i;
+	const struct sunxi_property *prop;
+	sunxi_for_each_property(sp, prop, i)
+		if (strncmp(name, prop->name, sizeof(prop->name)) == 0)
+			return prop;
+	return NULL;
+}
+
+/**
+ * sunxi_find_property2() - search for a (section, property) by name
+ */
+static inline const struct sunxi_property *sunxi_find_property2(
+		const char *secname, const char *propname)
+{
+	const struct sunxi_section *sp;
+	const struct sunxi_property *prop = NULL;
+	sp = sunxi_find_section(secname);
+	if (sp)
+		prop = sunxi_find_property(sp, propname);
+	return prop;
+}
+
+/**
+ * sunxi_find_property_fmt() - search for a property using a formated name
+ */
+const struct sunxi_property *sunxi_find_property_fmt(
+		const struct sunxi_section *sp,
+		const char *fmt, ...);
+
+/**
+ * sunxi_property_read_u32() - read value of u32 type property
+ */
+static inline int sunxi_property_read_u32(const struct sunxi_section *sp,
+					  const char *propname,
+					  u32 *val)
+{
+	const struct sunxi_property *pp =
+		sunxi_find_property(sp, propname);
+	if (pp && sunxi_property_type(pp) == SUNXI_PROP_TYPE_U32) {
+		u32 *v = sunxi_property_value(pp);
+		*val = *v;
+		return 1;
+	}
+	return 0;
+}
+
+static inline int sunxi_property2_read_u32(const char *secname,
+					   const char *propname,
+					   u32 *val)
+{
+	const struct sunxi_property *pp =
+		sunxi_find_property2(secname, propname);
+	if (pp && sunxi_property_type(pp) == SUNXI_PROP_TYPE_U32) {
+		u32 *v = sunxi_property_value(pp);
+		*val = *v;
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * sunxi_script_property_read_string() - read value of string property
+ */
+static inline int sunxi_property_read_string(const struct sunxi_property *prop,
+				     const char **val, size_t *length)
+{
+	enum sunxi_property_type t = sunxi_property_type(prop);
+	size_t s = sunxi_property_size(prop);
+
+	if (t == SUNXI_PROP_TYPE_STRING && s > 0) {
+		const char *v = sunxi_property_value(prop);
+		size_t l = s-4;
+		if (v[++l] && v[++l] && v[++l])
+			++l;
+		*val = v;
+		*length = l;
+	} else if (t == SUNXI_PROP_TYPE_NULL ||
+		   t == SUNXI_PROP_TYPE_STRING) {
+		*val = NULL;
+		*length = 0;
+	} else {
+		return 0;
+	}
+	return 1;
+}
+
+/**
+ * sunxi_script_property_read_gpio() - read value of gpio property
+ */
+static inline int sunxi_property_read_gpio(struct sunxi_property *prop,
+					struct sunxi_property_gpio_value **val)
+{
+	if (sunxi_property_type(prop) == SUNXI_PROP_TYPE_GPIO) {
+		struct sunxi_property_gpio_value *v = sunxi_property_value(prop);
+		*val = v;
+		return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/sys_config.h b/arch/arm/plat-sunxi/include/plat/sys_config.h
new file mode 100644
index 0000000..664487c
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/sys_config.h
@@ -0,0 +1,126 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/sys_config.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_SYS_CONFIG_H
+#define __SW_SYS_CONFIG_H
+
+#include <plat/script.h>
+
+#define   SCRIPT_PARSER_OK                   (0)
+#define   SCRIPT_PARSER_EMPTY_BUFFER         (-1)
+#define   SCRIPT_PARSER_KEYNAME_NULL         (-2)
+#define   SCRIPT_PARSER_DATA_VALUE_NULL      (-3)
+#define   SCRIPT_PARSER_KEY_NOT_FIND         (-4)
+#define   SCRIPT_PARSER_BUFFER_NOT_ENOUGH    (-5)
+
+typedef enum
+{
+	SCRIPT_PARSER_VALUE_TYPE_INVALID = 0,
+	SCRIPT_PARSER_VALUE_TYPE_SINGLE_WORD,
+	SCRIPT_PARSER_VALUE_TYPE_STRING,
+	SCRIPT_PARSER_VALUE_TYPE_MULTI_WORD,
+	SCRIPT_PARSER_VALUE_TYPE_GPIO_WORD
+} script_parser_value_type_t;
+
+typedef struct
+{
+	char  gpio_name[32];
+	int port;
+	int port_num;
+	int mul_sel;
+	int pull;
+	int drv_level;
+	int data;
+} script_gpio_set_t;
+
+typedef struct sunxi_script script_head_t;
+typedef struct sunxi_script_section script_main_key_t;
+typedef struct sunxi_script_property script_sub_key_t;
+
+#define   EGPIO_FAIL             (-1)
+#define   EGPIO_SUCCESS          (0)
+
+typedef enum
+{
+	PIN_PULL_DEFAULT 	= 	0xFF,
+	PIN_PULL_DISABLE 	=	0x00,
+	PIN_PULL_UP			  =	0x01,
+	PIN_PULL_DOWN	  	=	0x02,
+	PIN_PULL_RESERVED	=	0x03
+} pin_pull_level_t;
+
+typedef	enum
+{
+	PIN_MULTI_DRIVING_DEFAULT	=	0xFF,
+	PIN_MULTI_DRIVING_0			=	0x00,
+	PIN_MULTI_DRIVING_1			=	0x01,
+	PIN_MULTI_DRIVING_2			=	0x02,
+	PIN_MULTI_DRIVING_3			=	0x03
+} pin_drive_level_t;
+
+typedef enum
+{
+	PIN_DATA_LOW,
+	PIN_DATA_HIGH,
+	PIN_DATA_DEFAULT = 0XFF
+} pin_data_t;
+
+#define	PIN_PHY_GROUP_A			0x00
+#define	PIN_PHY_GROUP_B			0x01
+#define	PIN_PHY_GROUP_C			0x02
+#define	PIN_PHY_GROUP_D			0x03
+#define	PIN_PHY_GROUP_E			0x04
+#define	PIN_PHY_GROUP_F			0x05
+#define	PIN_PHY_GROUP_G			0x06
+#define	PIN_PHY_GROUP_H			0x07
+#define	PIN_PHY_GROUP_I			0x08
+#define	PIN_PHY_GROUP_J			0x09
+
+typedef script_gpio_set_t user_gpio_set_t;
+
+/* script operations */
+extern int script_parser_fetch(char *main_name, char *sub_name, int value[], int count);
+extern int script_parser_fetch_ex(char *main_name, char *sub_name, int value[],
+               script_parser_value_type_t *type, int count);
+extern int script_parser_subkey_count(char *main_name);
+extern int script_parser_mainkey_count(void);
+extern int script_parser_mainkey_get_gpio_count(char *main_name);
+extern int script_parser_mainkey_get_gpio_cfg(char *main_name, void *gpio_cfg, int gpio_count);
+
+/* gpio operations */
+extern int gpio_init(void);
+extern int gpio_exit(void);
+extern unsigned sunxi_gpio_request_array(user_gpio_set_t *gpio_list,
+					 unsigned group_count_max);
+extern unsigned gpio_request_ex(char *main_name, const char *sub_name);
+extern int gpio_release(unsigned p_handler, int if_release_to_default_status);
+extern int gpio_get_all_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, unsigned gpio_count_max, unsigned if_get_from_hardware);
+extern int gpio_get_one_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, unsigned if_get_from_hardware);
+extern int gpio_set_one_pin_status(unsigned p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, unsigned if_set_to_current_input_status);
+extern int gpio_set_one_pin_io_status(unsigned p_handler, unsigned if_set_to_output_status, const char *gpio_name);
+extern int gpio_set_one_pin_pull(unsigned p_handler, unsigned set_pull_status, const char *gpio_name);
+extern int gpio_set_one_pin_driver_level(unsigned p_handler, unsigned set_driver_level, const char *gpio_name);
+extern int gpio_read_one_pin_value(unsigned p_handler, const char *gpio_name);
+extern int gpio_write_one_pin_value(unsigned p_handler, unsigned value_to_gpio, const char *gpio_name);
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/system.h b/arch/arm/plat-sunxi/include/plat/system.h
new file mode 100644
index 0000000..200b134
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/system.h
@@ -0,0 +1,179 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/system.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_SYSTEM_H
+#define __SW_SYSTEM_H
+
+#include <asm/proc-fns.h>
+
+extern unsigned long fb_start;
+extern unsigned long fb_size;
+extern unsigned long g2d_start;
+extern unsigned long g2d_size;
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+enum sunxi_chip_id {
+	SUNXI_UNKNOWN_MACH = 0xffffffff,
+
+	SUNXI_MACH_SUN4I = 1623,
+	SUNXI_MACH_SUN5I = 1625,
+	SUNXI_MACH_SUN6I = 1633,
+	SUNXI_MACH_SUN7I = 1651,
+};
+
+enum {
+	SUNXI_BIT_SUN4I = BIT(30),
+	SUNXI_BIT_SUN5I = BIT(29),
+	SUNXI_BIT_SUN6I = BIT(28),
+	SUNXI_BIT_SUN7I = BIT(27),
+
+	/* SUNXI_BIT_UNKNOWN can't OR anything known */
+	SUNXI_BIT_UNKNOWN = BIT(20),
+
+	/* sun4i */
+	SUNXI_SOC_A10  = SUNXI_BIT_SUN4I | BIT(4),
+
+	/* sun5i */
+	SUNXI_SOC_A13  = SUNXI_BIT_SUN5I | BIT(4),
+	SUNXI_SOC_A12  = SUNXI_BIT_SUN5I | BIT(5),
+	SUNXI_SOC_A10S = SUNXI_BIT_SUN5I | BIT(6),
+
+	/* sun6i */
+	SUNXI_SOC_A31  = SUNXI_BIT_SUN6I | BIT(4),
+
+	/* sun7i */
+	SUNXI_SOC_A20  = SUNXI_BIT_SUN7I | BIT(4),
+
+	SUNXI_REV_UNKNOWN = 0,
+	SUNXI_REV_A,
+	SUNXI_REV_B,
+	SUNXI_REV_C,
+};
+
+/* BROM access only possible after iomap()s */
+u32 sunxi_brom_chip_id(void);
+int sunxi_pr_brom(void);
+
+u32 sunxi_sc_chip_id(void);
+
+u32 sunxi_chip_id(void) __pure;
+int sunxi_pr_chip_id(void);
+
+enum sw_ic_ver {
+	SUNXI_VER_UNKNOWN = SUNXI_BIT_UNKNOWN,
+
+	/* sun4i */
+	SUNXI_VER_A10A = SUNXI_SOC_A10 + SUNXI_REV_A,
+	SUNXI_VER_A10B,
+	SUNXI_VER_A10C,
+
+	/* sun5i */
+	SUNXI_VER_A13 = SUNXI_SOC_A13,
+	SUNXI_VER_A13A,
+	SUNXI_VER_A13B,
+	SUNXI_VER_A12 = SUNXI_SOC_A12,
+	SUNXI_VER_A12A,
+	SUNXI_VER_A12B,
+	SUNXI_VER_A10S = SUNXI_SOC_A10S,
+	SUNXI_VER_A10SA,
+	SUNXI_VER_A10SB,
+
+	/* sun6i */
+	SUNXI_VER_A31 = SUNXI_SOC_A31,
+
+	/* sun7i */
+	SUNXI_VER_A20 = SUNXI_SOC_A20,
+};
+
+enum sw_ic_ver sw_get_ic_ver(void) __pure;
+
+#define _sunxi_is(M)		((sw_get_ic_ver()&M) == M)
+
+#if defined(CONFIG_SUNXI_MULTIPLATFORM)
+/* sunxi_is_sunNi() could also be implemented ORing the ic_ver */
+#define sunxi_is_sun4i()	(sunxi_chip_id() == SUNXI_MACH_SUN4I)
+#define sunxi_is_sun5i()	(sunxi_chip_id() == SUNXI_MACH_SUN5I)
+#define sunxi_is_sun6i()	(sunxi_chip_id() == SUNXI_MACH_SUN6I)
+#define sunxi_is_sun7i()	(sunxi_chip_id() == SUNXI_MACH_SUN7I)
+#define sunxi_is_a10()		_sunxi_is(SUNXI_SOC_A10)
+#define sunxi_is_a13()		_sunxi_is(SUNXI_SOC_A13)
+#define sunxi_is_a12()		_sunxi_is(SUNXI_SOC_A12)
+#define sunxi_is_a10s()		_sunxi_is(SUNXI_SOC_A10S)
+#define sunxi_is_a31()		_sunxi_is(SUNXI_SOC_A31)
+#define sunxi_is_a20()		_sunxi_is(SUNXI_SOC_A20)
+
+#elif defined(CONFIG_ARCH_SUN4I)
+#define sunxi_is_sun4i()	(sunxi_chip_id() == SUNXI_MACH_SUN4I)
+#define sunxi_is_sun5i()	(0)
+#define sunxi_is_sun6i()	(0)
+#define sunxi_is_sun7i()	(0)
+#define sunxi_is_a10()		_sunxi_is(SUNXI_SOC_A10)
+#define sunxi_is_a13()		(0)
+#define sunxi_is_a12()		(0)
+#define sunxi_is_a10s()		(0)
+#define sunxi_is_a31()		(0)
+#define sunxi_is_a20()		(0)
+
+#elif defined(CONFIG_ARCH_SUN5I)
+#define sunxi_is_sun4i()	(0)
+#define sunxi_is_sun5i()	(sunxi_chip_id() == SUNXI_MACH_SUN5I)
+#define sunxi_is_sun6i()	(0)
+#define sunxi_is_sun7i()	(0)
+#define sunxi_is_a10()		(0)
+#define sunxi_is_a13()		_sunxi_is(SUNXI_SOC_A13)
+#define sunxi_is_a12()		_sunxi_is(SUNXI_SOC_A12)
+#define sunxi_is_a10s()		_sunxi_is(SUNXI_SOC_A10S)
+#define sunxi_is_a31()		(0)
+#define sunxi_is_a20()		(0)
+
+#elif defined(CONFIG_ARCH_SUN7I)
+#define sunxi_is_sun4i()	(0)
+#define sunxi_is_sun5i()	(0)
+#define sunxi_is_sun6i()	(0)
+#define sunxi_is_sun7i()	(sunxi_chip_id() == SUNXI_MACH_SUN7I)
+#define sunxi_is_a10()		(0)
+#define sunxi_is_a13()		(0)
+#define sunxi_is_a12()		(0)
+#define sunxi_is_a10s()		(0)
+#define sunxi_is_a31()		(0)
+#define sunxi_is_a20()		_sunxi_is(SUNXI_SOC_A20)
+
+#endif
+
+#define sunxi_soc_rev()		(sw_get_ic_ver() & 0xf)
+
+struct sw_chip_id
+{
+	unsigned int sid_rkey0;
+	unsigned int sid_rkey1;
+	unsigned int sid_rkey2;
+	unsigned int sid_rkey3;
+};
+
+int sw_get_chip_id(struct sw_chip_id *);
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/timex.h b/arch/arm/plat-sunxi/include/plat/timex.h
new file mode 100644
index 0000000..b2b1bae
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/timex.h
@@ -0,0 +1,33 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/timex.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_TIMEX_H
+#define __SW_TIMEX_H
+
+#define SYS_TIMER_SCAL      (16)            /* timer clock source pre-divsion   */
+#define SYS_TIMER_CLKSRC    (24000000)      /* timer clock source               */
+#define TMR_INTER_VAL       (SYS_TIMER_CLKSRC/(SYS_TIMER_SCAL*HZ))
+
+#define CLOCK_TICK_RATE     TMR_INTER_VAL  /* obsolete - any value shoud do */
+
+#endif
diff --git a/arch/arm/plat-sunxi/include/plat/uncompress.h b/arch/arm/plat-sunxi/include/plat/uncompress.h
new file mode 100644
index 0000000..d66537b
--- /dev/null
+++ b/arch/arm/plat-sunxi/include/plat/uncompress.h
@@ -0,0 +1,43 @@
+/*
+ * arch/arm/plat-sunxi/include/plat/uncompress.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SW_UNCOMPRESS_H
+#define __SW_UNCOMPRESS_H
+
+static inline void putc(int c)
+{
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif
+
+
diff --git a/arch/arm/plat-sunxi/pm/Makefile b/arch/arm/plat-sunxi/pm/Makefile
new file mode 100644
index 0000000..fa9f72c
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/Makefile
@@ -0,0 +1,8 @@
+subdir		:= standby
+
+obj-y		+= pm.o standby.o
+
+$(obj)/standby.o: $(obj)/standby/standby.bin
+
+$(obj)/standby/standby.bin: FORCE
+	$(Q)$(MAKE) $(build)=$(obj)/standby
diff --git a/arch/arm/plat-sunxi/pm/pm.c b/arch/arm/plat-sunxi/pm/pm.c
new file mode 100644
index 0000000..4998d87
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/pm.c
@@ -0,0 +1,99 @@
+/*
+ * arch/arm/plat-sunxi/pm/pm.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * chech usb to wake up system from standby
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/suspend.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/syscalls.h>
+#include <linux/slab.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <linux/power/aw_pm.h>
+
+
+extern char *standby_bin_start;
+extern char *standby_bin_end;
+
+static struct aw_pm_info standby_info = {
+	.pmu_arg = {
+		.twi_port = 0,
+		.dev_addr = 10,
+	},
+};
+
+static int aw_pm_valid(suspend_state_t state)
+{
+	return (state == PM_SUSPEND_STANDBY) || (state == PM_SUSPEND_MEM);
+}
+
+static int aw_pm_enter(suspend_state_t state)
+{
+	int (*standby)(struct aw_pm_info *arg) = (int (*)(struct aw_pm_info *arg))SRAM_FUNC_START;
+	int ret;
+
+	/* move standby code to sram */
+	memcpy((void *)SRAM_FUNC_START, (void *)&standby_bin_start, (int)&standby_bin_end - (int)&standby_bin_start);
+
+	/* config system wakeup evetn type */
+	standby_info.standby_para.event = SUSPEND_WAKEUP_SRC_EXINT | SUSPEND_WAKEUP_SRC_ALARM |
+		SUSPEND_WAKEUP_SRC_KEY | SUSPEND_WAKEUP_SRC_IR | SUSPEND_WAKEUP_SRC_USB;
+
+	/* goto sram and run */
+	ret = standby(&standby_info);
+	if (!ret)
+		pr_info("%s: wakeup by event:%d\n", __func__, standby_info.standby_para.event);
+	else
+		pr_err("%s: suspend failed with error:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static struct platform_suspend_ops aw_pm_ops = {
+	.valid = aw_pm_valid,
+	.enter = aw_pm_enter,
+};
+
+
+static int __init aw_pm_init(void)
+{
+	suspend_set_ops(&aw_pm_ops);
+
+	return 0;
+}
+
+
+static void __exit aw_pm_exit(void)
+{
+	suspend_set_ops(NULL);
+}
+
+module_init(aw_pm_init);
+module_exit(aw_pm_exit);
+
diff --git a/arch/arm/plat-sunxi/pm/standby.S b/arch/arm/plat-sunxi/pm/standby.S
new file mode 100644
index 0000000..e601a03
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby.S
@@ -0,0 +1,31 @@
+/*
+ * arch/arm/mach-sun4i/pm/standby.S
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * chech usb to wake up system from standby
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+	.globl	standby_bin_start
+standby_bin_start:
+	.incbin	"arch/arm/plat-sunxi/pm/standby/standby.bin"
+	.globl	standby_bin_end
+standby_bin_end:
+	.align	2
diff --git a/arch/arm/plat-sunxi/pm/standby/Makefile b/arch/arm/plat-sunxi/pm/standby/Makefile
new file mode 100644
index 0000000..b7f4540
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/Makefile
@@ -0,0 +1,25 @@
+always	:= standby.bin
+targets := standby.elf
+
+standby-y := common.o standby.o stack.o standby_clock.o \
+	     dram.o dram_init.o \
+	     standby_int.o standby_ir.o standby_key.o standby_power.o \
+	     standby_tmr.o standby_twi.o standby_usb.o standby_delay.o
+
+targets	+= $(standby-y)
+STANDBY_OBJS = $(addprefix $(obj)/,$(standby-y))
+
+LD_FILE = standby.lds
+
+KBUILD_CFLAGS := $(LINUXINCLUDE) -Os -g -march=armv7-a -marm -mlittle-endian -c
+KBUILD_CFLAGS += -fno-unwind-tables -fno-asynchronous-unwind-tables
+KBUILD_AFLAGS := $(KBUILD_CFLAGS) -D__ASSEMBLY__
+
+LDFLAGS_standby.elf := -T
+OBJCOPYFLAGS_standby.bin := -O binary
+
+$(obj)/standby.elf: $(src)/$(LD_FILE) $(STANDBY_OBJS) FORCE
+	$(call if_changed,ld)
+
+$(obj)/standby.bin: $(obj)/standby.elf FORCE
+	$(call if_changed,objcopy)
diff --git a/arch/arm/plat-sunxi/pm/standby/common.c b/arch/arm/plat-sunxi/pm/standby/common.c
new file mode 100644
index 0000000..675b307
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/common.c
@@ -0,0 +1,77 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/common.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+
+/*
+*********************************************************************************************************
+*                           standby_memcpy
+*
+*Description: memory copy function for standby.
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_memcpy(void *dest, void *src, int n)
+{
+    char    *tmp_src = (char *)src;
+    char    *tmp_dst = (char *)dest;
+
+    if(!dest || !src){
+        /* parameter is invalid */
+        return;
+    }
+
+    for( ; n > 0; n--){
+        *tmp_dst ++ = *tmp_src ++;
+    }
+
+    return;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mdelay
+*
+*Description: mdelay function
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_mdelay(int ms)
+{
+    standby_delay(ms * cpu_ms_loopcnt);
+}
+
diff --git a/arch/arm/plat-sunxi/pm/standby/common.h b/arch/arm/plat-sunxi/pm/standby/common.h
new file mode 100644
index 0000000..2a6d23c
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/common.h
@@ -0,0 +1,72 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/common.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/types.h>
+
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+static inline __u64 standby_uldiv(__u64 dividend, __u32 divisior)
+{
+    __u64   tmpDiv = (__u64)divisior;
+    __u64   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return 0;
+    }
+
+    while(!(tmpDiv & ((__u64)1<<63)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
+
+
+
+void standby_memcpy(void *dest, void *src, int n);
+void standby_mdelay(int ms);
+void standby_delay(int cycle);
+
+#endif  //__COMMON_H__
+
diff --git a/arch/arm/plat-sunxi/pm/standby/dram.c b/arch/arm/plat-sunxi/pm/standby/dram.c
new file mode 100644
index 0000000..76695a0
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/dram.c
@@ -0,0 +1,463 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/dram.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Berg Xing <bergxing@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "dram_i.h"
+
+
+/*
+*********************************************************************************************************
+*                 DRAM ENTER SELF REFRESH
+*
+* Description: dram enter/exit self-refresh;
+*
+* Arguments  : none
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+void mctl_precharge_all(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x15U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+    standby_delay(0x100);
+}
+
+void DRAMC_enter_selfrefresh(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	//disable all port
+	for(i=0; i<31; i++)
+	{
+		DRAMC_hostport_on_off(i, 0x0);
+	}
+
+	//disable auto-fresh
+	reg_val = mctl_read_w(SDR_DRR);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DRR, reg_val);
+
+	//issue prechage all command
+	mctl_precharge_all();
+
+	//enter into self-refresh
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x12U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	standby_delay(0x100);
+}
+void mctl_mode_exit(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x17U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	standby_delay(0x100);
+}
+
+void DRAMC_exit_selfrefresh(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	//exit self-refresh state
+	mctl_mode_exit();
+
+	//issue a refresh command
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x13U<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+    standby_delay(0x100);
+
+	//enable auto-fresh
+	reg_val = mctl_read_w(SDR_DRR);
+	reg_val &= ~(0x1U<<31);
+	mctl_write_w(SDR_DRR, reg_val);
+
+	//enable all port
+	for(i=0; i<31; i++)
+	{
+		DRAMC_hostport_on_off(i, 0x1);
+	}
+}
+
+/*
+*********************************************************************************************************
+*                 DRAM POWER DOWN
+*
+* Description: enter/exit dram power down state
+*
+* Arguments  :
+*
+* Returns    : none;
+*
+* Note       :
+*********************************************************************************************************
+*/
+void DRAMC_enter_power_down(void)
+{
+	__u32 i;
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DCR);
+	reg_val &= ~(0x1fU<<27);
+	reg_val |= 0x1eU<<27;
+	mctl_write_w(SDR_DCR, reg_val);
+
+	//check whether command has been executed
+	while( mctl_read_w(SDR_DCR)& (0x1U<<31) );
+	standby_delay(0x100);
+}
+
+void DRAMC_exit_power_down(void)
+{
+    mctl_mode_exit();
+}
+
+/*
+**********************************************************************************************************************
+*                 DRAM HOSTPORT CONTROL
+*
+* Description: dram host port enable/ disable
+*
+* Arguments  : __u32 port_idx		host port index   (0,1,...31)
+*				__u32 on		enable or disable (0: diable, 1: enable)
+*
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+void DRAMC_hostport_on_off(__u32 port_idx, __u32 on)
+{
+    __u32   reg_val;
+
+    if(port_idx<=31)
+    {
+	    reg_val = mctl_read_w(SDR_HPCR + (port_idx<<2));
+	    if(on)
+	    	reg_val |= 0x1;
+	    else
+	    	reg_val &= ~(0x1);
+	    mctl_write_w(SDR_HPCR + (port_idx<<2), reg_val);
+	}
+}
+/*
+**********************************************************************************************************************
+*                 DRAM GET HOSTPORT STATUS
+*
+* Description: dram get AHB FIFO status
+*
+* Arguments  : __u32 port_idx		host port index   	(0,1,...31)
+*
+* Returns    : __u32 ret_val		AHB FIFO status 	(0: FIFO not empty ,1: FIFO empty)
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__u32 DRAMC_hostport_check_ahb_fifo_status(__u32 port_idx)
+{
+    __u32   reg_val;
+
+    if(port_idx<=31)
+    {
+	    reg_val = mctl_read_w(SDR_CFSR);
+	    return ( (reg_val>>port_idx)&0x1 );
+	}
+	else
+	{
+		return 0;
+	}
+}
+/*
+**********************************************************************************************************************
+*                 DRAM GET HOSTPORT STATUS
+*
+* Description: dram get AHB FIFO status
+*
+* Arguments  : 	__u32 port_idx				host port index   	(0,1,...31)
+*				__u32 port_pri_level		priority level		(0,1,2,3)
+*
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+void DRAMC_hostport_setup(__u32 port_idx, __u32 port_pri_level, __u32 port_wait_cycle, __u32 cmd_num)
+{
+    __u32   reg_val;
+
+    if(port_idx<=31)
+    {
+	    reg_val = mctl_read_w(SDR_HPCR + (port_idx<<2));
+	    reg_val &= ~(0x3<<2);
+	    reg_val |= (port_pri_level&0x3)<<2;
+	    reg_val &= ~(0xf<<4);
+	    reg_val |= (port_wait_cycle&0xf)<<4;
+	    reg_val &= ~(0xff<<8);
+	    reg_val |= (cmd_num&0x3)<<8;
+	    mctl_write_w(SDR_HPCR + (port_idx<<2), reg_val);
+	}
+}
+/*
+*********************************************************************************************************
+*                 DRAM power save process
+*
+* Description: We can save power by disable DRAM PLL.
+*			   DRAMC_power_save_process() is called to disable DRAMC ITM and DLL, then disable PLL to save power;
+*			   Before exit SDRAM self-refresh state, we should enable DRAM PLL and make sure that it is stable clock.
+*			   Then call function DRAMC_exit_selfrefresh() to exit self-refresh state. Before access external SDRAM,
+*              the function DRAMC_power_up_process() should be called to enable DLL and re-training DRAM controller.
+*
+* Arguments  : none
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+__u32 mctl_ahb_reset(void)
+{
+	__u32 i;
+	__u32 reg_val;
+#if   defined(CONFIG_ARCH_SUN4I)
+	const __u32 clocks = 0x1;
+#elif defined(CONFIG_ARCH_SUN5I)
+	const __u32 clocks = 0x3;
+#else
+#error Unsupported sunxi architecture.
+#endif
+
+	reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+	reg_val &= ~(clocks << 14);
+	mctl_write_w(DRAM_CCM_AHB_GATE_REG,reg_val);
+	standby_delay(0x10);
+
+	reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+	reg_val |= (clocks << 14);
+	mctl_write_w(DRAM_CCM_AHB_GATE_REG,reg_val);
+}
+
+__s32 DRAMC_retraining(void)
+{
+	__u32 i;
+	__u32 reg_val;
+	__u32 ret_val;
+	__u32 reg_dcr, reg_drr, reg_tpr0, reg_tpr1, reg_tpr2, reg_mr, reg_emr, reg_emr2, reg_emr3;
+	__u32 reg_zqcr0, reg_iocr;
+
+	//remember register value
+	reg_dcr = mctl_read_w(SDR_DCR);
+	reg_drr = mctl_read_w(SDR_DRR);
+	reg_tpr0 = mctl_read_w(SDR_TPR0);
+	reg_tpr1 = mctl_read_w(SDR_TPR1);
+	reg_tpr2 = mctl_read_w(SDR_TPR2);
+	reg_mr = mctl_read_w(SDR_MR);
+	reg_emr = mctl_read_w(SDR_EMR);
+	reg_emr2 = mctl_read_w(SDR_EMR2);
+	reg_emr3 = mctl_read_w(SDR_EMR3);
+	reg_zqcr0 = mctl_read_w(SDR_ZQCR0);
+	reg_iocr = mctl_read_w(SDR_IOCR);
+	while(1){
+		mctl_ahb_reset();
+
+		//reset external DRAM
+		mctl_ddr3_reset();
+		mctl_set_drive();
+
+		//dram clock off
+		DRAMC_clock_output_en(0);
+
+		//select dram controller 1
+		mctl_write_w(SDR_SCSR, 0x16237495);
+
+		mctl_itm_disable();
+		mctl_enable_dll0();
+
+		//configure external DRAM
+		mctl_write_w(SDR_DCR, reg_dcr);
+
+		//dram clock on
+		DRAMC_clock_output_en(1);
+        standby_delay(0x10);
+		while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+		mctl_enable_dllx();
+
+		//set odt impendance divide ratio
+		mctl_write_w(SDR_ZQCR0, reg_zqcr0);
+
+		//set I/O configure register
+		mctl_write_w(SDR_IOCR, reg_iocr);
+
+		//set refresh period
+		mctl_write_w(SDR_DRR, reg_drr);
+
+		//set timing parameters
+		mctl_write_w(SDR_TPR0, reg_tpr0);
+		mctl_write_w(SDR_TPR1, reg_tpr1);
+		mctl_write_w(SDR_TPR2, reg_tpr2);
+
+		//set mode register
+		mctl_write_w(SDR_MR, reg_mr);
+		mctl_write_w(SDR_EMR, reg_emr);
+		mctl_write_w(SDR_EMR2, reg_emr2);
+		mctl_write_w(SDR_EMR3, reg_emr3);
+
+		//set DQS window mode
+		reg_val = mctl_read_w(SDR_CCR);
+		reg_val |= 0x1U<<14;
+		mctl_write_w(SDR_CCR, reg_val);
+
+		//initial external DRAM
+		reg_val = mctl_read_w(SDR_CCR);
+		reg_val |= 0x1U<<31;
+		mctl_write_w(SDR_CCR, reg_val);
+
+		while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+		//scan read pipe value
+		mctl_itm_enable();
+		ret_val = DRAMC_scan_readpipe();
+
+		//configure all host port
+		mctl_configure_hostport();
+
+		if(ret_val == 0)
+			return 0;
+    }
+}
+
+void dram_power_save_process(void)
+{
+	__u32 reg_val;
+
+	//put external SDRAM into self-fresh state
+	DRAMC_enter_selfrefresh();
+
+	//disable ITM
+	mctl_itm_disable();
+
+	//dramc clock off
+	DRAMC_clock_output_en(0);
+
+	//disable and reset all DLL
+	mctl_disable_dll();
+}
+__u32 dram_power_up_process(void)
+{
+	__u32 i;
+	__s32 ret_val;
+
+	mctl_itm_disable();
+
+	mctl_enable_dll0();
+
+	//dram clock on
+	DRAMC_clock_output_en(1);
+    standby_delay(0x10);
+
+	mctl_enable_dllx();
+
+	//enable ITM
+	mctl_itm_enable();
+
+	//exit from self-refresh state
+	DRAMC_exit_selfrefresh();
+
+	//scan read pipe value
+	ret_val = DRAMC_scan_readpipe();
+	if(ret_val != 0)
+	{
+		DRAMC_retraining();
+	}
+
+	return (ret_val);
+}
+
+
+void dram_enter_selfrefresh(void)
+{
+    DRAMC_enter_selfrefresh();
+}
+
+
+void dram_exit_selfrefresh(void)
+{
+    DRAMC_exit_selfrefresh();
+}
+
+
+void dram_enter_power_down(void)
+{
+    DRAMC_enter_power_down();
+}
+
+
+void dram_exit_power_down(void)
+{
+    DRAMC_exit_power_down();
+}
+
+
+void dram_hostport_on_off(__u32 port_idx, __u32 on)
+{
+    DRAMC_hostport_on_off(port_idx, on);
+}
+
+
+__u32 dram_hostport_check_ahb_fifo_status(__u32 port_idx)
+{
+    return DRAMC_hostport_check_ahb_fifo_status(port_idx);
+}
+
+
+void dram_hostport_setup(__u32 port, __u32 prio, __u32 wait_cycle, __u32 cmd_num)
+{
+    DRAMC_hostport_setup(port, prio, wait_cycle, cmd_num);
+}
+
diff --git a/arch/arm/plat-sunxi/pm/standby/dram_i.h b/arch/arm/plat-sunxi/pm/standby/dram_i.h
new file mode 100644
index 0000000..b7d1d6a
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/dram_i.h
@@ -0,0 +1,109 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/dram_i.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Berg Xing <bergxing@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DRAM_I_H__
+#define __DRAM_I_H__
+
+#include <mach/dram.h>
+#include "standby_i.h"
+
+#define DRAMC_IO_BASE       SW_VA_DRAM_IO_BASE
+#define DRAMC_MEM_SIZE      0x400
+
+#define SDR_CCR				(DRAMC_IO_BASE + 0x00)
+#define SDR_DCR				(DRAMC_IO_BASE + 0x04)
+#define SDR_IOCR			(DRAMC_IO_BASE + 0x08)
+#define SDR_CSR				(DRAMC_IO_BASE + 0x0c)
+#define SDR_DRR				(DRAMC_IO_BASE + 0x10)
+#define SDR_TPR0			(DRAMC_IO_BASE + 0x14)
+#define SDR_TPR1			(DRAMC_IO_BASE + 0x18)
+#define SDR_TPR2			(DRAMC_IO_BASE + 0x1c)
+#define SDR_RSLR0			(DRAMC_IO_BASE + 0x4c)
+#define SDR_RSLR1			(DRAMC_IO_BASE + 0x50)
+#define SDR_RDQSGR			(DRAMC_IO_BASE + 0x5c)
+#define SDR_ODTCR			(DRAMC_IO_BASE + 0x98)
+#define SDR_DTR0			(DRAMC_IO_BASE + 0x9c)
+#define SDR_DTR1			(DRAMC_IO_BASE + 0xa0)
+#define SDR_DTAR			(DRAMC_IO_BASE + 0xa4)
+#define SDR_ZQCR0			(DRAMC_IO_BASE + 0xa8)
+#define SDR_ZQCR1			(DRAMC_IO_BASE + 0xac)
+#define SDR_ZQSR			(DRAMC_IO_BASE + 0xb0)
+#define SDR_IDCR			(DRAMC_IO_BASE + 0xb4)
+#define SDR_MR				(DRAMC_IO_BASE + 0x1f0)
+#define SDR_EMR				(DRAMC_IO_BASE + 0x1f4)
+#define SDR_EMR2			(DRAMC_IO_BASE + 0x1f8)
+#define SDR_EMR3  			(DRAMC_IO_BASE + 0x1fc)
+#define SDR_DLLCR			(DRAMC_IO_BASE + 0x200)
+#define SDR_DLLCR0			(DRAMC_IO_BASE + 0x204)
+#define SDR_DLLCR1			(DRAMC_IO_BASE + 0x208)
+#define SDR_DLLCR2			(DRAMC_IO_BASE + 0x20c)
+#define SDR_DLLCR3			(DRAMC_IO_BASE + 0x210)
+#define SDR_DLLCR4			(DRAMC_IO_BASE + 0x214)
+#define SDR_DQTR0			(DRAMC_IO_BASE + 0x218)
+#define SDR_DQTR1			(DRAMC_IO_BASE + 0x21c)
+#define SDR_DQTR2			(DRAMC_IO_BASE + 0x220)
+#define SDR_DQTR3			(DRAMC_IO_BASE + 0x224)
+#define SDR_DQSTR0			(DRAMC_IO_BASE + 0x228)
+#define SDR_DQSTR1			(DRAMC_IO_BASE + 0x22c)
+#define SDR_CR				(DRAMC_IO_BASE + 0x230)
+#define SDR_CFSR			(DRAMC_IO_BASE + 0x234)
+#define SDR_APR  			(DRAMC_IO_BASE + 0x240)
+#define SDR_LTR	  			(DRAMC_IO_BASE + 0x244)
+#define SDR_HPCR			(DRAMC_IO_BASE + 0x250)
+#define SDR_SCSR			(DRAMC_IO_BASE + 0x2e0)
+
+
+
+#define mctl_read_w(n)      (*((volatile unsigned int *)(n)))
+#define mctl_write_w(n,c)   (*((volatile unsigned int *)(n)) = (c))
+
+
+//CCM register for dram
+#define DRAM_CCM_BASE       SW_VA_CCM_IO_BASE
+#define DRAM_CCM_MEMSIZE    0x400
+
+#define DRAM_CCM_SDRAM_PLL_REG    (DRAM_CCM_BASE + 0x20)
+#define DRAM_CCM_AHB_GATE_REG     (DRAM_CCM_BASE + 0x60)
+#define DRAM_CCM_GPS_CLK_REG      (DRAM_CCM_BASE + 0xd0)
+#define DRAM_CCM_SDRAM_CLK_REG    (DRAM_CCM_BASE + 0x100)
+#define DRAM_CCM_MUS_CLK_REG      (DRAM_CCM_BASE + 0x15c)
+
+//TIMER register for system
+#define DRAM_TIMER_BASE     SW_VA_TIMERC_IO_BASE
+#define TIMER_CPU_CFG_REG   (DRAM_TIMER_BASE + 0x13c)
+
+
+extern void 	DRAMC_clock_output_en(__u32 on);
+extern void 	DRAMC_set_autorefresh_cycle(__u32 clk);
+extern int  	DRAMC_scan_readpipe(void);
+extern unsigned DRAMC_get_dram_size(void);
+
+extern void mctl_itm_disable(void);
+extern void mctl_itm_enable(void);
+extern void mctl_enable_dll0(void);
+extern void mctl_enable_dllx(void);
+extern void mctl_disable_dll(void);
+extern void DRAMC_hostport_on_off(__u32 port_idx, __u32 on);
+
+#endif  //__DRAM_REG_H__
+
diff --git a/arch/arm/plat-sunxi/pm/standby/dram_init.c b/arch/arm/plat-sunxi/pm/standby/dram_init.c
new file mode 100644
index 0000000..1a4b044
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/dram_init.c
@@ -0,0 +1,637 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/dram_init.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Berg Xing <bergxing@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "dram_i.h"
+
+typedef struct dram_para_t  __dram_para_t;
+
+
+/*
+*********************************************************************************************************
+*                                   DRAM INIT
+*
+* Description: dram init function
+*
+* Arguments  : para     dram config parameter
+*
+*
+* Returns    : result
+*
+* Note       :
+*********************************************************************************************************
+*/
+void mctl_ddr3_reset(void)
+{
+    __u32 reg_val;
+#ifdef CONFIG_ARCH_SUN4I
+    __u32 i=0;
+
+    mctl_write_w(TIMER_CPU_CFG_REG, 0);
+    reg_val = mctl_read_w(TIMER_CPU_CFG_REG);
+    reg_val >>=6;
+    reg_val &=0x3;
+    if(reg_val == 0)
+    {
+#endif
+        reg_val = mctl_read_w(SDR_CR);
+        reg_val &= ~(0x1<<12);
+        mctl_write_w(SDR_CR, reg_val);
+        standby_delay(0x100);
+        reg_val = mctl_read_w(SDR_CR);
+        reg_val |= (0x1<<12);
+        mctl_write_w(SDR_CR, reg_val);
+#ifdef CONFIG_ARCH_SUN4I
+    }
+    else
+    {
+        reg_val = mctl_read_w(SDR_CR);
+        reg_val |= (0x1<<12);
+        mctl_write_w(SDR_CR, reg_val);
+        standby_delay(0x100);
+        reg_val = mctl_read_w(SDR_CR);
+        reg_val &= ~(0x1<<12);
+        mctl_write_w(SDR_CR, reg_val);
+    }
+#endif
+}
+
+void mctl_set_drive(void)
+{
+    __u32 reg_val;
+
+    reg_val = mctl_read_w(SDR_CR);
+    reg_val |= (0x6<<12);
+		reg_val |= 0xFFC;
+    reg_val &= ~0x3;
+    mctl_write_w(SDR_CR, reg_val);
+}
+
+void mctl_itm_disable(void)
+{
+    __u32 reg_val = 0x0;
+
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1<<28;
+    mctl_write_w(SDR_CCR, reg_val);
+}
+
+void mctl_itm_enable(void)
+{
+    __u32 reg_val = 0x0;
+
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val &= ~(0x1<<28);
+    mctl_write_w(SDR_CCR, reg_val);
+}
+
+void mctl_enable_dll0(void)
+{
+    __u32 i = 0;
+
+    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0x40000000 | 0x80000000);
+	standby_delay(0x100);
+
+    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0xC0000000);
+	standby_delay(0x1000);
+
+    mctl_write_w(SDR_DLLCR0, mctl_read_w(SDR_DLLCR0) & ~0x80000000 | 0x40000000);
+    standby_delay(0x1000);
+}
+
+void mctl_enable_dllx(void)
+{
+    __u32 i = 0;
+
+    for(i=1; i<5; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x40000000 | 0x80000000);
+    }
+
+	standby_delay(0x100);
+
+    for(i=1; i<5; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0xC0000000);
+    }
+
+	standby_delay(0x1000);
+
+    for(i=1; i<5; i++)
+    {
+        mctl_write_w(SDR_DLLCR0+(i<<2), mctl_read_w(SDR_DLLCR0+(i<<2)) & ~0x80000000 | 0x40000000);
+    }
+    standby_delay(0x1000);
+}
+
+void mctl_disable_dll(void)
+{
+	__u32 reg_val;
+
+	reg_val = mctl_read_w(SDR_DLLCR0);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR0, reg_val);
+
+	reg_val = mctl_read_w(SDR_DLLCR1);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR1, reg_val);
+
+	reg_val = mctl_read_w(SDR_DLLCR2);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR2, reg_val);
+
+	reg_val = mctl_read_w(SDR_DLLCR3);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR3, reg_val);
+
+	reg_val = mctl_read_w(SDR_DLLCR4);
+	reg_val &= ~(0x1<<30);
+	reg_val |= 0x1U<<31;
+	mctl_write_w(SDR_DLLCR4, reg_val);
+}
+
+__u32 hpcr_value[32] = {
+#if   defined(CONFIG_ARCH_SUN4I)
+	0x00000301,0x00000301,0x00000301,0x00000301,
+	0x00000301,0x00000301,0x0,0x0,
+	0x0,0x0,0x0,0x0,
+	0x0,0x0,0x0,0x0,
+	0x00001031,0x00001031,0x00000735,0x00001035,
+	0x00001035,0x00000731,0x00001031,0x00000735,
+	0x00001035,0x00001031,0x00000731,0x00001035,
+	0x00001031,0x00000301,0x00000301,0x00000731,
+#elif defined(CONFIG_ARCH_SUN5I)
+	0x0,0x0,0x0,0x0,
+	0x0,0x0,0x0,0x0,
+	0x0,0x0,0x0,0x0,
+	0x0,0x0,0x0,0x0,
+	0x00001031,0x00001031,0x00000735,0x00001035,
+	0x00001035,0x00000731,0x00001031,0x0,
+	0x00000301,0x00000301,0x00000301,0x00000301,
+	0x00000301,0x00000301,0x00000301,0x0
+#else
+#error Unsupported sunxi architecture.
+#endif
+};
+
+void mctl_configure_hostport(void)
+{
+    __u32 i;
+
+    for(i=0; i<32; i++)
+    {
+        mctl_write_w(SDR_HPCR + (i<<2), hpcr_value[i]);
+    }
+}
+
+void mctl_setup_dram_clock(__u32 clk)
+{
+    __u32 reg_val;
+#if   defined(CONFIG_ARCH_SUN4I)
+    const __u32 clocks = 0x1;
+#elif defined(CONFIG_ARCH_SUN5I)
+    const __u32 clocks = 0x3;
+#else
+#error Unsupported sunxi architecture.
+#endif
+
+    //setup DRAM PLL
+    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
+    reg_val &= ~0x3;
+    reg_val |= 0x1;                     //m factor
+    reg_val &= ~(0x3<<4);
+    reg_val |= 0x1<<4;                  //k factor
+    reg_val &= ~(0x1f<<8);
+    reg_val |= (standby_uldiv((__u64)clk, 24)&0x1f)<<8;      //n factor
+    reg_val &= ~(0x3<<16);
+    reg_val |= 0x1<<16;                 //p factor
+    reg_val &= ~(0x1<<29);                                         //PLL on
+    reg_val |= (__u32)0x1<<31;          //PLL En
+    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
+    standby_delay(0x100000);
+    reg_val = mctl_read_w(DRAM_CCM_SDRAM_PLL_REG);
+	reg_val |= 0x1<<29;
+    mctl_write_w(DRAM_CCM_SDRAM_PLL_REG, reg_val);
+
+#if   defined(CONFIG_ARCH_SUN4I)
+    //reset GPS
+    reg_val = mctl_read_w(DRAM_CCM_GPS_CLK_REG);
+    reg_val &= ~0x3;
+    mctl_write_w(DRAM_CCM_GPS_CLK_REG, reg_val);
+    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+    reg_val |= (0x1<<26);
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+    standby_delay(0x20);
+    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+    reg_val &= ~(0x1<<26);
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+#elif defined(CONFIG_ARCH_SUN5I)
+    //setup MBUS clock
+    reg_val &= (0x1<<31)|(0x2<<24)|(0x1);
+    mctl_write_w(DRAM_CCM_MUS_CLK_REG, reg_val);
+#else
+#error Unsupported sunxi architecture.
+#endif
+
+    //open DRAMC AHB clock ( & DLL register clock on sun5i )
+    //close it first
+    reg_val = mctl_read_w(DRAM_CCM_AHB_GATE_REG);
+    reg_val &= ~(clocks<<14);
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+	standby_delay(0x1000);
+
+    //then open it
+    reg_val |= clocks<<14;
+    mctl_write_w(DRAM_CCM_AHB_GATE_REG, reg_val);
+	standby_delay(0x1000);
+}
+
+__s32 DRAMC_init(__dram_para_t *para)
+{
+    __u32 reg_val;
+    __s32 ret_val;
+
+    //check input dram parameter structure
+    if(!para)
+    {
+        //dram parameter is invalid
+        return -1;
+    }
+
+    //setup DRAM relative clock
+    mctl_setup_dram_clock(para->dram_clk);
+
+    //reset external DRAM
+    mctl_ddr3_reset();
+    mctl_set_drive();
+
+    //dram clock off
+    DRAMC_clock_output_en(0);
+
+#if   defined(CONFIG_ARCH_SUN4I)
+    //select dram controller 1
+    mctl_write_w(SDR_SCSR, 0x16237495);
+#endif
+
+    mctl_itm_disable();
+    mctl_enable_dll0();
+
+    //configure external DRAM
+    reg_val = 0;
+    if(para->dram_type == 3)
+        reg_val |= 0x1;
+    reg_val |= (para->dram_io_width>>3) <<1;
+
+    if(para->dram_chip_density == 256)
+        reg_val |= 0x0<<3;
+    else if(para->dram_chip_density == 512)
+        reg_val |= 0x1<<3;
+    else if(para->dram_chip_density == 1024)
+        reg_val |= 0x2<<3;
+    else if(para->dram_chip_density == 2048)
+        reg_val |= 0x3<<3;
+    else if(para->dram_chip_density == 4096)
+        reg_val |= 0x4<<3;
+    else if(para->dram_chip_density == 8192)
+        reg_val |= 0x5<<3;
+    else
+        reg_val |= 0x0<<3;
+    reg_val |= ((para->dram_bus_width>>3) - 1)<<6;
+    reg_val |= (para->dram_rank_num -1)<<10;
+    reg_val |= 0x1<<12;
+    reg_val |= ((0x1)&0x3)<<13;
+    mctl_write_w(SDR_DCR, reg_val);
+
+    //dram clock on
+    DRAMC_clock_output_en(1);
+	standby_delay(0x10);
+    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+		mctl_enable_dllx();
+
+		//set odt impendance divide ratio
+#if   defined(CONFIG_ARCH_SUN4I)
+		reg_val = mctl_read_w(SDR_ZQCR0);
+		reg_val &= ~(0xff<<20);
+#elif defined(CONFIG_ARCH_SUN5I)
+		reg_val=((para->dram_zq)>>8)&0xfffff;
+		reg_val |= (para->dram_zq)&0xf0000000;
+#else
+#error Unsupported sunxi architecture.
+#endif
+		reg_val |= ((para->dram_zq)&0xff)<<20;
+		mctl_write_w(SDR_ZQCR0, reg_val);
+
+		//set I/O configure register
+		reg_val = 0x00cc0000;
+		reg_val |= (para->dram_odt_en)&0x3;
+		reg_val |= ((para->dram_odt_en)&0x3)<<30;
+		mctl_write_w(SDR_IOCR, reg_val);
+
+		//set refresh period
+    DRAMC_set_autorefresh_cycle(para->dram_clk);
+
+    //set timing parameters
+    mctl_write_w(SDR_TPR0, para->dram_tpr0);
+    mctl_write_w(SDR_TPR1, para->dram_tpr1);
+    mctl_write_w(SDR_TPR2, para->dram_tpr2);
+
+    //set mode register
+    if(para->dram_type==3)                  //ddr3
+    {
+        reg_val = 0x0;
+        reg_val |= (para->dram_cas - 4)<<4;
+        reg_val |= 0x5<<9;
+    }
+    else if(para->dram_type==2)             //ddr2
+    {
+        reg_val = 0x2;
+        reg_val |= para->dram_cas<<4;
+        reg_val |= 0x5<<9;
+    }
+    mctl_write_w(SDR_MR, reg_val);
+
+    reg_val = 0x0;
+    mctl_write_w(SDR_EMR, para->dram_emr1);
+    reg_val = 0x0;
+		mctl_write_w(SDR_EMR2, para->dram_emr2);
+    reg_val = 0x0;
+		mctl_write_w(SDR_EMR3, para->dram_emr3);
+
+	//set DQS window mode
+	reg_val = mctl_read_w(SDR_CCR);
+	reg_val |= 0x1U<<14;
+	reg_val &= ~(0x1U<<17);
+	mctl_write_w(SDR_CCR, reg_val);
+
+    //initial external DRAM
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1U<<31;
+    mctl_write_w(SDR_CCR, reg_val);
+
+    while(mctl_read_w(SDR_CCR) & (0x1U<<31)) {};
+
+    //scan read pipe value
+    mctl_itm_enable();
+    ret_val = DRAMC_scan_readpipe();
+
+    if(ret_val < 0)
+    {
+        return 0;
+    }
+    //configure all host port
+    mctl_configure_hostport();
+
+    return DRAMC_get_dram_size();
+}
+
+/*
+*********************************************************************************************************
+*                                   DRAM EXIT
+*
+* Description: dram exit;
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 DRAMC_exit(void)
+{
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                   CHECK DDR READPIPE
+*
+* Description: check ddr readpipe;
+*
+* Arguments  : none
+*
+* Returns    : result, 0:fail, 1:success;
+*
+* Note       :
+*********************************************************************************************************
+*/
+__s32 DRAMC_scan_readpipe(void)
+{
+    __u32 reg_val;
+
+    //data training trigger
+    reg_val = mctl_read_w(SDR_CCR);
+    reg_val |= 0x1<<30;
+    mctl_write_w(SDR_CCR, reg_val);
+
+    //check whether data training process is end
+    while(mctl_read_w(SDR_CCR) & (0x1<<30)) {};
+
+    //check data training result
+    reg_val = mctl_read_w(SDR_CSR);
+    if(reg_val & (0x1<<20))
+    {
+        return -1;
+    }
+
+    return (0);
+}
+
+
+/*
+*********************************************************************************************************
+*                                   DRAM SCAN READ PIPE
+*
+* Description: dram scan read pipe
+*
+* Arguments  : none
+*
+* Returns    : result, 0:fail, 1:success;
+*
+* Note       :
+*********************************************************************************************************
+*/
+
+
+/*
+*********************************************************************************************************
+*                                   DRAM CLOCK CONTROL
+*
+* Description: dram get clock
+*
+* Arguments  : on   dram clock output (0: disable, 1: enable)
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+void DRAMC_clock_output_en(__u32 on)
+{
+    __u32 reg_val;
+#if   defined(CONFIG_ARCH_SUN4I)
+    __const __u32 reg = DRAM_CCM_SDRAM_CLK_REG;
+    __const __u32 magic = 15;
+#elif defined(CONFIG_ARCH_SUN5I)
+    __const __u32 reg = SDR_CR;
+    __const __u32 magic = 16;
+#else
+#error Unsupported sunxi architecture.
+#endif
+
+    reg_val = mctl_read_w(reg);
+
+    if(on)
+        reg_val |= 0x1 << magic;
+    else
+        reg_val &= ~(0x1 << magic);
+
+    mctl_write_w(reg, reg_val);
+}
+/*
+*********************************************************************************************************
+* Description: Set autorefresh cycle
+*
+* Arguments  : clock value in MHz unit
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+void DRAMC_set_autorefresh_cycle(__u32 clk)
+{
+    __u32 reg_val;
+    __u32 dram_size;
+    __u32 tmp_val;
+
+    dram_size = mctl_read_w(SDR_DCR);
+    dram_size >>=3;
+    dram_size &= 0x7;
+
+    if(clk < 600)
+    {
+        if(dram_size<=0x2)
+            tmp_val = (131*clk)>>10;
+        else
+            tmp_val = (336*clk)>>10;
+        reg_val = tmp_val;
+        tmp_val = (7987*clk)>>10;
+        tmp_val = tmp_val*9 - 200;
+        reg_val |= tmp_val<<8;
+        reg_val |= 0x8<<24;
+        mctl_write_w(SDR_DRR, reg_val);
+    }
+    else
+    {
+        mctl_write_w(SDR_DRR, 0x0);
+    }
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               GET DRAM SIZE
+*
+* Description: Get DRAM Size in MB unit;
+*
+* Arguments  : None
+*
+* Returns    : 32/64/128
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__u32 DRAMC_get_dram_size(void)
+{
+    __u32 reg_val;
+    __u32 dram_size;
+    __u32 chip_den;
+
+    reg_val = mctl_read_w(SDR_DCR);
+    chip_den = (reg_val>>3)&0x7;
+    if(chip_den == 0)
+        dram_size = 32;
+    else if(chip_den == 1)
+        dram_size = 64;
+    else if(chip_den == 2)
+        dram_size = 128;
+    else if(chip_den == 3)
+        dram_size = 256;
+    else if(chip_den == 4)
+        dram_size = 512;
+    else
+        dram_size = 1024;
+
+    if( ((reg_val>>1)&0x3) == 0x1)
+        dram_size<<=1;
+    if( ((reg_val>>6)&0x7) == 0x3)
+        dram_size<<=1;
+    if( ((reg_val>>10)&0x3) == 0x1)
+        dram_size<<=1;
+
+    return dram_size;
+}
+
+
+__s32 dram_init(void)
+{
+    /* do nothing for dram init */
+    return 0;
+}
+
+__s32 dram_exit(void)
+{
+    return DRAMC_exit();
+}
+
+__s32 dram_get_size(void)
+{
+    return DRAMC_get_dram_size();
+}
+
+void dram_set_clock(int clk)
+{
+    return mctl_setup_dram_clock(clk);
+}
+
+void dram_set_drive(void)
+{
+    mctl_set_drive();
+}
+
+void dram_set_autorefresh_cycle(__u32 clk)
+{
+    DRAMC_set_autorefresh_cycle(clk);
+}
+
+__s32 dram_scan_readpipe(void)
+{
+    return DRAMC_scan_readpipe();
+}
+
diff --git a/arch/arm/plat-sunxi/pm/standby/stack.S b/arch/arm/plat-sunxi/pm/standby/stack.S
new file mode 100644
index 0000000..600e833
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/stack.S
@@ -0,0 +1,109 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/stack.S
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <mach/platform.h>
+
+/* stack point address in sram */
+#define SP_IN_SRAM	0xf0007ffc
+
+    .text
+    .globl save_sp
+save_sp:
+    mov r0, r13
+    ldr  r13, =SP_IN_SRAM
+    mov pc,lr
+
+    .text
+    .globl restore_sp
+restore_sp:
+    mov r13, r0
+    mov pc,lr
+
+
+    .text
+    .globl standby_flush_tlb
+standby_flush_tlb:
+    push    {r0-r3}
+    /* invalid un-locked data and instruction tlb */
+    mcr p15, 0, r0, c8, c7, 0
+    pop     {r0-r3}
+    mov pc,lr
+
+    .text
+    .globl standby_preload_tlb
+standby_preload_tlb:
+    push    {r0-r3}
+    /* preload data tlb for standby io operation */
+    ldr r0, =SW_VA_CCM_IO_BASE
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =SW_VA_TWI0_IO_BASE
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =SW_VA_TWI1_IO_BASE
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =SW_VA_TWI2_IO_BASE
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =SW_VA_INT_IO_BASE
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =SW_VA_TIMERC_IO_BASE
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =SW_VA_LRADC_IO_BASE
+    mcr p15, 0, r0, c10, c1, 0
+    /* preload data tlb for standby code&data area */
+    ldr r0, =0xf0000000
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =0xf0000400
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =0xf0000800
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =0xf0000c00
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =0xf0001000
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =0xf0001400
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =0xf0001800
+    mcr p15, 0, r0, c10, c1, 0
+    ldr r0, =0xf0001c00
+    mcr p15, 0, r0, c10, c1, 0
+
+    /* preload instruction tlb for standby code&data area */
+    ldr r0, =0xf0000000
+    mcr p15, 0, r0, c10, c1, 1
+    ldr r0, =0xf0000400
+    mcr p15, 0, r0, c10, c1, 1
+    ldr r0, =0xf0000800
+    mcr p15, 0, r0, c10, c1, 1
+    ldr r0, =0xf0000c00
+    mcr p15, 0, r0, c10, c1, 1
+    ldr r0, =0xf0001000
+    mcr p15, 0, r0, c10, c1, 1
+    ldr r0, =0xf0001400
+    mcr p15, 0, r0, c10, c1, 1
+    ldr r0, =0xf0001800
+    mcr p15, 0, r0, c10, c1, 1
+    ldr r0, =0xf0001c00
+    mcr p15, 0, r0, c10, c1, 1
+
+    pop     {r0-r3}
+    mov pc,lr
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby.c b/arch/arm/plat-sunxi/pm/standby/standby.c
new file mode 100644
index 0000000..145bb7a
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby.c
@@ -0,0 +1,257 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+extern unsigned int save_sp(void);
+extern void restore_sp(unsigned int sp);
+extern void standby_flush_tlb(void);
+extern void standby_preload_tlb(void);
+extern char *__bss_start;
+extern char *__bss_end;
+extern char *__standby_start;
+extern char *__standby_end;
+
+static __u32 sp_backup;
+static void standby(void);
+static __u32 dcdc2, dcdc3;
+static struct sun4i_clk_div_t  clk_div;
+static struct sun4i_clk_div_t  tmp_clk_div;
+
+/* parameter for standby, it will be transfered from sys_pwm module */
+struct aw_pm_info  pm_info;
+
+#define DRAM_BASE_ADDR      0xc0000000
+#define DRAM_TRANING_SIZE   (16)
+static __u32 dram_traning_area_back[DRAM_TRANING_SIZE];
+
+/*
+*********************************************************************************************************
+*                                   STANDBY MAIN PROCESS ENTRY
+*
+* Description: standby main process entry.
+*
+* Arguments  : arg  pointer to the parameter that transfered from sys_pwm module.
+*
+* Returns    : none
+*
+* Note       :
+*********************************************************************************************************
+*/
+int __attribute__((section(".startup")))main(struct aw_pm_info *arg)
+{
+    char    *tmpPtr = (char *)&__bss_start;
+
+    if(!arg){
+        /* standby parameter is invalid */
+        return -1;
+    }
+
+    /* flush data and instruction tlb, there is 32 items of data tlb and 32 items of instruction tlb,
+       The TLB is normally allocated on a rotating basis. The oldest entry is always the next allocated */
+    standby_flush_tlb();
+    /* preload tlb for standby */
+    standby_preload_tlb();
+
+    /* clear bss segment */
+    do{*tmpPtr ++ = 0;}while(tmpPtr <= (char *)&__bss_end);
+
+    /* copy standby parameter from dram */
+    standby_memcpy(&pm_info, arg, sizeof(pm_info));
+    /* copy standby code & data to load tlb */
+    standby_memcpy((char *)&__standby_end, (char *)&__standby_start, (char *)&__bss_end - (char *)&__bss_start);
+    /* backup dram traning area */
+    standby_memcpy((char *)dram_traning_area_back, (char *)DRAM_BASE_ADDR, sizeof(__u32)*DRAM_TRANING_SIZE);
+
+    /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
+    /* init module before dram enter selfrefresh */
+    /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
+
+    /* initialise standby modules */
+    standby_clk_init();
+    standby_int_init();
+    standby_tmr_init();
+    standby_power_init();
+    /* init some system wake source */
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_EXINT){
+        standby_enable_int(INT_SOURCE_EXTNMI);
+    }
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_KEY){
+        standby_key_init();
+        standby_enable_int(INT_SOURCE_LRADC);
+    }
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_IR){
+        standby_ir_init();
+        standby_enable_int(INT_SOURCE_IR0);
+        standby_enable_int(INT_SOURCE_IR1);
+    }
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_ALARM){
+        //standby_alarm_init();???
+        standby_enable_int(INT_SOURCE_ALARM);
+    }
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_USB){
+        standby_usb_init();
+        standby_enable_int(INT_SOURCE_USB0);
+    }
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_TIMEOFF){
+        /* set timer for power off */
+        if(pm_info.standby_para.time_off) {
+            standby_tmr_set(pm_info.standby_para.time_off);
+            standby_enable_int(INT_SOURCE_TIMER0);
+        }
+    }
+
+    /* save stack pointer registger, switch stack to sram */
+    sp_backup = save_sp();
+    /* enable dram enter into self-refresh */
+    dram_power_save_process();
+    /* process standby */
+    standby();
+    /* enable watch-dog to preserve dram training failed */
+    standby_tmr_enable_watchdog();
+    /* restore dram */
+    dram_power_up_process();
+    /* disable watch-dog    */
+    standby_tmr_disable_watchdog();
+
+    /* restore stack pointer register, switch stack back to dram */
+    restore_sp(sp_backup);
+
+    /* exit standby module */
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_USB){
+        standby_usb_exit();
+    }
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_IR){
+        standby_ir_exit();
+    }
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_ALARM){
+        //standby_alarm_exit();
+    }
+    if(pm_info.standby_para.event & SUSPEND_WAKEUP_SRC_KEY){
+        standby_key_exit();
+    }
+    standby_power_exit();
+    standby_tmr_exit();
+    standby_int_exit();
+    standby_clk_exit();
+
+    /* restore dram traning area */
+    standby_memcpy((char *)DRAM_BASE_ADDR, (char *)dram_traning_area_back, sizeof(__u32)*DRAM_TRANING_SIZE);
+
+    /* report which wake source wakeup system */
+    arg->standby_para.event = pm_info.standby_para.event;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     SYSTEM PWM ENTER STANDBY MODE
+*
+* Description: enter standby mode.
+*
+* Arguments  : none
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+static void standby(void)
+{
+    /* gating off dram clock */
+    standby_clk_dramgating(0);
+
+    /* switch cpu clock to HOSC, and disable pll */
+    standby_clk_core2hosc();
+    standby_clk_plldisable();
+
+    /* backup voltages */
+    dcdc2 = standby_get_voltage(POWER_VOL_DCDC2);
+    dcdc3 = standby_get_voltage(POWER_VOL_DCDC3);
+
+    /* adjust voltage */
+    standby_set_voltage(POWER_VOL_DCDC3, STANDBY_DCDC3_VOL);
+    standby_set_voltage(POWER_VOL_DCDC2, STANDBY_DCDC2_VOL);
+
+    /* set clock division cpu:axi:ahb:apb = 2:2:2:1 */
+    standby_clk_getdiv(&clk_div);
+    tmp_clk_div.axi_div = 0;
+    tmp_clk_div.ahb_div = 0;
+    tmp_clk_div.apb_div = 0;
+    standby_clk_setdiv(&tmp_clk_div);
+    /* swtich apb1 to losc */
+    standby_clk_apb2losc();
+    standby_mdelay(10);
+    /* switch cpu to 32k */
+    standby_clk_core2losc();
+    #if(ALLOW_DISABLE_HOSC)
+    // disable HOSC, and disable LDO
+    standby_clk_hoscdisable();
+    standby_clk_ldodisable();
+    #endif
+
+    /* cpu enter sleep, wait wakeup by interrupt */
+    asm("WFI");
+
+    #if(ALLOW_DISABLE_HOSC)
+    /* enable LDO, enable HOSC */
+    standby_clk_ldoenable();
+    /* delay 1ms for power be stable */
+    standby_delay(1);
+    standby_clk_hoscenable();
+    standby_delay(1);
+    #endif
+    /* swtich apb1 to hosc */
+    standby_clk_apb2hosc();
+    /* switch clock to hosc */
+    standby_clk_core2hosc();
+    /* restore clock division */
+    standby_clk_setdiv(&clk_div);
+
+    /* check system wakeup event */
+    pm_info.standby_para.event = 0;
+    pm_info.standby_para.event |= standby_query_int(INT_SOURCE_EXTNMI)? 0:SUSPEND_WAKEUP_SRC_EXINT;
+    pm_info.standby_para.event |= standby_query_int(INT_SOURCE_USB0)? 0:SUSPEND_WAKEUP_SRC_USB;
+    pm_info.standby_para.event |= standby_query_int(INT_SOURCE_LRADC)? 0:SUSPEND_WAKEUP_SRC_KEY;
+    pm_info.standby_para.event |= standby_query_int(INT_SOURCE_IR0)? 0:SUSPEND_WAKEUP_SRC_IR;
+    pm_info.standby_para.event |= standby_query_int(INT_SOURCE_ALARM)? 0:SUSPEND_WAKEUP_SRC_ALARM;
+    pm_info.standby_para.event |= standby_query_int(INT_SOURCE_TIMER0)? 0:SUSPEND_WAKEUP_SRC_TIMEOFF;
+
+    /* restore voltage for exit standby */
+    standby_set_voltage(POWER_VOL_DCDC2, dcdc2);
+    standby_set_voltage(POWER_VOL_DCDC3, dcdc3);
+    standby_mdelay(10);
+
+    /* enable pll */
+    standby_clk_pllenable();
+    standby_mdelay(10);
+    /* switch cpu clock to core pll */
+    standby_clk_core2pll();
+    standby_mdelay(10);
+
+    /* gating on dram clock */
+    standby_clk_dramgating(1);
+
+    return;
+}
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby.lds b/arch/arm/plat-sunxi/pm/standby/standby.lds
new file mode 100644
index 0000000..8c803c3
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby.lds
@@ -0,0 +1,41 @@
+/*
+ * arch/arm/mach-sun4i/pm/standby/standby.lds
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(arm)
+ENTRY(main)
+
+SECTIONS
+{
+	__standby_start = . ;
+	.text 0xf0000000 :
+	{
+		arch/arm/plat-sunxi/pm/standby/standby.o(.startup)
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	.data   : { *(.data) }
+
+	__bss_start = . ;
+	.bss : { *(.sbss) *(.scommon) *(.bss) *(COMMON) }
+	__bss_end = .;
+	__standby_end = . ;
+}
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_cfg.h b/arch/arm/plat-sunxi/pm/standby/standby_cfg.h
new file mode 100644
index 0000000..6915589
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_cfg.h
@@ -0,0 +1,41 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_cfg.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_CFG_H__
+#define __STANDBY_CFG_H__
+
+
+//config wakeup source for standby
+#define ALLOW_DISABLE_HOSC          (1)     // if allow disable hosc
+
+#define STANDBY_LDO1_VOL            (1300)  //LDO1 voltage value
+#define STANDBY_LDO2_VOL            (3000)  //LDO2 voltage value
+#define STANDBY_LDO3_VOL            (2800)  //LDO3 voltage value
+#define STANDBY_LDO4_VOL            (3300)  //LDO4 voltage value
+#define STANDBY_DCDC2_VOL           (1000)  //DCDC2 voltage value
+#define STANDBY_DCDC3_VOL           (1000)  //DCDC3 voltage value
+
+
+#endif  /* __STANDBY_CFG_H__ */
+
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_clock.c b/arch/arm/plat-sunxi/pm/standby/standby_clock.c
new file mode 100644
index 0000000..4c9c06b
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_clock.c
@@ -0,0 +1,391 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_clock.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+static __ccmu_reg_list_t   *CmuReg;;
+static __u32    ccu_reg_back[7];
+__u32   cpu_ms_loopcnt;
+
+/*
+*********************************************************************************************************
+*                           standby_clk_init
+*
+*Description: ccu init for platform standby
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_clk_init(void)
+{
+    CmuReg = (__ccmu_reg_list_t *)SW_VA_CCM_IO_BASE;
+
+    /* backup pll registers */
+    ccu_reg_back[0] = *(volatile __u32 *)&CmuReg->Pll1Ctl;
+    ccu_reg_back[1] = *(volatile __u32 *)&CmuReg->Pll2Ctl;
+    ccu_reg_back[2] = *(volatile __u32 *)&CmuReg->Pll3Ctl;
+    ccu_reg_back[3] = *(volatile __u32 *)&CmuReg->Pll4Ctl;
+    ccu_reg_back[4] = *(volatile __u32 *)&CmuReg->Pll5Ctl;
+    ccu_reg_back[5] = *(volatile __u32 *)&CmuReg->Pll6Ctl;
+    ccu_reg_back[6] = *(volatile __u32 *)&CmuReg->Pll7Ctl;
+
+    /* cpu frequency is 60mhz now */
+    cpu_ms_loopcnt = 3000;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_clk_exit
+*
+*Description: ccu exit for platform standby
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_clk_exit(void)
+{
+    /* restore pll registers */
+    *(volatile __u32 *)&CmuReg->Pll1Ctl = ccu_reg_back[0];
+    *(volatile __u32 *)&CmuReg->Pll2Ctl = ccu_reg_back[1];
+    *(volatile __u32 *)&CmuReg->Pll3Ctl = ccu_reg_back[2];
+    *(volatile __u32 *)&CmuReg->Pll4Ctl = ccu_reg_back[3];
+    *(volatile __u32 *)&CmuReg->Pll5Ctl = ccu_reg_back[4];
+    *(volatile __u32 *)&CmuReg->Pll6Ctl = ccu_reg_back[5];
+    *(volatile __u32 *)&CmuReg->Pll7Ctl = ccu_reg_back[6];
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_core2losc
+*
+* Description: switch core clock to 32k low osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_core2losc(void)
+{
+    CmuReg->SysClkDiv.AC328ClkSrc = 0;
+    /* cpu frequency is 32k hz */
+    cpu_ms_loopcnt = 1;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_core2hosc
+*
+* Description: switch core clock to 24M high osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_core2hosc(void)
+{
+    CmuReg->SysClkDiv.AC328ClkSrc = 1;
+    /* cpu frequency is 24M hz */
+    cpu_ms_loopcnt = 600;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_core2pll
+*
+* Description: switch core clock to core pll.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_core2pll(void)
+{
+    CmuReg->SysClkDiv.AC328ClkSrc = 2;
+    /* cpu frequency is 60M hz */
+    cpu_ms_loopcnt = 2000;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_plldisable
+*
+* Description: disable dram pll.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_plldisable(void)
+{
+    CmuReg->Pll1Ctl.PLLEn = 0;
+    CmuReg->Pll2Ctl.PLLEn = 0;
+    CmuReg->Pll3Ctl.PLLEn = 0;
+    CmuReg->Pll4Ctl.PLLEn = 0;
+    CmuReg->Pll5Ctl.PLLEn = 0;
+    CmuReg->Pll6Ctl.PLLEn = 0;
+    CmuReg->Pll7Ctl.PLLEn = 0;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_pllenable
+*
+* Description: enable dram pll.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_pllenable(void)
+{
+    CmuReg->Pll1Ctl.PLLEn = 1;
+    CmuReg->Pll2Ctl.PLLEn = 1;
+    CmuReg->Pll3Ctl.PLLEn = 1;
+    CmuReg->Pll4Ctl.PLLEn = 1;
+    CmuReg->Pll5Ctl.PLLEn = 1;
+    CmuReg->Pll6Ctl.PLLEn = 1;
+    CmuReg->Pll7Ctl.PLLEn = 1;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_hoscdisable
+*
+* Description: disable HOSC.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_hoscdisable(void)
+{
+    CmuReg->HoscCtl.OSC24MEn = 0;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_hoscenable
+*
+* Description: enable HOSC.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_hoscenable(void)
+{
+    CmuReg->HoscCtl.OSC24MEn = 1;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_ldodisable
+*
+* Description: disable LDO.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_ldodisable(void)
+{
+    CmuReg->HoscCtl.KeyField = 0x538;
+    CmuReg->HoscCtl.LDOEn = 0;
+    CmuReg->Pll5Ctl.LDO2En = 0;
+    CmuReg->HoscCtl.KeyField = 0x00;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_ldoenable
+*
+* Description: enable LDO.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_ldoenable(void)
+{
+    CmuReg->HoscCtl.KeyField = 0x538;
+    CmuReg->HoscCtl.LDOEn = 1;
+    CmuReg->Pll5Ctl.LDO2En = 1;
+    CmuReg->HoscCtl.KeyField = 0x00;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_setdiv
+*
+* Description: switch core clock to 32k low osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_setdiv(struct sun4i_clk_div_t  *clk_div)
+{
+    if(!clk_div)
+    {
+        return -1;
+    }
+
+    CmuReg->SysClkDiv.AXIClkDiv = clk_div->axi_div;
+    CmuReg->SysClkDiv.AHBClkDiv = clk_div->ahb_div;
+    CmuReg->SysClkDiv.APB0ClkDiv = clk_div->apb_div;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_getdiv
+*
+* Description: switch core clock to 32k low osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_getdiv(struct sun4i_clk_div_t  *clk_div)
+{
+    if(!clk_div)
+    {
+        return -1;
+    }
+
+    clk_div->axi_div = CmuReg->SysClkDiv.AXIClkDiv;
+    clk_div->ahb_div = CmuReg->SysClkDiv.AHBClkDiv;
+    clk_div->apb_div = CmuReg->SysClkDiv.APB0ClkDiv;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_dramgating
+*
+* Description: gating dram clock.
+*
+* Arguments  : onoff    dram clock gating on or off;
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+void standby_clk_dramgating(int onoff)
+{
+    if(onoff) {
+        CmuReg->Pll5Ctl.OutputEn = 1;
+    }
+    else {
+        CmuReg->Pll5Ctl.OutputEn = 0;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_apb2losc
+*
+* Description: switch apb1 clock to 32k low osc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_apb2losc(void)
+{
+    CmuReg->Apb1ClkDiv.ClkSrc = 2;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_apb2hosc
+*
+* Description: switch apb1 clock to 24M hosc.
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 standby_clk_apb2hosc(void)
+{
+    CmuReg->Apb1ClkDiv.ClkSrc = 0;
+    return 0;
+}
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_clock.h b/arch/arm/plat-sunxi/pm/standby/standby_clock.h
new file mode 100644
index 0000000..a9164a2
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_clock.h
@@ -0,0 +1,57 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_clock.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_CLOCK_H__
+#define __STANDBY_CLOCK_H__
+
+#include "standby_cfg.h"
+#include <mach/ccmu_regs.h>
+
+struct sun4i_clk_div_t {
+    __u32   cpu_div:4;      /* division of cpu clock, divide core_pll */
+    __u32   axi_div:4;      /* division of axi clock, divide cpu clock*/
+    __u32   ahb_div:4;      /* division of ahb clock, divide axi clock*/
+    __u32   apb_div:4;      /* division of apb clock, divide ahb clock*/
+    __u32   reserved:16;
+};
+
+__s32 standby_clk_init(void);
+__s32 standby_clk_exit(void);
+__s32 standby_clk_core2losc(void);
+__s32 standby_clk_core2hosc(void);
+__s32 standby_clk_core2pll(void);
+__s32 standby_clk_plldisable(void);
+__s32 standby_clk_pllenable(void);
+__s32 standby_clk_hoscdisable(void);
+__s32 standby_clk_hoscenable(void);
+__s32 standby_clk_ldodisable(void);
+__s32 standby_clk_ldoenable(void);
+__s32 standby_clk_setdiv(struct sun4i_clk_div_t  *clk_div);
+__s32 standby_clk_getdiv(struct sun4i_clk_div_t  *clk_div);
+void standby_clk_dramgating(int onoff);
+__s32 standby_clk_apb2losc(void);
+__s32 standby_clk_apb2hosc(void);
+
+extern __u32   cpu_ms_loopcnt;
+
+#endif  /* __STANDBY_CLOCK_H__ */
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_delay.S b/arch/arm/plat-sunxi/pm/standby/standby_delay.S
new file mode 100644
index 0000000..f06ba58
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_delay.S
@@ -0,0 +1,30 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_delay.S
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+    .text
+    .globl standby_delay
+standby_delay:
+	subs    r0, r0, #1
+	bhi	    standby_delay
+	mov     pc, lr
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_i.h b/arch/arm/plat-sunxi/pm/standby/standby_i.h
new file mode 100644
index 0000000..6725a71
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_i.h
@@ -0,0 +1,83 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_i.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_I_H__
+#define __STANDBY_I_H__
+
+#include <linux/power/aw_pm.h>
+#include <mach/platform.h>
+
+#include "standby_cfg.h"
+#include "common.h"
+#include "standby_clock.h"
+#include "standby_key.h"
+#include "standby_power.h"
+#include "standby_usb.h"
+#include "standby_twi.h"
+#include "standby_ir.h"
+#include "standby_tmr.h"
+#include "standby_int.h"
+
+extern struct aw_pm_info  pm_info;
+
+
+static inline __u32 raw_lib_udiv(__u32 dividend, __u32 divisior)
+{
+    __u32   tmpDiv = (__u32)divisior;
+    __u32   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return 0;
+    }
+
+    while(!(tmpDiv & ((__u32)1<<31)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
+
+
+
+#endif  //__STANDBY_I_H__
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_int.c b/arch/arm/plat-sunxi/pm/standby/standby_int.c
new file mode 100644
index 0000000..becea90
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_int.c
@@ -0,0 +1,149 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_int.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+static __u32    IrqEnReg[3], IrqMaskReg[3], IrqSelReg[3];
+static struct standby_int_reg_t  *IntcReg;
+
+
+
+
+/*
+*********************************************************************************************************
+*                                       STANDBY INTERRUPT INITIALISE
+*
+* Description: standby interrupt initialise.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 standby_int_init(void)
+{
+    IntcReg = (struct standby_int_reg_t *)SW_VA_INT_IO_BASE;
+
+    /* save interrupt controller registers */
+    IrqEnReg[0] = IntcReg->IrqEn[0];
+    IrqEnReg[1] = IntcReg->IrqEn[1];
+    IrqEnReg[2] = IntcReg->IrqEn[2];
+    IrqMaskReg[0] = IntcReg->IrqMask[0];
+    IrqMaskReg[1] = IntcReg->IrqMask[1];
+    IrqMaskReg[2] = IntcReg->IrqMask[2];
+    IrqSelReg[0] = IntcReg->TypeSel[0];
+    IrqSelReg[1] = IntcReg->TypeSel[1];
+    IrqSelReg[2] = IntcReg->TypeSel[2];
+
+    /* initialise interrupt enable and mask for standby */
+    IntcReg->IrqEn[0] = 0;
+    IntcReg->IrqEn[1] = 0;
+    IntcReg->IrqEn[2] = 0;
+    IntcReg->IrqMask[0] = 0xffffffff;
+    IntcReg->IrqMask[1] = 0xffffffff;
+    IntcReg->IrqMask[2] = 0xffffffff;
+    IntcReg->TypeSel[0] = 0;
+    IntcReg->TypeSel[1] = 0;
+    IntcReg->TypeSel[2] = 0;
+
+    /* clear external irq pending */
+    IntcReg->IrqPend[0] = 1;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       STANDBY INTERRUPT INITIALISE
+*
+* Description: standby interrupt initialise.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 standby_int_exit(void)
+{
+    /* restore interrupt registers */
+    IntcReg->IrqEn[0] = IrqEnReg[0];
+    IntcReg->IrqEn[1] = IrqEnReg[1];
+    IntcReg->IrqEn[2] = IrqEnReg[2];
+    IntcReg->IrqMask[0] = IrqMaskReg[0];
+    IntcReg->IrqMask[1] = IrqMaskReg[1];
+    IntcReg->IrqMask[2] = IrqMaskReg[2];
+    IntcReg->TypeSel[0] = IrqSelReg[0];
+    IntcReg->TypeSel[1] = IrqSelReg[1];
+    IntcReg->TypeSel[2] = IrqSelReg[2];
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       QUERY INTERRUPT
+*
+* Description: query interrupt.
+*
+* Arguments  : src  interrupt source number.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 standby_enable_int(enum interrupt_source_e src)
+{
+    __u32   tmpGrp = (__u32)src >> 5;
+    __u32   tmpSrc = (__u32)src & 0x1f;
+
+    //enable interrupt source
+    IntcReg->IrqEn[tmpGrp] |=  (1<<tmpSrc);
+    IntcReg->IrqMask[tmpGrp] &= ~(1<<tmpSrc);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       QUERY INTERRUPT
+*
+* Description: query interrupt.
+*
+* Arguments  : src  interrupt source number.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 standby_query_int(enum interrupt_source_e src)
+{
+    __s32   result = 0;
+    __u32   tmpGrp = (__u32)src >> 5;
+    __u32   tmpSrc = (__u32)src & 0x1f;
+
+    result = IntcReg->IrqPend[tmpGrp] & (1<<tmpSrc);
+
+    return result? 0:-1;
+}
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_int.h b/arch/arm/plat-sunxi/pm/standby/standby_int.h
new file mode 100644
index 0000000..6dca954
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_int.h
@@ -0,0 +1,90 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_int.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_INT_H__
+#define __STANDBY_INT_H__
+
+#include "standby_cfg.h"
+
+
+/* define interrupt source */
+enum interrupt_source_e{
+
+    INT_SOURCE_EXTNMI   = 0,
+    INT_SOURCE_IR0      = 5,
+    INT_SOURCE_IR1      = 6,
+    INT_SOURCE_KEYPAD   = 21,
+    INT_SOURCE_TIMER0   = 22,
+    INT_SOURCE_TIMER1   = 23,
+    INT_SOURCE_ALARM    = 24,
+    INT_SOURCE_TOUCHPNL = 29,
+    INT_SOURCE_LRADC    = 31,
+    INT_SOURCE_USB0     = 38,
+    INT_SOURCE_USB1     = 39,
+    INT_SOURCE_USB2     = 40,
+    INT_SOURCE_USB3     = 64,
+    INT_SOURCE_USB4     = 65,
+};
+
+
+/* define register for interrupt controller */
+struct standby_int_reg_t{
+
+    volatile __u32   Vector;
+    volatile __u32   BaseAddr;
+    volatile __u32   reserved0;
+    volatile __u32   NmiCtrl;
+
+    volatile __u32   IrqPend[3];
+    volatile __u32   reserved1;
+
+    volatile __u32   FiqPend[3];
+    volatile __u32   reserved2;
+
+    volatile __u32   TypeSel[3];
+    volatile __u32   reserved3;
+
+    volatile __u32   IrqEn[3];
+    volatile __u32   reserved4;
+
+    volatile __u32   IrqMask[3];
+    volatile __u32   reserved5;
+
+    volatile __u32   IrqResp[3];
+    volatile __u32   reserved6;
+
+    volatile __u32   IrqForce[3];
+    volatile __u32   reserved7;
+
+    volatile __u32   IrqPrio[5];
+};
+
+
+extern __s32 standby_int_init(void);
+extern __s32 standby_int_exit(void);
+extern __s32 standby_enable_int(enum interrupt_source_e src);
+extern __s32 standby_query_int(enum interrupt_source_e src);
+
+
+#endif  //__STANDBY_INT_H__
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_ir.c b/arch/arm/plat-sunxi/pm/standby/standby_ir.c
new file mode 100644
index 0000000..5ae43c9
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_ir.c
@@ -0,0 +1,101 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_ir.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include  "standby_i.h"
+
+
+
+/*
+*********************************************************************************************************
+*                           INIT IR FOR STANDBY
+*
+*Description: init ir for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    init ir successed;
+*               EPDK_FAIL,  init ir failed;
+*********************************************************************************************************
+*/
+__s32  standby_ir_init(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           EXIT IR FOR STANDBY
+*
+*Description: exit ir for standby;
+*
+*Arguments  : none;
+*
+*Return     : result.
+*               EPDK_OK,    exit ir successed;
+*               EPDK_FAIL,  exit ir failed;
+*********************************************************************************************************
+*/
+__s32 standby_ir_exit(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           DETECT IR FOR STANDBY
+*
+*Description: detect ir for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    receive some signal;
+*               EPDK_FAIL,  no signal;
+*********************************************************************************************************
+*/
+__s32 standby_ir_detect(void)
+{
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           VERIFY IR SIGNAL FOR STANDBY
+*
+*Description: verify ir signal for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    valid ir signal;
+*               EPDK_FAIL,  invalid ir signal;
+*********************************************************************************************************
+*/
+__s32 standby_ir_verify(void)
+{
+    return -1;
+}
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_ir.h b/arch/arm/plat-sunxi/pm/standby/standby_ir.h
new file mode 100644
index 0000000..089a1b6
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_ir.h
@@ -0,0 +1,34 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_ir.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_IR_H__
+#define __STANDBY_IR_H__
+
+#include "standby_cfg.h"
+
+extern __s32 standby_ir_init(void);
+extern __s32 standby_ir_exit(void);
+extern __s32 standby_ir_detect(void);
+extern __s32 standby_ir_verify(void);
+
+#endif  /*__STANDBY_IR_H__*/
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_key.c b/arch/arm/plat-sunxi/pm/standby/standby_key.c
new file mode 100644
index 0000000..af04576
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_key.c
@@ -0,0 +1,99 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_key.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * Querry key to wake up system from standby
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+static __standby_key_reg_t  *KeyReg;
+static __u32 KeyCtrl, KeyIntc, KeyInts, KeyData0, KeyData1;
+
+/*
+*********************************************************************************************************
+*                                     INIT KEY FOR STANDBY
+*
+* Description: init key for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_OK;
+*********************************************************************************************************
+*/
+__s32 standby_key_init(void)
+{
+    /* set key register base */
+    KeyReg = (__standby_key_reg_t *)SW_VA_LRADC_IO_BASE;
+
+    /* backup LRADC registers */
+    KeyCtrl = KeyReg->Lradc_Ctrl;
+    KeyIntc = KeyReg->Lradc_Intc;
+    KeyReg->Lradc_Ctrl = 0;
+    standby_mdelay(10);
+    KeyReg->Lradc_Ctrl = (0x1<<6)|(0x1<<0);
+    KeyReg->Lradc_Intc = (0x1<<1);
+    KeyReg->Lradc_Ints = (0x1<<1);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     EXIT KEY FOR STANDBY
+*
+* Description: exit key for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_OK;
+*********************************************************************************************************
+*/
+__s32 standby_key_exit(void)
+{
+    KeyReg->Lradc_Ctrl =  KeyCtrl;
+    KeyReg->Lradc_Intc =  KeyIntc;
+    return 0;
+}
+/*
+*********************************************************************************************************
+*                                     QUERY KEY FOR WAKEUP STANDBY
+*
+* Description: query key for wakeup standby.
+*
+* Arguments  : none
+*
+* Returns    : result;
+*               EPDK_TRUE,      get a key;
+*               EPDK_FALSE,     no key;
+*********************************************************************************************************
+*/
+__s32 standby_query_key(void)
+{
+    if(KeyReg->Lradc_Ints & 0x2)
+    {
+        KeyReg->Lradc_Ints = 0x2;
+        return 0;
+    }
+    return -1;
+}
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_key.h b/arch/arm/plat-sunxi/pm/standby/standby_key.h
new file mode 100644
index 0000000..86fd8cf
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_key.h
@@ -0,0 +1,45 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_key.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_KEY_H__
+#define __STANDBY_KEY_H__
+
+#include "standby_cfg.h"
+//define key controller registers
+typedef struct __STANDBY_KEY_REG
+{
+    // offset:0x00
+    volatile __u32   Lradc_Ctrl;
+    volatile __u32   Lradc_Intc;
+    volatile __u32   Lradc_Ints;
+    volatile __u32   Lradc_Data0;
+    volatile __u32   Lradc_Data1;
+} __standby_key_reg_t;
+
+extern __s32 standby_key_init(void);
+extern __s32 standby_key_exit(void);
+extern __s32 standby_query_key(void);
+
+
+#endif  /* __STANDBY_KEY_H__ */
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_power.c b/arch/arm/plat-sunxi/pm/standby/standby_power.c
new file mode 100644
index 0000000..053bb41
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_power.c
@@ -0,0 +1,239 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_power.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+/*
+*********************************************************************************************************
+*                           standby_power_init
+*
+* Description: init power for standby.
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*********************************************************************************************************
+*/
+__s32 standby_power_init(void)
+{
+    __u8 val, mask, reg_val;
+    __s32   i;
+
+	standby_twi_init(AXP_IICBUS);
+
+    #if(AXP_WAKEUP & AXP_WAKEUP_KEY)
+    /* enable pek long/short */
+	twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+	reg_val |= 0x03;
+	twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+    #endif
+
+    #if(AXP_WAKEUP & AXP_WAKEUP_LOWBATT)
+    /* enable low voltage warning */
+	twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN4, &reg_val);
+	reg_val |= 0x03;
+	twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN4, &reg_val);
+    /* clear pending */
+	reg_val = 0x03;
+	twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQ4, &reg_val);
+    #endif
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_power_exit
+*
+* Description: exit power for standby.
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*********************************************************************************************************
+*/
+__s32 standby_power_exit(void)
+{
+    __u8    reg_val;
+
+	twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQ4, &reg_val);
+	twi_byte_rw(TWI_OP_WR, AXP_ADDR,0x0E, &reg_val);
+
+    #if(AXP_WAKEUP & AXP_WAKEUP_KEY)
+    /* disable pek long/short */
+	twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+	reg_val &= ~0x03;
+	twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN3, &reg_val);
+    #endif
+
+    #if(AXP_WAKEUP & AXP_WAKEUP_LOWBATT)
+    /* disable low voltage warning */
+	twi_byte_rw(TWI_OP_RD, AXP_ADDR,AXP20_IRQEN4, &reg_val);
+	reg_val &= ~0x03;
+	twi_byte_rw(TWI_OP_WR, AXP_ADDR,AXP20_IRQEN4, &reg_val);
+    #endif
+
+    standby_twi_exit();
+    return 0;
+}
+
+
+static inline int check_range(struct axp_info *info,__s32 voltage)
+{
+	if (voltage < info->min_uV || voltage > info->max_uV)
+		return -1;
+
+	return 0;
+}
+
+static int axp20_ldo4_data[] = {
+    1250, 1300, 1400, 1500, 1600, 1700,
+    1800, 1900, 2000, 2500, 2700, 2800,
+    3000, 3100, 3200, 3300
+};
+
+static struct axp_info axp20_info[] = {
+	AXP(POWER_VOL_LDO1,	 AXP20LDO1,	AXP20LDO1,	  0, AXP20_LDO1,  0, 0),//ldo1 for rtc
+	AXP(POWER_VOL_LDO2,	      1800,      3300,  100, AXP20_LDO2,  4, 4),//ldo2 for analog1
+	AXP(POWER_VOL_LDO3,	       700,      3500,   25, AXP20_LDO3,  0, 7),//ldo3 for digital
+	AXP(POWER_VOL_LDO4,	      1250,      3300,  100, AXP20_LDO4,  0, 4),//ldo4 for analog2
+	AXP(POWER_VOL_DCDC2,       700,      2275,   25, AXP20_BUCK2, 0, 6),//buck2 for core
+	AXP(POWER_VOL_DCDC3,       700,      3500,   25, AXP20_BUCK3, 0, 7),//buck3 for memery
+};
+
+static inline struct axp_info *find_info(int id)
+{
+	struct axp_info *ri;
+	int i;
+
+	for (i = 0; i < sizeof(axp20_info)/sizeof(struct axp_info); i++) {
+		ri = &axp20_info[i];
+		if (ri->id == id)
+			return ri;
+	}
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           standby_set_voltage
+*
+*Description: set voltage for standby;
+*
+*Arguments  : type      voltage type, defined as "enum power_vol_type_e";
+*             voltage   voltage value, based on "mv";
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void  standby_set_voltage(enum power_vol_type_e type, __s32 voltage)
+{
+	struct axp_info *info = 0;
+	__u8 val, mask, reg_val;
+
+	info = find_info(type);
+	if (info == 0) {
+		return;
+	}
+
+	if (check_range(info, voltage)) {
+		return;
+	}
+
+	if (type != POWER_VOL_LDO4)
+		val = raw_lib_udiv((voltage-info->min_uV+info->step_uV-1), info->step_uV);
+	else{
+		if(voltage == 1250000 ){
+			val = 0;
+		}
+		else{
+			val = raw_lib_udiv((voltage-1200000+info->step_uV-1), info->step_uV);
+			if(val > 16){
+				val = val - 6;
+			}
+			else if(val > 13){
+				val = val - 5;
+			}
+			else if(val > 12){
+				val = val - 4;
+			}
+			else if(val > 8)
+				val = 8;
+		}
+	}
+
+
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	twi_byte_rw(TWI_OP_RD,AXP_ADDR,info->vol_reg, &reg_val);
+
+	if ((reg_val & mask) != val) {
+		reg_val = (reg_val & ~mask) | val;
+		twi_byte_rw(TWI_OP_WR,AXP_ADDR,info->vol_reg, &reg_val);
+	}
+
+	return;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_get_voltage
+*
+*Description: get voltage for standby;
+*
+*Arguments  : type  voltage type, defined as "enum power_vol_type_e";
+*
+*Return     : voltage value, based on "mv";
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__u32 standby_get_voltage(enum power_vol_type_e type)
+{
+	struct axp_info *info = 0;
+	__u8 val, mask;
+	int ret;
+
+	info = find_info(type);
+	if (info == 0) {
+		return -1;
+	}
+
+	twi_byte_rw(TWI_OP_RD,AXP_ADDR,info->vol_reg, &val);
+
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+	if (type != POWER_VOL_LDO4)
+		return info->min_uV + info->step_uV * val;
+	else
+		return axp20_ldo4_data[val]*1000;
+}
+
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_power.h b/arch/arm/plat-sunxi/pm/standby/standby_power.h
new file mode 100644
index 0000000..34a6c50
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_power.h
@@ -0,0 +1,102 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_power.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_POWER_H__
+#define __STANDBY_POWER_H__
+
+#include "standby_cfg.h"
+
+enum power_vol_type_e{
+
+    POWER_VOL_DCDC1,
+    POWER_VOL_DCDC2,
+    POWER_VOL_DCDC3,
+    POWER_VOL_LDO1,
+    POWER_VOL_LDO2,
+    POWER_VOL_LDO3,
+    POWER_VOL_LDO4,
+
+};
+
+#define AXP_ADDR        (0x34)
+#define AXP_IICBUS      (0)
+#define AXP20_LDO1      (0x00)
+#define AXP20_LDO2      (0x28)
+#define AXP20_LDO3      (0x29)
+#define AXP20_LDO4      (0x28)
+#define AXP20_BUCK2     (0x23)
+#define AXP20_BUCK3     (0x27)
+
+#define AXP20_IRQEN1    (0x40)
+#define AXP20_IRQEN2    (0x41)
+#define AXP20_IRQEN3    (0x42)
+#define AXP20_IRQEN4    (0x43)
+#define AXP20_IRQEN5    (0x44)
+
+#define AXP20_IRQ1      (0x48)
+#define AXP20_IRQ2      (0x49)
+#define AXP20_IRQ3      (0x4A)
+#define AXP20_IRQ4      (0x4B)
+#define AXP20_IRQ5      (0x4C)
+
+#define AXP20LDO1       1300
+
+
+#define AXP(_id, min, max, step, vreg, shift, nbits)    \
+{                               \
+    .id = _id,                  \
+    .min_uV        = (min),     \
+    .max_uV        = (max),     \
+    .step_uV    = (step),       \
+    .vol_reg    =  (vreg),      \
+    .vol_shift    = (shift),    \
+    .vol_nbits    = (nbits),    \
+}
+
+struct axp_info {
+    enum    power_vol_type_e id;
+    int     min_uV;
+    int     max_uV;
+    int     step_uV;
+    int     vol_reg;
+    int     vol_shift;
+    int     vol_nbits;
+};
+
+
+#define AXP_WAKEUP_KEY          (1<<0)
+#define AXP_WAKEUP_LOWBATT      (1<<1)
+#define AXP_WAKEUP_USB          (1<<2)
+#define AXP_WAKEUP_AC           (1<<3)
+
+#define AXP_WAKEUP              (AXP_WAKEUP_KEY | AXP_WAKEUP_LOWBATT)
+
+extern __s32 standby_power_init(void);
+extern __s32 standby_power_exit(void);
+extern void  standby_set_voltage(enum power_vol_type_e type, __s32 voltage);
+extern __u32 standby_get_voltage(enum power_vol_type_e type);
+
+
+#endif  /* __STANDBY_POWER_H__ */
+
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_tmr.c b/arch/arm/plat-sunxi/pm/standby/standby_tmr.c
new file mode 100644
index 0000000..4b27443
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_tmr.c
@@ -0,0 +1,243 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_tmr.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+static __standby_tmr_reg_t  *TmrReg;
+static __u32 TmrIntCtl, Tmr0Ctl, Tmr0IntVal, Tmr0CntVal, Tmr1Ctl, Tmr1IntVal, Tmr1CntVal;
+
+/*
+*********************************************************************************************************
+*                                     TIMER INIT
+*
+* Description: initialise timer for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 standby_tmr_init(void)
+{
+    __s32       i;
+
+    /* set timer register base */
+    TmrReg = (__standby_tmr_reg_t *)SW_VA_TIMERC_IO_BASE;
+
+    /* backup timer registers */
+    TmrIntCtl   = TmrReg->IntCtl;
+    Tmr0Ctl     = TmrReg->Tmr0Ctl;
+    Tmr0IntVal  = TmrReg->Tmr0IntVal;
+    Tmr0CntVal  = TmrReg->Tmr0CntVal;
+    Tmr1Ctl     = TmrReg->Tmr1Ctl;
+    Tmr1IntVal  = TmrReg->Tmr1IntVal;
+    Tmr1CntVal  = TmrReg->Tmr1CntVal;
+
+    /* config timer interrrupt */
+    TmrReg->IntCtl   = 0;
+    TmrReg->IntSta   = 1;
+
+    /* config timer1 for process udelay */
+    TmrReg->Tmr1Ctl  = 0;
+    standby_delay(1000);
+    TmrReg->Tmr1Ctl  = (1<<7)|(5<<4);
+    standby_delay(1000);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     TIMER EXIT
+*
+* Description: exit timer for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 standby_tmr_exit(void)
+{
+    __s32   i;
+
+    /* restore timer0 parameters */
+    TmrReg->Tmr0IntVal  = Tmr0IntVal;
+    TmrReg->Tmr0CntVal  = Tmr0CntVal;
+    TmrReg->Tmr0Ctl     = Tmr0Ctl;
+    TmrReg->Tmr1IntVal  = Tmr1IntVal;
+    TmrReg->Tmr1CntVal  = Tmr1CntVal;
+    TmrReg->Tmr1Ctl     = Tmr1Ctl;
+    TmrReg->IntCtl      = TmrIntCtl;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_tmr_set
+*
+*Description: set timer for wakeup system.
+*
+*Arguments  : second    time value for wakeup system.
+*
+*Return     : result, 0 - successed, -1 - failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_tmr_set(__u32 second)
+{
+    /* config timer interrrupt */
+    TmrReg->IntSta     = 1;
+    TmrReg->IntCtl     = 1;
+
+    /* config timer0 for standby */
+    TmrReg->Tmr0Ctl    = 0;
+    TmrReg->Tmr0IntVal = second << 10;
+    TmrReg->Tmr0Ctl    = (1<<7) | (5<<4);
+    TmrReg->Tmr0Ctl   |= (1<<1);
+    TmrReg->Tmr0Ctl   |= (1<<0);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_tmr_enable_watchdog
+*
+*Description: enable watch-dog.
+*
+*Arguments  : none.
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_tmr_enable_watchdog(void)
+{
+    /* set watch-dog reset, timeout is 2 seconds */
+    TmrReg->DogMode = (2<<3) | (1<<1);
+    /* enable watch-dog */
+    TmrReg->DogMode |= (1<<0);
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_tmr_disable_watchdog
+*
+*Description: disable watch-dog.
+*
+*Arguments  : none.
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_tmr_disable_watchdog(void)
+{
+    /* disable watch-dog reset */
+    TmrReg->DogMode &= ~(1<<1);
+    /* disable watch-dog */
+    TmrReg->DogMode &= ~(1<<0);
+}
+
+
+/*
+**********************************************************************************************************************
+*                                               standby_tmr_query
+*
+* Description:
+*
+* Arguments  :
+*
+* Returns    :
+*
+* Notes      :
+*
+**********************************************************************************************************************
+*/
+__s32 standby_tmr_query(enum tmr_event_type_e type)
+{
+    __s32   result;
+
+    switch(type)
+    {
+        case TMR_EVENT_POWEROFF:
+        {
+            if(TmrReg->IntSta & 1)
+            {
+                TmrReg->IntSta = 1;
+                return 0;
+            }
+            return -1;
+        }
+
+        case TMR_EVENT_ALARM:
+        default:
+            return -1;
+    }
+
+    return -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_tmr_mdlay
+*
+*Description: delay ms
+*
+*Arguments  : ms    time for delay;
+*
+*Return     : none
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_tmr_mdlay(int ms)
+{
+    int     i;
+
+    if(ms < 30){
+        ms = 30;
+    }
+
+    TmrReg->Tmr1IntVal = ms;
+    TmrReg->Tmr1Ctl   |= (1<<1);
+    TmrReg->Tmr1Ctl   |= (1<<0);
+    standby_delay(3000);
+    while(TmrReg->Tmr1CntVal);
+
+    return;
+}
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_tmr.h b/arch/arm/plat-sunxi/pm/standby/standby_tmr.h
new file mode 100644
index 0000000..1fa0a0c
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_tmr.h
@@ -0,0 +1,109 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_tmr.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_TMR_H__
+#define __STANDBY_TMR_H__
+
+#include "standby_cfg.h"
+
+//define timer controller registers
+typedef struct __STANDBY_TMR_REG
+{
+    // offset:0x00
+    volatile __u32   IntCtl;
+    volatile __u32   IntSta;
+    volatile __u32   reserved0[2];
+    // offset:0x10
+    volatile __u32   Tmr0Ctl;
+    volatile __u32   Tmr0IntVal;
+    volatile __u32   Tmr0CntVal;
+    volatile __u32   reserved1;
+    // offset:0x20
+    volatile __u32   Tmr1Ctl;
+    volatile __u32   Tmr1IntVal;
+    volatile __u32   Tmr1CntVal;
+    volatile __u32   reserved2;
+    // offset:0x30
+    volatile __u32   Tmr2Ctl;
+    volatile __u32   Tmr2IntVal;
+    volatile __u32   Tmr2CntVal;
+    volatile __u32   reserved3;
+    // offset:0x40
+    volatile __u32   Tmr3Ctl;
+    volatile __u32   Tmr3IntVal;
+    volatile __u32   reserved4[2];
+    // offset:0x50
+    volatile __u32   Tmr4Ctl;
+    volatile __u32   Tmr4IntVal;
+    volatile __u32   Tmr4CntVal;
+    volatile __u32   reserved5;
+    // offset:0x60
+    volatile __u32   Tmr5Ctl;
+    volatile __u32   Tmr5IntVal;
+    volatile __u32   Tmr5CntVal;
+    volatile __u32   reserved6[5];
+    // offset:0x80
+    volatile __u32   AvsCtl;
+    volatile __u32   Avs0Cnt;
+    volatile __u32   Avs1Cnt;
+    volatile __u32   AvsDiv;
+    // offset:0x90
+    volatile __u32   DogCtl;
+    volatile __u32   DogMode;
+    volatile __u32   reserved7[2];
+    // offset:0xa0
+    volatile __u32   Cnt64Ctl;
+    volatile __u32   Cnt64Lo;
+    volatile __u32   Cnt64Hi;
+    volatile __u32   reserved8[21];
+    // offset:0x100
+    volatile __u32   LoscCtl;
+    volatile __u32   RtcYMD;
+    volatile __u32   RtcHMS;
+    volatile __u32   RtcDHMS;
+    // offset:0x110
+    volatile __u32   AlarmWHMS;
+    volatile __u32   AlarmEn;
+    volatile __u32   AlarmIrqEn;
+    volatile __u32   AlarmIrqSta;
+    // offset:0x120
+    volatile __u32   TmrGpReg[4];
+
+} __standby_tmr_reg_t;
+
+
+enum tmr_event_type_e{
+    TMR_EVENT_POWEROFF,
+    TMR_EVENT_ALARM,
+};
+
+
+__s32 standby_tmr_init(void);
+__s32 standby_tmr_exit(void);
+__s32 standby_tmr_query(enum tmr_event_type_e type);
+void standby_tmr_mdlay(int ms);
+void standby_tmr_enable_watchdog(void);
+void standby_tmr_disable_watchdog(void);
+
+#endif  //__STANDBY_TMR_H__
+
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_twi.c b/arch/arm/plat-sunxi/pm/standby/standby_twi.c
new file mode 100644
index 0000000..6fb1040
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_twi.c
@@ -0,0 +1,288 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_twi.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+#define TWI_CHECK_TIMEOUT       (0x2ff)
+
+static __twic_reg_t*   TWI_REG_BASE[3] = {
+    (__twic_reg_t*)SW_VA_TWI0_IO_BASE,
+    (__twic_reg_t*)SW_VA_TWI1_IO_BASE,
+    (__twic_reg_t*)SW_VA_TWI2_IO_BASE
+};
+
+static __u32 TwiClkRegBak = 0;
+static __u32 TwiCtlRegBak = 0;
+static __twic_reg_t *twi_reg  = 0;
+
+
+
+/*
+*********************************************************************************************************
+*                                   standby_twi_init
+*
+*Description: init twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+__s32 standby_twi_init(int group)
+{
+    twi_reg  = TWI_REG_BASE[group];
+    TwiClkRegBak = twi_reg->reg_clkr;
+    TwiCtlRegBak = 0x80&twi_reg->reg_ctl;/* backup INT_EN;no need for BUS_EN(0xc0)  */
+    twi_reg->reg_clkr = (2<<3)|3;
+    twi_reg->reg_reset |= 0x1;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   standby_twi_exit
+*
+*Description: exit twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+__s32 standby_twi_exit(void)
+{
+    /* softreset twi module  */
+    twi_reg->reg_reset |= 0x1;
+    /* delay */
+    standby_mdelay(10);
+
+    /* restore clock division */
+    twi_reg->reg_clkr = TwiClkRegBak;
+    /* restore INT_EN */
+    twi_reg->reg_ctl |= TwiCtlRegBak;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   _standby_twi_stop
+*
+*Description: stop current twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+static int _standby_twi_stop(void)
+{
+    unsigned int   nop_read;
+    unsigned int   timeout = TWI_CHECK_TIMEOUT;
+
+    twi_reg->reg_ctl = (twi_reg->reg_ctl & 0xc0) | 0x10;/* set stop+clear int flag */
+
+    nop_read = twi_reg->reg_ctl;/* apbstop bit, */
+    nop_read = nop_read;
+    // 1. stop bit is zero.
+    while((twi_reg->reg_ctl & 0x10)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+    // 2. twi fsm is idle(0xf8).
+    timeout = TWI_CHECK_TIMEOUT;
+    while((0xf8 != twi_reg->reg_status)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+    // 3. twi scl & sda must high level.
+    timeout = TWI_CHECK_TIMEOUT;
+    while((0x3a != twi_reg->reg_lctl)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   twi_byte_rw
+*
+*Description: twi byte read and write.
+*
+*Arguments  : op        operation read or write;
+*             saddr     slave address;
+*             baddr     byte address;
+*             data      pointer to the data to be read or write;
+*
+*Return     : result;
+*               = EPDK_OK,      byte read or write successed;
+*               = EPDK_FAIL,    btye read or write failed!
+*********************************************************************************************************
+*/
+__s32 twi_byte_rw(enum twi_op_type_e op, __u8 saddr, __u8 baddr, __u8 *data)
+{
+    unsigned char state_tmp;
+    unsigned int   timeout;
+    int   ret = -1;
+
+    twi_reg->reg_efr = 0;/* 0 */
+
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0xf8)
+    {
+        goto stop_out;
+    }
+
+    /* control registser bitmap
+         7      6       5     4       3       2    1    0
+      INT_EN  BUS_EN  START  STOP  INT_FLAG  ACK  NOT  NOT
+    */
+
+    //1.Send Start
+    twi_reg->reg_ctl |= 0x20;
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x08)
+    {
+        goto stop_out;
+    }
+
+    //2.Send Slave Address
+    twi_reg->reg_data = (saddr<<1) | 0; /* slave address + write */
+    twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x18)
+    {
+        goto stop_out;
+    }
+
+    //3.Send Byte Address
+    twi_reg->reg_data = baddr;
+    twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x28)
+    {
+        goto stop_out;
+    }
+
+    if(op == TWI_OP_WR)
+    {
+        //4.Send Data to be write
+        twi_reg->reg_data = *data;
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x28)
+        {
+            goto stop_out;
+        }
+    }
+    else
+    {
+        //4. Send restart for read
+        twi_reg->reg_ctl = (twi_reg->reg_ctl & 0xc0) | 0x20;/* set start+clear int flag */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x10)
+        {
+            goto stop_out;
+        }
+
+        //5.Send Slave Address
+        twi_reg->reg_data = (saddr<<1) | 1;/* slave address+ read */
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag then 0x40 come in */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x40)
+        {
+            goto stop_out;
+        }
+
+        //6.Get data
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag then data come in */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        *data = twi_reg->reg_data;
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x58)
+        {
+          goto stop_out;
+        }
+    }
+
+    ret = 0;
+
+stop_out:
+    //WRITE: step 5; READ: step 7
+    //Send Stop
+    _standby_twi_stop();
+
+    return ret;
+}
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_twi.h b/arch/arm/plat-sunxi/pm/standby/standby_twi.h
new file mode 100644
index 0000000..61b354e
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_twi.h
@@ -0,0 +1,58 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_twi.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_TWI_H__
+#define __STANDBY_TWI_H__
+
+#include "standby_cfg.h"
+
+
+typedef struct tag_twic_reg
+{
+    volatile unsigned int reg_saddr;
+    volatile unsigned int reg_xsaddr;
+    volatile unsigned int reg_data;
+    volatile unsigned int reg_ctl;
+    volatile unsigned int reg_status;
+    volatile unsigned int reg_clkr;
+    volatile unsigned int reg_reset;
+    volatile unsigned int reg_efr;
+    volatile unsigned int reg_lctl;
+
+}__twic_reg_t;
+
+
+
+enum twi_op_type_e{
+    TWI_OP_RD,
+    TWI_OP_WR,
+};
+
+
+extern __s32 standby_twi_init(int group);
+extern __s32 standby_twi_exit(void);
+extern __s32 twi_byte_rw(enum twi_op_type_e op, __u8 saddr, __u8 baddr, __u8 *data);
+
+
+
+#endif  /* __STANDBY_TWI_H__ */
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_usb.c b/arch/arm/plat-sunxi/pm/standby/standby_usb.c
new file mode 100644
index 0000000..72b2b31
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_usb.c
@@ -0,0 +1,98 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_usb.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * chech usb to wake up system from standby
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "standby_i.h"
+
+/*
+*********************************************************************************************************
+*                                     standby_usb_init
+*
+* Description: init usb for standby.
+*
+* Arguments  : none;
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+__s32 standby_usb_init(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_usb_exit
+*
+* Description: exit usb for standby.
+*
+* Arguments  : none;
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+__s32 standby_usb_exit(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_is_usb_status_change
+*
+*Description: check if usb status is change.
+*
+*Arguments  : port  usb port number;
+*
+*Return     : result, 0 status not change, !0 status changed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_is_usb_status_change(__u32 port)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_query_usb_event
+*
+* Description: query usb event for wakeup system from standby.
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*               EPDK_TRUE,  some usb event happenned;
+*               EPDK_FALSE, none usb event;
+*********************************************************************************************************
+*/
+__s32 standby_query_usb_event(void)
+{
+    return -1;
+}
diff --git a/arch/arm/plat-sunxi/pm/standby/standby_usb.h b/arch/arm/plat-sunxi/pm/standby/standby_usb.h
new file mode 100644
index 0000000..8350ee4
--- /dev/null
+++ b/arch/arm/plat-sunxi/pm/standby/standby_usb.h
@@ -0,0 +1,34 @@
+/*
+ * arch/arm/plat-sunxi/pm/standby/standby_usb.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STANDBY_USB_H__
+#define __STANDBY_USB_H__
+
+#include "standby_cfg.h"
+
+
+extern __s32 standby_usb_init(void);
+extern __s32 standby_usb_exit(void);
+extern __s32 standby_query_usb_event(void);
+
+#endif  /* __STANDBY_USB_H__ */
diff --git a/arch/arm/plat-sunxi/script.c b/arch/arm/plat-sunxi/script.c
new file mode 100644
index 0000000..979ecd7
--- /dev/null
+++ b/arch/arm/plat-sunxi/script.c
@@ -0,0 +1,61 @@
+/*
+ * arch/arm/plat-sunxi/script.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define pr_fmt(fmt)	"sunxi: script: " fmt
+
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#include <plat/script.h>
+
+const struct sunxi_script *sunxi_script_base = NULL;
+EXPORT_SYMBOL(sunxi_script_base);
+
+void sunxi_script_init(const struct sunxi_script *base)
+{
+	sunxi_script_base = base;
+	pr_debug("base: 0x%p\n", base);
+	pr_debug("version: %u.%u.%u count: %u\n",
+		base->version[0], base->version[1], base->version[2],
+		base->count);
+}
+EXPORT_SYMBOL(sunxi_script_init);
+
+const struct sunxi_property *sunxi_find_property_fmt(
+		const struct sunxi_section *sp,
+		const char *fmt, ...)
+{
+	const struct sunxi_property *prop;
+	char name[sizeof(prop->name)];
+	va_list args;
+
+	va_start(args, fmt);
+	vsprintf(name, fmt, args);
+	va_end(args);
+
+	prop = sunxi_find_property(sp, name);
+	return prop;
+}
+EXPORT_SYMBOL_GPL(sunxi_find_property_fmt);
diff --git a/arch/arm/plat-sunxi/soc-detect.c b/arch/arm/plat-sunxi/soc-detect.c
new file mode 100644
index 0000000..631468d
--- /dev/null
+++ b/arch/arm/plat-sunxi/soc-detect.c
@@ -0,0 +1,269 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) "sunxi: " fmt
+
+#include <linux/module.h>
+#include <linux/io.h>
+
+#include <plat/platform.h>
+#include <plat/system.h>
+
+#define SC_CHIP_ID_REG	(SW_VA_SRAM_IO_BASE + 0x24)
+
+#define SC_CHIP_ID_EN_MASK	0x1
+#define SC_CHIP_ID_EN_OFF	15
+#define SC_CHIP_ID_EN	(SC_CHIP_ID_EN_MASK<<SC_CHIP_ID_EN_OFF)
+
+#define SC_CHIP_ID_MASK	0xffff
+#define SC_CHIP_ID_OFF	16
+#define SC_CHIP_ID		(SC_CHIP_ID_MASK<<SC_CHIP_ID_OFF)
+
+/*
+ * BROM
+ */
+struct brom_header {
+	u32 jump_instruction;	/* one intruction jumping to real code */
+	char magic[8];		/* ="eGON.BRM",  not C-style string. */
+	u32 length;		/* generated by PC */
+	char Boot_vsn[4];	/* Boot version */
+	char eGON_vsn[4];	/* eGON version */
+	char platform[8];	/* platform information */
+};
+
+static inline const struct brom_header *_sunxi_brom(void)
+{
+	const struct brom_header *brom = (void*)SW_VA_BROM_BASE + 0x4000;
+	if (strncmp(brom->magic, "eGON.BRM", 8) == 0)
+		return brom;
+	else
+		return NULL;
+}
+
+int sunxi_pr_brom(void)
+{
+	const struct brom_header *brom = _sunxi_brom();
+	if (brom) {
+		pr_info("BROM Ver: %.4s %.4s %.8s\n",
+			brom->Boot_vsn,
+			brom->eGON_vsn,
+			brom->platform);
+		return 1;
+	}
+	pr_err("BROM not found\n");
+	return 0;
+}
+
+u32 sunxi_brom_chip_id(void)
+{
+	const struct brom_header *brom = _sunxi_brom();
+	if (brom) {
+		char *endptr;
+		u32 chip_id = simple_strtoul(brom->platform, &endptr, 10);
+		if (*endptr == '\0')
+			return chip_id;
+
+		pr_err("BROM: failed to parse chip-id: \"%s\"\n",
+		       brom->platform);
+	}
+	return SUNXI_UNKNOWN_MACH;
+}
+EXPORT_SYMBOL(sunxi_brom_chip_id);
+
+/*
+ * SC
+ */
+u32 sunxi_sc_chip_id(void)
+{
+	u32 chip_id, reg_val;
+
+	/* enable chip_id reading */
+	reg_val = readl(SC_CHIP_ID_REG);
+	writel(reg_val | SC_CHIP_ID_EN, SC_CHIP_ID_REG);
+
+	reg_val = readl(SC_CHIP_ID_REG);
+	chip_id = ((reg_val&SC_CHIP_ID)>>SC_CHIP_ID_OFF) & SC_CHIP_ID_MASK;
+
+	switch (chip_id) {
+	case 0x1623:
+		return SUNXI_MACH_SUN4I;
+	case 0x1625:
+		return SUNXI_MACH_SUN5I;
+	case 0x1633:
+		return SUNXI_MACH_SUN6I;
+	case 0x1651:
+		return SUNXI_MACH_SUN7I;
+	default:
+		pr_err("SC: failed to identify chip-id 0x%04x (*0x%08x == 0x%08x)\n",
+		       chip_id, SC_CHIP_ID_REG, reg_val);
+		return SUNXI_UNKNOWN_MACH;
+	}
+}
+EXPORT_SYMBOL(sunxi_sc_chip_id);
+
+/*
+ */
+u32 sunxi_chip_id(void)
+{
+	static u32 chip_id;
+
+	if (unlikely(chip_id == 0))
+		chip_id = sunxi_sc_chip_id();
+
+	return chip_id;
+}
+EXPORT_SYMBOL(sunxi_chip_id);
+
+int sunxi_pr_chip_id(void)
+{
+	u32 chip_id = sunxi_chip_id();
+	const char *soc_family, *name;
+	int rev;
+
+	if (sunxi_is_sun4i())
+		soc_family = "sun4i";
+	else if (sunxi_is_sun5i())
+		soc_family = "sun5i";
+	else if (sunxi_is_sun6i())
+		soc_family = "sun6i";
+	else if (sunxi_is_sun7i())
+		soc_family = "sun7i";
+	else
+		soc_family = "sunNi?";
+
+	if (sunxi_is_a10())
+		name = "A10";
+	else if (sunxi_is_a13())
+		name = "A13";
+	else if (sunxi_is_a12())
+		name = "A12";
+	else if (sunxi_is_a10s())
+		name = "A10s";
+	else if (sunxi_is_a31())
+		name = "A31";
+	else if (sunxi_is_a20())
+		name = "A20";
+	else
+		name = NULL;
+
+	rev = sunxi_soc_rev();
+	if (rev)
+		pr_info("Allwinner %s revision %c (AW%u/%s) detected.\n",
+			name?name:"A??", 'A' + rev - 1, chip_id, soc_family);
+	else
+		pr_info("Allwinner %s (AW%u/%s) detected.\n",
+			name?name:"A??", chip_id, soc_family);
+
+	return name?1:0;
+}
+
+static inline void reg_dump(const char *name, u32 reg, unsigned len)
+{
+	unsigned i, j;
+
+	for (i=0; i<len; ) {
+		pr_info("soc-detect: %s (0x%08x):", name, reg);
+
+		for (j=0; i<len && j<4; i++, j++, reg += 0x04) {
+			u32 val = readl(reg);
+			printk(" %08x", val);
+		}
+
+		printk("\n");
+	}
+}
+
+enum sw_ic_ver sw_get_ic_ver(void)
+{
+	static enum sw_ic_ver ver;
+
+	if (likely(ver))
+		return ver;
+
+	if (sunxi_is_sun4i()) {
+		u32 val = readl(SW_VA_TIMERC_IO_BASE + 0x13c);
+		val = (val >> 6) & 0x3;
+
+		if (val == 0)
+			ver = SUNXI_VER_A10A;
+		else if (val == 3)
+			ver = SUNXI_VER_A10B;
+		else
+			ver = SUNXI_VER_A10C;
+	} else if (sunxi_is_sun5i()) {
+		u32 val = readl(SW_VA_SID_IO_BASE + 0x08);
+		val = (val >> 12) & 0xf;
+		switch (val) {
+		case 0:	ver = SUNXI_VER_A12; break;
+		case 3: ver = SUNXI_VER_A13; break;
+		case 7: ver = SUNXI_VER_A10S; break;
+		default:
+			goto unknown_chip;
+		}
+
+		val = readl(SW_VA_SID_IO_BASE+0x00);
+		val = (val >> 8) & 0xffffff;
+
+		if (val == 0 || val == 0x162541)
+			ver += SUNXI_REV_A;
+		else if (val == 0x162542)
+			ver += SUNXI_REV_B;
+		else {
+			const char *name;
+			if (ver == SUNXI_VER_A13)
+				name = "A13";
+			else if (ver == SUNXI_VER_A12)
+				name = "A12";
+			else
+				name = "A10S";
+
+			pr_err("unrecongnized %s revision (%x)\n",
+			       name, val);
+
+			reg_dump("SID", SW_VA_SID_IO_BASE, 4);
+		}
+	} else if (sunxi_is_sun6i())
+		ver = SUNXI_VER_A31;
+	else if (sunxi_is_sun7i())
+		ver = SUNXI_VER_A20;
+
+	goto done;
+
+unknown_chip:
+	pr_err("unrecognized IC (chip-id=%u)\n", sunxi_chip_id());
+	ver = SUNXI_VER_UNKNOWN;
+
+	if (sunxi_is_sun5i())
+		reg_dump("SSE", SW_VA_SSE_IO_BASE, 1);
+	reg_dump("SID", SW_VA_SID_IO_BASE, 4);
+done:
+	return ver;
+}
+EXPORT_SYMBOL(sw_get_ic_ver);
+
+int sw_get_chip_id(struct sw_chip_id *chip_id)
+{
+	chip_id->sid_rkey0 = readl(SW_VA_SID_IO_BASE);
+	chip_id->sid_rkey1 = readl(SW_VA_SID_IO_BASE+0x04);
+	chip_id->sid_rkey2 = readl(SW_VA_SID_IO_BASE+0x08);
+	chip_id->sid_rkey3 = readl(SW_VA_SID_IO_BASE+0x0C);
+
+	return 0;
+}
+EXPORT_SYMBOL(sw_get_chip_id);
diff --git a/arch/arm/plat-sunxi/sys_config.c b/arch/arm/plat-sunxi/sys_config.c
new file mode 100644
index 0000000..76181e7
--- /dev/null
+++ b/arch/arm/plat-sunxi/sys_config.c
@@ -0,0 +1,1230 @@
+/*
+ * arch/arm/mach-sun4i/sys_config.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <mach/memory.h>
+#include <mach/platform.h>
+#include <plat/script.h>
+#include <plat/sys_config.h>
+
+/*
+ * Script Operations
+ */
+static inline int __script_prop_fetch(const char *name_s, const char *name_p,
+				      enum sunxi_property_type *type,
+				      void *buf, size_t buf_size)
+{
+	const struct sunxi_property *prop;
+
+	/* check params */
+	if ((name_s == NULL) || (name_p == NULL))
+		return SCRIPT_PARSER_KEYNAME_NULL;
+
+	if (buf == NULL)
+		return SCRIPT_PARSER_DATA_VALUE_NULL;
+
+	prop = sunxi_find_property2(name_s, name_p);
+	if (prop) {
+		enum sunxi_property_type t = sunxi_property_type(prop);
+		size_t l = sunxi_property_size(prop);
+		const void *value = sunxi_property_value(prop);
+
+		switch (t) {
+		case SUNXI_PROP_TYPE_U32:
+			BUG_ON(l != sizeof(u32));
+			break;
+		case SUNXI_PROP_TYPE_STRING:
+		case SUNXI_PROP_TYPE_U32_ARRAY:
+			if (buf_size < l)
+				l = buf_size; /* truncate */
+			break;
+		case SUNXI_PROP_TYPE_GPIO:
+			BUG_ON(l != sizeof(struct sunxi_property_gpio_value));
+
+			if (unlikely(sizeof(user_gpio_set_t) > buf_size))
+				return SCRIPT_PARSER_BUFFER_NOT_ENOUGH;
+
+			strncpy(buf, name_p, 32);
+			buf = (char*)buf + 32;
+			break;
+		case SUNXI_PROP_TYPE_NULL:
+			l = 0;
+			break;
+		default:
+			l = 0;
+			t = SUNXI_PROP_TYPE_INVALID;
+		}
+
+		if (type)
+			*type = t;
+		if (l > 0)
+			memcpy(buf, value, l);
+
+		return SCRIPT_PARSER_OK;
+	}
+
+	return SCRIPT_PARSER_KEY_NOT_FIND;
+}
+
+int script_parser_fetch(char *main_name, char *sub_name, int value[], int count)
+{
+	BUG_ON(count < 1);
+	return __script_prop_fetch(main_name, sub_name, NULL, value, count<<2);
+}
+EXPORT_SYMBOL(script_parser_fetch);
+
+int script_parser_fetch_ex(char *main_name, char *sub_name, int value[],
+			   script_parser_value_type_t *type, int count)
+{
+	enum sunxi_property_type *value_type = (enum sunxi_property_type*)type;
+	BUG_ON(count < 1);
+	return __script_prop_fetch(main_name, sub_name, value_type, value, count<<2);
+}
+EXPORT_SYMBOL(script_parser_fetch_ex);
+
+int script_parser_subkey_count(char *main_name)
+{
+	const struct sunxi_section *sp;
+
+	if (main_name == NULL)
+		return SCRIPT_PARSER_KEYNAME_NULL;
+
+	sp = sunxi_find_section(main_name);
+	if (sp)
+		return sp->count;
+
+	return -1;
+}
+
+int script_parser_mainkey_count(void)
+{
+	return sunxi_script_base->count;
+}
+
+int script_parser_mainkey_get_gpio_count(char *main_name)
+{
+	const struct sunxi_section *sp;
+	const struct sunxi_property *pp;
+	int    i, gpio_count = 0;
+
+	if (main_name == NULL)
+		return SCRIPT_PARSER_KEYNAME_NULL;
+
+	sp = sunxi_find_section(main_name);
+	if (sp) {
+		sunxi_for_each_property(sp, pp, i) {
+			if (SUNXI_PROP_TYPE_GPIO == sunxi_property_type(pp))
+				gpio_count++;
+		}
+	}
+
+	return gpio_count;
+}
+
+int script_parser_mainkey_get_gpio_cfg(char *main_name, void *gpio_cfg, int gpio_count)
+{
+	const struct sunxi_section *sp;
+	const struct sunxi_property *pp;
+	user_gpio_set_t *user_gpio_cfg = gpio_cfg;
+	int i, j;
+
+	if (main_name == NULL)
+		return SCRIPT_PARSER_KEYNAME_NULL;
+
+	memset(user_gpio_cfg, 0, sizeof(user_gpio_set_t) * gpio_count);
+
+	if ((sp = sunxi_find_section(main_name))) {
+		j = 0;
+		sunxi_for_each_property(sp, pp, i) {
+			if (SUNXI_PROP_TYPE_GPIO == sunxi_property_type(pp)) {
+				const void *data = sunxi_property_value(pp);
+				strncpy(user_gpio_cfg[j].gpio_name, pp->name,
+					sizeof(pp->name));
+				memcpy(&user_gpio_cfg[j].port, data,
+				       sizeof(user_gpio_set_t) -
+				       sizeof(pp->name));
+
+				j++;
+				if (j >= gpio_count)
+					break;
+			}
+		}
+		return SCRIPT_PARSER_OK;
+	}
+
+	return SCRIPT_PARSER_KEY_NOT_FIND;
+}
+
+/*
+ *
+ *                           GPIO(PIN) Operations
+ *
+ */
+#define CSP_OSAL_PHY_2_VIRT(phys, size) SW_VA_PORTC_IO_BASE
+
+#define    CSP_PIN_PHY_ADDR_BASE    SW_PA_PORTC_IO_BASE
+#define    CSP_PIN_PHY_ADDR_SIZE    0x1000
+
+u32     gpio_g_pioMemBase;
+#define PIOC_REGS_BASE gpio_g_pioMemBase
+
+extern char sys_cofig_data[];
+extern char sys_cofig_data_end[];
+#define __REG(x)                        (*(volatile unsigned int *)(x))
+
+#define PIO_REG_CFG(n, i)               ((volatile unsigned int *)(PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x00))
+#define PIO_REG_DLEVEL(n, i)            ((volatile unsigned int *)(PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x14))
+#define PIO_REG_PULL(n, i)              ((volatile unsigned int *)(PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x1C))
+#define PIO_REG_DATA(n)                   ((volatile unsigned int *)(PIOC_REGS_BASE + ((n)-1)*0x24 + 0x10))
+
+#define PIO_REG_CFG_VALUE(n, i)          __REG(PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x00)
+#define PIO_REG_DLEVEL_VALUE(n, i)       __REG(PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x14)
+#define PIO_REG_PULL_VALUE(n, i)         __REG(PIOC_REGS_BASE + ((n)-1)*0x24 + ((i)<<2) + 0x1C)
+#define PIO_REG_DATA_VALUE(n)            __REG(PIOC_REGS_BASE + ((n)-1)*0x24 + 0x10)
+
+typedef struct {
+	int mul_sel;
+	int pull;
+	int drv_level;
+	int data;
+} gpio_status_set_t;
+
+typedef struct {
+	char    gpio_name[32];
+	int port;
+	int port_num;
+	gpio_status_set_t user_gpio_status;
+	gpio_status_set_t hardware_gpio_status;
+} system_gpio_set_t;
+
+/*
+ * CSP_PIN_init
+ *  Description:
+ *       init
+ *  Parameters:
+ *  Return value:
+ *        EGPIO_SUCCESS/EGPIO_FAIL
+ */
+int gpio_init(void)
+{
+	printk(KERN_INFO "Init eGon pin module V2.0\n");
+	gpio_g_pioMemBase = (u32)CSP_OSAL_PHY_2_VIRT(CSP_PIN_PHY_ADDR_BASE , CSP_PIN_PHY_ADDR_SIZE);
+	sunxi_script_init((void *)__va(SYS_CONFIG_MEMBASE));
+	return 1;
+}
+arch_initcall(gpio_init);
+
+/*
+ *
+ *
+ *             CSP_PIN_exit
+ *
+ *  Description:
+ *       exit
+ *
+ *  Parameters:
+ *
+ *  Return value:
+ *        EGPIO_SUCCESS/EGPIO_FAIL
+ */
+__s32 gpio_exit(void)
+{
+	return 0;
+}
+
+/*
+ *
+ *
+ *                                             CSP_GPIO_Request
+ *
+ *    
+ *
+ *    gpio_list      GPIOGPIO
+ *
+ *               group_count_max  GPIOGPIO
+ *
+ *      
+ *
+ *        
+ *
+ *
+ */
+u32 sunxi_gpio_request_array(user_gpio_set_t *gpio_list, __u32 group_count_max)
+{
+	char               *user_gpio_buf;	/* char */
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;	/* user_gpio_set */
+	user_gpio_set_t  *tmp_user_gpio_data;
+	__u32                real_gpio_count = 0, first_port;	/* GPIO */
+	__u32               tmp_group_func_data = 0;
+	__u32               tmp_group_pull_data = 0;
+	__u32               tmp_group_dlevel_data = 0;
+	__u32               tmp_group_data_data = 0;
+	__u32               func_change = 0, pull_change = 0;
+	__u32               dlevel_change = 0, data_change = 0;
+	volatile __u32  *tmp_group_func_addr = NULL, *tmp_group_pull_addr = NULL;
+	volatile __u32  *tmp_group_dlevel_addr = NULL, *tmp_group_data_addr = NULL;
+	__u32  port, port_num, port_num_func, port_num_pull;
+	__u32  pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff;
+	__u32  pre_port_num_pull = 0x7fffffff;
+	__s32  i, tmp_val;
+
+	if ((!gpio_list) || (!group_count_max))
+		return (u32)0;
+
+	for (i = 0; i < group_count_max; i++) {
+		tmp_user_gpio_data = gpio_list + i;	/* gpio_setGPIO */
+		if (!tmp_user_gpio_data->port)
+			continue;
+
+		real_gpio_count++;
+	}
+
+	/* printk("to malloc space for pin\n"); */
+	/* 16GPIO */
+	user_gpio_buf = kmalloc(16 + sizeof(system_gpio_set_t) * real_gpio_count, GFP_ATOMIC);
+	if (!user_gpio_buf)
+		return (u32)0;
+
+	memset(user_gpio_buf, 0, 16 + sizeof(system_gpio_set_t) * real_gpio_count);	/*  */
+	*(int *)user_gpio_buf = real_gpio_count;	/* GPIO */
+	user_gpio_set = (system_gpio_set_t *)(user_gpio_buf + 16);	/*  */
+	/* GPIO */
+	for (first_port = 0; first_port < group_count_max; first_port++) {
+		tmp_user_gpio_data = gpio_list + first_port;
+		port     = tmp_user_gpio_data->port;		/*  */
+		port_num = tmp_user_gpio_data->port_num;	/* GPIO */
+		if (!port)
+			continue;
+
+		port_num_func = (port_num >> 3);
+		port_num_pull = (port_num >> 4);
+
+		tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);	/*  */
+		tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);	/* pull */
+		tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);	/* level */
+		tmp_group_data_addr    = PIO_REG_DATA(port);			/* data */
+
+		tmp_group_func_data    = *tmp_group_func_addr;
+		tmp_group_pull_data    = *tmp_group_pull_addr;
+		tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+		tmp_group_data_data    = *tmp_group_data_addr;
+		break;
+	}
+	if (first_port >= group_count_max)
+		return 0;
+
+	/*  */
+	for (i = first_port; i < group_count_max; i++) {
+		tmp_sys_gpio_data  = user_gpio_set + i;		/* tmp_sys_gpio_dataGPIO */
+		tmp_user_gpio_data = gpio_list + i;		/* gpio_setGPIO */
+		port     = tmp_user_gpio_data->port;		/*  */
+		port_num = tmp_user_gpio_data->port_num;	/* GPIO */
+		if (!port)
+			continue;
+
+		/*  */
+		strcpy(tmp_sys_gpio_data->gpio_name, tmp_user_gpio_data->gpio_name);
+		tmp_sys_gpio_data->port                       = port;
+		tmp_sys_gpio_data->port_num                   = port_num;
+		tmp_sys_gpio_data->user_gpio_status.mul_sel   = tmp_user_gpio_data->mul_sel;
+		tmp_sys_gpio_data->user_gpio_status.pull      = tmp_user_gpio_data->pull;
+		tmp_sys_gpio_data->user_gpio_status.drv_level = tmp_user_gpio_data->drv_level;
+		tmp_sys_gpio_data->user_gpio_status.data      = tmp_user_gpio_data->data;
+
+		port_num_func = (port_num >> 3);
+		port_num_pull = (port_num >> 4);
+
+		/* pull */
+		if ((port_num_pull != pre_port_num_pull) || (port != pre_port)) {
+			if (func_change) {
+				*tmp_group_func_addr   = tmp_group_func_data;		/*  */
+				func_change = 0;
+			}
+			if (pull_change) {
+				pull_change = 0;
+			*tmp_group_pull_addr   = tmp_group_pull_data;			/* pull */
+			}
+			if (dlevel_change) {
+				dlevel_change = 0;
+				*tmp_group_dlevel_addr = tmp_group_dlevel_data;		/* driver level */
+			}
+			if (data_change) {
+				data_change = 0;
+				*tmp_group_data_addr   = tmp_group_data_data;		/*  */
+			}
+
+			tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);	/*  */
+			tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);	/* pull */
+			tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);	/* level */
+			tmp_group_data_addr    = PIO_REG_DATA(port);			/* data */
+
+			tmp_group_func_data    = *tmp_group_func_addr;
+			tmp_group_pull_data    = *tmp_group_pull_addr;
+			tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+			tmp_group_data_data    = *tmp_group_data_addr;
+		} else if (pre_port_num_func != port_num_func) {			/*  */
+			*tmp_group_func_addr   = tmp_group_func_data;			/*  */
+			tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);	/*  */
+
+			tmp_group_func_data    = *tmp_group_func_addr;
+		}
+		/*  */
+		pre_port_num_pull = port_num_pull;	/* GPIOGPIO */
+		pre_port_num_func = port_num_func;
+		pre_port          = port;
+
+		/*  */
+		if (tmp_user_gpio_data->mul_sel >= 0) {
+			tmp_val = (port_num - (port_num_func<<3)) << 2;
+			tmp_sys_gpio_data->hardware_gpio_status.mul_sel = (tmp_group_func_data >> tmp_val) & 0x07;
+			tmp_group_func_data &= ~(0x07  << tmp_val);
+			tmp_group_func_data |=  (tmp_user_gpio_data->mul_sel & 0x07) << tmp_val;
+			func_change = 1;
+		}
+		/* pullpull */
+
+		tmp_val = (port_num - (port_num_pull<<4)) << 1;
+
+		if (tmp_user_gpio_data->pull >= 0) {
+			tmp_sys_gpio_data->hardware_gpio_status.pull = (tmp_group_pull_data >> tmp_val) & 0x03;
+			if (tmp_user_gpio_data->pull >= 0) {
+				tmp_group_pull_data &= ~(0x03  << tmp_val);
+				tmp_group_pull_data |=  (tmp_user_gpio_data->pull & 0x03) << tmp_val;
+				pull_change = 1;
+			}
+		}
+		/* driver leveldriver level */
+		if (tmp_user_gpio_data->drv_level >= 0) {
+			tmp_sys_gpio_data->hardware_gpio_status.drv_level = (tmp_group_dlevel_data >> tmp_val) & 0x03;
+			if (tmp_user_gpio_data->drv_level >= 0) {
+				tmp_group_dlevel_data &= ~(0x03 << tmp_val);
+				tmp_group_dlevel_data |=  (tmp_user_gpio_data->drv_level & 0x03) << tmp_val;
+				dlevel_change = 1;
+			}
+		}
+		/* data */
+		if (tmp_user_gpio_data->mul_sel == 1) {
+			if (tmp_user_gpio_data->data >= 0) {
+				tmp_val = tmp_user_gpio_data->data;
+				tmp_val &= 1;
+				tmp_group_data_data &= ~(1 << port_num);
+				tmp_group_data_data |= tmp_val << port_num;
+				data_change = 1;
+			}
+		}
+	}
+	/* for */
+	if (tmp_group_func_addr) {	/*  */
+		/*  */
+		*tmp_group_func_addr   = tmp_group_func_data;		/*  */
+		if (pull_change)
+			*tmp_group_pull_addr   = tmp_group_pull_data;	/* pull */
+
+		if (dlevel_change)
+			*tmp_group_dlevel_addr = tmp_group_dlevel_data;	/* driver level */
+
+		if (data_change)
+			*tmp_group_data_addr   = tmp_group_data_data;	/* data */
+
+	}
+
+	return (u32)user_gpio_buf;
+}
+EXPORT_SYMBOL_GPL(sunxi_gpio_request_array);
+
+/*
+ * CSP_GPIO_Request_EX
+ * 
+ *
+ * :
+ * main_name   ()
+ * sub_name    GPIO
+ *
+ *   0 :    err
+ *          other: success
+ *
+ *     
+ */
+u32 gpio_request_ex(char *main_name, const char *sub_name)	/* GPIO */
+{
+	user_gpio_set_t    *gpio_list = NULL;
+	user_gpio_set_t     one_gpio = {"", 0};
+	__u32               gpio_handle;
+	__s32               gpio_count;
+
+	if (!sub_name) {
+		gpio_count = script_parser_mainkey_get_gpio_count(main_name);
+		if (gpio_count <= 0) {
+			printk(KERN_ERR "gpio count < =0 ,gpio_count is: %d\n", gpio_count);
+			return 0;
+		}
+		/*  */
+		gpio_list = kmalloc(sizeof(system_gpio_set_t) * gpio_count, GFP_ATOMIC);
+		if (!gpio_list) {
+			printk(KERN_ERR "malloc gpio_list error\n");
+			return 0;
+		}
+		if (!script_parser_mainkey_get_gpio_cfg(main_name, gpio_list, gpio_count)) {
+			gpio_handle = sunxi_gpio_request_array(gpio_list,
+								gpio_count);
+			kfree(gpio_list);
+		} else {
+			return 0;
+		}
+	} else {
+		if (script_parser_fetch((char *)main_name, (char *)sub_name, (int *)&one_gpio, (sizeof(user_gpio_set_t) >> 2)) < 0) {
+			return 0;
+		}
+
+		gpio_handle = sunxi_gpio_request_array(&one_gpio, 1);
+	}
+
+	return gpio_handle;
+}
+EXPORT_SYMBOL(gpio_request_ex);
+
+/*
+ * CSP_PIN_DEV_release
+ * Description:
+ *       pin
+ * Parameters:
+ *  p_handler    :    handler
+ *  if_release_to_default_status : ()
+ *  Return value:
+ *        EGPIO_SUCCESS/EGPIO_FAIL
+ */
+__s32 gpio_release(u32 p_handler, __s32 if_release_to_default_status)
+{
+	char               *tmp_buf;				/* char */
+	__u32               group_count_max, first_port;	/* GPIO */
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+	__u32               tmp_group_func_data = 0;
+	__u32               tmp_group_pull_data = 0;
+	__u32               tmp_group_dlevel_data = 0;
+	volatile __u32     *tmp_group_func_addr = NULL,   *tmp_group_pull_addr = NULL;
+	volatile __u32     *tmp_group_dlevel_addr = NULL;
+	__u32               port, port_num, port_num_pull, port_num_func;
+	__u32               pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff, pre_port_num_pull = 0x7fffffff;
+	__u32               i, tmp_val;
+
+	/*  */
+	if (!p_handler)
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	if (!group_count_max)
+		return EGPIO_FAIL;
+
+	if (if_release_to_default_status == 2) {
+		/* printk("gpio module :  release p_handler = %x\n",p_handler); */
+		kfree((char *)p_handler);
+
+		return EGPIO_SUCCESS;
+	}
+	user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+	/*  */
+	for (first_port = 0; first_port < group_count_max; first_port++) {
+		tmp_sys_gpio_data  = user_gpio_set + first_port;
+		port     = tmp_sys_gpio_data->port;		/*  */
+		port_num = tmp_sys_gpio_data->port_num;		/* GPIO */
+		if (!port)
+			continue;
+
+		port_num_func = (port_num >> 3);
+		port_num_pull = (port_num >> 4);
+
+		tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);	/*  */
+		tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);	/* pull */
+		tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);	/* level */
+
+		tmp_group_func_data    = *tmp_group_func_addr;
+		tmp_group_pull_data    = *tmp_group_pull_addr;
+		tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+		break;
+	}
+	if (first_port >= group_count_max)
+		return 0;
+
+	for (i = first_port; i < group_count_max; i++) {
+		tmp_sys_gpio_data  = user_gpio_set + i;		/* tmp_sys_gpio_dataGPIO */
+		port     = tmp_sys_gpio_data->port;		/*  */
+		port_num = tmp_sys_gpio_data->port_num;		/* GPIO */
+
+		port_num_func = (port_num >> 3);
+		port_num_pull = (port_num >> 4);
+
+		if ((port_num_pull != pre_port_num_pull) || (port != pre_port)) {		/* pull */
+			*tmp_group_func_addr   = tmp_group_func_data;			/*  */
+			*tmp_group_pull_addr   = tmp_group_pull_data;			/* pull */
+			*tmp_group_dlevel_addr = tmp_group_dlevel_data;			/* driver level */
+
+			tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);	/*  */
+			tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);	/* pull */
+			tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);	/* level */
+
+			tmp_group_func_data    = *tmp_group_func_addr;
+			tmp_group_pull_data    = *tmp_group_pull_addr;
+			tmp_group_dlevel_data  = *tmp_group_dlevel_addr;
+		} else if (pre_port_num_func != port_num_func) {			/*  */
+			*tmp_group_func_addr   = tmp_group_func_data;			/*  */
+			tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);	/*  */
+			tmp_group_func_data    = *tmp_group_func_addr;
+		}
+
+		pre_port_num_pull = port_num_pull;
+		pre_port_num_func = port_num_func;
+		pre_port          = port;
+		/*  */
+		tmp_group_func_data &= ~(0x07 << ((port_num - (port_num_func<<3)) << 2));
+		/* pull */
+		tmp_val              =  (port_num - (port_num_pull<<4)) << 1;
+		tmp_group_pull_data &= ~(0x03  << tmp_val);
+		tmp_group_pull_data |= (tmp_sys_gpio_data->hardware_gpio_status.pull & 0x03) << tmp_val;
+		/* driver */
+		tmp_val              =  (port_num - (port_num_pull<<4)) << 1;
+		tmp_group_dlevel_data &= ~(0x03  << tmp_val);
+		tmp_group_dlevel_data |= (tmp_sys_gpio_data->hardware_gpio_status.drv_level & 0x03) << tmp_val;
+	}
+	if (tmp_group_func_addr)				/*  */
+		/*  */
+		*tmp_group_func_addr   = tmp_group_func_data;	/*  */
+
+	if (tmp_group_pull_addr)
+		*tmp_group_pull_addr   = tmp_group_pull_data;
+
+	if (tmp_group_dlevel_addr)
+		*tmp_group_dlevel_addr = tmp_group_dlevel_data;
+
+	kfree((char*)p_handler);
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_release);
+
+/*
+ * CSP_PIN_Get_All_Gpio_Status
+ * Description:
+ *  GPIO
+ * Arguments  :
+ *  p_handler    :    handler
+ *  gpio_status    :    
+ *  gpio_count_max    :    
+ *  if_get_user_set_flag   :   
+ */
+__s32  gpio_get_all_pin_status(u32 p_handler,
+			    user_gpio_set_t *gpio_status, __u32 gpio_count_max,
+			    __u32 if_get_from_hardware)
+{
+	char               *tmp_buf;			    /* char */
+	__u32               group_count_max, first_port;    /* GPIO */
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+	user_gpio_set_t  *script_gpio;
+	__u32               port_num_func, port_num_pull;
+	volatile __u32     *tmp_group_func_addr = NULL, *tmp_group_pull_addr;
+	volatile __u32     *tmp_group_data_addr, *tmp_group_dlevel_addr;
+	__u32               port, port_num;
+	__u32               pre_port = 0x7fffffff, pre_port_num_func = 0x7fffffff, pre_port_num_pull = 0x7fffffff;
+	__u32               i;
+
+	if ((!p_handler) || (!gpio_status))
+		return EGPIO_FAIL;
+
+	if (gpio_count_max <= 0)
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	if (group_count_max <= 0)
+		return EGPIO_FAIL;
+
+	user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+	if (group_count_max > gpio_count_max)
+		group_count_max = gpio_count_max;
+
+	/*  */
+	/*  */
+	if (!if_get_from_hardware) {
+		for (i = 0; i < group_count_max; i++) {
+			tmp_sys_gpio_data = user_gpio_set + i;		/* tmp_sys_gpio_dataGPIO */
+			script_gpio       = gpio_status + i;		/* script_gpio */
+
+			script_gpio->port      = tmp_sys_gpio_data->port;			/* port */
+			script_gpio->port_num  = tmp_sys_gpio_data->port_num;			/* port_num */
+			script_gpio->pull      = tmp_sys_gpio_data->user_gpio_status.pull;	/* pull */
+			script_gpio->mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;	/*  */
+			script_gpio->drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level;	/*  */
+			script_gpio->data      = tmp_sys_gpio_data->user_gpio_status.data;	/* data */
+			strcpy(script_gpio->gpio_name, tmp_sys_gpio_data->gpio_name);
+		}
+	} else {
+		for (first_port = 0; first_port < group_count_max; first_port++) {
+			tmp_sys_gpio_data  = user_gpio_set + first_port;
+			port     = tmp_sys_gpio_data->port;		/*  */
+			port_num = tmp_sys_gpio_data->port_num;		/* GPIO */
+
+			if (!port)
+				continue;
+
+			port_num_func = (port_num >> 3);
+			port_num_pull = (port_num >> 4);
+			tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);		/*  */
+			tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);		/* pull */
+			tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);		/* level */
+			tmp_group_data_addr    = PIO_REG_DATA(port);				/* data */
+			break;
+		}
+		if (first_port >= group_count_max)
+			return 0;
+
+		for (i = first_port; i < group_count_max; i++) {
+			tmp_sys_gpio_data = user_gpio_set + i;					/* tmp_sys_gpio_dataGPIO */
+			script_gpio       = gpio_status + i;					/* script_gpio */
+
+			port     = tmp_sys_gpio_data->port;					/*  */
+			port_num = tmp_sys_gpio_data->port_num;					/* GPIO */
+
+			script_gpio->port = port;						/* port */
+			script_gpio->port_num  = port_num;					/* port_num */
+			strcpy(script_gpio->gpio_name, tmp_sys_gpio_data->gpio_name);
+
+			port_num_func = (port_num >> 3);
+			port_num_pull = (port_num >> 4);
+
+			if ((port_num_pull != pre_port_num_pull) || (port != pre_port)) {	/* pull */
+				tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);	/*  */
+				tmp_group_pull_addr    = PIO_REG_PULL(port, port_num_pull);	/* pull */
+				tmp_group_dlevel_addr  = PIO_REG_DLEVEL(port, port_num_pull);	/* level */
+				tmp_group_data_addr    = PIO_REG_DATA(port);			/* data */
+			} else if (pre_port_num_func != port_num_func) {				/*  */
+				tmp_group_func_addr    = PIO_REG_CFG(port, port_num_func);	/*  */
+			}
+
+			pre_port_num_pull = port_num_pull;
+			pre_port_num_func = port_num_func;
+			pre_port          = port;
+			/*  */
+			script_gpio->pull      = (*tmp_group_pull_addr   >> ((port_num - (port_num_pull<<4))<<1)) & 0x03;	/* pull */
+			script_gpio->drv_level = (*tmp_group_dlevel_addr >> ((port_num - (port_num_pull<<4))<<1)) & 0x03;	/*  */
+			script_gpio->mul_sel   = (*tmp_group_func_addr   >> ((port_num - (port_num_func<<3))<<2)) & 0x07;	/*  */
+			if (script_gpio->mul_sel <= 1)
+				script_gpio->data  = (*tmp_group_data_addr   >>   port_num) & 0x01;				/* data */
+			else
+				script_gpio->data = -1;
+		}
+	}
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_get_all_pin_status);
+
+/*
+ * CSP_GPIO_Get_One_PIN_Status
+ * Description:
+ *  GPIO
+ * Arguments  :
+ *  p_handler    :    handler
+ *  gpio_status    :    
+ *  gpio_name    :    GPIO
+ *  if_get_user_set_flag   :   
+ */
+__s32  gpio_get_one_pin_status(u32 p_handler, user_gpio_set_t *gpio_status, const char *gpio_name, __u32 if_get_from_hardware)
+{
+	char               *tmp_buf;				/* char */
+	__u32               group_count_max;			/* GPIO */
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+	__u32               port_num_func, port_num_pull;
+	__u32               port, port_num;
+	__u32               i, tmp_val1, tmp_val2;
+
+	/*  */
+	if ((!p_handler) || (!gpio_status))
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	if (group_count_max <= 0)
+		return EGPIO_FAIL;
+	else if ((group_count_max > 1) && (!gpio_name))
+		return EGPIO_FAIL;
+
+	user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+	/*  */
+	/*  */
+	for (i = 0; i < group_count_max; i++) {
+		tmp_sys_gpio_data = user_gpio_set + i;			/* tmp_sys_gpio_dataGPIO */
+		if (strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+			continue;
+
+		strcpy(gpio_status->gpio_name, tmp_sys_gpio_data->gpio_name);
+		port                   = tmp_sys_gpio_data->port;
+		port_num               = tmp_sys_gpio_data->port_num;
+		gpio_status->port      = port;							/* port */
+		gpio_status->port_num  = port_num;						/* port_num */
+
+		if (!if_get_from_hardware) {							/*  */
+			gpio_status->mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;	/*  */
+			gpio_status->pull      = tmp_sys_gpio_data->user_gpio_status.pull;	/* pull */
+			gpio_status->drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level;	/*  */
+			gpio_status->data      = tmp_sys_gpio_data->user_gpio_status.data;	/* data */
+		} else {									/*  */
+			port_num_func = (port_num >> 3);
+			port_num_pull = (port_num >> 4);
+
+			tmp_val1 = ((port_num - (port_num_func << 3)) << 2);
+			tmp_val2 = ((port_num - (port_num_pull << 4)) << 1);
+			gpio_status->mul_sel   = (PIO_REG_CFG_VALUE(port, port_num_func)>>tmp_val1) & 0x07;	/*  */
+			gpio_status->pull      = (PIO_REG_PULL_VALUE(port, port_num_pull)>>tmp_val2) & 0x03;	/* pull */
+			gpio_status->drv_level = (PIO_REG_DLEVEL_VALUE(port, port_num_pull)>>tmp_val2) & 0x03;	/* level */
+			if (gpio_status->mul_sel <= 1)
+				gpio_status->data = (PIO_REG_DATA_VALUE(port) >> port_num) & 0x01;		/* data */
+			else
+			gpio_status->data = -1;
+
+		}
+
+		break;
+	}
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_get_one_pin_status);
+
+/*
+ * CSP_PIN_Set_One_Gpio_Status
+ * Description:
+ *  GPIO
+ * Arguments  :
+ *  p_handler    :    handler
+ *  gpio_status    :    
+ *  gpio_name    :    GPIO
+ *  if_get_user_set_flag   :   
+ */
+
+__s32  gpio_set_one_pin_status(u32 p_handler, user_gpio_set_t *gpio_status,
+		    const char *gpio_name, __u32 if_set_to_current_input_status)
+{
+	char               *tmp_buf;			/* char */
+	__u32               group_count_max;		/* GPIO */
+	system_gpio_set_t  *user_gpio_set, *tmp_sys_gpio_data;
+	user_gpio_set_t     script_gpio;
+	volatile __u32     *tmp_addr;
+	__u32               port_num_func, port_num_pull;
+	__u32               port, port_num;
+	__u32               i, reg_val, tmp_val;
+
+	/*  */
+	if ((!p_handler) || (!gpio_name))
+		return EGPIO_FAIL;
+
+	if ((if_set_to_current_input_status) && (!gpio_status))
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	if (group_count_max <= 0)
+		return EGPIO_FAIL;
+
+	user_gpio_set = (system_gpio_set_t *)(tmp_buf + 16);
+	/*  */
+	/*  */
+	for (i = 0; i < group_count_max; i++) {
+		tmp_sys_gpio_data = user_gpio_set + i;		/* tmp_sys_gpio_dataGPIO */
+		if (strcmp(gpio_name, tmp_sys_gpio_data->gpio_name))
+			continue;
+
+
+		port          = tmp_sys_gpio_data->port;		/* port */
+		port_num      = tmp_sys_gpio_data->port_num;		/* port_num */
+		port_num_func = (port_num >> 3);
+		port_num_pull = (port_num >> 4);
+
+		if (if_set_to_current_input_status) {			/*  */
+			/* FUCN */
+			script_gpio.mul_sel   = gpio_status->mul_sel;
+			script_gpio.pull      = gpio_status->pull;
+			script_gpio.drv_level = gpio_status->drv_level;
+			script_gpio.data      = gpio_status->data;
+		} else {
+			script_gpio.mul_sel   = tmp_sys_gpio_data->user_gpio_status.mul_sel;
+			script_gpio.pull      = tmp_sys_gpio_data->user_gpio_status.pull;
+			script_gpio.drv_level = tmp_sys_gpio_data->user_gpio_status.drv_level;
+			script_gpio.data      = tmp_sys_gpio_data->user_gpio_status.data;
+		}
+
+		if (script_gpio.mul_sel >= 0) {
+			tmp_addr = PIO_REG_CFG(port, port_num_func);
+			reg_val = *tmp_addr;				/* FUNC */
+			tmp_val = (port_num - (port_num_func<<3))<<2;
+			reg_val &= ~(0x07 << tmp_val);
+			reg_val |=  (script_gpio.mul_sel) << tmp_val;
+			*tmp_addr = reg_val;
+		}
+		/* PULL */
+		if (script_gpio.pull >= 0) {
+			tmp_addr = PIO_REG_PULL(port, port_num_pull);
+			reg_val = *tmp_addr;				/* FUNC */
+			tmp_val = (port_num - (port_num_pull<<4))<<1;
+			reg_val &= ~(0x03 << tmp_val);
+			reg_val |=  (script_gpio.pull) << tmp_val;
+			*tmp_addr = reg_val;
+		}
+		/* DLEVEL */
+		if (script_gpio.drv_level >= 0) {
+			tmp_addr = PIO_REG_DLEVEL(port, port_num_pull);
+			reg_val = *tmp_addr;	/* FUNC */
+			tmp_val = (port_num - (port_num_pull<<4))<<1;
+			reg_val &= ~(0x03 << tmp_val);
+			reg_val |=  (script_gpio.drv_level) << tmp_val;
+			*tmp_addr = reg_val;
+		}
+		/* data */
+		if (script_gpio.mul_sel == 1) {
+			if (script_gpio.data >= 0) {
+				tmp_addr = PIO_REG_DATA(port);
+				reg_val = *tmp_addr;	/* DATA */
+				reg_val &= ~(0x01 << port_num);
+				reg_val |=  (script_gpio.data & 0x01) << port_num;
+				*tmp_addr = reg_val;
+			}
+		}
+
+		break;
+	}
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_status);
+
+/*
+ * CSP_GPIO_Set_One_PIN_IO_Status
+ * Description:
+ * GPIOIO
+ * Arguments  :
+ *  p_handler    :    handler
+ *  if_set_to_output_status    :    
+ *  gpio_name    :    GPIO
+ */
+__s32  gpio_set_one_pin_io_status(u32 p_handler, __u32 if_set_to_output_status,
+				  const char *gpio_name)
+{
+	char               *tmp_buf;			/* char */
+	__u32               group_count_max;		/* GPIO */
+	system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+	volatile __u32      *tmp_group_func_addr = NULL;
+	__u32               port, port_num, port_num_func;
+	__u32                i, reg_val;
+
+	/*  */
+	if (!p_handler)
+		return EGPIO_FAIL;
+
+	if (if_set_to_output_status > 1)
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+	if (group_count_max == 0) {
+		return EGPIO_FAIL;
+	} else if (group_count_max == 1) {
+		user_gpio_set = tmp_sys_gpio_data;
+	} else if (gpio_name) {
+		for (i = 0; i < group_count_max; i++) {
+			if (strcmp(gpio_name, tmp_sys_gpio_data->gpio_name)) {
+				tmp_sys_gpio_data++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if (!user_gpio_set)
+		return EGPIO_FAIL;
+
+	port     = user_gpio_set->port;
+	port_num = user_gpio_set->port_num;
+	port_num_func = port_num >> 3;
+
+	tmp_group_func_addr = PIO_REG_CFG(port, port_num_func);
+	reg_val = *tmp_group_func_addr;
+	reg_val &= ~(0x07 << (((port_num - (port_num_func<<3))<<2)));
+	reg_val |=   if_set_to_output_status << (((port_num - (port_num_func<<3))<<2));
+	*tmp_group_func_addr = reg_val;
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_io_status);
+
+/*
+ * CSP_GPIO_Set_One_PIN_Pull
+ * Description:
+ * GPIOIOPULL
+ * Arguments  :
+ *        p_handler    :    handler
+ *        if_set_to_output_status    :    pull
+ *        gpio_name    :    GPIO
+ */
+__s32  gpio_set_one_pin_pull(u32 p_handler, __u32 set_pull_status,
+			     const char *gpio_name)
+{
+	char               *tmp_buf;			/* char */
+	__u32               group_count_max;		/* GPIO */
+	system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+	volatile __u32      *tmp_group_pull_addr = NULL;
+	__u32               port, port_num, port_num_pull;
+	__u32                i, reg_val;
+	/*  */
+	if (!p_handler)
+		return EGPIO_FAIL;
+
+	if (set_pull_status >= 4)
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+	if (group_count_max == 0) {
+		return EGPIO_FAIL;
+	} else if (group_count_max == 1) {
+		user_gpio_set = tmp_sys_gpio_data;
+	} else if (gpio_name) {
+		for (i = 0; i < group_count_max; i++) {
+			if (strcmp(gpio_name, tmp_sys_gpio_data->gpio_name)) {
+				tmp_sys_gpio_data++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if (!user_gpio_set)
+		return EGPIO_FAIL;
+
+	port     = user_gpio_set->port;
+	port_num = user_gpio_set->port_num;
+	port_num_pull = port_num >> 4;
+
+	tmp_group_pull_addr = PIO_REG_PULL(port, port_num_pull);
+	reg_val = *tmp_group_pull_addr;
+	reg_val &= ~(0x03 << (((port_num - (port_num_pull<<4))<<1)));
+	reg_val |=  (set_pull_status << (((port_num - (port_num_pull<<4))<<1)));
+	*tmp_group_pull_addr = reg_val;
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_pull);
+
+/*
+ * CSP_GPIO_Set_One_PIN_driver_level
+ * Description:
+ * GPIOIO
+ * Arguments  :
+ *        p_handler    :    handler
+ *        if_set_to_output_status    :    
+ *        gpio_name    :    GPIO
+ */
+__s32  gpio_set_one_pin_driver_level(u32 p_handler, __u32 set_driver_level,
+				     const char *gpio_name)
+{
+	char               *tmp_buf;			/* char */
+	__u32               group_count_max;		/* GPIO */
+	system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+	volatile __u32      *tmp_group_dlevel_addr = NULL;
+	__u32               port, port_num, port_num_dlevel;
+	__u32                i, reg_val;
+	/*  */
+	if (!p_handler)
+		return EGPIO_FAIL;
+
+	if (set_driver_level >= 4)
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+	if (group_count_max == 0) {
+		return EGPIO_FAIL;
+	} else if (group_count_max == 1) {
+		user_gpio_set = tmp_sys_gpio_data;
+	} else if (gpio_name) {
+		for (i = 0; i < group_count_max; i++) {
+			if (strcmp(gpio_name, tmp_sys_gpio_data->gpio_name)) {
+				tmp_sys_gpio_data++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if (!user_gpio_set)
+		return EGPIO_FAIL;
+
+	port     = user_gpio_set->port;
+	port_num = user_gpio_set->port_num;
+	port_num_dlevel = port_num >> 4;
+
+	tmp_group_dlevel_addr = PIO_REG_DLEVEL(port, port_num_dlevel);
+	reg_val = *tmp_group_dlevel_addr;
+	reg_val &= ~(0x03 << (((port_num - (port_num_dlevel<<4))<<1)));
+	reg_val |=  (set_driver_level << (((port_num - (port_num_dlevel<<4))<<1)));
+	*tmp_group_dlevel_addr = reg_val;
+
+	return EGPIO_SUCCESS;
+}
+EXPORT_SYMBOL(gpio_set_one_pin_driver_level);
+
+/*
+ *
+ *                                               CSP_GPIO_Read_One_PIN_Value
+ *
+ * Description:
+ *                GPIOIO
+ * Arguments  :
+ *        p_handler    :    handler
+ *        gpio_name    :    GPIO
+ * Returns    :
+ *
+ * Notes      :
+ *
+ *
+ */
+__s32  gpio_read_one_pin_value(u32 p_handler, const char *gpio_name)
+{
+	char               *tmp_buf;			/* char */
+	__u32               group_count_max;		/* GPIO */
+	system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+	__u32               port, port_num, port_num_func, func_val;
+	__u32                i, reg_val;
+	/*  */
+	if (!p_handler)
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+	if (group_count_max == 0) {
+		return EGPIO_FAIL;
+	} else if (group_count_max == 1) {
+		user_gpio_set = tmp_sys_gpio_data;
+	} else if (gpio_name) {
+		for (i = 0; i < group_count_max; i++) {
+			if (strcmp(gpio_name, tmp_sys_gpio_data->gpio_name)) {
+				tmp_sys_gpio_data++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if (!user_gpio_set)
+		return EGPIO_FAIL;
+
+	port     = user_gpio_set->port;
+	port_num = user_gpio_set->port_num;
+	port_num_func = port_num >> 3;
+
+	reg_val  = PIO_REG_CFG_VALUE(port, port_num_func);
+	func_val = (reg_val >> ((port_num - (port_num_func<<3))<<2)) & 0x07;
+	if ((func_val == 0) || (func_val == 1)) {
+		reg_val = (PIO_REG_DATA_VALUE(port) >> port_num) & 0x01;
+
+		return reg_val;
+	}
+
+	return EGPIO_FAIL;
+}
+EXPORT_SYMBOL(gpio_read_one_pin_value);
+
+/*
+ * CSP_GPIO_Write_One_PIN_Value
+ * Description:
+ *  GPIOIO
+ * Arguments:
+ *	p_handler    :    handler
+ *	value_to_gpio:  
+ *	gpio_name    :    GPIO
+ */
+__s32  gpio_write_one_pin_value(u32 p_handler, __u32 value_to_gpio,
+				const char *gpio_name)
+{
+	char               *tmp_buf;			/* char */
+	__u32               group_count_max;		/* GPIO */
+	system_gpio_set_t  *user_gpio_set = NULL, *tmp_sys_gpio_data;
+	volatile __u32     *tmp_group_data_addr = NULL;
+	__u32               port, port_num, port_num_func, func_val;
+	__u32                i, reg_val;
+	/*  */
+	if (!p_handler)
+		return EGPIO_FAIL;
+
+	if (value_to_gpio >= 2)
+		return EGPIO_FAIL;
+
+	tmp_buf = (char *)p_handler;
+	group_count_max = *(int *)tmp_buf;
+	tmp_sys_gpio_data = (system_gpio_set_t *)(tmp_buf + 16);
+
+	if (group_count_max == 0) {
+		return EGPIO_FAIL;
+	} else if (group_count_max == 1) {
+		user_gpio_set = tmp_sys_gpio_data;
+	} else if (gpio_name) {
+		for (i = 0; i < group_count_max; i++) {
+			if (strcmp(gpio_name, tmp_sys_gpio_data->gpio_name)) {
+				tmp_sys_gpio_data++;
+				continue;
+			}
+			user_gpio_set = tmp_sys_gpio_data;
+			break;
+		}
+	}
+	if (!user_gpio_set)
+		return EGPIO_FAIL;
+
+	port     = user_gpio_set->port;
+	port_num = user_gpio_set->port_num;
+	port_num_func = port_num >> 3;
+
+	reg_val  = PIO_REG_CFG_VALUE(port, port_num_func);
+	func_val = (reg_val >> ((port_num - (port_num_func<<3))<<2)) & 0x07;
+	if (func_val == 1) {
+		tmp_group_data_addr = PIO_REG_DATA(port);
+		reg_val = *tmp_group_data_addr;
+		reg_val &= ~(1 << port_num);
+		reg_val |=  (value_to_gpio << port_num);
+		*tmp_group_data_addr = reg_val;
+
+		return EGPIO_SUCCESS;
+	}
+
+	return EGPIO_FAIL;
+}
+EXPORT_SYMBOL(gpio_write_one_pin_value);
diff --git a/arch/arm/vfp/entry.S b/arch/arm/vfp/entry.S
index 323ce1a..d7a57e5 100644
--- a/arch/arm/vfp/entry.S
+++ b/arch/arm/vfp/entry.S
@@ -7,20 +7,18 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ * Basic entry code, called from the kernel's undefined instruction trap.
+ *  r0  = faulted instruction
+ *  r2  = faulted PC+4
+ *  r9  = successful return
+ *  r10 = thread_info structure
+ *  lr  = failure return
  */
 #include <asm/thread_info.h>
 #include <asm/vfpmacros.h>
 #include "../kernel/entry-header.S"
 
-@ VFP entry point.
-@
-@  r0  = instruction opcode (32-bit ARM or two 16-bit Thumb)
-@  r2  = PC value to resume execution after successful emulation
-@  r9  = normal "successful" return address
-@  r10 = this threads thread_info structure
-@  lr  = unrecognised instruction return address
-@  IRQs disabled.
-@
 ENTRY(do_vfp)
 #ifdef CONFIG_PREEMPT_COUNT
 	ldr	r4, [r10, #TI_PREEMPT]	@ get preempt count
diff --git a/include/linux/power/aw_pm.h b/include/linux/power/aw_pm.h
new file mode 100644
index 0000000..990aca6
--- /dev/null
+++ b/include/linux/power/aw_pm.h
@@ -0,0 +1,135 @@
+/*
+ * include/linux/power/aw_pm.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : pm.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-27 14:08
+* Descript: power manager
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __AW_PM_H__
+#define __AW_PM_H__
+
+
+/**max device number of pmu*/
+#define PMU_MAX_DEVS        2
+/**start address for function run in sram*/
+#define SRAM_FUNC_START     SW_VA_SRAM_BASE
+
+/**
+*@name PMU command
+*@{
+*/
+#define AW_PMU_SET          0x10
+#define AW_PMU_VALID        0x20
+/**
+*@}
+*/
+
+/*
+* define event source for wakeup system when suspended
+*/
+#define SUSPEND_WAKEUP_SRC_EXINT    (1<<0)  /* external interrupt, pmu event for ex.    */
+#define SUSPEND_WAKEUP_SRC_USB      (1<<1)  /* usb connection event */
+#define SUSPEND_WAKEUP_SRC_KEY      (1<<2)  /* key event    */
+#define SUSPEND_WAKEUP_SRC_IR       (1<<3)  /* ir event */
+#define SUSPEND_WAKEUP_SRC_ALARM    (1<<4)  /* alarm event  */
+#define SUSPEND_WAKEUP_SRC_TIMEOFF  (1<<5)  /* set time to power off event  */
+#define SUSPEND_WAKEUP_SRC_PIO      (1<<6)  /* gpio event  */
+
+
+
+/**
+*@brief struct of pmu device arg
+*/
+struct aw_pmu_arg{
+    unsigned int  twi_port;     /**<twi port for pmu chip   */
+    unsigned char dev_addr;     /**<address of pmu device   */
+};
+
+#ifdef CONFIG_ARCH_SUN7I
+typedef struct _boot_dram_para_t
+{
+	unsigned int	dram_baseaddr;
+	unsigned int	dram_clk;
+	unsigned int	dram_type;
+	unsigned int	dram_rank_num;
+	unsigned int	dram_chip_density;
+	unsigned int	dram_io_width;
+	unsigned int	dram_bus_width;
+	unsigned int	dram_cas;
+	unsigned int	dram_zq;
+	unsigned int	dram_odt_en;
+	unsigned int 	dram_size;
+	unsigned int	dram_tpr0;
+	unsigned int	dram_tpr1;
+	unsigned int	dram_tpr2;
+	unsigned int	dram_tpr3;
+	unsigned int	dram_tpr4;
+	unsigned int	dram_tpr5;
+	unsigned int 	dram_emr1;
+	unsigned int	dram_emr2;
+	unsigned int	dram_emr3;
+}standy_dram_para_t;
+#endif
+
+/**
+*@brief struct of standby
+*/
+struct aw_standby_para{
+#ifdef CONFIG_ARCH_SUN7I
+	unsigned int event_enable;   /**<event type for system wakeup        */
+#endif
+    unsigned int event;     /**<event type for system wakeup    */
+#ifdef CONFIG_ARCH_SUN7I
+	unsigned int axp_src;        /**<axp event type for system wakeup    */
+	unsigned int axp_enable;     /**<axp event type for system wakeup    */
+#endif
+    signed int   time_off;  /**<time to power off from now, based on second */
+};
+
+
+/**
+*@brief struct of power management info
+*/
+struct aw_pm_info{
+    struct aw_standby_para  standby_para;   /* standby parameter            */
+    struct aw_pmu_arg       pmu_arg;        /**<args used by main function  */
+#ifdef CONFIG_ARCH_SUN7I
+	standy_dram_para_t	dram_para;
+#endif
+};
+
+
+#endif /* __AW_PM_H__ */
+
