diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 91c9855..5a052d9 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -48,9 +48,23 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
+config SOUND_SUNXI
+       tristate "SOUND driver for sunxi"
+       depends on (ARCH_SUN4I || ARCH_SUN5I || ARCH_SUN7I)
+       help
+         SOUND driver for sunxi
+         
+if SOUND_SUNXI          
+source "sound/soc/sunxi/Kconfig"
+source "sound/soc/sunxi/hdmiaudio/Kconfig"
+source "sound/soc/sunxi/spdif/Kconfig"
+# i2s needs various adjustments for sun7i
+if ARCH_SUN4I || ARCH_SUN5I
+source "sound/soc/sunxi/i2s/Kconfig"
+endif
+endif
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
 
 endif	# SND_SOC
-
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 0f37086..271973a 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -26,3 +26,7 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
+obj-$(CONFIG_SND_SOC)	+= sunxi/
+obj-$(CONFIG_SND_SOC)	+= sunxi/hdmiaudio/
+obj-$(CONFIG_SND_SOC)	+= sunxi/spdif/
+obj-$(CONFIG_SND_SOC)	+= sunxi/i2s/
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
new file mode 100644
index 0000000..8f6d4df
--- /dev/null
+++ b/sound/soc/sunxi/Kconfig
@@ -0,0 +1,5 @@
+config SND_SUNXI_SOC_CODEC
+	tristate "APB On-Chip sun4i and sun5i Codec"
+	default n
+
+
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
new file mode 100644
index 0000000..b8950d3
--- /dev/null
+++ b/sound/soc/sunxi/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SND_SUNXI_SOC_CODEC) += sunxi-codec.o
+
diff --git a/sound/soc/sunxi/hdmiaudio/Kconfig b/sound/soc/sunxi/hdmiaudio/Kconfig
new file mode 100644
index 0000000..9aba327
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/Kconfig
@@ -0,0 +1,6 @@
+
+config SND_SUNXI_SOC_HDMIAUDIO
+	tristate "HDMI Audio for the AllWinner sun4i and sun5i chips"
+	default n
+	help
+	  Say Y or M if you want to add support for hdmi audio
diff --git a/sound/soc/sunxi/hdmiaudio/Makefile b/sound/soc/sunxi/hdmiaudio/Makefile
new file mode 100644
index 0000000..af37106
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/Makefile
@@ -0,0 +1,6 @@
+
+obj-$(CONFIG_SND_SUNXI_SOC_HDMIAUDIO) += sunxi-hdmiaudio.o
+obj-$(CONFIG_SND_SUNXI_SOC_HDMIAUDIO) += sunxi-hdmipcm.o
+obj-$(CONFIG_SND_SUNXI_SOC_HDMIAUDIO) += sndhdmi.o
+obj-$(CONFIG_SND_SUNXI_SOC_HDMIAUDIO) += sunxi-sndhdmi.o
+
diff --git a/sound/soc/sunxi/hdmiaudio/sndhdmi.c b/sound/soc/sunxi/hdmiaudio/sndhdmi.c
new file mode 100644
index 0000000..d875c17
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/sndhdmi.c
@@ -0,0 +1,197 @@
+/*
+ * sound\soc\sunxi\hdmiaudio\sndhdmi.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <plat/sys_config.h>
+#include <linux/io.h>
+
+#include "sndhdmi.h"
+
+struct sndhdmi_priv {
+	int sysclk;
+	int dai_fmt;
+
+	struct snd_pcm_substream *master_substream;
+	struct snd_pcm_substream *slave_substream;
+};
+
+static hdmi_audio_t hdmi_para;
+static __audio_hdmi_func g_hdmi_func;
+
+void audio_set_hdmi_func(__audio_hdmi_func * hdmi_func)
+{
+	g_hdmi_func.hdmi_audio_enable = hdmi_func->hdmi_audio_enable;
+	g_hdmi_func.hdmi_set_audio_para = hdmi_func->hdmi_set_audio_para;
+}
+
+EXPORT_SYMBOL(audio_set_hdmi_func);
+
+#define SNDHDMI_RATES  (SNDRV_PCM_RATE_8000_192000|SNDRV_PCM_RATE_KNOT)
+#define SNDHDMI_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | \
+		                     SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S20_3LE)
+
+static int sndhdmi_mute(struct snd_soc_dai *dai, int mute)
+{
+	return 0;
+}
+
+static int sndhdmi_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void sndhdmi_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+
+}
+
+static int sndhdmi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params,
+	struct snd_soc_dai *dai)
+{
+	hdmi_para.sample_rate = params_rate(params);
+	hdmi_para.channel_num = params_channels(params);
+	g_hdmi_func.hdmi_set_audio_para(&hdmi_para);
+	g_hdmi_func.hdmi_audio_enable(1, 1);
+
+	return 0;
+}
+
+static int sndhdmi_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int sndhdmi_set_dai_clkdiv(struct snd_soc_dai *codec_dai, int div_id, int div)
+{
+
+	hdmi_para.fs_between = div;
+
+	return 0;
+}
+
+
+static int sndhdmi_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int fmt)
+{
+	return 0;
+}
+
+//codec dai operation
+struct snd_soc_dai_ops sndhdmi_dai_ops = {
+	.startup = sndhdmi_startup,
+	.shutdown = sndhdmi_shutdown,
+	.hw_params = sndhdmi_hw_params,
+	.digital_mute = sndhdmi_mute,
+	.set_sysclk = sndhdmi_set_dai_sysclk,
+	.set_clkdiv = sndhdmi_set_dai_clkdiv,
+	.set_fmt = sndhdmi_set_dai_fmt,
+};
+
+//codec dai
+struct snd_soc_dai_driver sndhdmi_dai = {
+	.name = "sndhdmi",
+	/* playback capabilities */
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDHDMI_RATES,
+		.formats = SNDHDMI_FORMATS,
+	},
+	/* pcm operations */
+	.ops = &sndhdmi_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL(sndhdmi_dai);
+
+static int sndhdmi_soc_probe(struct snd_soc_codec *codec)
+{
+	struct sndhdmi_priv *sndhdmi;
+
+	sndhdmi = kzalloc(sizeof(struct sndhdmi_priv), GFP_KERNEL);
+	if(sndhdmi == NULL){
+		printk("error at:%s,%d\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	snd_soc_codec_set_drvdata(codec, sndhdmi);
+
+	return 0;
+}
+
+static int sndhdmi_soc_remove(struct snd_soc_codec *codec)
+{
+	struct sndhdmi_priv *sndhdmi = snd_soc_codec_get_drvdata(codec);
+
+	kfree(sndhdmi);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_sndhdmi = {
+	.probe =        sndhdmi_soc_probe,
+	.remove =       sndhdmi_soc_remove,
+};
+
+static int __devinit sndhdmi_codec_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_sndhdmi, &sndhdmi_dai, 1);
+}
+
+static int __devexit sndhdmi_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver sndhdmi_codec_driver = {
+	.driver = {
+		.name = "sunxi-hdmiaudio-codec",
+		.owner = THIS_MODULE,
+	},
+	.probe = sndhdmi_codec_probe,
+	.remove = __devexit_p(sndhdmi_codec_remove),
+};
+
+static int __init sndhdmi_codec_init(void)
+{
+	int err = 0;
+
+	if ((err = platform_driver_register(&sndhdmi_codec_driver)) < 0)
+		return err;
+
+	return 0;
+}
+module_init(sndhdmi_codec_init);
+
+static void __exit sndhdmi_codec_exit(void)
+{
+	platform_driver_unregister(&sndhdmi_codec_driver);
+}
+module_exit(sndhdmi_codec_exit);
+
+MODULE_DESCRIPTION("SNDHDMI ALSA soc codec driver");
+MODULE_AUTHOR("Zoltan Devai, Christian Pellegrin <chripell@evolware.org>");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/sunxi/hdmiaudio/sndhdmi.h b/sound/soc/sunxi/hdmiaudio/sndhdmi.h
new file mode 100644
index 0000000..346e587
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/sndhdmi.h
@@ -0,0 +1,36 @@
+/*
+ * sound\soc\sunxi\hdmiaudio\sndhdmi.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef SNDHDMI_H
+#define SNDHDMI_H
+#include <linux/drv_hdmi.h>
+
+struct sndhdmi_platform_data {
+	void (*power) (int);
+	int model;
+	/*
+	  ALSA SOC usually puts the device in standby mode when it's not used
+	  for sometime. If you unset is_powered_on_standby the driver will
+	  turn off the ADC/DAC when this callback is invoked and turn it back
+	  on when needed. Unfortunately this will result in a very light bump
+	  (it can be audible only with good earphones). If this bothers you
+	  set is_powered_on_standby, you will have slightly higher power
+	  consumption. Please note that sending the L3 command for ADC is
+	  enough to make the bump, so it doesn't make difference if you
+	  completely take off power from the codec.
+	*/
+	int is_powered_on_standby;
+};
+
+#endif
diff --git a/sound/soc/sunxi/hdmiaudio/sunxi-hdmiaudio.c b/sound/soc/sunxi/hdmiaudio/sunxi-hdmiaudio.c
new file mode 100644
index 0000000..4fdd848
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/sunxi-hdmiaudio.c
@@ -0,0 +1,687 @@
+/*
+ * sound\soc\sunxi\hdmiaudio\sunxi-hdmiaudio.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+#include <plat/system.h>
+#include <plat/sys_config.h>
+#include <plat/dma_compat.h>
+
+#include "sunxi-hdmipcm.h"
+#include "sunxi-hdmiaudio.h"
+
+//save the register value
+static int regsave[8];
+
+static struct sunxi_dma_params sunxi_hdmiaudio_pcm_stereo_out = {
+	.client.name	=	"HDMIAUDIO PCM Stereo out",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	=	DMACH_HDMIAUDIO,
+#endif
+	.dma_addr 	=	0,
+};
+
+static struct sunxi_dma_params sunxi_hdmiaudio_pcm_stereo_in = {
+	.client.name	=	"HDMIAUDIO PCM Stereo in",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	=	DMACH_HDMIAUDIO,
+#endif
+	.dma_addr 	=	SUNXI_HDMIAUDIOBASE + SUNXI_HDMIAUDIORXFIFO,
+};
+
+struct sunxi_hdmiaudio_info sunxi_hdmiaudio;
+
+//clock handle
+static struct clk *hdmiaudio_apbclk;
+static struct clk *hdmiaudio_pll2clk;
+static struct clk *hdmiaudio_pllx8;
+static struct clk *hdmiaudio_moduleclk;
+
+void sunxi_snd_txctrl_hdmiaudio(struct snd_pcm_substream *substream, int on)
+{
+	u32 reg_val;
+
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_TXCHSEL);
+	reg_val &= ~0x7;
+	reg_val |= SUNXI_TXCHSEL_CHNUM(substream->runtime->channels);
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_TXCHSEL);
+
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_TXCHMAP);
+	reg_val = 0;
+	if(substream->runtime->channels == 1) {
+		reg_val = 0x76543200;
+	} else {
+		reg_val = 0x76543210;
+	}
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_TXCHMAP);
+
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	reg_val &= ~SUNXI_HDMIAUDIOCTL_SDO3EN;
+	reg_val &= ~SUNXI_HDMIAUDIOCTL_SDO2EN;
+	reg_val &= ~SUNXI_HDMIAUDIOCTL_SDO1EN;
+	reg_val &= ~SUNXI_HDMIAUDIOCTL_SDO0EN;
+	switch(substream->runtime->channels) {
+		case 1:
+		case 2:
+			reg_val |= SUNXI_HDMIAUDIOCTL_SDO0EN; break;
+		case 3:
+		case 4:
+			reg_val |= SUNXI_HDMIAUDIOCTL_SDO0EN | SUNXI_HDMIAUDIOCTL_SDO1EN; break;
+		case 5:
+		case 6:
+			reg_val |= SUNXI_HDMIAUDIOCTL_SDO0EN | SUNXI_HDMIAUDIOCTL_SDO1EN | SUNXI_HDMIAUDIOCTL_SDO2EN; break;
+		case 7:
+		case 8:
+			reg_val |= SUNXI_HDMIAUDIOCTL_SDO0EN | SUNXI_HDMIAUDIOCTL_SDO1EN | SUNXI_HDMIAUDIOCTL_SDO2EN | SUNXI_HDMIAUDIOCTL_SDO3EN; break;
+		default:
+			reg_val |= SUNXI_HDMIAUDIOCTL_SDO0EN; break;
+	}
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+	//flush TX FIFO
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFCTL);
+	reg_val |= SUNXI_HDMIAUDIOFCTL_FTX;
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFCTL);
+
+	//clear TX counter
+	writel(0, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOTXCNT);
+
+	if (on) {
+		/* hdmiaudio TX ENABLE */
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+		reg_val |= SUNXI_HDMIAUDIOCTL_TXEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+		/* enable DMA DRQ mode for play */
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+		reg_val |= SUNXI_HDMIAUDIOINT_TXDRQEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+
+		//Global Enable Digital Audio Interface
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+		reg_val |= SUNXI_HDMIAUDIOCTL_GEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	}else{
+		/* HDMIAUDIO TX DISABLE */
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+		reg_val &= ~SUNXI_HDMIAUDIOCTL_TXEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+		/* DISBALE dma DRQ mode */
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+		reg_val &= ~SUNXI_HDMIAUDIOINT_TXDRQEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+
+		//Global disable Digital Audio Interface
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+		reg_val &= ~SUNXI_HDMIAUDIOCTL_GEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	}
+}
+
+void sunxi_snd_rxctrl_hdmiaudio(struct snd_pcm_substream *substream, int on)
+{
+	u32 reg_val;
+
+	//flush RX FIFO
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFCTL);
+	reg_val |= SUNXI_HDMIAUDIOFCTL_FRX;
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFCTL);
+
+	//clear RX counter
+	writel(0, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIORXCNT);
+
+	if (on) {
+		/* HDMIAUDIO RX ENABLE */
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+		reg_val |= SUNXI_HDMIAUDIOCTL_RXEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+		/* enable DMA DRQ mode for record */
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+		reg_val |= SUNXI_HDMIAUDIOINT_RXDRQEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+
+		//Global Enable Digital Audio Interface
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+		reg_val |= SUNXI_HDMIAUDIOCTL_GEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	} else {
+		/* HDMIAUDIO RX DISABLE */
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+		reg_val &= ~SUNXI_HDMIAUDIOCTL_RXEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+		/* DISBALE dma DRQ mode */
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+		reg_val &= ~SUNXI_HDMIAUDIOINT_RXDRQEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+
+		//Global disable Digital Audio Interface
+		reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+		reg_val &= ~SUNXI_HDMIAUDIOCTL_GEN;
+		writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	}
+}
+
+static int sunxi_hdmiaudio_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	u32 reg_val;
+	u32 reg_val1;
+
+	if (sunxi_is_sun7i())
+		return 0; /* No rx / tx control, etc. on sun7i() */
+
+	//SDO ON
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	reg_val |= (SUNXI_HDMIAUDIOCTL_SDO0EN | SUNXI_HDMIAUDIOCTL_SDO1EN | SUNXI_HDMIAUDIOCTL_SDO2EN | SUNXI_HDMIAUDIOCTL_SDO3EN);
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+	/* master or slave selection */
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	switch(fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+		case SND_SOC_DAIFMT_CBM_CFM:   /* codec clk & frm master */
+			reg_val |= SUNXI_HDMIAUDIOCTL_MS;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:   /* codec clk & frm slave */
+			reg_val &= ~SUNXI_HDMIAUDIOCTL_MS;
+			break;
+		default:
+			return -EINVAL;
+	}
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+	/* pcm or hdmiaudio mode selection */
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	reg_val1 = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT0);
+	reg_val1 &= ~SUNXI_HDMIAUDIOFAT0_FMT_RVD;
+	switch(fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:        /* I2S mode */
+			reg_val &= ~SUNXI_HDMIAUDIOCTL_PCM;
+			reg_val1 |= SUNXI_HDMIAUDIOFAT0_FMT_I2S;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:    /* Right Justified mode */
+			reg_val &= ~SUNXI_HDMIAUDIOCTL_PCM;
+			reg_val1 |= SUNXI_HDMIAUDIOFAT0_FMT_RGT;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:     /* Left Justified mode */
+			reg_val &= ~SUNXI_HDMIAUDIOCTL_PCM;
+			reg_val1 |= SUNXI_HDMIAUDIOFAT0_FMT_LFT;
+			break;
+		case SND_SOC_DAIFMT_DSP_A:      /* L data msb after FRM LRC */
+			reg_val |= SUNXI_HDMIAUDIOCTL_PCM;
+			reg_val1 &= ~SUNXI_HDMIAUDIOFAT0_LRCP;
+			break;
+		case SND_SOC_DAIFMT_DSP_B:      /* L data msb during FRM LRC */
+			reg_val |= SUNXI_HDMIAUDIOCTL_PCM;
+			reg_val1 |= SUNXI_HDMIAUDIOFAT0_LRCP;
+			break;
+		default:
+			return -EINVAL;
+	}
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	writel(reg_val1, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT0);
+
+	/* DAI signal inversions */
+	reg_val1 = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT0);
+	switch(fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:     /* normal bit clock + frame */
+			reg_val1 &= ~SUNXI_HDMIAUDIOFAT0_LRCP;
+			reg_val1 &= ~SUNXI_HDMIAUDIOFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_NB_IF:     /* normal bclk + inv frm */
+			reg_val1 |= SUNXI_HDMIAUDIOFAT0_LRCP;
+			reg_val1 &= ~SUNXI_HDMIAUDIOFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:     /* invert bclk + nor frm */
+			reg_val1 &= ~SUNXI_HDMIAUDIOFAT0_LRCP;
+			reg_val1 |= SUNXI_HDMIAUDIOFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_IB_IF:     /* invert bclk + frm */
+			reg_val1 |= SUNXI_HDMIAUDIOFAT0_LRCP;
+			reg_val1 |= SUNXI_HDMIAUDIOFAT0_BCP;
+			break;
+	}
+	writel(reg_val1, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT0);
+
+	/* word select size */
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT0);
+	reg_val &= ~SUNXI_HDMIAUDIOFAT0_WSS_32BCLK;
+	if(sunxi_hdmiaudio.ws_size == 16)
+		reg_val |= SUNXI_HDMIAUDIOFAT0_WSS_16BCLK;
+	else if(sunxi_hdmiaudio.ws_size == 20)
+		reg_val |= SUNXI_HDMIAUDIOFAT0_WSS_20BCLK;
+	else if(sunxi_hdmiaudio.ws_size == 24)
+		reg_val |= SUNXI_HDMIAUDIOFAT0_WSS_24BCLK;
+	else
+		reg_val |= SUNXI_HDMIAUDIOFAT0_WSS_32BCLK;
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT0);
+
+	/* PCM REGISTER setup */
+	reg_val = sunxi_hdmiaudio.pcm_txtype&0x3;
+	reg_val |= sunxi_hdmiaudio.pcm_rxtype<<2;
+
+	if(!sunxi_hdmiaudio.pcm_sync_type)
+		reg_val |= SUNXI_HDMIAUDIOFAT1_SSYNC;							//short sync
+	if(sunxi_hdmiaudio.pcm_sw == 16)
+		reg_val |= SUNXI_HDMIAUDIOFAT1_SW;
+
+	reg_val |=((sunxi_hdmiaudio.pcm_start_slot - 1)&0x3)<<6;		//start slot index
+
+	reg_val |= sunxi_hdmiaudio.pcm_lsb_first<<9;			//MSB or LSB first
+
+	if(sunxi_hdmiaudio.pcm_sync_period == 256)
+		reg_val |= 0x4<<12;
+	else if (sunxi_hdmiaudio.pcm_sync_period == 128)
+		reg_val |= 0x3<<12;
+	else if (sunxi_hdmiaudio.pcm_sync_period == 64)
+		reg_val |= 0x2<<12;
+	else if (sunxi_hdmiaudio.pcm_sync_period == 32)
+		reg_val |= 0x1<<12;
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT1);
+
+	/* set FIFO control register */
+	reg_val = 0 & 0x3;
+	reg_val |= (0 & 0x1)<<2;
+	reg_val |= SUNXI_HDMIAUDIOFCTL_RXTL(0xf);				//RX FIFO trigger level
+	reg_val |= SUNXI_HDMIAUDIOFCTL_TXTL(0x40);				//TX FIFO empty trigger level
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFCTL);
+	return 0;
+}
+
+static int sunxi_hdmiaudio_hw_params(struct snd_pcm_substream *substream,
+																struct snd_pcm_hw_params *params,
+																struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sunxi_dma_params *dma_data;
+
+	/* play or record */
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &sunxi_hdmiaudio_pcm_stereo_out;
+	else
+		dma_data = &sunxi_hdmiaudio_pcm_stereo_in;
+
+	snd_soc_dai_set_dma_data(rtd->cpu_dai, substream, dma_data);
+
+	return 0;
+}
+
+static int sunxi_hdmiaudio_trigger(struct snd_pcm_substream *substream,
+                              int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sunxi_dma_params *dma_data =
+			snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	if (sunxi_is_sun7i())
+		return 0; /* No rx / tx control, etc. on sun7i() */
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_hdmiaudio(substream, 1);
+			} else {
+				sunxi_snd_txctrl_hdmiaudio(substream, 1);
+			}
+			sunxi_dma_started(dma_data);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_hdmiaudio(substream, 0);
+			} else {
+			  sunxi_snd_txctrl_hdmiaudio(substream, 0);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return ret;
+}
+
+//freq:   1: 22.5792MHz   0: 24.576MHz
+static int sunxi_hdmiaudio_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,
+                                 unsigned int freq, int dir)
+{
+	if (sunxi_is_sun7i())
+		return 0; /* No rx / tx control, etc. on sun7i() */
+
+	if (!freq) {
+		clk_set_rate(hdmiaudio_pll2clk, 24576000);
+	} else {
+		clk_set_rate(hdmiaudio_pll2clk, 22579200);
+	}
+
+	return 0;
+}
+
+static int sunxi_hdmiaudio_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id, int div)
+{
+	u32 reg;
+
+	if (sunxi_is_sun7i())
+		return 0; /* No rx / tx control, etc. on sun7i() */
+
+	switch (div_id) {
+	case SUNXI_DIV_MCLK:
+		if(div <= 8)
+			div  = (div >>1);
+		else if(div  == 12)
+			div  = 0x5;
+		else if(div  == 16)
+			div  = 0x6;
+		else if(div == 24)
+			div = 0x7;
+		else if(div == 32)
+			div = 0x8;
+		else if(div == 48)
+			div = 0x9;
+		else if(div == 64)
+			div = 0xa;
+		reg = (readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD) & ~SUNXI_HDMIAUDIOCLKD_MCLK_MASK) | (div << SUNXI_HDMIAUDIOCLKD_MCLK_OFFS);
+		writel(reg, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD);
+		break;
+	case SUNXI_DIV_BCLK:
+		if(div <= 8)
+			div = (div>>1) - 1;
+		else if(div == 12)
+			div = 0x4;
+		else if(div == 16)
+			div = 0x5;
+		else if(div == 32)
+			div = 0x6;
+		else if(div == 64)
+			div = 0x7;
+		reg = (readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD) & ~SUNXI_HDMIAUDIOCLKD_BCLK_MASK) | (div <<SUNXI_HDMIAUDIOCLKD_BCLK_OFFS);
+		writel(reg, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	//diable MCLK output when high samplerate
+	reg = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD);
+	if(!(reg & 0xF)) {
+		reg &= ~SUNXI_HDMIAUDIOCLKD_MCLKOEN;
+		writel(reg, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD);
+	} else {
+		reg |= SUNXI_HDMIAUDIOCLKD_MCLKOEN;
+		writel(reg, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD);
+	}
+
+	return 0;
+}
+
+u32 sunxi_hdmiaudio_get_clockrate(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_hdmiaudio_get_clockrate);
+
+static int sunxi_hdmiaudio_dai_probe(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+static int sunxi_hdmiaudio_dai_remove(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void hdmiaudioregsave(void)
+{
+	regsave[0] = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	regsave[1] = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT0);
+	regsave[2] = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT1);
+	regsave[3] = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFCTL) | (0x3<<24);
+	regsave[4] = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+	regsave[5] = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD);
+	regsave[6] = readl(sunxi_hdmiaudio.regs + SUNXI_TXCHSEL);
+	regsave[7] = readl(sunxi_hdmiaudio.regs + SUNXI_TXCHMAP);
+}
+
+static void hdmiaudioregrestore(void)
+{
+	writel(regsave[0], sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	writel(regsave[1], sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT0);
+	writel(regsave[2], sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFAT1);
+	writel(regsave[3], sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOFCTL);
+	writel(regsave[4], sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOINT);
+	writel(regsave[5], sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCLKD);
+	writel(regsave[6], sunxi_hdmiaudio.regs + SUNXI_TXCHSEL);
+	writel(regsave[7], sunxi_hdmiaudio.regs + SUNXI_TXCHMAP);
+}
+
+static int sunxi_hdmiaudio_suspend(struct snd_soc_dai *cpu_dai)
+{
+	u32 reg_val;
+
+	if (sunxi_is_sun7i())
+		return 0; /* No rx / tx control, etc. on sun7i() */
+
+ 	printk("[HDMIAUDIO]Entered %s\n", __func__);
+
+	//Global Enable Digital Audio Interface
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	reg_val &= ~SUNXI_HDMIAUDIOCTL_GEN;
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+	hdmiaudioregsave();
+	//release the module clock
+	clk_disable(hdmiaudio_moduleclk);
+
+	clk_disable(hdmiaudio_apbclk);
+
+	//printk("[HDMIAUDIO]PLL2 0x01c20008 = %#x, line = %d\n", *(volatile int*)0xF1C20008, __LINE__);
+	printk("[HDMIAUDIO]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[HDMIAUDIO]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+
+static int sunxi_hdmiaudio_resume(struct snd_soc_dai *cpu_dai)
+{
+	u32 reg_val;
+
+	if (sunxi_is_sun7i())
+		return 0; /* No rx / tx control, etc. on sun7i() */
+
+	printk("[HDMIAUDIO]Entered %s\n", __func__);
+
+	//release the module clock
+	clk_enable(hdmiaudio_apbclk);
+
+	//release the module clock
+	clk_enable(hdmiaudio_moduleclk);
+
+	hdmiaudioregrestore();
+
+	//Global Enable Digital Audio Interface
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	reg_val |= SUNXI_HDMIAUDIOCTL_GEN;
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+	//printk("[HDMIAUDIO]PLL2 0x01c20008 = %#x, line = %d\n", *(volatile int*)0xF1C20008, __LINE__);
+	printk("[HDMIAUDIO]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[HDMIAUDIO]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+
+#define SUNXI_I2S_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_hdmiaudio_dai_ops = {
+	.trigger 		= sunxi_hdmiaudio_trigger,
+	.hw_params 	= sunxi_hdmiaudio_hw_params,
+	.set_fmt 		= sunxi_hdmiaudio_set_fmt,
+	.set_clkdiv = sunxi_hdmiaudio_set_clkdiv,
+	.set_sysclk = sunxi_hdmiaudio_set_sysclk,
+};
+static struct snd_soc_dai_driver sunxi_hdmiaudio_dai = {
+	.probe 		= sunxi_hdmiaudio_dai_probe,
+	.suspend 	= sunxi_hdmiaudio_suspend,
+	.resume 	= sunxi_hdmiaudio_resume,
+	.remove 	= sunxi_hdmiaudio_dai_remove,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,},
+	.symmetric_rates = 1,
+	.ops = &sunxi_hdmiaudio_dai_ops,
+};
+
+static int __devinit sunxi_hdmiaudio_dev_probe(struct platform_device *pdev)
+{
+	int reg_val = 0;
+	int ret = 0;
+
+	if (sunxi_is_sun7i()) {
+		/* No rx / tx control, etc. on sun7i() */
+		return snd_soc_register_dai(&pdev->dev, &sunxi_hdmiaudio_dai);
+	}
+
+	sunxi_hdmiaudio.regs = ioremap(SUNXI_HDMIAUDIOBASE, 0x100);
+	if (sunxi_hdmiaudio.regs == NULL)
+		return -ENXIO;
+
+	sunxi_hdmiaudio.ccmregs = ioremap(SUNXI_CCMBASE, 0x100);
+	if (sunxi_hdmiaudio.ccmregs == NULL)
+		return -ENXIO;
+
+	sunxi_hdmiaudio.ioregs = ioremap(0x01C20800, 0x100);
+	if (sunxi_hdmiaudio.ioregs == NULL)
+		return -ENXIO;
+
+	//hdmiaudio apbclk
+	hdmiaudio_apbclk = clk_get(NULL, "apb_i2s");
+	if(-1 == clk_enable(hdmiaudio_apbclk)){
+		printk("hdmiaudio_apbclk failed! line = %d\n", __LINE__);
+	}
+
+	hdmiaudio_pllx8 = clk_get(NULL, "audio_pllx8");
+
+	//hdmiaudio pll2clk
+	hdmiaudio_pll2clk = clk_get(NULL, "audio_pll");
+
+	//hdmiaudio module clk
+	hdmiaudio_moduleclk = clk_get(NULL, "i2s");
+
+	if(clk_set_parent(hdmiaudio_moduleclk, hdmiaudio_pll2clk)){
+		printk("try to set parent of hdmiaudio_moduleclk to hdmiaudio_pll2ck failed! line = %d\n",__LINE__);
+	}
+
+
+	if(clk_set_rate(hdmiaudio_moduleclk, 24576000/8)){
+		printk("set hdmiaudio_moduleclk clock freq to 24576000 failed! line = %d\n", __LINE__);
+	}
+
+
+	if(-1 == clk_enable(hdmiaudio_moduleclk)){
+		printk("open hdmiaudio_moduleclk failed! line = %d\n", __LINE__);
+	}
+
+	reg_val = readl(sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+	reg_val |= SUNXI_HDMIAUDIOCTL_GEN;
+	writel(reg_val, sunxi_hdmiaudio.regs + SUNXI_HDMIAUDIOCTL);
+
+	ret = snd_soc_register_dai(&pdev->dev, &sunxi_hdmiaudio_dai);
+
+	iounmap(sunxi_hdmiaudio.ioregs);
+
+	return 0;
+}
+
+static int __devexit sunxi_hdmiaudio_dev_remove(struct platform_device *pdev)
+{
+	if (sunxi_is_sun7i()) {
+		/* No rx / tx control, etc. on sun7i() */
+		snd_soc_unregister_dai(&pdev->dev);
+		return 0;
+	}
+
+	//release the module clock
+	clk_disable(hdmiaudio_moduleclk);
+
+	//release pllx8clk
+	clk_put(hdmiaudio_pllx8);
+
+	//release pll2clk
+	clk_put(hdmiaudio_pll2clk);
+
+	//release apbclk
+	clk_put(hdmiaudio_apbclk);
+
+	snd_soc_unregister_dai(&pdev->dev);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct platform_driver sunxi_hdmiaudio_driver = {
+	.probe = sunxi_hdmiaudio_dev_probe,
+	.remove = __devexit_p(sunxi_hdmiaudio_dev_remove),
+	.driver = {
+		.name = "sunxi-hdmiaudio",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_hdmiaudio_init(void)
+{
+	int err = 0;
+
+	if ((err = platform_driver_register(&sunxi_hdmiaudio_driver)) < 0)
+		return err;
+
+	return 0;
+}
+module_init(sunxi_hdmiaudio_init);
+
+static void __exit sunxi_hdmiaudio_exit(void)
+{
+	platform_driver_unregister(&sunxi_hdmiaudio_driver);
+}
+module_exit(sunxi_hdmiaudio_exit);
+
+
+/* Module information */
+MODULE_AUTHOR("ALLWINNER");
+MODULE_DESCRIPTION("sunxi hdmiaudio SoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform: sunxi-hdmiaudio");
diff --git a/sound/soc/sunxi/hdmiaudio/sunxi-hdmiaudio.h b/sound/soc/sunxi/hdmiaudio/sunxi-hdmiaudio.h
new file mode 100644
index 0000000..9f4a0cc
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/sunxi-hdmiaudio.h
@@ -0,0 +1,303 @@
+/*
+ * sound\soc\sunxi\hdmiaudio\sunxi-hdmiaudio.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef SUNXI_HDMIAUIDO_H_
+#define SUNXI_HDMIAUIDO_H_
+#include <linux/drv_hdmi.h>
+
+/*------------------------------------------------------------*/
+/* REGISTER definition */
+
+/* HDMIAUDIO REGISTER */
+#define SUNXI_HDMIAUDIOBASE 		(0x01C22400)
+
+#define SUNXI_HDMIAUDIOCTL 	  (0x00)
+	#define SUNXI_HDMIAUDIOCTL_SDO3EN		(1<<11)
+	#define SUNXI_HDMIAUDIOCTL_SDO2EN		(1<<10)
+	#define SUNXI_HDMIAUDIOCTL_SDO1EN		(1<<9)
+	#define SUNXI_HDMIAUDIOCTL_SDO0EN		(1<<8)
+	#define SUNXI_HDMIAUDIOCTL_ASS			(1<<6)
+	#define SUNXI_HDMIAUDIOCTL_MS			(1<<5)
+	#define SUNXI_HDMIAUDIOCTL_PCM			(1<<4)
+	#define SUNXI_HDMIAUDIOCTL_LOOP			(1<<3)
+	#define SUNXI_HDMIAUDIOCTL_TXEN			(1<<2)
+	#define SUNXI_HDMIAUDIOCTL_RXEN			(1<<1)
+	#define SUNXI_HDMIAUDIOCTL_GEN			(1<<0)
+
+#define SUNXI_HDMIAUDIOFAT0 		(0x04)
+	#define SUNXI_HDMIAUDIOFAT0_LRCP					(1<<7)
+	#define SUNXI_HDMIAUDIOFAT0_BCP					(1<<6)
+	#define SUNXI_HDMIAUDIOFAT0_SR_RVD				(3<<4)
+	#define SUNXI_HDMIAUDIOFAT0_SR_16BIT				(0<<4)
+	#define	SUNXI_HDMIAUDIOFAT0_SR_20BIT				(1<<4)
+	#define SUNXI_HDMIAUDIOFAT0_SR_24BIT				(2<<4)
+	#define SUNXI_HDMIAUDIOFAT0_WSS_16BCLK			(0<<2)
+	#define SUNXI_HDMIAUDIOFAT0_WSS_20BCLK			(1<<2)
+	#define SUNXI_HDMIAUDIOFAT0_WSS_24BCLK			(2<<2)
+	#define SUNXI_HDMIAUDIOFAT0_WSS_32BCLK			(3<<2)
+	#define SUNXI_HDMIAUDIOFAT0_FMT_I2S				(0<<0)
+	#define SUNXI_HDMIAUDIOFAT0_FMT_LFT				(1<<0)
+	#define SUNXI_HDMIAUDIOFAT0_FMT_RGT				(2<<0)
+	#define SUNXI_HDMIAUDIOFAT0_FMT_RVD				(3<<0)
+
+#define SUNXI_HDMIAUDIOFAT1		(0x08)
+	#define SUNXI_HDMIAUDIOFAT1_SYNCLEN_16BCLK		(0<<12)
+	#define SUNXI_HDMIAUDIOFAT1_SYNCLEN_32BCLK		(1<<12)
+	#define SUNXI_HDMIAUDIOFAT1_SYNCLEN_64BCLK		(2<<12)
+	#define SUNXI_HDMIAUDIOFAT1_SYNCLEN_128BCLK		(3<<12)
+	#define SUNXI_HDMIAUDIOFAT1_SYNCLEN_256BCLK		(4<<12)
+	#define SUNXI_HDMIAUDIOFAT1_SYNCOUTEN			(1<<11)
+	#define SUNXI_HDMIAUDIOFAT1_OUTMUTE 				(1<<10)
+	#define SUNXI_HDMIAUDIOFAT1_MLS		 			(1<<9)
+	#define SUNXI_HDMIAUDIOFAT1_SEXT		 			(1<<8)
+	#define SUNXI_HDMIAUDIOFAT1_SI_1ST				(0<<6)
+	#define SUNXI_HDMIAUDIOFAT1_SI_2ND			 	(1<<6)
+	#define SUNXI_HDMIAUDIOFAT1_SI_3RD			 	(2<<6)
+	#define SUNXI_HDMIAUDIOFAT1_SI_4TH			 	(3<<6)
+	#define SUNXI_HDMIAUDIOFAT1_SW			 		(1<<5)
+	#define SUNXI_HDMIAUDIOFAT1_SSYNC	 			(1<<4)
+	#define SUNXI_HDMIAUDIOFAT1_RXPDM_16PCM			(0<<2)
+	#define SUNXI_HDMIAUDIOFAT1_RXPDM_8PCM			(1<<2)
+	#define SUNXI_HDMIAUDIOFAT1_RXPDM_8ULAW			(2<<2)
+	#define SUNXI_HDMIAUDIOFAT1_RXPDM_8ALAW  		(3<<2)
+	#define SUNXI_HDMIAUDIOFAT1_TXPDM_16PCM			(0<<0)
+	#define SUNXI_HDMIAUDIOFAT1_TXPDM_8PCM			(1<<0)
+	#define SUNXI_HDMIAUDIOFAT1_TXPDM_8ULAW			(2<<0)
+	#define SUNXI_HDMIAUDIOFAT1_TXPDM_8ALAW  		(3<<0)
+
+#define SUNXI_HDMIAUDIOTXFIFO 	(0x0C)
+
+#define SUNXI_HDMIAUDIORXFIFO 	(0x10)
+
+#define SUNXI_HDMIAUDIOFCTL  	(0x14)
+	#define SUNXI_HDMIAUDIOFCTL_FIFOSRC			(1<<31)
+	#define SUNXI_HDMIAUDIOFCTL_FTX				(1<<25)
+	#define SUNXI_HDMIAUDIOFCTL_FRX				(1<<24)
+	#define SUNXI_HDMIAUDIOFCTL_TXTL(v)			((v)<<12)
+	#define SUNXI_HDMIAUDIOFCTL_RXTL(v)  		((v)<<4)
+	#define SUNXI_HDMIAUDIOFCTL_TXIM_MOD0		(0<<2)
+	#define SUNXI_HDMIAUDIOFCTL_TXIM_MOD1		(1<<2)
+	#define SUNXI_HDMIAUDIOFCTL_RXOM_MOD0		(0<<0)
+	#define SUNXI_HDMIAUDIOFCTL_RXOM_MOD1		(1<<0)
+	#define SUNXI_HDMIAUDIOFCTL_RXOM_MOD2		(2<<0)
+	#define SUNXI_HDMIAUDIOFCTL_RXOM_MOD3		(3<<0)
+
+#define SUNXI_HDMIAUDIOFSTA   	(0x18)
+	#define SUNXI_HDMIAUDIOFSTA_TXE				(1<<28)
+	#define SUNXI_HDMIAUDIOFSTA_TXECNT(v)		((v)<<16)
+	#define SUNXI_HDMIAUDIOFSTA_RXA				(1<<8)
+	#define SUNXI_HDMIAUDIOFSTA_RXACNT(v)		((v)<<0)
+
+#define SUNXI_HDMIAUDIOINT    	(0x1C)
+	#define SUNXI_HDMIAUDIOINT_TXDRQEN				(1<<7)
+	#define SUNXI_HDMIAUDIOINT_TXUIEN				(1<<6)
+	#define SUNXI_HDMIAUDIOINT_TXOIEN				(1<<5)
+	#define SUNXI_HDMIAUDIOINT_TXEIEN				(1<<4)
+	#define SUNXI_HDMIAUDIOINT_RXDRQEN				(1<<2)
+	#define SUNXI_HDMIAUDIOINT_RXOIEN				(1<<1)
+	#define SUNXI_HDMIAUDIOINT_RXAIEN				(1<<0)
+
+#define SUNXI_HDMIAUDIOISTA   	(0x20)
+	#define SUNXI_HDMIAUDIOISTA_TXUISTA			(1<<6)
+	#define SUNXI_HDMIAUDIOISTA_TXOISTA			(1<<5)
+	#define SUNXI_HDMIAUDIOISTA_TXEISTA			(1<<4)
+	#define SUNXI_HDMIAUDIOISTA_RXOISTA			(1<<1)
+	#define SUNXI_HDMIAUDIOISTA_RXAISTA			(1<<0)
+
+#define SUNXI_HDMIAUDIOCLKD   	(0x24)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKOEN			(1<<7)
+	#define SUNXI_HDMIAUDIOCLKD_BCLKDIV_2		(0<<4)
+	#define SUNXI_HDMIAUDIOCLKD_BCLKDIV_4		(1<<4)
+	#define SUNXI_HDMIAUDIOCLKD_BCLKDIV_6		(2<<4)
+	#define SUNXI_HDMIAUDIOCLKD_BCLKDIV_8		(3<<4)
+	#define SUNXI_HDMIAUDIOCLKD_BCLKDIV_12		(4<<4)
+	#define SUNXI_HDMIAUDIOCLKD_BCLKDIV_16		(5<<4)
+	#define SUNXI_HDMIAUDIOCLKD_BCLKDIV_32		(6<<4)
+	#define SUNXI_HDMIAUDIOCLKD_BCLKDIV_64		(7<<4)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_1		(0<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_2		(1<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_4		(2<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_6		(3<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_8		(4<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_12		(5<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_16		(6<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_24		(7<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_32		(8<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_48		(9<<0)
+	#define SUNXI_HDMIAUDIOCLKD_MCLKDIV_64		(10<<0)
+
+#define SUNXI_HDMIAUDIOTXCNT  	(0x28)
+
+#define SUNXI_HDMIAUDIORXCNT  	(0x2C)
+
+#define SUNXI_TXCHSEL		(0x30)
+	#define SUNXI_TXCHSEL_CHNUM(v)			(((v)-1)<<0)
+
+#define SUNXI_TXCHMAP		(0x34)
+	#define SUNXI_TXCHMAP_CH7(v)			(((v)-1)<<28)
+	#define SUNXI_TXCHMAP_CH6(v)			(((v)-1)<<24)
+	#define SUNXI_TXCHMAP_CH5(v)			(((v)-1)<<20)
+	#define SUNXI_TXCHMAP_CH4(v)			(((v)-1)<<16)
+	#define SUNXI_TXCHMAP_CH3(v)			(((v)-1)<<12)
+	#define SUNXI_TXCHMAP_CH2(v)			(((v)-1)<<8)
+	#define SUNXI_TXCHMAP_CH1(v)			(((v)-1)<<4)
+	#define SUNXI_TXCHMAP_CH0(v)			(((v)-1)<<0)
+
+#define SUNXI_RXCHSEL		(0x38)
+	#define SUNXI_RXCHSEL_CHNUM(v)			(((v)-1)<<0)
+
+#define SUNXI_RXCHMAP		(0x3C)
+	#define SUNXI_RXCHMAP_CH3(v)			(((v)-1)<<12)
+	#define SUNXI_RXCHMAP_CH2(v)			(((v)-1)<<8)
+	#define SUNXI_RXCHMAP_CH1(v)			(((v)-1)<<4)
+	#define SUNXI_RXCHMAP_CH0(v)			(((v)-1)<<0)
+
+
+/* DMA REGISTER */
+#define SUNXI_DMABASE	(0x01C02000)
+
+#define SUNXI_DMAIRQEN						(0x0)
+	#define SUNXI_DMAIRQEN_NDMA_FULLEN(v)				(1<<((v)*2+1))
+	#define SUNXI_DMAIRQEN_NDMA_HALFEN(v)				(1<<((v)*2))
+
+#define SUNXI_DMAIRQPENDING	 		(0x4)
+	#define SUNXI_DMAIRQPENGDING_NDMA_FULLPEND(v)		(1<<((v)*2+1))
+	#define SUNXI_DMAIRQPENGDING_NDMA_HALFPEND(v)		(1<<((v)*2))
+
+#define SUNXI_NDMACFG(v)				((v)*0x20+0x100)
+	#define SUNXI_NDMACFG_DMALOAD					(1<<31)
+	#define SUNXI_NDMACFG_BUSY						(1<<30)
+	#define SUNXI_NDMACFG_CONTINUOUS				(1<<29)
+	#define SUNXI_NDMACFG_WAIT(v)					(((v)-1)<<26)   //wait clock = 2^n  example: 8 clocks = 2^3
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_8BIT		(0<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_16BIT		(1<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_32BIT		(2<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_RVD			(3<<24)
+	#define SUNXI_NDMACFG_DSTBURST4				(1<<23)
+	#define SUNXI_NDMACFG_DSTADDRTYPE_INC			(0<<21)
+	#define SUNXI_NDMACFG_DSTADDRTYPE_CON 			(1<<21)
+	#define SUNXI_NDMACFG_DSTTYPE_IRTX				(0x0<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPDIFTX			(0x1<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_IISTX			(0x2<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_AC97TX			(0x3<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI0TX 			(0x4<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI1TX			(0x5<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI2TX			(0x6<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART0TX			(0x8<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART1TX			(0x9<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART2TX			(0xA<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART3TX			(0xB<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_AUDIODA			(0xC<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_NFC				(0xF<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SRAM				(0x10<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_DRAM				(0x11<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART4TX			(0x12<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART5TX          (0x13<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART6TX			(0x14<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART7TX			(0x15<<16)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_8BIT		(0<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_16BIT		(1<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_32BIT		(2<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_RVD			(3<<8)
+	#define SUNXI_NDMACFG_SRCBURST4				(1<<7)
+	#define SUNXI_NDMACFG_SRCADDRTYPE_INC			(0<<5)
+	#define SUNXI_NDMACFG_SRCADDRTYPE_CON 			(1<<5)
+	#define SUNXI_NDMACFG_SRCTYPE_IRRX				(0x0<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPDIFRX			(0x1<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_IISRX			(0x2<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_AC97RX			(0x3<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI0RX 			(0x4<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI1RX			(0x5<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI2RX			(0x6<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART0RX			(0x8<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART1RX			(0x9<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART2RX			(0xA<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART3RX			(0xB<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_AUDIOAD			(0xC<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_TPAD				(0xD<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_NFC				(0xF<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SRAM				(0x10<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_DRAM				(0x11<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART4RX			(0x12<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART5RX			(0x13<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART6RX			(0x14<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART7RX			(0x15<<0)
+
+#define SUNXI_NDMASRCADDR(v)				((v)*0x20 + 0x100 + 4)
+
+#define SUNXI_NDMADSTADDR(v)				((v)*0x20 + 0x100 + 8)
+
+#define SUNXI_NDMACNT(v)				((v)*0x20 + 0x100 + 0xC)
+
+
+/* CCM REGISTER */
+#define SUNXI_CCMBASE    (0x01C20000)
+
+#define SUNXI_CCM_AUDIO_HOSC_PLL_REG   (0x08)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_AUDIOEN		(1<<31)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_FRE225792MHZ	(0<<27)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_FRE24576MHZ	(1<<27)
+
+#define SUNXI_CCM_APB_GATE_REG    		 (0x68)
+	#define SUNXI_CCM_APB_GATE_REG_IISGATE				(1<<3)
+
+#define SUNXI_CCM_AUDIO_CLK_REG				(0xb8)
+	#define SUNXI_CCM_AUDIO_CLK_REG_IISSPECIALGATE		(1<<31)
+	#define SUNXI_CCM_AUDIO_CLK_REG_DIV(v)					((v)<<16)
+/*------------------------------------------------------------*/
+
+/*------------------------------------------------------------*/
+/* Clock dividers */
+#define SUNXI_DIV_MCLK	0
+#define SUNXI_DIV_BCLK	1
+
+#define SUNXI_HDMIAUDIOCLKD_MCLK_MASK   0x0f
+#define SUNXI_HDMIAUDIOCLKD_MCLK_OFFS   0
+#define SUNXI_HDMIAUDIOCLKD_BCLK_MASK   0x070
+#define SUNXI_HDMIAUDIOCLKD_BCLK_OFFS   4
+#define SUNXI_HDMIAUDIOCLKD_MCLKEN_OFFS 7
+
+unsigned int sunxi_hdmiaudio_get_clockrate(void);
+extern struct sunxi_hdmiaudio_info sunxi_hdmiaudio;
+
+extern void sunxi_snd_txctrl_hdmiaudio(struct snd_pcm_substream *substream, int on);
+extern void sunxi_snd_rxctrl_hdmiaudio(struct snd_pcm_substream *substream, int on);
+
+struct sunxi_hdmiaudio_info {
+	void __iomem   *regs;    /* IIS BASE */
+	void __iomem   *ccmregs;  //CCM BASE
+	void __iomem   *ioregs;   //IO BASE
+
+	u32 slave;					//0: master, 1: slave
+	u32 mono;					//0: stereo, 1: mono
+	u32 samp_fs;				//audio sample rate (unit in kHz)
+	u32 samp_res;			//16 bits, 20 bits , 24 bits, 32 bits)
+	u32 samp_format;		//audio sample format (0: standard I2S, 1: left-justified, 2: right-justified, 3: pcm)
+	u32 ws_size;				//16 BCLK, 20 BCLK, 24 BCLK, 32 BCLK)
+	u32 mclk_rate;			//mclk frequency divide by fs (128fs, 192fs, 256fs, 384fs, 512fs, 768fs)
+	u32 lrc_pol;				//LRC clock polarity (0: normal ,1: inverted)
+	u32 bclk_pol;			//BCLK polarity (0: normal, 1: inverted)
+	u32 pcm_txtype;		//PCM transmitter type (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_rxtype;		//PCM receiver type  (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_sw;				//PCM slot width (8: 8 bits, 16: 16 bits)
+	u32 pcm_sync_period;//PCM sync period (16/32/64/128/256)
+	u32 pcm_sync_type;	//PCM sync symbol size (0: short sync, 1: long sync)
+	u32 pcm_start_slot;//PCM start slot index (1--4)
+	u32 pcm_lsb_first;	//0: MSB first, 1: LSB first
+	u32 pcm_ch_num;		//PCM channel number (1: one channel, 2: two channel)
+
+};
+
+extern struct sunxi_hdmiaudio_info sunxi_hdmiaudio;
+#endif
diff --git a/sound/soc/sunxi/hdmiaudio/sunxi-hdmipcm.c b/sound/soc/sunxi/hdmiaudio/sunxi-hdmipcm.c
new file mode 100644
index 0000000..b62daea
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/sunxi-hdmipcm.c
@@ -0,0 +1,446 @@
+/*
+ * sound\soc\sunxi\hdmiaudio\sunxi-hdmipcm.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <plat/dma_compat.h>
+
+#include "sunxi-hdmiaudio.h"
+#include "sunxi-hdmipcm.h"
+
+static volatile unsigned int dmasrc = 0;
+static volatile unsigned int dmadst = 0;
+
+static const struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				      SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+				      SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,    /* value must be (2^n)Kbyte size */
+	.period_bytes_min	= 1024*4,//1024*4,
+	.period_bytes_max	= 1024*32,//1024*32,
+	.periods_min		= 4,//4,
+	.periods_max		= 8,//8,
+	.fifo_size		= 128,//32,
+};
+
+struct sunxi_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct sunxi_dma_params *params;
+};
+
+static void sunxi_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	dma_addr_t pos = prtd->dma_pos;
+	unsigned int limit;
+	int ret;
+
+	unsigned long len = prtd->dma_period;
+  	limit = prtd->dma_limit;
+  	while(prtd->dma_loaded < limit)
+	{
+		if((pos + len) > prtd->dma_end){
+			len  = prtd->dma_end - pos;
+		}
+
+		ret = sunxi_dma_enqueue(prtd->params, pos, len, 0);
+		if (ret == 0) {
+			prtd->dma_loaded++;
+			pos += prtd->dma_period;
+			if(pos >= prtd->dma_end)
+				pos = prtd->dma_start;
+		}else {
+			break;
+		}
+
+	}
+	prtd->dma_pos = pos;
+}
+
+static void sunxi_audio_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	struct sunxi_runtime_data *prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	prtd = substream->runtime->private_data;
+		if (substream) {
+			snd_pcm_period_elapsed(substream);
+		}
+
+	spin_lock(&prtd->lock);
+	{
+		prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&prtd->lock);
+}
+
+static int sunxi_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	unsigned long totbytes = params_buffer_bytes(params);
+	struct sunxi_dma_params *dma =
+		snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	int ret = 0;
+
+	if (!dma)
+		return 0;
+
+	if (prtd->params == NULL) {
+		prtd->params = dma;
+		ret = sunxi_dma_request(prtd->params, 1);
+		if (ret < 0) {
+				return ret;
+		}
+	}
+
+	if (sunxi_dma_set_callback(prtd->params, sunxi_audio_buffdone,
+							    substream) != 0) {
+		sunxi_dma_release(prtd->params);
+		prtd->params = NULL;
+		return -EINVAL;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	runtime->dma_bytes = totbytes;
+
+	spin_lock_irq(&prtd->lock);
+	prtd->dma_loaded = 0;
+	prtd->dma_limit = runtime->hw.periods_min;
+	prtd->dma_period = params_period_bytes(params);
+	prtd->dma_start = runtime->dma_addr;
+	prtd->dma_pos = prtd->dma_start;
+	prtd->dma_end = prtd->dma_start + totbytes;
+	spin_unlock_irq(&prtd->lock);
+	return 0;
+}
+
+static int sunxi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+
+	if (prtd->params)
+		sunxi_dma_flush(prtd->params);
+
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	if (prtd->params) {
+		sunxi_dma_stop(prtd->params);
+		sunxi_dma_release(prtd->params);
+		prtd->params = NULL;
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	if (!prtd->params)
+		return 0;
+
+   	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+		struct dma_hw_conf codec_dma_conf;
+		codec_dma_conf.drqsrc_type  = DRQ_TYPE_SDRAM;
+		codec_dma_conf.drqdst_type  = DRQ_TYPE_HDMIAUDIO;
+		codec_dma_conf.xfer_type    = DMAXFER_D_BWORD_S_BWORD;
+		codec_dma_conf.address_type = DMAADDRT_D_IO_S_LN;
+		codec_dma_conf.dir          = SW_DMA_WDEV;
+		codec_dma_conf.reload       = 0;
+		codec_dma_conf.hf_irq       = SW_DMA_IRQ_FULL;
+		codec_dma_conf.from         = prtd->dma_start;
+		codec_dma_conf.to           = prtd->params->dma_addr;
+#else
+		dma_config_t codec_dma_conf;
+		memset(&codec_dma_conf, 0, sizeof(codec_dma_conf));
+		codec_dma_conf.xfer_type.src_data_width	= DATA_WIDTH_32BIT;
+		codec_dma_conf.xfer_type.src_bst_len 	= DATA_BRST_4;
+		codec_dma_conf.xfer_type.dst_data_width	= DATA_WIDTH_32BIT;
+		codec_dma_conf.xfer_type.dst_bst_len 	= DATA_BRST_4;
+		codec_dma_conf.address_type.src_addr_mode = DDMA_ADDR_LINEAR;
+		codec_dma_conf.address_type.dst_addr_mode = DDMA_ADDR_IO;
+		codec_dma_conf.src_drq_type		= D_SRC_SDRAM;
+		codec_dma_conf.dst_drq_type		= D_DST_HDMI_AUD;
+		codec_dma_conf.bconti_mode		= false;
+		codec_dma_conf.irq_spt			= CHAN_IRQ_FD;
+#endif
+		ret = sunxi_dma_config(prtd->params, &codec_dma_conf,
+					0x1F071F07);
+	}
+
+	/* flush the DMA channel */
+	prtd->dma_loaded = 0;
+	if (sunxi_dma_flush(prtd->params) == 0)
+		prtd->dma_pos = prtd->dma_start;
+
+	/* enqueue dma buffers */
+	sunxi_pcm_enqueue(substream);
+
+	return ret;
+}
+
+static int sunxi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	int ret ;
+	spin_lock(&prtd->lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/* enqueue dma buffers */
+		sunxi_pcm_enqueue(substream);
+		sunxi_dma_start(prtd->params);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		sunxi_dma_stop(prtd->params);
+		prtd->dma_loaded = 0;
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t sunxi_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	unsigned long res = 0;
+	snd_pcm_uframes_t offset = 0;
+
+	spin_lock(&prtd->lock);
+
+	sunxi_dma_getcurposition(prtd->params, (dma_addr_t*)&dmasrc,
+				 (dma_addr_t*)&dmadst);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		res = dmadst - prtd->dma_start;
+	else
+	{
+		offset = bytes_to_frames(runtime, dmasrc + prtd->dma_period - runtime->dma_addr);
+	}
+	spin_unlock(&prtd->lock);
+
+	if(offset >= runtime->buffer_size)
+		offset = 0;
+		return offset;
+}
+
+static int sunxi_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd;
+
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+
+	prtd = kzalloc(sizeof(struct sunxi_runtime_data), GFP_KERNEL);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&prtd->lock);
+
+	runtime->private_data = prtd;
+	return 0;
+}
+
+static int sunxi_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+
+	kfree(prtd);
+
+	return 0;
+}
+
+static int sunxi_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops sunxi_pcm_ops = {
+	.open				= sunxi_pcm_open,
+	.close			= sunxi_pcm_close,
+	.ioctl			= snd_pcm_lib_ioctl,
+	.hw_params	= sunxi_pcm_hw_params,
+	.hw_free		= sunxi_pcm_hw_free,
+	.prepare		= sunxi_pcm_prepare,
+	.trigger		= sunxi_pcm_trigger,
+	.pointer		= sunxi_pcm_pointer,
+	.mmap				= sunxi_pcm_mmap,
+};
+
+static int sunxi_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = sunxi_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void sunxi_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+static int sunxi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+static struct snd_soc_platform_driver sunxi_soc_platform_hdmiaudio = {
+		.ops        =        &sunxi_pcm_ops,
+		.pcm_new	=		 sunxi_pcm_new,
+		.pcm_free	=		 sunxi_pcm_free_dma_buffers,
+};
+
+static int __devinit sunxi_hdmiaudio_pcm_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &sunxi_soc_platform_hdmiaudio);
+}
+
+static int __devexit sunxi_hdmiaudio_pcm_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver sunxi_hdmiaudio_pcm_driver = {
+	.probe = sunxi_hdmiaudio_pcm_probe,
+	.remove = __devexit_p(sunxi_hdmiaudio_pcm_remove),
+	.driver = {
+		.name = "sunxi-hdmiaudio-pcm-audio",
+		.owner = THIS_MODULE,
+	},
+};
+
+
+static int __init sunxi_soc_platform_hdmiaudio_init(void)
+{
+	int err = 0;
+	if ((err = platform_driver_register(&sunxi_hdmiaudio_pcm_driver)) < 0)
+		return err;
+	return 0;
+}
+module_init(sunxi_soc_platform_hdmiaudio_init);
+
+static void __exit sunxi_soc_platform_hdmiaudio_exit(void)
+{
+	return platform_driver_unregister(&sunxi_hdmiaudio_pcm_driver);
+}
+module_exit(sunxi_soc_platform_hdmiaudio_exit);
+
+MODULE_AUTHOR("All winner");
+MODULE_DESCRIPTION("SUNXI HDMIAUDIO DMA module");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/sunxi/hdmiaudio/sunxi-hdmipcm.h b/sound/soc/sunxi/hdmiaudio/sunxi-hdmipcm.h
new file mode 100644
index 0000000..0649177
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/sunxi-hdmipcm.h
@@ -0,0 +1,25 @@
+/*
+ * sound\soc\sunxi\hdmiaudio\sunxi-hdmipcm.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SUNXI_HDMIPCM_H_
+#define SUNXI_HDMIPCM_H_
+
+enum sunxi_dma_buffresult {
+	SUNXI_RES_OK,
+	SUNXI_RES_ERR,
+	SUNXI_RES_ABORT
+};
+
+#endif //SUNXI_HDMIPCM_H_
diff --git a/sound/soc/sunxi/hdmiaudio/sunxi-sndhdmi.c b/sound/soc/sunxi/hdmiaudio/sunxi-sndhdmi.c
new file mode 100644
index 0000000..c89f760
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/sunxi-sndhdmi.c
@@ -0,0 +1,299 @@
+/*
+ * sound\soc\sunxi\hdmiaudio\sunxi-sndhdmi.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <plat/sys_config.h>
+#include <linux/io.h>
+
+#include "sunxi-hdmiaudio.h"
+#include "sunxi-hdmipcm.h"
+
+#include "sndhdmi.h"
+
+static struct clk *xtal;
+
+static int clk_users;
+static DEFINE_MUTEX(clk_lock);
+
+#ifdef ENFORCE_RATES
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+	.count	= ARRAY_SIZE(rates),
+	.list	= rates,
+	.mask	= 0,
+};
+#endif
+
+static int sunxi_sndhdmi_startup(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	#ifdef ENFORCE_RATES
+		struct snd_pcm_runtime *runtime = substream->runtime;;
+	#endif
+	mutex_lock(&clk_lock);
+	mutex_unlock(&clk_lock);
+	if (!ret) {
+	#ifdef ENFORCE_RATES
+		ret = snd_pcm_hw_constraint_list(runtime, 0,
+						 SNDRV_PCM_HW_PARAM_RATE,
+						 &hw_constraints_rates);
+		if (ret < 0)
+
+	#endif
+	}
+	return ret;
+}
+
+static void sunxi_sndhdmi_shutdown(struct snd_pcm_substream *substream)
+{
+	mutex_lock(&clk_lock);
+	clk_users -= 1;
+	if (clk_users == 0) {
+		clk_put(xtal);
+		xtal = NULL;
+	}
+	mutex_unlock(&clk_lock);
+}
+
+typedef struct __MCLK_SET_INF
+{
+    __u32       samp_rate;      // sample rate
+    __u16       mult_fs;        // multiply of smaple rate
+
+    __u8        clk_div;        // mpll division
+    __u8        mpll;           // select mpll, 0 - 24.576 Mhz, 1 - 22.5792 Mhz
+
+} __mclk_set_inf;
+
+typedef struct __BCLK_SET_INF
+{
+    __u8        bitpersamp;     // bits per sample
+    __u8        clk_div;        // clock division
+    __u16       mult_fs;        // multiplay of sample rate
+
+} __bclk_set_inf;
+
+//bclk divider table
+static __bclk_set_inf BCLK_INF[] =
+{
+    // 16bits per sample
+    {16,  4, 128}, {16,  6, 192}, {16,  8, 256},
+    {16, 12, 384}, {16, 16, 512},
+
+    //24 bits per sample
+    {24,  4, 192}, {24,  8, 384}, {24, 16, 768},
+
+    //32 bits per sample
+    {32,  2, 128}, {32,  4, 256}, {32,  6, 384},
+    {32,  8, 512}, {32, 12, 768},
+
+    //end flag
+    {0xff, 0, 0},
+};
+
+//mclk divider table
+static __mclk_set_inf  MCLK_INF[] =
+{
+    // 8k bitrate
+    {  8000, 128, 24, 0}, {  8000, 192, 16, 0}, {  8000, 256, 12, 0},
+    {  8000, 384,  8, 0}, {  8000, 512,  6, 0}, {  8000, 768,  4, 0},
+
+    // 16k bitrate
+    { 16000, 128, 12, 0}, { 16000, 192,  8, 0}, { 16000, 256,  6, 0},
+    { 16000, 384,  4, 0}, { 16000, 768,  2, 0},
+
+    // 32k bitrate
+    { 32000, 128,  6, 0}, { 32000, 192,  4, 0}, { 32000, 384,  2, 0},
+    { 32000, 768,  1, 0},
+
+    // 64k bitrate
+    { 64000, 192,  2, 0}, { 64000, 384,  1, 0},
+
+    //128k bitrate
+    {128000, 192,  1, 0},
+
+    // 12k bitrate
+    { 12000, 128, 16, 0}, { 12000, 256, 8, 0}, { 12000, 512, 4, 0},
+
+    // 24k bitrate
+    { 24000, 128,  8, 0}, { 24000, 256, 4, 0}, { 24000, 512, 2, 0},
+
+    // 48K bitrate
+    { 48000, 128,  4, 0}, { 48000, 256,  2, 0}, { 48000, 512, 1, 0},
+
+    // 96k bitrate
+    { 96000, 128 , 2, 0}, { 96000, 256,  1, 0},
+
+    //192k bitrate
+    {192000, 128,  1, 0},
+
+    //11.025k bitrate
+    { 11025, 128, 16, 1}, { 11205, 256,  8, 1}, { 11205, 512,  4, 1},
+
+    //22.05k bitrate
+    { 22050, 128,  8, 1}, { 22050, 256,  4, 1},
+    { 22050, 512,  2, 1},
+
+    //44.1k bitrate
+    { 44100, 128,  4, 1}, { 44100, 256,  2, 1}, { 44100, 512,  1, 1},
+
+    //88.2k bitrate
+    { 88200, 128,  2, 1}, { 88200, 256,  1, 1},
+
+    //176.4k bitrate
+    {176400, 128, 1, 1},
+
+    //end flag 0xffffffff
+    {0xffffffff, 0, 0, 0},
+};
+
+static s32 get_clock_divder(u32 sample_rate, u32 sample_width, u32 * mclk_div,
+                            u32* mpll, u32* bclk_div, u32* mult_fs)
+{
+	u32 i, j, ret = -EINVAL;
+
+	for(i=0; i< 100; i++) {
+		 if((MCLK_INF[i].samp_rate == sample_rate) &&
+		 	((MCLK_INF[i].mult_fs == 256) || (MCLK_INF[i].mult_fs == 128))) {
+			  for(j=0; j<ARRAY_SIZE(BCLK_INF); j++) {
+					if((BCLK_INF[j].bitpersamp == sample_width) &&
+						(BCLK_INF[j].mult_fs == MCLK_INF[i].mult_fs)) {
+						 //set mclk and bclk division
+						 *mclk_div = MCLK_INF[i].clk_div;
+						 *mpll = MCLK_INF[i].mpll;
+						 *bclk_div = BCLK_INF[j].clk_div;
+						 *mult_fs = MCLK_INF[i].mult_fs;
+						 ret = 0;
+						 break;
+					}
+			  }
+		 }else if(MCLK_INF[i].samp_rate == 0xffffffff)
+		 	break;
+	}
+
+	return ret;
+}
+
+static int sunxi_sndhdmi_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret = 0;
+	unsigned long rate = params_rate(params);
+	u32 mclk_div=0, mpll=0, bclk_div=0, mult_fs=0;
+
+	get_clock_divder(rate, 32, &mclk_div, &mpll, &bclk_div, &mult_fs);
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0 , mpll, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0 , mpll, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_MCLK, mclk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_BCLK, bclk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, 0, mult_fs);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sndhdmi_ops = {
+	.startup 	= sunxi_sndhdmi_startup,
+	.shutdown 	= sunxi_sndhdmi_shutdown,
+	.hw_params 	= sunxi_sndhdmi_hw_params,
+};
+
+static struct snd_soc_dai_link sunxi_sndhdmi_dai_link = {
+	.name 			= "HDMIAUDIO",
+	.stream_name 	= "SUNXI-HDMIAUDIO",
+	.cpu_dai_name 	= "sunxi-hdmiaudio.0",
+	.codec_dai_name = "sndhdmi",
+	.platform_name 	= "sunxi-hdmiaudio-pcm-audio.0",
+	.codec_name 	= "sunxi-hdmiaudio-codec.0",
+	.ops 			= &sunxi_sndhdmi_ops,
+};
+
+static struct snd_soc_card snd_soc_sunxi_sndhdmi = {
+	.name 		= "sunxi-sndhdmi",
+	.owner		= THIS_MODULE,
+	.dai_link 	= &sunxi_sndhdmi_dai_link,
+	.num_links 	= 1,
+};
+
+static int __devinit sunxi_sndhdmi_probe(struct platform_device *pdev)
+{
+	snd_soc_sunxi_sndhdmi.dev = &pdev->dev;
+	return snd_soc_register_card(&snd_soc_sunxi_sndhdmi);
+}
+
+static int __devexit sunxi_sndhdmi_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_card(&snd_soc_sunxi_sndhdmi);
+	return 0;
+}
+
+static struct platform_driver sunxi_sndhdmi_driver = {
+	.probe = sunxi_sndhdmi_probe,
+	.remove = __devexit_p(sunxi_sndhdmi_remove),
+	.driver = {
+		.name = "sunxi-sndhdmi",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_sndhdmi_init(void)
+{
+	return platform_driver_register(&sunxi_sndhdmi_driver);
+}
+
+static void __exit sunxi_sndhdmi_exit(void)
+{
+	platform_driver_unregister(&sunxi_sndhdmi_driver);
+}
+
+module_init(sunxi_sndhdmi_init);
+module_exit(sunxi_sndhdmi_exit);
+
+MODULE_AUTHOR("ALL WINNER");
+MODULE_DESCRIPTION("SUNXI_SNDHDMI ALSA SoC audio driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/hdmiaudio/sunxi-sndhdmi.h b/sound/soc/sunxi/hdmiaudio/sunxi-sndhdmi.h
new file mode 100644
index 0000000..341aee9
--- /dev/null
+++ b/sound/soc/sunxi/hdmiaudio/sunxi-sndhdmi.h
@@ -0,0 +1,26 @@
+/*
+ * sound\soc\sunxi\hdmiaudio\sunxi-sndhdmi.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SUNXI_SNDHDMI_H_
+#define SUNXI_SNDHDMI_H_
+
+struct sunxi_sndhdmi_platform_data {
+	int hdmiaudio_bclk;
+	int hdmiaudio_ws;
+	int hdmiaudio_data;
+	void (*power)(int);
+	int model;
+}
+#endif
diff --git a/sound/soc/sunxi/i2s/Kconfig b/sound/soc/sunxi/i2s/Kconfig
new file mode 100644
index 0000000..1783f16
--- /dev/null
+++ b/sound/soc/sunxi/i2s/Kconfig
@@ -0,0 +1,8 @@
+
+config SND_SUNXI_SOC_I2S_INTERFACE
+	tristate "SoC i2s interface for the AllWinner sun4i and sun5i chips"
+	default n
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the SUNXI AC97, I2S or PCM interface. You will also need
+	  to select the audio interfaces to support below.
diff --git a/sound/soc/sunxi/i2s/Makefile b/sound/soc/sunxi/i2s/Makefile
new file mode 100644
index 0000000..8025776
--- /dev/null
+++ b/sound/soc/sunxi/i2s/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += sunxi-i2s.o
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += sunxi-i2sdma.o
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += sndi2s.o
+obj-$(CONFIG_SND_SUNXI_SOC_I2S_INTERFACE) += sunxi-sndi2s.o
+
diff --git a/sound/soc/sunxi/i2s/sndi2s.c b/sound/soc/sunxi/i2s/sndi2s.c
new file mode 100644
index 0000000..68bad02
--- /dev/null
+++ b/sound/soc/sunxi/i2s/sndi2s.c
@@ -0,0 +1,206 @@
+/*
+ * sound\soc\sunxi\i2s\sndi2s.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <plat/sys_config.h>
+#include <linux/io.h>
+
+#include "sndi2s.h"
+
+struct sndi2s_priv {
+	int sysclk;
+	int dai_fmt;
+
+	struct snd_pcm_substream *master_substream;
+	struct snd_pcm_substream *slave_substream;
+};
+
+static int i2s_used = 0;
+#define sndi2s_RATES  (SNDRV_PCM_RATE_8000_192000|SNDRV_PCM_RATE_KNOT)
+#define sndi2s_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | \
+		                     SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S20_3LE)
+
+hdmi_audio_t hdmi_parameter;
+
+static int sndi2s_mute(struct snd_soc_dai *dai, int mute)
+{
+	return 0;
+}
+
+static int sndi2s_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void sndi2s_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+
+}
+
+static int sndi2s_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params,
+	struct snd_soc_dai *dai)
+{
+	hdmi_parameter.sample_rate = params_rate(params);
+
+	return 0;
+}
+
+static int sndi2s_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int sndi2s_set_dai_clkdiv(struct snd_soc_dai *codec_dai, int div_id, int div)
+{
+
+	hdmi_parameter.fs_between = div;
+
+	return 0;
+}
+
+static int sndi2s_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int fmt)
+{
+	return 0;
+}
+
+struct snd_soc_dai_ops sndi2s_dai_ops = {
+	.startup = sndi2s_startup,
+	.shutdown = sndi2s_shutdown,
+	.hw_params = sndi2s_hw_params,
+	.digital_mute = sndi2s_mute,
+	.set_sysclk = sndi2s_set_dai_sysclk,
+	.set_clkdiv = sndi2s_set_dai_clkdiv,
+	.set_fmt = sndi2s_set_dai_fmt,
+};
+
+struct snd_soc_dai_driver sndi2s_dai = {
+	.name = "sndi2s",
+	/* playback capabilities */
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = sndi2s_RATES,
+		.formats = sndi2s_FORMATS,
+	},
+	/* pcm operations */
+	.ops = &sndi2s_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL(sndi2s_dai);
+
+static int sndi2s_soc_probe(struct snd_soc_codec *codec)
+{
+	struct sndi2s_priv *sndi2s;
+
+	sndi2s = kzalloc(sizeof(struct sndi2s_priv), GFP_KERNEL);
+	if(sndi2s == NULL){
+		return -ENOMEM;
+	}
+	snd_soc_codec_set_drvdata(codec, sndi2s);
+
+	return 0;
+}
+
+/* power down chip */
+static int sndi2s_soc_remove(struct snd_soc_codec *codec)
+{
+	struct sndhdmi_priv *sndi2s = snd_soc_codec_get_drvdata(codec);
+
+	kfree(sndi2s);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_sndi2s = {
+	.probe 	=	sndi2s_soc_probe,
+	.remove =   sndi2s_soc_remove,
+};
+
+static int __devinit sndi2s_codec_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_sndi2s, &sndi2s_dai, 1);
+}
+
+static int __devexit sndi2s_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+/*data relating*/
+static struct platform_device sndi2s_codec_device = {
+	.name = "sunxi-i2s-codec",
+};
+
+/*method relating*/
+static struct platform_driver sndi2s_codec_driver = {
+	.driver = {
+		.name = "sunxi-i2s-codec",
+		.owner = THIS_MODULE,
+	},
+	.probe = sndi2s_codec_probe,
+	.remove = __devexit_p(sndi2s_codec_remove),
+};
+
+static int __init sndi2s_codec_init(void)
+{
+	int err = 0;
+	int ret = 0;
+
+	ret = script_parser_fetch("i2s_para","i2s_used", &i2s_used, sizeof(int));
+	if (ret) {
+        printk("[I2S]sndi2s_init fetch i2s using configuration failed\n");
+    }
+
+	if (i2s_used) {
+		if((err = platform_device_register(&sndi2s_codec_device)) < 0)
+			return err;
+
+		if ((err = platform_driver_register(&sndi2s_codec_driver)) < 0)
+			return err;
+	} else {
+       printk("[I2S]sndi2s cannot find any using configuration for controllers, return directly!\n");
+       return 0;
+    }
+
+	return 0;
+}
+module_init(sndi2s_codec_init);
+
+static void __exit sndi2s_codec_exit(void)
+{
+	if (i2s_used) {
+		i2s_used = 0;
+		platform_driver_unregister(&sndi2s_codec_driver);
+	}
+}
+module_exit(sndi2s_codec_exit);
+
+MODULE_DESCRIPTION("SNDI2S ALSA soc codec driver");
+MODULE_AUTHOR("Zoltan Devai, Christian Pellegrin <chripell@evolware.org>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-i2s-codec");
diff --git a/sound/soc/sunxi/i2s/sndi2s.h b/sound/soc/sunxi/i2s/sndi2s.h
new file mode 100644
index 0000000..e5b95c8
--- /dev/null
+++ b/sound/soc/sunxi/i2s/sndi2s.h
@@ -0,0 +1,58 @@
+/*
+ * sound\soc\sunxi\i2s\sndi2s.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SNDI2S_H_
+#define SNDI2S_H_
+
+typedef struct hdmi_audio
+{
+	__u8    hw_intf;        /* 0:iis  1:spdif 2:pcm */
+	__u16	fs_between;     /* fs */
+	__u32   sample_rate;    /*sample rate*/
+	__u8    clk_edge;       /* 0:*/
+	__u8    ch0_en;         /* 1 */
+	__u8    ch1_en;         /* 0 */
+	__u8 	ch2_en;         /* 0 */
+	__u8 	ch3_en;         /* 0 */
+	__u8	word_length;    /* 32 */
+	__u8    shift_ctl;      /* 0 */
+	__u8    dir_ctl;        /* 0 */
+	__u8    ws_pol;
+	__u8    just_pol;
+}hdmi_audio_t;
+
+
+typedef struct
+{
+    __s32 (*hdmi_audio_enable)(__u8 mode, __u8 channel);
+    __s32 (*hdmi_set_audio_para)(hdmi_audio_t * audio_para);
+}__audio_hdmi_func;
+
+
+/*define display driver command*/
+typedef enum tag_HDMI_CMD
+{
+    /* command cache on/off                         */
+		HDMI_CMD_SET_VIDEO_MOD,
+		HDMI_CMD_GET_VIDEO_MOD,
+		HDMI_CMD_SET_AUDIO_PARA,
+		HDMI_CMD_AUDIO_RESET_NOTIFY,            /*iis reset finish notify    */
+		HDMI_CMD_CLOSE,                         /*iis reset finish notify    */
+		HDMI_CMD_MOD_SUPPORT,                   /*判断某一种hdmi模式是否支持*/
+		HDMI_CMD_AUDIO_ENABLE,
+		HDMI_CMD_GET_HPD_STATUS,
+}__hdmi_cmd_t;
+
+#endif
diff --git a/sound/soc/sunxi/i2s/sunxi-i2s.c b/sound/soc/sunxi/i2s/sunxi-i2s.c
new file mode 100644
index 0000000..b4dd3ad
--- /dev/null
+++ b/sound/soc/sunxi/i2s/sunxi-i2s.c
@@ -0,0 +1,712 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2s.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/clock.h>
+#include <plat/system.h>
+#include <plat/sys_config.h>
+
+#include <mach/hardware.h>
+#include <asm/dma.h>
+#include <plat/dma_compat.h>
+
+#include "sunxi-i2sdma.h"
+#include "sunxi-i2s.h"
+
+static int regsave[8];
+static int i2s_used = 0;
+
+static struct sunxi_dma_params sunxi_i2s_pcm_stereo_out = {
+	.client.name	=	"I2S PCM Stereo out",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	=	DMACH_NIIS,
+#endif
+	.dma_addr 	=	SUNXI_IISBASE + SUNXI_IISTXFIFO,
+};
+
+static struct sunxi_dma_params sunxi_i2s_pcm_stereo_in = {
+	.client.name	=	"I2S PCM Stereo in",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	=	DMACH_NIIS,
+#endif
+	.dma_addr 	=	SUNXI_IISBASE + SUNXI_IISRXFIFO,
+};
+
+
+ struct sunxi_i2s_info sunxi_iis;
+static u32 i2s_handle = 0;
+ static struct clk *i2s_apbclk, *i2s_pll2clk, *i2s_pllx8, *i2s_moduleclk;
+
+void sunxi_snd_txctrl_i2s(struct snd_pcm_substream *substream, int on)
+{
+	u32 reg_val;
+
+	reg_val = readl(sunxi_iis.regs + SUNXI_TXCHSEL);
+	reg_val &= ~0x7;
+	reg_val |= SUNXI_TXCHSEL_CHNUM(substream->runtime->channels);
+	writel(reg_val, sunxi_iis.regs + SUNXI_TXCHSEL);
+
+	reg_val = readl(sunxi_iis.regs + SUNXI_TXCHMAP);
+	reg_val = 0;
+	if (sunxi_is_sun4i()) {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x76543200;
+		} else {
+			reg_val = 0x76543210;
+		}
+	} else {
+		if(substream->runtime->channels == 1) {
+			reg_val = 0x00000000;
+		} else {
+			reg_val = 0x00000010;
+		}
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_TXCHMAP);
+
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	if (sunxi_is_sun4i()) {
+		reg_val &= ~SUNXI_IISCTL_SDO3EN;
+		reg_val &= ~SUNXI_IISCTL_SDO2EN;
+		reg_val &= ~SUNXI_IISCTL_SDO1EN;
+		reg_val &= ~SUNXI_IISCTL_SDO0EN;
+		switch(substream->runtime->channels) {
+			case 1:
+			case 2:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				break;
+			case 3:
+			case 4:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				break;
+			case 5:
+			case 6:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				reg_val |= SUNXI_IISCTL_SDO2EN;
+				break;
+			case 7:
+			case 8:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+				reg_val |= SUNXI_IISCTL_SDO1EN;
+				reg_val |= SUNXI_IISCTL_SDO2EN;
+				reg_val |= SUNXI_IISCTL_SDO3EN;
+				break;
+			default:
+				reg_val |= SUNXI_IISCTL_SDO0EN;
+		}
+	} else {
+		reg_val |= SUNXI_IISCTL_SDO0EN;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	//flush TX FIFO
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISFCTL);
+	reg_val |= SUNXI_IISFCTL_FTX;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFCTL);
+
+	//clear TX counter
+	writel(0, sunxi_iis.regs + SUNXI_IISTXCNT);
+
+	if (on) {
+		/* IIS TX ENABLE */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val |= SUNXI_IISCTL_TXEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+		/* enable DMA DRQ mode for play */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
+		reg_val |= SUNXI_IISINT_TXDRQEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
+
+		//Global Enable Digital Audio Interface
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val |= SUNXI_IISCTL_GEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	} else {
+		/* IIS TX DISABLE */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val &= ~SUNXI_IISCTL_TXEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+		/* DISBALE dma DRQ mode */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
+		reg_val &= ~SUNXI_IISINT_TXDRQEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
+
+		//Global disable Digital Audio Interface
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val &= ~SUNXI_IISCTL_GEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+	}
+}
+
+void sunxi_snd_rxctrl_i2s(int on)
+{
+	u32 reg_val;
+
+	//flush RX FIFO
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISFCTL);
+	reg_val |= SUNXI_IISFCTL_FRX;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFCTL);
+
+	//clear RX counter
+	writel(0, sunxi_iis.regs + SUNXI_IISRXCNT);
+
+	if (on) {
+		/* IIS RX ENABLE */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val |= SUNXI_IISCTL_RXEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+		/* enable DMA DRQ mode for record */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
+		reg_val |= SUNXI_IISINT_RXDRQEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
+
+		//Global Enable Digital Audio Interface
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val |= SUNXI_IISCTL_GEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	} else {
+		/* IIS RX DISABLE */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val &= ~SUNXI_IISCTL_RXEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+		/* DISBALE dma DRQ mode */
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISINT);
+		reg_val &= ~SUNXI_IISINT_RXDRQEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISINT);
+
+		//Global disable Digital Audio Interface
+		reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+		reg_val &= ~SUNXI_IISCTL_GEN;
+		writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+	}
+}
+
+static inline int sunxi_snd_is_clkmaster(void)
+{
+	return ((readl(sunxi_iis.regs + SUNXI_IISCTL) & SUNXI_IISCTL_MS) ? 0 : 1);
+}
+
+static int sunxi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	u32 reg_val;
+	u32 reg_val1;
+
+	//SDO ON
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	if (sunxi_is_sun4i()) {
+		reg_val |= (SUNXI_IISCTL_SDO0EN | SUNXI_IISCTL_SDO1EN |
+			    SUNXI_IISCTL_SDO2EN | SUNXI_IISCTL_SDO3EN);
+	} else {
+		reg_val |= SUNXI_IISCTL_SDO0EN;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	/* master or slave selection */
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	switch(fmt & SND_SOC_DAIFMT_MASTER_MASK){
+		case SND_SOC_DAIFMT_CBM_CFM:   /* codec clk & frm master */
+			reg_val |= SUNXI_IISCTL_MS;
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:   /* codec clk & frm slave */
+			reg_val &= ~SUNXI_IISCTL_MS;
+			break;
+		default:
+			return -EINVAL;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	/* pcm or i2s mode selection */
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	reg_val1 = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	reg_val1 &= ~SUNXI_IISFAT0_FMT_RVD;
+	switch(fmt & SND_SOC_DAIFMT_FORMAT_MASK){
+		case SND_SOC_DAIFMT_I2S:        /* I2S mode */
+			reg_val &= ~SUNXI_IISCTL_PCM;
+			reg_val1 |= SUNXI_IISFAT0_FMT_I2S;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:    /* Right Justified mode */
+			reg_val &= ~SUNXI_IISCTL_PCM;
+			reg_val1 |= SUNXI_IISFAT0_FMT_RGT;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:     /* Left Justified mode */
+			reg_val &= ~SUNXI_IISCTL_PCM;
+			reg_val1 |= SUNXI_IISFAT0_FMT_LFT;
+			break;
+		case SND_SOC_DAIFMT_DSP_A:      /* L data msb after FRM LRC */
+			reg_val |= SUNXI_IISCTL_PCM;
+			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
+			break;
+		case SND_SOC_DAIFMT_DSP_B:      /* L data msb during FRM LRC */
+			reg_val |= SUNXI_IISCTL_PCM;
+			reg_val1 |= SUNXI_IISFAT0_LRCP;
+			break;
+		default:
+			return -EINVAL;
+	}
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+	writel(reg_val1, sunxi_iis.regs + SUNXI_IISFAT0);
+
+	/* DAI signal inversions */
+	reg_val1 = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	switch(fmt & SND_SOC_DAIFMT_INV_MASK){
+		case SND_SOC_DAIFMT_NB_NF:     /* normal bit clock + frame */
+			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
+			reg_val1 &= ~SUNXI_IISFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_NB_IF:     /* normal bclk + inv frm */
+			reg_val1 |= SUNXI_IISFAT0_LRCP;
+			reg_val1 &= ~SUNXI_IISFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:     /* invert bclk + nor frm */
+			reg_val1 &= ~SUNXI_IISFAT0_LRCP;
+			reg_val1 |= SUNXI_IISFAT0_BCP;
+			break;
+		case SND_SOC_DAIFMT_IB_IF:     /* invert bclk + frm */
+			reg_val1 |= SUNXI_IISFAT0_LRCP;
+			reg_val1 |= SUNXI_IISFAT0_BCP;
+			break;
+	}
+	writel(reg_val1, sunxi_iis.regs + SUNXI_IISFAT0);
+
+	/* word select size */
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	reg_val &= ~SUNXI_IISFAT0_WSS_32BCLK;
+	if(sunxi_iis.ws_size == 16)
+		reg_val |= SUNXI_IISFAT0_WSS_16BCLK;
+	else if(sunxi_iis.ws_size == 20)
+		reg_val |= SUNXI_IISFAT0_WSS_20BCLK;
+	else if(sunxi_iis.ws_size == 24)
+		reg_val |= SUNXI_IISFAT0_WSS_24BCLK;
+	else
+		reg_val |= SUNXI_IISFAT0_WSS_32BCLK;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFAT0);
+
+	/* PCM REGISTER setup */
+	reg_val = sunxi_iis.pcm_txtype&0x3;
+	reg_val |= sunxi_iis.pcm_rxtype<<2;
+
+	if(!sunxi_iis.pcm_sync_type)
+		reg_val |= SUNXI_IISFAT1_SSYNC;							//short sync
+	if(sunxi_iis.pcm_sw == 16)
+		reg_val |= SUNXI_IISFAT1_SW;
+
+	reg_val |=((sunxi_iis.pcm_start_slot - 1)&0x3)<<6;		//start slot index
+
+	reg_val |= sunxi_iis.pcm_lsb_first<<9;			//MSB or LSB first
+
+	if(sunxi_iis.pcm_sync_period == 256)
+		reg_val |= 0x4<<12;
+	else if (sunxi_iis.pcm_sync_period == 128)
+		reg_val |= 0x3<<12;
+	else if (sunxi_iis.pcm_sync_period == 64)
+		reg_val |= 0x2<<12;
+	else if (sunxi_iis.pcm_sync_period == 32)
+		reg_val |= 0x1<<12;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFAT1);
+
+	/* set FIFO control register */
+	reg_val = 0 & 0x3;
+	reg_val |= (1 & 0x1)<<2;
+	reg_val |= SUNXI_IISFCTL_RXTL(0xf);				//RX FIFO trigger level
+	reg_val |= SUNXI_IISFCTL_TXTL(0x40);				//TX FIFO empty trigger level
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISFCTL);
+	return 0;
+}
+
+static int sunxi_i2s_hw_params(struct snd_pcm_substream *substream,
+																struct snd_pcm_hw_params *params,
+																struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sunxi_dma_params *dma_data;
+
+	/* play or record */
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &sunxi_i2s_pcm_stereo_out;
+	else
+		dma_data = &sunxi_i2s_pcm_stereo_in;
+
+	snd_soc_dai_set_dma_data(rtd->cpu_dai, substream, dma_data);
+	return 0;
+}
+
+static int sunxi_i2s_trigger(struct snd_pcm_substream *substream,
+                              int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sunxi_dma_params *dma_data =
+					snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(1);
+			} else {
+				sunxi_snd_txctrl_i2s(substream, 1);
+			}
+			sunxi_dma_started(dma_data);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl_i2s(0);
+			} else {
+			  sunxi_snd_txctrl_i2s(substream, 0);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	return ret;
+}
+
+//freq:   1: 22.5792MHz   0: 24.576MHz
+static int sunxi_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,
+                                 unsigned int freq, int dir)
+{
+	if (!freq) {
+		clk_set_rate(i2s_pll2clk, 24576000);
+	} else {
+		clk_set_rate(i2s_pll2clk, 22579200);
+	}
+
+	return 0;
+}
+
+static int sunxi_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id, int div)
+{
+	u32 reg;
+	switch (div_id) {
+		case SUNXI_DIV_MCLK:
+			if(div <= 8)
+				div  = (div >>1);
+			else if(div  == 12)
+				div  = 0x5;
+			else if(div  == 16)
+				div  = 0x6;
+			else if(div == 24)
+				div = 0x7;
+			else if(div == 32)
+				div = 0x8;
+			else if(div == 48)
+				div = 0x9;
+			else if(div == 64)
+				div = 0xa;
+			reg = (readl(sunxi_iis.regs + SUNXI_IISCLKD) & ~SUNXI_IISCLKD_MCLK_MASK) | (div << SUNXI_IISCLKD_MCLK_OFFS);
+			writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+			break;
+		case SUNXI_DIV_BCLK:
+			if(div <= 8)
+				div = (div>>1) - 1;
+			else if(div == 12)
+				div = 0x4;
+			else if(div == 16)
+				div = 0x5;
+			else if(div == 32)
+				div = 0x6;
+			else if(div == 64)
+				div = 0x7;
+			reg = (readl(sunxi_iis.regs + SUNXI_IISCLKD) & ~SUNXI_IISCLKD_BCLK_MASK) | (div <<SUNXI_IISCLKD_BCLK_OFFS);
+			writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	//diable MCLK output when high samplerate
+	reg = readl(sunxi_iis.regs + SUNXI_IISCLKD);
+	if (!(reg & 0xF)) {
+		reg &= ~SUNXI_IISCLKD_MCLKOEN;
+		writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+	} else {
+		reg |= SUNXI_IISCLKD_MCLKOEN;
+		writel(reg, sunxi_iis.regs + SUNXI_IISCLKD);
+	}
+
+	return 0;
+}
+
+static int sunxi_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+static int sunxi_i2s_dai_remove(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void iisregsave(void)
+{
+	regsave[0] = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	regsave[1] = readl(sunxi_iis.regs + SUNXI_IISFAT0);
+	regsave[2] = readl(sunxi_iis.regs + SUNXI_IISFAT1);
+	regsave[3] = readl(sunxi_iis.regs + SUNXI_IISFCTL) | (0x3<<24);
+	regsave[4] = readl(sunxi_iis.regs + SUNXI_IISINT);
+	regsave[5] = readl(sunxi_iis.regs + SUNXI_IISCLKD);
+	regsave[6] = readl(sunxi_iis.regs + SUNXI_TXCHSEL);
+	regsave[7] = readl(sunxi_iis.regs + SUNXI_TXCHMAP);
+}
+
+static void iisregrestore(void)
+{
+	writel(regsave[0], sunxi_iis.regs + SUNXI_IISCTL);
+	writel(regsave[1], sunxi_iis.regs + SUNXI_IISFAT0);
+	writel(regsave[2], sunxi_iis.regs + SUNXI_IISFAT1);
+	writel(regsave[3], sunxi_iis.regs + SUNXI_IISFCTL);
+	writel(regsave[4], sunxi_iis.regs + SUNXI_IISINT);
+	writel(regsave[5], sunxi_iis.regs + SUNXI_IISCLKD);
+	writel(regsave[6], sunxi_iis.regs + SUNXI_TXCHSEL);
+	writel(regsave[7], sunxi_iis.regs + SUNXI_TXCHMAP);
+}
+
+static int sunxi_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	u32 reg_val;
+	printk("[IIS]Entered %s\n", __func__);
+
+	//Global Enable Digital Audio Interface
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	reg_val &= ~SUNXI_IISCTL_GEN;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	iisregsave();
+
+	//release the module clock
+	clk_disable(i2s_moduleclk);
+
+	clk_disable(i2s_apbclk);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+static int sunxi_i2s_resume(struct snd_soc_dai *cpu_dai)
+{
+	u32 reg_val;
+	printk("[IIS]Entered %s\n", __func__);
+
+	//release the module clock
+	clk_enable(i2s_apbclk);
+
+	//release the module clock
+	clk_enable(i2s_moduleclk);
+
+	iisregrestore();
+
+	//Global Enable Digital Audio Interface
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	reg_val |= SUNXI_IISCTL_GEN;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	//printk("[IIS]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[IIS]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[IIS]SPECIAL CLK 0x01c200B8 = %#x, line = %d\n", *(volatile int*)0xF1C200B8, __LINE__);
+
+	return 0;
+}
+
+#define SUNXI_I2S_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_iis_dai_ops = {
+	.trigger 	= sunxi_i2s_trigger,
+	.hw_params 	= sunxi_i2s_hw_params,
+	.set_fmt 	= sunxi_i2s_set_fmt,
+	.set_clkdiv = sunxi_i2s_set_clkdiv,
+	.set_sysclk = sunxi_i2s_set_sysclk,
+};
+
+static struct snd_soc_dai_driver sunxi_iis_dai = {
+	.probe 		= sunxi_i2s_dai_probe,
+	.suspend 	= sunxi_i2s_suspend,
+	.resume 	= sunxi_i2s_resume,
+	.remove 	= sunxi_i2s_dai_remove,
+	.playback 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture 	= {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_I2S_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.symmetric_rates = 1,
+	.ops 		= &sunxi_iis_dai_ops,
+};
+
+static int __devinit sunxi_i2s_dev_probe(struct platform_device *pdev)
+{
+	int reg_val = 0;
+	int ret;
+
+	sunxi_iis.regs = ioremap(SUNXI_IISBASE, 0x100);
+	if (sunxi_iis.regs == NULL)
+		return -ENXIO;
+
+	//i2s apbclk
+	i2s_apbclk = clk_get(NULL, "apb_i2s");
+	if(-1 == clk_enable(i2s_apbclk)){
+		printk("i2s_apbclk failed! line = %d\n", __LINE__);
+		goto out;
+	}
+
+	i2s_pllx8 = clk_get(NULL, "audio_pllx8");
+
+	//i2s pll2clk
+	i2s_pll2clk = clk_get(NULL, "audio_pll");
+
+	//i2s module clk
+	i2s_moduleclk = clk_get(NULL, "i2s");
+
+	if(clk_set_parent(i2s_moduleclk, i2s_pll2clk)){
+		printk("try to set parent of i2s_moduleclk to i2s_pll2ck failed! line = %d\n",__LINE__);
+		goto out1;
+	}
+
+	if(clk_set_rate(i2s_moduleclk, 24576000/8)){
+		printk("set i2s_moduleclk clock freq to 24576000 failed! line = %d\n", __LINE__);
+		goto out1;
+	}
+
+	if(-1 == clk_enable(i2s_moduleclk)){
+		printk("open i2s_moduleclk failed! line = %d\n", __LINE__);
+		goto out1;
+	}
+
+	reg_val = readl(sunxi_iis.regs + SUNXI_IISCTL);
+	reg_val |= SUNXI_IISCTL_GEN;
+	writel(reg_val, sunxi_iis.regs + SUNXI_IISCTL);
+
+	iounmap(sunxi_iis.ioregs);
+	ret = snd_soc_register_dai(&pdev->dev, &sunxi_iis_dai);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register DAI\n");
+		goto out2;
+	}
+
+	goto out;
+	out2:
+		clk_disable(i2s_moduleclk);
+	out1:
+		clk_disable(i2s_apbclk);
+	out:
+	return 0;
+}
+
+static int __devexit sunxi_i2s_dev_remove(struct platform_device *pdev)
+{
+	if(i2s_used) {
+		i2s_used = 0;
+		//release the module clock
+		clk_disable(i2s_moduleclk);
+
+		//release pllx8clk
+		clk_put(i2s_pllx8);
+
+		//release pll2clk
+		clk_put(i2s_pll2clk);
+
+		//release apbclk
+		clk_put(i2s_apbclk);
+
+		gpio_release(i2s_handle, 2);
+		snd_soc_unregister_dai(&pdev->dev);
+		platform_set_drvdata(pdev, NULL);
+	}
+	return 0;
+}
+
+/*data relating*/
+static struct platform_device sunxi_i2s_device = {
+	.name = "sunxi-i2s",
+};
+
+/*method relating*/
+static struct platform_driver sunxi_i2s_driver = {
+	.probe = sunxi_i2s_dev_probe,
+	.remove = __devexit_p(sunxi_i2s_dev_remove),
+	.driver = {
+		.name = "sunxi-i2s",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_i2s_init(void)
+{
+	int err = 0;
+	int ret;
+
+	ret = script_parser_fetch("i2s_para","i2s_used", &i2s_used, sizeof(int));
+	if (ret) {
+        printk("[I2S]sunxi_i2s_init fetch i2s using configuration failed\n");
+    }
+
+ 	if (i2s_used) {
+		i2s_handle = gpio_request_ex("i2s_para", NULL);
+
+		if((err = platform_device_register(&sunxi_i2s_device)) < 0)
+			return err;
+
+		if ((err = platform_driver_register(&sunxi_i2s_driver)) < 0)
+			return err;
+	} else {
+        printk("[I2S]sunxi-i2s cannot find any using configuration for controllers, return directly!\n");
+        return 0;
+    }
+	return 0;
+}
+module_init(sunxi_i2s_init);
+
+static void __exit sunxi_i2s_exit(void)
+{
+	platform_driver_unregister(&sunxi_i2s_driver);
+}
+module_exit(sunxi_i2s_exit);
+
+/* Module information */
+MODULE_AUTHOR("ALLWINNER");
+MODULE_DESCRIPTION("sunxi I2S SoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-i2s");
+
diff --git a/sound/soc/sunxi/i2s/sunxi-i2s.h b/sound/soc/sunxi/i2s/sunxi-i2s.h
new file mode 100644
index 0000000..f12d6d5
--- /dev/null
+++ b/sound/soc/sunxi/i2s/sunxi-i2s.h
@@ -0,0 +1,304 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2s.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SUNXI_I2S_H_
+#define SUNXI_I2S_H_
+
+/*------------------------------------------------------------*/
+/* REGISTER definition */
+
+/* IIS REGISTER */
+#define SUNXI_IISBASE 		(0x01C22400)
+
+#define SUNXI_IISCTL 	  (0x00)
+	#define SUNXI_IISCTL_SDO3EN		(1<<11)
+	#define SUNXI_IISCTL_SDO2EN		(1<<10)
+	#define SUNXI_IISCTL_SDO1EN		(1<<9)
+	#define SUNXI_IISCTL_SDO0EN		(1<<8)
+	#define SUNXI_IISCTL_ASS			(1<<6)
+	#define SUNXI_IISCTL_MS			(1<<5)
+	#define SUNXI_IISCTL_PCM			(1<<4)
+	#define SUNXI_IISCTL_LOOP			(1<<3)
+	#define SUNXI_IISCTL_TXEN			(1<<2)
+	#define SUNXI_IISCTL_RXEN			(1<<1)
+	#define SUNXI_IISCTL_GEN			(1<<0)
+
+#define SUNXI_IISFAT0 		(0x04)
+	#define SUNXI_IISFAT0_LRCP					(1<<7)
+	#define SUNXI_IISFAT0_BCP					(1<<6)
+	#define SUNXI_IISFAT0_SR_RVD				(3<<4)
+	#define SUNXI_IISFAT0_SR_16BIT				(0<<4)
+	#define	SUNXI_IISFAT0_SR_20BIT				(1<<4)
+	#define SUNXI_IISFAT0_SR_24BIT				(2<<4)
+	#define SUNXI_IISFAT0_WSS_16BCLK			(0<<2)
+	#define SUNXI_IISFAT0_WSS_20BCLK			(1<<2)
+	#define SUNXI_IISFAT0_WSS_24BCLK			(2<<2)
+	#define SUNXI_IISFAT0_WSS_32BCLK			(3<<2)
+	#define SUNXI_IISFAT0_FMT_I2S				(0<<0)
+	#define SUNXI_IISFAT0_FMT_LFT				(1<<0)
+	#define SUNXI_IISFAT0_FMT_RGT				(2<<0)
+	#define SUNXI_IISFAT0_FMT_RVD				(3<<0)
+
+#define SUNXI_IISFAT1		(0x08)
+	#define SUNXI_IISFAT1_SYNCLEN_16BCLK		(0<<12)
+	#define SUNXI_IISFAT1_SYNCLEN_32BCLK		(1<<12)
+	#define SUNXI_IISFAT1_SYNCLEN_64BCLK		(2<<12)
+	#define SUNXI_IISFAT1_SYNCLEN_128BCLK		(3<<12)
+	#define SUNXI_IISFAT1_SYNCLEN_256BCLK		(4<<12)
+	#define SUNXI_IISFAT1_SYNCOUTEN			(1<<11)
+	#define SUNXI_IISFAT1_OUTMUTE 				(1<<10)
+	#define SUNXI_IISFAT1_MLS		 			(1<<9)
+	#define SUNXI_IISFAT1_SEXT		 			(1<<8)
+	#define SUNXI_IISFAT1_SI_1ST				(0<<6)
+	#define SUNXI_IISFAT1_SI_2ND			 	(1<<6)
+	#define SUNXI_IISFAT1_SI_3RD			 	(2<<6)
+	#define SUNXI_IISFAT1_SI_4TH			 	(3<<6)
+	#define SUNXI_IISFAT1_SW			 		(1<<5)
+	#define SUNXI_IISFAT1_SSYNC	 			(1<<4)
+	#define SUNXI_IISFAT1_RXPDM_16PCM			(0<<2)
+	#define SUNXI_IISFAT1_RXPDM_8PCM			(1<<2)
+	#define SUNXI_IISFAT1_RXPDM_8ULAW			(2<<2)
+	#define SUNXI_IISFAT1_RXPDM_8ALAW  		(3<<2)
+	#define SUNXI_IISFAT1_TXPDM_16PCM			(0<<0)
+	#define SUNXI_IISFAT1_TXPDM_8PCM			(1<<0)
+	#define SUNXI_IISFAT1_TXPDM_8ULAW			(2<<0)
+	#define SUNXI_IISFAT1_TXPDM_8ALAW  		(3<<0)
+
+#define SUNXI_IISTXFIFO 	(0x0C)
+
+#define SUNXI_IISRXFIFO 	(0x10)
+
+#define SUNXI_IISFCTL  	(0x14)
+	#define SUNXI_IISFCTL_FIFOSRC			(1<<31)
+	#define SUNXI_IISFCTL_FTX				(1<<25)
+	#define SUNXI_IISFCTL_FRX				(1<<24)
+	#define SUNXI_IISFCTL_TXTL(v)			((v)<<12)
+	#define SUNXI_IISFCTL_RXTL(v)  		((v)<<4)
+	#define SUNXI_IISFCTL_TXIM_MOD0		(0<<2)
+	#define SUNXI_IISFCTL_TXIM_MOD1		(1<<2)
+	#define SUNXI_IISFCTL_RXOM_MOD0		(0<<0)
+	#define SUNXI_IISFCTL_RXOM_MOD1		(1<<0)
+	#define SUNXI_IISFCTL_RXOM_MOD2		(2<<0)
+	#define SUNXI_IISFCTL_RXOM_MOD3		(3<<0)
+
+#define SUNXI_IISFSTA   	(0x18)
+	#define SUNXI_IISFSTA_TXE				(1<<28)
+	#define SUNXI_IISFSTA_TXECNT(v)		((v)<<16)
+	#define SUNXI_IISFSTA_RXA				(1<<8)
+	#define SUNXI_IISFSTA_RXACNT(v)		((v)<<0)
+
+#define SUNXI_IISINT    	(0x1C)
+	#define SUNXI_IISINT_TXDRQEN				(1<<7)
+	#define SUNXI_IISINT_TXUIEN				(1<<6)
+	#define SUNXI_IISINT_TXOIEN				(1<<5)
+	#define SUNXI_IISINT_TXEIEN				(1<<4)
+	#define SUNXI_IISINT_RXDRQEN				(1<<2)
+	#define SUNXI_IISINT_RXOIEN				(1<<1)
+	#define SUNXI_IISINT_RXAIEN				(1<<0)
+
+#define SUNXI_IISISTA   	(0x20)
+	#define SUNXI_IISISTA_TXUISTA			(1<<6)
+	#define SUNXI_IISISTA_TXOISTA			(1<<5)
+	#define SUNXI_IISISTA_TXEISTA			(1<<4)
+	#define SUNXI_IISISTA_RXOISTA			(1<<1)
+	#define SUNXI_IISISTA_RXAISTA			(1<<0)
+
+#define SUNXI_IISCLKD   	(0x24)
+	#define SUNXI_IISCLKD_MCLKOEN			(1<<7)
+	#define SUNXI_IISCLKD_BCLKDIV_2		(0<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_4		(1<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_6		(2<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_8		(3<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_12		(4<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_16		(5<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_32		(6<<4)
+	#define SUNXI_IISCLKD_BCLKDIV_64		(7<<4)
+	#define SUNXI_IISCLKD_MCLKDIV_1		(0<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_2		(1<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_4		(2<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_6		(3<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_8		(4<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_12		(5<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_16		(6<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_24		(7<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_32		(8<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_48		(9<<0)
+	#define SUNXI_IISCLKD_MCLKDIV_64		(10<<0)
+
+#define SUNXI_IISTXCNT  	(0x28)
+
+#define SUNXI_IISRXCNT  	(0x2C)
+
+#define SUNXI_TXCHSEL		(0x30)
+	#define SUNXI_TXCHSEL_CHNUM(v)			(((v)-1)<<0)
+
+#define SUNXI_TXCHMAP		(0x34)
+	#define SUNXI_TXCHMAP_CH7(v)			(((v)-1)<<28)
+	#define SUNXI_TXCHMAP_CH6(v)			(((v)-1)<<24)
+	#define SUNXI_TXCHMAP_CH5(v)			(((v)-1)<<20)
+	#define SUNXI_TXCHMAP_CH4(v)			(((v)-1)<<16)
+	#define SUNXI_TXCHMAP_CH3(v)			(((v)-1)<<12)
+	#define SUNXI_TXCHMAP_CH2(v)			(((v)-1)<<8)
+	#define SUNXI_TXCHMAP_CH1(v)			(((v)-1)<<4)
+	#define SUNXI_TXCHMAP_CH0(v)			(((v)-1)<<0)
+
+#define SUNXI_RXCHSEL		(0x38)
+	#define SUNXI_RXCHSEL_CHNUM(v)			(((v)-1)<<0)
+
+#define SUNXI_RXCHMAP		(0x3C)
+	#define SUNXI_RXCHMAP_CH3(v)			(((v)-1)<<12)
+	#define SUNXI_RXCHMAP_CH2(v)			(((v)-1)<<8)
+	#define SUNXI_RXCHMAP_CH1(v)			(((v)-1)<<4)
+	#define SUNXI_RXCHMAP_CH0(v)			(((v)-1)<<0)
+
+
+/* DMA REGISTER */
+#define SUNXI_DMABASE	(0x01C02000)
+
+#define SUNXI_DMAIRQEN						(0x0)
+	#define SUNXI_DMAIRQEN_NDMA_FULLEN(v)				(1<<((v)*2+1))
+	#define SUNXI_DMAIRQEN_NDMA_HALFEN(v)				(1<<((v)*2))
+
+#define SUNXI_DMAIRQPENDING	 		(0x4)
+	#define SUNXI_DMAIRQPENGDING_NDMA_FULLPEND(v)		(1<<((v)*2+1))
+	#define SUNXI_DMAIRQPENGDING_NDMA_HALFPEND(v)		(1<<((v)*2))
+
+#define SUNXI_NDMACFG(v)				((v)*0x20+0x100)
+	#define SUNXI_NDMACFG_DMALOAD					(1<<31)
+	#define SUNXI_NDMACFG_BUSY						(1<<30)
+	#define SUNXI_NDMACFG_CONTINUOUS				(1<<29)
+	#define SUNXI_NDMACFG_WAIT(v)					(((v)-1)<<26)   //wait clock = 2^n  example: 8 clocks = 2^3
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_8BIT		(0<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_16BIT		(1<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_32BIT		(2<<24)
+	#define SUNXI_NDMACFG_DSTDATAWIDTH_RVD			(3<<24)
+	#define SUNXI_NDMACFG_DSTBURST4				(1<<23)
+	#define SUNXI_NDMACFG_DSTADDRTYPE_INC			(0<<21)
+	#define SUNXI_NDMACFG_DSTADDRTYPE_CON 			(1<<21)
+	#define SUNXI_NDMACFG_DSTTYPE_IRTX				(0x0<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPDIFTX			(0x1<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_IISTX			(0x2<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_AC97TX			(0x3<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI0TX 			(0x4<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI1TX			(0x5<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SPI2TX			(0x6<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART0TX			(0x8<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART1TX			(0x9<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART2TX			(0xA<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART3TX			(0xB<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_AUDIODA			(0xC<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_NFC				(0xF<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_SRAM				(0x10<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_DRAM				(0x11<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART4TX			(0x12<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART5TX          (0x13<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART6TX			(0x14<<16)
+	#define SUNXI_NDMACFG_DSTTYPE_UART7TX			(0x15<<16)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_8BIT		(0<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_16BIT		(1<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_32BIT		(2<<8)
+	#define SUNXI_NDMACFG_SRCDATAWIDTH_RVD			(3<<8)
+	#define SUNXI_NDMACFG_SRCBURST4				(1<<7)
+	#define SUNXI_NDMACFG_SRCADDRTYPE_INC			(0<<5)
+	#define SUNXI_NDMACFG_SRCADDRTYPE_CON 			(1<<5)
+	#define SUNXI_NDMACFG_SRCTYPE_IRRX				(0x0<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPDIFRX			(0x1<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_IISRX			(0x2<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_AC97RX			(0x3<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI0RX 			(0x4<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI1RX			(0x5<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SPI2RX			(0x6<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART0RX			(0x8<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART1RX			(0x9<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART2RX			(0xA<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART3RX			(0xB<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_AUDIOAD			(0xC<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_TPAD				(0xD<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_NFC				(0xF<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_SRAM				(0x10<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_DRAM				(0x11<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART4RX			(0x12<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART5RX			(0x13<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART6RX			(0x14<<0)
+	#define SUNXI_NDMACFG_SRCTYPE_UART7RX			(0x15<<0)
+
+#define SUNXI_NDMASRCADDR(v)				((v)*0x20 + 0x100 + 4)
+
+#define SUNXI_NDMADSTADDR(v)				((v)*0x20 + 0x100 + 8)
+
+#define SUNXI_NDMACNT(v)				((v)*0x20 + 0x100 + 0xC)
+
+
+/* CCM REGISTER */
+#define SUNXI_CCMBASE    (0x01C20000)
+
+#define SUNXI_CCM_AUDIO_HOSC_PLL_REG   (0x08)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_AUDIOEN		(1<<31)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_FRE225792MHZ	(0<<27)
+	#define SUNXI_CCM_AUDIO_HOSC_PLL_REG_FRE24576MHZ	(1<<27)
+
+#define SUNXI_CCM_APB_GATE_REG    		 (0x68)
+	#define SUNXI_CCM_APB_GATE_REG_IISGATE				(1<<3)
+
+#define SUNXI_CCM_AUDIO_CLK_REG				(0xb8)
+	#define SUNXI_CCM_AUDIO_CLK_REG_IISSPECIALGATE		(1<<31)
+	#define SUNXI_CCM_AUDIO_CLK_REG_DIV(v)					((v)<<16)
+/*------------------------------------------------------------*/
+
+/*------------------------------------------------------------*/
+/* Clock dividers */
+#define SUNXI_DIV_MCLK	0
+#define SUNXI_DIV_BCLK	1
+
+#define SUNXI_IISCLKD_MCLK_MASK   0x0f
+#define SUNXI_IISCLKD_MCLK_OFFS   0
+#define SUNXI_IISCLKD_BCLK_MASK   0x070
+#define SUNXI_IISCLKD_BCLK_OFFS   4
+#define SUNXI_IISCLKD_MCLKEN_OFFS 7
+
+unsigned int sunxi_i2s_get_clockrate(void);
+extern struct sunxi_i2s_info sunxi_i2s;
+//extern struct snd_soc_dai sunxi_iis_dai;
+
+extern void sunxi_snd_txctrl_i2s(struct snd_pcm_substream *substream, int on);
+extern void sunxi_snd_rxctrl_i2s(int on);
+
+struct sunxi_i2s_info {
+	void __iomem   *regs;    /* IIS BASE */
+	void __iomem   *ccmregs;  //CCM BASE
+	void __iomem   *ioregs;   //IO BASE
+
+	u32 slave;					//0: master, 1: slave
+	u32 mono;					//0: stereo, 1: mono
+	u32 samp_fs;				//audio sample rate (unit in kHz)
+	u32 samp_res;			//16 bits, 20 bits , 24 bits, 32 bits)
+	u32 samp_format;		//audio sample format (0: standard I2S, 1: left-justified, 2: right-justified, 3: pcm)
+	u32 ws_size;				//16 BCLK, 20 BCLK, 24 BCLK, 32 BCLK)
+	u32 mclk_rate;			//mclk frequency divide by fs (128fs, 192fs, 256fs, 384fs, 512fs, 768fs)
+	u32 lrc_pol;				//LRC clock polarity (0: normal ,1: inverted)
+	u32 bclk_pol;			//BCLK polarity (0: normal, 1: inverted)
+	u32 pcm_txtype;		//PCM transmitter type (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_rxtype;		//PCM receiver type  (0: 16-bits linear mode, 1: 8-bits linear mode, 2: u-law, 3: A-law)
+	u32 pcm_sw;				//PCM slot width (8: 8 bits, 16: 16 bits)
+	u32 pcm_sync_period;//PCM sync period (16/32/64/128/256)
+	u32 pcm_sync_type;	//PCM sync symbol size (0: short sync, 1: long sync)
+	u32 pcm_start_slot;//PCM start slot index (1--4)
+	u32 pcm_lsb_first;	//0: MSB first, 1: LSB first
+	u32 pcm_ch_num;		//PCM channel number (1: one channel, 2: two channel)
+
+};
+
+extern struct sunxi_i2s_info sunxi_i2s;
+#endif
diff --git a/sound/soc/sunxi/i2s/sunxi-i2sdma.c b/sound/soc/sunxi/i2s/sunxi-i2sdma.c
new file mode 100644
index 0000000..488ef4d
--- /dev/null
+++ b/sound/soc/sunxi/i2s/sunxi-i2sdma.c
@@ -0,0 +1,450 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2sdma.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <plat/dma_compat.h>
+
+#include "sunxi-i2s.h"
+#include "sunxi-i2sdma.h"
+
+static volatile unsigned int dmasrc = 0;
+static volatile unsigned int dmadst = 0;
+
+static const struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				      SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+				      SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,    /* value must be (2^n)Kbyte size */
+	.period_bytes_min	= 1024*4,//1024*4,
+	.period_bytes_max	= 1024*32,//1024*32,
+	.periods_min		= 4,//4,
+	.periods_max		= 8,//8,
+	.fifo_size		= 128,//32,
+};
+
+struct sunxi_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct sunxi_dma_params *params;
+};
+
+static void sunxi_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	dma_addr_t pos = prtd->dma_pos;
+	unsigned int limit;
+	int ret;
+
+	unsigned long len = prtd->dma_period;
+  	limit = prtd->dma_limit;
+  	while(prtd->dma_loaded < limit) {
+		if((pos + len) > prtd->dma_end) {
+			len  = prtd->dma_end - pos;
+		}
+
+		ret = sunxi_dma_enqueue(prtd->params, pos,  len, 0);
+		if(ret == 0) {
+			prtd->dma_loaded++;
+			pos += prtd->dma_period;
+			if(pos >= prtd->dma_end)
+				pos = prtd->dma_start;
+		}else {
+			break;
+		}
+
+	}
+	prtd->dma_pos = pos;
+}
+
+static void sunxi_audio_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	struct sunxi_runtime_data *prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	prtd = substream->runtime->private_data;
+	if (substream) {
+		snd_pcm_period_elapsed(substream);
+	}
+
+	spin_lock(&prtd->lock);
+	{
+		prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&prtd->lock);
+}
+
+static int sunxi_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	unsigned long totbytes = params_buffer_bytes(params);
+	struct sunxi_dma_params *dma =
+			snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	int ret = 0;
+	if (!dma)
+		return 0;
+
+	if (prtd->params == NULL) {
+		prtd->params = dma;
+		ret = sunxi_dma_request(prtd->params, 0);
+		if (ret < 0) {
+				return ret;
+		}
+	}
+
+	if (sunxi_dma_set_callback(prtd->params, sunxi_audio_buffdone,
+							    substream) != 0) {
+		sunxi_dma_release(prtd->params);
+		prtd->params = NULL;
+		return -EINVAL;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	runtime->dma_bytes = totbytes;
+
+	spin_lock_irq(&prtd->lock);
+	prtd->dma_loaded = 0;
+	prtd->dma_limit = runtime->hw.periods_min;
+	prtd->dma_period = params_period_bytes(params);
+	prtd->dma_start = runtime->dma_addr;
+	prtd->dma_pos = prtd->dma_start;
+	prtd->dma_end = prtd->dma_start + totbytes;
+	spin_unlock_irq(&prtd->lock);
+	return 0;
+}
+
+static int sunxi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+
+	if (prtd->params)
+		sunxi_dma_flush(prtd->params);
+
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	if (prtd->params) {
+		sunxi_dma_stop(prtd->params);
+		sunxi_dma_release(prtd->params);
+		prtd->params = NULL;
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	if (!prtd->params)
+		return 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+		struct dma_hw_conf codec_dma_conf;
+		codec_dma_conf.drqsrc_type  = DRQ_TYPE_SDRAM;
+		codec_dma_conf.drqdst_type  = DRQ_TYPE_IIS;
+		codec_dma_conf.xfer_type    = DMAXFER_D_BHALF_S_BHALF;
+		codec_dma_conf.address_type = DMAADDRT_D_FIX_S_INC;
+		codec_dma_conf.dir          = SW_DMA_WDEV;
+		codec_dma_conf.reload       = 0;
+		codec_dma_conf.hf_irq       = SW_DMA_IRQ_FULL;
+		codec_dma_conf.from         = prtd->dma_start;
+		codec_dma_conf.to           = prtd->params->dma_addr;
+#else
+		dma_config_t codec_dma_conf;
+		memset(&codec_dma_conf, 0, sizeof(codec_dma_conf));
+		codec_dma_conf.xfer_type.src_data_width	= DATA_WIDTH_16BIT;
+		codec_dma_conf.xfer_type.src_bst_len	= DATA_BRST_1;	
+		codec_dma_conf.xfer_type.dst_data_width	= DATA_WIDTH_16BIT;
+		codec_dma_conf.xfer_type.dst_bst_len	= DATA_BRST_1;
+		codec_dma_conf.address_type.src_addr_mode = NDMA_ADDR_INCREMENT;
+		codec_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_NOCHANGE;
+		codec_dma_conf.src_drq_type		= N_SRC_SDRAM;
+		codec_dma_conf.dst_drq_type		= N_DST_IIS0_TX;
+		codec_dma_conf.bconti_mode		= false;
+		codec_dma_conf.irq_spt			= CHAN_IRQ_FD;
+#endif
+		ret = sunxi_dma_config(prtd->params, &codec_dma_conf, 0);
+	}
+
+	/* flush the DMA channel */
+	prtd->dma_loaded = 0;
+	if (sunxi_dma_flush(prtd->params) == 0)
+		prtd->dma_pos = prtd->dma_start;
+
+	/* enqueue dma buffers */
+	sunxi_pcm_enqueue(substream);
+
+	return ret;
+}
+
+static int sunxi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	int ret ;
+	spin_lock(&prtd->lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		printk("[IIS] dma trigger start\n");
+		printk("[IIS] 0x01c22400+0x24 = %#x, line= %d\n", readl(0xf1c22400+0x24), __LINE__);
+		sunxi_dma_start(prtd->params);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+        printk("[IIS] dma trigger stop\n");
+		sunxi_dma_stop(prtd->params);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t sunxi_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	unsigned long res = 0;
+	snd_pcm_uframes_t offset = 0;
+
+	spin_lock(&prtd->lock);
+	sunxi_dma_getcurposition(prtd->params,
+				 (dma_addr_t*)&dmasrc, (dma_addr_t*)&dmadst);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		res = dmadst - prtd->dma_start;
+	else
+	{
+		offset = bytes_to_frames(runtime, dmasrc + prtd->dma_period - runtime->dma_addr);
+	}
+	spin_unlock(&prtd->lock);
+
+	if(offset >= runtime->buffer_size)
+		offset = 0;
+		return offset;
+}
+
+static int sunxi_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd;
+
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+
+	prtd = kzalloc(sizeof(struct sunxi_runtime_data), GFP_KERNEL);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&prtd->lock);
+
+	runtime->private_data = prtd;
+	return 0;
+}
+
+static int sunxi_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+
+	kfree(prtd);
+
+	return 0;
+}
+
+static int sunxi_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops sunxi_pcm_ops = {
+	.open			= sunxi_pcm_open,
+	.close			= sunxi_pcm_close,
+	.ioctl			= snd_pcm_lib_ioctl,
+	.hw_params		= sunxi_pcm_hw_params,
+	.hw_free		= sunxi_pcm_hw_free,
+	.prepare		= sunxi_pcm_prepare,
+	.trigger		= sunxi_pcm_trigger,
+	.pointer		= sunxi_pcm_pointer,
+	.mmap			= sunxi_pcm_mmap,
+};
+
+static int sunxi_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = sunxi_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void sunxi_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+static int sunxi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+static struct snd_soc_platform_driver sunxi_soc_platform = {
+	.ops		= &sunxi_pcm_ops,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free_dma_buffers,
+};
+
+static int __devinit sunxi_i2s_pcm_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &sunxi_soc_platform);
+}
+
+static int __devexit sunxi_i2s_pcm_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+/*data relating*/
+static struct platform_device sunxi_i2s_pcm_device = {
+	.name = "sunxi-i2s-pcm-audio",
+};
+
+/*method relating*/
+static struct platform_driver sunxi_i2s_pcm_driver = {
+	.probe = sunxi_i2s_pcm_probe,
+	.remove = __devexit_p(sunxi_i2s_pcm_remove),
+	.driver = {
+		.name = "sunxi-i2s-pcm-audio",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_soc_platform_i2s_init(void)
+{
+	int err = 0;
+	if((err = platform_device_register(&sunxi_i2s_pcm_device)) < 0)
+		return err;
+
+	if ((err = platform_driver_register(&sunxi_i2s_pcm_driver)) < 0)
+		return err;
+	return 0;
+}
+module_init(sunxi_soc_platform_i2s_init);
+
+static void __exit sunxi_soc_platform_i2s_exit(void)
+{
+	return platform_driver_unregister(&sunxi_i2s_pcm_driver);
+}
+module_exit(sunxi_soc_platform_i2s_exit);
+
+MODULE_AUTHOR("All winner");
+MODULE_DESCRIPTION("SUNXI PCM DMA module");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/sunxi/i2s/sunxi-i2sdma.h b/sound/soc/sunxi/i2s/sunxi-i2sdma.h
new file mode 100644
index 0000000..50418a58
--- /dev/null
+++ b/sound/soc/sunxi/i2s/sunxi-i2sdma.h
@@ -0,0 +1,35 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi-i2sdma.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+
+#ifndef SUNXI_PCM_H_
+#define SUNXI_PCM_H_
+
+#define ST_RUNNING    (1<<0)
+#define ST_OPENED     (1<<1)
+
+#define SUNXI_DAI_I2S			1
+
+enum sunxi_dma_buffresult {
+	SUNXI_RES_OK,
+	SUNXI_RES_ERR,
+	SUNXI_RES_ABORT
+};
+
+/* platform data */
+extern struct snd_soc_platform sunxi_soc_platform_i2s;
+extern struct sunxi_i2s_info sunxi_iis;
+
+#endif //SUNXI_PCM_H_
diff --git a/sound/soc/sunxi/i2s/sunxi-sndi2s.c b/sound/soc/sunxi/i2s/sunxi-sndi2s.c
new file mode 100644
index 0000000..7c1a3d4
--- /dev/null
+++ b/sound/soc/sunxi/i2s/sunxi-sndi2s.c
@@ -0,0 +1,318 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi_sndi2s.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <plat/sys_config.h>
+#include <linux/io.h>
+
+#include "sunxi-i2s.h"
+#include "sunxi-i2sdma.h"
+
+#include "sndi2s.h"
+
+static struct clk *xtal;
+static int clk_users;
+static DEFINE_MUTEX(clk_lock);
+
+#ifdef ENFORCE_RATES
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+	.count	= ARRAY_SIZE(rates),
+	.list	= rates,
+	.mask	= 0,
+};
+#endif
+
+static int sunxi_sndi2s_startup(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	#ifdef ENFORCE_RATES
+		struct snd_pcm_runtime *runtime = substream->runtime;;
+	#endif
+
+	if (!ret) {
+	#ifdef ENFORCE_RATES
+		ret = snd_pcm_hw_constraint_list(runtime, 0,
+						 SNDRV_PCM_HW_PARAM_RATE,
+						 &hw_constraints_rates);
+		if (ret < 0)
+			return ret;
+	#endif
+	}
+	return ret;
+}
+
+static void sunxi_sndi2s_shutdown(struct snd_pcm_substream *substream)
+{
+	mutex_lock(&clk_lock);
+	clk_users -= 1;
+	if (clk_users == 0) {
+		clk_put(xtal);
+		xtal = NULL;
+
+	}
+	mutex_unlock(&clk_lock);
+}
+
+typedef struct __MCLK_SET_INF
+{
+    __u32       samp_rate;      // sample rate
+    __u16       mult_fs;        // multiply of smaple rate
+
+    __u8        clk_div;        // mpll division
+    __u8        mpll;           // select mpll, 0 - 24.576 Mhz, 1 - 22.5792 Mhz
+
+} __mclk_set_inf;
+
+
+typedef struct __BCLK_SET_INF
+{
+    __u8        bitpersamp;     // bits per sample
+    __u8        clk_div;        // clock division
+    __u16       mult_fs;        // multiplay of sample rate
+
+} __bclk_set_inf;
+
+
+static __bclk_set_inf BCLK_INF[] =
+{
+    // 16bits per sample
+    {16,  4, 128}, {16,  6, 192}, {16,  8, 256},
+    {16, 12, 384}, {16, 16, 512},
+
+    //24 bits per sample
+    {24,  4, 192}, {24,  8, 384}, {24, 16, 768},
+
+    //32 bits per sample
+    {32,  2, 128}, {32,  4, 256}, {32,  6, 384},
+    {32,  8, 512}, {32, 12, 768},
+
+    //end flag
+    {0xff, 0, 0},
+};
+
+static __mclk_set_inf  MCLK_INF[] =
+{
+    // 8k bitrate
+    {  8000, 128, 24, 0}, {  8000, 192, 16, 0}, {  8000, 256, 12, 0},
+    {  8000, 384,  8, 0}, {  8000, 512,  6, 0}, {  8000, 768,  4, 0},
+
+    // 16k bitrate
+    { 16000, 128, 12, 0}, { 16000, 192,  8, 0}, { 16000, 256,  6, 0},
+    { 16000, 384,  4, 0}, { 16000, 768,  2, 0},
+
+    // 32k bitrate
+    { 32000, 128,  6, 0}, { 32000, 192,  4, 0}, { 32000, 384,  2, 0},
+    { 32000, 768,  1, 0},
+
+    // 64k bitrate
+    { 64000, 192,  2, 0}, { 64000, 384,  1, 0},
+
+    //128k bitrate
+    {128000, 192,  1, 0},
+
+    // 12k bitrate
+    { 12000, 128, 16, 0}, { 12000, 256, 8, 0}, { 12000, 512, 4, 0},
+
+    // 24k bitrate
+    { 24000, 128,  8, 0}, { 24000, 256, 4, 0}, { 24000, 512, 2, 0},
+
+    // 48K bitrate
+    { 48000, 128,  4, 0}, { 48000, 256,  2, 0}, { 48000, 512, 1, 0},
+
+    // 96k bitrate
+    { 96000, 128 , 2, 0}, { 96000, 256,  1, 0},
+
+    //192k bitrate
+    {192000, 128,  1, 0},
+
+    //11.025k bitrate
+    { 11025, 128, 16, 1}, { 11205, 256,  8, 1}, { 11205, 512,  4, 1},
+
+    //22.05k bitrate
+    { 22050, 128,  8, 1}, { 22050, 256,  4, 1},
+    { 22050, 512,  2, 1},
+
+    //44.1k bitrate
+    { 44100, 128,  4, 1}, { 44100, 256,  2, 1}, { 44100, 512,  1, 1},
+
+    //88.2k bitrate
+    { 88200, 128,  2, 1}, { 88200, 256,  1, 1},
+
+    //176.4k bitrate
+    {176400, 128, 1, 1},
+
+    //end flag 0xffffffff
+    {0xffffffff, 0, 0, 0},
+};
+
+static s32 get_clock_divder(u32 sample_rate, u32 sample_width, u32 * mclk_div, u32* mpll, u32* bclk_div, u32* mult_fs)
+{
+	u32 i, j, ret = -EINVAL;
+
+	for(i=0; i< 100; i++) {
+		 if((MCLK_INF[i].samp_rate == sample_rate) &&
+		 	((MCLK_INF[i].mult_fs == 256) || (MCLK_INF[i].mult_fs == 128))) {
+			  for(j=0; j<ARRAY_SIZE(BCLK_INF); j++) {
+					if((BCLK_INF[j].bitpersamp == sample_width) &&
+						(BCLK_INF[j].mult_fs == MCLK_INF[i].mult_fs)) {
+						 //set mclk and bclk division
+						 *mclk_div = MCLK_INF[i].clk_div;
+						 *mpll = MCLK_INF[i].mpll;
+						 *bclk_div = BCLK_INF[j].clk_div;
+						 *mult_fs = MCLK_INF[i].mult_fs;
+						 ret = 0;
+						 break;
+					}
+			  }
+		 }
+		 else if(MCLK_INF[i].samp_rate == 0xffffffff)
+		 	break;
+	}
+
+	return ret;
+}
+
+static int sunxi_sndi2s_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret = 0;
+	unsigned long rate = params_rate(params);
+	u32 mclk_div=0, mpll=0, bclk_div=0, mult_fs=0;
+
+	get_clock_divder(rate, 32, &mclk_div, &mpll, &bclk_div, &mult_fs);
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0 , mpll, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0 , mpll, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_MCLK, mclk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_BCLK, bclk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, 0, mult_fs);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sndi2s_ops = {
+	.startup 		= sunxi_sndi2s_startup,
+	.shutdown 		= sunxi_sndi2s_shutdown,
+	.hw_params 		= sunxi_sndi2s_hw_params,
+};
+
+static struct snd_soc_dai_link sunxi_sndi2s_dai_link = {
+	.name 			= "I2S",
+	.stream_name 	= "SUNXI-I2S",
+	.cpu_dai_name 	= "sunxi-i2s.0",
+	.codec_dai_name = "sndi2s",
+	.platform_name 	= "sunxi-i2s-pcm-audio.0",
+	.codec_name 	= "sunxi-i2s-codec.0",
+	.ops 			= &sunxi_sndi2s_ops,
+};
+
+static struct snd_soc_card snd_soc_sunxi_sndi2s = {
+	.name = "sunxi-sndi2s",
+	.owner = THIS_MODULE,
+	.dai_link = &sunxi_sndi2s_dai_link,
+	.num_links = 1,
+};
+
+static int __devinit sunxi_sndi2s_probe(struct platform_device *pdev)
+{
+	snd_soc_sunxi_sndi2s.dev = &pdev->dev;
+	return snd_soc_register_card(&snd_soc_sunxi_sndi2s);
+}
+
+static int __devexit sunxi_sndi2s_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_card(&snd_soc_sunxi_sndi2s);
+	return 0;
+}
+
+static struct platform_device sunxi_sndi2s_device = {
+	.name = "sunxi-sndi2s",
+};
+
+static struct platform_driver sunxi_sndi2s_driver = {
+	.probe = sunxi_sndi2s_probe,
+	.remove = __devexit_p(sunxi_sndi2s_remove),
+	.driver = {
+		.name = "sunxi-sndi2s",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_sndi2s_init(void)
+{
+	int ret, i2s_used = 0;
+
+	ret = script_parser_fetch("i2s_para", "i2s_used", &i2s_used, 1);
+	if (ret != 0 || !i2s_used)
+		return -ENODEV;
+
+	ret = platform_device_register(&sunxi_sndi2s_device);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sunxi_sndi2s_driver);
+	if (ret < 0) {
+		platform_device_unregister(&sunxi_sndi2s_device);
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit sunxi_sndi2s_exit(void)
+{
+	platform_driver_unregister(&sunxi_sndi2s_driver);
+	platform_device_unregister(&sunxi_sndi2s_device);
+}
+
+module_init(sunxi_sndi2s_init);
+module_exit(sunxi_sndi2s_exit);
+
+MODULE_AUTHOR("ALL WINNER");
+MODULE_DESCRIPTION("SUNXI_sndi2s ALSA SoC audio driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/i2s/sunxi-sndi2s.h b/sound/soc/sunxi/i2s/sunxi-sndi2s.h
new file mode 100644
index 0000000..47f0961
--- /dev/null
+++ b/sound/soc/sunxi/i2s/sunxi-sndi2s.h
@@ -0,0 +1,25 @@
+/*
+ * sound\soc\sunxi\i2s\sunxi_sndi2s.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef SUNXI_SNDI2S_H_
+#define SUNXI_SNDI2S_H_
+
+struct sunxi_sndi2s_platform_data {
+	int iis_bclk;
+	int iis_ws;
+	int iis_data;
+	void (*power)(int);
+	int model;
+}
+#endif
diff --git a/sound/soc/sunxi/spdif/Kconfig b/sound/soc/sunxi/spdif/Kconfig
new file mode 100644
index 0000000..3c6a7c7
--- /dev/null
+++ b/sound/soc/sunxi/spdif/Kconfig
@@ -0,0 +1,5 @@
+
+config SND_SUNXI_SOC_SPDIF
+	tristate "sun4i and sun5i On-Chip spdif"
+	default n
+
diff --git a/sound/soc/sunxi/spdif/Makefile b/sound/soc/sunxi/spdif/Makefile
new file mode 100644
index 0000000..c66dce9
--- /dev/null
+++ b/sound/soc/sunxi/spdif/Makefile
@@ -0,0 +1,8 @@
+
+
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF) += sunxi_spdif.o
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF) += sunxi_spdma.o
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF) += sndspdif.o
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF) += sunxi_sndspdif.o
+
+
diff --git a/sound/soc/sunxi/spdif/sndspdif.c b/sound/soc/sunxi/spdif/sndspdif.c
new file mode 100644
index 0000000..9bc8e0f
--- /dev/null
+++ b/sound/soc/sunxi/spdif/sndspdif.c
@@ -0,0 +1,190 @@
+/*
+ * sound\soc\sunxi\spdif\sndspdif.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <plat/sys_config.h>
+#include <linux/io.h>
+
+#include "sndspdif.h"
+
+#define SNDSPDIF_RATES  (SNDRV_PCM_RATE_8000_192000|SNDRV_PCM_RATE_KNOT)
+#define SNDSPDIF_FORMATS (SNDRV_PCM_FMTBIT_S16_LE)
+
+struct sndspdif_priv {
+	int sysclk;
+	int dai_fmt;
+
+	struct snd_pcm_substream *master_substream;
+	struct snd_pcm_substream *slave_substream;
+};
+
+static int sndspdif_mute(struct snd_soc_dai *dai, int mute)
+{
+	return 0;
+}
+
+static int sndspdif_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void sndspdif_shutdown(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+}
+
+static int sndspdif_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params,
+	struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sndspdif_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int sndspdif_set_dai_clkdiv(struct snd_soc_dai *codec_dai, int div_id, int div)
+{
+	return 0;
+}
+
+static int sndspdif_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int fmt)
+{
+	return 0;
+}
+struct snd_soc_dai_ops sndspdif_dai_ops = {
+	.startup = sndspdif_startup,
+	.shutdown = sndspdif_shutdown,
+	.hw_params = sndspdif_hw_params,
+	.digital_mute = sndspdif_mute,
+	.set_sysclk = sndspdif_set_dai_sysclk,
+	.set_clkdiv = sndspdif_set_dai_clkdiv,
+	.set_fmt = sndspdif_set_dai_fmt,
+};
+struct snd_soc_dai_driver sndspdif_dai = {
+	.name = "sndspdif",
+	/* playback capabilities */
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDSPDIF_RATES,
+		.formats = SNDSPDIF_FORMATS,
+	},
+	/* pcm operations */
+	.ops = &sndspdif_dai_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL(sndspdif_dai);
+
+static int sndspdif_soc_probe(struct snd_soc_codec *codec)
+{
+	struct sndspdif_priv *sndspdif;
+
+	sndspdif = kzalloc(sizeof(struct sndspdif_priv), GFP_KERNEL);
+	if(sndspdif == NULL){
+		printk("%s,%d\n",__func__,__LINE__);
+		return -ENOMEM;
+	}
+	snd_soc_codec_set_drvdata(codec, sndspdif);
+
+	return 0;
+}
+
+/* power down chip */
+static int sndspdif_soc_remove(struct snd_soc_codec *codec)
+{
+	struct sndspdif_priv *sndspdif = snd_soc_codec_get_drvdata(codec);
+
+	kfree(sndspdif);
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_sndspdif = {
+	.probe 	=	sndspdif_soc_probe,
+	.remove =   sndspdif_soc_remove,
+};
+
+static int __devinit sndspdif_codec_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_sndspdif, &sndspdif_dai, 1);
+}
+
+static int __devexit sndspdif_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+/*data relating*/
+static struct platform_device sndspdif_codec_device = {
+	.name = "sunxi-spdif-codec",
+};
+
+/*method relating*/
+static struct platform_driver sndspdif_codec_driver = {
+	.driver = {
+		.name = "sunxi-spdif-codec",
+		.owner = THIS_MODULE,
+	},
+	.probe = sndspdif_codec_probe,
+	.remove = __devexit_p(sndspdif_codec_remove),
+};
+
+static int __init sndspdif_codec_init(void)
+{
+	int ret, spdif_used = 0;
+
+	ret = script_parser_fetch("spdif_para", "spdif_used", &spdif_used, 1);
+	if (ret != 0 || !spdif_used)
+		return -ENODEV;
+
+	ret = platform_device_register(&sndspdif_codec_device);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sndspdif_codec_driver);
+	if (ret < 0) {
+		platform_device_unregister(&sndspdif_codec_device);
+		return ret;
+	}
+
+	return 0;
+}
+module_init(sndspdif_codec_init);
+
+static void __exit sndspdif_codec_exit(void)
+{
+	platform_driver_unregister(&sndspdif_codec_driver);
+	platform_device_unregister(&sndspdif_codec_device);
+}
+module_exit(sndspdif_codec_exit);
+
+MODULE_DESCRIPTION("SNDSPDIF ALSA soc codec driver");
+MODULE_AUTHOR("Zoltan Devai, Christian Pellegrin <chripell@evolware.org>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-spdif-codec");
diff --git a/sound/soc/sunxi/spdif/sndspdif.h b/sound/soc/sunxi/spdif/sndspdif.h
new file mode 100644
index 0000000..c47214b
--- /dev/null
+++ b/sound/soc/sunxi/spdif/sndspdif.h
@@ -0,0 +1,19 @@
+/*
+ * sound\soc\sunxi\spdif\sndspdif.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _SNDSPDIF_H
+#define _SNDSPDIF_H
+
+#endif
diff --git a/sound/soc/sunxi/spdif/sunxi_sndspdif.c b/sound/soc/sunxi/spdif/sunxi_sndspdif.c
new file mode 100644
index 0000000..885e7ae
--- /dev/null
+++ b/sound/soc/sunxi/spdif/sunxi_sndspdif.c
@@ -0,0 +1,294 @@
+/*
+ * sound\soc\sunxi\spdif\sunxi_sndspdif.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <plat/sys_config.h>
+#include <linux/io.h>
+
+#include "sunxi_spdif.h"
+#include "sunxi_spdma.h"
+
+#include "sndspdif.h"
+
+static struct clk *xtal;
+static int clk_users;
+static DEFINE_MUTEX(clk_lock);
+
+#ifdef ENFORCE_RATES
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+	.count	= ARRAY_SIZE(rates),
+	.list	= rates,
+	.mask	= 0,
+};
+#endif
+
+static int sunxi_sndspdif_startup(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	#ifdef ENFORCE_RATES
+		struct snd_pcm_runtime *runtime = substream->runtime;;
+	#endif
+	if (!ret) {
+	#ifdef ENFORCE_RATES
+		ret = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+		if (ret < 0)
+			return ret;
+	#endif
+	}
+	return ret;
+}
+
+static void sunxi_sndspdif_shutdown(struct snd_pcm_substream *substream)
+{
+	mutex_lock(&clk_lock);
+	clk_users -= 1;
+	if (clk_users == 0) {
+		clk_put(xtal);
+		xtal = NULL;
+	}
+	mutex_unlock(&clk_lock);
+}
+
+typedef struct __MCLK_SET_INF
+{
+    __u32   samp_rate;      // sample rate
+	__u16 	mult_fs;        // multiply of smaple rate
+
+    __u8    clk_div;        // mpll division
+    __u8    mpll;           // select mpll, 0 - 24.576 Mhz, 1 - 22.5792 Mhz
+
+} __mclk_set_inf;
+
+
+typedef struct __BCLK_SET_INF
+{
+    __u8    bitpersamp;     // bits per sample
+    __u8    clk_div;        // clock division
+    __u16   mult_fs;        // multiplay of sample rate
+
+} __bclk_set_inf;
+
+
+static __bclk_set_inf BCLK_INF[] =
+{
+    // 16bits per sample
+    {16,  4, 128}, {16,  6, 192}, {16,  8, 256},
+    {16, 12, 384}, {16, 16, 512},
+
+    //24 bits per sample
+    {24,  4, 192}, {24,  8, 384}, {24, 16, 768},
+
+    //32 bits per sample
+    {32,  2, 128}, {32,  4, 256}, {32,  6, 384},
+    {32,  8, 512}, {32, 12, 768},
+
+    //end flag
+    {0xff, 0, 0},
+};
+
+//TX RATIO value
+static __mclk_set_inf  MCLK_INF[] =
+{
+	//88.2k bitrate    //2
+    { 88200, 128,  2, 1}, { 88200, 256,  2, 1},
+
+	 //22.05k bitrate   //8
+    { 22050, 128,  8, 1}, { 22050, 256,  8, 1},
+    { 22050, 512,  8, 1},
+
+	// 24k bitrate   //8
+    { 24000, 128,  8, 0}, { 24000, 256, 8, 0}, { 24000, 512, 8, 0},
+
+    // 32k bitrate   //2.048MHz   24/4 = 6
+    { 32000, 128,  6, 0}, { 32000, 192,  6, 0}, { 32000, 384,  6, 0},
+    { 32000, 768,  6, 0},
+
+     // 48K bitrate   3.072  Mbit/s   16/4 = 4
+    { 48000, 128,  4, 0}, { 48000, 256,  4, 0}, { 48000, 512, 4, 0},
+
+    // 96k bitrate  6.144MHZ   8/4 = 2
+    { 96000, 128 , 2, 0}, { 96000, 256,  2, 0},
+
+    //192k bitrate   12.288MHZ  4/4 = 1
+    {192000, 128,  1, 0},
+
+    //44.1k bitrate  2.8224MHz   16/4 = 4
+    { 44100, 128,  4, 1}, { 44100, 256,  4, 1}, { 44100, 512,  4, 1},
+
+     //176.4k bitrate  11.2896MHZ 4/4 = 1
+    {176400, 128, 1, 1},
+
+    //end flag 0xffffffff
+    {0xffffffff, 0, 0, 0},
+};
+
+static s32 get_clock_divder(u32 sample_rate, u32 sample_width, u32 * mclk_div, u32* mpll, u32* bclk_div, u32* mult_fs)
+{
+	u32 i, j, ret = -EINVAL;
+
+	for(i=0; i< 100; i++) {
+		 if((MCLK_INF[i].samp_rate == sample_rate) &&
+		 	((MCLK_INF[i].mult_fs == 256) || (MCLK_INF[i].mult_fs == 128))) {
+			  for(j=0; j<ARRAY_SIZE(BCLK_INF); j++) {
+					if((BCLK_INF[j].bitpersamp == sample_width) &&
+						(BCLK_INF[j].mult_fs == MCLK_INF[i].mult_fs)) {
+						 *mclk_div = MCLK_INF[i].clk_div;
+						 *mpll = MCLK_INF[i].mpll;
+						 *bclk_div = BCLK_INF[j].clk_div;
+						 *mult_fs = MCLK_INF[i].mult_fs;
+						 ret = 0;
+						 break;
+					}
+			  }
+		 }
+		 else if(MCLK_INF[i].samp_rate == 0xffffffff)
+		 	break;
+	}
+
+	return ret;
+}
+
+static int sunxi_sndspdif_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret = 0;
+	unsigned long rate = params_rate(params);
+	u32 mclk_div=0, mpll=0, bclk_div=0, mult_fs=0;
+
+	get_clock_divder(rate, 32, &mclk_div, &mpll, &bclk_div, &mult_fs);
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0 , mpll, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0 , mpll, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_MCLK, mclk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, SUNXI_DIV_BCLK, bclk_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, 0, mult_fs);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sndspdif_ops = {
+	.startup 	= sunxi_sndspdif_startup,
+	.shutdown 	= sunxi_sndspdif_shutdown,
+	.hw_params 	= sunxi_sndspdif_hw_params,
+};
+
+static struct snd_soc_dai_link sunxi_sndspdif_dai_link = {
+	.name 			= "SPDIF",
+	.stream_name 	= "SUNXI-SPDIF",
+	.cpu_dai_name 	= "sunxi-spdif.0",
+	.codec_dai_name = "sndspdif",
+	.platform_name 	= "sunxi-spdif-pcm-audio.0",
+	.codec_name 	= "sunxi-spdif-codec.0",
+	.ops 			= &sunxi_sndspdif_ops,
+};
+
+static struct snd_soc_card snd_soc_sunxi_sndspdif = {
+	.name 		= "sunxi-sndspdif",
+	.owner		= THIS_MODULE,
+	.dai_link 	= &sunxi_sndspdif_dai_link,
+	.num_links 	= 1,
+};
+
+static int __devinit sunxi_sndspdif_probe(struct platform_device *pdev)
+{
+	snd_soc_sunxi_sndspdif.dev = &pdev->dev;
+	return snd_soc_register_card(&snd_soc_sunxi_sndspdif);
+}
+
+static int __devexit sunxi_sndspdif_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_card(&snd_soc_sunxi_sndspdif);
+	return 0;
+}
+
+static struct platform_device sunxi_sndspdif_device = {
+	.name = "sunxi-sndspdif",
+};
+
+static struct platform_driver sunxi_sndspdif_driver = {
+	.probe = sunxi_sndspdif_probe,
+	.remove = __devexit_p(sunxi_sndspdif_remove),
+	.driver = {
+		.name = "sunxi-sndspdif",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_sndspdif_init(void)
+{
+	int ret, spdif_used = 0;
+
+	ret = script_parser_fetch("spdif_para", "spdif_used", &spdif_used, 1);
+	if (ret != 0 || !spdif_used)
+		return -ENODEV;
+
+	ret = platform_device_register(&sunxi_sndspdif_device);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sunxi_sndspdif_driver);
+	if (ret < 0) {
+		platform_device_unregister(&sunxi_sndspdif_device);
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit sunxi_sndspdif_exit(void)
+{
+	platform_driver_unregister(&sunxi_sndspdif_driver);
+	platform_device_unregister(&sunxi_sndspdif_device);
+}
+
+module_init(sunxi_sndspdif_init);
+module_exit(sunxi_sndspdif_exit);
+
+MODULE_AUTHOR("ALL WINNER");
+MODULE_DESCRIPTION("SUNXI_SNDSPDIF ALSA SoC audio driver");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/sunxi/spdif/sunxi_sndspdif.h b/sound/soc/sunxi/spdif/sunxi_sndspdif.h
new file mode 100644
index 0000000..5671f6f
--- /dev/null
+++ b/sound/soc/sunxi/spdif/sunxi_sndspdif.h
@@ -0,0 +1,18 @@
+/*
+ * sound\soc\sunxi\spdif\sunxi_sndspdif.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef SUNXI_SNDSPDIF_H_
+#define SUNXI_SNDSPDIF_H_
+
+#endif
diff --git a/sound/soc/sunxi/spdif/sunxi_spdif.c b/sound/soc/sunxi/spdif/sunxi_spdif.c
new file mode 100644
index 0000000..d76e7da
--- /dev/null
+++ b/sound/soc/sunxi/spdif/sunxi_spdif.c
@@ -0,0 +1,628 @@
+/*
+ * sound\soc\sunxi\spdif\sunxi_spdif.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/clock.h>
+#include <plat/sys_config.h>
+
+#include <mach/hardware.h>
+#include <asm/dma.h>
+#include <plat/dma_compat.h>
+
+#include "sunxi_spdma.h"
+#include "sunxi_spdif.h"
+
+static int regsave[6];
+
+static struct sunxi_dma_params sunxi_spdif_stereo_out = {
+	.client.name	=	"SPDIF out",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	=	DMACH_NSPDIF,
+#endif
+	.dma_addr 	=	SUNXI_SPDIFBASE + SUNXI_SPDIF_TXFIFO,
+};
+
+static struct sunxi_dma_params sunxi_spdif_stereo_in = {
+	.client.name	=	"SPDIF out",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	=	DMACH_NSPDIF,
+#endif
+	.dma_addr 	=	SUNXI_SPDIFBASE + SUNXI_SPDIF_RXFIFO,
+};
+
+struct sunxi_spdif_info sunxi_spdif;
+static u32 spdif_handle = 0;
+static struct clk *spdif_apbclk, *spdif_pll2clk, *spdif_pllx8, *spdif_moduleclk;
+
+void sunxi_snd_txctrl(struct snd_pcm_substream *substream, int on)
+{
+	u32 reg_val;
+
+	if (substream->runtime->channels == 1) {
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+		reg_val |= SUNXI_SPDIF_TXCFG_SINGLEMOD;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+	}
+
+	//soft reset SPDIF
+	writel(0x1, sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+
+	//MCLK OUTPUT enable
+	reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+	reg_val |= SUNXI_SPDIF_CTL_MCLKOUTEN;
+	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+
+	//flush TX FIFO
+	reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_FCTL);
+	reg_val |= SUNXI_SPDIF_FCTL_FTX;
+	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_FCTL);
+
+	//clear interrupt status
+	reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_ISTA);
+	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_ISTA);
+
+	//clear TX counter
+	writel(0, sunxi_spdif.regs + SUNXI_SPDIF_TXCNT);
+
+	if (on) {
+		//SPDIF TX ENBALE
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+		reg_val |= SUNXI_SPDIF_TXCFG_TXEN;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+
+		//DRQ ENABLE
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_INT);
+		reg_val |= SUNXI_SPDIF_INT_TXDRQEN;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_INT);
+
+		//global enable
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+		reg_val |= SUNXI_SPDIF_CTL_GEN;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+	} else {
+		//SPDIF TX DISABALE
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+		reg_val &= ~SUNXI_SPDIF_TXCFG_TXEN;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+
+		//DRQ DISABLE
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_INT);
+		reg_val &= ~SUNXI_SPDIF_INT_TXDRQEN;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_INT);
+
+		//global disable
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+		reg_val &= ~SUNXI_SPDIF_CTL_GEN;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+	}
+}
+
+void sunxi_snd_rxctrl(int on)
+{
+}
+
+static inline int sunxi_snd_is_clkmaster(void)
+{
+	return 0;
+}
+
+static int sunxi_spdif_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	u32 reg_val;
+
+	reg_val = 0;
+	reg_val &= ~SUNXI_SPDIF_TXCFG_SINGLEMOD;
+	reg_val |= SUNXI_SPDIF_TXCFG_ASS;
+	reg_val &= ~SUNXI_SPDIF_TXCFG_NONAUDIO;
+	reg_val |= SUNXI_SPDIF_TXCFG_FMT16BIT;
+	reg_val |= SUNXI_SPDIF_TXCFG_CHSTMODE;
+	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+
+	reg_val = 0;
+	reg_val &= ~SUNXI_SPDIF_FCTL_FIFOSRC;
+	reg_val |= SUNXI_SPDIF_FCTL_TXTL(16);
+	reg_val |= SUNXI_SPDIF_FCTL_RXTL(15);
+	reg_val |= SUNXI_SPDIF_FCTL_TXIM(1);
+	reg_val |= SUNXI_SPDIF_FCTL_RXOM(3);
+	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_FCTL);
+
+	if (!fmt) {//PCM
+		reg_val = 0;
+		reg_val |= (SUNXI_SPDIF_TXCHSTA0_CHNUM(2));
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+		reg_val = 0;
+		reg_val |= (SUNXI_SPDIF_TXCHSTA1_SAMWORDLEN(1));
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+	} else {  //non PCM
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+		reg_val |= SUNXI_SPDIF_TXCFG_NONAUDIO;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+
+		reg_val = 0;
+		reg_val |= (SUNXI_SPDIF_TXCHSTA0_CHNUM(2));
+		reg_val |= SUNXI_SPDIF_TXCHSTA0_AUDIO;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+		reg_val = 0;
+		reg_val |= (SUNXI_SPDIF_TXCHSTA1_SAMWORDLEN(1));
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+	}
+
+	return 0;
+}
+
+static int sunxi_spdif_hw_params(struct snd_pcm_substream *substream,
+																struct snd_pcm_hw_params *params,
+																struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sunxi_dma_params *dma_data;
+
+	/* play or record */
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &sunxi_spdif_stereo_out;
+	else
+		dma_data = &sunxi_spdif_stereo_in;
+
+	snd_soc_dai_set_dma_data(rtd->cpu_dai, substream, dma_data);
+
+	return 0;
+}
+
+static int sunxi_spdif_trigger(struct snd_pcm_substream *substream,
+                              int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sunxi_dma_params *dma_data =
+					snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl(1);
+			} else {
+				sunxi_snd_txctrl(substream, 1);
+			}
+			sunxi_dma_started(dma_data);
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+				sunxi_snd_rxctrl(0);
+			} else {
+			  sunxi_snd_txctrl(substream, 0);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+		return ret;
+}
+
+//freq:   1: 22.5792MHz   0: 24.576MHz
+static int sunxi_spdif_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,
+                                 unsigned int freq, int dir)
+{
+	if (!freq) {
+		clk_set_rate(spdif_pll2clk, 24576000);
+	} else {
+		clk_set_rate(spdif_pll2clk, 22579200);
+	}
+
+	return 0;
+}
+
+static int sunxi_spdif_set_clkdiv(struct snd_soc_dai *cpu_dai, int div_id, int div)
+{
+	u32 reg_val = 0;
+
+	reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+	reg_val &= ~(SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0xf));
+	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+	reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+	reg_val &= ~(SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0xf));
+  	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+
+	switch(div_id) {
+		case SUNXI_DIV_MCLK:
+		{
+			reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+			reg_val &= ~SUNXI_SPDIF_TXCFG_TXRATIO(0x1F);
+			reg_val |= SUNXI_SPDIF_TXCFG_TXRATIO(div-1);
+			writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+
+			if(clk_get_rate(spdif_pll2clk) == 24576000)
+			{
+				switch(div)
+				{
+					//24KHZ
+					case 8:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0x6));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0x9));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					//32KHZ
+					case 6:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0x3));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0xC));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					//48KHZ
+					case 4:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0x2));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0xD));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					//96KHZ
+					case 2:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0xA));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0x5));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					//192KHZ
+					case 1:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0xE));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0x1));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					default:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(1));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+				}
+			}else{  //22.5792MHz
+				switch(div)
+				{
+					//22.05khz
+					case 8:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0x4));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0xb));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					//44.1KHZ
+					case 4:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0x0));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0xF));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					//88.2khz
+					case 2:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0x8));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0x7));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					//176.4KHZ
+					case 1:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(0xC));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0x3));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+
+					default:
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA0_SAMFREQ(1));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+
+						reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						reg_val |= (SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(0));
+						writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+						break;
+				}
+			}
+		}
+		break;
+		case SUNXI_DIV_BCLK:
+		break;
+
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+u32 sunxi_spdif_get_clockrate(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_spdif_get_clockrate);
+
+static int sunxi_spdif_dai_probe(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+static int sunxi_spdif_dai_remove(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void spdifregsave(void)
+{
+	regsave[0] = readl(sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+	regsave[1] = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+	regsave[2] = readl(sunxi_spdif.regs + SUNXI_SPDIF_FCTL) | (0x3<<16);
+	regsave[3] = readl(sunxi_spdif.regs + SUNXI_SPDIF_INT);
+	regsave[4] = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+	regsave[5] = readl(sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+}
+
+static void spdifregrestore(void)
+{
+	writel(regsave[0], sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+	writel(regsave[1], sunxi_spdif.regs + SUNXI_SPDIF_TXCFG);
+	writel(regsave[2], sunxi_spdif.regs + SUNXI_SPDIF_FCTL);
+	writel(regsave[3], sunxi_spdif.regs + SUNXI_SPDIF_INT);
+	writel(regsave[4], sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA0);
+	writel(regsave[5], sunxi_spdif.regs + SUNXI_SPDIF_TXCHSTA1);
+}
+
+//#ifdef CONFIG_PM
+static int sunxi_spdif_suspend(struct snd_soc_dai *cpu_dai)
+{
+	u32 reg_val;
+	printk("[SPDIF]Enter %s\n", __func__);
+
+	reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+	reg_val &= ~SUNXI_SPDIF_CTL_GEN;
+	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+
+	spdifregsave();
+
+	//disable the module clock
+	clk_disable(spdif_moduleclk);
+
+	clk_disable(spdif_apbclk);
+
+	printk("[SPDIF]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[SPDIF]SPECIAL CLK 0x01c200C0 = %#x, line= %d\n", *(volatile int*)0xF1C200C0, __LINE__);
+
+	return 0;
+}
+
+static int sunxi_spdif_resume(struct snd_soc_dai *cpu_dai)
+{
+	u32 reg_val;
+	printk("[SPDIF]Enter %s\n", __func__);
+
+	//disable the module clock
+	clk_enable(spdif_apbclk);
+
+	//enable the module clock
+	clk_enable(spdif_moduleclk);
+
+	spdifregrestore();
+
+	reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+	reg_val |= SUNXI_SPDIF_CTL_GEN;
+	writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+
+	//printk("[SPDIF]PLL2 0x01c20008 = %#x\n", *(volatile int*)0xF1C20008);
+	printk("[SPDIF]SPECIAL CLK 0x01c20068 = %#x, line= %d\n", *(volatile int*)0xF1C20068, __LINE__);
+	printk("[SPDIF]SPECIAL CLK 0x01c200C0 = %#x, line = %d\n", *(volatile int*)0xF1C200C0, __LINE__);
+
+	return 0;
+}
+
+#define SUNXI_SPDIF_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+static struct snd_soc_dai_ops sunxi_spdif_dai_ops = {
+	.trigger 		= sunxi_spdif_trigger,
+	.hw_params 	= sunxi_spdif_hw_params,
+	.set_fmt 		= sunxi_spdif_set_fmt,
+	.set_clkdiv = sunxi_spdif_set_clkdiv,
+	.set_sysclk = sunxi_spdif_set_sysclk,
+};
+static struct snd_soc_dai_driver sunxi_spdif_dai = {
+	.probe 		= sunxi_spdif_dai_probe,
+	.suspend 	= sunxi_spdif_suspend,
+	.resume 	= sunxi_spdif_resume,
+	.remove 	= sunxi_spdif_dai_remove,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_SPDIF_RATES,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_SPDIF_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.symmetric_rates = 1,
+	.ops = &sunxi_spdif_dai_ops,
+};
+
+static int __devinit sunxi_spdif_dev_probe(struct platform_device *pdev)
+{
+	int reg_val = 0;
+	int ret = 0;
+
+	sunxi_spdif.regs = ioremap(SUNXI_SPDIFBASE, 0x100);
+	if(sunxi_spdif.regs == NULL)
+		return -ENXIO;
+
+		//spdif apbclk
+		spdif_apbclk = clk_get(NULL, "apb_spdif");
+		if(-1 == clk_enable(spdif_apbclk)){
+			printk("spdif_apbclk failed! line = %d\n", __LINE__);
+		}
+
+		spdif_pllx8 = clk_get(NULL, "audio_pllx8");
+
+		//spdif pll2clk
+		spdif_pll2clk = clk_get(NULL, "audio_pll");
+
+		//spdif module clk
+		spdif_moduleclk = clk_get(NULL, "spdif");
+
+		if(clk_set_parent(spdif_moduleclk, spdif_pll2clk)){
+			printk("try to set parent of spdif_moduleclk to spdif_pll2ck failed! line = %d\n",__LINE__);
+		}
+
+		if(clk_set_rate(spdif_moduleclk, 24576000/8)){
+			printk("set spdif_moduleclk clock freq to 24576000 failed! line = %d\n", __LINE__);
+		}
+
+		if(-1 == clk_enable(spdif_moduleclk)){
+			printk("open spdif_moduleclk failed! line = %d\n", __LINE__);
+		}
+
+		//global enbale
+		reg_val = readl(sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+		reg_val |= SUNXI_SPDIF_CTL_GEN;
+		writel(reg_val, sunxi_spdif.regs + SUNXI_SPDIF_CTL);
+
+		ret = snd_soc_register_dai(&pdev->dev, &sunxi_spdif_dai);
+
+		iounmap(sunxi_spdif.ioregs);
+
+	return 0;
+}
+
+static int __devexit sunxi_spdif_dev_remove(struct platform_device *pdev)
+{
+	/* release the module clock */
+	clk_disable(spdif_moduleclk);
+
+	/* release pllx8clk */
+	clk_put(spdif_pllx8);
+
+	/* release pll2clk */
+	clk_put(spdif_pll2clk);
+
+	/* release apbclk */
+	clk_put(spdif_apbclk);
+
+	gpio_release(spdif_handle, 2);
+	snd_soc_unregister_dai(&pdev->dev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_device sunxi_spdif_device = {
+	.name = "sunxi-spdif",
+};
+
+static struct platform_driver sunxi_spdif_driver = {
+	.probe = sunxi_spdif_dev_probe,
+	.remove = __devexit_p(sunxi_spdif_dev_remove),
+	.driver = {
+		.name = "sunxi-spdif",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_spdif_init(void)
+{
+	int ret, spdif_used = 0;
+
+	ret = script_parser_fetch("spdif_para", "spdif_used", &spdif_used, 1);
+	if (ret != 0 || !spdif_used)
+		return -ENODEV;
+
+	ret = platform_device_register(&sunxi_spdif_device);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sunxi_spdif_driver);
+	if (ret < 0) {
+		platform_device_unregister(&sunxi_spdif_device);
+		return ret;
+	}
+	return 0;
+}
+module_init(sunxi_spdif_init);
+
+static void __exit sunxi_spdif_exit(void)
+{
+	platform_driver_unregister(&sunxi_spdif_driver);
+	platform_device_unregister(&sunxi_spdif_device);
+}
+module_exit(sunxi_spdif_exit);
+
+/* Module information */
+MODULE_AUTHOR("ALLWINNER");
+MODULE_DESCRIPTION("sunxi SPDIF SoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-spdif");
diff --git a/sound/soc/sunxi/spdif/sunxi_spdif.h b/sound/soc/sunxi/spdif/sunxi_spdif.h
new file mode 100644
index 0000000..67955d8
--- /dev/null
+++ b/sound/soc/sunxi/spdif/sunxi_spdif.h
@@ -0,0 +1,161 @@
+/*
+ * sound\soc\sunxi\spdif\sunxi_spdif.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef SUNXI_SPDIF_H_
+#define SUNXI_SPDIF_H_
+
+/*------------------SPDIF register definition--------------------*/
+#define SUNXI_SPDIFBASE 0x01C21000
+
+#define	SUNXI_SPDIF_CTL	(0x00)
+	#define SUNXI_SPDIF_CTL_MCLKDIV(v)		((v)<<4)		//v even
+	#define SUNXI_SPDIF_CTL_MCLKOUTEN			(1<<2)
+	#define SUNXI_SPDIF_CTL_GEN						(1<<1)
+	#define SUNXI_SPDIF_CTL_RESET					(1<<0)
+
+#define SUNXI_SPDIF_TXCFG (0x04)
+	#define SUNXI_SPDIF_TXCFG_SINGLEMOD		(1<<31)
+	#define SUNXI_SPDIF_TXCFG_ASS					(1<<17)
+	#define SUNXI_SPDIF_TXCFG_NONAUDIO		(1<<16)
+	#define SUNXI_SPDIF_TXCFG_TXRATIO(v)	((v)<<4)
+	#define SUNXI_SPDIF_TXCFG_FMTRVD			(3<<2)
+	#define SUNXI_SPDIF_TXCFG_FMT16BIT		(0<<2)
+	#define SUNXI_SPDIF_TXCFG_FMT20BIT		(1<<2)
+	#define SUNXI_SPDIF_TXCFG_FMT24BIT		(2<<2)
+	#define SUNXI_SPDIF_TXCFG_CHSTMODE		(1<<1)
+	#define SUNXI_SPDIF_TXCFG_TXEN				(1<<0)
+
+#define SUNXI_SPDIF_RXCFG (0x08)
+	#define SUNXI_SPDIF_RXCFG_LOCKFLAG		(1<<4)
+	#define SUNXI_SPDIF_RXCFG_CHSTSRC			(1<<3)
+	#define SUNXI_SPDIF_RXCFG_CHSTCP			(1<<1)
+	#define SUNXI_SPDIF_RXCFG_RXEN				(1<<0)
+
+#define SUNXI_SPDIF_TXFIFO (0x0C)
+
+#define SUNXI_SPDIF_RXFIFO (0x10)
+
+#define SUNXI_SPDIF_FCTL (0x14)
+	#define SUNXI_SPDIF_FCTL_FIFOSRC			(1<<31)
+	#define SUNXI_SPDIF_FCTL_FTX					(1<<17)
+	#define SUNXI_SPDIF_FCTL_FRX					(1<<16)
+	#define SUNXI_SPDIF_FCTL_TXTL(v)			((v)<<8)
+	#define SUNXI_SPDIF_FCTL_RXTL(v)			(((v))<<3)
+	#define SUNXI_SPDIF_FCTL_TXIM(v)			((v)<<2)
+	#define SUNXI_SPDIF_FCTL_RXOM(v)			((v)<<0)
+
+#define SUNXI_SPDIF_FSTA (0x18)
+	#define SUNXI_SPDIF_FSTA_TXE					(1<<14)
+	#define SUNXI_SPDIF_FSTA_TXECNTSHT		(8)
+	#define SUNXI_SPDIF_FSTA_RXA					(1<<6)
+	#define SUNXI_SPDIF_FSTA_RXACNTSHT		(0)
+
+#define SUNXI_SPDIF_INT (0x1C)
+	#define SUNXI_SPDIF_INT_RXLOCKEN			(1<<18)
+	#define SUNXI_SPDIF_INT_RXUNLOCKEN		(1<<17)
+	#define SUNXI_SPDIF_INT_RXPARERREN		(1<<16)
+	#define SUNXI_SPDIF_INT_TXDRQEN				(1<<7)
+	#define SUNXI_SPDIF_INT_TXUIEN				(1<<6)
+	#define SUNXI_SPDIF_INT_TXOIEN				(1<<5)
+	#define SUNXI_SPDIF_INT_TXEIEN				(1<<4)
+	#define SUNXI_SPDIF_INT_RXDRQEN				(1<<2)
+	#define SUNXI_SPDIF_INT_RXOIEN				(1<<1)
+	#define SUNXI_SPDIF_INT_RXAIEN				(1<<0)
+
+#define SUNXI_SPDIF_ISTA (0x20)
+	#define SUNXI_SPDIF_ISTA_RXLOCKSTA		(1<<18)
+	#define SUNXI_SPDIF_ISTA_RXUNLOCKSTA	(1<<17)
+	#define SUNXI_SPDIF_ISTA_RXPARERRSTA	(1<<16)
+	#define SUNXI_SPDIF_ISTA_TXUSTA				(1<<6)
+	#define SUNXI_SPDIF_ISTA_TXOSTA				(1<<5)
+	#define SUNXI_SPDIF_ISTA_TXESTA				(1<<4)
+	#define SUNXI_SPDIF_ISTA_RXOSTA				(1<<1)
+	#define SUNXI_SPDIF_ISTA_RXASTA				(1<<0)
+
+#define SUNXI_SPDIF_TXCNT	(0x24)
+
+#define SUNXI_SPDIF_RXCNT	(0x28)
+
+#define SUNXI_SPDIF_TXCHSTA0 (0x2C)
+	#define SUNXI_SPDIF_TXCHSTA0_CLK(v)					((v)<<28)
+	#define SUNXI_SPDIF_TXCHSTA0_SAMFREQ(v)			((v)<<24)
+	#define SUNXI_SPDIF_TXCHSTA0_CHNUM(v)				((v)<<20)
+	#define SUNXI_SPDIF_TXCHSTA0_SRCNUM(v)			((v)<<16)
+	#define SUNXI_SPDIF_TXCHSTA0_CATACOD(v)			((v)<<8)
+	#define SUNXI_SPDIF_TXCHSTA0_MODE(v)				((v)<<6)
+	#define SUNXI_SPDIF_TXCHSTA0_EMPHASIS(v)	  ((v)<<3)
+	#define SUNXI_SPDIF_TXCHSTA0_CP							(1<<2)
+	#define SUNXI_SPDIF_TXCHSTA0_AUDIO					(1<<1)
+	#define SUNXI_SPDIF_TXCHSTA0_PRO						(1<<0)
+
+#define SUNXI_SPDIF_TXCHSTA1 (0x30)
+	#define SUNXI_SPDIF_TXCHSTA1_CGMSA(v)				((v)<<8)
+	#define SUNXI_SPDIF_TXCHSTA1_ORISAMFREQ(v)	((v)<<4)
+	#define SUNXI_SPDIF_TXCHSTA1_SAMWORDLEN(v)	((v)<<1)
+	#define SUNXI_SPDIF_TXCHSTA1_MAXWORDLEN			(1<<0)
+
+#define SUNXI_SPDIF_RXCHSTA0 (0x34)
+	#define SUNXI_SPDIF_RXCHSTA0_CLK(v)					((v)<<28)
+	#define SUNXI_SPDIF_RXCHSTA0_SAMFREQ(v)			((v)<<24)
+	#define SUNXI_SPDIF_RXCHSTA0_CHNUM(v)				((v)<<20)
+	#define SUNXI_SPDIF_RXCHSTA0_SRCNUM(v)			((v)<<16)
+	#define SUNXI_SPDIF_RXCHSTA0_CATACOD(v)			((v)<<8)
+	#define SUNXI_SPDIF_RXCHSTA0_MODE(v)				((v)<<6)
+	#define SUNXI_SPDIF_RXCHSTA0_EMPHASIS(v)	  ((v)<<3)
+	#define SUNXI_SPDIF_RXCHSTA0_CP							(1<<2)
+	#define SUNXI_SPDIF_RXCHSTA0_AUDIO					(1<<1)
+	#define SUNXI_SPDIF_RXCHSTA0_PRO						(1<<0)
+
+#define SUNXI_SPDIF_RXCHSTA1 (0x38)
+	#define SUNXI_SPDIF_RXCHSTA1_CGMSA(v)				((v)<<8)
+	#define SUNXI_SPDIF_RXCHSTA1_ORISAMFREQ(v)	((v)<<4)
+	#define SUNXI_SPDIF_RXCHSTA1_SAMWORDLEN(v)	((v)<<1)
+	#define SUNXI_SPDIF_RXCHSTA1_MAXWORDLEN			(1<<0)
+
+/*--------------------------------CCM register definition---------------------*/
+#define SUNXI_CCMBASE (0x01C20000)
+
+#define SUNXI_CCMBASE_AUDIOHOSCPLL (0x08)
+	#define SUNXI_CCMBASE_AUDIOHOSCPLL_EN			(1<<31)
+	#define SUNXI_CCMBASE_AUDIOHOSCPLL_24576M		(1<<27)
+	#define SUNXI_CCMBASE_AUDIOHOSCPLL_225792M 		(0<<27)
+
+#define SUNXI_CCMBASE_APBGATE	(0x68)
+	#define SUNXI_CCMBASE_APBGATE_SPDIFGATE	(1<<1)
+
+#define SUNXI_CCMBASE_AUDIOCLK (0xC0)
+	#define SUNXI_CCMBASE_AUDIOCLK_SPDIFSPEGATE	(1<<31)
+	#define SUNXI_CCMBASE_AUDIOCLK_DIV(v)			((v)<<16)
+
+	/* Clock dividers */
+	#define SUNXI_DIV_MCLK	0
+	#define SUNXI_DIV_BCLK	1
+
+
+struct sunxi_spdif_info {
+	void __iomem   *regs;    /* IIS BASE */
+	void __iomem   *ccmregs;  //CCM BASE
+	void __iomem   *ioregs;   //IO BASE
+
+};
+
+extern struct sunxi_spdif_info sunxi_spdif;
+
+unsigned int sunxi_spdif_get_clockrate(void);
+
+extern void sunxi_snd_txctrl(struct snd_pcm_substream *substream, int on);
+extern void sunxi_snd_rxctrl(int on);
+
+#endif
diff --git a/sound/soc/sunxi/spdif/sunxi_spdma.c b/sound/soc/sunxi/spdif/sunxi_spdma.c
new file mode 100644
index 0000000..ec4ac99
--- /dev/null
+++ b/sound/soc/sunxi/spdif/sunxi_spdma.c
@@ -0,0 +1,471 @@
+/*
+ * sound\soc\sunxi\spdif\sunxi_spdma.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <plat/dma_compat.h>
+#include <plat/sys_config.h>
+
+#include "sunxi_spdif.h"
+#include "sunxi_spdma.h"
+
+static volatile unsigned int dmasrc = 0;
+static volatile unsigned int dmadst = 0;
+
+static const struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				      SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+				      SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,  //1024*1024  /* value must be (2^n)Kbyte size */
+	.period_bytes_min	= 1024*4,//1024*4,
+	.period_bytes_max	= 1024*32,//1024*128,
+	.periods_min		= 4,//8,
+	.periods_max		= 8,//8,
+	.fifo_size		= 32,//32,
+};
+
+struct sunxi_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t dma_start;
+	dma_addr_t dma_pos;
+	dma_addr_t dma_end;
+	struct sunxi_dma_params *params;
+};
+
+static void sunxi_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	dma_addr_t pos = prtd->dma_pos;
+	unsigned int limit;
+	int ret;
+
+	unsigned long len = prtd->dma_period;
+
+  	limit = prtd->dma_limit;
+  	while(prtd->dma_loaded < limit){
+		if((pos + len) > prtd->dma_end){
+			len  = prtd->dma_end - pos;
+		}
+
+		ret = sunxi_dma_enqueue(prtd->params, pos, len, 0);
+		if (ret == 0) {
+			prtd->dma_loaded++;
+			pos += prtd->dma_period;
+			if(pos >= prtd->dma_end)
+				pos = prtd->dma_start;
+		} else {
+			break;
+		  }
+	}
+	prtd->dma_pos = pos;
+}
+
+static void sunxi_audio_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	struct sunxi_runtime_data *prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	prtd = substream->runtime->private_data;
+		if (substream) {
+			snd_pcm_period_elapsed(substream);
+		}
+
+	spin_lock(&prtd->lock);
+	{
+		prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&prtd->lock);
+}
+
+static int sunxi_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	unsigned long totbytes = params_buffer_bytes(params);
+	struct sunxi_dma_params *dma =
+					snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	int ret = 0;
+	if (!dma)
+		return 0;
+
+	if (prtd->params == NULL) {
+		prtd->params = dma;
+		ret = sunxi_dma_request(prtd->params, 0);
+		if (ret < 0) {
+				return ret;
+		}
+	}
+
+	if (sunxi_dma_set_callback(prtd->params, sunxi_audio_buffdone,
+							    substream) != 0) {
+		sunxi_dma_release(prtd->params);
+		prtd->params = NULL;
+		return -EINVAL;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	runtime->dma_bytes = totbytes;
+
+	spin_lock_irq(&prtd->lock);
+	prtd->dma_loaded = 0;
+	prtd->dma_limit = runtime->hw.periods_min;
+	prtd->dma_period = params_period_bytes(params);
+	prtd->dma_start = runtime->dma_addr;
+	prtd->dma_pos = prtd->dma_start;
+	prtd->dma_end = prtd->dma_start + totbytes;
+	spin_unlock_irq(&prtd->lock);
+	return 0;
+}
+
+static int sunxi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+
+	if (prtd->params)
+		sunxi_dma_flush(prtd->params);
+
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	if (prtd->params) {
+		sunxi_dma_stop(prtd->params);
+		sunxi_dma_release(prtd->params);
+		prtd->params = NULL;
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	if (!prtd->params)
+		return 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+		struct dma_hw_conf spdif_dma_conf;
+		spdif_dma_conf.drqsrc_type  = DRQ_TYPE_SDRAM;
+		spdif_dma_conf.drqdst_type  = DRQ_TYPE_SPDIF;
+		spdif_dma_conf.xfer_type    = DMAXFER_D_BHALF_S_BHALF;
+		spdif_dma_conf.address_type = DMAADDRT_D_FIX_S_INC;
+		spdif_dma_conf.dir          = SW_DMA_WDEV;
+		spdif_dma_conf.reload       = 0;
+		spdif_dma_conf.hf_irq       = SW_DMA_IRQ_FULL;
+		spdif_dma_conf.from         = prtd->dma_start;
+		spdif_dma_conf.to           = prtd->params->dma_addr;
+#else
+		dma_config_t spdif_dma_conf;
+		memset(&spdif_dma_conf, 0, sizeof(spdif_dma_conf));
+		spdif_dma_conf.xfer_type.src_data_width = DATA_WIDTH_16BIT;
+		spdif_dma_conf.xfer_type.src_bst_len = DATA_BRST_4;
+		spdif_dma_conf.xfer_type.dst_data_width = DATA_WIDTH_16BIT;
+		spdif_dma_conf.xfer_type.dst_bst_len = DATA_BRST_4;
+		spdif_dma_conf.address_type.src_addr_mode = NDMA_ADDR_INCREMENT;
+		spdif_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_NOCHANGE;
+		spdif_dma_conf.bconti_mode = false;
+		spdif_dma_conf.irq_spt = CHAN_IRQ_FD;
+		spdif_dma_conf.src_drq_type = N_SRC_SDRAM;
+		spdif_dma_conf.dst_drq_type = N_DST_SPDIF_TX;//DRQDST_SPDIFTX;
+#endif
+		ret = sunxi_dma_config(prtd->params, &spdif_dma_conf, 0);
+	} else {
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+		struct dma_hw_conf spdif_dma_conf;
+		spdif_dma_conf.drqsrc_type  = DRQ_TYPE_SDRAM;
+		spdif_dma_conf.drqdst_type  = DRQ_TYPE_SPDIF;
+		spdif_dma_conf.xfer_type    = DMAXFER_D_BWORD_S_BWORD;
+		spdif_dma_conf.address_type = DMAADDRT_D_INC_S_FIX;
+		spdif_dma_conf.dir          = SW_DMA_RDEV;
+		spdif_dma_conf.reload       = 1;
+		spdif_dma_conf.hf_irq       = SW_DMA_IRQ_FULL|SW_DMA_IRQ_HALF;
+		spdif_dma_conf.from         = prtd->params->dma_addr;
+		spdif_dma_conf.to           = prtd->dma_start;
+		ret = sunxi_dma_config(prtd->params, &spdif_dma_conf, 0);
+#else
+		return -EINVAL;
+#endif
+	}
+	/* flush the DMA channel */
+	prtd->dma_loaded = 0;
+	if (sunxi_dma_flush(prtd->params) == 0)
+		prtd->dma_pos = prtd->dma_start;
+
+	/* enqueue dma buffers */
+	sunxi_pcm_enqueue(substream);
+
+	return ret;
+}
+
+static int sunxi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct sunxi_runtime_data *prtd = substream->runtime->private_data;
+	int ret ;
+	spin_lock(&prtd->lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		sunxi_dma_start(prtd->params);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		sunxi_dma_stop(prtd->params);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&prtd->lock);
+	return 0;
+}
+
+static snd_pcm_uframes_t sunxi_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	unsigned long res = 0;
+	snd_pcm_uframes_t offset = 0;
+
+	spin_lock(&prtd->lock);
+	sunxi_dma_getcurposition(prtd->params,
+				 (dma_addr_t*)&dmasrc, (dma_addr_t*)&dmadst);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE){
+		res = dmadst - prtd->dma_start;
+	} else {
+		offset = bytes_to_frames(runtime, dmasrc + prtd->dma_period - runtime->dma_addr);
+	}
+	spin_unlock(&prtd->lock);
+
+	if(offset >= runtime->buffer_size)
+		offset = 0;
+		return offset;
+}
+
+static int sunxi_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd;
+
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+
+	prtd = kzalloc(sizeof(struct sunxi_runtime_data), GFP_KERNEL);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&prtd->lock);
+
+	runtime->private_data = prtd;
+	return 0;
+}
+
+static int sunxi_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_runtime_data *prtd = runtime->private_data;
+	kfree(prtd);
+
+	return 0;
+}
+
+static int sunxi_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops sunxi_pcm_ops = {
+	.open			= sunxi_pcm_open,
+	.close			= sunxi_pcm_close,
+	.ioctl			= snd_pcm_lib_ioctl,
+	.hw_params		= sunxi_pcm_hw_params,
+	.hw_free		= sunxi_pcm_hw_free,
+	.prepare		= sunxi_pcm_prepare,
+	.trigger		= sunxi_pcm_trigger,
+	.pointer		= sunxi_pcm_pointer,
+	.mmap			= sunxi_pcm_mmap,
+};
+
+static int sunxi_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = sunxi_pcm_hardware.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void sunxi_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static u64 sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+static int sunxi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+ out:
+	return ret;
+}
+
+static struct snd_soc_platform_driver sunxi_soc_platform = {
+	.ops  		=   &sunxi_pcm_ops,
+	.pcm_new	=	sunxi_pcm_new,
+	.pcm_free	=	sunxi_pcm_free_dma_buffers,
+};
+
+static int __devinit sunxi_spdif_pcm_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &sunxi_soc_platform);
+}
+
+static int __devexit sunxi_spdif_pcm_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+/*data relating*/
+static struct platform_device sunxi_spdif_pcm_device = {
+	.name = "sunxi-spdif-pcm-audio",
+};
+
+/*method relating*/
+static struct platform_driver sunxi_spdif_pcm_driver = {
+	.probe = sunxi_spdif_pcm_probe,
+	.remove = __devexit_p(sunxi_spdif_pcm_remove),
+	.driver = {
+		.name = "sunxi-spdif-pcm-audio",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init sunxi_soc_platform_spdif_init(void)
+{
+	int ret, spdif_used = 0;
+
+	ret = script_parser_fetch("spdif_para", "spdif_used", &spdif_used, 1);
+	if (ret != 0 || !spdif_used)
+		return -ENODEV;
+
+	ret = platform_device_register(&sunxi_spdif_pcm_device);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sunxi_spdif_pcm_driver);
+	if (ret < 0) {
+		platform_device_unregister(&sunxi_spdif_pcm_device);
+		return ret;
+	}
+	return 0;
+}
+module_init(sunxi_soc_platform_spdif_init);
+
+static void __exit sunxi_soc_platform_spdif_exit(void)
+{
+	platform_driver_unregister(&sunxi_spdif_pcm_driver);
+	platform_device_unregister(&sunxi_spdif_pcm_device);
+}
+module_exit(sunxi_soc_platform_spdif_exit);
+
+MODULE_AUTHOR("All winner");
+MODULE_DESCRIPTION("SUNXI SPDIF DMA module");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/spdif/sunxi_spdma.h b/sound/soc/sunxi/spdif/sunxi_spdma.h
new file mode 100644
index 0000000..71bfc98
--- /dev/null
+++ b/sound/soc/sunxi/spdif/sunxi_spdma.h
@@ -0,0 +1,29 @@
+/*
+ * sound\soc\sunxi\spdif\sunxi_spdma.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * chenpailin <chenpailin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef SUNXI_SPDMA_H_
+#define SUNXI_SPDMA_H_
+
+#define ST_RUNNING    (1<<0)
+#define ST_OPENED     (1<<1)
+
+#define SUNXI_DAI_SPDIF			1
+
+enum sunxidma_buffresult {
+	SUNXI_RES_OK,
+	SUNXI_RES_ERR,
+	SUNXI_RES_ABORT
+};
+
+#endif
diff --git a/sound/soc/sunxi/sunxi-codec.c b/sound/soc/sunxi/sunxi-codec.c
new file mode 100644
index 0000000..9d604c9
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-codec.c
@@ -0,0 +1,1701 @@
+/*
+ *   Driver for CODEC on M1 soundcard
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License.
+ *
+*
+***************************************************************************************************/
+#define DEBUG
+#ifndef CONFIG_PM
+#define CONFIG_PM
+#endif
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <plat/dma_compat.h>
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include "sunxi-codec.h"
+#include <plat/sys_config.h>
+#include <mach/system.h>
+
+#define SCRIPT_AUDIO_OK (0)
+static int has_playback, has_capture;
+static int gpio_pa_shutdown = 0;
+struct clk *codec_apbclk,*codec_pll2clk,*codec_moduleclk;
+
+static volatile unsigned int capture_dmasrc = 0;
+static volatile unsigned int capture_dmadst = 0;
+static volatile unsigned int play_dmasrc = 0;
+static volatile unsigned int play_dmadst = 0;
+
+/* Structure/enum declaration ------------------------------- */
+typedef struct codec_board_info {
+	struct device	*dev;	     		/* parent device */
+	struct resource	*codec_base_res;   /* resources found */
+	struct resource	*codec_base_req;   /* resources found */
+
+	spinlock_t	lock;
+} codec_board_info_t;
+
+static struct sunxi_dma_params sunxi_codec_pcm_stereo_play = {
+	.client.name	= "CODEC PCM Stereo PLAY",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	= DMACH_NADDA_PLAY,
+#endif
+	.dma_addr	= CODEC_BASSADDRESS + SUNXI_DAC_TXDATA,//发送数据地址
+};
+
+static struct sunxi_dma_params sunxi_codec_pcm_stereo_capture = {
+	.client.name	= "CODEC PCM Stereo CAPTURE",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel	= DMACH_NADDA_CAPTURE,  //only support half full
+#endif	
+	.dma_addr	= CODEC_BASSADDRESS + SUNXI_ADC_RXDATA,//接收数据地址
+};
+
+struct sunxi_playback_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t   dma_start;
+	dma_addr_t   dma_pos;
+	dma_addr_t	 dma_end;
+	struct sunxi_dma_params	*params;
+};
+
+struct sunxi_capture_runtime_data {
+	spinlock_t lock;
+	int state;
+	unsigned int dma_loaded;
+	unsigned int dma_limit;
+	unsigned int dma_period;
+	dma_addr_t   dma_start;
+	dma_addr_t   dma_pos;
+	dma_addr_t	 dma_end;
+	struct sunxi_dma_params	*params;
+};
+
+/*播放设备硬件定义*/
+static struct snd_pcm_hardware sunxi_pcm_playback_hardware =
+{
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED |
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				   SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+				   SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |SNDRV_PCM_RATE_11025 |\
+				   SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 |\
+				   SNDRV_PCM_RATE_44100| SNDRV_PCM_RATE_48000 |SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+				   SNDRV_PCM_RATE_KNOT),
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,//最大的缓冲区大小
+	.period_bytes_min	= 1024*4,//最小周期大小
+	.period_bytes_max	= 1024*32,//最大周期大小
+	.periods_min		= 4,//最小周期数
+	.periods_max		= 8,//最大周期数
+	.fifo_size	     	= 32,//fifo字节数
+};
+
+/*录音设备硬件定义*/
+static struct snd_pcm_hardware sunxi_pcm_capture_hardware =
+{
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED |
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				   SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+				   SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |SNDRV_PCM_RATE_11025 |\
+				   SNDRV_PCM_RATE_22050| SNDRV_PCM_RATE_32000 |\
+				   SNDRV_PCM_RATE_44100| SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 |SNDRV_PCM_RATE_192000 |\
+				   SNDRV_PCM_RATE_KNOT),
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 2,
+	.buffer_bytes_max	= 128*1024,//最大的缓冲区大小
+	.period_bytes_min	= 1024*4,//最小周期大小
+	.period_bytes_max	= 1024*32,//最大周期大小
+	.periods_min		= 4,//最小周期数
+	.periods_max		= 8,//最大周期数
+	.fifo_size	     	= 32,//fifo字节数
+};
+
+struct sunxi_codec{
+	long samplerate;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+};
+
+static void codec_resume_events(struct work_struct *work);
+struct workqueue_struct *resume_work_queue;
+static DECLARE_WORK(codec_resume_work, codec_resume_events);
+
+static unsigned int rates[] = {
+	8000,11025,12000,16000,
+	22050,24000,24000,32000,
+	44100,48000,96000,192000
+};
+
+static struct snd_pcm_hw_constraint_list hw_constraints_rates = {
+	.count	= ARRAY_SIZE(rates),
+	.list	= rates,
+	.mask	= 0,
+};
+
+/**
+* codec_wrreg_bits - update codec register bits
+* @reg: codec register
+* @mask: register mask
+* @value: new value
+*
+* Writes new register value.
+* Return 1 for change else 0.
+*/
+int codec_wrreg_bits(unsigned short reg, unsigned int	mask,	unsigned int value)
+{
+	int change;
+	unsigned int old, new;
+
+	old	=	codec_rdreg(reg);
+	new	=	(old & ~mask) | value;
+	change = old != new;
+
+	if (change){
+		codec_wrreg(reg,new);
+	}
+
+	return change;
+}
+
+/**
+*	snd_codec_info_volsw	-	single	mixer	info	callback
+*	@kcontrol:	mixer control
+*	@uinfo:	control	element	information
+*	Callback to provide information about a single mixer control
+*
+* 	info()函数用于获得该control的详细信息，该函数必须填充传递给它的第二个参数snd_ctl_elem_info结构体
+*
+*	Returns 0 for success
+*/
+int snd_codec_info_volsw(struct snd_kcontrol *kcontrol,
+		struct	snd_ctl_elem_info	*uinfo)
+{
+	struct	codec_mixer_control *mc	= (struct codec_mixer_control*)kcontrol->private_value;
+	int	max	=	mc->max;
+	unsigned int shift  = mc->shift;
+	unsigned int rshift = mc->rshift;
+
+	if(max	== 1)
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;//the info of type
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = shift ==	rshift	?	1:	2;	//the info of elem count
+	uinfo->value.integer.min = 0;				//the info of min value
+	uinfo->value.integer.max = max;				//the info of max value
+	return	0;
+}
+
+/**
+*	snd_codec_get_volsw	-	single	mixer	get	callback
+*	@kcontrol:	mixer	control
+*	@ucontrol:	control	element	information
+*
+*	Callback to get the value of a single mixer control
+*	get()函数用于得到control的目前值并返回用户空间
+*	return 0 for success.
+*/
+int snd_codec_get_volsw(struct snd_kcontrol	*kcontrol,
+		struct	snd_ctl_elem_value	*ucontrol)
+{
+	struct codec_mixer_control *mc= (struct codec_mixer_control*)kcontrol->private_value;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int	max = mc->max;
+	/*fls(7) = 3,fls(1)=1,fls(0)=0,fls(15)=4,fls(3)=2,fls(23)=5*/
+	unsigned int mask = (1 << fls(max)) -1;
+	unsigned int invert = mc->invert;
+	unsigned int reg = mc->reg;
+
+	ucontrol->value.integer.value[0] =
+		(codec_rdreg(reg)>>	shift) & mask;
+	if(shift != rshift)
+		ucontrol->value.integer.value[1] =
+			(codec_rdreg(reg) >> rshift) & mask;
+
+	/*将获得的值写入snd_ctl_elem_value*/
+	if(invert){
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+		if(shift != rshift)
+			ucontrol->value.integer.value[1] =
+				max - ucontrol->value.integer.value[1];
+		}
+
+		return 0;
+}
+
+/**
+*	snd_codec_put_volsw	-	single	mixer put callback
+*	@kcontrol:	mixer	control
+*	@ucontrol:	control	element	information
+*
+*	put()用于从用户空间写入值，如果值被改变，该函数返回1，否则返回0.
+*	Callback to put the value of a single mixer control
+*
+* return 0 for success.
+*/
+int snd_codec_put_volsw(struct	snd_kcontrol	*kcontrol,
+	struct	snd_ctl_elem_value	*ucontrol)
+{
+	struct codec_mixer_control *mc= (struct codec_mixer_control*)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	unsigned int rshift = mc->rshift;
+	int max = mc->max;
+	unsigned int mask = (1<<fls(max))-1;
+	unsigned int invert = mc->invert;
+	unsigned int	val, val2, val_mask;
+
+	val = (ucontrol->value.integer.value[0] & mask);
+	if(invert)
+		val = max - val;
+	val <<= shift;
+	val_mask = mask << shift;
+	if(shift != rshift){
+		val2	= (ucontrol->value.integer.value[1] & mask);
+		if(invert)
+			val2	=	max	- val2;
+		val_mask |= mask <<rshift;
+		val |= val2 <<rshift;
+	}
+
+	return codec_wrreg_bits(reg,val_mask,val);
+}
+
+int codec_wr_control(u32 reg, u32 mask, u32 shift, u32 val)
+{
+	u32 reg_val;
+	reg_val = val << shift;
+	mask = mask << shift;
+	codec_wrreg_bits(reg, mask, reg_val);
+	return 0;
+}
+
+int codec_rd_control(u32 reg, u32 bit, u32 *val)
+{
+	return 0;
+}
+
+/**
+*	codec_reset - reset the codec
+* @codec	SoC Audio Codec
+* Reset the codec, set the register of codec default value
+* Return 0 for success
+*/
+static  int codec_init(void)
+{
+	enum sw_ic_ver  codec_chip_ver = sw_get_ic_ver();
+
+	//enable dac digital
+	codec_wr_control(SUNXI_DAC_DPC, 0x1, DAC_EN, 0x1);
+
+	codec_wr_control(SUNXI_DAC_FIFOC ,  0x1,28, 0x1);
+	//set digital volume to maximum
+	if (codec_chip_ver == SUNXI_VER_A10A)
+		codec_wr_control(SUNXI_DAC_DPC, 0x6, DIGITAL_VOL, 0x0);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	//enable PA
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	codec_wr_control(SUNXI_DAC_FIFOC, 0x3, DRA_LEVEL,0x3);
+	//set volume
+	if (sunxi_is_sun4i()) {
+		int rc;
+		int device_lr_change = 0;
+		if (codec_chip_ver == SUNXI_VER_A10A)
+			codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x01);
+		else if (codec_chip_ver == SUNXI_VER_A10B ||
+			 codec_chip_ver == SUNXI_VER_A10C)
+			codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x3b);
+		else {
+			printk("[audio codec] chip version is unknown!\n");
+			return -1;
+		}
+		rc = script_parser_fetch("audio_para", "audio_lr_change",
+					 &device_lr_change, 1);
+		if (rc != SCRIPT_AUDIO_OK) {
+			pr_err("No audio_lr_change in fex audio_para\n");
+			return -1;
+		}
+		if (device_lr_change)
+			codec_wr_control(SUNXI_DAC_DEBUG, 0x1,
+					 DAC_CHANNEL, 0x1);
+	} else {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x6, VOLUME, 0x3b);
+	}
+	return 0;
+}
+
+static int codec_play_open(struct snd_pcm_substream *substream)
+{
+	codec_wr_control(SUNXI_DAC_DPC ,  0x1, DAC_EN, 0x1);
+	codec_wr_control(SUNXI_DAC_FIFOC ,0x1, DAC_FIFO_FLUSH, 0x1);
+	//set TX FIFO send drq level
+	codec_wr_control(SUNXI_DAC_FIFOC ,0x4, TX_TRI_LEVEL, 0xf);
+	if(substream->runtime->rate > 32000){
+		codec_wr_control(SUNXI_DAC_FIFOC ,  0x1,28, 0x0);
+	}else{
+		codec_wr_control(SUNXI_DAC_FIFOC ,  0x1,28, 0x1);
+	}
+	//set TX FIFO MODE
+	codec_wr_control(SUNXI_DAC_FIFOC ,0x1, TX_FIFO_MODE, 0x1);
+	//send last sample when dac fifo under run
+	codec_wr_control(SUNXI_DAC_FIFOC ,0x1, LAST_SE, 0x0);
+	//enable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_L, 0x1);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_R, 0x1);
+	//enable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACPAS, 0x1);
+	return 0;
+}
+
+static int codec_capture_open(void)
+{
+	 //enable mic1 pa
+	 codec_wr_control(SUNXI_ADC_ACTL, 0x1, MIC1_EN, 0x1);
+	 //mic1 gain 32dB
+	 codec_wr_control(SUNXI_ADC_ACTL, 0x3,25,0x1);
+	  //enable VMIC
+	 codec_wr_control(SUNXI_ADC_ACTL, 0x1, VMIC_EN, 0x1);
+
+	if (sunxi_is_sun7i()) {
+		/* boost up record effect */
+		codec_wr_control(SUNXI_DAC_TUNE, 0x3, 8, 0x3);
+	}
+
+	 //enable adc digital
+	 codec_wr_control(SUNXI_ADC_FIFOC, 0x1,ADC_DIG_EN, 0x1);
+	 //set RX FIFO mode
+	 codec_wr_control(SUNXI_ADC_FIFOC, 0x1, RX_FIFO_MODE, 0x1);
+	 //flush RX FIFO
+	 codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x1);
+	 //set RX FIFO rec drq level
+	 codec_wr_control(SUNXI_ADC_FIFOC, 0xf, RX_TRI_LEVEL, 0x7);
+	 //enable adc1 analog
+	 codec_wr_control(SUNXI_ADC_ACTL, 0x3,  ADC_EN, 0x3);
+	 return 0;
+}
+
+static int codec_play_start(void)
+{
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	//flush TX FIFO
+	codec_wr_control(SUNXI_DAC_FIFOC ,0x1, DAC_FIFO_FLUSH, 0x1);
+	//enable dac drq
+	codec_wr_control(SUNXI_DAC_FIFOC ,0x1, DAC_DRQ, 0x1);
+	return 0;
+}
+
+static int codec_play_stop(void)
+{
+	//pa mute
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(5);
+	//disable dac drq
+	codec_wr_control(SUNXI_DAC_FIFOC ,0x1, DAC_DRQ, 0x0);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_R, 0x0);
+	return 0;
+}
+
+static int codec_capture_start(void)
+{
+	//enable adc drq
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	codec_wr_control(SUNXI_ADC_FIFOC ,0x1, ADC_DRQ, 0x1);
+	return 0;
+}
+
+static int codec_capture_stop(void)
+{
+	//disable adc drq
+	codec_wr_control(SUNXI_ADC_FIFOC ,0x1, ADC_DRQ, 0x0);
+	//enable mic1 pa
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, MIC1_EN, 0x0);
+
+	//enable VMIC
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, VMIC_EN, 0x0);
+
+	if (sunxi_is_sun7i())
+		codec_wr_control(SUNXI_DAC_TUNE, 0x3, 8, 0x0);
+
+	//enable adc digital
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1,ADC_DIG_EN, 0x0);
+	//set RX FIFO mode
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, RX_FIFO_MODE, 0x0);
+	//flush RX FIFO
+	codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x0);
+	//enable adc1 analog
+	codec_wr_control(SUNXI_ADC_ACTL, 0x3,  ADC_EN, 0x0);
+	return 0;
+}
+
+static int codec_dev_free(struct snd_device *device)
+{
+	return 0;
+};
+
+/*	对sunxi-codec.c各寄存器的各种设定，或读取。主要实现函数有三个.
+* 	.info = snd_codec_info_volsw, .get = snd_codec_get_volsw,\.put = snd_codec_put_volsw,
+* It should be noted that the only difference between sunxi and sun5i is the Master Playback Volume
+*/
+static const struct snd_kcontrol_new sunxibc_dac[] = {
+	//FOR B C VERSION
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL,0,0x3f,0),
+	CODEC_SINGLE("Playback Switch", SUNXI_DAC_ACTL,6,1,0),//全局输出开关
+	CODEC_SINGLE("Fm Volume",SUNXI_DAC_ACTL,23,7,0),//Fm 音量
+	CODEC_SINGLE("Line Volume",SUNXI_DAC_ACTL,26,1,0),//Line音量
+	CODEC_SINGLE("FmL Switch",SUNXI_DAC_ACTL,17,1,0),//Fm左开关
+	CODEC_SINGLE("FmR Switch",SUNXI_DAC_ACTL,16,1,0),//Fm右开关
+	CODEC_SINGLE("LineL Switch",SUNXI_DAC_ACTL,19,1,0),//Line左开关
+	CODEC_SINGLE("LineR Switch",SUNXI_DAC_ACTL,18,1,0),//Line右开关
+	CODEC_SINGLE("Ldac Left Mixer",SUNXI_DAC_ACTL,15,1,0),
+	CODEC_SINGLE("Rdac Right Mixer",SUNXI_DAC_ACTL,14,1,0),
+	CODEC_SINGLE("Ldac Right Mixer",SUNXI_DAC_ACTL,13,1,0),
+	CODEC_SINGLE("Mic Input Mux",SUNXI_DAC_ACTL,9,15,0),//from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new sunxia_dac[] = {
+	//For A VERSION
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_DPC,12,0x3f,0),//62 steps, 3e + 1 = 3f 主音量控制
+	CODEC_SINGLE("Playback Switch", SUNXI_DAC_ACTL,6,1,0),//全局输出开关
+	CODEC_SINGLE("Fm Volume",SUNXI_DAC_ACTL,23,7,0),//Fm 音量
+	CODEC_SINGLE("Line Volume",SUNXI_DAC_ACTL,26,1,0),//Line音量
+	CODEC_SINGLE("FmL Switch",SUNXI_DAC_ACTL,17,1,0),//Fm左开关
+	CODEC_SINGLE("FmR Switch",SUNXI_DAC_ACTL,16,1,0),//Fm右开关
+	CODEC_SINGLE("LineL Switch",SUNXI_DAC_ACTL,19,1,0),//Line左开关
+	CODEC_SINGLE("LineR Switch",SUNXI_DAC_ACTL,18,1,0),//Line右开关
+	CODEC_SINGLE("Ldac Left Mixer",SUNXI_DAC_ACTL,15,1,0),
+	CODEC_SINGLE("Rdac Right Mixer",SUNXI_DAC_ACTL,14,1,0),
+	CODEC_SINGLE("Ldac Right Mixer",SUNXI_DAC_ACTL,13,1,0),
+	CODEC_SINGLE("Mic Input Mux",SUNXI_DAC_ACTL,9,15,0),//from bit 9 to bit 12.Mic（麦克风）输入静音
+};
+
+static const struct snd_kcontrol_new codec_adc_controls[] = {
+	CODEC_SINGLE("Capture Volume",SUNXI_ADC_ACTL,20,7,0),//录音音量
+	CODEC_SINGLE("MicL Volume",SUNXI_ADC_ACTL,25,3,0),//mic左音量
+	CODEC_SINGLE("MicR Volume",SUNXI_ADC_ACTL,23,3,0),//mic右音量
+	CODEC_SINGLE("ADC Input Mux",SUNXI_ADC_ACTL,17,7,0),//ADC输入静音
+};
+
+static const struct snd_kcontrol_new sun7i_dac_ctls[] = {
+	/*SUNXI_DAC_ACTL = 0x10,PAVOL*/
+	CODEC_SINGLE("Master Playback Volume", SUNXI_DAC_ACTL, 0, 0x3f, 0),
+	CODEC_SINGLE("MIC output volume", SUNXI_DAC_ACTL, 20, 7, 0),
+	/*	FM Input to output mixer Gain Control
+	 * 	From -4.5db to 6db,1.5db/step,default is 0db
+	 *	-4.5db:0x0,-3.0db:0x1,-1.5db:0x2,0db:0x3
+	 *	1.5db:0x4,3.0db:0x5,4.5db:0x6,6db:0x7
+	 */
+	CODEC_SINGLE("Fm output Volume", SUNXI_DAC_ACTL, 23,  7, 0),
+	/*	Line-in gain stage to output mixer Gain Control
+	 *	0:-1.5db,1:0db
+	 */
+	CODEC_SINGLE("Line output Volume", SUNXI_DAC_ACTL, 26, 1, 0),
+};
+
+static const struct snd_kcontrol_new sun7i_adc_ctls[] = {
+	CODEC_SINGLE("LINEIN APM Volume", SUNXI_MIC_CRT, 13, 0x7, 0),
+	/* ADC Input Gain Control, capture volume
+	 * 000:-4.5db,001:-3db,010:-1.5db,011:0db,100:1.5db,101:3db,110:4.5db,111:6db
+	 */
+	CODEC_SINGLE("Capture Volume", SUNXI_ADC_ACTL, 20, 7, 0),
+	/*
+	 *	MIC2 pre-amplifier Gain Control
+	 *	00:0db,01:35db,10:38db,11:41db
+	 */
+	CODEC_SINGLE("Mic2 gain Volume", SUNXI_MIC_CRT, 26, 7, 0),
+	/*
+	 *	MIC1 pre-amplifier Gain Control
+	 *	00:0db,01:35db,10:38db,11:41db
+	 */
+	CODEC_SINGLE("Mic1 gain Volume", SUNXI_MIC_CRT, 29, 3, 0),
+};
+
+int __devinit snd_chip_codec_mixer_new(struct snd_card *card)
+{
+  	/*
+  	*	每个alsa预定义的组件在构造时需调用snd_device_new()，而每个组件的析构方法则在函数集中被包含
+  	*	对于PCM、AC97此类预定义组件，我们不需要关心它们的析构，而对于自定义的组件，则需要填充snd_device_ops
+  	*	中的析构函数指针dev_free，这样，当snd_card_free()被调用时，组件将被自动释放。
+  	*/
+  	static struct snd_device_ops ops = {
+  		.dev_free	=	codec_dev_free,
+  	};
+  	unsigned char *clnt = "codec";
+	int idx, err;
+	/*
+	*	snd_ctl_new1函数用于创建一个snd_kcontrol并返回其指针，
+	*	snd_ctl_add函数用于将创建的snd_kcontrol添加到对应的card中。
+	*/
+	enum sw_ic_ver  codec_chip_ver = sw_get_ic_ver();
+
+	if (codec_chip_ver == SUNXI_VER_A10A) {
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sunxia_dac); idx++)
+				if ((err = snd_ctl_add(card, snd_ctl_new1(&sunxia_dac[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(codec_adc_controls); idx++)
+				if ((err = snd_ctl_add(card, snd_ctl_new1(&codec_adc_controls[idx], clnt))) < 0)
+					return err;
+	} else if (sunxi_is_sun5i() ||
+		   codec_chip_ver == SUNXI_VER_A10B ||
+		   codec_chip_ver == SUNXI_VER_A10C) {
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sunxibc_dac); idx++)
+				if ((err = snd_ctl_add(card, snd_ctl_new1(&sunxibc_dac[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(codec_adc_controls); idx++)
+				if ((err = snd_ctl_add(card, snd_ctl_new1(&codec_adc_controls[idx], clnt))) < 0)
+					return err;
+	} else if (sunxi_is_sun7i()) {
+		if (has_playback)
+			for (idx = 0; idx < ARRAY_SIZE(sun7i_dac_ctls); idx++)
+				if ((err = snd_ctl_add(card, snd_ctl_new1(&sun7i_dac_ctls[idx], clnt))) < 0)
+					return err;
+		if (has_capture)
+			for (idx = 0; idx < ARRAY_SIZE(sun7i_adc_ctls); idx++)
+				if ((err = snd_ctl_add(card, snd_ctl_new1(&sun7i_adc_ctls[idx], clnt))) < 0)
+					return err;
+	} else {
+		printk("[audio codec] chip version is unknown!\n");
+		return -1;
+	}
+
+	/*
+	*	当card被创建后，设备（组件）能够被创建并关联于该card。第一个参数是snd_card_create
+	*	创建的card指针，第二个参数type指的是device-level即设备类型，形式为SNDRV_DEV_XXX,包括
+	*	SNDRV_DEV_CODEC、SNDRV_DEV_CONTROL、SNDRV_DEV_PCM、SNDRV_DEV_RAWMIDI等、用户自定义的
+	*	设备的device-level是SNDRV_DEV_LOWLEVEL，ops参数是1个函数集（snd_device_ops结构体）的
+	*	指针，device_data是设备数据指针，snd_device_new本身不会分配设备数据的内存，因此事先应
+	*	分配。在这里在snd_card_create分配。
+	*/
+	if ((err = snd_device_new(card, SNDRV_DEV_CODEC, clnt, &ops)) < 0) {
+		return err;
+	}
+
+	strcpy(card->mixername, "codec Mixer");
+
+	return 0;
+}
+
+static void sunxi_pcm_enqueue(struct snd_pcm_substream *substream)
+{
+	int play_ret = 0, capture_ret = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	dma_addr_t play_pos = 0, capture_pos = 0;
+	unsigned long play_len = 0, capture_len = 0;
+	unsigned int play_limit = 0, capture_limit = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		play_prtd = substream->runtime->private_data;
+		play_pos = play_prtd->dma_pos;
+		play_len = play_prtd->dma_period;
+		play_limit = play_prtd->dma_limit;
+		while(play_prtd->dma_loaded < play_limit){
+			if((play_pos + play_len) > play_prtd->dma_end){
+				play_len  = play_prtd->dma_end - play_pos;
+			}
+			play_ret = sunxi_dma_enqueue(play_prtd->params,
+						     play_pos, play_len, 0);
+			if(play_ret == 0){
+				play_prtd->dma_loaded++;
+				play_pos += play_prtd->dma_period;
+				if(play_pos >= play_prtd->dma_end)
+					play_pos = play_prtd->dma_start;
+			}else{
+				break;
+			}
+		}
+		play_prtd->dma_pos = play_pos;
+	}else{
+		capture_prtd = substream->runtime->private_data;
+		capture_pos = capture_prtd->dma_pos;
+		capture_len = capture_prtd->dma_period;
+		capture_limit = capture_prtd->dma_limit;
+		while(capture_prtd->dma_loaded < capture_limit){
+			if((capture_pos + capture_len) > capture_prtd->dma_end){
+				capture_len  = capture_prtd->dma_end - capture_pos;
+			}
+			capture_ret = sunxi_dma_enqueue(capture_prtd->params,
+						  capture_pos, capture_len, 1);
+			if(capture_ret == 0){
+			capture_prtd->dma_loaded++;
+			capture_pos += capture_prtd->dma_period;
+			if(capture_pos >= capture_prtd->dma_end)
+			capture_pos = capture_prtd->dma_start;
+			}else{
+				break;
+			}
+		}
+		capture_prtd->dma_pos = capture_pos;
+	}
+}
+
+static void sunxi_audio_capture_buffdone(struct sunxi_dma_params *dma,
+	void *dev_id)
+{
+	struct sunxi_capture_runtime_data *capture_prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	capture_prtd = substream->runtime->private_data;
+		if (substream){
+			snd_pcm_period_elapsed(substream);
+		}
+
+	spin_lock(&capture_prtd->lock);
+	{
+		capture_prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&capture_prtd->lock);
+}
+
+static void sunxi_audio_play_buffdone(struct sunxi_dma_params *dma,
+	void *dev_id)
+{
+	struct sunxi_playback_runtime_data *play_prtd;
+	struct snd_pcm_substream *substream = dev_id;
+
+	play_prtd = substream->runtime->private_data;
+	if (substream){
+		snd_pcm_period_elapsed(substream);
+	}
+
+	spin_lock(&play_prtd->lock);
+	{
+		play_prtd->dma_loaded--;
+		sunxi_pcm_enqueue(substream);
+	}
+	spin_unlock(&play_prtd->lock);
+}
+
+static snd_pcm_uframes_t snd_sunxi_codec_pointer(struct snd_pcm_substream *substream)
+{
+	unsigned long play_res = 0, capture_res = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+    	play_prtd = substream->runtime->private_data;
+   		spin_lock(&play_prtd->lock);
+   		sunxi_dma_getcurposition(play_prtd->params,
+   			(dma_addr_t*)&play_dmasrc, (dma_addr_t*)&play_dmadst);
+		play_res = play_dmasrc + play_prtd->dma_period - play_prtd->dma_start;
+		spin_unlock(&play_prtd->lock);
+		if (play_res >= snd_pcm_lib_buffer_bytes(substream)) {
+			if (play_res == snd_pcm_lib_buffer_bytes(substream))
+				play_res = 0;
+		}
+		return bytes_to_frames(substream->runtime, play_res);
+    }else{
+    	capture_prtd = substream->runtime->private_data;
+    	spin_lock(&capture_prtd->lock);
+		sunxi_dma_getcurposition(capture_prtd->params,
+		   (dma_addr_t*)&capture_dmasrc, (dma_addr_t*)&capture_dmadst);
+    	capture_res = capture_dmadst + capture_prtd->dma_period - capture_prtd->dma_start;
+    	spin_unlock(&capture_prtd->lock);
+    	if (capture_res >= snd_pcm_lib_buffer_bytes(substream)) {
+			if (capture_res == snd_pcm_lib_buffer_bytes(substream))
+				capture_res = 0;
+		}
+		return bytes_to_frames(substream->runtime, capture_res);
+    }
+}
+
+static int sunxi_codec_pcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+    int play_ret = 0, capture_ret = 0;
+    struct snd_pcm_runtime *play_runtime = NULL, *capture_runtime = NULL;
+    struct sunxi_playback_runtime_data *play_prtd = NULL;
+    struct sunxi_capture_runtime_data *capture_prtd = NULL;
+    unsigned long play_totbytes = 0, capture_totbytes = 0;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+	  	play_runtime = substream->runtime;
+		play_prtd = play_runtime->private_data;
+		play_totbytes = params_buffer_bytes(params);
+		snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if(play_prtd->params == NULL){
+			play_prtd->params = &sunxi_codec_pcm_stereo_play;
+			play_ret = sunxi_dma_request(play_prtd->params, 0);
+			if(play_ret < 0){
+				printk(KERN_ERR "failed to get dma channel. ret == %d\n", play_ret);
+				return play_ret;
+			}
+			play_ret = sunxi_dma_set_callback(play_prtd->params,
+					sunxi_audio_play_buffdone, substream);
+			if (play_ret < 0){
+				printk(KERN_ERR "failed to set dma callback. ret == %d\n", play_ret);
+				sunxi_dma_release(play_prtd->params);
+				play_prtd->params = NULL;
+				return play_ret;
+			}
+			snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+			play_runtime->dma_bytes = play_totbytes;
+   			spin_lock_irq(&play_prtd->lock);
+			play_prtd->dma_loaded = 0;
+			play_prtd->dma_limit = play_runtime->hw.periods_min;
+			play_prtd->dma_period = params_period_bytes(params);
+			play_prtd->dma_start = play_runtime->dma_addr;
+
+			play_dmasrc = play_prtd->dma_start;
+			play_prtd->dma_pos = play_prtd->dma_start;
+			play_prtd->dma_end = play_prtd->dma_start + play_totbytes;
+
+			spin_unlock_irq(&play_prtd->lock);
+		}
+	}else if(substream->stream == SNDRV_PCM_STREAM_CAPTURE){
+		capture_runtime = substream->runtime;
+		capture_prtd = capture_runtime->private_data;
+		capture_totbytes = params_buffer_bytes(params);
+		snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+		if(capture_prtd->params == NULL){
+			capture_prtd->params = &sunxi_codec_pcm_stereo_capture;
+			capture_ret = sunxi_dma_request(capture_prtd->params, 0);
+			if(capture_ret < 0){
+				printk(KERN_ERR "failed to get dma channel. capture_ret == %d\n", capture_ret);
+				return capture_ret;
+			}
+			capture_ret = sunxi_dma_set_callback(capture_prtd->params,
+					sunxi_audio_capture_buffdone, substream);
+			if (capture_ret < 0){
+				printk(KERN_ERR "failed to set dma callback. capture_ret == %d\n", capture_ret);
+				sunxi_dma_release(capture_prtd->params);
+				capture_prtd->params = NULL;
+				return capture_ret;
+			}
+			snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+			capture_runtime->dma_bytes = capture_totbytes;
+			spin_lock_irq(&capture_prtd->lock);
+			capture_prtd->dma_loaded = 0;
+			capture_prtd->dma_limit = capture_runtime->hw.periods_min;
+			capture_prtd->dma_period = params_period_bytes(params);
+			capture_prtd->dma_start = capture_runtime->dma_addr;
+
+			capture_dmadst = capture_prtd->dma_start;
+			capture_prtd->dma_pos = capture_prtd->dma_start;
+			capture_prtd->dma_end = capture_prtd->dma_start + capture_totbytes;
+
+			spin_unlock_irq(&capture_prtd->lock);
+		}
+	}else{
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int snd_sunxi_codec_hw_free(struct snd_pcm_substream *substream)
+{
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+
+   	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+ 		play_prtd = substream->runtime->private_data;
+		if(play_prtd->params)
+			sunxi_dma_flush(play_prtd->params);
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		if (play_prtd->params) {
+			sunxi_dma_stop(play_prtd->params);
+			sunxi_dma_release(play_prtd->params);
+			play_prtd->params = NULL;
+			/*
+			 * Clear out the DMA and any allocated buffers.
+			 */
+			snd_pcm_lib_free_pages(substream);
+		}
+   	}else{
+		capture_prtd = substream->runtime->private_data;
+		if(capture_prtd->params)
+			sunxi_dma_flush(capture_prtd->params);
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		if (capture_prtd->params) {
+			sunxi_dma_stop(capture_prtd->params);
+			sunxi_dma_release(capture_prtd->params);
+			capture_prtd->params = NULL;
+			/*
+			 * Clear out the DMA and any allocated buffers.
+			 */
+			snd_pcm_lib_free_pages(substream);
+		}
+   	}
+	return 0;
+}
+
+static int snd_sunxi_codec_prepare(struct	snd_pcm_substream	*substream)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	struct dma_hw_conf codec_play_dma_conf;
+	struct dma_hw_conf codec_capture_dma_conf;
+#else
+	dma_config_t codec_play_dma_conf;
+	dma_config_t codec_capture_dma_conf;
+#endif
+	int play_ret = 0, capture_ret = 0;
+	unsigned int reg_val;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		switch(substream->runtime->rate){
+			case 44100:
+				clk_set_rate(codec_pll2clk, 22579200);
+				clk_set_rate(codec_moduleclk, 22579200);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(0<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+
+				break;
+			case 22050:
+				clk_set_rate(codec_pll2clk, 22579200);
+				clk_set_rate(codec_moduleclk, 22579200);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(2<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 11025:
+				clk_set_rate(codec_pll2clk, 22579200);
+				clk_set_rate(codec_moduleclk, 22579200);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(4<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 48000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(0<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 96000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(7<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 192000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(6<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 32000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(1<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 24000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(2<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 16000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(3<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 12000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(4<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 8000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(5<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			default:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(0<<29);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+		}
+
+		switch(substream->runtime->channels){
+			case 1:
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val |=(1<<6);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			case 2:
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(1<<6);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+			default:
+				reg_val = readl(baseaddr + SUNXI_DAC_FIFOC);
+				reg_val &=~(1<<6);
+				writel(reg_val, baseaddr + SUNXI_DAC_FIFOC);
+				break;
+		}
+	}else{
+		switch(substream->runtime->rate){
+			case 44100:
+				clk_set_rate(codec_pll2clk, 22579200);
+				clk_set_rate(codec_moduleclk, 22579200);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(0<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+
+				break;
+			case 22050:
+				clk_set_rate(codec_pll2clk, 22579200);
+				clk_set_rate(codec_moduleclk, 22579200);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(2<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+			case 11025:
+				clk_set_rate(codec_pll2clk, 22579200);
+				clk_set_rate(codec_moduleclk, 22579200);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(4<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+			case 48000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(0<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+			case 32000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(1<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+			case 24000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(2<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+			case 16000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(3<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+			case 12000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(4<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+			case 8000:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(5<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+			default:
+				clk_set_rate(codec_pll2clk, 24576000);
+				clk_set_rate(codec_moduleclk, 24576000);
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(7<<29);
+				reg_val |=(0<<29);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+				break;
+		}
+
+		switch(substream->runtime->channels){
+			case 1:
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val |=(1<<7);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+			case 2:
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(1<<7);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+			default:
+				reg_val = readl(baseaddr + SUNXI_ADC_FIFOC);
+				reg_val &=~(1<<7);
+				writel(reg_val, baseaddr + SUNXI_ADC_FIFOC);
+			break;
+		}
+	}
+   if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+   	 	play_prtd = substream->runtime->private_data;
+   	 	/* return if this is a bufferless transfer e.g.
+	  	* codec <--> BT codec or GSM modem -- lg FIXME */
+   	 	if (!play_prtd->params)
+		return 0;
+   	 	//open the dac channel register
+		codec_play_open(substream);
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	  	codec_play_dma_conf.drqsrc_type  = D_DRQSRC_SDRAM;
+		codec_play_dma_conf.drqdst_type  = DRQ_TYPE_AUDIO;
+		codec_play_dma_conf.xfer_type    = DMAXFER_D_BHALF_S_BHALF;
+		codec_play_dma_conf.address_type = DMAADDRT_D_FIX_S_INC;
+		codec_play_dma_conf.dir          = SW_DMA_WDEV;
+		codec_play_dma_conf.reload       = 0;
+		codec_play_dma_conf.hf_irq       = SW_DMA_IRQ_FULL;
+		codec_play_dma_conf.from         = play_prtd->dma_start;
+		codec_play_dma_conf.to           = play_prtd->params->dma_addr;
+#else
+		memset(&codec_play_dma_conf, 0, sizeof(codec_play_dma_conf));
+		codec_play_dma_conf.xfer_type.src_data_width	= DATA_WIDTH_16BIT;
+		codec_play_dma_conf.xfer_type.src_bst_len	= DATA_BRST_4;
+		codec_play_dma_conf.xfer_type.dst_data_width	= DATA_WIDTH_16BIT;
+		codec_play_dma_conf.xfer_type.dst_bst_len	= DATA_BRST_4;
+		codec_play_dma_conf.address_type.src_addr_mode 	= NDMA_ADDR_INCREMENT;
+		codec_play_dma_conf.address_type.dst_addr_mode 	= NDMA_ADDR_NOCHANGE;
+		codec_play_dma_conf.src_drq_type		= N_SRC_SDRAM;
+		codec_play_dma_conf.dst_drq_type		= N_DST_AUDIO_CODEC_DA;
+		codec_play_dma_conf.bconti_mode			= false;
+		codec_play_dma_conf.irq_spt			= CHAN_IRQ_FD;
+#endif
+		play_ret = sunxi_dma_config(play_prtd->params,
+	  					&codec_play_dma_conf, 0);
+	  	/* flush the DMA channel */
+		play_prtd->dma_loaded = 0;
+		if (sunxi_dma_flush(play_prtd->params) == 0)
+			play_prtd->dma_pos = play_prtd->dma_start;
+		/* enqueue dma buffers */
+		sunxi_pcm_enqueue(substream);
+		return play_ret;
+	}else {
+		capture_prtd = substream->runtime->private_data;
+   	 	/* return if this is a bufferless transfer e.g.
+	  	 * codec <--> BT codec or GSM modem -- lg FIXME */
+   	 	if (!capture_prtd->params)
+		return 0;
+	   	//open the adc channel register
+	   	codec_capture_open();
+	   	//set the dma
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	   	codec_capture_dma_conf.drqsrc_type  = DRQ_TYPE_AUDIO;
+		codec_capture_dma_conf.drqdst_type  = D_DRQSRC_SDRAM;
+		codec_capture_dma_conf.xfer_type    = DMAXFER_D_BHALF_S_BHALF;
+		codec_capture_dma_conf.address_type = DMAADDRT_D_INC_S_FIX;
+		codec_capture_dma_conf.dir          = SW_DMA_RDEV;
+		codec_capture_dma_conf.reload       = 0;
+		codec_capture_dma_conf.hf_irq       = SW_DMA_IRQ_FULL;
+		codec_capture_dma_conf.from         = capture_prtd->params->dma_addr;
+		codec_capture_dma_conf.to           = capture_prtd->dma_start;
+#else
+	   	memset(&codec_capture_dma_conf, 0, sizeof(codec_capture_dma_conf));
+		codec_capture_dma_conf.xfer_type.src_data_width = DATA_WIDTH_16BIT;
+		codec_capture_dma_conf.xfer_type.src_bst_len 	= DATA_BRST_4;
+		codec_capture_dma_conf.xfer_type.dst_data_width = DATA_WIDTH_16BIT;
+		codec_capture_dma_conf.xfer_type.dst_bst_len 	= DATA_BRST_4;
+		codec_capture_dma_conf.address_type.src_addr_mode = NDMA_ADDR_NOCHANGE;
+		codec_capture_dma_conf.address_type.dst_addr_mode = NDMA_ADDR_INCREMENT;
+		codec_capture_dma_conf.src_drq_type 		= N_SRC_AUDIO_CODEC_AD;
+		codec_capture_dma_conf.dst_drq_type 		= N_DST_SDRAM;
+		codec_capture_dma_conf.bconti_mode 		= false;
+		codec_capture_dma_conf.irq_spt 			= CHAN_IRQ_FD;
+#endif
+	  	capture_ret = sunxi_dma_config(capture_prtd->params,
+	  					&codec_capture_dma_conf, 0);
+	  	/* flush the DMA channel */
+		capture_prtd->dma_loaded = 0;
+		if (sunxi_dma_flush(capture_prtd->params) == 0)
+			capture_prtd->dma_pos = capture_prtd->dma_start;
+
+		/* enqueue dma buffers */
+		sunxi_pcm_enqueue(substream);
+		return capture_ret;
+	}
+}
+
+static int snd_sunxi_codec_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	int play_ret = 0, capture_ret = 0;
+	struct sunxi_playback_runtime_data *play_prtd = NULL;
+	struct sunxi_capture_runtime_data *capture_prtd = NULL;
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+		play_prtd = substream->runtime->private_data;
+		spin_lock(&play_prtd->lock);
+		switch (cmd) {
+			case SNDRV_PCM_TRIGGER_START:
+			case SNDRV_PCM_TRIGGER_RESUME:
+			case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+				play_prtd->state |= ST_RUNNING;
+				codec_play_start();
+				sunxi_dma_start(play_prtd->params);
+				if(substream->runtime->rate >=192000){
+				}else if(substream->runtime->rate > 22050){
+					mdelay(2);
+				}else{
+					mdelay(7);
+				}
+				//pa unmute
+				codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+				break;
+			case SNDRV_PCM_TRIGGER_SUSPEND:
+				codec_play_stop();
+				break;
+			case SNDRV_PCM_TRIGGER_STOP:
+				play_prtd->state &= ~ST_RUNNING;
+				codec_play_stop();
+				sunxi_dma_stop(play_prtd->params);
+				break;
+			case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+				play_prtd->state &= ~ST_RUNNING;
+				sunxi_dma_stop(play_prtd->params);
+				break;
+			default:
+				printk("error:%s,%d\n", __func__, __LINE__);
+				play_ret = -EINVAL;
+				break;
+			}
+		spin_unlock(&play_prtd->lock);
+	}else{
+		capture_prtd = substream->runtime->private_data;
+		spin_lock(&capture_prtd->lock);
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			capture_prtd->state |= ST_RUNNING;
+			codec_capture_start();
+			mdelay(1);
+			codec_wr_control(SUNXI_ADC_FIFOC, 0x1, ADC_FIFO_FLUSH, 0x1);
+			sunxi_dma_start(capture_prtd->params);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+			codec_capture_stop();
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+			capture_prtd->state &= ~ST_RUNNING;
+			codec_capture_stop();
+			sunxi_dma_stop(capture_prtd->params);
+			break;
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			capture_prtd->state &= ~ST_RUNNING;
+			sunxi_dma_stop(capture_prtd->params);
+			break;
+		default:
+			printk("error:%s,%d\n", __func__, __LINE__);
+			capture_ret = -EINVAL;
+			break;
+		}
+		spin_unlock(&capture_prtd->lock);
+	}
+	return 0;
+}
+
+static int snd_sunxicard_capture_open(struct snd_pcm_substream *substream)
+{
+	/*获得PCM运行时信息指针*/
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	struct sunxi_capture_runtime_data *capture_prtd;
+
+	capture_prtd = kzalloc(sizeof(struct sunxi_capture_runtime_data), GFP_KERNEL);
+	if (capture_prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&capture_prtd->lock);
+
+	runtime->private_data = capture_prtd;
+
+	runtime->hw = sunxi_pcm_capture_hardware;
+
+	/* ensure that buffer size is a multiple of period size */
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates)) < 0)
+		return err;
+
+	return 0;
+}
+
+static int snd_sunxicard_capture_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	kfree(runtime->private_data);
+	return 0;
+}
+
+static int snd_sunxicard_playback_open(struct snd_pcm_substream *substream)
+{
+	/*获得PCM运行时信息指针*/
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int err;
+	struct sunxi_playback_runtime_data *play_prtd;
+
+	play_prtd = kzalloc(sizeof(struct sunxi_playback_runtime_data), GFP_KERNEL);
+	if (play_prtd == NULL)
+		return -ENOMEM;
+
+	spin_lock_init(&play_prtd->lock);
+
+	runtime->private_data = play_prtd;
+
+	runtime->hw = sunxi_pcm_playback_hardware;
+
+	/* ensure that buffer size is a multiple of period size */
+	if ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)
+		return err;
+	if ((err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates)) < 0)
+		return err;
+
+	return 0;
+}
+
+static int snd_sunxicard_playback_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	kfree(runtime->private_data);
+	return 0;
+}
+
+static struct snd_pcm_ops sunxi_pcm_playback_ops = {
+	.open			= snd_sunxicard_playback_open,//打开
+	.close			= snd_sunxicard_playback_close,//关闭
+	.ioctl			= snd_pcm_lib_ioctl,//I/O控制
+	.hw_params	    = sunxi_codec_pcm_hw_params,//硬件参数
+	.hw_free	    = snd_sunxi_codec_hw_free,//资源释放
+	.prepare		= snd_sunxi_codec_prepare,//准备
+	.trigger		= snd_sunxi_codec_trigger,//在pcm被开始、停止或暂停时调用
+	.pointer		= snd_sunxi_codec_pointer,//当前缓冲区的硬件位置
+};
+
+static struct snd_pcm_ops sunxi_pcm_capture_ops = {
+	.open			= snd_sunxicard_capture_open,//打开
+	.close			= snd_sunxicard_capture_close,//关闭
+	.ioctl			= snd_pcm_lib_ioctl,//I/O控制
+	.hw_params	    = sunxi_codec_pcm_hw_params,//硬件参数
+	.hw_free	    = snd_sunxi_codec_hw_free,//资源释放
+	.prepare		= snd_sunxi_codec_prepare,//准备
+	.trigger		= snd_sunxi_codec_trigger,//在pcm被开始、停止或暂停时调用
+	.pointer		= snd_sunxi_codec_pointer,//当前缓冲区的硬件位置
+};
+
+static int __init snd_card_sunxi_codec_pcm(struct sunxi_codec *sunxi_codec, int device)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	/*创建PCM实例*/
+	err = snd_pcm_new(sunxi_codec->card, "M1 PCM", device,
+			  has_playback, has_capture, &pcm);
+	if (err < 0) {
+		pr_err("snd_pcm_new M1 PCM failed: %d\n", err);
+		return err;
+	}
+
+	/*
+	 * this sets up our initial buffers and sets the dma_type to isa.
+	 * isa works but I'm not sure why (or if) it's the right choice
+	 * this may be too large, trying it for now
+	 */
+
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+					      snd_dma_isa_data(),
+					      32*1024, 32*1024);
+	/*
+	*	设置PCM操作，第1个参数是snd_pcm的指针，第2 个参数是SNDRV_PCM_STREAM_PLAYBACK
+	*	或SNDRV_ PCM_STREAM_CAPTURE，而第3 个参数是PCM 操作结构体snd_pcm_ops
+	*/
+	if (has_playback)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+				&sunxi_pcm_playback_ops);
+	if (has_capture)
+		snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+				&sunxi_pcm_capture_ops);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &sunxi_pcm_playback_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &sunxi_pcm_capture_ops);
+	pcm->private_data = sunxi_codec;//置pcm->private_data为芯片特定数据
+	pcm->info_flags = 0;
+	strcpy(pcm->name, "sunxi PCM");
+	/* setup DMA controller */
+
+	return 0;
+}
+
+void snd_sunxi_codec_free(struct snd_card *card)
+{
+
+}
+
+static void codec_resume_events(struct work_struct *work)
+{
+	printk("%s,%d\n",__func__,__LINE__);
+	if (sunxi_is_sun7i())
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	else
+		codec_wr_control(SUNXI_DAC_DPC ,  0x1, DAC_EN, 0x1);
+	msleep(20);
+	//enable PA
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x1);
+	msleep(550);
+    //enable dac analog
+	if (sunxi_is_sun7i()) {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x1);
+		codec_wr_control(SUNXI_ADC_ACTL, 0x1, 8, 0x0);
+	} else {
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_L, 0x1);
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_R, 0x1);
+
+		codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACPAS, 0x1);
+	}
+
+	if (gpio_pa_shutdown) {
+		msleep(50);
+		gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+	}
+}
+
+static int __devinit sunxi_codec_probe(struct platform_device *pdev)
+{
+	int err;
+	int ret;
+	struct snd_card *card;
+	struct sunxi_codec *chip;
+	struct codec_board_info  *db;
+	/* register the soundcard */
+	ret = snd_card_create(0, "sunxi-codec", THIS_MODULE, sizeof(struct sunxi_codec),
+			      &card);
+	if (ret != 0) {
+		return -ENOMEM;
+	}
+	/*从private_data中取出分配的内存大小*/
+	chip = card->private_data;
+	/*声卡芯片的专用数据*/
+	card->private_free = snd_sunxi_codec_free;//card私有数据释放
+	chip->card = card;
+	chip->samplerate = AUDIO_RATE_DEFAULT;
+
+	/*
+	*	mixer,注册control(mixer)接口
+	*	创建一个control至少要实现snd_kcontrol_new中的info(),get()和put()这三个成员函数
+	*/
+	if ((err = snd_chip_codec_mixer_new(card)))
+		goto nodev;
+
+	/*
+	*	PCM,录音放音相关，注册PCM接口
+	*/
+	if ((err = snd_card_sunxi_codec_pcm(chip, 0)) < 0)
+	    goto nodev;
+
+	strcpy(card->driver, "sunxi-CODEC");
+	strcpy(card->shortname, "sunxi-CODEC");
+	sprintf(card->longname, "sunxi-CODEC  Audio Codec");
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	//注册card
+	if ((err = snd_card_register(card)) == 0) {
+		platform_set_drvdata(pdev, card);
+	}else{
+      return err;
+	}
+
+	db = kzalloc(sizeof(*db), GFP_KERNEL);
+	if (!db)
+		return -ENOMEM;
+  	/* codec_apbclk */
+	codec_apbclk = clk_get(NULL,"apb_audio_codec");
+	if (-1 == clk_enable(codec_apbclk)) {
+		printk("codec_apbclk failed; \n");
+	}
+	/* codec_pll2clk */
+	codec_pll2clk = clk_get(NULL,"audio_pll");
+	clk_enable(codec_pll2clk);
+
+	/* codec_moduleclk */
+	codec_moduleclk = clk_get(NULL,"audio_codec");
+
+	if (clk_set_parent(codec_moduleclk, codec_pll2clk)) {
+		printk("try to set parent of codec_moduleclk to codec_pll2clk failed!\n");
+	}
+	if (clk_set_rate(codec_moduleclk, 24576000)) {
+		printk("set codec_moduleclk clock freq 24576000 failed!\n");
+	}
+	if (-1 == clk_enable(codec_moduleclk)){
+		printk("open codec_moduleclk failed; \n");
+	}
+	db->codec_base_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	db->dev = &pdev->dev;
+
+	if (db->codec_base_res == NULL) {
+		ret = -ENOENT;
+		printk("codec insufficient resources\n");
+		goto out;
+	}
+	 /* codec address remap */
+	 db->codec_base_req = request_mem_region(db->codec_base_res->start, 0x40,
+					   pdev->name);
+	 if (db->codec_base_req == NULL) {
+		 ret = -EIO;
+		 printk("cannot claim codec address reg area\n");
+		 goto out;
+	 }
+	 baseaddr = ioremap(db->codec_base_res->start, 0x40);
+
+	 if (baseaddr == NULL) {
+		 ret = -EINVAL;
+		 dev_err(db->dev,"failed to ioremap codec address reg\n");
+		 goto out;
+	 }
+
+	 kfree(db);
+	 gpio_pa_shutdown = gpio_request_ex("audio_para", "audio_pa_ctrl");
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+	 codec_init();
+	if (gpio_pa_shutdown)
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+	 resume_work_queue = create_singlethread_workqueue("codec_resume");
+	 if (resume_work_queue == NULL) {
+        printk("[su4i-codec] try to create workqueue for codec failed!\n");
+		ret = -ENOMEM;
+		goto err_resume_work_queue;
+	}
+	 return 0;
+     err_resume_work_queue:
+	 out:
+		 dev_err(db->dev, "not found (%d).\n", ret);
+
+	 nodev:
+		snd_card_free(card);
+		return err;
+}
+
+/*	suspend state,先disable左右声道，然后静音，再disable pa(放大器)，
+ *	disable 耳机，disable dac->pa，最后disable DAC
+ * 	顺序不可调，否则刚关闭声卡的时候可能出现噪音
+ */
+static int snd_sunxi_codec_suspend(struct platform_device *pdev,pm_message_t state)
+{
+	printk("[audio codec]:suspend start5000\n");
+	if (gpio_pa_shutdown) {
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+    //disable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_R, 0x0);
+
+	//disable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACPAS, 0x0);
+	codec_wr_control(SUNXI_DAC_DPC ,  0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+	printk("[audio codec]:suspend end\n");
+	return 0;
+}
+
+
+/*	resume state,先unmute，
+ *	再enable DAC，enable L/R DAC,enable PA，
+ * 	enable 耳机，enable dac to pa
+ *	顺序不可调，否则刚打开声卡的时候可能出现噪音
+ */
+static int snd_sunxi_codec_resume(struct platform_device *pdev)
+{
+	printk("[audio codec]:resume start\n");
+	if (-1 == clk_enable(codec_moduleclk)){
+		printk("open codec_moduleclk failed; \n");
+	}
+
+	queue_work(resume_work_queue, &codec_resume_work);
+	printk("[audio codec]:resume end\n");
+	return 0;
+}
+
+static int __devexit sunxi_codec_remove(struct platform_device *devptr)
+{
+	clk_disable(codec_moduleclk);
+	//释放codec_pll2clk时钟句柄
+	clk_put(codec_pll2clk);
+	//释放codec_apbclk时钟句柄
+	clk_put(codec_apbclk);
+
+	snd_card_free(platform_get_drvdata(devptr));
+	platform_set_drvdata(devptr, NULL);
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct platform_device *devptr)
+{
+	if (gpio_pa_shutdown) {
+		gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+		mdelay(50);
+	}
+	codec_wr_control(SUNXI_ADC_ACTL, 0x1, PA_ENABLE, 0x0);
+	mdelay(100);
+	//pa mute
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, PA_MUTE, 0x0);
+	mdelay(500);
+    //disable dac analog
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_L, 0x0);
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACAEN_R, 0x0);
+
+	//disable dac to pa
+	codec_wr_control(SUNXI_DAC_ACTL, 0x1, 	DACPAS, 0x0);
+	codec_wr_control(SUNXI_DAC_DPC ,  0x1, DAC_EN, 0x0);
+
+	clk_disable(codec_moduleclk);
+}
+
+static struct resource sunxi_codec_resource[] = {
+	[0] = {
+    	.start = CODEC_BASSADDRESS,
+        .end   = CODEC_BASSADDRESS + 0x40,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+/*data relating*/
+static struct platform_device sunxi_device_codec = {
+	.name = "sunxi-codec",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(sunxi_codec_resource),
+	.resource = sunxi_codec_resource,
+};
+
+/*method relating*/
+static struct platform_driver sunxi_codec_driver = {
+	.probe		= sunxi_codec_probe,
+	.remove		= sunxi_codec_remove,
+	.shutdown   = sunxi_codec_shutdown,
+#ifdef CONFIG_PM
+	.suspend	= snd_sunxi_codec_suspend,
+	.resume		= snd_sunxi_codec_resume,
+#endif
+	.driver		= {
+		.name	= "sunxi-codec",
+	},
+};
+
+static int __init sunxi_codec_init(void)
+{
+	int ret = 0, audio_used = 0;
+
+	ret = script_parser_fetch("audio_para", "audio_used", &audio_used, 1);
+	if (ret != 0)
+		return -ENODEV;
+
+	ret = script_parser_fetch("audio_para", "playback_used", &has_playback, 1);
+	/* On error set playback to 1 as this is a linux-sunxi.org extension */
+	if (ret == 0 && !has_playback)
+		has_playback = 0;
+	else
+		has_playback = 1;
+
+	ret = script_parser_fetch("audio_para", "capture_used", &has_capture, 1);
+	/* On error set capture to 0 as this is a linux-sunxi.org extension */
+	if (ret == 0 && has_capture)
+		has_capture = 1;
+	else
+		has_capture = 0;
+
+	if (!audio_used || (!has_playback && !has_capture))
+		return -ENODEV;
+
+	ret = platform_device_register(&sunxi_device_codec);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&sunxi_codec_driver);
+	if (ret < 0) {
+		platform_device_unregister(&sunxi_device_codec);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit sunxi_codec_exit(void)
+{
+	platform_driver_unregister(&sunxi_codec_driver);
+	platform_device_unregister(&sunxi_device_codec);
+}
+
+module_init(sunxi_codec_init);
+module_exit(sunxi_codec_exit);
+
+MODULE_DESCRIPTION("sunxi CODEC ALSA codec driver");
+MODULE_AUTHOR("software");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-codec.h b/sound/soc/sunxi/sunxi-codec.h
new file mode 100644
index 0000000..99bbd8e
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-codec.h
@@ -0,0 +1,139 @@
+/*
+ * sound/soc/sunxi/sunxi-codec.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _SUNXI_CODEC_H
+#define _SUNXI_CODEC_H
+
+//Codec Register
+#define CODEC_BASSADDRESS         (0x01c22c00)
+#define SUNXI_DAC_DPC                (0x00)
+#define SUNXI_DAC_FIFOC              (0x04)
+#define SUNXI_DAC_FIFOS              (0x08)
+#define SUNXI_DAC_TXDATA             (0x0c)
+#define SUNXI_DAC_ACTL               (0x10)
+#define SUNXI_DAC_TUNE               (0x14)
+#define SUNXI_DAC_DEBUG              (0x18)
+#define SUNXI_ADC_FIFOC              (0x1c)
+#define SUNXI_ADC_FIFOS              (0x20)
+#define SUNXI_ADC_RXDATA             (0x24)
+#define SUNXI_ADC_ACTL               (0x28)
+#define SUNXI_ADC_DEBUG              (0x2c)
+#define SUNXI_DAC_TXCNT              (0x30)
+#define SUNXI_ADC_RXCNT              (0x34)
+#define SUNXI_BIAS_CRT               (0x38)
+#define SUNXI_MIC_CRT                (0x3c)
+#define SUNXI_CODEC_REGS_NUM         (13)
+
+#define DAIFMT_16BITS             (16)
+#define DAIFMT_20BITS             (20)
+
+#define DAIFMT_BS_MASK            (~(1<<16))  	//FIFO big small mode mask
+#define DAIFMT_BITS_MASK          (~(1<<5))		//FIFO Bits select mask,not used yet.
+#define SAMPLE_RATE_MASK          (~(7<<29))  	//Sample Rate slect mask
+
+#define DAC_EN                    (31)
+#define DIGITAL_VOL               (12)
+//For CODEC OLD VERSION
+#define DAC_VERSION               (23)
+
+#define DAC_CHANNEL				  (6)
+#define LAST_SE                   (26)
+#define TX_FIFO_MODE              (24)
+#define DRA_LEVEL                 (21)
+#define TX_TRI_LEVEL              (8)
+#define DAC_MODE                  (6)			//not used yet
+#define TASR                      (5)			//not used yet
+#define DAC_DRQ                   (4)
+#define DAC_FIFO_FLUSH            (0)
+
+#define VOLUME                    (0)
+#define PA_MUTE                   (6)
+#define MIXPAS                    (7)
+#define DACPAS                    (8)
+#define MIXEN                     (29)
+#define DACAEN_L                  (30)
+#define DACAEN_R                  (31)
+
+#define ADC_DIG_EN                (28)
+#define RX_FIFO_MODE              (24)
+#define RX_TRI_LEVEL              (8)
+#define ADC_MODE                  (7)
+#define RASR                      (6)
+#define ADC_DRQ                   (4)
+#define ADC_FIFO_FLUSH            (0)
+
+#define  ADC_LF_EN                (31)
+#define  ADC_RI_EN                (30)
+#define  ADC_EN                   (30)
+#define  MIC1_EN                  (29)
+#define  MIC2_EN                  (28)
+#define  VMIC_EN                  (27)
+#define  MIC_GAIN                 (25)
+#define  ADC_SELECT               (17)
+#define  PA_ENABLE                (4)
+#define  HP_DIRECT                (3)
+
+enum m1_codec_config {
+	CMD_MIC_SEL =0,
+	CMD_ADC_SEL,
+};
+
+void  __iomem *baseaddr;
+
+#define AUDIO_RATE_DEFAULT	44100
+#define ST_RUNNING		(1<<0)
+#define ST_OPENED		(1<<1)
+
+#define codec_rdreg(reg)	    readl((baseaddr+(reg)))
+#define codec_wrreg(reg,val)  writel((val),(baseaddr+(reg)))
+
+/*
+* Convenience kcontrol builders
+*/
+#define CODEC_SINGLE_VALUE(xreg, xshift, xmax,	xinvert)\
+		((unsigned long)&(struct codec_mixer_control)\
+		{.reg	=	xreg,	.shift	=	xshift,	.rshift	=	xshift,	.max	=	xmax,\
+   	.invert	=	xinvert})
+
+#define CODEC_SINGLE(xname,	reg,	shift,	max,	invert)\
+{	.iface	= SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
+	.info	= snd_codec_info_volsw,	.get = snd_codec_get_volsw,\
+	.put	= snd_codec_put_volsw,\
+	.private_value	= CODEC_SINGLE_VALUE(reg, shift, max, invert)}
+
+/*	mixer control*/
+struct	codec_mixer_control{
+	int	min;
+	int     max;
+	int     where;
+	unsigned int mask;
+	unsigned int reg;
+	unsigned int rreg;
+	unsigned int shift;
+	unsigned int rshift;
+	unsigned int invert;
+	unsigned int value;
+};
+
+extern int __init snd_chip_codec_mixer_new(struct snd_card *card);
+#endif
