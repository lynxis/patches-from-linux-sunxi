diff --git a/drivers/media/Kconfig b/drivers/media/Kconfig
index 9575db4..87762dd 100644
--- a/drivers/media/Kconfig
+++ b/drivers/media/Kconfig
@@ -121,6 +121,26 @@ source "drivers/media/video/Kconfig"
 source "drivers/media/radio/Kconfig"
 
 #
+# Audio Engine
+#
+config AUDIO_ENGINE
+	tristate "AUDIO Engine"
+	---help---
+	  Support for audio engine/dsp
+
+source "drivers/media/audio/Kconfig"
+
+#
+# PA CONTROL
+#
+config PA_CONTROL
+	tristate "PA Control"
+	---help---
+	  Support for audio pa control
+
+source "drivers/media/pa/Kconfig"
+
+#
 # DVB adapters
 #
 
diff --git a/drivers/media/Makefile b/drivers/media/Makefile
index 64755c9..89321ed 100644
--- a/drivers/media/Makefile
+++ b/drivers/media/Makefile
@@ -12,3 +12,5 @@ obj-y += common/ rc/ video/
 
 obj-$(CONFIG_VIDEO_DEV) += radio/
 obj-$(CONFIG_DVB_CORE)  += dvb/
+obj-$(CONFIG_AUDIO_ENGINE) += audio/
+obj-$(CONFIG_PA_CONTROL) += pa/
\ No newline at end of file
diff --git a/drivers/media/audio/Kconfig b/drivers/media/audio/Kconfig
new file mode 100644
index 0000000..9cfa781
--- /dev/null
+++ b/drivers/media/audio/Kconfig
@@ -0,0 +1,4 @@
+config ACE_CONFIG
+	tristate "ace modlue manage clock"
+	default y
+	depends on AUDIO_ENGINE
diff --git a/drivers/media/audio/Makefile b/drivers/media/audio/Makefile
new file mode 100644
index 0000000..95fd056
--- /dev/null
+++ b/drivers/media/audio/Makefile
@@ -0,0 +1,3 @@
+
+obj-$(CONFIG_ACE_CONFIG) += sun4i_dev_ace.o
+obj-$(CONFIG_ACE_CONFIG) += sun4i_ace.o
diff --git a/drivers/media/audio/sun4i_ace.c b/drivers/media/audio/sun4i_ace.c
new file mode 100644
index 0000000..4eb12ef
--- /dev/null
+++ b/drivers/media/audio/sun4i_ace.c
@@ -0,0 +1,195 @@
+/*
+ * drivers\media\audio\sun4i_ace.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include "sun4i_ace_i.h"
+#include <linux/module.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+
+static __s32 ACE_EnableModule(__ace_module_type_e module, __u32 mode);
+
+
+struct clk *hAceMClk, *hDramAceClk, *hAceAhbClk;
+void *       ace_hsram;
+EXPORT_SYMBOL(ace_hsram);
+
+__s32       configTimes = 0;
+
+#define ACE_REGS_BASE ACE_REGS_pBASE
+struct semaphore		pSemAceClkAdjust;
+struct semaphore		pSemAceCe;
+struct semaphore		pSemAceConfig;
+
+
+struct clk *parent_clk = NULL;
+int esCLK_SetMclkSrc(struct clk *clk, int parent)
+{
+	int ret = 0;
+
+	if (clk == NULL) {
+		printk(" %s %d The clk is NULL\n ", __FUNCTION__, __LINE__);
+		return ACE_FAIL;
+	}
+
+	if (parent == CSP_CCM_SYS_CLK_SDRAM_PLL) {
+		parent_clk = clk_get(NULL, "sdram_pll");
+		if (parent_clk == NULL) {
+			printk("%s %d : get sdram pll fail \n", __FUNCTION__, __LINE__);
+			return ACE_FAIL;
+		}
+		ret = clk_set_parent(clk, parent_clk);
+	}
+
+	return ret;
+}
+
+int esCLK_CloseMclkSrc(int parent)
+{
+	struct clk *parent_clk = NULL;
+
+	if (parent == CSP_CCM_SYS_CLK_SDRAM_PLL) {
+		if (parent_clk) {
+			printk("release parent clk\n");
+			clk_put(parent_clk);
+			parent_clk = NULL;
+		}
+	}
+
+	return 0;
+}
+
+int esCLK_MclkOnOff(struct clk *clk, int onoff)
+{
+	int ret = 1;
+
+	if (onoff == 1) {
+		ret = clk_enable(clk);
+		if (ret == -1) {
+			printk("%s %d : Enable clk fail\n", __FUNCTION__, __LINE__);
+		}
+	}
+	else if(onoff == 0){
+		clk_disable(clk);
+		ret = 1;
+	}
+
+	return ret;
+}
+void *esMEM_SramReqBlk(int addr)
+{
+	void *map_addr = NULL;
+
+	addr |= 0xf0000000;
+	map_addr = (void *)addr;
+
+	return map_addr;
+}
+
+__s32 ACE_Init(void)
+{
+    //create semphore to sync clock adjust.
+ 	sema_init(&pSemAceClkAdjust, 1);
+
+	/*ae,ceçç¸å³å¯å­å¨é½éè¦éè¿è¿ä¸ªå°åå¼æ å°åç§»æ¾å°*/
+	ace_hsram = ioremap(ACE_REGS_pBASE, 4096);
+    if (!ace_hsram) {
+        printk("cannot map region for sram");
+       return -1;
+    }
+    //create sem to sync ace config
+    sema_init(&pSemAceConfig, 1);
+
+    //create semphore to sync resource usage
+    sema_init(&pSemAceCe, 1);
+
+    configTimes = 0;
+    return ACE_OK;
+}
+EXPORT_SYMBOL_GPL(ACE_Init);
+
+__s32 ACE_Exit(void)
+{
+    iounmap((void *)ace_hsram);
+    return ACE_OK;
+}
+EXPORT_SYMBOL_GPL(ACE_Exit);
+
+s32 ACE_HwReq(__ace_module_type_e module, __ace_request_mode_e mode, __u32 timeout)
+{
+    if (ACE_MODULE_CE == module || ACE_MODULE_PNG == module || ACE_MODULE_TSCC == module ) {
+        //request semphore
+        if (ACE_REQUEST_MODE_NOWAIT == mode) {
+            if (down_trylock(&pSemAceCe)== 0) {     //the resource is available or not
+                 return ACE_FAIL;
+	    	}
+	    } else if (ACE_REQUEST_MODE_WAIT == mode) {
+            if (down_interruptible(&pSemAceCe)) {
+	    	    return  -ERESTARTSYS;
+	        }
+	    }
+        ACE_EnableModule(ACE_MODULE_CE, ACE_MODULE_ENABLE);
+    } else if (ACE_MODULE_AE == module) {
+        ACE_EnableModule(ACE_MODULE_AE, ACE_MODULE_ENABLE);
+    } else {
+		printk("%s, %d\n", __FILE__, __LINE__);
+        return ACE_FAIL;
+    }
+
+    return ACE_OK;
+}
+EXPORT_SYMBOL_GPL(ACE_HwReq);
+
+__s32 ACE_HwRel(__ace_module_type_e module)
+{
+	if (module == ACE_MODULE_CE) {
+        //release semphore
+	    up(&pSemAceCe);
+        ACE_EnableModule(ACE_MODULE_CE, ACE_MODULE_DISABLE);
+    } else if(module == ACE_MODULE_AE) {
+        ACE_EnableModule(ACE_MODULE_AE, ACE_MODULE_DISABLE);
+    }
+
+    return ACE_OK;
+
+}
+EXPORT_SYMBOL_GPL(ACE_HwRel);
+
+__u32 ACE_GetClk(void)
+{
+    __u32 temp = 0;
+    temp = esCLK_GetSrcFreq(esCLK_GetMclkSrc(hAceMClk));
+    return temp;
+}
+EXPORT_SYMBOL_GPL(ACE_GetClk);
+
+static __s32 ACE_EnableModule(__ace_module_type_e module, __u32 mode)
+{
+    __u32 status = readReg(ACE_MODE_SELECTOR);
+    if(ACE_MODULE_CE == module || ACE_MODULE_PNG == module || ACE_MODULE_TSCC == module) {
+        if(ACE_MODULE_ENABLE == mode) {
+        	status |=  ACE_CE_ENABLE_MASK;
+        } else if(ACE_MODULE_DISABLE == mode) {
+            status &= (~ACE_CE_ENABLE_MASK);
+        }
+    } else if(ACE_MODULE_AE == module) {
+        if(ACE_MODULE_ENABLE == mode) {
+			status |=  ACE_AE_ENABLE_MASK;
+        } else if(ACE_MODULE_DISABLE == mode) {
+            status &= (~ACE_AE_ENABLE_MASK);
+        }
+    }
+    writeReg(ACE_MODE_SELECTOR,status);
+    return ACE_OK;
+}
diff --git a/drivers/media/audio/sun4i_ace_i.h b/drivers/media/audio/sun4i_ace_i.h
new file mode 100644
index 0000000..d5d8723
--- /dev/null
+++ b/drivers/media/audio/sun4i_ace_i.h
@@ -0,0 +1,94 @@
+/*
+ * drivers\media\audio\sun4i_ace_i.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _SUN4I_ACE_I_H_
+#define	_SUN4I_ACE_I_H_
+
+#include "sun4i_drv_ace.h"
+
+#define writeReg(nReg, nVal)    \
+            do{*(volatile __u32 *)(nReg) = (nVal);}while(0)
+#define readReg(nReg)   \
+            *(volatile __u32 *)(nReg)
+#define sys_get_wvalue(n)   (*((volatile __u32 *)(n)))          /* word input */
+#define sys_put_wvalue(n,c) (*((volatile __u32 *)(n))  = (c))   /* word output */
+
+#define ACE_REGS_pBASE    	(0x01c1a000)
+
+extern void *       ace_hsram;
+
+/*ACE register offset*/
+#define ACE_MODE_SELECTOR_OFF   	      	0x00
+#define ACE_ACE_RESET_OFF   	          	0x04
+
+/*AE register offset*/
+#define AE_INT_EN_REG_OFF             (0x100+0x08)
+#define AE_STATUS_REG_OFF             (0x100+0x24)
+
+/*ACE register address*/
+#define ACE_MODE_SELECTOR     	(ace_hsram + ACE_MODE_SELECTOR_OFF)
+#define ACE_ACE_RESET         	(ace_hsram + ACE_ACE_RESET_OFF)
+
+/*AE register address*/
+#define AE_INT_EN_REG        	(ace_hsram + AE_INT_EN_REG_OFF)
+#define AE_STATUS_REG	        (ace_hsram + AE_STATUS_REG_OFF)
+
+#define ACE_ENGINE_MAX_FREQ      150000000            //150M
+
+//ace reset mask
+#define ACE_RESET_MASK                      (1<<0)
+//ace reset mode
+#define ACE_RESET_DISABLE                   (0)
+#define ACE_RESET_ENABLE                    (1)
+
+//ace ce enable mask
+#define ACE_CE_ENABLE_MASK                  (1<<4)
+//ace ae enable mask
+#define ACE_AE_ENABLE_MASK                  (1<<0)
+
+typedef struct __ACE_MODULE_USE_STAT{
+    __ace_module_type_e ceUseCnt;
+    __ace_module_type_e aeUseCnt;
+}__ace_module_use_stat_t;
+
+//ace module enable mode
+#define ACE_MODULE_DISABLE                      (0)
+#define ACE_MODULE_ENABLE                       (1)
+
+#define CSP_CCM_SYS_CLK_SDRAM_PLL  1
+
+#define CLK_OFF 0
+#define CLK_ON  1
+
+#define ACE_FAIL    -1
+#define ACE_OK       0
+
+#define CLK_CMD_SCLKCHG_REQ  2
+#define CLK_CMD_SCLKCHG_DONE 3
+
+#define CSP_CCM_MOD_CLK_ACE  "ace"
+#define CSP_CCM_MOD_CLK_AHB_ACE "ahb_ace"
+#define CSP_CCM_MOD_CLK_SDRAM_ACE "sdram_ace"
+
+#define esCLK_OpenMclk(a)  clk_get(NULL, (a))
+#define esCLK_CloseMclk      clk_put
+#define esCLK_GetMclkSrc     clk_get_parent
+
+#define esCLK_GetSrcFreq    clk_get_rate
+#define esCLK_SetMclkDiv    clk_set_rate
+#define esCLK_MclkRegCb(a, b)   NULL
+#define esCLK_MclkUnregCb(a, b) NULL
+#define esCLK_MclkReset(a, b)   clk_reset(a, b)
+
+#endif	/* _ACE_I_H_ */
diff --git a/drivers/media/audio/sun4i_dev_ace.c b/drivers/media/audio/sun4i_dev_ace.c
new file mode 100644
index 0000000..e5a38bb
--- /dev/null
+++ b/drivers/media/audio/sun4i_dev_ace.c
@@ -0,0 +1,386 @@
+/*
+ * drivers\media\audio\sun4i_dev_ace.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+
+#include <linux/slab.h>
+#include <linux/preempt.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+#include <linux/rmap.h>
+#include <linux/string.h>
+#include <mach/clock.h>
+#include "sun4i_drv_ace.h"
+#include "sun4i_ace_i.h"
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+
+static struct class *ace_dev_class;
+static struct cdev *ace_dev;
+static dev_t dev_num ;
+struct clk *ace_moduleclk,*dram_aceclk,*ahb_aceclk,*ace_pll5_pclk;
+static unsigned long suspend_acerate = 0;
+static int ref_count = 0;
+static DECLARE_WAIT_QUEUE_HEAD(wait_ae);
+__u32 ae_interrupt_sta = 0, ae_interrupt_value = 0;
+void *       ccmu_hsram;
+/*aeãaceãceå±äº«ä¸­æ­å·*/
+#define ACE_IRQ_NO (60)
+
+//#define ACE_DEBUG
+static int ace_dev_open(struct inode *inode, struct file *filp){
+    int status = 0;
+    return status;
+}
+
+static int ace_dev_release(struct inode *inode, struct file *filp){
+    int status = 0;
+
+    return status;
+}
+
+/*
+ * Audio engine interrupt service routine
+ * To wake up ae wait queue
+ */
+static irqreturn_t ace_interrupt(int irq, void *dev)
+{
+	volatile int ae_out_mode_reg = 0;
+
+	/*status 0x24*/
+	ae_out_mode_reg = readReg(AE_STATUS_REG);
+	ae_interrupt_value = ae_out_mode_reg;
+	if(ae_out_mode_reg & 0x04){
+	  writeReg(AE_INT_EN_REG,readReg(AE_INT_EN_REG)&(~0x0f));
+	}
+
+	ae_out_mode_reg &= 0x0f;
+	writeReg(AE_STATUS_REG,ae_out_mode_reg);
+	ae_interrupt_sta = 1;
+
+	ae_out_mode_reg = readReg(AE_STATUS_REG);
+	wake_up_interruptible(&wait_ae);
+
+    return IRQ_HANDLED;
+}
+
+static long ace_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int 				ret_val = 0;
+	unsigned long       test_arg;
+	__ace_req_e 		mpara;
+	unsigned long rate;
+	switch (cmd){
+		case ACE_DEV_HWREQ:
+			test_arg = copy_from_user(&mpara, (__ace_req_e *)arg,
+                       sizeof(__ace_req_e));
+			ret_val = ACE_HwReq(mpara.module, mpara.mode, mpara.timeout);
+			break;
+
+		case ACE_DEV_HWREL:
+			test_arg = copy_from_user(&mpara, (__ace_req_e *)arg,
+                       sizeof(__ace_req_e));
+			ret_val = ACE_HwRel(mpara.module);
+			break;
+
+		case ACE_DEV_GETCLKFREQ:
+			test_arg = ACE_GetClk();
+			put_user(test_arg, (unsigned long *)arg);
+			ret_val = 1;
+			break;
+		case ACE_DEV_GET_ADDR:
+			put_user((int)ace_hsram, (int *)arg);
+			break;
+		case ACE_DEV_INS_ISR:
+			break;
+
+		case ACE_DEV_UNINS_ISR:
+		   break;
+
+		case ACE_DEV_WAIT_AE:
+			wait_event_interruptible(wait_ae,
+			    ae_interrupt_sta);
+			ae_interrupt_sta = 0;
+			return ae_interrupt_value;
+		case ACE_DEV_CLK_OPEN:
+			/* ace_moduleclk */
+			ace_moduleclk = clk_get(NULL,"ace");
+			ace_pll5_pclk = clk_get(NULL, "sdram_pll_p");
+			if (clk_set_parent(ace_moduleclk, ace_pll5_pclk)) {
+				printk("try to set parent of ace_moduleclk to ace_pll5clk failed!\n");
+			}
+			rate = clk_get_rate(ace_pll5_pclk);
+			if(clk_set_rate(ace_moduleclk, rate/2)) {
+				printk("try to set ace_moduleclk rate failed!!!\n");
+				 goto out;
+			}
+			if(clk_reset(ace_moduleclk, 1)){
+				printk("try to reset ace_moduleclkfailed!!!\n");
+				 goto out;
+			}
+			if(clk_reset(ace_moduleclk, 0)){
+				printk("try to reset ace_moduleclkfailed!!!\n");
+				 goto out;
+			}
+			if (-1 == clk_enable(ace_moduleclk)) {
+				printk("ace_moduleclk failed; \n");
+				goto out;
+			}
+
+			/*geting dram clk for ace!*/
+			dram_aceclk = clk_get(NULL, "sdram_ace");
+
+			if (-1 == clk_enable(dram_aceclk)) {
+				printk("dram_moduleclk failed; \n");
+				 goto out1;
+			}
+			/* getting ahb clk for ace! */
+			ahb_aceclk = clk_get(NULL,"ahb_ace");
+			if (-1 == clk_enable(ahb_aceclk)) {
+				printk("ahb_aceclk failed; \n");
+				goto out2;
+			}
+			ref_count++;
+			goto out;
+			out2:
+				clk_disable(dram_aceclk);
+			out1:
+				clk_disable(ace_moduleclk);
+			out:
+			break;
+		case ACE_DEV_CLK_CLOSE:
+			clk_disable(ace_moduleclk);
+			//éæ¾ace_moduleclkæ¶éå¥æ
+			clk_put(ace_moduleclk);
+			//éæ¾ace_pll5_pclkæ¶éå¥æ
+			clk_put(ace_pll5_pclk);
+
+			clk_disable(dram_aceclk);
+			//éæ¾dram_aceclkæ¶éå¥æ
+			clk_put(dram_aceclk);
+
+			clk_disable(ahb_aceclk);
+			//éæ¾ahb_aceclkæ¶éå¥æ
+			clk_put(ahb_aceclk);
+			ref_count--;
+			break;
+		default:
+			break;
+	}
+	return ret_val;
+}
+
+void acedev_vma_open(struct vm_area_struct *vma)
+{
+
+}
+
+void acedev_vma_close(struct vm_area_struct *vma)
+{
+
+}
+
+static struct vm_operations_struct acedev_remap_vm_ops = {
+    .open = acedev_vma_open,
+    .close = acedev_vma_close,
+};
+
+static int acedev_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long temp_pfn;
+    temp_pfn = ACE_REGS_pBASE >> 12;
+    /* Set reserved and I/O flag for the area. */
+    vma->vm_flags |= VM_RESERVED | VM_IO;
+
+    /* Select uncached access. */
+    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+    if (io_remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                    vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+        return -EAGAIN;
+    }
+    vma->vm_ops = &acedev_remap_vm_ops;
+    acedev_vma_open(vma);
+
+    return 0;
+}
+
+static int snd_sw_ace_suspend(struct platform_device *pdev,pm_message_t state)
+{
+	suspend_acerate = clk_get_rate(ace_moduleclk);
+	clk_disable(dram_aceclk);
+	//éæ¾dram_aceclkæ¶éå¥æ
+	clk_put(dram_aceclk);
+
+	clk_disable(ace_moduleclk);
+	//éæ¾ace_moduleclkæ¶éå¥æ
+	clk_put(ace_moduleclk);
+	clk_disable(ahb_aceclk);
+	//éæ¾ahb_aceclkæ¶éå¥æ
+	clk_put(ahb_aceclk);
+	//éæ¾ace_pll5_pclkæ¶éå¥æ
+	clk_put(ace_pll5_pclk);
+
+	/*for clk test*/
+#ifdef ACE_DEBUG
+	printk("[ace_suspend reg]\n");
+	printk("ace_module CLK:0xf1c20148 is:%x\n", *(volatile int *)0xf1c20148);
+	printk("ace_pll5_p CLK:0xf1c20020 is:%x\n", *(volatile int *)0xf1c20020);
+	printk("dram_ace CLK:0xf1c20100 is:%x\n", *(volatile int *)0xf1c20100);
+	printk("ahb_ace CLK:0xf1c20060 is:%x\n", *(volatile int *)0xf1c20060);
+	printk("[ace_suspend reg]\n");
+#endif
+	return 0;
+}
+
+static int snd_sw_ace_resume(struct platform_device *pdev)
+{
+	if(ref_count == 0){
+		return 0;
+	}
+	/* ace_moduleclk */
+	ace_moduleclk = clk_get(NULL,"ace");
+	ace_pll5_pclk = clk_get(NULL, "sdram_pll_p");
+	if (clk_set_parent(ace_moduleclk, ace_pll5_pclk)) {
+		printk("try to set parent of ace_moduleclk to ace_pll5clk failed!\n");
+		goto out;
+	}
+
+	if(clk_set_rate(ace_moduleclk, suspend_acerate)) {
+	   	printk("try to set ace_moduleclk rate failed!!!\n");
+	   	goto out;
+	}
+	if(clk_reset(ace_moduleclk, 1)){
+	   	printk("try to reset ace_moduleclkfailed!!!\n");
+	   	goto out;
+	}
+	if(clk_reset(ace_moduleclk, 0)){
+	   	printk("try to reset ace_moduleclkfailed!!!\n");
+	   	goto out;
+	}
+	if (-1 == clk_enable(ace_moduleclk)) {
+	   printk("ace_moduleclk failed; \n");
+	   goto out;
+	}
+
+	/*geting dram clk for ace!*/
+	dram_aceclk = clk_get(NULL, "sdram_ace");
+
+	if (-1 == clk_enable(dram_aceclk)) {
+	   	printk("dram_moduleclk failed; \n");
+	   	goto out1;
+	}
+	/* getting ahb clk for ace! */
+	ahb_aceclk = clk_get(NULL,"ahb_ace");
+	if (-1 == clk_enable(ahb_aceclk)) {
+	   	printk("ahb_aceclk failed; \n");
+	   	goto out2;
+	}
+	goto out;
+
+	out2:
+		clk_disable(dram_aceclk);
+	out1:
+		clk_disable(ace_moduleclk);
+	out:
+	return 0;
+}
+
+static struct file_operations ace_dev_fops = {
+    .owner =    THIS_MODULE,
+    .unlocked_ioctl = ace_dev_ioctl,
+    .mmap           = acedev_mmap,
+    .open           = ace_dev_open,
+    .release        = ace_dev_release,
+};
+
+/*data relating*/
+static struct platform_device sw_device_ace = {
+	.name = "sun4i-ace",
+};
+
+/*method relating*/
+static struct platform_driver sw_ace_driver = {
+#ifdef CONFIG_PM
+	.suspend	= snd_sw_ace_suspend,
+	.resume		= snd_sw_ace_resume,
+#endif
+	.driver		= {
+		.name	= "sun4i-ace",
+	},
+};
+
+static int __init ace_dev_init(void)
+{
+    int status = 0;
+    int err = 0;
+	int ret = 0;
+	printk("[ace_drv] start!!!\n");
+	ret = request_irq(ACE_IRQ_NO, ace_interrupt, 0, "ace_dev", NULL);
+	if (ret < 0) {
+	   printk("request ace irq err\n");
+	   return -EINVAL;
+	}
+
+	if((platform_device_register(&sw_device_ace))<0)
+		return err;
+	if ((err = platform_driver_register(&sw_ace_driver)) < 0)
+		return err;
+
+    alloc_chrdev_region(&dev_num, 0, 1, "ace_chrdev");
+    ace_dev = cdev_alloc();
+    cdev_init(ace_dev, &ace_dev_fops);
+    ace_dev->owner = THIS_MODULE;
+    err = cdev_add(ace_dev, dev_num, 1);
+    if (err) {
+    	printk(KERN_NOTICE"Error %d adding ace_dev!\n", err);
+        return -1;
+    }
+
+    ace_dev_class = class_create(THIS_MODULE, "ace_cls");
+    device_create(ace_dev_class, NULL, dev_num, NULL, "ace_dev");
+    ACE_Init();
+    printk("[ace_drv] init end!!!\n");
+    return status;
+}
+module_init(ace_dev_init);
+
+static void __exit ace_dev_exit(void)
+{
+	free_irq(ACE_IRQ_NO, NULL);
+	ACE_Exit();
+    device_destroy(ace_dev_class,  dev_num);
+    class_destroy(ace_dev_class);
+    platform_driver_unregister(&sw_ace_driver);
+}
+module_exit(ace_dev_exit);
+
+MODULE_AUTHOR("young");
+MODULE_DESCRIPTION("User mode encrypt device interface");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/audio/sun4i_drv_ace.h b/drivers/media/audio/sun4i_drv_ace.h
new file mode 100644
index 0000000..d3bb23f
--- /dev/null
+++ b/drivers/media/audio/sun4i_drv_ace.h
@@ -0,0 +1,66 @@
+/*
+ * drivers\media\audio\sun4i_drv_ace.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __ACE_HAL_H__
+#define	__ACE_HAL_H__
+#include <linux/types.h>
+#include <linux/clk.h>
+
+// defule type of modules in ACE
+typedef enum __ACE_MODULE_TYPE
+{
+    ACE_MODULE_NONE = 0,
+    ACE_MODULE_CE,
+    ACE_MODULE_AE,
+    ACE_MODULE_PNG,
+    ACE_MODULE_TSCC,
+    ACE_MODULE_
+
+}__ace_module_type_e;
+
+typedef enum __ACE_REQUEST_MODE
+{
+    ACE_REQUEST_MODE_WAIT = 0,  //request hw with waiting mode
+    ACE_REQUEST_MODE_NOWAIT,    //request hw with no-wait mode
+    ACE_REQUEST_MODE_
+
+} __ace_request_mode_e;
+
+typedef enum __ACE_OPS
+{
+	ACE_DEV_HWREQ = 100,
+	ACE_DEV_HWREL,
+	ACE_DEV_GETCLKFREQ,
+	ACE_DEV_GET_ADDR,
+	ACE_DEV_INS_ISR,
+	ACE_DEV_UNINS_ISR,
+	ACE_DEV_WAIT_AE,
+	ACE_DEV_CLK_OPEN,
+	ACE_DEV_CLK_CLOSE,
+	ACE_DEV_
+}__ace_ops_e;
+
+typedef struct ace_req{
+	__ace_module_type_e module;
+	__ace_request_mode_e mode;
+	__u32 timeout;
+}__ace_req_e;
+
+__s32 ACE_Init(void);
+__s32 ACE_Exit(void);
+s32 ACE_HwReq(__ace_module_type_e module, __ace_request_mode_e mode, __u32 timeout);
+__s32 ACE_HwRel(u32 hHWRes);
+__u32 ACE_GetClk(void);
+
+#endif	/* __ACE_HAL_H__ */
diff --git a/drivers/media/pa/Kconfig b/drivers/media/pa/Kconfig
new file mode 100644
index 0000000..2c7f998
--- /dev/null
+++ b/drivers/media/pa/Kconfig
@@ -0,0 +1,4 @@
+config PA_CONFIG
+	tristate "pa mamage config"
+	default y
+	depends on PA_CONTROL
diff --git a/drivers/media/pa/Makefile b/drivers/media/pa/Makefile
new file mode 100644
index 0000000..7b1e8b8
--- /dev/null
+++ b/drivers/media/pa/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_PA_CONFIG) += sun4i_pa.o
diff --git a/drivers/media/pa/sun4i_pa.c b/drivers/media/pa/sun4i_pa.c
new file mode 100644
index 0000000..fdd17a1
--- /dev/null
+++ b/drivers/media/pa/sun4i_pa.c
@@ -0,0 +1,172 @@
+/*
+ * drivers/media/pa/sun4i_pa.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/preempt.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+#include <linux/rmap.h>
+#include <linux/string.h>
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+#include <plat/sys_config.h>
+#include <mach/system.h>
+
+static int gpio_pa_shutdown = 0;
+static struct class *pa_dev_class;
+static struct cdev *pa_dev;
+static dev_t dev_num ;
+
+//#define PA_DEBUG
+typedef enum PA_OPT
+{
+	PA_OPEN = 200,
+	PA_CLOSE,
+	PA_DEV_
+}__ace_ops_e;
+
+
+static int pa_dev_open(struct inode *inode, struct file *filp){
+	#ifdef PA_DEBUG
+	 printk("%s,%d\n", __func__, __LINE__);
+	 #endif
+    return 0;
+}
+
+static int pa_dev_release(struct inode *inode, struct file *filp){
+	#ifdef PA_DEBUG
+	 printk("%s,%d\n", __func__, __LINE__);
+	 #endif
+    return 0;
+}
+
+static long
+pa_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
+
+	switch (cmd) {
+		case PA_OPEN:
+			#ifdef PA_DEBUG
+			printk("%s,%d\n", __func__, __LINE__);
+			#endif
+			gpio_write_one_pin_value(gpio_pa_shutdown, 1, "audio_pa_ctrl");
+			break;
+		case PA_CLOSE:
+			#ifdef PA_DEBUG
+			printk("%s,%d\n", __func__, __LINE__);
+			#endif
+			gpio_write_one_pin_value(gpio_pa_shutdown, 0, "audio_pa_ctrl");
+			break;
+		default:
+			break;
+	}
+	return 0;
+}
+
+static int snd_sun4i_pa_suspend(struct platform_device *pdev,pm_message_t state)
+{
+	return 0;
+}
+
+static int snd_sun4i_pa_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct file_operations pa_dev_fops = {
+    .owner 			= THIS_MODULE,
+    .unlocked_ioctl = pa_dev_ioctl,
+    .open           = pa_dev_open,
+    .release        = pa_dev_release,
+};
+
+/*data relating*/
+static struct platform_device sun4i_device_pa = {
+	.name = "sun4i-pa",
+};
+
+/*method relating*/
+static struct platform_driver sun4i_pa_driver = {
+#ifdef CONFIG_PM
+	.suspend	= snd_sun4i_pa_suspend,
+	.resume		= snd_sun4i_pa_resume,
+#endif
+	.driver		= {
+		.name	= "sun4i-pa",
+	},
+};
+
+static int __init pa_dev_init(void)
+{
+    int err = 0;
+	printk("[pa_drv] start!!!\n");
+
+	if((platform_device_register(&sun4i_device_pa))<0)
+		return err;
+
+	if ((err = platform_driver_register(&sun4i_pa_driver)) < 0)
+		return err;
+
+    alloc_chrdev_region(&dev_num, 0, 1, "pa_chrdev");
+    pa_dev = cdev_alloc();
+    cdev_init(pa_dev, &pa_dev_fops);
+    pa_dev->owner = THIS_MODULE;
+    err = cdev_add(pa_dev, dev_num, 1);
+    if (err) {
+    	printk(KERN_NOTICE"Error %d adding pa_dev!\n", err);
+        return -1;
+    }
+    pa_dev_class = class_create(THIS_MODULE, "pa_cls");
+    device_create(pa_dev_class, NULL,
+                  dev_num, NULL, "pa_dev");
+    printk("[pa_drv] init end!!!\n");
+    return 0;
+}
+module_init(pa_dev_init);
+
+static void __exit pa_dev_exit(void)
+{
+    device_destroy(pa_dev_class,  dev_num);
+    class_destroy(pa_dev_class);
+    platform_driver_unregister(&sun4i_pa_driver);
+}
+module_exit(pa_dev_exit);
+
+MODULE_AUTHOR("young");
+MODULE_DESCRIPTION("User mode encrypt device interface");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index ce1e7ba..a034ec6 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1222,3 +1222,32 @@ config VIDEO_MX2_EMMAPRP
 	    conversion.
 
 endif # V4L_MEM2MEM_DRIVERS
+
+config VIDEO_SUN4I_CEDAR
+       tristate "CEDAR driver for sun4i"
+       depends on ARCH_SUN4I
+       help
+         CEDAR driver for sun4i
+
+if VIDEO_SUN4I_CEDAR
+source "drivers/media/video/sun4i/Kconfig"
+endif
+
+config VIDEO_SUN5I_CEDAR
+       tristate "CEDAR driver for sun5i"
+       depends on ARCH_SUN5I
+       help
+         CEDAR driver for sun5i
+
+if VIDEO_SUN5I_CEDAR
+source "drivers/media/video/sun5i/Kconfig"
+endif
+
+menuconfig VIDEO_CSI_SUN4I
+	bool "CSI Driver Config for sun4i"
+	default m
+	depends on VIDEO_DEV && VIDEO_V4L2
+
+if VIDEO_CSI_SUN4I
+source "drivers/media/video/sun4i_csi/Kconfig"	   	  
+endif
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index a6282a3..cd22c31 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -97,6 +97,7 @@ obj-$(CONFIG_SOC_CAMERA_OV9740)		+= ov9740.o
 obj-$(CONFIG_SOC_CAMERA_RJ54N1)		+= rj54n1cb0c.o
 obj-$(CONFIG_SOC_CAMERA_TW9910)		+= tw9910.o
 
+obj-$(CONFIG_VIDEO_CSI_SUN4I)					+= sun4i_csi/device/
 # And now the v4l2 drivers:
 
 obj-$(CONFIG_VIDEO_BT848) += bt8xx/
@@ -212,3 +213,13 @@ obj-$(CONFIG_ARCH_OMAP)	+= omap/
 ccflags-y += -I$(srctree)/drivers/media/dvb/dvb-core
 ccflags-y += -I$(srctree)/drivers/media/dvb/frontends
 ccflags-y += -I$(srctree)/drivers/media/common/tuners
+
+ifdef CONFIG_VIDEO_SUN4I_CEDAR
+  obj-$(CONFIG_VIDEO_SUN4I_CEDAR) += sun4i/
+endif
+ifdef CONFIG_VIDEO_SUN5I_CEDAR
+  obj-$(CONFIG_VIDEO_SUN5I_CEDAR) += sun5i/
+endif
+
+obj-$(CONFIG_CSI0_SUN4I) += sun4i_csi/csi0/
+obj-$(CONFIG_CSI1_SUN4I) += sun4i_csi/csi1/
diff --git a/drivers/media/video/sun4i/Kconfig b/drivers/media/video/sun4i/Kconfig
new file mode 100644
index 0000000..3c83be5
--- /dev/null
+++ b/drivers/media/video/sun4i/Kconfig
@@ -0,0 +1,18 @@
+config VIDEO_DECODER_SUN4I
+	tristate "sun4i video decoder support"
+	depends on VIDEO_SUN4I_CEDAR
+	default y
+	---help---
+	  This is the driver for sun4i video decoder, including h264/
+	  mpeg4/mpeg2/vc1/rmvb.
+	  To compile this driver as a module, choose M here: the
+	  module will be called cedar_dev.
+
+config VIDEO_AVS_COUNTER
+	tristate "sun4i av-sync counter support"
+	depends on VIDEO_SUN4I_CEDAR
+	default n
+	---help---
+	  This is the driver for sun4i av-sync counter.
+	  To compile this driver as a module, choose M here: the
+	  module will be called avs_dev.
diff --git a/drivers/media/video/sun4i/Makefile b/drivers/media/video/sun4i/Makefile
new file mode 100644
index 0000000..1dc253b
--- /dev/null
+++ b/drivers/media/video/sun4i/Makefile
@@ -0,0 +1,5 @@
+# AW16XX Audio Card Support
+obj-$(CONFIG_VIDEO_DECODER_SUN4I) += sun4i_cedar_mod.o
+obj-$(CONFIG_VIDEO_AVS_COUNTER) += sun4i_avs.o
+
+sun4i_cedar_mod-objs := sun4i_cedar.o cache-v7.o
diff --git a/drivers/media/video/sun4i/cache-v7.S b/drivers/media/video/sun4i/cache-v7.S
new file mode 100644
index 0000000..560ef5a
--- /dev/null
+++ b/drivers/media/video/sun4i/cache-v7.S
@@ -0,0 +1,65 @@
+/*
+ * drivers/media/video/sun4i/cache-v7.S
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __ASSEMBLY__
+#define __ASSEMBLY__
+#endif
+#include <asm/assembler.h>
+/*
+    c code declared as follows:
+    int flush_clean_user_range(long start, long end);
+*/
+	.macro	dcache_line_size, reg, tmp
+	mrc	p15, 1, \tmp, c0, c0, 0		@ read CSIDR
+	and	\tmp, \tmp, #7			@ cache line size encoding
+	mov	\reg, #16			@ size offset
+	mov	\reg, \reg, lsl \tmp		@ actual cache line size
+	.endm
+
+    .text
+    .globl flush_clean_user_range
+flush_clean_user_range:
+    dcache_line_size r2, r3
+    sub	r3, r2, #1
+    bic	r0, r0, r3
+1:
+    USER(	mcr	p15, 0, r0, c7, c14, 1	)	@ clean and flush D line to the point of unification
+    add	r0, r0, r2
+2:
+    cmp	r0, r1
+    blo	1b
+    mov	r0, #0
+    dsb
+    mov	pc, lr
+
+/*
+ * Fault handling for the cache operation above. If the virtual address in r0
+ * isn't mapped, just try the next page.
+ */
+9001:
+    mov	r0, r0, lsr #12
+    mov	r0, r0, lsl #12
+    add	r0, r0, #4096
+    b	2b
+
+
diff --git a/drivers/media/video/sun4i/readme b/drivers/media/video/sun4i/readme
new file mode 100644
index 0000000..a91b192
--- /dev/null
+++ b/drivers/media/video/sun4i/readme
@@ -0,0 +1,48 @@
+/*
+ * drivers/media/video/sun4i/readme
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#------------------------------------------------------------
+# Cedar_dev : video engine driver
+#------------------------------------------------------------
+
+#------------------------------------------------------------
+#@version: cedar_vers0_08
+#@Author : Truby.Zong
+#@Date   : 2011-4-06
+#@Description:
+#	The second version of cedar video engine driver, which
+# add VD/DE SRAM prority and change file name.
+#-------------------------------------------------------------
+#
+#------------------------------------------------------------
+#@version: Vers0_01
+#@Author : Truby.Zong
+#@Date   : 2011-3-18
+#@Description:
+#	The first version of cedar video engine driver, which
+#handles the irq/clock/phy memory alloc of the cedar device,
+#and also the AV-SYNC counter (AVS_CNT1);
+#    Please pay attention to the method to request/remap IO
+#resource and request/free irq, which are just handle once in
+#module init and module exit.
+#-------------------------------------------------------------
+
diff --git a/drivers/media/video/sun4i/sun4i_avs.c b/drivers/media/video/sun4i/sun4i_avs.c
new file mode 100644
index 0000000..3cf0fdb
--- /dev/null
+++ b/drivers/media/video/sun4i/sun4i_avs.c
@@ -0,0 +1,426 @@
+/*
+ * drivers/media/video/sun4i/sun4i_avs.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * sun4i_avs.c
+ * driver for av-sync counter
+ * Author : Truby.Zong <truby.zhuang@chipsbank.com>
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/preempt.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+#include <linux/rmap.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+
+#include "sun4i_cedar.h"
+
+#define DRV_VERSION "0.01alpha"
+
+#ifndef AVSDEV_MAJOR
+#define AVSDEV_MAJOR (151)
+#endif
+#ifndef AVSDEV_MINOR
+#define AVSDEV_MINOR (0)
+#endif
+
+#undef _info
+#ifdef CEDAR_DEBUG
+#  define _info(fmt, args...) printk( KERN_DEBUG "[avs]: " fmt, ## args)
+#else
+#  define _info(fmt, args...)
+#endif
+
+int avs_dev_major = AVSDEV_MAJOR;
+int avs_dev_minor = AVSDEV_MINOR;
+module_param(avs_dev_major, int, S_IRUGO);
+module_param(avs_dev_minor, int, S_IRUGO);
+
+struct iomap_resource{
+	struct resource *io_sram;
+	struct resource *io_ccmu;
+	struct resource *io_macc;
+	struct resource *io_mpeg;
+	struct resource *io_vc1;
+	struct resource *io_memc;
+};
+struct iomap_resource iomap_res;
+
+struct iomap_para{
+	volatile char*	regs_sram;
+	volatile char*	regs_ccmu;
+	volatile char*	regs_macc;
+	volatile char*	regs_mpeg;
+	volatile char*	regs_vc1;
+	volatile char*	regs_memc;
+};
+
+struct avs_dev {
+	struct cdev cdev;	             /* char device struct                 */
+	struct device *dev;              /* ptr to class device struct         */
+	struct class  *class;            /* class for auto create device node  */
+
+	struct semaphore sem;            /* mutual exclusion semaphore         */
+	spinlock_t lock;                 /* spinlock to pretect ioctl access   */
+
+	struct iomap_para iomap_addrs;   /* io remap addrs                     */
+    struct iomap_resource iomap_res; /* io remap resources                 */
+};
+struct avs_dev *avs_devp;
+
+/*
+ * ioremap and request iomem
+ */
+static void avs_register_iomem(struct avs_dev *devp)
+{
+    struct resource *res;
+    char *addr;
+
+    memset(&devp->iomap_res,   0, sizeof(struct iomap_resource));
+    memset(&devp->iomap_addrs, 0, sizeof(struct iomap_para));
+
+    /* request mem for ccmu */
+    res = request_mem_region(CCMU_REGS_pBASE, 1024, "ccmu");
+    if (res == NULL)    {
+        printk("Cannot reserve region for ccmu\n");
+        goto err_out;
+    }
+    devp->iomap_res.io_ccmu = res;
+
+	/* ioremap for ccmu */
+    addr = ioremap(CCMU_REGS_pBASE, 4096);
+    if (!addr){
+        printk("cannot map region for ccmu");
+        goto err_out;
+    }
+    devp->iomap_addrs.regs_ccmu = addr;
+
+    return;
+
+err_out:
+    if (devp->iomap_addrs.regs_ccmu)
+		iounmap(devp->iomap_addrs.regs_ccmu);
+}
+
+/*
+ * unmap/release iomem
+ */
+static void avs_iomem_unregister(struct avs_dev *devp)
+{
+    if (devp->iomap_res.io_ccmu) {
+		release_resource(devp->iomap_res.io_ccmu);
+		devp->iomap_res.io_ccmu = NULL;
+	}
+
+	/* iounmap */
+    if (devp->iomap_addrs.regs_ccmu) {
+		iounmap(devp->iomap_addrs.regs_ccmu);
+		devp->iomap_addrs.regs_ccmu = NULL;
+	}
+}
+
+/*
+ * ioctl function
+ * including : wait video engine done,
+ *             AVS Counter control,
+ *             Physical memory control,
+ *             module clock/freq control.
+ */
+long avsdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long   ret;
+    unsigned int v;
+
+	spinlock_t *lock;
+	struct avs_dev *devp;
+
+	ret = 0;
+	devp = filp->private_data;
+	lock = &devp->lock;
+
+    switch (cmd)
+    {
+        case IOCTL_GETVALUE_AVS2:
+			spin_lock(lock);
+
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc40);
+
+			spin_unlock(lock);
+			return v;
+
+        case IOCTL_CONFIG_AVS2:
+			spin_lock(lock);
+
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc44);
+            v = 239<<16 | (v&0xffff);
+            writel(v, devp->iomap_addrs.regs_ccmu + 0xc44);
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc38);
+            v |= 1<<9 | 1<<1;
+            writel(v, devp->iomap_addrs.regs_ccmu + 0xc38);
+            writel(0, devp->iomap_addrs.regs_ccmu + 0xc40);
+
+			spin_unlock(lock);
+            break;
+
+        case IOCTL_RESET_AVS2:
+			spin_lock(lock);
+
+            writel(0, devp->iomap_addrs.regs_ccmu + 0xc40);
+
+			spin_unlock(lock);
+            break;
+
+        case IOCTL_PAUSE_AVS2:
+			spin_lock(lock);
+
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc38);
+            v |= 1<<9;
+            writel(v, devp->iomap_addrs.regs_ccmu + 0xc38);
+
+			spin_unlock(lock);
+            break;
+
+        case IOCTL_START_AVS2:
+			spin_lock(lock);
+
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc38);
+            v &= ~(1<<9);
+            writel(v, devp->iomap_addrs.regs_ccmu + 0xc38);
+
+			spin_unlock(lock);
+            break;
+
+        default:
+            break;
+    }
+
+    return ret;
+}
+
+static int avsdev_open(struct inode *inode, struct file *filp)
+{
+	struct avs_dev *devp;
+	devp = container_of(inode->i_cdev, struct avs_dev, cdev);
+	filp->private_data = devp;
+
+	if (down_interruptible(&devp->sem)) {
+		return -ERESTARTSYS;
+	}
+
+	// init other resource here
+
+	up(&devp->sem);
+
+	nonseekable_open(inode, filp);
+	return 0;
+}
+
+static int avsdev_release(struct inode *inode, struct file *filp)
+{
+	struct avs_dev *devp;
+
+	devp = filp->private_data;
+
+	if (down_interruptible(&devp->sem)) {
+		return -ERESTARTSYS;
+	}
+
+	/* release other resource here */
+
+	up(&devp->sem);
+	return 0;
+}
+
+void avsdev_vma_open(struct vm_area_struct *vma)
+{
+    printk(KERN_NOTICE "avsdev VMA open, virt %lx, phys %lx\n",
+		vma->vm_start, vma->vm_pgoff << PAGE_SHIFT);
+	return;
+}
+
+void avsdev_vma_close(struct vm_area_struct *vma)
+{
+    printk(KERN_NOTICE "avsdev VMA close.\n");
+	return;
+}
+
+static struct vm_operations_struct avsdev_remap_vm_ops = {
+    .open  = avsdev_vma_open,
+    .close = avsdev_vma_close,
+};
+
+static int avsdev_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long temp_pfn;
+    unsigned int  VAddr;
+	struct iomap_para addrs;
+
+	unsigned int io_ram = 0;
+    VAddr = vma->vm_pgoff << 12;
+
+	addrs = avs_devp->iomap_addrs;
+
+    if(VAddr == (unsigned int)addrs.regs_ccmu) {
+        temp_pfn = CCMU_REGS_pBASE >> 12;
+        io_ram = 1;
+    } else {
+        temp_pfn = (__pa(vma->vm_pgoff << 12))>>12;
+        io_ram = 0;
+    }
+
+    if (io_ram == 0) {
+        /* Set reserved and I/O flag for the area. */
+        vma->vm_flags |= VM_RESERVED | VM_IO;
+
+        /* Select uncached access. */
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                            vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+            return -EAGAIN;
+        }
+    } else {
+        /* Set reserved and I/O flag for the area. */
+        vma->vm_flags |= VM_RESERVED | VM_IO;
+
+        /* Select uncached access. */
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (io_remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                               vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+            return -EAGAIN;
+        }
+    }
+
+    vma->vm_ops = &avsdev_remap_vm_ops;
+    avsdev_vma_open(vma);
+
+    return 0;
+}
+
+static struct file_operations avsdev_fops = {
+    .owner   = THIS_MODULE,
+    .unlocked_ioctl   = avsdev_ioctl,
+    .mmap    = avsdev_mmap,
+    .open    = avsdev_open,
+    .release = avsdev_release,
+	.llseek  = no_llseek,
+};
+
+static int __init avsdev_init(void)
+{
+	int ret;
+	int devno;
+	dev_t dev = 0;
+
+	printk("[tt]----- avs_dev driver load... ----\n");
+	if (avs_dev_major) {
+		dev = MKDEV(avs_dev_major, avs_dev_minor);
+		ret = register_chrdev_region(dev, 1, "avs_dev");
+	} else {
+		ret = alloc_chrdev_region(&dev, avs_dev_minor, 1, "avs_dev");
+		avs_dev_major = MAJOR(dev);
+		avs_dev_minor = MINOR(dev);
+	}
+
+	if (ret < 0) {
+		printk(KERN_WARNING "avs_dev: can't get major %d\n", avs_dev_major);
+		return ret;
+	}
+
+	avs_devp = kmalloc(sizeof(struct avs_dev), GFP_KERNEL);
+	if (avs_devp == NULL) {
+		printk("malloc mem for avs device err\n");
+		return -ENOMEM;
+	}
+	memset(avs_devp, 0, sizeof(struct avs_dev));
+
+	sema_init(&avs_devp->sem, 0);
+
+	/* request resources and ioremap */
+	printk("[tt]-----      register iomem      ----\n");
+	avs_register_iomem(avs_devp);
+
+	/* init lock for protect ioctl access */
+	spin_lock_init(&avs_devp->lock);
+
+	devno = MKDEV(avs_dev_major, avs_dev_minor);
+	cdev_init(&avs_devp->cdev, &avsdev_fops);
+	avs_devp->cdev.owner = THIS_MODULE;
+	avs_devp->cdev.ops = &avsdev_fops;
+	ret = cdev_add(&avs_devp->cdev, devno, 1);
+	if (ret) {
+		printk(KERN_NOTICE "Err:%d add avsdev", ret);
+	}
+
+    avs_devp->class = class_create(THIS_MODULE, "avs_dev");
+    avs_devp->dev   = device_create(avs_devp->class, NULL, devno, NULL, "avs_dev");
+
+	printk("[tt]--- avs_dev driver load ok!! -----\n");
+	return 0;
+}
+module_init(avsdev_init);
+
+static void __exit avsdev_exit(void)
+{
+	dev_t dev;
+	dev = MKDEV(avs_dev_major, avs_dev_minor);
+
+	/* Unregister iomem and iounmap */
+	avs_iomem_unregister(avs_devp);
+
+	if (avs_devp) {
+		cdev_del(&avs_devp->cdev);
+		device_destroy(avs_devp->class, dev);
+		class_destroy(avs_devp->class);
+	}
+
+	unregister_chrdev_region(dev, 1);
+
+	if (avs_devp) {
+		kfree(avs_devp);
+	}
+}
+module_exit(avsdev_exit);
+
+MODULE_AUTHOR("Soft-Allwinner");
+MODULE_DESCRIPTION("avs device driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/media/video/sun4i/sun4i_cedar.c b/drivers/media/video/sun4i/sun4i_cedar.c
new file mode 100644
index 0000000..1fab375
--- /dev/null
+++ b/drivers/media/video/sun4i/sun4i_cedar.c
@@ -0,0 +1,1119 @@
+/*
+ * drivers\media\video\sun4i\sun4i_cedar.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/preempt.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/rmap.h>
+#include <linux/wait.h>
+#include <linux/semaphore.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+#include <asm/siginfo.h>
+#include <asm/signal.h>
+#include <mach/system.h>
+#include <mach/clock.h>
+#include "sun4i_cedar.h"
+
+#define DRV_VERSION "0.01alpha"
+
+#define CHIP_VERSION_F23
+
+#undef USE_CEDAR_ENGINE
+
+#ifndef CEDARDEV_MAJOR
+#define CEDARDEV_MAJOR (150)
+#endif
+#ifndef CEDARDEV_MINOR
+#define CEDARDEV_MINOR (0)
+#endif
+
+//#define CEDAR_DEBUG
+
+#define CONFIG_SW_SYSMEM_RESERVED_BASE 0x43000000
+#define CONFIG_SW_SYSMEM_RESERVED_SIZE 75776
+
+int g_dev_major = CEDARDEV_MAJOR;
+int g_dev_minor = CEDARDEV_MINOR;
+module_param(g_dev_major, int, S_IRUGO);//S_IRUGO represent that g_dev_major can be read,but canot be write
+module_param(g_dev_minor, int, S_IRUGO);
+
+#ifdef CHIP_VERSION_F23
+#define VE_IRQ_NO (53)
+#else
+#define VE_IRQ_NO (48)
+#endif
+
+struct clk *ve_moduleclk = NULL;
+struct clk *ve_pll4clk = NULL;
+struct clk *ahb_veclk = NULL;
+struct clk *dram_veclk = NULL;
+struct clk *avs_moduleclk = NULL;
+struct clk *hosc_clk = NULL;
+
+static unsigned long pll4clk_rate = 720000000;
+
+extern unsigned long ve_start;
+extern unsigned long ve_size;
+extern int flush_clean_user_range(long start, long end);
+struct iomap_para{
+	volatile char* regs_macc;
+	#ifdef CHIP_VERSION_F23
+	volatile char* regs_avs;
+	#else
+	volatile char* regs_ccmu;
+	#endif
+};
+
+static DECLARE_WAIT_QUEUE_HEAD(wait_ve);
+struct cedar_dev {
+	struct cdev cdev;	             /* char device struct                 */
+	struct device *dev;              /* ptr to class device struct         */
+	struct class  *class;            /* class for auto create device node  */
+
+	struct semaphore sem;            /* mutual exclusion semaphore         */
+
+	wait_queue_head_t wq;            /* wait queue for poll ops            */
+
+	struct iomap_para iomap_addrs;   /* io remap addrs                     */
+
+	struct timer_list cedar_engine_timer;
+	struct timer_list cedar_engine_timer_rel;
+
+	u32 irq;                         /* cedar video engine irq number      */
+	u32 irq_flag;                    /* flag of video engine irq generated */
+	u32 irq_value;                   /* value of video engine irq          */
+	u32 irq_has_enable;
+	u32 ref_count;
+};
+struct cedar_dev *cedar_devp;
+
+u32 int_sta=0,int_value;
+
+/*
+ * Video engine interrupt service routine
+ * To wake up ve wait queue
+ */
+static irqreturn_t VideoEngineInterupt(int irq, void *dev)
+{
+    unsigned int ve_int_ctrl_reg;
+    volatile int val;
+    int modual_sel;
+    struct iomap_para addrs = cedar_devp->iomap_addrs;
+
+    modual_sel = readl(addrs.regs_macc + 0);
+    modual_sel &= 0xf;
+
+	/* estimate Which video format */
+    switch (modual_sel)
+    {
+        case 0: //mpeg124
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x100 + 0x14);
+            break;
+        case 1: //h264
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x200 + 0x20);
+            break;
+        case 2: //vc1
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x300 + 0x24);
+            break;
+        case 3: //rmvb
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x400 + 0x14);
+            break;
+        case 0xa: //isp
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0xa00 + 0x08);
+            break;
+        case 0xb: //avc enc
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0xb00 + 0x14);
+            break;
+        default:
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x100 + 0x14);
+            printk("macc modual sel not defined!\n");
+            break;
+    }
+
+    //disable interrupt
+    if(modual_sel == 0) {
+        val = readl(ve_int_ctrl_reg);
+        writel(val & (~0x7c), ve_int_ctrl_reg);
+    } else {
+        val = readl(ve_int_ctrl_reg);
+        writel(val & (~0xf), ve_int_ctrl_reg);
+    }
+
+    cedar_devp->irq_value = 1;	//hx modify 2011-8-1 16:08:47
+    cedar_devp->irq_flag = 1;
+    //any interrupt will wake up wait queue
+    wake_up_interruptible(&wait_ve);        //ioctl
+
+    return IRQ_HANDLED;
+}
+
+/*
+ * poll operateion for wait for ve irq
+ */
+unsigned int cedardev_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	int mask = 0;
+	struct cedar_dev *devp = filp->private_data;
+
+	poll_wait(filp, &devp->wq, wait);
+	if (devp->irq_flag == 1) {
+		devp->irq_flag = 0;
+		mask |= POLLIN | POLLRDNORM;
+	}
+	return mask;
+}
+
+static int clk_status = 0;
+static LIST_HEAD(run_task_list);
+static LIST_HEAD(del_task_list);
+static spinlock_t cedar_spin_lock;
+#define CEDAR_RUN_LIST_NONULL	-1
+#define CEDAR_NONBLOCK_TASK  0      //éé»å¡
+#define CEDAR_BLOCK_TASK 1
+#define CLK_REL_TIME 10000	//10ç§
+#define TIMER_CIRCLE 50		//50æ¯«ç§
+#define TASK_INIT      0x00
+#define TASK_TIMEOUT   0x55
+#define TASK_RELEASE   0xaa
+#define SIG_CEDAR		35
+
+int enable_cedar_hw_clk(void)
+{
+	unsigned long flags;
+	int res = -EFAULT;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	if (clk_status == 1)
+		goto out;
+	clk_status = 1;
+
+	if(0 != clk_enable(ahb_veclk)){
+		printk("ahb_veclk failed; \n");
+		goto out;
+	}
+	if(0 != clk_enable(ve_moduleclk)){
+		printk("ve_moduleclk failed; \n");
+		goto out3;
+	}
+	if(0 != clk_enable(dram_veclk)){
+		printk("dram_veclk failed; \n");
+		goto out2;
+	}
+	if(0 != clk_enable(avs_moduleclk)){
+		printk("ve_moduleclk failed; \n");
+		goto out1;
+	}
+	#ifdef CEDAR_DEBUG
+	printk("%s,%d\n",__func__,__LINE__);
+	#endif
+	res = 0;
+	goto out;
+
+out1:
+	clk_disable(dram_veclk);
+out2:
+	clk_disable(ve_moduleclk);
+out3:
+	clk_disable(ahb_veclk);
+out:
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+	return res;
+}
+
+int disable_cedar_hw_clk(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	if (clk_status == 0)
+		goto out;
+	clk_status = 0;
+
+	clk_disable(dram_veclk);
+	clk_disable(ve_moduleclk);
+	clk_disable(ahb_veclk);
+	clk_disable(avs_moduleclk);
+	#ifdef CEDAR_DEBUG
+	printk("%s,%d\n",__func__,__LINE__);
+	#endif
+out:
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+	return 0;
+}
+
+void cedardev_insert_task(struct cedarv_engine_task* new_task)
+{
+	struct cedarv_engine_task *task_entry;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	if(list_empty(&run_task_list))
+		new_task->is_first_task = 1;
+
+	/*éårun_task_listé¾è¡¨ï¼å¦ææå¥çä»»å¡ä¼åçº§æ¯é¾è¡¨èç¹ä¸­çä»»å¡ä¼åçº§é«ï¼å¹¶ä¸å½åæå¥ä»»å¡ä¸æ¯ç¬¬ä¸ä¸ªæå¥çä»»å¡ã
+	 *é£ä¹å°±å°ä¼åçº§é«çä»»å¡æ¾äºåé¢ï¼éåä¸­çä»»å¡éåä»é«å°åºçä¼åçº§éåæéã
+	 */
+	list_for_each_entry(task_entry, &run_task_list, list) {
+		if ((task_entry->is_first_task == 0) && (task_entry->running == 0) && (task_entry->t.task_prio < new_task->t.task_prio)) {
+			break;
+		}
+	}
+
+	list_add(&new_task->list, task_entry->list.prev);
+
+	#ifdef CEDAR_DEBUG
+	printk("%s,%d, TASK_ID:",__func__,__LINE__);
+	list_for_each_entry(task_entry, &run_task_list, list) {
+		printk("%d!", task_entry->t.ID);
+	}
+	printk("\n");
+	#endif
+	/*æ¯æ¬¡æå¥ä¸ä¸ªä»»å¡ï¼å°±å°å½åçè®¡æ¶å¨æ¶é´éç½®ä¸ºç³»ç»å½åçjiffies*/
+	mod_timer(&cedar_devp->cedar_engine_timer, jiffies + 0);
+
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+}
+
+int cedardev_del_task(int task_id)
+{
+	struct cedarv_engine_task *task_entry;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	/*éårun_task_listé¾è¡¨
+	*å¦ææ¾å°å¯¹åºçidå·ï¼é£ä¹å°±å°run_task_listé¾è¡¨ä¸­çä»»å¡ç§»å°del_task_listé¾è¡¨çè¡¨å¤´ã
+	*/
+	list_for_each_entry(task_entry, &run_task_list, list) {
+		if (task_entry->t.ID == task_id && task_entry->status != TASK_RELEASE) {
+			task_entry->status = TASK_RELEASE;
+
+			spin_unlock_irqrestore(&cedar_spin_lock, flags);
+			mod_timer(&cedar_devp->cedar_engine_timer, jiffies + 0);
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+
+	//æ¾ä¸å°å¯¹åº ID
+	return -1;
+}
+
+int cedardev_check_delay(int check_prio)
+{
+	struct cedarv_engine_task *task_entry;
+	int timeout_total = 0;
+	unsigned long flags;
+
+	/*è·åæ»çç­å¾æ¶é´*/
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+	list_for_each_entry(task_entry, &run_task_list, list) {
+		if ((task_entry->t.task_prio >= check_prio) || (task_entry->running == 1) || (task_entry->is_first_task == 1))
+			timeout_total = timeout_total + task_entry->t.frametime;
+	}
+
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+#ifdef CEDAR_DEBUG
+	printk("%s,%d,%d\n", __func__, __LINE__, timeout_total);
+#endif
+	return timeout_total;
+}
+
+static void cedar_engine_for_timer_rel(unsigned long arg)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	if(list_empty(&run_task_list)){
+		disable_cedar_hw_clk();
+	} else {
+		printk("Warring: cedar engine timeout for clk disable, but task left, something wrong?\n");
+		mod_timer( &cedar_devp->cedar_engine_timer, jiffies + msecs_to_jiffies(TIMER_CIRCLE));
+	}
+
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+}
+
+static void cedar_engine_for_events(unsigned long arg)
+{
+	struct cedarv_engine_task *task_entry, *task_entry_tmp;
+	struct siginfo info;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	list_for_each_entry_safe(task_entry, task_entry_tmp, &run_task_list, list) {
+		mod_timer(&cedar_devp->cedar_engine_timer_rel, jiffies + msecs_to_jiffies(CLK_REL_TIME));
+		if (task_entry->status == TASK_RELEASE ||
+				time_after(jiffies, task_entry->t.timeout)) {
+			if (task_entry->status == TASK_INIT)
+				task_entry->status = TASK_TIMEOUT;
+			list_move(&task_entry->list, &del_task_list);
+		}
+	}
+
+	list_for_each_entry_safe(task_entry, task_entry_tmp, &del_task_list, list) {
+		info.si_signo = SIG_CEDAR;
+		info.si_code = task_entry->t.ID;
+		if (task_entry->status == TASK_TIMEOUT){//è¡¨ç¤ºä»»å¡timeoutå é¤
+			info.si_errno = TASK_TIMEOUT;
+			send_sig_info(SIG_CEDAR, &info, task_entry->task_handle);
+		}else if(task_entry->status == TASK_RELEASE){//è¡¨ç¤ºä»»å¡æ­£å¸¸è¿è¡å®æ¯å é¤
+			info.si_errno = TASK_RELEASE;
+			send_sig_info(SIG_CEDAR, &info, task_entry->task_handle);
+		}
+		list_del(&task_entry->list);
+		kfree(task_entry);
+	}
+
+	/*æ¿æ´»é¾è¡¨ä¸­çtask*/
+	if(!list_empty(&run_task_list)){
+		task_entry = list_entry(run_task_list.next, struct cedarv_engine_task, list);
+		if(task_entry->running == 0){
+			task_entry->running = 1;
+			info.si_signo = SIG_CEDAR;
+			info.si_code = task_entry->t.ID;
+			info.si_errno = TASK_INIT;	//ä»»å¡å·²ç»å¯å¨
+			send_sig_info(SIG_CEDAR, &info, task_entry->task_handle);
+		}
+
+		mod_timer( &cedar_devp->cedar_engine_timer, jiffies + msecs_to_jiffies(TIMER_CIRCLE));
+	}
+
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+}
+
+#ifdef CHIP_VERSION_F23
+static unsigned int g_ctx_reg0;
+static void save_context(void)
+{
+	g_ctx_reg0 = readl(0xf1c20e00);
+}
+
+static void restore_context(void)
+{
+	writel(g_ctx_reg0, 0xf1c20e00);
+}
+#else
+	#define save_context()
+	#define restore_context()
+#endif
+
+#ifdef CHIP_VERSION_F23
+short VEPLLTable[][6] =
+{
+	//set, actual, Nb, Kb, Mb, Pb
+	{ 60,  60,  5,  2,  2,  1},
+	{ 90,  90,  5,  2,  0,  2},
+	{120, 120,  5,  2,  2,  0},
+	{150, 150, 25,  0,  0,  2},
+	{180, 180,  5,  2,  0,  1},
+	{216, 216,  6,  2,  0,  1},
+	{240, 240,  5,  3,  0,  1},
+	{270, 270, 15,  2,  0,  2},
+	{300, 300, 25,  0,  0,  1},
+	{330, 336,  7,  1,  0,  0},
+	{360, 360,  5,  2,  0,  0},
+	{384, 384,  4,  3,  0,  0},
+	{402, 400, 25,  1,  2,  0},
+	{420, 416, 13,  3,  2,  0},
+	{444, 448, 14,  3,  2,  0},
+	{456, 456, 19,  0,  0,  0},
+	{468, 468, 13,  2,  0,  1},
+	{480, 480,  5,  3,  0,  0},
+	{492, 496, 31,  1,  2,  0},
+};
+#endif
+
+/*
+ * ioctl function
+ * including : wait video engine done,
+ *             AVS Counter control,
+ *             Physical memory control,
+ *             module clock/freq control.
+ *				cedar engine
+ */
+long cedardev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long   ret = 0;
+	unsigned int v;
+	int ve_timeout = 0;
+	struct cedar_dev *devp;
+#ifdef USE_CEDAR_ENGINE
+	int rel_taskid = 0;
+	struct __cedarv_task task_ret;
+	struct cedarv_engine_task *task_ptr = NULL;
+#endif
+	unsigned long flags;
+
+	devp = filp->private_data;
+
+	switch (cmd)
+	{
+   		case IOCTL_ENGINE_REQ:
+   		#ifdef USE_CEDAR_ENGINE
+			if(copy_from_user(&task_ret, (void __user*)arg, sizeof(struct __cedarv_task))){
+				printk("IOCTL_ENGINE_REQ copy_from_user fail\n");
+				return -EFAULT;
+			}
+			spin_lock_irqsave(&cedar_spin_lock, flags);
+			/*å¦ætaskä¸ºéé»å¡ç¶æï¼è¯·æ±èå¯ä»¥ç«å³è¿å*/
+			if(!list_empty(&run_task_list) && ( task_ret.block_mode == CEDAR_NONBLOCK_TASK)){
+				spin_unlock_irqrestore(&cedar_spin_lock, flags);
+				return CEDAR_RUN_LIST_NONULL; //run_task_listéé¢æä»»å¡ï¼è¿å-1
+			}
+			spin_unlock_irqrestore(&cedar_spin_lock, flags);
+
+			/*å¦ætaskä¸ºé»å¡ç¶æï¼å°taskæå¥run_task_listé¾è¡¨ä¸­*/
+			task_ptr = kmalloc(sizeof(struct cedarv_engine_task), GFP_KERNEL);
+			if(!task_ptr){
+				printk("get mem for IOCTL_ENGINE_REQ\n");
+				return PTR_ERR(task_ptr);
+			}
+			task_ptr->task_handle = current;
+			task_ptr->t.ID = task_ret.ID;
+			task_ptr->t.timeout = jiffies + msecs_to_jiffies(1000*task_ret.timeout);//ms to jiffies
+			task_ptr->t.frametime = task_ret.frametime;
+			task_ptr->t.task_prio = task_ret.task_prio;
+			task_ptr->running = 0;
+			task_ptr->is_first_task = 0;
+			task_ptr->status = TASK_INIT;
+
+			cedardev_insert_task(task_ptr);
+
+			enable_cedar_hw_clk();
+
+			return task_ptr->is_first_task;//æå¥run_task_listé¾è¡¨ä¸­çä»»å¡æ¯ç¬¬ä¸ä¸ªä»»å¡ï¼è¿å1ï¼ä¸æ¯ç¬¬ä¸ä¸ªä»»å¡è¿å0. hx modify 2011-7-28 16:59:16ï¼ï¼ï¼
+		#else
+			enable_cedar_hw_clk();
+			cedar_devp->ref_count++;
+			break;
+		#endif
+    	case IOCTL_ENGINE_REL:
+    	#ifdef USE_CEDAR_ENGINE
+			rel_taskid = (int)arg;
+			/*
+			*	å©ç¨ä»»å¡çidå·è¿è¡ä»»å¡çå é¤æä½ãè¿åå¼æä¹ï¼æ¾ä¸å°å¯¹åºIDï¼è¿å-1;æ¾å°å¯¹åºIDï¼è¿å0ã
+			*/
+			ret = cedardev_del_task(rel_taskid);
+		#else
+			disable_cedar_hw_clk();
+			cedar_devp->ref_count--;
+		#endif
+			return ret;
+		case IOCTL_ENGINE_CHECK_DELAY:
+			{
+	            struct cedarv_engine_task_info task_info;
+	            /*ä»ç¨æ·ç©ºé´ä¸­è·åè¦æ¥è¯¢çä»»å¡ä¼åçº§ï¼éè¿ä»»å¡ä¼åçº§ï¼ç»è®¡éè¦ç­å¾çæ»æ¶é´total_time.
+				* å¨è¿ä¸ªæ¥å£ä¸­ï¼åæ¶ä¹ç»ç¨æ·ä¼ éäºå½åä»»å¡çframetimeï¼è¿æ ·åå¯ä»¥åå°æ¥å£ï¼ä½æ¯ç¨æ·ç©ºé´è¦å¤è®¾ç½®ä¸ä¸ªç©ºçframetimeå¼ï¼
+				*å¯¹äºå½åtaskçframetimeï¼ä¹å¯ä»¥ç¨é¢å¤çæ¥å£è·åï¼ä½æ¯è¿æ ·åï¼frametimeåtotal_timeå°±å¤äºä¸åæ¥å£ä¸­ãå¥½å¤ï¼ï¼ï¼
+				*/
+	            if(copy_from_user(&task_info, (void __user*)arg, sizeof(struct cedarv_engine_task_info))){
+					printk("IOCTL_ENGINE_CHECK_DELAY copy_from_user fail\n");
+					return -EFAULT;
+				}
+				task_info.total_time = cedardev_check_delay(task_info.task_prio);//task_info.task_prioæ¯ä¼ éè¿æ¥çä¼åçº§
+				#ifdef CEDAR_DEBUG
+				printk("%s,%d,%d\n", __func__, __LINE__, task_info.total_time);
+				#endif
+				task_info.frametime = 0;
+				spin_lock_irqsave(&cedar_spin_lock, flags);
+				if(!list_empty(&run_task_list)){
+					/*è·årun_task_listé¾è¡¨ä¸­çç¬¬ä¸ä¸ªä»»å¡ï¼ä¹å°±æ¯å½åè¿è¡çä»»å¡ï¼éè¿å½åè¿è¡çä»»å¡è·åframetimeæ¶é´*/
+					struct cedarv_engine_task *task_entry;
+					#ifdef CEDAR_DEBUG
+					printk("%s,%d\n",__func__,__LINE__);
+					#endif
+					task_entry = list_entry(run_task_list.next, struct cedarv_engine_task, list);
+					if(task_entry->running == 1)
+						task_info.frametime = task_entry->t.frametime;
+					#ifdef CEDAR_DEBUG
+					printk("%s,%d,%d\n",__func__,__LINE__,task_info.frametime);
+					#endif
+				}
+				spin_unlock_irqrestore(&cedar_spin_lock, flags);
+				/*
+				*å°ä»»å¡ä¼åçº§ï¼total_time,frametimeæ·è´å°ç¨æ·ç©ºé´ãä»»å¡ä¼åçº§è¿æ¯ç¨æ·è®¾ç½®çå¼ï¼total_timeæ¯éè¦ç­å¾çæ»æ¶é´ï¼
+				*frametimeæ¯å½åä»»å¡çè¿è¡æ¶é´.å¶å®å½åä»»å¡çä¿¡æ¯æå¥½ç¨å¦ä¸ä¸ªæ¥å£å®ç°.åå°è¦ååº¦åæ¥å£çæå±æ§.
+				*/
+				if (copy_to_user((void *)arg, &task_info, sizeof(struct cedarv_engine_task_info))){
+	            	printk("IOCTL_ENGINE_CHECK_DELAY copy_to_user fail\n");
+	                return -EFAULT;
+	            }
+        	}
+			break;
+        case IOCTL_WAIT_VE:
+            //wait_event_interruptible(wait_ve, cedar_devp->irq_flag);
+            ve_timeout = (int)arg;
+            cedar_devp->irq_value = 0;
+
+            spin_lock_irqsave(&cedar_spin_lock, flags);
+            if(cedar_devp->irq_flag)
+            	cedar_devp->irq_value = 1;
+            spin_unlock_irqrestore(&cedar_spin_lock, flags);
+
+            wait_event_interruptible_timeout(wait_ve, cedar_devp->irq_flag, ve_timeout*HZ);
+            //printk("%s,%d,ve_timeout:%d,cedar_devp->irq_value:%d\n", __func__, __LINE__, ve_timeout, cedar_devp->irq_value);
+	        cedar_devp->irq_flag = 0;
+	        /*è¿å1ï¼è¡¨ç¤ºä¸­æ­è¿åï¼è¿å0ï¼è¡¨ç¤ºtimeoutè¿å*/
+			return cedar_devp->irq_value;
+
+		case IOCTL_ENABLE_VE:
+            clk_enable(ve_moduleclk);
+			break;
+
+		case IOCTL_DISABLE_VE:
+			clk_disable(ve_moduleclk);
+			break;
+
+		case IOCTL_RESET_VE:
+            clk_disable(dram_veclk);
+            clk_reset(ve_moduleclk, 1);
+            clk_reset(ve_moduleclk, 0);
+            clk_enable(dram_veclk);
+		break;
+
+		case IOCTL_SET_VE_FREQ:
+			{
+				int arg_rate = (int)arg;
+				if(arg_rate >= 320){
+					clk_set_rate(ve_moduleclk, pll4clk_rate/3);//ve_moduleclk rate is 320khz
+				}else if((arg_rate >= 240) && (arg_rate < 320)){
+					clk_set_rate(ve_moduleclk, pll4clk_rate/4);//ve_moduleclk rate is 240khz
+				}else if((arg_rate >= 160) && (arg_rate < 240)){
+					clk_set_rate(ve_moduleclk, pll4clk_rate/6);//ve_moduleclk rate is 160khz
+				}else{
+					printk("IOCTL_SET_VE_FREQ set ve freq error,%s,%d\n", __func__, __LINE__);
+				}
+				break;
+			}
+        case IOCTL_GETVALUE_AVS2:
+			/* Return AVS1 counter value */
+            return readl(cedar_devp->iomap_addrs.regs_avs + 0x88);
+
+        case IOCTL_ADJUST_AVS2:
+        {
+            int arg_s = (int)arg;
+            int temp;
+            if (SUNXI_VER_A10A == sw_get_ic_ver()) {
+	            save_context();
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            temp = v & 0xffff0000;
+	            temp =temp + temp*arg_s/100;
+				temp = temp > (244<<16) ? (244<<16) : temp;
+				temp = temp < (234<<16) ? (234<<16) : temp;
+	            v = (temp & 0xffff0000) | (v&0x0000ffff);
+	            #ifdef CEDAR_DEBUG
+	            printk("Kernel AVS ADJUST Print: 0x%x\n", v);
+	            #endif
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            restore_context();
+	        } else if (SUNXI_VER_A10B == sw_get_ic_ver() ||
+			   SUNXI_VER_A10C == sw_get_ic_ver()) {
+				v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            temp = v & 0xffff0000;
+	            temp =temp + temp*arg_s/100;
+				temp = temp > (244<<16) ? (244<<16) : temp;
+				temp = temp < (234<<16) ? (234<<16) : temp;
+	            v = (temp & 0xffff0000) | (v&0x0000ffff);
+	            #ifdef CEDAR_DEBUG
+	            printk("Kernel AVS ADJUST Print: 0x%x\n", v);
+	            #endif
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	        }else{
+	        	printk("IOCTL_ADJUST_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+	        }
+            break;
+        }
+
+        case IOCTL_ADJUST_AVS2_ABS:
+        {
+            int arg_s = (int)arg;
+            int v_dst;
+
+            switch(arg_s){
+            case -2:
+            	v_dst = 234;
+            	break;
+            case -1:
+            	v_dst = 236;
+            	break;
+            case 1:
+            	v_dst = 242;
+            	break;
+            case 2:
+            	v_dst = 244;
+            	break;
+            default:
+            	v_dst = 239;
+            	break;
+            }
+
+            if (SUNXI_VER_A10A == sw_get_ic_ver()) {
+	            save_context();
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            v = (v_dst<<16)  | (v&0x0000ffff);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            restore_context();
+	        } else if (SUNXI_VER_A10B == sw_get_ic_ver() ||
+			   SUNXI_VER_A10C == sw_get_ic_ver()) {
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            v = (v_dst<<16)  | (v&0x0000ffff);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	        }else{
+	        	printk("IOCTL_ADJUST_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+	        }
+            break;
+        }
+
+        case IOCTL_CONFIG_AVS2:
+		if (SUNXI_VER_A10A == sw_get_ic_ver()) {
+	        	save_context();
+				/* Set AVS counter divisor */
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            v = 239 << 16 | (v & 0xffff);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+
+				/* Enable AVS_CNT1 and Pause it */
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v |= 1 << 9 | 1 << 1;
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+
+				/* Set AVS_CNT1 init value as zero  */
+	            writel(0, cedar_devp->iomap_addrs.regs_avs + 0x88);
+				restore_context();
+		} else if (SUNXI_VER_A10B == sw_get_ic_ver() || SUNXI_VER_A10C == sw_get_ic_ver()) {
+				/* Set AVS counter divisor */
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            v = 239 << 16 | (v & 0xffff);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+
+				/* Enable AVS_CNT1 and Pause it */
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v |= 1 << 9 | 1 << 1;
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+
+				/* Set AVS_CNT1 init value as zero  */
+	            writel(0, cedar_devp->iomap_addrs.regs_avs + 0x88);
+        	}else{
+        		printk("IOCTL_CONFIG_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+            break;
+
+        case IOCTL_RESET_AVS2:
+            /* Set AVS_CNT1 init value as zero */
+            if (SUNXI_VER_A10A == sw_get_ic_ver()) {
+	        	save_context();
+	            writel(0, cedar_devp->iomap_addrs.regs_avs + 0x88);
+	            restore_context();
+		} else if (SUNXI_VER_A10B == sw_get_ic_ver() ||
+			   SUNXI_VER_A10C == sw_get_ic_ver()) {
+        		writel(0, cedar_devp->iomap_addrs.regs_avs + 0x88);
+        	}else{
+        		printk("IOCTL_RESET_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+            break;
+
+        case IOCTL_PAUSE_AVS2:
+            /* Pause AVS_CNT1 */
+            if (SUNXI_VER_A10A == sw_get_ic_ver()) {
+	        	save_context();
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v |= 1 << 9;
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            restore_context();
+		} else if (SUNXI_VER_A10B == sw_get_ic_ver() ||
+			   SUNXI_VER_A10C == sw_get_ic_ver()) {
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v |= 1 << 9;
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+        	}else{
+        		printk("IOCTL_PAUSE_AVS2 get error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+            break;
+
+        case IOCTL_START_AVS2:
+        	/* Start AVS_CNT1 : do not pause */
+		if (SUNXI_VER_A10A == sw_get_ic_ver()) {
+	        	save_context();
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v &= ~(1 << 9);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            restore_context();
+		} else if (SUNXI_VER_A10B == sw_get_ic_ver() ||
+			   SUNXI_VER_A10C == sw_get_ic_ver()) {
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v &= ~(1 << 9);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+        	}else{
+        		printk("IOCTL_START_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+            break;
+
+        case IOCTL_GET_ENV_INFO:
+        {
+            struct cedarv_env_infomation env_info;
+            env_info.phymem_start = (unsigned int)phys_to_virt(ve_start);
+            env_info.phymem_total_size = ve_size;
+	        env_info.address_macc = (unsigned int)cedar_devp->iomap_addrs.regs_macc;
+            if (copy_to_user((char *)arg, &env_info, sizeof(struct cedarv_env_infomation)))
+                return -EFAULT;
+        }
+        break;
+        case IOCTL_GET_IC_VER:
+        {
+		if (SUNXI_VER_A10A == sw_get_ic_ver()) {
+        		return 0x0A10000A;
+		} else if (SUNXI_VER_A10B == sw_get_ic_ver() ||
+			   SUNXI_VER_A10C == sw_get_ic_ver()) {
+        		return 0x0A10000B;
+        	}else{
+        		printk("IC_VER get error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+        }
+        case IOCTL_FLUSH_CACHE:
+        {
+        	struct cedarv_cache_range cache_range;
+    		if(copy_from_user(&cache_range, (void __user*)arg, sizeof(struct cedarv_cache_range))){
+				printk("IOCTL_FLUSH_CACHE copy_from_user fail\n");
+				return -EFAULT;
+			}
+			flush_clean_user_range(cache_range.start, cache_range.end);
+        }
+        break;
+        default:
+        break;
+    }
+    return ret;
+}
+
+static int cedardev_open(struct inode *inode, struct file *filp)
+{
+	struct cedar_dev *devp;
+	devp = container_of(inode->i_cdev, struct cedar_dev, cdev);
+	filp->private_data = devp;
+	if (down_interruptible(&devp->sem)) {
+		return -ERESTARTSYS;
+	}
+	/* init other resource here */
+    devp->irq_flag = 0;
+	up(&devp->sem);
+	nonseekable_open(inode, filp);
+	return 0;
+}
+
+static int cedardev_release(struct inode *inode, struct file *filp)
+{
+	struct cedar_dev *devp;
+
+	devp = filp->private_data;
+	if (down_interruptible(&devp->sem)) {
+		return -ERESTARTSYS;
+	}
+	/* release other resource here */
+    devp->irq_flag = 1;
+	up(&devp->sem);
+	return 0;
+}
+
+void cedardev_vma_open(struct vm_area_struct *vma)
+{
+}
+
+void cedardev_vma_close(struct vm_area_struct *vma)
+{
+}
+
+static struct vm_operations_struct cedardev_remap_vm_ops = {
+    .open  = cedardev_vma_open,
+    .close = cedardev_vma_close,
+};
+
+static int cedardev_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long temp_pfn;
+    unsigned int  VAddr;
+	struct iomap_para addrs;
+
+	unsigned int io_ram = 0;
+    VAddr = vma->vm_pgoff << 12;
+	addrs = cedar_devp->iomap_addrs;
+
+    if (VAddr == (unsigned int)addrs.regs_macc) {
+        temp_pfn = MACC_REGS_BASE >> 12;
+        io_ram = 1;
+    } else {
+        temp_pfn = (__pa(vma->vm_pgoff << 12))>>12;
+        io_ram = 0;
+    }
+
+    if (io_ram == 0) {
+        /* Set reserved and I/O flag for the area. */
+        vma->vm_flags |= VM_RESERVED | VM_IO;
+
+        /* Select uncached access. */
+        //vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                            vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+            return -EAGAIN;
+        }
+    } else {
+        /* Set reserved and I/O flag for the area. */
+        vma->vm_flags |= VM_RESERVED | VM_IO;
+        /* Select uncached access. */
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (io_remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                               vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+            return -EAGAIN;
+        }
+    }
+
+    vma->vm_ops = &cedardev_remap_vm_ops;
+    cedardev_vma_open(vma);
+
+    return 0;
+}
+
+static int snd_sw_cedar_suspend(struct platform_device *pdev,pm_message_t state)
+{
+	disable_cedar_hw_clk();
+
+	return 0;
+}
+
+static int snd_sw_cedar_resume(struct platform_device *pdev)
+{
+	if(cedar_devp->ref_count == 0){
+		return 0;
+	}
+	enable_cedar_hw_clk();
+
+	return 0;
+}
+
+static struct file_operations cedardev_fops = {
+    .owner   = THIS_MODULE,
+    .mmap    = cedardev_mmap,
+	.poll    = cedardev_poll,
+    .open    = cedardev_open,
+    .release = cedardev_release,
+	.llseek  = no_llseek,
+    .unlocked_ioctl   = cedardev_ioctl,
+};
+
+/*data relating*/
+static struct platform_device sw_device_cedar = {
+	.name = "sun4i-cedar",
+};
+
+/*method relating*/
+static struct platform_driver sw_cedar_driver = {
+#ifdef CONFIG_PM
+	.suspend	= snd_sw_cedar_suspend,
+	.resume		= snd_sw_cedar_resume,
+#endif
+	.driver		= {
+		.name	= "sun4i-cedar",
+	},
+};
+
+static int __init cedardev_init(void)
+{
+	int ret = 0;
+	int err = 0;
+	int devno;
+	unsigned int val;
+	dev_t dev = 0;
+
+	if (ve_size == 0)
+		return -ENODEV;
+
+	printk("[cedar dev]: install start!!!\n");
+	if((platform_device_register(&sw_device_cedar))<0)
+		return err;
+
+	if ((err = platform_driver_register(&sw_cedar_driver)) < 0)
+		return err;
+	/*register or alloc the device number.*/
+	if (g_dev_major) {
+		dev = MKDEV(g_dev_major, g_dev_minor);
+		ret = register_chrdev_region(dev, 1, "cedar_dev");
+	} else {
+		ret = alloc_chrdev_region(&dev, g_dev_minor, 1, "cedar_dev");
+		g_dev_major = MAJOR(dev);
+		g_dev_minor = MINOR(dev);
+	}
+
+	if (ret < 0) {
+		printk(KERN_WARNING "cedar_dev: can't get major %d\n", g_dev_major);
+		return ret;
+	}
+	spin_lock_init(&cedar_spin_lock);
+	cedar_devp = kmalloc(sizeof(struct cedar_dev), GFP_KERNEL);
+	if (cedar_devp == NULL) {
+		printk("malloc mem for cedar device err\n");
+		return -ENOMEM;
+	}
+	memset(cedar_devp, 0, sizeof(struct cedar_dev));
+	cedar_devp->irq = VE_IRQ_NO;
+
+	sema_init(&cedar_devp->sem, 1);
+	init_waitqueue_head(&cedar_devp->wq);
+
+	memset(&cedar_devp->iomap_addrs, 0, sizeof(struct iomap_para));
+
+    ret = request_irq(VE_IRQ_NO, VideoEngineInterupt, 0, "cedar_dev", NULL);
+    if (ret < 0) {
+        printk("request irq err\n");
+        return -EINVAL;
+    }
+	/* map for macc io space */
+    cedar_devp->iomap_addrs.regs_macc = ioremap(MACC_REGS_BASE, 4096);
+    if (!cedar_devp->iomap_addrs.regs_macc){
+        printk("cannot map region for macc");
+    }
+    cedar_devp->iomap_addrs.regs_avs = ioremap(AVS_REGS_BASE, 1024);
+
+	//VE_SRAM mapping to AC320
+	val = readl(0xf1c00000);
+	val &= 0x80000000;
+	writel(val,0xf1c00000);
+	//remapping SRAM to MACC for codec test
+	val = readl(0xf1c00000);
+	val |= 0x7fffffff;
+	writel(val,0xf1c00000);
+
+	ve_pll4clk = clk_get(NULL,"ve_pll");
+	pll4clk_rate = clk_get_rate(ve_pll4clk);
+	/* getting ahb clk for ve!(macc) */
+	ahb_veclk = clk_get(NULL,"ahb_ve");
+	ve_moduleclk = clk_get(NULL,"ve");
+	if(clk_set_parent(ve_moduleclk, ve_pll4clk)){
+		printk("set parent of ve_moduleclk to ve_pll4clk failed!\n");
+		return -EFAULT;
+	}
+	/*default the ve freq to 160M by lys 2011-12-23 15:25:34*/
+	clk_set_rate(ve_moduleclk, pll4clk_rate/6);
+	/*geting dram clk for ve!*/
+	dram_veclk = clk_get(NULL, "sdram_ve");
+	hosc_clk = clk_get(NULL,"hosc");
+	avs_moduleclk = clk_get(NULL,"avs");
+	if(clk_set_parent(avs_moduleclk, hosc_clk)){
+		printk("set parent of avs_moduleclk to hosc_clk failed!\n");
+		return -EFAULT;
+	}
+
+	/*for clk test*/
+	#ifdef CEDAR_DEBUG
+	printk("PLL4 CLK:0xf1c20018 is:%x\n", *(volatile int *)0xf1c20018);
+	printk("AHB CLK:0xf1c20064 is:%x\n", *(volatile int *)0xf1c20064);
+	printk("VE CLK:0xf1c2013c is:%x\n", *(volatile int *)0xf1c2013c);
+	printk("SDRAM CLK:0xf1c20100 is:%x\n", *(volatile int *)0xf1c20100);
+	printk("SRAM:0xf1c00000 is:%x\n", *(volatile int *)0xf1c00000);
+	#endif
+	/* Create char device */
+	devno = MKDEV(g_dev_major, g_dev_minor);
+	cdev_init(&cedar_devp->cdev, &cedardev_fops);
+	cedar_devp->cdev.owner = THIS_MODULE;
+	cedar_devp->cdev.ops = &cedardev_fops;
+	ret = cdev_add(&cedar_devp->cdev, devno, 1);
+	if (ret) {
+		printk(KERN_NOTICE "Err:%d add cedardev", ret);
+	}
+    cedar_devp->class = class_create(THIS_MODULE, "cedar_dev");
+    cedar_devp->dev   = device_create(cedar_devp->class, NULL, devno, NULL, "cedar_dev");
+	/*å¨cedar drvåå§åçæ¶åï¼åå§åå®æ¶å¨å¹¶è®¾ç½®å®çæå
+	* å¨æä»»å¡æå¥run_task_listçæ¶åï¼å¯å¨å®æ¶å¨ï¼å¹¶è®¾ç½®å®æ¶å¨çæ¶éä¸ºå½åç³»ç»çjiffiesï¼åècedardev_insert_task
+	*/
+    setup_timer(&cedar_devp->cedar_engine_timer, cedar_engine_for_events, (unsigned long)cedar_devp);
+	setup_timer(&cedar_devp->cedar_engine_timer_rel, cedar_engine_for_timer_rel, (unsigned long)cedar_devp);
+	printk("[cedar dev]: install end!!!\n");
+	return 0;
+}
+module_init(cedardev_init);
+
+static void __exit cedardev_exit(void)
+{
+	dev_t dev;
+	dev = MKDEV(g_dev_major, g_dev_minor);
+
+    free_irq(VE_IRQ_NO, NULL);
+	iounmap(cedar_devp->iomap_addrs.regs_macc);
+	iounmap(cedar_devp->iomap_addrs.regs_avs);
+	/* Destroy char device */
+	if(cedar_devp){
+		cdev_del(&cedar_devp->cdev);
+		device_destroy(cedar_devp->class, dev);
+		class_destroy(cedar_devp->class);
+	}
+	clk_disable(dram_veclk);
+	clk_put(dram_veclk);
+
+	clk_disable(ve_moduleclk);
+	clk_put(ve_moduleclk);
+
+	clk_disable(ahb_veclk);
+	clk_put(ahb_veclk);
+
+	clk_put(ve_pll4clk);
+
+	clk_disable(avs_moduleclk);
+	clk_put(avs_moduleclk);
+
+	unregister_chrdev_region(dev, 1);
+  	platform_driver_unregister(&sw_cedar_driver);
+	if (cedar_devp) {
+		kfree(cedar_devp);
+	}
+}
+module_exit(cedardev_exit);
+
+MODULE_AUTHOR("Soft-Allwinner");
+MODULE_DESCRIPTION("User mode CEDAR device interface");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/media/video/sun4i/sun4i_cedar.h b/drivers/media/video/sun4i/sun4i_cedar.h
new file mode 100644
index 0000000..c7296a2
--- /dev/null
+++ b/drivers/media/video/sun4i/sun4i_cedar.h
@@ -0,0 +1,133 @@
+/*
+ * drivers/media/video/sun4i/sun4i_cedar.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+**************************************************************************************************************
+*											         eLDK
+*						            the Easy Portable/Player Develop Kits
+*									           desktop system
+*
+*						        	 (c) Copyright 2009-2012, ,HUANGXIN China
+*											 All Rights Reserved
+*
+* File    	: sun4i_cedar.h
+* By      	: HUANGXIN
+* Func		:
+* Version	: v1.0
+* ============================================================================================================
+* 2011-5-25 9:57:05  HUANGXIN create this file, implements the fundemental interface;
+**************************************************************************************************************
+*/
+#ifndef _SUN4I_CEDAR_H_
+#define _SUN4I_CEDAR_H_
+
+enum IOCTL_CMD {
+	IOCTL_UNKOWN = 0x100,
+	IOCTL_GET_ENV_INFO,
+	IOCTL_WAIT_VE,
+	IOCTL_RESET_VE,
+	IOCTL_ENABLE_VE,
+	IOCTL_DISABLE_VE,
+	IOCTL_SET_VE_FREQ,
+
+	IOCTL_CONFIG_AVS2 = 0x200,
+	IOCTL_GETVALUE_AVS2 ,
+	IOCTL_PAUSE_AVS2 ,
+	IOCTL_START_AVS2 ,
+	IOCTL_RESET_AVS2 ,
+	IOCTL_ADJUST_AVS2,
+	IOCTL_ENGINE_REQ,
+	IOCTL_ENGINE_REL,
+	IOCTL_ENGINE_CHECK_DELAY,
+	IOCTL_GET_IC_VER,
+
+	IOCTL_ADJUST_AVS2_ABS,
+	IOCTL_FLUSH_CACHE,
+};
+
+struct cedarv_env_infomation{
+	unsigned int phymem_start;
+	int  phymem_total_size;
+	unsigned int  address_macc;
+};
+
+struct cedarv_cache_range{
+	long start;
+	long end;
+};
+
+struct __cedarv_task {
+	int task_prio;
+	int ID;
+	unsigned long timeout;
+	unsigned int frametime;
+	unsigned int block_mode;
+};
+
+struct cedarv_engine_task {
+	struct __cedarv_task t;
+	struct list_head list;
+	struct task_struct *task_handle;
+	unsigned int status;
+	unsigned int running;
+	unsigned int is_first_task;
+};
+
+/*å©ç¨ä¼åçº§task_prioæ¥è¯¢å½åè¿è¡taskçframetimeï¼åæ¯ä¼åçº§task_prioé«çtaskå¯è½è¿è¡çæ»æ¶é´total_time*/
+struct cedarv_engine_task_info {
+	int task_prio;
+	unsigned int frametime;
+	unsigned int total_time;
+};
+
+/*--------------------------------------------------------------------------------*/
+#define REGS_pBASE			(0x01C00000)	 	      // register base addr
+
+#define SRAM_REGS_pBASE     (REGS_pBASE + 0x00000)    // SRAM Controller
+#define CCMU_REGS_pBASE     (REGS_pBASE + 0x20000)    // clock manager unit
+#define MACC_REGS_pBASE     (REGS_pBASE + 0x0E000)    // media accelerate VE
+#define SS_REGS_pBASE       (REGS_pBASE + 0x15000)    // Security System
+#define SDRAM_REGS_pBASE    (REGS_pBASE + 0x01000)    // SDRAM Controller
+#define AVS_REGS_pBASE      (REGS_pBASE + 0x20c00)
+
+#define SRAM_REGS_BASE      SRAM_REGS_pBASE           // SRAM Controller
+#define CCMU_REGS_BASE      CCMU_REGS_pBASE           // Clock Control manager unit  OK
+#define MACC_REGS_BASE      MACC_REGS_pBASE           // Media ACCelerate
+#define SS_REGS_BASE        SS_REGS_pBASE             // Security System
+#define SDRAM_REGS_BASE		SDRAM_REGS_pBASE          //SDRAM Controller   OK
+#define AVS_REGS_BASE       AVS_REGS_pBASE
+
+#define MPEG_REGS_BASE      (MACC_REGS_BASE + 0x100)  // MPEG engine
+#define H264_REGS_BASE      (MACC_REGS_BASE + 0x200)  // H264 engine
+#define VC1_REGS_BASE       (MACC_REGS_BASE + 0x300)  // VC-1 engine
+
+#define SRAM_REGS_SIZE      (4096)  // 4K
+#define CCMU_REGS_SIZE      (1024)  // 1K
+#define MACC_REGS_SIZE      (4096)  // 4K
+#define SS_REGS_SIZE        (4096)  // 4K
+/*--------------------------------------------------------------------------------*/
+
+#define SRAM_REG_o_CFG	    (0x00)
+#define SRAM_REG_ADDR_CFG   (SRAM_REGS_BASE + SRAM_REG_o_CFG) // SRAM MAP Cfg Reg 0
+/*--------------------------------------------------------------------------------*/
+
+#endif
diff --git a/drivers/media/video/sun4i_csi/Kconfig b/drivers/media/video/sun4i_csi/Kconfig
new file mode 100644
index 0000000..e5a4d64
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/Kconfig
@@ -0,0 +1,110 @@
+config CSI_DEV_SEL
+	tristate
+
+config CSI0_SUN4I
+	tristate "CSI0 v4l2 driver for sun4i"
+	default m
+	depends on CSI_DEV_SEL&&I2C && VIDEO_DEV && VIDEO_V4L2
+	select VIDEOBUF_DMA_CONTIG
+
+config CSI1_SUN4I
+	tristate "CSI1 v4l2 driver for sun4i"
+	default m
+	depends on CSI_DEV_SEL&&I2C && VIDEO_DEV && VIDEO_V4L2
+	select VIDEOBUF_DMA_CONTIG
+
+config CSI_OV7670
+	tristate "OmniVision OV7670 sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV7670 VGA camera.
+
+config CSI_GT2005
+	tristate "GalaxyCore GT2005 2M sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the GalaxyCore
+	  GT2005 2M camera.
+
+config CSI_GC0308
+	tristate "GalaxyCore GC0308 VGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the GalaxyCore
+	  GC0308 VGA camera.
+
+config CSI_HI704
+	tristate "HYNIX HI704 VGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Hynix
+	  HI704 VGA camera.
+
+config CSI_SP0838
+	tristate "Superpix SP0838 VGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Superpix
+	  SP0838 VGA camera.
+
+config CSI_MT9M112
+	tristate "Micron MT9M112 UXGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Micron
+	  MT9M112 UXGA camera.
+
+config CSI_MT9M113
+	tristate "Micron MT9M113 SXGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Micron
+	  MT9M113 SXGA camera.
+
+config CSI_OV2655
+	tristate "OmniVision OV2655 UXGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the MOmniVision
+	  OV2655 UXGA camera.
+
+config CSI_HI253
+	tristate "Hynix HI253 UXGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Hynix
+	  HI253 UXGA camera.
+
+config CSI_MT9D112
+	tristate "Micron MT9D112 UXGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Micron
+	  MT9D112 UXGA camera.
+
+config CSI_GC0307
+	tristate "GalaxyCore GC0307 VGA sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the GalaxyCore
+	  GC0307 VGA camera.
+
+config CSI_OV5640
+	tristate "OmniVision OV5640 5M sensor support"
+	depends on I2C && VIDEO_V4L2
+	select	CSI_DEV_SEL
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5640 5M camera.
\ No newline at end of file
diff --git a/drivers/media/video/sun4i_csi/csi0/Makefile b/drivers/media/video/sun4i_csi/csi0/Makefile
new file mode 100644
index 0000000..1d77172
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi0/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_CSI0_SUN4I) += sun4i_csi0.o
+
+sun4i_csi0-objs := sun4i_csi_reg.o sun4i_drv_csi.o
+
+
+
+
diff --git a/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c b/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c
new file mode 100644
index 0000000..e48f108
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c
@@ -0,0 +1,180 @@
+/*
+ * drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Sun4i Camera register read/write interface
+ * Author:raymonxiu
+*/
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include "../include/sun4i_csi_core.h"
+#include "sun4i_csi_reg.h"
+
+/* open module */
+void bsp_csi_open(struct csi_dev *dev)
+{
+	W(dev->regs+CSI_REG_EN, 0x1);
+}
+
+void bsp_csi_close(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_EN, 0X1 << 0);
+}
+
+/* configure */
+void bsp_csi_configure(struct csi_dev *dev,__csi_conf_t *mode)
+{
+	u32 t;
+	W(dev->regs+CSI_REG_CONF, mode->input_fmt << 20 | /* [21:20] */
+							  mode->output_fmt<< 16 | /* [18:16] */
+							  mode->field_sel << 10 | /* [11:10] */
+							  mode->seq       << 8  | /* [9:8] */
+							  mode->vref      << 2  | /* [2] */
+							  mode->href      << 1  | /* [1] */
+							  mode->clock     << 0    /* [0] */
+      );
+
+  t = R(dev->regs+CSI_REG_CONF);
+
+}
+
+/* buffer */
+u32 static inline bsp_csi_get_buffer_address(struct csi_dev *dev,__csi_buf_t buf)
+{
+	u32 t;
+	t = R(dev->regs+CSI_REG_BUF_0_A + (buf<<2));
+	return t;
+}
+
+void bsp_csi_double_buffer_enable(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_BUF_CTRL, 0X1<<0);
+}
+
+void bsp_csi_double_buffer_disable(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_BUF_CTRL, 0X1<<0);
+}
+
+void static inline bsp_csi_double_buffer_select_next(struct csi_dev *dev,__csi_double_buf_t type)
+{
+    if (CSI_BUF_A == type) {
+        C(dev->regs+CSI_REG_BUF_CTRL, 0x1<<2);
+	} else {
+        S(dev->regs+CSI_REG_BUF_CTRL, 0x1<<2);
+	}
+}
+
+void static inline bsp_csi_double_buffer_get_status(struct csi_dev *dev,__csi_double_buf_status_t * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_BUF_CTRL);
+    status->enable = t&0x1;
+    status->cur  = (__csi_double_buf_t)(t&(0x1<<1));
+    status->next = (__csi_double_buf_t)(t&(0x1<<2));
+
+}
+
+/* capture */
+void bsp_csi_capture_video_start(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_CTRL, 0X1<<1);
+}
+
+void bsp_csi_capture_video_stop(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_CTRL, 0X1<<1);
+}
+
+void bsp_csi_capture_picture(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_CTRL, 0X1<<0);
+}
+
+void bsp_csi_capture_get_status(struct csi_dev *dev,__csi_capture_status * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_STATUS);
+    status->picture_in_progress = t&0x1;
+    status->video_in_progress   = (t>>1)&0x1;
+}
+
+/* size */
+void bsp_csi_set_size(struct csi_dev *dev, u32 length_h, u32 length_v, u32 buf_length_h)
+{
+	/* make sure yuv422 input 2 byte(clock) output 1 pixel */
+		u32 t;
+
+		t = R(dev->regs+CSI_REG_RESIZE_H);
+		t = (t&0x0000ffff)|(length_h<<16);
+    W(dev->regs+CSI_REG_RESIZE_H, t);
+
+    t = R(dev->regs+CSI_REG_RESIZE_H);
+    t = (t&0x0000ffff)|(length_v<<16);
+    W(dev->regs+CSI_REG_RESIZE_V, t);
+
+    W(dev->regs+CSI_REG_BUF_LENGTH, buf_length_h);
+}
+
+
+/* offset */
+void bsp_csi_set_offset(struct csi_dev *dev,u32 start_h, u32 start_v)
+{
+    u32 t;
+
+    t = R(dev->regs+CSI_REG_RESIZE_H);
+    t = (t&0xffff0000)|start_h;
+    W(dev->regs+CSI_REG_RESIZE_H, t);
+
+    t = R(dev->regs+CSI_REG_RESIZE_V);
+    t = (t&0xffff0000)|start_v;
+    W(dev->regs+CSI_REG_RESIZE_V, t);
+}
+
+
+/* interrupt */
+void bsp_csi_int_enable(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    S(dev->regs+CSI_REG_INT_EN, interrupt);
+}
+
+void bsp_csi_int_disable(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    C(dev->regs+CSI_REG_INT_EN, interrupt);
+}
+
+void static inline bsp_csi_int_get_status(struct csi_dev *dev,__csi_int_status_t * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_INT_STATUS);
+
+    status->capture_done     = t&CSI_INT_CAPTURE_DONE;
+    status->frame_done       = t&CSI_INT_FRAME_DONE;
+    status->buf_0_overflow   = t&CSI_INT_BUF_0_OVERFLOW;
+    status->buf_1_overflow   = t&CSI_INT_BUF_1_OVERFLOW;
+    status->buf_2_overflow   = t&CSI_INT_BUF_2_OVERFLOW;
+    status->protection_error = t&CSI_INT_PROTECTION_ERROR;
+    status->hblank_overflow  = t&CSI_INT_HBLANK_OVERFLOW;
+    status->vsync_trig		 = t&CSI_INT_VSYNC_TRIG;
+
+}
diff --git a/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h b/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h
new file mode 100644
index 0000000..c00296a
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h
@@ -0,0 +1,58 @@
+/*
+ * drivers/media/video/sun4i_csi/csi0/sun4i_csi_reg.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Sun4i Camera register define
+ * Author:raymonxiu
+*/
+#ifndef _SUN4I_CSI_REG_H_
+#define _SUN4I_CSI_REG_H_
+
+#define  W(addr, val)   writel(val, addr)
+#define  R(addr)        readl(addr)
+#define  S(addr,bit)	writel(readl(addr)|bit,addr)
+#define  C(addr,bit)	writel(readl(addr)&(~bit),addr)
+
+#define CSI0_REGS_BASE        0x01c09000
+#define CSI1_REGS_BASE        0X01c1D000
+#define CSI0_REG_SIZE 				0x1000
+#define CSI1_REG_SIZE 				0x1000
+
+#define CSI_REG_EN           (0x00)
+#define CSI_REG_CONF         (0x04)
+#define CSI_REG_CTRL         (0x08)
+#define CSI_REG_SCALE        (0x0C)
+#define CSI_REG_BUF_0_A      (0x10)
+#define CSI_REG_BUF_0_B      (0x14)
+#define CSI_REG_BUF_1_A      (0x18)
+#define CSI_REG_BUF_1_B      (0x1C)
+#define CSI_REG_BUF_2_A      (0x20)
+#define CSI_REG_BUF_2_B      (0x24)
+#define CSI_REG_BUF_CTRL     (0x28)
+#define CSI_REG_STATUS       (0x2C)
+#define CSI_REG_INT_EN       (0x30)
+#define CSI_REG_INT_STATUS   (0x34)
+#define CSI_REG_RESIZE_H     (0x40)
+#define CSI_REG_RESIZE_V     (0x44)
+#define CSI_REG_BUF_LENGTH   (0x48)
+
+#endif  /* _CSI_H_ */
diff --git a/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c b/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
new file mode 100644
index 0000000..baf22a9
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
@@ -0,0 +1,2212 @@
+/*
+ * drivers/media/video/sun4i_csi/csi0/sun4i_drv_csi.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Sun4i Camera Interface  driver
+ * Author: raymonxiu
+ */
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+#include <linux/freezer.h>
+#endif
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-common.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf-dma-contig.h>
+#include <linux/moduleparam.h>
+
+#include <plat/sys_config.h>
+#include <mach/clock.h>
+#include <mach/irqs.h>
+#include <linux/regulator/consumer.h>
+
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+#include "sun4i_csi_reg.h"
+
+#define CSI_MAJOR_VERSION 1
+#define CSI_MINOR_VERSION 0
+#define CSI_RELEASE 0
+#define CSI_VERSION \
+	KERNEL_VERSION(CSI_MAJOR_VERSION, CSI_MINOR_VERSION, CSI_RELEASE)
+#define CSI_MODULE_NAME "sun4i_csi"
+
+//#define USE_DMA_CONTIG
+
+//#define AJUST_DRAM_PRIORITY
+#define REGS_pBASE					(0x01C00000)	 	      // register base addr
+#define SDRAM_REGS_pBASE    (REGS_pBASE + 0x01000)    // SDRAM Controller
+
+#define NUM_INPUTS 2
+#define CSI_OUT_RATE      (24*1000*1000)
+#define CSI_ISP_RATE			(80*1000*1000)
+#define CSI_MAX_FRAME_MEM (32*1024*1024)
+//#define TWI_NO		 (1)
+
+#define MIN_WIDTH  (32)
+#define MIN_HEIGHT (32)
+#define MAX_WIDTH  (4096)
+#define MAX_HEIGHT (4096)
+
+static unsigned video_nr = 0;
+static unsigned first_flag = 0;
+
+
+static char ccm[I2C_NAME_SIZE] = "";
+static uint i2c_addr = 0xff;
+
+static char ccm_b[I2C_NAME_SIZE] = "";
+static uint i2c_addr_b = 0xff;
+
+
+static struct ccm_config ccm_cfg[NUM_INPUTS] = {
+	{
+		.i2c_addr = 0xff,
+	},
+	{
+		.i2c_addr = 0xff,
+	},
+};
+
+module_param_string(ccm, ccm, sizeof(ccm), S_IRUGO|S_IWUSR);
+module_param(i2c_addr,uint, S_IRUGO|S_IWUSR);
+module_param_string(ccm_b, ccm_b, sizeof(ccm_b), S_IRUGO|S_IWUSR);
+module_param(i2c_addr_b,uint, S_IRUGO|S_IWUSR);
+
+static struct i2c_board_info  dev_sensor[] =  {
+	{
+		//I2C_BOARD_INFO(ccm, i2c_addr),
+		.platform_data	= NULL,
+	},
+	{
+		//I2C_BOARD_INFO(ccm, i2c_addr),
+		.platform_data	= NULL,
+	},
+};
+
+//ccm support format
+static struct csi_fmt formats[] = {
+	{
+		.name     		= "planar YUV 422",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUV422P,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_PLANAR_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 3,
+	},
+	{
+		.name     		= "planar YUV 420",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUV420,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_PLANAR_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 3,
+	},
+	{
+		.name     		= "planar YUV 422 UV combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV16,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 420 UV combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV12,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 422 VU combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV61,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 420 VU combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV21,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "MB YUV420",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_HM12,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_MB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "RAW Bayer",
+		.ccm_fmt			= V4L2_MBUS_FMT_SBGGR8_1X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_SBGGR8,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 8,
+		.planes_cnt		= 1,
+	},
+//	{
+//		.name     		= "planar RGB242",
+//		.ccm_fmt			= V4L2_PIX_FMT_SBGGR8,
+//		.fourcc   		= V4L2_PIX_FMT_RGB32,		//can't find the appropriate format in V4L2 define,use this temporarily
+//		.input_fmt		= CSI_BAYER,
+//		.output_fmt		= CSI_PLANAR_RGB242,
+//		.depth    		= 8,
+//		.planes_cnt		= 3,
+//	},
+	{
+		.name     		= "YUV422 YUYV",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUYV,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 YVYU",
+		.ccm_fmt			= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YVYU,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 UYVY",
+		.ccm_fmt			= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_UYVY,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 VYUY",
+		.ccm_fmt			= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_VYUY,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+};
+
+static struct csi_fmt *get_format(struct v4l2_format *f)
+{
+	struct csi_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat) {
+			break;
+		}
+	}
+
+	if (k == ARRAY_SIZE(formats)) {
+		return NULL;
+	}
+
+	return &formats[k];
+};
+
+void static inline bsp_csi_set_buffer_address(struct csi_dev *dev,__csi_buf_t buf, u32 addr)
+{
+	//bufer0a +4 = buffer0b, bufer0a +8 = buffer1a
+    W(dev->regs+CSI_REG_BUF_0_A + (buf<<2), addr);
+}
+
+static inline void csi_set_addr(struct csi_dev *dev,struct csi_buffer *buffer)
+{
+
+	struct csi_buffer *buf = buffer;
+	dma_addr_t addr_org;
+
+	csi_dbg(3,"buf ptr=%p\n",buf);
+
+	addr_org = videobuf_to_dma_contig((struct videobuf_buffer *)buf);
+
+
+	if(dev->fmt->input_fmt==CSI_RAW){
+		dev->csi_buf_addr.y  = addr_org;
+		dev->csi_buf_addr.cb = addr_org;
+		dev->csi_buf_addr.cr = addr_org;
+
+	}else if(dev->fmt->input_fmt==CSI_BAYER){
+		//really rare here
+		dev->csi_buf_addr.cb = addr_org;//for G channel
+		dev->csi_buf_addr.y  = addr_org + dev->width*dev->height*1/2;//for B channel
+		dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*3/4;//for R channel
+
+	}else if(dev->fmt->input_fmt==CSI_CCIR656){
+	//TODO:
+
+	}else if(dev->fmt->input_fmt==CSI_YUV422){
+
+		switch (dev->fmt->output_fmt) {
+			case CSI_PLANAR_YUV422:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*3/2;
+				break;
+
+			case CSI_PLANAR_YUV420:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*5/4;
+				break;
+
+			case CSI_UV_CB_YUV422:
+			case CSI_UV_CB_YUV420:
+			case CSI_MB_YUV422:
+			case CSI_MB_YUV420:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height;
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	bsp_csi_set_buffer_address(dev, CSI_BUF_0_A, dev->csi_buf_addr.y);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_0_B, dev->csi_buf_addr.y);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_1_A, dev->csi_buf_addr.cb);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_1_B, dev->csi_buf_addr.cb);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_2_A, dev->csi_buf_addr.cr);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_2_B, dev->csi_buf_addr.cr);
+
+	csi_dbg(3,"csi_buf_addr_y=%x\n",  dev->csi_buf_addr.y);
+	csi_dbg(3,"csi_buf_addr_cb=%x\n", dev->csi_buf_addr.cb);
+	csi_dbg(3,"csi_buf_addr_cr=%x\n", dev->csi_buf_addr.cr);
+
+}
+
+static int csi_clk_get(struct csi_dev *dev)
+{
+	int ret;
+
+	dev->csi_ahb_clk=clk_get(NULL, "ahb_csi0");
+	if (dev->csi_ahb_clk == NULL) {
+       	csi_err("get csi0 ahb clk error!\n");
+		return -1;
+    }
+
+	if(dev->ccm_info->mclk==24000000 || dev->ccm_info->mclk==12000000)
+	{
+		dev->csi_clk_src=clk_get(NULL,"hosc");
+		if (dev->csi_clk_src == NULL) {
+       	csi_err("get csi0 hosc source clk error!\n");
+			return -1;
+    }
+  }
+  else
+  {
+		dev->csi_clk_src=clk_get(NULL,"video_pll1");
+		if (dev->csi_clk_src == NULL) {
+       	csi_err("get csi0 video pll1 source clk error!\n");
+			return -1;
+    }
+	}
+
+	dev->csi_module_clk=clk_get(NULL,"csi0");
+	if(dev->csi_module_clk == NULL) {
+       	csi_err("get csi0 module clk error!\n");
+		return -1;
+    }
+
+	ret = clk_set_parent(dev->csi_module_clk, dev->csi_clk_src);
+	if (ret == -1) {
+        csi_err(" csi set parent failed \n");
+	    return -1;
+    }
+
+	clk_put(dev->csi_clk_src);
+
+	ret = clk_set_rate(dev->csi_module_clk,dev->ccm_info->mclk);
+	if (ret == -1) {
+        csi_err("set csi0 module clock error\n");
+		return -1;
+   	}
+
+	dev->csi_isp_src_clk=clk_get(NULL,"video_pll0");
+	if (dev->csi_isp_src_clk == NULL) {
+       	csi_err("get csi_isp source clk error!\n");
+		return -1;
+    }
+
+  dev->csi_isp_clk=clk_get(NULL,"csi_isp");
+	if(dev->csi_isp_clk == NULL) {
+       	csi_err("get csi_isp clk error!\n");
+		return -1;
+    }
+
+	ret = clk_set_parent(dev->csi_isp_clk, dev->csi_isp_src_clk);
+	if (ret == -1) {
+        csi_err(" csi_isp set parent failed \n");
+	    return -1;
+    }
+
+	clk_put(dev->csi_isp_src_clk);
+
+  ret = clk_set_rate(dev->csi_isp_clk, CSI_ISP_RATE);
+	if (ret == -1) {
+        csi_err("set csi_isp clock error\n");
+		return -1;
+   	}
+
+	dev->csi_dram_clk = clk_get(NULL, "sdram_csi0");
+	if (dev->csi_dram_clk == NULL) {
+       	csi_err("get csi0 dram clk error!\n");
+		return -1;
+    }
+
+	return 0;
+}
+
+static int csi_clk_out_set(struct csi_dev *dev)
+{
+	int ret;
+	ret = clk_set_rate(dev->csi_module_clk, dev->ccm_info->mclk);
+	if (ret == -1) {
+		csi_err("set csi0 module clock error\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void csi_reset_enable(struct csi_dev *dev)
+{
+	clk_reset(dev->csi_module_clk, 1);
+}
+
+static void csi_reset_disable(struct csi_dev *dev)
+{
+	clk_reset(dev->csi_module_clk, 0);
+}
+
+static int csi_clk_enable(struct csi_dev *dev)
+{
+	clk_enable(dev->csi_ahb_clk);
+//	clk_enable(dev->csi_module_clk);
+	clk_enable(dev->csi_isp_clk);
+	clk_enable(dev->csi_dram_clk);
+
+	return 0;
+}
+
+static int csi_clk_disable(struct csi_dev *dev)
+{
+	clk_disable(dev->csi_ahb_clk);
+//	clk_disable(dev->csi_module_clk);
+	clk_disable(dev->csi_isp_clk);
+	clk_disable(dev->csi_dram_clk);
+
+	return 0;
+}
+
+static int csi_clk_release(struct csi_dev *dev)
+{
+	clk_put(dev->csi_ahb_clk);
+    dev->csi_ahb_clk = NULL;
+
+	clk_put(dev->csi_module_clk);
+    dev->csi_module_clk = NULL;
+
+	clk_put(dev->csi_dram_clk);
+    dev->csi_dram_clk = NULL;
+
+	return 0;
+}
+
+static int inline csi_is_generating(struct csi_dev *dev)
+{
+	return test_bit(0, &dev->generating);
+}
+
+static void inline csi_start_generating(struct csi_dev *dev)
+{
+	 set_bit(0, &dev->generating);
+	 return;
+}
+
+static void inline csi_stop_generating(struct csi_dev *dev)
+{
+	 first_flag = 0;
+	 clear_bit(0, &dev->generating);
+	 return;
+}
+
+static int update_ccm_info(struct csi_dev *dev , struct ccm_config *ccm_cfg)
+{
+   dev->sd = ccm_cfg->sd;
+   dev->ccm_info = &ccm_cfg->ccm_info;
+   dev->interface = ccm_cfg->interface;
+	 dev->vflip = ccm_cfg->vflip;
+	 dev->hflip = ccm_cfg->hflip;
+	 dev->flash_pol = ccm_cfg->flash_pol;
+	 dev->iovdd = ccm_cfg->iovdd;
+	 dev->avdd = ccm_cfg->avdd;
+	 dev->dvdd = ccm_cfg->dvdd;
+	 return v4l2_subdev_call(dev->sd,core,ioctl,CSI_SUBDEV_CMD_SET_INFO,dev->ccm_info);
+}
+
+void static inline bsp_csi_int_clear_status(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    W(dev->regs+CSI_REG_INT_STATUS, interrupt);
+}
+
+static irqreturn_t csi_isr(int irq, void *priv)
+{
+	struct csi_buffer *buf;
+	struct csi_dev *dev = (struct csi_dev *)priv;
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+//	__csi_int_status_t * status;
+
+	csi_dbg(3,"csi_isr\n");
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+
+	spin_lock(&dev->slock);
+
+	if (first_flag == 0) {
+		first_flag=1;
+		goto set_next_addr;
+	}
+
+	if (list_empty(&dma_q->active)) {
+		csi_err("No active queue to serve\n");
+		goto unlock;
+	}
+
+	buf = list_entry(dma_q->active.next,struct csi_buffer, vb.queue);
+	csi_dbg(3,"buf ptr=%p\n",buf);
+
+	/* Nobody is waiting on this buffer*/
+
+	if (!waitqueue_active(&buf->vb.done)) {
+		csi_dbg(1," Nobody is waiting on this buffer,buf = 0x%p\n",buf);
+	}
+
+	list_del(&buf->vb.queue);
+
+	do_gettimeofday(&buf->vb.ts);
+	buf->vb.field_count++;
+
+	dev->ms += jiffies_to_msecs(jiffies - dev->jiffies);
+	dev->jiffies = jiffies;
+
+	buf->vb.state = VIDEOBUF_DONE;
+	wake_up(&buf->vb.done);
+
+	//judge if the frame queue has been written to the last
+	if (list_empty(&dma_q->active)) {
+		csi_dbg(1,"No more free frame\n");
+		goto unlock;
+	}
+
+	if ((&dma_q->active) == dma_q->active.next->next) {
+		csi_dbg(1,"No more free frame on next time\n");
+		goto unlock;
+	}
+
+
+set_next_addr:
+	buf = list_entry(dma_q->active.next->next,struct csi_buffer, vb.queue);
+	csi_set_addr(dev,buf);
+
+unlock:
+	spin_unlock(&dev->slock);
+//	bsp_csi_int_get_status(dev, status);
+//	if((status->buf_0_overflow) || (status->buf_1_overflow) || (status->buf_2_overflow))
+//	{
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_0_OVERFLOW);
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_1_OVERFLOW);
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_2_OVERFLOW);
+//		csi_err("fifo overflow\n");
+//	}
+//
+//	if((status->hblank_overflow))
+//	{
+//		bsp_csi_int_clear_status(dev,CSI_INT_HBLANK_OVERFLOW);
+//		csi_err("hblank overflow\n");
+//	}
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_enable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Videobuf operations
+ */
+static int buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+	struct csi_dev *dev = vq->priv_data;
+
+	csi_dbg(1,"buffer_setup\n");
+
+	if(dev->fmt->input_fmt == CSI_RAW)
+	{
+		switch(dev->fmt->fourcc) {
+			case 	V4L2_PIX_FMT_YUYV:
+			case	V4L2_PIX_FMT_YVYU:
+			case	V4L2_PIX_FMT_UYVY:
+			case	V4L2_PIX_FMT_VYUY:
+				*size = dev->width * dev->height * 2;
+				break;
+			default:
+				*size = dev->width * dev->height;
+				break;
+		}
+	}
+	else if(dev->fmt->input_fmt == CSI_BAYER)
+	{
+		*size = dev->width * dev->height;
+	}
+	else if(dev->fmt->input_fmt == CSI_CCIR656)
+	{
+		//TODO
+	}
+	else if(dev->fmt->input_fmt == CSI_YUV422)
+	{
+		switch (dev->fmt->output_fmt) {
+			case 	CSI_PLANAR_YUV422:
+			case	CSI_UV_CB_YUV422:
+			case 	CSI_MB_YUV422:
+				*size = dev->width * dev->height * 2;
+				break;
+
+			case CSI_PLANAR_YUV420:
+			case CSI_UV_CB_YUV420:
+			case CSI_MB_YUV420:
+				*size = dev->width * dev->height * 3/2;
+				break;
+
+			default:
+				*size = dev->width * dev->height * 2;
+				break;
+		}
+	}
+	else
+	{
+		*size = dev->width * dev->height * 2;
+	}
+
+	dev->frame_size = *size;
+
+	if (*count < 3) {
+		*count = 3;
+		csi_err("buffer count is invalid, set to 3\n");
+	} else if(*count > 5) {
+		*count = 5;
+		csi_err("buffer count is invalid, set to 5\n");
+	}
+
+	while (*size * *count > CSI_MAX_FRAME_MEM) {
+		(*count)--;
+	}
+	csi_print("%s, buffer count=%d, size=%d\n", __func__,*count, *size);
+
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct csi_buffer *buf)
+{
+	csi_dbg(1,"%s, state: %i\n", __func__, buf->vb.state);
+
+#ifdef USE_DMA_CONTIG
+	videobuf_dma_contig_free(vq, &buf->vb);
+#endif
+
+	csi_dbg(1,"free_buffer: freed\n");
+
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+static int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+						  enum v4l2_field field)
+{
+	struct csi_dev *dev = vq->priv_data;
+	struct csi_buffer *buf = container_of(vb, struct csi_buffer, vb);
+	int rc;
+
+	csi_dbg(1,"buffer_prepare\n");
+
+	BUG_ON(NULL == dev->fmt);
+
+	if (dev->width  < MIN_WIDTH || dev->width  > MAX_WIDTH ||
+	    dev->height < MIN_HEIGHT || dev->height > MAX_HEIGHT) {
+		return -EINVAL;
+	}
+
+	buf->vb.size = dev->frame_size;
+
+	if (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size) {
+		return -EINVAL;
+	}
+
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = dev->fmt;
+	buf->vb.width  = dev->width;
+	buf->vb.height = dev->height;
+	buf->vb.field  = field;
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0) {
+			goto fail;
+		}
+	}
+
+	vb->boff= videobuf_to_dma_contig(vb);
+	buf->vb.state = VIDEOBUF_PREPARED;
+
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct csi_dev *dev = vq->priv_data;
+	struct csi_buffer *buf = container_of(vb, struct csi_buffer, vb);
+	struct csi_dmaqueue *vidq = &dev->vidq;
+
+	csi_dbg(1,"buffer_queue\n");
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+			   struct videobuf_buffer *vb)
+{
+	struct csi_buffer *buf  = container_of(vb, struct csi_buffer, vb);
+
+	csi_dbg(1,"buffer_release\n");
+
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops csi_video_qops = {
+	.buf_setup    = buffer_setup,
+	.buf_prepare  = buffer_prepare,
+	.buf_queue    = buffer_queue,
+	.buf_release  = buffer_release,
+};
+
+/*
+ * IOCTL vidioc handling
+ */
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	strcpy(cap->driver, "sun4i_csi");
+	strcpy(cap->card, "sun4i_csi");
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+
+	cap->version = CSI_VERSION;
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | \
+			    V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	struct csi_fmt *fmt;
+
+	csi_dbg(0,"vidioc_enum_fmt_vid_cap\n");
+
+	if (f->index > ARRAY_SIZE(formats)-1) {
+		return -EINVAL;
+	}
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	f->fmt.pix.width        = dev->width;
+	f->fmt.pix.height       = dev->height;
+	f->fmt.pix.field        = dev->vb_vidq.field;
+	f->fmt.pix.pixelformat  = dev->fmt->fourcc;
+	f->fmt.pix.bytesperline = (f->fmt.pix.width * dev->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage    = f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return 0;
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+			struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_fmt *csi_fmt;
+	struct v4l2_mbus_framefmt ccm_fmt;//linux-3.0
+	int ret = 0;
+
+	csi_dbg(0,"vidioc_try_fmt_vid_cap\n");
+
+	/*judge the resolution*/
+	if(f->fmt.pix.width > MAX_WIDTH || f->fmt.pix.height > MAX_HEIGHT) {
+		csi_err("size is too large,automatically set to maximum!\n");
+		f->fmt.pix.width = MAX_WIDTH;
+		f->fmt.pix.height = MAX_HEIGHT;
+	}
+
+	csi_fmt = get_format(f);
+	if (!csi_fmt) {
+		csi_err("Fourcc format (0x%08x) invalid.\n",f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	ccm_fmt.code = csi_fmt->ccm_fmt;//linux-3.0
+	ccm_fmt.width = f->fmt.pix.width;//linux-3.0
+	ccm_fmt.height = f->fmt.pix.height;//linux-3.0
+
+	ret = v4l2_subdev_call(dev->sd,video,try_mbus_fmt,&ccm_fmt);//linux-3.0
+	if (ret < 0) {
+		csi_err("v4l2 sub device try_fmt error!\n");
+		return ret;
+	}
+
+	//info got from module
+	f->fmt.pix.width = ccm_fmt.width;//linux-3.0
+	f->fmt.pix.height = ccm_fmt.height;//linux-3.0
+//	f->fmt.pix.bytesperline = ccm_fmt.fmt.pix.bytesperline;//linux-3.0
+//	f->fmt.pix.sizeimage = ccm_fmt.fmt.pix.sizeimage;//linux-3.0
+	f->fmt.pix.field = ccm_fmt.field; /* Needed even if none */
+
+	csi_dbg(0,"pix->width=%d\n",f->fmt.pix.width);
+	csi_dbg(0,"pix->height=%d\n",f->fmt.pix.height);
+
+	return 0;
+}
+
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct videobuf_queue *q = &dev->vb_vidq;
+	int ret,width_buf,height_buf,width_len;
+	struct v4l2_mbus_framefmt ccm_fmt;//linux-3.0
+	struct csi_fmt *csi_fmt;
+
+	csi_dbg(0,"vidioc_s_fmt_vid_cap\n");
+
+	if (csi_is_generating(dev)) {
+		csi_err("%s device busy\n", __func__);
+		return -EBUSY;
+	}
+
+	mutex_lock(&q->vb_lock);
+
+	ret = vidioc_try_fmt_vid_cap(file, priv, f);
+	if (ret < 0) {
+		csi_err("try format failed!\n");
+		goto out;
+	}
+
+	csi_fmt = get_format(f);
+	if (!csi_fmt) {
+		csi_err("Fourcc format (0x%08x) invalid.\n",f->fmt.pix.pixelformat);
+		ret	= -EINVAL;
+		goto out;
+	}
+
+	ccm_fmt.code = csi_fmt->ccm_fmt;//linux-3.0
+	ccm_fmt.width = f->fmt.pix.width;//linux-3.0
+	ccm_fmt.height = f->fmt.pix.width;//linux-3.0
+
+	ret = v4l2_subdev_call(dev->sd,video,s_mbus_fmt,&ccm_fmt);//linux-3.0
+	if (ret < 0) {
+		csi_err("v4l2 sub device s_fmt error!\n");
+		goto out;
+	}
+
+	//save the current format info
+	dev->fmt = csi_fmt;
+	dev->vb_vidq.field = f->fmt.pix.field;
+	dev->width  = f->fmt.pix.width;
+	dev->height = f->fmt.pix.height;
+
+	//set format
+	dev->csi_mode.output_fmt = dev->fmt->output_fmt;
+	dev->csi_mode.input_fmt = dev->fmt->input_fmt;
+
+	switch(dev->fmt->ccm_fmt) {
+	case V4L2_MBUS_FMT_YUYV8_2X8://linux-3.0
+		if ((dev->fmt->fourcc == V4L2_PIX_FMT_NV61) || (dev->fmt->fourcc == V4L2_PIX_FMT_NV21))
+			dev->csi_mode.seq = CSI_YVYU;
+		else
+			dev->csi_mode.seq = CSI_YUYV;
+		break;
+	case V4L2_MBUS_FMT_YVYU8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_YVYU;
+		break;
+	case V4L2_MBUS_FMT_UYVY8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_UYVY;
+		break;
+	case V4L2_MBUS_FMT_VYUY8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_VYUY;
+		break;
+	default:
+		dev->csi_mode.seq = CSI_YUYV;
+		break;
+	}
+
+	switch(dev->fmt->input_fmt){
+	case CSI_RAW:
+		if ( (dev->fmt->fourcc == V4L2_PIX_FMT_YUYV) || (dev->fmt->fourcc == V4L2_PIX_FMT_YVYU) || \
+				 (dev->fmt->fourcc == V4L2_PIX_FMT_UYVY) || (dev->fmt->fourcc == V4L2_PIX_FMT_VYUY)) {
+
+			width_len  = dev->width*2;
+			width_buf = dev->width*2;
+			height_buf = dev->height;
+
+		} else {
+			width_len  = dev->width;
+			width_buf = dev->width;
+			height_buf = dev->height;
+		}
+		break;
+	case CSI_BAYER:
+		width_len  = dev->width;
+		width_buf = dev->width;
+		height_buf = dev->height;
+		break;
+	case CSI_CCIR656://TODO
+	case CSI_YUV422:
+		width_len  = dev->width;
+		width_buf = dev->width*2;
+		height_buf = dev->height;
+		break;
+	default:
+		width_len  = dev->width;
+		width_buf = dev->width*2;
+		height_buf = dev->height;
+		break;
+	}
+
+	bsp_csi_configure(dev,&dev->csi_mode);
+	//horizontal and vertical offset are constant zero
+	bsp_csi_set_size(dev,width_buf,height_buf,width_len);
+
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+	return ret;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+			  struct v4l2_requestbuffers *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	csi_dbg(0,"vidioc_reqbufs\n");
+
+	return videobuf_reqbufs(&dev->vb_vidq, p);
+}
+
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_querybuf(&dev->vb_vidq, p);
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_qbuf(&dev->vb_vidq, p);
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_dqbuf(&dev->vb_vidq, p, file->f_flags & O_NONBLOCK);
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_cgmbuf(&dev->vb_vidq, mbuf, 8);
+}
+#endif
+
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+	struct csi_buffer *buf;
+
+	int ret;
+
+	csi_dbg(0,"video stream on\n");
+	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return -EINVAL;
+	}
+
+	if (csi_is_generating(dev)) {
+		csi_err("stream has been already on\n");
+		return 0;
+	}
+
+	/* Resets frame counters */
+	dev->ms = 0;
+	dev->jiffies = jiffies;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	ret = videobuf_streamon(&dev->vb_vidq);
+	if (ret) {
+		return ret;
+	}
+
+	buf = list_entry(dma_q->active.next,struct csi_buffer, vb.queue);
+	csi_set_addr(dev,buf);
+
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_enable(dev, CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_capture_video_start(dev);
+
+	csi_start_generating(dev);
+	return 0;
+}
+
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+	int ret;
+
+	csi_dbg(0,"video stream off\n");
+
+	if (!csi_is_generating(dev)) {
+		csi_err("stream has been already off\n");
+		return 0;
+	}
+
+	csi_stop_generating(dev);
+
+	/* Resets frame counters */
+	dev->ms = 0;
+	dev->jiffies = jiffies;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_capture_video_stop(dev);
+
+	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return -EINVAL;
+	}
+
+	ret = videobuf_streamoff(&dev->vb_vidq);
+	if (ret!=0) {
+		csi_err("videobu_streamoff error!\n");
+		return ret;
+	}
+
+	if (ret!=0) {
+		csi_err("videobuf_mmap_free error!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static int vidioc_enum_input(struct file *file, void *priv,
+				struct v4l2_input *inp)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	if (inp->index > dev->dev_qty-1) {
+		csi_err("input index invalid!\n");
+		return -EINVAL;
+	}
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	*i = dev->input;
+	return 0;
+}
+
+static int internal_s_input(struct csi_dev *dev, unsigned int i)
+{
+	struct v4l2_control ctrl;
+	int ret;
+
+	if (i > dev->dev_qty-1) {
+		csi_err("set input error!\n");
+		return -EINVAL;
+	}
+
+	if (i == dev->input)
+		return 0;
+
+	csi_dbg(0,"input_num = %d\n",i);
+
+//	spin_lock(&dev->slock);
+
+	/*Power down current device*/
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	if(ret < 0)
+		goto altend;
+
+	/* Alternate the device info and select target device*/
+  ret = update_ccm_info(dev, dev->ccm_cfg[i]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when selecting input!,input_num = %d\n",i);
+		goto recover;
+	}
+
+	/* change the csi setting */
+	csi_dbg(0,"dev->ccm_info->vref = %d\n",dev->ccm_info->vref);
+	csi_dbg(0,"dev->ccm_info->href = %d\n",dev->ccm_info->href);
+	csi_dbg(0,"dev->ccm_info->clock = %d\n",dev->ccm_info->clock);
+	csi_dbg(0,"dev->ccm_info->mclk = %d\n",dev->ccm_info->mclk);
+
+	dev->csi_mode.vref       = dev->ccm_info->vref;
+  dev->csi_mode.href       = dev->ccm_info->href;
+  dev->csi_mode.clock      = dev->ccm_info->clock;
+
+//  bsp_csi_configure(dev,&dev->csi_mode);
+	csi_clk_out_set(dev);
+
+	/* Initial target device */
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_OFF);
+	if (ret!=0) {
+	  csi_err("sensor standby off error when selecting target device!\n");
+	  goto recover;
+	}
+
+	ret = v4l2_subdev_call(dev->sd,core, init, 0);
+	if (ret!=0) {
+		csi_err("sensor initial error when selecting target device!\n");
+		goto recover;
+	}
+
+	/* Set the initial flip */
+	ctrl.id = V4L2_CID_VFLIP;
+	ctrl.value = dev->vflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_VFLIP error when vidioc_s_input!input_num = %d\n",i);
+	}
+
+	ctrl.id = V4L2_CID_HFLIP;
+	ctrl.value = dev->hflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_HFLIP error when vidioc_s_input!input_num = %d\n",i);
+	}
+
+	dev->input = i;
+  ret = 0;
+
+altend:
+//  spin_unlock(&dev->slock);
+	return ret;
+
+recover:
+	/*Power down target device*/
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	if(ret < 0)
+		goto altend;
+
+	/* Alternate the device info and select the current device*/
+  ret = update_ccm_info(dev, dev->ccm_cfg[dev->input]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when selecting input!\n");
+		goto altend;
+	}
+
+
+	/*Re Initial current device*/
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_OFF);
+	if (ret!=0) {
+	  csi_err("sensor standby off error when selecting back current device!\n");
+	  goto recover;
+	}
+
+	ret = v4l2_subdev_call(dev->sd,core, init, 0);
+	if (ret!=0) {
+		csi_err("sensor recovering error when selecting back current device!\n");
+	}
+	ret = 0;
+	goto altend;
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return internal_s_input(dev , i);
+}
+
+
+static int vidioc_queryctrl(struct file *file, void *priv,
+			    struct v4l2_queryctrl *qc)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,core,queryctrl,qc);
+	if (ret < 0)
+		csi_err("v4l2 sub device queryctrl error!\n");
+
+	return ret;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *ctrl)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,core,g_ctrl,ctrl);
+	if (ret < 0)
+		csi_err("v4l2 sub device g_ctrl error!\n");
+
+	return ret;
+}
+
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct v4l2_queryctrl qc;
+	int ret;
+
+	qc.id = ctrl->id;
+	ret = vidioc_queryctrl(file, priv, &qc);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
+		return -ERANGE;
+	}
+
+	ret = v4l2_subdev_call(dev->sd,core,s_ctrl,ctrl);
+	if (ret < 0)
+		csi_err("v4l2 sub device s_ctrl error!\n");
+
+	return ret;
+}
+
+static int vidioc_g_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *parms)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,video,g_parm,parms);
+	if (ret < 0)
+		csi_err("v4l2 sub device g_parm error!\n");
+
+	return ret;
+}
+
+static int vidioc_s_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *parms)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,video,s_parm,parms);
+	if (ret < 0)
+		csi_err("v4l2 sub device s_parm error!\n");
+
+	return ret;
+}
+
+
+static ssize_t csi_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+//	csi_start_generating(dev);
+	if(csi_is_generating(dev)) {
+		return videobuf_read_stream(&dev->vb_vidq, data, count, ppos, 0,
+					file->f_flags & O_NONBLOCK);
+	} else {
+		csi_err("csi is not generating!\n");
+		return -EINVAL;
+	}
+}
+
+static unsigned int csi_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct videobuf_queue *q = &dev->vb_vidq;
+
+//	csi_start_generating(dev);
+	if(csi_is_generating(dev)) {
+		return videobuf_poll_stream(file, q, wait);
+	} else {
+		csi_err("csi is not generating!\n");
+		return -EINVAL;
+	}
+}
+
+static int csi_open(struct file *file)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret,input_num;
+	struct v4l2_control ctrl;
+
+	csi_dbg(0,"csi_open\n");
+
+	if (dev->opened == 1) {
+		csi_err("device open busy\n");
+		return -EBUSY;
+	}
+
+	csi_clk_enable(dev);
+	csi_reset_disable(dev);
+
+	//open all the device power and set it to standby on
+	for (input_num=dev->dev_qty-1; input_num>=0; input_num--) {
+		/* update target device info and select it*/
+		ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+		if (ret < 0)
+		{
+			csi_err("Error when set ccm info when csi open!\n");
+		}
+
+		dev->csi_mode.vref       = dev->ccm_info->vref;
+	  dev->csi_mode.href       = dev->ccm_info->href;
+	  dev->csi_mode.clock      = dev->ccm_info->clock;
+		csi_clk_out_set(dev);
+
+		ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+	  if (ret!=0) {
+	  	csi_err("sensor CSI_SUBDEV_PWR_ON error at device number %d when csi open!\n",input_num);
+	  }
+
+		ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+		if (ret!=0) {
+	  	csi_err("sensor CSI_SUBDEV_STBY_ON error at device number %d when csi open!\n",input_num);
+	  }
+	}
+
+	dev->input=0;//default input
+
+	bsp_csi_open(dev);
+	bsp_csi_set_offset(dev,0,0);//h and v offset is initialed to zero
+
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_OFF);
+	if (ret!=0) {
+	  csi_err("sensor standby off error when csi open!\n");
+	  return ret;
+	}
+
+	ret = v4l2_subdev_call(dev->sd,core, init, 0);
+	if (ret!=0) {
+		csi_err("sensor initial error when csi open!\n");
+		return ret;
+	} else {
+		csi_print("sensor initial success when csi open!\n");
+	}
+
+	ctrl.id = V4L2_CID_VFLIP;
+	ctrl.value = dev->vflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_VFLIP error when csi open!\n");
+	}
+
+	ctrl.id = V4L2_CID_HFLIP;
+	ctrl.value = dev->hflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_HFLIP error when csi open!\n");
+	}
+
+	dev->opened = 1;
+	dev->fmt = &formats[5]; //default format
+	return 0;
+}
+
+static int csi_close(struct file *file)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret,input_num;
+
+	csi_dbg(0,"csi_close\n");
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	//bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);
+
+	bsp_csi_capture_video_stop(dev);
+	bsp_csi_close(dev);
+
+	csi_clk_disable(dev);
+	csi_reset_enable(dev);
+
+
+	videobuf_stop(&dev->vb_vidq);
+	videobuf_mmap_free(&dev->vb_vidq);
+
+	dev->opened=0;
+	csi_stop_generating(dev);
+
+	if(dev->stby_mode == 0) {
+		return v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	} else {
+		//close all the device power
+		for (input_num=0; input_num<dev->dev_qty; input_num++) {
+      /* update target device info and select it */
+      ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+			if (ret < 0)
+			{
+				csi_err("Error when set ccm info when csi_close!\n");
+			}
+
+			ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+		  if (ret!=0) {
+		  	csi_err("sensor power off error at device number %d when csi open!\n",input_num);
+		  	return ret;
+		  }
+		}
+	}
+
+	return 0;
+}
+
+static int csi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	csi_dbg(0,"mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&dev->vb_vidq, vma);
+
+	csi_dbg(0,"vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end - (unsigned long)vma->vm_start,
+		ret);
+	return ret;
+}
+
+static const struct v4l2_file_operations csi_fops = {
+	.owner	  = THIS_MODULE,
+	.open	  = csi_open,
+	.release  = csi_close,
+	.read     = csi_read,
+	.poll	  = csi_poll,
+	.ioctl    = video_ioctl2,
+	.mmap     = csi_mmap,
+};
+
+static const struct v4l2_ioctl_ops csi_ioctl_ops = {
+	.vidioc_querycap          = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_reqbufs           = vidioc_reqbufs,
+	.vidioc_querybuf          = vidioc_querybuf,
+	.vidioc_qbuf              = vidioc_qbuf,
+	.vidioc_dqbuf             = vidioc_dqbuf,
+	.vidioc_enum_input        = vidioc_enum_input,
+	.vidioc_g_input           = vidioc_g_input,
+	.vidioc_s_input           = vidioc_s_input,
+	.vidioc_streamon          = vidioc_streamon,
+	.vidioc_streamoff         = vidioc_streamoff,
+	.vidioc_queryctrl         = vidioc_queryctrl,
+	.vidioc_g_ctrl            = vidioc_g_ctrl,
+	.vidioc_s_ctrl            = vidioc_s_ctrl,
+	.vidioc_g_parm		 			  = vidioc_g_parm,
+	.vidioc_s_parm		  			= vidioc_s_parm,
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf              = vidiocgmbuf,
+#endif
+};
+
+static struct video_device csi_template = {
+	.name		= "csi",
+	.fops       = &csi_fops,
+	.ioctl_ops 	= &csi_ioctl_ops,
+	.release	= video_device_release,
+};
+
+static int fetch_config(struct csi_dev *dev)
+{
+	int input_num,ret;
+
+	/* fetch device quatity issue */
+	ret = script_parser_fetch("csi0_para","csi_dev_qty", &dev->dev_qty , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_dev_qty from sys_config failed\n");
+	}
+
+	/* fetch standby mode */
+	ret = script_parser_fetch("csi0_para","csi_stby_mode", &dev->stby_mode , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_stby_mode from sys_config failed\n");
+	}
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		dev->ccm_cfg[input_num] = &ccm_cfg[input_num];
+		csi_dbg(0,"dev->ccm_cfg[%d] = %p\n",input_num,dev->ccm_cfg[input_num]);
+	}
+
+	if(dev->dev_qty > 0)
+	{
+		dev->ccm_cfg[0]->i2c_addr = i2c_addr;
+		strcpy(dev->ccm_cfg[0]->ccm,ccm);
+
+		/* fetch i2c and module name*/
+		ret = script_parser_fetch("csi0_para","csi_twi_id", &dev->ccm_cfg[0]->twi_id , sizeof(int));
+		if (ret) {
+		}
+
+		ret = strcmp(dev->ccm_cfg[0]->ccm,"");
+		if((dev->ccm_cfg[0]->i2c_addr == 0xff) && (ret == 0))	//when insmod without parm
+		{
+			ret = script_parser_fetch("csi0_para","csi_twi_addr", &dev->ccm_cfg[0]->i2c_addr , sizeof(int));
+			if (ret) {
+				csi_err("fetch csi_twi_addr from sys_config failed\n");
+			}
+
+			ret = script_parser_fetch("csi0_para","csi_mname", (int *)&dev->ccm_cfg[0]->ccm , I2C_NAME_SIZE*sizeof(char));
+			if (ret) {
+				csi_err("fetch csi_mname from sys_config failed\n");
+			}
+		}
+
+		/* fetch interface issue*/
+		ret = script_parser_fetch("csi0_para","csi_if", &dev->ccm_cfg[0]->interface , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_if from sys_config failed\n");
+		}
+
+		/* fetch power issue*/
+
+		ret = script_parser_fetch("csi0_para","csi_iovdd", (int *)&dev->ccm_cfg[0]->iovdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_iovdd from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_avdd", (int *)&dev->ccm_cfg[0]->avdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_avdd from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_dvdd", (int *)&dev->ccm_cfg[0]->dvdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_dvdd from sys_config failed\n");
+		}
+
+		/* fetch flip issue */
+		ret = script_parser_fetch("csi0_para","csi_vflip", &dev->ccm_cfg[0]->vflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 vflip from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_hflip", &dev->ccm_cfg[0]->hflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 hflip from sys_config failed\n");
+		}
+
+		/* fetch flash light issue */
+		ret = script_parser_fetch("csi0_para","csi_flash_pol", &dev->ccm_cfg[0]->flash_pol , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 csi_flash_pol from sys_config failed\n");
+		}
+	}
+
+	if(dev->dev_qty > 1)
+	{
+		dev->ccm_cfg[1]->i2c_addr = i2c_addr_b;
+		strcpy(dev->ccm_cfg[1]->ccm,ccm_b);
+
+		/* fetch i2c and module name*/
+		ret = script_parser_fetch("csi0_para","csi_twi_id_b", &dev->ccm_cfg[1]->twi_id , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_twi_id_b from sys_config failed\n");
+		}
+
+		ret = strcmp(dev->ccm_cfg[1]->ccm,"");
+		if((dev->ccm_cfg[1]->i2c_addr == 0xff) && (ret == 0))	//when insmod without parm
+		{
+			ret = script_parser_fetch("csi0_para","csi_twi_addr_b", &dev->ccm_cfg[1]->i2c_addr , sizeof(int));
+			if (ret) {
+				csi_err("fetch csi_twi_addr_b from sys_config failed\n");
+			}
+
+			ret = script_parser_fetch("csi0_para","csi_mname_b", (int *)&dev->ccm_cfg[1]->ccm , I2C_NAME_SIZE*sizeof(char));
+			if (ret) {
+				csi_err("fetch csi_mname_b from sys_config failed\n");;
+			}
+		}
+
+		/* fetch interface issue*/
+		ret = script_parser_fetch("csi0_para","csi_if_b", &dev->ccm_cfg[1]->interface , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_if_b from sys_config failed\n");
+		}
+
+		/* fetch power issue*/
+		ret = script_parser_fetch("csi0_para","csi_iovdd_b", (int *)&dev->ccm_cfg[1]->iovdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_iovdd_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_avdd_b", (int *)&dev->ccm_cfg[1]->avdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_avdd_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_dvdd_b", (int *)&dev->ccm_cfg[1]->dvdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_dvdd_b from sys_config failed\n");
+		}
+
+		/* fetch flip issue */
+		ret = script_parser_fetch("csi0_para","csi_vflip_b", &dev->ccm_cfg[1]->vflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 vflip_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi0_para","csi_hflip_b", &dev->ccm_cfg[1]->hflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 hflip_b from sys_config failed\n");
+		}
+
+		/* fetch flash light issue */
+		ret = script_parser_fetch("csi0_para","csi_flash_pol_b", &dev->ccm_cfg[1]->flash_pol , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi0 csi_flash_pol_b from sys_config failed\n");
+		}
+	}
+
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm = %s\n",input_num,dev->ccm_cfg[input_num]->ccm);
+		csi_dbg(0,"dev->ccm_cfg[%d]->twi_id = %x\n",input_num,dev->ccm_cfg[input_num]->twi_id);
+		csi_dbg(0,"dev->ccm_cfg[%d]->i2c_addr = %x\n",input_num,dev->ccm_cfg[input_num]->i2c_addr);
+		csi_dbg(0,"dev->ccm_cfg[%d]->interface = %x\n",input_num,dev->ccm_cfg[input_num]->interface);
+		csi_dbg(0,"dev->ccm_cfg[%d]->vflip = %x\n",input_num,dev->ccm_cfg[input_num]->vflip);
+		csi_dbg(0,"dev->ccm_cfg[%d]->hflip = %x\n",input_num,dev->ccm_cfg[input_num]->hflip);
+		csi_dbg(0,"dev->ccm_cfg[%d]->iovdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->iovdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->avdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->avdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->dvdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->dvdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->flash_pol = %x\n",input_num,dev->ccm_cfg[input_num]->flash_pol);
+	}
+
+	return 0;
+}
+
+static int csi_probe(struct platform_device *pdev)
+{
+	struct csi_dev *dev;
+	struct resource *res;
+	struct video_device *vfd;
+	struct i2c_adapter *i2c_adap;
+	int ret = 0;
+	int input_num;
+
+	csi_dbg(0,"csi_probe\n");
+	/*request mem for dev*/
+	dev = kzalloc(sizeof(struct csi_dev), GFP_KERNEL);
+	if (!dev) {
+		csi_err("request dev mem failed!\n");
+		return -ENOMEM;
+	}
+	dev->id = pdev->id;
+	dev->pdev = pdev;
+
+	spin_lock_init(&dev->slock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		csi_err("failed to find the registers\n");
+		ret = -ENOENT;
+		goto err_info;
+	}
+
+	dev->regs_res = request_mem_region(res->start, resource_size(res),
+			dev_name(&pdev->dev));
+	if (!dev->regs_res) {
+		csi_err("failed to obtain register region\n");
+		ret = -ENOENT;
+		goto err_info;
+	}
+
+	dev->regs = ioremap(res->start, resource_size(res));
+	if (!dev->regs) {
+		csi_err("failed to map registers\n");
+		ret = -ENXIO;
+		goto err_req_region;
+	}
+
+
+  /*get irq resource*/
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		csi_err("failed to get IRQ resource\n");
+		ret = -ENXIO;
+		goto err_regs_unmap;
+	}
+
+	dev->irq = res->start;
+
+	ret = request_irq(dev->irq, csi_isr, 0, pdev->name, dev);
+	if (ret) {
+		csi_err("failed to install irq (%d)\n", ret);
+		goto err_clk;
+	}
+
+    /*pin resource*/
+	dev->csi_pin_hd = gpio_request_ex("csi0_para",NULL);
+	if (dev->csi_pin_hd==-1) {
+		csi_err("csi0 pin request error!\n");
+		ret = -ENXIO;
+		goto err_irq;
+	}
+
+    /* v4l2 device register */
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret) {
+		csi_err("Error registering v4l2 device\n");
+		goto err_irq;
+
+	}
+
+	dev_set_drvdata(&(pdev)->dev, (dev));
+
+	/* fetch sys_config1 */
+
+	ret = fetch_config(dev);
+	if (ret) {
+		csi_err("Error at fetch_config\n");
+		goto err_irq;
+	}
+
+  /* v4l2 subdev register	*/
+	dev->module_flag = 0;
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+//		if(dev->module_flag)
+//			break;
+
+		if(!strcmp(dev->ccm_cfg[input_num]->ccm,""))
+			break;
+
+		if(dev->module_flag) {
+			dev->ccm_cfg[input_num]->sd = dev->ccm_cfg[input_num-1]->sd;
+			csi_dbg(0,"num = %d , sd_0 = %p,sd_1 = %p\n",input_num,dev->ccm_cfg[input_num]->sd,dev->ccm_cfg[input_num-1]->sd);
+			goto reg_sd;
+		}
+
+		if((dev->dev_qty > 1) && (input_num+1<dev->dev_qty))
+		{
+			if( (!strcmp(dev->ccm_cfg[input_num]->ccm,dev->ccm_cfg[input_num+1]->ccm)))
+				dev->module_flag = 1;
+		}
+
+		i2c_adap = i2c_get_adapter(dev->ccm_cfg[input_num]->twi_id);
+
+		if (i2c_adap == NULL) {
+			csi_err("request i2c adapter failed,input_num = %d\n",input_num);
+			ret = -EINVAL;
+			goto free_dev;//linux-3.0
+		}
+
+		dev->ccm_cfg[input_num]->sd = kmalloc(sizeof(struct v4l2_subdev *),GFP_KERNEL);
+		if (dev->ccm_cfg[input_num]->sd == NULL) {
+			csi_err("unable to allocate memory for subdevice pointers,input_num = %d\n",input_num);
+			ret = -ENOMEM;
+			goto free_dev;//linux-3.0
+		}
+
+		dev_sensor[input_num].addr = (unsigned short)(dev->ccm_cfg[input_num]->i2c_addr>>1);
+		strcpy(dev_sensor[input_num].type,dev->ccm_cfg[input_num]->ccm);
+
+		dev->ccm_cfg[input_num]->sd = v4l2_i2c_new_subdev_board(&dev->v4l2_dev,
+											i2c_adap,
+											//dev_sensor[input_num].type,//linux-3.0
+											&dev_sensor[input_num],
+											NULL);
+reg_sd:
+		if (!dev->ccm_cfg[input_num]->sd) {
+			csi_err("Error registering v4l2 subdevice,input_num = %d\n",input_num);
+			goto free_dev;
+		} else{
+			csi_print("registered sub device,input_num = %d\n",input_num);
+		}
+
+		dev->ccm_cfg[input_num]->ccm_info.mclk = CSI_OUT_RATE;
+		dev->ccm_cfg[input_num]->ccm_info.vref = CSI_LOW;
+		dev->ccm_cfg[input_num]->ccm_info.href = CSI_LOW;
+		dev->ccm_cfg[input_num]->ccm_info.clock = CSI_FALLING;
+
+		ret = v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core,ioctl,CSI_SUBDEV_CMD_GET_INFO,&dev->ccm_cfg[input_num]->ccm_info);
+		if (ret < 0)
+		{
+			csi_err("Error when get ccm info,input_num = %d,use default!\n",input_num);
+		}
+
+		dev->ccm_cfg[input_num]->ccm_info.iocfg = input_num;
+
+		ret = v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core,ioctl,CSI_SUBDEV_CMD_SET_INFO,&dev->ccm_cfg[input_num]->ccm_info);
+		if (ret < 0)
+		{
+			csi_err("Error when set ccm info,input_num = %d,use default!\n",input_num);
+		}
+
+		/*power issue*/
+		dev->ccm_cfg[input_num]->iovdd = NULL;
+		dev->ccm_cfg[input_num]->avdd = NULL;
+		dev->ccm_cfg[input_num]->dvdd = NULL;
+
+		if(strcmp(dev->ccm_cfg[input_num]->iovdd_str,"")) {
+			dev->ccm_cfg[input_num]->iovdd = regulator_get(NULL, dev->ccm_cfg[input_num]->iovdd_str);
+			if (dev->ccm_cfg[input_num]->iovdd == NULL) {
+				csi_err("get regulator csi_iovdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(strcmp(dev->ccm_cfg[input_num]->avdd_str,"")) {
+			dev->ccm_cfg[input_num]->avdd = regulator_get(NULL, dev->ccm_cfg[input_num]->avdd_str);
+			if (dev->ccm_cfg[input_num]->avdd == NULL) {
+				csi_err("get regulator csi_avdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(strcmp(dev->ccm_cfg[input_num]->dvdd_str,"")) {
+			dev->ccm_cfg[input_num]->dvdd = regulator_get(NULL, dev->ccm_cfg[input_num]->dvdd_str);
+			if (dev->ccm_cfg[input_num]->dvdd == NULL) {
+				csi_err("get regulator csi_dvdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(dev->stby_mode == 1) {
+			csi_print("power on and power off camera!\n");
+      ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+      if(ret<0)
+      	csi_err("Error when set ccm info when probe!\n");
+
+			v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+			v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+		}
+	}
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		csi_dbg(0,"dev->ccm_cfg[%d]->sd = %p\n",input_num,dev->ccm_cfg[input_num]->sd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info = %p\n",input_num,&dev->ccm_cfg[input_num]->ccm_info);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.iocfg = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.iocfg);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.vref = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.vref);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.href = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.href);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.clock = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.clock);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.mclk = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.mclk);
+		csi_dbg(0,"dev->ccm_cfg[%d]->iovdd = %p\n",input_num,dev->ccm_cfg[input_num]->iovdd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->avdd = %p\n",input_num,dev->ccm_cfg[input_num]->avdd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->dvdd = %p\n",input_num,dev->ccm_cfg[input_num]->dvdd);
+	}
+
+	update_ccm_info(dev, dev->ccm_cfg[0]);
+
+	/*clock resource*/
+	if (csi_clk_get(dev)) {
+		csi_err("csi clock get failed!\n");
+		ret = -ENXIO;
+		goto unreg_dev;
+	}
+
+//	csi_dbg("%s(): csi-%d registered successfully\n",__func__, dev->id);
+
+	/*video device register	*/
+	ret = -ENOMEM;
+	vfd = video_device_alloc();
+	if (!vfd) {
+		goto err_clk;
+	}
+
+	*vfd = csi_template;
+	vfd->v4l2_dev = &dev->v4l2_dev;
+
+	dev_set_name(&vfd->dev, "csi-0");
+	ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
+	if (ret < 0) {
+		goto rel_vdev;
+	}
+	video_set_drvdata(vfd, dev);
+
+	/*add device list*/
+	/* Now that everything is fine, let's add it to device list */
+	list_add_tail(&dev->csi_devlist, &csi_devlist);
+
+	if (video_nr != -1) {
+		video_nr++;
+	}
+	dev->vfd = vfd;
+
+	csi_print("V4L2 device registered as %s\n",video_device_node_name(vfd));
+
+	/*initial video buffer queue*/
+	videobuf_queue_dma_contig_init(&dev->vb_vidq, &csi_video_qops,
+			NULL, &dev->slock, V4L2_BUF_TYPE_VIDEO_CAPTURE,
+			V4L2_FIELD_NONE,//default format, can be changed by s_fmt
+			sizeof(struct csi_buffer), dev,NULL);//linux-3.0
+
+	/* init video dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	//init_waitqueue_head(&dev->vidq.wq);
+
+	return 0;
+
+rel_vdev:
+	video_device_release(vfd);
+err_clk:
+	csi_clk_release(dev);
+unreg_dev:
+	v4l2_device_unregister(&dev->v4l2_dev);
+free_dev:
+//	kfree(dev);
+err_irq:
+	free_irq(dev->irq, dev);
+err_regs_unmap:
+	iounmap(dev->regs);
+err_req_region:
+	release_resource(dev->regs_res);
+	kfree(dev->regs_res);
+err_info:
+	kfree(dev);
+	csi_err("failed to install\n");
+
+	return ret;
+}
+
+void csi_dev_release(struct device *dev)
+{
+}
+
+static int csi_release(void)
+{
+	struct csi_dev *dev;
+	struct list_head *list;
+
+	csi_dbg(0,"csi_release\n");
+	while (!list_empty(&csi_devlist))
+	{
+		list = csi_devlist.next;
+		list_del(list);
+		dev = list_entry(list, struct csi_dev, csi_devlist);
+
+		v4l2_info(&dev->v4l2_dev, "unregistering %s\n", video_device_node_name(dev->vfd));
+		video_unregister_device(dev->vfd);
+		csi_clk_release(dev);
+		v4l2_device_unregister(&dev->v4l2_dev);
+		free_irq(dev->irq, dev);
+		iounmap(dev->regs);
+		release_resource(dev->regs_res);
+		kfree(dev->regs_res);
+		kfree(dev);
+	}
+
+	csi_print("csi_release ok!\n");
+	return 0;
+}
+
+static int __devexit csi_remove(struct platform_device *pdev)
+{
+	struct csi_dev *dev;
+	dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+
+	csi_dbg(0,"csi_remove\n");
+
+//	video_device_release(vfd);
+//	csi_clk_release(dev);
+//	free_irq(dev->irq, dev);
+//
+//	iounmap(dev->regs);
+//	release_resource(dev->regs_res);
+//	kfree(dev->regs_res);
+//	kfree(dev);
+	csi_print("csi_remove ok!\n");
+	return 0;
+}
+
+static int csi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+	int ret,input_num;
+
+	csi_print("csi_suspend\n");
+
+	if (dev->opened==1) {
+		csi_clk_disable(dev);
+
+		if(dev->stby_mode == 0) {
+			csi_print("set camera to standby!\n");
+			return v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+		} else {
+			csi_print("set camera to power off!\n");
+			//close all the device power
+			for (input_num=0; input_num<dev->dev_qty; input_num++) {
+        /* update target device info and select it */
+        ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+        if (ret < 0)
+				{
+					csi_err("Error when set ccm info when csi_suspend!\n");
+				}
+
+				ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+			  if (ret!=0) {
+			  	csi_err("sensor power off error at device number %d when csi_suspend!\n",input_num);
+			  	return ret;
+			  }
+			}
+		}
+	}
+	return 0;
+}
+
+static int csi_resume(struct platform_device *pdev)
+{
+	int ret,input_num;
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+
+	csi_print("csi_resume\n");
+
+	if (dev->opened==1) {
+		csi_clk_out_set(dev);
+//		csi_clk_enable(dev);
+		if(dev->stby_mode == 0) {
+			ret = v4l2_subdev_call(dev->sd,core, s_power,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+			ret = v4l2_subdev_call(dev->sd,core, init, 0);
+			if (ret!=0) {
+				csi_err("sensor initial error when resume from suspend!\n");
+				return ret;
+			} else {
+				csi_print("sensor initial success when resume from suspend!\n");
+			}
+		} else {
+			//open all the device power
+			for (input_num=0; input_num<dev->dev_qty; input_num++) {
+        /* update target device info and select it */
+        ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+        if (ret < 0)
+				{
+					csi_err("Error when set ccm info when csi_resume!\n");
+				}
+
+				ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+			  if (ret!=0) {
+			  	csi_err("sensor power on error at device number %d when csi_resume!\n",input_num);
+			  }
+			}
+
+			/* update target device info and select it */
+			ret = update_ccm_info(dev, dev->ccm_cfg[0]);
+			if (ret < 0)
+			{
+				csi_err("Error when set ccm info when csi_resume!\n");
+			}
+
+			ret = v4l2_subdev_call(dev->sd,core, init,0);
+			if (ret!=0) {
+				csi_err("sensor full initial error when resume from suspend!\n");
+				return ret;
+			} else {
+				csi_print("sensor full initial success when resume from suspend!\n");
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+static struct platform_driver csi_driver = {
+	.probe		= csi_probe,
+	.remove		= __devexit_p(csi_remove),
+	.suspend	= csi_suspend,
+	.resume		= csi_resume,
+	//.id_table	= csi_driver_ids,
+	.driver = {
+		.name	= "sun4i_csi",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static struct resource csi0_resource[] = {
+	[0] = {
+		.start	= CSI0_REGS_BASE,
+		.end	= CSI0_REGS_BASE + CSI0_REG_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SW_INTC_IRQNO_CSI0,
+		.end	= SW_INTC_IRQNO_CSI0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device csi_device[] = {
+	[0] = {
+	.name           	= "sun4i_csi",
+  .id             	= 0,
+	.num_resources		= ARRAY_SIZE(csi0_resource),
+  .resource       	= csi0_resource,
+	.dev.release      = csi_dev_release,
+	}
+};
+
+static int __init csi_init(void)
+{
+	u32 ret;
+	int csi_used;
+	csi_print("Welcome to CSI driver\n");
+	csi_print("csi_init\n");
+
+	ret = script_parser_fetch("csi0_para","csi_used", &csi_used , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_used from sys_config failed\n");
+		return -1;
+	}
+
+	if(!csi_used)
+	{
+		csi_err("csi_used=0,csi driver is not enabled!\n");
+		return 0;
+	}
+
+	ret = platform_driver_register(&csi_driver);
+
+	if (ret) {
+		csi_err("platform driver register failed\n");
+		return -1;
+	}
+
+	ret = platform_device_register(&csi_device[0]);
+	if (ret) {
+		csi_err("platform device register failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void __exit csi_exit(void)
+{
+	int csi_used,ret;
+
+	csi_print("csi_exit\n");
+
+	ret = script_parser_fetch("csi0_para","csi_used", &csi_used , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_used from sys_config failed\n");
+		return;
+	}
+
+	if(csi_used)
+	{
+		csi_release();
+		platform_device_unregister(&csi_device[0]);
+		platform_driver_unregister(&csi_driver);
+	}
+}
+
+module_init(csi_init);
+module_exit(csi_exit);
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("CSI driver for sun4i");
diff --git a/drivers/media/video/sun4i_csi/csi1/Makefile b/drivers/media/video/sun4i_csi/csi1/Makefile
new file mode 100644
index 0000000..c01a11f
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi1/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_CSI1_SUN4I) += sun4i_csi1.o
+
+sun4i_csi1-objs := sun4i_csi_reg.o sun4i_drv_csi.o
+
+
+
+
diff --git a/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c b/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c
new file mode 100644
index 0000000..d3574ce
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c
@@ -0,0 +1,180 @@
+/*
+ * drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Sun4i Camera register read/write interface
+ * Author:raymonxiu
+*/
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#include "../include/sun4i_csi_core.h"
+#include "sun4i_csi_reg.h"
+
+/* open module */
+void bsp_csi_open(struct csi_dev *dev)
+{
+	W(dev->regs+CSI_REG_EN, 0x1);
+}
+
+void bsp_csi_close(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_EN, 0X1 << 0);
+}
+
+/* configure */
+void bsp_csi_configure(struct csi_dev *dev,__csi_conf_t *mode)
+{
+	u32 t;
+	W(dev->regs+CSI_REG_CONF, mode->input_fmt << 20 | /* [21:20] */
+							  mode->output_fmt<< 16 | /* [18:16] */
+							  mode->field_sel << 10 | /* [11:10] */
+							  mode->seq       << 8  | /* [9:8] */
+							  mode->vref      << 2  | /* [2] */
+							  mode->href      << 1  | /* [1] */
+							  mode->clock     << 0    /* [0] */
+      );
+
+  t = R(dev->regs+CSI_REG_CONF);
+
+}
+
+/* buffer */
+u32 static inline bsp_csi_get_buffer_address(struct csi_dev *dev,__csi_buf_t buf)
+{
+	u32 t;
+	t = R(dev->regs+CSI_REG_BUF_0_A + (buf<<2));
+	return t;
+}
+
+void bsp_csi_double_buffer_enable(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_BUF_CTRL, 0X1<<0);
+}
+
+void bsp_csi_double_buffer_disable(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_BUF_CTRL, 0X1<<0);
+}
+
+void static inline bsp_csi_double_buffer_select_next(struct csi_dev *dev,__csi_double_buf_t type)
+{
+    if (CSI_BUF_A == type) {
+        C(dev->regs+CSI_REG_BUF_CTRL, 0x1<<2);
+	} else {
+        S(dev->regs+CSI_REG_BUF_CTRL, 0x1<<2);
+	}
+}
+
+void static inline bsp_csi_double_buffer_get_status(struct csi_dev *dev,__csi_double_buf_status_t * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_BUF_CTRL);
+    status->enable = t&0x1;
+    status->cur  = (__csi_double_buf_t)(t&(0x1<<1));
+    status->next = (__csi_double_buf_t)(t&(0x1<<2));
+
+}
+
+/* capture */
+void bsp_csi_capture_video_start(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_CTRL, 0X1<<1);
+}
+
+void bsp_csi_capture_video_stop(struct csi_dev *dev)
+{
+    C(dev->regs+CSI_REG_CTRL, 0X1<<1);
+}
+
+void bsp_csi_capture_picture(struct csi_dev *dev)
+{
+    S(dev->regs+CSI_REG_CTRL, 0X1<<0);
+}
+
+void bsp_csi_capture_get_status(struct csi_dev *dev,__csi_capture_status * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_STATUS);
+    status->picture_in_progress = t&0x1;
+    status->video_in_progress   = (t>>1)&0x1;
+}
+
+/* size */
+void bsp_csi_set_size(struct csi_dev *dev, u32 length_h, u32 length_v, u32 buf_length_h)
+{
+	/* make sure yuv422 input 2 byte(clock) output 1 pixel */
+		u32 t;
+
+		t = R(dev->regs+CSI_REG_RESIZE_H);
+		t = (t&0x0000ffff)|(length_h<<16);
+    W(dev->regs+CSI_REG_RESIZE_H, t);
+
+    t = R(dev->regs+CSI_REG_RESIZE_H);
+    t = (t&0x0000ffff)|(length_v<<16);
+    W(dev->regs+CSI_REG_RESIZE_V, t);
+
+    W(dev->regs+CSI_REG_BUF_LENGTH, buf_length_h);
+}
+
+
+/* offset */
+void bsp_csi_set_offset(struct csi_dev *dev,u32 start_h, u32 start_v)
+{
+    u32 t;
+
+    t = R(dev->regs+CSI_REG_RESIZE_H);
+    t = (t&0xffff0000)|start_h;
+    W(dev->regs+CSI_REG_RESIZE_H, t);
+
+    t = R(dev->regs+CSI_REG_RESIZE_V);
+    t = (t&0xffff0000)|start_v;
+    W(dev->regs+CSI_REG_RESIZE_V, t);
+}
+
+
+/* interrupt */
+void bsp_csi_int_enable(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    S(dev->regs+CSI_REG_INT_EN, interrupt);
+}
+
+void bsp_csi_int_disable(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    C(dev->regs+CSI_REG_INT_EN, interrupt);
+}
+
+void static inline bsp_csi_int_get_status(struct csi_dev *dev,__csi_int_status_t * status)
+{
+    u32 t;
+    t = R(dev->regs+CSI_REG_INT_STATUS);
+
+    status->capture_done     = t&CSI_INT_CAPTURE_DONE;
+    status->frame_done       = t&CSI_INT_FRAME_DONE;
+    status->buf_0_overflow   = t&CSI_INT_BUF_0_OVERFLOW;
+    status->buf_1_overflow   = t&CSI_INT_BUF_1_OVERFLOW;
+    status->buf_2_overflow   = t&CSI_INT_BUF_2_OVERFLOW;
+    status->protection_error = t&CSI_INT_PROTECTION_ERROR;
+    status->hblank_overflow  = t&CSI_INT_HBLANK_OVERFLOW;
+    status->vsync_trig		 = t&CSI_INT_VSYNC_TRIG;
+
+}
diff --git a/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h b/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h
new file mode 100644
index 0000000..829b851
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h
@@ -0,0 +1,58 @@
+/*
+ * drivers/media/video/sun4i_csi/csi1/sun4i_csi_reg.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Sun4i Camera register define
+ * Author:raymonxiu
+*/
+#ifndef _SUN4I_CSI_REG_H_
+#define _SUN4I_CSI_REG_H_
+
+#define  W(addr, val)   writel(val, addr)
+#define  R(addr)        readl(addr)
+#define  S(addr,bit)	writel(readl(addr)|bit,addr)
+#define  C(addr,bit)	writel(readl(addr)&(~bit),addr)
+
+#define CSI0_REGS_BASE        0x01c09000
+#define CSI1_REGS_BASE        0X01c1D000
+#define CSI0_REG_SIZE 				0x1000
+#define CSI1_REG_SIZE 				0x1000
+
+#define CSI_REG_EN           (0x00)
+#define CSI_REG_CONF         (0x04)
+#define CSI_REG_CTRL         (0x08)
+#define CSI_REG_SCALE        (0x0C)
+#define CSI_REG_BUF_0_A      (0x10)
+#define CSI_REG_BUF_0_B      (0x14)
+#define CSI_REG_BUF_1_A      (0x18)
+#define CSI_REG_BUF_1_B      (0x1C)
+#define CSI_REG_BUF_2_A      (0x20)
+#define CSI_REG_BUF_2_B      (0x24)
+#define CSI_REG_BUF_CTRL     (0x28)
+#define CSI_REG_STATUS       (0x2C)
+#define CSI_REG_INT_EN       (0x30)
+#define CSI_REG_INT_STATUS   (0x34)
+#define CSI_REG_RESIZE_H     (0x40)
+#define CSI_REG_RESIZE_V     (0x44)
+#define CSI_REG_BUF_LENGTH   (0x48)
+
+#endif  /* _CSI_H_ */
diff --git a/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c b/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
new file mode 100644
index 0000000..38137ec
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
@@ -0,0 +1,2211 @@
+/*
+ * drivers/media/video/sun4i_csi/csi1/sun4i_drv_csi.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Sun4i Camera Interface  driver
+ * Author: raymonxiu
+ */
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+#include <linux/freezer.h>
+#endif
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-common.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf-dma-contig.h>
+#include <linux/moduleparam.h>
+
+#include <plat/sys_config.h>
+#include <mach/clock.h>
+#include <mach/irqs.h>
+#include <linux/regulator/consumer.h>
+
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+#include "sun4i_csi_reg.h"
+
+#define CSI_MAJOR_VERSION 1
+#define CSI_MINOR_VERSION 0
+#define CSI_RELEASE 0
+#define CSI_VERSION \
+	KERNEL_VERSION(CSI_MAJOR_VERSION, CSI_MINOR_VERSION, CSI_RELEASE)
+#define CSI_MODULE_NAME "sun4i_csi1"
+
+//#define USE_DMA_CONTIG
+
+//#define AJUST_DRAM_PRIORITY
+#define REGS_pBASE					(0x01C00000)	 	      // register base addr
+#define SDRAM_REGS_pBASE    (REGS_pBASE + 0x01000)    // SDRAM Controller
+
+#define NUM_INPUTS 2
+#define CSI_OUT_RATE      (24*1000*1000)
+//#define CSI_ISP_RATE			(100*1000*1000)
+#define CSI_MAX_FRAME_MEM (32*1024*1024)
+//#define TWI_NO		 (1)
+
+#define MIN_WIDTH  (32)
+#define MIN_HEIGHT (32)
+#define MAX_WIDTH  (4096)
+#define MAX_HEIGHT (4096)
+
+static unsigned video_nr = 1;
+static unsigned first_flag = 0;
+
+
+
+static char ccm[I2C_NAME_SIZE] = "";
+static uint i2c_addr = 0xff;
+
+static char ccm_b[I2C_NAME_SIZE] = "";
+static uint i2c_addr_b = 0xff;
+
+
+static struct ccm_config ccm_cfg[NUM_INPUTS] = {
+	{
+		.i2c_addr = 0xff,
+	},
+	{
+		.i2c_addr = 0xff,
+	},
+};
+
+module_param_string(ccm, ccm, sizeof(ccm), S_IRUGO|S_IWUSR);
+module_param(i2c_addr,uint, S_IRUGO|S_IWUSR);
+module_param_string(ccm_b, ccm_b, sizeof(ccm_b), S_IRUGO|S_IWUSR);
+module_param(i2c_addr_b,uint, S_IRUGO|S_IWUSR);
+
+static struct i2c_board_info  dev_sensor[] =  {
+	{
+		//I2C_BOARD_INFO(ccm, i2c_addr),
+		.platform_data	= NULL,
+	},
+	{
+		//I2C_BOARD_INFO(ccm, i2c_addr),
+		.platform_data	= NULL,
+	},
+};
+
+//ccm support format
+static struct csi_fmt formats[] = {
+	{
+		.name     		= "planar YUV 422",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUV422P,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_PLANAR_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 3,
+	},
+	{
+		.name     		= "planar YUV 420",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUV420,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_PLANAR_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 3,
+	},
+	{
+		.name     		= "planar YUV 422 UV combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV16,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 420 UV combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV12,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 422 VU combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV61,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV422,
+		.depth    		= 16,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "planar YUV 420 VU combined",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_NV21,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_UV_CB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "MB YUV420",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_HM12,
+		.input_fmt		= CSI_YUV422,
+		.output_fmt		= CSI_MB_YUV420,
+		.depth    		= 12,
+		.planes_cnt		= 2,
+	},
+	{
+		.name     		= "RAW Bayer",
+		.ccm_fmt			= V4L2_MBUS_FMT_SBGGR8_1X8,	//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_SBGGR8,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 8,
+		.planes_cnt		= 1,
+	},
+//	{
+//		.name     		= "planar RGB242",
+//		.ccm_fmt			= V4L2_PIX_FMT_SBGGR8,
+//		.fourcc   		= V4L2_PIX_FMT_RGB32,		//can't find the appropriate format in V4L2 define,use this temporarily
+//		.input_fmt		= CSI_BAYER,
+//		.output_fmt		= CSI_PLANAR_RGB242,
+//		.depth    		= 8,
+//		.planes_cnt		= 3,
+//	},
+	{
+		.name     		= "YUV422 YUYV",
+		.ccm_fmt			= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YUYV,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 YVYU",
+		.ccm_fmt			= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_YVYU,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 UYVY",
+		.ccm_fmt			= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_UYVY,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+	{
+		.name     		= "YUV422 VYUY",
+		.ccm_fmt			= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.fourcc   		= V4L2_PIX_FMT_VYUY,
+		.input_fmt		= CSI_RAW,
+		.output_fmt		= CSI_PASS_THROUTH,
+		.depth    		= 16,
+		.planes_cnt		= 1,
+	},
+};
+
+static struct csi_fmt *get_format(struct v4l2_format *f)
+{
+	struct csi_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat) {
+			break;
+		}
+	}
+
+	if (k == ARRAY_SIZE(formats)) {
+		return NULL;
+	}
+
+	return &formats[k];
+};
+
+void static inline bsp_csi_int_clear_status(struct csi_dev *dev,__csi_int_t interrupt)
+{
+    W(dev->regs+CSI_REG_INT_STATUS, interrupt);
+}
+
+void static inline bsp_csi_set_buffer_address(struct csi_dev *dev,__csi_buf_t buf, u32 addr)
+{
+	//bufer0a +4 = buffer0b, bufer0a +8 = buffer1a
+    W(dev->regs+CSI_REG_BUF_0_A + (buf<<2), addr);
+}
+
+
+static inline void csi_set_addr(struct csi_dev *dev,struct csi_buffer *buffer)
+{
+
+	struct csi_buffer *buf = buffer;
+	dma_addr_t addr_org;
+
+	csi_dbg(3,"buf ptr=%p\n",buf);
+
+	addr_org = videobuf_to_dma_contig((struct videobuf_buffer *)buf);
+
+
+	if(dev->fmt->input_fmt==CSI_RAW){
+		dev->csi_buf_addr.y  = addr_org;
+		dev->csi_buf_addr.cb = addr_org;
+		dev->csi_buf_addr.cr = addr_org;
+
+	}else if(dev->fmt->input_fmt==CSI_BAYER){
+		//really rare here
+		dev->csi_buf_addr.cb = addr_org;//for G channel
+		dev->csi_buf_addr.y  = addr_org + dev->width*dev->height*1/2;//for B channel
+		dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*3/4;//for R channel
+
+	}else if(dev->fmt->input_fmt==CSI_CCIR656){
+	//TODO:
+
+	}else if(dev->fmt->input_fmt==CSI_YUV422){
+
+		switch (dev->fmt->output_fmt) {
+			case CSI_PLANAR_YUV422:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*3/2;
+				break;
+
+			case CSI_PLANAR_YUV420:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height*5/4;
+				break;
+
+			case CSI_UV_CB_YUV422:
+			case CSI_UV_CB_YUV420:
+			case CSI_MB_YUV422:
+			case CSI_MB_YUV420:
+				dev->csi_buf_addr.y  = addr_org;
+				dev->csi_buf_addr.cb = addr_org + dev->width*dev->height;
+				dev->csi_buf_addr.cr = addr_org + dev->width*dev->height;
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	bsp_csi_set_buffer_address(dev, CSI_BUF_0_A, dev->csi_buf_addr.y);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_0_B, dev->csi_buf_addr.y);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_1_A, dev->csi_buf_addr.cb);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_1_B, dev->csi_buf_addr.cb);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_2_A, dev->csi_buf_addr.cr);
+	bsp_csi_set_buffer_address(dev, CSI_BUF_2_B, dev->csi_buf_addr.cr);
+
+	csi_dbg(3,"csi_buf_addr_y=%x\n",  dev->csi_buf_addr.y);
+	csi_dbg(3,"csi_buf_addr_cb=%x\n", dev->csi_buf_addr.cb);
+	csi_dbg(3,"csi_buf_addr_cr=%x\n", dev->csi_buf_addr.cr);
+
+}
+
+static int csi_clk_get(struct csi_dev *dev)
+{
+	int ret;
+
+	dev->csi_ahb_clk=clk_get(NULL, "ahb_csi1");
+	if (dev->csi_ahb_clk == NULL) {
+       	csi_err("get csi1 ahb clk error!\n");
+		return -1;
+    }
+
+	if(dev->ccm_info->mclk==24000000 || dev->ccm_info->mclk==12000000)
+	{
+		dev->csi_clk_src=clk_get(NULL,"hosc");
+		if (dev->csi_clk_src == NULL) {
+       	csi_err("get csi1 hosc source clk error!\n");
+			return -1;
+    }
+  }
+  else
+  {
+		dev->csi_clk_src=clk_get(NULL,"video_pll1");
+		if (dev->csi_clk_src == NULL) {
+       	csi_err("get csi1 video pll1 source clk error!\n");
+			return -1;
+    }
+	}
+
+	dev->csi_module_clk=clk_get(NULL,"csi1");
+	if(dev->csi_module_clk == NULL) {
+       	csi_err("get csi1 module clk error!\n");
+		return -1;
+    }
+
+	ret = clk_set_parent(dev->csi_module_clk, dev->csi_clk_src);
+	if (ret == -1) {
+        csi_err(" csi set parent failed \n");
+	    return -1;
+    }
+
+	clk_put(dev->csi_clk_src);
+
+	ret = clk_set_rate(dev->csi_module_clk,dev->ccm_info->mclk);
+	if (ret == -1) {
+        csi_err("set csi1 module clock error\n");
+		return -1;
+   	}
+
+//	dev->csi_isp_src_clk=clk_get(NULL,"video_pll0");
+//	if (dev->csi_isp_src_clk == NULL) {
+//       	csi_err("get csi_isp source clk error!\n");
+//		return -1;
+//    }
+//
+//  dev->csi_isp_clk=clk_get(NULL,"csi_isp");
+//	if(dev->csi_isp_clk == NULL) {
+//       	csi_err("get csi_isp clk error!\n");
+//		return -1;
+//    }
+//
+//	ret = clk_set_parent(dev->csi_isp_clk, dev->csi_isp_src_clk);
+//	if (ret == -1) {
+//        csi_err(" csi_isp set parent failed \n");
+//	    return -1;
+//    }
+//
+//	clk_put(dev->csi_isp_src_clk);
+//
+//  ret = clk_set_rate(dev->csi_isp_clk, CSI_ISP_RATE);
+//	if (ret == -1) {
+//        csi_err("set csi_isp clock error\n");
+//		return -1;
+//   	}
+
+	dev->csi_dram_clk = clk_get(NULL, "sdram_csi1");
+	if (dev->csi_dram_clk == NULL) {
+       	csi_err("get csi1 dram clk error!\n");
+		return -1;
+    }
+
+	return 0;
+}
+
+static int csi_clk_out_set(struct csi_dev *dev)
+{
+	int ret;
+	ret = clk_set_rate(dev->csi_module_clk, dev->ccm_info->mclk);
+	if (ret == -1) {
+		csi_err("set csi1 module clock error\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void csi_reset_enable(struct csi_dev *dev)
+{
+	clk_reset(dev->csi_module_clk, 1);
+}
+
+static void csi_reset_disable(struct csi_dev *dev)
+{
+	clk_reset(dev->csi_module_clk, 0);
+}
+
+static int csi_clk_enable(struct csi_dev *dev)
+{
+	clk_enable(dev->csi_ahb_clk);
+//	clk_enable(dev->csi_module_clk);
+	clk_enable(dev->csi_isp_clk);
+	clk_enable(dev->csi_dram_clk);
+
+	return 0;
+}
+
+static int csi_clk_disable(struct csi_dev *dev)
+{
+	clk_disable(dev->csi_ahb_clk);
+//	clk_disable(dev->csi_module_clk);
+	clk_disable(dev->csi_isp_clk);
+	clk_disable(dev->csi_dram_clk);
+
+	return 0;
+}
+
+static int csi_clk_release(struct csi_dev *dev)
+{
+	clk_put(dev->csi_ahb_clk);
+    dev->csi_ahb_clk = NULL;
+
+	clk_put(dev->csi_module_clk);
+    dev->csi_module_clk = NULL;
+
+	clk_put(dev->csi_dram_clk);
+    dev->csi_dram_clk = NULL;
+
+	return 0;
+}
+
+static int inline csi_is_generating(struct csi_dev *dev)
+{
+	return test_bit(0, &dev->generating);
+}
+
+static void inline csi_start_generating(struct csi_dev *dev)
+{
+	 set_bit(0, &dev->generating);
+	 return;
+}
+
+static void inline csi_stop_generating(struct csi_dev *dev)
+{
+	 first_flag = 0;
+	 clear_bit(0, &dev->generating);
+	 return;
+}
+
+static int update_ccm_info(struct csi_dev *dev , struct ccm_config *ccm_cfg)
+{
+   dev->sd = ccm_cfg->sd;
+   dev->ccm_info = &ccm_cfg->ccm_info;
+   dev->interface = ccm_cfg->interface;
+	 dev->vflip = ccm_cfg->vflip;
+	 dev->hflip = ccm_cfg->hflip;
+	 dev->flash_pol = ccm_cfg->flash_pol;
+	 dev->iovdd = ccm_cfg->iovdd;
+	 dev->avdd = ccm_cfg->avdd;
+	 dev->dvdd = ccm_cfg->dvdd;
+	 return v4l2_subdev_call(dev->sd,core,ioctl,CSI_SUBDEV_CMD_SET_INFO,dev->ccm_info);
+}
+
+static irqreturn_t csi_isr(int irq, void *priv)
+{
+	struct csi_buffer *buf;
+	struct csi_dev *dev = (struct csi_dev *)priv;
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+//	__csi_int_status_t * status;
+
+	csi_dbg(3,"csi_isr\n");
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+
+	spin_lock(&dev->slock);
+
+	if (first_flag == 0) {
+		first_flag=1;
+		goto set_next_addr;
+	}
+
+	if (list_empty(&dma_q->active)) {
+		csi_err("No active queue to serve\n");
+		goto unlock;
+	}
+
+	buf = list_entry(dma_q->active.next,struct csi_buffer, vb.queue);
+	csi_dbg(3,"buf ptr=%p\n",buf);
+
+	/* Nobody is waiting on this buffer*/
+
+	if (!waitqueue_active(&buf->vb.done)) {
+		csi_dbg(1," Nobody is waiting on this buffer,buf = 0x%p\n",buf);
+	}
+
+	list_del(&buf->vb.queue);
+
+	do_gettimeofday(&buf->vb.ts);
+	buf->vb.field_count++;
+
+	dev->ms += jiffies_to_msecs(jiffies - dev->jiffies);
+	dev->jiffies = jiffies;
+
+	buf->vb.state = VIDEOBUF_DONE;
+	wake_up(&buf->vb.done);
+
+	//judge if the frame queue has been written to the last
+	if (list_empty(&dma_q->active)) {
+		csi_dbg(1,"No more free frame\n");
+		goto unlock;
+	}
+
+	if ((&dma_q->active) == dma_q->active.next->next) {
+		csi_dbg(1,"No more free frame on next time\n");
+		goto unlock;
+	}
+
+
+set_next_addr:
+	buf = list_entry(dma_q->active.next->next,struct csi_buffer, vb.queue);
+	csi_set_addr(dev,buf);
+
+unlock:
+	spin_unlock(&dev->slock);
+
+//	bsp_csi_int_get_status(dev, status);
+//	if((status->buf_0_overflow) || (status->buf_1_overflow) || (status->buf_2_overflow))
+//	{
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_0_OVERFLOW);
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_1_OVERFLOW);
+//		bsp_csi_int_clear_status(dev,CSI_INT_BUF_2_OVERFLOW);
+//		csi_err("fifo overflow\n");
+//	}
+//
+//	if((status->hblank_overflow))
+//	{
+//		bsp_csi_int_clear_status(dev,CSI_INT_HBLANK_OVERFLOW);
+//		csi_err("hblank overflow\n");
+//	}
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_enable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Videobuf operations
+ */
+static int buffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)
+{
+	struct csi_dev *dev = vq->priv_data;
+
+	csi_dbg(1,"buffer_setup\n");
+
+	if(dev->fmt->input_fmt == CSI_RAW)
+	{
+		switch(dev->fmt->fourcc) {
+			case 	V4L2_PIX_FMT_YUYV:
+			case	V4L2_PIX_FMT_YVYU:
+			case	V4L2_PIX_FMT_UYVY:
+			case	V4L2_PIX_FMT_VYUY:
+				*size = dev->width * dev->height * 2;
+				break;
+			default:
+				*size = dev->width * dev->height;
+				break;
+		}
+	}
+	else if(dev->fmt->input_fmt == CSI_BAYER)
+	{
+		*size = dev->width * dev->height;
+	}
+	else if(dev->fmt->input_fmt == CSI_CCIR656)
+	{
+		//TODO
+	}
+	else if(dev->fmt->input_fmt == CSI_YUV422)
+	{
+		switch (dev->fmt->output_fmt) {
+			case 	CSI_PLANAR_YUV422:
+			case	CSI_UV_CB_YUV422:
+			case 	CSI_MB_YUV422:
+				*size = dev->width * dev->height * 2;
+				break;
+
+			case CSI_PLANAR_YUV420:
+			case CSI_UV_CB_YUV420:
+			case CSI_MB_YUV420:
+				*size = dev->width * dev->height * 3/2;
+				break;
+
+			default:
+				*size = dev->width * dev->height * 2;
+				break;
+		}
+	}
+	else
+	{
+		*size = dev->width * dev->height * 2;
+	}
+
+	dev->frame_size = *size;
+
+	if (*count < 3) {
+		*count = 3;
+		csi_err("buffer count is invalid, set to 3\n");
+	} else if(*count > 5) {
+		*count = 5;
+		csi_err("buffer count is invalid, set to 5\n");
+	}
+
+	while (*size * *count > CSI_MAX_FRAME_MEM) {
+		(*count)--;
+	}
+	csi_print("%s, buffer count=%d, size=%d\n", __func__,*count, *size);
+
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct csi_buffer *buf)
+{
+	csi_dbg(1,"%s, state: %i\n", __func__, buf->vb.state);
+
+#ifdef USE_DMA_CONTIG
+	videobuf_dma_contig_free(vq, &buf->vb);
+#endif
+
+	csi_dbg(1,"free_buffer: freed\n");
+
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+static int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
+						  enum v4l2_field field)
+{
+	struct csi_dev *dev = vq->priv_data;
+	struct csi_buffer *buf = container_of(vb, struct csi_buffer, vb);
+	int rc;
+
+	csi_dbg(1,"buffer_prepare\n");
+
+	BUG_ON(NULL == dev->fmt);
+
+	if (dev->width  < MIN_WIDTH || dev->width  > MAX_WIDTH ||
+	    dev->height < MIN_HEIGHT || dev->height > MAX_HEIGHT) {
+		return -EINVAL;
+	}
+
+	buf->vb.size = dev->frame_size;
+
+	if (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size) {
+		return -EINVAL;
+	}
+
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = dev->fmt;
+	buf->vb.width  = dev->width;
+	buf->vb.height = dev->height;
+	buf->vb.field  = field;
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0) {
+			goto fail;
+		}
+	}
+
+	vb->boff= videobuf_to_dma_contig(vb);
+	buf->vb.state = VIDEOBUF_PREPARED;
+
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct csi_dev *dev = vq->priv_data;
+	struct csi_buffer *buf = container_of(vb, struct csi_buffer, vb);
+	struct csi_dmaqueue *vidq = &dev->vidq;
+
+	csi_dbg(1,"buffer_queue\n");
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+			   struct videobuf_buffer *vb)
+{
+	struct csi_buffer *buf  = container_of(vb, struct csi_buffer, vb);
+
+	csi_dbg(1,"buffer_release\n");
+
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops csi_video_qops = {
+	.buf_setup    = buffer_setup,
+	.buf_prepare  = buffer_prepare,
+	.buf_queue    = buffer_queue,
+	.buf_release  = buffer_release,
+};
+
+/*
+ * IOCTL vidioc handling
+ */
+static int vidioc_querycap(struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	strcpy(cap->driver, "sun4i_csi");
+	strcpy(cap->card, "sun4i_csi");
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
+
+	cap->version = CSI_VERSION;
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING | \
+			    V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	struct csi_fmt *fmt;
+
+	csi_dbg(0,"vidioc_enum_fmt_vid_cap\n");
+
+	if (f->index > ARRAY_SIZE(formats)-1) {
+		return -EINVAL;
+	}
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	f->fmt.pix.width        = dev->width;
+	f->fmt.pix.height       = dev->height;
+	f->fmt.pix.field        = dev->vb_vidq.field;
+	f->fmt.pix.pixelformat  = dev->fmt->fourcc;
+	f->fmt.pix.bytesperline = (f->fmt.pix.width * dev->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage    = f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return 0;
+}
+
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+			struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_fmt *csi_fmt;
+	struct v4l2_mbus_framefmt ccm_fmt;//linux-3.0
+	int ret = 0;
+
+	csi_dbg(0,"vidioc_try_fmt_vid_cap\n");
+
+	/*judge the resolution*/
+	if(f->fmt.pix.width > MAX_WIDTH || f->fmt.pix.height > MAX_HEIGHT) {
+		csi_err("size is too large,automatically set to maximum!\n");
+		f->fmt.pix.width = MAX_WIDTH;
+		f->fmt.pix.height = MAX_HEIGHT;
+	}
+
+	csi_fmt = get_format(f);
+	if (!csi_fmt) {
+		csi_err("Fourcc format (0x%08x) invalid.\n",f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	ccm_fmt.code = csi_fmt->ccm_fmt;//linux-3.0
+	ccm_fmt.width = f->fmt.pix.width;//linux-3.0
+	ccm_fmt.height = f->fmt.pix.height;//linux-3.0
+
+	ret = v4l2_subdev_call(dev->sd,video,try_mbus_fmt,&ccm_fmt);//linux-3.0
+	if (ret < 0) {
+		csi_err("v4l2 sub device try_fmt error!\n");
+		return ret;
+	}
+
+	//info got from module
+	f->fmt.pix.width = ccm_fmt.width;//linux-3.0
+	f->fmt.pix.height = ccm_fmt.height;//linux-3.0
+//	f->fmt.pix.bytesperline = ccm_fmt.fmt.pix.bytesperline;//linux-3.0
+//	f->fmt.pix.sizeimage = ccm_fmt.fmt.pix.sizeimage;//linux-3.0
+
+	csi_dbg(0,"pix->width=%d\n",f->fmt.pix.width);
+	csi_dbg(0,"pix->height=%d\n",f->fmt.pix.height);
+
+	return 0;
+}
+
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct videobuf_queue *q = &dev->vb_vidq;
+	int ret,width_buf,height_buf,width_len;
+	struct v4l2_mbus_framefmt ccm_fmt;//linux-3.0
+	struct csi_fmt *csi_fmt;
+
+	csi_dbg(0,"vidioc_s_fmt_vid_cap\n");
+
+	if (csi_is_generating(dev)) {
+		csi_err("%s device busy\n", __func__);
+		return -EBUSY;
+	}
+
+	mutex_lock(&q->vb_lock);
+
+	ret = vidioc_try_fmt_vid_cap(file, priv, f);
+	if (ret < 0) {
+		csi_err("try format failed!\n");
+		goto out;
+	}
+
+	csi_fmt = get_format(f);
+	if (!csi_fmt) {
+		csi_err("Fourcc format (0x%08x) invalid.\n",f->fmt.pix.pixelformat);
+		ret	= -EINVAL;
+		goto out;
+	}
+
+	ccm_fmt.code = csi_fmt->ccm_fmt;//linux-3.0
+	ccm_fmt.width = f->fmt.pix.width;//linux-3.0
+	ccm_fmt.height = f->fmt.pix.width;//linux-3.0
+
+	ret = v4l2_subdev_call(dev->sd,video,s_mbus_fmt,&ccm_fmt);//linux-3.0
+	if (ret < 0) {
+		csi_err("v4l2 sub device s_fmt error!\n");
+		goto out;
+	}
+
+	//save the current format info
+	dev->fmt = csi_fmt;
+	dev->vb_vidq.field = f->fmt.pix.field;
+	dev->width  = f->fmt.pix.width;
+	dev->height = f->fmt.pix.height;
+
+	//set format
+	dev->csi_mode.output_fmt = dev->fmt->output_fmt;
+	dev->csi_mode.input_fmt = dev->fmt->input_fmt;
+
+	switch(dev->fmt->ccm_fmt) {
+	case V4L2_MBUS_FMT_YUYV8_2X8://linux-3.0
+		if ((dev->fmt->fourcc == V4L2_PIX_FMT_NV61) || (dev->fmt->fourcc == V4L2_PIX_FMT_NV21))
+			dev->csi_mode.seq = CSI_YVYU;
+		else
+			dev->csi_mode.seq = CSI_YUYV;
+		break;
+	case V4L2_MBUS_FMT_YVYU8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_YVYU;
+		break;
+	case V4L2_MBUS_FMT_UYVY8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_UYVY;
+		break;
+	case V4L2_MBUS_FMT_VYUY8_2X8://linux-3.0
+		dev->csi_mode.seq = CSI_VYUY;
+		break;
+	default:
+		dev->csi_mode.seq = CSI_YUYV;
+		break;
+	}
+
+	switch(dev->fmt->input_fmt){
+	case CSI_RAW:
+		if ( (dev->fmt->fourcc == V4L2_PIX_FMT_YUYV) || (dev->fmt->fourcc == V4L2_PIX_FMT_YVYU) || \
+				 (dev->fmt->fourcc == V4L2_PIX_FMT_UYVY) || (dev->fmt->fourcc == V4L2_PIX_FMT_VYUY)) {
+
+			width_len  = dev->width*2;
+			width_buf = dev->width*2;
+			height_buf = dev->height;
+
+		} else {
+			width_len  = dev->width;
+			width_buf = dev->width;
+			height_buf = dev->height;
+		}
+		break;
+	case CSI_BAYER:
+		width_len  = dev->width;
+		width_buf = dev->width;
+		height_buf = dev->height;
+		break;
+	case CSI_CCIR656://TODO
+	case CSI_YUV422:
+		width_len  = dev->width;
+		width_buf = dev->width*2;
+		height_buf = dev->height;
+		break;
+	default:
+		width_len  = dev->width;
+		width_buf = dev->width*2;
+		height_buf = dev->height;
+		break;
+	}
+
+	bsp_csi_configure(dev,&dev->csi_mode);
+	//horizontal and vertical offset are constant zero
+	bsp_csi_set_size(dev,width_buf,height_buf,width_len);
+
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+	return ret;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+			  struct v4l2_requestbuffers *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	csi_dbg(0,"vidioc_reqbufs\n");
+
+	return videobuf_reqbufs(&dev->vb_vidq, p);
+}
+
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_querybuf(&dev->vb_vidq, p);
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_qbuf(&dev->vb_vidq, p);
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_dqbuf(&dev->vb_vidq, p, file->f_flags & O_NONBLOCK);
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return videobuf_cgmbuf(&dev->vb_vidq, mbuf, 8);
+}
+#endif
+
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+	struct csi_buffer *buf;
+
+	int ret;
+
+	csi_dbg(0,"video stream on\n");
+	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return -EINVAL;
+	}
+
+	if (csi_is_generating(dev)) {
+		csi_err("stream has been already on\n");
+		return 0;
+	}
+
+	/* Resets frame counters */
+	dev->ms = 0;
+	dev->jiffies = jiffies;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	ret = videobuf_streamon(&dev->vb_vidq);
+	if (ret) {
+		return ret;
+	}
+
+	buf = list_entry(dma_q->active.next,struct csi_buffer, vb.queue);
+	csi_set_addr(dev,buf);
+
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_enable(dev, CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_capture_video_start(dev);
+	csi_start_generating(dev);
+
+	return 0;
+}
+
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct csi_dmaqueue *dma_q = &dev->vidq;
+	int ret;
+
+	csi_dbg(0,"video stream off\n");
+
+	if (!csi_is_generating(dev)) {
+		csi_err("stream has been already off\n");
+		return 0;
+	}
+
+	csi_stop_generating(dev);
+
+	/* Resets frame counters */
+	dev->ms = 0;
+	dev->jiffies = jiffies;
+
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	bsp_csi_capture_video_stop(dev);
+
+	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		return -EINVAL;
+	}
+
+	ret = videobuf_streamoff(&dev->vb_vidq);
+	if (ret!=0) {
+		csi_err("videobu_streamoff error!\n");
+		return ret;
+	}
+
+	if (ret!=0) {
+		csi_err("videobuf_mmap_free error!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static int vidioc_enum_input(struct file *file, void *priv,
+				struct v4l2_input *inp)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	if (inp->index > dev->dev_qty-1) {
+		csi_err("input index invalid!\n");
+		return -EINVAL;
+	}
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	*i = dev->input;
+	return 0;
+}
+
+static int internal_s_input(struct csi_dev *dev, unsigned int i)
+{
+	struct v4l2_control ctrl;
+	int ret;
+
+	if (i > dev->dev_qty-1) {
+		csi_err("set input error!\n");
+		return -EINVAL;
+	}
+
+	if (i == dev->input)
+		return 0;
+
+	csi_dbg(0,"input_num = %d\n",i);
+
+//	spin_lock(&dev->slock);
+
+	/*Power down current device*/
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	if(ret < 0)
+		goto altend;
+
+	/* Alternate the device info and select target device*/
+  ret = update_ccm_info(dev, dev->ccm_cfg[i]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when selecting input!,input_num = %d\n",i);
+		goto recover;
+	}
+
+	/* change the csi setting */
+	csi_dbg(0,"dev->ccm_info->vref = %d\n",dev->ccm_info->vref);
+	csi_dbg(0,"dev->ccm_info->href = %d\n",dev->ccm_info->href);
+	csi_dbg(0,"dev->ccm_info->clock = %d\n",dev->ccm_info->clock);
+	csi_dbg(0,"dev->ccm_info->mclk = %d\n",dev->ccm_info->mclk);
+
+	dev->csi_mode.vref       = dev->ccm_info->vref;
+  dev->csi_mode.href       = dev->ccm_info->href;
+  dev->csi_mode.clock      = dev->ccm_info->clock;
+
+//  bsp_csi_configure(dev,&dev->csi_mode);
+	csi_clk_out_set(dev);
+
+	/* Initial target device */
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_OFF);
+	if (ret!=0) {
+	  csi_err("sensor standby off error when selecting target device!\n");
+	  goto recover;
+	}
+	ret = v4l2_subdev_call(dev->sd,core, init, 0);
+	if (ret!=0) {
+		csi_err("sensor initial error when selecting target device!\n");
+		goto recover;
+	}
+
+	/* Set the initial flip */
+	ctrl.id = V4L2_CID_VFLIP;
+	ctrl.value = dev->vflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_VFLIP error when vidioc_s_input!input_num = %d\n",i);
+	}
+
+	ctrl.id = V4L2_CID_HFLIP;
+	ctrl.value = dev->hflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_HFLIP error when vidioc_s_input!input_num = %d\n",i);
+	}
+
+	dev->input = i;
+  ret = 0;
+
+altend:
+//  spin_unlock(&dev->slock);
+	return ret;
+
+recover:
+	/*Power down target device*/
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	if(ret < 0)
+		goto altend;
+
+	/* Alternate the device info and select the current device*/
+  ret = update_ccm_info(dev, dev->ccm_cfg[dev->input]);
+  if (ret < 0)
+	{
+		csi_err("Error when set ccm info when selecting input!\n");
+		goto altend;
+	}
+
+	/*Re Initial current device*/
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_OFF);
+	if (ret!=0) {
+	  csi_err("sensor standby off error when selecting back current device!\n");
+	  goto recover;
+	}
+
+	ret = v4l2_subdev_call(dev->sd,core, init, 0);
+	if (ret!=0) {
+		csi_err("sensor recovering error when selecting back current device!\n");
+	}
+	ret = 0;
+	goto altend;
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+	return internal_s_input(dev , i);
+}
+
+
+static int vidioc_queryctrl(struct file *file, void *priv,
+			    struct v4l2_queryctrl *qc)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,core,queryctrl,qc);
+	if (ret < 0)
+		csi_err("v4l2 sub device queryctrl error!\n");
+
+	return ret;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *ctrl)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,core,g_ctrl,ctrl);
+	if (ret < 0)
+		csi_err("v4l2 sub device g_ctrl error!\n");
+
+	return ret;
+}
+
+
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct v4l2_queryctrl qc;
+	int ret;
+
+	qc.id = ctrl->id;
+	ret = vidioc_queryctrl(file, priv, &qc);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
+		return -ERANGE;
+	}
+
+	ret = v4l2_subdev_call(dev->sd,core,s_ctrl,ctrl);
+	if (ret < 0)
+		csi_err("v4l2 sub device s_ctrl error!\n");
+
+	return ret;
+}
+
+static int vidioc_g_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *parms)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,video,g_parm,parms);
+	if (ret < 0)
+		csi_err("v4l2 sub device g_parm error!\n");
+
+	return ret;
+}
+
+static int vidioc_s_parm(struct file *file, void *priv,
+			 struct v4l2_streamparm *parms)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	ret = v4l2_subdev_call(dev->sd,video,s_parm,parms);
+	if (ret < 0)
+		csi_err("v4l2 sub device s_parm error!\n");
+
+	return ret;
+}
+
+
+static ssize_t csi_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
+{
+	struct csi_dev *dev = video_drvdata(file);
+
+//	csi_start_generating(dev);
+	if(csi_is_generating(dev)) {
+		return videobuf_read_stream(&dev->vb_vidq, data, count, ppos, 0,
+					file->f_flags & O_NONBLOCK);
+	} else {
+		csi_err("csi is not generating!\n");
+		return -EINVAL;
+	}
+}
+
+static unsigned int csi_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	struct videobuf_queue *q = &dev->vb_vidq;
+
+//	csi_start_generating(dev);
+	if(csi_is_generating(dev)) {
+		return videobuf_poll_stream(file, q, wait);
+	} else {
+		csi_err("csi is not generating!\n");
+		return -EINVAL;
+	}
+}
+
+static int csi_open(struct file *file)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret,input_num;
+	struct v4l2_control ctrl;
+
+	csi_dbg(0,"csi_open\n");
+
+	if (dev->opened == 1) {
+		csi_err("device open busy\n");
+		return -EBUSY;
+	}
+
+	csi_clk_enable(dev);
+	csi_reset_disable(dev);
+	//open all the device power and set it to standby on
+	for (input_num=dev->dev_qty-1; input_num>=0; input_num--) {
+		/* update target device info and select it*/
+		ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+		if (ret < 0)
+		{
+			csi_err("Error when set ccm info when csi open!\n");
+		}
+
+		dev->csi_mode.vref       = dev->ccm_info->vref;
+	  dev->csi_mode.href       = dev->ccm_info->href;
+	  dev->csi_mode.clock      = dev->ccm_info->clock;
+		csi_clk_out_set(dev);
+
+		ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+	  if (ret!=0) {
+	  	csi_err("sensor CSI_SUBDEV_PWR_ON error at device number %d when csi open!\n",input_num);
+	  }
+
+		ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+		if (ret!=0) {
+	  	csi_err("sensor CSI_SUBDEV_STBY_ON error at device number %d when csi open!\n",input_num);
+	  }
+	}
+
+	dev->input=0;//default input
+
+	bsp_csi_open(dev);
+	bsp_csi_set_offset(dev,0,0);//h and v offset is initialed to zero
+
+	ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_OFF);
+	if (ret!=0) {
+	  csi_err("sensor standby off error when csi open!\n");
+	  return ret;
+	}
+	ret = v4l2_subdev_call(dev->sd,core, init, 0);
+	if (ret!=0) {
+		csi_err("sensor initial error when csi open!\n");
+		return ret;
+	} else {
+		csi_print("sensor initial success when csi open!\n");
+	}
+
+	ctrl.id = V4L2_CID_VFLIP;
+	ctrl.value = dev->vflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_VFLIP error when csi open!\n");
+	}
+
+	ctrl.id = V4L2_CID_HFLIP;
+	ctrl.value = dev->hflip;
+	ret = v4l2_subdev_call(dev->sd,core, s_ctrl, &ctrl);
+	if (ret!=0) {
+		csi_err("sensor sensor_s_ctrl V4L2_CID_HFLIP error when csi open!\n");
+	}
+
+	dev->opened=1;
+	dev->fmt = &formats[5]; //default format
+	return 0;
+}
+
+static int csi_close(struct file *file)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret,input_num;
+
+	csi_dbg(0,"csi_close\n");
+
+	bsp_csi_int_disable(dev,CSI_INT_FRAME_DONE);//CSI_INT_FRAME_DONE
+	//bsp_csi_int_clear_status(dev,CSI_INT_FRAME_DONE);
+
+	bsp_csi_capture_video_stop(dev);
+	bsp_csi_close(dev);
+
+	csi_clk_disable(dev);
+	csi_reset_enable(dev);
+
+
+	videobuf_stop(&dev->vb_vidq);
+	videobuf_mmap_free(&dev->vb_vidq);
+
+	dev->opened=0;
+	csi_stop_generating(dev);
+
+	if(dev->stby_mode == 0) {
+		return v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+	} else {
+
+		//close all the device power
+		for (input_num=0; input_num<dev->dev_qty; input_num++) {
+      /* update target device info and select it */
+      ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+			if (ret < 0)
+			{
+				csi_err("Error when set ccm info when csi_close!\n");
+			}
+
+			ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+		  if (ret!=0) {
+		  	csi_err("sensor power off error at device number %d when csi open!\n",input_num);
+		  	return ret;
+		  }
+		}
+	}
+
+	return 0;
+}
+
+static int csi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct csi_dev *dev = video_drvdata(file);
+	int ret;
+
+	csi_dbg(0,"mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&dev->vb_vidq, vma);
+
+	csi_dbg(0,"vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end - (unsigned long)vma->vm_start,
+		ret);
+	return ret;
+}
+
+static const struct v4l2_file_operations csi_fops = {
+	.owner	  = THIS_MODULE,
+	.open	  = csi_open,
+	.release  = csi_close,
+	.read     = csi_read,
+	.poll	  = csi_poll,
+	.ioctl    = video_ioctl2,
+	.mmap     = csi_mmap,
+};
+
+static const struct v4l2_ioctl_ops csi_ioctl_ops = {
+	.vidioc_querycap          = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_reqbufs           = vidioc_reqbufs,
+	.vidioc_querybuf          = vidioc_querybuf,
+	.vidioc_qbuf              = vidioc_qbuf,
+	.vidioc_dqbuf             = vidioc_dqbuf,
+	.vidioc_enum_input        = vidioc_enum_input,
+	.vidioc_g_input           = vidioc_g_input,
+	.vidioc_s_input           = vidioc_s_input,
+	.vidioc_streamon          = vidioc_streamon,
+	.vidioc_streamoff         = vidioc_streamoff,
+	.vidioc_queryctrl         = vidioc_queryctrl,
+	.vidioc_g_ctrl            = vidioc_g_ctrl,
+	.vidioc_s_ctrl            = vidioc_s_ctrl,
+	.vidioc_g_parm		 			  = vidioc_g_parm,
+	.vidioc_s_parm		  			= vidioc_s_parm,
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf              = vidiocgmbuf,
+#endif
+};
+
+static struct video_device csi_template = {
+	.name		= "csi",
+	.fops       = &csi_fops,
+	.ioctl_ops 	= &csi_ioctl_ops,
+	.release	= video_device_release,
+};
+
+static int fetch_config(struct csi_dev *dev)
+{
+	int input_num,ret;
+
+	/* fetch device quatity issue */
+	ret = script_parser_fetch("csi1_para","csi_dev_qty", &dev->dev_qty , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_dev_qty from sys_config failed\n");
+	}
+
+	/* fetch standby mode */
+	ret = script_parser_fetch("csi1_para","csi_stby_mode", &dev->stby_mode , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_stby_mode from sys_config failed\n");
+	}
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		dev->ccm_cfg[input_num] = &ccm_cfg[input_num];
+		csi_dbg(0,"dev->ccm_cfg[%d] = %p\n",input_num,dev->ccm_cfg[input_num]);
+	}
+
+	if(dev->dev_qty > 0)
+	{
+		dev->ccm_cfg[0]->i2c_addr = i2c_addr;
+		strcpy(dev->ccm_cfg[0]->ccm,ccm);
+
+		/* fetch i2c and module name*/
+		ret = script_parser_fetch("csi1_para","csi_twi_id", &dev->ccm_cfg[0]->twi_id , sizeof(int));
+		if (ret) {
+		}
+
+		ret = strcmp(dev->ccm_cfg[0]->ccm,"");
+		if((dev->ccm_cfg[0]->i2c_addr == 0xff) && (ret == 0))	//when insmod without parm
+		{
+			ret = script_parser_fetch("csi1_para","csi_twi_addr", &dev->ccm_cfg[0]->i2c_addr , sizeof(int));
+			if (ret) {
+				csi_err("fetch csi_twi_addr from sys_config failed\n");
+			}
+
+			ret = script_parser_fetch("csi1_para","csi_mname", (int *)&dev->ccm_cfg[0]->ccm , I2C_NAME_SIZE*sizeof(char));
+			if (ret) {
+				csi_err("fetch csi_mname from sys_config failed\n");
+			}
+		}
+
+		/* fetch interface issue*/
+		ret = script_parser_fetch("csi1_para","csi_if", &dev->ccm_cfg[0]->interface , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_if from sys_config failed\n");
+		}
+
+		/* fetch power issue*/
+
+		ret = script_parser_fetch("csi1_para","csi_iovdd", (int *)&dev->ccm_cfg[0]->iovdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_iovdd from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_avdd", (int *)&dev->ccm_cfg[0]->avdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_avdd from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_dvdd", (int *)&dev->ccm_cfg[0]->dvdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_dvdd from sys_config failed\n");
+		}
+
+		/* fetch flip issue */
+		ret = script_parser_fetch("csi1_para","csi_vflip", &dev->ccm_cfg[0]->vflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 vflip from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_hflip", &dev->ccm_cfg[0]->hflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 hflip from sys_config failed\n");
+		}
+
+		/* fetch flash light issue */
+		ret = script_parser_fetch("csi1_para","csi_flash_pol", &dev->ccm_cfg[0]->flash_pol , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 csi_flash_pol from sys_config failed\n");
+		}
+	}
+
+	if(dev->dev_qty > 1)
+	{
+		dev->ccm_cfg[1]->i2c_addr = i2c_addr_b;
+		strcpy(dev->ccm_cfg[1]->ccm,ccm_b);
+
+		/* fetch i2c and module name*/
+		ret = script_parser_fetch("csi1_para","csi_twi_id_b", &dev->ccm_cfg[1]->twi_id , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_twi_id_b from sys_config failed\n");
+		}
+
+		ret = strcmp(dev->ccm_cfg[1]->ccm,"");
+		if((dev->ccm_cfg[1]->i2c_addr == 0xff) && (ret == 0))	//when insmod without parm
+		{
+			ret = script_parser_fetch("csi1_para","csi_twi_addr_b", &dev->ccm_cfg[1]->i2c_addr , sizeof(int));
+			if (ret) {
+				csi_err("fetch csi_twi_addr_b from sys_config failed\n");
+			}
+
+			ret = script_parser_fetch("csi1_para","csi_mname_b", (int *)&dev->ccm_cfg[1]->ccm , I2C_NAME_SIZE*sizeof(char));
+			if (ret) {
+				csi_err("fetch csi_mname_b from sys_config failed\n");;
+			}
+		}
+
+		/* fetch interface issue*/
+		ret = script_parser_fetch("csi1_para","csi_if_b", &dev->ccm_cfg[1]->interface , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi_if_b from sys_config failed\n");
+		}
+
+		/* fetch power issue*/
+		ret = script_parser_fetch("csi1_para","csi_iovdd_b", (int *)&dev->ccm_cfg[1]->iovdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_iovdd_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_avdd_b", (int *)&dev->ccm_cfg[1]->avdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_avdd_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_dvdd_b", (int *)&dev->ccm_cfg[1]->dvdd_str , 32*sizeof(char));
+		if (ret) {
+			csi_err("fetch csi_dvdd_b from sys_config failed\n");
+		}
+
+		/* fetch flip issue */
+		ret = script_parser_fetch("csi1_para","csi_vflip_b", &dev->ccm_cfg[1]->vflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 vflip_b from sys_config failed\n");
+		}
+
+		ret = script_parser_fetch("csi1_para","csi_hflip_b", &dev->ccm_cfg[1]->hflip , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 hflip_b from sys_config failed\n");
+		}
+
+		/* fetch flash light issue */
+		ret = script_parser_fetch("csi1_para","csi_flash_pol_b", &dev->ccm_cfg[1]->flash_pol , sizeof(int));
+		if (ret) {
+			csi_err("fetch csi1 csi_flash_pol_b from sys_config failed\n");
+		}
+	}
+
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm = %s\n",input_num,dev->ccm_cfg[input_num]->ccm);
+		csi_dbg(0,"dev->ccm_cfg[%d]->twi_id = %x\n",input_num,dev->ccm_cfg[input_num]->twi_id);
+		csi_dbg(0,"dev->ccm_cfg[%d]->i2c_addr = %x\n",input_num,dev->ccm_cfg[input_num]->i2c_addr);
+		csi_dbg(0,"dev->ccm_cfg[%d]->interface = %x\n",input_num,dev->ccm_cfg[input_num]->interface);
+		csi_dbg(0,"dev->ccm_cfg[%d]->vflip = %x\n",input_num,dev->ccm_cfg[input_num]->vflip);
+		csi_dbg(0,"dev->ccm_cfg[%d]->hflip = %x\n",input_num,dev->ccm_cfg[input_num]->hflip);
+		csi_dbg(0,"dev->ccm_cfg[%d]->iovdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->iovdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->avdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->avdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->dvdd_str = %s\n",input_num,dev->ccm_cfg[input_num]->dvdd_str);
+		csi_dbg(0,"dev->ccm_cfg[%d]->flash_pol = %x\n",input_num,dev->ccm_cfg[input_num]->flash_pol);
+	}
+
+	return 0;
+}
+
+static int csi_probe(struct platform_device *pdev)
+{
+	struct csi_dev *dev;
+	struct resource *res;
+	struct video_device *vfd;
+	struct i2c_adapter *i2c_adap;
+	int ret = 0;
+	int input_num;
+
+	csi_dbg(0,"csi_probe\n");
+
+	/*request mem for dev*/
+	dev = kzalloc(sizeof(struct csi_dev), GFP_KERNEL);
+	if (!dev) {
+		csi_err("request dev mem failed!\n");
+		return -ENOMEM;
+	}
+	dev->id = pdev->id;
+	dev->pdev = pdev;
+
+	spin_lock_init(&dev->slock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		csi_err("failed to find the registers\n");
+		ret = -ENOENT;
+		goto err_info;
+	}
+
+	dev->regs_res = request_mem_region(res->start, resource_size(res),
+			dev_name(&pdev->dev));
+	if (!dev->regs_res) {
+		csi_err("failed to obtain register region\n");
+		ret = -ENOENT;
+		goto err_info;
+	}
+
+	dev->regs = ioremap(res->start, resource_size(res));
+	if (!dev->regs) {
+		csi_err("failed to map registers\n");
+		ret = -ENXIO;
+		goto err_req_region;
+	}
+
+
+  /*get irq resource*/
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		csi_err("failed to get IRQ resource\n");
+		ret = -ENXIO;
+		goto err_regs_unmap;
+	}
+
+	dev->irq = res->start;
+
+	ret = request_irq(dev->irq, csi_isr, 0, pdev->name, dev);
+	if (ret) {
+		csi_err("failed to install irq (%d)\n", ret);
+		goto err_clk;
+	}
+
+    /*pin resource*/
+	dev->csi_pin_hd = gpio_request_ex("csi1_para",NULL);
+	if (dev->csi_pin_hd==-1) {
+		csi_err("csi1 pin request error!\n");
+		ret = -ENXIO;
+		goto err_irq;
+	}
+
+    /* v4l2 device register */
+	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
+	if (ret) {
+		csi_err("Error registering v4l2 device\n");
+		goto err_irq;
+
+	}
+
+	dev_set_drvdata(&(pdev)->dev, (dev));
+
+	/* fetch sys_config1 */
+
+	ret = fetch_config(dev);
+	if (ret) {
+		csi_err("Error at fetch_config\n");
+		goto err_irq;
+	}
+
+  /* v4l2 subdev register	*/
+	dev->module_flag = 0;
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+//		if(dev->module_flag)
+//			break;
+
+		if(!strcmp(dev->ccm_cfg[input_num]->ccm,""))
+			break;
+
+		if(dev->module_flag) {
+			dev->ccm_cfg[input_num]->sd = dev->ccm_cfg[input_num-1]->sd;
+			csi_dbg(0,"num = %d , sd_0 = %p,sd_1 = %p\n",input_num,dev->ccm_cfg[input_num]->sd,dev->ccm_cfg[input_num-1]->sd);
+			goto reg_sd;
+		}
+
+		if((dev->dev_qty > 1) && (input_num+1<dev->dev_qty))
+		{
+			if( (!strcmp(dev->ccm_cfg[input_num]->ccm,dev->ccm_cfg[input_num+1]->ccm)))
+				dev->module_flag = 1;
+		}
+
+		i2c_adap = i2c_get_adapter(dev->ccm_cfg[input_num]->twi_id);
+
+		if (i2c_adap == NULL) {
+			csi_err("request i2c adapter failed,input_num = %d\n",input_num);
+			ret = -EINVAL;
+			goto free_dev;//linux-3.0
+		}
+
+		dev->ccm_cfg[input_num]->sd = kmalloc(sizeof(struct v4l2_subdev *),GFP_KERNEL);
+		if (dev->ccm_cfg[input_num]->sd == NULL) {
+			csi_err("unable to allocate memory for subdevice pointers,input_num = %d\n",input_num);
+			ret = -ENOMEM;
+			goto free_dev;//linux-3.0
+		}
+
+		dev_sensor[input_num].addr = (unsigned short)(dev->ccm_cfg[input_num]->i2c_addr>>1);
+		strcpy(dev_sensor[input_num].type,dev->ccm_cfg[input_num]->ccm);
+
+		dev->ccm_cfg[input_num]->sd = v4l2_i2c_new_subdev_board(&dev->v4l2_dev,
+											i2c_adap,
+											//dev_sensor[input_num].type,//linux-3.0
+											&dev_sensor[input_num],
+											NULL);
+reg_sd:
+		if (!dev->ccm_cfg[input_num]->sd) {
+			csi_err("Error registering v4l2 subdevice,input_num = %d\n",input_num);
+			goto free_dev;
+		} else{
+			csi_print("registered sub device,input_num = %d\n",input_num);
+		}
+
+		dev->ccm_cfg[input_num]->ccm_info.mclk = CSI_OUT_RATE;
+		dev->ccm_cfg[input_num]->ccm_info.vref = CSI_LOW;
+		dev->ccm_cfg[input_num]->ccm_info.href = CSI_LOW;
+		dev->ccm_cfg[input_num]->ccm_info.clock = CSI_FALLING;
+
+		ret = v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core,ioctl,CSI_SUBDEV_CMD_GET_INFO,&dev->ccm_cfg[input_num]->ccm_info);
+		if (ret < 0)
+		{
+			csi_err("Error when get ccm info,input_num = %d,use default!\n",input_num);
+		}
+
+		dev->ccm_cfg[input_num]->ccm_info.iocfg = input_num;
+
+		ret = v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core,ioctl,CSI_SUBDEV_CMD_SET_INFO,&dev->ccm_cfg[input_num]->ccm_info);
+		if (ret < 0)
+		{
+			csi_err("Error when set ccm info,input_num = %d,use default!\n",input_num);
+		}
+
+		/*power issue*/
+		dev->ccm_cfg[input_num]->iovdd = NULL;
+		dev->ccm_cfg[input_num]->avdd = NULL;
+		dev->ccm_cfg[input_num]->dvdd = NULL;
+
+		if(strcmp(dev->ccm_cfg[input_num]->iovdd_str,"")) {
+			dev->ccm_cfg[input_num]->iovdd = regulator_get(NULL, dev->ccm_cfg[input_num]->iovdd_str);
+			if (dev->ccm_cfg[input_num]->iovdd == NULL) {
+				csi_err("get regulator csi_iovdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(strcmp(dev->ccm_cfg[input_num]->avdd_str,"")) {
+			dev->ccm_cfg[input_num]->avdd = regulator_get(NULL, dev->ccm_cfg[input_num]->avdd_str);
+			if (dev->ccm_cfg[input_num]->avdd == NULL) {
+				csi_err("get regulator csi_avdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(strcmp(dev->ccm_cfg[input_num]->dvdd_str,"")) {
+			dev->ccm_cfg[input_num]->dvdd = regulator_get(NULL, dev->ccm_cfg[input_num]->dvdd_str);
+			if (dev->ccm_cfg[input_num]->dvdd == NULL) {
+				csi_err("get regulator csi_dvdd error!input_num = %d\n",input_num);
+				goto free_dev;
+			}
+		}
+
+		if(dev->stby_mode == 1) {
+			csi_print("power on and power off camera!\n");
+      ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+      if(ret<0)
+      	csi_err("Error when set ccm info when probe!\n");
+
+			v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+			v4l2_subdev_call(dev->ccm_cfg[input_num]->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+		}
+	}
+
+	for(input_num=0; input_num<dev->dev_qty; input_num++)
+	{
+		csi_dbg(0,"dev->ccm_cfg[%d]->sd = %p\n",input_num,dev->ccm_cfg[input_num]->sd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info = %p\n",input_num,&dev->ccm_cfg[input_num]->ccm_info);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.iocfg = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.iocfg);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.vref = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.vref);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.href = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.href);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.clock = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.clock);
+		csi_dbg(0,"dev->ccm_cfg[%d]->ccm_info.mclk = %d\n",input_num,dev->ccm_cfg[input_num]->ccm_info.mclk);
+		csi_dbg(0,"dev->ccm_cfg[%d]->iovdd = %p\n",input_num,dev->ccm_cfg[input_num]->iovdd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->avdd = %p\n",input_num,dev->ccm_cfg[input_num]->avdd);
+		csi_dbg(0,"dev->ccm_cfg[%d]->dvdd = %p\n",input_num,dev->ccm_cfg[input_num]->dvdd);
+	}
+
+	update_ccm_info(dev, dev->ccm_cfg[0]);
+
+	/*clock resource*/
+	if (csi_clk_get(dev)) {
+		csi_err("csi clock get failed!\n");
+		ret = -ENXIO;
+		goto unreg_dev;
+	}
+
+//	csi_dbg("%s(): csi-%d registered successfully\n",__func__, dev->id);
+
+	/*video device register	*/
+	ret = -ENOMEM;
+	vfd = video_device_alloc();
+	if (!vfd) {
+		goto err_clk;
+	}
+
+	*vfd = csi_template;
+	vfd->v4l2_dev = &dev->v4l2_dev;
+
+	dev_set_name(&vfd->dev, "csi-1");
+	ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
+	if (ret < 0) {
+		goto rel_vdev;
+	}
+	video_set_drvdata(vfd, dev);
+
+	/*add device list*/
+	/* Now that everything is fine, let's add it to device list */
+	list_add_tail(&dev->csi_devlist, &csi_devlist);
+
+	if (video_nr != -1) {
+		video_nr++;
+	}
+	dev->vfd = vfd;
+
+	csi_print("V4L2 device registered as %s\n",video_device_node_name(vfd));
+
+	/*initial video buffer queue*/
+	videobuf_queue_dma_contig_init(&dev->vb_vidq, &csi_video_qops,
+			NULL, &dev->slock, V4L2_BUF_TYPE_VIDEO_CAPTURE,
+			V4L2_FIELD_NONE,
+			sizeof(struct csi_buffer), dev,NULL);//linux-3.0
+
+	/* init video dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	//init_waitqueue_head(&dev->vidq.wq);
+
+	return 0;
+
+rel_vdev:
+	video_device_release(vfd);
+err_clk:
+	csi_clk_release(dev);
+unreg_dev:
+	v4l2_device_unregister(&dev->v4l2_dev);
+free_dev:
+//	kfree(dev);
+err_irq:
+	free_irq(dev->irq, dev);
+err_regs_unmap:
+	iounmap(dev->regs);
+err_req_region:
+	release_resource(dev->regs_res);
+	kfree(dev->regs_res);
+err_info:
+	kfree(dev);
+	csi_err("failed to install\n");
+
+	return ret;
+}
+void csi_dev_release(struct device *dev)
+{
+}
+
+static int csi_release(void)
+{
+	struct csi_dev *dev;
+	struct list_head *list;
+
+	csi_dbg(0,"csi_release\n");
+	while (!list_empty(&csi_devlist))
+	{
+		list = csi_devlist.next;
+		list_del(list);
+		dev = list_entry(list, struct csi_dev, csi_devlist);
+
+		v4l2_info(&dev->v4l2_dev, "unregistering %s\n", video_device_node_name(dev->vfd));
+		video_unregister_device(dev->vfd);
+		csi_clk_release(dev);
+		v4l2_device_unregister(&dev->v4l2_dev);
+		free_irq(dev->irq, dev);
+		iounmap(dev->regs);
+		release_resource(dev->regs_res);
+		kfree(dev->regs_res);
+		kfree(dev);
+	}
+
+	csi_print("csi_release ok!\n");
+	return 0;
+}
+
+static int __devexit csi_remove(struct platform_device *pdev)
+{
+	struct csi_dev *dev;
+	dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+
+	csi_dbg(0,"csi_remove\n");
+
+//	video_device_release(vfd);
+//	csi_clk_release(dev);
+//	free_irq(dev->irq, dev);
+//
+//	iounmap(dev->regs);
+//	release_resource(dev->regs_res);
+//	kfree(dev->regs_res);
+//	kfree(dev);
+	csi_print("csi_remove ok!\n");
+	return 0;
+}
+
+static int csi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+	int ret,input_num;
+
+	csi_print("csi_suspend\n");
+
+	if (dev->opened==1) {
+		csi_clk_disable(dev);
+
+		if(dev->stby_mode == 0) {
+			csi_print("set camera to standby!\n");
+			return v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_STBY_ON);
+		} else {
+			csi_print("set camera to power off!\n");
+			//close all the device power
+			for (input_num=0; input_num<dev->dev_qty; input_num++) {
+        /* update target device info and select it */
+        ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+        if (ret < 0)
+				{
+					csi_err("Error when set ccm info when csi_suspend!\n");
+				}
+
+				ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_OFF);
+			  if (ret!=0) {
+			  	csi_err("sensor power off error at device number %d when csi_suspend!\n",input_num);
+			  	return ret;
+			  }
+			}
+		}
+	}
+	return 0;
+}
+
+static int csi_resume(struct platform_device *pdev)
+{
+	int ret,input_num;
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(&(pdev)->dev);
+
+	csi_print("csi_resume\n");
+
+	if (dev->opened==1) {
+		csi_clk_out_set(dev);
+//		csi_clk_enable(dev);
+		if(dev->stby_mode == 0) {
+			ret = v4l2_subdev_call(dev->sd,core, s_power,CSI_SUBDEV_STBY_OFF);
+			if(ret < 0)
+				return ret;
+			ret = v4l2_subdev_call(dev->sd,core, init, 0);
+			if (ret!=0) {
+				csi_err("sensor initial error when resume from suspend!\n");
+				return ret;
+			} else {
+				csi_print("sensor initial success when resume from suspend!\n");
+			}
+		} else {
+			//open all the device power
+			for (input_num=0; input_num<dev->dev_qty; input_num++) {
+        /* update target device info and select it */
+        ret = update_ccm_info(dev, dev->ccm_cfg[input_num]);
+        if (ret < 0)
+				{
+					csi_err("Error when set ccm info when csi_resume!\n");
+				}
+
+				ret = v4l2_subdev_call(dev->sd,core, s_power, CSI_SUBDEV_PWR_ON);
+			  if (ret!=0) {
+			  	csi_err("sensor power on error at device number %d when csi_resume!\n",input_num);
+			  }
+			}
+
+			/* update target device info and select it */
+			ret = update_ccm_info(dev, dev->ccm_cfg[0]);
+			if (ret < 0)
+			{
+				csi_err("Error when set ccm info when csi_resume!\n");
+			}
+
+			ret = v4l2_subdev_call(dev->sd,core, init,0);
+			if (ret!=0) {
+				csi_err("sensor full initial error when resume from suspend!\n");
+				return ret;
+			} else {
+				csi_print("sensor full initial success when resume from suspend!\n");
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+static struct platform_driver csi_driver = {
+	.probe		= csi_probe,
+	.remove		= __devexit_p(csi_remove),
+	.suspend	= csi_suspend,
+	.resume		= csi_resume,
+	//.id_table	= csi_driver_ids,
+	.driver = {
+		.name	= "sun4i_csi1",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static struct resource csi1_resource[] = {
+	[0] = {
+		.start	= CSI1_REGS_BASE,
+		.end	= CSI1_REGS_BASE + CSI1_REG_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SW_INTC_IRQNO_CSI1,
+		.end	= SW_INTC_IRQNO_CSI1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device csi_device[] = {
+	[0] = {
+	.name           	= "sun4i_csi1",
+    	.id             	= 0,
+	.num_resources		= ARRAY_SIZE(csi1_resource),
+    	.resource       	= csi1_resource,
+	.dev.release      = csi_dev_release,
+	}
+};
+
+static int __init csi_init(void)
+{
+	u32 ret;
+	int csi_used;
+	csi_print("Welcome to CSI driver\n");
+	csi_print("csi_init\n");
+
+	ret = script_parser_fetch("csi1_para","csi_used", &csi_used , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_used from sys_config failed\n");
+		return -1;
+	}
+
+	if(!csi_used)
+	{
+		csi_err("csi_used=0,csi driver is not enabled!\n");
+		return 0;
+	}
+
+	ret = platform_driver_register(&csi_driver);
+	if (ret) {
+		csi_err("platform driver register failed\n");
+		return -1;
+	}
+
+	ret = platform_device_register(&csi_device[0]);
+	if (ret) {
+		csi_err("platform device register failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void __exit csi_exit(void)
+{
+	int csi_used,ret;
+
+	csi_print("csi_exit\n");
+
+	ret = script_parser_fetch("csi1_para","csi_used", &csi_used , sizeof(int));
+	if (ret) {
+		csi_err("fetch csi_used from sys_config failed\n");
+		return;
+	}
+
+	if(csi_used)
+	{
+		csi_release();
+		platform_device_unregister(&csi_device[0]);
+		platform_driver_unregister(&csi_driver);
+	}
+}
+
+module_init(csi_init);
+module_exit(csi_exit);
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("CSI driver for sun4i");
diff --git a/drivers/media/video/sun4i_csi/device/Makefile b/drivers/media/video/sun4i_csi/device/Makefile
new file mode 100644
index 0000000..3878620
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/Makefile
@@ -0,0 +1,12 @@
+obj-$(CONFIG_CSI_OV7670) 					+= ov7670.o
+obj-$(CONFIG_CSI_GT2005)					+= gt2005.o
+obj-$(CONFIG_CSI_GC0308)					+= gc0308.o
+obj-$(CONFIG_CSI_HI704)						+= hi704.o
+obj-$(CONFIG_CSI_SP0838)					+= sp0838.o
+obj-$(CONFIG_CSI_MT9M112)					+= mt9m112.o
+obj-$(CONFIG_CSI_MT9M113)					+= mt9m113.o
+obj-$(CONFIG_CSI_OV2655)					+= ov2655.o
+obj-$(CONFIG_CSI_HI253)						+= hi253.o
+obj-$(CONFIG_CSI_MT9D112)					+= mt9d112.o
+obj-$(CONFIG_CSI_GC0307)					+= gc0307.o
+obj-$(CONFIG_CSI_OV5640)					+= ov5640.o
\ No newline at end of file
diff --git a/drivers/media/video/sun4i_csi/device/gc0307.c b/drivers/media/video/sun4i_csi/device/gc0307.c
new file mode 100644
index 0000000..5a1d023
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/gc0307.c
@@ -0,0 +1,2640 @@
+/*
+ * drivers/media/video/sun4i_csi/device/gc0307.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for GalaxyCore GC0307 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore GC0307 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][GC0307]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][GC0307]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][GC0307]"x,##arg)
+
+#define MCLK (12*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x0307
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 10
+
+/*
+ * The gc0307 sits on i2c with ID 0x42
+ */
+#define I2C_ADDR 0x42
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+static struct regval_list sensor_default_regs[] =
+{
+
+     // Initail Sequence Write In.
+    //========= close output
+{{0x43},{0x00}},
+{{0x44},{0xa2}},
+
+         //========= close some functions
+          // open them after configure their parmameters
+{{0x40},{0x10}},
+{{0x41},{0x00}},
+{{0x42},{0x10}},
+{{0x47},{0x00}},//mode1,
+{{0x48},{0xc1}},//mode2,
+{{0x49},{0x00}},//dither_mode
+{{0x4a},{0x00}},//clock_gating_en
+{{0x4b},{0x00}},//mode_reg3
+{{0x4E},{0x23}},//sync mode
+{{0x4F},{0x01}},//AWB, AEC, every N frame
+
+                        //========= frame timing
+{{0x01},{0x6a}},//HB
+{{0x02},{0x70}},//VB//0c
+{{0x1C},{0x00}},//Vs_st
+{{0x1D},{0x00}},//Vs_et
+{{0x10},{0x00}},//high 4 bits of VB, HB
+{{0x11},{0x05}},//row_tail,  AD_pipe_number
+
+{{0x03},{0x01}},//row_start
+{{0x04},{0x2c}},
+
+              //========= windowing
+{{0x05},{0x00}},//row_start
+{{0x06},{0x00}},
+{{0x07},{0x00}},//col start
+{{0x08},{0x00}},
+{{0x09},{0x01}},//win height
+{{0x0A},{0xE8}},
+{{0x0B},{0x02}},//win width, pixel array only 640
+{{0x0C},{0x80}},
+
+                      //========= analog
+{{0x0D},{0x22}},//rsh_width
+{{0x0E},{0x02}},//CISCTL mode2,
+{{0x0F},{0xb2}},//CISCTL mode1
+
+
+{{0x12},{0x70}},//7 hrst, 6_4 darsg,
+{{0x13},{0x00}},//7 CISCTL_restart, 0 apwd
+{{0x14},{0x00}},//NA
+{{0x15},{0xba}},//7_4 vref
+{{0x16},{0x13}},//5to4 _coln_r,  __1to0__da18
+{{0x17},{0x52}},//opa_r, ref_r, sRef_r
+//{{0x18},{0xc0}},//analog_mode, best case for left band.
+{{0x18},{0x00}},
+
+{{0x1E},{0x0d}},//tsp_width
+{{0x1F},{0x32}},//sh_delay
+
+                          //========= offset
+{{0x47},{0x00}}, //7__test_image, __6__fixed_pga, //__5__auto_DN,__4__CbCr_fix,
+                   //__3to2__dark_sequence, __1__allow_pclk_vcync, __0__LSC_test_image
+{{0x19},{0x06}}, //pga_o
+{{0x1a},{0x06}}, //pga_e
+
+{{0x31},{0x00}}, //4  //pga_oFFset ,   high 8bits of 11bits
+{{0x3B},{0x00}}, //global_oFFset, low 8bits of 11bits
+
+{{0x59},{0x0f}}, //offset_mode
+{{0x58},{0x88}}, //DARK_VALUE_RATIO_G,  DARK_VALUE_RATIO_RB
+{{0x57},{0x08}}, //DARK_CURRENT_RATE
+{{0x56},{0x77}}, //PGA_OFFSET_EVEN_RATIO, PGA_OFFSET_ODD_RATIO
+
+             //========= blk
+{{0x35},{0xd8}}, //blk_mode
+
+{{0x36},{0x40}},
+
+{{0x3C},{0x00}},
+{{0x3D},{0x00}},
+{{0x3E},{0x00}},
+{{0x3F},{0x00}},
+
+{{0xb5},{0x70}},
+{{0xb6},{0x40}},
+{{0xb7},{0x00}},
+{{0xb8},{0x38}},
+{{0xb9},{0xc3}},
+{{0xba},{0x0f}},
+
+{{0x7e},{0x45}},
+{{0x7f},{0x66}},
+
+{{0x5c},{0x48}},//78
+{{0x5d},{0x58}},//88
+
+
+               //========= manual_gain
+{{0x61},{0x80}},//manual_gain_g1
+{{0x63},{0x80}},//manual_gain_r
+{{0x65},{0x98}},//manual_gai_b, 0xa0=1.25, 0x98=1.1875
+{{0x67},{0x80}},//manual_gain_g2
+{{0x68},{0x18}},//global_manual_gain   2.4bits
+
+                 //=========CC _R
+{{0x69},{0x58}}, //54//58
+{{0x6A},{0xf6}}, //ff
+{{0x6B},{0xfb}}, //fe
+{{0x6C},{0xf4}}, //ff
+{{0x6D},{0x5a}}, //5f
+{{0x6E},{0xe6}}, //e1
+
+{{0x6f},{0x00}},
+
+           //=========lsc
+{{0x70},{0x14}},
+{{0x71},{0x1c}},
+{{0x72},{0x20}},
+
+{{0x73},{0x10}},
+{{0x74},{0x3c}},//480/8
+{{0x75},{0x52}},// 640/8
+
+                 //=========dn
+{{0x7d},{0x2f}}, //dn_mode
+{{0x80},{0x0c}},//when auto_dn, check 7e,7f
+{{0x81},{0x0c}},
+{{0x82},{0x44}},
+
+                   //dd
+{{0x83},{0x18}}, //DD_TH1
+{{0x84},{0x18}}, //DD_TH2
+{{0x85},{0x04}}, //DD_TH3
+{{0x87},{0x34}}, //32 b DNDD_low_range X16,  DNDD_low_range_C_weight_center
+
+
+               //=========intp-ee
+{{0x88},{0x04}},
+{{0x89},{0x01}},
+{{0x8a},{0x50}},//60
+{{0x8b},{0x50}},//60
+{{0x8c},{0x07}},
+
+{{0x50},{0x0c}},
+{{0x5f},{0x3c}},
+
+{{0x8e},{0x02}},
+{{0x86},{0x02}},
+
+{{0x51},{0x20}},
+{{0x52},{0x08}},
+{{0x53},{0x00}},
+
+
+              //========= YCP
+                   //contrast_center
+{{0x77},{0x80}},//contrast_center
+{{0x78},{0x00}},//fixed_Cb
+{{0x79},{0x00}},//fixed_Cr
+{{0x7a},{0x00}},//luma_offset
+{{0x7b},{0x40}},//hue_cos
+{{0x7c},{0x00}},//hue_sin
+
+            //saturation
+{{0xa0},{0x40}},//global_saturation
+{{0xa1},{0x40}},//luma_contrast
+{{0xa2},{0x34}},//saturation_Cb//0x34
+{{0xa3},{0x32}},// 34  saturation_Cr//0x34
+
+{{0xa4},{0xc8}},
+{{0xa5},{0x02}},
+{{0xa6},{0x28}},
+{{0xa7},{0x02}},
+
+          //skin
+{{0xa8},{0xee}},
+{{0xa9},{0x12}},
+{{0xaa},{0x01}},
+{{0xab},{0x20}},
+{{0xac},{0xf0}},
+{{0xad},{0x10}},
+
+             //========= ABS
+{{0xae},{0x18}},//  black_pixel_target_number
+{{0xaf},{0x74}},
+{{0xb0},{0xe0}},
+{{0xb1},{0x20}},
+{{0xb2},{0x6c}},
+{{0xb3},{0x40}},
+{{0xb4},{0x04}},
+
+               //========= AWB
+{{0xbb},{0x42}},
+{{0xbc},{0x60}},
+{{0xbd},{0x50}},
+{{0xbe},{0x50}},
+
+{{0xbf},{0x0c}},
+{{0xc0},{0x06}},
+{{0xc1},{0x60}},
+{{0xc2},{0xf1}}, //f4
+{{0xc3},{0x40}},
+{{0xc4},{0x1c}},//18
+{{0xc5},{0x56}},
+{{0xc6},{0x1d}},
+
+{{0xca},{0x70}},//0x70
+{{0xcb},{0x70}},//0x70
+{{0xcc},{0x78}},//0x78
+
+{{0xcd},{0x80}},//R_ratio
+{{0xce},{0x80}},//G_ratio  , cold_white white
+{{0xcf},{0x80}},//B_ratio
+
+                   //=========  aecT
+{{0x20},{0x06}},//02
+{{0x21},{0xc0}},
+{{0x22},{0x40}},
+{{0x23},{0x88}},
+{{0x24},{0x96}},
+{{0x25},{0x30}},
+{{0x26},{0xd0}},
+{{0x27},{0x00}},
+
+
+    /////23 M
+{{0x28},{0x02}},//AEC_exp_level_1bit11to8
+{{0x29},{0x58}},//AEC_exp_level_1bit7to0
+{{0x2a},{0x02}},//AEC_exp_level_2bit11to8
+{{0x2b},{0x58}},//AEC_exp_level_2bit7to0
+{{0x2c},{0x02}},//AEC_exp_level_3bit11to8   659 - 8FPS,  8ca - 6FPS  //
+{{0x2d},{0x58}},//AEC_exp_level_3bit7to0
+{{0x2e},{0x02}},//AEC_exp_level_4bit11to8   4FPS
+{{0x2f},{0xee}},//AEC_exp_level_4bit7to0
+
+{{0x30},{0x20}},
+{{0x31},{0x00}},
+{{0x32},{0x1c}},
+{{0x33},{0x90}},
+{{0x34},{0x10}},
+
+{{0xd0},{0x34}},//[2]  1  before gamma,  0 after gamma
+
+{{0xd1},{0x50}},//AEC_target_Y//0x50
+{{0xd2},{0x61}},//f2
+{{0xd4},{0x4b}},//96
+{{0xd5},{0x01}},// 10
+{{0xd6},{0x4b}},//antiflicker_step //96
+{{0xd7},{0x03}},//AEC_exp_time_min //10
+{{0xd8},{0x02}},
+
+{{0xdd},{0x12}},
+
+         //========= measure window
+{{0xe0},{0x03}},
+{{0xe1},{0x02}},
+{{0xe2},{0x27}},
+{{0xe3},{0x1e}},
+{{0xe8},{0x3b}},
+{{0xe9},{0x6e}},
+{{0xea},{0x2c}},
+{{0xeb},{0x50}},
+{{0xec},{0x73}},
+
+              //========= close_frame
+{{0xed},{0x00}},//close_frame_num1 ,can be use to reduce FPS
+{{0xee},{0x00}},//close_frame_num2
+{{0xef},{0x00}},//close_frame_num
+
+        // page1
+{{0xf0},{0x01}},//select page1
+
+{{0x00},{0x20}},
+{{0x01},{0x20}},
+{{0x02},{0x20}},
+{{0x03},{0x20}},
+{{0x04},{0x78}},
+{{0x05},{0x78}},
+{{0x06},{0x78}},
+{{0x07},{0x78}},
+
+
+
+{{0x10},{0x04}},
+{{0x11},{0x04}},
+{{0x12},{0x04}},
+{{0x13},{0x04}},
+{{0x14},{0x01}},
+{{0x15},{0x01}},
+{{0x16},{0x01}},
+{{0x17},{0x01}},
+
+
+{{0x20},{0x00}},
+{{0x21},{0x00}},
+{{0x22},{0x00}},
+{{0x23},{0x00}},
+{{0x24},{0x00}},
+{{0x25},{0x00}},
+{{0x26},{0x00}},
+{{0x27},{0x00}},
+
+{{0x40},{0x11}},
+
+       //=============================lscP
+{{0x45},{0x06}},
+{{0x46},{0x06}},
+{{0x47},{0x05}},
+
+{{0x48},{0x04}},
+{{0x49},{0x03}},
+{{0x4a},{0x03}},
+
+
+{{0x62},{0xd8}},
+{{0x63},{0x24}},
+{{0x64},{0x24}},
+{{0x65},{0x24}},
+{{0x66},{0xd8}},
+{{0x67},{0x24}},
+
+{{0x5a},{0x00}},
+{{0x5b},{0x00}},
+{{0x5c},{0x00}},
+{{0x5d},{0x00}},
+{{0x5e},{0x00}},
+{{0x5f},{0x00}},
+
+
+           //============================= ccP
+
+{{0x69},{0x03}},//cc_mode
+
+           //CC_G
+{{0x70},{0x5d}},
+{{0x71},{0xed}},
+{{0x72},{0xff}},
+{{0x73},{0xe5}},
+{{0x74},{0x5f}},
+{{0x75},{0xe6}},
+
+         //CC_B
+{{0x76},{0x41}},
+{{0x77},{0xef}},
+{{0x78},{0xff}},
+{{0x79},{0xff}},
+{{0x7a},{0x5f}},
+{{0x7b},{0xfa}},
+
+
+          //============================= AGP
+
+{{0x7e},{0x00}},
+{{0x7f},{0x30}},   //  00    select gamma
+{{0x80},{0x48}}, //  c8
+{{0x81},{0x06}},
+{{0x82},{0x08}},
+
+
+{{0x83},{0x23}},
+{{0x84},{0x38}},
+{{0x85},{0x4F}},
+{{0x86},{0x61}},
+{{0x87},{0x72}},
+{{0x88},{0x80}},
+{{0x89},{0x8D}},
+{{0x8a},{0xA2}},
+{{0x8b},{0xB2}},
+{{0x8c},{0xC0}},
+{{0x8d},{0xCA}},
+{{0x8e},{0xD3}},
+{{0x8f},{0xDB}},
+{{0x90},{0xE2}},
+{{0x91},{0xED}},
+{{0x92},{0xF6}},
+{{0x93},{0xFD}},
+        /*
+{{0x83},{0x13}}, // ç¸å½äº0x20å¯¹åºçGamma
+{{0x84},{0x23}},
+{{0x85},{0x35}},
+{{0x86},{0x44}},
+{{0x87},{0x53}},
+{{0x88},{0x60}},
+{{0x89},{0x6D}},
+{{0x8a},{0x84}},
+{{0x8b},{0x98}},
+{{0x8c},{0xaa}},
+{{0x8d},{0xb8}},
+{{0x8e},{0xc6}},
+{{0x8f},{0xd1}},
+{{0x90},{0xdb}},
+{{0x91},{0xea}},
+{{0x92},{0xf5}},
+{{0x93},{0xFb}},
+     */
+            //about gamma1 is hex r oct
+{{0x94},{0x04}},
+{{0x95},{0x0E}},
+{{0x96},{0x1B}},
+{{0x97},{0x28}},
+{{0x98},{0x35}},
+{{0x99},{0x41}},
+{{0x9a},{0x4E}},
+{{0x9b},{0x67}},
+{{0x9c},{0x7E}},
+{{0x9d},{0x94}},
+{{0x9e},{0xA7}},
+{{0x9f},{0xBA}},
+{{0xa0},{0xC8}},
+{{0xa1},{0xD4}},
+{{0xa2},{0xE7}},
+{{0xa3},{0xF4}},
+{{0xa4},{0xFA}},
+
+            //========= open functions
+{{0xf0},{0x00}},//set back to page0
+
+{{0x40},{0x7e}},
+{{0x41},{0x2f}},
+{{0x43},{0x40}},
+{{0x44},{0xE2}},
+
+{{0x0f},{0x82}},
+{{0x45},{0x24}},
+{{0x47},{0x20}},
+
+};
+
+static struct regval_list sensor_oe_disable[] =
+{
+	{{0xf0},{0x00}},
+	{{0x44},{0xA2}},
+};
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0xf0},{0x00}},
+//	{{0x41},{0x2b}},
+	{{0xc7},{0x4c}},
+	{{0xc8},{0x40}},
+	{{0xc9},{0x4a}},
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0xf0},{0x00}},
+//	{{0x41},{0x2b}},
+	{{0xc7},{0x5a}},
+	{{0xc8},{0x42}},
+	{{0xc9},{0x40}},
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0xf0},{0x00}},
+//	{{0x41},{0x2b}},
+	{{0xc7},{0x50}},
+	{{0xc8},{0x45}},
+	{{0xc9},{0x40}},
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0xf0},{0x00}},
+//	{{0x41},{0x2b}},
+	{{0xc7},{0x48}},
+	{{0xc8},{0x40}},
+	{{0xc9},{0x5c}},
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0xf0},{0x00}},
+//	{{0x41},{0x2b}},
+	{{0xc7},{0x40}},
+	{{0xc8},{0x42}},
+	{{0xc9},{0x50}},
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0xf0},{0x00}},
+//	{{0x41},{0x2b}},
+	{{0xc7},{0x40}},
+	{{0xc8},{0x54}},
+	{{0xc9},{0x70}},
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+			{{0xf0},{0x00}},
+			{{0x41},{0x2f}},//  3f
+			{{0x40},{0x7e}},
+			{{0x42},{0x10}},
+			{{0x47},{0x2c}},//
+			{{0x48},{0xc3}},
+			{{0x8a},{0x50}},//60
+			{{0x8b},{0x50}},
+			{{0x8c},{0x07}},
+			{{0x50},{0x0c}},
+			{{0x77},{0x80}},
+			{{0xa1},{0x40}},
+			{{0x7a},{0x00}},
+			{{0x78},{0x00}},
+			{{0x79},{0x00}},
+			{{0x7b},{0x40}},
+			{{0x7c},{0x00}},
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+      {{0xf0},{0x00}},
+      {{0x41},{0x2f}},//2f  blackboard
+			{{0x40},{0x7e}},
+			{{0x42},{0x10}},
+			{{0x47},{0x3c}},//2c
+			{{0x48},{0xc3}},
+			{{0x8a},{0x60}},
+			{{0x8b},{0x60}},
+			{{0x8c},{0x07}},
+			{{0x50},{0x0c}},
+			{{0x77},{0x80}},
+			{{0xa1},{0x40}},
+			{{0x7a},{0x00}},
+			{{0x78},{0x00}},
+			{{0x79},{0x00}},
+			{{0x7b},{0x40}},
+			{{0x7c},{0x00}},
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+      {{0xf0},{0x00}},
+      {{0x41},{0x2f}},
+			{{0x40},{0x7e}},
+			{{0x42},{0x10}},
+			{{0x47},{0x3c}},
+			{{0x48},{0xc3}},
+			{{0x8a},{0x60}},
+			{{0x8b},{0x60}},
+			{{0x8c},{0x07}},
+			{{0x50},{0x0c}},
+			{{0x77},{0x80}},
+			{{0xa1},{0x40}},
+			{{0x7a},{0x00}},
+			{{0x78},{0xc0}},
+			{{0x79},{0x20}},
+			{{0x7b},{0x40}},
+			{{0x7c},{0x00}},
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+      {{0xf0},{0x00}},
+      {{0x41},{0x6f}},//[6]
+			{{0x40},{0x7e}},
+			{{0x42},{0x10}},
+			{{0x47},{0x20}},//20
+			{{0x48},{0xc3}},
+			{{0x8a},{0x60}},
+			{{0x8b},{0x60}},
+			{{0x8c},{0x07}},
+			{{0x50},{0x0c}},
+			{{0x77},{0x80}},
+			{{0xa1},{0x40}},
+			{{0x7a},{0x00}},
+			{{0x78},{0x00}},
+			{{0x79},{0x00}},
+			{{0x7b},{0x40}},
+			{{0x7c},{0x00}},
+			{{0x41},{0x6f}},
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	    {{0xf0},{0x00}},
+	    {{0x41},{0x2f}},
+			{{0x40},{0x7e}},
+			{{0x42},{0x10}},
+			{{0x47},{0x3c}},
+			{{0x48},{0xc3}},
+			{{0x8a},{0x60}},
+			{{0x8b},{0x60}},
+			{{0x8c},{0x07}},
+			{{0x50},{0x0c}},
+			{{0x77},{0x80}},
+			{{0xa1},{0x40}},
+			{{0x7a},{0x00}},
+			{{0x78},{0x00}},
+			{{0x79},{0x00}},
+			{{0x7b},{0x40}},
+			{{0x7c},{0x00}},
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	    {{0xf0},{0x00}},
+	    {{0x41},{0x2f}},
+			{{0x40},{0x7e}},
+			{{0x42},{0x10}},
+			{{0x47},{0x2c}},
+			{{0x48},{0xc3}},
+			{{0x8a},{0x60}},
+			{{0x8b},{0x60}},
+			{{0x8c},{0x07}},
+			{{0x50},{0x0c}},
+			{{0x77},{0x80}},
+			{{0xa1},{0x40}},
+			{{0x7a},{0x00}},
+			{{0x78},{0x70}},
+			{{0x79},{0x00}},
+			{{0x7b},{0x3f}},
+			{{0x7c},{0xf5}},
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+			{{0xf0},{0x00}},
+			{{0x41},{0x2f}},
+			{{0x40},{0x7e}},
+			{{0x42},{0x10}},
+			{{0x47},{0x3c}},
+			{{0x48},{0xc3}},
+			{{0x8a},{0x60}},
+			{{0x8b},{0x60}},
+			{{0x8c},{0x07}},
+			{{0x50},{0x0c}},
+			{{0x77},{0x80}},
+			{{0xa1},{0x40}},
+			{{0x7a},{0x00}},
+			{{0x78},{0xc0}},
+			{{0x79},{0xc0}},
+			{{0x7b},{0x40}},
+			{{0x7c},{0x00}},
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0x00}},
+	{{0xd1},{0x50}},
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0xd0}},
+	{{0xd1},{0x38}},
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0xe0}},
+	{{0xd1},{0x40}},
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0xf0}},
+	{{0xd1},{0x48}},
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0x00}},
+	{{0xd1},{0x50}},
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0x00}},
+	{{0xd1},{0x50}},
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0x20}},
+	{{0xd1},{0x58}},
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0x30}},
+	{{0xd1},{0x60}},
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0xf0},{0x00}},
+	{{0x7a},{0x40}},
+	{{0xd1},{0x68}},
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	//YCbYCr
+	{{0xf0},{0x00}},
+	{{0x44},{0xE2}},
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	//YCrYCb
+	{{0xf0},{0x00}},
+	{{0x44},{0xE3}},
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	//CrYCbY
+	{{0xf0},{0x00}},
+	{{0x44},{0xE1}},
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	//CbYCrY
+	{{0xf0},{0x00}},
+	{{0x44},{0xE0}},
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//	//raw
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_dev_err("sensor_write_err!\n");
+				return ret;
+			}
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+	int ret;
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//disable oe
+			ret = sensor_write_array(sd,sensor_oe_disable,ARRAY_SIZE(sensor_oe_disable));
+			if(ret < 0)
+				csi_dev_err("sensor_oe_disable error\n");
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00; //PAGE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x99)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+	writel(0x0055555d,0xf1c208a4);//debug
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+
+	return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= NULL,
+		.regs_size	= 0,
+		.set_size	= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct v4l2_fract *tpf = &cp->timeperframe;
+	//struct sensor_info *info = to_state(sd);
+	//int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else
+//		div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > CLK_SCALE)
+//		div = CLK_SCALE;
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x0f;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<4);
+	regs.value[0] = regs.value[0]>>4;		//0x0f bit4 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret,i;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs[3];
+
+	regs[0].reg_num[0] = 0xf0;
+	regs[0].value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs[0].reg_num, regs[0].value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs[0].reg_num[0] = 0x0f;
+	regs[1].reg_num[0] = 0x45;
+	regs[2].reg_num[0] = 0x47;
+
+	for(i=0; i<3; i++) {
+		ret = sensor_read(sd, regs[i].reg_num, regs[i].value);
+		if (ret < 0) {
+			csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+			return ret;
+		}
+	}
+
+	switch (value) {
+		case 0:
+		  regs[0].value[0] &= 0xef;
+		  regs[1].value[0] &= 0xfe;
+		  regs[2].value[0] &= 0xfb;
+			break;
+		case 1:
+			regs[0].value[0] |= 0x10;
+		  regs[1].value[0] |= 0x01;
+		  regs[2].value[0] |= 0x04;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	for(i=0; i<3; i++) {
+		ret = sensor_write(sd, regs[i].reg_num, regs[i].value);
+		if (ret < 0) {
+			csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+			return ret;
+		}
+	}
+
+	msleep(100);
+
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x0f;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<5);
+	regs.value[0] = regs.value[0]>>5;		//0x0f bit5 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret,i;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs[3];
+
+	regs[0].reg_num[0] = 0xf0;
+	regs[0].value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs[0].reg_num, regs[0].value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs[0].reg_num[0] = 0x0f;
+	regs[1].reg_num[0] = 0x45;
+	regs[2].reg_num[0] = 0x47;
+
+	for(i=0; i<3; i++) {
+		ret = sensor_read(sd, regs[i].reg_num, regs[i].value);
+		if (ret < 0) {
+			csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+			return ret;
+		}
+	}
+
+	switch (value) {
+		case 0:
+		  regs[0].value[0] &= 0xdf;
+		  regs[1].value[0] &= 0xfd;
+		  regs[2].value[0] &= 0xf7;
+			break;
+		case 1:
+			regs[0].value[0] |= 0x20;
+		  regs[1].value[0] |= 0x02;
+		  regs[2].value[0] |= 0x08;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	for(i=0; i<3; i++) {
+		ret = sensor_write(sd, regs[i].reg_num, regs[i].value);
+		if (ret < 0) {
+			csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+			return ret;
+		}
+	}
+
+	msleep(100);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x41;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x08;
+	if (regs.value[0] == 0x08) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x41;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x08;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0xf7;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	msleep(60);
+
+	info->autoexp = value;
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x41;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<2);
+	regs.value[0] = regs.value[0]>>2;		//0x41 bit2 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x41;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfb;
+		break;
+	case 1:
+		regs.value[0] |= 0x04;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	msleep(60);
+
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+
+	msleep(60);
+
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+
+	msleep(60);
+
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+
+	msleep(60);
+
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "gc0307", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "gc0307",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
+
diff --git a/drivers/media/video/sun4i_csi/device/gc0308.c b/drivers/media/video/sun4i_csi/device/gc0308.c
new file mode 100644
index 0000000..61f8f3b
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/gc0308.c
@@ -0,0 +1,2394 @@
+/*
+ * drivers/media/video/sun4i_csi/device/gc0308.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for GalaxyCore GC0308 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore GC0308 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][GC0308]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][GC0308]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][GC0308]"x,##arg)
+
+#define MCLK_VER_B (49.5*1000*1000)
+#define MCLK_VER_C (24*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x0308
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 10
+
+/*
+ * The gc0308 sits on i2c with ID 0x42
+ */
+#define I2C_ADDR 0x42
+
+/* Registers */
+static enum sw_ic_ver magic_ver;
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK_VER_C,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+static struct regval_list sensor_default_regs_49p5M[] = {
+{{0xfe},{0x00}},
+//MCLK=49.5MHz 10fps
+{{0x01},{0xcb}},   //0x28
+{{0x02},{0x60}},   //0x00
+{{0x0f},{0x18}},	 //0x21
+{{0xe2},{0x00}},
+{{0xe3},{0xFA}},
+{{0xe4},{0x03}},
+{{0xe5},{0xE8}},
+{{0xe6},{0x03}},
+{{0xe7},{0xE8}},
+{{0xe8},{0x03}},
+{{0xe9},{0xE8}},
+{{0xea},{0x09}},
+{{0xeb},{0xC4}},
+};
+
+static struct regval_list sensor_default_regs_24M[] = {
+{{0xfe},{0x00}},
+//MCLK=24MHz 10fps
+{{0x0f},{0x05}},	 //0x00
+{{0x01},{0xe1}},   //0x6a
+{{0x02},{0x70}},   //0x70
+{{0xe2},{0x00}},
+{{0xe3},{0x96}},
+{{0xe4},{0x02}},
+{{0xe5},{0x58}},
+{{0xe6},{0x02}},
+{{0xe7},{0x58}},
+{{0xe8},{0x02}},
+{{0xe9},{0x58}},
+{{0xea},{0x0e}},
+{{0xeb},{0xa6}},
+};
+
+static struct regval_list sensor_default_regs[] = {
+{{0xfe},{0x00}},
+{{0xec},{0x20}},
+{{0x05},{0x00}},
+{{0x06},{0x00}},
+{{0x07},{0x00}},
+{{0x08},{0x00}},
+{{0x09},{0x01}},
+{{0x0a},{0xe8}},
+{{0x0b},{0x02}},
+{{0x0c},{0x88}},
+{{0x0d},{0x02}},
+{{0x0e},{0x02}},
+{{0x10},{0x26}},
+{{0x11},{0x0d}},
+{{0x12},{0x2a}},
+{{0x13},{0x00}},
+{{0x14},{0x11}},
+{{0x15},{0x0a}},
+{{0x16},{0x05}},
+{{0x17},{0x01}},
+{{0x18},{0x44}},
+{{0x19},{0x44}},
+{{0x1a},{0x2a}},
+{{0x1b},{0x00}},
+{{0x1c},{0x49}},
+{{0x1d},{0x9a}},
+{{0x1e},{0x61}},
+{{0x1f},{0x16}},
+{{0x20},{0x7f}},
+{{0x21},{0xfa}},
+{{0x22},{0x57}},
+{{0x24},{0xa2}},	//YCbYCr
+{{0x25},{0x0f}},
+{{0x26},{0x03}}, // 0x01
+{{0x28},{0x00}},
+{{0x2d},{0x0a}},
+{{0x2f},{0x01}},
+{{0x30},{0xf7}},
+{{0x31},{0x50}},
+{{0x32},{0x00}},
+{{0x33},{0x28}},
+{{0x34},{0x2a}},
+{{0x35},{0x28}},
+{{0x39},{0x04}},
+{{0x3a},{0x20}},
+{{0x3b},{0x20}},
+{{0x3c},{0x00}},
+{{0x3d},{0x00}},
+{{0x3e},{0x00}},
+{{0x3f},{0x00}},
+{{0x50},{0x14}}, // 0x14
+{{0x52},{0x41}},
+{{0x53},{0x80}},
+{{0x54},{0x80}},
+{{0x55},{0x80}},
+{{0x56},{0x80}},
+{{0x8b},{0x20}},
+{{0x8c},{0x20}},
+{{0x8d},{0x20}},
+{{0x8e},{0x14}},
+{{0x8f},{0x10}},
+{{0x90},{0x14}},
+{{0x91},{0x3c}},
+{{0x92},{0x50}},
+//{{0x8b},{0x10}},
+//{{0x8c},{0x10}},
+//{{0x8d},{0x10}},
+//{{0x8e},{0x10}},
+//{{0x8f},{0x10}},
+//{{0x90},{0x10}},
+//{{0x91},{0x3c}},
+//{{0x92},{0x50}},
+{{0x5d},{0x12}},
+{{0x5e},{0x1a}},
+{{0x5f},{0x24}},
+{{0x60},{0x07}},
+{{0x61},{0x15}},
+{{0x62},{0x08}}, // 0x08
+{{0x64},{0x03}},  // 0x03
+{{0x66},{0xe8}},
+{{0x67},{0x86}},
+{{0x68},{0x82}},
+{{0x69},{0x18}},
+{{0x6a},{0x0f}},
+{{0x6b},{0x00}},
+{{0x6c},{0x5f}},
+{{0x6d},{0x8f}},
+{{0x6e},{0x55}},
+{{0x6f},{0x38}},
+{{0x70},{0x15}},
+{{0x71},{0x33}},
+{{0x72},{0xdc}},
+{{0x73},{0x00}},
+{{0x74},{0x02}},
+{{0x75},{0x3f}},
+{{0x76},{0x02}},
+{{0x77},{0x38}}, // 0x47
+{{0x78},{0x88}},
+{{0x79},{0x81}},
+{{0x7a},{0x81}},
+{{0x7b},{0x22}},
+{{0x7c},{0xff}},
+{{0x93},{0x48}},  //color matrix default
+{{0x94},{0x02}},
+{{0x95},{0x07}},
+{{0x96},{0xe0}},
+{{0x97},{0x40}},
+{{0x98},{0xf0}},
+{{0xb1},{0x40}},
+{{0xb2},{0x40}},
+{{0xb3},{0x40}}, //0x40
+{{0xb6},{0xe0}},
+{{0xbd},{0x38}},
+{{0xbe},{0x36}},
+{{0xd0},{0xCB}},
+{{0xd1},{0x10}},
+{{0xd2},{0x90}},
+{{0xd3},{0x48}},
+{{0xd5},{0xF2}},
+{{0xd6},{0x16}},
+{{0xdb},{0x92}},
+{{0xdc},{0xA5}},
+{{0xdf},{0x23}},
+{{0xd9},{0x00}},
+{{0xda},{0x00}},
+{{0xe0},{0x09}},
+{{0xed},{0x04}},
+{{0xee},{0xa0}},
+{{0xef},{0x40}},
+{{0x80},{0x03}},
+
+{{0x9F},{0x10}},
+{{0xA0},{0x20}},
+{{0xA1},{0x38}},
+{{0xA2},{0x4e}},
+{{0xA3},{0x63}},
+{{0xA4},{0x76}},
+{{0xA5},{0x87}},
+{{0xA6},{0xa2}},
+{{0xA7},{0xb8}},
+{{0xA8},{0xca}},
+{{0xA9},{0xd8}},
+{{0xAA},{0xe3}},
+{{0xAB},{0xeb}},
+{{0xAC},{0xf0}},
+{{0xAD},{0xF8}},
+{{0xAE},{0xFd}},
+{{0xAF},{0xFF}},
+
+{{0xc0},{0x00}},
+{{0xc1},{0x10}},
+{{0xc2},{0x1c}},
+{{0xc3},{0x30}},
+{{0xc4},{0x43}},
+{{0xc5},{0x54}},
+{{0xc6},{0x65}},
+{{0xc7},{0x75}},
+{{0xc8},{0x93}},
+{{0xc9},{0xB0}},
+{{0xca},{0xCB}},
+{{0xcb},{0xE6}},
+{{0xcc},{0xFF}},
+{{0xf0},{0x02}},
+{{0xf1},{0x01}},
+{{0xf2},{0x02}},
+{{0xf3},{0x30}},
+{{0xf7},{0x12}},
+{{0xf8},{0x0a}},
+{{0xf9},{0x9f}},
+{{0xfa},{0x78}},
+{{0xfe},{0x01}},
+{{0x00},{0xf5}},
+{{0x02},{0x20}},
+{{0x04},{0x10}},
+{{0x05},{0x08}},
+{{0x06},{0x20}},
+{{0x08},{0x0a}},
+{{0x0a},{0xa0}},
+{{0x0b},{0x60}},
+{{0x0c},{0x08}},
+{{0x0e},{0x44}},
+{{0x0f},{0x32}},
+{{0x10},{0x41}},
+{{0x11},{0x37}},
+{{0x12},{0x22}},
+{{0x13},{0x19}},
+{{0x14},{0x44}},
+{{0x15},{0x44}},
+{{0x16},{0xc2}},
+{{0x17},{0xA8}},
+{{0x18},{0x18}},
+{{0x19},{0x50}},
+{{0x1a},{0xd8}},
+{{0x1b},{0xf5}},
+{{0x70},{0x40}},
+{{0x71},{0x58}},
+{{0x72},{0x30}},
+{{0x73},{0x48}},
+{{0x74},{0x20}},
+{{0x75},{0x60}},
+{{0x77},{0x20}},
+{{0x78},{0x32}},
+{{0x30},{0x03}},
+{{0x31},{0x40}},
+{{0x32},{0x10}},
+{{0x33},{0xe0}},
+{{0x34},{0xe0}},
+{{0x35},{0x00}},
+{{0x36},{0x80}},
+{{0x37},{0x00}},
+{{0x38},{0x04}},
+{{0x39},{0x09}},
+{{0x3a},{0x12}},
+{{0x3b},{0x1C}},
+{{0x3c},{0x28}},
+{{0x3d},{0x31}},
+{{0x3e},{0x44}},
+{{0x3f},{0x57}},
+{{0x40},{0x6C}},
+{{0x41},{0x81}},
+{{0x42},{0x94}},
+{{0x43},{0xA7}},
+{{0x44},{0xB8}},
+{{0x45},{0xD6}},
+{{0x46},{0xEE}},
+{{0x47},{0x0d}},
+{{0x62},{0xf7}},
+{{0x63},{0x68}},
+{{0x64},{0xd3}},
+{{0x65},{0xd3}},
+{{0x66},{0x60}},
+{{0xfe},{0x00}},
+};
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0x22},{0x57}},
+	{{0x5a},{0x56}},
+	{{0x5b},{0x40}},
+	{{0x5c},{0x4a}}
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0x22},{0x55}},
+	{{0x5a},{0x8c}},
+	{{0x5b},{0x50}},
+	{{0x5c},{0x40}}
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0x22},{0x55}},
+	{{0x22},{0x55}},
+	{{0x5a},{0x74}},
+	{{0x5b},{0x52}},
+	{{0x5c},{0x40}}
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0x22},{0x55}},
+	{{0x5a},{0x48}},
+	{{0x5b},{0x40}},
+	{{0x5c},{0x5c}}
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0x22},{0x55}},
+	{{0x5a},{0x40}},
+	{{0x5b},{0x42}},
+	{{0x5c},{0x50}}
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0x22},{0x55}},
+	{{0x5a},{0x40}},
+	{{0x5b},{0x54}},
+	{{0x5c},{0x70}}
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0x23},{0x00}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+	{{0x77},{0x54}},
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0xd0}},
+	{{0xbb},{0x28}}
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0x23},{0x01}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xbf}},
+	{{0xd2},{0x10}},
+	{{0x73},{0x01}},
+
+	{{0x51},{0x40}},
+	{{0x52},{0x40}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xbf}},
+	{{0xd2},{0x10}},
+	{{0x73},{0x01}},
+
+	{{0x51},{0x40}},
+	{{0x52},{0x40}},
+
+	{{0xb3},{0x98}},
+	{{0xb4},{0x06}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x00}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0x50}},
+	{{0xbb},{0xe0}}
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xff}},
+	{{0xd2},{0x90}},
+	{{0x73},{0x88}},
+
+	{{0xb3},{0x40}},
+	{{0xb4},{0x80}},
+	{{0xba},{0xc0}},
+	{{0xbb},{0xc0}}
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	{{0x23},{0x02}},
+	{{0x2d},{0x0a}},
+	{{0x20},{0xbf}},
+	{{0xd2},{0x10}},
+	{{0x73},{0x01}},
+
+	{{0x51},{0x40}},
+	{{0x52},{0x40}},
+
+	{{0xb3},{0x60}},
+	{{0xb4},{0x40}},
+	{{0xba},{0x00}},
+	{{0xbb},{0x00}}
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0xb5},{0xc0}},
+	{{0xd3},{0x28}}
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0xb5},{0xd0}},
+	{{0xd3},{0x30}}
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0xb5},{0xe0}},
+	{{0xd3},{0x38}}
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0xb5},{0xf0}},
+	{{0xd3},{0x40}}
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0xb5},{0x00}},
+	{{0xd3},{0x48}}
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0xb5},{0x10}},
+	{{0xd3},{0x50}}
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0xb5},{0x20}},
+	{{0xd3},{0x58}}
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0xb5},{0x30}},
+	{{0xd3},{0x60}}
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0xb5},{0x40}},
+	{{0xd3},{0x68}}
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0x24},{0xa2}}	//YCbYCr
+};
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0x24},{0xa3}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0x24},{0xa1}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0x24},{0xa0}}	//CbYCrY
+};
+
+static struct regval_list sensor_fmt_raw[] = {
+	{{0x24},{0xb7}}//raw
+};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_dev_err("sensor_write_err!\n");
+				return ret;
+			}
+		udelay(100);
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00; //PAGE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x9b)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	switch(magic_ver) {
+	case SUNXI_VER_A10A:
+	case SUNXI_VER_A10B:
+		sensor_write_array(sd, sensor_default_regs_49p5M , ARRAY_SIZE(sensor_default_regs_49p5M));
+		break;
+	case SUNXI_VER_A10C:
+		sensor_write_array(sd, sensor_default_regs_24M , ARRAY_SIZE(sensor_default_regs_24M));
+		break;
+	default:
+		sensor_write_array(sd, sensor_default_regs_24M , ARRAY_SIZE(sensor_default_regs_24M));
+		break;
+	}
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "Raw RGB Bayer",
+		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+		.regs 		= sensor_fmt_raw,
+		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+		.bpp		= 1
+	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= NULL,
+		.regs_size	= 0,
+		.set_size	= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+
+	csi_dev_dbg("sensor_s_fmt\n");
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct v4l2_fract *tpf = &cp->timeperframe;
+	//struct sensor_info *info = to_state(sd);
+	//int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else
+//		div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > CLK_SCALE)
+//		div = CLK_SCALE;
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x14;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x14 bit0 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x14;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfe;
+			break;
+		case 1:
+			regs.value[0] |= 0x01;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x14;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x14 bit1 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x14;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfd;
+			break;
+		case 1:
+			regs.value[0] |= 0x02;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xd2;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x80;
+	if (regs.value[0] == 0x80) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xd2;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x80;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0x7f;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autoexp = value;
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x22;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x22 bit1 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x22;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfd;
+		break;
+	case 1:
+		regs.value[0] |= 0x02;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+//		ret = sensor_s_autowb(sd, 1);
+//		return ret;
+			ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+			info->autowb = 1;
+	}
+	else {
+//		ret = sensor_s_autowb(sd, 0);
+//		if(ret < 0) {
+//			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+//			return ret;
+//		}
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+		info->autowb = 0;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(100);
+
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	magic_ver = sw_get_ic_ver();
+  switch(magic_ver) {
+  case SUNXI_VER_A10A:
+  case SUNXI_VER_A10B:
+  	info->ccm_info->mclk = MCLK_VER_B;
+  	break;
+  case SUNXI_VER_A10C:
+  	info->ccm_info->mclk = MCLK_VER_C;
+  	break;
+  default:
+  	info->ccm_info->mclk = MCLK_VER_C;
+  	break;
+  }
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "gc0308", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	  .name = "gc0308",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/gt2005.c b/drivers/media/video/sun4i_csi/device/gt2005.c
new file mode 100644
index 0000000..b4ff7f8
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/gt2005.c
@@ -0,0 +1,2693 @@
+/*
+ * drivers/media/video/sun4i_csi/device/gt2005.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for GalaxyCore gt2005 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore GT2005 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][GT2005]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][GT2005]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][GT2005]"x,##arg)
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0:csi back 1:csi front
+#define V4L2_IDENT_SENSOR 0x2005
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			0
+#define CSI_STBY_OFF 		1
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 2
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define UXGA_WIDTH		1600
+#define UXGA_HEIGHT		1200
+#define HD720_WIDTH 	1280
+#define HD720_HEIGHT	720
+#define SVGA_WIDTH		800
+#define SVGA_HEIGHT 	600
+#define VGA_WIDTH			640
+#define VGA_HEIGHT		480
+#define QVGA_WIDTH		320
+#define QVGA_HEIGHT		240
+#define CIF_WIDTH			352
+#define CIF_HEIGHT		288
+#define QCIF_WIDTH		176
+#define	QCIF_HEIGHT		144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 30
+
+/*
+ * The gt2005 sits on i2c with ID 0x78
+ */
+#define I2C_ADDR 0x78
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+struct snesor_colorfx_struct; /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+  enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+
+/*
+ * The default register settings
+ *
+ */
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+
+static struct regval_list sensor_default_regs[] = {
+	{{0x01,	0x01} , {0x00}},
+	{{0x01,	0x03} , {0x00}},
+
+	//Hcount&Vcount
+	{{0x01,	0x05} , {0x00}},
+	{{0x01,	0x06} , {0xF0}},
+	{{0x01,	0x07} , {0x00}},
+	{{0x01,	0x08} , {0x1C}},
+
+	//Binning&Resoultion
+	//1600*1200
+	{{0x01,	0x09} , {0x01}},
+	{{0x01,	0x0A} , {0x00}},
+	{{0x01,	0x0B} , {0x00}},
+	{{0x01,	0x0C} , {0x00}},
+	{{0x01,	0x0D} , {0x08}},
+	{{0x01,	0x0E} , {0x00}},
+	{{0x01,	0x0F} , {0x08}},
+	{{0x01,	0x10} , {0x06}},
+	{{0x01,	0x11} , {0x40}},
+	{{0x01,	0x12} , {0x04}},
+	{{0x01,	0x13} , {0xB0}},
+
+	//YUV Mode
+	{{0x01,	0x14} , {0x04}},//YUYV
+
+	//Picture Effect
+	{{0x01,	0x15} , {0x00}},
+
+	//PLL&Frame Rate
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x17} , {0x00}},
+	{{0x01,	0x18} , {0x67}},
+	{{0x01,	0x19} , {0x02}},
+	{{0x01,	0x1A} , {0x04}},
+	{{0x01,	0x1B} , {0x01}},
+
+	//DCLK Polarity
+	{{0x01,	0x1C} , {0x00}},
+
+	//Do not change
+	{{0x01,	0x1D} , {0x02}},
+	{{0x01,	0x1E} , {0x00}},
+
+	{{0x01,	0x1F} , {0x00}},
+	{{0x01,	0x20} , {0x1C}},
+	{{0x01,	0x21} , {0x00}},
+	{{0x01,	0x22} , {0x04}},
+	{{0x01,	0x23} , {0x00}},
+	{{0x01,	0x24} , {0x00}},
+	{{0x01,	0x25} , {0x00}},
+	{{0x01,	0x26} , {0x00}},
+	{{0x01,	0x27} , {0x00}},
+	{{0x01,	0x28} , {0x00}},
+
+	//Contrast
+	{{0x02,	0x00} , {0x00}},
+
+	//Brightness
+	{{0x02,	0x01} , {0x00}},
+
+	//Saturation
+	{{0x02,	0x02} , {0x40}},
+
+	//Do not change
+	{{0x02,	0x03} , {0x00}},
+	{{0x02,	0x04} , {0x03}},
+	{{0x02,	0x05} , {0x1F}},
+	{{0x02,	0x06} , {0x0B}},
+	{{0x02,	0x07} , {0x20}},
+	{{0x02,	0x08} , {0x00}},
+	{{0x02,	0x09} , {0x2A}},
+	{{0x02,	0x0A} , {0x01}},
+
+	//Sharpness
+	{{0x02,	0x0B} , {0x48}},
+	{{0x02,	0x0C} , {0x64}},
+
+	//Do not change
+	{{0x02,	0x0D}, {0xC8}},
+	{{0x02,	0x0E}, {0xBC}},
+	{{0x02,	0x0F}, {0x08}},
+	{{0x02,	0x10}, {0xD6}},
+	{{0x02,	0x11}, {0x00}},
+	{{0x02,	0x12}, {0x20}},
+	{{0x02,	0x13}, {0x81}},
+	{{0x02,	0x14}, {0x15}},
+	{{0x02,	0x15}, {0x00}},
+	{{0x02,	0x16}, {0x00}},
+	{{0x02,	0x17}, {0x00}},
+	{{0x02,	0x18}, {0x46}},
+	{{0x02,	0x19}, {0x30}},
+	{{0x02,	0x1A}, {0x03}},
+	{{0x02,	0x1B}, {0x28}},
+	{{0x02,	0x1C}, {0x02}},
+	{{0x02,	0x1D}, {0x60}},
+	{{0x02,	0x1E}, {0x00}},
+	{{0x02,	0x1F}, {0x00}},
+	{{0x02,	0x20}, {0x08}},
+	{{0x02,	0x21}, {0x08}},
+	{{0x02,	0x22}, {0x04}},
+	{{0x02,	0x23}, {0x00}},
+	{{0x02,	0x24}, {0x1F}},
+	{{0x02,	0x25}, {0x1E}},
+	{{0x02,	0x26}, {0x18}},
+	{{0x02,	0x27}, {0x1D}},
+	{{0x02,	0x28}, {0x1F}},
+	{{0x02,	0x29}, {0x1F}},
+	{{0x02,	0x2A}, {0x01}},
+	{{0x02,	0x2B}, {0x04}},
+	{{0x02,	0x2C}, {0x05}},
+	{{0x02,	0x2D}, {0x05}},
+	{{0x02,	0x2E}, {0x04}},
+	{{0x02,	0x2F}, {0x03}},
+	{{0x02,	0x30}, {0x02}},
+	{{0x02,	0x31}, {0x1F}},
+	{{0x02,	0x32}, {0x1A}},
+	{{0x02,	0x33}, {0x19}},
+	{{0x02,	0x34}, {0x19}},
+	{{0x02,	0x35}, {0x1B}},
+	{{0x02,	0x36}, {0x1F}},
+	{{0x02,	0x37}, {0x04}},
+	{{0x02,	0x38}, {0xEE}},
+	{{0x02,	0x39}, {0xFF}},
+	{{0x02,	0x3A}, {0x00}},
+	{{0x02,	0x3B}, {0x00}},
+	{{0x02,	0x3C}, {0x00}},
+	{{0x02,	0x3D}, {0x00}},
+	{{0x02,	0x3E}, {0x00}},
+	{{0x02,	0x3F}, {0x00}},
+	{{0x02,	0x40}, {0x00}},
+	{{0x02,	0x41}, {0x00}},
+	{{0x02,	0x42}, {0x00}},
+	{{0x02,	0x43}, {0x21}},
+	{{0x02,	0x44}, {0x42}},
+	{{0x02,	0x45}, {0x53}},
+	{{0x02,	0x46}, {0x54}},
+	{{0x02,	0x47}, {0x54}},
+	{{0x02,	0x48}, {0x54}},
+	{{0x02,	0x49}, {0x33}},
+	{{0x02,	0x4A}, {0x11}},
+	{{0x02,	0x4B}, {0x00}},
+	{{0x02,	0x4C}, {0x00}},
+	{{0x02,	0x4D}, {0xFF}},
+	{{0x02,	0x4E}, {0xEE}},
+	{{0x02,	0x4F}, {0xDD}},
+	{{0x02,	0x50}, {0x00}},
+	{{0x02,	0x51}, {0x00}},
+	{{0x02,	0x52}, {0x00}},
+	{{0x02,	0x53}, {0x00}},
+	{{0x02,	0x54}, {0x00}},
+	{{0x02,	0x55}, {0x00}},
+	{{0x02,	0x56}, {0x00}},
+	{{0x02,	0x57}, {0x00}},
+	{{0x02,	0x58}, {0x00}},
+	{{0x02,	0x59}, {0x00}},
+	{{0x02,	0x5A}, {0x00}},
+	{{0x02,	0x5B}, {0x00}},
+	{{0x02,	0x5C}, {0x00}},
+	{{0x02,	0x5D}, {0x00}},
+	{{0x02,	0x5E}, {0x00}},
+	{{0x02,	0x5F}, {0x00}},
+	{{0x02,	0x60}, {0x00}},
+	{{0x02,	0x61}, {0x00}},
+	{{0x02,	0x62}, {0x00}},
+	{{0x02,	0x63}, {0x00}},
+	{{0x02,	0x64}, {0x00}},
+	{{0x02,	0x65}, {0x00}},
+	{{0x02,	0x66}, {0x00}},
+	{{0x02,	0x67}, {0x00}},
+	{{0x02,	0x68}, {0x8F}},
+	{{0x02,	0x69}, {0xA3}},
+	{{0x02,	0x6A}, {0xB4}},
+	{{0x02,	0x6B}, {0x90}},
+	{{0x02,	0x6C}, {0x00}},
+	{{0x02,	0x6D}, {0xD0}},
+	{{0x02,	0x6E}, {0x60}},
+	{{0x02,	0x6F}, {0xA0}},
+	{{0x02,	0x70}, {0x40}},
+	{{0x03,	0x00}, {0x81}},
+	{{0x03,	0x01}, {0x80}},
+	{{0x03,	0x02}, {0x22}},
+	{{0x03,	0x03}, {0x06}},
+	{{0x03,	0x04}, {0x03}},
+	{{0x03,	0x05}, {0x83}},
+	{{0x03,	0x06}, {0x00}},
+	{{0x03,	0x07}, {0x22}},
+	{{0x03,	0x08}, {0x00}},
+	{{0x03,	0x09}, {0x55}},
+	{{0x03,	0x0A}, {0x55}},
+	{{0x03,	0x0B}, {0x55}},
+	{{0x03,	0x0C}, {0x54}},
+	{{0x03,	0x0D}, {0x1F}},
+	{{0x03,	0x0E}, {0x0A}},
+	{{0x03,	0x0F}, {0x10}},
+	{{0x03,	0x10}, {0x04}},
+	{{0x03,	0x11}, {0xFF}},
+	{{0x03,	0x12}, {0x08}},
+	{{0x03,	0x13}, {0x28}},
+	{{0x03,	0x14}, {0x66}},
+	{{0x03,	0x15}, {0x96}},
+	{{0x03,	0x16}, {0x26}},
+	{{0x03,	0x17}, {0x02}},
+	{{0x03,	0x18}, {0x08}},
+	{{0x03,	0x19}, {0x0C}},
+
+#ifndef A_LIGHT_CORRECTION
+	//Normal AWB Setting
+	{{0x03,	0x1A} , {0x81}},
+	{{0x03,	0x1B} , {0x00}},
+	{{0x03,	0x1C} , {0x3D}},
+	{{0x03,	0x1D} , {0x00}},
+	{{0x03,	0x1E} , {0xF9}},
+	{{0x03,	0x1F} , {0x00}},
+	{{0x03,	0x20} , {0x24}},
+	{{0x03,	0x21} , {0x14}},
+	{{0x03,	0x22} , {0x1A}},
+	{{0x03,	0x23} , {0x24}},
+	{{0x03,	0x24} , {0x08}},
+	{{0x03,	0x25} , {0xF0}},
+	{{0x03,	0x26} , {0x30}},
+	{{0x03,	0x27} , {0x17}},
+	{{0x03,	0x28} , {0x11}},
+	{{0x03,	0x29} , {0x22}},
+	{{0x03,	0x2A} , {0x2F}},
+	{{0x03,	0x2B} , {0x21}},
+	{{0x03,	0x2C} , {0xDA}},
+	{{0x03,	0x2D} , {0x10}},
+	{{0x03,	0x2E} , {0xEA}},
+	{{0x03,	0x2F} , {0x18}},
+	{{0x03,	0x30} , {0x29}},
+	{{0x03,	0x31} , {0x25}},
+	{{0x03,	0x32} , {0x12}},
+	{{0x03,	0x33} , {0x0F}},
+	{{0x03,	0x34} , {0xE0}},
+	{{0x03,	0x35} , {0x13}},
+	{{0x03,	0x36} , {0xFF}},
+	{{0x03,	0x37} , {0x20}},
+	{{0x03,	0x38} , {0x46}},
+	{{0x03,	0x39} , {0x04}},
+	{{0x03,	0x3A} , {0x04}},
+	{{0x03,	0x3B} , {0xFF}},
+	{{0x03,	0x3C} , {0x01}},
+	{{0x03,	0x3D} , {0x00}},
+
+#else
+	//A LIGHT CORRECTION
+	{{0x03,	0x1A} , {0x81}},
+	{{0x03,	0x1B} , {0x00}},
+	{{0x03,	0x1C} , {0x1D}},
+	{{0x03,	0x1D} , {0x00}},
+	{{0x03,	0x1E} , {0xFD}},
+	{{0x03,	0x1F} , {0x00}},
+	{{0x03,	0x20} , {0xE1}},
+	{{0x03,	0x21} , {0x1A}},
+	{{0x03,	0x22} , {0xDE}},
+	{{0x03,	0x23} , {0x11}},
+	{{0x03,	0x24} , {0x1A}},
+	{{0x03,	0x25} , {0xEE}},
+	{{0x03,	0x26} , {0x50}},
+	{{0x03,	0x27} , {0x18}},
+	{{0x03,	0x28} , {0x25}},
+	{{0x03,	0x29} , {0x37}},
+	{{0x03,	0x2A} , {0x24}},
+	{{0x03,	0x2B} , {0x32}},
+	{{0x03,	0x2C} , {0xA9}},
+	{{0x03,	0x2D} , {0x32}},
+	{{0x03,	0x2E} , {0xFF}},
+	{{0x03,	0x2F} , {0x7F}},
+	{{0x03,	0x30} , {0xBA}},
+	{{0x03,	0x31} , {0x7F}},
+	{{0x03,	0x32} , {0x7F}},
+	{{0x03,	0x33} , {0x14}},
+	{{0x03,	0x34} , {0x81}},
+	{{0x03,	0x35} , {0x14}},
+	{{0x03,	0x36} , {0xFF}},
+	{{0x03,	0x37} , {0x20}},
+	{{0x03,	0x38} , {0x46}},
+	{{0x03,	0x39} , {0x04}},
+	{{0x03,	0x3A} , {0x04}},
+	{{0x03,	0x3B} , {0x00}},
+	{{0x03,	0x3C} , {0x00}},
+	{{0x03,	0x3D} , {0x00}},
+#endif
+
+	//Do not change
+	{{0x03,	0x3E} , {0x03}},
+	{{0x03,	0x3F} , {0x28}},
+	{{0x03,	0x40} , {0x02}},
+	{{0x03,	0x41} , {0x60}},
+	{{0x03,	0x42} , {0xAC}},
+	{{0x03,	0x43} , {0x97}},
+	{{0x03,	0x44} , {0x7F}},
+	{{0x04,	0x00} , {0xE8}},
+	{{0x04,	0x01} , {0x40}},
+	{{0x04,	0x02} , {0x00}},
+	{{0x04,	0x03} , {0x00}},
+	{{0x04,	0x04} , {0xF8}},
+	{{0x04,	0x05} , {0x03}},
+	{{0x04,	0x06} , {0x03}},
+	{{0x04,	0x07} , {0x85}},
+	{{0x04,	0x08} , {0x44}},
+	{{0x04,	0x09} , {0x1F}},
+	{{0x04,	0x0A} , {0x40}},
+	{{0x04,	0x0B} , {0x33}},
+
+	//Lens Shading Correction
+	{{0x04,	0x0C} , {0xA0}},
+	{{0x04,	0x0D} , {0x00}},
+	{{0x04,	0x0E} , {0x00}},
+	{{0x04,	0x0F} , {0x00}},
+	{{0x04,	0x10} , {0x0D}},
+	{{0x04,	0x11} , {0x0D}},
+	{{0x04,	0x12} , {0x0C}},
+	{{0x04,	0x13} , {0x04}},
+	{{0x04,	0x14} , {0x00}},
+	{{0x04,	0x15} , {0x00}},
+	{{0x04,	0x16} , {0x07}},
+	{{0x04,	0x17} , {0x09}},
+	{{0x04,	0x18} , {0x16}},
+	{{0x04,	0x19} , {0x14}},
+	{{0x04,	0x1A} , {0x11}},
+	{{0x04,	0x1B} , {0x14}},
+	{{0x04,	0x1C} , {0x07}},
+	{{0x04,	0x1D} , {0x07}},
+	{{0x04,	0x1E} , {0x06}},
+	{{0x04,	0x1F} , {0x02}},
+	{{0x04,	0x20} , {0x42}},
+	{{0x04,	0x21} , {0x42}},
+	{{0x04,	0x22} , {0x47}},
+	{{0x04,	0x23} , {0x39}},
+	{{0x04,	0x24} , {0x3E}},
+	{{0x04,	0x25} , {0x4D}},
+	{{0x04,	0x26} , {0x46}},
+	{{0x04,	0x27} , {0x3A}},
+	{{0x04,	0x28} , {0x21}},
+	{{0x04,	0x29} , {0x21}},
+	{{0x04,	0x2A} , {0x26}},
+	{{0x04,	0x2B} , {0x1C}},
+	{{0x04,	0x2C} , {0x25}},
+	{{0x04,	0x2D} , {0x25}},
+	{{0x04,	0x2E} , {0x28}},
+	{{0x04,	0x2F} , {0x20}},
+	{{0x04,	0x30} , {0x3E}},
+	{{0x04,	0x31} , {0x3E}},
+	{{0x04,	0x32} , {0x33}},
+	{{0x04,	0x33} , {0x2E}},
+	{{0x04,	0x34} , {0x54}},
+	{{0x04,	0x35} , {0x53}},
+	{{0x04,	0x36} , {0x3C}},
+	{{0x04,	0x37} , {0x51}},
+	{{0x04,	0x38} , {0x2B}},
+	{{0x04,	0x39} , {0x2B}},
+	{{0x04,	0x3A} , {0x38}},
+	{{0x04,	0x3B} , {0x22}},
+	{{0x04,	0x3C} , {0x3B}},
+	{{0x04,	0x3D} , {0x3B}},
+	{{0x04,	0x3E} , {0x31}},
+	{{0x04,	0x3F} , {0x37}},
+
+	//PWB Gain
+	{{0x04,	0x40} , {0x00}},
+	{{0x04,	0x41} , {0x4B}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x31}},
+
+	{{0x04,	0x45} , {0x00}},
+	{{0x04,	0x46} , {0x00}},
+	{{0x04,	0x47} , {0x00}},
+	{{0x04,	0x48} , {0x00}},
+	{{0x04,	0x49} , {0x00}},
+	{{0x04,	0x4A} , {0x00}},
+	{{0x04,	0x4D} , {0xE0}},
+	{{0x04,	0x4E} , {0x05}},
+	{{0x04,	0x4F} , {0x07}},
+	{{0x04,	0x50} , {0x00}},
+	{{0x04,	0x51} , {0x00}},
+	{{0x04,	0x52} , {0x00}},
+	{{0x04,	0x53} , {0x00}},
+	{{0x04,	0x54} , {0x00}},
+	{{0x04,	0x55} , {0x00}},
+	{{0x04,	0x56} , {0x00}},
+	{{0x04,	0x57} , {0x00}},
+	{{0x04,	0x58} , {0x00}},
+	{{0x04,	0x59} , {0x00}},
+	{{0x04,	0x5A} , {0x00}},
+	{{0x04,	0x5B} , {0x00}},
+	{{0x04,	0x5C} , {0x00}},
+	{{0x04,	0x5D} , {0x00}},
+	{{0x04,	0x5E} , {0x00}},
+	{{0x04,	0x5F} , {0x00}},
+
+	//GAMMA Correction
+	{{0x04,	0x60} , {0x80}},
+	{{0x04,	0x61} , {0x10}},
+	{{0x04,	0x62} , {0x10}},
+	{{0x04,	0x63} , {0x10}},
+	{{0x04,	0x64} , {0x08}},
+	{{0x04,	0x65} , {0x08}},
+	{{0x04,	0x66} , {0x11}},
+	{{0x04,	0x67} , {0x09}},
+	{{0x04,	0x68} , {0x23}},
+	{{0x04,	0x69} , {0x2A}},
+	{{0x04,	0x6A} , {0x2A}},
+	{{0x04,	0x6B} , {0x47}},
+	{{0x04,	0x6C} , {0x52}},
+	{{0x04,	0x6D} , {0x42}},
+	{{0x04,	0x6E} , {0x36}},
+	{{0x04,	0x6F} , {0x46}},
+	{{0x04,	0x70} , {0x3A}},
+	{{0x04,	0x71} , {0x32}},
+	{{0x04,	0x72} , {0x32}},
+	{{0x04,	0x73} , {0x38}},
+	{{0x04,	0x74} , {0x3D}},
+	{{0x04,	0x75} , {0x2F}},
+	{{0x04,	0x76} , {0x29}},
+	{{0x04,	0x77} , {0x48}},
+
+	//Do not change
+	{{0x06,	0x00} , {0x00}},
+	{{0x06,	0x01} , {0x24}},
+	{{0x06,	0x02} , {0x45}},
+	{{0x06,	0x03} , {0x0E}},
+	{{0x06,	0x04} , {0x14}},
+	{{0x06,	0x05} , {0x2F}},
+	{{0x06,	0x06} , {0x01}},
+	{{0x06,	0x07} , {0x0E}},
+	{{0x06,	0x08} , {0x0E}},
+	{{0x06,	0x09} , {0x37}},
+	{{0x06,	0x0A} , {0x18}},
+	{{0x06,	0x0B} , {0xA0}},
+	{{0x06,	0x0C} , {0x20}},
+	{{0x06,	0x0D} , {0x07}},
+	{{0x06,	0x0E} , {0x47}},
+	{{0x06,	0x0F} , {0x90}},
+	{{0x06,	0x10} , {0x06}},
+	{{0x06,	0x11} , {0x0C}},
+	{{0x06,	0x12} , {0x28}},
+	{{0x06,	0x13} , {0x13}},
+	{{0x06,	0x14} , {0x0B}},
+	{{0x06,	0x15} , {0x10}},
+	{{0x06,	0x16} , {0x14}},
+	{{0x06,	0x17} , {0x19}},
+	{{0x06,	0x18} , {0x52}},
+	{{0x06,	0x19} , {0xA0}},
+	{{0x06,	0x1A} , {0x11}},
+	{{0x06,	0x1B} , {0x33}},
+	{{0x06,	0x1C} , {0x56}},
+	{{0x06,	0x1D} , {0x20}},
+	{{0x06,	0x1E} , {0x28}},
+	{{0x06,	0x1F} , {0x2B}},
+	{{0x06,	0x20} , {0x22}},
+	{{0x06,	0x21} , {0x11}},
+	{{0x06,	0x22} , {0x75}},
+	{{0x06,	0x23} , {0x49}},
+	{{0x06,	0x24} , {0x6E}},
+	{{0x06,	0x25} , {0x80}},
+	{{0x06,	0x26} , {0x02}},
+	{{0x06,	0x27} , {0x0C}},
+	{{0x06,	0x28} , {0x51}},
+	{{0x06,	0x29} , {0x25}},
+	{{0x06,	0x2A} , {0x01}},
+	{{0x06,	0x2B} , {0x3D}},
+	{{0x06,	0x2C} , {0x04}},
+	{{0x06,	0x2D} , {0x01}},
+	{{0x06,	0x2E} , {0x0C}},
+	{{0x06,	0x2F} , {0x2C}},
+	{{0x06,	0x30} , {0x0D}},
+	{{0x06,	0x31} , {0x14}},
+	{{0x06,	0x32} , {0x12}},
+	{{0x06,	0x33} , {0x34}},
+	{{0x06,	0x34} , {0x00}},
+	{{0x06,	0x35} , {0x00}},
+	{{0x06,	0x36} , {0x00}},
+	{{0x06,	0x37} , {0xB1}},
+	{{0x06,	0x38} , {0x22}},
+	{{0x06,	0x39} , {0x32}},
+	{{0x06,	0x3A} , {0x0E}},
+	{{0x06,	0x3B} , {0x18}},
+	{{0x06,	0x3C} , {0x88}},
+	{{0x06,	0x40} , {0xB2}},
+	{{0x06,	0x41} , {0xC0}},
+	{{0x06,	0x42} , {0x01}},
+	{{0x06,	0x43} , {0x26}},
+	{{0x06,	0x44} , {0x13}},
+	{{0x06,	0x45} , {0x88}},
+	{{0x06,	0x46} , {0x64}},
+	{{0x06,	0x47} , {0x00}},
+	{{0x06,	0x81} , {0x1B}},
+	{{0x06,	0x82} , {0xA0}},
+	{{0x06,	0x83} , {0x28}},
+	{{0x06,	0x84} , {0x00}},
+	{{0x06,	0x85} , {0xB0}},
+	{{0x06,	0x86} , {0x6F}},
+	{{0x06,	0x87} , {0x33}},
+	{{0x06,	0x88} , {0x1F}},
+	{{0x06,	0x89} , {0x44}},
+	{{0x06,	0x8A} , {0xA8}},
+	{{0x06,	0x8B} , {0x44}},
+	{{0x06,	0x8C} , {0x08}},
+	{{0x06,	0x8D} , {0x08}},
+	{{0x06,	0x8E} , {0x00}},
+	{{0x06,	0x8F} , {0x00}},
+	{{0x06,	0x90} , {0x01}},
+	{{0x06,	0x91} , {0x00}},
+	{{0x06,	0x92} , {0x01}},
+	{{0x06,	0x93} , {0x00}},
+	{{0x06,	0x94} , {0x00}},
+	{{0x06,	0x95} , {0x00}},
+	{{0x06,	0x96} , {0x00}},
+	{{0x06,	0x97} , {0x00}},
+	{{0x06,	0x98} , {0x2A}},
+	{{0x06,	0x99} , {0x80}},
+	{{0x06,	0x9A} , {0x1F}},
+	{{0x06,	0x9B} , {0x00}},
+	{{0x06,	0x9C} , {0x02}},
+	{{0x06,	0x9D} , {0xF5}},
+	{{0x06,	0x9E} , {0x03}},
+	{{0x06,	0x9F} , {0x6D}},
+	{{0x06,	0xA0} , {0x0C}},
+	{{0x06,	0xA1} , {0xB8}},
+	{{0x06,	0xA2} , {0x0D}},
+	{{0x06,	0xA3} , {0x74}},
+	{{0x06,	0xA4} , {0x00}},
+	{{0x06,	0xA5} , {0x2F}},
+	{{0x06,	0xA6} , {0x00}},
+	{{0x06,	0xA7} , {0x2F}},
+	{{0x0F,	0x00} , {0x00}},
+	{{0x0F,	0x01} , {0x00}},
+
+	//Output Enable
+	{{0x01,	0x00} , {0x01}},
+	{{0x01,	0x02} , {0x02}},
+	{{0x01,	0x04} , {0x03}},
+};
+
+static struct regval_list sensor_uxga_regs[] = {
+	//Resoltion Setting : 1600*1200
+	{{0x01,	0x09} , {0x01}},
+	{{0x01,	0x0A} , {0x00}},
+	{{0x01,	0x0B} , {0x00}},
+	{{0x01,	0x10} , {0x06}},
+	{{0x01,	0x11} , {0x40}},
+	{{0x01,	0x12} , {0x04}},
+	{{0x01,	0x13} , {0xb0}},
+
+	//PLL&Frame Rate 15fps
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x18} , {0x69}},//0x67
+	{{0x01,	0x19} , {0x01}},//0x02
+	{{0x01,	0x1A} , {0x04}},
+	{{0x01,	0x1B} , {0x00}},//PCLK DIV
+
+	//banding
+	{{0x03,	0x15} , {0x16}},
+	{{0x03,	0x13} , {0x38}},//0x2866 for uxga ,0x388b  for hd720,0x3536 for svga
+	{{0x03,	0x14} , {0x8B}},//
+};
+
+static struct regval_list sensor_hd720_regs[] = {
+//Resolution Setting : 1280*720
+	{{0x01,	0x09} , {0x00}},
+	{{0x01,	0x0A} , {0x00}},
+	{{0x01,	0x0B} , {0x03}},
+	{{0x01,	0x10} , {0x05}},
+	{{0x01,	0x11} , {0x00}},
+	{{0x01,	0x12} , {0x02}},
+	{{0x01,	0x13} , {0xD0}},
+
+	//PLL Setting 15FPS Under 24MHz PCLK
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x18} , {0x69}},
+	{{0x01,	0x19} , {0x01}},
+	{{0x01,	0x1a} , {0x04}},
+	{{0x01,	0x1B} , {0x00}},//PCLK DIV
+
+	//banding
+	{{0x03,	0x15} , {0x16}},
+	{{0x03,	0x13} , {0x38}},
+	{{0x03,	0x14} , {0x8B}},
+};
+
+static struct regval_list sensor_svga_regs[] = {
+	//Resolution Setting : 800*600
+	{{0x01,	0x09} , {0x00}},
+	{{0x01,	0x0A} , {0x04}},
+	{{0x01,	0x0B} , {0x03}},
+	{{0x01,	0x10} , {0x03}},
+	{{0x01,	0x11} , {0x20}},
+	{{0x01,	0x12} , {0x02}},
+	{{0x01,	0x13} , {0x58}},
+
+	//PLL Setting 30FPS Under 24MHz PCLK
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x18} , {0x69}},//0x40
+	{{0x01,	0x19} , {0x01}},
+	{{0x01,	0x1a} , {0x04}},
+	{{0x01,	0x1B} , {0x00}},//PCLK DIV
+
+	//banding
+	{{0x03,	0x15} , {0x16}},
+	{{0x03,	0x13} , {0x38}},//0x35
+	{{0x03,	0x14} , {0x8B}},//0x36
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	//Resolution Setting : 640*480
+	{{0x01,	0x09} , {0x00}},
+	{{0x01,	0x0A} , {0x04}},
+	{{0x01,	0x0B} , {0x03}},
+	{{0x01,	0x10} , {0x02}},
+	{{0x01,	0x11} , {0x80}},
+	{{0x01,	0x12} , {0x01}},
+	{{0x01,	0x13} , {0xE0}},
+
+	//PLL Setting 30FPS Under 24MHz PCLK
+	{{0x01,	0x16} , {0x02}},
+	{{0x01,	0x18} , {0x69}},//0x40
+	{{0x01,	0x19} , {0x01}},
+	{{0x01,	0x1a} , {0x04}},
+	{{0x01,	0x1B} , {0x00}},//PCLK DIV
+
+	//banding
+	{{0x03,	0x15} , {0x16}},
+	{{0x03,	0x13} , {0x38}},//0x35
+	{{0x03,	0x14} , {0x8B}},//0x36
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0x03,	0x20} , {0x24}},
+	{{0x03,	0x21} , {0x14}},
+	{{0x03,	0x22} , {0x1a}},
+	{{0x03,	0x23} , {0x24}},
+	{{0x04,	0x41} , {0x4B}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x31}},
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x80}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x0D}},
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x60}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x14}},
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x50}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x30}},
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x43}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x4B}},
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0x03,	0x20} , {0x02}},
+	{{0x03,	0x21} , {0x02}},
+	{{0x03,	0x22} , {0x02}},
+	{{0x03,	0x23} , {0x02}},
+	{{0x04,	0x41} , {0x0B}},
+	{{0x04,	0x42} , {0x00}},
+	{{0x04,	0x43} , {0x00}},
+	{{0x04,	0x44} , {0x5E}},
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0x01,	0x15}	,	{0x00}},
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0x01,	0x15}	,	{0x06}},
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0x01,	0x15}	,	{0x0a}},
+	{{0x02,	0x6e}	,	{0x60}},
+	{{0x02,	0x6f}	,	{0xa0}},
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0x01,	0x15}	,	{0x09}},
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0x01,	0x15}	,	{0x0a}},
+	{{0x02,	0x6e}	,	{0xfb}},
+	{{0x02,	0x6f}	,	{0x00}},
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0x01,	0x15}	,	{0x0a}},
+	{{0x02,	0x6e}	,	{0x20}},
+	{{0x02,	0x6f}	,	{0x00}},
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0x03,0x01} , {0x40}},
+	{{0x02,0x01} , {0x90}},
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0x03,0x01} , {0x50}},
+	{{0x02,0x01} , {0xa0}},
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0x03,0x01} , {0x60}},
+	{{0x02,0x01} , {0xb0}},
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0x03,0x01} , {0x70}},
+	{{0x02,0x01} , {0xd0}},
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0x03,0x01} , {0x80}},
+	{{0x02,0x01} , {0x0c}},
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0x03,0x01} , {0x90}},
+	{{0x02,0x01} , {0x30}},
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0x03,0x01} , {0xa0}},
+	{{0x02,0x01} , {0x50}},
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0x03,0x01} , {0xb0}},
+	{{0x02,0x01} , {0x60}},
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0x03,0x01} , {0xc0}},
+	{{0x02,0x01} , {0x70}},
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+
+	{{0x01,	0x14} , {0x04}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+
+	{{0x01,	0x14} , {0x06}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+
+	{{0x01,	0x14} , {0x02}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+
+	{{0x01,	0x14} , {0x00}}	//CbYCrY
+};
+
+static struct regval_list sensor_fmt_raw[] = {
+
+	{{0x01,	0x14} , {0x01}}//raw
+};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+		data[i] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		if(vals->reg_num[0] == 0xff && vals->reg_num[1] == 0xff) {
+			msleep(vals->value[0]);
+		} else {
+			ret = sensor_write(sd, vals->reg_num, vals->value);
+			if (ret < 0)
+				{
+					csi_dev_err("sensor_write_err!\n");
+					return ret;
+				}
+		}
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x00;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x51)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "Raw RGB Bayer",
+		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+		.regs 		= sensor_fmt_raw,
+		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+		.bpp		= 1
+	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* UXGA */
+	{
+		.width			= UXGA_WIDTH,
+		.height			= UXGA_HEIGHT,
+		.regs 			= sensor_uxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_uxga_regs),
+		.set_size		= NULL,
+	},
+	/* 720p */
+	{
+		.width			= HD720_WIDTH,
+		.height			= HD720_HEIGHT,
+		.regs				= sensor_hd720_regs,
+		.regs_size	= ARRAY_SIZE(sensor_hd720_regs),
+		.set_size		= NULL,
+	},
+	/* SVGA */
+	{
+		.width			= SVGA_WIDTH,
+		.height			= SVGA_HEIGHT,
+		.regs				= sensor_svga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_svga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width			= VGA_WIDTH,
+		.height			= VGA_HEIGHT,
+		.regs				= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+
+	if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE/2;
+	}
+	else {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+	}
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+//	struct v4l2_fract *tpf = &cp->timeperframe;
+//	struct sensor_info *info = to_state(sd);
+//	int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else {
+//		if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE/2)/tpf->denominator;
+//		}
+//		else {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//		}
+//	}
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > 8)
+//		div = 8;
+//
+//	switch()
+//
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//
+//	sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x01;
+	regs.reg_num[1] = 0x01;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x0101 bit0 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x01;
+	regs.reg_num[1] = 0x01;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfe;
+			break;
+		case 1:
+			regs.value[0] |= 0x01;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x01;
+	regs.reg_num[1] = 0x01;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x0101 bit1 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x01;
+	regs.reg_num[1] = 0x01;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfd;
+			break;
+		case 1:
+			regs.value[0] |= 0x02;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x80;
+	if (regs.value[0] == 0x80) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x80;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0x7f;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autoexp = value;
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.reg_num[1] = 0x1a;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<7);
+	regs.value[0] = regs.value[0]>>7;		//0x031a bit7 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x03;
+	regs.reg_num[1] = 0x1a;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0x7f;
+		break;
+	case 1:
+		regs.value[0] |= 0x80;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "gt2005", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "gt2005",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/hi253.c b/drivers/media/video/sun4i_csi/device/hi253.c
new file mode 100644
index 0000000..0a6607f
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/hi253.c
@@ -0,0 +1,3406 @@
+/*
+ * drivers/media/video/sun4i_csi/device/hi253.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for Hynix HI253 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for Hynix HI253 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][HI253]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][HI253]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][HI253]"x,##arg)
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_LOW
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x253
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define UXGA_WIDTH		1600
+#define UXGA_HEIGHT		1200
+#define HD720_WIDTH 	1280
+#define HD720_HEIGHT	720
+#define SVGA_WIDTH		800
+#define SVGA_HEIGHT 	600
+#define VGA_WIDTH		640
+#define VGA_HEIGHT		480
+#define QVGA_WIDTH		320
+#define QVGA_HEIGHT		240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT		288
+#define QCIF_WIDTH		176
+#define	QCIF_HEIGHT		144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 20
+
+/*
+ * The hi253 sits on i2c with ID 0x40
+ */
+#define I2C_ADDR 0x40
+
+//For hi253
+//Sensor address in two-wire serial bus :
+// 40H(write) , 41H(read)
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+static struct regval_list sensor_default_regs[] = {
+	{{0x01}, {0x79}}, //sleep on
+	{{0x08}, {0x0f}}, //Hi-Z on
+	{{0x01}, {0x78}}, //sleep off
+
+	{{0x03}, {0x00}}, // Dummy 750us START
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}}, // Dummy 750us END
+
+	{{0x0e}, {0x03}}, //PLL On
+	{{0x0e}, {0x73}}, //PLLx2
+
+	{{0x03}, {0x00}}, // Dummy 750us START
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}}, // Dummy 750us END
+
+	{{0x0e}, {0x00}}, //PLL off
+	{{0x01}, {0x71}}, //sleep on
+	{{0x08}, {0x00}}, //Hi-Z off
+
+	{{0x01}, {0x73}},
+	{{0x01}, {0x71}},
+
+	// PAGE 20
+	{{0x03}, {0x20}}, //page 20
+	{{0x10}, {0x1c}}, //ae off
+
+	// PAGE 22
+	{{0x03}, {0x22}}, //page 22
+	{{0x10}, {0x69}}, //awb off
+
+
+	//Initial Start
+	/////// PAGE 0 START ///////
+	{{0x03}, {0x00}},
+	{{0x10}, {0x11}}, // Sub1/2_Preview2 Mode_H binning
+	{{0x11}, {0x90}},
+	{{0x12}, {0x04}},
+
+	{{0x0b}, {0xaa}}, // ESD Check Register
+	{{0x0c}, {0xaa}}, // ESD Check Register
+	{{0x0d}, {0xaa}}, // ESD Check Register
+
+	{{0x20}, {0x00}}, // Windowing start point Y
+	{{0x21}, {0x04}},
+	{{0x22}, {0x00}}, // Windowing start point X
+	{{0x23}, {0x07}},
+
+	{{0x24}, {0x04}},
+	{{0x25}, {0xb0}},
+	{{0x26}, {0x06}},
+	{{0x27}, {0x40}}, // WINROW END
+
+	{{0x40}, {0x01}}, //Hblank 408
+	{{0x41}, {0x98}},
+	{{0x42}, {0x00}}, //Vblank 20
+	{{0x43}, {0x47}},
+
+	{{0x45}, {0x04}},
+	{{0x46}, {0x18}},
+	{{0x47}, {0xd8}},
+
+	//BLC
+	{{0x80}, {0x2e}},
+	{{0x81}, {0x7e}},
+	{{0x82}, {0x90}},
+	{{0x83}, {0x00}},
+	{{0x84}, {0x0c}},
+	{{0x85}, {0x00}},
+	{{0x90}, {0x0c}}, //BLC_TIME_TH_ON
+	{{0x91}, {0x0c}}, //BLC_TIME_TH_OFF
+	{{0x92}, {0x98}}, //BLC_AG_TH_ON
+	{{0x93}, {0x90}}, //BLC_AG_TH_OFF
+	{{0x94}, {0x75}},
+	{{0x95}, {0x70}},
+	{{0x96}, {0xdc}},
+	{{0x97}, {0xfe}},
+	{{0x98}, {0x38}},
+
+	//OutDoor  BLC
+	{{0x99}, {0x43}},
+	{{0x9a}, {0x43}},
+	{{0x9b}, {0x43}},
+	{{0x9c}, {0x43}},
+
+	//Dark BLC
+	{{0xa0}, {0x00}},
+	{{0xa2}, {0x00}},
+	{{0xa4}, {0x00}},
+	{{0xa6}, {0x00}},
+
+	//Normal BLC
+	{{0xa8}, {0x43}},
+	{{0xaa}, {0x43}},
+	{{0xac}, {0x43}},
+	{{0xae}, {0x43}},
+
+	{{0x03}, {0x02}}, //Page 02
+	{{0x10}, {0x00}}, //Mode_test
+	{{0x11}, {0x00}}, //Mode_dead_test
+	{{0x12}, {0x03}}, //pwr_ctl_ctl1
+	{{0x13}, {0x03}}, //Mode_ana_test
+	{{0x14}, {0x00}}, //mode_memory
+	{{0x16}, {0x00}}, //dcdc_ctl1
+	{{0x17}, {0x8c}}, //dcdc_ctl2
+	{{0x18}, {0x4C}}, //analog_func1
+	{{0x19}, {0x00}}, //analog_func2
+	{{0x1a}, {0x39}}, //analog_func3
+	{{0x1b}, {0x00}}, //analog_func4
+	{{0x1c}, {0x09}}, //dcdc_ctl3
+	{{0x1d}, {0x40}}, //dcdc_ctl4
+	{{0x1e}, {0x30}}, //analog_func7
+	{{0x1f}, {0x10}}, //analog_func8
+	{{0x20}, {0x77}}, //pixel bias
+	{{0x21}, {0xde}}, //adc},asp bias
+	{{0x22}, {0xa7}}, //main},bus bias
+	{{0x23}, {0x30}}, //clamp
+	{{0x24}, {0x4a}},
+	{{0x25}, {0x10}},
+	{{0x27}, {0x3c}},
+	{{0x28}, {0x00}},
+	{{0x29}, {0x0c}},
+	{{0x2a}, {0x80}},
+	{{0x2b}, {0x80}},
+	{{0x2c}, {0x02}},
+	{{0x2d}, {0xa0}},
+	{{0x2e}, {0x00}}, // {0x11->{0x00 [20110809 update]
+	{{0x2f}, {0x00}},// {0xa1->{0x00 [20110809 update]
+	{{0x30}, {0x05}}, //swap_ctl
+	{{0x31}, {0x99}},
+	{{0x32}, {0x00}},
+	{{0x33}, {0x00}},
+	{{0x34}, {0x22}},
+	{{0x38}, {0x88}},
+	{{0x39}, {0x88}},
+	{{0x50}, {0x20}},
+	{{0x51}, {0x00}},
+	{{0x52}, {0x01}},
+	{{0x53}, {0xc1}},
+	{{0x54}, {0x10}},
+	{{0x55}, {0x1c}},
+	{{0x56}, {0x11}},
+	{{0x58}, {0x10}},
+	{{0x59}, {0x0e}},
+	{{0x5d}, {0xa2}},
+	{{0x5e}, {0x5a}},
+	{{0x60}, {0x87}},
+	{{0x61}, {0x99}},
+	{{0x62}, {0x88}},
+	{{0x63}, {0x97}},
+	{{0x64}, {0x88}},
+	{{0x65}, {0x97}},
+	{{0x67}, {0x0c}},
+	{{0x68}, {0x0c}},
+	{{0x69}, {0x0c}},
+	{{0x6a}, {0xb4}},
+	{{0x6b}, {0xc4}},
+	{{0x6c}, {0xb5}},
+	{{0x6d}, {0xc2}},
+	{{0x6e}, {0xb5}},
+	{{0x6f}, {0xc0}},
+	{{0x70}, {0xb6}},
+	{{0x71}, {0xb8}},
+	{{0x72}, {0x89}},
+	{{0x73}, {0x96}},
+	{{0x74}, {0x89}},
+	{{0x75}, {0x96}},
+	{{0x76}, {0x89}},
+	{{0x77}, {0x96}},
+	{{0x7c}, {0x85}},
+	{{0x7d}, {0xaf}},
+	{{0x80}, {0x01}},
+	{{0x81}, {0x7f}},
+	{{0x82}, {0x13}}, //rx_on1_read
+	{{0x83}, {0x24}},
+	{{0x84}, {0x7D}},
+	{{0x85}, {0x81}},
+	{{0x86}, {0x7D}},
+	{{0x87}, {0x81}},
+	{{0x88}, {0xab}},
+	{{0x89}, {0xbc}},
+	{{0x8a}, {0xac}},
+	{{0x8b}, {0xba}},
+	{{0x8c}, {0xad}},
+	{{0x8d}, {0xb8}},
+	{{0x8e}, {0xae}},
+	{{0x8f}, {0xb2}},
+	{{0x90}, {0xb3}},
+	{{0x91}, {0xb7}},
+	{{0x92}, {0x48}},
+	{{0x93}, {0x54}},
+	{{0x94}, {0x7D}},
+	{{0x95}, {0x81}},
+	{{0x96}, {0x7D}},
+	{{0x97}, {0x81}},
+	{{0xa0}, {0x02}},
+	{{0xa1}, {0x7B}},
+	{{0xa2}, {0x02}},
+	{{0xa3}, {0x7B}},
+	{{0xa4}, {0x7B}},
+	{{0xa5}, {0x02}},
+	{{0xa6}, {0x7B}},
+	{{0xa7}, {0x02}},
+	{{0xa8}, {0x85}},
+	{{0xa9}, {0x8C}},
+	{{0xaa}, {0x85}},
+	{{0xab}, {0x8C}},
+	{{0xac}, {0x10}}, //Rx_pwr_off1_read
+	{{0xad}, {0x16}}, //Rx_pwr_on1_read
+	{{0xae}, {0x10}}, //Rx_pwr_off2_read
+	{{0xaf}, {0x16}}, //Rx_pwr_on1_read
+	{{0xb0}, {0x99}},
+	{{0xb1}, {0xA3}},
+	{{0xb2}, {0xA4}},
+	{{0xb3}, {0xAE}},
+	{{0xb4}, {0x9B}},
+	{{0xb5}, {0xA2}},
+	{{0xb6}, {0xA6}},
+	{{0xb7}, {0xAC}},
+	{{0xb8}, {0x9B}},
+	{{0xb9}, {0x9F}},
+	{{0xba}, {0xA6}},
+	{{0xbb}, {0xAA}},
+	{{0xbc}, {0x9B}},
+	{{0xbd}, {0x9F}},
+	{{0xbe}, {0xA6}},
+	{{0xbf}, {0xaa}},
+	{{0xc4}, {0x2c}},
+	{{0xc5}, {0x43}},
+	{{0xc6}, {0x63}},
+	{{0xc7}, {0x79}},
+	{{0xc8}, {0x2d}},
+	{{0xc9}, {0x42}},
+	{{0xca}, {0x2d}},
+	{{0xcb}, {0x42}},
+	{{0xcc}, {0x64}},
+	{{0xcd}, {0x78}},
+	{{0xce}, {0x64}},
+	{{0xcf}, {0x78}},
+	{{0xd0}, {0x0a}},
+	{{0xd1}, {0x09}},
+	{{0xd2}, {0x20}},
+	{{0xd3}, {0x00}},
+
+	{{0xd4}, {0x0c}},
+	{{0xd5}, {0x0c}},
+	{{0xd6}, {0x98}},
+	{{0xd7}, {0x90}},
+
+	{{0xe0}, {0xc4}},
+	{{0xe1}, {0xc4}},
+	{{0xe2}, {0xc4}},
+	{{0xe3}, {0xc4}},
+	{{0xe4}, {0x00}},
+	{{0xe8}, {0x80}},
+	{{0xe9}, {0x40}},
+	{{0xea}, {0x7f}},
+	{{0xf0}, {0x01}}, //sram1_cfg
+	{{0xf1}, {0x01}}, //sram2_cfg
+	{{0xf2}, {0x01}}, //sram3_cfg
+	{{0xf3}, {0x01}}, //sram4_cfg
+	{{0xf4}, {0x01}}, //sram5_cfg
+
+	/////// PAGE 3 ///////
+	{{0x03}, {0x03}},
+	{{0x10}, {0x10}},
+
+	/////// PAGE 10 START ///////
+	{{0x03}, {0x10}},
+	{{0x10}, {0x03}}, // CrYCbY // For Demoset {0x03
+	{{0x12}, {0x30}},
+	{{0x13}, {0x0a}}, // contrast on
+	{{0x20}, {0x00}},
+
+	{{0x30}, {0x00}},
+	{{0x31}, {0x00}},
+	{{0x32}, {0x00}},
+	{{0x33}, {0x00}},
+
+	{{0x34}, {0x30}},
+	{{0x35}, {0x00}},
+	{{0x36}, {0x00}},
+	{{0x38}, {0x00}},
+	{{0x3e}, {0x58}},
+	{{0x3f}, {0x00}},
+
+	{{0x40}, {0x80}}, // YOFS
+	{{0x41}, {0x00}}, // DYOFS
+	{{0x48}, {0x80}}, // Contrast
+
+	{{0x60}, {0x67}},
+	{{0x61}, {0x7c}}, //7e //8e //88 //80
+	{{0x62}, {0x7c}}, //7e //8e //88 //80
+	{{0x63}, {0x50}}, //Double_AG 50->30
+	{{0x64}, {0x41}},
+
+	{{0x66}, {0x42}},
+	{{0x67}, {0x20}},
+
+	{{0x6a}, {0x80}}, //8a
+	{{0x6b}, {0x84}}, //74
+	{{0x6c}, {0x80}}, //7e //7a
+	{{0x6d}, {0x80}}, //8e
+
+	//Don't touch//////////////////////////
+	//{{0x72}, {0x84}},
+	//{{0x76}, {0x19}},
+	//{{0x73}, {0x70}},
+	//{{0x74}, {0x68}},
+	//{{0x75}, {0x60}}, // white protection ON
+	//{{0x77}, {0x0e}}, //08 //0a
+	//{{0x78}, {0x2a}}, //20
+	//{{0x79}, {0x08}},
+	////////////////////////////////////////
+
+	/////// PAGE 11 START ///////
+	{{0x03}, {0x11}},
+	{{0x10}, {0x7f}},
+	{{0x11}, {0x40}},
+	{{0x12}, {0x0a}}, // Blue Max-Filter Delete
+	{{0x13}, {0xbb}},
+
+	{{0x26}, {0x31}}, // Double_AG 31->20
+	{{0x27}, {0x34}}, // Double_AG 34->22
+	{{0x28}, {0x0f}},
+	{{0x29}, {0x10}},
+	{{0x2b}, {0x30}},
+	{{0x2c}, {0x32}},
+
+	//Out2 D-LPF th
+	{{0x30}, {0x70}},
+	{{0x31}, {0x10}},
+	{{0x32}, {0x58}},
+	{{0x33}, {0x09}},
+	{{0x34}, {0x06}},
+	{{0x35}, {0x03}},
+
+	//Out1 D-LPF th
+	{{0x36}, {0x70}},
+	{{0x37}, {0x18}},
+	{{0x38}, {0x58}},
+	{{0x39}, {0x09}},
+	{{0x3a}, {0x06}},
+	{{0x3b}, {0x03}},
+
+	//Indoor D-LPF th
+	{{0x3c}, {0x80}},
+	{{0x3d}, {0x18}},
+	{{0x3e}, {0xa0}}, //80
+	{{0x3f}, {0x0c}},
+	{{0x40}, {0x09}},
+	{{0x41}, {0x06}},
+
+	{{0x42}, {0x80}},
+	{{0x43}, {0x18}},
+	{{0x44}, {0xa0}}, //80
+	{{0x45}, {0x12}},
+	{{0x46}, {0x10}},
+	{{0x47}, {0x10}},
+
+	{{0x48}, {0x90}},
+	{{0x49}, {0x40}},
+	{{0x4a}, {0x80}},
+	{{0x4b}, {0x13}},
+	{{0x4c}, {0x10}},
+	{{0x4d}, {0x11}},
+
+	{{0x4e}, {0x80}},
+	{{0x4f}, {0x30}},
+	{{0x50}, {0x80}},
+	{{0x51}, {0x13}},
+	{{0x52}, {0x10}},
+	{{0x53}, {0x13}},
+
+	{{0x54}, {0x11}},
+	{{0x55}, {0x17}},
+	{{0x56}, {0x20}},
+	{{0x57}, {0x01}},
+	{{0x58}, {0x00}},
+	{{0x59}, {0x00}},
+
+	{{0x5a}, {0x1f}}, //18
+	{{0x5b}, {0x00}},
+	{{0x5c}, {0x00}},
+
+	{{0x60}, {0x3f}},
+	{{0x62}, {0x60}},
+	{{0x70}, {0x06}},
+
+	/////// PAGE 12 START ///////
+	{{0x03}, {0x12}},
+	{{0x20}, {0x0f}},
+	{{0x21}, {0x0f}},
+
+	{{0x25}, {0x00}}, //{0x30
+
+	{{0x28}, {0x00}},
+	{{0x29}, {0x00}},
+	{{0x2a}, {0x00}},
+
+	{{0x30}, {0x50}},
+	{{0x31}, {0x18}},
+	{{0x32}, {0x32}},
+	{{0x33}, {0x40}},
+	{{0x34}, {0x50}},
+	{{0x35}, {0x70}},
+	{{0x36}, {0xa0}},
+
+	{{0x3b}, {0x06}},
+	{{0x3c}, {0x06}},
+
+
+	//Out2 th
+	{{0x40}, {0xa0}},
+	{{0x41}, {0x40}},
+	{{0x42}, {0xa0}},
+	{{0x43}, {0x90}},
+	{{0x44}, {0x90}},
+	{{0x45}, {0x80}},
+
+	//Out1 th
+	{{0x46}, {0xb0}},
+	{{0x47}, {0x55}},
+	{{0x48}, {0xa0}},
+	{{0x49}, {0x90}},
+	{{0x4a}, {0x90}},
+	{{0x4b}, {0x80}},
+
+	//Indoor th
+	{{0x4c}, {0xb0}},
+	{{0x4d}, {0x40}},
+	{{0x4e}, {0x90}},
+	{{0x4f}, {0x90}},
+	{{0x50}, {0xa0}},
+	{{0x51}, {0x80}},
+
+	//Dark1 th
+	{{0x52}, {0xb0}},
+	{{0x53}, {0x60}},
+	{{0x54}, {0xc0}},
+	{{0x55}, {0xc0}},
+	{{0x56}, {0xc0}},
+	{{0x57}, {0x80}},
+
+	//Dark2 th
+	{{0x58}, {0x90}},
+	{{0x59}, {0x40}},
+	{{0x5a}, {0xd0}},
+	{{0x5b}, {0xd0}},
+	{{0x5c}, {0xe0}},
+	{{0x5d}, {0x80}},
+
+	//Dark3 th
+	{{0x5e}, {0x88}},
+	{{0x5f}, {0x40}},
+	{{0x60}, {0xe0}},
+	{{0x61}, {0xe0}},
+	{{0x62}, {0xe0}},
+	{{0x63}, {0x80}},
+
+	{{0x70}, {0x15}},
+	{{0x71}, {0x01}}, //Don't Touch register
+
+	{{0x72}, {0x18}},
+	{{0x73}, {0x01}}, //Don't Touch register
+
+	{{0x74}, {0x25}},
+	{{0x75}, {0x15}},
+
+
+	{{0x90}, {0x5d}}, //DPC
+	{{0x91}, {0x88}},
+	{{0x98}, {0x7d}},
+	{{0x99}, {0x28}},
+	{{0x9A}, {0x14}},
+	{{0x9B}, {0xc8}},
+	{{0x9C}, {0x02}},
+	{{0x9D}, {0x1e}},
+	{{0x9E}, {0x28}},
+	{{0x9F}, {0x07}},
+	{{0xA0}, {0x32}},
+	{{0xA4}, {0x04}},
+	{{0xA5}, {0x0e}},
+	{{0xA6}, {0x0c}},
+	{{0xA7}, {0x04}},
+	{{0xA8}, {0x3c}},
+
+	{{0xAA}, {0x14}},
+	{{0xAB}, {0x11}},
+	{{0xAC}, {0x0f}},
+	{{0xAD}, {0x16}},
+	{{0xAE}, {0x15}},
+	{{0xAF}, {0x14}},
+
+	{{0xB1}, {0xaa}},
+	{{0xB2}, {0x96}},
+	{{0xB3}, {0x28}},
+	//{{0xB6},read}}, only//dpc_flat_thres
+	//{{0xB7},read}}, only//dpc_grad_cnt
+	{{0xB8}, {0x78}},
+	{{0xB9}, {0xa0}},
+	{{0xBA}, {0xb4}},
+	{{0xBB}, {0x14}},
+	{{0xBC}, {0x14}},
+	{{0xBD}, {0x14}},
+	{{0xBE}, {0x64}},
+	{{0xBF}, {0x64}},
+	{{0xC0}, {0x64}},
+	{{0xC1}, {0x64}},
+	{{0xC2}, {0x04}},
+	{{0xC3}, {0x03}},
+	{{0xC4}, {0x0c}},
+	{{0xC5}, {0x30}},
+	{{0xC6}, {0x2a}},
+	{{0xD0}, {0x0c}}, //CI Option/CI DPC
+	{{0xD1}, {0x80}},
+	{{0xD2}, {0x67}},
+	{{0xD3}, {0x00}},
+	{{0xD4}, {0x00}},
+	{{0xD5}, {0x02}},
+	{{0xD6}, {0xff}},
+	{{0xD7}, {0x18}},
+
+	/////// PAGE 13 START ///////
+	{{0x03}, {0x13}},
+	//Edge
+	{{0x10}, {0xcb}},
+	{{0x11}, {0x7b}},
+	{{0x12}, {0x07}},
+	{{0x14}, {0x00}},
+
+	{{0x20}, {0x15}},
+	{{0x21}, {0x13}},
+	{{0x22}, {0x33}},
+	{{0x23}, {0x05}},
+	{{0x24}, {0x09}},
+
+	{{0x25}, {0x0a}},
+
+	{{0x26}, {0x18}},
+	{{0x27}, {0x30}},
+	{{0x29}, {0x12}},
+	{{0x2a}, {0x50}},
+
+	//Low clip th
+	{{0x2b}, {0x00}}, //Out2 02
+	{{0x2c}, {0x00}}, //Out1 02 //01
+	{{0x25}, {0x06}},
+	{{0x2d}, {0x0c}},
+	{{0x2e}, {0x12}},
+	{{0x2f}, {0x12}},
+
+	//Out2 Edge
+	{{0x50}, {0x18}}, //{0x10 //{0x16
+	{{0x51}, {0x1c}}, //{0x14 //{0x1a
+	{{0x52}, {0x1a}}, //{0x12 //{0x18
+	{{0x53}, {0x14}}, //{0x0c //{0x12
+	{{0x54}, {0x17}}, //{0x0f //{0x15
+	{{0x55}, {0x14}}, //{0x0c //{0x12
+
+	//Out1 Edge 		 //Edge
+	{{0x56}, {0x18}}, //{0x10 //{0x16
+	{{0x57}, {0x1c}}, //{0x13 //{0x1a
+	{{0x58}, {0x1a}}, //{0x12 //{0x18
+	{{0x59}, {0x14}}, //{0x0c //{0x12
+	{{0x5a}, {0x17}}, //{0x0f //{0x15
+	{{0x5b}, {0x14}}, //{0x0c //{0x12
+
+	//Indoor Edge
+	{{0x5c}, {0x0a}},
+	{{0x5d}, {0x0b}},
+	{{0x5e}, {0x0a}},
+	{{0x5f}, {0x08}},
+	{{0x60}, {0x09}},
+	{{0x61}, {0x08}},
+
+	//Dark1 Edge
+	{{0x62}, {0x08}},
+	{{0x63}, {0x08}},
+	{{0x64}, {0x08}},
+	{{0x65}, {0x06}},
+	{{0x66}, {0x06}},
+	{{0x67}, {0x06}},
+
+	//Dark2 Edge
+	{{0x68}, {0x07}},
+	{{0x69}, {0x07}},
+	{{0x6a}, {0x07}},
+	{{0x6b}, {0x05}},
+	{{0x6c}, {0x05}},
+	{{0x6d}, {0x05}},
+
+	//Dark3 Edge
+	{{0x6e}, {0x07}},
+	{{0x6f}, {0x07}},
+	{{0x70}, {0x07}},
+	{{0x71}, {0x05}},
+	{{0x72}, {0x05}},
+	{{0x73}, {0x05}},
+
+	//2DY
+	{{0x80}, {0xfd}},
+	{{0x81}, {0x1f}},
+	{{0x82}, {0x05}},
+	{{0x83}, {0x31}},
+
+	{{0x90}, {0x05}},
+	{{0x91}, {0x05}},
+	{{0x92}, {0x33}},
+	{{0x93}, {0x30}},
+	{{0x94}, {0x03}},
+	{{0x95}, {0x14}},
+	{{0x97}, {0x20}},
+	{{0x99}, {0x20}},
+
+	{{0xa0}, {0x01}},
+	{{0xa1}, {0x02}},
+	{{0xa2}, {0x01}},
+	{{0xa3}, {0x02}},
+	{{0xa4}, {0x05}},
+	{{0xa5}, {0x05}},
+	{{0xa6}, {0x07}},
+	{{0xa7}, {0x08}},
+	{{0xa8}, {0x07}},
+	{{0xa9}, {0x08}},
+	{{0xaa}, {0x07}},
+	{{0xab}, {0x08}},
+
+	//Out2
+	{{0xb0}, {0x22}},
+	{{0xb1}, {0x2a}},
+	{{0xb2}, {0x28}},
+	{{0xb3}, {0x22}},
+	{{0xb4}, {0x2a}},
+	{{0xb5}, {0x28}},
+
+	//Out1
+	{{0xb6}, {0x22}},
+	{{0xb7}, {0x2a}},
+	{{0xb8}, {0x28}},
+	{{0xb9}, {0x22}},
+	{{0xba}, {0x2a}},
+	{{0xbb}, {0x28}},
+
+	//Indoor
+	{{0xbc}, {0x25}},
+	{{0xbd}, {0x2a}},
+	{{0xbe}, {0x27}},
+	{{0xbf}, {0x25}},
+	{{0xc0}, {0x2a}},
+	{{0xc1}, {0x27}},
+
+	//Dark1
+	{{0xc2}, {0x1e}},
+	{{0xc3}, {0x24}},
+	{{0xc4}, {0x20}},
+	{{0xc5}, {0x1e}},
+	{{0xc6}, {0x24}},
+	{{0xc7}, {0x20}},
+
+	//Dark2
+	{{0xc8}, {0x18}},
+	{{0xc9}, {0x20}},
+	{{0xca}, {0x1e}},
+	{{0xcb}, {0x18}},
+	{{0xcc}, {0x20}},
+	{{0xcd}, {0x1e}},
+
+	//Dark3
+	{{0xce}, {0x18}},
+	{{0xcf}, {0x20}},
+	{{0xd0}, {0x1e}},
+	{{0xd1}, {0x18}},
+	{{0xd2}, {0x20}},
+	{{0xd3}, {0x1e}},
+
+	/////// PAGE 14 START ///////
+	{{0x03}, {0x14}},
+	{{0x10}, {0x11}},
+
+	{{0x14}, {0x80}}, // GX
+	{{0x15}, {0x80}}, // GY
+	{{0x16}, {0x80}}, // RX
+	{{0x17}, {0x80}}, // RY
+	{{0x18}, {0x80}}, // BX
+	{{0x19}, {0x80}}, // BY
+
+	{{0x20}, {0x60}}, //X 60 //a0
+	{{0x21}, {0x80}}, //Y
+
+	{{0x22}, {0x80}},
+	{{0x23}, {0x80}},
+	{{0x24}, {0x80}},
+
+	{{0x30}, {0xc8}},
+	{{0x31}, {0x2b}},
+	{{0x32}, {0x00}},
+	{{0x33}, {0x00}},
+	{{0x34}, {0x90}},
+
+	{{0x40}, {0x48}}, //31
+	{{0x50}, {0x34}}, //23 //32
+	{{0x60}, {0x29}}, //1a //27
+	{{0x70}, {0x34}}, //23 //32
+
+	/////// PAGE 15 START ///////
+	{{0x03}, {0x15}},
+	{{0x10}, {0x0f}},
+
+	//Rstep H 16
+	//Rstep L 14
+	{{0x14}, {0x42}}, //CMCOFSGH_Day //4c
+	{{0x15}, {0x32}}, //CMCOFSGM_CWF //3c
+	{{0x16}, {0x24}}, //CMCOFSGL_A //2e
+	{{0x17}, {0x2f}}, //CMC SIGN
+
+	//CMC_Default_CWF
+	{{0x30}, {0x8f}},
+	{{0x31}, {0x59}},
+	{{0x32}, {0x0a}},
+	{{0x33}, {0x15}},
+	{{0x34}, {0x5b}},
+	{{0x35}, {0x06}},
+	{{0x36}, {0x07}},
+	{{0x37}, {0x40}},
+	{{0x38}, {0x87}}, //86
+
+	//CMC OFS L_A
+	{{0x40}, {0x92}},
+	{{0x41}, {0x1b}},
+	{{0x42}, {0x89}},
+	{{0x43}, {0x81}},
+	{{0x44}, {0x00}},
+	{{0x45}, {0x01}},
+	{{0x46}, {0x89}},
+	{{0x47}, {0x9e}},
+	{{0x48}, {0x28}},
+
+	//{{0x40}, {0x93}},
+	//{{0x41}, {0x1c}},
+	//{{0x42}, {0x89}},
+	//{{0x43}, {0x82}},
+	//{{0x44}, {0x01}},
+	//{{0x45}, {0x01}},
+	//{{0x46}, {0x8a}},
+	//{{0x47}, {0x9d}},
+	//{{0x48}, {0x28}},
+
+	//CMC POFS H_DAY
+	{{0x50}, {0x02}},
+	{{0x51}, {0x82}},
+	{{0x52}, {0x00}},
+	{{0x53}, {0x07}},
+	{{0x54}, {0x11}},
+	{{0x55}, {0x98}},
+	{{0x56}, {0x00}},
+	{{0x57}, {0x0b}},
+	{{0x58}, {0x8b}},
+
+	{{0x80}, {0x03}},
+	{{0x85}, {0x40}},
+	{{0x87}, {0x02}},
+	{{0x88}, {0x00}},
+	{{0x89}, {0x00}},
+	{{0x8a}, {0x00}},
+
+	/////// PAGE 16 START ///////
+	{{0x03}, {0x16}},
+	{{0x10}, {0x31}},
+	{{0x18}, {0x5e}},// Double_AG 5e->37
+	{{0x19}, {0x5d}},// Double_AG 5e->36
+	{{0x1a}, {0x0e}},
+	{{0x1b}, {0x01}},
+	{{0x1c}, {0xdc}},
+	{{0x1d}, {0xfe}},
+
+	//GMA Default
+	{{0x30}, {0x00}},
+	{{0x31}, {0x0a}},
+	{{0x32}, {0x1f}},
+	{{0x33}, {0x33}},
+	{{0x34}, {0x53}},
+	{{0x35}, {0x6c}},
+	{{0x36}, {0x81}},
+	{{0x37}, {0x94}},
+	{{0x38}, {0xa4}},
+	{{0x39}, {0xb3}},
+	{{0x3a}, {0xc0}},
+	{{0x3b}, {0xcb}},
+	{{0x3c}, {0xd5}},
+	{{0x3d}, {0xde}},
+	{{0x3e}, {0xe6}},
+	{{0x3f}, {0xee}},
+	{{0x40}, {0xf5}},
+	{{0x41}, {0xfc}},
+	{{0x42}, {0xff}},
+	//RGMA
+	{{0x50}, {0x00}},
+	{{0x51}, {0x09}},
+	{{0x52}, {0x1f}},
+	{{0x53}, {0x37}},
+	{{0x54}, {0x5b}},
+	{{0x55}, {0x76}},
+	{{0x56}, {0x8d}},
+	{{0x57}, {0xa1}},
+	{{0x58}, {0xb2}},
+	{{0x59}, {0xbe}},
+	{{0x5a}, {0xc9}},
+	{{0x5b}, {0xd2}},
+	{{0x5c}, {0xdb}},
+	{{0x5d}, {0xe3}},
+	{{0x5e}, {0xeb}},
+	{{0x5f}, {0xf0}},
+	{{0x60}, {0xf5}},
+	{{0x61}, {0xf7}},
+	{{0x62}, {0xf8}},
+	//BGMA
+	{{0x70}, {0x00}}, // new gamma for low noise
+	{{0x71}, {0x07}},
+	{{0x72}, {0x0c}},
+	{{0x73}, {0x18}},
+	{{0x74}, {0x31}},
+	{{0x75}, {0x4d}},
+	{{0x76}, {0x69}},
+	{{0x77}, {0x83}},
+	{{0x78}, {0x9b}},
+	{{0x79}, {0xb1}},
+	{{0x7a}, {0xc3}},
+	{{0x7b}, {0xd2}},
+	{{0x7c}, {0xde}},
+	{{0x7d}, {0xe8}},
+	{{0x7e}, {0xf0}},
+	{{0x7f}, {0xf5}},
+	{{0x80}, {0xfa}},
+	{{0x81}, {0xfd}},
+	{{0x82}, {0xff}},
+
+	/////// PAGE 17 START ///////
+	{{0x03}, {0x17}},
+	{{0x10}, {0xf7}},
+
+	/////// PAGE 20 START ///////
+	{{0x03}, {0x20}},
+	{{0x11}, {0x1c}},
+	{{0x18}, {0x30}},
+	{{0x1a}, {0x08}},
+	{{0x20}, {0x01}}, //05_lowtemp Y Mean off
+	{{0x21}, {0x30}},
+	{{0x22}, {0x10}},
+	{{0x23}, {0x00}},
+	{{0x24}, {0x00}}, //Uniform Scene Off
+
+	{{0x28}, {0xe7}},
+	{{0x29}, {0x0d}}, //20100305 ad->0d
+	{{0x2a}, {0xff}},
+	{{0x2b}, {0x04}}, //f4->Adaptive off
+
+	{{0x2c}, {0xc2}},
+	{{0x2d}, {0xcf}},  //fe->AE Speed option
+	{{0x2e}, {0x33}},
+	{{0x30}, {0x78}}, //f8
+	{{0x32}, {0x03}},
+	{{0x33}, {0x2e}},
+	{{0x34}, {0x30}},
+	{{0x35}, {0xd4}},
+	{{0x36}, {0xfe}},
+	{{0x37}, {0x32}},
+	{{0x38}, {0x04}},
+
+	{{0x39}, {0x22}}, //AE_escapeC10
+	{{0x3a}, {0xde}}, //AE_escapeC11
+
+	{{0x3b}, {0x22}}, //AE_escapeC1
+	{{0x3c}, {0xde}}, //AE_escapeC2
+
+	{{0x50}, {0x45}},
+	{{0x51}, {0x88}},
+
+	{{0x56}, {0x03}},
+	{{0x57}, {0xf7}},
+	{{0x58}, {0x14}},
+	{{0x59}, {0x88}},
+	{{0x5a}, {0x04}},
+
+	//New Weight For Samsung
+	{{0x60}, {0xff}},
+	{{0x61}, {0xff}},
+	{{0x62}, {0xea}},
+	{{0x63}, {0xab}},
+	{{0x64}, {0xea}},
+	{{0x65}, {0xab}},
+	{{0x66}, {0xeb}},
+	{{0x67}, {0xeb}},
+	{{0x68}, {0xeb}},
+	{{0x69}, {0xeb}},
+	{{0x6a}, {0xea}},
+	{{0x6b}, {0xab}},
+	{{0x6c}, {0xea}},
+	{{0x6d}, {0xab}},
+	{{0x6e}, {0xff}},
+	{{0x6f}, {0xff}},
+
+	//{{0x60}, {0x55}}, // AEWGT1
+	//{{0x61}, {0x55}}, // AEWGT2
+	//{{0x62}, {0x6a}}, // AEWGT3
+	//{{0x63}, {0xa9}}, // AEWGT4
+	//{{0x64}, {0x6a}}, // AEWGT5
+	//{{0x65}, {0xa9}}, // AEWGT6
+	//{{0x66}, {0x6a}}, // AEWGT7
+	//{{0x67}, {0xa9}}, // AEWGT8
+	//{{0x68}, {0x6b}}, // AEWGT9
+	//{{0x69}, {0xe9}}, // AEWGT10
+	//{{0x6a}, {0x6a}}, // AEWGT11
+	//{{0x6b}, {0xa9}}, // AEWGT12
+	//{{0x6c}, {0x6a}}, // AEWGT13
+	//{{0x6d}, {0xa9}}, // AEWGT14
+	//{{0x6e}, {0x55}}, // AEWGT15
+	//{{0x6f}, {0x55}}, // AEWGT16
+
+	{{0x70}, {0x76}}, //6e
+	{{0x71}, {0x89}}, //00 //-4
+
+	// haunting control
+	{{0x76}, {0x43}},
+	{{0x77}, {0xe2}}, //04 //f2
+
+	{{0x78}, {0x23}}, //Yth1
+	{{0x79}, {0x42}}, //Yth2 //46
+	{{0x7a}, {0x23}}, //23
+	{{0x7b}, {0x22}}, //22
+	{{0x7d}, {0x23}},
+
+	{{0x83}, {0x01}}, //EXP Normal 33.33 fps
+	{{0x84}, {0x5f}},
+	{{0x85}, {0x00}},
+
+	{{0x86}, {0x02}}, //EXPMin 5859.38 fps
+	{{0x87}, {0x00}},
+
+	{{0x88}, {0x05}}, //EXP Max 8.00 fps
+	{{0x89}, {0x7c}},
+	{{0x8a}, {0x00}},
+
+	{{0x8B}, {0x75}}, //EXP100
+	{{0x8C}, {0x00}},
+	{{0x8D}, {0x61}}, //EXP120
+	{{0x8E}, {0x00}},
+
+	{{0x9c}, {0x18}}, //EXP Limit 488.28 fps
+	{{0x9d}, {0x00}},
+	{{0x9e}, {0x02}}, //EXP Unit
+	{{0x9f}, {0x00}},
+
+	//AE_Middle Time option
+	//{{0xa0}, {0x03}},
+	//{{0xa1}, {0xa9}},
+	//{{0xa2}, {0x80}},
+
+	{{0xb0}, {0x18}},
+	{{0xb1}, {0x14}}, //ADC 400->560
+	{{0xb2}, {0xa0}},
+	{{0xb3}, {0x18}},
+	{{0xb4}, {0x1a}},
+	{{0xb5}, {0x44}},
+	{{0xb6}, {0x2f}},
+	{{0xb7}, {0x28}},
+	{{0xb8}, {0x25}},
+	{{0xb9}, {0x22}},
+	{{0xba}, {0x21}},
+	{{0xbb}, {0x20}},
+	{{0xbc}, {0x1f}},
+	{{0xbd}, {0x1f}},
+
+	{{0xc0}, {0x14}},
+	{{0xc1}, {0x1f}},
+	{{0xc2}, {0x1f}},
+	{{0xc3}, {0x18}}, //2b
+	{{0xc4}, {0x10}}, //08
+
+	{{0xc8}, {0x80}},
+	{{0xc9}, {0x40}},
+
+	/////// PAGE 22 START ///////
+	{{0x03}, {0x22}},
+	{{0x10}, {0xfd}},
+	{{0x11}, {0x2e}},
+	{{0x19}, {0x01}}, // Low On //
+	{{0x20}, {0x30}},
+	{{0x21}, {0x80}},
+	{{0x24}, {0x01}},
+	//{{0x25}, {0x00}}, //7f New Lock Cond & New light stable
+
+	{{0x30}, {0x80}},
+	{{0x31}, {0x80}},
+	{{0x38}, {0x11}},
+	{{0x39}, {0x34}},
+
+	{{0x40}, {0xf7}}, //
+	{{0x41}, {0x55}}, //44
+	{{0x42}, {0x33}}, //43
+
+	{{0x43}, {0xf7}},
+	{{0x44}, {0x55}}, //44
+	{{0x45}, {0x44}}, //33
+
+	{{0x46}, {0x00}},
+	{{0x50}, {0xb2}},
+	{{0x51}, {0x81}},
+	{{0x52}, {0x98}},
+
+	{{0x80}, {0x40}}, //3e
+	{{0x81}, {0x20}},
+	{{0x82}, {0x3e}},
+
+	{{0x83}, {0x5e}}, //5e
+	{{0x84}, {0x1e}}, //24
+	{{0x85}, {0x5e}}, //54 //56 //5a
+	{{0x86}, {0x22}}, //24 //22
+
+	{{0x87}, {0x40}},
+	{{0x88}, {0x30}},
+	{{0x89}, {0x3f}}, //38
+	{{0x8a}, {0x28}}, //2a
+
+	{{0x8b}, {0x40}}, //47
+	{{0x8c}, {0x33}},
+	{{0x8d}, {0x39}},
+	{{0x8e}, {0x30}}, //2c
+
+	{{0x8f}, {0x53}}, //4e
+	{{0x90}, {0x52}}, //4d
+	{{0x91}, {0x51}}, //4c
+	{{0x92}, {0x4e}}, //4a
+	{{0x93}, {0x4a}}, //46
+	{{0x94}, {0x45}},
+	{{0x95}, {0x3d}},
+	{{0x96}, {0x31}},
+	{{0x97}, {0x28}},
+	{{0x98}, {0x24}},
+	{{0x99}, {0x20}},
+	{{0x9a}, {0x20}},
+
+	{{0x9b}, {0x77}},
+	{{0x9c}, {0x77}},
+	{{0x9d}, {0x48}},
+	{{0x9e}, {0x38}},
+	{{0x9f}, {0x30}},
+
+	{{0xa0}, {0x60}},
+	{{0xa1}, {0x34}},
+	{{0xa2}, {0x6f}},
+	{{0xa3}, {0xff}},
+
+	{{0xa4}, {0x14}}, //1500fps
+	{{0xa5}, {0x2c}}, // 700fps
+	{{0xa6}, {0xcf}},
+
+	{{0xad}, {0x40}},
+	{{0xae}, {0x4a}},
+
+	{{0xaf}, {0x28}},  // low temp Rgain
+	{{0xb0}, {0x26}},  // low temp Rgain
+
+	{{0xb1}, {0x00}}, //{0x20 -> {0x00 0405 modify
+	{{0xb4}, {0xea}},
+	{{0xb8}, {0xa0}}, //a2: b-2}, R+2  //b4 B-3}, R+4 lowtemp
+	{{0xb9}, {0x00}},
+
+	// PAGE 20
+	{{0x03}, {0x20}}, //page 20
+	{{0x10}, {0x9c}}, //ae off
+
+	// PAGE 22
+	{{0x03}, {0x22}}, //page 22
+	{{0x10}, {0xe9}}, //awb off
+
+	// PAGE 0
+	{{0x03}, {0x00}},
+	{{0x0e}, {0x03}}, //PLL On
+	{{0x0e}, {0x73}}, //PLLx2
+
+	{{0x03}, {0x00}}, // Dummy 750us
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+	{{0x03}, {0x00}},
+
+	{{0x03}, {0x00}}, // Page 0
+	{{0x01}, {0xc0}}, // Sleep Off {0xf8->{0x50 for solve green line issue
+
+	{{0xff}, {0xff}},
+	{{0xff}, {0xff}},
+
+};
+
+static struct regval_list sensor_uxga_regs[] = {
+	//Resolution Setting : 1600*1200
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+
+	{{0x10}, {0x00}},//VGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x04}},
+	{{0x22}, {0x00}},
+	{{0x23}, {0x07}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x98}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x47}},
+};
+
+static struct regval_list sensor_hd720_regs[] = {
+//Resolution Setting : 1280*720
+        {{0x03}, {0x00}},	//PAGEMODE(0x03)
+
+	{{0x10}, {0x00}},//VGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0xf0}},
+	{{0x22}, {0x00}},
+	{{0x23}, {0xa0}},
+
+	{{0x24}, {0x02}},
+	{{0x25}, {0xd0}},
+	{{0x26}, {0x05}},
+	{{0x27}, {0x00}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x98}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x47}},
+
+	 {{0x03}, {0x18}},	//PAGEMODE(0x03)
+     {{0x10}, {0x00}},
+};
+
+static struct regval_list sensor_svga_regs[] = {
+	//Resolution Setting : 800*600
+	 {{0x03}, {0x00}},	//PAGEMODE(0x03)
+
+	{{0x10}, {0x11}},//VGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x04}},
+	{{0x22}, {0x00}},
+	{{0x23}, {0x07}},
+
+	{{0x24}, {0x04}},
+	{{0x25}, {0xb0}},
+	{{0x26}, {0x06}},
+	{{0x27}, {0x40}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x98}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x47}},
+
+	 {{0x03}, {0x18}},	//PAGEMODE(0x03)
+     {{0x10}, {0x00}},
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	//Resolution Setting : 600*480
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+
+	{{0x10}, {0x11}},//VGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x04}},
+	{{0x22}, {0x00}},
+	{{0x23}, {0x07}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x98}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x47}},
+
+   {{0x03}, {0x18}},
+   {{0x12}, {0x20}},
+   {{0x10}, {0x07}},
+   {{0x11}, {0x00}},
+   {{0x20}, {0x05}},
+   {{0x21}, {0x00}},
+   {{0x22}, {0x01}},
+   {{0x23}, {0xe0}},
+   {{0x24}, {0x00}},
+   {{0x25}, {0x06}},
+   {{0x26}, {0x00}},
+   {{0x27}, {0x00}},
+   {{0x28}, {0x05}},
+   {{0x29}, {0x06}},
+   {{0x2a}, {0x01}},
+   {{0x2b}, {0xe0}},
+   {{0x2c}, {0x0a}},
+   {{0x2d}, {0x00}},
+   {{0x2e}, {0x0a}},
+   {{0x2f}, {0x00}},
+   {{0x30}, {0x45}},
+
+
+};
+
+static struct regval_list sensor_qvga_regs[] = {
+	//Resolution Setting : 320*240
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+
+	{{0x10}, {0x11}},//VGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x04}},
+	{{0x22}, {0x00}},
+	{{0x23}, {0x07}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x98}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x47}},
+
+   {{0x03}, {0x18}},
+   {{0x12}, {0x20}},
+   {{0x10}, {0x07}},
+   {{0x11}, {0x00}},
+   {{0x20}, {0x02}},
+   {{0x21}, {0x80}},
+   {{0x22}, {0x00}},
+   {{0x23}, {0xf0}},
+   {{0x24}, {0x00}},
+   {{0x25}, {0x06}},
+   {{0x26}, {0x00}},
+   {{0x27}, {0x00}},
+   {{0x28}, {0x02}},
+   {{0x29}, {0x86}},
+   {{0x2a}, {0x00}},
+   {{0x2b}, {0xf0}},
+   {{0x2c}, {0x14}},
+   {{0x2d}, {0x00}},
+   {{0x2e}, {0x14}},
+   {{0x2f}, {0x00}},
+   {{0x30}, {0x65}},
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0x03}, {0x22}},
+	{{0x11}, {0x2e}},
+
+	{{0x83}, {0x5e}},
+	{{0x84}, {0x1e}},
+	{{0x85}, {0x5e}},
+	{{0x86}, {0x22}},
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0x03}, {0x22}},
+	{{0x11}, {0x28}},
+	{{0x80}, {0x71}},
+	{{0x82}, {0x2b}},
+	{{0x83}, {0x72}},
+	{{0x84}, {0x70}},
+	{{0x85}, {0x2b}},
+	{{0x86}, {0x28}},
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0x03}, {0x22}},
+	{{0x11}, {0x28}},
+	{{0x80}, {0x59}},
+	{{0x82}, {0x29}},
+	{{0x83}, {0x60}},
+	{{0x84}, {0x50}},
+	{{0x85}, {0x2f}},
+	{{0x86}, {0x23}},
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0x03}, {0x22}},
+	{{0x11}, {0x28}},
+	{{0x80}, {0x29}},
+	{{0x82}, {0x54}},
+	{{0x83}, {0x2e}},
+	{{0x84}, {0x23}},
+	{{0x85}, {0x58}},
+	{{0x86}, {0x4f}},
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+  {{0x03}, {0x22}},
+	{{0x11}, {0x28}},
+	{{0x80}, {0x41}},
+	{{0x82}, {0x42}},
+	{{0x83}, {0x44}},
+	{{0x84}, {0x34}},
+	{{0x85}, {0x46}},
+	{{0x86}, {0x3a}},
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0x03}, {0x22}},
+	{{0x80}, {0x24}},
+	{{0x81}, {0x20}},
+	{{0x82}, {0x58}},
+	{{0x83}, {0x27}},
+	{{0x84}, {0x22}},
+	{{0x85}, {0x58}},
+	{{0x86}, {0x52}},
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+   {{0x03}, {0x10}},
+   {{0x11}, {0x03}},
+   {{0x12}, {0x30}},
+   {{0x13}, {0x02}},
+   {{0x44}, {0x80}},
+   {{0x45}, {0x80}},
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+   {{0x03}, {0x10}},
+   {{0x11}, {0x03}},
+   {{0x12}, {0x03}},
+   {{0x13}, {0x02}},
+   {{0x40}, {0x00}},
+   {{0x44}, {0x80}},
+   {{0x45}, {0x80}},
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+   {{0x03}, {0x10}},
+   {{0x11}, {0x03}},
+   {{0x12}, {0x33}},
+   {{0x13}, {0x02}},
+   {{0x44}, {0x70}},
+   {{0x45}, {0x98}},
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+   {{0x03}, {0x10}},
+   {{0x11}, {0x03}},
+   {{0x12}, {0x08}},
+   {{0x13}, {0x02}},
+   {{0x14}, {0x00}},
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+   {{0x03}, {0x10}},
+   {{0x11}, {0x03}},
+   {{0x12}, {0x03}},
+   {{0x40}, {0x00}},
+   {{0x13}, {0x02}},
+   {{0x44}, {0xb0}},
+   {{0x45}, {0x40}},
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+  {{0x03}, {0x10}},
+  {{0x11}, {0x03}},
+  {{0x12}, {0x03}},
+  {{0x40}, {0x00}},
+  {{0x13}, {0x02}},
+  {{0x44}, {0x30}},
+  {{0x45}, {0x50}},
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+	//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xe0}}
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xc0}}
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xa0}}
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x90}}
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x00}}
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x10}}
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x20}}
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x30}}
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x40}}
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x44}}
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x54}}
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x64}}
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x74}}
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x84}}
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x94}}
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xa4}}
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xb4}}
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xc4}}
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0x50}},
+	{{0x62},{0x50}}
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0x60}},
+	{{0x62},{0x60}}
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0x70}},
+	{{0x62},{0x70}}
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0x80}},
+	{{0x62},{0x80}}
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0x90}},
+	{{0x62},{0x90}}
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0xa0}},
+	{{0x62},{0xa0}}
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0xb0}},
+	{{0x62},{0xb0}}
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0xc0}},
+	{{0x62},{0xc0}}
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x61},{0xd0}},
+	{{0x62},{0xd0}}
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x58}}
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x60}}
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x68}}
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x70}}
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x76}}
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x80}}
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x88}}
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x90}}
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x98}}
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x03}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x02}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x00}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x01}}	//CbYCrY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+//	for(i = 0; i < REG_STEP; i++)
+//		printk("data[%x]=%x\n",i,data[i]);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_dev_err("sensor_write_err!\n");
+				return ret;
+			}
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x04;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x92)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* UXGA */
+	{
+		.width			= UXGA_WIDTH,
+		.height			= UXGA_HEIGHT,
+		.regs 			= sensor_uxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_uxga_regs),
+		.set_size		= NULL,
+	},
+	/* 720p */
+	{
+		.width			= HD720_WIDTH,
+		.height			= HD720_HEIGHT,
+		.regs				= sensor_hd720_regs,
+		.regs_size	= ARRAY_SIZE(sensor_hd720_regs),
+		.set_size		= NULL,
+	},
+	/* SVGA */
+	{
+		.width			= SVGA_WIDTH,
+		.height			= SVGA_HEIGHT,
+		.regs				= sensor_svga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_svga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width			= VGA_WIDTH,
+		.height			= VGA_HEIGHT,
+		.regs				= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+	/* QVGA */
+	{
+		.width		= QVGA_WIDTH,
+		.height		= QVGA_HEIGHT,
+		.regs 		= sensor_qvga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_qvga_regs),
+		.set_size		= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct v4l2_fract *tpf = &cp->timeperframe;
+	//struct sensor_info *info = to_state(sd);
+	//int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else
+//		div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > CLK_SCALE)
+//		div = CLK_SCALE;
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_CONTRAST:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_SATURATION:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x11 bit0 is hflip enable
+
+	*value = regs.value[0];
+	info->hflip = regs.value[0];
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfe;
+		break;
+	case 1:
+		regs.value[0] |= 0x01;
+		break;
+	default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x11 bit1 is vflip enable
+
+	*value = regs.value[0];
+	info->hflip = regs.value[0];
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfd;
+		break;
+	case 1:
+		regs.value[0] |= 0x02;
+		break;
+	default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x20;		//PAGEMODE 0x20
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x80;
+	if (regs.value[0] == 0x80) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x20;		//PAGEMODE 0x20
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x80;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0x7f;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->autoexp = value;
+
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x22;
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<7);
+	regs.value[0] = regs.value[0]>>7;		//0x10 bit7 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0x7f;
+		break;
+	case 1:
+		regs.value[0] |= 0x80;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+	msleep(10);
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "hi253", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "hi253",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/hi704.c b/drivers/media/video/sun4i_csi/device/hi704.c
new file mode 100644
index 0000000..2e6d81d
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/hi704.c
@@ -0,0 +1,2636 @@
+/*
+ * drivers/media/video/sun4i_csi/device/hi704.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for Hynix HI704 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for Hynix HI704 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][HI704]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][HI704]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][HI704]"x,##arg)
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_LOW
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x704
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 20
+
+/*
+ * The hi704 sits on i2c with ID 0x60
+ */
+#define I2C_ADDR 0x60
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+static struct regval_list sensor_default_regs[] = {
+  //PAGE 0
+	//Image Size/Windowing/HSYNC/VSYNC[Type1]
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+	{{0x01}, {0xf1}},
+	{{0x01}, {0xf3}},	//PWRCTL(0x01[P0])Bit[1]:Software Reset.
+	{{0x01}, {0xf1}},
+
+	{{0x11}, {0x94}},	//For Fixed Framerate Bit[2]
+	{{0x12}, {0x04}},
+
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x04}},
+	{{0x22}, {0x00}},
+	{{0x23}, {0x04}},
+
+	{{0x24}, {0x01}},
+	{{0x25}, {0xe0}},
+	{{0x26}, {0x02}},
+	{{0x27}, {0x80}},
+
+	{{0x40}, {0x01}},	//HBLANK: 0x70 = 112
+	{{0x41}, {0x58}},
+	{{0x42}, {0x00}},	//VBLANK: 0x40 = 64
+	{{0x43}, {0x27}},	//0x04 -> 0x40: For Max Framerate = 30fps
+
+	//BLC
+	{{0x80}, {0x2e}},
+	{{0x81}, {0x7e}},
+	{{0x82}, {0x90}},
+	{{0x83}, {0x30}},
+	{{0x84}, {0x2c}},//*** Change 100406
+	{{0x85}, {0x4b}},//*** Change 100406
+	{{0x89}, {0x48}},//BLC hold
+	{{0x90}, {0x0c}},//TIME_IN	11/100	_100318
+	{{0x91}, {0x0c}},//TIME_OUT 11/100	_100318
+	{{0x92}, {0x78}},//AG_IN
+	{{0x93}, {0x78}},//AG_OUT
+	{{0x98}, {0x38}},
+	{{0x99}, {0x40}}, //Out BLC
+	{{0xa0}, {0x00}}, //Dark BLC
+	{{0xa8}, {0x40}}, //Normal BLC
+
+	//Page 2  Last Update 10_03_12
+	{{0x03}, {0x02}},
+	{{0x13}, {0x40}}, //*** ADD 100402
+	{{0x14}, {0x04}}, //*** ADD 100402
+	{{0x1a}, {0x00}}, //*** ADD 100402
+	{{0x1b}, {0x08}}, //*** ADD 100402
+	{{0x20}, {0x33}},
+	{{0x21}, {0xaa}},//*** Change 100402
+	{{0x22}, {0xa7}},
+	{{0x23}, {0x32}},//*** Change 100405
+	{{0x3b}, {0x48}},//*** ADD 100405
+	{{0x50}, {0x21}}, //*** ADD 100406
+	{{0x52}, {0xa2}},
+	{{0x53}, {0x0a}},
+	{{0x54}, {0x30}},//*** ADD 100405
+	{{0x55}, {0x10}},//*** Change 100402
+	{{0x56}, {0x0c}},
+	{{0x59}, {0x0F}},//*** ADD 100405
+	{{0x60}, {0xca}},
+	{{0x61}, {0xdb}},
+	{{0x62}, {0xca}},
+	{{0x63}, {0xda}},
+	{{0x64}, {0xca}},
+	{{0x65}, {0xda}},
+	{{0x72}, {0xcb}},
+	{{0x73}, {0xd8}},
+	{{0x74}, {0xcb}},
+	{{0x75}, {0xd8}},
+	{{0x80}, {0x02}},
+	{{0x81}, {0xbd}},
+	{{0x82}, {0x24}},
+	{{0x83}, {0x3e}},
+	{{0x84}, {0x24}},
+	{{0x85}, {0x3e}},
+	{{0x92}, {0x72}},
+	{{0x93}, {0x8c}},
+	{{0x94}, {0x72}},
+	{{0x95}, {0x8c}},
+	{{0xa0}, {0x03}},
+	{{0xa1}, {0xbb}},
+	{{0xa4}, {0xbb}},
+	{{0xa5}, {0x03}},
+	{{0xa8}, {0x44}},
+	{{0xa9}, {0x6a}},
+	{{0xaa}, {0x92}},
+	{{0xab}, {0xb7}},
+	{{0xb8}, {0xc9}},
+	{{0xb9}, {0xd0}},
+	{{0xbc}, {0x20}},
+	{{0xbd}, {0x28}},
+	{{0xc0}, {0xDE}},
+	{{0xc1}, {0xEC}},
+	{{0xc2}, {0xDE}},
+	{{0xc3}, {0xEC}},
+	{{0xc4}, {0xE0}},
+	{{0xc5}, {0xEA}},
+	{{0xc6}, {0xE0}},
+	{{0xc7}, {0xEa}},
+	{{0xc8}, {0xe1}},
+	{{0xc9}, {0xe8}},
+	{{0xca}, {0xe1}},
+	{{0xcb}, {0xe8}},
+	{{0xcc}, {0xe2}},
+	{{0xcd}, {0xe7}},
+	{{0xce}, {0xe2}},
+	{{0xcf}, {0xe7}},
+	{{0xd0}, {0xc8}},
+	{{0xd1}, {0xef}},
+	//{0xd7, 0x48},
+
+	//PAGE 10
+	//Image Format, Image Effect
+	{{0x03}, {0x10}},
+	{{0x10}, {0x03}},
+
+	{{0x11}, {0x43}},
+	{{0x12}, {0x30}}, //Y offet, dy offseet enable
+	//{0x40, 0x80},
+	{{0x41}, {0x10}}, //00 DYOFS  00->10  _100318
+	{{0x48}, {0x90}}, //Contrast  88->84  _100318
+	{{0x50}, {0x48}}, //AGBRT
+
+	{{0x60}, {0x7f}},
+	{{0x61}, {0x00}}, //Use default
+	{{0x62}, {0xa8}}, //SATB  (1.4x)
+	{{0x63}, {0xa0}}, //SATR  (1.2x)
+	{{0x64}, {0x48}}, //AGSAT
+	{{0x66}, {0x90}}, //wht_th2
+	{{0x67}, {0x36}}, //wht_gain  Dark (0.4x), Normal (0.75x)
+
+	//LPF
+	{{0x03}, {0x11}},
+	{{0x10}, {0x25}},	//LPF_CTL1 //0x01
+	{{0x11}, {0x1f}},	//Test Setting
+	{{0x20}, {0x00}},	//LPF_AUTO_CTL
+	{{0x21}, {0x38}},	//LPF_PGA_TH
+	{{0x23}, {0x0a}},	//LPF_TIME_TH
+	{{0x60}, {0x0a}},	//ZARA_SIGMA_TH //40->10
+	{{0x61}, {0x82}},
+	{{0x62}, {0x00}},	//ZARA_HLVL_CTL
+	{{0x63}, {0x83}},	//ZARA_LLVL_CTL
+	{{0x64}, {0x83}},	//ZARA_DY_CTL
+
+	{{0x67}, {0xF0}},	//*** Change 100402     //Dark
+	{{0x68}, {0x30}},	//*** Change 100402     //Middle
+	{{0x69}, {0x10}},	//High
+
+	{{0x03}, {0x12}},
+	{{0x40}, {0xe9}},	//YC2D_LPF_CTL1
+	{{0x41}, {0x09}},	//YC2D_LPF_CTL2
+	{{0x50}, {0x18}},	//Test Setting
+	{{0x51}, {0x24}},	//Test Setting
+	{{0x70}, {0x1f}},	//GBGR_CTL1 //0x1f
+	{{0x71}, {0x00}},	//Test Setting
+	{{0x72}, {0x00}},	//Test Setting
+	{{0x73}, {0x00}},	//Test Setting
+	{{0x74}, {0x10}},	//GBGR_G_UNIT_TH
+	{{0x75}, {0x10}},	//GBGR_RB_UNIT_TH
+	{{0x76}, {0x20}},	//GBGR_EDGE_TH
+	{{0x77}, {0x80}},	//GBGR_HLVL_TH
+	{{0x78}, {0x88}},	//GBGR_HLVL_COMP
+	{{0x79}, {0x18}},	//Test Setting
+	{{0xb0}, {0x7d}},   //dpc
+
+	//Edge
+	{{0x03}, {0x13}},
+	{{0x10}, {0x01}},
+	{{0x11}, {0x89}},
+	{{0x12}, {0x14}},
+	{{0x13}, {0x19}},
+	{{0x14}, {0x08}},	//Test Setting
+	{{0x20}, {0x07}},	//SHARP_Negative
+	{{0x21}, {0x05}},	//SHARP_Positive
+	{{0x23}, {0x30}},	//SHARP_DY_CTL
+	{{0x24}, {0x33}},	//40->33
+	{{0x25}, {0x08}},	//SHARP_PGA_TH
+	{{0x26}, {0x18}},	//Test Setting
+	{{0x27}, {0x00}},	//Test Setting
+	{{0x28}, {0x08}},	//Test Setting
+	{{0x29}, {0x50}},	//AG_TH
+	{{0x2a}, {0xe0}},	//region ratio
+	{{0x2b}, {0x10}},	//Test Setting
+	{{0x2c}, {0x28}},	//Test Setting
+	{{0x2d}, {0x40}},	//Test Setting
+	{{0x2e}, {0x00}},	//Test Setting
+	{{0x2f}, {0x00}},	//Test Setting
+	{{0x30}, {0x11}},	//Test Setting
+	{{0x80}, {0x03}},	//SHARP2D_CTL
+	{{0x81}, {0x07}},	//Test Setting
+	{{0x90}, {0x06}},	//SHARP2D_SLOPE
+	{{0x91}, {0x04}},	//SHARP2D_DIFF_CTL
+	{{0x92}, {0x00}},	//SHARP2D_HI_CLIP
+	{{0x93}, {0x20}},	//SHARP2D_DY_CTL
+	{{0x94}, {0x42}},	//Test Setting
+	{{0x95}, {0x60}},	//Test Setting
+
+	{{0x03}, {0x14}}, //disable for white pixel
+	{{0x10}, {0x01}},
+	{{0x20}, {0x8a}}, //XCEN
+	{{0x21}, {0x8e}}, //YCEN
+	{{0x22}, {0x66}}, //76, 34, 2b
+	{{0x23}, {0x50}}, //4b, 15, 0d
+	{{0x24}, {0x44}}, //3b, 10, 0b
+
+	//Page 15 CMC
+	{{0x03}, {0x15}},
+	{{0x10}, {0x03}},
+
+	{{0x14}, {0x3c}},
+	{{0x16}, {0x2c}},
+	{{0x17}, {0x2f}},
+
+	{{0x30}, {0xcb}},
+	{{0x31}, {0x61}},
+	{{0x32}, {0x16}},
+	{{0x33}, {0x23}},
+	{{0x34}, {0xce}},
+	{{0x35}, {0x2b}},
+	{{0x36}, {0x01}},
+	{{0x37}, {0x34}},
+	{{0x38}, {0x75}},
+
+	{{0x40}, {0x87}},
+	{{0x41}, {0x18}},
+	{{0x42}, {0x91}},
+	{{0x43}, {0x94}},
+	{{0x44}, {0x9f}},
+	{{0x45}, {0x33}},
+	{{0x46}, {0x00}},
+	{{0x47}, {0x94}},
+	{{0x48}, {0x14}},
+
+	{{0x03}, {0x16}},
+	{{0x30}, {0x00}},
+	{{0x31}, {0x0b}},
+	{{0x32}, {0x20}},
+	{{0x33}, {0x36}},
+	{{0x34}, {0x5b}},
+	{{0x35}, {0x75}},
+	{{0x36}, {0x8c}},
+	{{0x37}, {0x9f}},
+	{{0x38}, {0xaf}},
+	{{0x39}, {0xbd}},
+	{{0x3a}, {0xca}},
+	{{0x3b}, {0xdd}},
+	{{0x3c}, {0xec}},
+	{{0x3d}, {0xf7}},
+	{{0x3e}, {0xff}},
+
+	//Page 17 AE
+	{{0x03}, {0x17}},
+	{{0xc4}, {0x3c}},
+	{{0xc5}, {0x32}},
+
+	//Page 20 AE
+	{{0x03}, {0x20}},
+	{{0x10}, {0x0c}},
+	{{0x11}, {0x04}},
+
+	{{0x20}, {0x01}},
+	{{0x28}, {0x27}},
+	{{0x29}, {0xa1}},
+
+	{{0x2a}, {0xf0}},
+	{{0x2b}, {0x34}},
+	{{0x2c}, {0x2b}}, //23->2b 2010_04_06 hhzin
+
+	{{0x30}, {0xf8}},
+
+	{{0x39}, {0x22}},
+	{{0x3a}, {0xde}},
+	{{0x3b}, {0x22}}, //23->22 _10_04_06 hhzin
+	{{0x3c}, {0xde}},
+
+	{{0x60}, {0x95}}, //d5, 99
+	{{0x68}, {0x3c}},
+	{{0x69}, {0x64}},
+	{{0x6A}, {0x28}},
+	{{0x6B}, {0xc8}},
+
+	{{0x70}, {0x42}},//Y Target 42
+
+	{{0x76}, {0x32}}, //Unlock bnd1
+	{{0x77}, {0xa1}}, //Unlock bnd2 02->a2 _10_04_06 hhzin
+
+	{{0x78}, {0x22}}, //Yth 1
+	{{0x79}, {0x30}}, //Yth 2 26->27 _10_04_06 hhzin
+	{{0x7a}, {0x23}}, //Yth 3
+
+	{{0x7c}, {0x1d}},
+	{{0x7d}, {0x22}},
+
+	//50Hz
+	{{0x83}, {0x00}},//ExpTime 30fps
+	{{0x84}, {0x57}},
+	{{0x85}, {0xe4}},
+
+	{{0x86}, {0x00}},//ExpMin
+	{{0x87}, {0xfa}},
+
+	{{0x88}, {0x01}},
+	{{0x89}, {0x24}},
+	{{0x8a}, {0xf8}},
+
+	{{0x8b}, {0x1d}},//Exp100
+	{{0x8c}, {0x4c}},
+
+	{{0x8d}, {0x18}},//Exp120
+	{{0x8e}, {0x6a}},
+
+	{{0x91}, {0x02}},
+	{{0x92}, {0xdc}},
+	{{0x93}, {0x6c}},
+
+	{{0x94}, {0x01}}, //fix_step
+	{{0x95}, {0xb7}},
+	{{0x96}, {0x74}},
+
+	{{0x98}, {0x8C}},
+	{{0x99}, {0x23}},
+
+	{{0x9c}, {0x0b}}, //4shared limit_10_04_06 hhzin
+	{{0x9d}, {0xb8}}, // 0x06d3 --> 0x0b3b
+	{{0x9e}, {0x00}}, //4shared Unit_10_04_06 hhzin
+	{{0x9f}, {0xfa}}, // 0x01f4 --> 0xfa
+
+	{{0xb1}, {0x14}},
+	{{0xb2}, {0x50}},
+	{{0xb4}, {0x14}},
+	{{0xb5}, {0x38}},
+	{{0xb6}, {0x26}},
+	{{0xb7}, {0x20}},
+	{{0xb8}, {0x1d}},
+	{{0xb9}, {0x1b}},
+	{{0xba}, {0x1a}},
+	{{0xbb}, {0x19}},
+	{{0xbc}, {0x19}},
+	{{0xbd}, {0x18}},
+
+	{{0xc0}, {0x1a}},
+	{{0xc3}, {0x48}},
+	{{0xc4}, {0x48}},
+
+	//Page 22 AWB
+	{{0x03}, {0x22}},
+	{{0x10}, {0xe2}},
+	{{0x11}, {0x26}},
+	{{0x20}, {0x34}},
+	{{0x21}, {0x40}},
+	{{0x30}, {0x80}},
+	{{0x31}, {0x80}},
+	{{0x38}, {0x12}},
+	{{0x39}, {0x33}},
+	{{0x40}, {0xf0}},
+	{{0x41}, {0x32}},
+	{{0x42}, {0x33}},
+	{{0x43}, {0xf3}},
+	{{0x44}, {0x88}},
+	{{0x45}, {0x66}},
+	{{0x46}, {0x02}},
+
+	{{0x80}, {0x3a}},
+	{{0x81}, {0x20}},
+	{{0x82}, {0x40}},
+	{{0x83}, {0x52}}, //RMAX Default : 50 -> 48 -> 52
+	{{0x84}, {0x18}}, //RMIN Default : 20
+	{{0x85}, {0x5c}}, //BMAX Default : 50, 5a -> 58 -> 55
+	{{0x86}, {0x25}}, //BMIN Default : 20
+	{{0x87}, {0x4d}}, //RMAXB Default : 50, 4d
+	{{0x88}, {0x38}}, //RMINB Default : 3e, 45 --> 42
+	{{0x89}, {0x3e}}, //BMAXB Default : 2e, 2d --> 30
+	{{0x8a}, {0x29}}, //BMINB Default : 20, 22 --> 26 --> 29
+	{{0x8b}, {0x02}}, //OUT TH
+	{{0x8d}, {0x22}},
+	{{0x8e}, {0x71}},
+
+	{{0x8f}, {0x5c}},
+	{{0x90}, {0x59}},
+	{{0x91}, {0x55}},
+	{{0x92}, {0x50}},
+	{{0x93}, {0x48}},
+	{{0x94}, {0x3e}},
+	{{0x95}, {0x37}},
+	{{0x96}, {0x30}},
+	{{0x97}, {0x29}},
+	{{0x98}, {0x26}},
+	{{0x99}, {0x20}},
+	{{0x9a}, {0x1a}},
+	{{0x9b}, {0x0b}},
+
+	{{0x03}, {0x22}},
+	{{0x10}, {0xfb}},
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x9c}},
+
+	{{0x01}, {0xf0}}
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+	{{0x01}, {0xf1}},//Sleep: For Write Reg
+
+	{{0x10}, {0x00}},//VGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x04}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x58}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x27}},
+
+	{{0x03}, {0x11}},
+	{{0x10}, {0x25}},
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x1c}},//Close AE
+	{{0x18}, {0x38}},//Reset AE
+
+	{{0x86}, {0x00}},
+	{{0x87}, {0xfa}},
+	{{0x8b}, {0x1d}},
+	{{0x8c}, {0x4c}},
+	{{0x8d}, {0x18}},
+	{{0x8e}, {0x6a}},
+	{{0x9c}, {0x0b}},
+	{{0x9d}, {0xb8}},
+	{{0x9e}, {0x00}},
+	{{0x9f}, {0xfa}},
+
+	{{0x01}, {0xf0}},//Exit Sleep: For Write Reg
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x9c}},//Open AE
+	{{0x18}, {0x30}},//Reset AE
+};
+
+static struct regval_list sensor_qvga_regs[] = {
+	{{0x03}, {0x00}},	//PAGEMODE(0x03)
+	{{0x01}, {0xf1}},//Sleep: For Write Reg
+
+	{{0x10}, {0x01}},//QVGA Size
+
+	{{0x20}, {0x00}},
+	{{0x21}, {0x02}},
+
+	{{0x40}, {0x01}},//HBLANK: 0x70 = 112
+	{{0x41}, {0x58}},
+	{{0x42}, {0x00}},//VBLANK: 0x04 = 4
+	{{0x43}, {0x27}},
+
+	{{0x03}, {0x11}},//QVGA Fixframerate
+	{{0x10}, {0x21}},
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x1c}},//Close AE
+	{{0x18}, {0x38}},//Reset AE
+
+	{{0x86}, {0x00}},
+	{{0x87}, {0xfa}},
+	{{0x8b}, {0x1d}},
+	{{0x8c}, {0x4c}},
+	{{0x8d}, {0x18}},
+	{{0x8e}, {0x6a}},
+	{{0x9c}, {0x0b}},
+	{{0x9d}, {0xb8}},
+	{{0x9e}, {0x00}},
+	{{0x9f}, {0xfa}},
+
+	{{0x01}, {0xf0}},//Exit Sleep: For Write Reg
+
+	{{0x03}, {0x20}},
+	{{0x10}, {0x9c}},//Open AE
+	{{0x18}, {0x30}},//Reset AE
+};
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x48}},
+	{{0x81},{0x20}},
+	{{0x82},{0x40}},
+	{{0x83},{0x58}},
+	{{0x84},{0x10}},
+	{{0x85},{0x70}},
+	{{0x86},{0x10}},
+//	{{0x10},{0xea}}
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x62}},
+	{{0x81},{0x20}},
+	{{0x82},{0x2e}},
+	{{0x83},{0x6d}},
+	{{0x84},{0x65}},
+	{{0x85},{0x30}},
+	{{0x86},{0x25}}
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x50}},
+	{{0x81},{0x20}},
+	{{0x82},{0x2d}},
+	{{0x83},{0x52}},
+	{{0x84},{0x45}},
+	{{0x85},{0x30}},
+	{{0x86},{0x1c}}
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x26}},
+	{{0x81},{0x20}},
+	{{0x82},{0x55}},
+	{{0x83},{0x24}},
+	{{0x84},{0x1e}},
+	{{0x85},{0x58}},
+	{{0x86},{0x4a}}
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x40}},
+	{{0x81},{0x20}},
+	{{0x82},{0x4f}},
+	{{0x83},{0x44}},
+	{{0x84},{0x3a}},
+	{{0x85},{0x47}},
+	{{0x86},{0x3a}}
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0x03},{0x22}},
+	{{0x10},{0x6a}},
+	{{0x80},{0x34}},
+	{{0x81},{0x20}},
+	{{0x82},{0x48}},
+	{{0x83},{0x36}},
+	{{0x84},{0x30}},
+	{{0x85},{0x50}},
+	{{0x86},{0x44}}
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x30}},
+	{{0x13},{0x00}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x06}},
+	{{0x21},{0x04}}
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x23}},
+	{{0x13},{0x00}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x23}},
+	{{0x13},{0x00}},
+	{{0x44},{0x70}},
+	{{0x45},{0x98}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x28}},
+	{{0x13},{0x00}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x23}},
+	{{0x12},{0x33}},
+	{{0x13},{0x02}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x07}}
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x13}},
+	{{0x12},{0x38}},
+	{{0x13},{0x02}},
+	{{0x44},{0x80}},
+	{{0x45},{0x80}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x07}}
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x33}},
+	{{0x13},{0x00}},
+	{{0x44},{0xb0}},
+	{{0x45},{0x40}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0x03},{0x10}},
+	{{0x11},{0x03}},
+	{{0x12},{0x33}},
+	{{0x13},{0x00}},
+	{{0x44},{0x60}},
+	{{0x45},{0x60}},
+	{{0x47},{0x7f}},
+	{{0x03},{0x13}},
+	{{0x20},{0x07}},
+	{{0x21},{0x03}}
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+	//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xe0}}
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xc0}}
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0xa0}}
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x90}}
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x00}}
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x10}}
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x20}}
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x30}}
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x40},{0x40}}
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x44}}
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x54}}
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x64}}
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x74}}
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x84}}
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0x94}}
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xa4}}
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xb4}}
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x48},{0xc4}}
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x50}},
+	{{0x63},{0x50}}
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x60}},
+	{{0x63},{0x60}}
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x70}},
+	{{0x63},{0x70}}
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x80}},
+	{{0x63},{0x80}}
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0x90}},
+	{{0x63},{0x90}}
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0xa0}},
+	{{0x63},{0xa0}}
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0xb0}},
+	{{0x63},{0xb0}}
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0xc0}},
+	{{0x63},{0xc0}}
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+	{{0x03},{0x10}},
+	{{0x62},{0xd0}},
+	{{0x63},{0xd0}}
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x12}}
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x2a}}
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x32}}
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x3a}}
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x42}}
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x4a}}
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x52}}
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x5a}}
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0x03},{0x20}},
+	{{0x70},{0x62}}
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x03}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x02}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x00}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0x03},{0x10}},//PAGEMODE 0x10
+	{{0x10},{0x01}}	//CbYCrY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_dev_err("sensor_write_err!\n");
+				return ret;
+			}
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x04;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x96)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+	/* QVGA */
+	{
+		.width		= QVGA_WIDTH,
+		.height		= QVGA_HEIGHT,
+		.regs 		= sensor_qvga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_qvga_regs),
+		.set_size		= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct v4l2_fract *tpf = &cp->timeperframe;
+	//struct sensor_info *info = to_state(sd);
+	//int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else
+//		div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > CLK_SCALE)
+//		div = CLK_SCALE;
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_CONTRAST:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_SATURATION:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x11 bit0 is hflip enable
+
+	*value = regs.value[0];
+	info->hflip = regs.value[0];
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfe;
+		break;
+	case 1:
+		regs.value[0] |= 0x01;
+		break;
+	default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x11 bit1 is vflip enable
+
+	*value = regs.value[0];
+	info->hflip = regs.value[0];
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x11;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xfd;
+		break;
+	case 1:
+		regs.value[0] |= 0x02;
+		break;
+	default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x20;		//PAGEMODE 0x20
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x80;
+	if (regs.value[0] == 0x80) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x20;		//PAGEMODE 0x20
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x80;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0x7f;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->autoexp = value;
+
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x03;
+	regs.value[0] = 0x22;
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<7);
+	regs.value[0] = regs.value[0]>>7;		//0x10 bit7 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x10;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0x7f;
+		break;
+	case 1:
+		regs.value[0] |= 0x80;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+	msleep(10);
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "hi704", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "hi704",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/mt9d112.c b/drivers/media/video/sun4i_csi/device/mt9d112.c
new file mode 100644
index 0000000..6eb49c9
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/mt9d112.c
@@ -0,0 +1,2561 @@
+/*
+ * drivers/media/video/sun4i_csi/device/mt9d112.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for Micron mt9d112 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for Micron mt9d112 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][MT9D112]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][MT9D112]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][MT9D112]"x,##arg)
+
+#define MCLK (24*1000*1000)
+//#define MCLK (49.5*1000*1000)
+
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_FALLING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x1320
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 2
+#define REG_DATA_STEP 2
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define UXGA_WIDTH	1600
+#define UXGA_HEIGHT	1200
+#define VGA_WIDTH	640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 25
+
+/*
+ * The Micron mt9d112 sits on i2c with ID 0x20
+ */
+#define I2C_ADDR 0x78//(0x78 for write,0x79 for read)
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+
+static struct regval_list sensor_default_regs[] = {
+	{{0x33,0x86}, {0x25,0x01}}, 		//MCU_BOOT_MODE
+	{{0x33,0x86}, {0x25,0x00}}, 		//MCU_BOOT_MODE
+	{{0xff,0xff}, {0x00,0x64}},//DELAY= 100
+	{{0x30,0x1A}, {0x0A,0xCC}}, 		//RESET_REGISTER
+	{{0x32,0x02}, {0x00,0x08}}, 		//STANDBY_CONTROL
+	{{0xff,0xff}, {0x00,0x64}},//DELAY = 100
+	//{{0x32,0x14},{0x00,0x80}},
+	{{0x33,0x8C}, {0xA2,0x15}}, 	 //AE maxADChi
+	{{0x33,0x90}, {0x00,0x06}}, 	 //gain_thd , by jiujian
+	{{0x33,0x8C}, {0xA2,0x06}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x36}}, // AE_TARGET
+	{{0x33,0x8C}, {0xA2,0x07}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x04}}, // AE_GATE
+	{{0x33,0x8C}, {0xA2,0x0c}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x08}}, // AE_GAT
+
+	{{0x32,0x78}, {0x00,0x50}}, // first black level
+	{{0x32,0x7a}, {0x00,0x50}}, // first black level,red
+	{{0x32,0x7c}, {0x00,0x50}}, // green_1
+	{{0x32,0x7e}, {0x00,0x50}}, // green_2
+	{{0x32,0x80}, {0x00,0x50}}, // blue
+	{{0xff,0xff}, {0x00,0x0a}},//DELAY = 10
+	{{0x33,0x7e}, {0x20,0x00}}, // Y/RGB offset
+	{{0x33,0x8C}, {0xA3,0x4A}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x59}}, 		// AWB_GAIN_MIN
+	{{0x33,0x8C}, {0xA3,0x4B}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xA6}}, 		// AWB_GAIN_MAX
+	{{0x33,0x8C}, {0x23,0x5F}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x40}}, 		// AWB_CNT_PXL_TH
+	{{0x33,0x8C}, {0xA3,0x61}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xD2}}, 		// AWB_TG_MIN0
+	{{0x33,0x8C}, {0xA3,0x62}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xE6}}, 		// AWB_TG_MAX0
+	{{0x33,0x8C}, {0xA3,0x63}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x10}}, 		// AWB_X0
+	{{0x33,0x8C}, {0xA3,0x64}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xA0}}, 		// AWB_KR_L
+	{{0x33,0x8C}, {0xA3,0x65}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x96}}, 		// AWB_KG_L
+	{{0x33,0x8C}, {0xA3,0x66}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x80}}, 		// AWB_KB_L
+	{{0x33,0x8C}, {0xA3,0x67}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x80}}, 		// AWB_KR_R
+	{{0x33,0x8C}, {0xA3,0x68}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x80}}, 		// AWB_KG_R
+	{{0x33,0x8C}, {0xA3,0x69}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x80}}, 		// AWB_KB_R
+	{{0x32,0xA2}, {0x36,0x40}}, 		// RESERVED_SOC1_32A2  //fine tune color setting
+	{{0x33,0x8C}, {0x23,0x06}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x02,0xFF}}, 		// AWB_CCM_L_0
+	{{0x33,0x8C}, {0x23,0x08}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFE,0x6E}}, 		// AWB_CCM_L_1
+	{{0x33,0x8C}, {0x23,0x0A}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFF,0xC2}}, 		// AWB_CCM_L_2
+	{{0x33,0x8C}, {0x23,0x0C}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFF,0x4A}}, 		// AWB_CCM_L_3
+	{{0x33,0x8C}, {0x23,0x0E}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x02,0xD7}}, 		// AWB_CCM_L_4
+	{{0x33,0x8C}, {0x23,0x10}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFF,0x30}}, 		// AWB_CCM_L_5
+	{{0x33,0x8C}, {0x23,0x12}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFF,0x6E}}, 		// AWB_CCM_L_6
+	{{0x33,0x8C}, {0x23,0x14}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFD,0xEE}}, 		// AWB_CCM_L_7
+	{{0x33,0x8C}, {0x23,0x16}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x03,0xCF}}, 		// AWB_CCM_L_8
+	{{0x33,0x8C}, {0x23,0x18}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x20}}, 		// AWB_CCM_L_9
+	{{0x33,0x8C}, {0x23,0x1A}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x3C}}, 		// AWB_CCM_L_10
+	{{0x33,0x8C}, {0x23,0x1C}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x2C}}, 		// AWB_CCM_RL_0
+	{{0x33,0x8C}, {0x23,0x1E}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFF,0xBC}}, 		// AWB_CCM_RL_1
+	{{0x33,0x8C}, {0x23,0x20}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x16}}, 		// AWB_CCM_RL_2
+	{{0x33,0x8C}, {0x23,0x22}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x37}}, 		// AWB_CCM_RL_3
+	{{0x33,0x8C}, {0x23,0x24}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFF,0xCD}}, 		// AWB_CCM_RL_4
+	{{0x33,0x8C}, {0x23,0x26}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFF,0xF3}}, 		// AWB_CCM_RL_5
+	{{0x33,0x8C}, {0x23,0x28}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x77}}, 		// AWB_CCM_RL_6
+	{{0x33,0x8C}, {0x23,0x2A}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xF4}}, 		// AWB_CCM_RL_7
+	{{0x33,0x8C}, {0x23,0x2C}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFE,0x95}}, 		// AWB_CCM_RL_8
+	{{0x33,0x8C}, {0x23,0x2E}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x14}}, 		// AWB_CCM_RL_9
+	{{0x33,0x8C}, {0x23,0x30}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0xFF,0xE8}}, 		// AWB_CCM_RL_10  //end
+	{{0x33,0x8C}, {0xA3,0x48}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x08}}, 		// AWB_GAIN_BUFFER_SPEED
+	{{0x33,0x8C}, {0xA3,0x49}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x02}}, 		// AWB_JUMP_DIVISOR
+	{{0x33,0x8C}, {0xA3,0x4A}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x59}}, 		// AWB_GAIN_MIN
+	{{0x33,0x8C}, {0xA3,0x4B}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xA6}}, 		// AWB_GAIN_MAX
+	{{0x33,0x8C}, {0xA3,0x4F}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x00}}, 		// AWB_CCM_POSITION_MIN
+	{{0x33,0x8C}, {0xA3,0x50}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x7F}}, 		// AWB_CCM_POSITION_MAX
+	{{0x33,0x8C}, {0xA3,0x52}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x1E}}, 		// AWB_SATURATION
+	{{0x33,0x8C}, {0xA3,0x53}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x02}}, 		// AWB_MODE
+	{{0x33,0x8C}, {0xA3,0x5B}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x7E}}, 		// AWB_STEADY_BGAIN_OUT_MIN
+	{{0x33,0x8C}, {0xA3,0x5C}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x86}}, 		// AWB_STEADY_BGAIN_OUT_MAX
+	{{0x33,0x8C}, {0xA3,0x5D}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x7F}}, 		// AWB_STEADY_BGAIN_IN_MIN
+	{{0x33,0x8C}, {0xA3,0x5E}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x82}}, 		// AWB_STEADY_BGAIN_IN_MAX
+	{{0x33,0x8C}, {0x23,0x5F}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x40}}, 		// AWB_CNT_PXL_TH
+	{{0x33,0x8C}, {0xA3,0x61}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xD2}}, 		// AWB_TG_MIN0
+	{{0x33,0x8C}, {0xA3,0x62}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xE6}}, 		// AWB_TG_MAX0
+	{{0x33,0x8C}, {0xA3,0x02}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x00}}, 		// AWB_WINDOW_POS
+	{{0x33,0x8C}, {0xA3,0x03}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0xEF}}, 		// AWB_WINDOW_SIZE
+	{{0x33,0x8C}, {0xAB,0x05}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x00}}, 		// HG_PERCENT
+	{{0x33,0x8C}, {0xA7,0x82}}, 		// MCU_ADDRESS
+	{{0x35,0xA4}, {0x05,0x96}}, 		// BRIGHT_COLOR_KILL_CONTROLS
+	{{0x33,0x8C}, {0xA1,0x18}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x1E}}, 		// SEQ_LLSAT1
+	{{0x33,0x8C}, {0xA1,0x19}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x04}}, 		// SEQ_LLSAT2
+	{{0x33,0x8C}, {0xA1,0x1A}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x0A}}, 		// SEQ_LLINTERPTHRESH1
+	{{0x33,0x8C}, {0xA1,0x1B}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x20}}, 		// SEQ_LLINTERPTHRESH2
+	{{0x33,0x8C}, {0xA1,0x3E}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x04}}, 		// SEQ_NR_TH1_R
+	{{0x33,0x8C}, {0xA1,0x3F}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x0E}}, 		// SEQ_NR_TH1_G
+	{{0x33,0x8C}, {0xA1,0x40}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x04}}, 		// SEQ_NR_TH1_B
+	{{0x33,0x8C}, {0xA1,0x41}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x04}}, 		// SEQ_NR_TH1_OL
+	{{0x33,0x8C}, {0xA1,0x42}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x32}}, 		// SEQ_NR_TH2_R
+	{{0x33,0x8C}, {0xA1,0x43}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x0F}}, 		// SEQ_NR_TH2_G
+	{{0x33,0x8C}, {0xA1,0x44}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x32}}, 		// SEQ_NR_TH2_B
+	{{0x33,0x8C}, {0xA1,0x45}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x32}}, 		// SEQ_NR_TH2_OL
+	{{0x33,0x8C}, {0xA1,0x46}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x05}}, 		// SEQ_NR_GAINTH1
+	{{0x33,0x8C}, {0xA1,0x47}}, 		// MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x3A}}, 		// SEQ_NR_GAINTH2
+
+	{{0x33, 0x8C}, {0x27, 0x03}},		//Output Width (A)
+	{{0x33, 0x90}, {0x02, 0x80}},		 // 	 = 640
+	{{0x33, 0x8C}, {0x27, 0x05}},		 //Output Height (A)
+	{{0x33, 0x90}, {0x01, 0xE0}},		 // 	 = 480
+	{{0x33, 0x8C}, {0x27, 0x07}},		 //Output Width (B)
+	{{0x33, 0x90}, {0x06, 0x40}},		 // 	 = 1600
+	{{0x33, 0x8C}, {0x27, 0x09}},		//Output Height (B)
+	{{0x33, 0x90}, {0x04, 0xB0}},		 // 	 = 1200
+	{{0x33, 0x8C}, {0x27, 0x0D}},		 //Row Start (A)
+	{{0x33, 0x90}, {0x00, 0x78}},		 // 	 = 120
+	{{0x33, 0x8C}, {0x27, 0x0F}},		 //Column Start (A)
+	{{0x33, 0x90}, {0x00, 0xA0}},		 // 	 = 160
+	{{0x33, 0x8C}, {0x27, 0x11}},		 //Row End (A)
+	{{0x33, 0x90}, {0x04, 0x4d}},		 // 	 = 1101
+	{{0x33, 0x8C}, {0x27, 0x13}},		 //Column End (A)
+	{{0x33, 0x90}, {0x05, 0xb5}},		 // 	 = 1461
+	{{0x33, 0x8C}, {0x27, 0x15}},		 //Extra Delay (A)
+	{{0x33, 0x90}, {0x00, 0xAF}},		 // 	 = 175
+	{{0x33, 0x8C}, {0x27, 0x17}},		 //Row Speed (A)
+	{{0x33, 0x90}, {0x21, 0x11}},		 // 	 = 8465
+	{{0x33, 0x8C}, {0x27, 0x19}},		 //Read Mode (A)
+	{{0x33, 0x90}, {0x04, 0x6c}},		 // 	 = 1132
+	{{0x33, 0x8C}, {0x27, 0x1B}},		 //sensor_sample_time_pck (A)
+	{{0x33, 0x90}, {0x02, 0x4F}},		 // 	 = 591
+	{{0x33, 0x8C}, {0x27, 0x1D}},		 //sensor_fine_correction (A)
+	{{0x33, 0x90}, {0x01, 0x02}},		 // 	 = 258
+	{{0x33, 0x8C}, {0x27, 0x1F}},		 //sensor_fine_IT_min (A)
+	{{0x33, 0x90}, {0x02, 0x79}},		 // 	 = 633
+	{{0x33, 0x8C}, {0x27, 0x21}},		 //sensor_fine_IT_max_margin (A)
+	{{0x33, 0x90}, {0x01, 0x55}},		 // 	 = 341
+	{{0x33, 0x8C}, {0x27, 0x23}},		 //Frame Lines (A)
+	{{0x33, 0x90}, {0x02, 0x05}},		 // 	 = 575
+	{{0x33, 0x8C}, {0x27, 0x25}},		 //Line Length (A)
+	{{0x33, 0x90}, {0x05, 0x6F}},		 // 	 = 1391
+	{{0x33, 0x8C}, {0x27, 0x27}},		 //sensor_dac_id_4_5 (A)
+	{{0x33, 0x90}, {0x20, 0x20}},		 // 	 = 8224
+	{{0x33, 0x8C}, {0x27, 0x29}},		 //sensor_dac_id_6_7 (A)
+	{{0x33, 0x90}, {0x20, 0x20}},		 // 	 = 8224
+	{{0x33, 0x8C}, {0x27, 0x2B}},		 //sensor_dac_id_8_9 (A)
+	{{0x33, 0x90}, {0x10, 0x20}},		 // 	 = 4128
+	{{0x33, 0x8C}, {0x27, 0x2D}},		 //sensor_dac_id_10_11 (A)
+	{{0x33, 0x90}, {0x20, 0x07}},		 // 	 = 8199
+	{{0x33, 0x8c}, {0x27, 0x95}},		   // Natural , Swaps chrominance byte
+	{{0x33, 0x90}, {0x00, 0x02}},
+	{{0x33, 0x8C}, {0x27, 0x2F}},		 //Row Start (B)
+	{{0x33, 0x90}, {0x00, 0x04}},		 // 	 = 4
+	{{0x33, 0x8C}, {0x27, 0x31}},		 //Column Start (B)
+	{{0x33, 0x90}, {0x00, 0x04}},		 // 	 = 4
+	{{0x33, 0x8C}, {0x27, 0x33}},		 //Row End (B)
+	{{0x33, 0x90}, {0x04, 0xBB}},		 // 	 = 1211
+	{{0x33, 0x8C}, {0x27, 0x35}},		 //Column End (B)
+	{{0x33, 0x90}, {0x06, 0x4B}},		 // 	 = 1611
+	{{0x33, 0x8C}, {0x27, 0x37}},		 //Extra Delay (B)
+	{{0x33, 0x90}, {0x00, 0x7C}},		 // 	 = 124
+	{{0x33, 0x8C}, {0x27, 0x39}},		 //Row Speed (B)
+	{{0x33, 0x90}, {0x21, 0x11}},		 // 	 = 8465
+	{{0x33, 0x8C}, {0x27, 0x3B}},		 //Read Mode (B)
+	{{0x33, 0x90}, {0x00, 0x24}},		 // 	 = 36
+	{{0x33, 0x8C}, {0x27, 0x3D}},		 //sensor_sample_time_pck (B)
+	{{0x33, 0x90}, {0x01, 0x20}},		 // 	 = 288
+	{{0x33, 0x8C}, {0x27, 0x41}},		 //sensor_fine_IT_min (B)
+	{{0x33, 0x90}, {0x01, 0x69}},		 // 	 = 361
+	{{0x33, 0x8C}, {0x27, 0x45}},		 //Frame Lines (B)
+	{{0x33, 0x90}, {0x04, 0xFC}},		 // 	 = 1276
+	{{0x33, 0x8C}, {0x27, 0x47}},		 //Line Length (B)
+	{{0x33, 0x90}, {0x09, 0x2F}},		 // 	 = 2351
+	{{0x33, 0x8C}, {0x27, 0x51}},		 //Crop_X0 (A)
+	{{0x33, 0x90}, {0x00, 0x00}},		 // 	 = 0
+	{{0x33, 0x8C}, {0x27, 0x53}},		 //Crop_X1 (A)
+	{{0x33, 0x90}, {0x02, 0x80}},		 // 	 = 640
+	{{0x33, 0x8C}, {0x27, 0x55}},		 //Crop_Y0 (A)
+	{{0x33, 0x90}, {0x00, 0x00}},		 // 	 = 0
+	{{0x33, 0x8C}, {0x27, 0x57}},		 //Crop_Y1 (A)
+	{{0x33, 0x90}, {0x01, 0xE0}},		 // 	 = 480
+	{{0x33, 0x8C}, {0x27, 0x5F}},		 //Crop_X0 (B)
+	{{0x33, 0x90}, {0x00, 0x00}},		 // 	 = 0
+	{{0x33, 0x8C}, {0x27, 0x61}},		 //Crop_X1 (B)
+	{{0x33, 0x90}, {0x06, 0x40}},		 // 	 = 1600
+	{{0x33, 0x8C}, {0x27, 0x63}},		 //Crop_Y0 (B)
+	{{0x33, 0x90}, {0x00, 0x00}},		 // 	 = 0
+	{{0x33, 0x8C}, {0x27, 0x65}},		 //Crop_Y1 (B)
+	{{0x33, 0x90}, {0x04, 0xB0}},		 // 	 = 1200
+	{{0x33, 0x8C}, {0x22, 0x2E}},		 //R9 Step
+	{{0x33, 0x90}, {0x00, 0x90}},		 // 	 = 144
+	{{0x33, 0x8C}, {0xA4, 0x08}},		 //search_f1_50
+	{{0x33, 0x90}, {0x00, 0x1A}},		 // 	 = 26
+	{{0x33, 0x8C}, {0xA4, 0x09}},		 //search_f2_50
+	{{0x33, 0x90}, {0x00, 0x1D}},		 // 	 = 29
+	{{0x33, 0x8C}, {0xA4, 0x0A}},		 //search_f1_60
+	{{0x33, 0x90}, {0x00, 0x20}},		 // 	 = 32
+	{{0x33, 0x8C}, {0xA4, 0x0B}},		 //search_f2_60
+	{{0x33, 0x90}, {0x00, 0x23}},		 // 	 = 35
+	{{0x33, 0x8C}, {0x24, 0x11}},		 //R9_Step_60_A
+	{{0x33, 0x90}, {0x00, 0x90}},		 // 	 = 144
+	{{0x33, 0x8C}, {0x24, 0x13}},		 //R9_Step_50_A
+	{{0x33, 0x90}, {0x00, 0xAD}},		 // 	 = 173
+	{{0x33, 0x8C}, {0x24, 0x15}},		 //R9_Step_60_B
+	{{0x33, 0x90}, {0x00, 0x55}},		 // 	 = 85
+	{{0x33, 0x8C}, {0x24, 0x17}},		 //R9_Step_50_B
+	{{0x33, 0x90}, {0x00, 0x66}},		 // 	 = 102
+
+	{{0x33, 0x8C}, {0xA3, 0x4A}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x59}},		// AWB_GAIN_MIN
+	{{0x33, 0x8C}, {0xA3, 0x4B}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xA6}},		// AWB_GAIN_MAX
+	{{0x33, 0x8C}, {0x23, 0x5F}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x40}},		// AWB_CNT_PXL_TH
+	{{0x33, 0x8C}, {0xA3, 0x61}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xD2}},		// AWB_TG_MIN0
+	{{0x33, 0x8C}, {0xA3, 0x62}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xE6}},		// AWB_TG_MAX0
+	{{0x33, 0x8C}, {0xA3, 0x63}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x10}},		// AWB_X0
+	{{0x33, 0x8C}, {0xA3, 0x64}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xA0}},		// AWB_KR_L
+	{{0x33, 0x8C}, {0xA3, 0x65}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x96}},		// AWB_KG_L
+	{{0x33, 0x8C}, {0xA3, 0x66}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x80}},		// AWB_KB_L
+	{{0x33, 0x8C}, {0xA3, 0x67}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x80}},		// AWB_KR_R
+	{{0x33, 0x8C}, {0xA3, 0x68}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x80}},		// AWB_KG_R
+	{{0x33, 0x8C}, {0xA3, 0x69}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x80}},		// AWB_KB_R
+
+	{{0x32, 0xA2}, {0x36, 0x40}},		// RESERVED_SOC1_32A2  //fine tune color setting
+	{{0x33, 0x8C}, {0x23, 0x06}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x02, 0xFF}},		// AWB_CCM_L_0
+	{{0x33, 0x8C}, {0x23, 0x08}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFE, 0x6E}},		// AWB_CCM_L_1
+	{{0x33, 0x8C}, {0x23, 0x0A}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFF, 0xC2}},		// AWB_CCM_L_2
+	{{0x33, 0x8C}, {0x23, 0x0C}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFF, 0x4A}},		// AWB_CCM_L_3
+	{{0x33, 0x8C}, {0x23, 0x0E}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x02, 0xD7}},		// AWB_CCM_L_4
+	{{0x33, 0x8C}, {0x23, 0x10}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFF, 0x30}},		// AWB_CCM_L_5
+	{{0x33, 0x8C}, {0x23, 0x12}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFF, 0x6E}},		// AWB_CCM_L_6
+	{{0x33, 0x8C}, {0x23, 0x14}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFD, 0xEE}},		// AWB_CCM_L_7
+	{{0x33, 0x8C}, {0x23, 0x16}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x03, 0xCF}},		// AWB_CCM_L_8
+	{{0x33, 0x8C}, {0x23, 0x18}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x20}},		// AWB_CCM_L_9
+	{{0x33, 0x8C}, {0x23, 0x1A}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x3C}},		// AWB_CCM_L_10
+	{{0x33, 0x8C}, {0x23, 0x1C}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x2C}},		// AWB_CCM_RL_0
+	{{0x33, 0x8C}, {0x23, 0x1E}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFF, 0xBC}},		// AWB_CCM_RL_1
+	{{0x33, 0x8C}, {0x23, 0x20}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x16}},		// AWB_CCM_RL_2
+	{{0x33, 0x8C}, {0x23, 0x22}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x37}},		// AWB_CCM_RL_3
+	{{0x33, 0x8C}, {0x23, 0x24}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFF, 0xCD}},		// AWB_CCM_RL_4
+	{{0x33, 0x8C}, {0x23, 0x26}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFF, 0xF3}},		// AWB_CCM_RL_5
+	{{0x33, 0x8C}, {0x23, 0x28}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x77}},		// AWB_CCM_RL_6
+	{{0x33, 0x8C}, {0x23, 0x2A}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xF4}},		// AWB_CCM_RL_7
+	{{0x33, 0x8C}, {0x23, 0x2C}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFE, 0x95}},		// AWB_CCM_RL_8
+	{{0x33, 0x8C}, {0x23, 0x2E}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x14}},		// AWB_CCM_RL_9
+	{{0x33, 0x8C}, {0x23, 0x30}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0xFF, 0xE8}},		// AWB_CCM_RL_10
+	//end
+	{{0x33, 0x8C}, {0xA3, 0x48}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x08}},		// AWB_GAIN_BUFFER_SPEED
+	{{0x33, 0x8C}, {0xA3, 0x49}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x02}},		// AWB_JUMP_DIVISOR
+	{{0x33, 0x8C}, {0xA3, 0x4A}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x59}},		// AWB_GAIN_MIN
+	{{0x33, 0x8C}, {0xA3, 0x4B}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xA6}},		// AWB_GAIN_MAX
+	{{0x33, 0x8C}, {0xA3, 0x4F}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x00}},		// AWB_CCM_POSITION_MIN
+	{{0x33, 0x8C}, {0xA3, 0x50}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x7F}},		// AWB_CCM_POSITION_MAX
+	{{0x33, 0x8C}, {0xA3, 0x52}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x1E}},		// AWB_SATURATION
+	{{0x33, 0x8C}, {0xA3, 0x53}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x02}},		// AWB_MODE
+	{{0x33, 0x8C}, {0xA3, 0x5B}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x7E}},		// AWB_STEADY_BGAIN_OUT_MIN
+	{{0x33, 0x8C}, {0xA3, 0x5C}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x86}},		// AWB_STEADY_BGAIN_OUT_MAX
+	{{0x33, 0x8C}, {0xA3, 0x5D}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x7F}},		// AWB_STEADY_BGAIN_IN_MIN
+	{{0x33, 0x8C}, {0xA3, 0x5E}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x82}},		// AWB_STEADY_BGAIN_IN_MAX
+	{{0x33, 0x8C}, {0x23, 0x5F}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x40}},		// AWB_CNT_PXL_TH
+	{{0x33, 0x8C}, {0xA3, 0x61}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xD2}},		// AWB_TG_MIN0
+	{{0x33, 0x8C}, {0xA3, 0x62}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xE6}},		// AWB_TG_MAX0
+	{{0x33, 0x8C}, {0xA3, 0x02}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x00}},		// AWB_WINDOW_POS
+	{{0x33, 0x8C}, {0xA3, 0x03}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0xEF}},		// AWB_WINDOW_SIZE
+	{{0x33, 0x8C}, {0xAB, 0x05}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x00}},		// HG_PERCENT
+	{{0x33, 0x8C}, {0xA7, 0x82}},		// MCU_ADDRESS
+	{{0x35, 0xA4}, {0x05, 0x96}},		// BRIGHT_COLOR_KILL_CONTROLS
+	{{0x33, 0x8C}, {0xA1, 0x18}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x1E}},		// SEQ_LLSAT1
+	{{0x33, 0x8C}, {0xA1, 0x19}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x04}},		// SEQ_LLSAT2
+	{{0x33, 0x8C}, {0xA1, 0x1A}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x0A}},		// SEQ_LLINTERPTHRESH1
+	{{0x33, 0x8C}, {0xA1, 0x1B}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x20}},		// SEQ_LLINTERPTHRESH2
+	{{0x33, 0x8C}, {0xA1, 0x3E}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x04}},		// SEQ_NR_TH1_R
+	{{0x33, 0x8C}, {0xA1, 0x3F}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x0E}},		// SEQ_NR_TH1_G
+	{{0x33, 0x8C}, {0xA1, 0x40}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x04}},		// SEQ_NR_TH1_B
+	{{0x33, 0x8C}, {0xA1, 0x41}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x04}},		// SEQ_NR_TH1_OL
+	{{0x33, 0x8C}, {0xA1, 0x42}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x32}},		// SEQ_NR_TH2_R
+	{{0x33, 0x8C}, {0xA1, 0x43}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x0F}},		// SEQ_NR_TH2_G
+	{{0x33, 0x8C}, {0xA1, 0x44}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x32}},		// SEQ_NR_TH2_B
+	{{0x33, 0x8C}, {0xA1, 0x45}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x32}},		// SEQ_NR_TH2_OL
+	{{0x33, 0x8C}, {0xA1, 0x46}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x05}},		// SEQ_NR_GAINTH1
+	{{0x33, 0x8C}, {0xA1, 0x47}},		// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x3A}},		// SEQ_NR_GAINTH2
+	{{0x33, 0x8C}, {0xA2, 0x15}},	   //AE maxADChi
+	{{0x33, 0x90}, {0x00, 0x06}},	   //gain_thd , by ethan
+
+	{{0x33,0x8c},  {0xa2,0x07}},// AE sensitivity
+	{{0x33,0x90},  {0x00,0x40}},
+
+	{{0x33, 0x8C}, {0xA4, 0x0D}},		 //Stat_min
+	{{0x33, 0x90}, {0x00, 0x02}},		 // 	 = 2
+	{{0x33, 0x8C}, {0xA4, 0x10}},		 //Min_amplitude
+	{{0x33, 0x90}, {0x00, 0x01}},		 // 	 = 1
+	{{0x33,0x8C},{0x27,0x5F}}, 	// MCU_ADDRESS [MODE_CROP_X0_B]
+	{{0x33,0x90},{0x00,0x00}}, 	// MCU_DATA_0
+	{{0x33,0x8C},{0x27,0x61}}, 	// MCU_ADDRESS [MODE_CROP_X1_B]
+	{{0x33,0x90},{0x06,0x40}}, 	// MCU_DATA_0
+	{{0x33,0x8C},{0x27,0x63}}, 	// MCU_ADDRESS [MODE_CROP_Y0_B]
+	{{0x33,0x90},{0x00,0x00}}, 	// MCU_DATA_0
+	{{0x33,0x8C},{0x27,0x65}}, 	// MCU_ADDRESS [MODE_CROP_Y1_B]
+	{{0x33,0x90},{0x04,0xB0}}, 	// MCU_DATA_0
+};
+
+static struct regval_list sensor_uxga_regs[] = {
+  {{0xff,0xff},  {0x00,0x0a}},           //delay 10ms
+  {{0x34, 0x1E}, {0x8F, 0x09}},		 //PLL/ Clk_in control: BYPASS PLL = 0x8F09
+	{{0x34, 0x1C}, {0x01, 0x20}},		 //PLL Control 1 = 0x120
+	{{0xff,0xff},  {0x00,0x0a}},           //delay 10ms
+	{{0x34, 0x1E}, {0x8F, 0x09}},		 //PLL/ Clk_in control: PLL ON, bypassed = 0x8F09
+	{{0x34, 0x1E}, {0x8F, 0x08}},		 //PLL/ Clk_in control: USE PLL = 0x8F08
+
+	{{0x33,0x8c},{0xa1,0x03}},
+	{{0x33,0x90},{0x00,0x02}},
+	{{0xff,0xff},{0x00,0x0a}},			//delay 10ms
+
+  {{0x33,0x8c},{0xa1,0x20}},
+	{{0x33,0x90},{0x00,0x02}},
+	{{0x33,0x8c},{0xa1,0x03}},
+	{{0x33,0x90},{0x00,0x02}},
+	{{0xff,0xff},{0x00,0x64}},
+	{{0x33,0x8c},{0xa1,0x20}},
+	{{0x33,0x90},{0x00,0x02}},
+	{{0x33,0x8c},{0xa1,0x03}},
+	{{0x33,0x90},{0x00,0x02}},
+	{{0xff,0xff},{0x00,0x64}},
+	{{0x33,0x8c},{0xa1,0x03}},
+	{{0x33,0x90},{0x00,0x02}},
+	{{0x33,0x8c},{0xa1,0x03}},
+	{{0x33,0x90},{0x00,0x02}},
+	{{0xff,0xff},{0x00,0xff}},
+};
+
+static struct regval_list sensor_vga_regs[] = {
+
+	{{0x30,0x1A},  {0x0A,0xCC}},	 // RESET_REGISTER
+  {{0x32,0x02},	 { 0x00,0x08}},	 // STANDBY_CONTROL
+  {{0xff,0xff},  {0x00,0x10}},       //delay 10ms
+	{{0x34, 0x1E}, {0x8F, 0x09}},		 //PLL/ Clk_in control: BYPASS PLL = 0x8F09
+	{{0x34, 0x1C}, {0x01, 0x20}},		 //PLL Control 1 = 0x120
+	{{0xff,0xff},  {0x00,0x0a}},       //delay 10ms
+	{{0x34, 0x1E}, {0x8F, 0x09}},		 //PLL/ Clk_in control: PLL ON, bypassed = 0x8F09
+	{{0x34, 0x1E}, {0x8F, 0x08}},		 //PLL/ Clk_in control: USE PLL = 0x8F08
+
+	{{0x33, 0x8C}, {0xA4, 0x0D}},		 //Stat_min
+	{{0x33, 0x90}, {0x00, 0x02}},		 // 	 = 2
+	{{0x33, 0x8C}, {0xA4, 0x10}},		 //Min_amplitude
+	{{0x33, 0x90}, {0x00, 0x01}},		 // 	 = 1
+	{{0x33, 0x8C}, {0xA1, 0x03}},		 //Refresh Sequencer Mode
+	{{0x33, 0x90}, {0x00, 0x06}},		 // 	 = 6
+	{{0xff,0xff}, {0x00,0x64}},				//delay 100ms
+	{{0x33, 0x8C}, {0xA1, 0x03}},		 //Refresh Sequencer
+	{{0x33, 0x90}, {0x00, 0x05}},		 // 	 = 5
+	{{0xff,0xff}, {0x00,0x64}},				//delay 100ms
+
+	{{0x33, 0xf4}, {0x03, 0x1d}},		//defect
+	{{0x33, 0x8c}, {0xa1, 0x18}},	  //saturation
+	{{0x33, 0x90}, {0x00, 0x26}},
+
+	{{0x33, 0x8C}, {0xA1, 0x20}},	// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x00}},	// SEQ_CAP_MODE
+	{{0x33, 0x8C}, {0xA1, 0x03}},	// MCU_ADDRESS
+	{{0x33, 0x90}, {0x00, 0x01}},	// SEQ_CM
+	{{0xff,0xff}, {0x00,0xff}},		//delay 100ms
+};
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+{{0x33,0x8C}, {0xA1,0x02}},
+{{0x33,0x90}, {0x00,0x0F}},
+{{0x33,0x8C}, {0xA3,0x67}},
+{{0x33,0x90}, {0x00,0x80}},
+{{0x33,0x8C}, {0xA3,0x68}},
+{{0x33,0x90}, {0x00,0x80}},
+{{0x33,0x8C}, {0xA3,0x69}},
+{{0x33,0x90}, {0x00,0x80}},
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+{{0x33,0x8C}, {0xA1,0x02}},
+{{0x33,0x90}, {0x00,0x0B}},
+{{0x33,0x8C}, {0xA3,0x67}},
+{{0x33,0x90}, {0x00,0x9f}},
+{{0x33,0x8C}, {0xA3,0x68}},
+{{0x33,0x90}, {0x00,0x80}},
+{{0x33,0x8C}, {0xA3,0x69}},
+{{0x33,0x90}, {0x00,0x7e}},
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+{{0x33,0x8C}, {0xA1,0x02}},
+{{0x33,0x90}, {0x00,0x0B}},
+{{0x33,0x8C}, {0xA3,0x67}},
+{{0x33,0x90}, {0x00,0x85}},
+{{0x33,0x8C}, {0xA3,0x68}},
+{{0x33,0x90}, {0x00,0x90}},
+{{0x33,0x8C}, {0xA3,0x69}},
+{{0x33,0x90}, {0x00,0x90}},
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+{{0x33,0x8C}, {0xA1,0x02}},
+{{0x33,0x90}, {0x00,0x0B}},
+
+{{0x33,0x8C}, {0xA3,0x67}},
+{{0x33,0x90}, {0x00,0x81}},
+{{0x33,0x8C}, {0xA3,0x68}},
+{{0x33,0x90}, {0x00,0x88}},
+{{0x33,0x8C}, {0xA3,0x69}},
+{{0x33,0x90}, {0x00,0x83}},
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+{{0x33,0x8C}, {0xA1,0x02}},
+{{0x33,0x90}, {0x00,0x0B}},
+
+{{0x33,0x8C}, {0xA3,0x67}},
+{{0x33,0x90}, {0x00,0x81}},
+{{0x33,0x8C}, {0xA3,0x68}},
+{{0x33,0x90}, {0x00,0x80}},
+{{0x33,0x8C}, {0xA3,0x69}},
+{{0x33,0x90}, {0x00,0x98}},
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+{{0x33,0x8C}, {0xA1,0x02}},
+{{0x33,0x90}, {0x00,0x0B}},
+
+{{0x33,0x8C}, {0xA3,0x67}},
+{{0x33,0x90}, {0x00,0x91}},
+{{0x33,0x8C}, {0xA3,0x68}},
+{{0x33,0x90}, {0x00,0x7F}},
+{{0x33,0x8C}, {0xA3,0x69}},
+{{0x33,0x90}, {0x00,0x82}},
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+{{0x33,0x8C}, {0x27,0x99}},
+{{0x33,0x90}, {0x64,0x08}},
+{{0x33,0x8C}, {0x27,0x9B}},
+{{0x33,0x90}, {0x64,0x08}},
+{{0x33,0x8C}, {0xA1,0x03}},
+{{0x33,0x90}, {0x00,0x05}},
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+{{0x33,0x8C}, {0x27,0x99}},
+{{0x33,0x90}, {0x64,0x09}},
+{{0x33,0x8C}, {0x27,0x9B}},
+{{0x33,0x90}, {0x64,0x09}},
+{{0x33,0x8C}, {0xA1,0x03}},
+{{0x33,0x90}, {0x00,0x05}},
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+{{0x33,0x8C}, {0x27,0x99}},
+{{0x33,0x90}, {0x64,0x0A}},
+{{0x33,0x8C}, {0x27,0x9B}},
+{{0x33,0x90}, {0x64,0x0A}},
+{{0x33,0x8C}, {0xA1,0x03}},
+{{0x33,0x90}, {0x00,0x05}},
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+{{0x33,0x8C}, {0x27,0x99}},
+{{0x33,0x90}, {0x64,0x0B}},
+{{0x33,0x8C}, {0x27,0x9B}},
+{{0x33,0x90}, {0x64,0x0B}},
+{{0x33,0x8C}, {0xA1,0x03}},
+{{0x33,0x90}, {0x00,0x05}},
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+	//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x10}},
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x20}},
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x20}},
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x30}},
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x3d}},
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x4d}},
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x5d}},
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x6d}},
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0x33,0x8c},{0x22,0x44}},
+	{{0x33,0x90},{0x00,0x7d}},
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0x33,0x8C}, {0x27,0x95}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x02}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x97}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x02}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x95}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x02}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x97}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x02}}, // SEQ_CMD
+	{{0x33,0x8C}, {0xa1,0x03}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x05}}, // SEQ_CMD
+
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0x33,0x8C}, {0x27,0x95}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x03}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x97}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x03}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x95}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x03}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x97}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x03}}, // SEQ_CMD
+	{{0x33,0x8C}, {0xa1,0x03}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x05}}, // SEQ_CMD
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0x33,0x8C}, {0x27,0x95}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x01}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x97}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x01}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x95}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x01}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x97}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x01}}, // SEQ_CMD
+	{{0x33,0x8C}, {0xa1,0x03}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x05}}, // SEQ_CMD
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0x33,0x8C}, {0x27,0x95}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x00}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x97}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x00}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x95}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x00}}, // SEQ_CMD
+	{{0x33,0x8C}, {0x27,0x97}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x00}}, // SEQ_CMD
+	{{0x33,0x8C}, {0xa1,0x03}}, // MCU_ADDRESS
+	{{0x33,0x90}, {0x00,0x05}}, // SEQ_CMD
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		if(vals->reg_num[0] == 0xff)
+			msleep(vals->value[0] * 256 + vals->value[1]);
+		else {
+			ret = sensor_write(sd, vals->reg_num, vals->value);
+			if (ret < 0)
+				{
+					csi_dev_err("sensor_write_err!\n");
+					return ret;
+			}
+		}
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(200);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.value[0] = 0x00;
+	regs.value[1] = 0x00;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x15)//0x1580
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* SXGA */
+	{
+		.width		= UXGA_WIDTH,
+		.height		= UXGA_HEIGHT,
+		.regs 		= sensor_uxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_uxga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct v4l2_fract *tpf = &cp->timeperframe;
+	//struct sensor_info *info = to_state(sd);
+	//int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else
+//		div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > CLK_SCALE)
+//		div = CLK_SCALE;
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_EXPOSURE:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+//	case V4L2_CID_EXPOSURE_AUTO:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_DO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+//	case V4L2_CID_AUTO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_COLORFX:
+//		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x8c;
+	regs.value[0] = 0x27;
+	regs.value[1] = 0x19;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x90;
+
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[1] &= (1<<0); //bit0 is hflip enable
+
+	*value = regs.value[1];
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x8C;
+	regs.value[0] = 0x27;
+	regs.value[1] = 0x19;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x90;
+
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[1] &= 0xfe;
+		break;
+	case 1:
+		regs.value[1] |= 0x01;
+		break;
+	default:
+		break;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x8C;
+	regs.value[0] = 0x27;
+	regs.value[1] = 0x3B;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x90;
+
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[1] &= 0xfe;
+		break;
+	case 1:
+		regs.value[1] |= 0x01;
+		break;
+	default:
+		break;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x8c;
+	regs.value[0] = 0x27;
+	regs.value[1] = 0x19;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x90;
+
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[1] &= (1<<1); //bit1 is vflip enable
+
+	*value = regs.value[1];
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x8C;
+	regs.value[0] = 0x27;
+	regs.value[1] = 0x19;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x90;
+
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[1] &= 0xfd;
+		break;
+	case 1:
+		regs.value[1] |= 0x02;
+		break;
+	default:
+		break;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x8C;
+	regs.value[0] = 0x27;
+	regs.value[1] = 0x3B;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x33;
+	regs.reg_num[1] = 0x90;
+
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[1] &= 0xfd;
+		break;
+	case 1:
+		regs.value[1] |= 0x02;
+		break;
+	default:
+		break;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->autowb ;
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	msleep(60);
+
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "mt9d112", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "mt9d112",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
+
diff --git a/drivers/media/video/sun4i_csi/device/mt9m112.c b/drivers/media/video/sun4i_csi/device/mt9m112.c
new file mode 100644
index 0000000..090532d
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/mt9m112.c
@@ -0,0 +1,2055 @@
+/*
+ * drivers/media/video/sun4i_csi/device/mt9m112.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for Micron mt9m112 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for Micron mt9m112 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][MT9M112]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][MT9M112]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][MT9M112]"x,##arg)
+
+#define MCLK (24*1000*1000)
+//#define MCLK (49.5*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x1320
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 2
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define SXGA_WIDTH	1280
+#define SXGA_HEIGHT	1024
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 25
+
+/*
+ * The Micron mt9m112 sits on i2c with ID 0xBA
+ */
+#define I2C_ADDR 0xBA
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+
+static struct regval_list sensor_default_regs[] = {
+#if 1 //MCLK == 24M
+{{0xf0},{0x00,0x00}},
+{{0x66},{0x10,0x01}},
+{{0x67},{0x05,0x01}},
+{{0x65},{0xa0,0x00}},
+{{0xff},{0x00,0x64}},
+{{0x65},{0x20,0x00}},
+{{0xff},{0x00,0x64}},
+#endif
+{{0xf0},{0x00,0x00}},
+{{0x0d},{0x00,0x09}},
+{{0xff},{0x00,0x20}},
+{{0x0d},{0x00,0x08}},
+{{0xf0},{0x00,0x00}},
+{{0x01},{0x00,0x24}},
+{{0x03},{0x04,0x00}},// default value
+{{0x30},{0x04,0x2a}},
+{{0xf0},{0x00,0x01}},
+{{0x05},{0x00,0x0f}},
+{{0x25},{0x00,0x4d}},// saturation adjustment, default value  0x4d
+{{0x3b},{0x04,0x30}},//0x0436
+{{0x3c},{0x04,0x00}},
+{{0x47},{0x32,0x2e}},
+{{0x9d},{0x3c,0xe0}},
+
+{{0xf0},{0x00,0x02}},
+{{0x28},{0xef,0x02}},//0xef3e
+{{0x06},{0x74,0x8e}},
+{{0x02},{0x00,0xee}},// base matrix signs
+{{0x15},{0x00,0xd9}},// delta coefficients signs
+{{0x09},{0x00,0x67}},//k1
+{{0x0a},{0x00,0x9a}},//k2
+{{0x0b},{0x00,0x28}},//k3
+{{0x0c},{0x00,0x30}},//k4
+{{0x0d},{0x00,0xca}},//k5
+{{0x0e},{0x00,0x37}},//k6
+{{0x0f},{0x00,0x1a}},//k7
+{{0x10},{0x00,0x65}},//k8
+{{0x11},{0x00,0x86}},//k9
+{{0x16},{0x00,0x5e}},//d1  0x0062
+{{0x17},{0x00,0x84}},//d2
+{{0x18},{0x00,0x4d}},//d3
+{{0x19},{0x00,0x24}},//d4
+{{0x1a},{0x00,0x1f}},//d5
+{{0x1b},{0x00,0x2f}},//d6
+{{0x1c},{0x00,0x04}},//d7
+{{0x1d},{0x00,0x23}},//d8
+{{0x1e},{0x00,0x10}},//d9
+{{0x03},{0x39,0x22}},// base matrix scale k1-k5
+{{0x04},{0x05,0x24}},// base matrix scale k6-k9 0x04e4
+{{0xf0},{0x00,0x02}},
+{{0x1f},{0x01,0x80}},
+{{0x20},{0xc8,0x14}},//0xdc0c
+{{0x21},{0x80,0x80}},
+{{0x22},{0x90,0x80}},
+{{0x23},{0x88,0x78}},
+{{0x26},{0x80,0x00}},
+{{0x27},{0x80,0x08}},
+{{0x2e},{0x0c,0x44}},// 0x0d20
+{{0x3e},{0x1c,0xff}},
+{{0x46},{0x00,0xb0}},
+{{0x5b},{0x80,0x02}},
+{{0x5c},{0x11,0x0c}},
+{{0x5d},{0x15,0x10}},
+{{0x5e},{0x53,0x4c}},
+{{0x5f},{0x2b,0x21}},
+{{0x24},{0x7f,0x40}},
+{{0x60},{0x00,0x02}},
+{{0x62},{0x10,0x10}},
+{{0x65},{0x00,0x00}},
+{{0xdc},{0x0f,0xf8}},
+{{0xdd},{0x0c,0xe0}},
+{{0xf0},{0x00,0x01}},
+{{0x47},{0x20,0x2e}},
+{{0x80},{0x00,0x06}},// lens correction control
+{{0x81},{0x00,0x00}},// vertical red knee 0 and initial value  0x0009
+{{0x82},{0xfe,0x05}},// vertical red knees 2 and 1
+{{0x83},{0x00,0x00}},// vertical red knees 4 and 30x00ff
+{{0x84},{0x0c,0x00}},// vertical green knee 0 and initial value
+{{0x85},{0xfe,0x02}},// vertical green knees 2 and 1
+{{0x86},{0x00,0xff}},// vertical green knees 4 and 3
+{{0x87},{0x07,0x01}},// vertical blue knee 0 and initial value 1003
+{{0x88},{0xfc,0x06}},// vertical blue knees 2 and 1
+{{0x89},{0x00,0xff}},// vertical blue knees 4 and 3
+{{0x8a},{0x08,0x01}},// horizontal red knee 0 and initial value
+{{0x8b},{0x03,0x0e}},// horizontal red knees 2 and 1
+{{0x8c},{0xfe,0xfd}},// horizontal red knees 4 and 3
+{{0x8d},{0x00,0xff}},// horizontal red knee 5
+{{0x8e},{0x06,0x01}},// horizontal green knee 0 and initial value
+{{0x8f},{0x04,0x0b}},// horizontal green knees 2 and 1
+{{0x90},{0xfe,0xfb}},// horizontal green knees 4 and 3
+{{0x91},{0x00,0xfe}},// horizontal green knee 5
+{{0x92},{0x06,0x00}},// horizontal blue knee 0 and initial value
+{{0x93},{0x04,0x0b}},// horizontal blue knees 2 and 1
+{{0x94},{0xfe,0xfd}},// horizontal blue knees 4 and 3
+{{0x95},{0x00,0xff}},// horizontal blue knees 5
+{{0xb6},{0x02,0x04}},// lens vertical red knees 6 and 5
+{{0xb7},{0xfb,0xfa}},// lens vertical red knees 8 and 7
+{{0xb8},{0x05,0x03}},// lens vertical green knees 6 and 5
+{{0xb9},{0xfa,0xf8}},// lens vertical green knees 8 and 7
+{{0xba},{0x04,0x01}},// lens vertical blue knees 6 and 5
+{{0xbb},{0xfe,0xf8}},// lens vertical blue knees 8 and 7
+{{0xbc},{0xff,0x01}},// lens horizontal red knees 7 and 6
+{{0xbd},{0xf4,0xff}},// lens horizontal red knees 9 and 8
+{{0xbe},{0x00,0xfb}},// lens horizontal red knee 10
+{{0xbf},{0x00,0x00}},// lens horizontal green knees 7 and 6
+{{0xc0},{0xf8,0xfd}},// lens horizontal green knees 9 and 8
+{{0xc1},{0x00,0xf7}},// lens horizontal green knee 10
+{{0xc2},{0x01,0xff}},// lens horizontal blue knees 7 and 6
+{{0xc3},{0xf5,0xfc}},// lens horizontal blue knees 9 and 8
+{{0xc4},{0x00,0xfa}},// lens horizontal blue knee 10
+{{0x06},{0x74,0x8e}},
+{{0x9d},{0x3c,0xe0}},// defect correction control
+{{0xf0},{0x00,0x02}},
+{{0x2e},{0x0d,0x3a}},// 0x0d32
+{{0x37},{0x00,0x81}},
+{{0x36},{0x78,0x10}},
+{{0xf0},{0x00,0x01}},
+{{0x06},{0xf4,0x8e}},
+{{0xf0},{0x00,0x01}},
+{{0x06},{0x64,0x8e}},
+{{0xf0},{0x00,0x02}},
+{{0x5b},{0x00,0x01}},//0x0003
+
+{{0xf0},{0x00,0x00}},
+{{0x20},{0x01,0x00}},
+{{0x21},{0x80,0x00}},
+{{0x22},{0x09,0x0d}},
+};
+
+static struct regval_list sensor_oe_disable_regs[] = {
+{{0xf0},{0x00,0x00}},
+{{0x0d},{0x00,0x18}},
+};
+
+static struct regval_list sensor_sxga_regs[] = {
+{{0xf0},{0x00,0x00}},
+{{0x05},{0x01,0x40}},// horizontal blank
+{{0x06},{0x00,0x0d}},
+{{0xf0},{0x00,0x02}},
+{{0xc8},{0x1f,0x0b}},
+{{0x9c},{0xd1,0x00}},// auto exposure speed B
+{{0x59},{0x02,0x71}},
+{{0x5a},{0x02,0x71}},
+{{0xf0},{0x00,0x00}},
+//{{0x20},{0x01,0x00}},
+//{{0x22},{0x09,0x0d}},
+{{0x68},{0x00,0x70}},
+{{0xf0},{0x00,0x01}},
+{{0xa1},{0x05,0x00}},// horizontal output size B
+{{0xa4},{0x04,0x00}},// vertical output size B
+{{0x9b},{0x02,0x02}},
+{{0xdc},{0x11,0x05}},// gamma start B
+{{0xdd},{0x5d,0x33}},
+{{0xde},{0xad,0x8d}},
+{{0xdf},{0xd6,0xc4}},
+{{0xe0},{0xf3,0xe6}},
+{{0xe1},{0xff,0x00}},// gamma end B
+{{0xf0},{0x00,0x00}},
+};
+
+static struct regval_list sensor_vga_regs[] = {
+{{0xf0},{0x00,0x00}},
+{{0x07},{0x03,0x74}},   //horizontal blank
+{{0x08},{0x00,0x09}},
+{{0xf0},{0x00,0x02}},
+{{0xc8},{0x00,0x00}},
+{{0x2f},{0xd1,0x00}},// auto exposure speed A
+{{0x57},{0x02,0x71}},
+{{0x58},{0x02,0x71}},
+{{0xf0},{0x00,0x00}},
+//{{0x21},{0x80,0x00}},
+//{{0x22},{0x09,0x0d}},
+{{0x68},{0x00,0x70}},
+{{0xf0},{0x00,0x01}},
+{{0xa7},{0x02,0x80}},// horizontal output size A
+{{0xaa},{0x02,0x00}},// vertical output size A
+{{0x3a},{0x02,0x02}},
+{{0x53},{0x11,0x05}},// gamma start A
+{{0x54},{0x5d,0x33}},
+{{0x55},{0xad,0x8d}},
+{{0x56},{0xd6,0xc4}},
+{{0x57},{0xf3,0xe6}},
+{{0x58},{0xff,0x00}},// gamma end A
+{{0xf0},{0x00,0x00}},
+};
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+//static struct regval_list sensor_wb_auto_regs[] = {
+//	//NULL
+//};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	//NULL
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	//NULL
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	//NULL
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	//NULL
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+{{0xf0},{0x00,0x01}},
+{{0xe2},{0x70,0x00}},
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+{{0xf0},{0x00,0x01}},
+{{0xe2},{0x70,0x01}},
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+{{0xf0},{0x00,0x01}},
+{{0xe2},{0x70,0x02}},
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+{{0xf0},{0x00,0x01}},
+{{0xe2},{0x70,0x03}},
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+	//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+	//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	//NULL
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0xf0},{0x00,0x01}},   //Page 1
+	{{0x9b},{0x02,0x02}},   //Context B YCbYCr
+	{{0x3a},{0x02,0x02}},   //Context A YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0xf0},{0x00,0x01}},   //Page 1
+	{{0x9b},{0x02,0x03}},   //Context B YCrYCb
+	{{0x3a},{0x02,0x03}},   //Context A YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0xf0},{0x00,0x01}},   //Page 1
+	{{0x9b},{0x02,0x01}},   //Context B CrYCbY
+	{{0x3a},{0x02,0x01}},   //Context A CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0xf0},{0x00,0x01}},   //Page 1
+	{{0x9b},{0x02,0x00}},   //Context B CbYCrY
+	{{0x3a},{0x02,0x00}},   //Context A CbYCrY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		if(vals->reg_num[0] == 0xff)
+			msleep(vals->value[0] * 256 + vals->value[1]);
+		else {
+			ret = sensor_write(sd, vals->reg_num, vals->value);
+			if (ret < 0)
+				{
+					csi_dev_err("sensor_write_err!\n");
+					return ret;
+				}
+		}
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+	int ret;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//disable io oe
+			csi_dev_print("disalbe oe!\n");
+			ret = sensor_write_array(sd, sensor_oe_disable_regs , ARRAY_SIZE(sensor_oe_disable_regs));
+			if(ret < 0)
+				csi_dev_err("disalbe oe falied!\n");
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+//			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+//			msleep(100);
+//			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+//			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+//			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+//			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfe;
+	regs.value[0] = 0x00; //PAGE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x00;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x14)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* SXGA */
+	{
+		.width		= SXGA_WIDTH,
+		.height		= SXGA_HEIGHT,
+		.regs 		= sensor_sxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_sxga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_EXPOSURE:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+//	case V4L2_CID_EXPOSURE_AUTO:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_DO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+//	case V4L2_CID_AUTO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[1] &= (1<<1);
+	regs.value[1] = regs.value[1]>>1;		//0x20 bit1 is hflip enable
+
+	*value = regs.value[1];
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[1] &= 0xfd;
+		break;
+	case 1:
+		regs.value[1] |= 0x02;
+		break;
+	default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[1] &= (1<<0);
+	regs.value[1] = regs.value[0]>>0;		//0x20 bit0 is vflip enable
+
+	*value = regs.value[1];
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xf0;
+	regs.value[0] = 0x00; //PAGEMODE 0x00
+	regs.value[1] = 0x00;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[1] &= 0xfe;
+		break;
+	case 1:
+		regs.value[1] |= 0x01;
+		break;
+	default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+	msleep(100);
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "mt9m112", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "mt9m112",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/mt9m113.c b/drivers/media/video/sun4i_csi/device/mt9m113.c
new file mode 100644
index 0000000..1775f2c
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/mt9m113.c
@@ -0,0 +1,2175 @@
+/*
+ * drivers/media/video/sun4i_csi/device/mt9m113.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for GalaxyCore mt9m113 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+#include <linux/io.h>
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore mt9m113 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][MT9M113]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][MT9M113]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][MT9M113]"x,##arg)
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_FALLING
+#define IO_CFG		0						//0 for csi0
+#define V4L2_IDENT_SENSOR 0x113
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 2
+#define REG_DATA_STEP 2
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define UXGA_WIDTH		1600
+#define UXGA_HEIGHT		1200
+#define SXGA_WIDTH		1280
+#define SXGA_HEIGHT		1024
+#define HD720_WIDTH 	1280
+#define HD720_HEIGHT	720
+#define SVGA_WIDTH		800
+#define SVGA_HEIGHT 	600
+#define VGA_WIDTH			640
+#define VGA_HEIGHT		480
+#define QVGA_WIDTH		320
+#define QVGA_HEIGHT		240
+#define CIF_WIDTH			352
+#define CIF_HEIGHT		288
+#define QCIF_WIDTH		176
+#define	QCIF_HEIGHT		144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 30
+
+/*
+ * The mt9m113 sits on i2c with ID 0x78
+ */
+#define I2C_ADDR 0x78
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+struct snesor_colorfx_struct; /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+
+/*
+ * The default register settings
+ *
+ */
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+
+static struct regval_list sensor_default_regs[] = {
+//{ {0x00,0x1A}, {0x02,0x11} }, // RESET_AND_MISC_CONTROL
+//{ {0xff,0xff}, {0x00,0x64} },
+//{ {0x00,0x1A}, {0x02,0x10} }, // RESET_AND_MISC_CONTROL
+
+{ {0x00,0x14}, {0xB0,0x47} }, // PLL_CONTROL
+{ {0x00,0x14}, {0xB0,0x45} }, // PLL_CONTROL
+{ {0x00,0x14}, {0x21,0x45} }, // PLL_CONTROL
+{ {0x00,0x10}, {0x01,0x14} }, // PLL_DIVIDERS
+{ {0x00,0x12}, {0x1F,0xF1} }, // PLL_P_DIVIDERS
+{ {0x00,0x14}, {0x25,0x45} }, // PLL_CONTROL
+{ {0x00,0x14}, {0x25,0x47} }, // PLL_CONTROL
+{ {0x00,0x14}, {0x34,0x47} }, // PLL_CONTROL
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x00,0x14}, {0x30,0x47} }, // PLL_CONTROL
+{ {0x00,0x14}, {0x30,0x46} }, // PLL_CONTROL
+{ {0x00,0x1A}, {0x02,0x10} }, // RESET_AND_MISC_CONTROL
+{ {0x00,0x18}, {0x40,0x28} }, // STANDBY_CONTROL
+{ {0x32,0x1C}, {0x00,0x03} }, // OFIFO_CONTROL_STATUS
+////preview=640*480,capture=1280*1024,YUV MODE
+{ {0x09,0x8C}, {0x27,0x03} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x02,0xa0} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x05} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x02,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x07} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x05,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x09} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x04,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x0D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x0F} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x11} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x03,0xed} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x13} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x05,0x2D} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x15} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x21,0x11} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x17} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x04,0x6e} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x23} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x25} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x27} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x04,0x1B} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x29} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x05,0x2B} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x2B} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x21,0x11} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x2D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x26} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x2F} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x4C} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x31} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0xF9} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x33} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0xA7} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x35} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x05,0x3D} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x37} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x07,0x22} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x39} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x3B} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x02,0x8F} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x3D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x3F} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x01,0xeF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x47} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x49} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x04,0xFF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x4B} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x4D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x03,0xFF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x04} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x0D} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x0E} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x03} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x10} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x0A} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x06} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS
+{ {0x09,0x90}, {0x00,0x05} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0x22,0x2D} },  // MCU_ADDRESS [AE_R9_STEP]
+{ {0x09,0x90}, {0x00,0x67} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x08} },  // MCU_ADDRESS [FD_SEARCH_F1_50]
+{ {0x09,0x90}, {0x00,0x13} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x09} },  // MCU_ADDRESS [FD_SEARCH_F2_50]
+{ {0x09,0x90}, {0x00,0x15} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x0A} },  // MCU_ADDRESS [FD_SEARCH_F1_60]
+{ {0x09,0x90}, {0x00,0x17} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA4,0x0B} },  // MCU_ADDRESS [FD_SEARCH_F2_60]
+{ {0x09,0x90}, {0x00,0x19} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x24,0x11} },  // MCU_ADDRESS [FD_R9_STEP_F60_A]
+{ {0x09,0x90}, {0x00,0x67} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x24,0x13} },  // MCU_ADDRESS [FD_R9_STEP_F50_A]
+{ {0x09,0x90}, {0x00,0x7C} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x24,0x15} },  // MCU_ADDRESS [FD_R9_STEP_F60_B]
+{ {0x09,0x90}, {0x00,0x67} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x24,0x17} },  // MCU_ADDRESS [FD_R9_STEP_F50_B]
+{ {0x09,0x90}, {0x00,0x7C} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xAB,0x2D} },  // MCU_ADDRESS [HG_NR_START_G]
+{ {0x09,0x90}, {0x00,0x2A} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xAB,0x31} },  // MCU_ADDRESS [HG_NR_STOP_G]
+{ {0x09,0x90}, {0x00,0x2E} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x2B,0x28} },  // MCU_ADDRESS [HG_LL_BRIGHTNESSSTART]
+{ {0x09,0x90}, {0x1F,0x40} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x2B,0x2A} },  // MCU_ADDRESS [HG_LL_BRIGHTNESSSTOP]
+{ {0x09,0x90}, {0x3A,0x98} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x2B,0x38} },  // MCU_ADDRESS [HG_GAMMASTARTMORPH]
+{ {0x09,0x90}, {0x1F,0x40} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x2B,0x3A} },  // MCU_ADDRESS [HG_GAMMASTOPMORPH]
+{ {0x09,0x90}, {0x3A,0x98} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x22,0x57} },  // MCU_ADDRESS [RESERVED_AE_57]
+{ {0x09,0x90}, {0x27,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x22,0x50} },  // MCU_ADDRESS [RESERVED_AE_50]
+{ {0x09,0x90}, {0x1B,0x58} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x22,0x52} },  // MCU_ADDRESS [RESERVED_AE_52]
+{ {0x09,0x90}, {0x32,0xC8} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x19} },  // MCU_ADDRESS [MODE_SENSOR_FINE_CORRECTION_A]
+{ {0x09,0x90}, {0x00,0xAC} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x1B} },  // MCU_ADDRESS [MODE_SENSOR_FINE_IT_MIN_A]
+{ {0x09,0x90}, {0x01,0xF1} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x1D} },  // MCU_ADDRESS [MODE_SENSOR_FINE_IT_MAX_MARGIN_A]
+{ {0x09,0x90}, {0x01,0x3F} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x1F} },  // MCU_ADDRESS [MODE_SENSOR_FRAME_LENGTH_A]
+{ {0x09,0x90}, {0x02,0x93} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x21} },  // MCU_ADDRESS [MODE_SENSOR_LINE_LENGTH_PCK_A]
+{ {0x09,0x90}, {0x06,0x80} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x5F} },  // MCU_ADDRESS [RESERVED_MODE_5F]
+{ {0x09,0x90}, {0x05,0x96} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x61} },  // MCU_ADDRESS [RESERVED_MODE_61]
+{ {0x09,0x90}, {0x00,0x94} },  // MCU_DATA_0
+{ {0x36,0x4E}, {0x08,0xF0} },  // P_GR_P0Q0
+{ {0x36,0x50}, {0x15,0x4F} },  // P_GR_P0Q1
+{ {0x36,0x52}, {0x01,0x71} },  // P_GR_P0Q2
+{ {0x36,0x54}, {0x2D,0x6E} },  // P_GR_P0Q3
+{ {0x36,0x56}, {0x9E,0x2F} },  // P_GR_P0Q4
+{ {0x36,0x58}, {0x02,0x70} },  // P_RD_P0Q0
+{ {0x36,0x5A}, {0xD8,0x8B} },  // P_RD_P0Q1
+{ {0x36,0x5C}, {0x0A,0x51} },  // P_RD_P0Q2
+{ {0x36,0x5E}, {0x5C,0xEE} },  // P_RD_P0Q3
+{ {0x36,0x60}, {0xBE,0x8F} },  // P_RD_P0Q4
+{ {0x36,0x62}, {0x06,0x30} },  // P_BL_P0Q0
+{ {0x36,0x64}, {0x01,0x8F} },  // P_BL_P0Q1
+{ {0x36,0x66}, {0x49,0xB0} },  // P_BL_P0Q2
+{ {0x36,0x68}, {0x0B,0x6C} },  // P_BL_P0Q3
+{ {0x36,0x6A}, {0x8F,0xEF} },  // P_BL_P0Q4
+{ {0x36,0x6C}, {0x02,0x50} },  // P_GB_P0Q0
+{ {0x36,0x6E}, {0xBE,0x6A} },  // P_GB_P0Q1
+{ {0x36,0x70}, {0x5A,0x50} },  // P_GB_P0Q2
+{ {0x36,0x72}, {0x2D,0x6E} },  // P_GB_P0Q3
+{ {0x36,0x74}, {0xE8,0x8E} },  // P_GB_P0Q4
+{ {0x36,0x76}, {0x1A,0xCD} },  // P_GR_P1Q0
+{ {0x36,0x78}, {0x44,0xAD} },  // P_GR_P1Q1
+{ {0x36,0x7A}, {0x63,0xAD} },  // P_GR_P1Q2
+{ {0x36,0x7C}, {0x83,0xCF} },  // P_GR_P1Q3
+{ {0x36,0x7E}, {0x95,0x2F} },  // P_GR_P1Q4
+{ {0x36,0x80}, {0x2F,0xCD} },  // P_RD_P1Q0
+{ {0x36,0x82}, {0xE9,0x2B} },  // P_RD_P1Q1
+{ {0x36,0x84}, {0x74,0xAE} },  // P_RD_P1Q2
+{ {0x36,0x86}, {0x96,0x4E} },  // P_RD_P1Q3
+{ {0x36,0x88}, {0xAB,0x0F} },  // P_RD_P1Q4
+{ {0x36,0x8A}, {0x21,0x6C} },  // P_BL_P1Q0
+{ {0x36,0x8C}, {0x3A,0xE8} },  // P_BL_P1Q1
+{ {0x36,0x8E}, {0x77,0x4D} },  // P_BL_P1Q2
+{ {0x36,0x90}, {0x9D,0x6E} },  // P_BL_P1Q3
+{ {0x36,0x92}, {0x93,0xAF} },  // P_BL_P1Q4
+{ {0x36,0x94}, {0x56,0x4C} },  // P_GB_P1Q0
+{ {0x36,0x96}, {0x5A,0x6C} },  // P_GB_P1Q1
+{ {0x36,0x98}, {0x20,0x0C} },  // P_GB_P1Q2
+{ {0x36,0x9A}, {0x90,0xAE} },  // P_GB_P1Q3
+{ {0x36,0x9C}, {0x86,0xAE} },  // P_GB_P1Q4
+{ {0x36,0x9E}, {0x39,0x50} },  // P_GR_P2Q0
+{ {0x36,0xA0}, {0x6F,0x8E} },  // P_GR_P2Q1
+{ {0x36,0xA2}, {0xA2,0xB0} },  // P_GR_P2Q2
+{ {0x36,0xA4}, {0x8C,0x6F} },  // P_GR_P2Q3
+{ {0x36,0xA6}, {0x7F,0xCD} },  // P_GR_P2Q4
+{ {0x36,0xA8}, {0x62,0x90} },  // P_RD_P2Q0
+{ {0x36,0xAA}, {0xE8,0xEA} },  // P_RD_P2Q1
+{ {0x36,0xAC}, {0xF6,0xAF} },  // P_RD_P2Q2
+{ {0x36,0xAE}, {0x04,0x30} },  // P_RD_P2Q3
+{ {0x36,0xB0}, {0x41,0xCF} },  // P_RD_P2Q4
+{ {0x36,0xB2}, {0x1F,0xD0} },  // P_BL_P2Q0
+{ {0x36,0xB4}, {0x76,0x6D} },  // P_BL_P2Q1
+{ {0x36,0xB6}, {0xD7,0x70} },  // P_BL_P2Q2
+{ {0x36,0xB8}, {0x33,0x6F} },  // P_BL_P2Q3
+{ {0x36,0xBA}, {0x55,0xB1} },  // P_BL_P2Q4
+{ {0x36,0xBC}, {0x2B,0xB0} },  // P_GB_P2Q0
+{ {0x36,0xBE}, {0xC8,0xED} },  // P_GB_P2Q1
+{ {0x36,0xC0}, {0x83,0x10} },  // P_GB_P2Q2
+{ {0x36,0xC2}, {0x12,0xAF} },  // P_GB_P2Q3
+{ {0x36,0xC4}, {0x52,0x8E} },  // P_GB_P2Q4
+{ {0x36,0xC6}, {0x17,0x0D} },  // P_GR_P3Q0
+{ {0x36,0xC8}, {0x14,0xCD} },  // P_GR_P3Q1
+{ {0x36,0xCA}, {0x0F,0xEF} },  // P_GR_P3Q2
+{ {0x36,0xCC}, {0xB9,0x6F} },  // P_GR_P3Q3
+{ {0x36,0xCE}, {0x9D,0xD1} },  // P_GR_P3Q4
+{ {0x36,0xD0}, {0x4E,0xCD} },  // P_RD_P3Q0
+{ {0x36,0xD2}, {0x57,0x2C} },  // P_RD_P3Q1
+{ {0x36,0xD4}, {0xF3,0x4B} },  // P_RD_P3Q2
+{ {0x36,0xD6}, {0x43,0x4E} },  // P_RD_P3Q3
+{ {0x36,0xD8}, {0xEE,0x4F} },  // P_RD_P3Q4
+{ {0x36,0xDA}, {0x25,0x09} },  // P_BL_P3Q0
+{ {0x36,0xDC}, {0x87,0x6A} },  // P_BL_P3Q1
+{ {0x36,0xDE}, {0x52,0x0F} },  // P_BL_P3Q2
+{ {0x36,0xE0}, {0x3A,0xAD} },  // P_BL_P3Q3
+{ {0x36,0xE2}, {0x85,0xF1} },  // P_BL_P3Q4
+{ {0x36,0xE4}, {0xB4,0x2C} },  // P_GB_P3Q0
+{ {0x36,0xE6}, {0x5C,0xCD} },  // P_GB_P3Q1
+{ {0x36,0xE8}, {0x75,0x0F} },  // P_GB_P3Q2
+{ {0x36,0xEA}, {0xA1,0x4E} },  // P_GB_P3Q3
+{ {0x36,0xEC}, {0x9D,0xB1} },  // P_GB_P3Q4
+{ {0x36,0xEE}, {0xD1,0x4F} },  // P_GR_P4Q0
+{ {0x36,0xF0}, {0xC7,0x0D} },  // P_GR_P4Q1
+{ {0x36,0xF2}, {0x03,0x72} },  // P_GR_P4Q2
+{ {0x36,0xF4}, {0x86,0x11} },  // P_GR_P4Q3
+{ {0x36,0xF6}, {0x9F,0x73} },  // P_GR_P4Q4
+{ {0x36,0xF8}, {0xF4,0x2F} },  // P_RD_P4Q0
+{ {0x36,0xFA}, {0x27,0x8E} },  // P_RD_P4Q1
+{ {0x36,0xFC}, {0x79,0xB1} },  // P_RD_P4Q2
+{ {0x36,0xFE}, {0xE1,0x71} },  // P_RD_P4Q3
+{ {0x37,0x00}, {0xCF,0x73} },  // P_RD_P4Q4
+{ {0x37,0x02}, {0x82,0x0E} },  // P_BL_P4Q0
+{ {0x37,0x04}, {0x09,0x6E} },  // P_BL_P4Q1
+{ {0x37,0x06}, {0x62,0x32} },  // P_BL_P4Q2
+{ {0x37,0x08}, {0xE0,0xD1} },  // P_BL_P4Q3
+{ {0x37,0x0A}, {0x87,0x74} },  // P_BL_P4Q4
+{ {0x37,0x0C}, {0x90,0xAF} },  // P_GB_P4Q0
+{ {0x37,0x0E}, {0x02,0x8F} },  // P_GB_P4Q1
+{ {0x37,0x10}, {0x62,0xF1} },  // P_GB_P4Q2
+{ {0x37,0x12}, {0xC9,0x70} },  // P_GB_P4Q3
+{ {0x37,0x14}, {0xF1,0x32} },  // P_GB_P4Q4
+{ {0x36,0x44}, {0x02,0x84} },  // POLY_ORIGIN_C
+{ {0x36,0x42}, {0x02,0x04} },  // POLY_ORIGIN_R
+{ {0x32,0x10}, {0x00,0xB8} },  // COLOR_PIPELINE_CONTROL
+{ {0x09,0x8C}, {0x23,0x06} },  // MCU_ADDRESS [AWB_CCM_L_0]
+{ {0x09,0x90}, {0x02,0x33} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x08} },  // MCU_ADDRESS [AWB_CCM_L_1]
+{ {0x09,0x90}, {0xFF,0x0B} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x0A} },  // MCU_ADDRESS [AWB_CCM_L_2]
+{ {0x09,0x90}, {0x00,0x24} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x0C} },  // MCU_ADDRESS [AWB_CCM_L_3]
+{ {0x09,0x90}, {0xFF,0xC8} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x0E} },  // MCU_ADDRESS [AWB_CCM_L_4]
+{ {0x09,0x90}, {0x01,0xDE} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x10} },  // MCU_ADDRESS [AWB_CCM_L_5]
+{ {0x09,0x90}, {0xFF,0xBD} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x12} },  // MCU_ADDRESS [AWB_CCM_L_6]
+{ {0x09,0x90}, {0x00,0x19} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x14} },  // MCU_ADDRESS [AWB_CCM_L_7]
+{ {0x09,0x90}, {0xFF,0x2B} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x16} },  // MCU_ADDRESS [AWB_CCM_L_8]
+{ {0x09,0x90}, {0x01,0xE8} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x18} },  // MCU_ADDRESS [AWB_CCM_L_9]
+{ {0x09,0x90}, {0x00,0x24} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x1A} },  // MCU_ADDRESS [AWB_CCM_L_10]
+{ {0x09,0x90}, {0x00,0x48} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x1C} },  // MCU_ADDRESS [AWB_CCM_RL_0]
+{ {0x09,0x90}, {0xFE,0xF2} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x1E} },  // MCU_ADDRESS [AWB_CCM_RL_1]
+{ {0x09,0x90}, {0x00,0xB1} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x20} },  // MCU_ADDRESS [AWB_CCM_RL_2]
+{ {0x09,0x90}, {0x00,0x2C} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x22} },  // MCU_ADDRESS [AWB_CCM_RL_3]
+{ {0x09,0x90}, {0x00,0x17} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x24} },  // MCU_ADDRESS [AWB_CCM_RL_4]
+{ {0x09,0x90}, {0x00,0x09} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x26} },  // MCU_ADDRESS [AWB_CCM_RL_5]
+{ {0x09,0x90}, {0xFF,0xB2} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x28} },  // MCU_ADDRESS [AWB_CCM_RL_6]
+{ {0x09,0x90}, {0xFF,0xFD} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x2A} },  // MCU_ADDRESS [AWB_CCM_RL_7]
+{ {0x09,0x90}, {0x00,0xCF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x2C} },  // MCU_ADDRESS [AWB_CCM_RL_8]
+{ {0x09,0x90}, {0xFF,0x34} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x2E} },  // MCU_ADDRESS [AWB_CCM_RL_9]
+{ {0x09,0x90}, {0x00,0x10} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x30} },  // MCU_ADDRESS [AWB_CCM_RL_10]
+{ {0x09,0x90}, {0xFF,0xDC} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x48} },  // MCU_ADDRESS [AWB_GAIN_BUFFER_SPEED]
+{ {0x09,0x90}, {0x00,0x08} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x49} },  // MCU_ADDRESS [AWB_JUMP_DIVISOR]
+{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x4A} },  // MCU_ADDRESS [AWB_GAIN_MIN]
+{ {0x09,0x90}, {0x00,0x59} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x4B} },  // MCU_ADDRESS [AWB_GAIN_MAX]
+{ {0x09,0x90}, {0x00,0xA6} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x51} },  // MCU_ADDRESS [AWB_CCM_POSITION_MIN]
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x52} },  // MCU_ADDRESS [AWB_CCM_POSITION_MAX]
+{ {0x09,0x90}, {0x00,0x7F} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x54} },  // MCU_ADDRESS [AWB_SATURATION]
+{ {0x09,0x90}, {0x00,0x80} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x55} },  // MCU_ADDRESS [AWB_MODE]
+{ {0x09,0x90}, {0x00,0x01} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x5D} },  // MCU_ADDRESS [AWB_STEADY_BGAIN_OUT_MIN]
+{ {0x09,0x90}, {0x00,0x78} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x5E} },  // MCU_ADDRESS [AWB_STEADY_BGAIN_OUT_MAX]
+{ {0x09,0x90}, {0x00,0x86} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x5F} },  // MCU_ADDRESS [AWB_STEADY_BGAIN_IN_MIN]
+{ {0x09,0x90}, {0x00,0x7E} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x60} },  // MCU_ADDRESS [AWB_STEADY_BGAIN_IN_MAX]
+{ {0x09,0x90}, {0x00,0x82} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x23,0x61} },  // MCU_ADDRESS [RESERVED_AWB_61]
+{ {0x09,0x90}, {0x00,0x40} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x63} },  // MCU_ADDRESS [RESERVED_AWB_63]
+{ {0x09,0x90}, {0x00,0xD2} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x64} },  // MCU_ADDRESS [RESERVED_AWB_64]
+{ {0x09,0x90}, {0x00,0xEE} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x02} },  // MCU_ADDRESS [AWB_WINDOW_POS]
+{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0xA3,0x03} },  // MCU_ADDRESS [AWB_WINDOW_SIZE]
+{ {0x09,0x90}, {0x00,0xEF} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+{ {0x00,0x1E}, {0x04,0x01} }, // PAD_SLEW 700 707 400 403 701
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x06} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+static struct regval_list sensor_sxga_regs[] = {
+	//Resoltion Setting : 1280*1024
+{ {0x09,0x8C}, {0xA1,0x15} },	// MCU_ADDRESS [SEQ_CAP_MODE]
+{ {0x09,0x90}, {0x00,0x02} },	// MCU_DATA_0
+{ {0x09,0x8C}, {0xA1,0x16} }, // p1:0x16 frame number in capture mode
+{ {0x09,0x90}, {0xff,0xff} },
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x02} },	// MCU_DATA_0
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x00,0x1E}, {0x04,0x02} }, // PAD_SLEW 700 707 400 403 701
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x06} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+
+static struct regval_list sensor_svga_regs[] = {
+	//Resolution Setting : 800*600
+
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	//Resolution Setting : 640*480
+{ {0x09,0x8C}, {0xA1,0x15} },	// MCU_ADDRESS [SEQ_CAP_MODE]
+{ {0x09,0x90}, {0x00,0x02} },	// MCU_DATA_0
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x01} },	// MCU_DATA_0
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x00,0x1E}, {0x04,0x01} }, // PAD_SLEW 700 707 400 403 701
+{ {0x09,0x8C}, {0xA1,0x03} },  // MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x06} },  // MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+
+{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+{ {0x00,0x00}, {0x00,0x00} },
+
+{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+
+	//YCbYCr
+	{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+	{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x02} },  // MCU_DATA_0
+
+	{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+	{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+	{ {0x00,0x00}, {0x00,0x00} },
+	{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+
+	//YCrYCb
+	{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x03} },  // MCU_DATA_0
+	{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x03} },  // MCU_DATA_0
+
+	{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+	{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+	{ {0x00,0x00}, {0x00,0x00} },
+	{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+
+	//CrYCbY
+	{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x01} },  // MCU_DATA_0
+	{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x01} },  // MCU_DATA_0
+
+	{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+	{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+	{ {0x00,0x00}, {0x00,0x00} },
+	{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+
+	//CbYCrY
+	{ {0x09,0x8C}, {0x27,0x55} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+	{ {0x09,0x8C}, {0x27,0x57} },  // MCU_ADDRESS [YUV_SWAP]
+	{ {0x09,0x90}, {0x00,0x00} },  // MCU_DATA_0
+
+	{ {0x09,0x8C}, {0xA1,0x03} },	// MCU_ADDRESS [SEQ_CMD]
+	{ {0x09,0x90}, {0x00,0x05} },	// MCU_DATA_0
+	{ {0x00,0x00}, {0x00,0x00} },
+	{ {0xff,0xff}, {0x00,0x64} }, //delay
+};
+
+static struct regval_list sensor_fmt_raw[] = {
+
+};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+		data[i] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+	for(i = 0; i < size ; i++)
+	{
+		if(vals->reg_num[0]==0xff && vals->reg_num[1]==0xff) {
+				msleep(vals->value[0]);
+		}
+		else {
+			ret = sensor_write(sd, vals->reg_num, vals->value);
+			if (ret < 0)
+				{
+					csi_dev_err("sensor_write_err!\n");
+					return ret;
+				}
+		}
+
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x00;
+	regs.reg_num[1] = 0x00;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x24)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "Raw RGB Bayer",
+		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+		.regs 		= sensor_fmt_raw,
+		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+		.bpp		= 1
+	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* SXGA */
+	{
+		.width			= SXGA_WIDTH,
+		.height			= SXGA_HEIGHT,
+		.regs 			= sensor_sxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_sxga_regs),
+		.set_size		= NULL,
+	},
+	/* SVGA */
+	{
+		.width			= SVGA_WIDTH,
+		.height			= SVGA_HEIGHT,
+		.regs				= sensor_svga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_svga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width			= VGA_WIDTH,
+		.height			= VGA_HEIGHT,
+		.regs				= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+//	case V4L2_CID_VFLIP:
+//	case V4L2_CID_HFLIP:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_EXPOSURE:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+//	case V4L2_CID_EXPOSURE_AUTO:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_DO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+//	case V4L2_CID_AUTO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_COLORFX:
+//		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "mt9m113", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "mt9m113",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/ov2655.c b/drivers/media/video/sun4i_csi/device/ov2655.c
new file mode 100644
index 0000000..0f2cfb1
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/ov2655.c
@@ -0,0 +1,2350 @@
+/*
+ * drivers/media/video/sun4i_csi/device/ov2655.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for OV ov2655 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for OV ov2655 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][OV2655]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][OV2655]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][OV2655]"x,##arg)
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_LOW
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+#define V4L2_IDENT_SENSOR 0x2655
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 2
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define UXGA_WIDTH		1600
+#define UXGA_HEIGHT		1200
+#define HD720_WIDTH 	1280
+#define HD720_HEIGHT	720
+#define SVGA_WIDTH		800
+#define SVGA_HEIGHT 	600
+#define VGA_WIDTH			640
+#define VGA_HEIGHT		480
+#define QVGA_WIDTH		320
+#define QVGA_HEIGHT		240
+#define CIF_WIDTH			352
+#define CIF_HEIGHT		288
+#define QCIF_WIDTH		176
+#define	QCIF_HEIGHT		144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 30
+
+/*
+ * The ov2655 sits on i2c with ID 0x60
+ */
+#define I2C_ADDR 0x60
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+struct snesor_colorfx_struct; /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+
+/*
+ * The default register settings
+ *
+ */
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+
+static struct regval_list sensor_default_regs[] = {
+// YUV base on 1600X1200
+{{0x30, 0x8c}, {0x80}},
+{{0x30, 0x8d}, {0x0e}},
+{{0x36, 0x0b}, {0x00}},
+{{0x30, 0xb0}, {0xff}},
+{{0x30, 0xb1}, {0xff}},
+{{0x30, 0xb2}, {0x24}},
+
+{{0x30, 0x0e}, {0x34}},
+{{0x30, 0x0f}, {0xa6}},
+{{0x30, 0x10}, {0x81}},
+{{0x30, 0x82}, {0x01}},
+{{0x30, 0xf4}, {0x01}},
+{{0x30, 0x90}, {0x33}},//0x3b,
+{{0x30, 0x91}, {0xc0}},
+{{0x30, 0xac}, {0x42}},
+
+{{0x30, 0xd1}, {0x08}},
+{{0x30, 0xa8}, {0x56}},
+{{0x30, 0x15}, {0x41}},//0x02,
+{{0x30, 0x93}, {0x00}},
+{{0x30, 0x7e}, {0xe5}},
+{{0x30, 0x79}, {0x00}},
+{{0x30, 0xaa}, {0x42}},
+{{0x30, 0x17}, {0x40}},
+{{0x30, 0xf3}, {0x82}},
+{{0x30, 0x6a}, {0x0c}},
+{{0x30, 0x6d}, {0x00}},
+{{0x33, 0x6a}, {0x3c}},
+{{0x30, 0x76}, {0x6a}},
+{{0x30, 0xd9}, {0x95}},
+{{0x30, 0x16}, {0x82}},
+{{0x36, 0x01}, {0x30}},
+{{0x30, 0x4e}, {0x88}},
+{{0x30, 0xf1}, {0x82}},
+{{0x30, 0x16}, {0x82}},		//Keep night mode trigger gain
+{{0x33, 0x94}, {0x00}},		//For DK mode use
+{{0x33, 0x95}, {0x00}},
+
+// AEC Range
+{{0x30, 0x13}, {0xe2}},//0xf7,
+{{0x30, 0x15}, {0x41}},
+{{0x30, 0x18}, {0xa0}},
+{{0x30, 0x19}, {0x70}},
+{{0x30, 0x1a}, {0xa4}},
+
+//AWB
+{{0x33, 0x06}, {0x0a}},//0x08,//Sharpness enable
+{{0x33, 0x20}, {0xfa}},
+{{0x33, 0x21}, {0x11}},
+{{0x33, 0x22}, {0x92}},
+{{0x33, 0x23}, {0x01}},
+{{0x33, 0x24}, {0x97}},
+{{0x33, 0x25}, {0x02}},
+{{0x33, 0x26}, {0xff}},
+{{0x33, 0x27}, {0x0c}},
+{{0x33, 0x28}, {0x10}},
+{{0x33, 0x29}, {0x10}},
+{{0x33, 0x2a}, {0x58}},
+{{0x33, 0x2b}, {0x56}},
+{{0x33, 0x2c}, {0xbe}},
+{{0x33, 0x2d}, {0xe1}},
+{{0x33, 0x2e}, {0x3a}},
+{{0x33, 0x2f}, {0x36}},
+{{0x33, 0x30}, {0x4d}},
+{{0x33, 0x31}, {0x44}},
+{{0x33, 0x32}, {0xf8}},
+{{0x33, 0x33}, {0x0a}},
+{{0x33, 0x34}, {0xf0}},
+{{0x33, 0x35}, {0xf0}},
+{{0x33, 0x36}, {0xf0}},
+{{0x33, 0x37}, {0x63}},//6c,
+{{0x33, 0x38}, {0x58}},//0x40,AWB_G_Gain
+{{0x33, 0x39}, {0x50}},//30,
+{{0x33, 0x3a}, {0x00}},
+{{0x33, 0x3b}, {0x00}},
+//Color Matrix
+{{0x33, 0x80}, {0x28}},
+{{0x33, 0x81}, {0x48}},
+{{0x33, 0x82}, {0x10}},
+{{0x33, 0x83}, {0x22}},
+{{0x33, 0x84}, {0xc0}},
+{{0x33, 0x85}, {0xe2}},
+{{0x33, 0x86}, {0xe2}},
+{{0x33, 0x87}, {0xf2}},
+{{0x33, 0x88}, {0x10}},
+{{0x33, 0x89}, {0x98}},
+{{0x33, 0x8a}, {0x00}},
+
+//Gamma
+{{0x33, 0x4f}, {0x20}},
+{{0x33, 0x40}, {0x06}},
+{{0x33, 0x41}, {0x14}},
+{{0x33, 0x42}, {0x2b}},
+{{0x33, 0x43}, {0x42}},
+{{0x33, 0x44}, {0x55}},
+{{0x33, 0x45}, {0x65}},
+{{0x33, 0x46}, {0x70}},
+{{0x33, 0x47}, {0x7c}},
+{{0x33, 0x48}, {0x86}},
+{{0x33, 0x49}, {0x96}},
+{{0x33, 0x4a}, {0xa3}},
+{{0x33, 0x4b}, {0xaf}},
+{{0x33, 0x4c}, {0xc4}},
+{{0x33, 0x4d}, {0xd7}},
+{{0x33, 0x4e}, {0xe8}},
+
+//UVadjust
+{{0x33, 0x01}, {0xff}},
+{{0x33, 0x8b}, {0x10}},
+{{0x33, 0x8c}, {0x0a}},
+{{0x33, 0x8d}, {0x40}},
+
+//Sharpness and De-noise
+{{0x33, 0x70}, {0xd0}},
+{{0x33, 0x71}, {0x00}},
+{{0x33, 0x72}, {0x00}},
+{{0x33, 0x73}, {0x60}},
+{{0x33, 0x74}, {0x10}},
+{{0x33, 0x75}, {0x10}},
+{{0x33, 0x76}, {0x00}},
+{{0x33, 0x77}, {0x00}},
+{{0x33, 0x78}, {0x04}},
+{{0x33, 0x79}, {0x70}},
+
+//BLC
+{{0x30, 0x69}, {0x84}},
+{{0x30, 0x7c}, {0x10}},//0x13,
+{{0x30, 0x87}, {0x02}},
+
+{{0x33, 0x19}, {0x0c}}, // for awb timing
+{{0x33, 0x1d}, {0x4c}}, // for awb timing
+
+};
+
+static struct regval_list sensor_lsc_normal_regs[]= {
+//Lens correction for 0x307c=0x10, 0x3090=0x33
+{{0x33, 0x00}, {0xfc}}, // turn on lens correction
+//R
+{{0x33, 0x50}, {0x33}}, // rx
+{{0x33, 0x51}, {0x28}}, // ry
+{{0x33, 0x52}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x53}, {0x14}}, // a1
+{{0x33, 0x54}, {0x00}}, // b1
+{{0x33, 0x55}, {0x85}}, // b2
+//G
+{{0x33, 0x56}, {0x35}}, // rx
+{{0x33, 0x57}, {0x28}}, // ry
+{{0x33, 0x58}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x59}, {0x13}}, // a1
+{{0x33, 0x5a}, {0x00}}, // b1
+{{0x33, 0x5b}, {0x85}}, // b2, a0 30
+//B
+{{0x33, 0x5c}, {0x34}}, // rx	20080219
+{{0x33, 0x5d}, {0x28}}, // ry
+{{0x33, 0x5e}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x5f}, {0x13}}, // a1
+{{0x33, 0x60}, {0x00}}, // b1
+{{0x33, 0x61}, {0x85}}, // b2, a0 30
+
+{{0x33, 0x63}, {0x70}}, // ry
+{{0x33, 0x64}, {0x7f}}, // ry[3:0],rx[3:0]
+{{0x33, 0x65}, {0x00}}, // a1
+{{0x33, 0x66}, {0x00}}, // b1
+{{0x33, 0x62}, {0x90}}, // b2, a0 30
+};
+
+static struct regval_list sensor_lsc_mirror_regs[]= {
+//Lens correction  for 0x307c=0x13, 0x3090=0x3b
+{{0x33, 0x00}, {0xfc}}, // turn on lens correction
+//R
+{{0x33, 0x50}, {0x37}}, // rx
+{{0x33, 0x51}, {0x27}}, // ry
+{{0x33, 0x52}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x53}, {0x14}}, // a1
+{{0x33, 0x54}, {0x00}}, // b1
+{{0x33, 0x55}, {0x85}}, // b2
+//G
+{{0x33, 0x56}, {0x35}}, // rx
+{{0x33, 0x57}, {0x28}}, // ry
+{{0x33, 0x58}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x59}, {0x13}}, // a1
+{{0x33, 0x5a}, {0x00}}, // b1
+{{0x33, 0x5b}, {0x85}}, // b2, a0 30
+//B
+{{0x33, 0x5c}, {0x37}}, // rx	20080219
+{{0x33, 0x5d}, {0x28}}, // ry
+{{0x33, 0x5e}, {0x00}}, // ry[3:0],rx[3:0]
+{{0x33, 0x5f}, {0x13}}, // a1
+{{0x33, 0x60}, {0x00}}, // b1
+{{0x33, 0x61}, {0x85}}, // b2, a0 30
+
+{{0x33, 0x63}, {0x70}}, // ry
+{{0x33, 0x64}, {0x7f}}, // ry[3:0],rx[3:0]
+{{0x33, 0x65}, {0x00}}, // a1
+{{0x33, 0x66}, {0x00}}, // b1
+{{0x33, 0x62}, {0x90}}, // b2, a0 30
+};
+
+static struct regval_list sensor_uxga_regs[] = {
+{{0x30, 0x0e}, {0x34}},
+{{0x30, 0x12}, {0x00}},
+{{0x30, 0x2A}, {0x04}},
+{{0x30, 0x2B}, {0xd4}},
+{{0x30, 0x6f}, {0x54}},
+{{0x30, 0x20}, {0x01}},
+{{0x30, 0x21}, {0x18}},
+{{0x30, 0x22}, {0x00}},
+{{0x30, 0x23}, {0x0a}},
+{{0x30, 0x24}, {0x06}},
+{{0x30, 0x25}, {0x58}},
+{{0x30, 0x26}, {0x04}},
+{{0x30, 0x27}, {0xbc}},
+{{0x30, 0x88}, {0x06}},
+{{0x30, 0x89}, {0x44}},//0x40,
+{{0x30, 0x8a}, {0x04}},
+{{0x30, 0x8b}, {0xb0}},
+{{0x33, 0x1a}, {0x64}},
+{{0x33, 0x1b}, {0x4b}},
+{{0x33, 0x1c}, {0x00}},
+{{0x31, 0x00}, {0x00}},
+{{0x33, 0x62}, {0x80}},
+{{0x33, 0x00}, {0xfc}},
+{{0x33, 0x02}, {0x01}},
+{{0x33, 0x16}, {0x64}},
+{{0x33, 0x17}, {0x4b}},
+{{0x33, 0x18}, {0x00}},
+{{0x34, 0x00}, {0x00}},
+{{0x36, 0x01}, {0x30}},
+{{0x36, 0x06}, {0x20}},
+{{0x30, 0xf3}, {0x83}},
+{{0x30, 0x4e}, {0x88}},
+{{0x30, 0x88}, {0x06}},
+{{0x30, 0x89}, {0x44}},//0x40,
+{{0x30, 0x8a}, {0x04}},
+{{0x30, 0x8b}, {0xb0}},
+{{0x30, 0xb2}, {0x27}},//bit[1:0] io pad drive
+};
+
+
+static struct regval_list sensor_svga_regs[] = {
+{{0x30, 0x0e}, {0x34}}, //<5:0>plldiv
+{{0x30, 0x12}, {0x10}}, //<4>vario
+{{0x30, 0x2A}, {0x02}}, //VTS high-byte
+{{0x30, 0x2B}, {0x6a}}, //VTS low-byte
+{{0x30, 0x6f}, {0x14}}, //<6:4>window,<3:0>targ_s
+{{0x30, 0x20}, {0x01}},
+{{0x30, 0x21}, {0x18}},
+{{0x30, 0x22}, {0x00}},
+{{0x30, 0x23}, {0x06}}, //array output vertical start L
+{{0x30, 0x24}, {0x06}}, //array output width H
+{{0x30, 0x25}, {0x58}}, //array output width L
+{{0x30, 0x26}, {0x02}}, //array output height H
+{{0x30, 0x27}, {0x61}}, //array output height L
+{{0x30, 0x88}, {0x06}}, //image output width H
+{{0x30, 0x89}, {0x40}}, //image output width L
+{{0x30, 0x8a}, {0x02}}, //image output height H
+{{0x30, 0x8b}, {0x61}}, //image output height L
+{{0x33, 0x1a}, {0x64}},
+{{0x33, 0x1b}, {0x4b}},
+{{0x33, 0x1c}, {0x00}},
+{{0x31, 0x00}, {0x00}}, //<3>bypass_win,<2>bypass_fmt,<1>rgb_sel,<0>snr_sel
+{{0x33, 0x62}, {0x90}},
+{{0x33, 0x00}, {0xfc}},
+{{0x33, 0x02}, {0x10}},
+{{0x33, 0x16}, {0x64}},
+{{0x33, 0x17}, {0x25}},
+{{0x33, 0x18}, {0x80}},
+{{0x34, 0x00}, {0x00}},
+{{0x36, 0x01}, {0x30}},
+{{0x36, 0x06}, {0x20}},
+{{0x30, 0xf3}, {0x82}},
+{{0x30, 0x4e}, {0x88}},
+{{0x30, 0x88}, {0x03}},
+{{0x30, 0x89}, {0x28}},
+{{0x30, 0x8a}, {0x02}},
+{{0x30, 0x8b}, {0x58}},
+{{0x30, 0xb2}, {0x27}},//bit[1:0] io pad drive
+};
+
+static struct regval_list sensor_vga_regs[] = {
+{{0x30, 0x0e}, {0x34}}, //<5:0>plldiv
+{{0x30, 0x12}, {0x10}}, //<4>vario
+{{0x30, 0x2A}, {0x02}}, //VTS high-byte
+{{0x30, 0x2B}, {0x6a}}, //VTS low-byte
+{{0x30, 0x6f}, {0x14}}, //<6:4>window,<3:0>targ_s
+{{0x30, 0x20}, {0x01}},
+{{0x30, 0x21}, {0x18}},
+{{0x30, 0x22}, {0x00}},
+{{0x30, 0x23}, {0x06}}, //array output vertical start L
+{{0x30, 0x24}, {0x06}}, //array output width H
+{{0x30, 0x25}, {0x58}}, //array output width L
+{{0x30, 0x26}, {0x02}}, //array output height H
+{{0x30, 0x27}, {0x61}}, //array output height L
+{{0x30, 0x88}, {0x06}}, //image output width H
+{{0x30, 0x89}, {0x40}}, //image output width L
+{{0x30, 0x8a}, {0x02}}, //image output height H
+{{0x30, 0x8b}, {0x58}}, //image output height L
+{{0x33, 0x1a}, {0x64}},
+{{0x33, 0x1b}, {0x4b}},
+{{0x33, 0x1c}, {0x00}},
+{{0x31, 0x00}, {0x00}}, //<3>bypass_win,<2>bypass_fmt,<1>rgb_sel,<0>snr_sel
+{{0x33, 0x62}, {0x90}},
+{{0x33, 0x00}, {0xfc}},
+{{0x33, 0x02}, {0x10}},
+{{0x33, 0x16}, {0x64}},
+{{0x33, 0x17}, {0x25}},
+{{0x33, 0x18}, {0x80}},
+{{0x34, 0x00}, {0x00}},
+{{0x36, 0x01}, {0x30}},
+{{0x36, 0x06}, {0x20}},
+{{0x30, 0xf3}, {0x82}},
+{{0x30, 0x4e}, {0x88}},
+{{0x30, 0x88}, {0x02}},
+{{0x30, 0x89}, {0x82}},//0x80,
+{{0x30, 0x8a}, {0x01}},
+{{0x30, 0x8b}, {0xf0}},
+{{0x30, 0xb2}, {0x27}},//bit[1:0] io pad drive
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+
+	{{0x34,	0x00} , {0x00}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+
+	{{0x34,	0x00} , {0x01}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+
+	{{0x34,	0x00} , {0x02}}	//CbYCrY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+
+	{{0x34,	0x00} , {0x03}}	//CrYCbY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+		data[i] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_dev_err("sensor_write_err!\n");
+				return ret;
+			}
+
+		udelay(10);	//some module need delay between i2c writing
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x0A;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x26)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* UXGA */
+	{
+		.width			= UXGA_WIDTH,
+		.height			= UXGA_HEIGHT,
+		.regs 			= sensor_uxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_uxga_regs),
+		.set_size		= NULL,
+	},
+	/* SVGA */
+	{
+		.width			= SVGA_WIDTH,
+		.height			= SVGA_HEIGHT,
+		.regs				= sensor_svga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_svga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width			= VGA_WIDTH,
+		.height			= VGA_HEIGHT,
+		.regs				= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+
+	if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE/2;
+	}
+	else {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+	}
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+//	struct v4l2_fract *tpf = &cp->timeperframe;
+//	struct sensor_info *info = to_state(sd);
+//	int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else {
+//		if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE/2)/tpf->denominator;
+//		}
+//		else {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//		}
+//	}
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > 8)
+//		div = 8;
+//
+//	switch()
+//
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//
+//	sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_EXPOSURE:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_DO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+//	case V4L2_CID_AUTO_WHITE_BALANCE:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+//	case V4L2_CID_COLORFX:
+//		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x7C;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+	regs.value[0] = regs.value[0]>>1;		//0x307C bit1 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x7C;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfd;
+			break;
+		case 1:
+			regs.value[0] |= 0x02;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+	msleep(200);
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x90;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xf7;
+			break;
+		case 1:
+			regs.value[0] |= 0x08;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(200);
+
+	switch (value) {
+		case 0:
+		  ret = sensor_write_array(sd, sensor_lsc_normal_regs, ARRAY_SIZE(sensor_lsc_normal_regs));
+			if (ret < 0) {
+				csi_dev_err("sensor_write_array err at sensor_s_hflip!\n");
+				return ret;
+			}
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_lsc_mirror_regs, ARRAY_SIZE(sensor_lsc_mirror_regs));
+			if (ret < 0) {
+				csi_dev_err("sensor_write_array err at sensor_s_hflip!\n");
+				return ret;
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+	msleep(100);
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x7C;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<0);
+	regs.value[0] = regs.value[0]>>0;		//0x307C bit0 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x7c;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xfe;
+			break;
+		case 1:
+			regs.value[0] |= 0x01;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(200);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x13;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x01;
+	if (regs.value[0] == 0x01) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x13;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x01;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0xfe;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+	msleep(100);
+	info->autoexp = value;
+
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x1a;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_dev_err("sensor_read err at sensor_g_autowb!\n");
+//		return ret;
+//	}
+//
+//	regs.value[0] &= (1<<7);
+//	regs.value[0] = regs.value[0]>>7;		//0x031a bit7 is awb enable
+//
+//	*value = regs.value[0];
+//	info->autowb = *value;
+
+	return -EINVAL;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x1a;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_dev_err("sensor_read err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//
+//	switch(value) {
+//	case 0:
+//		regs.value[0] &= 0x7f;
+//		break;
+//	case 1:
+//		regs.value[0] |= 0x80;
+//		break;
+//	default:
+//		break;
+//	}
+//	ret = sensor_write(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+//		return ret;
+//	}
+//	msleep(10);
+//	info->autowb = value;
+	return -EINVAL;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "ov2655", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "ov2655",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/device/ov5640.c b/drivers/media/video/sun4i_csi/device/ov5640.c
new file mode 100644
index 0000000..d301973
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/ov5640.c
@@ -0,0 +1,3760 @@
+/*
+ * drivers/media/video/sun4i_csi/device/ov5640.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for OV ov5640 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for OV ov5640 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][OV5640]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][OV5640]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][OV5640]"x,##arg)
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_LOW
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+#define V4L2_IDENT_SENSOR 0x5640
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 2
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define QSXGA_WIDTH		2592
+#define QSXGA_HEIGHT	1936
+#define QXGA_WIDTH 		2048
+#define QXGA_HEIGHT		1536
+#define P1080P_WIDTH	1920
+#define P1080P_HEIGHT	1080
+#define UXGA_WIDTH		1600
+#define UXGA_HEIGHT		1200
+#define P720_WIDTH 		1280
+#define P720_HEIGHT		720
+//SXGA: 1280*960
+#define SXGA_WIDTH		1280
+#define SXGA_HEIGHT		960
+#define HD720_WIDTH 	1280
+#define HD720_HEIGHT	720
+//XGA: 1024*768
+#define XGA_WIDTH		1024
+#define XGA_HEIGHT 		768
+#define SVGA_WIDTH		800
+#define SVGA_HEIGHT 	600
+#define VGA_WIDTH			640
+#define VGA_HEIGHT		480
+#define QVGA_WIDTH		320
+#define QVGA_HEIGHT		240
+#define CIF_WIDTH			352
+#define CIF_HEIGHT		288
+#define QCIF_WIDTH		176
+#define	QCIF_HEIGHT		144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 30
+
+/*
+ * The ov5640 sits on i2c with ID 0x78
+ */
+#define I2C_ADDR 0x78
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+struct snesor_colorfx_struct; /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+
+/*
+ * The default register settings
+ *
+ */
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+
+static struct regval_list sensor_default_regs[] = {
+//15fps YUV mode
+{{0x31,0x03},{0x11}},//
+//{{0x30,0x08},{0x82}},//
+{{0x30,0x08},{0x42}},//
+{{0x31,0x03},{0x03}},//
+{{0x30,0x17},{0xff}},//
+{{0x30,0x18},{0xff}},//
+{{0x30,0x34},{0x1a}},//
+{{0x30,0x35},{0x21}},//
+{{0x30,0x36},{0x46}},//0x46->30fps
+{{0x30,0x37},{0x13}},//////div
+	{{0x3c,0x00},{0x04}},
+	{{0x3c,0x01},{0xb4}},
+{{0x31,0x08},{0x01}},//
+{{0x36,0x30},{0x36}},//
+{{0x36,0x31},{0x0e}},//
+{{0x36,0x32},{0xe2}},//
+{{0x36,0x33},{0x12}},//
+{{0x36,0x21},{0xe0}},//
+{{0x37,0x04},{0xa0}},//
+{{0x37,0x03},{0x5a}},//
+{{0x37,0x15},{0x78}},//
+{{0x37,0x17},{0x01}},//
+{{0x37,0x0b},{0x60}},//
+{{0x37,0x05},{0x1a}},//
+{{0x39,0x05},{0x02}},//
+{{0x39,0x06},{0x10}},//
+{{0x39,0x01},{0x0a}},//
+{{0x37,0x31},{0x12}},//
+{{0x36,0x00},{0x08}},//
+{{0x36,0x01},{0x33}},//
+{{0x30,0x2d},{0x60}},//
+{{0x36,0x20},{0x52}},//
+{{0x37,0x1b},{0x20}},//
+{{0x47,0x1c},{0x50}},//
+{{0x3a,0x13},{0x43}},//
+{{0x3a,0x18},{0x00}},//
+{{0x3a,0x19},{0xf8}},//
+{{0x36,0x35},{0x13}},//
+{{0x36,0x36},{0x03}},//
+{{0x36,0x34},{0x40}},//
+{{0x36,0x22},{0x01}},//
+{{0x3c,0x01},{0x34}},//
+{{0x3c,0x04},{0x28}},//
+{{0x3c,0x05},{0x98}},//
+{{0x3c,0x06},{0x00}},//
+{{0x3c,0x07},{0x08}},//
+{{0x3c,0x08},{0x00}},//
+{{0x3c,0x09},{0x1c}},//
+{{0x3c,0x0a},{0x9c}},//
+{{0x3c,0x0b},{0x40}},//
+//{{0x38,0x20},{0x41}},//
+//{{0x38,0x21},{0x07}},//
+{{0x38,0x14},{0x31}},//
+{{0x38,0x15},{0x31}},//
+{{0x38,0x00},{0x00}},//
+{{0x38,0x01},{0x00}},//
+{{0x38,0x02},{0x00}},//
+{{0x38,0x03},{0x04}},//
+{{0x38,0x04},{0x0a}},//
+{{0x38,0x05},{0x3f}},//
+{{0x38,0x06},{0x07}},//
+{{0x38,0x07},{0x9b}},//
+{{0x38,0x08},{0x02}},//
+{{0x38,0x09},{0x80}},//
+{{0x38,0x0a},{0x01}},//
+{{0x38,0x0b},{0xe0}},//
+{{0x38,0x0c},{0x07}},//
+{{0x38,0x0d},{0x68}},//
+{{0x38,0x0e},{0x03}},//
+{{0x38,0x0f},{0xd8}},//
+{{0x38,0x10},{0x00}},//
+{{0x38,0x11},{0x10}},//
+{{0x38,0x12},{0x00}},//
+{{0x38,0x13},{0x06}},//
+{{0x36,0x18},{0x00}},//
+{{0x36,0x12},{0x29}},//
+{{0x37,0x08},{0x64}},//
+{{0x37,0x09},{0x52}},//
+{{0x37,0x0c},{0x03}},//
+{{0x3a,0x02},{0x03}},//
+{{0x3a,0x03},{0xd8}},//
+{{0x3a,0x08},{0x01}},//
+{{0x3a,0x09},{0x27}},//
+{{0x3a,0x0a},{0x00}},//
+{{0x3a,0x0b},{0xf6}},//
+{{0x3a,0x0e},{0x03}},//
+{{0x3a,0x0d},{0x04}},//
+{{0x3a,0x14},{0x03}},//
+{{0x3a,0x15},{0xd8}},//
+{{0x40,0x01},{0x02}},//
+{{0x40,0x04},{0x02}},//
+{{0x30,0x00},{0x00}},//
+{{0x30,0x02},{0x1c}},//
+{{0x30,0x04},{0xff}},//
+{{0x30,0x06},{0xc3}},//
+{{0x30,0x0e},{0x58}},//
+{{0x30,0x2e},{0x00}},//
+
+{{0x30,0x2c},{0xc2}},//bit[7:6]: output drive capability
+						//00: 1x   01: 2x  10: 3x  11: 4x
+
+{{0x43,0x00},{0x30}},//
+{{0x50,0x1f},{0x00}},//
+{{0x47,0x13},{0x03}},//
+{{0x44,0x07},{0x04}},//
+{{0x44,0x0e},{0x00}},//
+{{0x46,0x0b},{0x35}},//
+{{0x46,0x0c},{0x20}},//
+	{{0x48,0x37},{0x22}},
+{{0x38,0x24},{0x02}},//
+{{0x50,0x00},{0xa7}},//
+{{0x50,0x01},{0xa3}},//
+	/*
+	{{0x51,0x80},{0xff}},
+	{{0x51,0x81},{0xf2}},
+	{{0x51,0x82},{0x00}},
+	{{0x51,0x83},{0x14}},
+	{{0x51,0x84},{0x25}},
+	{{0x51,0x85},{0x24}},
+	{{0x51,0x86},{0x09}},
+	{{0x51,0x87},{0x09}},
+	{{0x51,0x88},{0x09}},
+	{{0x51,0x89},{0x75}},
+	{{0x51,0x8a},{0x54}},
+	{{0x51,0x8b},{0xe0}},
+	{{0x51,0x8c},{0xb2}},
+	{{0x51,0x8d},{0x42}},
+	{{0x51,0x8e},{0x3d}},
+	{{0x51,0x8f},{0x56}},
+	{{0x51,0x90},{0x46}},
+	{{0x51,0x91},{0xf8}},
+	{{0x51,0x92},{0x04}},
+	{{0x51,0x93},{0x70}},
+	{{0x51,0x94},{0xf0}},
+	{{0x51,0x95},{0xf0}},
+	{{0x51,0x96},{0x03}},
+	{{0x51,0x97},{0x01}},
+	{{0x51,0x98},{0x04}},
+	{{0x51,0x99},{0x12}},
+	{{0x51,0x9a},{0x04}},
+	{{0x51,0x9b},{0x00}},
+	{{0x51,0x9c},{0x06}},
+	{{0x51,0x9d},{0x82}},
+	{{0x51,0x9e},{0x38}},
+	*/
+    {{0x51,0x80},{0xff}},
+	{{0x51,0x81},{0xf2}},
+	{{0x51,0x82},{0x00}},
+	{{0x51,0x83},{0x14}},
+	{{0x51,0x84},{0x25}},
+	{{0x51,0x85},{0x24}},
+	{{0x51,0x86},{0x0f}},
+	{{0x51,0x87},{0x0f}},
+	{{0x51,0x88},{0x0f}},
+	{{0x51,0x89},{0x80}},
+	{{0x51,0x8a},{0x5d}},
+	{{0x51,0x8b},{0xe3}},
+	{{0x51,0x8c},{0xa7}},
+	{{0x51,0x8d},{0x40}},
+	{{0x51,0x8e},{0x33}},
+	{{0x51,0x8f},{0x5e}},
+	{{0x51,0x90},{0x4e}},
+	{{0x51,0x91},{0xf8}},
+	{{0x51,0x92},{0x04}},
+	{{0x51,0x93},{0x70}},
+	{{0x51,0x94},{0xf0}},
+	{{0x51,0x95},{0xf0}},
+	{{0x51,0x96},{0x03}},
+	{{0x51,0x97},{0x01}},
+	{{0x51,0x98},{0x06}},
+	{{0x51,0x99},{0xd0}},
+	{{0x51,0x9a},{0x04}},
+	{{0x51,0x9b},{0x00}},
+	{{0x51,0x9c},{0x04}},
+	{{0x51,0x9d},{0x87}},
+	{{0x51,0x9e},{0x38}},
+
+
+	{{0x53,0x81},{0x1e}},
+	{{0x53,0x82},{0x5b}},
+	{{0x53,0x83},{0x08}},
+	{{0x53,0x84},{0x0a}},
+	{{0x53,0x85},{0x7e}},
+	{{0x53,0x86},{0x88}},
+	{{0x53,0x87},{0x7c}},
+	{{0x53,0x88},{0x6c}},
+	{{0x53,0x89},{0x10}},
+	{{0x53,0x8a},{0x01}},
+	{{0x53,0x8b},{0x98}},
+	{{0x53,0x00},{0x08}},
+	{{0x53,0x01},{0x30}},
+	{{0x53,0x02},{0x10}},
+	{{0x53,0x03},{0x00}},
+	{{0x53,0x04},{0x08}},
+	{{0x53,0x05},{0x30}},
+	{{0x53,0x06},{0x08}},
+	{{0x53,0x07},{0x16}},
+	{{0x53,0x09},{0x08}},
+	{{0x53,0x0a},{0x30}},
+	{{0x53,0x0b},{0x04}},
+	{{0x53,0x0c},{0x06}},
+	{{0x54,0x80},{0x01}},
+	{{0x54,0x81},{0x08}},
+	{{0x54,0x82},{0x14}},
+	{{0x54,0x83},{0x28}},
+	{{0x54,0x84},{0x51}},
+	{{0x54,0x85},{0x65}},
+	{{0x54,0x86},{0x71}},
+	{{0x54,0x87},{0x7d}},
+	{{0x54,0x88},{0x87}},
+	{{0x54,0x89},{0x91}},
+	{{0x54,0x8a},{0x9a}},
+	{{0x54,0x8b},{0xaa}},
+	{{0x54,0x8c},{0xb8}},
+	{{0x54,0x8d},{0xcd}},
+	{{0x54,0x8e},{0xdd}},
+	{{0x54,0x8f},{0xea}},
+	{{0x54,0x90},{0x1d}},
+	{{0x55,0x80},{0x04}},
+
+    {{0x55,0x87},{0x05}},
+	{{0x55,0x88},{0x09}},
+
+
+	{{0x55,0x83},{0x40}},
+	{{0x55,0x84},{0x10}},
+	{{0x55,0x89},{0x10}},
+	{{0x55,0x8a},{0x00}},
+	{{0x55,0x8b},{0xf8}},
+	{{0x58,0x00},{0x3D}},
+	{{0x58,0x01},{0x1F}},
+	{{0x58,0x02},{0x17}},
+	{{0x58,0x03},{0x16}},
+	{{0x58,0x04},{0x1E}},
+	{{0x58,0x05},{0x3A}},
+	{{0x58,0x06},{0x14}},
+	{{0x58,0x07},{0x0A}},
+	{{0x58,0x08},{0x07}},
+	{{0x58,0x09},{0x06}},
+	{{0x58,0x0A},{0x0A}},
+	{{0x58,0x0B},{0x11}},
+	{{0x58,0x0C},{0x0B}},
+	{{0x58,0x0D},{0x04}},
+	{{0x58,0x0E},{0x00}},
+	{{0x58,0x0F},{0x00}},
+	{{0x58,0x10},{0x04}},
+	{{0x58,0x11},{0x0A}},
+	{{0x58,0x12},{0x0B}},
+	{{0x58,0x13},{0x04}},
+	{{0x58,0x14},{0x00}},
+	{{0x58,0x15},{0x00}},
+	{{0x58,0x16},{0x04}},
+	{{0x58,0x17},{0x0A}},
+	{{0x58,0x18},{0x14}},
+	{{0x58,0x19},{0x0A}},
+	{{0x58,0x1A},{0x06}},
+	{{0x58,0x1B},{0x06}},
+	{{0x58,0x1C},{0x09}},
+	{{0x58,0x1D},{0x12}},
+	{{0x58,0x1E},{0x3D}},
+	{{0x58,0x1F},{0x21}},
+	{{0x58,0x20},{0x18}},
+	{{0x58,0x21},{0x17}},
+	{{0x58,0x22},{0x1F}},
+	{{0x58,0x23},{0x3B}},
+	{{0x58,0x24},{0x37}},
+	{{0x58,0x25},{0x36}},
+	{{0x58,0x26},{0x28}},
+	{{0x58,0x27},{0x25}},
+	{{0x58,0x28},{0x37}},
+	{{0x58,0x29},{0x35}},
+	{{0x58,0x2A},{0x25}},
+	{{0x58,0x2B},{0x34}},
+	{{0x58,0x2C},{0x24}},
+	{{0x58,0x2D},{0x26}},
+	{{0x58,0x2E},{0x26}},
+	{{0x58,0x2F},{0x32}},
+	{{0x58,0x30},{0x50}},
+	{{0x58,0x31},{0x42}},
+	{{0x58,0x32},{0x16}},
+	{{0x58,0x33},{0x36}},
+	{{0x58,0x34},{0x35}},
+	{{0x58,0x35},{0x34}},
+	{{0x58,0x36},{0x34}},
+	{{0x58,0x37},{0x26}},
+	{{0x58,0x38},{0x26}},
+	{{0x58,0x39},{0x36}},
+	{{0x58,0x3A},{0x28}},
+	{{0x58,0x3B},{0x36}},
+	{{0x58,0x3C},{0x37}},
+	{{0x58,0x3D},{0xCE}},
+	{{0x50,0x25},{0x00}},
+	{{0x3a,0x0f},{0x30}},
+	{{0x3a,0x10},{0x28}},
+	{{0x3a,0x1b},{0x30}},
+	{{0x3a,0x1e},{0x26}},
+	{{0x3a,0x11},{0x60}},
+	{{0x3a,0x1f},{0x14}},
+	{{0x30,0x08},{0x02}},
+
+
+};
+
+
+static struct regval_list sensor_qsxga_regs[] = { //qsxga: 2590*1944
+	//capture 5Mega 3.75fps
+	{{0x35,0x03},{0x07}},
+	{{0x3a,0x00},{0x78}},
+	{{0x35,0x0c},{0x00}},
+	{{0x35,0x0d},{0x00}},
+	{{0x3c,0x07},{0x07}},
+	//{{0x38,0x20},{0x40}},
+	//{{0x38,0x21},{0x06}},
+	{{0x38,0x14},{0x11}},
+	{{0x38,0x15},{0x11}},
+	{{0x38,0x03},{0x00}},
+	{{0x38,0x07},{0x9f}},
+	{{0x38,0x08},{0x0a}},
+	{{0x38,0x09},{0x20}},
+	{{0x38,0x0a},{0x07}},
+	{{0x38,0x0b},{0x98}},
+	{{0x38,0x0c},{0x0b}},
+	{{0x38,0x0d},{0x1c}},
+	{{0x38,0x0e},{0x07}},
+	{{0x38,0x0f},{0xb0}},
+    {{0x53,0x02},{0x30}},//sharpness
+
+    {{0x40,0x02},{0xc5}},
+	{{0x40,0x05},{0x1a}},
+
+	{{0x38,0x13},{0x04}},
+	{{0x36,0x18},{0x04}},
+	{{0x36,0x12},{0x2b}},
+	{{0x37,0x09},{0x12}},
+	{{0x37,0x0c},{0x00}},
+	{{0x3a,0x02},{0x07}},
+	{{0x3a,0x03},{0xb0}},
+	{{0x3a,0x0e},{0x06}},
+	{{0x3a,0x0d},{0x08}},
+	{{0x3a,0x14},{0x07}},
+	{{0x3a,0x15},{0xb0}},
+	{{0x40,0x04},{0x06}},
+	{{0x30,0x35},{0x21}},
+	{{0x30,0x36},{0x46}},
+	{{0x48,0x37},{0x2c}},
+	{{0x50,0x01},{0xa3}},
+
+	//2592*1936
+	{{0x38,0x08},{0x0a}},
+	{{0x38,0x09},{0x20}},
+	{{0x38,0x0a},{0x07}},
+	{{0x38,0x0b},{0x90}},
+};
+
+static struct regval_list sensor_qxga_regs[] = { //qxga: 2048*1536
+	//capture 5Mega 3.75fps
+	{{0x35,0x03},{0x07}},
+	{{0x3a,0x00},{0x78}},
+	{{0x35,0x0c},{0x00}},
+	{{0x35,0x0d},{0x00}},
+	{{0x3c,0x07},{0x07}},
+	//{{0x38,0x20},{0x40}},
+	//{{0x38,0x21},{0x06}},
+	{{0x38,0x14},{0x11}},
+	{{0x38,0x15},{0x11}},
+	{{0x38,0x03},{0x00}},
+	{{0x38,0x07},{0x9f}},
+	{{0x38,0x08},{0x0a}},
+	{{0x38,0x09},{0x20}},
+	{{0x38,0x0a},{0x07}},
+	{{0x38,0x0b},{0x98}},
+	{{0x38,0x0c},{0x0b}},
+	{{0x38,0x0d},{0x1c}},
+	{{0x38,0x0e},{0x07}},
+	{{0x38,0x0f},{0xb0}},
+    {{0x53,0x02},{0x30}},//sharpness
+
+    {{0x40,0x02},{0xc5}},
+	{{0x40,0x05},{0x1a}},
+
+	{{0x38,0x13},{0x04}},
+	{{0x36,0x18},{0x04}},
+	{{0x36,0x12},{0x2b}},
+	{{0x37,0x09},{0x12}},
+	{{0x37,0x0c},{0x00}},
+	{{0x3a,0x02},{0x07}},
+	{{0x3a,0x03},{0xb0}},
+	{{0x3a,0x0e},{0x06}},
+	{{0x3a,0x0d},{0x08}},
+	{{0x3a,0x14},{0x07}},
+	{{0x3a,0x15},{0xb0}},
+	{{0x40,0x04},{0x06}},
+	{{0x30,0x35},{0x21}},
+	{{0x30,0x36},{0x46}},
+	{{0x48,0x37},{0x2c}},
+	{{0x50,0x01},{0xa3}},
+
+	//2048*1536
+	{{0x38,0x08},{0x08}},
+	{{0x38,0x09},{0x00}},
+	{{0x38,0x0a},{0x06}},
+	{{0x38,0x0b},{0x00}},
+};
+
+
+static struct regval_list sensor_1080p_regs[] = { //1080: 1920*1080 //pclk:90m 15fps
+													//720p:15fps pck:56m
+/*
+	{{0x30,0x08},{0x82}},
+	{{0x31,0x03},{0x03}},
+	{{0x30,0x17},{0xff}},
+	{{0x30,0x18},{0xff}},
+	{{0x31,0x08},{0x01}},
+	{{0x30,0x37},{0x13}},
+	{{0x36,0x30},{0x2e}},
+	{{0x36,0x32},{0xe2}},
+	{{0x36,0x33},{0x23}},
+	{{0x36,0x34},{0x44}},
+	{{0x36,0x21},{0xe0}},
+	{{0x37,0x04},{0xa0}},
+	{{0x37,0x03},{0x5a}},
+	{{0x37,0x15},{0x78}},
+	{{0x37,0x17},{0x01}},
+	{{0x37,0x0b},{0x60}},
+	{{0x37,0x05},{0x1a}},
+	{{0x39,0x05},{0x02}},
+	{{0x39,0x06},{0x10}},
+	{{0x39,0x01},{0x0a}},
+	{{0x37,0x31},{0x12}},
+	{{0x36,0x00},{0x08}},
+	{{0x36,0x01},{0x33}},
+	{{0x47,0x1c},{0x50}},
+	//{{0x38,0x20},{0x41}},
+	//{{0x38,0x21},{0x26}},
+	{{0x38,0x14},{0x11}},
+	{{0x38,0x15},{0x11}},
+	{{0x38,0x00},{0x01}},
+	{{0x38,0x01},{0x50}},
+	{{0x38,0x02},{0x01}},
+	{{0x38,0x03},{0xb2}},
+	{{0x38,0x04},{0x08}},
+	{{0x38,0x05},{0xef}},
+	{{0x38,0x06},{0x05}},
+	{{0x38,0x07},{0xf2}},
+	{{0x38,0x08},{0x07}},
+	{{0x38,0x09},{0x80}},
+	{{0x38,0x0a},{0x04}},
+	{{0x38,0x0b},{0x38}},
+	{{0x38,0x0c},{0x09}},
+	{{0x38,0x0d},{0xc4}},
+	{{0x38,0x0e},{0x04}},
+	{{0x38,0x0f},{0x60}},
+	{{0x38,0x10},{0x00}},
+	{{0x38,0x11},{0x10}},
+	{{0x38,0x12},{0x00}},
+	{{0x38,0x13},{0x04}},
+	{{0x36,0x18},{0x04}},
+	{{0x36,0x12},{0x4b}},
+	{{0x37,0x08},{0x62}},
+	{{0x37,0x09},{0x12}},
+	{{0x37,0x0c},{0x00}},
+	{{0x3a,0x02},{0x04}},
+	{{0x3a,0x03},{0x60}},
+	{{0x3a,0x08},{0x01}},
+	{{0x3a,0x09},{0x50}},
+	{{0x3a,0x0a},{0x01}},
+	{{0x3a,0x0b},{0x18}},
+	{{0x3a,0x0e},{0x03}},
+	{{0x3a,0x0d},{0x04}},
+	{{0x3a,0x14},{0x04}},
+	{{0x3a,0x15},{0x60}},
+	{{0x40,0x01},{0x02}},
+	{{0x40,0x04},{0x06}},
+	{{0x30,0x02},{0x00}},
+	{{0x30,0x06},{0xff}},
+	{{0x43,0x00},{0x30}},
+	{{0x50,0x1f},{0x00}},
+	{{0x47,0x13},{0x03}},
+	{{0x30,0x35},{0x11}},
+	{{0x44,0x07},{0x04}},
+	{{0x46,0x0b},{0x35}},
+	{{0x46,0x0c},{0x22}},
+	{{0x38,0x24},{0x04}},
+	{{0x50,0x00},{0xa7}},
+	{{0x50,0x01},{0x83}},
+	{{0x50,0x00},{0xa7}},
+	{{0x36,0x22},{0x01}},
+	{{0x36,0x35},{0x1c}},
+	{{0x36,0x34},{0x40}},
+	{{0x3c,0x01},{0x34}},
+	{{0x3c,0x00},{0x00}},
+	{{0x3c,0x04},{0x28}},
+	{{0x3c,0x05},{0x98}},
+	{{0x3c,0x06},{0x00}},
+	{{0x3c,0x07},{0x08}},
+	{{0x3c,0x08},{0x00}},
+	{{0x3c,0x09},{0x1c}},
+	{{0x30,0x0c},{0x22}},
+	{{0x3c,0x0a},{0x9c}},
+	{{0x3c,0x0b},{0x40}},
+	{{0x51,0x80},{0xff}},
+	{{0x51,0x81},{0xf2}},
+	{{0x51,0x82},{0x00}},
+	{{0x51,0x83},{0x94}},
+	{{0x51,0x84},{0x25}},
+	{{0x51,0x85},{0x24}},
+	{{0x51,0x86},{0x06}},
+	{{0x51,0x87},{0x08}},
+	{{0x51,0x88},{0x08}},
+	{{0x51,0x89},{0x78}},
+	{{0x51,0x8a},{0x54}},
+	{{0x51,0x8b},{0xb2}},
+	{{0x51,0x8c},{0xb2}},
+	{{0x51,0x8d},{0x44}},
+	{{0x51,0x8e},{0x3d}},
+	{{0x51,0x8f},{0x58}},
+	{{0x51,0x90},{0x46}},
+	{{0x51,0x91},{0xf8}},
+	{{0x51,0x92},{0x04}},
+	{{0x51,0x93},{0x70}},
+	{{0x51,0x94},{0xf0}},
+	{{0x51,0x95},{0xf0}},
+	{{0x51,0x96},{0x03}},
+	{{0x51,0x97},{0x01}},
+	{{0x51,0x98},{0x04}},
+	{{0x51,0x99},{0x12}},
+	{{0x51,0x9a},{0x04}},
+	{{0x51,0x9b},{0x00}},
+	{{0x51,0x9c},{0x06}},
+	{{0x51,0x9d},{0x82}},
+	{{0x51,0x9e},{0x38}},
+	{{0x53,0x81},{0x1c}},
+	{{0x53,0x82},{0x5a}},
+	{{0x53,0x83},{0x06}},
+	{{0x53,0x84},{0x20}},
+	{{0x53,0x85},{0x80}},
+	{{0x53,0x86},{0xa0}},
+	{{0x53,0x87},{0xa2}},
+	{{0x53,0x88},{0xa0}},
+	{{0x53,0x89},{0x02}},
+	{{0x53,0x8a},{0x01}},
+	{{0x53,0x8b},{0x98}},
+	{{0x53,0x00},{0x08}},
+	{{0x53,0x01},{0x30}},
+	{{0x53,0x02},{0x10}},
+	{{0x53,0x03},{0x00}},
+	{{0x53,0x04},{0x08}},
+	{{0x53,0x05},{0x30}},
+	{{0x53,0x06},{0x08}},
+	{{0x53,0x07},{0x16}},
+	{{0x53,0x09},{0x08}},
+	{{0x53,0x0a},{0x30}},
+	{{0x53,0x0b},{0x04}},
+	{{0x53,0x0c},{0x06}},
+	{{0x54,0x80},{0x01}},
+	{{0x54,0x81},{0x08}},
+	{{0x54,0x82},{0x14}},
+	{{0x54,0x83},{0x28}},
+	{{0x54,0x84},{0x51}},
+	{{0x54,0x85},{0x65}},
+	{{0x54,0x86},{0x71}},
+	{{0x54,0x87},{0x7d}},
+	{{0x54,0x88},{0x87}},
+	{{0x54,0x89},{0x91}},
+	{{0x54,0x8a},{0x9a}},
+	{{0x54,0x8b},{0xaa}},
+	{{0x54,0x8c},{0xb8}},
+	{{0x54,0x8d},{0xcd}},
+	{{0x54,0x8e},{0xdd}},
+	{{0x54,0x8f},{0xea}},
+	{{0x54,0x90},{0x1d}},
+	{{0x55,0x80},{0x02}},
+	{{0x55,0x83},{0x40}},
+	{{0x55,0x84},{0x10}},
+	{{0x55,0x89},{0x10}},
+	{{0x55,0x8a},{0x00}},
+	{{0x55,0x8b},{0xf8}},
+	{{0x58,0x00},{0x23}},
+	{{0x58,0x01},{0x15}},
+	{{0x58,0x02},{0x10}},
+	{{0x58,0x03},{0x10}},
+	{{0x58,0x04},{0x15}},
+	{{0x58,0x05},{0x23}},
+	{{0x58,0x06},{0x0c}},
+	{{0x58,0x07},{0x08}},
+	{{0x58,0x08},{0x05}},
+	{{0x58,0x09},{0x05}},
+	{{0x58,0x0a},{0x08}},
+	{{0x58,0x0b},{0x0c}},
+	{{0x58,0x0c},{0x07}},
+	{{0x58,0x0d},{0x03}},
+	{{0x58,0x0e},{0x00}},
+	{{0x58,0x0f},{0x00}},
+	{{0x58,0x10},{0x03}},
+	{{0x58,0x11},{0x07}},
+	{{0x58,0x12},{0x07}},
+	{{0x58,0x13},{0x03}},
+	{{0x58,0x14},{0x00}},
+	{{0x58,0x15},{0x00}},
+	{{0x58,0x16},{0x03}},
+	{{0x58,0x17},{0x07}},
+	{{0x58,0x18},{0x0b}},
+	{{0x58,0x19},{0x08}},
+	{{0x58,0x1a},{0x05}},
+	{{0x58,0x1b},{0x05}},
+	{{0x58,0x1c},{0x07}},
+	{{0x58,0x1d},{0x0b}},
+	{{0x58,0x1e},{0x2a}},
+	{{0x58,0x1f},{0x16}},
+	{{0x58,0x20},{0x11}},
+	{{0x58,0x21},{0x11}},
+	{{0x58,0x22},{0x15}},
+	{{0x58,0x23},{0x29}},
+	{{0x58,0x24},{0xbf}},
+	{{0x58,0x25},{0xaf}},
+	{{0x58,0x26},{0x9f}},
+	{{0x58,0x27},{0xaf}},
+	{{0x58,0x28},{0xdf}},
+	{{0x58,0x29},{0x6f}},
+	{{0x58,0x2a},{0x8e}},
+	{{0x58,0x2b},{0xab}},
+	{{0x58,0x2c},{0x9e}},
+	{{0x58,0x2d},{0x7f}},
+	{{0x58,0x2e},{0x4f}},
+	{{0x58,0x2f},{0x89}},
+	{{0x58,0x30},{0x86}},
+	{{0x58,0x31},{0x98}},
+	{{0x58,0x32},{0x6f}},
+	{{0x58,0x33},{0x4f}},
+	{{0x58,0x34},{0x6e}},
+	{{0x58,0x35},{0x7b}},
+	{{0x58,0x36},{0x7e}},
+	{{0x58,0x37},{0x6f}},
+	{{0x58,0x38},{0xde}},
+	{{0x58,0x39},{0xbf}},
+	{{0x58,0x3a},{0x9f}},
+	{{0x58,0x3b},{0xbf}},
+	{{0x58,0x3c},{0xec}},
+	{{0x50,0x25},{0x00}},
+	{{0x3a,0x0f},{0x30}},
+	{{0x3a,0x10},{0x28}},
+	{{0x3a,0x1b},{0x30}},
+	{{0x3a,0x1e},{0x26}},
+	{{0x3a,0x11},{0x60}},
+	{{0x3a,0x1f},{0x14}},
+	{{0x3a,0x18},{0x00}},
+	{{0x3a,0x19},{0xf8}},
+	{{0x30,0x35},{0x21}},
+*/
+{{0x31,0x03},{0x11}},
+//{{0x30,0x08},{0x82}},
+{{0x30,0x08},{0x42}},
+{{0x31,0x03},{0x03}},
+{{0x30,0x17},{0xff}},
+{{0x30,0x18},{0xff}},
+{{0x30,0x34},{0x1a}},
+//{{0x30,0x35},{0x11}},
+{{0x30,0x35},{0x21}},
+{{0x30,0x36},{0x69}},
+
+
+{{0x30,0x2c},{0xc2}},//bit[7:6]: output drive capability
+					//00: 1x   01: 2x  10: 3x  11: 4x
+
+{{0x30,0x37},{0x13}},
+{{0x31,0x08},{0x01}},//pclk div = 2
+{{0x36,0x30},{0x36}},
+{{0x36,0x31},{0x0e}},
+{{0x36,0x32},{0xe2}},
+{{0x36,0x33},{0x12}},
+{{0x36,0x21},{0xe0}},
+{{0x37,0x04},{0xa0}},
+{{0x37,0x03},{0x5a}},
+{{0x37,0x15},{0x78}},
+{{0x37,0x17},{0x01}},
+{{0x37,0x0b},{0x60}},
+{{0x37,0x05},{0x1a}},
+{{0x39,0x05},{0x02}},
+{{0x39,0x06},{0x10}},
+{{0x39,0x01},{0x0a}},
+{{0x37,0x31},{0x12}},
+{{0x36,0x00},{0x08}},
+{{0x36,0x01},{0x33}},
+{{0x30,0x2d},{0x60}},
+{{0x36,0x20},{0x52}},
+{{0x37,0x1b},{0x20}},
+{{0x47,0x1c},{0x50}},
+{{0x3a,0x13},{0x43}},
+{{0x3a,0x18},{0x00}},
+{{0x3a,0x19},{0xf8}},
+{{0x36,0x35},{0x13}},
+{{0x36,0x36},{0x03}},
+{{0x36,0x34},{0x40}},
+{{0x36,0x22},{0x01}},
+{{0x3c,0x01},{0x34}},
+{{0x3c,0x04},{0x28}},
+{{0x3c,0x05},{0x98}},
+{{0x3c,0x06},{0x00}},
+{{0x3c,0x07},{0x07}},
+{{0x3c,0x08},{0x00}},
+{{0x3c,0x09},{0x1c}},
+{{0x3c,0x0a},{0x9c}},
+{{0x3c,0x0b},{0x40}},
+//{{0x38,0x20},{0x40}},
+//{{0x38,0x21},{0x06}},
+{{0x38,0x14},{0x11}},
+{{0x38,0x15},{0x11}},
+{{0x38,0x00},{0x01}},
+{{0x38,0x01},{0x50}},
+{{0x38,0x02},{0x01}},
+{{0x38,0x03},{0xb2}},
+{{0x38,0x04},{0x08}},
+{{0x38,0x05},{0xef}},
+{{0x38,0x06},{0x05}},
+{{0x38,0x07},{0xf1}},
+{{0x38,0x08},{0x07}},
+{{0x38,0x09},{0x80}},
+{{0x38,0x0a},{0x04}},
+{{0x38,0x0b},{0x38}},
+{{0x38,0x0c},{0x09}},
+{{0x38,0x0d},{0xc4}},
+{{0x38,0x0e},{0x04}},
+{{0x38,0x0f},{0x60}},
+{{0x38,0x10},{0x00}},
+{{0x38,0x11},{0x10}},
+{{0x38,0x12},{0x00}},
+{{0x38,0x13},{0x04}},
+{{0x36,0x18},{0x04}},
+{{0x36,0x12},{0x2b}},
+{{0x37,0x08},{0x64}},
+{{0x37,0x09},{0x12}},
+{{0x37,0x0c},{0x00}},
+{{0x3a,0x02},{0x04}},
+{{0x3a,0x03},{0x60}},
+{{0x3a,0x08},{0x01}},
+{{0x3a,0x09},{0x50}},
+{{0x3a,0x0a},{0x01}},
+{{0x3a,0x0b},{0x18}},
+{{0x3a,0x0e},{0x03}},
+{{0x3a,0x0d},{0x04}},
+{{0x3a,0x14},{0x04}},
+{{0x3a,0x15},{0x60}},
+{{0x40,0x01},{0x02}},
+{{0x40,0x04},{0x06}},
+{{0x30,0x00},{0x00}},
+{{0x30,0x02},{0x1c}},
+{{0x30,0x04},{0xff}},
+{{0x30,0x06},{0xc3}},
+{{0x30,0x0e},{0x58}},
+{{0x30,0x2e},{0x00}},
+{{0x43,0x00},{0x30}},
+{{0x50,0x1f},{0x00}},
+{{0x47,0x13},{0x02}},
+{{0x44,0x07},{0x04}},
+{{0x44,0x0e},{0x00}},
+{{0x46,0x0b},{0x37}},
+{{0x46,0x0c},{0x20}},
+{{0x48,0x37},{0x16}},
+{{0x38,0x24},{0x04}},
+{{0x50,0x00},{0xa7}},
+{{0x50,0x01},{0x83}},
+{{0x51,0x80},{0xff}},
+{{0x51,0x81},{0xf2}},
+{{0x51,0x82},{0x00}},
+{{0x51,0x83},{0x14}},
+{{0x51,0x84},{0x25}},
+{{0x51,0x85},{0x24}},
+{{0x51,0x86},{0x09}},
+{{0x51,0x87},{0x09}},
+{{0x51,0x88},{0x09}},
+{{0x51,0x89},{0x75}},
+{{0x51,0x8a},{0x54}},
+{{0x51,0x8b},{0xe0}},
+{{0x51,0x8c},{0xb2}},
+{{0x51,0x8d},{0x42}},
+{{0x51,0x8e},{0x3d}},
+{{0x51,0x8f},{0x56}},
+{{0x51,0x90},{0x46}},
+{{0x51,0x91},{0xf8}},
+{{0x51,0x92},{0x04}},
+{{0x51,0x93},{0x70}},
+{{0x51,0x94},{0xf0}},
+{{0x51,0x95},{0xf0}},
+{{0x51,0x96},{0x03}},
+{{0x51,0x97},{0x01}},
+{{0x51,0x98},{0x04}},
+{{0x51,0x99},{0x12}},
+{{0x51,0x9a},{0x04}},
+{{0x51,0x9b},{0x00}},
+{{0x51,0x9c},{0x06}},
+{{0x51,0x9d},{0x82}},
+{{0x51,0x9e},{0x38}},
+{{0x53,0x81},{0x1e}},
+{{0x53,0x82},{0x5b}},
+{{0x53,0x83},{0x08}},
+{{0x53,0x84},{0x0a}},
+{{0x53,0x85},{0x7e}},
+{{0x53,0x86},{0x88}},
+{{0x53,0x87},{0x7c}},
+{{0x53,0x88},{0x6c}},
+{{0x53,0x89},{0x10}},
+{{0x53,0x8a},{0x01}},
+{{0x53,0x8b},{0x98}},
+{{0x53,0x00},{0x08}},
+{{0x53,0x01},{0x30}},
+{{0x53,0x02},{0x10}},
+{{0x53,0x03},{0x00}},
+{{0x53,0x04},{0x08}},
+{{0x53,0x05},{0x30}},
+{{0x53,0x06},{0x08}},
+{{0x53,0x07},{0x16}},
+{{0x53,0x09},{0x08}},
+{{0x53,0x0a},{0x30}},
+{{0x53,0x0b},{0x04}},
+{{0x53,0x0c},{0x06}},
+{{0x54,0x80},{0x01}},
+{{0x54,0x81},{0x08}},
+{{0x54,0x82},{0x14}},
+{{0x54,0x83},{0x28}},
+{{0x54,0x84},{0x51}},
+{{0x54,0x85},{0x65}},
+{{0x54,0x86},{0x71}},
+{{0x54,0x87},{0x7d}},
+{{0x54,0x88},{0x87}},
+{{0x54,0x89},{0x91}},
+{{0x54,0x8a},{0x9a}},
+{{0x54,0x8b},{0xaa}},
+{{0x54,0x8c},{0xb8}},
+{{0x54,0x8d},{0xcd}},
+{{0x54,0x8e},{0xdd}},
+{{0x54,0x8f},{0xea}},
+{{0x54,0x90},{0x1d}},
+{{0x55,0x80},{0x02}},
+{{0x55,0x83},{0x40}},
+{{0x55,0x84},{0x10}},
+{{0x55,0x89},{0x10}},
+{{0x55,0x8a},{0x00}},
+{{0x55,0x8b},{0xf8}},
+{{0x58,0x00},{0x23}},
+{{0x58,0x01},{0x14}},
+{{0x58,0x02},{0x0f}},
+{{0x58,0x03},{0x0f}},
+{{0x58,0x04},{0x12}},
+{{0x58,0x05},{0x26}},
+{{0x58,0x06},{0x0c}},
+{{0x58,0x07},{0x08}},
+{{0x58,0x08},{0x05}},
+{{0x58,0x09},{0x05}},
+{{0x58,0x0a},{0x08}},
+{{0x58,0x0b},{0x0d}},
+{{0x58,0x0c},{0x08}},
+{{0x58,0x0d},{0x03}},
+{{0x58,0x0e},{0x00}},
+{{0x58,0x0f},{0x00}},
+{{0x58,0x10},{0x03}},
+{{0x58,0x11},{0x09}},
+{{0x58,0x12},{0x07}},
+{{0x58,0x13},{0x03}},
+{{0x58,0x14},{0x00}},
+{{0x58,0x15},{0x01}},
+{{0x58,0x16},{0x03}},
+{{0x58,0x17},{0x08}},
+{{0x58,0x18},{0x0d}},
+{{0x58,0x19},{0x08}},
+{{0x58,0x1a},{0x05}},
+{{0x58,0x1b},{0x06}},
+{{0x58,0x1c},{0x08}},
+{{0x58,0x1d},{0x0e}},
+{{0x58,0x1e},{0x29}},
+{{0x58,0x1f},{0x17}},
+{{0x58,0x20},{0x11}},
+{{0x58,0x21},{0x11}},
+{{0x58,0x22},{0x15}},
+{{0x58,0x23},{0x28}},
+{{0x58,0x24},{0x46}},
+{{0x58,0x25},{0x26}},
+{{0x58,0x26},{0x08}},
+{{0x58,0x27},{0x26}},
+{{0x58,0x28},{0x64}},
+{{0x58,0x29},{0x26}},
+{{0x58,0x2a},{0x24}},
+{{0x58,0x2b},{0x22}},
+{{0x58,0x2c},{0x24}},
+{{0x58,0x2d},{0x24}},
+{{0x58,0x2e},{0x06}},
+{{0x58,0x2f},{0x22}},
+{{0x58,0x30},{0x40}},
+{{0x58,0x31},{0x42}},
+{{0x58,0x32},{0x24}},
+{{0x58,0x33},{0x26}},
+{{0x58,0x34},{0x24}},
+{{0x58,0x35},{0x22}},
+{{0x58,0x36},{0x22}},
+{{0x58,0x37},{0x26}},
+{{0x58,0x38},{0x44}},
+{{0x58,0x39},{0x24}},
+{{0x58,0x3a},{0x26}},
+{{0x58,0x3b},{0x28}},
+{{0x58,0x3c},{0x42}},
+{{0x58,0x3d},{0xce}},
+{{0x50,0x25},{0x00}},
+{{0x3a,0x0f},{0x30}},
+{{0x3a,0x10},{0x28}},
+{{0x3a,0x1b},{0x30}},
+{{0x3a,0x1e},{0x26}},
+{{0x3a,0x11},{0x60}},
+{{0x3a,0x1f},{0x14}},
+{{0x30,0x08},{0x02}},
+{{0x30,0x35},{0x21}},
+};
+
+static struct regval_list sensor_uxga_regs[] = { //UXGA: 1600*1200
+	//capture 5Mega 3.75fps
+	{{0x35,0x03},{0x07}},
+	{{0x3a,0x00},{0x78}},
+	{{0x35,0x0c},{0x00}},
+	{{0x35,0x0d},{0x00}},
+	{{0x3c,0x07},{0x07}},
+	//{{0x38,0x20},{0x40}},
+	//{{0x38,0x21},{0x06}},
+	{{0x38,0x14},{0x11}},
+	{{0x38,0x15},{0x11}},
+	{{0x38,0x03},{0x00}},
+	{{0x38,0x07},{0x9f}},
+	{{0x38,0x08},{0x0a}},
+	{{0x38,0x09},{0x20}},
+	{{0x38,0x0a},{0x07}},
+	{{0x38,0x0b},{0x98}},
+	{{0x38,0x0c},{0x0b}},
+	{{0x38,0x0d},{0x1c}},
+	{{0x38,0x0e},{0x07}},
+	{{0x38,0x0f},{0xb0}},
+
+    {{0x40,0x02},{0xc5}},
+	{{0x40,0x05},{0x1a}},
+    {{0x53,0x02},{0x30}},//sharpness
+
+	{{0x38,0x13},{0x04}},
+	{{0x36,0x18},{0x04}},
+	{{0x36,0x12},{0x2b}},
+	{{0x37,0x09},{0x12}},
+	{{0x37,0x0c},{0x00}},
+	{{0x3a,0x02},{0x07}},
+	{{0x3a,0x03},{0xb0}},
+	{{0x3a,0x0e},{0x06}},
+	{{0x3a,0x0d},{0x08}},
+	{{0x3a,0x14},{0x07}},
+	{{0x3a,0x15},{0xb0}},
+	{{0x40,0x04},{0x06}},
+	{{0x30,0x35},{0x21}},
+	{{0x30,0x36},{0x46}},
+	{{0x48,0x37},{0x2c}},
+	{{0x50,0x01},{0xa3}},
+
+    {{0x40,0x02},{0xc5}},
+	{{0x40,0x05},{0x12}},
+
+
+
+	//1600*1200
+	{{0x38,0x08},{0x06}},
+	{{0x38,0x09},{0x40}},
+	{{0x38,0x0a},{0x04}},
+	{{0x38,0x0b},{0xb0}},
+};
+
+static struct regval_list sensor_720p_regs[] = { //1280*720
+	{{0x31,0x03},{0x11}},
+//	{{0x30,0x08},{0x82}},
+	{{0x30,0x08},{0x42}},
+	{{0x31,0x03},{0x03}},
+	{{0x30,0x17},{0xff}},
+	{{0x30,0x18},{0xff}},
+	{{0x30,0x34},{0x1a}},
+	//{{0x30,0x35},{0x11}},////
+	{{0x30,0x35},{0x21}},////
+
+	{{0x30,0x2c},{0xc2}},//bit[7:6]: output drive capability
+								//00: 1x   01: 2x  10: 3x  11: 4x
+
+	{{0x30,0x36},{0x69}},
+	{{0x30,0x37},{0x13}},
+	{{0x31,0x08},{0x01}},//pclk div = 1
+	{{0x36,0x30},{0x36}},
+	{{0x36,0x31},{0x0e}},
+	{{0x36,0x32},{0xe2}},
+	{{0x36,0x33},{0x12}},
+	{{0x36,0x21},{0xe0}},
+	{{0x37,0x04},{0xa0}},
+	{{0x37,0x03},{0x5a}},
+	{{0x37,0x15},{0x78}},
+	{{0x37,0x17},{0x01}},
+	{{0x37,0x0b},{0x60}},
+	{{0x37,0x05},{0x1a}},
+	{{0x39,0x05},{0x02}},
+	{{0x39,0x06},{0x10}},
+	{{0x39,0x01},{0x0a}},
+	{{0x37,0x31},{0x12}},
+	{{0x36,0x00},{0x08}},
+	{{0x36,0x01},{0x33}},
+	{{0x30,0x2d},{0x60}},
+	{{0x36,0x20},{0x52}},
+	{{0x37,0x1b},{0x20}},
+	{{0x47,0x1c},{0x50}},
+	{{0x3a,0x13},{0x43}},
+	{{0x3a,0x18},{0x00}},
+	{{0x3a,0x19},{0xf8}},
+	{{0x36,0x35},{0x13}},
+	{{0x36,0x36},{0x03}},
+	{{0x36,0x34},{0x40}},
+	{{0x36,0x22},{0x01}},
+	{{0x3c,0x01},{0x34}},
+	{{0x3c,0x04},{0x28}},
+	{{0x3c,0x05},{0x98}},
+	{{0x3c,0x06},{0x00}},
+	{{0x3c,0x07},{0x07}},
+	{{0x3c,0x08},{0x00}},
+	{{0x3c,0x09},{0x1c}},
+	{{0x3c,0x0a},{0x9c}},
+	{{0x3c,0x0b},{0x40}},
+	//{{0x38,0x20},{0x41}},
+	//{{0x38,0x21},{0x00}},
+	{{0x38,0x14},{0x31}},
+	{{0x38,0x15},{0x31}},
+	{{0x38,0x00},{0x00}},
+	{{0x38,0x01},{0x00}},
+	{{0x38,0x02},{0x00}},
+	{{0x38,0x03},{0xfa}},
+	{{0x38,0x04},{0x0a}},
+	{{0x38,0x05},{0x3f}},
+	{{0x38,0x06},{0x06}},
+	{{0x38,0x07},{0xa9}},
+	{{0x38,0x08},{0x05}},
+	{{0x38,0x09},{0x00}},
+	{{0x38,0x0a},{0x02}},
+	{{0x38,0x0b},{0xd0}},
+	{{0x38,0x0c},{0x07}},
+	{{0x38,0x0d},{0x64}},
+	{{0x38,0x0e},{0x02}},
+	{{0x38,0x0f},{0xe4}},
+	{{0x38,0x10},{0x00}},
+	{{0x38,0x11},{0x10}},
+	{{0x38,0x12},{0x00}},
+	{{0x38,0x13},{0x04}},
+	{{0x36,0x18},{0x00}},
+	{{0x36,0x12},{0x29}},
+	{{0x37,0x08},{0x64}},
+	{{0x37,0x09},{0x52}},
+	{{0x37,0x0c},{0x03}},
+	{{0x3a,0x02},{0x02}},
+	{{0x3a,0x03},{0xe4}},
+	{{0x3a,0x08},{0x01}},
+	{{0x3a,0x09},{0xbc}},
+	{{0x3a,0x0a},{0x01}},
+	{{0x3a,0x0b},{0x72}},
+	{{0x3a,0x0e},{0x01}},
+	{{0x3a,0x0d},{0x02}},
+	{{0x3a,0x14},{0x02}},
+	{{0x3a,0x15},{0xe4}},
+	{{0x40,0x01},{0x02}},
+	{{0x40,0x04},{0x02}},
+	{{0x30,0x00},{0x00}},
+	{{0x30,0x02},{0x1c}},
+	{{0x30,0x04},{0xff}},
+	{{0x30,0x06},{0xc3}},
+	{{0x30,0x0e},{0x58}},
+	{{0x30,0x2e},{0x00}},
+	{{0x43,0x00},{0x30}},
+	{{0x50,0x1f},{0x00}},
+	{{0x47,0x13},{0x02}},
+	{{0x44,0x07},{0x04}},
+	{{0x44,0x0e},{0x00}},
+	{{0x46,0x0b},{0x37}},
+	{{0x46,0x0c},{0x20}},
+	{{0x48,0x27},{0x16}},
+	{{0x38,0x24},{0x04}},
+	{{0x50,0x00},{0xa7}},
+	{{0x50,0x01},{0x83}},
+	{{0x51,0x80},{0xff}},
+	{{0x51,0x81},{0xf2}},
+	{{0x51,0x82},{0x00}},
+	{{0x51,0x83},{0x14}},
+	{{0x51,0x84},{0x25}},
+	{{0x51,0x85},{0x24}},
+	{{0x51,0x86},{0x09}},
+	{{0x51,0x87},{0x09}},
+	{{0x51,0x88},{0x09}},
+	{{0x51,0x89},{0x75}},
+	{{0x51,0x8a},{0x54}},
+	{{0x51,0x8b},{0xe0}},
+	{{0x51,0x8c},{0xb2}},
+	{{0x51,0x8d},{0x42}},
+	{{0x51,0x8e},{0x3d}},
+	{{0x51,0x8f},{0x56}},
+	{{0x51,0x90},{0x46}},
+	{{0x51,0x91},{0xf8}},
+	{{0x51,0x92},{0x04}},
+	{{0x51,0x93},{0x70}},
+	{{0x51,0x94},{0xf0}},
+	{{0x51,0x95},{0xf0}},
+	{{0x51,0x96},{0x03}},
+	{{0x51,0x97},{0x01}},
+	{{0x51,0x98},{0x04}},
+	{{0x51,0x99},{0x12}},
+	{{0x51,0x9a},{0x04}},
+	{{0x51,0x9b},{0x00}},
+	{{0x51,0x9c},{0x06}},
+	{{0x51,0x9d},{0x82}},
+	{{0x51,0x9e},{0x38}},
+	{{0x53,0x81},{0x1e}},
+	{{0x53,0x82},{0x5b}},
+	{{0x53,0x83},{0x08}},
+	{{0x53,0x84},{0x0a}},
+	{{0x53,0x85},{0x7e}},
+	{{0x53,0x86},{0x88}},
+	{{0x53,0x87},{0x7c}},
+	{{0x53,0x88},{0x6c}},
+	{{0x53,0x89},{0x10}},
+	{{0x53,0x8a},{0x01}},
+	{{0x53,0x8b},{0x98}},
+	{{0x53,0x00},{0x08}},
+	{{0x53,0x01},{0x30}},
+	{{0x53,0x02},{0x10}},
+	{{0x53,0x03},{0x00}},
+	{{0x53,0x04},{0x08}},
+	{{0x53,0x05},{0x30}},
+	{{0x53,0x06},{0x08}},
+	{{0x53,0x07},{0x16}},
+	{{0x53,0x09},{0x08}},
+	{{0x53,0x0a},{0x30}},
+	{{0x53,0x0b},{0x04}},
+	{{0x53,0x0c},{0x06}},
+	{{0x54,0x80},{0x01}},
+	{{0x54,0x81},{0x08}},
+	{{0x54,0x82},{0x14}},
+	{{0x54,0x83},{0x28}},
+	{{0x54,0x84},{0x51}},
+	{{0x54,0x85},{0x65}},
+	{{0x54,0x86},{0x71}},
+	{{0x54,0x87},{0x7d}},
+	{{0x54,0x88},{0x87}},
+	{{0x54,0x89},{0x91}},
+	{{0x54,0x8a},{0x9a}},
+	{{0x54,0x8b},{0xaa}},
+	{{0x54,0x8c},{0xb8}},
+	{{0x54,0x8d},{0xcd}},
+	{{0x54,0x8e},{0xdd}},
+	{{0x54,0x8f},{0xea}},
+	{{0x54,0x90},{0x1d}},
+	{{0x55,0x80},{0x02}},
+	{{0x55,0x83},{0x40}},
+	{{0x55,0x84},{0x10}},
+	{{0x55,0x89},{0x10}},
+	{{0x55,0x8a},{0x00}},
+	{{0x55,0x8b},{0xf8}},
+	{{0x58,0x00},{0x23}},
+	{{0x58,0x01},{0x14}},
+	{{0x58,0x02},{0x0f}},
+	{{0x58,0x03},{0x0f}},
+	{{0x58,0x04},{0x12}},
+	{{0x58,0x05},{0x26}},
+	{{0x58,0x06},{0x0c}},
+	{{0x58,0x07},{0x08}},
+	{{0x58,0x08},{0x05}},
+	{{0x58,0x09},{0x05}},
+	{{0x58,0x0a},{0x08}},
+	{{0x58,0x0b},{0x0d}},
+	{{0x58,0x0c},{0x08}},
+	{{0x58,0x0d},{0x03}},
+	{{0x58,0x0e},{0x00}},
+	{{0x58,0x0f},{0x00}},
+	{{0x58,0x10},{0x03}},
+	{{0x58,0x11},{0x09}},
+	{{0x58,0x12},{0x07}},
+	{{0x58,0x13},{0x03}},
+	{{0x58,0x14},{0x00}},
+	{{0x58,0x15},{0x01}},
+	{{0x58,0x16},{0x03}},
+	{{0x58,0x17},{0x08}},
+	{{0x58,0x18},{0x0d}},
+	{{0x58,0x19},{0x08}},
+	{{0x58,0x1a},{0x05}},
+	{{0x58,0x1b},{0x06}},
+	{{0x58,0x1c},{0x08}},
+	{{0x58,0x1d},{0x0e}},
+	{{0x58,0x1e},{0x29}},
+	{{0x58,0x1f},{0x17}},
+	{{0x58,0x20},{0x11}},
+	{{0x58,0x21},{0x11}},
+	{{0x58,0x22},{0x15}},
+	{{0x58,0x23},{0x28}},
+	{{0x58,0x24},{0x46}},
+	{{0x58,0x25},{0x26}},
+	{{0x58,0x26},{0x08}},
+	{{0x58,0x27},{0x26}},
+	{{0x58,0x28},{0x64}},
+	{{0x58,0x29},{0x26}},
+	{{0x58,0x2a},{0x24}},
+	{{0x58,0x2b},{0x22}},
+	{{0x58,0x2c},{0x24}},
+	{{0x58,0x2d},{0x24}},
+	{{0x58,0x2e},{0x06}},
+	{{0x58,0x2f},{0x22}},
+	{{0x58,0x30},{0x40}},
+	{{0x58,0x31},{0x42}},
+	{{0x58,0x32},{0x24}},
+	{{0x58,0x33},{0x26}},
+	{{0x58,0x34},{0x24}},
+	{{0x58,0x35},{0x22}},
+	{{0x58,0x36},{0x22}},
+	{{0x58,0x37},{0x26}},
+	{{0x58,0x38},{0x44}},
+	{{0x58,0x39},{0x24}},
+	{{0x58,0x3a},{0x26}},
+	{{0x58,0x3b},{0x28}},
+	{{0x58,0x3c},{0x42}},
+	{{0x58,0x3d},{0xce}},
+	{{0x50,0x25},{0x00}},
+	{{0x3a,0x0f},{0x30}},
+	{{0x3a,0x10},{0x28}},
+	{{0x3a,0x1b},{0x30}},
+	{{0x3a,0x1e},{0x26}},
+	{{0x3a,0x11},{0x60}},
+	{{0x3a,0x1f},{0x14}},
+	{{0x30,0x08},{0x02}},
+	{{0x30,0x35},{0x21}},
+	{{0x3c,0x01},{0xb4}},
+	{{0x3c,0x00},{0x04}},
+
+/*	{{0x38,0x00},{0x0 }},
+	{{0x38,0x01},{0x0 }},
+	{{0x38,0x02},{0x0 }},
+	{{0x38,0x03},{0x4 }},
+	{{0x38,0x04},{0xa }},
+	{{0x38,0x05},{0x3f}},
+	{{0x38,0x06},{0x7 }},
+	{{0x38,0x07},{0x9b}},
+
+	{{0x38,0x08},{0x05}},
+	{{0x38,0x09},{0x00}},
+	{{0x38,0x0a},{0x02}},
+	{{0x38,0x0b},{0xd0}},
+	{{0x38,0x0c},{0x7 }},
+	{{0x38,0x0d},{0x68}},
+	{{0x38,0x0e},{0x3 }},*/
+};
+
+static struct regval_list sensor_sxga_regs[] = { //SXGA: 1280*960
+	//capture 5Mega 3.75fps
+	{{0x35,0x03},{0x07}},
+	{{0x3a,0x00},{0x78}},
+	{{0x35,0x0c},{0x00}},
+	{{0x35,0x0d},{0x00}},
+	{{0x3c,0x07},{0x07}},
+	//{{0x38,0x20},{0x40}},
+	//{{0x38,0x21},{0x06}},
+	{{0x38,0x14},{0x11}},
+	{{0x38,0x15},{0x11}},
+	{{0x38,0x03},{0x00}},
+	{{0x38,0x07},{0x9f}},
+	{{0x38,0x08},{0x0a}},
+	{{0x38,0x09},{0x20}},
+	{{0x38,0x0a},{0x07}},
+	{{0x38,0x0b},{0x98}},
+	{{0x38,0x0c},{0x0b}},
+	{{0x38,0x0d},{0x1c}},
+	{{0x38,0x0e},{0x07}},
+	{{0x38,0x0f},{0xb0}},
+
+    {{0x40,0x02},{0xc5}},
+	{{0x40,0x05},{0x1a}},
+	{{0x53,0x02},{0x30}},//sharpness
+	{{0x38,0x13},{0x04}},
+	{{0x36,0x18},{0x04}},
+	{{0x36,0x12},{0x2b}},
+	{{0x37,0x09},{0x12}},
+	{{0x37,0x0c},{0x00}},
+	{{0x3a,0x02},{0x07}},
+	{{0x3a,0x03},{0xb0}},
+	{{0x3a,0x0e},{0x06}},
+	{{0x3a,0x0d},{0x08}},
+	{{0x3a,0x14},{0x07}},
+	{{0x3a,0x15},{0xb0}},
+	{{0x40,0x04},{0x06}},
+	{{0x30,0x35},{0x21}},
+	{{0x30,0x36},{0x46}},
+	{{0x48,0x37},{0x2c}},
+	{{0x50,0x01},{0xa3}},
+
+	//1280*960
+	{{0x38,0x08},{0x05}},
+	{{0x38,0x09},{0x00}},
+	{{0x38,0x0a},{0x03}},
+	{{0x38,0x0b},{0xc0}},
+};
+
+static struct regval_list sensor_xga_regs[] = { //XGA: 1024*768
+	//capture 5Mega 3.75fps
+	{{0x35,0x03},{0x07}},
+	{{0x3a,0x00},{0x78}},
+	{{0x35,0x0c},{0x00}},
+	{{0x35,0x0d},{0x00}},
+	{{0x3c,0x07},{0x07}},
+	//{{0x38,0x20},{0x40}},
+	//{{0x38,0x21},{0x06}},
+	{{0x38,0x14},{0x11}},
+	{{0x38,0x15},{0x11}},
+	{{0x38,0x03},{0x00}},
+	{{0x38,0x07},{0x9f}},
+	{{0x38,0x08},{0x0a}},
+	{{0x38,0x09},{0x20}},
+	{{0x38,0x0a},{0x07}},
+	{{0x38,0x0b},{0x98}},
+	{{0x38,0x0c},{0x0b}},
+	{{0x38,0x0d},{0x1c}},
+	{{0x38,0x0e},{0x07}},
+	{{0x38,0x0f},{0xb0}},
+
+	{{0x40,0x02},{0xc5}},
+	{{0x40,0x05},{0x12}},
+    {{0x53,0x02},{0x30}},//sharpness
+
+	{{0x38,0x13},{0x04}},
+	{{0x36,0x18},{0x04}},
+	{{0x36,0x12},{0x2b}},
+	{{0x37,0x09},{0x12}},
+	{{0x37,0x0c},{0x00}},
+	{{0x3a,0x02},{0x07}},
+	{{0x3a,0x03},{0xb0}},
+	{{0x3a,0x0e},{0x06}},
+	{{0x3a,0x0d},{0x08}},
+	{{0x3a,0x14},{0x07}},
+	{{0x3a,0x15},{0xb0}},
+	{{0x40,0x04},{0x06}},
+	{{0x30,0x35},{0x21}},
+	{{0x30,0x36},{0x46}},
+	{{0x48,0x37},{0x2c}},
+	{{0x50,0x01},{0xa3}},
+
+	//1024*768
+	{{0x38,0x08},{0x04}},
+	{{0x38,0x09},{0x00}},
+	{{0x38,0x0a},{0x03}},
+	{{0x38,0x0b},{0x00}},
+};
+
+
+static struct regval_list sensor_svga_regs[] = { //SVGA: 800*600
+	{{0x38,0x00},{0x0 }},
+	{{0x38,0x01},{0x0 }},
+	{{0x38,0x02},{0x0 }},
+	{{0x38,0x03},{0x4 }},
+	{{0x38,0x04},{0xa }},
+	{{0x38,0x05},{0x3f}},
+	{{0x38,0x06},{0x7 }},
+	{{0x38,0x07},{0x9b}},
+	{{0x38,0x08},{0x3 }},
+	{{0x38,0x09},{0x20}},
+	{{0x38,0x0a},{0x2 }},
+	{{0x38,0x0b},{0x58}},
+	{{0x38,0x0c},{0x7 }},
+	{{0x38,0x0d},{0x68}},
+	{{0x38,0x0e},{0x3 }},
+};
+
+static struct regval_list sensor_vga_regs[] = { //VGA:  640*480
+/*
+	{{0x30,0x35},{0x11}},
+	{{0x3a,0x00},{0x78}},
+
+	{{0x38,0x00},{0x0 }},
+	{{0x38,0x01},{0x0 }},
+	{{0x38,0x02},{0x0 }},
+	{{0x38,0x03},{0x4 }},
+	{{0x38,0x04},{0xa }},
+	{{0x38,0x05},{0x3f}},
+	{{0x38,0x06},{0x7 }},
+	{{0x38,0x07},{0x9b}},
+	{{0x38,0x08},{0x2 }},
+	{{0x38,0x09},{0x80}},
+	{{0x38,0x0a},{0x1 }},
+	{{0x38,0x0b},{0xe0}},
+	{{0x38,0x0c},{0x7 }},
+	{{0x38,0x0d},{0x68}},
+	{{0x38,0x0e},{0x3 }},
+	{{0x38,0x0f},{0xd8}},*/
+
+	{{0x30,0x35},{0x21}},//
+	{{0x30,0x36},{0x46}},//0x46->30fps
+	{{0x30,0x37},{0x13}},//////div
+
+	{{0x35,0x03},{0x00}},
+	{{0x3c,0x07},{0x08}},
+	//{{0x38,0x20},{0x41}},
+	//{{0x38,0x21},{0x07}},
+	{{0x38,0x14},{0x31}},
+	{{0x38,0x15},{0x31}},
+	{{0x38,0x03},{0x04}},
+	{{0x38,0x07},{0x9b}},
+	{{0x38,0x08},{0x02}},
+	{{0x38,0x09},{0x80}},
+	{{0x38,0x0a},{0x01}},
+	{{0x38,0x0b},{0xe0}},
+	{{0x38,0x0c},{0x07}},
+	{{0x38,0x0d},{0x68}},
+	{{0x38,0x0e},{0x03}},
+	{{0x38,0x0f},{0xd8}},
+	{{0x53,0x02},{0x10}},
+	{{0x40,0x02},{0x45}},
+	{{0x40,0x05},{0x18}},
+
+	{{0x38,0x13},{0x06}},
+	{{0x36,0x18},{0x00}},
+	{{0x36,0x12},{0x29}},
+	{{0x37,0x09},{0x52}},
+	{{0x37,0x0c},{0x03}},
+	{{0x3a,0x02},{0x03}},
+	{{0x3a,0x03},{0xd8}},
+	{{0x3a,0x0e},{0x03}},
+	{{0x3a,0x0d},{0x04}},
+	{{0x3a,0x14},{0x03}},
+	{{0x3a,0x15},{0xd8}},
+	{{0x40,0x04},{0x02}},
+	{{0x30,0x35},{0x21}}, //fps
+	{{0x30,0x36},{0x46}}, //fps
+	{{0x48,0x37},{0x22}},
+	{{0x50,0x01},{0xa3}},
+};
+
+static struct regval_list sensor_oe_disable_regs[] = {
+{{0x30,0x17},{0x00}},
+{{0x30,0x18},{0x00}},
+};
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0x34,0x06},{0x0}},
+	//{{0x51,0x83},{0x94}},
+	//{{0x51,0x91},{0xff}},
+	//{{0x51,0x92},{0x00}},
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0x34,0x06},{0x1 }},
+	{{0x34,0x00},{0x6 }},
+	{{0x34,0x01},{0x48}},
+	{{0x34,0x02},{0x4 }},
+	{{0x34,0x03},{0x0 }},
+	{{0x34,0x04},{0x4 }},
+	{{0x34,0x05},{0xd3}},
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0x34,0x06},{0x1 }},
+	{{0x34,0x00},{0x6 }},
+	{{0x34,0x01},{0x1c}},
+	{{0x34,0x02},{0x4 }},
+	{{0x34,0x03},{0x0 }},
+	{{0x34,0x04},{0x4 }},
+	{{0x34,0x05},{0xf3}},
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0x34,0x06},{0x1 }},
+	{{0x34,0x00},{0x4 }},
+	{{0x34,0x01},{0x10}},
+	{{0x34,0x02},{0x4 }},
+	{{0x34,0x03},{0x0 }},
+	{{0x34,0x04},{0x8 }},
+	{{0x34,0x05},{0xb6}},
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0x34,0x06},{0x1 }},
+	{{0x34,0x00},{0x5 }},
+	{{0x34,0x01},{0x48}},
+	{{0x34,0x02},{0x4 }},
+	{{0x34,0x03},{0x0 }},
+	{{0x34,0x04},{0x7 }},
+	{{0x34,0x05},{0xcf}},
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0x50,0x01},{0x7f}},
+	{{0x55,0x80},{0x04}},
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0x50,0x01},{0xff}},
+	{{0x55,0x80},{0x18}},
+	{{0x55,0x83},{0x80}},
+	{{0x55,0x84},{0x80}},
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0x50,0x01},{0xff}},
+	{{0x55,0x80},{0x18}},
+	{{0x55,0x83},{0x40}},
+	{{0x55,0x84},{0xa0}},
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0x50,0x01},{0xff}},
+	{{0x55,0x80},{0x40}},
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	{{0x50,0x01},{0xff}},
+	{{0x55,0x80},{0x18}},
+	{{0x55,0x83},{0x80}},
+	{{0x55,0x84},{0xc0}},
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	{{0x50,0x01},{0xff}},
+	{{0x55,0x80},{0x18}},
+	{{0x55,0x83},{0x80}},
+	{{0x55,0x84},{0xc0}},
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0x50,0x01},{0xff}},
+	{{0x55,0x80},{0x18}},
+	{{0x55,0x83},{0xa0}},
+	{{0x55,0x84},{0x40}},
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0x50,0x01},{0xff}},
+	{{0x55,0x80},{0x18}},
+	{{0x55,0x83},{0x60}},
+	{{0x55,0x84},{0x60}},
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+//NULL
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+//NULL
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0x3a,0x0f},{0x10}},	//-1.7EV
+	{{0x3a,0x10},{0x08}},
+	{{0x3a,0x1b},{0x10}},
+	{{0x3a,0x1e},{0x08}},
+	{{0x3a,0x11},{0x20}},
+	{{0x3a,0x1f},{0x10}},
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0x3a,0x0f},{0x18}},	//-1.3EV
+	{{0x3a,0x10},{0x10}},
+	{{0x3a,0x1b},{0x18}},
+	{{0x3a,0x1e},{0x10}},
+	{{0x3a,0x11},{0x30}},
+	{{0x3a,0x1f},{0x10}},
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0x3a,0x0f},{0x20}},	//-1.0EV
+	{{0x3a,0x10},{0x18}},
+	{{0x3a,0x11},{0x41}},
+	{{0x3a,0x1b},{0x20}},
+	{{0x3a,0x1e},{0x18}},
+	{{0x3a,0x1f},{0x10}},
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0x3a,0x0f},{0x28}},	//-0.7EV
+	{{0x3a,0x10},{0x20}},
+	{{0x3a,0x11},{0x51}},
+	{{0x3a,0x1b},{0x28}},
+	{{0x3a,0x1e},{0x20}},
+	{{0x3a,0x1f},{0x10}},
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0x3a,0x0f},{0x38}},		//default
+	{{0x3a,0x10},{0x30}},
+	{{0x3a,0x11},{0x61}},
+	{{0x3a,0x1b},{0x38}},
+	{{0x3a,0x1e},{0x30}},
+	{{0x3a,0x1f},{0x10}},
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0x3a,0x0f},{0x48}},	//0.7EV
+	{{0x3a,0x10},{0x40}},
+	{{0x3a,0x11},{0x80}},
+	{{0x3a,0x1b},{0x48}},
+	{{0x3a,0x1e},{0x40}},
+	{{0x3a,0x1f},{0x20}},
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0x3a,0x0f},{0x50}},	//1.0EV
+	{{0x3a,0x10},{0x48}},
+	{{0x3a,0x11},{0x90}},
+	{{0x3a,0x1b},{0x50}},
+	{{0x3a,0x1e},{0x48}},
+	{{0x3a,0x1f},{0x20}},
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0x3a,0x0f},{0x58}},	//1.3EV
+	{{0x3a,0x10},{0x50}},
+	{{0x3a,0x11},{0x91}},
+	{{0x3a,0x1b},{0x58}},
+	{{0x3a,0x1e},{0x50}},
+	{{0x3a,0x1f},{0x20}},
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0x3a,0x0f},{0x60}},	//1.7EV
+	{{0x3a,0x10},{0x58}},
+	{{0x3a,0x11},{0xa0}},
+	{{0x3a,0x1b},{0x60}},
+	{{0x3a,0x1e},{0x58}},
+	{{0x3a,0x1f},{0x20}},
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+
+	{{0x43,	0x00} , {0x30}}	//YUYV
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+
+	{{0x43,	0x00} , {0x31}}	//YVYU
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+
+	{{0x43,	0x00} , {0x33}}	//VYUY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+
+	{{0x43,	0x00} , {0x32}}	//UYVY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+		data[i] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+//	unsigned char rd;
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		if(vals->reg_num[0] == 0xff && vals->reg_num[0] == 0xff) {
+			msleep(vals->value[0] * 256 + vals->value[1]);
+		}
+		else {
+			ret = sensor_write(sd, vals->reg_num, vals->value);
+			if (ret < 0)
+			{
+				csi_dev_err("sensor_write_err!\n");
+				return ret;
+			}
+		}
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+	int ret;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//disable io oe
+			csi_dev_print("disalbe oe!\n");
+			ret = sensor_write_array(sd, sensor_oe_disable_regs , ARRAY_SIZE(sensor_oe_disable_regs));
+			if(ret < 0)
+				csi_dev_err("disalbe oe falied!\n");
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+//			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+//			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x0A;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x56)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* qsxga: 2590*1944 */
+	{
+		.width			= QSXGA_WIDTH,
+		.height 		= QSXGA_HEIGHT,
+		.regs			= sensor_qsxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_qsxga_regs),
+		.set_size		= NULL,
+	},
+	/* qxga: 2048*1536 */
+	{
+		.width			= QXGA_WIDTH,
+		.height 		= QXGA_HEIGHT,
+		.regs			= sensor_qxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_qxga_regs),
+		.set_size		= NULL,
+	},
+	/* 1080P */
+	{
+		.width			= P1080P_WIDTH,
+		.height			= P1080P_HEIGHT,
+		.regs 			= sensor_1080p_regs,
+		.regs_size	= ARRAY_SIZE(sensor_1080p_regs),
+		.set_size		= NULL,
+	},
+	/* UXGA */
+	{
+		.width			= UXGA_WIDTH,
+		.height			= UXGA_HEIGHT,
+		.regs 			= sensor_uxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_uxga_regs),
+		.set_size		= NULL,
+	},
+	/* SXGA */
+	{
+		.width			= SXGA_WIDTH,
+		.height 		= SXGA_HEIGHT,
+		.regs			= sensor_sxga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_sxga_regs),
+		.set_size		= NULL,
+	},
+	/* 720p */
+	{
+		.width			= P720_WIDTH,
+		.height			= P720_HEIGHT,
+		.regs 			= sensor_720p_regs,
+		.regs_size	= ARRAY_SIZE(sensor_720p_regs),
+		.set_size		= NULL,
+	},
+	/* XGA */
+	{
+		.width			= XGA_WIDTH,
+		.height 		= XGA_HEIGHT,
+		.regs			= sensor_xga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_xga_regs),
+		.set_size		= NULL,
+	},
+	/* SVGA */
+	{
+		.width			= SVGA_WIDTH,
+		.height			= SVGA_HEIGHT,
+		.regs				= sensor_svga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_svga_regs),
+		.set_size		= NULL,
+	},
+	/* VGA */
+	{
+		.width			= VGA_WIDTH,
+		.height			= VGA_HEIGHT,
+		.regs				= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size		= NULL,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+static int sensor_set_exposure(struct v4l2_subdev *sd,
+	unsigned char *gain,unsigned char *exposurelow,unsigned char *exposuremid,unsigned char *exposurehigh)
+{
+	#define CAPTURE_FRAMERATE 375
+	#define PREVIEW_FRAMERATE 1500
+
+	int ret;
+	unsigned char ogain,oexposurelow,oexposuremid,oexposurehigh;
+	int lines_10ms;
+	int capture_maxLines;
+	int preview_maxlines;
+	long capture_Exposure;
+	long capture_exposure_gain;
+	long previewExposure;
+	long capture_gain;
+
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x35;
+	regs.reg_num[1] = 0x03;
+	regs.value[0] = 0x07;
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err !\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x35;
+	regs.reg_num[1] = 0x0b;
+	regs.value[0] = 0;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+	ogain = regs.value[0];
+
+	regs.reg_num[0] = 0x35;
+	regs.reg_num[1] = 0x02;
+	regs.value[0] = 0;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+	oexposurelow = regs.value[0];
+
+	regs.reg_num[0] = 0x35;
+	regs.reg_num[1] = 0x01;
+	regs.value[0] = 0;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+	oexposuremid = regs.value[0];
+
+	regs.reg_num[0] = 0x35;
+	regs.reg_num[1] = 0x00;
+	regs.value[0] = 0;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+	oexposurehigh = regs.value[0];
+
+	preview_maxlines = 984;
+	capture_maxLines = 1968;
+	lines_10ms = CAPTURE_FRAMERATE * capture_maxLines/10000*13/12;
+
+	previewExposure = ((unsigned int)(oexposurehigh))<<12 ;
+	previewExposure += ((unsigned int)oexposuremid)<<4 ;
+	previewExposure += (oexposurelow >>4);
+	if(0 == preview_maxlines || 0== lines_10ms)
+	{
+		return 0;
+	}
+
+	capture_Exposure =
+		((previewExposure*(CAPTURE_FRAMERATE)*(capture_maxLines))/
+	(((preview_maxlines)*(PREVIEW_FRAMERATE))))*6/5;
+
+	capture_gain = ogain ;
+	//if(AWB_NIGHT == m_CurrentEnvi)
+	//{
+	//capture_exposure_gain = ulCapture_Exposure * capture_gain*2;
+	//*2
+	//}else
+	//{
+	capture_exposure_gain = capture_Exposure * capture_gain;
+	//}
+	if(capture_exposure_gain <
+		((signed int)(capture_maxLines)*16))
+	{
+		capture_Exposure = capture_exposure_gain/16;
+		if (capture_Exposure > lines_10ms)
+		{
+			capture_Exposure /= lines_10ms;
+			capture_Exposure *= lines_10ms;
+		}
+	} else {
+		capture_Exposure = capture_maxLines;
+	}
+	if(capture_Exposure == 0)
+	{
+		capture_Exposure = 1;
+	}
+	capture_gain =(capture_exposure_gain*2/capture_Exposure + 1)/2;
+	*exposurelow = ((unsigned char)capture_Exposure)<<4;
+	*exposuremid = (unsigned char)(capture_Exposure >> 4) & 0xff;
+	*exposurehigh = (unsigned char)(capture_Exposure >> 12);
+	*gain =(unsigned char) capture_gain;
+
+	return 0;
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	unsigned char gain,exposurelow,exposuremid,exposurehigh;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct regval_list regs;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+
+	gain = 0;
+	exposurelow = 0;
+	exposuremid = 0;
+	exposurehigh = 0;
+
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+	if(!((wsize->width == VGA_WIDTH)&&(wsize->height == VGA_HEIGHT)))
+	{
+		ret = sensor_set_exposure(sd,&gain,&exposurelow,&exposuremid,&exposurehigh);
+		if (ret)
+		{
+			csi_dev_err("sensor_set_exposure err !\n");
+			return ret;
+		}
+	}
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+
+	{
+		//printk("gain:0x%x,exposurelow:0x%x,exposuremid:0x%x,exposurehigh:0x%x\n",gain,exposurelow,exposuremid,exposurehigh);
+		regs.reg_num[0] = 0x35;
+		regs.reg_num[1] = 0x0b;
+		regs.value[0] = gain;
+		ret = sensor_write(sd, regs.reg_num, regs.value);
+		if (ret < 0) {
+			csi_dev_err("sensor_write gain err !\n");
+			return ret;
+		}
+
+		regs.reg_num[0] = 0x35;
+		regs.reg_num[1] = 0x02;
+		regs.value[0] = exposurelow;
+		ret = sensor_write(sd, regs.reg_num, regs.value);
+		if (ret < 0) {
+			csi_dev_err("sensor_write exposurelow err !\n");
+			return ret;
+		}
+
+		regs.reg_num[0] = 0x35;
+		regs.reg_num[1] = 0x01;
+		regs.value[0] = exposuremid;
+		ret = sensor_write(sd, regs.reg_num, regs.value);
+		if (ret < 0) {
+			csi_dev_err("sensor_write exposuremid err !\n");
+			return ret;
+		}
+
+		regs.reg_num[0] = 0x35;
+		regs.reg_num[1] = 0x00;
+		regs.value[0] = exposurehigh;
+		ret = sensor_write(sd, regs.reg_num, regs.value);
+		if (ret < 0) {
+			csi_dev_err("sensor_write exposurehigh err !\n");
+			return ret;
+		}
+
+		if (wsize->set_size)
+		{
+			ret = wsize->set_size(sd);
+			if (ret < 0)
+				return ret;
+		}
+	}
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	msleep(600);
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+
+	if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE/2;
+	}
+	else {
+		cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+	}
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+//	struct v4l2_captureparm *cp = &parms->parm.capture;
+//	struct v4l2_fract *tpf = &cp->timeperframe;
+//	struct sensor_info *info = to_state(sd);
+//	int div;
+
+//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+//		return -EINVAL;
+//	if (cp->extendedmode != 0)
+//		return -EINVAL;
+
+//	if (tpf->numerator == 0 || tpf->denominator == 0)
+//		div = 1;  /* Reset to full rate */
+//	else {
+//		if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE/2)/tpf->denominator;
+//		}
+//		else {
+//			div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
+//		}
+//	}
+//
+//	if (div == 0)
+//		div = 1;
+//	else if (div > 8)
+//		div = 8;
+//
+//	switch()
+//
+//	info->clkrc = (info->clkrc & 0x80) | div;
+//	tpf->numerator = 1;
+//	tpf->denominator = sensor_FRAME_RATE/div;
+//
+//	sensor_write(sd, REG_CLKRC, info->clkrc);
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+//	case V4L2_CID_BRIGHTNESS:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_CONTRAST:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x38;
+	regs.reg_num[1] = 0x21;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x38;
+	regs.reg_num[1] = 0x21;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xf9;
+			break;
+		case 1:
+			regs.value[0] |= 0x06;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+	msleep(100);
+
+	info->hflip = value;
+
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x38;
+	regs.reg_num[1] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<1);
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x38;
+	regs.reg_num[1] = 0x20;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xf9;
+			break;
+		case 1:
+			regs.value[0] |= 0x06;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->vflip = value;
+
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	/*
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x13;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x01;
+	if (regs.value[0] == 0x01) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	*/
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	/*
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0x30;
+	regs.reg_num[1] = 0x13;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x01;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0xfe;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+	msleep(100);
+	info->autoexp = value;
+	*/
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+//	int ret;
+//	struct sensor_info *info = to_state(sd);
+//	struct regval_list regs;
+//
+//	regs.reg_num[0] = 0x03;
+//	regs.reg_num[1] = 0x1a;
+//	ret = sensor_read(sd, regs.reg_num, regs.value);
+//	if (ret < 0) {
+//		csi_dev_err("sensor_read err at sensor_g_autowb!\n");
+//		return ret;
+//	}
+//
+//	regs.value[0] &= (1<<7);
+//	regs.value[0] = regs.value[0]>>7;		//0x031a bit7 is awb enable
+//
+//	*value = regs.value[0];
+//	info->autowb = *value;
+
+	return -EINVAL;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x34;
+	regs.reg_num[1] = 0x06;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] |= 0x01;
+		break;
+	case 1:
+		regs.value[0] &= 0xfe;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+	msleep(10);
+	info->autowb = value;
+
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+	msleep(10);
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+	msleep(10);
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+	msleep(10);
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+	msleep(10);
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+	msleep(10);
+	info->clrfx = value;
+
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "ov5640", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "ov5640",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
+
diff --git a/drivers/media/video/sun4i_csi/device/ov7670.c b/drivers/media/video/sun4i_csi/device/ov7670.c
new file mode 100644
index 0000000..18db99d
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/ov7670.c
@@ -0,0 +1,1920 @@
+/*
+ * A V4L2 driver for OmniVision OV7670 cameras.
+ *
+ * Copyright 2006 One Laptop Per Child Association, Inc.  Written
+ * by Jonathan Corbet with substantial inspiration from Mark
+ * McClelland's ovcamchip code.
+ *
+ * Copyright 2006-7 Jonathan Corbet <corbet@lwn.net>
+ *
+ * This file may be distributed under the terms of the GNU General
+ * Public License, version 2.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("Jonathan Corbet <corbet@lwn.net>");
+MODULE_DESCRIPTION("A low-level driver for OmniVision ov7670 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][OV7670]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][OV7670]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][OV7670]"x,##arg)
+#define MCLK (27*1000*1000)
+#define VREF_POL	CSI_LOW
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0 for csi0
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define OV7670_FRAME_RATE 30
+
+/*
+ * The 7670 sits on i2c with ID 0x42
+ */
+#define OV7670_I2C_ADDR 0x42
+
+/* Registers */
+#define REG_GAIN	0x00	/* Gain lower 8 bits (rest in vref) */
+#define REG_BLUE	0x01	/* blue gain */
+#define REG_RED		0x02	/* red gain */
+#define REG_VREF	0x03	/* Pieces of GAIN, VSTART, VSTOP */
+#define REG_COM1	0x04	/* Control 1 */
+#define  COM1_CCIR656	  0x40  /* CCIR656 enable */
+#define REG_BAVE	0x05	/* U/B Average level */
+#define REG_GbAVE	0x06	/* Y/Gb Average level */
+#define REG_AECHH	0x07	/* AEC MS 5 bits */
+#define REG_RAVE	0x08	/* V/R Average level */
+#define REG_COM2	0x09	/* Control 2 */
+#define  COM2_SSLEEP	  0x10	/* Soft sleep mode */
+#define REG_PID		0x0a	/* Product ID MSB */
+#define REG_VER		0x0b	/* Product ID LSB */
+#define REG_COM3	0x0c	/* Control 3 */
+#define  COM3_SWAP	  0x40	  /* Byte swap */
+#define  COM3_SCALEEN	  0x08	  /* Enable scaling */
+#define  COM3_DCWEN	  0x04	  /* Enable downsamp/crop/window */
+#define REG_COM4	0x0d	/* Control 4 */
+#define REG_COM5	0x0e	/* All "reserved" */
+#define REG_COM6	0x0f	/* Control 6 */
+#define REG_AECH	0x10	/* More bits of AEC value */
+#define REG_CLKRC	0x11	/* Clocl control */
+#define   CLK_EXT	  0x40	  /* Use external clock directly */
+#define   CLK_SCALE	  0x3f	  /* Mask for internal clock scale */
+#define REG_COM7	0x12	/* Control 7 */
+#define   COM7_RESET	  0x80	  /* Register reset */
+#define   COM7_FMT_MASK	  0x38
+#define   COM7_FMT_VGA	  0x00
+#define	  COM7_FMT_CIF	  0x20	  /* CIF format */
+#define   COM7_FMT_QVGA	  0x10	  /* QVGA format */
+#define   COM7_FMT_QCIF	  0x08	  /* QCIF format */
+#define	  COM7_RGB	  0x04	  /* bits 0 and 2 - RGB format */
+#define	  COM7_YUV	  0x00	  /* YUV */
+#define	  COM7_BAYER	  0x01	  /* Bayer format */
+#define	  COM7_PBAYER	  0x05	  /* "Processed bayer" */
+#define REG_COM8	0x13	/* Control 8 */
+#define   COM8_FASTAEC	  0x80	  /* Enable fast AGC/AEC */
+#define   COM8_AECSTEP	  0x40	  /* Unlimited AEC step size */
+#define   COM8_BFILT	  0x20	  /* Band filter enable */
+#define   COM8_AGC	  0x04	  /* Auto gain enable */
+#define   COM8_AWB	  0x02	  /* White balance enable */
+#define   COM8_AEC	  0x01	  /* Auto exposure enable */
+#define REG_COM9	0x14	/* Control 9  - gain ceiling */
+#define REG_COM10	0x15	/* Control 10 */
+#define   COM10_HSYNC	  0x40	  /* HSYNC instead of HREF */
+#define   COM10_PCLK_HB	  0x20	  /* Suppress PCLK on horiz blank */
+#define   COM10_HREF_REV  0x08	  /* Reverse HREF */
+#define   COM10_VS_LEAD	  0x04	  /* VSYNC on clock leading edge */
+#define   COM10_VS_NEG	  0x02	  /* VSYNC negative */
+#define   COM10_HS_NEG	  0x01	  /* HSYNC negative */
+#define REG_HSTART	0x17	/* Horiz start high bits */
+#define REG_HSTOP	0x18	/* Horiz stop high bits */
+#define REG_VSTART	0x19	/* Vert start high bits */
+#define REG_VSTOP	0x1a	/* Vert stop high bits */
+#define REG_PSHFT	0x1b	/* Pixel delay after HREF */
+#define REG_MIDH	0x1c	/* Manuf. ID high */
+#define REG_MIDL	0x1d	/* Manuf. ID low */
+#define REG_MVFP	0x1e	/* Mirror / vflip */
+#define   MVFP_MIRROR	  0x20	  /* Mirror image */
+#define   MVFP_FLIP	  0x10	  /* Vertical flip */
+
+#define REG_AEW		0x24	/* AGC upper limit */
+#define REG_AEB		0x25	/* AGC lower limit */
+#define REG_VPT		0x26	/* AGC/AEC fast mode op region */
+#define REG_HSYST	0x30	/* HSYNC rising edge delay */
+#define REG_HSYEN	0x31	/* HSYNC falling edge delay */
+#define REG_HREF	0x32	/* HREF pieces */
+#define REG_TSLB	0x3a	/* lots of stuff */
+#define   TSLB_YLAST	  0x04	  /* UYVY or VYUY - see com13 */
+#define REG_COM11	0x3b	/* Control 11 */
+#define   COM11_NIGHT	  0x80	  /* NIght mode enable */
+#define   COM11_NMFR	  0x60	  /* Two bit NM frame rate */
+#define   COM11_HZAUTO	  0x10	  /* Auto detect 50/60 Hz */
+#define	  COM11_50HZ	  0x08	  /* Manual 50Hz select */
+#define   COM11_EXP	  0x02
+#define REG_COM12	0x3c	/* Control 12 */
+#define   COM12_HREF	  0x80	  /* HREF always */
+#define REG_COM13	0x3d	/* Control 13 */
+#define   COM13_GAMMA	  0x80	  /* Gamma enable */
+#define	  COM13_UVSAT	  0x40	  /* UV saturation auto adjustment */
+#define   COM13_UVSWAP	  0x01	  /* V before U - w/TSLB */
+#define REG_COM14	0x3e	/* Control 14 */
+#define   COM14_DCWEN	  0x10	  /* DCW/PCLK-scale enable */
+#define REG_EDGE	0x3f	/* Edge enhancement factor */
+#define REG_COM15	0x40	/* Control 15 */
+#define   COM15_R10F0	  0x00	  /* Data range 10 to F0 */
+#define	  COM15_R01FE	  0x80	  /*            01 to FE */
+#define   COM15_R00FF	  0xc0	  /*            00 to FF */
+#define   COM15_RGB565	  0x10	  /* RGB565 output */
+#define   COM15_RGB555	  0x30	  /* RGB555 output */
+#define REG_COM16	0x41	/* Control 16 */
+#define   COM16_AWBGAIN   0x08	  /* AWB gain enable */
+#define REG_COM17	0x42	/* Control 17 */
+#define   COM17_AECWIN	  0xc0	  /* AEC window - must match COM4 */
+#define   COM17_CBAR	  0x08	  /* DSP Color bar */
+
+/*
+ * This matrix defines how the colors are generated, must be
+ * tweaked to adjust hue and saturation.
+ *
+ * Order: v-red, v-green, v-blue, u-red, u-green, u-blue
+ *
+ * They are nine-bit signed quantities, with the sign bit
+ * stored in 0x58.  Sign for v-red is bit 0, and up from there.
+ */
+#define	REG_CMATRIX_BASE 0x4f
+#define   CMATRIX_LEN 6
+#define REG_CMATRIX_SIGN 0x58
+
+
+#define REG_BRIGHT	0x55	/* Brightness */
+#define REG_CONTRAS	0x56	/* Contrast control */
+
+#define REG_GFIX	0x69	/* Fix gain control */
+
+#define REG_REG76	0x76	/* OV's name */
+#define   R76_BLKPCOR	  0x80	  /* Black pixel correction enable */
+#define   R76_WHTPCOR	  0x40	  /* White pixel correction enable */
+
+#define REG_RGB444	0x8c	/* RGB 444 control */
+#define   R444_ENABLE	  0x02	  /* Turn on RGB444, overrides 5x5 */
+#define   R444_RGBX	  0x01	  /* Empty nibble at end */
+
+#define REG_HAECC1	0x9f	/* Hist AEC/AGC control 1 */
+#define REG_HAECC2	0xa0	/* Hist AEC/AGC control 2 */
+
+#define REG_BD50MAX	0xa5	/* 50hz banding step limit */
+#define REG_HAECC3	0xa6	/* Hist AEC/AGC control 3 */
+#define REG_HAECC4	0xa7	/* Hist AEC/AGC control 4 */
+#define REG_HAECC5	0xa8	/* Hist AEC/AGC control 5 */
+#define REG_HAECC6	0xa9	/* Hist AEC/AGC control 6 */
+#define REG_HAECC7	0xaa	/* Hist AEC/AGC control 7 */
+#define REG_BD60MAX	0xab	/* 60hz banding step limit */
+
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct ov7670_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+struct ov7670_info {
+	struct v4l2_subdev sd;
+	struct ov7670_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	unsigned char sat;		/* Saturation value */
+	int hue;			/* Hue value */
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct ov7670_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ov7670_info, sd);
+}
+
+
+
+/*
+ * The default register settings, as obtained from OmniVision.  There
+ * is really no making sense of most of these - lots of "reserved" values
+ * and such.
+ *
+ * These settings give VGA YUYV.
+ */
+
+struct regval_list {
+	unsigned char reg_num;
+	unsigned char value;
+};
+
+static struct regval_list ov7670_default_regs[] = {
+	{ REG_COM7, COM7_RESET },
+/*
+ * Clock scale: 3 = 15fps
+ *              2 = 20fps
+ *              1 = 30fps
+ */
+	{ REG_CLKRC, 0x1 },	/* OV: clock scale (30 fps) */
+	{ REG_TSLB,  0x04 },	/* OV */
+	{ REG_COM7, 0 },	/* VGA */
+	/*
+	 * Set the hardware window.  These values from OV don't entirely
+	 * make sense - hstop is less than hstart.  But they work...
+	 */
+	{ REG_HSTART, 0x13 },	{ REG_HSTOP, 0x01 },
+	{ REG_HREF, 0xb6 },	{ REG_VSTART, 0x02 },
+	{ REG_VSTOP, 0x7a },	{ REG_VREF, 0x0a },
+
+	{ REG_COM3, 0 },	{ REG_COM14, 0 },
+	/* Mystery scaling numbers */
+	{ 0x70, 0x3a },		{ 0x71, 0x35 },
+	{ 0x72, 0x11 },		{ 0x73, 0xf0 },
+	{ 0xa2, 0x02 },		{ REG_COM10, 0x0 },
+
+	/* Gamma curve values */
+	{ 0x7a, 0x20 },		{ 0x7b, 0x10 },
+	{ 0x7c, 0x1e },		{ 0x7d, 0x35 },
+	{ 0x7e, 0x5a },		{ 0x7f, 0x69 },
+	{ 0x80, 0x76 },		{ 0x81, 0x80 },
+	{ 0x82, 0x88 },		{ 0x83, 0x8f },
+	{ 0x84, 0x96 },		{ 0x85, 0xa3 },
+	{ 0x86, 0xaf },		{ 0x87, 0xc4 },
+	{ 0x88, 0xd7 },		{ 0x89, 0xe8 },
+
+	/* AGC and AEC parameters.  Note we start by disabling those features,
+	   then turn them only after tweaking the values. */
+	{ REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_BFILT },
+	{ REG_GAIN, 0 },	{ REG_AECH, 0 },
+	{ REG_COM4, 0x40 }, /* magic reserved bit */
+	{ REG_COM9, 0x18 }, /* 4x gain + magic rsvd bit */
+	{ REG_BD50MAX, 0x05 },	{ REG_BD60MAX, 0x07 },
+	{ REG_AEW, 0x95 },	{ REG_AEB, 0x33 },
+	{ REG_VPT, 0xe3 },	{ REG_HAECC1, 0x78 },
+	{ REG_HAECC2, 0x68 },	{ 0xa1, 0x03 }, /* magic */
+	{ REG_HAECC3, 0xd8 },	{ REG_HAECC4, 0xd8 },
+	{ REG_HAECC5, 0xf0 },	{ REG_HAECC6, 0x90 },
+	{ REG_HAECC7, 0x94 },
+	{ REG_COM8, COM8_FASTAEC|COM8_AECSTEP|COM8_BFILT|COM8_AGC|COM8_AEC },
+
+	/* Almost all of these are magic "reserved" values.  */
+	{ REG_COM5, 0x61 },	{ REG_COM6, 0x4b },
+	{ 0x16, 0x02 },		{ REG_MVFP, 0x07 },
+	{ 0x21, 0x02 },		{ 0x22, 0x91 },
+	{ 0x29, 0x07 },		{ 0x33, 0x0b },
+	{ 0x35, 0x0b },		{ 0x37, 0x1d },
+	{ 0x38, 0x71 },		{ 0x39, 0x2a },
+	{ REG_COM12, 0x78 },	{ 0x4d, 0x40 },
+	{ 0x4e, 0x20 },		{ REG_GFIX, 0 },
+	{ 0x6b, 0x4a },		{ 0x74, 0x10 },
+	{ 0x8d, 0x4f },		{ 0x8e, 0 },
+	{ 0x8f, 0 },		{ 0x90, 0 },
+	{ 0x91, 0 },		{ 0x96, 0 },
+	{ 0x9a, 0 },		{ 0xb0, 0x84 },
+	{ 0xb1, 0x0c },		{ 0xb2, 0x0e },
+	{ 0xb3, 0x82 },		{ 0xb8, 0x0a },
+
+	/* More reserved magic, some of which tweaks white balance */
+	{ 0x43, 0x0a },		{ 0x44, 0xf0 },
+	{ 0x45, 0x34 },		{ 0x46, 0x58 },
+	{ 0x47, 0x28 },		{ 0x48, 0x3a },
+	{ 0x59, 0x88 },		{ 0x5a, 0x88 },
+	{ 0x5b, 0x44 },		{ 0x5c, 0x67 },
+	{ 0x5d, 0x49 },		{ 0x5e, 0x0e },
+	{ 0x6c, 0x0a },		{ 0x6d, 0x55 },
+	{ 0x6e, 0x11 },		{ 0x6f, 0x9f }, /* "9e for advance AWB" */
+	{ 0x6a, 0x40 },		{ REG_BLUE, 0x40 },
+	{ REG_RED, 0x60 },
+	{ REG_COM8, COM8_FASTAEC|COM8_AECSTEP|COM8_BFILT|COM8_AGC|COM8_AEC|COM8_AWB },
+
+	/* Matrix coefficients */
+	{ 0x4f, 0x80 },		{ 0x50, 0x80 },
+	{ 0x51, 0 },		{ 0x52, 0x22 },
+	{ 0x53, 0x5e },		{ 0x54, 0x80 },
+	{ 0x58, 0x9e },
+
+	{ REG_COM16, COM16_AWBGAIN },	{ REG_EDGE, 0 },
+	{ 0x75, 0x05 },		{ 0x76, 0xe1 },
+	{ 0x4c, 0 },		{ 0x77, 0x01 },
+	{ REG_COM13, 0xc3 },	{ 0x4b, 0x09 },
+	{ 0xc9, 0x60 },		{ REG_COM16, 0x38 },
+	{ 0x56, 0x40 },
+
+	{ 0x34, 0x11 },		{ REG_COM11, COM11_EXP|COM11_HZAUTO },
+	{ 0xa4, 0x88 },		{ 0x96, 0 },
+	{ 0x97, 0x30 },		{ 0x98, 0x20 },
+	{ 0x99, 0x30 },		{ 0x9a, 0x84 },
+	{ 0x9b, 0x29 },		{ 0x9c, 0x03 },
+	{ 0x9d, 0x4c },		{ 0x9e, 0x3f },
+	{ 0x78, 0x04 },
+
+	/* Extra-weird stuff.  Some sort of multiplexor register */
+	{ 0x79, 0x01 },		{ 0xc8, 0xf0 },
+	{ 0x79, 0x0f },		{ 0xc8, 0x00 },
+	{ 0x79, 0x10 },		{ 0xc8, 0x7e },
+	{ 0x79, 0x0a },		{ 0xc8, 0x80 },
+	{ 0x79, 0x0b },		{ 0xc8, 0x01 },
+	{ 0x79, 0x0c },		{ 0xc8, 0x0f },
+	{ 0x79, 0x0d },		{ 0xc8, 0x20 },
+	{ 0x79, 0x09 },		{ 0xc8, 0x80 },
+	{ 0x79, 0x02 },		{ 0xc8, 0xc0 },
+	{ 0x79, 0x03 },		{ 0xc8, 0x40 },
+	{ 0x79, 0x05 },		{ 0xc8, 0x30 },
+	{ 0x79, 0x26 },
+
+	{ 0xff, 0xff },	/* END MARKER */
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ * RGB656 and YUV422 come from OV; RGB444 is homebrewed.
+ *
+ * IMPORTANT RULE: the first entry must be for COM7, see ov7670_s_fmt for why.
+ */
+
+
+static struct regval_list ov7670_fmt_yuv422_yuyv[] = {
+	{ REG_COM7, 0x0 },  /* Selects YUV mode */
+	{ REG_TSLB,  0x00 },	/* bit[3:2] YUYV */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R00FF },
+	{ REG_COM9, 0x18 }, /* 4x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0x80 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0x80 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x22 }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0x5e }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0x80 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_yuv422_yvyu[] = {
+	{ REG_COM7, 0x0 },  /* Selects YUV mode */
+	{ REG_TSLB,  0x04 },	/* bit[3:2] YVYU */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R00FF },
+	{ REG_COM9, 0x18 }, /* 4x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0x80 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0x80 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x22 }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0x5e }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0x80 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT|COM13_UVSWAP },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_yuv422_vyuy[] = {
+	{ REG_COM7, 0x0 },  /* Selects YUV mode */
+	{ REG_TSLB,  0x08 },	/* bit[3:2] VYUY */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R00FF },
+	{ REG_COM9, 0x18 }, /* 4x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0x80 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0x80 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x22 }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0x5e }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0x80 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT|TSLB_YLAST },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_yuv422_uyvy[] = {
+	{ REG_COM7, 0x0 },  /* Selects YUV mode */
+	{ REG_TSLB,  0x0c },	/* bit[3:2] UYVY */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R00FF },
+	{ REG_COM9, 0x18 }, /* 4x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0x80 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0x80 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x22 }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0x5e }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0x80 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT|COM13_UVSWAP|TSLB_YLAST },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_rgb565[] = {
+	{ REG_COM7, COM7_RGB },	/* Selects RGB mode */
+	{ REG_RGB444, 0 },	/* No RGB444 please */
+	{ REG_COM1, 0x0 },	/* CCIR601 */
+	{ REG_COM15, COM15_RGB565 },
+	{ REG_COM9, 0x38 }, 	/* 16x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0xb3 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0xb3 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x3d }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0xa7 }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0xe4 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT },
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_rgb444[] = {
+	{ REG_COM7, COM7_RGB },	/* Selects RGB mode */
+	{ REG_RGB444, R444_ENABLE },	/* Enable xxxxrrrr ggggbbbb */
+	{ REG_COM1, 0x0 },	/* CCIR601 */
+	{ REG_COM15, COM15_R01FE|COM15_RGB565 }, /* Data range needed? */
+	{ REG_COM9, 0x38 }, 	/* 16x gain ceiling; 0x8 is reserved bit */
+	{ 0x4f, 0xb3 }, 	/* "matrix coefficient 1" */
+	{ 0x50, 0xb3 }, 	/* "matrix coefficient 2" */
+	{ 0x51, 0    },		/* vb */
+	{ 0x52, 0x3d }, 	/* "matrix coefficient 4" */
+	{ 0x53, 0xa7 }, 	/* "matrix coefficient 5" */
+	{ 0x54, 0xe4 }, 	/* "matrix coefficient 6" */
+	{ REG_COM13, COM13_GAMMA|COM13_UVSAT|0x2 },  /* Magic rsvd bit */
+	{ 0xff, 0xff },
+};
+
+static struct regval_list ov7670_fmt_raw[] = {
+	{ REG_COM7, COM7_BAYER },
+	{ REG_COM13, 0x08 }, /* No gamma, magic rsvd bit */
+	{ REG_COM16, 0x3d }, /* Edge enhancement, denoise */
+	{ REG_REG76, 0xe1 }, /* Pix correction, magic rsvd */
+	{ 0xff, 0xff },
+};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ * Note that there are two versions of these.  On the XO 1, the
+ * i2c controller only does SMBUS, so that's what we use.  The
+ * ov7670 is not really an SMBUS device, though, so the communication
+ * is not always entirely reliable.
+ */
+#ifdef CONFIG_OLPC_XO_1
+static int ov7670_read(struct v4l2_subdev *sd, unsigned char reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret >= 0) {
+		*value = (unsigned char)ret;
+		ret = 0;
+	}
+	return ret;
+}
+
+
+static int ov7670_write(struct v4l2_subdev *sd, unsigned char reg,
+		unsigned char value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = i2c_smbus_write_byte_data(client, reg, value);
+
+	if (reg == REG_COM7 && (value & COM7_RESET))
+		msleep(5);  /* Wait for reset to run */
+	return ret;
+}
+
+#else /* ! CONFIG_OLPC_XO_1 */
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int ov7670_read(struct v4l2_subdev *sd, unsigned char reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data = reg;
+	struct i2c_msg msg;
+	int ret;
+
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 1;
+	msg.buf = &data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		printk(KERN_ERR "Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+	msg.flags = I2C_M_RD;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		*value = data;
+		ret = 0;
+	}
+	return ret;
+}
+
+
+static int ov7670_write(struct v4l2_subdev *sd, unsigned char reg,
+		unsigned char value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[2] = { reg, value };
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0)
+		ret = 0;
+	if (reg == REG_COM7 && (value & COM7_RESET))
+		msleep(5);  /* Wait for reset to run */
+	return ret;
+}
+#endif /* CONFIG_OLPC_XO_1 */
+
+
+/*
+ * Write a list of register settings; ff/ff stops the process.
+ */
+static int ov7670_write_array(struct v4l2_subdev *sd, struct regval_list *vals)
+{
+	while (vals->reg_num != 0xff || vals->value != 0xff) {
+		int ret = ov7670_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			return ret;
+		vals++;
+	}
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int ov7670_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct ov7670_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ov7670_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct ov7670_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+//	ov7670_write(sd, REG_COM7, COM7_RESET);
+//	msleep(1);
+	return 0;
+}
+
+static int ov7670_detect(struct v4l2_subdev *sd)
+{
+	unsigned char v;
+	int ret;
+
+//	ret = ov7670_init(sd, 0);
+//	if (ret < 0)
+//		return ret;
+	ret = ov7670_read(sd, REG_MIDH, &v);
+	if (ret < 0)
+		return ret;
+	if (v != 0x7f) /* OV manuf. id. */
+		return -ENODEV;
+	ret = ov7670_read(sd, REG_MIDL, &v);
+	if (ret < 0)
+		return ret;
+	if (v != 0xa2)
+		return -ENODEV;
+	/*
+	 * OK, we know we have an OmniVision chip...but which one?
+	 */
+	ret = ov7670_read(sd, REG_PID, &v);
+	if (ret < 0)
+		return ret;
+	if (v != 0x76)  /* PID + VER = 0x76 / 0x73 */
+		return -ENODEV;
+	ret = ov7670_read(sd, REG_VER, &v);
+	if (ret < 0)
+		return ret;
+	if (v != 0x73)  /* PID + VER = 0x76 / 0x73 */
+		return -ENODEV;
+	return 0;
+}
+
+static int ov7670_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("ov7670_init\n");
+
+	/* Make sure it's an ov7670 */
+	ret = ov7670_detect(sd);
+	if (ret) {
+		csi_err("chip found is not an ov7670 chip.\n");
+		return ret;
+	}
+	return ov7670_write_array(sd, ov7670_default_regs);
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct ov7670_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct ov7670_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+		return ret;
+}
+
+
+
+
+/*
+ * Store information about the video data format.  The color matrix
+ * is deeply tied into the format, so keep the relevant values here.
+ * The magic matrix nubmers come from OmniVision.
+ */
+static struct ov7670_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int cmatrix[CMATRIX_LEN];
+	int bpp;   /* Bytes per pixel */
+} ov7670_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= ov7670_fmt_yuv422_yuyv,
+		.cmatrix	= { 128, -128, 0, -34, -94, 128 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= ov7670_fmt_yuv422_yvyu,
+		.cmatrix	= { 128, -128, 0, -34, -94, 128 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= ov7670_fmt_yuv422_uyvy,
+		.cmatrix	= { 128, -128, 0, -34, -94, 128 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= ov7670_fmt_yuv422_vyuy,
+		.cmatrix	= { 128, -128, 0, -34, -94, 128 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "RGB 444",
+		.mbus_code	= V4L2_MBUS_FMT_RGB444_2X8_PADHI_LE,//linux-3.0
+		.regs		= ov7670_fmt_rgb444,
+		.cmatrix	= { 179, -179, 0, -61, -176, 228 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "RGB 565",
+		.mbus_code	= V4L2_MBUS_FMT_RGB565_2X8_LE,//linux-3.0
+		.regs		= ov7670_fmt_rgb565,
+		.cmatrix	= { 179, -179, 0, -61, -176, 228 },
+		.bpp		= 2,
+	},
+	{
+		.desc		= "Raw RGB Bayer",
+		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+		.regs 		= ov7670_fmt_raw,
+		.cmatrix	= { 0, 0, 0, 0, 0, 0 },
+		.bpp		= 1
+	},
+};
+#define N_OV7670_FMTS ARRAY_SIZE(ov7670_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+/*
+ * QCIF mode is done (by OV) in a very strange way - it actually looks like
+ * VGA with weird scaling options - they do *not* use the canned QCIF mode
+ * which is allegedly provided by the sensor.  So here's the weird register
+ * settings.
+ */
+static struct regval_list ov7670_qcif_regs[] = {
+	{ REG_COM3, COM3_SCALEEN|COM3_DCWEN },
+	{ REG_COM3, COM3_DCWEN },
+	{ REG_COM14, COM14_DCWEN | 0x01},
+	{ 0x73, 0xf1 },
+	{ 0xa2, 0x52 },
+	{ 0x7b, 0x1c },
+	{ 0x7c, 0x28 },
+	{ 0x7d, 0x3c },
+	{ 0x7f, 0x69 },
+	{ REG_COM9, 0x38 },
+	{ 0xa1, 0x0b },
+	{ 0x74, 0x19 },
+	{ 0x9a, 0x80 },
+	{ 0x43, 0x14 },
+	{ REG_COM13, 0xc0 },
+	{ 0xff, 0xff },
+};
+
+static struct ov7670_win_size {
+	int	width;
+	int	height;
+	unsigned char com7_bit;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+/* h/vref stuff */
+} ov7670_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.com7_bit	= COM7_FMT_VGA,
+		.hstart		= 158,		/* These values from */
+		.hstop		=  14,		/* Omnivision */
+		.vstart		=  10,
+		.vstop		= 490,
+		.regs 		= NULL,
+	},
+	/* CIF */
+	{
+		.width		= CIF_WIDTH,
+		.height		= CIF_HEIGHT,
+		.com7_bit	= COM7_FMT_CIF,
+		.hstart		= 170,		/* Empirically determined */
+		.hstop		=  90,
+		.vstart		=  14,
+		.vstop		= 494,
+		.regs 		= NULL,
+	},
+	/* QVGA */
+	{
+		.width		= QVGA_WIDTH,
+		.height		= QVGA_HEIGHT,
+		.com7_bit	= COM7_FMT_QVGA,
+		.hstart		= 164,		/* Empirically determined */
+		.hstop		=  20,
+		.vstart		=  14,
+		.vstop		= 494,
+		.regs 		= NULL,
+	},
+	/* QCIF */
+	{
+		.width		= QCIF_WIDTH,
+		.height		= QCIF_HEIGHT,
+		.com7_bit	= COM7_FMT_VGA, /* see comment above */
+		.hstart		= 456,		/* Empirically determined */
+		.hstop		=  24,
+		.vstart		=  14,
+		.vstop		= 494,
+		.regs 		= ov7670_qcif_regs,
+	},
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(ov7670_win_sizes))
+
+
+/*
+ * Store a set of start/stop values into the camera.
+ */
+static int ov7670_set_hw(struct v4l2_subdev *sd, int hstart, int hstop,
+		int vstart, int vstop)
+{
+	int ret;
+	unsigned char v;
+/*
+ * Horizontal: 11 bits, top 8 live in hstart and hstop.  Bottom 3 of
+ * hstart are in href[2:0], bottom 3 of hstop in href[5:3].  There is
+ * a mystery "edge offset" value in the top two bits of href.
+ */
+	ret =  ov7670_write(sd, REG_HSTART, (hstart >> 3) & 0xff);
+	ret += ov7670_write(sd, REG_HSTOP, (hstop >> 3) & 0xff);
+	ret += ov7670_read(sd, REG_HREF, &v);
+	v = (v & 0xc0) | ((hstop & 0x7) << 3) | (hstart & 0x7);
+	msleep(10);
+	ret += ov7670_write(sd, REG_HREF, v);
+/*
+ * Vertical: similar arrangement, but only 10 bits.
+ */
+	ret += ov7670_write(sd, REG_VSTART, (vstart >> 2) & 0xff);
+	ret += ov7670_write(sd, REG_VSTOP, (vstop >> 2) & 0xff);
+	ret += ov7670_read(sd, REG_VREF, &v);
+	v = (v & 0xf0) | ((vstop & 0x3) << 2) | (vstart & 0x3);
+	msleep(10);
+	ret += ov7670_write(sd, REG_VREF, v);
+	return ret;
+}
+
+
+static int ov7670_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct ov7670_format_struct *ofmt;
+
+	if (index >= N_OV7670_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = ov7670_formats[index].mbus_code;//linux-3.0
+
+//	ofmt = ov7670_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int ov7670_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct ov7670_format_struct **ret_fmt,
+		struct ov7670_win_size **ret_wsize)
+{
+	int index;
+	struct ov7670_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("ov7670_try_fmt_internal\n");
+	for (index = 0; index < N_OV7670_FMTS; index++)
+		if (ov7670_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+	if (index >= N_OV7670_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = ov7670_formats[0].mbus_code;//linux-3.0
+	}
+	if (ret_fmt != NULL)
+		*ret_fmt = ov7670_formats + index;
+	/*
+	 * Fields: the OV devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+
+
+	for (wsize = ov7670_win_sizes; wsize < ov7670_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+
+
+	if (wsize >= ov7670_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+//pix->bytesperline = pix->width*ov7670_formats[index].bpp;//linux-3.0
+//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+		return 0;
+}
+
+static int ov7670_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return ov7670_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int ov7670_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct ov7670_format_struct *ovfmt;
+	struct ov7670_win_size *wsize;
+	struct ov7670_info *info = to_state(sd);
+	unsigned char com7;
+	csi_dev_dbg("ov7670_s_fmt\n");
+	ret = ov7670_try_fmt_internal(sd, fmt, &ovfmt, &wsize);
+	if (ret)
+		return ret;
+
+	/*
+	 * COM7 is a pain in the ass, it doesn't like to be read then
+	 * quickly written afterward.  But we have everything we need
+	 * to set it absolutely here, as long as the format-specific
+	 * register sets list it first.
+	 */
+	com7 = ovfmt->regs[0].value;
+	com7 |= wsize->com7_bit;
+	ov7670_write(sd, REG_COM7, com7);
+	/*
+	 * Now write the rest of the array.  Also store start/stops
+	 */
+	ov7670_write_array(sd, ovfmt->regs + 1);
+	ov7670_set_hw(sd, wsize->hstart, wsize->hstop, wsize->vstart,
+			wsize->vstop);
+	ret = 0;
+	if (wsize->regs)
+		ret = ov7670_write_array(sd, wsize->regs);
+	info->fmt = ovfmt;
+
+	/*
+	 * If we're running RGB565, we must rewrite clkrc after setting
+	 * the other parameters or the image looks poor.  If we're *not*
+	 * doing RGB565, we must not rewrite clkrc or the image looks
+	 * *really* poor.
+	 *
+	 * (Update) Now that we retain clkrc state, we should be able
+	 * to write it unconditionally, and that will make the frame
+	 * rate persistent too.
+	 */
+	if (ret == 0)
+		ret = ov7670_write(sd, REG_CLKRC, info->clkrc);
+	return ret;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int ov7670_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct ov7670_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = OV7670_FRAME_RATE;
+	if ((info->clkrc & CLK_EXT) == 0 && (info->clkrc & CLK_SCALE) > 1)
+		cp->timeperframe.denominator /= (info->clkrc & CLK_SCALE);
+	return 0;
+}
+
+static int ov7670_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct v4l2_fract *tpf = &cp->timeperframe;
+	struct ov7670_info *info = to_state(sd);
+	int div;
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (cp->extendedmode != 0)
+		return -EINVAL;
+
+	if (tpf->numerator == 0 || tpf->denominator == 0)
+		div = 1;  /* Reset to full rate */
+	else
+		div = (tpf->numerator*OV7670_FRAME_RATE)/tpf->denominator;
+	if (div == 0)
+		div = 1;
+	else if (div > CLK_SCALE)
+		div = CLK_SCALE;
+	info->clkrc = (info->clkrc & 0x80) | div;
+	tpf->numerator = 1;
+	tpf->denominator = OV7670_FRAME_RATE/div;
+	return ov7670_write(sd, REG_CLKRC, info->clkrc);
+}
+
+
+
+/*
+ * Code for dealing with controls.
+ */
+
+
+
+
+
+static int ov7670_store_cmatrix(struct v4l2_subdev *sd,
+		int matrix[CMATRIX_LEN])
+{
+	int i, ret;
+	unsigned char signbits = 0;
+
+	/*
+	 * Weird crap seems to exist in the upper part of
+	 * the sign bits register, so let's preserve it.
+	 */
+	ret = ov7670_read(sd, REG_CMATRIX_SIGN, &signbits);
+	signbits &= 0xc0;
+
+	for (i = 0; i < CMATRIX_LEN; i++) {
+		unsigned char raw;
+
+		if (matrix[i] < 0) {
+			signbits |= (1 << i);
+			if (matrix[i] < -255)
+				raw = 0xff;
+			else
+				raw = (-1 * matrix[i]) & 0xff;
+		}
+		else {
+			if (matrix[i] > 255)
+				raw = 0xff;
+			else
+				raw = matrix[i] & 0xff;
+		}
+		ret += ov7670_write(sd, REG_CMATRIX_BASE + i, raw);
+	}
+	ret += ov7670_write(sd, REG_CMATRIX_SIGN, signbits);
+	return ret;
+}
+
+
+/*
+ * Hue also requires messing with the color matrix.  It also requires
+ * trig functions, which tend not to be well supported in the kernel.
+ * So here is a simple table of sine values, 0-90 degrees, in steps
+ * of five degrees.  Values are multiplied by 1000.
+ *
+ * The following naive approximate trig functions require an argument
+ * carefully limited to -180 <= theta <= 180.
+ */
+#define SIN_STEP 5
+static const int ov7670_sin_table[] = {
+	   0,	 87,   173,   258,   342,   422,
+	 499,	573,   642,   707,   766,   819,
+	 866,	906,   939,   965,   984,   996,
+	1000
+};
+
+static int ov7670_sine(int theta)
+{
+	int chs = 1;
+	int sine;
+
+	if (theta < 0) {
+		theta = -theta;
+		chs = -1;
+	}
+	if (theta <= 90)
+		sine = ov7670_sin_table[theta/SIN_STEP];
+	else {
+		theta -= 90;
+		sine = 1000 - ov7670_sin_table[theta/SIN_STEP];
+	}
+	return sine*chs;
+}
+
+static int ov7670_cosine(int theta)
+{
+	theta = 90 - theta;
+	if (theta > 180)
+		theta -= 360;
+	else if (theta < -180)
+		theta += 360;
+	return ov7670_sine(theta);
+}
+
+
+
+
+static void ov7670_calc_cmatrix(struct ov7670_info *info,
+		int matrix[CMATRIX_LEN])
+{
+	int i;
+	/*
+	 * Apply the current saturation setting first.
+	 */
+	for (i = 0; i < CMATRIX_LEN; i++)
+		matrix[i] = (info->fmt->cmatrix[i]*info->sat) >> 7;
+	/*
+	 * Then, if need be, rotate the hue value.
+	 */
+	if (info->hue != 0) {
+		int sinth, costh, tmpmatrix[CMATRIX_LEN];
+
+		memcpy(tmpmatrix, matrix, CMATRIX_LEN*sizeof(int));
+		sinth = ov7670_sine(info->hue);
+		costh = ov7670_cosine(info->hue);
+
+		matrix[0] = (matrix[3]*sinth + matrix[0]*costh)/1000;
+		matrix[1] = (matrix[4]*sinth + matrix[1]*costh)/1000;
+		matrix[2] = (matrix[5]*sinth + matrix[2]*costh)/1000;
+		matrix[3] = (matrix[3]*costh - matrix[0]*sinth)/1000;
+		matrix[4] = (matrix[4]*costh - matrix[1]*sinth)/1000;
+		matrix[5] = (matrix[5]*costh - matrix[2]*sinth)/1000;
+	}
+}
+
+
+
+static int ov7670_s_sat(struct v4l2_subdev *sd, int value)
+{
+	struct ov7670_info *info = to_state(sd);
+	int matrix[CMATRIX_LEN];
+	int ret;
+
+	info->sat = value;
+	ov7670_calc_cmatrix(info, matrix);
+	ret = ov7670_store_cmatrix(sd, matrix);
+	return ret;
+}
+
+static int ov7670_g_sat(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct ov7670_info *info = to_state(sd);
+
+	*value = info->sat;
+	return 0;
+}
+
+static int ov7670_s_hue(struct v4l2_subdev *sd, int value)
+{
+	struct ov7670_info *info = to_state(sd);
+	int matrix[CMATRIX_LEN];
+	int ret;
+
+	if (value < -180 || value > 180)
+		return -EINVAL;
+	info->hue = value;
+	ov7670_calc_cmatrix(info, matrix);
+	ret = ov7670_store_cmatrix(sd, matrix);
+	return ret;
+}
+
+
+static int ov7670_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct ov7670_info *info = to_state(sd);
+
+	*value = info->hue;
+	return 0;
+}
+
+
+/*
+ * Some weird registers seem to store values in a sign/magnitude format!
+ */
+static unsigned char ov7670_sm_to_abs(unsigned char v)
+{
+	if ((v & 0x80) == 0)
+		return v + 128;
+	return 128 - (v & 0x7f);
+}
+
+
+static unsigned char ov7670_abs_to_sm(unsigned char v)
+{
+	if (v > 127)
+		return v & 0x7f;
+	return (128 - v) | 0x80;
+}
+
+static int ov7670_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	unsigned char com8 = 0, v;
+	int ret;
+
+	ov7670_read(sd, REG_COM8, &com8);
+	com8 &= ~COM8_AEC;
+	ov7670_write(sd, REG_COM8, com8);
+	v = ov7670_abs_to_sm(value);
+	ret = ov7670_write(sd, REG_BRIGHT, v);
+	return ret;
+}
+
+static int ov7670_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	unsigned char v = 0;
+	int ret = ov7670_read(sd, REG_BRIGHT, &v);
+
+	*value = ov7670_sm_to_abs(v);
+	return ret;
+}
+
+static int ov7670_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	return ov7670_write(sd, REG_CONTRAS, (unsigned char) value);
+}
+
+static int ov7670_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	unsigned char v = 0;
+	int ret = ov7670_read(sd, REG_CONTRAS, &v);
+
+	*value = v;
+	return ret;
+}
+
+static int ov7670_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char v = 0;
+
+	ret = ov7670_read(sd, REG_MVFP, &v);
+	*value = (v & MVFP_MIRROR) == MVFP_MIRROR;
+	return ret;
+}
+
+
+static int ov7670_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	unsigned char v = 0;
+	int ret;
+
+	ret = ov7670_read(sd, REG_MVFP, &v);
+	if (value)
+		v |= MVFP_MIRROR;
+	else
+		v &= ~MVFP_MIRROR;
+	msleep(10);  /* FIXME */
+	ret += ov7670_write(sd, REG_MVFP, v);
+	return ret;
+}
+
+
+
+static int ov7670_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char v = 0;
+
+	ret = ov7670_read(sd, REG_MVFP, &v);
+	*value = (v & MVFP_FLIP) == MVFP_FLIP;
+	return ret;
+}
+
+
+static int ov7670_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	unsigned char v = 0;
+	int ret;
+
+	ret = ov7670_read(sd, REG_MVFP, &v);
+	if (value)
+		v |= MVFP_FLIP;
+	else
+		v &= ~MVFP_FLIP;
+	msleep(10);  /* FIXME */
+	ret += ov7670_write(sd, REG_MVFP, v);
+	return ret;
+}
+
+/*
+ * GAIN is split between REG_GAIN and REG_VREF[7:6].  If one believes
+ * the data sheet, the VREF parts should be the most significant, but
+ * experience shows otherwise.  There seems to be little value in
+ * messing with the VREF bits, so we leave them alone.
+ */
+static int ov7670_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char gain;
+
+	ret = ov7670_read(sd, REG_GAIN, &gain);
+	*value = gain;
+	return ret;
+}
+
+static int ov7670_s_gain(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	unsigned char com8;
+
+	ret = ov7670_write(sd, REG_GAIN, value & 0xff);
+	/* Have to turn off AGC as well */
+	if (ret == 0) {
+		ret = ov7670_read(sd, REG_COM8, &com8);
+		ret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AGC);
+	}
+	return ret;
+}
+
+/*
+ * Tweak autogain.
+ */
+static int ov7670_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char com8;
+
+	ret = ov7670_read(sd, REG_COM8, &com8);
+	*value = (com8 & COM8_AGC) != 0;
+	return ret;
+}
+
+static int ov7670_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	unsigned char com8;
+
+	ret = ov7670_read(sd, REG_COM8, &com8);
+	if (ret == 0) {
+		if (value)
+			com8 |= COM8_AGC;
+		else
+			com8 &= ~COM8_AGC;
+		ret = ov7670_write(sd, REG_COM8, com8);
+	}
+	return ret;
+}
+
+/*
+ * Exposure is spread all over the place: top 6 bits in AECHH, middle
+ * 8 in AECH, and two stashed in COM1 just for the hell of it.
+ */
+static int ov7670_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char com1, aech, aechh;
+
+	ret = ov7670_read(sd, REG_COM1, &com1) +
+		ov7670_read(sd, REG_AECH, &aech) +
+		ov7670_read(sd, REG_AECHH, &aechh);
+	*value = ((aechh & 0x3f) << 10) | (aech << 2) | (com1 & 0x03);
+	return ret;
+}
+
+static int ov7670_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	unsigned char com1, com8, aech, aechh;
+
+	ret = ov7670_read(sd, REG_COM1, &com1) +
+		ov7670_read(sd, REG_COM8, &com8);
+		ov7670_read(sd, REG_AECHH, &aechh);
+	if (ret)
+		return ret;
+
+	com1 = (com1 & 0xfc) | (value & 0x03);
+	aech = (value >> 2) & 0xff;
+	aechh = (aechh & 0xc0) | ((value >> 10) & 0x3f);
+	ret = ov7670_write(sd, REG_COM1, com1) +
+		ov7670_write(sd, REG_AECH, aech) +
+		ov7670_write(sd, REG_AECHH, aechh);
+	/* Have to turn off AEC as well */
+	if (ret == 0)
+		ret = ov7670_write(sd, REG_COM8, com8 & ~COM8_AEC);
+	return ret;
+}
+
+/*
+ * Tweak autoexposure.
+ */
+static int ov7670_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	unsigned char com8;
+	enum v4l2_exposure_auto_type *atype = (enum v4l2_exposure_auto_type *) value;
+
+	ret = ov7670_read(sd, REG_COM8, &com8);
+	if (com8 & COM8_AEC)
+		*atype = V4L2_EXPOSURE_AUTO;
+	else
+		*atype = V4L2_EXPOSURE_MANUAL;
+	return ret;
+}
+
+static int ov7670_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	unsigned char com8;
+
+	ret = ov7670_read(sd, REG_COM8, &com8);
+	if (ret == 0) {
+		if (value == V4L2_EXPOSURE_AUTO)
+			com8 |= COM8_AEC;
+		else
+			com8 &= ~COM8_AEC;
+		ret = ov7670_write(sd, REG_COM8, com8);
+	}
+	return ret;
+}
+
+
+
+static int ov7670_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+	case V4L2_CID_CONTRAST:
+		return v4l2_ctrl_query_fill(qc, 0, 127, 1, 64);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_SATURATION:
+//		return v4l2_ctrl_query_fill(qc, 0, 256, 1, 128);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_GAIN:
+		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+	case V4L2_CID_AUTOGAIN:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, 0, 65535, 1, 500);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct ov7670_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct ov7670_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int ov7670_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return ov7670_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return ov7670_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return ov7670_g_sat(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return ov7670_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return ov7670_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return ov7670_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return ov7670_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return ov7670_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return ov7670_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return ov7670_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int ov7670_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return ov7670_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return ov7670_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return ov7670_s_sat(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return ov7670_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return ov7670_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return ov7670_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return ov7670_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return ov7670_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return ov7670_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return ov7670_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int ov7670_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV7670, 0);
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov7670_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned char val = 0;
+	int ret;
+
+	if (!v4l2_chip_match_i2c_client(client, &reg->match))
+		return -EINVAL;
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	ret = ov7670_read(sd, reg->reg & 0xff, &val);
+	reg->val = val;
+	reg->size = 1;
+	return ret;
+}
+
+static int ov7670_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!v4l2_chip_match_i2c_client(client, &reg->match))
+		return -EINVAL;
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	ov7670_write(sd, reg->reg & 0xff, reg->val & 0xff);
+	return 0;
+}
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops ov7670_core_ops = {
+	.g_chip_ident = ov7670_g_chip_ident,
+	.g_ctrl = ov7670_g_ctrl,
+	.s_ctrl = ov7670_s_ctrl,
+	.queryctrl = ov7670_queryctrl,
+	.reset = ov7670_reset,
+	.init = ov7670_init,
+	.s_power = ov7670_power,
+	.ioctl = sensor_ioctl,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov7670_g_register,
+	.s_register = ov7670_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_video_ops ov7670_video_ops = {
+	.enum_mbus_fmt = ov7670_enum_fmt,//linux-3.0
+	.try_mbus_fmt = ov7670_try_fmt,//linux-3.0
+	.s_mbus_fmt = ov7670_s_fmt,//linux-3.0
+	.s_parm = ov7670_s_parm,
+	.g_parm = ov7670_g_parm,
+};
+
+static const struct v4l2_subdev_ops ov7670_ops = {
+	.core = &ov7670_core_ops,
+	.video = &ov7670_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int ov7670_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct ov7670_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct ov7670_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &ov7670_ops);
+
+	info->fmt = &ov7670_formats[0];
+	info->ccm_info = &ccm_info_con;
+	info->sat = 128;	/* Review this */
+	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int ov7670_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id ov7670_id[] = {
+	{ "ov7670", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov7670_id);
+
+//linux-3.0
+static struct i2c_driver ov7670_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	  .name = "ov7670",
+	 },
+	.probe = ov7670_probe,
+	.remove = ov7670_remove,
+	.id_table = ov7670_id,
+};
+
+static __init int init_ov7670(void)
+{
+	return i2c_add_driver(&ov7670_driver);
+}
+
+static __exit void exit_ov7670(void)
+{
+  i2c_del_driver(&ov7670_driver);
+}
+
+module_init(init_ov7670);
+module_exit(exit_ov7670);
diff --git a/drivers/media/video/sun4i_csi/device/sp0838.c b/drivers/media/video/sun4i_csi/device/sp0838.c
new file mode 100644
index 0000000..11642af
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/device/sp0838.c
@@ -0,0 +1,2429 @@
+/*
+ * drivers/media/video/sun4i_csi/device/sp0838.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * A V4L2 driver for Superpix sp0838 cameras.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/clk.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+#include <linux/io.h>
+//#include <mach/gpio_v2.h>
+#include <plat/sys_config.h>
+#include <linux/regulator/consumer.h>
+#include <mach/system.h>
+#include "../include/sun4i_csi_core.h"
+#include "../include/sun4i_dev_csi.h"
+
+MODULE_AUTHOR("raymonxiu");
+MODULE_DESCRIPTION("A low-level driver for Superpix sp0838 sensors");
+MODULE_LICENSE("GPL");
+
+//for internel driver debug
+#define DEV_DBG_EN   		0
+#if(DEV_DBG_EN == 1)
+#define csi_dev_dbg(x,arg...) printk(KERN_INFO"[CSI_DEBUG][SP0838]"x,##arg)
+#else
+#define csi_dev_dbg(x,arg...)
+#endif
+#define csi_dev_err(x,arg...) printk(KERN_INFO"[CSI_ERR][SP0838]"x,##arg)
+#define csi_dev_print(x,arg...) printk(KERN_INFO"[CSI][SP0838]"x,##arg)
+
+#define MCLK (24*1000*1000)
+#define VREF_POL	CSI_HIGH
+#define HREF_POL	CSI_HIGH
+#define CLK_POL		CSI_RISING
+#define IO_CFG		0						//0:csi back 1:csi front
+
+//define the voltage level of control signal
+#define CSI_STBY_ON			1
+#define CSI_STBY_OFF 		0
+#define CSI_RST_ON			0
+#define CSI_RST_OFF			1
+#define CSI_PWR_ON			1
+#define CSI_PWR_OFF			0
+
+
+#define V4L2_IDENT_SENSOR 0x0838
+
+#define REG_TERM 0xff
+#define VAL_TERM 0xff
+
+
+#define REG_ADDR_STEP 1
+#define REG_DATA_STEP 1
+#define REG_STEP 			(REG_ADDR_STEP+REG_DATA_STEP)
+
+
+/*
+ * Basic window sizes.  These probably belong somewhere more globally
+ * useful.
+ */
+#define VGA_WIDTH		640
+#define VGA_HEIGHT	480
+#define QVGA_WIDTH	320
+#define QVGA_HEIGHT	240
+#define CIF_WIDTH		352
+#define CIF_HEIGHT	288
+#define QCIF_WIDTH	176
+#define	QCIF_HEIGHT	144
+
+/*
+ * Our nominal (default) frame rate.
+ */
+#define SENSOR_FRAME_RATE 20
+
+/*
+ * The Superpix sp0838 sits on i2c with ID 0x30
+ */
+#define I2C_ADDR 0x30
+
+/* Registers */
+
+
+/*
+ * Information we maintain about a known sensor.
+ */
+struct sensor_format_struct;  /* coming later */
+__csi_subdev_info_t ccm_info_con =
+{
+	.mclk 	= MCLK,
+	.vref 	= VREF_POL,
+	.href 	= HREF_POL,
+	.clock	= CLK_POL,
+	.iocfg	= IO_CFG,
+};
+
+struct sensor_info {
+	struct v4l2_subdev sd;
+	struct sensor_format_struct *fmt;  /* Current format */
+	__csi_subdev_info_t *ccm_info;
+	int	width;
+	int	height;
+	int brightness;
+	int	contrast;
+	int saturation;
+	int hue;
+	int hflip;
+	int vflip;
+	int gain;
+	int autogain;
+	int exp;
+	enum v4l2_exposure_auto_type autoexp;
+	int autowb;
+	enum v4l2_whiteblance wb;
+	enum v4l2_colorfx clrfx;
+	enum v4l2_flash_mode flash_mode;
+	u8 clkrc;			/* Clock divider value */
+};
+
+static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sensor_info, sd);
+}
+
+
+struct regval_list {
+	unsigned char reg_num[REG_ADDR_STEP];
+	unsigned char value[REG_DATA_STEP];
+};
+
+
+/*
+ * The default register settings
+ *
+ */
+static struct regval_list sensor_default_regs[] = {
+  //[Sensor]
+	{{0xfd},{0x00}},//  ;P0
+	{{0x1B},{0x02}},//
+	{{0x27},{0xe8}},//
+	{{0x28},{0x0B}},//
+	{{0x32},{0x00}},//
+	{{0x22},{0xc0}},//
+	{{0x26},{0x10}},//
+	{{0x31},{0x30}},//  ;Upside/mirr/Pclk inv/sub
+	{{0x5f},{0x11}},//  ;Bayer order
+	{{0xfd},{0x01}},//  ;P1
+	{{0x25},{0x1a}},//  ;Awb start
+	{{0x26},{0xfb}},//
+	{{0x28},{0x61}},//
+	{{0x29},{0x49}},//
+	{{0x31},{0x64}},// ;64
+	{{0x32},{0x18}},//
+	{{0x4d},{0xdc}},//
+	{{0x4e},{0x6b}},//
+	{{0x41},{0x8c}},//
+	{{0x42},{0x66}},//
+	{{0x55},{0xff}},//
+	{{0x56},{0x00}},//
+	{{0x59},{0x82}},//
+	{{0x5a},{0x00}},//
+	{{0x5d},{0xff}},//
+	{{0x5e},{0x6f}},//
+	{{0x57},{0xff}},//
+	{{0x58},{0x00}},//
+	{{0x5b},{0xff}},//
+	{{0x5c},{0xa8}},//
+	{{0x5f},{0x75}},//
+	{{0x60},{0x00}},//
+	{{0x2d},{0x00}},//
+	{{0x2e},{0x00}},//
+	{{0x2f},{0x00}},//
+	{{0x30},{0x00}},//
+	{{0x33},{0x00}},//
+	{{0x34},{0x00}},//
+	{{0x37},{0x00}},//
+	{{0x38},{0x00}},//  ;awb end
+	{{0xfd},{0x00}},//  ;P0
+	{{0x33},{0x6f}},//  ;LSC BPC EN
+	{{0x51},{0x3f}},//  ;BPC debug start
+	{{0x52},{0x09}},//
+	{{0x53},{0x00}},//
+	{{0x54},{0x00}},//
+	{{0x55},{0x10}},//  ;BPC debug end
+	{{0x4f},{0xff}},//  ;blueedge
+	{{0x50},{0xff}},//
+	{{0x57},{0x40}},//  ;Raw filter debut start
+	{{0x58},{0x40}},//  ;4
+	{{0x59},{0x10}},//  ;04
+	{{0x56},{0x70}},//
+	{{0x5a},{0x02}},//
+	{{0x5b},{0x02}},//
+	{{0x5c},{0x20}},//  ;Raw filter debut end
+	{{0x65},{0x06}},//  ;Sharpness debug start
+	{{0x66},{0x01}},//
+	{{0x67},{0x03}},//
+	{{0x68},{0xc6}},//
+	{{0x69},{0x7f}},//
+	{{0x6a},{0x01}},//
+	{{0x6b},{0x06}},//
+	{{0x6c},{0x01}},//
+	{{0x6d},{0x03}},//  ;Edge gain normal
+	{{0x6e},{0xc6}},//  ;Edge gain normal
+	{{0x6f},{0x7f}},//
+	{{0x70},{0x01}},//
+	{{0x71},{0x0a}},//
+	{{0x72},{0x10}},//
+	{{0x73},{0x03}},//
+	{{0x74},{0xc4}},//
+	{{0x75},{0x7f}},//
+	{{0x76},{0x01}},//  ;Sharpness debug end
+	{{0xcb},{0x07}},//  ;HEQ&Saturation debug start
+	{{0xcc},{0x04}},//
+	{{0xce},{0xff}},//
+	{{0xcf},{0x10}},//
+	{{0xd0},{0x20}},//
+	{{0xd1},{0x00}},//
+	{{0xd2},{0x1c}},//
+	{{0xd3},{0x16}},//
+	{{0xd4},{0x00}},//
+	{{0xd6},{0x1c}},//
+	{{0xd7},{0x16}},//
+	{{0xdd},{0x70}},//  ;Contrast
+	{{0xde},{0x90}},//  ;HEQ&Saturation debug end
+	{{0x7f},{0x91}},//  ;Color Correction start
+	{{0x80},{0xf2}},//
+	{{0x81},{0xfe}},//
+	{{0x82},{0xde}},//
+	{{0x83},{0xa3}},//
+	{{0x84},{0xff}},//
+	{{0x85},{0xea}},//
+	{{0x86},{0x81}},//
+	{{0x87},{0x16}},//
+	{{0x88},{0x3c}},//
+	{{0x89},{0x33}},//
+	{{0x8a},{0x1f}},//  ;Color Correction end
+	{{0x8b},{0x00}},//   ;gamma start
+	{{0x8c},{0x1a}},//
+	{{0x8d},{0x29}},//
+	{{0x8e},{0x41}},//
+	{{0x8f},{0x62}},//
+	{{0x90},{0x7c}},//
+	{{0x91},{0x90}},//
+	{{0x92},{0xa2}},//
+	{{0x93},{0xaf}},//
+	{{0x94},{0xbc}},//
+	{{0x95},{0xc5}},//
+	{{0x96},{0xcd}},//
+	{{0x97},{0xd5}},//
+	{{0x98},{0xdd}},//
+	{{0x99},{0xe5}},//
+	{{0x9a},{0xed}},//
+	{{0x9b},{0xf5}},//
+	{{0xfd},{0x01}},//  ;P1
+	{{0x8d},{0xfd}},//
+	{{0x8e},{0xff}},//  ;gamma end
+	{{0xfd},{0x00}},//  ;P0
+	{{0xca},{0xcf}},//
+	{{0xd8},{0x65}},//  ;UV outdoor
+	{{0xd9},{0x65}},//  ;UV indoor
+	{{0xda},{0x65}},//  ;UV dummy
+	{{0xdb},{0x50}},//  ;UV lowlight
+	{{0xb9},{0x00}},//  ;Ygamma start
+	{{0xba},{0x04}},//
+	{{0xbb},{0x08}},//
+	{{0xbc},{0x10}},//
+	{{0xbd},{0x20}},//
+	{{0xbe},{0x30}},//
+	{{0xbf},{0x40}},//
+	{{0xc0},{0x50}},//
+	{{0xc1},{0x60}},//
+	{{0xc2},{0x70}},//
+	{{0xc3},{0x80}},//
+	{{0xc4},{0x90}},//
+	{{0xc5},{0xA0}},//
+	{{0xc6},{0xB0}},//
+	{{0xc7},{0xC0}},//
+	{{0xc8},{0xD0}},//
+	{{0xc9},{0xE0}},//
+	{{0xfd},{0x01}},//  ;P1
+	{{0x89},{0xf0}},//
+	{{0x8a},{0xff}},//  ;Ygamma end
+	{{0xfd},{0x00}},//  ;P0
+	{{0xe8},{0x30}},//  ;AEdebug start
+	{{0xe9},{0x30}},//
+	{{0xea},{0x40}},//  ;Alc Window sel
+	{{0xf4},{0x1b}},//  ;outdoor mode sel
+	{{0xf5},{0x80}},//
+	{{0xf7},{0x78}},//  ;AE target
+	{{0xf8},{0x63}},//
+	{{0xf9},{0x68}},//  ;AE target
+	{{0xfa},{0x53}},//
+	{{0xfd},{0x01}},//  ;P1
+	{{0x09},{0x31}},//  ;AE Step 3.0
+	{{0x0a},{0x85}},//
+	{{0x0b},{0x0b}},//  ;AE Step 3.0
+	{{0x14},{0x20}},//
+	{{0x15},{0x0f}},//
+	{{0xfd},{0x00}},//  ;p0
+	{{0x05},{0x00}},//
+	{{0x06},{0x00}},//
+	{{0x09},{0x01}},//
+	{{0x0a},{0x76}},//
+	{{0xf0},{0x62}},//
+	{{0xf1},{0x0 }},//
+	{{0xf2},{0x5f}},//
+	{{0xf5},{0x78}},//
+	{{0xfd},{0x01}},//;P1
+	{{0x00},{0xb2}},//
+	{{0x0f},{0x60}},//
+	{{0x16},{0x60}},//
+	{{0x17},{0xa2}},//
+	{{0x18},{0xaa}},//
+	{{0x1b},{0x60}},//
+	{{0x1c},{0xaa}},//
+	{{0xb4},{0x20}},//
+	{{0xb5},{0x3a}},//
+	{{0xb6},{0x5e}},//
+	{{0xb9},{0x40}},//
+	{{0xba},{0x4f}},//
+	{{0xbb},{0x47}},//
+	{{0xbc},{0x45}},//
+	{{0xbd},{0x43}},//
+	{{0xbe},{0x42}},//
+	{{0xbf},{0x42}},//
+	{{0xc0},{0x42}},//
+	{{0xc1},{0x41}},//
+	{{0xc2},{0x41}},//
+	{{0xc3},{0x41}},//
+	{{0xc4},{0x41}},//
+	{{0xc5},{0x70}},//
+	{{0xc6},{0x41}},//
+	{{0xca},{0x70}},//
+	{{0xcb},{0x0c}},//   ;AEdebug end
+	{{0xfd},{0x00}},//  ;P0
+	{{0x32},{0x15}},//  ;Auto_mode set
+	{{0x34},{0x66}},//  ;Isp_mode set
+
+	//50HZ 20fps fixed
+	{{0xfd},{0x00}},
+	{{0x05},{0x0 }},
+	{{0x06},{0x0 }},
+	{{0x09},{0x1 }},
+	{{0x0a},{0x76}},
+	{{0xf0},{0x62}},
+	{{0xf1},{0x0 }},
+	{{0xf2},{0x5f}},
+	{{0xf5},{0x78}},
+	{{0xfd},{0x01}},
+	{{0x00},{0xa1}},
+	{{0x0f},{0x60}},
+	{{0x16},{0x60}},
+	{{0x17},{0x91}},
+	{{0x18},{0x99}},
+	{{0x1b},{0x60}},
+	{{0x1c},{0x99}},
+	{{0xb4},{0x20}},
+	{{0xb5},{0x3a}},
+	{{0xb6},{0x5e}},
+	{{0xb9},{0x40}},
+	{{0xba},{0x4f}},
+	{{0xbb},{0x47}},
+	{{0xbc},{0x45}},
+	{{0xbd},{0x43}},
+	{{0xbe},{0x70}},
+	{{0xbf},{0x42}},
+	{{0xc0},{0x42}},
+	{{0xc1},{0x41}},
+	{{0xc2},{0x41}},
+	{{0xc3},{0x41}},
+	{{0xc4},{0x41}},
+	{{0xc5},{0x41}},
+	{{0xc6},{0x41}},
+	{{0xca},{0x70}},
+	{{0xcb},{0x5 }},
+	{{0xfd},{0x00}}
+};
+
+static struct regval_list sensor_vga_regs[] = {
+	{{0xfd},{0x00}}
+};
+
+static struct regval_list sensor_qvga_regs[] = {
+	{{0xfd},{0x00}}
+};
+
+
+
+/*
+ * The white balance settings
+ * Here only tune the R G B channel gain.
+ * The white balance enalbe bit is modified in sensor_s_autowb and sensor_s_wb
+ */
+static struct regval_list sensor_wb_auto_regs[] = {
+	{{0xfd},{0x00}},  // AUTO 3000K~7000K
+	{{0x32},{0x15}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x61}},
+	{{0x29},{0x49}}
+};
+
+static struct regval_list sensor_wb_cloud_regs[] = {
+	{{0xfd},{0x00}},  //7000K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x71}},
+	{{0x29},{0x41}}
+};
+
+static struct regval_list sensor_wb_daylight_regs[] = {
+	//tai yang guang
+	{{0xfd},{0x00}},  //6500K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x6b}},
+	{{0x29},{0x48}}
+};
+
+static struct regval_list sensor_wb_incandescence_regs[] = {
+	//bai re guang
+	{{0xfd},{0x00}},  //2800K-3000K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x41}},
+	{{0x29},{0x71}}
+};
+
+static struct regval_list sensor_wb_fluorescent_regs[] = {
+	//ri guang deng
+	{{0xfd},{0x00}},  //4200K-5000K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x5a}},
+	{{0x29},{0x62}}
+};
+
+static struct regval_list sensor_wb_tungsten_regs[] = {
+	//wu si deng
+	{{0xfd},{0x00}},  //4000K
+	{{0x32},{0x05}},
+	{{0xfd},{0x01}},
+	{{0x28},{0x57}},
+	{{0x29},{0x66}}
+};
+
+/*
+ * The color effect settings
+ */
+static struct regval_list sensor_colorfx_none_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x00}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_bw_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x40}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_sepia_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x20}},
+	{{0x63},{0xc0}},
+	{{0x64},{0x20}}
+};
+
+static struct regval_list sensor_colorfx_negative_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x10}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_emboss_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x02}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_sketch_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x01}},
+	{{0x63},{0x80}},
+	{{0x64},{0x80}}
+};
+
+static struct regval_list sensor_colorfx_sky_blue_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x20}},
+	{{0x63},{0x20}},
+	{{0x64},{0xf0}}
+};
+
+static struct regval_list sensor_colorfx_grass_green_regs[] = {
+	{{0xfd},{0x00}},
+	{{0x62},{0x20}},
+	{{0x63},{0x20}},
+	{{0x64},{0x20}}
+};
+
+static struct regval_list sensor_colorfx_skin_whiten_regs[] = {
+	//NULL
+};
+
+static struct regval_list sensor_colorfx_vivid_regs[] = {
+	//NULL
+};
+
+/*
+ * The brightness setttings
+ */
+static struct regval_list sensor_brightness_neg4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0xc0}}
+};
+
+static struct regval_list sensor_brightness_neg3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0xd0}}
+};
+
+static struct regval_list sensor_brightness_neg2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0xe0}}
+};
+
+static struct regval_list sensor_brightness_neg1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0xf0}}
+};
+
+static struct regval_list sensor_brightness_zero_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_brightness_pos1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x10}}
+};
+
+static struct regval_list sensor_brightness_pos2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x20}}
+};
+
+static struct regval_list sensor_brightness_pos3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x30}}
+};
+
+static struct regval_list sensor_brightness_pos4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xdc},{0x40}}
+};
+
+/*
+ * The contrast setttings
+ */
+static struct regval_list sensor_contrast_neg4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x40}}
+};
+
+static struct regval_list sensor_contrast_neg3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x50}}
+};
+
+static struct regval_list sensor_contrast_neg2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x60}}
+};
+
+static struct regval_list sensor_contrast_neg1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x70}}
+};
+
+static struct regval_list sensor_contrast_zero_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x80}}
+};
+
+static struct regval_list sensor_contrast_pos1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0x90}}
+};
+
+static struct regval_list sensor_contrast_pos2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0xa0}}
+};
+
+static struct regval_list sensor_contrast_pos3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0xb0}}
+};
+
+static struct regval_list sensor_contrast_pos4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xde},{0xc0}}
+};
+
+/*
+ * The saturation setttings
+ */
+static struct regval_list sensor_saturation_neg4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x20}}
+};
+
+static struct regval_list sensor_saturation_neg3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x30}}
+};
+
+static struct regval_list sensor_saturation_neg2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x40}}
+};
+
+static struct regval_list sensor_saturation_neg1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x50}}
+};
+
+static struct regval_list sensor_saturation_zero_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x60}}
+};
+
+static struct regval_list sensor_saturation_pos1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x70}}
+};
+
+static struct regval_list sensor_saturation_pos2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x80}}
+};
+
+static struct regval_list sensor_saturation_pos3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0x90}}
+};
+
+static struct regval_list sensor_saturation_pos4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xd9},{0xa0}}
+};
+
+/*
+ * The exposure target setttings
+ */
+static struct regval_list sensor_ev_neg4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78-0x20}},
+	{{0xf8},{0x63-0x20}},
+	{{0xf9},{0x68-0x20}},
+	{{0xfa},{0x53-0x20}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_neg3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78-0x18}},
+	{{0xf8},{0x63-0x18}},
+	{{0xf9},{0x68-0x18}},
+	{{0xfa},{0x53-0x18}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_neg2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78-0x10}},
+	{{0xf8},{0x63-0x10}},
+	{{0xf9},{0x68-0x10}},
+	{{0xfa},{0x53-0x10}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_neg1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78-0x08}},
+	{{0xf8},{0x63-0x08}},
+	{{0xf9},{0x68-0x08}},
+	{{0xfa},{0x53-0x08}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_zero_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78}},
+	{{0xf8},{0x63}},
+	{{0xf9},{0x68}},
+	{{0xfa},{0x53}},
+	{{0xdc},{0x00}},
+};
+
+static struct regval_list sensor_ev_pos1_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78+0x08}},
+	{{0xf8},{0x63+0x08}},
+	{{0xf9},{0x68+0x08}},
+	{{0xfa},{0x53+0x08}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_pos2_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78+0x10}},
+	{{0xf8},{0x63+0x10}},
+	{{0xf9},{0x68+0x10}},
+	{{0xfa},{0x53+0x10}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_pos3_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78+0x18}},
+	{{0xf8},{0x63+0x18}},
+	{{0xf9},{0x68+0x18}},
+	{{0xfa},{0x53+0x18}},
+	{{0xdc},{0x00}}
+};
+
+static struct regval_list sensor_ev_pos4_regs[] = {
+	{{0xfd},{0x00}},
+	{{0xf7},{0x78+0x20}},
+	{{0xf8},{0x63+0x20}},
+	{{0xf9},{0x68+0x20}},
+	{{0xfa},{0x53+0x20}},
+	{{0xdc},{0x00}}
+};
+
+
+/*
+ * Here we'll try to encapsulate the changes for just the output
+ * video format.
+ *
+ */
+
+
+static struct regval_list sensor_fmt_yuv422_yuyv[] = {
+	{{0xfd},{0x00}},//Page 0
+	{{0x35},{0x40}}	//YCbYCr
+};
+
+
+static struct regval_list sensor_fmt_yuv422_yvyu[] = {
+	{{0xfd},{0x00}},//Page 0
+	{{0x35},{0xc0}}	//YCrYCb
+};
+
+static struct regval_list sensor_fmt_yuv422_vyuy[] = {
+	{{0xfd},{0x00}},//Page 0
+	{{0x35},{0x80}}	//CrYCbY
+};
+
+static struct regval_list sensor_fmt_yuv422_uyvy[] = {
+	{{0xfd},{0x00}},//Page 0
+	{{0x35},{0x00}}	//CbYCrY
+};
+
+//static struct regval_list sensor_fmt_raw[] = {
+//
+//};
+
+
+
+/*
+ * Low-level register I/O.
+ *
+ */
+
+
+/*
+ * On most platforms, we'd rather do straight i2c I/O.
+ */
+static int sensor_read(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[REG_STEP];
+	struct i2c_msg msg;
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+		data[i] = reg[i];
+
+	data[REG_ADDR_STEP] = 0xff;
+	/*
+	 * Send out the register address...
+	 */
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_ADDR_STEP;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		csi_dev_err("Error %d on register write\n", ret);
+		return ret;
+	}
+	/*
+	 * ...then read back the result.
+	 */
+
+	msg.flags = I2C_M_RD;
+	msg.len = REG_DATA_STEP;
+	msg.buf = &data[REG_ADDR_STEP];
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0) {
+		for(i = 0; i < REG_DATA_STEP; i++)
+			value[i] = data[i+REG_ADDR_STEP];
+		ret = 0;
+	}
+	else {
+		csi_dev_err("Error %d on register read\n", ret);
+	}
+	return ret;
+}
+
+
+static int sensor_write(struct v4l2_subdev *sd, unsigned char *reg,
+		unsigned char *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_msg msg;
+	unsigned char data[REG_STEP];
+	int ret,i;
+
+	for(i = 0; i < REG_ADDR_STEP; i++)
+			data[i] = reg[i];
+	for(i = REG_ADDR_STEP; i < REG_STEP; i++)
+			data[i] = value[i-REG_ADDR_STEP];
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = REG_STEP;
+	msg.buf = data;
+
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret > 0) {
+		ret = 0;
+	}
+	else if (ret < 0) {
+		csi_dev_err("sensor_write error!\n");
+	}
+	return ret;
+}
+
+
+/*
+ * Write a list of register settings;
+ */
+static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *vals , uint size)
+{
+	int i,ret;
+
+	if (size == 0)
+		return -EINVAL;
+
+	for(i = 0; i < size ; i++)
+	{
+		ret = sensor_write(sd, vals->reg_num, vals->value);
+		if (ret < 0)
+			{
+				csi_dev_err("sensor_write_err!\n");
+				return ret;
+			}
+
+		vals++;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Stuff that knows about the sensor.
+ */
+
+static int sensor_power(struct v4l2_subdev *sd, int on)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_stby_str[32],csi_power_str[32],csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_stby_str,"csi_stby");
+		strcpy(csi_power_str,"csi_power_en");
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_stby_str,"csi_stby_b");
+	  strcpy(csi_power_str,"csi_power_en_b");
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+  switch(on)
+	{
+		case CSI_SUBDEV_STBY_ON:
+			csi_dev_dbg("CSI_SUBDEV_STBY_ON\n");
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			//active mclk before stadby in
+			clk_enable(dev->csi_module_clk);
+			msleep(100);
+			//standby on io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			msleep(100);
+			//inactive mclk after stadby in
+			clk_disable(dev->csi_module_clk);
+
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_STBY_OFF:
+			csi_dev_dbg("CSI_SUBDEV_STBY_OFF\n");
+			//active mclk before stadby out
+			clk_enable(dev->csi_module_clk);
+			msleep(10);
+			//reset off io
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_PWR_ON:
+			csi_dev_dbg("CSI_SUBDEV_PWR_ON\n");
+			//inactive mclk before power on
+			clk_disable(dev->csi_module_clk);
+			//power on reset
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_stby_str);//set the gpio to output
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,1,csi_reset_str);//set the gpio to output
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_ON,csi_stby_str);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(1);
+			//power supply
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_ON,csi_power_str);
+			msleep(10);
+			if(dev->dvdd) {
+				regulator_enable(dev->dvdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_enable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->iovdd) {
+				regulator_enable(dev->iovdd);
+				msleep(10);
+			}
+			//active mclk before power on
+			clk_enable(dev->csi_module_clk);
+			//reset after power on
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_STBY_OFF,csi_stby_str);
+			msleep(10);
+			break;
+
+		case CSI_SUBDEV_PWR_OFF:
+			csi_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
+			//power supply off
+			if(dev->iovdd) {
+				regulator_disable(dev->iovdd);
+				msleep(10);
+			}
+			if(dev->avdd) {
+				regulator_disable(dev->avdd);
+				msleep(10);
+			}
+			if(dev->dvdd) {
+				regulator_disable(dev->dvdd);
+				msleep(10);
+			}
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_PWR_OFF,csi_power_str);
+			msleep(10);
+
+			//inactive mclk after power off
+			clk_disable(dev->csi_module_clk);
+
+			//set the io to hi-z
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_reset_str);//set the gpio to input
+			gpio_set_one_pin_io_status(dev->csi_pin_hd,0,csi_stby_str);//set the gpio to input
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_reset(struct v4l2_subdev *sd, u32 val)
+{
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	struct sensor_info *info = to_state(sd);
+	char csi_reset_str[32];
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_reset_str,"csi_reset");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_reset_str,"csi_reset_b");
+	}
+
+	switch(val)
+	{
+		case CSI_SUBDEV_RST_OFF:
+			csi_dev_dbg("CSI_SUBDEV_RST_OFF\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_ON:
+			csi_dev_dbg("CSI_SUBDEV_RST_ON\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(10);
+			break;
+		case CSI_SUBDEV_RST_PUL:
+			csi_dev_dbg("CSI_SUBDEV_RST_PUL\n");
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_ON,csi_reset_str);
+			msleep(100);
+			gpio_write_one_pin_value(dev->csi_pin_hd,CSI_RST_OFF,csi_reset_str);
+			msleep(10);
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sensor_detect(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00; //PAGE 0x00
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_detect!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x02;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_detect!\n");
+		return ret;
+	}
+
+	if(regs.value[0] != 0x27)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	csi_dev_dbg("sensor_init\n");
+
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		csi_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	int ret=0;
+
+	switch(cmd){
+		case CSI_SUBDEV_CMD_GET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_GET_INFO\n");
+
+			ccm_info->mclk 	=	info->ccm_info->mclk ;
+			ccm_info->vref 	=	info->ccm_info->vref ;
+			ccm_info->href 	=	info->ccm_info->href ;
+			ccm_info->clock	=	info->ccm_info->clock;
+			ccm_info->iocfg	=	info->ccm_info->iocfg;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		case CSI_SUBDEV_CMD_SET_INFO:
+		{
+			struct sensor_info *info = to_state(sd);
+			__csi_subdev_info_t *ccm_info = arg;
+
+			csi_dev_dbg("CSI_SUBDEV_CMD_SET_INFO\n");
+
+			info->ccm_info->mclk 	=	ccm_info->mclk 	;
+			info->ccm_info->vref 	=	ccm_info->vref 	;
+			info->ccm_info->href 	=	ccm_info->href 	;
+			info->ccm_info->clock	=	ccm_info->clock	;
+			info->ccm_info->iocfg	=	ccm_info->iocfg	;
+
+			csi_dev_dbg("ccm_info.mclk=%x\n ",info->ccm_info->mclk);
+			csi_dev_dbg("ccm_info.vref=%x\n ",info->ccm_info->vref);
+			csi_dev_dbg("ccm_info.href=%x\n ",info->ccm_info->href);
+			csi_dev_dbg("ccm_info.clock=%x\n ",info->ccm_info->clock);
+			csi_dev_dbg("ccm_info.iocfg=%x\n ",info->ccm_info->iocfg);
+			break;
+		}
+		default:
+			return -EINVAL;
+	}
+
+	return ret;
+}
+
+
+/*
+ * Store information about the video data format.
+ */
+static struct sensor_format_struct {
+	__u8 *desc;
+	//__u32 pixelformat;
+	enum v4l2_mbus_pixelcode mbus_code;//linux-3.0
+	struct regval_list *regs;
+	int	regs_size;
+	int bpp;   /* Bytes per pixel */
+} sensor_formats[] = {
+	{
+		.desc		= "YUYV 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YUYV8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yuyv,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yuyv),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "YVYU 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_YVYU8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_yvyu,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_yvyu),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "UYVY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_UYVY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_uyvy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_uyvy),
+		.bpp		= 2,
+	},
+	{
+		.desc		= "VYUY 4:2:2",
+		.mbus_code	= V4L2_MBUS_FMT_VYUY8_2X8,//linux-3.0
+		.regs 		= sensor_fmt_yuv422_vyuy,
+		.regs_size = ARRAY_SIZE(sensor_fmt_yuv422_vyuy),
+		.bpp		= 2,
+	},
+//	{
+//		.desc		= "Raw RGB Bayer",
+//		.mbus_code	= V4L2_MBUS_FMT_SBGGR8_1X8,//linux-3.0
+//		.regs 		= sensor_fmt_raw,
+//		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
+//		.bpp		= 1
+//	},
+};
+#define N_FMTS ARRAY_SIZE(sensor_formats)
+
+
+/*
+ * Then there is the issue of window sizes.  Try to capture the info here.
+ */
+
+int __sensor_set_vga(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at __sensor_set_vga!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at __sensor_set_vga!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0xfb;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at __sensor_set_vga!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int __sensor_set_qvga(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at __sensor_set_qvga!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at __sensor_set_qvga!\n");
+		return ret;
+	}
+
+	regs.value[0] |= 0x04;
+
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at __sensor_set_qvga!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct sensor_win_size {
+	int	width;
+	int	height;
+	int	hstart;		/* Start/stop values for the camera.  Note */
+	int	hstop;		/* that they do not always make complete */
+	int	vstart;		/* sense to humans, but evidently the sensor */
+	int	vstop;		/* will do the right thing... */
+	struct regval_list *regs; /* Regs to tweak */
+	int regs_size;
+	int (*set_size) (struct v4l2_subdev *sd);
+/* h/vref stuff */
+} sensor_win_sizes[] = {
+	/* VGA */
+	{
+		.width		= VGA_WIDTH,
+		.height		= VGA_HEIGHT,
+		.regs 		= sensor_vga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
+		.set_size	= __sensor_set_vga,
+	},
+	/* QVGA */
+	{
+		.width		= QVGA_WIDTH,
+		.height		= QVGA_HEIGHT,
+		.regs 		= sensor_qvga_regs,
+		.regs_size	= ARRAY_SIZE(sensor_qvga_regs),
+		.set_size	= __sensor_set_qvga,
+	}
+};
+
+#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+
+
+
+
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
+                 enum v4l2_mbus_pixelcode *code)//linux-3.0
+{
+//	struct sensor_format_struct *ofmt;
+
+	if (index >= N_FMTS)//linux-3.0
+		return -EINVAL;
+
+	*code = sensor_formats[index].mbus_code;//linux-3.0
+//	ofmt = sensor_formats + fmt->index;
+//	fmt->flags = 0;
+//	strcpy(fmt->description, ofmt->desc);
+//	fmt->pixelformat = ofmt->pixelformat;
+	return 0;
+}
+
+
+static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
+		//struct v4l2_format *fmt,
+		struct v4l2_mbus_framefmt *fmt,//linux-3.0
+		struct sensor_format_struct **ret_fmt,
+		struct sensor_win_size **ret_wsize)
+{
+	int index;
+	struct sensor_win_size *wsize;
+//	struct v4l2_pix_format *pix = &fmt->fmt.pix;//linux-3.0
+	csi_dev_dbg("sensor_try_fmt_internal\n");
+	for (index = 0; index < N_FMTS; index++)
+		if (sensor_formats[index].mbus_code == fmt->code)//linux-3.0
+			break;
+
+	if (index >= N_FMTS) {
+		/* default to first format */
+		index = 0;
+		fmt->code = sensor_formats[0].mbus_code;//linux-3.0
+	}
+
+	if (ret_fmt != NULL)
+		*ret_fmt = sensor_formats + index;
+
+	/*
+	 * Fields: the sensor devices claim to be progressive.
+	 */
+	fmt->field = V4L2_FIELD_NONE;//linux-3.0
+
+
+	/*
+	 * Round requested image size down to the nearest
+	 * we support, but not below the smallest.
+	 */
+	for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
+	     wsize++)
+		if (fmt->width >= wsize->width && fmt->height >= wsize->height)//linux-3.0
+			break;
+
+	if (wsize >= sensor_win_sizes + N_WIN_SIZES)
+		wsize--;   /* Take the smallest one */
+	if (ret_wsize != NULL)
+		*ret_wsize = wsize;
+	/*
+	 * Note the size we'll actually handle.
+	 */
+	fmt->width = wsize->width;//linux-3.0
+	fmt->height = wsize->height;//linux-3.0
+	//pix->bytesperline = pix->width*sensor_formats[index].bpp;//linux-3.0
+	//pix->sizeimage = pix->height*pix->bytesperline;//linux-3.0
+
+	return 0;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
+}
+
+/*
+ * Set a format.
+ */
+static int sensor_s_fmt(struct v4l2_subdev *sd,
+             struct v4l2_mbus_framefmt *fmt)//linux-3.0
+{
+	int ret;
+	struct sensor_format_struct *sensor_fmt;
+	struct sensor_win_size *wsize;
+	struct sensor_info *info = to_state(sd);
+	csi_dev_dbg("sensor_s_fmt\n");
+	ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
+	if (ret)
+		return ret;
+
+
+	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
+
+	ret = 0;
+	if (wsize->regs)
+	{
+		ret = sensor_write_array(sd, wsize->regs , wsize->regs_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (wsize->set_size)
+	{
+		ret = wsize->set_size(sd);
+		if (ret < 0)
+			return ret;
+	}
+
+	info->fmt = sensor_fmt;
+	info->width = wsize->width;
+	info->height = wsize->height;
+
+	return 0;
+}
+
+/*
+ * Implement G/S_PARM.  There is a "high quality" mode we could try
+ * to do someday; for now, we just do the frame rate tweak.
+ */
+static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	//struct sensor_info *info = to_state(sd);
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(struct v4l2_captureparm));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	cp->timeperframe.denominator = SENSOR_FRAME_RATE;
+
+	return 0;
+}
+
+static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	return -EINVAL;
+}
+
+
+/*
+ * Code for dealing with controls.
+ * fill with different sensor module
+ * different sensor module has different settings here
+ * if not support the follow function ,retrun -EINVAL
+ */
+
+/* *********************************************begin of ******************************************** */
+static int sensor_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	/* Fill in min, max, step and default value for these controls. */
+	/* see include/linux/videodev2.h for details */
+	/* see sensor_s_parm and sensor_g_parm for the meaning of value */
+
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_CONTRAST:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+	case V4L2_CID_SATURATION:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 1);
+//	case V4L2_CID_HUE:
+//		return v4l2_ctrl_query_fill(qc, -180, 180, 5, 0);
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HFLIP:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+//	case V4L2_CID_GAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 255, 1, 128);
+//	case V4L2_CID_AUTOGAIN:
+//		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_EXPOSURE:
+		return v4l2_ctrl_query_fill(qc, -4, 4, 1, 0);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 0);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 5, 1, 0);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return v4l2_ctrl_query_fill(qc, 0, 1, 1, 1);
+	case V4L2_CID_COLORFX:
+		return v4l2_ctrl_query_fill(qc, 0, 9, 1, 0);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return v4l2_ctrl_query_fill(qc, 0, 4, 1, 0);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_hflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_hflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<5);
+	regs.value[0] = regs.value[0]>>5;		//0x31 bit5 is mirror
+
+	*value = regs.value[0];
+
+	info->hflip = *value;
+	return 0;
+}
+
+static int sensor_s_hflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xdf;
+			break;
+		case 1:
+			regs.value[0] |= 0x20;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_hflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->hflip = value;
+	return 0;
+}
+
+static int sensor_g_vflip(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_vflip!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<6);
+	regs.value[0] = regs.value[0]>>6;		//0x31 bit6 is upsidedown
+
+	*value = regs.value[0];
+
+	info->vflip = *value;
+	return 0;
+}
+
+static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x31;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case 0:
+		  regs.value[0] &= 0xbf;
+			break;
+		case 1:
+			regs.value[0] |= 0x40;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_vflip!\n");
+		return ret;
+	}
+
+	msleep(100);
+
+	info->vflip = value;
+	return 0;
+}
+
+static int sensor_g_autogain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_autogain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_autoexp(struct v4l2_subdev *sd, __s32 *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x32;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autoexp!\n");
+		return ret;
+	}
+
+	regs.value[0] &= 0x01;
+	if (regs.value[0] == 0x01) {
+		*value = V4L2_EXPOSURE_AUTO;
+	}
+	else
+	{
+		*value = V4L2_EXPOSURE_MANUAL;
+	}
+
+	info->autoexp = *value;
+	return 0;
+}
+
+static int sensor_s_autoexp(struct v4l2_subdev *sd,
+		enum v4l2_exposure_auto_type value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x32;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	switch (value) {
+		case V4L2_EXPOSURE_AUTO:
+		  regs.value[0] |= 0x01;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			regs.value[0] &= 0xfe;
+			break;
+		case V4L2_EXPOSURE_SHUTTER_PRIORITY:
+			return -EINVAL;
+		case V4L2_EXPOSURE_APERTURE_PRIORITY:
+			return -EINVAL;
+		default:
+			return -EINVAL;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autoexp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autoexp = value;
+	return 0;
+}
+
+static int sensor_g_autowb(struct v4l2_subdev *sd, int *value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x32;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_g_autowb!\n");
+		return ret;
+	}
+
+	regs.value[0] &= (1<<4);
+	regs.value[0] = regs.value[0]>>4;		//0x32 bit4 is awb enable
+
+	*value = regs.value[0];
+	info->autowb = *value;
+	return 0;
+}
+
+static int sensor_s_autowb(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+	struct regval_list regs;
+
+	ret = sensor_write_array(sd, sensor_wb_auto_regs, ARRAY_SIZE(sensor_wb_auto_regs));
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0xfd;
+	regs.value[0] = 0x00;		//page 0
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	regs.reg_num[0] = 0x32;
+	ret = sensor_read(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_read err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	switch(value) {
+	case 0:
+		regs.value[0] &= 0xef;
+		break;
+	case 1:
+		regs.value[0] |= 0x10;
+		break;
+	default:
+		break;
+	}
+	ret = sensor_write(sd, regs.reg_num, regs.value);
+	if (ret < 0) {
+		csi_dev_err("sensor_write err at sensor_s_autowb!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->autowb = value;
+	return 0;
+}
+
+static int sensor_g_hue(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_hue(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+
+static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
+{
+	return -EINVAL;
+}
+
+static int sensor_s_gain(struct v4l2_subdev *sd, int value)
+{
+	return -EINVAL;
+}
+/* *********************************************end of ******************************************** */
+
+static int sensor_g_brightness(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->brightness;
+	return 0;
+}
+
+static int sensor_s_brightness(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_brightness_neg4_regs, ARRAY_SIZE(sensor_brightness_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_brightness_neg3_regs, ARRAY_SIZE(sensor_brightness_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_brightness_neg2_regs, ARRAY_SIZE(sensor_brightness_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_brightness_neg1_regs, ARRAY_SIZE(sensor_brightness_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_brightness_zero_regs, ARRAY_SIZE(sensor_brightness_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_brightness_pos1_regs, ARRAY_SIZE(sensor_brightness_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_brightness_pos2_regs, ARRAY_SIZE(sensor_brightness_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_brightness_pos3_regs, ARRAY_SIZE(sensor_brightness_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_brightness_pos4_regs, ARRAY_SIZE(sensor_brightness_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_brightness!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->brightness = value;
+	return 0;
+}
+
+static int sensor_g_contrast(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->contrast;
+	return 0;
+}
+
+static int sensor_s_contrast(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_contrast_neg4_regs, ARRAY_SIZE(sensor_contrast_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_contrast_neg3_regs, ARRAY_SIZE(sensor_contrast_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_contrast_neg2_regs, ARRAY_SIZE(sensor_contrast_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_contrast_neg1_regs, ARRAY_SIZE(sensor_contrast_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_contrast_zero_regs, ARRAY_SIZE(sensor_contrast_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_contrast_pos1_regs, ARRAY_SIZE(sensor_contrast_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_contrast_pos2_regs, ARRAY_SIZE(sensor_contrast_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_contrast_pos3_regs, ARRAY_SIZE(sensor_contrast_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_contrast_pos4_regs, ARRAY_SIZE(sensor_contrast_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_contrast!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->contrast = value;
+	return 0;
+}
+
+static int sensor_g_saturation(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->saturation;
+	return 0;
+}
+
+static int sensor_s_saturation(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_saturation_neg4_regs, ARRAY_SIZE(sensor_saturation_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_saturation_neg3_regs, ARRAY_SIZE(sensor_saturation_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_saturation_neg2_regs, ARRAY_SIZE(sensor_saturation_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_saturation_neg1_regs, ARRAY_SIZE(sensor_saturation_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_saturation_zero_regs, ARRAY_SIZE(sensor_saturation_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_saturation_pos1_regs, ARRAY_SIZE(sensor_saturation_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_saturation_pos2_regs, ARRAY_SIZE(sensor_saturation_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_saturation_pos3_regs, ARRAY_SIZE(sensor_saturation_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_saturation_pos4_regs, ARRAY_SIZE(sensor_saturation_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_saturation!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->saturation = value;
+	return 0;
+}
+
+static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+
+	*value = info->exp;
+	return 0;
+}
+
+static int sensor_s_exp(struct v4l2_subdev *sd, int value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+		case -4:
+		  ret = sensor_write_array(sd, sensor_ev_neg4_regs, ARRAY_SIZE(sensor_ev_neg4_regs));
+			break;
+		case -3:
+			ret = sensor_write_array(sd, sensor_ev_neg3_regs, ARRAY_SIZE(sensor_ev_neg3_regs));
+			break;
+		case -2:
+			ret = sensor_write_array(sd, sensor_ev_neg2_regs, ARRAY_SIZE(sensor_ev_neg2_regs));
+			break;
+		case -1:
+			ret = sensor_write_array(sd, sensor_ev_neg1_regs, ARRAY_SIZE(sensor_ev_neg1_regs));
+			break;
+		case 0:
+			ret = sensor_write_array(sd, sensor_ev_zero_regs, ARRAY_SIZE(sensor_ev_zero_regs));
+			break;
+		case 1:
+			ret = sensor_write_array(sd, sensor_ev_pos1_regs, ARRAY_SIZE(sensor_ev_pos1_regs));
+			break;
+		case 2:
+			ret = sensor_write_array(sd, sensor_ev_pos2_regs, ARRAY_SIZE(sensor_ev_pos2_regs));
+			break;
+		case 3:
+			ret = sensor_write_array(sd, sensor_ev_pos3_regs, ARRAY_SIZE(sensor_ev_pos3_regs));
+			break;
+		case 4:
+			ret = sensor_write_array(sd, sensor_ev_pos4_regs, ARRAY_SIZE(sensor_ev_pos4_regs));
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_write_array err at sensor_s_exp!\n");
+		return ret;
+	}
+
+	msleep(10);
+
+	info->exp = value;
+	return 0;
+}
+
+static int sensor_g_wb(struct v4l2_subdev *sd, int *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_whiteblance *wb_type = (enum v4l2_whiteblance*)value;
+
+	*wb_type = info->wb;
+
+	return 0;
+}
+
+static int sensor_s_wb(struct v4l2_subdev *sd,
+		enum v4l2_whiteblance value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	if (value == V4L2_WB_AUTO) {
+		ret = sensor_s_autowb(sd, 1);
+		return ret;
+	}
+	else {
+		ret = sensor_s_autowb(sd, 0);
+		if(ret < 0) {
+			csi_dev_err("sensor_s_autowb error, return %x!\n",ret);
+			return ret;
+		}
+
+		switch (value) {
+			case V4L2_WB_CLOUD:
+			  ret = sensor_write_array(sd, sensor_wb_cloud_regs, ARRAY_SIZE(sensor_wb_cloud_regs));
+				break;
+			case V4L2_WB_DAYLIGHT:
+				ret = sensor_write_array(sd, sensor_wb_daylight_regs, ARRAY_SIZE(sensor_wb_daylight_regs));
+				break;
+			case V4L2_WB_INCANDESCENCE:
+				ret = sensor_write_array(sd, sensor_wb_incandescence_regs, ARRAY_SIZE(sensor_wb_incandescence_regs));
+				break;
+			case V4L2_WB_FLUORESCENT:
+				ret = sensor_write_array(sd, sensor_wb_fluorescent_regs, ARRAY_SIZE(sensor_wb_fluorescent_regs));
+				break;
+			case V4L2_WB_TUNGSTEN:
+				ret = sensor_write_array(sd, sensor_wb_tungsten_regs, ARRAY_SIZE(sensor_wb_tungsten_regs));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_wb error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->wb = value;
+	return 0;
+}
+
+static int sensor_g_colorfx(struct v4l2_subdev *sd,
+		__s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_colorfx *clrfx_type = (enum v4l2_colorfx*)value;
+
+	*clrfx_type = info->clrfx;
+	return 0;
+}
+
+static int sensor_s_colorfx(struct v4l2_subdev *sd,
+		enum v4l2_colorfx value)
+{
+	int ret;
+	struct sensor_info *info = to_state(sd);
+
+	switch (value) {
+	case V4L2_COLORFX_NONE:
+	  ret = sensor_write_array(sd, sensor_colorfx_none_regs, ARRAY_SIZE(sensor_colorfx_none_regs));
+		break;
+	case V4L2_COLORFX_BW:
+		ret = sensor_write_array(sd, sensor_colorfx_bw_regs, ARRAY_SIZE(sensor_colorfx_bw_regs));
+		break;
+	case V4L2_COLORFX_SEPIA:
+		ret = sensor_write_array(sd, sensor_colorfx_sepia_regs, ARRAY_SIZE(sensor_colorfx_sepia_regs));
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		ret = sensor_write_array(sd, sensor_colorfx_negative_regs, ARRAY_SIZE(sensor_colorfx_negative_regs));
+		break;
+	case V4L2_COLORFX_EMBOSS:
+		ret = sensor_write_array(sd, sensor_colorfx_emboss_regs, ARRAY_SIZE(sensor_colorfx_emboss_regs));
+		break;
+	case V4L2_COLORFX_SKETCH:
+		ret = sensor_write_array(sd, sensor_colorfx_sketch_regs, ARRAY_SIZE(sensor_colorfx_sketch_regs));
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		ret = sensor_write_array(sd, sensor_colorfx_sky_blue_regs, ARRAY_SIZE(sensor_colorfx_sky_blue_regs));
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		ret = sensor_write_array(sd, sensor_colorfx_grass_green_regs, ARRAY_SIZE(sensor_colorfx_grass_green_regs));
+		break;
+	case V4L2_COLORFX_SKIN_WHITEN:
+		ret = sensor_write_array(sd, sensor_colorfx_skin_whiten_regs, ARRAY_SIZE(sensor_colorfx_skin_whiten_regs));
+		break;
+	case V4L2_COLORFX_VIVID:
+		ret = sensor_write_array(sd, sensor_colorfx_vivid_regs, ARRAY_SIZE(sensor_colorfx_vivid_regs));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret < 0) {
+		csi_dev_err("sensor_s_colorfx error, return %x!\n",ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	info->clrfx = value;
+	return 0;
+}
+
+static int sensor_g_flash_mode(struct v4l2_subdev *sd,
+    __s32 *value)
+{
+	struct sensor_info *info = to_state(sd);
+	enum v4l2_flash_mode *flash_mode = (enum v4l2_flash_mode*)value;
+
+	*flash_mode = info->flash_mode;
+	return 0;
+}
+
+static int sensor_s_flash_mode(struct v4l2_subdev *sd,
+    enum v4l2_flash_mode value)
+{
+	struct sensor_info *info = to_state(sd);
+	struct csi_dev *dev=(struct csi_dev *)dev_get_drvdata(sd->v4l2_dev->dev);
+	char csi_flash_str[32];
+	int flash_on,flash_off;
+
+	if(info->ccm_info->iocfg == 0) {
+		strcpy(csi_flash_str,"csi_flash");
+	} else if(info->ccm_info->iocfg == 1) {
+	  strcpy(csi_flash_str,"csi_flash_b");
+	}
+
+	flash_on = (dev->flash_pol!=0)?1:0;
+	flash_off = (flash_on==1)?0:1;
+
+	switch (value) {
+	case V4L2_FLASH_MODE_OFF:
+	  gpio_write_one_pin_value(dev->csi_pin_hd,flash_off,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_AUTO:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_ON:
+		gpio_write_one_pin_value(dev->csi_pin_hd,flash_on,csi_flash_str);
+		break;
+	case V4L2_FLASH_MODE_TORCH:
+		return -EINVAL;
+		break;
+	case V4L2_FLASH_MODE_RED_EYE:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	info->flash_mode = value;
+	return 0;
+}
+
+static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_g_brightness(sd, &ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_g_contrast(sd, &ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_g_saturation(sd, &ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_g_hue(sd, &ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_g_vflip(sd, &ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_g_hflip(sd, &ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_g_gain(sd, &ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_g_autogain(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_g_exp(sd, &ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_g_autoexp(sd, &ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_g_wb(sd, &ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_g_autowb(sd, &ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_g_colorfx(sd,	&ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return sensor_g_flash_mode(sd, &ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		return sensor_s_brightness(sd, ctrl->value);
+	case V4L2_CID_CONTRAST:
+		return sensor_s_contrast(sd, ctrl->value);
+	case V4L2_CID_SATURATION:
+		return sensor_s_saturation(sd, ctrl->value);
+	case V4L2_CID_HUE:
+		return sensor_s_hue(sd, ctrl->value);
+	case V4L2_CID_VFLIP:
+		return sensor_s_vflip(sd, ctrl->value);
+	case V4L2_CID_HFLIP:
+		return sensor_s_hflip(sd, ctrl->value);
+	case V4L2_CID_GAIN:
+		return sensor_s_gain(sd, ctrl->value);
+	case V4L2_CID_AUTOGAIN:
+		return sensor_s_autogain(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE:
+		return sensor_s_exp(sd, ctrl->value);
+	case V4L2_CID_EXPOSURE_AUTO:
+		return sensor_s_autoexp(sd,
+				(enum v4l2_exposure_auto_type) ctrl->value);
+	case V4L2_CID_DO_WHITE_BALANCE:
+		return sensor_s_wb(sd,
+				(enum v4l2_whiteblance) ctrl->value);
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		return sensor_s_autowb(sd, ctrl->value);
+	case V4L2_CID_COLORFX:
+		return sensor_s_colorfx(sd,
+				(enum v4l2_colorfx) ctrl->value);
+	case V4L2_CID_CAMERA_FLASH_MODE:
+	  return sensor_s_flash_mode(sd,
+	      (enum v4l2_flash_mode) ctrl->value);
+	}
+	return -EINVAL;
+}
+
+static int sensor_g_chip_ident(struct v4l2_subdev *sd,
+		struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+static const struct v4l2_subdev_core_ops sensor_core_ops = {
+	.g_chip_ident = sensor_g_chip_ident,
+	.g_ctrl = sensor_g_ctrl,
+	.s_ctrl = sensor_s_ctrl,
+	.queryctrl = sensor_queryctrl,
+	.reset = sensor_reset,
+	.init = sensor_init,
+	.s_power = sensor_power,
+	.ioctl = sensor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops sensor_video_ops = {
+	.enum_mbus_fmt = sensor_enum_fmt,//linux-3.0
+	.try_mbus_fmt = sensor_try_fmt,//linux-3.0
+	.s_mbus_fmt = sensor_s_fmt,//linux-3.0
+	.s_parm = sensor_s_parm,//linux-3.0
+	.g_parm = sensor_g_parm,//linux-3.0
+};
+
+static const struct v4l2_subdev_ops sensor_ops = {
+	.core = &sensor_core_ops,
+	.video = &sensor_video_ops,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static int sensor_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd;
+	struct sensor_info *info;
+//	int ret;
+
+	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
+	if (info == NULL)
+		return -ENOMEM;
+	sd = &info->sd;
+	v4l2_i2c_subdev_init(sd, client, &sensor_ops);
+
+	info->fmt = &sensor_formats[0];
+	info->ccm_info = &ccm_info_con;
+
+	info->brightness = 0;
+	info->contrast = 0;
+	info->saturation = 0;
+	info->hue = 0;
+	info->hflip = 0;
+	info->vflip = 0;
+	info->gain = 0;
+	info->autogain = 1;
+	info->exp = 0;
+	info->autoexp = 0;
+	info->autowb = 1;
+	info->wb = 0;
+	info->clrfx = 0;
+
+//	info->clkrc = 1;	/* 30fps */
+
+	return 0;
+}
+
+
+static int sensor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(to_state(sd));
+	return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{ "sp0838", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+//linux-3.0
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+	.name = "sp0838",
+	},
+	.probe = sensor_probe,
+	.remove = sensor_remove,
+	.id_table = sensor_id,
+};
+static __init int init_sensor(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+static __exit void exit_sensor(void)
+{
+  i2c_del_driver(&sensor_driver);
+}
+
+module_init(init_sensor);
+module_exit(exit_sensor);
diff --git a/drivers/media/video/sun4i_csi/include/sun4i_csi_core.h b/drivers/media/video/sun4i_csi/include/sun4i_csi_core.h
new file mode 100644
index 0000000..06b7779
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/include/sun4i_csi_core.h
@@ -0,0 +1,393 @@
+/*
+ * drivers/media/video/sun4i_csi/include/sun4i_csi_core.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Sun4i Camera core header file
+ * Author:raymonxiu
+*/
+#ifndef _SUN4I_CSI_CORE_H_
+#define _SUN4I_CSI_CORE_H_
+
+#include <linux/types.h>
+#include <media/videobuf-core.h>
+#include <media/v4l2-device.h>
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <media/v4l2-mediabus.h>//linux-3.0
+
+//for internel driver debug
+#define DBG_EN   		0
+//debug level 0~3
+#define DBG_LEVEL 	3
+
+//for internel driver debug
+#if(DBG_EN==1)
+#define csi_dbg(l,x,arg...) if(l <= DBG_LEVEL) printk("[CSI_DEBUG]"x,##arg)
+#else
+#define csi_dbg(l,x,arg...)
+#endif
+
+//print when error happens
+#define csi_err(x,arg...) printk(KERN_INFO"[CSI_ERR]"x,##arg)
+
+//print unconditional, for important info
+#define csi_print(x,arg...) printk(KERN_INFO"[CSI]"x,##arg)
+
+#define MAX_NUM_INPUTS 2
+
+struct csi_subdev_info {
+	const char *name;
+	struct i2c_board_info board_info;
+};
+
+/*
+ * input data format
+ */
+typedef enum tag_CSI_INPUT_FMT
+{
+    CSI_RAW=0,     /* raw stream  */
+    CSI_BAYER,     /* byer rgb242 */
+    CSI_CCIR656,   /* ccir656     */
+    CSI_YUV422,    /* yuv422      */
+}__csi_input_fmt_t;
+
+/*
+ * output data format
+ */
+typedef enum tag_CSI_OUTPUT_FMT
+{
+    /* only when input is raw */
+    CSI_PASS_THROUTH = 0,                /* raw */
+
+    /* only when input is bayer */
+    CSI_PLANAR_RGB242 = 0,               /* planar rgb242 */
+
+    /* only when input is ccir656 */
+    CSI_FIELD_PLANAR_YUV422 = 0,         /* parse a field(odd or even) into planar yuv420 */
+    CSI_FIELD_PLANAR_YUV420 = 1,         /* parse a field(odd or even) into planar yuv420 */
+    CSI_FRAME_PLANAR_YUV420 = 2,
+    CSI_FRAME_PLANAR_YUV422 = 3,
+    CSI_FIELD_UV_CB_YUV422  = 4,         /* parse and reconstruct evry 2 fields(odd and even) into a frame, format is planar yuv420 */
+    CSI_FIELD_UV_CB_YUV420  = 5,
+    CSI_FRAME_UV_CB_YUV420  = 6,
+    CSI_FRAME_UV_CB_YUV422  = 7,
+    CSI_FIELD_MB_YUV422     = 8,
+    CSI_FIELD_MB_YUV420     = 9,
+    CSI_FRAME_MB_YUV422     = 10,
+    CSI_FRAME_MB_YUV420     = 11,
+    CSI_INTLC_INTLV_YUV422  = 15,
+
+    /* only when input is yuv422 */
+    CSI_PLANAR_YUV422=0,                /* parse yuv422 into planar yuv422 */
+    CSI_PLANAR_YUV420=1,                /* parse yuv422 into planar yuv420 */
+    CSI_UV_CB_YUV422=4,
+    CSI_UV_CB_YUV420=5,
+    CSI_MB_YUV422=8,
+    CSI_MB_YUV420=9,
+}__csi_output_fmt_t;
+
+/*
+ * input field selection, only when input is ccir656
+ */
+typedef enum tag_CSI_FIELD_SEL
+{
+    CSI_ODD,    /* odd field */
+    CSI_EVEN,   /* even field */
+    CSI_EITHER, /* either field */
+}__csi_field_sel_t;
+
+/*
+ * input data sequence
+ */
+typedef enum tag_CSI_SEQ
+{
+    /* only when input is yuv422 */
+    CSI_YUYV=0,
+    CSI_YVYU,
+    CSI_UYVY,
+    CSI_VYUY,
+
+    /* only when input is byer */
+    CSI_RGRG=0,               /* first line sequence is RGRG... */
+    CSI_GRGR,                 /* first line sequence is GRGR... */
+    CSI_BGBG,                 /* first line sequence is BGBG... */
+    CSI_GBGB,                 /* first line sequence is GBGB... */
+}__csi_seq_t;
+
+/*
+ * input reference signal polarity
+ */
+typedef enum tag_CSI_REF
+{
+    CSI_LOW,    /* active low */
+    CSI_HIGH,   /* active high */
+}__csi_ref_t;
+
+/*
+ * input data valid of the input clock edge type
+ */
+typedef enum tag_CSI_CLK
+{
+    CSI_FALLING,    /* active falling */
+    CSI_RISING,     /* active rising */
+}__csi_clk_t;
+
+/*
+ * csi mode configuration
+ */
+typedef struct tag_CSI_CONF
+{
+    __csi_input_fmt_t  input_fmt;   /* input data format */
+    __csi_output_fmt_t output_fmt;  /* output data format */
+    __csi_field_sel_t  field_sel;   /* input field selection */
+    __csi_seq_t        seq;         /* input data sequence */
+    __csi_ref_t        vref;        /* input vref signal polarity */
+    __csi_ref_t        href;        /* input href signal polarity */
+    __csi_clk_t        clock;       /* input data valid of the input clock edge type */
+}__csi_conf_t;
+
+
+
+/*
+ * csi buffer
+ */
+
+typedef enum tag_CSI_BUF
+{
+    CSI_BUF_0_A,    /* FIFO for Y address A */
+    CSI_BUF_0_B,    /* FIFO for Y address B */
+    CSI_BUF_1_A,    /* FIFO for Cb address A */
+    CSI_BUF_1_B,    /* FIFO for Cb address B */
+    CSI_BUF_2_A,    /* FIFO for Cr address A */
+    CSI_BUF_2_B,    /* FIFO for Cr address B */
+}__csi_buf_t;
+
+/*
+ * csi capture status
+ */
+typedef struct tag_CSI_CAPTURE_STATUS
+{
+    _Bool picture_in_progress;
+    _Bool video_in_progress;
+}__csi_capture_status;
+
+
+/*
+ * csi double buffer
+ */
+typedef enum tag_CSI_DOUBLE_BUF
+{
+    CSI_BUF_A,
+    CSI_BUF_B,
+}__csi_double_buf_t;
+
+/*
+ * csi double buffer status
+ */
+typedef struct tag_CSI_DOUBLE_BUF_STATUS
+{
+    _Bool             enable;   /* double buffer enable */
+    __csi_double_buf_t cur;     /* current frame selected output type, buffer A or B*/
+    __csi_double_buf_t next;    /* next frame output type, buffer A or B */
+}__csi_double_buf_status_t;
+
+/*
+ * csi interrupt
+ */
+typedef enum tag_CSI_INT
+{
+    CSI_INT_CAPTURE_DONE     = 0X1,
+    CSI_INT_FRAME_DONE       = 0X2,
+    CSI_INT_BUF_0_OVERFLOW   = 0X4,
+    CSI_INT_BUF_1_OVERFLOW   = 0X8,
+    CSI_INT_BUF_2_OVERFLOW   = 0X10,
+    CSI_INT_PROTECTION_ERROR = 0X20,
+    CSI_INT_HBLANK_OVERFLOW  = 0X40,
+    CSI_INT_VSYNC_TRIG       = 0X80,
+}__csi_int_t;
+
+/*
+ * csi interrupt status
+ */
+typedef struct tag_CSI_INT_STATUS
+{
+    _Bool capture_done;
+    _Bool frame_done;
+    _Bool buf_0_overflow;
+    _Bool buf_1_overflow;
+    _Bool buf_2_overflow;
+    _Bool protection_error;
+    _Bool hblank_overflow;
+    _Bool vsync_trig;
+}__csi_int_status_t;
+
+/*
+ * csi sub device info
+ */
+typedef struct tag_CSI_SUBDEV_INFO
+{
+    int								 mclk;				/* the mclk frequency for sensor module in HZ unit*/
+    __csi_ref_t        vref;        /* input vref signal polarity */
+    __csi_ref_t        href;        /* input href signal polarity */
+    __csi_clk_t        clock;       /* input data valid of the input clock edge type */
+    int								 iocfg;				/*0 for csi back , 1 for csi front*/
+}__csi_subdev_info_t;
+struct csi_buf_addr {
+	dma_addr_t	y;
+	dma_addr_t	cb;
+	dma_addr_t	cr;
+};
+
+struct csi_fmt {
+	u8					name[32];
+	enum v4l2_mbus_pixelcode					ccm_fmt;//linux-3.0
+	u32   				fourcc;          /* v4l2 format id */
+	__csi_input_fmt_t	input_fmt;
+	__csi_output_fmt_t 	output_fmt;
+	int   				depth;
+	u16	  				planes_cnt;
+};
+
+struct csi_size{
+	u32		csi_width;
+	u32		csi_height;
+};
+
+/* buffer for one video frame */
+struct csi_buffer {
+	struct videobuf_buffer vb;
+	struct csi_fmt        *fmt;
+};
+
+struct csi_dmaqueue {
+	struct list_head active;
+
+	/* Counters to control fps rate */
+	int frame;
+	int ini_jiffies;
+};
+
+static LIST_HEAD(csi_devlist);
+
+struct ccm_config {
+	char ccm[I2C_NAME_SIZE];
+	char iovdd_str[32];
+	char avdd_str[32];
+	char dvdd_str[32];
+	int twi_id;
+	uint i2c_addr;
+	int vflip;
+	int hflip;
+	int stby_mode;
+	int interface;
+	int flash_pol;
+	struct regulator 	 *iovdd;		  /*interface voltage source of sensor module*/
+	struct regulator 	 *avdd;			/*anlog voltage source of sensor module*/
+	struct regulator 	 *dvdd;			/*core voltage source of sensor module*/
+	__csi_subdev_info_t ccm_info;
+	struct v4l2_subdev			*sd;
+};
+
+struct csi_dev {
+	struct list_head       	csi_devlist;
+	struct v4l2_device 	   	v4l2_dev;
+	struct v4l2_subdev			*sd;
+	struct platform_device	*pdev;
+
+	int						id;
+
+	spinlock_t              slock;
+
+	/* various device info */
+	struct video_device     *vfd;
+
+	struct csi_dmaqueue     vidq;
+
+	/* Several counters */
+	unsigned 		   		ms;
+	unsigned long           jiffies;
+
+	/* Input Number */
+	int			   			input;
+
+	/* video capture */
+	struct csi_fmt          *fmt;
+	unsigned int            width;
+	unsigned int            height;
+	unsigned int						frame_size;
+	struct videobuf_queue   vb_vidq;
+
+	/*working state*/
+	unsigned long 		   	generating;
+	int						opened;
+
+	/*pin,clock,irq resource*/
+	int							csi_pin_hd;
+	struct clk				*csi_clk_src;
+	struct clk				*csi_ahb_clk;
+	struct clk				*csi_module_clk;
+	struct clk				*csi_dram_clk;
+	struct clk				*csi_isp_src_clk;
+	struct clk				*csi_isp_clk;
+	int						irq;
+	void __iomem			*regs;
+	struct resource			*regs_res;
+
+	/*power issue*/
+
+	int								 stby_mode;
+	struct regulator 	 *iovdd;		  /*interface voltage source of sensor module*/
+  struct regulator 	 *avdd;			/*anlog voltage source of sensor module*/
+  struct regulator 	 *dvdd;			/*core voltage source of sensor module*/
+
+	/* attribution */
+	int interface;
+	int vflip;
+	int hflip;
+	int flash_pol;
+
+	/*parameters*/
+	__csi_conf_t			csi_mode;
+	struct csi_buf_addr		csi_buf_addr;
+
+	/* ccm config */
+  int dev_qty;
+	int module_flag;
+	__csi_subdev_info_t *ccm_info;  /*current config*/
+	struct ccm_config *ccm_cfg[MAX_NUM_INPUTS];
+};
+
+void  bsp_csi_open(struct csi_dev *dev);
+void  bsp_csi_close(struct csi_dev *dev);
+void  bsp_csi_configure(struct csi_dev *dev,__csi_conf_t *mode);
+void  bsp_csi_double_buffer_enable(struct csi_dev *dev);
+void  bsp_csi_double_buffer_disable(struct csi_dev *dev);
+void  bsp_csi_capture_video_start(struct csi_dev *dev);
+void  bsp_csi_capture_video_stop(struct csi_dev *dev);
+void  bsp_csi_capture_picture(struct csi_dev *dev);
+void  bsp_csi_capture_get_status(struct csi_dev *dev,__csi_capture_status * status);
+void 	bsp_csi_set_size(struct csi_dev *dev, u32 length_h, u32 length_v, u32 buf_length_h);
+void 	bsp_csi_set_offset(struct csi_dev *dev,u32 start_h, u32 start_v);
+void  bsp_csi_int_enable(struct csi_dev *dev,__csi_int_t interrupt);
+void  bsp_csi_int_disable(struct csi_dev *dev,__csi_int_t interrupt);
+
+#endif  /* _CSI_H_ */
diff --git a/drivers/media/video/sun4i_csi/include/sun4i_dev_csi.h b/drivers/media/video/sun4i_csi/include/sun4i_dev_csi.h
new file mode 100644
index 0000000..4c9f790
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/include/sun4i_dev_csi.h
@@ -0,0 +1,52 @@
+/*
+ * drivers/media/video/sun4i_csi/include/sun4i_dev_csi.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __DEV_CSI_H__
+#define __DEV_CSI_H__
+
+
+/*
+ * ioctl to proccess sub device
+ */
+typedef enum tag_CSI_SUBDEV_CMD
+{
+	CSI_SUBDEV_CMD_GET_INFO = 0x01,
+	CSI_SUBDEV_CMD_SET_INFO = 0x02,
+}__csi_subdev_cmd_t;
+
+/*
+ * control id
+ */
+
+typedef enum tag_CSI_SUBDEV_CTL_ID
+{
+	CSI_SUBDEV_INIT_FULL = 0x01,
+	CSI_SUBDEV_INIT_SIMP = 0x02,
+	CSI_SUBDEV_RST_ON = 0x03,
+	CSI_SUBDEV_RST_OFF = 0x04,
+	CSI_SUBDEV_RST_PUL = 0x05,
+	CSI_SUBDEV_STBY_ON = 0x06,
+	CSI_SUBDEV_STBY_OFF = 0x07,
+	CSI_SUBDEV_PWR_ON = 0x08,
+	CSI_SUBDEV_PWR_OFF = 0x09,
+}__csi_subdev_ctl_id_t;
+#endif
diff --git a/drivers/media/video/sun4i_csi/readme.txt b/drivers/media/video/sun4i_csi/readme.txt
new file mode 100644
index 0000000..d66ac7a
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/readme.txt
@@ -0,0 +1,75 @@
+/*
+ * drivers/media/video/sun4i_csi/readme.txt
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+===========================================
+
+Version: V1_11
+
+Author:  raymonxiu
+
+Date:     2012-1-19 19:25:36
+
+Description:
+
+newest module list:(X = 0 or 1)
+insmod sun4i_csiX.ko ccm="ov7670" i2c_addr=0x42
+insmod sun4i_csiX.ko ccm="gc0308" i2c_addr=0x42
+insmod sun4i_csiX.ko ccm="gt2005" i2c_addr=0x78
+insmod sun4i_csiX.ko ccm="hi704"  i2c_addr=0x60
+insmod sun4i_csiX.ko ccm="sp0838" i2c_addr=0x30
+insmod sun4i_csiX.ko ccm="mt9m112" i2c_addr=0xba
+insmod sun4i_csiX.ko ccm="mt9m113" i2c_addr=0x78
+insmod sun4i_csiX.ko ccm="ov2655" i2c_addr=0x60
+insmod sun4i_csiX.ko ccm="hi253" i2c_addr=0x40
+insmod sun4i_csiX.ko ccm="gc0307" i2c_addr=0x42
+insmod sun4i_csiX.ko ccm="mt9d112" i2c_addr=0x78
+insmod sun4i_csiX.ko ccm="ov5640" i2c_addr=0x78
+
+V1_11
+CSI: Mainly fix bugs on mt9m112,ov5640 and ov7670
+1) Fix bug on calling poll or read before streamon
+2) Fix bug on mt9m112 and ov5640 multiplex use
+3) Fix ov7670 sensor init
+4) Modify the delay on ov2655 after every i2c command
+5) Modify camera debug info
+
+V1_10
+CSI: Fix bugs, add new modules support and modity power/standby interface
+1) Fix bugs for CTS test
+2) Fix bugs for crash when insmod after rmmod
+3) Add default format for csi driver
+4) Modify the power on/off,stanby on/off interface
+5) Fix bugs for multipex dual sensors using one csi
+6) Add gc0307, mt9d112 and ov5640 modules support
+7) Fix gc0308 AWB alternation bug
+
+V1_02
+CSI: Change clock source to video pll 1 and add code for C version IC
+
+V1_01
+CSI: Add HI253 support IC version detection and fix HI704 i2c bug
+
+V1_00
+CSI:Initial version for linux 3.0.8
+1) Ported from linux2.3.36
+
+
diff --git a/drivers/media/video/sun4i_csi/test/Makefile b/drivers/media/video/sun4i_csi/test/Makefile
new file mode 100644
index 0000000..773f03f
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/test/Makefile
@@ -0,0 +1,15 @@
+CC := arm-none-linux-gnueabi-gcc
+LINUX_DIR=/home/raymonxiu/lichee/linux-v2.6.36
+CFLAGS := -I$(LINUX_DIR)
+TARGET := app_test
+
+.PHONY: all clean
+
+
+all: $(TARGET)
+
+app_test:app_test_ok.c
+	$(CC) $(CFLAGS) -static  $^  -o  $@
+
+clean:
+	rm -rf $(TARGET)
diff --git a/drivers/media/video/sun4i_csi/test/app_test b/drivers/media/video/sun4i_csi/test/app_test
new file mode 100644
index 0000000..c54a5ab
Binary files /dev/null and b/drivers/media/video/sun4i_csi/test/app_test differ
diff --git a/drivers/media/video/sun4i_csi/test/app_test_ok.c b/drivers/media/video/sun4i_csi/test/app_test_ok.c
new file mode 100644
index 0000000..e6a51f6
--- /dev/null
+++ b/drivers/media/video/sun4i_csi/test/app_test_ok.c
@@ -0,0 +1,1215 @@
+/*
+ * drivers/media/video/sun4i_csi/test/app_test_ok.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+//#å äºç¹æ³¨é
+
+//#Rockie Cheng
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include <getopt.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <malloc.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <asm/types.h>
+#include <linux/videodev2.h>
+#include <time.h>
+#include <linux/fb.h>
+//#include "../../../../video/sunxi/drv_display.h"//modify this
+#include "./../../../../video/sunxi/drv_display.h"//modify this
+
+//#define READ_NUM 5000
+#define DISPLAY
+#define LCD_WIDTH		800
+#define LCD_HEIGHT	480
+
+#define CLEAR(x) memset (&(x), 0, sizeof (x))
+
+int count;
+
+struct buffer {
+        void *                  start;
+        size_t                  length;
+};
+
+struct size{
+	int width;
+	int height;
+};
+
+static char *           dev_name        = "/dev/video0";//æåå¤´è®¾å¤å
+static int              fd              = -1;
+struct buffer *         buffers         = NULL;
+static unsigned int     n_buffers       = 0;
+
+FILE *file_fd;
+static unsigned long file_length;
+static unsigned char *file_name;
+
+int disphd;
+unsigned int hlay;
+int sel = 0;//which screen 0/1
+__disp_layer_info_t layer_para;
+__disp_video_fb_t video_fb;
+__u32 arg[4];
+
+//struct timeval time_test;
+//struct timezone tz;
+
+struct size input_size;
+struct size disp_size;
+int  csi_format;
+__disp_pixel_fmt_t  disp_format;
+__disp_pixel_mod_t  disp_mode;
+__disp_pixel_seq_t	disp_seq;
+int	 read_num=100;
+int  test_num=10;
+int  req_frame_num;
+int	 fps=30;
+int	 fps_test=0;
+int	 invalid_ops=0;
+int  invalid_fmt_test=0;
+int	 control_test=0;
+int  ioctl_test=0;
+int	 lost_frame_test=0;
+struct test_case{
+		int 							  input_width;
+		int									input_height;
+		int 							  disp_width;
+		int									disp_height;
+		int 								csi_format;
+		__disp_pixel_fmt_t 	disp_format;
+		__disp_pixel_mod_t	disp_mode;
+		__disp_pixel_seq_t	disp_seq;
+};
+
+struct test_case test_case_set[]={
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV420,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 328,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 248,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 312,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 232,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 648,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 488,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 632,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 472,
+		.csi_format   = V4L2_PIX_FMT_YUV422P,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUV420,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_NV16,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_UV_COMBINED,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_NV12,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_UV_COMBINED,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUV420,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_PLANAR,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_NV16,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_NON_MB_UV_COMBINED,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_NV12,
+		.disp_format	= DISP_FORMAT_YUV420,
+		.disp_mode		= DISP_MOD_NON_MB_UV_COMBINED,
+		.disp_seq			= DISP_SEQ_UVUV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 328,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 248,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 312,
+		.input_height = 240,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 320,
+		.input_height = 232,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 648,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 488,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 632,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 472,
+		.csi_format   = V4L2_PIX_FMT_YUYV,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YUYV,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_YVYU,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_YVYU,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_UYVY,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_UYVY,
+	},
+	{
+		.input_width  = 640,
+		.input_height = 480,
+		.csi_format   = V4L2_PIX_FMT_VYUY,
+		.disp_format	= DISP_FORMAT_YUV422,
+		.disp_mode		= DISP_MOD_INTERLEAVED,
+		.disp_seq			= DISP_SEQ_VYUY,
+	},
+};
+
+enum v4l2_ctrl_type qc_ctrl[]=
+{
+	V4L2_CID_BRIGHTNESS,
+	V4L2_CID_CONTRAST,
+	V4L2_CID_SATURATION,
+	V4L2_CID_HUE,
+	V4L2_CID_VFLIP,
+	V4L2_CID_HFLIP,
+	V4L2_CID_GAIN,
+	V4L2_CID_AUTOGAIN,
+	V4L2_CID_EXPOSURE,
+	V4L2_CID_EXPOSURE_AUTO,
+	V4L2_CID_DO_WHITE_BALANCE,
+	V4L2_CID_AUTO_WHITE_BALANCE,
+	(V4L2_CID_BASE+31)
+};
+
+//////////////////////////////////////////////////////
+//è·åä¸å¸§æ°æ®
+//////////////////////////////////////////////////////
+static int read_frame (void)
+{
+	struct v4l2_buffer buf;
+	unsigned int i;
+
+
+	CLEAR (buf);
+	buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	buf.memory = V4L2_MEMORY_MMAP;
+
+	ioctl (fd, VIDIOC_DQBUF, &buf); //åºåééçå¸§ç¼å²
+
+
+	if((fps_test==1)||(lost_frame_test==1))
+	    printf("process image %d sec %d usec\n",buf.timestamp.tv_sec,buf.timestamp.tv_usec);
+
+
+	assert (buf.index < n_buffers);
+//	printf ("buf.index dq is %d,\n",buf.index);
+//	printf ("buf.m.offset = 0x%x\n",buf.m.offset);
+	//disp_set_addr(320,240,&buf.m.offset);
+	disp_set_addr(disp_size.width, disp_size.height,&buf.m.offset);
+
+	//printf ("press ENTER to continue!\n");
+	//getchar();
+	//fwrite(buffers[buf.index].start, buffers[buf.index].length, 1, file_fd); //å°å¶åå¥æä»¶ä¸­
+
+
+
+	if(lost_frame_test==1)
+	{
+		if(count%31==0)
+		{
+			printf("count = %d,delay\n",count);
+			for(i=0;i<0x1ffffff;i++)
+			{
+
+
+			}
+		}
+	}
+
+	ioctl (fd, VIDIOC_QBUF, &buf); //åå°å¶å¥å
+
+	return 1;
+}
+
+int disp_int(int w,int h)
+{
+	/*display start*/
+    //unsigned int h,w;
+    __u32 id = 0;
+
+    //h= 480;
+    //w= 640;
+
+	if((disphd = open("/dev/disp",O_RDWR)) == -1)
+	{
+		printf("open file /dev/disp fail. \n");
+		return 0;
+	}
+
+    arg[0] = 0;
+    ioctl(disphd, DISP_CMD_LCD_ON, (void*)arg);
+
+    //layer0
+    arg[0] = 0;
+    arg[1] = DISP_LAYER_WORK_MODE_SCALER;
+    hlay = ioctl(disphd, DISP_CMD_LAYER_REQUEST, (void*)arg);
+    if(hlay == 0)
+    {
+        printf("request layer0 fail\n");
+        return 0;
+    }
+	printf("video layer hdl:%d\n", hlay);
+
+    layer_para.mode = DISP_LAYER_WORK_MODE_SCALER;
+    layer_para.pipe = 0;
+    layer_para.fb.addr[0]       = 0;//your Y address,modify this
+    layer_para.fb.addr[1]       = 0; //your C address,modify this
+    layer_para.fb.addr[2]       = 0;
+    layer_para.fb.size.width    = w;
+    layer_para.fb.size.height   = h;
+    layer_para.fb.mode          = disp_mode;///DISP_MOD_INTERLEAVED;//DISP_MOD_NON_MB_PLANAR;//DISP_MOD_NON_MB_PLANAR;//DISP_MOD_NON_MB_UV_COMBINED;
+    layer_para.fb.format        = disp_format;//DISP_FORMAT_YUV420;//DISP_FORMAT_YUV422;//DISP_FORMAT_YUV420;
+    layer_para.fb.br_swap       = 0;
+    layer_para.fb.seq           = disp_seq;//DISP_SEQ_UVUV;//DISP_SEQ_YUYV;//DISP_SEQ_YVYU;//DISP_SEQ_UYVY;//DISP_SEQ_VYUY//DISP_SEQ_UVUV
+    layer_para.ck_enable        = 0;
+    layer_para.alpha_en         = 1;
+    layer_para.alpha_val        = 0xff;
+    layer_para.src_win.x        = 0;
+    layer_para.src_win.y        = 0;
+    layer_para.src_win.width    = w;
+    layer_para.src_win.height   = h;
+    layer_para.scn_win.x        = 0;
+    layer_para.scn_win.y        = 0;
+    layer_para.scn_win.width    = LCD_WIDTH;//800;
+    layer_para.scn_win.height   = LCD_HEIGHT;//480;
+	arg[0] = sel;
+    arg[1] = hlay;
+    arg[2] = (__u32)&layer_para;
+    ioctl(disphd,DISP_CMD_LAYER_SET_PARA,(void*)arg);
+#if 0
+    arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd,DISP_CMD_LAYER_TOP,(void*)arg);
+#endif
+    arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd,DISP_CMD_LAYER_OPEN,(void*)arg);
+
+#if 1
+	int fb_fd;
+	unsigned long fb_layer;
+	void *addr = NULL;
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (ioctl(fb_fd, FBIOGET_LAYER_HDL_0, &fb_layer) == -1) {
+		printf("get fb layer handel\n");
+	}
+
+	addr = malloc(LCD_WIDTH*LCD_HEIGHT*3);
+	memset(addr, 0xff, LCD_WIDTH*LCD_HEIGHT*3);
+	write(fb_fd, addr, LCD_WIDTH*LCD_HEIGHT*3);
+	//memset(addr, 0x12, 800*480*3);
+
+	printf("fb_layer hdl: %ld\n", fb_layer);
+	close(fb_fd);
+
+	arg[0] = 0;
+	arg[1] = fb_layer;
+	ioctl(disphd, DISP_CMD_LAYER_BOTTOM, (void *)arg);
+#endif
+}
+
+void disp_start(void)
+{
+	arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd, DISP_CMD_VIDEO_START,  (void*)arg);
+}
+
+void disp_stop(void)
+{
+	arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd, DISP_CMD_VIDEO_STOP,  (void*)arg);
+}
+
+int disp_on()
+{
+		arg[0] = 0;
+    ioctl(disphd, DISP_CMD_LCD_ON, (void*)arg);
+}
+
+int disp_set_addr(int w,int h,int *addr)
+{
+#if 0
+	layer_para.fb.addr[0]       = *addr;//your Y address,modify this
+    layer_para.fb.addr[1]       = *addr+w*h; //your C address,modify this
+    layer_para.fb.addr[2]       = *addr+w*h*3/2;
+
+    arg[0] = sel;
+    arg[1] = hlay;
+    arg[2] = (__u32)&layer_para;
+    ioctl(disphd,DISP_CMD_LAYER_SET_PARA,(void*)arg);
+#endif
+	__disp_video_fb_t  fb_addr;
+	memset(&fb_addr, 0, sizeof(__disp_video_fb_t));
+
+	fb_addr.interlace       = 0;
+	fb_addr.top_field_first = 0;
+	fb_addr.frame_rate      = 25;
+	fb_addr.addr[0] = *addr;
+//	fb_addr.addr[1] = *addr + w * h;
+//	fb_addr.addr[2] = *addr + w*h*3/2;
+
+
+	switch(csi_format){
+		case V4L2_PIX_FMT_YUV422P:
+    case V4L2_PIX_FMT_YUYV:
+    case V4L2_PIX_FMT_YVYU:
+    case V4L2_PIX_FMT_UYVY:
+    case V4L2_PIX_FMT_VYUY:
+    	fb_addr.addr[1]       = *addr+w*h; //your C address,modify this
+    	fb_addr.addr[2]       = *addr+w*h*3/2;
+    	break;
+    case V4L2_PIX_FMT_YUV420:
+    	fb_addr.addr[1]       = *addr+w*h; //your C address,modify this
+    	fb_addr.addr[2]       = *addr+w*h*5/4;
+    	break;
+    case V4L2_PIX_FMT_NV16:
+    case V4L2_PIX_FMT_NV12:
+    case V4L2_PIX_FMT_HM12:
+    	fb_addr.addr[1]       = *addr+w*h; //your C address,modify this
+    	fb_addr.addr[2]       = layer_para.fb.addr[1];
+    	break;
+
+    default:
+    	printf("csi_format is not found!\n");
+    	break;
+
+  	}
+
+  	fb_addr.id = 0;  //TODO
+
+    arg[0] = sel;
+    arg[1] = hlay;
+    arg[2] = (__u32)&fb_addr;
+    ioctl(disphd, DISP_CMD_VIDEO_SET_FB, (void*)arg);
+}
+
+int disp_quit()
+{
+	__u32 arg[4];
+	arg[0] = 0;
+    ioctl(disphd, DISP_CMD_LCD_OFF, (void*)arg);
+
+    arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd, DISP_CMD_LAYER_CLOSE,  (void*)arg);
+
+    arg[0] = sel;
+    arg[1] = hlay;
+    ioctl(disphd, DISP_CMD_LAYER_RELEASE,  (void*)arg);
+    close (disphd);
+}
+
+int main_test (void)
+{
+	struct v4l2_capability cap;
+	struct v4l2_format fmt;
+	unsigned int i;
+	enum v4l2_buf_type type;
+	struct v4l2_cropcap cropcap;
+
+	//fd = open (dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);//æå¼è®¾å¤
+	//fd = open (dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);//æå¼è®¾å¤
+	//close (fd);
+	fd = open (dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);//æå¼è®¾å¤
+
+	if(invalid_ops)
+	{
+		if(-1 == ioctl (fd, 0xff, &cropcap))
+			printf("invalid_ops return error\n");
+	}
+	if(ioctl_test==1)
+	{
+			//Test VIDIOC_QUERYCAP
+			if (-1 == ioctl (fd, VIDIOC_QUERYCAP, &cap))//è·åæåå¤´åæ°
+				printf("VIDIOC_QUERYCAP error!\n");
+
+			printf("cap.driver=%s\n",cap.driver);
+			printf("cap.card=%s\n",cap.card);
+			printf("cap.bus_info=%s\n",cap.bus_info);
+			printf("cap.version=%d\n",cap.version);
+			printf("cap.capabilities=%d\n",cap.capabilities);
+
+		//Test VIDIOC_ENUMINPUT,VIDIOC_S_INPUT,VIDIOC_G_INPUT
+			struct v4l2_input inp;
+
+			for(i=0;i<2;i++)
+			{
+				inp.index = i;
+				if (-1 == ioctl (fd, VIDIOC_ENUMINPUT, &inp))//è·åè¾å¥åæ°
+					printf("VIDIOC_ENUMINPUT error!\n");
+				if (inp.type == V4L2_INPUT_TYPE_CAMERA)
+					printf("enuminput type is V4L2_INPUT_TYPE_CAMERA!\n");
+
+				if (-1 == ioctl (fd, VIDIOC_S_INPUT, &inp))	//è®¾ç½®è¾å¥index
+					printf("VIDIOC_S_INPUT error!\n");
+
+				if (-1 == ioctl (fd, VIDIOC_G_INPUT, &inp))	//è·åè¾å¥index
+					printf("VIDIOC_G_INPUT error!\n");
+				printf("input index is %d\n",inp.index);
+			}
+		//Test VIDIOC_ENUM_FMT
+			struct v4l2_fmtdesc fmtdesc;
+
+			fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			for(i=0;i<12;i++)
+			{
+				fmtdesc.index = i;
+				if (-1 == ioctl (fd, VIDIOC_ENUM_FMT, &fmtdesc))//è·åæ ¼å¼åæ°
+					{
+						printf("VIDIOC_ENUM_FMT error!\n");
+						continue;
+					}
+				printf("**************************************************************\n");
+				printf("format index = %d, name = %s, v4l2 pixel format = %x\n",i,fmtdesc.description,fmtdesc.pixelformat);
+			}
+	}
+
+//		printf("%s %d\n",__FILE__,__LINE__);
+		//Test VIDIOC_S_FMT
+			CLEAR (fmt);
+			fmt.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			fmt.fmt.pix.width       = input_size.width; //320;
+			fmt.fmt.pix.height      = input_size.height; //240;
+			fmt.fmt.pix.pixelformat = csi_format;//V4L2_PIX_FMT_YUV422P;//V4L2_PIX_FMT_NV12;//V4L2_PIX_FMT_YUYV;
+			fmt.fmt.pix.field       = V4L2_FIELD_NONE;
+			int ret = -1;
+
+
+			if(invalid_fmt_test==1)
+			{
+				printf("Try V4L2_PIX_FMT_YUV410\n");
+				fmt.fmt.pix.pixelformat=V4L2_PIX_FMT_YUV410;
+				if (-1 == ioctl (fd, VIDIOC_S_FMT, &fmt)) //è®¾ç½®éè¯¯å¾åæ ¼å¼
+				{
+					printf("VIDIOC_S_FMT error!\n");
+				}
+
+				printf("Try V4L2_PIX_FMT_YVU420\n");
+				fmt.fmt.pix.pixelformat=V4L2_PIX_FMT_YVU420;
+				if (-1 == ioctl (fd, VIDIOC_S_FMT, &fmt)) //è®¾ç½®éè¯¯å¾åæ ¼å¼
+				{
+					printf("VIDIOC_S_FMT error!\n");
+				}
+
+				printf("Try V4L2_PIX_FMT_NV16\n");
+				fmt.fmt.pix.pixelformat=V4L2_PIX_FMT_NV16;
+			}
+
+
+
+
+
+			if (-1 == ioctl (fd, VIDIOC_S_FMT, &fmt)) //è®¾ç½®å¾åæ ¼å¼
+			{
+					printf("VIDIOC_S_FMT error!\n");
+					ret = -1;
+					return ret;
+					//goto close;
+			}
+
+			disp_size.width = fmt.fmt.pix.width;
+			disp_size.height = fmt.fmt.pix.height;
+
+//		printf("%s %d\n",__FILE__,__LINE__);
+		if(ioctl_test==1)
+		{
+			printf("**************************************************************\n");
+			printf("fmt.type = %d\n",fmt.type);
+			printf("fmt.fmt.pix.width = %d\n",fmt.fmt.pix.width);
+			printf("fmt.fmt.pix.height = %d\n",fmt.fmt.pix.height);
+			printf("fmt.fmt.pix.pixelformat = %x\n",fmt.fmt.pix.pixelformat);
+			printf("fmt.fmt.pix.field = %d\n",fmt.fmt.pix.field);
+		}
+		//Test VIDIOC_G_FMT
+
+
+
+		if (-1 == ioctl (fd, VIDIOC_G_FMT, &fmt)) //è·åå¾åæ ¼å¼
+		{
+				printf("VIDIOC_G_FMT error!\n");
+		}
+		else
+		{
+			printf("**************************************************************\n");
+			printf("resolution got from sensor = %d*%d\n",fmt.fmt.pix.width,fmt.fmt.pix.height);
+			printf("**************************************************************\n");
+		}
+
+
+		if(ioctl_test==1)
+		{
+			printf("**************************************************************\n");
+			printf("fmt.fmt.pix.width = %d\n",fmt.fmt.pix.width);
+			printf("fmt.fmt.pix.height = %d\n",fmt.fmt.pix.height);
+			printf("fmt.fmt.pix.pixelformat = %x\n",fmt.fmt.pix.pixelformat);
+			printf("fmt.fmt.pix.field = %d\n",fmt.fmt.pix.field);
+			printf("fmt.fmt.pix.bytesperline = %d\n",fmt.fmt.pix.bytesperline);
+			printf("fmt.fmt.pix.sizeimage = %d\n",fmt.fmt.pix.sizeimage);
+		}
+
+	if(fps_test==1)
+	{
+		//Test VIDIOC_G_PARM
+			struct v4l2_streamparm parms;
+			parms.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+			if (-1 == ioctl (fd, VIDIOC_G_PARM, &parms)) //è·åå¸§ç
+					printf ("VIDIOC_G_PARM error\n");
+
+			printf("numerator = %d\n",parms.parm.capture.timeperframe.numerator);
+			printf("denominator = %d\n",parms.parm.capture.timeperframe.denominator);
+
+
+//		//Test VIDIOC_S_PARM
+//			parms.parm.capture.timeperframe.denominator = fps;//
+//
+//			if (-1 == ioctl (fd, VIDIOC_S_PARM, &parms)) //è·åå¸§ç
+//					printf ("VIDIOC_G_PARM error\n");
+//
+//		//Test VIDIOC_G_PARM
+//			if (-1 == ioctl (fd, VIDIOC_G_PARM, &parms)) //è·åå¸§ç
+//					printf ("VIDIOC_G_PARM error\n");
+//
+//			printf("numerator = %d\n",parms.parm.capture.timeperframe.numerator);
+//			printf("denominator = %d\n",parms.parm.capture.timeperframe.denominator);
+	}
+
+	//count=read_num;
+
+	struct v4l2_requestbuffers req;
+	CLEAR (req);
+	req.count               = req_frame_num;
+	req.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	req.memory              = V4L2_MEMORY_MMAP;
+
+
+	ioctl (fd, VIDIOC_REQBUFS, &req); //ç³è¯·ç¼å²ï¼countæ¯ç³è¯·çæ°é
+
+	buffers = calloc (req.count, sizeof (*buffers));//åå­ä¸­å»ºç«å¯¹åºç©ºé´
+
+	for (n_buffers = 0; n_buffers < req.count; ++n_buffers)
+	{
+	   struct v4l2_buffer buf;   //é©±å¨ä¸­çä¸å¸§
+	   CLEAR (buf);
+	   buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	   buf.memory      = V4L2_MEMORY_MMAP;
+	   buf.index       = n_buffers;
+
+	   if (-1 == ioctl (fd, VIDIOC_QUERYBUF, &buf)) //æ å°ç¨æ·ç©ºé´
+			printf ("VIDIOC_QUERYBUF error\n");
+
+	   buffers[n_buffers].length = buf.length;
+	   buffers[n_buffers].start  = mmap (NULL /* start anywhere */,    //éè¿mmapå»ºç«æ å°å³ç³»
+								         buf.length,
+								         PROT_READ | PROT_WRITE /* required */,
+								         MAP_SHARED /* recommended */,
+								         fd, buf.m.offset);
+
+	   if (MAP_FAILED == buffers[n_buffers].start)
+			printf ("mmap failed\n");
+	}
+
+	for (i = 0; i < n_buffers; ++i)
+	{
+	   struct v4l2_buffer buf;
+	   CLEAR (buf);
+
+	   buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	   buf.memory      = V4L2_MEMORY_MMAP;
+	   buf.index       = i;
+
+	   if (-1 == ioctl (fd, VIDIOC_QBUF, &buf))//ç³è¯·å°çç¼å²è¿å¥åé
+		printf ("VIDIOC_QBUF failed\n");
+	}
+
+#ifdef DISPLAY
+				disp_int(disp_size.width,disp_size.height);
+				disp_start();
+#endif
+
+	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (-1 == ioctl (fd, VIDIOC_STREAMON, &type)) //å¼å§ææå¾åæ°æ®
+		printf ("VIDIOC_STREAMON failed\n");
+	else
+		printf ("VIDIOC_STREAMON ok\n");
+
+	if (-1 == ioctl (fd, VIDIOC_STREAMON, &type)) //å¼å§ææå¾åæ°æ®
+		printf ("VIDIOC_STREAMON failed\n");
+	else
+		printf ("VIDIOC_STREAMON ok\n");
+
+  count = read_num;
+
+	while(count-->0)
+//	while(1)
+	{
+		//gettimeofday(&time_test,&tz);
+
+
+
+		for (;;) //è¿ä¸æ®µæ¶åå°å¼æ­¥IO
+		{
+		   fd_set fds;
+		   struct timeval tv;
+		   int r;
+
+		   FD_ZERO (&fds);//å°æå®çæä»¶æè¿°ç¬¦éæ¸ç©º
+		   FD_SET (fd, &fds);//å¨æä»¶æè¿°ç¬¦éåä¸­å¢å ä¸ä¸ªæ°çæä»¶æè¿°ç¬¦
+
+		   /* Timeout. */
+		   tv.tv_sec = 2;
+		   tv.tv_usec = 0;
+
+		   r = select (fd + 1, &fds, NULL, NULL, &tv);//å¤æ­æ¯å¦å¯è¯»ï¼å³æåå¤´æ¯å¦åå¤å¥½ï¼ï¼tvæ¯å®æ¶
+
+		   if (-1 == r) {
+			if (EINTR == errno)
+			 continue;
+			printf ("select err\n");
+								}
+		   if (0 == r) {
+			fprintf (stderr, "select timeout\n");
+			exit (EXIT_FAILURE);
+								}
+
+#ifdef DISPLAY
+      if(count==read_num-1)
+      	disp_on();
+#endif
+		   if (read_frame ())//å¦æå¯è¯»ï¼æ§è¡read_frame ()å½æ°ï¼å¹¶è·³åºå¾ªç¯
+		   break;
+		}
+	}
+
+	if(control_test==1)
+	{
+		struct v4l2_queryctrl qc;
+		struct v4l2_control ctrl;
+
+		for(i=0;i<sizeof(qc_ctrl);i++)
+		{
+			CLEAR(qc);
+			qc.id = qc_ctrl[i];
+			if (-1 == ioctl (fd, VIDIOC_QUERYCTRL, &qc))
+			{
+				printf("VIDIOC_QUERYCTRL %s failed!\n",qc.name);
+				continue;
+			}
+			else
+			{
+				printf("**************************************************************\n");
+				printf("Name:%s\n",qc.name);
+				printf("qc.min = %d\n",qc.minimum);
+				printf("qc.max = %d\n",qc.maximum);
+				printf("qc.step = %d\n",qc.step);
+				printf("qc.default_value = %d\n",qc.default_value);
+			}
+
+			ctrl.id = qc.id;
+			ctrl.value = qc.maximum;
+			if (-1 == ioctl (fd, VIDIOC_S_CTRL, &ctrl))
+				printf("VIDIOC_S_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("%s set to max\n",qc.name);
+
+			}
+
+			ctrl.value = 0;
+			if (-1 == ioctl (fd, VIDIOC_G_CTRL, &ctrl))
+				printf("VIDIOC_G_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("Name:%s\n",qc.name);
+				printf("read ctrl.value = %d\n",ctrl.value);
+			}
+
+			printf("press ENTER to continue!\n");
+			getchar();
+
+			ctrl.value = qc.minimum;
+			if (-1 == ioctl (fd, VIDIOC_S_CTRL, &ctrl))
+				printf("VIDIOC_S_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("%s set to min\n",qc.name);
+			}
+
+			ctrl.value = 0;
+			if (-1 == ioctl (fd, VIDIOC_G_CTRL, &ctrl))
+				printf("VIDIOC_G_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("Name:%s\n",qc.name);
+				printf("read ctrl.value = %d\n",ctrl.value);
+			}
+
+			printf("press ENTER to continue!\n");
+			getchar();
+
+			ctrl.value = qc.default_value;
+			if (-1 == ioctl (fd, VIDIOC_S_CTRL, &ctrl))
+				printf("VIDIOC_S_CTRL %s failed!\n",qc.name);
+			else
+			{
+				printf("%s set to default_value\n",qc.name);
+			}
+
+		}
+	}
+
+close:
+	if (-1 == ioctl (fd, VIDIOC_STREAMOFF, &type)) //åæ­¢ææå¾åæ°æ®
+		printf ("VIDIOC_STREAMOFF failed\n");
+	else
+		printf ("VIDIOC_STREAMOFF ok\n");
+
+	if (-1 == ioctl (fd, VIDIOC_STREAMOFF, &type)) //åæ­¢ææå¾åæ°æ®
+		printf ("VIDIOC_STREAMOFF failed\n");
+	else
+		printf ("VIDIOC_STREAMOFF ok\n");
+
+	if(read_num==1)
+	{
+	   printf("press ENTER key to continue!\n");
+	   getchar();
+	}
+
+unmap:
+	for (i = 0; i < n_buffers; ++i) {
+		if (-1 == munmap (buffers[i].start, buffers[i].length)) {
+			printf ("munmap error");
+		}
+	}
+	disp_stop();
+	disp_quit();
+
+
+
+	close (fd);
+
+	return 0;
+}
+
+int
+main(void)
+{
+		int i;
+		struct test_case *test_ptr;
+
+		test_num=1;
+		read_num=200;
+
+		req_frame_num = 5;
+		input_size.width = 1280;//1600;//640;
+		input_size.height = 1024;//1200;//480;
+//		disp_size.width = 1280;//1600;//640;
+//		disp_size.height = 1024;//1200;//480;
+		csi_format=V4L2_PIX_FMT_NV12;
+		disp_format=DISP_FORMAT_YUV420;
+		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+		disp_seq=DISP_SEQ_UVUV;
+
+printf("********************************************************************Read stream test start,capture 1000 frames,press to continue\n");
+		getchar();
+
+		read_num = 1000;
+		main_test();
+
+//printf("********************************************************************fps test start,press to continue\n");
+//		getchar();
+//
+//		fps_test=1;
+//		read_num=30;
+//		main_test();
+//		fps_test=0;
+
+//printf("********************************************************************IOCTL invalid test start,press to continue\n");
+//		getchar();
+//		invalid_ops=1;
+//		main_test();
+//		invalid_ops=0;
+//
+//printf("********************************************************************Try and set invalid format test start,press to continue\n");
+//		getchar();
+//
+//		invalid_fmt_test=1;
+//		main_test();
+//		invalid_fmt_test=0;
+//
+//
+//printf("********************************************************************ENUMFMT,SETFMT,GETFMT test start,press to continue\n");
+//		getchar();
+//		ioctl_test=1;
+//		main_test();
+//		ioctl_test=0;
+//
+//
+//printf("********************************************************************Read one frame test start,capture 1 frame,press to continue\n");
+//		getchar();
+//		read_num=1;
+//		main_test();
+//
+//printf("********************************************************************Read stream test start,capture 1000 frames,press to continue\n");
+//		getchar();
+//
+//		read_num = 1000;
+//		main_test();
+
+//printf("********************************************************************Req buffer test start,press to continue\n");
+//		getchar();
+//
+//		read_num = 100;
+//		for(i=1;i<7;i++)
+//		{
+//			printf("Req buffer count = %d, capture 100 frames\n",i);
+//			req_frame_num = i;
+//			main_test();
+//			printf("press to continue\n");
+//			getchar();
+//		}
+//
+//
+//
+//printf("********************************************************************V4L2 control test start,press to continue\n");
+//	 	getchar();
+//	 	control_test=1;
+//	 	csi_format=V4L2_PIX_FMT_NV16;
+//		disp_format=DISP_FORMAT_YUV422;
+//		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+//		disp_seq=DISP_SEQ_UVUV;
+//	 	main_test();
+//		control_test=0;
+//
+printf("********************************************************************resolution and format test start,press to continue\n");
+		getchar();
+
+		read_num=200;
+
+		for(i=0;i<30;i++)		//16 //30
+		{
+			test_ptr = &test_case_set[i];
+			input_size.width = test_ptr->input_width;
+			input_size.height = test_ptr->input_height;
+//			disp_size.width = test_ptr->disp_width;
+//			disp_size.height = test_ptr->disp_height;
+			csi_format = test_ptr->csi_format;
+			disp_format = test_ptr->disp_format;
+			disp_mode=test_ptr->disp_mode;
+			disp_seq=test_ptr->disp_seq;
+
+			printf("***************************************************************************************\ninput size:%dx%d\n",
+			input_size.width,input_size.height);
+
+			switch(csi_format){
+			case V4L2_PIX_FMT_YUV422P:
+    		printf("format: V4L2_PIX_FMT_YUV422P\n");
+    		break;
+    	case V4L2_PIX_FMT_YUV420:
+    		printf("format: V4L2_PIX_FMT_YUV420\n");
+    		break;
+    	case V4L2_PIX_FMT_NV16:
+    		printf("format: V4L2_PIX_FMT_NV16\n");
+    		break;
+    	case V4L2_PIX_FMT_NV12:
+    		printf("format: V4L2_PIX_FMT_NV12\n");
+    		break;
+    	case V4L2_PIX_FMT_HM12:
+    		printf("format: V4L2_PIX_FMT_HM12\n");
+    		break;
+    	case V4L2_PIX_FMT_YUYV:
+    		printf("format: V4L2_PIX_FMT_YUYV\n");
+    		break;
+    	case V4L2_PIX_FMT_YVYU:
+    		printf("format: V4L2_PIX_FMT_YVYU\n");
+    		break;
+    	case V4L2_PIX_FMT_UYVY:
+    		printf("format: V4L2_PIX_FMT_UYVY\n");
+    		break;
+    	case V4L2_PIX_FMT_VYUY:
+    		printf("format: V4L2_PIX_FMT_VYUY\n");
+    		break;
+    	default:
+    		printf("format: error\n");
+    		break;
+    	}
+
+			printf("***************************************************************************************\n");
+			main_test();
+			printf("press to continue\n");
+			getchar();
+		}
+
+printf("********************************************************************lost frame test start,press to continue\n");
+		getchar();
+		lost_frame_test=1;
+		fps=30;
+		read_num=200;
+		req_frame_num = 4;
+		input_size.width = 640;
+		input_size.height = 480;
+		disp_size.width = 640;
+		disp_size.height = 480;
+		csi_format=V4L2_PIX_FMT_NV16;
+		disp_format=DISP_FORMAT_YUV422;
+		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+		disp_seq=DISP_SEQ_UVUV;
+		main_test();
+//
+//
+//printf("********************************************************************fps test start,press to continue\n");
+//		getchar();
+//
+//		printf("set fps to 30fps\n");
+//		fps_test=1;
+//		fps=30;
+//		read_num=30;
+//		req_frame_num = 4;
+//		input_size.width = 640;
+//		input_size.height = 480;
+//		disp_size.width = 640;
+//		disp_size.height = 480;
+//		csi_format=V4L2_PIX_FMT_NV16;
+//		disp_format=DISP_FORMAT_YUV422;
+//		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+//		disp_seq=DISP_SEQ_UVUV;
+//		main_test();
+//
+//
+//
+//		printf("set fps to 15fps\n");
+//		fps=15;
+//		read_num=30;
+//		req_frame_num = 4;
+//		input_size.width = 640;
+//		input_size.height = 480;
+//		disp_size.width = 640;
+//		disp_size.height = 480;
+//		csi_format=V4L2_PIX_FMT_NV16;
+//		disp_format=DISP_FORMAT_YUV422;
+//		disp_mode=DISP_MOD_NON_MB_UV_COMBINED;
+//		disp_seq=DISP_SEQ_UVUV;
+//		main_test();
+
+printf("********************************************************************test done,press to end\n");
+		getchar();
+
+
+
+	exit (EXIT_SUCCESS);
+	return 0;
+}
diff --git a/drivers/media/video/sun5i/Kconfig b/drivers/media/video/sun5i/Kconfig
new file mode 100644
index 0000000..5d5dcd2
--- /dev/null
+++ b/drivers/media/video/sun5i/Kconfig
@@ -0,0 +1,18 @@
+config VIDEO_DECODER_SUN5I
+	tristate "sun5i video decoder support"
+	depends on VIDEO_SUN5I_CEDAR
+	default y
+	---help---
+	  This is the driver for sun4i video decoder, including h264/
+	  mpeg4/mpeg2/vc1/rmvb.
+	  To compile this driver as a module, choose M here: the
+	  module will be called cedar_dev.
+
+config VIDEO_AVS_COUNTER
+	tristate "sun5i av-sync counter support"
+	depends on VIDEO_SUN5I_CEDAR
+	default n
+	---help---
+	  This is the driver for sun4i av-sync counter.
+	  To compile this driver as a module, choose M here: the
+	  module will be called avs_dev.
diff --git a/drivers/media/video/sun5i/Makefile b/drivers/media/video/sun5i/Makefile
new file mode 100644
index 0000000..e9c6ebc
--- /dev/null
+++ b/drivers/media/video/sun5i/Makefile
@@ -0,0 +1,4 @@
+# AW16XX Audio Card Support
+obj-$(CONFIG_VIDEO_DECODER_SUN5I) += sun5i_cedar.o
+obj-$(CONFIG_VIDEO_AVS_COUNTER) += sun5i_avs.o
+
diff --git a/drivers/media/video/sun5i/readme b/drivers/media/video/sun5i/readme
new file mode 100644
index 0000000..1daf295
--- /dev/null
+++ b/drivers/media/video/sun5i/readme
@@ -0,0 +1,48 @@
+/*
+ * drivers/media/video/sun5i/readme
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#------------------------------------------------------------
+# Cedar_dev : video engine driver
+#------------------------------------------------------------
+
+#------------------------------------------------------------
+#@version: cedar_vers0_08
+#@Author : Truby.Zong
+#@Date   : 2011-4-06
+#@Description:
+#	The second version of cedar video engine driver, which
+# add VD/DE SRAM prority and change file name.
+#-------------------------------------------------------------
+#
+#------------------------------------------------------------
+#@version: Vers0_01
+#@Author : Truby.Zong
+#@Date   : 2011-3-18
+#@Description:
+#	The first version of cedar video engine driver, which
+#handles the irq/clock/phy memory alloc of the cedar device,
+#and also the AV-SYNC counter (AVS_CNT1);
+#    Please pay attention to the method to request/remap IO
+#resource and request/free irq, which are just handle once in
+#module init and module exit.
+#-------------------------------------------------------------
+
diff --git a/drivers/media/video/sun5i/sun5i_avs.c b/drivers/media/video/sun5i/sun5i_avs.c
new file mode 100644
index 0000000..0aaeff4
--- /dev/null
+++ b/drivers/media/video/sun5i/sun5i_avs.c
@@ -0,0 +1,426 @@
+/*
+ * drivers/media/video/sun5i/sun5i_avs.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * sun4i_avs.c
+ * driver for av-sync counter
+ * Author : Truby.Zong <truby.zhuang@chipsbank.com>
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/preempt.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+#include <linux/rmap.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+
+#include "sun5i_cedar.h"
+
+#define DRV_VERSION "0.01alpha"
+
+#ifndef AVSDEV_MAJOR
+#define AVSDEV_MAJOR (151)
+#endif
+#ifndef AVSDEV_MINOR
+#define AVSDEV_MINOR (0)
+#endif
+
+#undef _info
+#ifdef CEDAR_DEBUG
+#  define _info(fmt, args...) printk( KERN_DEBUG "[avs]: " fmt, ## args)
+#else
+#  define _info(fmt, args...)
+#endif
+
+int avs_dev_major = AVSDEV_MAJOR;
+int avs_dev_minor = AVSDEV_MINOR;
+module_param(avs_dev_major, int, S_IRUGO);
+module_param(avs_dev_minor, int, S_IRUGO);
+
+struct iomap_resource{
+	struct resource *io_sram;
+	struct resource *io_ccmu;
+	struct resource *io_macc;
+	struct resource *io_mpeg;
+	struct resource *io_vc1;
+	struct resource *io_memc;
+};
+struct iomap_resource iomap_res;
+
+struct iomap_para{
+	volatile char*	regs_sram;
+	volatile char*	regs_ccmu;
+	volatile char*	regs_macc;
+	volatile char*	regs_mpeg;
+	volatile char*	regs_vc1;
+	volatile char*	regs_memc;
+};
+
+struct avs_dev {
+	struct cdev cdev;	             /* char device struct                 */
+	struct device *dev;              /* ptr to class device struct         */
+	struct class  *class;            /* class for auto create device node  */
+
+	struct semaphore sem;            /* mutual exclusion semaphore         */
+	spinlock_t lock;                 /* spinlock to pretect ioctl access   */
+
+	struct iomap_para iomap_addrs;   /* io remap addrs                     */
+    struct iomap_resource iomap_res; /* io remap resources                 */
+};
+struct avs_dev *avs_devp;
+
+/*
+ * ioremap and request iomem
+ */
+static void avs_register_iomem(struct avs_dev *devp)
+{
+    struct resource *res;
+    char *addr;
+
+    memset(&devp->iomap_res,   0, sizeof(struct iomap_resource));
+    memset(&devp->iomap_addrs, 0, sizeof(struct iomap_para));
+
+    /* request mem for ccmu */
+    res = request_mem_region(CCMU_REGS_pBASE, 1024, "ccmu");
+    if (res == NULL)    {
+        printk("Cannot reserve region for ccmu\n");
+        goto err_out;
+    }
+    devp->iomap_res.io_ccmu = res;
+
+	/* ioremap for ccmu */
+    addr = ioremap(CCMU_REGS_pBASE, 4096);
+    if (!addr){
+        printk("cannot map region for ccmu");
+        goto err_out;
+    }
+    devp->iomap_addrs.regs_ccmu = addr;
+
+    return;
+
+err_out:
+    if (devp->iomap_addrs.regs_ccmu)
+		iounmap(devp->iomap_addrs.regs_ccmu);
+}
+
+/*
+ * unmap/release iomem
+ */
+static void avs_iomem_unregister(struct avs_dev *devp)
+{
+    if (devp->iomap_res.io_ccmu) {
+		release_resource(devp->iomap_res.io_ccmu);
+		devp->iomap_res.io_ccmu = NULL;
+	}
+
+	/* iounmap */
+    if (devp->iomap_addrs.regs_ccmu) {
+		iounmap(devp->iomap_addrs.regs_ccmu);
+		devp->iomap_addrs.regs_ccmu = NULL;
+	}
+}
+
+/*
+ * ioctl function
+ * including : wait video engine done,
+ *             AVS Counter control,
+ *             Physical memory control,
+ *             module clock/freq control.
+ */
+long avsdev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long   ret;
+    unsigned int v;
+
+	spinlock_t *lock;
+	struct avs_dev *devp;
+
+	ret = 0;
+	devp = filp->private_data;
+	lock = &devp->lock;
+
+    switch (cmd)
+    {
+        case IOCTL_GETVALUE_AVS2:
+			spin_lock(lock);
+
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc40);
+
+			spin_unlock(lock);
+			return v;
+
+        case IOCTL_CONFIG_AVS2:
+			spin_lock(lock);
+
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc44);
+            v = 239<<16 | (v&0xffff);
+            writel(v, devp->iomap_addrs.regs_ccmu + 0xc44);
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc38);
+            v |= 1<<9 | 1<<1;
+            writel(v, devp->iomap_addrs.regs_ccmu + 0xc38);
+            writel(0, devp->iomap_addrs.regs_ccmu + 0xc40);
+
+			spin_unlock(lock);
+            break;
+
+        case IOCTL_RESET_AVS2:
+			spin_lock(lock);
+
+            writel(0, devp->iomap_addrs.regs_ccmu + 0xc40);
+
+			spin_unlock(lock);
+            break;
+
+        case IOCTL_PAUSE_AVS2:
+			spin_lock(lock);
+
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc38);
+            v |= 1<<9;
+            writel(v, devp->iomap_addrs.regs_ccmu + 0xc38);
+
+			spin_unlock(lock);
+            break;
+
+        case IOCTL_START_AVS2:
+			spin_lock(lock);
+
+            v = readl(devp->iomap_addrs.regs_ccmu + 0xc38);
+            v &= ~(1<<9);
+            writel(v, devp->iomap_addrs.regs_ccmu + 0xc38);
+
+			spin_unlock(lock);
+            break;
+
+        default:
+            break;
+    }
+
+    return ret;
+}
+
+static int avsdev_open(struct inode *inode, struct file *filp)
+{
+	struct avs_dev *devp;
+	devp = container_of(inode->i_cdev, struct avs_dev, cdev);
+	filp->private_data = devp;
+
+	if (down_interruptible(&devp->sem)) {
+		return -ERESTARTSYS;
+	}
+
+	// init other resource here
+
+	up(&devp->sem);
+
+	nonseekable_open(inode, filp);
+	return 0;
+}
+
+static int avsdev_release(struct inode *inode, struct file *filp)
+{
+	struct avs_dev *devp;
+
+	devp = filp->private_data;
+
+	if (down_interruptible(&devp->sem)) {
+		return -ERESTARTSYS;
+	}
+
+	/* release other resource here */
+
+	up(&devp->sem);
+	return 0;
+}
+
+void avsdev_vma_open(struct vm_area_struct *vma)
+{
+    printk(KERN_NOTICE "avsdev VMA open, virt %lx, phys %lx\n",
+		vma->vm_start, vma->vm_pgoff << PAGE_SHIFT);
+	return;
+}
+
+void avsdev_vma_close(struct vm_area_struct *vma)
+{
+    printk(KERN_NOTICE "avsdev VMA close.\n");
+	return;
+}
+
+static struct vm_operations_struct avsdev_remap_vm_ops = {
+    .open  = avsdev_vma_open,
+    .close = avsdev_vma_close,
+};
+
+static int avsdev_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long temp_pfn;
+    unsigned int  VAddr;
+	struct iomap_para addrs;
+
+	unsigned int io_ram = 0;
+    VAddr = vma->vm_pgoff << 12;
+
+	addrs = avs_devp->iomap_addrs;
+
+    if(VAddr == (unsigned int)addrs.regs_ccmu) {
+        temp_pfn = CCMU_REGS_pBASE >> 12;
+        io_ram = 1;
+    } else {
+        temp_pfn = (__pa(vma->vm_pgoff << 12))>>12;
+        io_ram = 0;
+    }
+
+    if (io_ram == 0) {
+        /* Set reserved and I/O flag for the area. */
+        vma->vm_flags |= VM_RESERVED | VM_IO;
+
+        /* Select uncached access. */
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                            vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+            return -EAGAIN;
+        }
+    } else {
+        /* Set reserved and I/O flag for the area. */
+        vma->vm_flags |= VM_RESERVED | VM_IO;
+
+        /* Select uncached access. */
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (io_remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                               vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+            return -EAGAIN;
+        }
+    }
+
+    vma->vm_ops = &avsdev_remap_vm_ops;
+    avsdev_vma_open(vma);
+
+    return 0;
+}
+
+static struct file_operations avsdev_fops = {
+    .owner   = THIS_MODULE,
+    .unlocked_ioctl   = avsdev_ioctl,
+    .mmap    = avsdev_mmap,
+    .open    = avsdev_open,
+    .release = avsdev_release,
+	.llseek  = no_llseek,
+};
+
+static int __init avsdev_init(void)
+{
+	int ret;
+	int devno;
+	dev_t dev = 0;
+
+	printk("[tt]----- avs_dev driver load... ----\n");
+	if (avs_dev_major) {
+		dev = MKDEV(avs_dev_major, avs_dev_minor);
+		ret = register_chrdev_region(dev, 1, "avs_dev");
+	} else {
+		ret = alloc_chrdev_region(&dev, avs_dev_minor, 1, "avs_dev");
+		avs_dev_major = MAJOR(dev);
+		avs_dev_minor = MINOR(dev);
+	}
+
+	if (ret < 0) {
+		printk(KERN_WARNING "avs_dev: can't get major %d\n", avs_dev_major);
+		return ret;
+	}
+
+	avs_devp = kmalloc(sizeof(struct avs_dev), GFP_KERNEL);
+	if (avs_devp == NULL) {
+		printk("malloc mem for avs device err\n");
+		return -ENOMEM;
+	}
+	memset(avs_devp, 0, sizeof(struct avs_dev));
+
+	sema_init(&avs_devp->sem, 0);
+
+	/* request resources and ioremap */
+	printk("[tt]-----      register iomem      ----\n");
+	avs_register_iomem(avs_devp);
+
+	/* init lock for protect ioctl access */
+	spin_lock_init(&avs_devp->lock);
+
+	devno = MKDEV(avs_dev_major, avs_dev_minor);
+	cdev_init(&avs_devp->cdev, &avsdev_fops);
+	avs_devp->cdev.owner = THIS_MODULE;
+	avs_devp->cdev.ops = &avsdev_fops;
+	ret = cdev_add(&avs_devp->cdev, devno, 1);
+	if (ret) {
+		printk(KERN_NOTICE "Err:%d add avsdev", ret);
+	}
+
+    avs_devp->class = class_create(THIS_MODULE, "avs_dev");
+    avs_devp->dev   = device_create(avs_devp->class, NULL, devno, NULL, "avs_dev");
+
+	printk("[tt]--- avs_dev driver load ok!! -----\n");
+	return 0;
+}
+module_init(avsdev_init);
+
+static void __exit avsdev_exit(void)
+{
+	dev_t dev;
+	dev = MKDEV(avs_dev_major, avs_dev_minor);
+
+	/* Unregister iomem and iounmap */
+	avs_iomem_unregister(avs_devp);
+
+	if (avs_devp) {
+		cdev_del(&avs_devp->cdev);
+		device_destroy(avs_devp->class, dev);
+		class_destroy(avs_devp->class);
+	}
+
+	unregister_chrdev_region(dev, 1);
+
+	if (avs_devp) {
+		kfree(avs_devp);
+	}
+}
+module_exit(avsdev_exit);
+
+MODULE_AUTHOR("Soft-Allwinner");
+MODULE_DESCRIPTION("avs device driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/media/video/sun5i/sun5i_cedar.c b/drivers/media/video/sun5i/sun5i_cedar.c
new file mode 100644
index 0000000..03abf56
--- /dev/null
+++ b/drivers/media/video/sun5i/sun5i_cedar.c
@@ -0,0 +1,1119 @@
+/*
+ * drivers\media\video\sun5i\sun5i_cedar.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/preempt.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/rmap.h>
+#include <linux/wait.h>
+#include <linux/semaphore.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+#include <asm/siginfo.h>
+#include <asm/signal.h>
+#include <mach/system.h>
+#include <mach/clock.h>
+#include "sun5i_cedar.h"
+
+#define DRV_VERSION "0.01alpha"
+
+#define CHIP_VERSION_F23
+
+#undef USE_CEDAR_ENGINE
+
+#ifndef CEDARDEV_MAJOR
+#define CEDARDEV_MAJOR (150)
+#endif
+#ifndef CEDARDEV_MINOR
+#define CEDARDEV_MINOR (0)
+#endif
+
+//#define CEDAR_DEBUG
+
+int g_dev_major = CEDARDEV_MAJOR;
+int g_dev_minor = CEDARDEV_MINOR;
+module_param(g_dev_major, int, S_IRUGO);//S_IRUGO represent that g_dev_major can be read,but canot be write
+module_param(g_dev_minor, int, S_IRUGO);
+
+#ifdef CHIP_VERSION_F23
+#define VE_IRQ_NO (53)
+#else
+#define VE_IRQ_NO (48)
+#endif
+
+struct clk *ve_moduleclk = NULL;
+struct clk *ve_pll4clk = NULL;
+struct clk *ahb_veclk = NULL;
+struct clk *dram_veclk = NULL;
+struct clk *avs_moduleclk = NULL;
+struct clk *hosc_clk = NULL;
+
+static unsigned long pll4clk_rate = 240000000;
+
+extern unsigned long ve_start;
+extern unsigned long ve_size;
+
+struct iomap_para{
+	volatile char* regs_macc;
+	#ifdef CHIP_VERSION_F23
+	volatile char* regs_avs;
+	#else
+	volatile char* regs_ccmu;
+	#endif
+};
+
+static DECLARE_WAIT_QUEUE_HEAD(wait_ve);
+struct cedar_dev {
+	struct cdev cdev;	             /* char device struct                 */
+	struct device *dev;              /* ptr to class device struct         */
+	struct class  *class;            /* class for auto create device node  */
+
+	struct semaphore sem;            /* mutual exclusion semaphore         */
+
+	wait_queue_head_t wq;            /* wait queue for poll ops            */
+
+	struct iomap_para iomap_addrs;   /* io remap addrs                     */
+
+	struct timer_list cedar_engine_timer;
+	struct timer_list cedar_engine_timer_rel;
+
+	u32 irq;                         /* cedar video engine irq number      */
+	u32 irq_flag;                    /* flag of video engine irq generated */
+	u32 irq_value;                   /* value of video engine irq          */
+	u32 irq_has_enable;
+	u32 ref_count;
+};
+struct cedar_dev *cedar_devp;
+
+u32 int_sta=0,int_value;
+
+/*
+ * Video engine interrupt service routine
+ * To wake up ve wait queue
+ */
+static irqreturn_t VideoEngineInterupt(int irq, void *dev)
+{
+    unsigned int ve_int_ctrl_reg;
+    volatile int val;
+    int modual_sel;
+    struct iomap_para addrs = cedar_devp->iomap_addrs;
+
+    modual_sel = readl(addrs.regs_macc + 0);
+    modual_sel &= 0xf;
+
+	/* estimate Which video format */
+    switch (modual_sel)
+    {
+        case 0: //mpeg124
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x100 + 0x14);
+            break;
+        case 1: //h264
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x200 + 0x20);
+            break;
+        case 2: //vc1
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x300 + 0x24);
+            break;
+        case 3: //rmvb
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x400 + 0x14);
+            break;
+        case 0xa: //isp
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0xa00 + 0x08);
+            break;
+        case 0xb: //avc enc
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0xb00 + 0x14);
+            break;
+        default:
+            ve_int_ctrl_reg = (unsigned int)(addrs.regs_macc + 0x100 + 0x14);
+            printk("macc modual sel not defined!\n");
+            break;
+    }
+
+    //disable interrupt
+    if(modual_sel == 0) {
+        val = readl(ve_int_ctrl_reg);
+        writel(val & (~0x7c), ve_int_ctrl_reg);
+    } else {
+        val = readl(ve_int_ctrl_reg);
+        writel(val & (~0xf), ve_int_ctrl_reg);
+    }
+
+    cedar_devp->irq_value = 1;	//hx modify 2011-8-1 16:08:47
+    cedar_devp->irq_flag = 1;
+    //any interrupt will wake up wait queue
+    wake_up_interruptible(&wait_ve);        //ioctl
+
+    return IRQ_HANDLED;
+}
+
+/*
+ * poll operateion for wait for ve irq
+ */
+unsigned int cedardev_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	int mask = 0;
+	struct cedar_dev *devp = filp->private_data;
+
+	poll_wait(filp, &devp->wq, wait);
+	if (devp->irq_flag == 1) {
+		devp->irq_flag = 0;
+		mask |= POLLIN | POLLRDNORM;
+	}
+	return mask;
+}
+
+static int clk_status = 0;
+static LIST_HEAD(run_task_list);
+static LIST_HEAD(del_task_list);
+static spinlock_t cedar_spin_lock;
+#define CEDAR_RUN_LIST_NONULL	-1
+#define CEDAR_NONBLOCK_TASK  0      //éé»å¡
+#define CEDAR_BLOCK_TASK 1
+#define CLK_REL_TIME 10000	//10ç§
+#define TIMER_CIRCLE 50		//50æ¯«ç§
+#define TASK_INIT      0x00
+#define TASK_TIMEOUT   0x55
+#define TASK_RELEASE   0xaa
+#define SIG_CEDAR		35
+
+int enable_cedar_hw_clk(void)
+{
+	unsigned long flags;
+	int res = -EFAULT;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	if (clk_status == 1)
+		goto out;
+	clk_status = 1;
+
+	if(0 != clk_enable(ahb_veclk)){
+		printk("ahb_veclk failed; \n");
+		goto out;
+	}
+	if(0 != clk_enable(ve_moduleclk)){
+		printk("ve_moduleclk failed; \n");
+		goto out3;
+	}
+	if(0 != clk_enable(dram_veclk)){
+		printk("dram_veclk failed; \n");
+		goto out2;
+	}
+	if(0 != clk_enable(avs_moduleclk)){
+		printk("ve_moduleclk failed; \n");
+		goto out1;
+	}
+	#ifdef CEDAR_DEBUG
+	printk("%s,%d\n",__func__,__LINE__);
+	#endif
+	res = 0;
+	goto out;
+
+out1:
+	clk_disable(dram_veclk);
+out2:
+	clk_disable(ve_moduleclk);
+out3:
+	clk_disable(ahb_veclk);
+out:
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+	return res;
+}
+
+int disable_cedar_hw_clk(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	if (clk_status == 0)
+		goto out;
+	clk_status = 0;
+
+	clk_disable(dram_veclk);
+	clk_disable(ve_moduleclk);
+	clk_disable(ahb_veclk);
+	clk_disable(avs_moduleclk);
+	#ifdef CEDAR_DEBUG
+	printk("%s,%d\n",__func__,__LINE__);
+	#endif
+out:
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+	return 0;
+}
+
+void cedardev_insert_task(struct cedarv_engine_task* new_task)
+{
+	struct cedarv_engine_task *task_entry;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	if(list_empty(&run_task_list))
+		new_task->is_first_task = 1;
+
+	/*éårun_task_listé¾è¡¨ï¼å¦ææå¥çä»»å¡ä¼åçº§æ¯é¾è¡¨èç¹ä¸­çä»»å¡ä¼åçº§é«ï¼å¹¶ä¸å½åæå¥ä»»å¡ä¸æ¯ç¬¬ä¸ä¸ªæå¥çä»»å¡ã
+	 *é£ä¹å°±å°ä¼åçº§é«çä»»å¡æ¾äºåé¢ï¼éåä¸­çä»»å¡éåä»é«å°åºçä¼åçº§éåæéã
+	 */
+	list_for_each_entry(task_entry, &run_task_list, list) {
+		if ((task_entry->is_first_task == 0) && (task_entry->running == 0) && (task_entry->t.task_prio < new_task->t.task_prio)) {
+			break;
+		}
+	}
+
+	list_add(&new_task->list, task_entry->list.prev);
+
+	#ifdef CEDAR_DEBUG
+	printk("%s,%d, TASK_ID:",__func__,__LINE__);
+	list_for_each_entry(task_entry, &run_task_list, list) {
+		printk("%d!", task_entry->t.ID);
+	}
+	printk("\n");
+	#endif
+	/*æ¯æ¬¡æå¥ä¸ä¸ªä»»å¡ï¼å°±å°å½åçè®¡æ¶å¨æ¶é´éç½®ä¸ºç³»ç»å½åçjiffies*/
+	mod_timer(&cedar_devp->cedar_engine_timer, jiffies + 0);
+
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+}
+
+int cedardev_del_task(int task_id)
+{
+	struct cedarv_engine_task *task_entry;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	/*éårun_task_listé¾è¡¨
+	*å¦ææ¾å°å¯¹åºçidå·ï¼é£ä¹å°±å°run_task_listé¾è¡¨ä¸­çä»»å¡ç§»å°del_task_listé¾è¡¨çè¡¨å¤´ã
+	*/
+	list_for_each_entry(task_entry, &run_task_list, list) {
+		if (task_entry->t.ID == task_id && task_entry->status != TASK_RELEASE) {
+			task_entry->status = TASK_RELEASE;
+
+			spin_unlock_irqrestore(&cedar_spin_lock, flags);
+			mod_timer(&cedar_devp->cedar_engine_timer, jiffies + 0);
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+
+	//æ¾ä¸å°å¯¹åº ID
+	return -1;
+}
+
+int cedardev_check_delay(int check_prio)
+{
+	struct cedarv_engine_task *task_entry;
+	int timeout_total = 0;
+	unsigned long flags;
+
+	/*è·åæ»çç­å¾æ¶é´*/
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+	list_for_each_entry(task_entry, &run_task_list, list) {
+		if ((task_entry->t.task_prio >= check_prio) || (task_entry->running == 1) || (task_entry->is_first_task == 1))
+			timeout_total = timeout_total + task_entry->t.frametime;
+	}
+
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+#ifdef CEDAR_DEBUG
+	printk("%s,%d,%d\n", __func__, __LINE__, timeout_total);
+#endif
+	return timeout_total;
+}
+
+static void cedar_engine_for_timer_rel(unsigned long arg)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	if(list_empty(&run_task_list)){
+		disable_cedar_hw_clk();
+	} else {
+		printk("Warring: cedar engine timeout for clk disable, but task left, something wrong?\n");
+		mod_timer( &cedar_devp->cedar_engine_timer, jiffies + msecs_to_jiffies(TIMER_CIRCLE));
+	}
+
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+}
+
+static void cedar_engine_for_events(unsigned long arg)
+{
+	struct cedarv_engine_task *task_entry, *task_entry_tmp;
+	struct siginfo info;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cedar_spin_lock, flags);
+
+	list_for_each_entry_safe(task_entry, task_entry_tmp, &run_task_list, list) {
+		mod_timer(&cedar_devp->cedar_engine_timer_rel, jiffies + msecs_to_jiffies(CLK_REL_TIME));
+		if (task_entry->status == TASK_RELEASE ||
+				time_after(jiffies, task_entry->t.timeout)) {
+			if (task_entry->status == TASK_INIT)
+				task_entry->status = TASK_TIMEOUT;
+			list_move(&task_entry->list, &del_task_list);
+		}
+	}
+
+	list_for_each_entry_safe(task_entry, task_entry_tmp, &del_task_list, list) {
+		info.si_signo = SIG_CEDAR;
+		info.si_code = task_entry->t.ID;
+		if (task_entry->status == TASK_TIMEOUT){//è¡¨ç¤ºä»»å¡timeoutå é¤
+			info.si_errno = TASK_TIMEOUT;
+			send_sig_info(SIG_CEDAR, &info, task_entry->task_handle);
+		}else if(task_entry->status == TASK_RELEASE){//è¡¨ç¤ºä»»å¡æ­£å¸¸è¿è¡å®æ¯å é¤
+			info.si_errno = TASK_RELEASE;
+			send_sig_info(SIG_CEDAR, &info, task_entry->task_handle);
+		}
+		list_del(&task_entry->list);
+		kfree(task_entry);
+	}
+
+	/*æ¿æ´»é¾è¡¨ä¸­çtask*/
+	if(!list_empty(&run_task_list)){
+		task_entry = list_entry(run_task_list.next, struct cedarv_engine_task, list);
+		if(task_entry->running == 0){
+			task_entry->running = 1;
+			info.si_signo = SIG_CEDAR;
+			info.si_code = task_entry->t.ID;
+			info.si_errno = TASK_INIT;	//ä»»å¡å·²ç»å¯å¨
+			send_sig_info(SIG_CEDAR, &info, task_entry->task_handle);
+		}
+
+		mod_timer( &cedar_devp->cedar_engine_timer, jiffies + msecs_to_jiffies(TIMER_CIRCLE));
+	}
+
+	spin_unlock_irqrestore(&cedar_spin_lock, flags);
+}
+
+#ifdef CHIP_VERSION_F23
+static unsigned int g_ctx_reg0;
+static void save_context(void)
+{
+	g_ctx_reg0 = readl(0xf1c20e00);
+}
+
+static void restore_context(void)
+{
+	writel(g_ctx_reg0, 0xf1c20e00);
+}
+#else
+	#define save_context()
+	#define restore_context()
+#endif
+
+#ifdef CHIP_VERSION_F23
+short VEPLLTable[][6] =
+{
+	//set, actual, Nb, Kb, Mb, Pb
+	{ 60,  60,  5,  2,  2,  1},
+	{ 90,  90,  5,  2,  0,  2},
+	{120, 120,  5,  2,  2,  0},
+	{150, 150, 25,  0,  0,  2},
+	{180, 180,  5,  2,  0,  1},
+	{216, 216,  6,  2,  0,  1},
+	{240, 240,  5,  3,  0,  1},
+	{270, 270, 15,  2,  0,  2},
+	{300, 300, 25,  0,  0,  1},
+	{330, 336,  7,  1,  0,  0},
+	{360, 360,  5,  2,  0,  0},
+	{384, 384,  4,  3,  0,  0},
+	{402, 400, 25,  1,  2,  0},
+	{420, 416, 13,  3,  2,  0},
+	{444, 448, 14,  3,  2,  0},
+	{456, 456, 19,  0,  0,  0},
+	{468, 468, 13,  2,  0,  1},
+	{480, 480,  5,  3,  0,  0},
+	{492, 496, 31,  1,  2,  0},
+};
+#endif
+
+/*
+ * ioctl function
+ * including : wait video engine done,
+ *             AVS Counter control,
+ *             Physical memory control,
+ *             module clock/freq control.
+ *				cedar engine
+ */
+long cedardev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long   ret = 0;
+	unsigned int v;
+	int ve_timeout = 0;
+	struct cedar_dev *devp;
+#ifdef USE_CEDAR_ENGINE
+	int rel_taskid = 0;
+	struct __cedarv_task task_ret;
+	struct cedarv_engine_task *task_ptr = NULL;
+#endif
+	unsigned long flags;
+		//unsigned int val;
+	devp = filp->private_data;
+
+	switch (cmd)
+	{
+   		case IOCTL_ENGINE_REQ:
+   		#ifdef USE_CEDAR_ENGINE
+			if(copy_from_user(&task_ret, (void __user*)arg, sizeof(struct __cedarv_task))){
+				printk("IOCTL_ENGINE_REQ copy_from_user fail\n");
+				return -EFAULT;
+			}
+			spin_lock_irqsave(&cedar_spin_lock, flags);
+			/*å¦ætaskä¸ºéé»å¡ç¶æï¼è¯·æ±èå¯ä»¥ç«å³è¿å*/
+			if(!list_empty(&run_task_list) && ( task_ret.block_mode == CEDAR_NONBLOCK_TASK)){
+				spin_unlock_irqrestore(&cedar_spin_lock, flags);
+				return CEDAR_RUN_LIST_NONULL; //run_task_listéé¢æä»»å¡ï¼è¿å-1
+			}
+			spin_unlock_irqrestore(&cedar_spin_lock, flags);
+
+			/*å¦ætaskä¸ºé»å¡ç¶æï¼å°taskæå¥run_task_listé¾è¡¨ä¸­*/
+			task_ptr = kmalloc(sizeof(struct cedarv_engine_task), GFP_KERNEL);
+			if(!task_ptr){
+				printk("get mem for IOCTL_ENGINE_REQ\n");
+				return PTR_ERR(task_ptr);
+			}
+			task_ptr->task_handle = current;
+			task_ptr->t.ID = task_ret.ID;
+			task_ptr->t.timeout = jiffies + msecs_to_jiffies(1000*task_ret.timeout);//ms to jiffies
+			task_ptr->t.frametime = task_ret.frametime;
+			task_ptr->t.task_prio = task_ret.task_prio;
+			task_ptr->running = 0;
+			task_ptr->is_first_task = 0;
+			task_ptr->status = TASK_INIT;
+
+			cedardev_insert_task(task_ptr);
+
+			enable_cedar_hw_clk();
+
+			return task_ptr->is_first_task;//æå¥run_task_listé¾è¡¨ä¸­çä»»å¡æ¯ç¬¬ä¸ä¸ªä»»å¡ï¼è¿å1ï¼ä¸æ¯ç¬¬ä¸ä¸ªä»»å¡è¿å0. hx modify 2011-7-28 16:59:16ï¼ï¼ï¼
+		#else
+			enable_cedar_hw_clk();
+			cedar_devp->ref_count++;
+			break;
+		#endif
+    	case IOCTL_ENGINE_REL:
+    	#ifdef USE_CEDAR_ENGINE
+			rel_taskid = (int)arg;
+			/*
+			*	å©ç¨ä»»å¡çidå·è¿è¡ä»»å¡çå é¤æä½ãè¿åå¼æä¹ï¼æ¾ä¸å°å¯¹åºIDï¼è¿å-1;æ¾å°å¯¹åºIDï¼è¿å0ã
+			*/
+			ret = cedardev_del_task(rel_taskid);
+		#else
+			disable_cedar_hw_clk();
+			cedar_devp->ref_count--;
+		#endif
+			return ret;
+		case IOCTL_ENGINE_CHECK_DELAY:
+			{
+	            struct cedarv_engine_task_info task_info;
+	            /*ä»ç¨æ·ç©ºé´ä¸­è·åè¦æ¥è¯¢çä»»å¡ä¼åçº§ï¼éè¿ä»»å¡ä¼åçº§ï¼ç»è®¡éè¦ç­å¾çæ»æ¶é´total_time.
+				* å¨è¿ä¸ªæ¥å£ä¸­ï¼åæ¶ä¹ç»ç¨æ·ä¼ éäºå½åä»»å¡çframetimeï¼è¿æ ·åå¯ä»¥åå°æ¥å£ï¼ä½æ¯ç¨æ·ç©ºé´è¦å¤è®¾ç½®ä¸ä¸ªç©ºçframetimeå¼ï¼
+				*å¯¹äºå½åtaskçframetimeï¼ä¹å¯ä»¥ç¨é¢å¤çæ¥å£è·åï¼ä½æ¯è¿æ ·åï¼frametimeåtotal_timeå°±å¤äºä¸åæ¥å£ä¸­ãå¥½å¤ï¼ï¼ï¼
+				*/
+	            if(copy_from_user(&task_info, (void __user*)arg, sizeof(struct cedarv_engine_task_info))){
+					printk("IOCTL_ENGINE_CHECK_DELAY copy_from_user fail\n");
+					return -EFAULT;
+				}
+				task_info.total_time = cedardev_check_delay(task_info.task_prio);//task_info.task_prioæ¯ä¼ éè¿æ¥çä¼åçº§
+				#ifdef CEDAR_DEBUG
+				printk("%s,%d,%d\n", __func__, __LINE__, task_info.total_time);
+				#endif
+				task_info.frametime = 0;
+				spin_lock_irqsave(&cedar_spin_lock, flags);
+				if(!list_empty(&run_task_list)){
+					/*è·årun_task_listé¾è¡¨ä¸­çç¬¬ä¸ä¸ªä»»å¡ï¼ä¹å°±æ¯å½åè¿è¡çä»»å¡ï¼éè¿å½åè¿è¡çä»»å¡è·åframetimeæ¶é´*/
+					struct cedarv_engine_task *task_entry;
+					#ifdef CEDAR_DEBUG
+					printk("%s,%d\n",__func__,__LINE__);
+					#endif
+					task_entry = list_entry(run_task_list.next, struct cedarv_engine_task, list);
+					if(task_entry->running == 1)
+						task_info.frametime = task_entry->t.frametime;
+					#ifdef CEDAR_DEBUG
+					printk("%s,%d,%d\n",__func__,__LINE__,task_info.frametime);
+					#endif
+				}
+				spin_unlock_irqrestore(&cedar_spin_lock, flags);
+				/*
+				*å°ä»»å¡ä¼åçº§ï¼total_time,frametimeæ·è´å°ç¨æ·ç©ºé´ãä»»å¡ä¼åçº§è¿æ¯ç¨æ·è®¾ç½®çå¼ï¼total_timeæ¯éè¦ç­å¾çæ»æ¶é´ï¼
+				*frametimeæ¯å½åä»»å¡çè¿è¡æ¶é´.å¶å®å½åä»»å¡çä¿¡æ¯æå¥½ç¨å¦ä¸ä¸ªæ¥å£å®ç°.åå°è¦ååº¦åæ¥å£çæå±æ§.
+				*/
+				if (copy_to_user((void *)arg, &task_info, sizeof(struct cedarv_engine_task_info))){
+	            	printk("IOCTL_ENGINE_CHECK_DELAY copy_to_user fail\n");
+	                return -EFAULT;
+	            }
+        	}
+			break;
+        case IOCTL_WAIT_VE:
+            //wait_event_interruptible(wait_ve, cedar_devp->irq_flag);
+            ve_timeout = (int)arg;
+            cedar_devp->irq_value = 0;
+
+            spin_lock_irqsave(&cedar_spin_lock, flags);
+            if(cedar_devp->irq_flag)
+            	cedar_devp->irq_value = 1;
+            spin_unlock_irqrestore(&cedar_spin_lock, flags);
+
+            wait_event_interruptible_timeout(wait_ve, cedar_devp->irq_flag, ve_timeout*HZ);
+            //printk("%s,%d,ve_timeout:%d,cedar_devp->irq_value:%d\n", __func__, __LINE__, ve_timeout, cedar_devp->irq_value);
+	        cedar_devp->irq_flag = 0;
+	        /*è¿å1ï¼è¡¨ç¤ºä¸­æ­è¿åï¼è¿å0ï¼è¡¨ç¤ºtimeoutè¿å*/
+			return cedar_devp->irq_value;
+
+		case IOCTL_ENABLE_VE:
+            clk_enable(ve_moduleclk);
+			break;
+
+		case IOCTL_DISABLE_VE:
+			clk_disable(ve_moduleclk);
+			break;
+
+		case IOCTL_RESET_VE:
+            clk_disable(dram_veclk);
+            clk_reset(ve_moduleclk, 1);
+            clk_reset(ve_moduleclk, 0);
+            	/*********for fpga*********/
+//	val = readl(0xf1c2013c);
+//	val &= ~0x00000001;
+//	writel(val,0xf1c2013c);
+//	val |= 0x00000001;
+//	writel(val,0xf1c2013c);
+	/*********for fpga*********/
+            clk_enable(dram_veclk);
+		break;
+
+		case IOCTL_SET_VE_FREQ:
+			{
+//				int arg_rate = (int)arg;
+//				if(arg_rate >= 320){
+//					clk_set_rate(ve_moduleclk, pll4clk_rate/3);//ve_moduleclk rate is 320khz
+//				}else if((arg_rate >= 240) && (arg_rate < 320)){
+//					clk_set_rate(ve_moduleclk, pll4clk_rate/4);//ve_moduleclk rate is 240khz
+//				}else if((arg_rate >= 160) && (arg_rate < 240)){
+//					clk_set_rate(ve_moduleclk, pll4clk_rate/6);//ve_moduleclk rate is 160khz
+//				}else{
+//					printk("IOCTL_SET_VE_FREQ set ve freq error,%s,%d\n", __func__, __LINE__);
+//				}
+			break;
+			}
+        case IOCTL_GETVALUE_AVS2:
+			/* Return AVS1 counter value */
+            return readl(cedar_devp->iomap_addrs.regs_avs + 0x88);
+
+        case IOCTL_ADJUST_AVS2:
+        {
+            int arg_s = (int)arg;
+            int temp;
+            if (SUNXI_VER_A13A == sw_get_ic_ver()) {
+	            save_context();
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            temp = v & 0xffff0000;
+	            temp =temp + temp*arg_s/100;
+				temp = temp > (244<<16) ? (244<<16) : temp;
+				temp = temp < (234<<16) ? (234<<16) : temp;
+	            v = (temp & 0xffff0000) | (v&0x0000ffff);
+	            #ifdef CEDAR_DEBUG
+	            printk("Kernel AVS ADJUST Print: 0x%x\n", v);
+	            #endif
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            restore_context();
+	        } else if (SUNXI_VER_A13B == sw_get_ic_ver()) {
+				v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            temp = v & 0xffff0000;
+	            temp =temp + temp*arg_s/100;
+				temp = temp > (244<<16) ? (244<<16) : temp;
+				temp = temp < (234<<16) ? (234<<16) : temp;
+	            v = (temp & 0xffff0000) | (v&0x0000ffff);
+	            #ifdef CEDAR_DEBUG
+	            printk("Kernel AVS ADJUST Print: 0x%x\n", v);
+	            #endif
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	        }else{
+	        	printk("IOCTL_ADJUST_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+	        }
+            break;
+        }
+
+        case IOCTL_ADJUST_AVS2_ABS:
+        {
+            int arg_s = (int)arg;
+            int v_dst;
+
+            switch(arg_s){
+            case -2:
+            	v_dst = 234;
+            	break;
+            case -1:
+            	v_dst = 236;
+            	break;
+            case 1:
+            	v_dst = 242;
+            	break;
+            case 2:
+            	v_dst = 244;
+            	break;
+            default:
+            	v_dst = 239;
+            	break;
+            }
+
+            if (SUNXI_VER_A13A == sw_get_ic_ver()) {
+	            save_context();
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            v = (v_dst<<16)  | (v&0x0000ffff);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            restore_context();
+	        } else if(SUNXI_VER_A13B == sw_get_ic_ver()) {
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            v = (v_dst<<16)  | (v&0x0000ffff);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	        }else{
+	        	printk("IOCTL_ADJUST_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+	        }
+            break;
+        }
+
+        case IOCTL_CONFIG_AVS2:
+		if (SUNXI_VER_A13A == sw_get_ic_ver()) {
+	        	save_context();
+				/* Set AVS counter divisor */
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            v = 239 << 16 | (v & 0xffff);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+
+				/* Enable AVS_CNT1 and Pause it */
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v |= 1 << 9 | 1 << 1;
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+
+				/* Set AVS_CNT1 init value as zero  */
+	            writel(0, cedar_devp->iomap_addrs.regs_avs + 0x88);
+				restore_context();
+		} else if (SUNXI_VER_A13B == sw_get_ic_ver()) {
+				/* Set AVS counter divisor */
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x8c);
+	            v = 239 << 16 | (v & 0xffff);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x8c);
+
+				/* Enable AVS_CNT1 and Pause it */
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v |= 1 << 9 | 1 << 1;
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+
+				/* Set AVS_CNT1 init value as zero  */
+	            writel(0, cedar_devp->iomap_addrs.regs_avs + 0x88);
+        	}else{
+        		printk("IOCTL_CONFIG_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+            break;
+
+        case IOCTL_RESET_AVS2:
+            /* Set AVS_CNT1 init value as zero */
+            if (SUNXI_VER_A13A == sw_get_ic_ver()) {
+	        	save_context();
+	            writel(0, cedar_devp->iomap_addrs.regs_avs + 0x88);
+	            restore_context();
+		} else if(SUNXI_VER_A13B == sw_get_ic_ver()) {
+        		writel(0, cedar_devp->iomap_addrs.regs_avs + 0x88);
+        	}else{
+        		printk("IOCTL_RESET_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+            break;
+
+        case IOCTL_PAUSE_AVS2:
+            /* Pause AVS_CNT1 */
+		if (SUNXI_VER_A13A == sw_get_ic_ver()) {
+	        	save_context();
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v |= 1 << 9;
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            restore_context();
+		} else if(SUNXI_VER_A13B == sw_get_ic_ver()) {
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v |= 1 << 9;
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+        	}else{
+        		printk("IOCTL_PAUSE_AVS2 get error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+            break;
+
+        case IOCTL_START_AVS2:
+        	/* Start AVS_CNT1 : do not pause */
+		if (SUNXI_VER_A13A == sw_get_ic_ver()) {
+	        	save_context();
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v &= ~(1 << 9);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            restore_context();
+		} else if(SUNXI_VER_A13B == sw_get_ic_ver()) {
+	            v = readl(cedar_devp->iomap_addrs.regs_avs + 0x80);
+	            v &= ~(1 << 9);
+	            writel(v, cedar_devp->iomap_addrs.regs_avs + 0x80);
+        	}else{
+        		printk("IOCTL_START_AVS2 error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+            break;
+
+        case IOCTL_GET_ENV_INFO:
+        {
+            struct cedarv_env_infomation env_info;
+            env_info.phymem_start = (unsigned int)phys_to_virt(ve_start);
+            env_info.phymem_total_size = ve_size;
+	        env_info.address_macc = (unsigned int)cedar_devp->iomap_addrs.regs_macc;
+            if (copy_to_user((char *)arg, &env_info, sizeof(struct cedarv_env_infomation)))
+                return -EFAULT;
+        }
+        break;
+        case IOCTL_GET_IC_VER:
+        {
+		if (SUNXI_VER_A13A == sw_get_ic_ver()) {
+        		return 0x0A10000A;
+		} else if(SUNXI_VER_A13B == sw_get_ic_ver()) {
+        		return 0x0A10000B;
+        	}else{
+        		printk("IC_VER get error:%s,%d\n", __func__, __LINE__);
+        		return -EFAULT;
+        	}
+        }
+        default:
+        break;
+    }
+    return ret;
+}
+
+static int cedardev_open(struct inode *inode, struct file *filp)
+{
+	struct cedar_dev *devp;
+	devp = container_of(inode->i_cdev, struct cedar_dev, cdev);
+	filp->private_data = devp;
+	if (down_interruptible(&devp->sem)) {
+		return -ERESTARTSYS;
+	}
+	/* init other resource here */
+    devp->irq_flag = 0;
+	up(&devp->sem);
+	nonseekable_open(inode, filp);
+	return 0;
+}
+
+static int cedardev_release(struct inode *inode, struct file *filp)
+{
+	struct cedar_dev *devp;
+
+	devp = filp->private_data;
+	if (down_interruptible(&devp->sem)) {
+		return -ERESTARTSYS;
+	}
+	/* release other resource here */
+    devp->irq_flag = 1;
+	up(&devp->sem);
+	return 0;
+}
+
+void cedardev_vma_open(struct vm_area_struct *vma)
+{
+}
+
+void cedardev_vma_close(struct vm_area_struct *vma)
+{
+}
+
+static struct vm_operations_struct cedardev_remap_vm_ops = {
+    .open  = cedardev_vma_open,
+    .close = cedardev_vma_close,
+};
+
+static int cedardev_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long temp_pfn;
+    unsigned int  VAddr;
+	struct iomap_para addrs;
+
+	unsigned int io_ram = 0;
+    VAddr = vma->vm_pgoff << 12;
+	addrs = cedar_devp->iomap_addrs;
+
+    if (VAddr == (unsigned int)addrs.regs_macc) {
+        temp_pfn = MACC_REGS_BASE >> 12;
+        io_ram = 1;
+    } else {
+        temp_pfn = (__pa(vma->vm_pgoff << 12))>>12;
+        io_ram = 0;
+    }
+
+    if (io_ram == 0) {
+        /* Set reserved and I/O flag for the area. */
+        vma->vm_flags |= VM_RESERVED | VM_IO;
+
+        /* Select uncached access. */
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                            vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+            return -EAGAIN;
+        }
+    } else {
+        /* Set reserved and I/O flag for the area. */
+        vma->vm_flags |= VM_RESERVED | VM_IO;
+        /* Select uncached access. */
+        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+        if (io_remap_pfn_range(vma, vma->vm_start, temp_pfn,
+                               vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+            return -EAGAIN;
+        }
+    }
+
+    vma->vm_ops = &cedardev_remap_vm_ops;
+    cedardev_vma_open(vma);
+
+    return 0;
+}
+
+static int snd_sw_cedar_suspend(struct platform_device *pdev,pm_message_t state)
+{
+	disable_cedar_hw_clk();
+
+	return 0;
+}
+
+static int snd_sw_cedar_resume(struct platform_device *pdev)
+{
+	if(cedar_devp->ref_count == 0){
+		return 0;
+	}
+	enable_cedar_hw_clk();
+
+	return 0;
+}
+
+static struct file_operations cedardev_fops = {
+    .owner   = THIS_MODULE,
+    .mmap    = cedardev_mmap,
+	.poll    = cedardev_poll,
+    .open    = cedardev_open,
+    .release = cedardev_release,
+	.llseek  = no_llseek,
+    .unlocked_ioctl   = cedardev_ioctl,
+};
+
+/*data relating*/
+static struct platform_device sw_device_cedar = {
+	.name = "sun4i-cedar",
+};
+
+/*method relating*/
+static struct platform_driver sw_cedar_driver = {
+#ifdef CONFIG_PM
+	.suspend	= snd_sw_cedar_suspend,
+	.resume		= snd_sw_cedar_resume,
+#endif
+	.driver		= {
+		.name	= "sun4i-cedar",
+	},
+};
+
+static int __init cedardev_init(void)
+{
+	int ret = 0;
+	int err = 0;
+	int devno;
+	unsigned int val;
+	dev_t dev = 0;
+
+	if (ve_size == 0)
+		return -ENODEV;
+
+	printk("[cedar dev]: install start!!!\n");
+	if((platform_device_register(&sw_device_cedar))<0)
+		return err;
+
+	if ((err = platform_driver_register(&sw_cedar_driver)) < 0)
+		return err;
+	/*register or alloc the device number.*/
+	if (g_dev_major) {
+		dev = MKDEV(g_dev_major, g_dev_minor);
+		ret = register_chrdev_region(dev, 1, "cedar_dev");
+	} else {
+		ret = alloc_chrdev_region(&dev, g_dev_minor, 1, "cedar_dev");
+		g_dev_major = MAJOR(dev);
+		g_dev_minor = MINOR(dev);
+	}
+
+	if (ret < 0) {
+		printk(KERN_WARNING "cedar_dev: can't get major %d\n", g_dev_major);
+		return ret;
+	}
+	spin_lock_init(&cedar_spin_lock);
+	cedar_devp = kmalloc(sizeof(struct cedar_dev), GFP_KERNEL);
+	if (cedar_devp == NULL) {
+		printk("malloc mem for cedar device err\n");
+		return -ENOMEM;
+	}
+	memset(cedar_devp, 0, sizeof(struct cedar_dev));
+	cedar_devp->irq = VE_IRQ_NO;
+
+	sema_init(&cedar_devp->sem, 1);
+	init_waitqueue_head(&cedar_devp->wq);
+
+	memset(&cedar_devp->iomap_addrs, 0, sizeof(struct iomap_para));
+
+    ret = request_irq(VE_IRQ_NO, VideoEngineInterupt, 0, "cedar_dev", NULL);
+    if (ret < 0) {
+        printk("request irq err\n");
+        return -EINVAL;
+    }
+	/* map for macc io space */
+    cedar_devp->iomap_addrs.regs_macc = ioremap(MACC_REGS_BASE, 4096);
+    if (!cedar_devp->iomap_addrs.regs_macc){
+        printk("cannot map region for macc");
+    }
+    cedar_devp->iomap_addrs.regs_avs = ioremap(AVS_REGS_BASE, 1024);
+
+	//VE_SRAM mapping to AC320
+	val = readl(0xf1c00000);
+	val &= 0x80000000;
+	writel(val,0xf1c00000);
+	//remapping SRAM to MACC for codec test
+	val = readl(0xf1c00000);
+	val |= 0x7fffffff;
+	writel(val,0xf1c00000);
+	/*********for fpga*********/
+//	val = readl(0xf1c2013c);
+//	val |= 0x00000001;
+//	writel(val,0xf1c2013c);
+	/*********for fpga*********/
+	ve_pll4clk = clk_get(NULL,"ve_pll");
+	pll4clk_rate = clk_get_rate(ve_pll4clk);
+	/* getting ahb clk for ve!(macc) */
+	ahb_veclk = clk_get(NULL,"ahb_ve");
+	ve_moduleclk = clk_get(NULL,"ve");
+	if(clk_set_parent(ve_moduleclk, ve_pll4clk)){
+		printk("set parent of ve_moduleclk to ve_pll4clk failed!\n");
+		return -EFAULT;
+	}
+	clk_set_rate(ve_moduleclk, pll4clk_rate/2);
+	//	//macc PLL
+//	val = readl(0xf1c20018);
+//	val &= 0x7ffc0000;
+//	val |= 1<<31;
+//	val |= (0x0)<<16; //Pb
+//	val |= (0x3)<<8; //Nb
+//	val |= (0x3)<<4; //Kb
+//	val |= (0x0)<<0; //Mb
+//	writel(val,0xf1c20018);
+	/*geting dram clk for ve!*/
+	dram_veclk = clk_get(NULL, "sdram_ve");
+	hosc_clk = clk_get(NULL,"hosc");
+	avs_moduleclk = clk_get(NULL,"avs");
+	if(clk_set_parent(avs_moduleclk, hosc_clk)){
+		printk("set parent of avs_moduleclk to hosc_clk failed!\n");
+		return -EFAULT;
+	}
+
+	/*for clk test*/
+	#ifdef CEDAR_DEBUG
+	printk("PLL4 CLK:0xf1c20018 is:%x\n", *(volatile int *)0xf1c20018);
+	printk("AHB CLK:0xf1c20064 is:%x\n", *(volatile int *)0xf1c20064);
+	printk("VE CLK:0xf1c2013c is:%x\n", *(volatile int *)0xf1c2013c);
+	printk("SDRAM CLK:0xf1c20100 is:%x\n", *(volatile int *)0xf1c20100);
+	printk("SRAM:0xf1c00000 is:%x\n", *(volatile int *)0xf1c00000);
+	#endif
+	/* Create char device */
+	devno = MKDEV(g_dev_major, g_dev_minor);
+	cdev_init(&cedar_devp->cdev, &cedardev_fops);
+	cedar_devp->cdev.owner = THIS_MODULE;
+	cedar_devp->cdev.ops = &cedardev_fops;
+	ret = cdev_add(&cedar_devp->cdev, devno, 1);
+	if (ret) {
+		printk(KERN_NOTICE "Err:%d add cedardev", ret);
+	}
+    cedar_devp->class = class_create(THIS_MODULE, "cedar_dev");
+    cedar_devp->dev   = device_create(cedar_devp->class, NULL, devno, NULL, "cedar_dev");
+	/*å¨cedar drvåå§åçæ¶åï¼åå§åå®æ¶å¨å¹¶è®¾ç½®å®çæå
+	* å¨æä»»å¡æå¥run_task_listçæ¶åï¼å¯å¨å®æ¶å¨ï¼å¹¶è®¾ç½®å®æ¶å¨çæ¶éä¸ºå½åç³»ç»çjiffiesï¼åècedardev_insert_task
+	*/
+    setup_timer(&cedar_devp->cedar_engine_timer, cedar_engine_for_events, (unsigned long)cedar_devp);
+	setup_timer(&cedar_devp->cedar_engine_timer_rel, cedar_engine_for_timer_rel, (unsigned long)cedar_devp);
+	printk("[cedar dev]: install end!!!\n");
+	return 0;
+}
+module_init(cedardev_init);
+
+static void __exit cedardev_exit(void)
+{
+	dev_t dev;
+	dev = MKDEV(g_dev_major, g_dev_minor);
+
+    free_irq(VE_IRQ_NO, NULL);
+	iounmap(cedar_devp->iomap_addrs.regs_macc);
+	iounmap(cedar_devp->iomap_addrs.regs_avs);
+	/* Destroy char device */
+	if(cedar_devp){
+		cdev_del(&cedar_devp->cdev);
+		device_destroy(cedar_devp->class, dev);
+		class_destroy(cedar_devp->class);
+	}
+	clk_disable(dram_veclk);
+	clk_put(dram_veclk);
+
+	clk_disable(ve_moduleclk);
+	clk_put(ve_moduleclk);
+
+	clk_disable(ahb_veclk);
+	clk_put(ahb_veclk);
+
+	clk_put(ve_pll4clk);
+
+	clk_disable(avs_moduleclk);
+	clk_put(avs_moduleclk);
+
+	unregister_chrdev_region(dev, 1);
+  	platform_driver_unregister(&sw_cedar_driver);
+	if (cedar_devp) {
+		kfree(cedar_devp);
+	}
+}
+module_exit(cedardev_exit);
+
+MODULE_AUTHOR("Soft-Allwinner");
+MODULE_DESCRIPTION("User mode CEDAR device interface");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/media/video/sun5i/sun5i_cedar.h b/drivers/media/video/sun5i/sun5i_cedar.h
new file mode 100644
index 0000000..3427297
--- /dev/null
+++ b/drivers/media/video/sun5i/sun5i_cedar.h
@@ -0,0 +1,127 @@
+/*
+ * drivers/media/video/sun5i/sun5i_cedar.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+**************************************************************************************************************
+*											         eLDK
+*						            the Easy Portable/Player Develop Kits
+*									           desktop system
+*
+*						        	 (c) Copyright 2009-2012, ,HUANGXIN China
+*											 All Rights Reserved
+*
+* File    	: sun4i_cedar.h
+* By      	: HUANGXIN
+* Func		:
+* Version	: v1.0
+* ============================================================================================================
+* 2011-5-25 9:57:05  HUANGXIN create this file, implements the fundemental interface;
+**************************************************************************************************************
+*/
+#ifndef _SUN4I_CEDAR_H_
+#define _SUN4I_CEDAR_H_
+
+enum IOCTL_CMD {
+	IOCTL_UNKOWN = 0x100,
+	IOCTL_GET_ENV_INFO,
+	IOCTL_WAIT_VE,
+	IOCTL_RESET_VE,
+	IOCTL_ENABLE_VE,
+	IOCTL_DISABLE_VE,
+	IOCTL_SET_VE_FREQ,
+
+	IOCTL_CONFIG_AVS2 = 0x200,
+	IOCTL_GETVALUE_AVS2 ,
+	IOCTL_PAUSE_AVS2 ,
+	IOCTL_START_AVS2 ,
+	IOCTL_RESET_AVS2 ,
+	IOCTL_ADJUST_AVS2,
+	IOCTL_ENGINE_REQ,
+	IOCTL_ENGINE_REL,
+	IOCTL_ENGINE_CHECK_DELAY,
+	IOCTL_GET_IC_VER,
+
+	IOCTL_ADJUST_AVS2_ABS,
+};
+
+struct cedarv_env_infomation{
+	unsigned int phymem_start;
+	int  phymem_total_size;
+	unsigned int  address_macc;
+};
+
+struct __cedarv_task {
+	int task_prio;
+	int ID;
+	unsigned long timeout;
+	unsigned int frametime;
+	unsigned int block_mode;
+};
+
+struct cedarv_engine_task {
+	struct __cedarv_task t;
+	struct list_head list;
+	struct task_struct *task_handle;
+	unsigned int status;
+	unsigned int running;
+	unsigned int is_first_task;
+};
+
+/*å©ç¨ä¼åçº§task_prioæ¥è¯¢å½åè¿è¡taskçframetimeï¼åæ¯ä¼åçº§task_prioé«çtaskå¯è½è¿è¡çæ»æ¶é´total_time*/
+struct cedarv_engine_task_info {
+	int task_prio;
+	unsigned int frametime;
+	unsigned int total_time;
+};
+
+/*--------------------------------------------------------------------------------*/
+#define REGS_pBASE			(0x01C00000)	 	      // register base addr
+
+#define SRAM_REGS_pBASE     (REGS_pBASE + 0x00000)    // SRAM Controller
+#define CCMU_REGS_pBASE     (REGS_pBASE + 0x20000)    // clock manager unit
+#define MACC_REGS_pBASE     (REGS_pBASE + 0x0E000)    // media accelerate VE
+#define SS_REGS_pBASE       (REGS_pBASE + 0x15000)    // Security System
+#define SDRAM_REGS_pBASE    (REGS_pBASE + 0x01000)    // SDRAM Controller
+#define AVS_REGS_pBASE      (REGS_pBASE + 0x20c00)
+
+#define SRAM_REGS_BASE      SRAM_REGS_pBASE           // SRAM Controller
+#define CCMU_REGS_BASE      CCMU_REGS_pBASE           // Clock Control manager unit  OK
+#define MACC_REGS_BASE      MACC_REGS_pBASE           // Media ACCelerate
+#define SS_REGS_BASE        SS_REGS_pBASE             // Security System
+#define SDRAM_REGS_BASE		SDRAM_REGS_pBASE          //SDRAM Controller   OK
+#define AVS_REGS_BASE       AVS_REGS_pBASE
+
+#define MPEG_REGS_BASE      (MACC_REGS_BASE + 0x100)  // MPEG engine
+#define H264_REGS_BASE      (MACC_REGS_BASE + 0x200)  // H264 engine
+#define VC1_REGS_BASE       (MACC_REGS_BASE + 0x300)  // VC-1 engine
+
+#define SRAM_REGS_SIZE      (4096)  // 4K
+#define CCMU_REGS_SIZE      (1024)  // 1K
+#define MACC_REGS_SIZE      (4096)  // 4K
+#define SS_REGS_SIZE        (4096)  // 4K
+/*--------------------------------------------------------------------------------*/
+
+#define SRAM_REG_o_CFG	    (0x00)
+#define SRAM_REG_ADDR_CFG   (SRAM_REGS_BASE + SRAM_REG_o_CFG) // SRAM MAP Cfg Reg 0
+/*--------------------------------------------------------------------------------*/
+
+#endif
diff --git a/drivers/media/video/v4l2-ctrls.c b/drivers/media/video/v4l2-ctrls.c
index 18015c0..9786878 100644
--- a/drivers/media/video/v4l2-ctrls.c
+++ b/drivers/media/video/v4l2-ctrls.c
@@ -361,6 +361,15 @@ const char * const *v4l2_ctrl_get_menu(u32 id)
 		"External",
 		NULL,
 	};
+	/* Add camera flash light by raymonxiu */
+	static const char *flash_mode[] = {
+		"Off",
+		"Auto",
+		"On",
+		"Torch",
+		"Red-Eye",
+		NULL
+	};
 
 	static const char * const jpeg_chroma_subsampling[] = {
 		"4:4:4",
@@ -438,6 +447,9 @@ const char * const *v4l2_ctrl_get_menu(u32 id)
 		return mpeg4_profile;
 	case V4L2_CID_JPEG_CHROMA_SUBSAMPLING:
 		return jpeg_chroma_subsampling;
+	/* Add camera flash light by raymonxiu */
+	case V4L2_CID_CAMERA_FLASH_MODE:
+		return flash_mode;
 
 	default:
 		return NULL;
@@ -493,6 +505,8 @@ const char *v4l2_ctrl_get_name(u32 id)
 	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:	return "Min Number of Capture Buffers";
 	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:	return "Min Number of Output Buffers";
 	case V4L2_CID_ALPHA_COMPONENT:		return "Alpha Component";
+	/* Add camera flash light by raymonxiu */
+	case V4L2_CID_CAMERA_FLASH_MODE:	return "FlashLight Mode";
 
 	/* MPEG controls */
 	/* Keep the order of the 'case's the same as in videodev2.h! */
@@ -733,6 +747,8 @@ void v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,
 	case V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:
 	case V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:
 	case V4L2_CID_JPEG_CHROMA_SUBSAMPLING:
+	/* Add camera flash light by raymonxiu */
+	case V4L2_CID_CAMERA_FLASH_MODE:
 		*type = V4L2_CTRL_TYPE_MENU;
 		break;
 	case V4L2_CID_RDS_TX_PS_NAME:
diff --git a/drivers/media/video/videobuf-dma-contig.c b/drivers/media/video/videobuf-dma-contig.c
index c969111..97429a4 100644
--- a/drivers/media/video/videobuf-dma-contig.c
+++ b/drivers/media/video/videobuf-dma-contig.c
@@ -37,6 +37,15 @@ struct videobuf_dma_contig_memory {
 		BUG();							    \
 	}
 
+#if defined CONFIG_VIDEO_DECODER_SUN4I || \
+	defined CONFIG_VIDEO_DECODER_SUN4I_MODULE || \
+	defined CONFIG_VIDEO_DECODER_SUN5I || \
+	defined CONFIG_VIDEO_DECODER_SUN5I_MODULE
+#define RESERVE_VE_MEM 1
+extern unsigned long ve_start;
+extern unsigned long ve_size;
+#endif
+
 static void
 videobuf_vm_open(struct vm_area_struct *vma)
 {
@@ -91,8 +100,12 @@ static void videobuf_vm_close(struct vm_area_struct *vma)
 				dev_dbg(q->dev, "buf[%d] freeing %p\n",
 					i, mem->vaddr);
 
-				dma_free_coherent(q->dev, mem->size,
+#ifdef RESERVE_VE_MEM
+				if (ve_size == 0)
+#endif
+					dma_free_coherent(q->dev, mem->size,
 						  mem->vaddr, mem->dma_handle);
+
 				mem->vaddr = NULL;
 			}
 
@@ -283,8 +296,17 @@ static int __videobuf_mmap_mapper(struct videobuf_queue *q,
 	MAGIC_CHECK(mem->magic, MAGIC_DC_MEM);
 
 	mem->size = PAGE_ALIGN(buf->bsize);
-	mem->vaddr = dma_alloc_coherent(q->dev, mem->size,
-					&mem->dma_handle, GFP_KERNEL);
+
+#ifdef RESERVE_VE_MEM
+	if (ve_size) {
+		mem->dma_handle = (ve_start + ve_size - 24 * 1024 * 1024 +
+		    buf->i * mem->size + 4095) & (~(4095)); /* 4k aligned */
+		mem->vaddr = (void *)(mem->dma_handle + 0x80000000); /* NA */
+	} else
+#endif
+		mem->vaddr = dma_alloc_coherent(q->dev, mem->size,
+						&mem->dma_handle, GFP_KERNEL);
+
 	if (!mem->vaddr) {
 		dev_err(q->dev, "dma_alloc_coherent size %ld failed\n",
 			mem->size);
