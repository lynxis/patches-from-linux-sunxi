diff --git a/drivers/cpufreq/Kconfig b/drivers/cpufreq/Kconfig
index e24a2a1..f5d560b 100644
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -99,6 +99,25 @@ config CPU_FREQ_DEFAULT_GOV_CONSERVATIVE
 	  Be aware that not all cpufreq drivers support the conservative
 	  governor. If unsure have a look at the help section of the
 	  driver. Fallback governor will be the performance governor.
+
+config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
+	bool "interactive"
+	select CPU_FREQ_GOV_INTERACTIVE
+	help
+	  Use the CPUFreq governor 'interactive' as default. This allows
+	  you to get a full dynamic cpu frequency capable system by simply
+	  loading your cpufreq low-level hardware driver, using the
+	  'interactive' governor for latency-sensitive workloads.
+
+config CPU_FREQ_DEFAULT_GOV_FANTASY
+	bool "fantasy"
+	select CPU_FREQ_GOV_FANTASY
+	help
+	  Use the CPUFreq governor 'fantasy' as default. This allows
+	  you to get a full dynamic cpu frequency capable system by simply
+	  loading your cpufreq low-level hardware driver, using the
+	  'fantasy' governor for latency-sensitive workloads.
+
 endchoice
 
 config CPU_FREQ_GOV_PERFORMANCE
@@ -156,6 +175,23 @@ config CPU_FREQ_GOV_ONDEMAND
 
 	  If in doubt, say N.
 
+config CPU_FREQ_GOV_INTERACTIVE
+	tristate "'interactive' cpufreq policy governor"
+	help
+	  'interactive' - This driver adds a dynamic cpufreq policy governor
+	  designed for latency-sensitive workloads.
+
+	  This governor attempts to reduce the latency of clock
+	  increases so that the system is more responsive to
+	  interactive workloads.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cpufreq_interactive.
+
+	  For details, take a look at linux/Documentation/cpu-freq.
+
+	  If in doubt, say N.
+
 config CPU_FREQ_GOV_CONSERVATIVE
 	tristate "'conservative' cpufreq governor"
 	depends on CPU_FREQ
@@ -179,6 +215,40 @@ config CPU_FREQ_GOV_CONSERVATIVE
 
 	  If in doubt, say N.
 
+config CPU_FREQ_GOV_FANTASY
+	tristate "'fantasy' cpufreq policy governor"
+	select CPU_FREQ_TABLE
+	help
+	  'fantasy' - This driver adds a dynamic cpufreq policy governor.
+	  The governor does a periodic polling and
+	  changes frequency based on the CPU utilization.
+	  The support for this governor depends on CPU capability to
+	  do fast frequency switching (i.e, very low latency frequency
+	  transitions).
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cpufreq_fantasy.
+
+	  For details, take a look at linux/Documentation/cpu-freq.
+
+	  If in doubt, say N.
+
+config CPU_FREQ_USR_EVNT_NOTIFY
+	bool "CPU frequency user event notify"
+	help
+	  This will allow input sub-system notify cpu-freq that some user event has happend,
+	  need up cpu frequency to response it.
+
+	  If in doubt, say N.
+
+config CPU_FREQ_DVFS
+	bool "CPU work voltage change with frequency"
+	depends on AW_AXP
+	help
+	  This will allow cpu work voltage dynamic changed when the frequency is changed.
+
+	  If in doubt, say N.
+
 menu "x86 CPU frequency scaling drivers"
 depends on X86
 source "drivers/cpufreq/Kconfig.x86"
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 9531fc2..8033046 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -9,6 +9,8 @@ obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o
+obj-$(CONFIG_CPU_FREQ_GOV_FANTASY)      += cpufreq_fantasy.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 7f2f149..42c8355 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -535,6 +535,19 @@ static ssize_t show_affected_cpus(struct cpufreq_policy *policy, char *buf)
 	return show_cpus(policy->cpus, buf);
 }
 
+
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+/**
+ * show_user_event_notify - user event notify
+ */
+static ssize_t show_user_event_notify(struct cpufreq_policy *policy, char *buf)
+{
+	cpufreq_user_event_notify();
+	return sprintf(buf, "uevent");;
+}
+#endif
+
+
 static ssize_t store_scaling_setspeed(struct cpufreq_policy *policy,
 					const char *buf, size_t count)
 {
@@ -590,6 +603,9 @@ cpufreq_freq_attr_rw(scaling_min_freq);
 cpufreq_freq_attr_rw(scaling_max_freq);
 cpufreq_freq_attr_rw(scaling_governor);
 cpufreq_freq_attr_rw(scaling_setspeed);
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+cpufreq_freq_attr_ro(user_event_notify);
+#endif
 
 static struct attribute *default_attrs[] = {
 	&cpuinfo_min_freq.attr,
@@ -603,6 +619,9 @@ static struct attribute *default_attrs[] = {
 	&scaling_driver.attr,
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+	&user_event_notify.attr,
+#endif
 	NULL
 };
 
@@ -1918,6 +1937,20 @@ int cpufreq_unregister_driver(struct cpufreq_driver *driver)
 }
 EXPORT_SYMBOL_GPL(cpufreq_unregister_driver);
 
+
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+/* user event notification */
+void cpufreq_user_event_notify(void)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get(0);
+	if(policy && policy->governor) {
+        policy->governor->governor(policy, CPUFREQ_GOV_USRENET);
+    }
+}
+EXPORT_SYMBOL_GPL(cpufreq_user_event_notify);
+#endif
+
+
 static int __init cpufreq_core_init(void)
 {
 	int cpu;
diff --git a/drivers/cpufreq/cpufreq_fantasy.c b/drivers/cpufreq/cpufreq_fantasy.c
new file mode 100644
index 0000000..d8e4076
--- /dev/null
+++ b/drivers/cpufreq/cpufreq_fantasy.c
@@ -0,0 +1,726 @@
+/*
+ * drivers/cpufreq/cpufreq_fantasy.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin Zhang <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/jiffies.h>
+#include <linux/kernel_stat.h>
+#include <linux/mutex.h>
+#include <linux/hrtimer.h>
+#include <linux/tick.h>
+#include <linux/ktime.h>
+#include <linux/sched.h>
+
+/* idle rate coarse adjust for cpu frequency down */
+#define FANTASY_CPUFREQ_IDLE_MAX_RATE(freq)         \
+    (freq<100000? 65 : (freq<200000? 60 : (freq<600000? 55 : (freq<900000? 35 : 20))))
+
+/*
+ * minimum rate for idle task, if idle rate is less than this
+ * value, cpu frequency should be adjusted to the mauximum value
+*/
+#define FANTASY_CPUFREQ_IDLE_MIN_RATE(freq)         \
+    (freq<100000? 35 : (freq<200000? 30 : (freq<600000? 20 : (freq<900000? 15 : 5))))
+
+#define LATENCY_MULTIPLIER          (1000)                      /* latency multiplier */
+#define TRANSITION_LATENCY_LIMIT    (1 * 1000 * 1000 * 1000)    /* latency limitation, should be larger than 1 second */
+#define IOWAIT_IS_BUSY              (1)                         /* io wait time should be counted in idle time */
+
+#define DECRASE_FREQ_STEP_LIMIT1    (300000)   /* decrase frequency limited to 300Mhz when frequency is [900Mhz, 1008Mhz] */
+#define DECRASE_FREQ_STEP_LIMIT2    (200000)   /* decrase frequency limited to 200Mhz when frequency is [600Mhz,  900Mhz) */
+#define DECRASE_FREQ_STEP_LIMIT3    (100000)   /* decrase frequency limited to 100Mhz when frequency is [200Mhz,  600Mhz) */
+#define DECRASE_FREQ_STEP_LIMIT4    (20000)    /* decrase frequency limited to  20Mhz when frequency is [60Mhz,   200Mhz) */
+#define IOWAIT_FREQ_STEP_LIMIT1     (300000)   /* frequency limited to  300Mhz when iowait is [10, 20)  */
+#define IOWAIT_FREQ_STEP_LIMIT2     (600000)   /* frequency limited to  600Mhz when iowait is [20, 30)  */
+#define IOWAIT_FREQ_STEP_LIMIT3     (816000)   /* frequency limited to  816Mhz when iowait is [30, 40)  */
+#define IOWAIT_FREQ_STEP_LIMIT4     (1008000)  /* frequency limited to 1008Mhz when iowait is [40, 100) */
+
+
+enum cpufreq_fantasy_step {
+    CPUFREQ_FANTASY_STEP1,      /* step1 for fantasy policy, adjust cpu frequency to the maximum value      */
+    CPUFREQ_FANTASY_STEP2,      /* step2 for fantasy policy, adjust cpu frequency to the 2nd maximum value  */
+    CPUFREQ_FANTASY_STEP3,      /* step3 for fantasy policy, adjust cpu frequency to the value which keep
+                                   CPU idle rate upto FANTASY_CPUFREQ_IDLE_MAX_RATE  */
+    CPUFREQ_FANTASY_STEP4,      /* step4 for fantasy policy, adjust cpu frequency down, step by step, the
+                                   idle rate will be closed to FANTASY_CPUFREQ_IDLE_MIN_RATE    */
+};
+/*
+state machine for the 4 step is following:
+    step1 -----> step2 -----> step3 -----> step4 ---------------------|
+      ^            |            |            ^                        |
+      |            |            |            | close to min idle rate |
+      -------------|            |            -------------------------|
+      |                         |                                     |
+      --------------------------|                                     |
+      |             user event or cpu load heavy                      |
+      ----------------------------------------------------------------|
+*/
+
+
+static void do_dbs_timer(struct work_struct *work);
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_FANTASY
+static
+#endif
+struct cpufreq_governor cpufreq_gov_fantasy = {
+       .name                   = "fantasy",
+       .governor               = cpufreq_governor_dbs,
+       .max_transition_latency = TRANSITION_LATENCY_LIMIT,
+       .owner                  = THIS_MODULE,
+};
+
+
+static struct cpu_dbs_info_s {
+    cputime64_t prev_cpu_idle;                  /* cpu idle time accumulative total */
+    cputime64_t prev_cpu_iowait;                /* io wait time accumulative total  */
+    cputime64_t prev_cpu_wall;                  /* cpu run time accumulative total  */
+    struct cpufreq_policy *cur_policy;          /* current policy                   */
+    struct cpufreq_frequency_table *freq_table; /* cpu frequency table              */
+    struct mutex timer_mutex;                   /* mutex for timer operation        */
+    enum cpufreq_fantasy_step step;             /* policy state machine             */
+    struct delayed_work work;                   /* timer proc for workqueue         */
+} fantasy_dbs_info;
+
+
+static struct dbs_tuners {
+    unsigned int sampling_rate; /* cpu loading statistic frequency                                  */
+    unsigned int io_is_busy;    /* flag to mark that if io wait time should be count in idle time   */
+} dbs_tuners_ins = {
+    .sampling_rate = TRANSITION_LATENCY_LIMIT,      /* default sample rate is                       */
+};
+
+static struct workqueue_struct    *kfantasy_wq;     /* work queue for process cpu dynamic frequency */
+
+static DEFINE_MUTEX(dbs_mutex); /* mutex for protect dbs start/stop                                 */
+
+#undef FANTASY_DBG
+#undef FANTASY_ERR
+#if (0)
+    #define FANTASY_DBG(format,args...)   printk("[fantasy]"format,##args)
+    #define FANTASY_ERR(format,args...)   printk("[fantasy]"format,##args)
+#else
+    #define FANTASY_DBG(format,args...)   do{}while(0)
+    #define FANTASY_ERR(format,args...)   do{}while(0)
+#endif
+
+
+#undef FANTASY_INF
+#if (0)
+    #define FANTASY_INF(format,args...)   printk(format,##args)
+#else
+    #define FANTASY_INF(format,args...)   do{}while(0)
+#endif
+
+
+/*
+*********************************************************************************************************
+*                           __ulldiv
+*
+*Description: unsigned long long int division.
+*
+*Arguments  : dividend  64bits dividend;
+*             divisior  64bits divisior;
+*
+*Return     : 64bits quotient;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline __u64 __ulldiv(__u64 dividend, __u64 divisior)
+{
+    __u64   tmpDiv = divisior;
+    __u64   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return 0;
+    }
+
+    while(!(tmpDiv & ((__u64)1<<63)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
+
+
+
+/*
+*********************************************************************************************************
+*                           get_cpu_idle_time_jiffy
+*
+*Description: get cpu idle time by jiffies, update cpu run total time;
+*
+*Arguments  : wall  pointer for store total run-time;
+*
+*Return     : cpu idle time, based on us.
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline cputime64_t get_cpu_idle_time_jiffy(unsigned int cpu, cputime64_t *wall)
+{
+    cputime64_t idle_time;
+    cputime64_t cur_wall_time;
+    cputime64_t busy_time;
+
+    cur_wall_time = jiffies64_to_cputime64(get_jiffies_64());
+
+	busy_time = kcpustat_cpu(cpu).cpustat[CPUTIME_USER] +
+		kcpustat_cpu(cpu).cpustat[CPUTIME_SYSTEM];
+
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_IRQ];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SOFTIRQ];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_STEAL];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_NICE];
+
+	idle_time = cur_wall_time - busy_time;
+    if (wall)
+        *wall = (cputime64_t)jiffies_to_usecs(cur_wall_time);
+
+    return (cputime64_t)jiffies_to_usecs(idle_time);
+}
+
+
+/*
+*********************************************************************************************************
+*                           get_cpu_idle_time
+*
+*Description: get cpu idle time, try to get cpu idle time with clock source first, if clock source
+*             is invlalid, try to get idle time with jiffies again.
+*
+*Arguments  : wall  pointer for store cpu run total time.
+*
+*Return     : idle time;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline cputime64_t get_cpu_idle_time(cputime64_t *wall)
+{
+    u64 idle_time = get_cpu_idle_time_us(fantasy_dbs_info.cur_policy->cpu, wall);
+
+    if (idle_time == -1ULL)
+        return get_cpu_idle_time_jiffy(fantasy_dbs_info.cur_policy->cpu, wall);
+
+    return idle_time;
+}
+
+
+/*
+*********************************************************************************************************
+*                           get_cpu_iowait_time_jiffy
+*
+*Description: get cpu iowait time by jiffies;
+*
+*Arguments  : cpu  cpu number;
+*
+*Return     : cpu iowait time, based on us.
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline cputime64_t get_cpu_iowait_time_jiffy(unsigned int cpu)
+{
+    cputime64_t iowait_time;
+    iowait_time = kcpustat_cpu(cpu).cpustat[CPUTIME_IOWAIT];
+
+    return (cputime64_t)jiffies_to_usecs(iowait_time);
+}
+
+
+/*
+*********************************************************************************************************
+*                           get_cpu_iowait_time
+*
+*Description: get io wait time.
+*
+*Arguments  : wall  pointer for store cpu run total time.
+*
+*Return     : io wait time.
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline cputime64_t get_cpu_iowait_time(cputime64_t *wall)
+{
+    u64 iowait_time = get_cpu_iowait_time_us(fantasy_dbs_info.cur_policy->cpu, wall);
+
+    if (iowait_time == -1ULL)
+        return get_cpu_iowait_time_jiffy(fantasy_dbs_info.cur_policy->cpu);
+
+    return iowait_time;
+}
+
+
+/*
+*********************************************************************************************************
+*                           do_dbs_timer
+*
+*Description: cpu frequency timer process handler.
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void do_dbs_timer(struct work_struct *work)
+{
+    /* We want all CPUs to do sampling nearly on same jiffy */
+    int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
+    unsigned int freq_cur;
+
+    mutex_lock(&fantasy_dbs_info.timer_mutex);
+
+    /* get current frequency */
+    freq_cur = cpufreq_quick_get(fantasy_dbs_info.cur_policy->cpu);
+    FANTASY_DBG("current cpu frequency is:%d\n", freq_cur);
+
+    switch (fantasy_dbs_info.step) {
+
+        case CPUFREQ_FANTASY_STEP1: {
+            FANTASY_DBG("step1 : set cpu frequency to max value (%d)\n", fantasy_dbs_info.cur_policy->max);
+            if(freq_cur != fantasy_dbs_info.cur_policy->max) {
+                /* adjust cpu frequncy to the maximum value */
+                __cpufreq_driver_target(fantasy_dbs_info.cur_policy, fantasy_dbs_info.cur_policy->max, CPUFREQ_RELATION_H);
+            }
+            fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP2;
+            break;
+        }
+
+        case CPUFREQ_FANTASY_STEP2: {
+            /* adjust cpu frequncy to the maximum value */
+            FANTASY_DBG("step2 : set cpu frequency to second max value\n");
+            __cpufreq_driver_target(fantasy_dbs_info.cur_policy, freq_cur-1000, CPUFREQ_RELATION_L);
+            fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP3;
+            break;
+        }
+
+        case CPUFREQ_FANTASY_STEP3: {
+            cputime64_t cur_wall_time, cur_idle_time, cur_iowait_time;
+            unsigned int idle_time, wall_time, iowait_time;
+            unsigned int freq_target;
+            unsigned int idle_rate, iowait_rate;
+
+            FANTASY_DBG("step3 : set cpu frequency\n");
+
+            /* get idle time, io-wait time, and cpu run total time */
+            cur_idle_time = get_cpu_idle_time(&cur_wall_time);
+            cur_iowait_time = get_cpu_iowait_time(&cur_wall_time);
+
+            /* calculate idle/io-wait/total run time in last statistic cycle */
+		wall_time = (unsigned int)
+			(cur_wall_time - fantasy_dbs_info.prev_cpu_wall);
+		idle_time = (unsigned int)
+			(cur_idle_time - fantasy_dbs_info.prev_cpu_idle);
+		iowait_time = (unsigned int)
+			(cur_iowait_time - fantasy_dbs_info.prev_cpu_iowait);
+
+            if(dbs_tuners_ins.io_is_busy) {
+                idle_time -= iowait_time;
+                if(idle_time < 0) {
+                    idle_time = 0;
+                }
+            }
+
+            /* update parameters */
+            fantasy_dbs_info.prev_cpu_wall = cur_wall_time;
+            fantasy_dbs_info.prev_cpu_idle = cur_idle_time;
+            fantasy_dbs_info.prev_cpu_iowait = cur_iowait_time;
+
+            idle_rate = idle_time*100/wall_time;
+            iowait_rate = iowait_time*100/wall_time;
+
+            FANTASY_INF("%d,", freq_cur/1000);  /*cpu current frequency*/
+            FANTASY_INF("%d,", idle_rate);      /*cpu idle rate*/
+            FANTASY_INF("%d\n", iowait_rate);   /*cpu iowait rate*/
+
+            /* check idle rate */
+            if(idle_rate > FANTASY_CPUFREQ_IDLE_MAX_RATE(freq_cur)) {
+                /* idle rate is higher than the max idle rate, so, try to decrase the cpu frequency */
+              	freq_target = __ulldiv((u64)freq_cur*(wall_time-idle_time)*100, wall_time);
+			   	freq_target = freq_target / ((100-FANTASY_CPUFREQ_IDLE_MAX_RATE(freq_target)));
+
+			   	FANTASY_DBG("current max idle rate is:%d\n", FANTASY_CPUFREQ_IDLE_MAX_RATE(freq_cur));
+
+                if(freq_cur >= 900000){
+                    if(freq_cur - freq_target > DECRASE_FREQ_STEP_LIMIT1){
+                        freq_target = freq_cur - DECRASE_FREQ_STEP_LIMIT1;
+                    }
+                }
+                else if(freq_cur >= 600000){
+                    if(freq_cur - freq_target > DECRASE_FREQ_STEP_LIMIT2){
+                            freq_target = freq_cur - DECRASE_FREQ_STEP_LIMIT2;
+                    }
+                }
+                else if(freq_cur >= 200000){
+                    if(freq_cur - freq_target > DECRASE_FREQ_STEP_LIMIT3){
+                        freq_target = freq_cur - DECRASE_FREQ_STEP_LIMIT3;
+                    }
+                }
+                else if(freq_cur >= 60000){
+                    if(freq_cur - freq_target > DECRASE_FREQ_STEP_LIMIT4){
+                        freq_target = freq_cur - DECRASE_FREQ_STEP_LIMIT4;
+                    }
+                }
+
+                if(iowait_rate >= 40){
+                    if(freq_target < IOWAIT_FREQ_STEP_LIMIT4){
+                        freq_target = IOWAIT_FREQ_STEP_LIMIT4;
+                    }
+                }
+                else if(iowait_rate >= 30){
+                    if(freq_target < IOWAIT_FREQ_STEP_LIMIT3){
+                        freq_target = IOWAIT_FREQ_STEP_LIMIT3;
+                    }
+                }
+                else if(iowait_rate >= 20){
+                    if(freq_target < IOWAIT_FREQ_STEP_LIMIT2){
+                        freq_target = IOWAIT_FREQ_STEP_LIMIT2;
+                    }
+                }
+                else if(iowait_rate >= 10){
+                    if(freq_target < IOWAIT_FREQ_STEP_LIMIT1){
+                        freq_target = IOWAIT_FREQ_STEP_LIMIT1;
+                    }
+                }
+
+                if (fantasy_dbs_info.cur_policy->cur == fantasy_dbs_info.cur_policy->min){
+                    fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP3;
+                    break;
+                }
+
+                /* set target frequency */
+                __cpufreq_driver_target(fantasy_dbs_info.cur_policy, freq_target, CPUFREQ_RELATION_L);
+                FANTASY_DBG("set cpu frequency to %d\n", freq_target);
+            }
+            else if(idle_rate < FANTASY_CPUFREQ_IDLE_MIN_RATE(freq_cur)) {
+			   	FANTASY_DBG("min idle rate is:%d\n", FANTASY_CPUFREQ_IDLE_MIN_RATE(freq_cur));
+
+                /* adjust cpu frequncy to the maximum value */
+                __cpufreq_driver_target(fantasy_dbs_info.cur_policy, fantasy_dbs_info.cur_policy->max, CPUFREQ_RELATION_H);
+                FANTASY_DBG("set cpu frequency to %d\n", fantasy_dbs_info.cur_policy->max);
+                fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP2;
+                break;
+            }
+            else {
+                if(iowait_rate >= 40){
+                    if(freq_cur < IOWAIT_FREQ_STEP_LIMIT4){
+                        freq_target = IOWAIT_FREQ_STEP_LIMIT4;
+                    }
+                    else {
+                        break;
+                    }
+                }
+                else if(iowait_rate >= 30){
+                    if(freq_cur < IOWAIT_FREQ_STEP_LIMIT3){
+                        freq_target = IOWAIT_FREQ_STEP_LIMIT3;
+                    }
+                    else {
+                        break;
+                    }
+                }
+                else if(iowait_rate >= 20){
+                    if(freq_cur < IOWAIT_FREQ_STEP_LIMIT2){
+                        freq_target = IOWAIT_FREQ_STEP_LIMIT2;
+                    }
+                    else {
+                        break;
+                    }
+                }
+                else if(iowait_rate >= 10){
+                    if(freq_cur < IOWAIT_FREQ_STEP_LIMIT1){
+                        freq_target = IOWAIT_FREQ_STEP_LIMIT1;
+                    }
+                    else {
+                        break;
+                    }
+                }else {
+                    /* cpu frequency is in the valid threshold, do nothing */
+                    FANTASY_DBG("do nothing for cpu frequency change\n");
+                    break;
+                }
+
+                /* set target frequency */
+                __cpufreq_driver_target(fantasy_dbs_info.cur_policy, freq_target, CPUFREQ_RELATION_L);
+                FANTASY_DBG("set cpu frequency to %d\n", freq_target);
+            }
+
+            fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP3;
+            break;
+        }
+
+        case CPUFREQ_FANTASY_STEP4: {
+            /* don't process cpu frequency nice ajust now */
+            break;
+        }
+    }
+
+    queue_delayed_work(kfantasy_wq, &fantasy_dbs_info.work, delay);
+    mutex_unlock(&fantasy_dbs_info.timer_mutex);
+}
+
+
+/*
+*********************************************************************************************************
+*                           dbs_timer_init
+*
+*Description: initialise timer for process cpu frquency.
+*
+*Arguments  : dbs_info  cpu frequency policy informatioin.
+*
+*Return     : none
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void dbs_timer_init(struct cpu_dbs_info_s *dbs_info)
+{
+    /* calcualte timer cycle time by sampling rate */
+    int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
+    /* init workqueue for process cpu frequency */
+    INIT_DELAYED_WORK_DEFERRABLE(&dbs_info->work, do_dbs_timer);
+    queue_delayed_work(kfantasy_wq, &dbs_info->work, delay);
+}
+
+
+/*
+*********************************************************************************************************
+*                           dbs_timer_exit
+*
+*Description:
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
+{
+    cancel_delayed_work_sync(&dbs_info->work);
+}
+
+
+/*
+*********************************************************************************************************
+*                           cpufreq_governor_dbs
+*
+*Description: cpu frequency governor process handle, call-back by cpu-freq core.
+*
+*Arguments  : policy    cpu frequency policy crrent using.
+*             event     command from cpu-freq core.
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event)
+{
+    unsigned int    cpu = policy->cpu;
+    struct cpu_dbs_info_s *this_dbs_info = &fantasy_dbs_info;
+    unsigned int    latency;
+
+    switch (event){
+        case CPUFREQ_GOV_START: {
+            mutex_lock(&dbs_mutex);
+
+            /* set cpu policy */
+            this_dbs_info->cur_policy = policy;
+
+            /* initialise cpu idle time */
+            this_dbs_info->prev_cpu_idle = get_cpu_idle_time(&this_dbs_info->prev_cpu_wall);
+
+            /* initialise cpu iowait time */
+            this_dbs_info->prev_cpu_iowait = get_cpu_iowait_time(&this_dbs_info->prev_cpu_wall);
+
+            /* initialise cpu frequency table */
+            this_dbs_info->freq_table = cpufreq_frequency_get_table(cpu);
+
+            /* policy latency is in nS. Convert it to uS first */
+            latency = policy->cpuinfo.transition_latency / 1000;
+            latency = latency ? latency : 1;
+            dbs_tuners_ins.sampling_rate = latency * LATENCY_MULTIPLIER;
+
+            /* set if io wait should be counted in cpu idle */
+            dbs_tuners_ins.io_is_busy = IOWAIT_IS_BUSY;
+            mutex_unlock(&dbs_mutex);
+
+            /* init mutex for protecting timer process */
+            mutex_init(&this_dbs_info->timer_mutex);
+
+            /* init tuners state machine */
+            fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP1;
+
+            /* init timer for prccess cpu-frequencyh */
+            dbs_timer_init(this_dbs_info);
+            break;
+        }
+
+        case CPUFREQ_GOV_STOP: {
+            /* delete timer */
+            dbs_timer_exit(this_dbs_info);
+            mutex_lock(&dbs_mutex);
+            /* destroy timer mutex */
+            mutex_destroy(&this_dbs_info->timer_mutex);
+            mutex_unlock(&dbs_mutex);
+            break;
+        }
+
+        case CPUFREQ_GOV_LIMITS: {
+            /* cpu frequency limitation has changed, adjust current frequency */
+            mutex_lock(&this_dbs_info->timer_mutex);
+            /* set cpu frequency to the max value, and reset state machine */
+            __cpufreq_driver_target(fantasy_dbs_info.cur_policy, fantasy_dbs_info.cur_policy->max, CPUFREQ_RELATION_H);
+            /* reset tuners state machine */
+            fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP1;
+            mutex_unlock(&this_dbs_info->timer_mutex);
+            break;
+        }
+
+        #ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+        case CPUFREQ_GOV_USRENET: {
+            /* cpu frequency limitation has changed, adjust current frequency */
+            if(!mutex_trylock(&this_dbs_info->timer_mutex)) {
+                FANTASY_DBG("CPUFREQ_GOV_USRENET try to lock mutex failed!\n");
+                /* reset tuners state machine */
+                fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP1;
+                break;
+            }
+            /* set cpu frequenc to the max value, and reset state machine */
+            __cpufreq_driver_target(fantasy_dbs_info.cur_policy, fantasy_dbs_info.cur_policy->max, CPUFREQ_RELATION_H);
+            /* reset tuners state machine */
+            fantasy_dbs_info.step = CPUFREQ_FANTASY_STEP1;
+            mutex_unlock(&this_dbs_info->timer_mutex);
+            break;
+        }
+        #endif
+    }
+   return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           cpufreq_gov_dbs_init
+*
+*Description: fantasy cpu-freq governor initialise.
+*
+*Arguments  : none
+*
+*Return     : result
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int __init cpufreq_gov_dbs_init(void)
+{
+    int     err;
+
+    /* create work queue for process cpu frequency policy */
+    kfantasy_wq = create_workqueue("kfantasy");
+    if (!kfantasy_wq) {
+        printk(KERN_ERR "Creation of kfantasy failed\n");
+        return -EFAULT;
+    }
+    /* register cpu frequency governor into cpu-freq core */
+    err = cpufreq_register_governor(&cpufreq_gov_fantasy);
+    if (err) {
+        destroy_workqueue(kfantasy_wq);
+    }
+
+    return err;
+}
+
+
+/*
+*********************************************************************************************************
+*                           cpufreq_gov_dbs_exit
+*
+*Description: fantasy cpu-freq governor exit.
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void __exit cpufreq_gov_dbs_exit(void)
+{
+    /* unregister cpu frequency governor */
+    cpufreq_unregister_governor(&cpufreq_gov_fantasy);
+    /* destroy work queue */
+    destroy_workqueue(kfantasy_wq);
+}
+
+
+
+MODULE_AUTHOR("kevin.z.m <kevin@allwinnertech.com>");
+MODULE_DESCRIPTION("'cpufreq_fantasy' - A good cpu frequency policy");
+MODULE_LICENSE("GPL");
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_FANTASY
+fs_initcall(cpufreq_gov_dbs_init);
+#else
+module_init(cpufreq_gov_dbs_init);
+#endif
+module_exit(cpufreq_gov_dbs_exit);
diff --git a/drivers/cpufreq/cpufreq_interactive.c b/drivers/cpufreq/cpufreq_interactive.c
new file mode 100644
index 0000000..9a0986c
--- /dev/null
+++ b/drivers/cpufreq/cpufreq_interactive.c
@@ -0,0 +1,1185 @@
+/*
+ * drivers/cpufreq/cpufreq_interactive.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Author: Mike Chan (mike@android.com)
+ *
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/cpufreq.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/rwsem.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/kernel_stat.h>
+#include <asm/cputime.h>
+
+#define CREATE_TRACE_POINTS
+#include <trace/events/cpufreq_interactive.h>
+
+static int active_count;
+
+struct cpufreq_interactive_cpuinfo {
+	struct timer_list cpu_timer;
+	struct timer_list cpu_slack_timer;
+	spinlock_t load_lock; /* protects the next 4 fields */
+	u64 time_in_idle;
+	u64 time_in_idle_timestamp;
+	u64 cputime_speedadj;
+	u64 cputime_speedadj_timestamp;
+	struct cpufreq_policy *policy;
+	struct cpufreq_frequency_table *freq_table;
+	unsigned int target_freq;
+	unsigned int floor_freq;
+	u64 floor_validate_time;
+	u64 hispeed_validate_time;
+	struct rw_semaphore enable_sem;
+	int governor_enabled;
+};
+
+static DEFINE_PER_CPU(struct cpufreq_interactive_cpuinfo, cpuinfo);
+
+/* realtime thread handles frequency scaling */
+static struct task_struct *speedchange_task;
+static cpumask_t speedchange_cpumask;
+static spinlock_t speedchange_cpumask_lock;
+static struct mutex gov_lock;
+
+/* Hi speed to bump to from lo speed when load burst (default max) */
+static unsigned int hispeed_freq;
+
+/* Go to hi speed when CPU load at or above this value. */
+#define DEFAULT_GO_HISPEED_LOAD 99
+static unsigned long go_hispeed_load = DEFAULT_GO_HISPEED_LOAD;
+
+/* Target load.  Lower values result in higher CPU speeds. */
+#define DEFAULT_TARGET_LOAD 90
+static unsigned int default_target_loads[] = {DEFAULT_TARGET_LOAD};
+static spinlock_t target_loads_lock;
+static unsigned int *target_loads = default_target_loads;
+static int ntarget_loads = ARRAY_SIZE(default_target_loads);
+
+/*
+ * The minimum amount of time to spend at a frequency before we can ramp down.
+ */
+#define DEFAULT_MIN_SAMPLE_TIME (80 * USEC_PER_MSEC)
+static unsigned long min_sample_time = DEFAULT_MIN_SAMPLE_TIME;
+
+/*
+ * The sample rate of the timer used to increase frequency
+ */
+#define DEFAULT_TIMER_RATE (20 * USEC_PER_MSEC)
+static unsigned long timer_rate = DEFAULT_TIMER_RATE;
+
+/*
+ * Wait this long before raising speed above hispeed, by default a single
+ * timer interval.
+ */
+#define DEFAULT_ABOVE_HISPEED_DELAY DEFAULT_TIMER_RATE
+static unsigned int default_above_hispeed_delay[] = {
+	DEFAULT_ABOVE_HISPEED_DELAY };
+static spinlock_t above_hispeed_delay_lock;
+static unsigned int *above_hispeed_delay = default_above_hispeed_delay;
+static int nabove_hispeed_delay = ARRAY_SIZE(default_above_hispeed_delay);
+
+/* Non-zero means indefinite speed boost active */
+static int boost_val;
+/* Duration of a boot pulse in usecs */
+static int boostpulse_duration_val = DEFAULT_MIN_SAMPLE_TIME;
+/* End time of boost pulse in ktime converted to usecs */
+static u64 boostpulse_endtime;
+
+/*
+ * Max additional time to wait in idle, beyond timer_rate, at speeds above
+ * minimum before wakeup to reduce speed, or -1 if unnecessary.
+ */
+#define DEFAULT_TIMER_SLACK (4 * DEFAULT_TIMER_RATE)
+static int timer_slack_val = DEFAULT_TIMER_SLACK;
+
+static bool io_is_busy;
+
+static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
+		unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE
+static
+#endif
+struct cpufreq_governor cpufreq_gov_interactive = {
+	.name = "interactive",
+	.governor = cpufreq_governor_interactive,
+	.max_transition_latency = 10000000,
+	.owner = THIS_MODULE,
+};
+
+static inline cputime64_t get_cpu_idle_time_jiffy(unsigned int cpu,
+						  cputime64_t *wall)
+{
+	u64 idle_time;
+	u64 cur_wall_time;
+	u64 busy_time;
+
+	cur_wall_time = jiffies64_to_cputime64(get_jiffies_64());
+
+	busy_time  = kcpustat_cpu(cpu).cpustat[CPUTIME_USER];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SYSTEM];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_IRQ];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SOFTIRQ];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_STEAL];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_NICE];
+
+	idle_time = cur_wall_time - busy_time;
+	if (wall)
+		*wall = jiffies_to_usecs(cur_wall_time);
+
+	return jiffies_to_usecs(idle_time);
+}
+
+static inline cputime64_t get_cpu_idle_time(unsigned int cpu,
+					    cputime64_t *wall)
+{
+	u64 idle_time = get_cpu_idle_time_us(cpu, wall);
+
+	if (idle_time == -1ULL)
+		idle_time = get_cpu_idle_time_jiffy(cpu, wall);
+	else if (!io_is_busy)
+		idle_time += get_cpu_iowait_time_us(cpu, wall);
+
+	return idle_time;
+}
+
+static void cpufreq_interactive_timer_resched(
+	struct cpufreq_interactive_cpuinfo *pcpu)
+{
+	unsigned long expires = jiffies + usecs_to_jiffies(timer_rate);
+	unsigned long flags;
+
+	mod_timer_pinned(&pcpu->cpu_timer, expires);
+	if (timer_slack_val >= 0 && pcpu->target_freq > pcpu->policy->min) {
+		expires += usecs_to_jiffies(timer_slack_val);
+		mod_timer_pinned(&pcpu->cpu_slack_timer, expires);
+	}
+
+	spin_lock_irqsave(&pcpu->load_lock, flags);
+	pcpu->time_in_idle =
+		get_cpu_idle_time(smp_processor_id(),
+				     &pcpu->time_in_idle_timestamp);
+	pcpu->cputime_speedadj = 0;
+	pcpu->cputime_speedadj_timestamp = pcpu->time_in_idle_timestamp;
+	spin_unlock_irqrestore(&pcpu->load_lock, flags);
+}
+
+static unsigned int freq_to_above_hispeed_delay(unsigned int freq)
+{
+	int i;
+	unsigned int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&above_hispeed_delay_lock, flags);
+
+	for (i = 0; i < nabove_hispeed_delay - 1 &&
+			freq >= above_hispeed_delay[i+1]; i += 2)
+		;
+
+	ret = above_hispeed_delay[i];
+	spin_unlock_irqrestore(&above_hispeed_delay_lock, flags);
+	return ret;
+}
+
+static unsigned int freq_to_targetload(unsigned int freq)
+{
+	int i;
+	unsigned int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target_loads_lock, flags);
+
+	for (i = 0; i < ntarget_loads - 1 && freq >= target_loads[i+1]; i += 2)
+		;
+
+	ret = target_loads[i];
+	spin_unlock_irqrestore(&target_loads_lock, flags);
+	return ret;
+}
+
+/*
+ * If increasing frequencies never map to a lower target load then
+ * choose_freq() will find the minimum frequency that does not exceed its
+ * target load given the current load.
+ */
+
+static unsigned int choose_freq(
+	struct cpufreq_interactive_cpuinfo *pcpu, unsigned int loadadjfreq)
+{
+	unsigned int freq = pcpu->policy->cur;
+	unsigned int prevfreq, freqmin, freqmax;
+	unsigned int tl;
+	int index;
+
+	freqmin = 0;
+	freqmax = UINT_MAX;
+
+	do {
+		prevfreq = freq;
+		tl = freq_to_targetload(freq);
+
+		/*
+		 * Find the lowest frequency where the computed load is less
+		 * than or equal to the target load.
+		 */
+
+		cpufreq_frequency_table_target(
+			pcpu->policy, pcpu->freq_table, loadadjfreq / tl,
+			CPUFREQ_RELATION_L, &index);
+		freq = pcpu->freq_table[index].frequency;
+
+		if (freq > prevfreq) {
+			/* The previous frequency is too low. */
+			freqmin = prevfreq;
+
+			if (freq >= freqmax) {
+				/*
+				 * Find the highest frequency that is less
+				 * than freqmax.
+				 */
+				cpufreq_frequency_table_target(
+					pcpu->policy, pcpu->freq_table,
+					freqmax - 1, CPUFREQ_RELATION_H,
+					&index);
+				freq = pcpu->freq_table[index].frequency;
+
+				if (freq == freqmin) {
+					/*
+					 * The first frequency below freqmax
+					 * has already been found to be too
+					 * low.  freqmax is the lowest speed
+					 * we found that is fast enough.
+					 */
+					freq = freqmax;
+					break;
+				}
+			}
+		} else if (freq < prevfreq) {
+			/* The previous frequency is high enough. */
+			freqmax = prevfreq;
+
+			if (freq <= freqmin) {
+				/*
+				 * Find the lowest frequency that is higher
+				 * than freqmin.
+				 */
+				cpufreq_frequency_table_target(
+					pcpu->policy, pcpu->freq_table,
+					freqmin + 1, CPUFREQ_RELATION_L,
+					&index);
+				freq = pcpu->freq_table[index].frequency;
+
+				/*
+				 * If freqmax is the first frequency above
+				 * freqmin then we have already found that
+				 * this speed is fast enough.
+				 */
+				if (freq == freqmax)
+					break;
+			}
+		}
+
+		/* If same frequency chosen as previous then done. */
+	} while (freq != prevfreq);
+
+	return freq;
+}
+
+static u64 update_load(int cpu)
+{
+	struct cpufreq_interactive_cpuinfo *pcpu = &per_cpu(cpuinfo, cpu);
+	u64 now;
+	u64 now_idle;
+	unsigned int delta_idle;
+	unsigned int delta_time;
+	u64 active_time;
+
+	now_idle = get_cpu_idle_time(cpu, &now);
+	delta_idle = (unsigned int)(now_idle - pcpu->time_in_idle);
+	delta_time = (unsigned int)(now - pcpu->time_in_idle_timestamp);
+	active_time = delta_time - delta_idle;
+	pcpu->cputime_speedadj += active_time * pcpu->policy->cur;
+
+	pcpu->time_in_idle = now_idle;
+	pcpu->time_in_idle_timestamp = now;
+	return now;
+}
+
+static void cpufreq_interactive_timer(unsigned long data)
+{
+	u64 now;
+	unsigned int delta_time;
+	u64 cputime_speedadj;
+	int cpu_load;
+	struct cpufreq_interactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, data);
+	unsigned int new_freq;
+	unsigned int loadadjfreq;
+	unsigned int index;
+	unsigned long flags;
+	bool boosted;
+
+	if (!down_read_trylock(&pcpu->enable_sem))
+		return;
+	if (!pcpu->governor_enabled)
+		goto exit;
+
+	spin_lock_irqsave(&pcpu->load_lock, flags);
+	now = update_load(data);
+	delta_time = (unsigned int)(now - pcpu->cputime_speedadj_timestamp);
+	cputime_speedadj = pcpu->cputime_speedadj;
+	spin_unlock_irqrestore(&pcpu->load_lock, flags);
+
+	if (WARN_ON_ONCE(!delta_time))
+		goto rearm;
+
+	do_div(cputime_speedadj, delta_time);
+	loadadjfreq = (unsigned int)cputime_speedadj * 100;
+	cpu_load = loadadjfreq / pcpu->target_freq;
+	boosted = boost_val || now < boostpulse_endtime;
+
+	if (cpu_load >= go_hispeed_load || boosted) {
+		if (pcpu->target_freq < hispeed_freq) {
+			new_freq = hispeed_freq;
+		} else {
+			new_freq = choose_freq(pcpu, loadadjfreq);
+
+			if (new_freq < hispeed_freq)
+				new_freq = hispeed_freq;
+		}
+	} else {
+		new_freq = choose_freq(pcpu, loadadjfreq);
+	}
+
+	if (pcpu->target_freq >= hispeed_freq &&
+	    new_freq > pcpu->target_freq &&
+	    now - pcpu->hispeed_validate_time <
+	    freq_to_above_hispeed_delay(pcpu->target_freq)) {
+		trace_cpufreq_interactive_notyet(
+			data, cpu_load, pcpu->target_freq,
+			pcpu->policy->cur, new_freq);
+		goto rearm;
+	}
+
+	pcpu->hispeed_validate_time = now;
+
+	if (cpufreq_frequency_table_target(pcpu->policy, pcpu->freq_table,
+					   new_freq, CPUFREQ_RELATION_L,
+					   &index)) {
+		pr_warn_once("timer %d: cpufreq_frequency_table_target error\n",
+			     (int) data);
+		goto rearm;
+	}
+
+	new_freq = pcpu->freq_table[index].frequency;
+
+	/*
+	 * Do not scale below floor_freq unless we have been at or above the
+	 * floor frequency for the minimum sample time since last validated.
+	 */
+	if (new_freq < pcpu->floor_freq) {
+		if (now - pcpu->floor_validate_time < min_sample_time) {
+			trace_cpufreq_interactive_notyet(
+				data, cpu_load, pcpu->target_freq,
+				pcpu->policy->cur, new_freq);
+			goto rearm;
+		}
+	}
+
+	/*
+	 * Update the timestamp for checking whether speed has been held at
+	 * or above the selected frequency for a minimum of min_sample_time,
+	 * if not boosted to hispeed_freq.  If boosted to hispeed_freq then we
+	 * allow the speed to drop as soon as the boostpulse duration expires
+	 * (or the indefinite boost is turned off).
+	 */
+
+	if (!boosted || new_freq > hispeed_freq) {
+		pcpu->floor_freq = new_freq;
+		pcpu->floor_validate_time = now;
+	}
+
+	if (pcpu->target_freq == new_freq) {
+		trace_cpufreq_interactive_already(
+			data, cpu_load, pcpu->target_freq,
+			pcpu->policy->cur, new_freq);
+		goto rearm_if_notmax;
+	}
+
+	trace_cpufreq_interactive_target(data, cpu_load, pcpu->target_freq,
+					 pcpu->policy->cur, new_freq);
+
+	pcpu->target_freq = new_freq;
+	spin_lock_irqsave(&speedchange_cpumask_lock, flags);
+	cpumask_set_cpu(data, &speedchange_cpumask);
+	spin_unlock_irqrestore(&speedchange_cpumask_lock, flags);
+	wake_up_process(speedchange_task);
+
+rearm_if_notmax:
+	/*
+	 * Already set max speed and don't see a need to change that,
+	 * wait until next idle to re-evaluate, don't need timer.
+	 */
+	if (pcpu->target_freq == pcpu->policy->max)
+		goto exit;
+
+rearm:
+	if (!timer_pending(&pcpu->cpu_timer))
+		cpufreq_interactive_timer_resched(pcpu);
+
+exit:
+	up_read(&pcpu->enable_sem);
+	return;
+}
+
+static void cpufreq_interactive_idle_start(void)
+{
+	struct cpufreq_interactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, smp_processor_id());
+	int pending;
+
+	if (!down_read_trylock(&pcpu->enable_sem))
+		return;
+	if (!pcpu->governor_enabled) {
+		up_read(&pcpu->enable_sem);
+		return;
+	}
+
+	pending = timer_pending(&pcpu->cpu_timer);
+
+	if (pcpu->target_freq != pcpu->policy->min) {
+		/*
+		 * Entering idle while not at lowest speed.  On some
+		 * platforms this can hold the other CPU(s) at that speed
+		 * even though the CPU is idle. Set a timer to re-evaluate
+		 * speed so this idle CPU doesn't hold the other CPUs above
+		 * min indefinitely.  This should probably be a quirk of
+		 * the CPUFreq driver.
+		 */
+		if (!pending)
+			cpufreq_interactive_timer_resched(pcpu);
+	}
+
+	up_read(&pcpu->enable_sem);
+}
+
+static void cpufreq_interactive_idle_end(void)
+{
+	struct cpufreq_interactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, smp_processor_id());
+
+	if (!down_read_trylock(&pcpu->enable_sem))
+		return;
+	if (!pcpu->governor_enabled) {
+		up_read(&pcpu->enable_sem);
+		return;
+	}
+
+	/* Arm the timer for 1-2 ticks later if not already. */
+	if (!timer_pending(&pcpu->cpu_timer)) {
+		cpufreq_interactive_timer_resched(pcpu);
+	} else if (time_after_eq(jiffies, pcpu->cpu_timer.expires)) {
+		del_timer(&pcpu->cpu_timer);
+		del_timer(&pcpu->cpu_slack_timer);
+		cpufreq_interactive_timer(smp_processor_id());
+	}
+
+	up_read(&pcpu->enable_sem);
+}
+
+static int cpufreq_interactive_speedchange_task(void *data)
+{
+	unsigned int cpu;
+	cpumask_t tmp_mask;
+	unsigned long flags;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+
+	while (1) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_lock_irqsave(&speedchange_cpumask_lock, flags);
+
+		if (cpumask_empty(&speedchange_cpumask)) {
+			spin_unlock_irqrestore(&speedchange_cpumask_lock,
+					       flags);
+			schedule();
+
+			if (kthread_should_stop())
+				break;
+
+			spin_lock_irqsave(&speedchange_cpumask_lock, flags);
+		}
+
+		set_current_state(TASK_RUNNING);
+		tmp_mask = speedchange_cpumask;
+		cpumask_clear(&speedchange_cpumask);
+		spin_unlock_irqrestore(&speedchange_cpumask_lock, flags);
+
+		for_each_cpu(cpu, &tmp_mask) {
+			unsigned int j;
+			unsigned int max_freq = 0;
+
+			pcpu = &per_cpu(cpuinfo, cpu);
+			if (!down_read_trylock(&pcpu->enable_sem))
+				continue;
+			if (!pcpu->governor_enabled) {
+				up_read(&pcpu->enable_sem);
+				continue;
+			}
+
+			for_each_cpu(j, pcpu->policy->cpus) {
+				struct cpufreq_interactive_cpuinfo *pjcpu =
+					&per_cpu(cpuinfo, j);
+
+				if (pjcpu->target_freq > max_freq)
+					max_freq = pjcpu->target_freq;
+			}
+
+			if (max_freq != pcpu->policy->cur)
+				__cpufreq_driver_target(pcpu->policy,
+							max_freq,
+							CPUFREQ_RELATION_H);
+			trace_cpufreq_interactive_setspeed(cpu,
+						     pcpu->target_freq,
+						     pcpu->policy->cur);
+
+			up_read(&pcpu->enable_sem);
+		}
+	}
+
+	return 0;
+}
+
+static void cpufreq_interactive_boost(void)
+{
+	int i;
+	int anyboost = 0;
+	unsigned long flags;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+
+	spin_lock_irqsave(&speedchange_cpumask_lock, flags);
+
+	for_each_online_cpu(i) {
+		pcpu = &per_cpu(cpuinfo, i);
+
+		if (pcpu->target_freq < hispeed_freq) {
+			pcpu->target_freq = hispeed_freq;
+			cpumask_set_cpu(i, &speedchange_cpumask);
+			pcpu->hispeed_validate_time =
+				ktime_to_us(ktime_get());
+			anyboost = 1;
+		}
+
+		/*
+		 * Set floor freq and (re)start timer for when last
+		 * validated.
+		 */
+
+		pcpu->floor_freq = hispeed_freq;
+		pcpu->floor_validate_time = ktime_to_us(ktime_get());
+	}
+
+	spin_unlock_irqrestore(&speedchange_cpumask_lock, flags);
+
+	if (anyboost)
+		wake_up_process(speedchange_task);
+}
+
+static int cpufreq_interactive_notifier(
+	struct notifier_block *nb, unsigned long val, void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+	int cpu;
+	unsigned long flags;
+
+	if (val == CPUFREQ_POSTCHANGE) {
+		pcpu = &per_cpu(cpuinfo, freq->cpu);
+		if (!down_read_trylock(&pcpu->enable_sem))
+			return 0;
+		if (!pcpu->governor_enabled) {
+			up_read(&pcpu->enable_sem);
+			return 0;
+		}
+
+		for_each_cpu(cpu, pcpu->policy->cpus) {
+			struct cpufreq_interactive_cpuinfo *pjcpu =
+				&per_cpu(cpuinfo, cpu);
+			spin_lock_irqsave(&pjcpu->load_lock, flags);
+			update_load(cpu);
+			spin_unlock_irqrestore(&pjcpu->load_lock, flags);
+		}
+
+		up_read(&pcpu->enable_sem);
+	}
+	return 0;
+}
+
+static struct notifier_block cpufreq_notifier_block = {
+	.notifier_call = cpufreq_interactive_notifier,
+};
+
+static unsigned int *get_tokenized_data(const char *buf, int *num_tokens)
+{
+	const char *cp;
+	int i;
+	int ntokens = 1;
+	unsigned int *tokenized_data;
+	int err = -EINVAL;
+
+	cp = buf;
+	while ((cp = strpbrk(cp + 1, " :")))
+		ntokens++;
+
+	if (!(ntokens & 0x1))
+		goto err;
+
+	tokenized_data = kmalloc(ntokens * sizeof(unsigned int), GFP_KERNEL);
+	if (!tokenized_data) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+	cp = buf;
+	i = 0;
+	while (i < ntokens) {
+		if (sscanf(cp, "%u", &tokenized_data[i++]) != 1)
+			goto err_kfree;
+
+		cp = strpbrk(cp, " :");
+		if (!cp)
+			break;
+		cp++;
+	}
+
+	if (i != ntokens)
+		goto err_kfree;
+
+	*num_tokens = ntokens;
+	return tokenized_data;
+
+err_kfree:
+	kfree(tokenized_data);
+err:
+	return ERR_PTR(err);
+}
+
+static ssize_t show_target_loads(
+	struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	int i;
+	ssize_t ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target_loads_lock, flags);
+
+	for (i = 0; i < ntarget_loads; i++)
+		ret += sprintf(buf + ret, "%u%s", target_loads[i],
+			       i & 0x1 ? ":" : " ");
+
+	ret += sprintf(buf + ret, "\n");
+	spin_unlock_irqrestore(&target_loads_lock, flags);
+	return ret;
+}
+
+static ssize_t store_target_loads(
+	struct kobject *kobj, struct attribute *attr, const char *buf,
+	size_t count)
+{
+	int ntokens;
+	unsigned int *new_target_loads = NULL;
+	unsigned long flags;
+
+	new_target_loads = get_tokenized_data(buf, &ntokens);
+	if (IS_ERR(new_target_loads))
+		return PTR_RET(new_target_loads);
+
+	spin_lock_irqsave(&target_loads_lock, flags);
+	if (target_loads != default_target_loads)
+		kfree(target_loads);
+	target_loads = new_target_loads;
+	ntarget_loads = ntokens;
+	spin_unlock_irqrestore(&target_loads_lock, flags);
+	return count;
+}
+
+static struct global_attr target_loads_attr =
+	__ATTR(target_loads, S_IRUGO | S_IWUSR,
+		show_target_loads, store_target_loads);
+
+static ssize_t show_above_hispeed_delay(
+	struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	int i;
+	ssize_t ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&above_hispeed_delay_lock, flags);
+
+	for (i = 0; i < nabove_hispeed_delay; i++)
+		ret += sprintf(buf + ret, "%u%s", above_hispeed_delay[i],
+			       i & 0x1 ? ":" : " ");
+
+	ret += sprintf(buf + ret, "\n");
+	spin_unlock_irqrestore(&above_hispeed_delay_lock, flags);
+	return ret;
+}
+
+static ssize_t store_above_hispeed_delay(
+	struct kobject *kobj, struct attribute *attr, const char *buf,
+	size_t count)
+{
+	int ntokens;
+	unsigned int *new_above_hispeed_delay = NULL;
+	unsigned long flags;
+
+	new_above_hispeed_delay = get_tokenized_data(buf, &ntokens);
+	if (IS_ERR(new_above_hispeed_delay))
+		return PTR_RET(new_above_hispeed_delay);
+
+	spin_lock_irqsave(&above_hispeed_delay_lock, flags);
+	if (above_hispeed_delay != default_above_hispeed_delay)
+		kfree(above_hispeed_delay);
+	above_hispeed_delay = new_above_hispeed_delay;
+	nabove_hispeed_delay = ntokens;
+	spin_unlock_irqrestore(&above_hispeed_delay_lock, flags);
+	return count;
+
+}
+
+static struct global_attr above_hispeed_delay_attr =
+	__ATTR(above_hispeed_delay, S_IRUGO | S_IWUSR,
+		show_above_hispeed_delay, store_above_hispeed_delay);
+
+static ssize_t show_hispeed_freq(struct kobject *kobj,
+				 struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", hispeed_freq);
+}
+
+static ssize_t store_hispeed_freq(struct kobject *kobj,
+				  struct attribute *attr, const char *buf,
+				  size_t count)
+{
+	int ret;
+	long unsigned int val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	hispeed_freq = val;
+	return count;
+}
+
+static struct global_attr hispeed_freq_attr = __ATTR(hispeed_freq, 0644,
+		show_hispeed_freq, store_hispeed_freq);
+
+
+static ssize_t show_go_hispeed_load(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", go_hispeed_load);
+}
+
+static ssize_t store_go_hispeed_load(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	go_hispeed_load = val;
+	return count;
+}
+
+static struct global_attr go_hispeed_load_attr = __ATTR(go_hispeed_load, 0644,
+		show_go_hispeed_load, store_go_hispeed_load);
+
+static ssize_t show_min_sample_time(struct kobject *kobj,
+				struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", min_sample_time);
+}
+
+static ssize_t store_min_sample_time(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	min_sample_time = val;
+	return count;
+}
+
+static struct global_attr min_sample_time_attr = __ATTR(min_sample_time, 0644,
+		show_min_sample_time, store_min_sample_time);
+
+static ssize_t show_timer_rate(struct kobject *kobj,
+			struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", timer_rate);
+}
+
+static ssize_t store_timer_rate(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = strict_strtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	timer_rate = val;
+	return count;
+}
+
+static struct global_attr timer_rate_attr = __ATTR(timer_rate, 0644,
+		show_timer_rate, store_timer_rate);
+
+static ssize_t show_timer_slack(
+	struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", timer_slack_val);
+}
+
+static ssize_t store_timer_slack(
+	struct kobject *kobj, struct attribute *attr, const char *buf,
+	size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtol(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	timer_slack_val = val;
+	return count;
+}
+
+define_one_global_rw(timer_slack);
+
+static ssize_t show_boost(struct kobject *kobj, struct attribute *attr,
+			  char *buf)
+{
+	return sprintf(buf, "%d\n", boost_val);
+}
+
+static ssize_t store_boost(struct kobject *kobj, struct attribute *attr,
+			   const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	boost_val = val;
+
+	if (boost_val) {
+		trace_cpufreq_interactive_boost("on");
+		cpufreq_interactive_boost();
+	} else {
+		trace_cpufreq_interactive_unboost("off");
+	}
+
+	return count;
+}
+
+define_one_global_rw(boost);
+
+static ssize_t store_boostpulse(struct kobject *kobj, struct attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	boostpulse_endtime = ktime_to_us(ktime_get()) + boostpulse_duration_val;
+	trace_cpufreq_interactive_boost("pulse");
+	cpufreq_interactive_boost();
+	return count;
+}
+
+static struct global_attr boostpulse =
+	__ATTR(boostpulse, 0200, NULL, store_boostpulse);
+
+static ssize_t show_boostpulse_duration(
+	struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", boostpulse_duration_val);
+}
+
+static ssize_t store_boostpulse_duration(
+	struct kobject *kobj, struct attribute *attr, const char *buf,
+	size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	boostpulse_duration_val = val;
+	return count;
+}
+
+define_one_global_rw(boostpulse_duration);
+
+static ssize_t show_io_is_busy(struct kobject *kobj,
+			struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", io_is_busy);
+}
+
+static ssize_t store_io_is_busy(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	unsigned long val;
+
+	ret = kstrtoul(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	io_is_busy = val;
+	return count;
+}
+
+static struct global_attr io_is_busy_attr = __ATTR(io_is_busy, 0644,
+		show_io_is_busy, store_io_is_busy);
+
+static struct attribute *interactive_attributes[] = {
+	&target_loads_attr.attr,
+	&above_hispeed_delay_attr.attr,
+	&hispeed_freq_attr.attr,
+	&go_hispeed_load_attr.attr,
+	&min_sample_time_attr.attr,
+	&timer_rate_attr.attr,
+	&timer_slack.attr,
+	&boost.attr,
+	&boostpulse.attr,
+	&boostpulse_duration.attr,
+	&io_is_busy_attr.attr,
+	NULL,
+};
+
+static struct attribute_group interactive_attr_group = {
+	.attrs = interactive_attributes,
+	.name = "interactive",
+};
+
+static int cpufreq_interactive_idle_notifier(struct notifier_block *nb,
+					     unsigned long val,
+					     void *data)
+{
+	switch (val) {
+	case IDLE_START:
+		cpufreq_interactive_idle_start();
+		break;
+	case IDLE_END:
+		cpufreq_interactive_idle_end();
+		break;
+	}
+
+	return 0;
+}
+
+static struct notifier_block cpufreq_interactive_idle_nb = {
+	.notifier_call = cpufreq_interactive_idle_notifier,
+};
+
+static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
+		unsigned int event)
+{
+	int rc;
+	unsigned int j;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+	struct cpufreq_frequency_table *freq_table;
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if (!cpu_online(policy->cpu))
+			return -EINVAL;
+
+		mutex_lock(&gov_lock);
+
+		freq_table =
+			cpufreq_frequency_get_table(policy->cpu);
+		if (!hispeed_freq)
+			hispeed_freq = policy->max;
+
+		for_each_cpu(j, policy->cpus) {
+			unsigned long expires;
+
+			pcpu = &per_cpu(cpuinfo, j);
+			pcpu->policy = policy;
+			pcpu->target_freq = policy->cur;
+			pcpu->freq_table = freq_table;
+			pcpu->floor_freq = pcpu->target_freq;
+			pcpu->floor_validate_time =
+				ktime_to_us(ktime_get());
+			pcpu->hispeed_validate_time =
+				pcpu->floor_validate_time;
+			down_write(&pcpu->enable_sem);
+			expires = jiffies + usecs_to_jiffies(timer_rate);
+			pcpu->cpu_timer.expires = expires;
+			add_timer_on(&pcpu->cpu_timer, j);
+			if (timer_slack_val >= 0) {
+				expires += usecs_to_jiffies(timer_slack_val);
+				pcpu->cpu_slack_timer.expires = expires;
+				add_timer_on(&pcpu->cpu_slack_timer, j);
+			}
+			pcpu->governor_enabled = 1;
+			up_write(&pcpu->enable_sem);
+		}
+
+		/*
+		 * Do not register the idle hook and create sysfs
+		 * entries if we have already done so.
+		 */
+		if (++active_count > 1) {
+			mutex_unlock(&gov_lock);
+			return 0;
+		}
+
+		rc = sysfs_create_group(cpufreq_global_kobject,
+				&interactive_attr_group);
+		if (rc) {
+			mutex_unlock(&gov_lock);
+			return rc;
+		}
+
+		idle_notifier_register(&cpufreq_interactive_idle_nb);
+		cpufreq_register_notifier(
+			&cpufreq_notifier_block, CPUFREQ_TRANSITION_NOTIFIER);
+		mutex_unlock(&gov_lock);
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		mutex_lock(&gov_lock);
+		for_each_cpu(j, policy->cpus) {
+			pcpu = &per_cpu(cpuinfo, j);
+			down_write(&pcpu->enable_sem);
+			pcpu->governor_enabled = 0;
+			del_timer_sync(&pcpu->cpu_timer);
+			del_timer_sync(&pcpu->cpu_slack_timer);
+			up_write(&pcpu->enable_sem);
+		}
+
+		if (--active_count > 0) {
+			mutex_unlock(&gov_lock);
+			return 0;
+		}
+
+		cpufreq_unregister_notifier(
+			&cpufreq_notifier_block, CPUFREQ_TRANSITION_NOTIFIER);
+		idle_notifier_unregister(&cpufreq_interactive_idle_nb);
+		sysfs_remove_group(cpufreq_global_kobject,
+				&interactive_attr_group);
+		mutex_unlock(&gov_lock);
+
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+		if (policy->max < policy->cur)
+			__cpufreq_driver_target(policy,
+					policy->max, CPUFREQ_RELATION_H);
+		else if (policy->min > policy->cur)
+			__cpufreq_driver_target(policy,
+					policy->min, CPUFREQ_RELATION_L);
+		break;
+	}
+	return 0;
+}
+
+static void cpufreq_interactive_nop_timer(unsigned long data)
+{
+}
+
+static int __init cpufreq_interactive_init(void)
+{
+	unsigned int i;
+	struct cpufreq_interactive_cpuinfo *pcpu;
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO-1 };
+
+	/* Initalize per-cpu timers */
+	for_each_possible_cpu(i) {
+		pcpu = &per_cpu(cpuinfo, i);
+		init_timer_deferrable(&pcpu->cpu_timer);
+		pcpu->cpu_timer.function = cpufreq_interactive_timer;
+		pcpu->cpu_timer.data = i;
+		init_timer(&pcpu->cpu_slack_timer);
+		pcpu->cpu_slack_timer.function = cpufreq_interactive_nop_timer;
+		spin_lock_init(&pcpu->load_lock);
+		init_rwsem(&pcpu->enable_sem);
+	}
+
+	spin_lock_init(&target_loads_lock);
+	spin_lock_init(&speedchange_cpumask_lock);
+	spin_lock_init(&above_hispeed_delay_lock);
+	mutex_init(&gov_lock);
+	speedchange_task =
+		kthread_create(cpufreq_interactive_speedchange_task, NULL,
+			       "cfinteractive");
+	if (IS_ERR(speedchange_task))
+		return PTR_ERR(speedchange_task);
+
+	sched_setscheduler_nocheck(speedchange_task, SCHED_FIFO, &param);
+	get_task_struct(speedchange_task);
+
+	/* NB: wake up so the thread does not look hung to the freezer */
+	wake_up_process(speedchange_task);
+
+	return cpufreq_register_governor(&cpufreq_gov_interactive);
+}
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE
+fs_initcall(cpufreq_interactive_init);
+#else
+module_init(cpufreq_interactive_init);
+#endif
+
+static void __exit cpufreq_interactive_exit(void)
+{
+	cpufreq_unregister_governor(&cpufreq_gov_interactive);
+	kthread_stop(speedchange_task);
+	put_task_struct(speedchange_task);
+}
+
+module_exit(cpufreq_interactive_exit);
+
+MODULE_AUTHOR("Mike Chan <mike@android.com>");
+MODULE_DESCRIPTION("'cpufreq_interactive' - A cpufreq governor for "
+	"Latency sensitive workloads");
+MODULE_LICENSE("GPL");
diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 3998316..1a9a6a5 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -316,6 +316,27 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	return 0;
 }
 
+static int cpufreq_stats_create_table_cpu(unsigned int cpu)
+{
+	struct cpufreq_policy *policy;
+	struct cpufreq_frequency_table *table;
+	int ret = -ENODEV;
+
+	policy = cpufreq_cpu_get(cpu);
+	if (!policy)
+		return -ENODEV;
+
+	table = cpufreq_frequency_get_table(cpu);
+	if (!table)
+		goto out;
+
+	ret = cpufreq_stats_create_table(policy, table);
+
+out:
+	cpufreq_cpu_put(policy);
+	return ret;
+}
+
 static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 					       unsigned long action,
 					       void *hcpu)
@@ -335,6 +356,10 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 	case CPU_DEAD_FROZEN:
 		cpufreq_stats_free_table(cpu);
 		break;
+	case CPU_DOWN_FAILED:
+	case CPU_DOWN_FAILED_FROZEN:
+		cpufreq_stats_create_table_cpu(cpu);
+		break;
 	}
 	return NOTIFY_OK;
 }
