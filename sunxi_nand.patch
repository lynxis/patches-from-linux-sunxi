diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index a796407..99da56a 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -555,4 +555,22 @@ config BLK_DEV_RBD
 
 	  If unsure, say N.
 
+config SUNXI_NAND
+	depends on BLOCK
+	depends on ARCH_SUN4I || ARCH_SUN5I || ARCH_SUN7I
+	select SUNXI_NAND_PARTITION
+	tristate "SUNXI Nandflash Driver"
+
+config SUNXI_NAND_COMPAT_DEV
+	depends on SUNXI_NAND
+	bool "Create old nand device names (nanda-nandz)"
+	default y
+	---help---
+	  This is the traditional device naming on sunxi platform.
+	  If unsure, say Y.
+
+config SUNXI_NAND_TEST
+	depends on SUNXI_NAND
+	tristate "SUNXI Nandflash Test Driver "
+
 endif # BLK_DEV
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index 5b79505..e59d765 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -41,5 +41,7 @@ obj-$(CONFIG_XEN_BLKDEV_BACKEND)	+= xen-blkback/
 obj-$(CONFIG_BLK_DEV_DRBD)     += drbd/
 obj-$(CONFIG_BLK_DEV_RBD)     += rbd.o
 obj-$(CONFIG_BLK_DEV_PCIESSD_MTIP32XX)	+= mtip32xx/
+obj-$(CONFIG_SUNXI_NAND) += sunxi_nand/
+
 
 swim_mod-y	:= swim.o swim_asm.o
diff --git a/drivers/block/sunxi_nand/Makefile b/drivers/block/sunxi_nand/Makefile
new file mode 100644
index 0000000..7dd4bb8
--- /dev/null
+++ b/drivers/block/sunxi_nand/Makefile
@@ -0,0 +1,2 @@
+obj-y		+= nfd/
+obj-$(CONFIG_SUNXI_NAND_TEST)		+= nandtest/
diff --git a/drivers/block/sunxi_nand/f20_nand_readme.txt b/drivers/block/sunxi_nand/f20_nand_readme.txt
new file mode 100644
index 0000000..390f58b
--- /dev/null
+++ b/drivers/block/sunxi_nand/f20_nand_readme.txt
@@ -0,0 +1,31 @@
+/*
+ * drivers/block/sunxi_nand/f20_nand_readme.txt
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+########################################################################
+#$Id$
+########################################################################
+version: sun3i_nand_ver0_01
+author:  penggang,clmiao
+date:    2011/04/01 10:52
+descript:
+1) fix bug: not check all parameters in write sectors
+2) Add abnormal test items
diff --git a/drivers/block/sunxi_nand/include/sunii.h b/drivers/block/sunxi_nand/include/sunii.h
new file mode 100644
index 0000000..57cea6d
--- /dev/null
+++ b/drivers/block/sunxi_nand/include/sunii.h
@@ -0,0 +1,95 @@
+/*
+ * drivers/block/sunxi_nand/include/sunii.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __SUNII_H_
+#define  __SUNII_H_
+
+extern void * nand_base;
+
+#define __REG(x)    (*(volatile unsigned int   *)(nand_base + x))
+#define __REGw(x)   (*(volatile unsigned int   *)(nand_base + x))
+#define __REGhw(x)  (*(volatile unsigned short *)(nand_base + x))
+#define __REGb(x)   (*(volatile unsigned char  *)(nand_base + x))
+/*
+*********************************************************************************************************
+*   hardware registers base define
+*********************************************************************************************************
+*/
+#define REGS_pBASE		0x01C00000		//å¯å­å¨ç©çå°å
+#define REGS_pSIZE      0x00300000      //å¯å­å¨ç©çç©ºé´å¤§å°
+#define DRAM_pBASE      0x80000000
+#define SRAM_pBASE      0x00000000
+//#define SRAM_SIZE      (32 * 1024)
+
+//#define	REGS_vBASE  0xf0000000      //??â²??Ã·DÃ©?aÎ¼??Â·
+//#define DRAM_vBASE	0xc2000000
+//#define SRAM_vBASE  0xffe00000
+
+//#ifdef  USE_PHYSICAL_ADDRESS
+//	#define SRAM_BASE               SRAM_pBASE
+//	#define DRAM_BASE               DRAM_pBASE
+//#else
+//	#define SRAM_BASE               SRAM_vBASE
+//	#define DRAM_BASE               DRAM_vBASE
+//#endif    // #ifdef  USE_PHYSICAL_ADDRESS
+//
+// ç©çå°å
+#define SRAM_REGS_pBASE         ( REGS_pBASE + 0x00000 )    //SRAM controller
+#define DRAM_REGS_pBASE         ( REGS_pBASE + 0x01000 )    //SDRAM/DDR controller
+#define DMAC_REGS_pBASE         ( REGS_pBASE + 0x02000 )    //DMA controller
+#define NAFC_REGS_pBASE         ( REGS_pBASE + 0x03000 )    //nand flash controller
+#define TSC_REGS_pBASE          ( REGS_pBASE + 0x04000 )    //transport stream interface
+#define SPIC0_REGS_pBASE        ( REGS_pBASE + 0x05000 )    //spi
+#define SPIC1_REGS_pBASE        ( REGS_pBASE + 0x06000 )    //spi
+#define MSHC_REGS_pBASE         ( REGS_pBASE + 0x07000 )    //ms
+#define CSIC_REGS_pBASE         ( REGS_pBASE + 0x09000 )    //csi controller
+#define TVEC_REGS_pBASE         ( REGS_pBASE + 0x0a000 )    //tv
+#define LCDC_REGS_pBASE         ( REGS_pBASE + 0x0c000 )    //lcd
+#define MACC_REGS_pBASE         ( REGS_pBASE + 0x0e000 )    //media accelerate
+#define SDMC0_REGS_pBASE        ( REGS_pBASE + 0x0f000 )    //sdmmc0 controller
+#define SDMC1_REGS_pBASE        ( REGS_pBASE + 0x10000 )    //sdmmc1 controller
+#define SDMC2_REGS_pBASE        ( REGS_pBASE + 0x11000 )    //sdmmc2 controller
+#define SDMC3_REGS_pBASE        ( REGS_pBASE + 0x12000 )    //sdmmc3 controller
+#define USBC0_REGS_pBASE        ( REGS_pBASE + 0x13000 )    //usb/otg 0 controller
+#define USBC1_REGS_pBASE        ( REGS_pBASE + 0x14000 )    //usb/otg 1 controller
+#define CCMU_REGS_pBASE         ( REGS_pBASE + 0x20000 )    //clock manager unit
+#define INTC_REGS_pBASE         ( REGS_pBASE + 0x20400 )    //arm interrupt controller
+#define PIOC_REGS_pBASE         ( REGS_pBASE + 0x20800 )    //general perpose I/O
+#define TMRC_REGS_pBASE         ( REGS_pBASE + 0x20c00 )    //timer
+#define UART0_REGS_pBASE        ( REGS_pBASE + 0x21000 )    //uart0
+#define UART1_REGS_pBASE        ( REGS_pBASE + 0x21400 )    //uart1
+#define UART2_REGS_pBASE        ( REGS_pBASE + 0x21800 )    //uart2
+#define UART3_REGS_pBASE        ( REGS_pBASE + 0x21c00 )    //uart3
+#define SPDIF_REGS_pBASE        ( REGS_pBASE + 0x22000 )    //SPDIF interface
+#define PS2_REGS_pBASE          ( REGS_pBASE + 0x22400 )    //media accelerate
+#define AC97_REGS_pBASE         ( REGS_pBASE + 0x22800 )    //AC97 interface
+#define IRCC_REGS_pBASE         ( REGS_pBASE + 0x22c00 )    //fir
+#define I2SC_REGS_pBASE         ( REGS_pBASE + 0x23000 )    //i2s
+#define LRAC_REGS_pBASE         ( REGS_pBASE + 0x23400 )    //lradc
+#define ADDA_REGS_pBASE         ( REGS_pBASE + 0x23c00 )    //AD/DA
+#define TWIC0_REGS_pBASE        ( REGS_pBASE + 0x24000 )    //twi0
+#define TWIC1_REGS_pBASE        ( REGS_pBASE + 0x24400 )    //twi1
+#define TPC_REGS_pBASE          ( REGS_pBASE + 0x24800 )    //touch panel controller
+#define DISE_REGS_pBASE         ( REGS_pBASE + 0x200000)    //display engine
+
+
+#endif // end of #ifndef __SUNII_H_
diff --git a/drivers/block/sunxi_nand/include/type_def.h b/drivers/block/sunxi_nand/include/type_def.h
new file mode 100644
index 0000000..c23061e
--- /dev/null
+++ b/drivers/block/sunxi_nand/include/type_def.h
@@ -0,0 +1,59 @@
+/*
+ * drivers/block/sunxi_nand/include/type_def.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef TYPE_DEF_H
+#define TYPE_DEF_H
+
+//#include "sunii.h"
+#include <linux/kernel.h>
+
+//typedef signed char s8;
+//typedef unsigned char u8;
+//
+//typedef signed short s16;
+//typedef unsigned short u16;
+//
+//typedef signed int s32;
+//typedef unsigned int u32;
+//
+//typedef signed long s64;
+//typedef unsigned long u64;
+//
+//typedef signed char __s8;
+//typedef unsigned char __u8;
+//
+//typedef signed short __s16;
+//typedef unsigned short __u16;
+//
+//typedef signed int __s32;
+//typedef unsigned int __u32;
+//
+//typedef signed long __s64;
+//typedef unsigned long __u64;
+
+  typedef unsigned int __hdle;
+
+#define EPDK_OK 0
+#define EPDK_FAIL -1
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/block/sunxi_nand/nandtest/Makefile b/drivers/block/sunxi_nand/nandtest/Makefile
new file mode 100644
index 0000000..6c1fe22
--- /dev/null
+++ b/drivers/block/sunxi_nand/nandtest/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_SUNXI_NAND_TEST) +=nand_test.o
diff --git a/drivers/block/sunxi_nand/nandtest/nand_test.c b/drivers/block/sunxi_nand/nandtest/nand_test.c
new file mode 100644
index 0000000..961a6f0
--- /dev/null
+++ b/drivers/block/sunxi_nand/nandtest/nand_test.c
@@ -0,0 +1,1290 @@
+/*
+ * drivers/block/sunxi_nand/nandtest/nand_test.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/stat.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/scatterlist.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/cpufreq.h>
+#include <linux/sched.h>
+#include "../src/include/nand_type.h"
+#include "../src/include/nand_drv_cfg.h"
+#include "../src/include/nand_format.h"
+#include "../src/include/nand_logic.h"
+#include "../src/include/nand_oal.h"
+#include "../src/include/nand_physic.h"
+#include "../src/include/nand_scan.h"
+#include "../src/include/nand_simple.h"
+
+#include "../nfd/nand_blk.h"
+#include <plat/mbr.h>
+
+#include "nand_test.h"
+
+#ifdef CONFIG_SUNXI_NAND_TEST     //  open nand test module
+
+#define NAND_TEST  "[nand_test]:"
+
+#define RESULT_OK   (0)
+#define RESULT_FAIL   (1)
+
+#define MAX_SECTORS       (100)         // max alloc buffer
+#define BUFFER_SIZE       (512*MAX_SECTORS)
+
+static ssize_t nand_test_store(struct kobject *kobject,struct attribute *attr, const char *buf, size_t count);
+static ssize_t nand_test_show(struct kobject *kobject,struct attribute *attr, char *buf);
+
+void obj_test_release(struct kobject *kobject);
+
+
+
+struct nand_test_card {
+    u8    *buffer;
+    u8    *scratch;
+    unsigned int sector_cnt;
+};
+
+struct nand_test_case {
+    const char *name;
+    int  sectors_cnt;
+    int (*prepare)(struct nand_test_card *, int sectors_cnt);
+    int (*run)(struct nand_test_card * );
+    int (*cleanup)(struct nand_test_card *);
+};
+
+struct attribute prompt_attr = {
+    .name = "nand_test",
+    .mode = S_IRWXUGO
+};
+
+static struct attribute *def_attrs[] = {
+    &prompt_attr,
+    NULL
+};
+
+
+struct sysfs_ops obj_test_sysops =
+{
+    .show =  nand_test_show,
+    .store = nand_test_store
+};
+
+struct kobj_type ktype =
+{
+    .release = obj_test_release,
+    .sysfs_ops=&obj_test_sysops,
+    .default_attrs=def_attrs
+};
+
+void obj_test_release(struct kobject *kobject)
+{
+    printk(NAND_TEST "release .\n");
+}
+
+
+
+/* prepare buffer data for read and write*/
+static int __nand_test_prepare(struct nand_test_card *test, int sector_cnt,int write)
+{
+    int i;
+
+    test->sector_cnt = sector_cnt;
+
+    if (write){
+        memset(test->buffer, 0xDF, 512 * (sector_cnt) +4);
+    }
+    else {
+        for (i = 0; i < 512 * (sector_cnt) + 4; i++){
+            test->buffer[i] = i%256;
+         }
+    }
+
+    return 0;
+}
+
+
+static int nand_test_prepare_write(struct nand_test_card *test, int sector_cnt)
+{
+    return __nand_test_prepare(test, sector_cnt, 1);
+}
+
+static int nand_test_prepare_read(struct nand_test_card *test, int sector_cnt)
+{
+    return __nand_test_prepare(test, sector_cnt, 0);
+}
+
+
+static int nand_test_prepare_pwm(struct nand_test_card *test, int sector_cnt)
+{
+    test->sector_cnt = sector_cnt;
+    return 0;
+}
+
+
+/* read /write one sector with out verification*/
+static int nand_test_simple_transfer(struct nand_test_card *test,
+                                    unsigned dev_addr,unsigned start,
+                                    unsigned nsector, int write)
+{
+    int ret;
+    if (write){
+
+#ifndef NAND_CACHE_RW
+        ret = LML_Write(start, nsector, test->buffer + dev_addr);
+#else
+        //printk("Ws %lu %lu \n",start, nsector);
+        ret = NAND_CacheWrite(start, nsector, test->buffer + dev_addr);
+#endif
+        if(ret){
+            return -EIO;
+        }
+        return 0;
+        }
+    else {
+
+#ifndef NAND_CACHE_RW
+        LML_FlushPageCache();
+        ret = LML_Read(start, nsector, test->buffer + dev_addr);
+#else
+        //printk("Rs %lu %lu \n",start, nsector);
+        LML_FlushPageCache();
+        ret = NAND_CacheRead(start, nsector, test->buffer + dev_addr);
+#endif                                                  // read
+
+        if (ret){
+            return -EIO;
+        }
+        return 0;
+    }
+}
+
+
+/* read /write one or more sectors with verification*/
+static int nand_test_transfer(struct nand_test_card *test,
+                              unsigned dev_addr,unsigned start,
+                              unsigned nsector, int write)
+{
+    int ret;
+    int i;
+
+    if (!write){
+        ret = nand_test_simple_transfer(test, 0, start, nsector, 1);  // write to sectors for read
+        if (ret){
+            return ret;
+        }
+        memset(test->buffer, 0, nsector * 512 +4);    // clean mem for read
+    }
+
+    if ( ( ret = nand_test_simple_transfer(test, dev_addr, start, nsector, write ) ) ) {   // read or write
+        return ret;
+    }
+    if(write){
+        memset(test->buffer, 0, nsector * 512 + 4);    // clean mem for read
+        ret = nand_test_simple_transfer(test, 0 , start, nsector, 0);   // read
+        if (ret){
+            return ret;
+        }
+        for(i  = 0; i < nsector * 512; i++){    // verify data
+            if (test->buffer[i] != 0xDF){
+                printk(KERN_INFO "[nand_test] Ttest->buffer[i] = %d, i = %d, dev_addr = %d, nsector = %d\n", test->buffer[i],  i, dev_addr,nsector);
+                return RESULT_FAIL;
+            }
+        }
+    }
+    else {   //read
+        for(i  = 0 + dev_addr; i < nsector * 512 + dev_addr ; i++){   // verify data
+
+            if (test->buffer[i] != (i-dev_addr)%256){
+                printk(KERN_INFO "[nand_test] Ttest->buffer[i] = %d, i = %d, dev_addr = %d, nsector = %d\n", test->buffer[i],  i, dev_addr,nsector);
+                return RESULT_FAIL;
+            }
+       }
+    }
+    return RESULT_OK;
+}
+
+
+
+/* write one sector without verification*/
+static int nand_test_single_write(struct nand_test_card *test)
+{
+    int ret;
+
+
+    ret = nand_test_simple_transfer(test, 0, 0, test->sector_cnt,1);
+
+    if(ret){
+        return ret;
+    }
+    return nand_test_simple_transfer(test, 0, DiskSize/2, test->sector_cnt, 1 );
+
+}
+
+/* read one sector without verification*/
+static int nand_test_single_read(struct nand_test_card *test)
+{
+    int ret;
+
+    ret = nand_test_simple_transfer(test, 0, 0, test->sector_cnt,0);
+    if(ret){
+        return ret;
+    }
+    return nand_test_simple_transfer(test, 0, DiskSize/2, test->sector_cnt, 0);
+}
+
+/* write one  sector with verification */
+static int nand_test_verify_write(struct nand_test_card *test)
+{
+    return nand_test_transfer(test,  0, 1, test->sector_cnt, 1);
+}
+
+/* read one  sector with verification */
+static int nand_test_verify_read(struct nand_test_card *test)
+{
+    return nand_test_transfer(test,  0, 1, test->sector_cnt, 0);
+}
+
+/* write multi sector with start sector num 5*/
+static int nand_test_multi_write(struct nand_test_card *test)
+{
+    return nand_test_transfer(test,  0, 5, test->sector_cnt, 1);
+}
+
+
+/* write multi sector with start sector num 29*/
+
+static int nand_test_multi_read(struct nand_test_card *test)
+{
+    return nand_test_transfer(test,  0, 29, test->sector_cnt, 0);
+}
+
+/* write from buffer+1, buffer+2, and buffer+3, where buffer is  4  bytes algin */
+static int nand_test_align_write(struct nand_test_card *test)
+{
+    int ret;
+    int i;
+
+    for (i = 1;i < 4;i++) {
+        ret = nand_test_transfer(test,  i, 1, test->sector_cnt, 1);
+    }
+    return ret;
+}
+
+
+/* read to buffer+1, buffer+2, and buffer+3, where buffer is  4  bytes algin */
+
+static int nand_test_align_read(struct nand_test_card *test)
+{
+    int ret;
+    int i;
+
+    for (i = 1;i < 4;i++) {
+        ret = nand_test_transfer(test,  i, 1, test->sector_cnt, 0);
+    }
+    if (ret){
+        return ret;
+    }
+
+    return 0;
+}
+
+/* write to incorrect sector num such as -1, DiskSize,  DiskSize +1 */
+static int nand_test_negstart_write(struct nand_test_card *test)
+{
+    int ret;
+
+    /* start + sectnum > 0, start < 0*/
+    ret = nand_test_simple_transfer(test,  0, -5 , 11, 1);
+
+    if (!ret){
+        return RESULT_FAIL;
+    }
+    printk(NAND_TEST "start + sectnum > 0 pass\n");
+
+    /* start + sectnum < 0 , start < 0 */
+    ret = nand_test_simple_transfer(test,  0, -62, 5, 1);
+
+    if (!ret){
+        return RESULT_FAIL;
+    }
+    return RESULT_OK;
+
+}
+
+
+/* read from negative sector num   start + sectnum > 0, and start + setnum < 0 */
+static int nand_test_negstart_read(struct nand_test_card *test)
+{
+    int ret;
+
+    /* start + sectnum > 0, start < 0*/
+    ret = nand_test_simple_transfer(test,  0, -1, 3, 0);
+
+    if (!ret){
+        return RESULT_FAIL;
+    }
+    printk(NAND_TEST "start + sectnum > 0 pass\n");
+
+    /* start + sectnum < 0 , start < 0 */
+    ret = nand_test_simple_transfer(test,  0, -90, 15, 0);
+
+    if (!ret){
+        return RESULT_FAIL;
+    }
+    return RESULT_OK;
+
+}
+
+static int nand_test_beyond(struct nand_test_card *test, int write)
+{
+    int ret;
+
+
+    ret = nand_test_simple_transfer(test,  0, DiskSize -3 , 5, write);
+
+    if (!ret){
+
+        return 1;
+    }
+    printk(NAND_TEST "DiskSize -3 , 5 pass\n");
+    ret = nand_test_simple_transfer(test,  0, DiskSize -1 , 2, write);
+
+    if (!ret){
+
+        return 1;
+    }
+    printk(NAND_TEST "DiskSize -1 , 2 pass\n");
+    ret = nand_test_simple_transfer(test,  0, DiskSize , 3, write);
+
+    if (!ret){
+
+        return 1;
+    }
+
+    printk(NAND_TEST "DiskSize , 3 pass\n");
+
+    ret = nand_test_simple_transfer(test,  0, DiskSize + 3 , 0, write);
+
+    if (!ret){
+
+        return 1;
+    }
+
+    printk(NAND_TEST "DiskSize + 3 , 0 pass\n");
+
+    ret = nand_test_simple_transfer(test,  0, DiskSize - 3 , -2, write);
+
+    if (!ret){
+
+        return 1;
+    }
+
+    printk(NAND_TEST "DiskSize - 3 , -2 pass\n");
+
+    return RESULT_OK;
+}
+
+
+static int nand_test_beyond_write(struct nand_test_card *test)
+{
+    return (nand_test_beyond(test, 1));
+}
+
+
+/* read from incorrect sector num such as -1, DiskSize(max sector num + 1),  DiskSize +1 */
+static int nand_test_beyond_read(struct nand_test_card *test)
+{
+
+    return (nand_test_beyond(test, 0));
+
+}
+
+
+
+/* write all sectors from sector num 0 to DiskSize - 1(max sector num )*/
+static int nand_test_write_all_ascending(struct nand_test_card *test)
+{
+    int ret;
+    int i = 0;
+    int j = 0;
+
+    printk(KERN_INFO "DiskSize = %x\n", DiskSize);
+
+
+    for (i = 0; i < DiskSize; i++) {   // write all sectors
+        ret = nand_test_simple_transfer(test, 0, i, test->sector_cnt,1);
+        if(ret){
+            printk(KERN_INFO "nand_test_write_all_ascending fail, sector num %d\n", i);
+            return ret;
+        }
+    }
+
+    /* start check */
+    printk(KERN_INFO "[nand test]:start check\n");
+
+    for (i = 0; i < DiskSize; i++){
+        memset(test->buffer, 0, test->sector_cnt * 512);  // clear buffer
+
+        ret = nand_test_simple_transfer(test, 0 , i, test->sector_cnt, 0);   // read
+        if(ret){
+            return ret;
+        }
+
+        for(j  = 0; j < test->sector_cnt * 512; j++)  {  // verify
+            if (test->buffer[j] != 0xDF){
+                printk(KERN_INFO "nand_test_write_all_ascending, Ttest->buffer[j] = %d, i = %d\n", test->buffer[j],  i);
+                return RESULT_FAIL;
+            }
+        }
+
+    }
+    return RESULT_OK;
+}
+
+
+/* read all sectors from sector num 0 to DiskSize - 1(max sector num )*/
+static int nand_test_read_all_ascending(struct nand_test_card *test)
+{
+    int ret;
+    int i = 0;
+    int j = 0;
+
+    /*  before reading, write */
+    for (i = 0; i < DiskSize; i++) {
+
+        ret = nand_test_simple_transfer(test, 0, i, test->sector_cnt,1);  // write all sectors
+        if(ret){
+            printk(KERN_INFO "nand_test_read_all_ascending fail, sector num %d\n", i);
+            return ret;
+        }
+    }
+
+   /* finish write,  start to read and check */
+    for (i = 0; i < DiskSize; i++)
+    {
+        if (i%100000 == 0){
+            printk(KERN_INFO "[nand test]: sector num:%d\n", i);
+        }
+
+        memset(test->buffer, 0, test->sector_cnt * 512);  // clear buffer
+
+        ret = nand_test_simple_transfer(test, 0 , i, test->sector_cnt, 0);   // read
+        if(ret){
+            return ret;
+        }
+        for(j  = 0 ; j < test->sector_cnt * 512  ; j++){
+            if (test->buffer[j] != (j)%256){
+                printk(KERN_INFO "nand_test_read_all_ascending fial! Ttest->buffer[j] = %d, i = %d\n", test->buffer[i],  j);
+                return RESULT_FAIL;
+            }
+
+       }
+    }
+    return RESULT_OK;
+}
+
+
+/* write all sectors from sector num  DiskSize - 1(max sector num ) to  0  */
+static int nand_test_write_all_descending(struct nand_test_card *test)
+{
+    int ret;
+    int i = 0;
+    int j = 0;
+
+    printk(KERN_INFO "nand_test: DiskSize = %x\n", DiskSize);
+
+    for (i = DiskSize - 1; i >= 0; i--){
+
+        memset(test->buffer, i%256, 512);
+
+        if (i%100000 == 0){
+            printk(KERN_INFO "[nand test]: sector num:%d\n", i);
+        }
+
+        ret = nand_test_simple_transfer(test, 0, i, test->sector_cnt,1);  // write all sectors
+        if(ret){
+            printk(KERN_INFO "[nand_test]: nand_test_write_all_ascending fail, sector num %d\n", i);
+            return ret;
+        }
+   }
+
+   printk(KERN_INFO "[nand test]: check start\n");
+
+   for (i = DiskSize - 1; i >= 0; i--){
+
+       if (i%100000 == 0){
+           printk(KERN_INFO "[nand test]: sector num:%d\n", i);
+       }
+
+       memset(test->buffer, 0, test->sector_cnt * 512);  // clear buffer
+
+       ret = nand_test_simple_transfer(test, 0 , i, test->sector_cnt, 0);   // read
+       if(ret){
+           return ret;
+       }
+       for(j  = 0; j < 512; j++){  // verify
+            if (test->buffer[j] != i%256){
+                printk(KERN_INFO "[nand_test]: nand_test_write_all_ascending, Ttest->buffer[j] = %d, i = %d\n", test->buffer[j],  i);
+                return RESULT_FAIL;
+            }
+        }
+    }
+    return RESULT_OK;
+}
+
+/* read all sectors from sector num  DiskSize - 1(max sector num ) to  0  */
+static int nand_test_read_all_descending(struct nand_test_card *test)
+{
+    int ret;
+    int i = 0;
+    int j = 0;
+
+    for (i = DiskSize - 1; i >= 0; i--){
+        memset(test->buffer, i%256, 512);
+
+        ret = nand_test_simple_transfer(test, 0, i, test->sector_cnt,1);  // write all sectors
+        if(ret){
+            printk(KERN_INFO "[nand_test]: nand_test_read_all_ascending fail, sector num %d\n", i);
+            return ret;
+        }
+    }
+
+    printk(KERN_INFO "[nand test]: check start\n");
+    for (i = DiskSize - 1; i >= 0; i--){
+        if (i%100000 == 0){
+            printk(KERN_INFO "[nand test]: sector num:%d\n", i);
+        }
+        memset(test->buffer, 0, test->sector_cnt * 512);  // clear buffer
+        ret = nand_test_simple_transfer(test, 0 , i, test->sector_cnt, 0);   // read
+        if(ret){
+            return ret;
+        }
+        for(j = 0 ; j < test->sector_cnt * 512  ; j++){      // verify data
+            if (test->buffer[j] != (i)%256){
+                printk(KERN_INFO "[nand_test]:nand_test_read_all_ascending fial! Ttest->buffer[j] = %d, i = %d\n", test->buffer[j],  i);
+                return RESULT_FAIL;
+            }
+        }
+    }
+    return RESULT_OK;
+}
+
+/* write a sector for  n times  without verification to test stability */
+static int nand_test_repeat_single_write(struct nand_test_card *test)
+{
+    int ret;
+    int i = 0;
+
+    printk(NAND_TEST "DiskSize = %d\n", DiskSize);
+
+    for(i = 0; i < REPEAT_TIMES*1000; i++){
+       ret = nand_test_simple_transfer(test, 0 , DiskSize/7, test->sector_cnt, 1);
+       if(ret){
+           return ret;
+       }
+    }
+    return 0;
+}
+
+
+/* read a sector for  n times with verification to test stability*/
+static int nand_test_repeat_single_read(struct nand_test_card *test)
+{
+    int ret;
+    int i = 0;
+    for(i = 0; i < REPEAT_TIMES*30; i++){
+        ret = nand_test_simple_transfer(test, 0 , DiskSize/4 + 7, test->sector_cnt, 0);
+        if(ret){
+            return ret;
+        }
+   }
+   return 0;
+}
+
+/* write multi sectors for  n times without verification to test stability*/
+static int nand_test_repeat_multi_write(struct nand_test_card *test)
+{
+    int ret;
+    int i = 0;
+
+    for(i = 0; i < 1100000; i++){
+        ret = nand_test_simple_transfer(test, 0 , DiskSize/2, test->sector_cnt, 1);
+        if(ret) {
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
+
+/* read multi sectors for  n times without verification to test stability*/
+static int nand_test_repeat_multi_read(struct nand_test_card *test)
+{
+    int ret;
+    int i = 0;
+    for(i = 0; i < 9200000; i++){
+        ret = nand_test_simple_transfer(test, 0 , DiskSize/3, test->sector_cnt, 0);
+        if(ret){
+            return ret;
+       }
+    }
+    return 0;
+}
+
+/* random write one or more sectors*/
+static int nand_test_random_write(struct nand_test_card *test)
+{
+    int ret;
+
+    ret = nand_test_simple_transfer(test, 0 , 0, test->sector_cnt, 1);
+    if(ret){
+        return ret;
+    }
+
+    ret = nand_test_simple_transfer(test, 0 , DiskSize -1, test->sector_cnt, 1);
+    if(ret) {
+        return ret;
+    }
+
+    ret = nand_test_simple_transfer(test, 0 , DiskSize/2, test->sector_cnt, 1);
+    if(ret){
+        return ret;
+    }
+    return 0;
+}
+
+/* random read one or more sectors*/
+static int nand_test_random_read(struct nand_test_card *test)
+{
+    int ret;
+
+    ret = nand_test_simple_transfer(test, 0 , 0, test->sector_cnt, 0);
+    if(ret) {
+        return ret;
+    }
+
+    ret = nand_test_simple_transfer(test, 0 , DiskSize -1, test->sector_cnt, 0);
+    if(ret){
+        return ret;
+    }
+
+    ret = nand_test_simple_transfer(test, 0 , DiskSize/2, test->sector_cnt, 0);
+    if(ret){
+        return ret;
+    }
+
+    return 0;
+}
+
+
+/* clear r/w buffer to 0*/
+static int nand_test_cleanup(struct nand_test_card *test)
+{
+    memset(test->buffer, 0, 512* (test->sector_cnt));
+    return 0;
+}
+
+
+/* test cases */
+
+static const struct nand_test_case nand_test_cases[] = {
+    {
+	    .name = "single sector write (no data verification)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_single_write,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "single sector read (no data verification)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_single_read,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "single sector write(verify data)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_verify_write,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "single sector read(verify data)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_verify_read,
+	    .cleanup = nand_test_cleanup
+    },
+
+    /* multi read/write*/
+    {
+	    .name = "multi sector read(2 sectors, verify)",
+	    .sectors_cnt = 2,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_multi_read,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "multi sector read(3 sectors, verify)",
+	    .sectors_cnt = 3,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_multi_read,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "multi sector read(8 sectors, verify)",
+	    .sectors_cnt = 8,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_multi_read,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "multi sector read(18 sectors, verify)",
+	    .sectors_cnt = 18,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_multi_read,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "multi sector read(53 sectors, verify)",
+	    .sectors_cnt = 53,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_multi_read,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "multi sector write(2 sectors ,verify)",
+	    .sectors_cnt = 2,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_multi_write,
+	    .cleanup = nand_test_cleanup
+    },
+
+    {
+	    .name = "multi sector write(5 sectors ,verify)",
+	    .sectors_cnt = 5,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_multi_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "multi sector write(12 sectors ,verify)",
+	    .sectors_cnt = 12,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_multi_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "multi sector write(15 sectors ,verify)",
+	    .sectors_cnt = 15,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_multi_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "multi sector write(26 sectors ,verify)",
+	    .sectors_cnt = 26,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_multi_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "multi sector write(93 sectors ,verify)",
+	    .sectors_cnt = 93,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_multi_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    /*align test*/
+    {
+	    .name = "align write(1 sector ,verify)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_align_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "align read(1 sector ,verify)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_align_read,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    /* stability test */
+    {
+	    .name = "weird write(negative start)",   // 18
+	    .sectors_cnt = 10,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_negstart_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "weid read(nagative satrt)",
+	    .sectors_cnt = 10,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_negstart_read,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "weird write(beyond start)",   // 20
+	    .sectors_cnt = 10,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_beyond_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "weid read(bayond start)",
+	    .sectors_cnt = 10,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_beyond_read,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {                                            // 22
+	    .name = "write all ascending",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_write_all_ascending,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "read all ascending",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_read_all_ascending,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {
+	    .name = "write all descending",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_write_all_descending,
+	     .cleanup = nand_test_cleanup,
+    },
+
+
+    {
+	    .name = "read all descending",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_read_all_descending,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {                                                     // 26
+	    .name = " repeat  write (no data verification) ",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_repeat_single_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {                                                    // 27
+	    .name = " repeat  read (no data verification) ",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_repeat_single_read,
+	    .cleanup = nand_test_cleanup,
+   },
+
+   {                                                     // 28
+	    .name = " repeat multi write (no data verification)",
+	    .sectors_cnt = 43,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_repeat_multi_write,
+	    .cleanup = nand_test_cleanup,
+   },
+
+   {                                                    // 29
+	    .name = " repeat multi read (no data verification)",
+	    .sectors_cnt = 81,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_repeat_multi_read,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {                                                    // 30
+	    .name = " random  write (no data verification)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_write,
+	    .run = nand_test_random_write,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {                                                    // 31
+	    .name = " random  read (no data verification)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_read,
+	    .run = nand_test_random_read,
+	    .cleanup = nand_test_cleanup,
+    },
+
+    {                                                    // 32
+	    .name = " pwm  test (no data verification)",
+	    .sectors_cnt = 1,
+	    .prepare = nand_test_prepare_pwm,
+	    //.run = nand_test_pwm,
+	    .cleanup = nand_test_cleanup,
+    },
+};
+
+static DEFINE_MUTEX(nand_test_lock);
+
+
+/* run test cases*/
+static void nand_test_run(struct nand_test_card *test, int testcase)
+{
+    int i, ret;
+
+    printk(KERN_INFO "[nand_test]: Starting tests of nand\n");
+
+    for (i = 0;i < ARRAY_SIZE(nand_test_cases);i++) {
+        if (testcase && ((i + 1) != testcase)){
+            continue;
+        }
+
+        printk(KERN_INFO "[nand_test]: Test case %d. %s...\n", i + 1, nand_test_cases[i].name);
+
+        if (nand_test_cases[i].prepare) {
+              ret = nand_test_cases[i].prepare(test, nand_test_cases[i].sectors_cnt);
+          if (ret) {
+              printk(KERN_INFO "[nand_test]: Result: Prepare stage failed! (%d)\n", ret);
+              continue;
+          }
+        }
+
+        ret = nand_test_cases[i].run(test);
+
+        switch (ret) {
+            case RESULT_OK:
+                printk(KERN_INFO "[nand_test]: Result: OK\n");
+                break;
+            case RESULT_FAIL:
+                printk(KERN_INFO "[nand_test]:Result: FAILED\n");
+                break;
+                //    case RESULT_UNSUP_HOST:                //grace del
+                //      printk(KERN_INFO "%s: Result: UNSUPPORTED "
+                //        "(by host)\n",
+                //        mmc_hostname(test->card->host));
+                //      break;
+                //    case RESULT_UNSUP_CARD:
+                //      printk(KERN_INFO "%s: Result: UNSUPPORTED "
+                //        "(by card)\n",
+                //        mmc_hostname(test->card->host));
+                //      break;
+            default:
+                printk(KERN_INFO "[nand_test]:Result: ERROR (%d)\n", ret);
+        }
+
+        if (nand_test_cases[i].cleanup) {
+            ret = nand_test_cases[i].cleanup(test);
+            if (ret) {
+                printk(KERN_INFO "[nand_test]:Warning: Cleanup"
+                       "stage failed! (%d)\n", ret);
+            }
+        }
+    }
+
+    //mmc_release_host(test->card->host);
+
+    printk(KERN_INFO "[nand_test]: Nand tests completed.\n");
+}
+
+
+/* do nothing */
+static ssize_t nand_test_show(struct kobject *kobject,struct attribute *attr, char *buf)
+{
+    return 0;
+}
+
+
+/* receive testcase num from echo command */
+static ssize_t nand_test_store(struct kobject *kobject,struct attribute *attr, const char *buf, size_t count)
+{
+
+    struct nand_test_card *test;
+    int testcase;
+
+    testcase = simple_strtol(buf, NULL, 10);  // get test case number     >> grace
+
+    test = kzalloc(sizeof(struct nand_test_card), GFP_KERNEL);
+    if (!test){
+        return -ENOMEM;
+    }
+
+    test->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);  // alloc buffer for r/w
+    test->scratch = kzalloc(BUFFER_SIZE, GFP_KERNEL); // not used now
+
+    if (test->buffer && test->scratch) {
+        mutex_lock(&nand_test_lock);
+        nand_test_run(test, testcase);             // run test cases
+        mutex_unlock(&nand_test_lock);
+    }
+
+
+    kfree(test->buffer);
+    kfree(test->scratch);
+    kfree(test);
+
+    return count;
+}
+
+struct kobject kobj;
+
+
+/* if nand driver is not inited ,  functions below will be used  */
+#ifdef INIT_NAND_IN_TESTDRIVER
+
+static void set_nand_pio(void)
+{
+    __u32 cfg0;
+    __u32 cfg1;
+    __u32 cfg2;
+    void* gpio_base;
+
+    //modify for f20
+    gpio_base = (void *)SW_VA_PORTC_IO_BASE;
+
+    cfg0 = *(volatile __u32 *)(gpio_base + 0x48);
+    cfg1 = *(volatile __u32 *)(gpio_base + 0x4c);
+    cfg2 = *(volatile __u32 *)(gpio_base + 0x50);
+
+    /*set PIOC for nand*/
+    cfg0 &= 0x0;
+    cfg0 |= 0x22222222;
+    cfg1 &= 0x0;
+    cfg1 |= 0x22222222;
+    cfg2 &= 0x0;
+    cfg2 |= 0x22222222;
+
+    *(volatile __u32 *)(gpio_base + 0x48) = cfg0;
+    *(volatile __u32 *)(gpio_base + 0x4c) = cfg1;
+    *(volatile __u32 *)(gpio_base + 0x50) = cfg2;
+
+    //iounmap(gpio_base);
+}
+
+static __u32 get_cmu_clk(void)
+{
+	__u32 reg_val;
+	__u32 div_p, factor_n;
+	__u32 factor_k, factor_m;
+	__u32 clock;
+
+	reg_val  = *(volatile unsigned int *)(0xf1c20000 + 0x20);
+	div_p    = (reg_val >> 16) & 0x3;
+	factor_n = (reg_val >> 8) & 0x1f;
+	factor_k = ((reg_val >> 4) & 0x3) + 1;
+	factor_m = ((reg_val >> 0) & 0x3) + 1;
+
+	clock = 24 * factor_n * factor_k/div_p/factor_m;
+	printk("cmu_clk is %d \n", clock);
+
+	return clock;
+}
+
+static void set_nand_clock(__u32 nand_max_clock)
+{
+	__u32 edo_clk, cmu_clk;
+	__u32 cfg;
+	__u32 nand_clk_divid_ratio;
+
+	/*open ahb nand clk */
+	cfg = *(volatile __u32 *)(0xf1c20000 + 0x60);
+	cfg |= (0x1<<13);
+	*(volatile __u32 *)(0xf1c20000 + 0x60) = cfg;
+
+	/*set nand clock*/
+	//edo_clk = (nand_max_clock > 20)?(nand_max_clock-10):nand_max_clock;
+	edo_clk = nand_max_clock * 2;
+
+    cmu_clk = get_cmu_clk( );
+	nand_clk_divid_ratio = cmu_clk / edo_clk;
+	if (cmu_clk % edo_clk)
+			nand_clk_divid_ratio++;
+	if (nand_clk_divid_ratio){
+		if (nand_clk_divid_ratio > 16)
+			nand_clk_divid_ratio = 15;
+		else
+			nand_clk_divid_ratio--;
+	}
+	/*set nand clock gate on*/
+	cfg = *(volatile __u32 *)(0xf1c20000 + 0x80);
+
+	/*gate on nand clock*/
+	cfg |= (1U << 31);
+	/*take cmu pll as nand src block*/
+	cfg &= ~(0x3 << 24);
+	cfg |=  (0x2 << 24);
+	//set divn = 0
+	cfg &= ~(0x03 << 12);
+
+	/*set ratio*/
+	cfg &= ~(0x0f << 0);
+	cfg |= (nand_clk_divid_ratio & 0xf) << 0;
+
+	*(volatile __u32 *)(0xf1c20000 + 0x80) = cfg;
+
+	printk("nand clk init end \n");
+	printk("offset 0xc:  0x%x \n", *(volatile __u32 *)(0xf1c20000 + 0x60));
+	printk("offset 0x14:  0x%x \n", *(volatile __u32 *)(0xf1c20000 + 0x80));
+}
+
+#endif
+
+static int __init nand_test_init(void)
+{
+
+   int ret;
+#ifdef INIT_NAND_IN_TESTDRIVER
+    __u32 cmu_clk;
+#endif
+
+    printk("[nand_test]:nand_test_init test init.\n");
+    if((ret = kobject_init_and_add(&kobj,&ktype,NULL,"nand")) != 0 ) {
+        return ret;
+    }
+
+
+#ifdef INIT_NAND_IN_TESTDRIVER
+
+    /* init nand resource */
+    printk("[nand_test]:init nand resource \n");
+    //set nand clk
+    set_nand_clock(20);
+
+   //set nand pio
+    set_nand_pio();
+
+    clear_NAND_ZI();
+
+    printk("/*********************************************************/ \n");
+    printk("[nand_test]: init nand block layer start \n");
+    printk("/*********************************************************/ \n");
+
+    ret = PHY_Init();
+    if (ret) {
+     PHY_Exit();
+     return -1;
+    }
+
+    ret = SCN_AnalyzeNandSystem();
+    if (ret < 0){
+        return ret;
+    }
+
+    ret = PHY_ChangeMode(1);
+    if (ret < 0){
+        return ret;
+    }
+    ret = FMT_Init();
+    if (ret < 0){
+        return ret;
+    }
+    ret = FMT_FormatNand();
+    if (ret < 0){
+        return ret;
+    }
+    FMT_Exit();
+
+    /*init logic layer*/
+    ret = LML_Init();
+    if (ret < 0){
+        return ret;
+    }
+#ifdef NAND_CACHE_RW
+    NAND_CacheOpen();
+#endif
+
+#endif
+
+   return 0;  // init success
+
+}
+
+
+
+static void __exit nand_test_exit(void)
+{
+    printk("[nand_test]:nand test exit.\n");
+    kobject_del(&kobj);
+
+#ifdef INIT_NAND_IN_TESTDRIVER
+    LML_FlushPageCache();
+    BMM_WriteBackAllMapTbl();
+    LML_Exit();
+    FMT_Exit();
+    PHY_Exit();
+#ifdef NAND_CACHE_RW
+    NAND_CacheOpen();
+#endif
+
+#endif
+
+    return;
+}
+
+
+module_init(nand_test_init);
+module_exit(nand_test_exit);
+
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nand test driver");
+MODULE_AUTHOR("Grace Miao");
+#endif
diff --git a/drivers/block/sunxi_nand/nandtest/nand_test.h b/drivers/block/sunxi_nand/nandtest/nand_test.h
new file mode 100644
index 0000000..ede66b7
--- /dev/null
+++ b/drivers/block/sunxi_nand/nandtest/nand_test.h
@@ -0,0 +1,35 @@
+/*
+ * drivers/block/sunxi_nand/nandtest/nand_test.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef  __NAND_TEST_H__
+#define  __NAND_TEST_H__
+
+
+
+#define  INIT_NAND_IN_TESTDRIVER
+//#define   NAND_CACHE_RW
+
+#define REPEAT_TIMES    500000
+
+
+
+#endif
diff --git a/drivers/block/sunxi_nand/nfc/nfc.h b/drivers/block/sunxi_nand/nfc/nfc.h
new file mode 100644
index 0000000..ca33836
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfc/nfc.h
@@ -0,0 +1,235 @@
+/*
+ * drivers/block/sunxi_nand/nfc/nfc.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _NFC_H_
+#define _NFC_H_
+
+#include <mach/platform.h>
+
+#define NAND_IO_BASE		SW_VA_NANDFLASHC_IO_BASE
+#define __NFC_REG(x)    (*(volatile unsigned int   *)(NAND_IO_BASE + x))
+/*
+*********************************************************************************************************
+*   Nand Flash Controller define          < maintained by Richard >
+*********************************************************************************************************
+*/
+  /* offset */
+#define NFC_REG_o_CTL              0x0000
+#define NFC_REG_o_ST               0x0004
+#define NFC_REG_o_INT              0x0008
+#define NFC_REG_o_TIMING_CTL       0x000C
+#define NFC_REG_o_TIMING_CFG       0x0010
+#define NFC_REG_o_ADDR_LOW         0x0014
+#define NFC_REG_o_ADDR_HIGH        0x0018
+#define NFC_REG_o_SECTOR_NUM       0x001C
+#define NFC_REG_o_CNT              0x0020
+#define NFC_REG_o_CMD              0x0024
+#define NFC_REG_o_RCMD_SET         0x0028
+#define NFC_REG_o_WCMD_SET         0x002C
+#define NFC_REG_o_IO_DATA          0x0030
+#define NFC_REG_o_ECC_CTL          0x0034
+#define NFC_REG_o_ECC_ST           0x0038
+#define NFC_REG_o_DEBUG            0x003C
+#define NFC_REG_o_ECC_CNT0         0x0040
+#define NFC_REG_o_ECC_CNT1         0x0044
+#define NFC_REG_o_ECC_CNT2         0x0048
+#define NFC_REG_o_ECC_CNT3         0x004c
+#define NFC_REG_o_USER_DATA_BASE   0x0050
+#define NFC_REG_o_SPARE_AREA       0x00A0
+#define NFC_o_RAM0_BASE            0x0400
+#define NFC_o_RAM1_BASE            0x0800
+  /* registers */
+#define NFC_REG_CTL                __NFC_REG( NFC_REG_o_CTL             )
+#define NFC_REG_ST                 __NFC_REG( NFC_REG_o_ST              )
+#define NFC_REG_INT                __NFC_REG( NFC_REG_o_INT             )
+#define NFC_REG_TIMING_CTL         __NFC_REG( NFC_REG_o_TIMING_CTL      )
+#define NFC_REG_TIMING_CFG         __NFC_REG( NFC_REG_o_TIMING_CFG      )
+#define NFC_REG_ADDR_LOW           __NFC_REG( NFC_REG_o_ADDR_LOW        )
+#define NFC_REG_ADDR_HIGH          __NFC_REG( NFC_REG_o_ADDR_HIGH       )
+#define NFC_REG_SECTOR_NUM         __NFC_REG( NFC_REG_o_SECTOR_NUM      )
+#define NFC_REG_CNT                __NFC_REG( NFC_REG_o_CNT             )
+#define NFC_REG_CMD                __NFC_REG( NFC_REG_o_CMD             )
+#define NFC_REG_RCMD_SET           __NFC_REG( NFC_REG_o_RCMD_SET        )
+#define NFC_REG_WCMD_SET           __NFC_REG( NFC_REG_o_WCMD_SET        )
+#define NFC_REG_IO_DATA            __NFC_REG( NFC_REG_o_IO_DATA         )
+#define NFC_REG_ECC_CTL            __NFC_REG( NFC_REG_o_ECC_CTL         )
+#define NFC_REG_ECC_ST             __NFC_REG( NFC_REG_o_ECC_ST          )
+#define NFC_REG_ECC_CNT0           __NFC_REG( NFC_REG_o_ECC_CNT0          )
+#define NFC_REG_ECC_CNT1           __NFC_REG( NFC_REG_o_ECC_CNT1          )
+#define NFC_REG_ECC_CNT2           __NFC_REG( NFC_REG_o_ECC_CNT2          )
+#define NFC_REG_ECC_CNT3           __NFC_REG( NFC_REG_o_ECC_CNT3          )
+#define NFC_REG_DEBUG              __NFC_REG( NFC_REG_o_DEBUG           )
+#define NFC_REG_USER_DATA(sct_num) __NFC_REG( NFC_REG_o_USER_DATA_BASE + 4 * sct_num )
+#define NFC_REG_SPARE_AREA         __NFC_REG( NFC_REG_o_SPARE_AREA        )
+#define NFC_RAM0_BASE                   ( NFC_o_RAM0_BASE           )
+#define NFC_RAM1_BASE                   ( NFC_o_RAM1_BASE           )
+
+/*define bit use in NFC_CTL*/
+#define NFC_EN					(1 << 0)
+#define NFC_RESET				(1 << 1)
+#define NFC_BUS_WIDYH			(1 << 2)
+#define NFC_RB_SEL				(1 << 3)
+#define NFC_CE_SEL				(7 << 24)
+#define NFC_CE_CTL				(1 << 6)
+#define NFC_CE_CTL1				(1 << 7)
+#define NFC_PAGE_SIZE			(0xf << 8)
+#define NFC_SAM					(1 << 12)
+#define NFC_RAM_METHOD			(1 << 14)
+#define NFC_DEBUG_CTL			(1 << 31)
+
+/*define	bit use in NFC_ST*/
+#define NFC_RB_B2R				(1 << 0)
+#define NFC_CMD_INT_FLAG		(1 << 1)
+#define NFC_DMA_INT_FLAG		(1 << 2)
+#define NFC_CMD_FIFO_STATUS		(1 << 3)
+#define NFC_STA					(1 << 4)
+#define NFC_NATCH_INT_FLAG		(1 << 5)
+#define NFC_RB_STATE0			(1 << 8)
+#define NFC_RB_STATE1			(1 << 9)
+#define NFC_RB_STATE2			(1 << 10)
+#define NFC_RB_STATE3			(1 << 11)
+
+/*define bit use in NFC_INT*/
+#define NFC_B2R_INT_ENABLE		(1 << 0)
+#define NFC_CMD_INT_ENABLE		(1 << 1)
+#define NFC_DMA_INT_ENABLE		(1 << 2)
+
+
+/*define bit use in NFC_CMD*/
+#define NFC_CMD_LOW_BYTE		(0xff << 0)
+#define NFC_CMD_HIGH_BYTE		(0xff << 8)
+#define NFC_ADR_NUM				(0x7 << 16)
+#define NFC_SEND_ADR			(1 << 19)
+#define NFC_ACCESS_DIR			(1 << 20)
+#define NFC_DATA_TRANS			(1 << 21)
+#define NFC_SEND_CMD1			(1 << 22)
+#define NFC_WAIT_FLAG			(1 << 23)
+#define NFC_SEND_CMD2			(1 << 24)
+#define NFC_SEQ					(1 << 25)
+#define NFC_DATA_SWAP_METHOD	(1 << 26)
+#define NFC_ROW_AUTO_INC		(1 << 27)
+#define NFC_SEND_CMD3           (1 << 28)
+#define NFC_SEND_CMD4           (1 << 29)
+#define NFC_CMD_TYPE			(3 << 30)
+
+/* define bit use in NFC_RCMD_SET*/
+#define NFC_READ_CMD			(0xff<< 0)
+#define NFC_RANDOM_READ_CMD0 	(0xff << 8)
+#define NFC_RANDOM_READ_CMD1 	(0xff << 16)
+
+/*define bit use in NFC_WCMD_SET*/
+#define NFC_PROGRAM_CMD			(0xff << 0)
+#define NFC_RANDOM_WRITE_CMD	(0xff << 8)
+#define NFC_READ_CMD0			(0xff << 16)
+#define NFC_READ_CMD1	        (0xff << 24)
+
+/*define bit use in NFC_ECC_CTL*/
+#define NFC_ECC_EN				(1 << 0)
+#define NFC_ECC_PIPELINE		(1 << 3)
+#define NFC_ECC_EXCEPTION       (1 << 4)
+#define NFC_ECC_BLOCK_SIZE		(1 << 5)
+#define NFC_RANDOM_EN           (1 << 9 )
+#define NFC_RANDOM_DIRECTION    (1 << 10 )
+#define NFC_ECC_MODE			(0xf << 12)
+#define NFC_RANDOM_SEED         (0x7fff << 16))
+
+#define NFC_IRQ_MAJOR		    13
+/*cmd flag bit*/
+#define NFC_PAGE_MODE  			0x1
+#define NFC_NORMAL_MODE  		0x0
+
+#define NFC_DATA_FETCH 			0x1
+#define NFC_NO_DATA_FETCH 		0x0
+#define NFC_MAIN_DATA_FETCH 	0x1
+#define NFC_SPARE_DATA_FETCH	0X0
+#define NFC_WAIT_RB				0x1
+#define NFC_NO_WAIT_RB			0x0
+#define NFC_IGNORE				0x0
+
+#define NFC_INT_RB				0
+#define NFC_INT_CMD				1
+#define NFC_INT_DMA				2
+#define NFC_INT_BATCh			5
+
+typedef struct cmd_list{
+	struct	cmd_list *next;
+	__u8	*addr;
+	__u8	addr_cycle;
+	__u8	data_fetch_flag;
+	__u8	main_data_fetch;
+	__u8	wait_rb_flag;
+	__u32 	bytecnt;
+	__u32	value;
+}NFC_CMD_LIST;
+
+typedef struct NFC_init_info{
+	__u8	bus_width;// bus width 8 bit
+	__u8	rb_sel; // ready busy
+	__u8	ce_ctl; // chip select
+	__u8	ce_ctl1;
+	__u8	pagesize; // 1024 ,2048 ,
+	__u8	serial_access_mode; // SAM0 SAM1
+	__u8    ddr_type;
+	__u8	debug;
+}NFC_INIT_INFO;
+
+__s32 NFC_ReadRetryInit(__u32 read_retry_type);
+__s32 NFC_ReadRetryExit(__u32 read_retry_type);
+__s32 NFC_GetDefaultParam(__u32 chip, __u8 *defautl_value, __u32 read_retry_type);
+__s32 NFC_SetDefaultParam(__u32 chip, __u8 *defautl_value, __u32 read_retry_type);
+__s32 NFC_ReadRetry(__u32 chip, __u32 retry_count, __u32 read_retry_type);
+__s32 NFC_LSBEnable(__u32 chip, __u32 read_retry_type);
+__s32 NFC_LSBDisable(__u32 chip, __u32 read_retry_type);
+__s32 NFC_LSBInit(__u32 read_retry_type);
+__s32 NFC_LSBExit(__u32 read_retry_type);
+__s32 NFC_SetRandomSeed(__u32 random_seed);
+__s32 NFC_RandomEnable(void);
+__s32 NFC_RandomDisable(void);
+__s32 NFC_Init(NFC_INIT_INFO * nand_info);
+void NFC_Exit(void);
+__s32 NFC_Read(NFC_CMD_LIST * rcmd, void * mainbuf, void * sparebuf, __u8 dma_wait_mode, __u8 page_mode);
+__s32 NFC_Read_1K(NFC_CMD_LIST * rcmd, void * mainbuf, void * sparebuf, __u8 dma_wait_mode, __u8 page_mode);
+__s32 NFC_Read_Seq(NFC_CMD_LIST * rcmd, void * mainbuf, void * sparebuf, __u8 dma_wait_mode, __u8 page_mode);
+__s32 NFC_Read_Spare(NFC_CMD_LIST * rcmd, void * mainbuf, void * sparebuf, __u8 dma_wait_mode, __u8 page_mode);
+__s32 NFC_Write(NFC_CMD_LIST * wcmd, void * mainbuf, void * sparebuf, __u8 dma_wait_mode, __u8 rb_wait_mode, __u8 page_mode);
+__s32 NFC_Write_Seq(NFC_CMD_LIST * wcmd, void * mainbuf, void * sparebuf, __u8 dma_wait_mode, __u8 rb_wait_mode, __u8 page_mode);
+__s32 NFC_Write_1K(NFC_CMD_LIST * wcmd, void * mainbuf, void * sparebuf, __u8 dma_wait_mode, __u8 rb_wait_mode, __u8 page_mode);
+__s32 NFC_Erase(NFC_CMD_LIST * ecmd, __u8 rb_wait_mode);
+__s32 NFC_CopyBackRead(NFC_CMD_LIST * crcmd);
+__s32 NFC_CopyBackWrite(NFC_CMD_LIST * cwcmd, __u8 rb_wait_mode);
+__s32 NFC_GetId(NFC_CMD_LIST * idcmd, __u8 * idbuf);
+__s32 NFC_GetUniqueId(NFC_CMD_LIST * idcmd, __u8 * idbuf);
+__s32 NFC_SelectChip(__u32 chip);
+__s32 NFC_DeSelectChip(__u32 chip);
+__s32 NFC_SelectRb(__u32 rb);
+__s32 NFC_DeSelectRb(__u32 rb);
+__s32 NFC_GetStatus(NFC_CMD_LIST * scmd);
+__s32 NFC_CheckRbReady(__u32 rb);
+__s32 NFC_ChangMode(NFC_INIT_INFO * nand_info);
+__s32 NFC_SetEccMode(__u8 ecc_mode);
+__s32 NFC_ResetChip(NFC_CMD_LIST * reset_cmd);
+__u32 NFC_QueryINT(void);
+void NFC_EnableInt(__u8 minor_int);
+void NFC_DisableInt(__u8 minor_int);
+void NFC_InitDDRParam(__u32 chip, __u32 param);
+
+#endif    // #ifndef _NFC_H_
diff --git a/drivers/block/sunxi_nand/nfc/nfc_i.h b/drivers/block/sunxi_nand/nfc/nfc_i.h
new file mode 100644
index 0000000..6e401f8
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfc/nfc_i.h
@@ -0,0 +1,70 @@
+/*
+ * drivers/block/sunxi_nand/nfc/nfc_i.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef	_NFC_I_H_
+#define	_NFC_I_H_
+
+#include "../include/type_def.h"
+#include "nfc.h"
+//#include "../nfd/dma_for_nand.h"
+//#include "ebios_i.h"
+//#define MAX_ECC_BIT_CNT	8
+
+#define NFC_READ_REG(reg)   		(reg)
+#define NFC_WRITE_REG(reg,data) 	(reg) = (data)
+
+
+#define ERR_ECC 	12
+#define ECC_LIMIT 	10
+#define ERR_TIMEOUT 14
+#define READ_RETRY_MAX_TYPE_NUM 5
+#define READ_RETRY_MAX_REG_NUM	4
+#define READ_RETRY_MAX_CYCLE	10
+#define LSB_MODE_MAX_REG_NUM	8
+/* define various unit data input or output*/
+#define NFC_READ_RAM_B(ram)    		(*((volatile __u8 *)(NAND_IO_BASE + ram)))
+#define NFC_WRITE_RAM_B(ram,data)  	(*((volatile __u8 *)(NAND_IO_BASE + ram)) = (data))
+#define NFC_READ_RAM_HW(ram)   		(*((volatile __u16 *)(NAND_IO_BASE + ram)))
+#define NFC_WRITE_RAM_HW(ram,data) 	(*((volatile __u16 *)(NAND_IO_BASE + ram)) = (data))
+#define NFC_READ_RAM_W(ram)   		(*((volatile __u32 *)(NAND_IO_BASE + ram)))
+#define NFC_WRITE_RAM_W(ram,data) 	(*((volatile __u32 *)(NAND_IO_BASE + ram)) = (data))
+
+
+
+#ifdef USE_PHYSICAL_ADDRESS
+#define NFC_IS_SDRAM(addr)			((addr >= DRAM_BASE)?1:0)
+#else
+#define NFC_IS_SDRAM(addr)			( ((addr >= DRAM_BASE))&&(addr < SRAM_BASE)?1:0)
+#endif
+
+extern __hdle NAND_RequestDMA(__u32 dmatype);
+extern __s32 NAND_ReleaseDMA(__hdle hDma);
+extern void NAND_Config_Start_DMA(__u8 rw, dma_addr_t buff_addr, __u32 len);
+extern __s32 NAND_WaitDmaFinish(void);
+extern void NAND_ClearRbInt(void);
+extern void NAND_EnRbInt(void);
+
+extern void NAND_RbInterrupt(void);
+extern __s32 NAND_WaitRbReady(void);
+
+
+#endif	/* _NFC_I_H_ */
diff --git a/drivers/block/sunxi_nand/nfc/nfc_r.c b/drivers/block/sunxi_nand/nfc/nfc_r.c
new file mode 100644
index 0000000..4975d24
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfc/nfc_r.c
@@ -0,0 +1,1363 @@
+/*
+ * drivers/block/sunxi_nand/nfc/nfc_r.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "nfc_i.h"
+#include <linux/dma-mapping.h>
+
+__u32	nand_board_version;
+__u32 	pagesize;
+__hdle 	dma_hdle;
+volatile __u32 irq_value;
+
+
+__u8 read_retry_reg_adr[READ_RETRY_MAX_REG_NUM];
+__u8 read_retry_default_val[8][READ_RETRY_MAX_REG_NUM];
+__s16 read_retry_val[READ_RETRY_MAX_CYCLE][READ_RETRY_MAX_REG_NUM];
+__u8 read_retry_mode;
+__u8 read_retry_cycle;
+__u8 read_retry_reg_num;
+
+__u8 lsb_mode_reg_adr[LSB_MODE_MAX_REG_NUM];
+__u8 lsb_mode_default_val[LSB_MODE_MAX_REG_NUM];
+__u8 lsb_mode_val[LSB_MODE_MAX_REG_NUM];
+__u8 lsb_mode_reg_num;
+
+__u32 ddr_param[8];
+
+void NFC_InitDDRParam(__u32 chip, __u32 param)
+{
+    if(chip<8)
+        ddr_param[chip] = param;
+}
+
+void nfc_repeat_mode_enable(void)
+{
+    __u32 reg_val;
+
+
+	reg_val = NFC_READ_REG(NFC_REG_CTL);
+	if(((reg_val>>18)&0x3)>1)   //ddr type
+	{
+    	reg_val |= 0x1<<20;
+    	NFC_WRITE_REG(NFC_REG_CTL, reg_val);
+    }
+
+}
+
+void nfc_repeat_mode_disable(void)
+{
+    __u32 reg_val;
+
+    reg_val = NFC_READ_REG(NFC_REG_CTL);
+	if(((reg_val>>18)&0x3)>1)   //ddr type
+	{
+    	reg_val &= (~(0x1<<20));
+    	NFC_WRITE_REG(NFC_REG_CTL, reg_val);
+    }
+}
+
+/*******************wait nfc********************************************/
+__s32 _wait_cmdfifo_free(void)
+{
+	__s32 timeout = 0xffff;
+
+	while ( (timeout--) && (NFC_READ_REG(NFC_REG_ST) & NFC_CMD_FIFO_STATUS) );
+	if (timeout <= 0)
+		return -ERR_TIMEOUT;
+	return 0;
+}
+
+__s32 _wait_cmd_finish(void)
+{
+	__s32 timeout = 0xffff;
+	while( (timeout--) && !(NFC_READ_REG(NFC_REG_ST) & NFC_CMD_INT_FLAG) );
+	if (timeout <= 0)
+		return -ERR_TIMEOUT;
+
+	NFC_WRITE_REG(NFC_REG_ST, NFC_READ_REG(NFC_REG_ST) & NFC_CMD_INT_FLAG);
+	return 0;
+}
+
+__s32 _reset(void)
+{
+	__u32 cfg;
+
+	__s32 timeout = 0xffff;
+
+	/*reset NFC*/
+	cfg = NFC_READ_REG(NFC_REG_CTL);
+	cfg |= NFC_RESET;
+	NFC_WRITE_REG(NFC_REG_CTL, cfg);
+	//waiting reset operation end
+	while((timeout--) && (NFC_READ_REG(NFC_REG_CTL) & NFC_RESET));
+	if (timeout <= 0)
+		return -ERR_TIMEOUT;
+
+	return 0;
+}
+
+/***************ecc function*****************************************/
+__s32 _check_ecc(__u32 eblock_cnt)
+{
+	__u32 i;
+	__u32 ecc_mode;
+	__u32 max_ecc_bit_cnt = 16;
+	__u32 cfg;
+	__u8 ecc_cnt[16];
+
+	ecc_mode = (NFC_READ_REG(NFC_REG_ECC_CTL)>>12)&0xf;
+	if(ecc_mode == 0)
+		max_ecc_bit_cnt = 16;
+	if(ecc_mode == 1)
+		max_ecc_bit_cnt = 24;
+	if(ecc_mode == 2)
+		max_ecc_bit_cnt = 28;
+	if(ecc_mode == 3)
+		max_ecc_bit_cnt = 32;
+	if(ecc_mode == 4)
+		max_ecc_bit_cnt = 40;
+	if(ecc_mode == 5)
+		max_ecc_bit_cnt = 48;
+	if(ecc_mode == 6)
+		max_ecc_bit_cnt = 56;
+    if(ecc_mode == 7)
+		max_ecc_bit_cnt = 60;
+    if(ecc_mode == 8)
+		max_ecc_bit_cnt = 64;
+
+	//check ecc errro
+	cfg = NFC_READ_REG(NFC_REG_ECC_ST)&0xffff;
+	for (i = 0; i < eblock_cnt; i++)
+	{
+		if (cfg & (1<<i))
+				return -ERR_ECC;
+	}
+
+	//check ecc limit
+	cfg = NFC_READ_REG(NFC_REG_ECC_CNT0);
+	ecc_cnt[0] = (__u8)((cfg>>0)&0xff);
+	ecc_cnt[1] = (__u8)((cfg>>8)&0xff);
+	ecc_cnt[2] = (__u8)((cfg>>16)&0xff);
+	ecc_cnt[3] = (__u8)((cfg>>24)&0xff);
+
+	cfg = NFC_READ_REG(NFC_REG_ECC_CNT1);
+	ecc_cnt[4] = (__u8)((cfg>>0)&0xff);
+	ecc_cnt[5] = (__u8)((cfg>>8)&0xff);
+	ecc_cnt[6] = (__u8)((cfg>>16)&0xff);
+	ecc_cnt[7] = (__u8)((cfg>>24)&0xff);
+
+	cfg = NFC_READ_REG(NFC_REG_ECC_CNT2);
+	ecc_cnt[8] = (__u8)((cfg>>0)&0xff);
+	ecc_cnt[9] = (__u8)((cfg>>8)&0xff);
+	ecc_cnt[10] = (__u8)((cfg>>16)&0xff);
+	ecc_cnt[11] = (__u8)((cfg>>24)&0xff);
+
+	cfg = NFC_READ_REG(NFC_REG_ECC_CNT3);
+	ecc_cnt[12] = (__u8)((cfg>>0)&0xff);
+	ecc_cnt[13] = (__u8)((cfg>>8)&0xff);
+	ecc_cnt[14] = (__u8)((cfg>>16)&0xff);
+	ecc_cnt[15] = (__u8)((cfg>>24)&0xff);
+
+	for (i = 0; i < eblock_cnt; i++)
+	{
+		if((max_ecc_bit_cnt - 4) <= ecc_cnt[i])
+			return ECC_LIMIT;
+	}
+
+	return 0;
+}
+
+void _disable_ecc(void)
+{
+	__u32 cfg = NFC_READ_REG(NFC_REG_ECC_CTL);
+	cfg &= ( (~NFC_ECC_EN)&0xffffffff );
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, cfg);
+}
+
+void _enable_ecc(__u32 pipline)
+{
+	__u32 cfg = NFC_READ_REG(NFC_REG_ECC_CTL);
+	if (pipline ==1 )
+		cfg |= NFC_ECC_PIPELINE;
+	else
+		cfg &= ((~NFC_ECC_PIPELINE)&0xffffffff);
+
+
+	/*after erased, all data is 0xff, but ecc is not 0xff,
+			so ecc asume it is right*/
+	//if random open, disable exception
+	if(cfg&(0x1<<9))
+	    cfg &= (~(0x1<<4));
+	else
+	    cfg |= (1 << 4);
+
+	//cfg |= (1 << 1); 16 bit ecc
+
+	cfg |= NFC_ECC_EN;
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, cfg);
+}
+
+__s32 _enter_nand_critical(void)
+{
+	return 0;
+}
+
+__s32 _exit_nand_critical(void)
+{
+	return 0;
+}
+
+void _set_addr(__u8 *addr, __u8 cnt)
+{
+	__u32 i;
+	__u32 addr_low = 0;
+	__u32 addr_high = 0;
+
+	for (i = 0; i < cnt; i++){
+		if (i < 4)
+			addr_low |= (addr[i] << (i*8) );
+		else
+			addr_high |= (addr[i] << ((i - 4)*8));
+	}
+
+	NFC_WRITE_REG(NFC_REG_ADDR_LOW, addr_low);
+	NFC_WRITE_REG(NFC_REG_ADDR_HIGH, addr_high);
+}
+
+__s32 _read_in_page_mode(NFC_CMD_LIST  *rcmd,void *mainbuf,void *sparebuf,__u8 dma_wait_mode)
+{
+	__s32 ret;
+	__s32 i;
+	__u32 cfg;
+	NFC_CMD_LIST *cur_cmd,*read_addr_cmd;
+	__u32 read_data_cmd,random_read_cmd0,random_read_cmd1;
+	dma_addr_t this_dma_handle;
+
+	ret = 0;
+	read_addr_cmd = rcmd;
+	cur_cmd = rcmd;
+	cur_cmd = cur_cmd->next;
+	random_read_cmd0 = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	random_read_cmd1 = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	read_data_cmd = cur_cmd->value;
+
+	//access NFC internal RAM by DMA bus
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | NFC_RAM_METHOD);
+
+	/*set dma and run*/
+//	/*sdram*/
+//	if (NFC_IS_SDRAM((__u32)mainbuf))
+//		attr = 0x2810293;
+//	/*sram*/
+//	else
+//		attr = 0x2800293;
+	//printk("fill with: %x\n", 0xaaaaaaa);
+	//*((int*)mainbuf) = 0xaaaaaaa;
+	this_dma_handle = dma_map_single(NULL, mainbuf, pagesize,
+					 DMA_FROM_DEVICE);
+
+	NAND_Config_Start_DMA(0, this_dma_handle, pagesize);
+
+	/*wait cmd fifo free*/
+	ret = _wait_cmdfifo_free();
+	if (ret) {
+		dma_unmap_single(NULL, this_dma_handle, pagesize, DMA_FROM_DEVICE);
+		return ret;
+	}
+
+	/*set NFC_REG_CNT*/
+	NFC_WRITE_REG(NFC_REG_CNT,1024);
+
+	/*set NFC_REG_RCMD_SET*/
+	cfg = 0;
+	cfg |= (read_data_cmd & 0xff);
+	cfg |= ((random_read_cmd0 & 0xff) << 8);
+	cfg |= ((random_read_cmd1 & 0xff) << 16);
+	NFC_WRITE_REG(NFC_REG_RCMD_SET, cfg);
+
+	/*set NFC_REG_SECTOR_NUM*/
+	NFC_WRITE_REG(NFC_REG_SECTOR_NUM, pagesize/1024);
+
+	/*set addr*/
+	_set_addr(read_addr_cmd->addr,read_addr_cmd->addr_cycle);
+
+	/*set NFC_REG_CMD*/
+	cfg  = 0;
+	cfg |= read_addr_cmd->value;
+	/*set sequence mode*/
+	//cfg |= 0x1<<25;
+	cfg |= ( (read_addr_cmd->addr_cycle - 1) << 16);
+	cfg |= (NFC_SEND_ADR | NFC_DATA_TRANS | NFC_SEND_CMD1 | NFC_SEND_CMD2 | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD);
+	cfg |= ((__u32)0x2 << 30);//page command
+
+	if (pagesize/1024 == 1)
+		cfg |= NFC_SEQ;
+
+	/*enable ecc*/
+	_enable_ecc(1);
+	NFC_WRITE_REG(NFC_REG_CMD,cfg);
+    NAND_WaitDmaFinish();
+
+	/*wait cmd fifo free and cmd finish*/
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+	dma_unmap_single(NULL, this_dma_handle, pagesize, DMA_FROM_DEVICE);
+
+	if (ret){
+		_disable_ecc();
+		return ret;
+	}
+	/*get user data*/
+	for (i = 0; i < pagesize/1024;  i++){
+		*(((__u32*) sparebuf)+i) = NFC_READ_REG(NFC_REG_USER_DATA(i));
+	}
+
+	/*ecc check and disable ecc*/
+	ret = _check_ecc(pagesize/1024);
+	_disable_ecc();
+
+	return ret;
+}
+
+/*******************************************************************************
+*								NFC_Read
+*
+* Description 	: read some sectors data from flash in single plane mode.
+* Arguments	: *rcmd	-- the read command sequence list headã
+*			  *mainbuf	-- point to data buffer address, 	it must be four bytes align.
+*                     *sparebuf	-- point to spare buffer address.
+*                     dma_wait_mode	-- how to deal when dma start, 0 = wait till dma finish,
+							    1 = dma interrupt was set and now sleep till interrupt occurs.
+*			  page_mode  -- 0 = normal command, 1 = page mode
+* Returns		: 0 = success.
+			  1 = success & ecc limit.
+			  -1 = too much ecc err.
+* Notes		:  if align page data requiredï¼page command mode is used., if the commands do
+			   not fetch dataï¼ecc is not neccesary.
+********************************************************************************/
+__s32 NFC_Read(NFC_CMD_LIST  *rcmd, void *mainbuf, void *sparebuf, __u8 dma_wait_mode,__u8 page_mode )
+{
+
+	__u32 ret ;
+
+	_enter_nand_critical();
+
+	ret = _read_in_page_mode(rcmd, mainbuf,sparebuf, dma_wait_mode);
+
+	/*switch to ahb*/
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) & (~NFC_RAM_METHOD));
+
+	_exit_nand_critical();
+
+
+	return ret;
+}
+
+
+/*finish the comand list */
+__s32 nfc_set_cmd_register(NFC_CMD_LIST *cmd)
+{
+	__u32 cfg;
+	__s32 ret;
+
+	NFC_CMD_LIST *cur_cmd = cmd;
+	while(cur_cmd != NULL){
+		/*wait cmd fifo free*/
+		ret = _wait_cmdfifo_free();
+		if (ret)
+			return ret;
+
+		cfg = 0;
+		/*set addr*/
+		if (cur_cmd->addr_cycle){
+			_set_addr(cur_cmd->addr,cur_cmd->addr_cycle);
+			cfg |= ( (cur_cmd->addr_cycle - 1) << 16);
+			cfg |= NFC_SEND_ADR;
+		}
+
+		/*set NFC_REG_CMD*/
+		/*set cmd value*/
+		cfg |= cur_cmd->value;
+		/*set sequence mode*/
+		//cfg |= 0x1<<25;
+		/*wait rb?*/
+		if (cur_cmd->wait_rb_flag){
+			cfg |= NFC_WAIT_FLAG;
+		}
+		if (cur_cmd->data_fetch_flag){
+			NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) & (~NFC_RAM_METHOD));
+			cfg |= NFC_DATA_TRANS;
+			NFC_WRITE_REG(NFC_REG_CNT, cur_cmd->bytecnt);
+		}
+		/*send command*/
+		cfg |= NFC_SEND_CMD1;
+		NFC_WRITE_REG(NFC_REG_CMD, cfg);
+		cur_cmd = cur_cmd ->next;
+	}
+	return 0;
+}
+
+__s32 NFC_SetRandomSeed(__u32 random_seed)
+{
+	__u32 cfg;
+
+
+	  cfg = NFC_READ_REG(NFC_REG_ECC_CTL);
+	  cfg &= 0x0000ffff;
+	  cfg |= (random_seed<<16);
+	  NFC_WRITE_REG(NFC_REG_ECC_CTL,cfg);
+
+	return 0;
+}
+
+__s32 NFC_RandomEnable(void)
+{
+	__u32 cfg;
+
+
+	cfg = NFC_READ_REG(NFC_REG_ECC_CTL);
+	cfg |= (0x1<<9);
+	NFC_WRITE_REG(NFC_REG_ECC_CTL,cfg);
+
+
+	return 0;
+}
+
+__s32 NFC_RandomDisable(void)
+{
+	__u32 cfg;
+
+
+	cfg = NFC_READ_REG(NFC_REG_ECC_CTL);
+	cfg &= (~(0x1<<9));
+	NFC_WRITE_REG(NFC_REG_ECC_CTL,cfg);
+
+
+	return 0;
+}
+
+
+
+/*******************************************************************************
+*								NFC_GetId
+*
+* Description 	: get chip id.
+* Arguments	: *idcmd	-- the get id command sequence list head.
+
+* Returns		: 0 = success.
+			  -1 = fail.
+* Notes		:
+********************************************************************************/
+__s32 NFC_GetId(NFC_CMD_LIST  *idcmd ,__u8 *idbuf)
+{
+	__u32 i;
+	__s32 ret;
+
+	_enter_nand_critical();
+
+    nfc_repeat_mode_enable();
+	ret = nfc_set_cmd_register(idcmd);
+	if (ret){
+		_exit_nand_critical();
+		return ret;
+	}
+
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+
+	/*get 5 bytes id value*/
+	for (i = 0; i < 6; i++){
+		*(idbuf + i) = NFC_READ_RAM_B(NFC_RAM0_BASE+i);
+	}
+
+    nfc_repeat_mode_disable();
+
+	_exit_nand_critical();
+	return ret;
+}
+
+__s32 NFC_GetUniqueId(NFC_CMD_LIST  *idcmd ,__u8 *idbuf)
+{
+	__u32 i;
+	__s32 ret;
+
+	_enter_nand_critical();
+    nfc_repeat_mode_enable();
+
+	ret = nfc_set_cmd_register(idcmd);
+	if (ret){
+		_exit_nand_critical();
+		return ret;
+	}
+
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+
+	/*get 5 bytes id value*/
+	for (i = 0; i < 32; i++){
+		*(idbuf + i) = NFC_READ_RAM_B(NFC_RAM0_BASE+i);
+	}
+
+    nfc_repeat_mode_disable();
+	_exit_nand_critical();
+	return ret;
+}
+
+/*******************************************************************************
+*								NFC_GetStatus
+*
+* Description 	: get status.
+* Arguments	: *scmd	-- the get status command sequence list head.
+
+* Returns		: status result
+* Notes		: some cmd must be sent with addr.
+********************************************************************************/
+__s32 NFC_GetStatus(NFC_CMD_LIST  *scmd)
+{
+	__s32 ret;
+
+	_enter_nand_critical();
+	nfc_repeat_mode_enable();
+	ret = nfc_set_cmd_register(scmd);
+	if (ret){
+		_exit_nand_critical();
+		return ret;
+	}
+
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+	if(ret){
+		_exit_nand_critical();
+		return ret;
+	}
+
+    nfc_repeat_mode_disable();
+	_exit_nand_critical();
+	return (NFC_READ_RAM_B(NFC_RAM0_BASE));
+
+}
+/*******************************************************************************
+*								NFC_ResetChip
+*
+* Description 	: reset nand flash.
+* Arguments	: *reset_cmd	-- the reset command sequence list head.
+
+* Returns		: sucess or fail
+* Notes		:
+********************************************************************************/
+__s32 NFC_ResetChip(NFC_CMD_LIST *reset_cmd)
+
+{
+	__s32 ret;
+
+	_enter_nand_critical();
+
+	ret = nfc_set_cmd_register(reset_cmd);
+	if (ret){
+		_exit_nand_critical();
+		return ret;
+	}
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+	_exit_nand_critical();
+	return ret;
+}
+
+/*******************************************************************************
+*								NFC_SelectChip
+*
+* Description 	: enable chip ce.
+* Arguments	: chip	-- chip no.
+
+* Returns		: 0 = sucess -1 = fail
+* Notes		:
+********************************************************************************/
+__s32 NFC_SelectChip( __u32 chip)
+{
+	__u32 cfg;
+
+
+    cfg = NFC_READ_REG(NFC_REG_CTL);
+    cfg &= ( (~NFC_CE_SEL) & 0xffffffff);
+    cfg |= ((chip & 0x7) << 24);
+    NFC_WRITE_REG(NFC_REG_CTL,cfg);
+
+    if((cfg>>18)&0x3) //ddr nand
+    {
+        //set ddr param
+        NFC_WRITE_REG(NFC_REG_TIMING_CTL,ddr_param[chip]);
+    }
+
+	return 0;
+}
+
+/*******************************************************************************
+*								NFC_SelectRb
+*
+* Description 	: select rb.
+* Arguments	: rb	-- rb no.
+
+* Returns		: 0 = sucess -1 = fail
+* Notes		:
+********************************************************************************/
+__s32 NFC_SelectRb( __u32 rb)
+{
+	__s32 cfg;
+
+
+	  cfg = NFC_READ_REG(NFC_REG_CTL);
+	  cfg &= ( (~NFC_RB_SEL) & 0xffffffff);
+	  cfg |= ((rb & 0x1) << 3);
+	  NFC_WRITE_REG(NFC_REG_CTL,cfg);
+
+	  return 0;
+
+}
+
+
+
+
+
+__s32 NFC_DeSelectChip( __u32 chip)
+{
+
+
+
+
+
+	return 0;
+}
+
+__s32 NFC_DeSelectRb( __u32 rb)
+{
+
+
+
+
+
+	return 0;
+}
+
+
+/*******************************************************************************
+*								NFC_CheckRbReady
+*
+* Description 	: check rb if ready.
+* Arguments	: rb	-- rb no.
+
+* Returns		: 0 = sucess -1 = fail
+* Notes		:
+********************************************************************************/
+
+__s32 NFC_CheckRbReady( __u32 rb)
+{
+	__s32 ret;
+	__u32 cfg = NFC_READ_REG(NFC_REG_ST);
+
+
+	cfg &= (NFC_RB_STATE0 << (rb & 0x3));
+
+	if (cfg)
+		ret = 0;
+	else
+		ret = -1;
+
+	return ret;
+}
+
+/*******************************************************************************
+*								NFC_ChangeMode
+*
+* Description 	: change serial access mode when clock change.
+* Arguments	: nand_info -- structure with flash bus width,pagesize ,serial access mode and other configure parametre
+
+* Returns		: 0 = sucess -1 = fail
+* Notes		: NFC must be reset before seial access mode changes.
+********************************************************************************/
+__s32 NFC_ChangMode(NFC_INIT_INFO *nand_info )
+{
+	__u32 cfg;
+
+	pagesize = nand_info->pagesize * 512;
+
+	/*reset nfc*/
+	_reset();
+
+	/*set NFC_REG_CTL*/
+	cfg = 0;
+	cfg |= NFC_EN;
+	cfg |= ( (nand_info->bus_width & 0x1) << 2);
+	cfg |= ( (nand_info->ce_ctl & 0x1) << 6);
+	cfg |= ( (nand_info->ce_ctl1 & 0x1) << 7);
+	if(nand_info->pagesize == 2 )            /*  1K  */
+	   cfg |= ( 0x0 << 8 );
+	else if(nand_info->pagesize == 4 )       /*  2K  */
+	   cfg |= ( 0x1 << 8 );
+	else if(nand_info->pagesize == 8 )       /*  4K  */
+	   cfg |= ( 0x2 << 8 );
+    else if(nand_info->pagesize == 16 )       /*  8K  */
+	   cfg |= ( 0x3 << 8 );
+	else if(nand_info->pagesize == 32 )       /*  16K  */
+	   cfg |= ( 0x4 << 8 );
+	else                                      /* default 4K */
+	   cfg |= ( 0x2 << 8 );
+	cfg |= ((nand_info->ddr_type & 0x3) << 18);   //set ddr type
+	cfg |= ((nand_info->debug & 0x1) << 31);
+	NFC_WRITE_REG(NFC_REG_CTL,cfg);
+
+	/*set NFC_TIMING */
+	cfg = 0;
+	if((nand_info->ddr_type & 0x3) == 0)
+	    cfg |=((nand_info->serial_access_mode & 0x1) & 0xf)<<8;
+	else if((nand_info->ddr_type & 0x3) == 2)
+	{
+	    cfg |= 0x3f;
+	    cfg |= 0x3<<8;
+    }
+    else if((nand_info->ddr_type & 0x3) == 3)
+	{
+	    cfg |= 0x1f;
+	    cfg |= 0x2<<8;
+	}
+	NFC_WRITE_REG(NFC_REG_TIMING_CTL,cfg);
+	NFC_WRITE_REG(NFC_REG_TIMING_CFG,0xff);
+	/*set NFC_SPARE_AREA */
+	NFC_WRITE_REG(NFC_REG_SPARE_AREA, pagesize);
+
+	return 0;
+}
+
+__s32 NFC_SetEccMode(__u8 ecc_mode)
+{
+    __u32 cfg = NFC_READ_REG(NFC_REG_ECC_CTL);
+
+
+    cfg &=	((~NFC_ECC_MODE)&0xffffffff);
+    cfg |= (NFC_ECC_MODE & (ecc_mode<<12));
+
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, cfg);
+
+	return 0;
+}
+/*******************************************************************************
+*								NFC_Init
+*
+* Description 	: init hardware, set NFC, set TIMING, request dma .
+* Arguments	: nand_info -- structure with flash bus width,pagesize ,serial access mode and other configure parametre
+
+* Returns		: 0 = sucess -1 = fail
+* Notes		: .
+********************************************************************************/
+__s32 NFC_Init(NFC_INIT_INFO *nand_info )
+{
+	__s32 ret;
+    __s32 i;
+
+    //init ddr_param
+    for(i=0;i<8;i++)
+        ddr_param[i] = 0;
+
+	NFC_SetEccMode(0);
+
+	/*init nand control machine*/
+	ret = NFC_ChangMode( nand_info);
+
+	/*request special dma*/
+	dma_hdle = NAND_RequestDMA(1);
+	if (dma_hdle == 0)
+		return -1;
+	return ret;
+
+}
+
+/*******************************************************************************
+*								NFC_Exit
+*
+* Description 	: free hardware resource, free dma , disable NFC.
+* Arguments	: nand_info -- structure with flash bus width,pagesize ,serial access mode and other configure parametre
+
+* Returns		: 0 = sucess -1 = fail
+* Notes		: .
+********************************************************************************/
+void NFC_Exit( void )
+{
+	__u32 cfg;
+	/*disable NFC*/
+	cfg = NFC_READ_REG(NFC_REG_CTL);
+	cfg &= ( (~NFC_EN) & 0xffffffff);
+	NFC_WRITE_REG(NFC_REG_CTL,cfg);
+
+	/*free dma*/
+	NAND_ReleaseDMA(dma_hdle);
+}
+
+/*******************************************************************************
+*								NFC_QueryINT
+*
+* Description 	: get nand interrupt info.
+* Arguments	:
+* Returns		: interrupt no. 0 = RB_B2R,1 = SINGLE_CMD_FINISH,2 = DMA_FINISH,
+								5 = MULTI_CMD_FINISH
+* Notes		:
+********************************************************************************/
+__u32 NFC_QueryINT( void )
+{
+
+//	__u16 i;
+//	__u32 cfg;
+//
+//	cfg = NFC_READ_REG(NFC_REG_INT);
+//	for (i = 0; i < 6; i++)
+//	{
+//		if (cfg & (1 << i))
+//		{
+//			/*clear irq*/
+//			cfg &= ((~(1 << i))&0xffffffff);
+//			NFC_WRITE_REG(NFC_REG_INT, cfg);
+//
+//			return ( (NFC_IRQ_MAJOR << 24) | (i << 16));
+//		}
+//	}
+//
+//	return (NFC_IRQ_MAJOR << 24);
+  return 0;
+
+}
+
+void NFC_EnableInt(__u8 minor_int)
+{
+	/*
+	NFC_WRITE_REG(INTC_REG_ENABLE1,NFC_READ_REG(INTC_REG_ENABLE1) | (1 << NFC_IRQ_MAJOR));
+	NFC_WRITE_REG(NFC_REG_INT, NFC_READ_REG(NFC_REG_INT) | (1 << minor_int));
+    */
+}
+
+void NFC_DisableInt(__u8 minor_int)
+{
+    /*
+	NFC_WRITE_REG(NFC_REG_INT, NFC_READ_REG(NFC_REG_INT) | (~(1 << minor_int)));
+	NFC_WRITE_REG(INTC_REG_ENABLE1,NFC_READ_REG(INTC_REG_ENABLE1) | (~(1 << NFC_IRQ_MAJOR)));
+    */
+}
+
+__s32 _vender_get_param(__u8 *para, __u8 *addr, __u32 count)
+{
+    __u32 i, cfg;
+    __u32 cmd_r = 0;
+    __s32 ret = 0;
+
+    _enter_nand_critical();
+
+    if(read_retry_mode <0x10) //hynix mode
+    {
+        cmd_r = 0x37;
+    }
+    else if((read_retry_mode >=0x10)&&(read_retry_mode <0x20)) //toshiba mode
+    {
+        _exit_nand_critical();
+		return ret;
+    }
+
+    for(i=0; i<count; i++)
+	{
+		_set_addr(&addr[i], 1);
+
+        //set data cnt
+		NFC_WRITE_REG(NFC_REG_CNT, 1);
+
+		/*set NFC_REG_CMD*/
+		cfg = cmd_r;
+		cfg |= (NFC_SEND_ADR | NFC_DATA_TRANS | NFC_SEND_CMD1 );
+		NFC_WRITE_REG(NFC_REG_CMD, cfg);
+
+		ret = _wait_cmdfifo_free();
+		ret |= _wait_cmd_finish();
+
+		if(ret)
+		{
+			_exit_nand_critical();
+			return ret;
+		}
+
+		*(para+i) = NFC_READ_RAM_B(NFC_RAM0_BASE);
+	}
+
+    _exit_nand_critical();
+	return ret;
+}
+
+__s32 _vender_set_param(__u8 *para, __u8 *addr, __u32 count)
+{
+    __u32 i, cfg;
+    __u32 cmd_w=0xff, cmd_end=0xff, cmd_done0 =0xff, cmd_done1=0xff;
+    __s32 ret = 0;
+
+    _enter_nand_critical();
+
+    if(read_retry_mode <0x10) //hynix mode
+    {
+        cmd_w = 0x36;
+        cmd_end = 0x16;
+        cmd_done0 = 0xff;
+        cmd_done1 = 0xff;
+    }
+    else if((read_retry_mode >=0x10)&&(read_retry_mode <0x20)) //toshiba mode
+    {
+        cmd_w = 0x55;
+        cmd_end = 0xff;
+        cmd_done0 = 0x26;
+        cmd_done1 = 0x5D;
+
+    }
+    else if((read_retry_mode >=0x20)&&(read_retry_mode <0x30)) //Samsung mode
+    {
+        cmd_w = 0xA1;
+        cmd_end = 0xff;
+        cmd_done0 = 0xff;
+        cmd_done1 = 0xff;
+
+    }
+
+    for(i=0; i<count; i++)
+	{
+	    if((read_retry_mode >=0x20)&&(read_retry_mode <0x30)) //samsung mode
+	    {
+	        /* send cmd to set param */
+	        NFC_WRITE_RAM_B(NFC_RAM0_BASE, 0x00);
+	        NFC_WRITE_RAM_B(NFC_RAM0_BASE+1, addr[i]);
+    		NFC_WRITE_RAM_B(NFC_RAM0_BASE+2, para[i]);
+
+    		NFC_WRITE_REG(NFC_REG_CNT, 3);
+
+    		/*set NFC_REG_CMD*/
+    		cfg = cmd_w;
+    		cfg |= ( NFC_DATA_TRANS | NFC_ACCESS_DIR | NFC_SEND_CMD1);
+    		nfc_repeat_mode_enable();
+    		NFC_WRITE_REG(NFC_REG_CMD, cfg);
+    		nfc_repeat_mode_disable();
+	    }
+	    else //hynix & toshiba mode
+	    {
+	        /* send cmd to set param */
+    		NFC_WRITE_RAM_B(NFC_RAM0_BASE, para[i]);
+    		_set_addr(&addr[i], 1);
+    		NFC_WRITE_REG(NFC_REG_CNT, 1);
+
+    		/*set NFC_REG_CMD*/
+    		cfg = cmd_w;
+    		cfg |= (NFC_SEND_ADR | NFC_DATA_TRANS | NFC_ACCESS_DIR | NFC_SEND_CMD1);
+    		NFC_WRITE_REG(NFC_REG_CMD, cfg);
+	    }
+
+		ret = _wait_cmdfifo_free();
+		ret |= _wait_cmd_finish();
+
+		if(ret)
+		{
+			_exit_nand_critical();
+			return ret;
+		}
+
+		/* send cmd to end */
+		if(cmd_end != 0xff)
+		{
+		    /*set NFC_REG_CMD*/
+    		cfg = cmd_end;
+    		cfg |= ( NFC_SEND_CMD1);
+    		NFC_WRITE_REG(NFC_REG_CMD, cfg);
+
+    		ret = _wait_cmdfifo_free();
+    		ret |= _wait_cmd_finish();
+
+    		if(ret)
+    		{
+    			_exit_nand_critical();
+    			return ret;
+    		}
+		}
+
+	}
+
+	if(cmd_done0!=0xff)
+	{
+	    /*set NFC_REG_CMD*/
+		cfg = cmd_done0;
+		cfg |= ( NFC_SEND_CMD1);
+		NFC_WRITE_REG(NFC_REG_CMD, cfg);
+
+		ret = _wait_cmdfifo_free();
+		ret |= _wait_cmd_finish();
+
+		if(ret)
+		{
+			_exit_nand_critical();
+			return ret;
+		}
+	}
+
+	if(cmd_done1!=0xff)
+	{
+	    /*set NFC_REG_CMD*/
+		cfg = cmd_done1;
+		cfg |= ( NFC_SEND_CMD1);
+		NFC_WRITE_REG(NFC_REG_CMD, cfg);
+
+		ret = _wait_cmdfifo_free();
+		ret |= _wait_cmd_finish();
+
+		if(ret)
+		{
+			_exit_nand_critical();
+			return ret;
+		}
+	}
+
+
+
+    _exit_nand_critical();
+	return ret;
+}
+
+__s32 _vender_pre_condition(void)
+{
+    __u32 i, cfg;
+    __u32 cmd[2]= {0x5c, 0xc5};
+    __s32 ret = 0;
+
+    _enter_nand_critical();
+    if((read_retry_mode>=0x10)&&(read_retry_mode<0x20))  //toshiba mode
+    {
+        for(i=0;i<2;i++)
+        {
+        	/*set NFC_REG_CMD*/
+        	cfg = cmd[i];
+        	cfg |= (NFC_SEND_CMD1);
+        	NFC_WRITE_REG(NFC_REG_CMD, cfg);
+
+        	ret = _wait_cmdfifo_free();
+        	ret |= _wait_cmd_finish();
+
+        	if (ret)
+        	{
+        		_exit_nand_critical();
+        		return ret;
+        	}
+        }
+    }
+    _exit_nand_critical();
+
+	return ret;
+}
+
+static __u32 get_nand_clk(void)
+{
+    __u32 reg_val = *(volatile __u32 *)(0xf1c20000 + 0x80);
+
+    return reg_val;
+}
+
+static void nand_clk_down(void)
+{
+    __u32 reg_val = *(volatile __u32 *)(0xf1c20000 + 0x80);
+
+    reg_val |=(0xf);  //set to mix clock
+
+    *(volatile __u32 *)(0xf1c20000 + 0x80) = reg_val;
+
+}
+
+static void nand_clk_recover(__u32 reg_val)
+{
+     *(volatile __u32 *)(0xf1c20000 + 0x80) = reg_val;
+}
+
+
+//for offset from defaul value
+__s32 NFC_ReadRetry(__u32 chip, __u32 retry_count, __u32 read_retry_type)
+{
+    __u32 i;
+    __s32 ret=0;
+    __s16 temp_val;
+    __u8 param[READ_RETRY_MAX_REG_NUM];
+    __u32 nand_clk_bak;
+
+	if(retry_count >read_retry_cycle)
+		return -1;
+
+    if(read_retry_mode<0x10)  //for hynix read retry mode
+    {
+        if(retry_count == 0)
+    	    ret = _vender_set_param(&read_retry_default_val[chip][0], &read_retry_reg_adr[0], read_retry_reg_num);
+    	else
+    	{
+    	    for(i=0; i<read_retry_reg_num; i++)
+        	{
+
+        	    temp_val = (read_retry_default_val[chip][i] + read_retry_val[retry_count-1][i]);
+        	    if(temp_val >255)
+        	        temp_val = 0xff;
+        	    else if(temp_val <0)
+    				temp_val = 0;
+    			else
+        	        temp_val &= 0xff;
+
+        	    param[i] = (__u8)temp_val;
+
+        	}
+
+    		//fix 0
+    		if(read_retry_mode == 0)
+    		{
+    			if(retry_count == 10)
+        	    	param[1] = 0;
+    		}
+    		else if(read_retry_mode == 1)
+    		{
+    			if((retry_count >=2)&&(retry_count<=6))
+    				param[0] = 0;
+
+    			if((retry_count == 5)||(retry_count == 6))
+        	    	param[1] = 0;
+    		}
+
+        	ret =_vender_set_param(&param[0], &read_retry_reg_adr[0], read_retry_reg_num);
+    	}
+
+    }
+    else if((read_retry_mode>=0x10)&&(read_retry_mode<0x20))  //for toshiba readretry mode
+    {
+        nand_clk_bak = get_nand_clk();
+        nand_clk_down();
+
+        if(retry_count == 1)
+            _vender_pre_condition();
+
+        for(i=0; i<read_retry_reg_num; i++)
+            param[i] = (__u8)read_retry_val[retry_count-1][i];
+
+        ret =_vender_set_param(&param[0], &read_retry_reg_adr[0], read_retry_reg_num);
+
+        nand_clk_recover(nand_clk_bak);
+    }
+    else if((read_retry_mode>=0x20)&&(read_retry_mode<0x30))
+    {
+        for(i=0; i<read_retry_reg_num; i++)
+            param[i] = (__u8)read_retry_val[retry_count][i];
+
+        ret =_vender_set_param(&param[0], &read_retry_reg_adr[0], read_retry_reg_num);
+    }
+
+	return ret;
+}
+
+__s32 NFC_ReadRetryInit(__u32 read_retry_type)
+{
+	__u32 i,j;
+	__s16 para0[6][4] = {	{0x00,  0x06,  0x0A,  0x06},
+    						{0x00, -0x03, -0x07, -0x08},
+    						{0x00, -0x06, -0x0D, -0x0F},
+    						{0x00, -0x0B, -0x14, -0x17},
+    						{0x00,  0x00, -0x1A, -0x1E},
+    						{0x00,  0x00, -0x20, -0x25}
+					};
+	__s16 para1[6][4] = {	{0x00,  0x06,  0x0a,  0x06},
+    						{0x00, -0x03, -0x07, -0x08},
+    						{0x00, -0x06, -0x0d, -0x0f},
+    						{0x00, -0x09, -0x14, -0x17},
+    						{0x00,  0x00, -0x1a, -0x1e},
+    						{0x00,  0x00, -0x20, -0x25}
+
+					};
+    __s16 para0x10[5] = {0x04, 0x7c, 0x78, 0x74, 0x08};
+    __s16 para0x20[15][4] ={{0x00, 0x00, 0x00, 0x00},    //0
+                         {0x05, 0x0A, 0x00, 0x00},    //1
+                         {0x28, 0x00, 0xEC, 0xD8},    //2
+                         {0xED, 0xF5, 0xED, 0xE6},    //3
+                         {0x0A, 0x0F, 0x05, 0x00},    //4
+                         {0x0F, 0x0A, 0xFB, 0xEC},    //5
+                         {0xE8, 0xEF, 0xE8, 0xDC},    //6
+                         {0xF1, 0xFB, 0xFE, 0xF0},    //7
+                         {0x0A, 0x00, 0xFB, 0xEC},    //8
+                         {0xD0, 0xE2, 0xD0, 0xC2},    //9
+                         {0x14, 0x0F, 0xFB, 0xEC},    //10
+                         {0xE8, 0xFB, 0xE8, 0xDC},    //11
+                         {0x1E, 0x14, 0xFB, 0xEC},    //12
+                         {0xFB, 0xFF, 0xFB, 0xF8},    //13
+                         {0x07, 0x0C, 0x02, 0x00}     //14
+	                    };
+	//init
+	read_retry_mode = (read_retry_type>>16)&0xff;
+	read_retry_cycle =(read_retry_type>>8)&0xff;
+	read_retry_reg_num = (read_retry_type>>0)&0xff;
+
+	if(read_retry_mode == 0)  //mode0  hynix readretry mode0
+	{
+		read_retry_reg_adr[0] = 0xAC;
+		read_retry_reg_adr[1] = 0xAD;
+		read_retry_reg_adr[2] = 0xAE;
+		read_retry_reg_adr[3] = 0xAF;
+
+		//set read retry level
+		for(i=0;i<read_retry_cycle;i++)
+		{
+			for(j=0; j<read_retry_reg_num;j++)
+			{
+				read_retry_val[i][j] = para0[i][j];
+			}
+		}
+
+	}
+	else if(read_retry_mode == 1) //mode1  hynix readretry mode
+	{
+		read_retry_reg_adr[0] = 0xA7;
+		read_retry_reg_adr[1] = 0xAD;
+		read_retry_reg_adr[2] = 0xAE;
+		read_retry_reg_adr[3] = 0xAF;
+
+		//set read retry level
+		for(i=0;i<read_retry_cycle;i++)
+		{
+			for(j=0; j<read_retry_reg_num;j++)
+			{
+				read_retry_val[i][j] = para1[i][j];
+			}
+
+		}
+
+		//set lsb mode
+		lsb_mode_reg_num = 5;
+
+		lsb_mode_reg_adr[0] = 0xa4;
+		lsb_mode_reg_adr[1] = 0xa5;
+		lsb_mode_reg_adr[2] = 0xb0;
+		lsb_mode_reg_adr[3] = 0xb1;
+		lsb_mode_reg_adr[4] = 0xc9;
+
+		lsb_mode_val[0] = 0x25;
+		lsb_mode_val[1] = 0x25;
+		lsb_mode_val[2] = 0x25;
+		lsb_mode_val[3] = 0x25;
+		lsb_mode_val[4] = 0x1;
+	}
+	else if(read_retry_mode == 0x10)  //mode0x10  toshiba readretry mode0
+	{
+	    read_retry_reg_adr[0] = 0x04;
+		read_retry_reg_adr[1] = 0x05;
+		read_retry_reg_adr[2] = 0x06;
+		read_retry_reg_adr[3] = 0x07;
+
+	    //set read retry level
+		for(i=0;i<read_retry_cycle;i++)
+		{
+			for(j=0; j<read_retry_reg_num;j++)
+			{
+				read_retry_val[i][j] = para0x10[i];
+			}
+		}
+
+	}
+	else if(read_retry_mode == 0x20)  //mode0x10  Samsung mode0
+	{
+	    read_retry_reg_adr[0] = 0xA7;
+		read_retry_reg_adr[1] = 0xA4;
+		read_retry_reg_adr[2] = 0xA5;
+		read_retry_reg_adr[3] = 0xA6;
+
+	    //set read retry level
+		for(i=0;i<read_retry_cycle+1;i++)
+		{
+			for(j=0; j<read_retry_reg_num;j++)
+			{
+				read_retry_val[i][j] = para0x20[i][j];
+			}
+
+		}
+	}
+
+	return 0;
+}
+
+__s32 NFC_GetDefaultParam(__u32 chip,__u8* default_value, __u32 read_retry_type)
+{
+    __s32 ret;
+    __u32 i;
+
+
+    if(read_retry_mode<0x10)  //hynix read retry mode
+    {
+        ret =_vender_get_param(&read_retry_default_val[chip][0], &read_retry_reg_adr[0], read_retry_reg_num);
+        for(i=0; i<read_retry_reg_num; i++)
+        {
+            default_value[i] = read_retry_default_val[chip][i];
+        }
+
+    	return ret;
+	}
+    else
+    {
+        return 0;
+    }
+}
+
+__s32 NFC_SetDefaultParam(__u32 chip,__u8* default_value,__u32 read_retry_type)
+{
+    __s32 ret;
+    __u32 i;
+
+    if(read_retry_mode<0x10)  //hynix read retry mode
+    {
+        for(i=0; i<read_retry_reg_num; i++)
+        {
+            default_value[i] = read_retry_default_val[chip][i];
+        }
+        ret =_vender_set_param(&read_retry_default_val[chip][0], &read_retry_reg_adr[0], read_retry_reg_num);
+
+    	return ret;
+    }
+    else if((read_retry_mode>=0x20)&&(read_retry_mode<0x30))  //samsung read retry mode
+    {
+        for(i=0; i<read_retry_reg_num; i++)
+        {
+            default_value[i] = (__u8)read_retry_val[0][i];;
+        }
+        ret =_vender_set_param(default_value, &read_retry_reg_adr[0], read_retry_reg_num);
+
+    	return ret;
+    }
+    else
+    {
+        return 0;
+    }
+
+
+}
+
+__s32 NFC_ReadRetryExit(__u32 read_retry_type)
+{
+
+	return 0;
+}
+
+
+
diff --git a/drivers/block/sunxi_nand/nfc/nfc_w.c b/drivers/block/sunxi_nand/nfc/nfc_w.c
new file mode 100644
index 0000000..c9e5b78
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfc/nfc_w.c
@@ -0,0 +1,953 @@
+/*
+ * drivers/block/sunxi_nand/nfc/nfc_w.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/dma-mapping.h>
+#include "nfc_i.h"
+
+extern __u32 pagesize;
+extern __s32 _wait_cmdfifo_free(void);
+extern __s32 _wait_cmd_finish(void);
+extern __s32 _check_ecc(__u32 eblock_cnt);
+extern void _disable_ecc(void);
+extern void _enable_ecc(__u32 pipline);
+extern __s32 _enter_nand_critical(void);
+extern __s32 _exit_nand_critical(void);
+extern void _set_addr(__u8 *addr, __u8 cnt);
+extern __s32 nfc_set_cmd_register(NFC_CMD_LIST *cmd);
+extern __s32 _read_in_page_mode(NFC_CMD_LIST  *rcmd,void *mainbuf,void *sparebuf,__u8 dma_wait_mode);
+extern __s32 _read_in_normal_mode(NFC_CMD_LIST  *rcmd, __u8 *mainbuf, __u8 *sparebuf,__u8 dma_wait_mode);
+
+
+extern __u8 read_retry_reg_adr[READ_RETRY_MAX_REG_NUM];
+extern __u8 read_retry_default_val[8][READ_RETRY_MAX_REG_NUM];
+extern __s16 read_retry_val[READ_RETRY_MAX_CYCLE][READ_RETRY_MAX_REG_NUM];
+extern __u8 read_retry_mode;
+extern __u8 read_retry_cycle;
+extern __u8 read_retry_reg_num;
+
+extern __u8 lsb_mode_reg_adr[LSB_MODE_MAX_REG_NUM];
+extern __u8 lsb_mode_default_val[LSB_MODE_MAX_REG_NUM];
+extern __u8 lsb_mode_val[LSB_MODE_MAX_REG_NUM];
+extern __u8 lsb_mode_reg_num;
+
+extern __s32 _vender_get_param(__u8 *para, __u8 *addr, __u32 count);
+extern __s32 _vender_set_param(__u8 *para, __u8 *addr, __u32 count);
+extern __s32 _vender_pre_condition(void);
+
+
+/*after send write or erase command, must wait rb from ready to busy, then can send status command
+	because nfc not do this, so software delay by xr, 2009-3-25*/
+
+void _wait_twb(void)
+{
+/*
+	__u32 timeout = 800;
+
+	while ( (timeout--) && !(NFC_READ_REG(NFC_REG_ST) & NFC_CMD_FIFO_STATUS));
+*/
+}
+
+/*******************************************************************************
+*								NFC_Write
+*
+* Description 	: write one page data into flash in single plane mode.
+* Arguments	: *wcmd	-- the write command sequence list headã
+*			  *mainbuf	-- point to data buffer address, 	it must be four bytes align.
+*                     *sparebuf	-- point to spare buffer address.
+*                     dma_wait_mode	-- how to deal when dma start, 0 = wait till dma finish,
+							    1 = dma interrupt was set and now sleep till interrupt occurs.
+*			  rb_wait_mode -- 0 = do not care rb, 1 = set rb interrupt and do not wait rb ready.
+*			  page_mode  -- 0 = common command, 1 = page command.
+* Returns		: 0 = success.
+			  -1 = fail.
+* Notes		: the unit must be page, so if  page_mode is not 1, return fail,the function exits without checking status,
+			  if the commands do not fetch data,ecc is not neccesary.
+********************************************************************************/
+__s32 NFC_Write( NFC_CMD_LIST  *wcmd, void *mainbuf, void *sparebuf,  __u8 dma_wait_mode, __u8 rb_wait_mode,
+				    __u8 page_mode)
+{
+	__s32 ret;
+	__s32 i;
+	__u32 cfg;
+	__u32 program_cmd,random_program_cmd;
+	NFC_CMD_LIST *cur_cmd,*program_addr_cmd;
+	dma_addr_t this_dma_handle;
+
+	if (page_mode == 0){
+		return -1;
+	}
+
+	ret = 0;
+	_enter_nand_critical();
+
+	/*write in page_mode*/
+	program_addr_cmd = wcmd;
+	cur_cmd = wcmd;
+	cur_cmd = cur_cmd->next;
+	random_program_cmd = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	program_cmd = cur_cmd->value;
+
+	//access NFC internal RAM by DMA bus
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | NFC_RAM_METHOD);
+
+	/*set dma and run*/
+//	if (NFC_IS_SDRAM((__u32)mainbuf))
+//		attr = 0x2930281;
+//	else
+//		attr = 0x2930280;
+
+	this_dma_handle = dma_map_single(NULL, mainbuf, pagesize,
+					 DMA_TO_DEVICE);
+	NAND_Config_Start_DMA(1, this_dma_handle, pagesize);
+
+	/*wait cmd fifo free*/
+	ret = _wait_cmdfifo_free();
+	if (ret){
+		_exit_nand_critical();
+		dma_unmap_single(NULL, this_dma_handle, pagesize, DMA_TO_DEVICE);
+		return ret;
+	}
+	/*set NFC_REG_CNT*/
+  NFC_WRITE_REG(NFC_REG_CNT,1024);
+
+	/*set NFC_REG_RCMD_SET*/
+	cfg = 0;
+	cfg |= (program_cmd & 0xff);
+	cfg |= ((random_program_cmd & 0xff) << 8);
+	NFC_WRITE_REG(NFC_REG_WCMD_SET, cfg);
+
+	/*set NFC_REG_SECTOR_NUM*/
+	NFC_WRITE_REG(NFC_REG_SECTOR_NUM, pagesize/1024);
+
+	/*set user data*/
+	for (i = 0; i < pagesize/1024;  i++){
+		NFC_WRITE_REG(NFC_REG_USER_DATA(i), *((__u32 *)sparebuf + i) );
+	}
+
+	/*set addr*/
+	_set_addr(program_addr_cmd->addr,program_addr_cmd->addr_cycle);
+
+	/*set NFC_REG_CMD*/
+	cfg  = 0;
+	 /*set sequence mode*/
+	//cfg |= 0x1<<25;
+	cfg |= program_addr_cmd->value;
+	cfg |= ( (program_addr_cmd->addr_cycle - 1) << 16);
+	//cfg |= (NFC_SEND_ADR | NFC_ACCESS_DIR | NFC_DATA_TRANS | NFC_SEND_CMD | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD);
+	cfg |= (NFC_SEND_ADR | NFC_ACCESS_DIR | NFC_DATA_TRANS | NFC_SEND_CMD1 | NFC_SEND_CMD2 | NFC_DATA_SWAP_METHOD);
+	cfg |= ((__u32)0x2 << 30);//page command
+	if (pagesize/1024 == 1)
+		cfg |= NFC_SEQ;
+
+	/*enable ecc*/
+	_enable_ecc(1);
+	NFC_WRITE_REG(NFC_REG_CMD,cfg);
+
+    NAND_WaitDmaFinish();
+
+	_wait_twb();
+	_wait_cmdfifo_free();
+	_wait_cmd_finish();
+	dma_unmap_single(NULL, this_dma_handle, pagesize, DMA_TO_DEVICE);
+
+	/*disable ecc*/
+	_disable_ecc();
+
+	/*switch to ahb*/
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) & (~NFC_RAM_METHOD));
+
+	_exit_nand_critical();
+	return ret;
+}
+
+__s32 NFC_Write_Seq( NFC_CMD_LIST  *wcmd, void *mainbuf, void *sparebuf,  __u8 dma_wait_mode, __u8 rb_wait_mode,
+				    __u8 page_mode)
+{
+	__s32 ret;
+	__s32 i;
+	__u32 cfg;
+	__u32 ecc_mode_temp;
+	__u32 program_cmd,random_program_cmd;
+	NFC_CMD_LIST *cur_cmd,*program_addr_cmd;
+	dma_addr_t this_dma_handle;
+
+	if (page_mode == 0){
+		return -1;
+	}
+
+	ret = 0;
+	_enter_nand_critical();
+
+	/*write in page_mode*/
+	program_addr_cmd = wcmd;
+	cur_cmd = wcmd;
+	cur_cmd = cur_cmd->next;
+	random_program_cmd = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	program_cmd = cur_cmd->value;
+
+	//access NFC internal RAM by DMA bus
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | NFC_RAM_METHOD);
+
+//	/*set dma and run*/
+//	if (NFC_IS_SDRAM((__u32)mainbuf))
+//		attr = 0x2930281;
+//	else
+//		attr = 0x2930280;
+
+	this_dma_handle = dma_map_single(NULL, mainbuf, pagesize,
+					 DMA_TO_DEVICE);
+	NAND_Config_Start_DMA(1, this_dma_handle, pagesize);
+
+	/*wait cmd fifo free*/
+	ret = _wait_cmdfifo_free();
+	if (ret){
+		_exit_nand_critical();
+		dma_unmap_single(NULL, this_dma_handle, pagesize, DMA_TO_DEVICE);
+		return ret;
+	}
+	/*set NFC_REG_CNT*/
+  NFC_WRITE_REG(NFC_REG_CNT,1024);
+
+	/*set NFC_REG_RCMD_SET*/
+	cfg = 0;
+	cfg |= (program_cmd & 0xff);
+	cfg |= ((random_program_cmd & 0xff) << 8);
+	NFC_WRITE_REG(NFC_REG_WCMD_SET, cfg);
+
+	/*set NFC_REG_SECTOR_NUM*/
+	NFC_WRITE_REG(NFC_REG_SECTOR_NUM, pagesize/1024);
+
+	/*set user data*/
+	for (i = 0; i < pagesize/1024;  i++){
+		NFC_WRITE_REG(NFC_REG_USER_DATA(i), *((__u32 *)sparebuf + i) );
+	}
+
+	/*set addr*/
+	_set_addr(program_addr_cmd->addr,program_addr_cmd->addr_cycle);
+
+	/*set NFC_REG_CMD*/
+	cfg  = 0;
+	 /*set sequence mode*/
+	cfg |= 0x1<<25;
+	cfg |= program_addr_cmd->value;
+	cfg |= ( (program_addr_cmd->addr_cycle - 1) << 16);
+	//cfg |= (NFC_SEND_ADR | NFC_ACCESS_DIR | NFC_DATA_TRANS | NFC_SEND_CMD | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD);
+	cfg |= (NFC_SEND_ADR | NFC_ACCESS_DIR | NFC_DATA_TRANS | NFC_SEND_CMD1 | NFC_SEND_CMD2 | NFC_DATA_SWAP_METHOD);
+	cfg |= ((__u32)0x2 << 30);//page command
+	if (pagesize/1024 == 1)
+		cfg |= NFC_SEQ;
+
+	/*enable ecc*/
+	_enable_ecc(1);
+
+	/*set ecc to 24-bit ecc*/
+    ecc_mode_temp = NFC_READ_REG(NFC_REG_ECC_CTL) & 0xf000;
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, ((NFC_READ_REG(NFC_REG_ECC_CTL) & (~NFC_ECC_MODE))|(0x1<<12) ));
+
+	NFC_WRITE_REG(NFC_REG_CMD,cfg);
+
+    NAND_WaitDmaFinish();
+
+	_wait_twb();
+	_wait_cmdfifo_free();
+	_wait_cmd_finish();
+
+	dma_unmap_single(NULL, this_dma_handle, pagesize, DMA_TO_DEVICE);
+
+	/*disable ecc*/
+	_disable_ecc();
+
+	/*set ecc to original value*/
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, (NFC_READ_REG(NFC_REG_ECC_CTL) & (~NFC_ECC_MODE))|ecc_mode_temp);
+
+	/*switch to ahb*/
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) & (~NFC_RAM_METHOD));
+
+	_exit_nand_critical();
+	return ret;
+}
+
+__s32 NFC_Write_1K( NFC_CMD_LIST  *wcmd, void *mainbuf, void *sparebuf,  __u8 dma_wait_mode, __u8 rb_wait_mode,
+				    __u8 page_mode)
+{
+	__s32 ret;
+	__s32 i;
+	__u32 cfg;
+	__u32 page_size_temp, ecc_mode_temp;
+	__u32 program_cmd,random_program_cmd;
+	NFC_CMD_LIST *cur_cmd,*program_addr_cmd;
+	dma_addr_t this_dma_handle;
+
+	if (page_mode == 0){
+		return -1;
+	}
+
+	ret = 0;
+	_enter_nand_critical();
+
+	/*write in page_mode*/
+	program_addr_cmd = wcmd;
+	cur_cmd = wcmd;
+	cur_cmd = cur_cmd->next;
+	random_program_cmd = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	program_cmd = cur_cmd->value;
+
+	//access NFC internal RAM by DMA bus
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | NFC_RAM_METHOD);
+
+	//set pagesize to 1K
+      page_size_temp = (NFC_READ_REG(NFC_REG_CTL) & 0xf00)>>8;
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | (0x3<<8));
+
+//	/*set dma and run*/
+//	if (NFC_IS_SDRAM((__u32)mainbuf))
+//		attr = 0x2930281;
+//	else
+//		attr = 0x2930280;
+
+	this_dma_handle = dma_map_single(NULL, mainbuf, 1024,
+					 DMA_TO_DEVICE);
+	NAND_Config_Start_DMA(1, this_dma_handle, 1024);
+
+	/*wait cmd fifo free*/
+	ret = _wait_cmdfifo_free();
+	if (ret){
+		_exit_nand_critical();
+		dma_unmap_single(NULL, this_dma_handle, 1024, DMA_TO_DEVICE);
+		return ret;
+	}
+	/*set NFC_REG_CNT*/
+  NFC_WRITE_REG(NFC_REG_CNT,1024);
+
+	/*set NFC_REG_RCMD_SET*/
+	cfg = 0;
+	cfg |= (program_cmd & 0xff);
+	cfg |= ((random_program_cmd & 0xff) << 8);
+	NFC_WRITE_REG(NFC_REG_WCMD_SET, cfg);
+
+	/*set NFC_REG_SECTOR_NUM*/
+	NFC_WRITE_REG(NFC_REG_SECTOR_NUM, 1024/1024);
+
+	/*set user data*/
+	for (i = 0; i < 1024/1024;  i++){
+		NFC_WRITE_REG(NFC_REG_USER_DATA(i), *((__u32 *)sparebuf + i) );
+	}
+
+	/*set addr*/
+	_set_addr(program_addr_cmd->addr,program_addr_cmd->addr_cycle);
+
+	/*set NFC_REG_CMD*/
+	cfg  = 0;
+	 /*set sequence mode*/
+	cfg |= 0x1<<25;
+	cfg |= program_addr_cmd->value;
+	cfg |= ( (program_addr_cmd->addr_cycle - 1) << 16);
+	//cfg |= (NFC_SEND_ADR | NFC_ACCESS_DIR | NFC_DATA_TRANS | NFC_SEND_CMD | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD);
+	cfg |= (NFC_SEND_ADR | NFC_ACCESS_DIR | NFC_DATA_TRANS | NFC_SEND_CMD1 | NFC_SEND_CMD2 | NFC_DATA_SWAP_METHOD);
+	cfg |= ((__u32)0x2 << 30);//page command
+	if (pagesize/1024 == 1)
+		cfg |= NFC_SEQ;
+
+	/*enable ecc*/
+	_enable_ecc(1);
+
+	/*set ecc to 64-bit ecc*/
+    ecc_mode_temp = NFC_READ_REG(NFC_REG_ECC_CTL) & 0xf000;
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, ((NFC_READ_REG(NFC_REG_ECC_CTL) & (~NFC_ECC_MODE))|(0x8<<12) ));
+	NFC_WRITE_REG(NFC_REG_CMD,cfg);
+
+    NAND_WaitDmaFinish();
+
+	_wait_twb();
+	_wait_cmdfifo_free();
+	_wait_cmd_finish();
+	dma_unmap_single(NULL, this_dma_handle, 1024, DMA_TO_DEVICE);
+
+	/*disable ecc*/
+	_disable_ecc();
+
+	/*set ecc to original value*/
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, (NFC_READ_REG(NFC_REG_ECC_CTL) & (~NFC_ECC_MODE))|ecc_mode_temp);
+
+      /*set pagesize to original value*/
+      NFC_WRITE_REG(NFC_REG_CTL, ((NFC_READ_REG(NFC_REG_CTL)) & (~NFC_PAGE_SIZE)) | (page_size_temp<<8));
+
+	/*switch to ahb*/
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) & (~NFC_RAM_METHOD));
+
+	_exit_nand_critical();
+	return ret;
+}
+
+/*******************************************************************************
+*								NFC_Erase
+*
+* Description 	: erase one block in signle plane mode or multi plane mode.
+* Arguments	: *ecmd	-- the erase command sequence list head
+*			  rb_wait_mode  -- 0 = do not care rb, 1 = set rb interrupt and do not wait rb ready.
+* Returns		: 0 = success.
+			  -1 = fail.
+* Notes		: the unit must be page, so if  page_mode is not 1, return fail,the function exits without checking status,
+			  if the commands do not fetch data,ecc is not neccesary.
+********************************************************************************/
+__s32 NFC_Erase(NFC_CMD_LIST  *ecmd, __u8 rb_wait_mode)
+{
+
+	__s32 ret;
+
+	_enter_nand_critical();
+
+	ret = nfc_set_cmd_register(ecmd);
+	if (ret){
+		_exit_nand_critical();
+		return ret;
+	}
+	_wait_twb();
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+
+	_exit_nand_critical();
+
+	return ret;
+}
+
+/*******************************************************************************
+*								NFC_CopyBackRead
+*
+* Description 	: copyback read one page data inside flash in single plane mode or multi plane mode
+* Arguments	: *crcmd	-- the copyback read command sequence list head.
+* Returns		: 0 = success.
+			  -1 = fail.
+* Notes		: the unit must be page.
+********************************************************************************/
+__s32 NFC_CopyBackRead(NFC_CMD_LIST  *crcmd)
+{
+
+	__s32 ret;
+
+	_enter_nand_critical();
+	ret = nfc_set_cmd_register(crcmd);
+	if (ret){
+		_exit_nand_critical();
+		return ret;
+	}
+
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+
+	_exit_nand_critical();
+
+	return ret;
+}
+//#pragma arm section code="NFC_CopyBackWrite"
+/*******************************************************************************
+*								NFC_CopyBackWrite
+*
+* Description 	: copyback write one page data inside flash in single plane mode or multi plane mode
+* Arguments	: *cwcmd	-- the copyback read command sequence list head.
+ 			  rb_wait_mode  -- 0 = do not care rb, 1 = set rb interrupt and do not wait rb ready.
+* Returns		: 0 = success.
+			  -1 = fail.
+* Notes		: the unit must be page.
+********************************************************************************/
+__s32 NFC_CopyBackWrite(NFC_CMD_LIST  *cwcmd, __u8 rb_wait_mode)
+{
+	__s32 ret;
+
+	_enter_nand_critical();
+
+	ret = nfc_set_cmd_register(cwcmd);
+	if (ret){
+		_exit_nand_critical();
+		return ret;
+	}
+	_wait_twb();
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+
+	_exit_nand_critical();
+
+	return ret;
+}
+
+__s32 _read_in_page_mode_seq(NFC_CMD_LIST  *rcmd,void *mainbuf,void *sparebuf,__u8 dma_wait_mode)
+{
+	__s32 ret;
+	__s32 i;
+	__u32 cfg;
+	NFC_CMD_LIST *cur_cmd,*read_addr_cmd;
+	__u32 read_data_cmd,random_read_cmd0,random_read_cmd1;
+	__u32 ecc_mode_temp;
+	dma_addr_t this_dma_handle;
+
+	ret = 0;
+	read_addr_cmd = rcmd;
+	cur_cmd = rcmd;
+	cur_cmd = cur_cmd->next;
+	random_read_cmd0 = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	random_read_cmd1 = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	read_data_cmd = cur_cmd->value;
+
+	//access NFC internal RAM by DMA bus
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | NFC_RAM_METHOD);
+
+//	/*set dma and run*/
+//	/*sdram*/
+//	if (NFC_IS_SDRAM((__u32)mainbuf))
+//		attr = 0x2810293;
+//	/*sram*/
+//	else
+//		attr = 0x2800293;
+	this_dma_handle = dma_map_single(NULL, mainbuf, pagesize,
+					 DMA_FROM_DEVICE);
+	NAND_Config_Start_DMA(0, this_dma_handle, pagesize);
+
+	/*wait cmd fifo free*/
+	ret = _wait_cmdfifo_free();
+	if (ret) {
+		dma_unmap_single(NULL, this_dma_handle, pagesize, DMA_FROM_DEVICE);
+		return ret;
+	}
+
+	/*set NFC_REG_CNT*/
+	NFC_WRITE_REG(NFC_REG_CNT,1024);
+
+	/*set NFC_REG_RCMD_SET*/
+	cfg = 0;
+	cfg |= (read_data_cmd & 0xff);
+	cfg |= ((random_read_cmd0 & 0xff) << 8);
+	cfg |= ((random_read_cmd1 & 0xff) << 16);
+	NFC_WRITE_REG(NFC_REG_RCMD_SET, cfg);
+
+	/*set NFC_REG_SECTOR_NUM*/
+	NFC_WRITE_REG(NFC_REG_SECTOR_NUM, pagesize/1024);
+
+	/*set addr*/
+	_set_addr(read_addr_cmd->addr,read_addr_cmd->addr_cycle);
+
+	/*set NFC_REG_CMD*/
+	cfg  = 0;
+	cfg |= read_addr_cmd->value;
+	/*set sequence mode*/
+	cfg |= 0x1<<25;
+	cfg |= ( (read_addr_cmd->addr_cycle - 1) << 16);
+	cfg |= (NFC_SEND_ADR | NFC_DATA_TRANS | NFC_SEND_CMD1 | NFC_SEND_CMD2 | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD);
+	cfg |= ((__u32)0x2 << 30);//page command
+
+	if (pagesize/1024 == 1)
+		cfg |= NFC_SEQ;
+
+	/*enable ecc*/
+	_enable_ecc(1);
+
+	/*set ecc to 24-bit ecc*/
+    ecc_mode_temp = NFC_READ_REG(NFC_REG_ECC_CTL) & 0xf000;
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, ((NFC_READ_REG(NFC_REG_ECC_CTL) & (~NFC_ECC_MODE))|(0x1<<12)));
+
+	NFC_WRITE_REG(NFC_REG_CMD,cfg);
+
+    NAND_WaitDmaFinish();
+
+	/*wait cmd fifo free and cmd finish*/
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+
+	dma_unmap_single(NULL, this_dma_handle, pagesize, DMA_FROM_DEVICE);
+
+	if (ret){
+		_disable_ecc();
+		return ret;
+	}
+	/*get user data*/
+	for (i = 0; i < pagesize/1024;  i++){
+		*(((__u32*) sparebuf)+i) = NFC_READ_REG(NFC_REG_USER_DATA(i));
+	}
+
+	/*ecc check and disable ecc*/
+	ret = _check_ecc(pagesize/1024);
+	_disable_ecc();
+
+    /*set ecc to original value*/
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, (NFC_READ_REG(NFC_REG_ECC_CTL) & (~NFC_ECC_MODE))|ecc_mode_temp);
+
+	return ret;
+}
+
+
+__s32 _read_in_page_mode_1K(NFC_CMD_LIST  *rcmd,void *mainbuf,void *sparebuf,__u8 dma_wait_mode)
+{
+	__s32 ret;
+	__s32 i;
+	__u32 cfg;
+	NFC_CMD_LIST *cur_cmd,*read_addr_cmd;
+	__u32 read_data_cmd,random_read_cmd0,random_read_cmd1;
+	__u32 page_size_temp, ecc_mode_temp;
+	dma_addr_t this_dma_handle;
+
+	ret = 0;
+	read_addr_cmd = rcmd;
+	cur_cmd = rcmd;
+	cur_cmd = cur_cmd->next;
+	random_read_cmd0 = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	random_read_cmd1 = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	read_data_cmd = cur_cmd->value;
+
+	//access NFC internal RAM by DMA bus
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | NFC_RAM_METHOD);
+
+	//set pagesize to 1K
+      page_size_temp = (NFC_READ_REG(NFC_REG_CTL) & 0xf00)>>8;
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | (0x3<<8));
+
+	///*set dma and run*/
+	///*sdram*/
+	//if (NFC_IS_SDRAM((__u32)mainbuf))
+	//	attr = 0x2810293;
+	///*sram*/
+	//else
+	//	attr = 0x2800293;
+	this_dma_handle = dma_map_single(NULL, mainbuf, 1024,
+					 DMA_FROM_DEVICE);
+	NAND_Config_Start_DMA(0, this_dma_handle, 1024);
+
+	/*wait cmd fifo free*/
+	ret = _wait_cmdfifo_free();
+	if (ret) {
+		dma_unmap_single(NULL, this_dma_handle, 1024, DMA_FROM_DEVICE);
+		return ret;
+	}
+
+	/*set NFC_REG_CNT*/
+	NFC_WRITE_REG(NFC_REG_CNT,1024);
+
+	/*set NFC_REG_RCMD_SET*/
+	cfg = 0;
+	cfg |= (read_data_cmd & 0xff);
+	cfg |= ((random_read_cmd0 & 0xff) << 8);
+	cfg |= ((random_read_cmd1 & 0xff) << 16);
+	NFC_WRITE_REG(NFC_REG_RCMD_SET, cfg);
+
+	/*set NFC_REG_SECTOR_NUM*/
+	NFC_WRITE_REG(NFC_REG_SECTOR_NUM, 1024/1024);
+
+	/*set addr*/
+	_set_addr(read_addr_cmd->addr,read_addr_cmd->addr_cycle);
+
+	/*set NFC_REG_CMD*/
+	cfg  = 0;
+	cfg |= read_addr_cmd->value;
+	/*set sequence mode*/
+	cfg |= 0x1<<25;
+	cfg |= ( (read_addr_cmd->addr_cycle - 1) << 16);
+	cfg |= (NFC_SEND_ADR | NFC_DATA_TRANS | NFC_SEND_CMD1 | NFC_SEND_CMD2 | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD);
+	cfg |= ((__u32)0x2 << 30);//page command
+
+	if (1024/1024 == 1)
+		cfg |= NFC_SEQ;
+
+	/*enable ecc*/
+	_enable_ecc(1);
+
+	/*set ecc to 64-bit ecc*/
+    ecc_mode_temp = NFC_READ_REG(NFC_REG_ECC_CTL) & 0xf000;
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, ((NFC_READ_REG(NFC_REG_ECC_CTL) & (~NFC_ECC_MODE))|(0x8<<12) ));
+
+	NFC_WRITE_REG(NFC_REG_CMD,cfg);
+
+    NAND_WaitDmaFinish();
+
+	/*wait cmd fifo free and cmd finish*/
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+
+	dma_unmap_single(NULL, this_dma_handle, 1024, DMA_FROM_DEVICE);
+
+	if (ret){
+		_disable_ecc();
+		return ret;
+	}
+	/*get user data*/
+	for (i = 0; i < 1024/1024;  i++){
+		*(((__u32*) sparebuf)+i) = NFC_READ_REG(NFC_REG_USER_DATA(i));
+	}
+
+	/*ecc check and disable ecc*/
+	ret = _check_ecc(pagesize/1024);
+	_disable_ecc();
+
+	/*set ecc to original value*/
+	NFC_WRITE_REG(NFC_REG_ECC_CTL, (NFC_READ_REG(NFC_REG_ECC_CTL) & (~NFC_ECC_MODE))|ecc_mode_temp);
+
+    /*set pagesize to original value*/
+    NFC_WRITE_REG(NFC_REG_CTL, ((NFC_READ_REG(NFC_REG_CTL)) & (~NFC_PAGE_SIZE)) | (page_size_temp<<8));
+
+	return ret;
+}
+
+
+__s32 _read_in_page_mode_spare(NFC_CMD_LIST  *rcmd,void *mainbuf,void *sparebuf,__u8 dma_wait_mode)
+{
+	__s32 ret;
+	__s32 i;
+	__u32 cfg;
+	NFC_CMD_LIST *cur_cmd,*read_addr_cmd;
+	__u32 read_data_cmd,random_read_cmd0,random_read_cmd1;
+	dma_addr_t this_dma_handle;
+
+	ret = 0;
+	read_addr_cmd = rcmd;
+	cur_cmd = rcmd;
+	cur_cmd = cur_cmd->next;
+	random_read_cmd0 = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	random_read_cmd1 = cur_cmd->value;
+	cur_cmd = cur_cmd->next;
+	read_data_cmd = cur_cmd->value;
+
+	//access NFC internal RAM by DMA bus
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) | NFC_RAM_METHOD);
+
+
+	///*set dma and run*/
+	///*sdram*/
+	//if (NFC_IS_SDRAM((__u32)mainbuf))
+	//	attr = 0x2810293;
+	///*sram*/
+	//else
+	//	attr = 0x2800293;
+	this_dma_handle = dma_map_single(NULL, mainbuf, 2048,
+					 DMA_FROM_DEVICE);
+	NAND_Config_Start_DMA(0, this_dma_handle, 2048);
+
+	/*wait cmd fifo free*/
+	ret = _wait_cmdfifo_free();
+	if (ret) {
+		dma_unmap_single(NULL, this_dma_handle, 2048, DMA_FROM_DEVICE);
+		return ret;
+	}
+
+	/*set NFC_REG_CNT*/
+	NFC_WRITE_REG(NFC_REG_CNT,1024);
+
+	/*set NFC_REG_RCMD_SET*/
+	cfg = 0;
+	cfg |= (read_data_cmd & 0xff);
+	cfg |= ((random_read_cmd0 & 0xff) << 8);
+	cfg |= ((random_read_cmd1 & 0xff) << 16);
+	NFC_WRITE_REG(NFC_REG_RCMD_SET, cfg);
+
+	/*set NFC_REG_SECTOR_NUM*/
+	NFC_WRITE_REG(NFC_REG_SECTOR_NUM, 2048/1024);
+
+	/*set addr*/
+	_set_addr(read_addr_cmd->addr,read_addr_cmd->addr_cycle);
+
+	/*set NFC_REG_CMD*/
+	cfg  = 0;
+	cfg |= read_addr_cmd->value;
+	/*set sequence mode*/
+	//cfg |= 0x1<<25;
+	cfg |= ( (read_addr_cmd->addr_cycle - 1) << 16);
+	cfg |= (NFC_SEND_ADR | NFC_DATA_TRANS | NFC_SEND_CMD1 | NFC_SEND_CMD2 | NFC_WAIT_FLAG | NFC_DATA_SWAP_METHOD);
+	cfg |= ((__u32)0x2 << 30);//page command
+
+	if (pagesize/1024 == 1)
+		cfg |= NFC_SEQ;
+
+	/*enable ecc*/
+	_enable_ecc(1);
+	NFC_WRITE_REG(NFC_REG_CMD,cfg);
+
+    NAND_WaitDmaFinish();//
+
+	/*wait cmd fifo free and cmd finish*/
+	ret = _wait_cmdfifo_free();
+	ret |= _wait_cmd_finish();
+
+	dma_unmap_single(NULL, this_dma_handle, 2048, DMA_FROM_DEVICE);
+
+	if (ret){
+		_disable_ecc();
+		return ret;
+	}
+	/*get user data*/
+	for (i = 0; i < 2048/1024;  i++){
+		*(((__u32*) sparebuf)+i) = NFC_READ_REG(NFC_REG_USER_DATA(i));
+	}
+
+	/*ecc check and disable ecc*/
+	ret = _check_ecc(2048/1024);
+	_disable_ecc();
+
+	return ret;
+}
+
+
+
+__s32 NFC_Read_Seq(NFC_CMD_LIST  *rcmd, void *mainbuf, void *sparebuf, __u8 dma_wait_mode,__u8 page_mode )
+{
+
+	__s32 ret ;
+
+	_enter_nand_critical();
+
+	ret = _read_in_page_mode_seq(rcmd, mainbuf,sparebuf, dma_wait_mode);
+
+	/*switch to ahb*/
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) & (~NFC_RAM_METHOD));
+
+	_exit_nand_critical();
+
+
+	return ret;
+}
+
+__s32 NFC_Read_1K(NFC_CMD_LIST  *rcmd, void *mainbuf, void *sparebuf, __u8 dma_wait_mode,__u8 page_mode )
+{
+
+	__s32 ret ;
+
+	_enter_nand_critical();
+
+	ret = _read_in_page_mode_1K(rcmd, mainbuf,sparebuf, dma_wait_mode);
+
+	/*switch to ahb*/
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) & (~NFC_RAM_METHOD));
+
+	_exit_nand_critical();
+
+
+	return ret;
+}
+
+__s32 NFC_Read_Spare(NFC_CMD_LIST  *rcmd, void *mainbuf, void *sparebuf, __u8 dma_wait_mode,__u8 page_mode )
+{
+
+	__s32 ret ;
+
+	_enter_nand_critical();
+
+	ret = _read_in_page_mode_spare(rcmd, mainbuf,sparebuf, dma_wait_mode);
+
+	/*switch to ahb*/
+	NFC_WRITE_REG(NFC_REG_CTL, (NFC_READ_REG(NFC_REG_CTL)) & (~NFC_RAM_METHOD));
+
+	_exit_nand_critical();
+
+
+	return ret;
+}
+
+__s32 NFC_LSBInit(__u32 read_retry_type)
+{
+	//init
+	read_retry_mode = (read_retry_type>>16)&0xff;
+	read_retry_cycle =(read_retry_type>>8)&0xff;
+	read_retry_reg_num = (read_retry_type>>0)&0xff;
+
+	if(read_retry_mode == 1) //mode1
+	{
+		//set lsb mode
+		lsb_mode_reg_num = 5;
+
+		lsb_mode_reg_adr[0] = 0xa4;
+		lsb_mode_reg_adr[1] = 0xa5;
+		lsb_mode_reg_adr[2] = 0xb0;
+		lsb_mode_reg_adr[3] = 0xb1;
+		lsb_mode_reg_adr[4] = 0xc9;
+
+		lsb_mode_val[0] = 0x25;
+		lsb_mode_val[1] = 0x25;
+		lsb_mode_val[2] = 0x25;
+		lsb_mode_val[3] = 0x25;
+		lsb_mode_val[4] = 0x1;
+	}
+	else
+	{
+	    return -1;
+	}
+
+	return 0;
+}
+
+__s32 LSB_GetDefaultParam(__u32 chip,__u8* default_value, __u32 read_retry_type)
+{
+    __s32 ret;
+    __u32 i;
+
+    ret =_vender_get_param(&lsb_mode_default_val[0], &lsb_mode_reg_adr[0], lsb_mode_reg_num);
+    for(i=0; i<lsb_mode_reg_num; i++)
+    {
+        default_value[i] = lsb_mode_default_val[i];
+    }
+
+	return ret;
+
+}
+
+__s32 LSB_SetDefaultParam(__u32 chip,__u8* default_value, __u32 read_retry_type)
+{
+    __s32 ret;
+
+    ret =_vender_set_param(&lsb_mode_default_val[0], &lsb_mode_reg_adr[0], lsb_mode_reg_num);
+
+	return ret;
+}
+
+__s32 NFC_LSBEnable(__u32 chip, __u32 read_retry_type)
+{
+    __u8 value[LSB_MODE_MAX_REG_NUM];
+    __u32 i;
+
+    //fix chip 0
+    LSB_GetDefaultParam(0,value,read_retry_type);
+    for(i=0;i<lsb_mode_reg_num;i++)
+        value[i] += lsb_mode_val[i];
+
+    _vender_set_param(value, &lsb_mode_reg_adr[0], lsb_mode_reg_num);
+
+    return 0;
+}
+
+__s32 NFC_LSBDisable(__u32 chip, __u32 read_retry_type)
+{
+    __u8 value[LSB_MODE_MAX_REG_NUM];
+
+    //fix chip 0
+    LSB_SetDefaultParam(0,value, read_retry_type);
+
+    return 0;
+}
+
+__s32 NFC_LSBExit(__u32 read_retry_type)
+{
+
+	return 0;
+}
+
diff --git a/drivers/block/sunxi_nand/nfd/Makefile b/drivers/block/sunxi_nand/nfd/Makefile
new file mode 100644
index 0000000..32507e6
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfd/Makefile
@@ -0,0 +1,10 @@
+
+obj-$(CONFIG_SUNXI_NAND)  += nand.o
+nand-y := nand_blk.o  dma_for_nand.o int_for_nand.o \
+         ../src/format/nand_format.o \
+         ../src/logic/bad_manage.o ../src/logic/logic_ctl.o ../src/logic/mapping.o ../src/logic/mapping_base.o ../src/logic/merge.o ../src/logic/read_reclaim.o ../src/logic/wear_levelling.o ../src/logic/logic_cache.o \
+         ../src/scan/nand_scan.o ../src/scan/nand_id.o\
+         ../src/physic/nand_phy.o ../src/physic/nand_simple_r.o ../src/physic/nand_simple_w.o \
+         ../nfc/nfc_r.o ../nfc/nfc_w.o
+
+
diff --git a/drivers/block/sunxi_nand/nfd/clk_for_nand.c b/drivers/block/sunxi_nand/nfd/clk_for_nand.c
new file mode 100644
index 0000000..156a150
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfd/clk_for_nand.c
@@ -0,0 +1,202 @@
+/*
+ * drivers/block/sunxi_nand/nfd/clk_for_nand.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "nand_private.h"
+
+extern struct __NandDriverGlobal_t NandDriverInfo;
+
+//__krnl_event_t      *nand_clk_adjust_sem;
+static __hdle       h_nandmclk, h_nandahbclk, h_dram_access;
+static __u32        clk_adjust_lock;
+
+
+__s32 NAND_SetClk(__u32 nand_clk)
+{
+
+//	__u32 ahb_clk, cmu_clk;
+//	__u32 edo_clk;
+//	__u32 nand_clk_divid_ratio;
+//
+//	/*get cmu clk and ahb clk*/
+//	cmu_clk = 270 * 1000000;
+//	//ahb_clk = esCLK_GetSrcFreq(CCMU_SCLK_AHBCLK);
+//	ahb_clk = 120*1000000;
+//
+//	/*configure nand clock divid ratio*/
+//	edo_clk = nand_clk * 2 * 1000000;
+//	nand_clk_divid_ratio = vedio_clk/ edo_clk;
+//	if (nand_clk_divid_ratio){
+//		if (vedio_clk % edo_clk)
+//			nand_clk_divid_ratio++;
+//		if (nand_clk_divid_ratio > 16)
+//			nand_clk_divid_ratio = 16;
+//	}
+//	else
+//	{
+//		nand_clk_divid_ratio = 1;
+//	}
+//
+//	/*ahb clk must be above nfc clk*/
+//	while (ahb_clk <= ((vedio_clk>> 1)/nand_clk_divid_ratio))
+//	{
+//		nand_clk_divid_ratio++;
+//	}
+//	if (nand_clk_divid_ratio > 16)
+//	{
+//		//__wrn("ahb clk less than nfc clk : cmu clk = %dM,ahb clk = %dM, nand clk = %dM\n",
+//		//	cmu_clk,ahb_clk,(cmu_clk >> 1)/nand_clk_divid_ratio);
+//		return EPDK_FALSE;
+//	}
+//
+//	//__inf("nand clock divid ratio = %d\n",nand_clk_divid_ratio);
+//
+//	/*set divid ratio*/
+//	//nand_clk_divid_ratio--;
+//	//eLIBs_printf("nand clock divid ratio = %d\n",nand_clk_divid_ratio);
+//	esCLK_SetFreq(h_nandmclk, CCMU_SCLK_VIDEOPLL, nand_clk_divid_ratio);
+//    esCLK_OnOff(h_nandmclk, CLK_ON);
+//	esCLK_OnOff(h_nandahbclk, CLK_ON);
+
+	return EPDK_OK;
+}
+
+
+__s32 cb_NAND_ClockChange(__u32 cmd, __s32 aux)
+{
+//    __s32       cpu_sr;
+//
+//    switch(cmd)
+//    {
+//        case CLK_CMD_SCLKCHG_REQ:
+//        {
+//            __u8    err;
+//            __u32   tmpLock;
+//
+//            ENTER_CRITICAL(cpu_sr);
+//            tmpLock = clk_adjust_lock;
+//            clk_adjust_lock++;
+//            EXIT_CRITICAL(cpu_sr);
+//
+//            if(!tmpLock)
+//            {
+//                /*wait current op finished*/
+//                esKRNL_SemPend(nand_clk_adjust_sem,0,&err);
+//            }
+//
+//            return EPDK_OK;
+//        }
+//
+//        case CLK_CMD_SCLKCHG_DONE:
+//        {
+//            __u32   tmpLock;
+//
+//            ENTER_CRITICAL(cpu_sr);
+//            clk_adjust_lock--;
+//            tmpLock = clk_adjust_lock;
+//            EXIT_CRITICAL(cpu_sr);
+//
+//            if(!tmpLock)
+//            {
+//                /*configure frequency*/
+//                NAND_SetClk(NandStorageInfo.FrequencePar);
+//                /*reset nand control machine*/
+//                PHY_ChangeMode(1);
+//                /*release sem*/
+//                esKRNL_SemPost(nand_clk_adjust_sem);
+//            }
+//            return EPDK_OK;
+//        }
+//
+//        default:
+//        {
+//            break;
+//        }
+//    }
+
+    return EPDK_FAIL;
+}
+
+
+__s32 cb_NAND_DMA_DramAccess(__u32 cmd, __s32 aux)
+{
+//    __u8    err;
+//
+//    switch(cmd)
+//    {
+//        case CLK_CMD_SCLKCHG_REQ:
+//        {
+//            esKRNL_SemPend(nand_clk_adjust_sem,0,&err);
+//            return EPDK_OK;
+//        }
+//
+//        case CLK_CMD_SCLKCHG_DONE:
+//        {
+//            esKRNL_SemPost(nand_clk_adjust_sem);
+//            return EPDK_OK;
+//        }
+//
+//        default:
+//        {
+//            break;
+//        }
+//    }
+
+    return EPDK_FAIL;
+}
+
+
+__s32 NAND_OpenClk(void)
+{
+//	__u8 err;
+//	/*create sem*/
+//	nand_clk_adjust_sem = esKRNL_SemCreate(1);
+//
+//	/*open 320 clk*/
+//	h_nandmclk  = esCLK_Open(CCMU_MCLK_NAND, cb_NAND_ClockChange, &err);
+//	h_nandahbclk = esCLK_Open(CCMU_MCLK_AHB_NAND, cb_NAND_ClockChange, &err);
+//    //register dram access for dma
+//    h_dram_access = esMEM_RegDramAccess(DRAM_DEVICE_DMA, cb_NAND_DMA_DramAccess);
+//
+//    clk_adjust_lock = 0;
+
+	return EPDK_OK;
+}
+__s32 NAND_CloseClk(void)
+{
+//	__u8 err;
+//
+//    clk_adjust_lock = 0;
+//
+//    if(h_dram_access)
+//    {
+//        esMEM_UnRegDramAccess(h_dram_access);
+//        h_dram_access = 0;
+//    }
+//	esKRNL_SemDel(nand_clk_adjust_sem,OS_DEL_ALWAYS,&err);
+//	esCLK_Close(h_nandmclk);
+//	esCLK_Close(h_nandahbclk);
+
+	return EPDK_OK;
+}
+
+
+
diff --git a/drivers/block/sunxi_nand/nfd/dma_for_nand.c b/drivers/block/sunxi_nand/nfd/dma_for_nand.c
new file mode 100644
index 0000000..fa490c5
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfd/dma_for_nand.c
@@ -0,0 +1,137 @@
+/*
+ * drivers/block/sunxi_nand/nfd/dma_for_nand.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+//#include "nand_oal.h"
+#include "nand_private.h"
+#include <plat/dma_compat.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <asm/cacheflush.h>
+
+#define DMA_HALF_INT_MASK       (1<<0)
+#define DMA_END_INT_MASK        (1<<1)
+
+#define NAND_DMA_TIMEOUT 20000 /*20 sec*/
+
+static int nanddma_completed_flag = 1;
+static DECLARE_WAIT_QUEUE_HEAD(DMA_wait);
+
+struct sunxi_dma_params nand_dma = {
+	.client.name="NAND_DMA",
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	.channel = DMACH_DNAND,
+#endif
+	.dma_addr = 0x01c03030,
+};
+
+void nanddma_buffdone(struct sunxi_dma_params *dma, void *dev_id)
+{
+	nanddma_completed_flag = 1;
+	wake_up( &DMA_wait );
+}
+
+__hdle NAND_RequestDMA  (__u32 dmatype)
+{
+	int r;
+
+	r = sunxi_dma_request(&nand_dma, 1);
+	if (r < 0)
+		return r;
+
+	r = sunxi_dma_set_callback(&nand_dma, nanddma_buffdone, NULL);
+	if (r < 0)
+		return r;
+
+	return 1;
+}
+
+__s32  NAND_ReleaseDMA  (__hdle hDma)
+{
+	return 0;
+}
+
+void NAND_Config_Start_DMA(__u8 rw, dma_addr_t buff_addr, __u32 len)
+{
+#if defined CONFIG_ARCH_SUN4I || defined CONFIG_ARCH_SUN5I
+	struct dma_hw_conf nand_hwconf = {
+		.xfer_type = DMAXFER_D_BWORD_S_BWORD,
+		.hf_irq = SW_DMA_IRQ_FULL,
+	};
+
+	nand_hwconf.dir = rw+1;
+
+	if(rw == 0){
+		nand_hwconf.from = 0x01C03030,
+		nand_hwconf.address_type = DMAADDRT_D_LN_S_IO,
+		nand_hwconf.drqsrc_type = DRQ_TYPE_NAND;
+	} else {
+		nand_hwconf.to = 0x01C03030,
+		nand_hwconf.address_type = DMAADDRT_D_IO_S_LN,
+		nand_hwconf.drqdst_type = DRQ_TYPE_NAND;
+	}
+
+	sw_dma_setflags(DMACH_DNAND, SW_DMAF_AUTOSTART);
+#else
+	static int dma_started = 0;
+
+	dma_config_t nand_hwconf = {
+		.xfer_type.src_data_width	= DATA_WIDTH_32BIT,
+		.xfer_type.src_bst_len		= DATA_BRST_4,
+		.xfer_type.dst_data_width	= DATA_WIDTH_32BIT,
+		.xfer_type.dst_bst_len		= DATA_BRST_4,
+		.bconti_mode			= false,
+		.irq_spt			= CHAN_IRQ_FD,
+	};
+
+	if(rw == 0) {
+		nand_hwconf.address_type.src_addr_mode	= DDMA_ADDR_IO; 
+		nand_hwconf.address_type.dst_addr_mode	= DDMA_ADDR_LINEAR;
+		nand_hwconf.src_drq_type		= D_DST_NAND;
+		nand_hwconf.dst_drq_type		= D_DST_SDRAM;
+	} else {
+		nand_hwconf.address_type.src_addr_mode	= DDMA_ADDR_LINEAR;
+		nand_hwconf.address_type.dst_addr_mode	= DDMA_ADDR_IO;
+		nand_hwconf.src_drq_type		= D_DST_SDRAM;
+		nand_hwconf.dst_drq_type		= D_DST_NAND;
+	}
+#endif
+	sunxi_dma_config(&nand_dma, &nand_hwconf, 0x7f077f07);
+
+	nanddma_completed_flag = 0;
+	sunxi_dma_enqueue(&nand_dma, buff_addr, len, rw == 0);
+#if !defined CONFIG_ARCH_SUN4I && !defined CONFIG_ARCH_SUN5I
+	/* No auto-start, start manually */
+	if (!dma_started) {
+		sunxi_dma_start(&nand_dma);
+		dma_started = 1;
+	}
+#endif
+}
+
+__s32 NAND_WaitDmaFinish(void)
+{
+	int ret = wait_event_timeout(DMA_wait, nanddma_completed_flag,\
+			msecs_to_jiffies(NAND_DMA_TIMEOUT));
+	if (!ret)
+		pr_err("sunxi:nand: Dma operation finish timeout\n");
+	return ret;
+}
diff --git a/drivers/block/sunxi_nand/nfd/int_for_nand.c b/drivers/block/sunxi_nand/nfd/int_for_nand.c
new file mode 100644
index 0000000..050379f
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfd/int_for_nand.c
@@ -0,0 +1,167 @@
+/*
+ * drivers/block/sunxi_nand/nfd/int_for_nand.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "nand_private.h"
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include "../nfc/nfc.h"
+#include "../nfc/nfc_i.h"
+
+static int nandrb_ready_flag = 1;
+static DECLARE_WAIT_QUEUE_HEAD(NAND_RB_WAIT);
+
+//#define RB_INT_MSG_ON
+#ifdef  RB_INT_MSG_ON
+#define dbg_rbint(fmt, args...) printk(fmt, ## args)
+#else
+#define dbg_rbint(fmt, ...)  ({})
+#endif
+
+//#define RB_INT_WRN_ON
+#ifdef  RB_INT_WRN_ON
+#define dbg_rbint_wrn(fmt, args...) printk(fmt, ## args)
+#else
+#define dbg_rbint_wrn(fmt, ...)  ({})
+#endif
+
+
+void NAND_EnRbInt(void)
+{
+	//clear interrupt
+	NFC_WRITE_REG(NFC_REG_ST,NFC_RB_B2R);
+	if(NFC_READ_REG(NFC_REG_ST)&NFC_RB_B2R)
+	{
+		dbg_rbint_wrn("nand clear rb int status error in int enable \n");
+		dbg_rbint_wrn("rb status: 0x%x\n", NFC_READ_REG(NFC_REG_ST));
+	}
+
+	nandrb_ready_flag = 0;
+
+	//enable interrupt
+	NFC_WRITE_REG(NFC_REG_INT, NFC_B2R_INT_ENABLE);
+
+	dbg_rbint("rb int en\n");
+}
+
+
+void NAND_ClearRbInt(void)
+{
+
+	//disable interrupt
+	NFC_WRITE_REG(NFC_REG_INT, 0);
+
+	dbg_rbint("rb int clear\n");
+
+	//clear interrupt
+	NFC_WRITE_REG(NFC_REG_ST,NFC_READ_REG(NFC_REG_ST));
+	if(NFC_READ_REG(NFC_REG_ST)&NFC_RB_B2R)
+	{
+		dbg_rbint_wrn("nand clear rb int status error in int clear \n");
+		dbg_rbint_wrn("rb status: 0x%x\n", NFC_READ_REG(NFC_REG_ST));
+	}
+
+	nandrb_ready_flag = 0;
+}
+
+
+void NAND_RbInterrupt(void)
+{
+
+	dbg_rbint("rb int occor! \n");
+	if(!(NFC_READ_REG(NFC_REG_ST)&NFC_RB_B2R))
+	{
+		dbg_rbint_wrn("nand rb int late, rb status: 0x%x, rb int en: 0x%x \n",NFC_READ_REG(NFC_REG_ST),NFC_READ_REG(NFC_REG_INT));
+	}
+
+    NAND_ClearRbInt();
+
+    nandrb_ready_flag = 1;
+	wake_up( &NAND_RB_WAIT );
+
+}
+
+
+__s32 NAND_WaitRbReady(void)
+{
+	__u32 rb;
+
+	NAND_EnRbInt();
+
+	//wait_event(NAND_RB_WAIT, nandrb_ready_flag);
+	dbg_rbint("rb wait, nfc_ctl: 0x%x, rb status: 0x%x, rb int en: 0x%x\n", NFC_READ_REG(NFC_REG_CTL), NFC_READ_REG(NFC_REG_ST), NFC_READ_REG(NFC_REG_INT));
+
+	if(nandrb_ready_flag)
+	{
+		dbg_rbint("fast rb int\n");
+		NAND_ClearRbInt();
+		return 0;
+	}
+
+	rb=  ( NFC_READ_REG(NFC_REG_CTL) & NFC_RB_SEL ) >>3;
+	if(!rb)
+	{
+		if(NFC_READ_REG(NFC_REG_ST) & NFC_RB_STATE0)
+		{
+			dbg_rbint_wrn("rb0 fast ready \n");
+			dbg_rbint_wrn("nfc_ctl: 0x%x, rb status: 0x%x, rb int en: 0x%x\n", NFC_READ_REG(NFC_REG_CTL), NFC_READ_REG(NFC_REG_ST), NFC_READ_REG(NFC_REG_INT));
+			NAND_ClearRbInt();
+			return 0;
+		}
+
+	}
+	else
+	{
+		if(NFC_READ_REG(NFC_REG_ST) & NFC_RB_STATE1)
+		{
+			dbg_rbint_wrn("rb1 fast ready \n");
+			dbg_rbint_wrn("nfc_ctl: 0x%x, rb status: 0x%x, rb int en: 0x%x\n", NFC_READ_REG(NFC_REG_CTL), NFC_READ_REG(NFC_REG_ST), NFC_READ_REG(NFC_REG_INT));
+			NAND_ClearRbInt();
+			return 0;
+		}
+	}
+
+	if(wait_event_timeout(NAND_RB_WAIT, nandrb_ready_flag, 1*HZ)==0)
+	{
+		dbg_rbint_wrn("nand wait rb ready time out\n");
+		dbg_rbint_wrn("rb wait time out, nfc_ctl: 0x%x, rb status: 0x%x, rb int en: 0x%x\n", NFC_READ_REG(NFC_REG_CTL), NFC_READ_REG(NFC_REG_ST), NFC_READ_REG(NFC_REG_INT));
+		NAND_ClearRbInt();
+	}
+	else
+	{
+		dbg_rbint("nand wait rb ready ok\n");
+	}
+
+    return 0;
+}
+
+/*
+__s32 NAND_WaitRbReady(void)
+{
+
+	//wait_event(NAND_RB_WAIT, nandrb_ready_flag);
+	printk("rb wait, nfc_ctl: 0x%x, rb status:0x%x, rb int en: 0x%x\n", NFC_READ_REG(NFC_REG_CTL), NFC_READ_REG(NFC_REG_ST), NFC_READ_REG(NFC_REG_INT));
+    wait_event(NAND_RB_WAIT, nandrb_ready_flag);
+	printk("rb wait ok\n");
+
+    return 0;
+}
+*/
diff --git a/drivers/block/sunxi_nand/nfd/nand_blk.c b/drivers/block/sunxi_nand/nfd/nand_blk.c
new file mode 100644
index 0000000..a632453
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfd/nand_blk.c
@@ -0,0 +1,1529 @@
+/*
+ * drivers/block/sunxi_nand/nfd/nand_blk.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/blkpg.h>
+#include <linux/spinlock.h>
+#include <linux/hdreg.h>
+#include <linux/init.h>
+#include <linux/semaphore.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include "../src/include/nand_type.h"
+#include "../src/include/nand_drv_cfg.h"
+#include "../nfc/nfc_i.h"
+#include "nand_blk.h"
+#include <mach/clock.h>
+#include <plat/sys_config.h>
+
+#include "nand_private.h"
+#include "../include/type_def.h"
+#include "../nandtest/nand_test.h"
+
+#include "nand_private.h"
+#include <linux/wait.h>
+#include <linux/sched.h>
+
+#define BLK_ERR_MSG_ON
+#ifdef  BLK_ERR_MSG_ON
+#define dbg_err(fmt, args...) printk("[NAND]"fmt, ## args)
+#else
+#define dbg_err(fmt, ...)  ({})
+#endif
+
+
+//#define BLK_INFO_MSG_ON
+#ifdef  BLK_INFO_MSG_ON
+#define dbg_inf(fmt, args...) printk("[NAND]"fmt, ## args)
+#else
+#define dbg_inf(fmt, ...)  ({})
+#endif
+
+
+#define REMAIN_SPACE 0
+#define PART_FREE 0x55
+#define PART_DUMMY 0xff
+#define PART_READONLY 0x85
+#define PART_WRITEONLY 0x86
+#define PART_NO_ACCESS 0x87
+
+#define TIMEOUT 				1			// per second
+
+#define NAND_CACHE_FLUSH_EVERY_SEC
+//#define NAND_BIO_ALIGN
+#define NAND_CACHE_RW
+#define USE_SYS_PIN
+//#define USE_SYS_CLK
+
+/**
+*USE_BIO_MERGE level description:
+*1	:	merge bvc in one bio
+*2	:	merge bvc in one bio and merge bios in one request
+*/
+#define USE_BIO_MERGE			2
+#define NAND_TEST_TICK			0
+
+#ifdef NAND_CACHE_FLUSH_EVERY_SEC
+static int after_write = 0;
+
+struct collect_ops{
+		unsigned long timeout;
+		wait_queue_head_t wait;
+		struct completion thread_exit;
+		unsigned char quit;
+};
+struct collect_ops collect_arg;
+
+#endif
+
+
+DEFINE_SEMAPHORE(nand_mutex);
+static unsigned char volatile IS_IDLE = 1;
+u32 nand_handle=0;
+#ifdef USE_SYS_CLK
+static struct clk *ahb_nand_clk = NULL;
+static struct clk *mod_nand_clk = NULL;
+#endif
+static int nand_flush(struct nand_blk_dev *dev);
+
+spinlock_t     nand_rb_lock;
+
+static irqreturn_t nand_rb_interrupt(int irq, void *dev_id)
+{
+    unsigned long iflags;
+
+    spin_lock_irqsave(&nand_rb_lock, iflags);
+    NAND_RbInterrupt();
+    spin_unlock_irqrestore(&nand_rb_lock, iflags);
+
+	return IRQ_HANDLED;
+}
+
+
+
+
+#if USE_BIO_MERGE==0
+static int cache_align_page_request(struct nand_blk_ops * nandr, struct nand_blk_dev * dev, struct request * req)
+{
+	unsigned long start,nsector;
+	char *buf;
+	__s32 ret;
+
+	int cmd = rq_data_dir(req);
+
+	if(dev->disable_access || ( (cmd == WRITE) && (dev->readonly) ) \
+		|| ((cmd == READ) && (dev->writeonly))){
+		dbg_err("can not access this part\n");
+
+		return -EIO;
+	}
+
+
+	//for2.6.36
+	buf = req->buffer;
+	start = blk_rq_pos(req);
+	nsector = blk_rq_cur_bytes(req)>>9;
+
+	if ( (start + nsector) > get_capacity(req->rq_disk))
+	{
+		dbg_err("over the limit of disk\n");
+
+		return -EIO;
+	}
+	start += dev->off_size;
+
+	switch(cmd) {
+
+	case READ:
+
+		dbg_inf("READ:%lu from %lu\n",nsector,start);
+
+		#ifndef NAND_CACHE_RW
+			LML_FlushPageCache();
+  		ret = LML_Read(start, nsector, buf);
+		#else
+			//printk("Rs %lu %lu \n",start, nsector);
+      LML_FlushPageCache();
+			ret = NAND_CacheRead(start, nsector, buf);
+			//printk("Rs %lu %lu \n",start, nsector);
+		#endif
+		if (ret)
+		{
+			dbg_err("cache_align_page_request:read err\n");
+			return -EIO;
+
+		}
+		return 0;
+
+
+	case WRITE:
+
+		dbg_inf("WRITE:%lu from %lu\n",nsector,start);
+		#ifndef NAND_CACHE_RW
+			ret = LML_Write(start, nsector, buf);
+		#else
+			//printk("Ws %lu %lu \n",start, nsector);
+			ret = NAND_CacheWrite(start, nsector, buf);
+			//printk("We %lu %lu \n",start, nsector);
+		#endif
+		if (ret)
+		{
+			dbg_err("cache_align_page_request:write err\n");
+			return -EIO;
+		}
+		return 0;
+
+	default:
+		dbg_err("Unknown request \n");
+		return -EIO;
+	}
+
+}
+#endif
+
+//for 2.6.29
+#ifdef NAND_BIO_ALIGN
+static int nand_blk_phys_contig_segment(struct request_queue *q, struct bio *bio, struct bio *nxt)
+{
+	//if (!(q->queue_flags & (1 << QUEUE_FLAG_CLUSTER)))
+	//	return 0;
+
+	if (!BIOVEC_PHYS_MERGEABLE(__BVEC_END(bio), __BVEC_START(nxt)))
+		return 0;
+	if (bio->bi_size + nxt->bi_size > q->limits.max_segment_size)
+		return 0;
+
+	/*
+	 * bio and nxt are contigous in memory, check if the queue allows
+	 * these two to be merged into one
+	 */
+	if (BIO_SEG_BOUNDARY(q, bio, nxt))
+		return 1;
+
+	return 0;
+}
+/* Compute maximal contiguous buffer size. */
+static int nand_buffer_chain_size(struct request *req)
+{
+	struct bio *bio,*prevbio = NULL;
+	struct bio_vec *bv;
+	int i;
+	unsigned long size = 0;
+	char *base=bio_data(req->bio);
+	unsigned int phys_size = 0;
+	struct request_queue *q = req->q;
+
+      __rq_for_each_bio(bio, req) {
+
+		if(prevbio){
+			int pseg = phys_size + prevbio->bi_size + bio->bi_size;
+			if (!nand_blk_phys_contig_segment(q, prevbio, bio) || pseg > q->limits.max_segment_size){
+				break;
+			}
+		}
+
+		bio_for_each_segment(bv, bio, i) {
+                   if (page_address(bv->bv_page) + bv->bv_offset != base + size){
+				break;
+             	}
+                   size += bv->bv_len;
+              }
+		prevbio = bio;
+	}
+	//return size>>9;
+	return size;
+}
+
+static void reset(struct request *req)
+{
+	//req->current_nr_sectors = req->hard_cur_sectors = nand_buffer_chain_size(req);
+	nand_buffer_chain_size(req);
+
+}
+#endif
+
+#if USE_BIO_MERGE
+#define nand_bio_kmap(bio,idx,kmtype)	\
+	(page_address(bio_iovec_idx((bio), (idx))->bv_page) +	bio_iovec_idx((bio), (idx))->bv_offset)
+
+
+
+
+static int nand_transfer(struct nand_blk_dev * dev, unsigned long start,unsigned long nsector, char *buf, int cmd)
+{
+	__s32 ret;
+
+	if(dev->disable_access || ( (cmd == WRITE) && (dev->readonly) ) \
+		|| ((cmd == READ) && (dev->writeonly))){
+		dbg_err("can not access this part\n");
+		return -EIO;
+	}
+	//printk("[N]start=%lx,nsec=%lx,buffer=%p,cmd=%d\n",start,nsector,buf,cmd);
+	start += dev->off_size;
+
+	switch(cmd) {
+
+	case READ:
+        //printk("R %lu %lu 0x%x \n",start, nsector, (__u32)buf);
+		dbg_inf("READ:%lu from %lu\n",nsector,start);
+
+		#ifndef NAND_CACHE_RW
+			LML_FlushPageCache();
+  			ret = LML_Read(start, nsector, buf);
+		#else
+			//printk("Rs %lu %lu \n",start, nsector);
+      		LML_FlushPageCache();
+			ret = NAND_CacheRead(start, nsector, buf);
+			//printk("Rs %lu %lu \n",start, nsector);
+		#endif
+		if (ret)
+		{
+			dbg_err("cache_align_page_request:read err\n");
+			return -EIO;
+
+		}
+		return 0;
+
+
+	case WRITE:
+        //printk("W %lu %lu 0x%x \n",start, nsector, (__u32)buf);
+		dbg_inf("WRITE:%lu from %lu\n",nsector,start);
+		#ifndef NAND_CACHE_RW
+			ret = LML_Write(start, nsector, buf);
+		#else
+			//printk("Ws %lu %lu \n",start, nsector);
+			ret = NAND_CacheWrite(start, nsector, buf);
+			//printk("We %lu %lu \n",start, nsector);
+		#endif
+		if (ret)
+		{
+			dbg_err("cache_align_page_request:write err\n");
+			return -EIO;
+		}
+		return 0;
+
+	default:
+		dbg_err("Unknown request \n");
+		return -EIO;
+	}
+
+}
+#endif
+#if NAND_TEST_TICK
+static unsigned long nand_rw_time = 0;
+#endif
+static int nand_blktrans_thread(void *arg)
+{
+	struct nand_blk_ops *nandr = arg;
+	struct request_queue *rq = nandr->rq;
+	struct request *req = NULL;
+#if NAND_TEST_TICK
+	unsigned long tick=0;
+#endif
+#if USE_BIO_MERGE
+	struct req_iterator rq_iter;
+	struct bio_vec *bvec;
+	unsigned long long sector = ULLONG_MAX;
+	unsigned long rq_len = 0;
+	char *buffer=NULL;
+	int rw_flag = 0;
+#endif
+
+	/* we might get involved when memory gets low, so use PF_MEMALLOC */
+	current->flags |= PF_MEMALLOC | PF_NOFREEZE;
+	daemonize("%sd", nandr->name);
+
+	/* daemonize() doesn't do this for us since some kernel threads
+	   actually want to deal with signals. We can't just call
+	   exit_sighand() since that'll cause an oops when we finally
+	   do exit. */
+	spin_lock_irq(&current->sighand->siglock);
+	sigfillset(&current->blocked);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	spin_lock_irq(rq->queue_lock);
+
+	while (!nandr->quit) {
+
+		struct nand_blk_dev *dev;
+	#if USE_BIO_MERGE == 0
+		int res = 0;
+	#endif
+		DECLARE_WAITQUEUE(wait, current);
+
+		if (!req && !(req = blk_fetch_request(rq))) {
+			//printk("[N]wait req\n");
+			add_wait_queue(&nandr->thread_wq, &wait);
+			set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irq(rq->queue_lock);
+			schedule();
+			spin_lock_irq(rq->queue_lock);
+			remove_wait_queue(&nandr->thread_wq, &wait);
+			continue;
+		}
+
+		dev = req->rq_disk->private_data;
+	#if USE_BIO_MERGE==1
+		//spin_unlock_irq(rq->queue_lock);
+		IS_IDLE = 0;
+		//printk("[N]request start\n");
+		__rq_for_each_bio(rq_iter.bio,req){
+			if(!bio_segments(rq_iter.bio)){
+				continue;
+			}
+			//printk("[N]start bio,count=%d\n",(rq_iter.bio)->bi_vcnt);
+			sector = (rq_iter.bio)->bi_sector;
+			buffer = nand_bio_kmap(rq_iter.bio, (rq_iter.bio)->bi_idx, KM_USER0);
+			bio_for_each_segment(bvec, rq_iter.bio, rq_iter.i){
+				if(rq_iter.i<(rq_iter.bio)->bi_vcnt-1){
+					if(nand_bio_kmap(rq_iter.bio, rq_iter.i+1, KM_USER0) == nand_bio_kmap(rq_iter.bio, rq_iter.i, KM_USER0)+ bvec->bv_len){
+						rq_len += bvec->bv_len;
+						//printk("[N]go on\n");
+					}else{
+						rq_len += bvec->bv_len;
+						spin_unlock_irq(rq->queue_lock);
+						down(&nandr->nand_ops_mutex);
+						#if NAND_TEST_TICK
+						tick = jiffies;
+						nand_transfer(dev, sector, rq_len>>9, buffer, bio_data_dir(rq_iter.bio));
+						nand_rw_time += jiffies - tick;
+						#else
+						nand_transfer(dev, sector, rq_len>>9, buffer, bio_data_dir(rq_iter.bio));
+						#endif
+						up(&nandr->nand_ops_mutex);
+						spin_lock_irq(rq->queue_lock);
+						sector += rq_len>>9;
+						rq_len = 0;
+						buffer = nand_bio_kmap(rq_iter.bio, rq_iter.i+1, KM_USER0);
+					}
+				}else{
+					rq_len += bvec->bv_len;
+					spin_unlock_irq(rq->queue_lock);
+					down(&nandr->nand_ops_mutex);
+					#if NAND_TEST_TICK
+					tick = jiffies;
+					nand_transfer(dev, sector,  rq_len>>9, buffer, bio_data_dir(rq_iter.bio));
+					nand_rw_time += jiffies - tick;
+					#else
+					nand_transfer(dev, sector,  rq_len>>9, buffer, bio_data_dir(rq_iter.bio));
+					#endif
+					up(&nandr->nand_ops_mutex);
+					spin_lock_irq(rq->queue_lock);
+					rq_len=0;
+				}
+			}
+			//printk("[N]end bio...\n");
+		}
+		//printk("[N]request finished\n");
+		#if NAND_TEST_TICK
+		printk("[N]ticks=%ld\n",nand_rw_time);
+		#endif
+
+		//printk("req flags=%x\n",req->cmd_flags);
+		#ifdef NAND_CACHE_FLUSH_EVERY_SEC
+		if(req->cmd_flags&REQ_WRITE)
+			after_write = 1;
+		if(req->cmd_flags&REQ_SYNC){
+			wake_up_interruptible(&collect_arg.wait);
+		}
+		#endif
+
+		//spin_lock_irq(rq->queue_lock);
+		__blk_end_request_all(req,0);
+		req = NULL;
+	#elif USE_BIO_MERGE==2
+		//IS_IDLE = 0;
+
+		rw_flag = req->cmd_flags&REQ_WRITE;
+
+		__rq_for_each_bio(rq_iter.bio,req){
+			if(!bio_segments(rq_iter.bio)){
+				continue;
+			}
+			if(unlikely(sector == ULLONG_MAX)){
+				/*new bio, no data exists*/
+				sector = (rq_iter.bio)->bi_sector;
+			}else{
+				/*last bio data exists*/
+				if((rq_iter.bio)->bi_sector == (sector + (rq_len>>9))){
+					//printk("[N]bio merge\n");
+				}else{
+					/*flush last bio data here*/
+					spin_unlock_irq(rq->queue_lock);
+					down(&nandr->nand_ops_mutex);
+				#if NAND_TEST_TICK
+					tick = jiffies;
+					nand_transfer(dev, sector,  rq_len>>9, buffer, rw_flag);
+					nand_rw_time += jiffies - tick;
+				#else
+					nand_transfer(dev, sector, rq_len>>9, buffer, rw_flag);
+				#endif
+					up(&nandr->nand_ops_mutex);
+					spin_lock_irq(rq->queue_lock);
+					/*update new bio*/
+					sector = (rq_iter.bio)->bi_sector;
+					buffer = 0;
+					rq_len = 0;
+				}
+			}
+
+			bio_for_each_segment(bvec, rq_iter.bio, rq_iter.i){
+				if(1){
+					if(nand_bio_kmap(rq_iter.bio, rq_iter.i, KM_USER0) == buffer + rq_len){
+						/*merge vec*/
+						rq_len += bvec->bv_len;
+						//printk("[N]merge bvc\n");
+					}else{
+						/*flush previous data*/
+						if(rq_len){
+							spin_unlock_irq(rq->queue_lock);
+							down(&nandr->nand_ops_mutex);
+						#if NAND_TEST_TICK
+							tick = jiffies;
+							nand_transfer(dev, sector,  rq_len>>9, buffer, rw_flag);
+							nand_rw_time += jiffies - tick;
+						#else
+							nand_transfer(dev, sector, rq_len>>9, buffer, rw_flag);
+						#endif
+							up(&nandr->nand_ops_mutex);
+							spin_lock_irq(rq->queue_lock);
+						}
+						/*update new*/
+						sector += rq_len>>9;
+						buffer = nand_bio_kmap(rq_iter.bio, rq_iter.i, KM_USER0);
+						rq_len = bvec->bv_len;
+					}
+				}
+			}
+		}
+
+		if(rq_len){
+			spin_unlock_irq(rq->queue_lock);
+			down(&nandr->nand_ops_mutex);
+		#if NAND_TEST_TICK
+			tick = jiffies;
+			nand_transfer(dev, sector,  rq_len>>9, buffer, rw_flag);
+			nand_rw_time += jiffies - tick;
+		#else
+			nand_transfer(dev, sector, rq_len>>9, buffer, rw_flag);
+		#endif
+			up(&nandr->nand_ops_mutex);
+			spin_lock_irq(rq->queue_lock);
+			sector = ULLONG_MAX;
+			rq_len = 0;
+			buffer = NULL;
+		}
+
+		#if NAND_TEST_TICK
+		printk("[N]ticks=%ld\n",nand_rw_time);
+		#endif
+
+		#ifdef NAND_CACHE_FLUSH_EVERY_SEC
+		if(rw_flag == REQ_WRITE)
+			after_write = 1;
+		if(req->cmd_flags&REQ_SYNC){
+			wake_up_interruptible(&collect_arg.wait);
+		}
+		#endif
+
+		//spin_lock_irq(rq->queue_lock);
+		__blk_end_request_all(req,0);
+		req = NULL;
+	#else
+		nandr = dev->nandr;
+		spin_unlock_irq(rq->queue_lock);
+		down(&nandr->nand_ops_mutex);
+		IS_IDLE = 0;
+
+		#ifdef NAND_BIO_ALIGN
+			reset(req);
+		#endif
+		#if NAND_TEST_TICK
+		tick = jiffies;
+		res = cache_align_page_request(nandr, dev, req);
+		nand_rw_time += jiffies - tick;
+		#else
+		res = cache_align_page_request(nandr, dev, req);
+		#endif
+		up(&nandr->nand_ops_mutex);
+		IS_IDLE = 1;
+		spin_lock_irq(rq->queue_lock);
+
+		if(!__blk_end_request_cur(req, res)){
+			req = NULL;
+			#if NAND_TEST_TICK
+			printk("[N]ticks=%ld\n",nand_rw_time);
+			#endif
+		}
+	#endif
+
+	}
+
+	if(req)
+		__blk_end_request_all(req, -EIO);
+	spin_unlock_irq(rq->queue_lock);
+
+	complete_and_exit(&nandr->thread_exit, 0);
+
+	return 0;
+}
+
+
+static void nand_blk_request(struct request_queue *rq)
+{
+	struct nand_blk_ops *nandr = rq->queuedata;
+	wake_up(&nandr->thread_wq);
+}
+
+static int nand_open(struct block_device *bdev, fmode_t mode)
+{
+	struct nand_blk_dev *dev;
+	struct nand_blk_ops *nandr;
+	int ret = -ENODEV;
+
+	dev = bdev->bd_disk->private_data;
+	nandr = dev->nandr;
+
+	if (!try_module_get(nandr->owner))
+		goto out;
+
+	ret = 0;
+	if (nandr->open && (ret = nandr->open(dev))) {
+		out:
+		module_put(nandr->owner);
+	}
+	return ret;
+}
+static int nand_release(struct gendisk *disk, fmode_t mode)
+{
+	struct nand_blk_dev *dev;
+	struct nand_blk_ops *nandr;
+
+	int ret = 0;
+
+	dev = disk->private_data;
+	nandr = dev->nandr;
+	//nand_flush(NULL);
+	if (nandr->release)
+		ret = nandr->release(dev);
+
+	if (!ret) {
+		module_put(nandr->owner);
+	}
+
+	return ret;
+}
+
+
+/*filp->f_dentry->d_inode->i_bdev->bd_disk->fops->ioctl(filp->f_dentry->d_inode, filp, cmd, arg);*/
+#define DISABLE_WRITE         _IO('V',0)
+#define ENABLE_WRITE          _IO('V',1)
+#define DISABLE_READ 	     _IO('V',2)
+#define ENABLE_READ 	     _IO('V',3)
+static int nand_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)
+{
+	struct nand_blk_dev *dev = bdev->bd_disk->private_data;
+	struct nand_blk_ops *nandr = dev->nandr;
+
+	switch (cmd) {
+	case BLKFLSBUF:
+		dbg_err("BLKFLSBUF called!\n");
+		if (nandr->flush)
+			return nandr->flush(dev);
+		/* The core code did the work, we had nothing to do. */
+		return 0;
+
+	case HDIO_GETGEO:
+		if (nandr->getgeo) {
+			struct hd_geometry g;
+			int ret;
+
+			memset(&g, 0, sizeof(g));
+			ret = nandr->getgeo(dev, &g);
+			if (ret)
+				return ret;
+  			dbg_err("HDIO_GETGEO called!\n");
+			g.start = get_start_sect(bdev);
+			if (copy_to_user((void __user *)arg, &g, sizeof(g)))
+				return -EFAULT;
+
+			return 0;
+		}
+		return 0;
+	case ENABLE_WRITE:
+		dbg_err("enable write!\n");
+		dev->disable_access = 0;
+		dev->readonly = 0;
+		set_disk_ro(dev->blkcore_priv, 0);
+		return 0;
+
+	case DISABLE_WRITE:
+		dbg_err("disable write!\n");
+		dev->readonly = 1;
+		set_disk_ro(dev->blkcore_priv, 1);
+		return 0;
+
+	case ENABLE_READ:
+		dbg_err("enable read!\n");
+		dev->disable_access = 0;
+		dev->writeonly = 0;
+		return 0;
+
+	case DISABLE_READ:
+		dbg_err("disable read!\n");
+		dev->writeonly = 1;
+		return 0;
+	default:
+		return -ENOTTY;
+	}
+}
+
+struct block_device_operations nand_blktrans_ops = {
+	.owner		= THIS_MODULE,
+	.open		= nand_open,
+	.release		= nand_release,
+	.ioctl		= nand_ioctl,
+};
+
+void set_part_mod(char *name,int cmd)
+{
+	struct file *filp = NULL;
+	filp = filp_open(name, O_RDWR, 0);
+	filp->f_dentry->d_inode->i_bdev->bd_disk->fops->ioctl(filp->f_dentry->d_inode->i_bdev, 0, cmd, 0);
+	filp_close(filp, current->files);
+}
+static int nand_add_dev(struct nand_blk_ops *nandr)
+{
+	struct nand_blk_dev *dev;
+	struct gendisk *gd;
+	unsigned long temp;
+
+	if (!down_trylock(&nand_mutex)) {
+		up(&nand_mutex);
+		BUG();
+	}
+
+	dev = &nandr->dev;
+	if (dev->blkcore_priv)
+		return -EBUSY;
+
+	memset(dev, 0, sizeof(*dev));
+	dev->nandr = nandr;
+	dev->size = DiskSize;
+	dev->off_size = 0;
+	dev->devnum = 0;
+
+	dev->cylinders = 1024;
+	dev->heads = 16;
+
+	temp = dev->cylinders * dev->heads;
+	dev->sectors = ( dev->size) / temp;
+	if ((dev->size) % temp) {
+		dev->sectors++;
+		temp = dev->cylinders * dev->sectors;
+		dev->heads = (dev->size)  / temp;
+
+		if ((dev->size)   % temp) {
+			dev->heads++;
+			temp = dev->heads * dev->sectors;
+			dev->cylinders = (dev->size)  / temp;
+		}
+	}
+
+	gd = alloc_disk(1 << nandr->minorbits);
+	if (!gd) {
+		return -ENOMEM;
+	}
+	gd->major = nandr->major;
+	gd->first_minor = (dev->devnum) << nandr->minorbits;
+	gd->fops = &nand_blktrans_ops;
+
+	/* /dev/nand */
+	snprintf(gd->disk_name, sizeof(gd->disk_name),
+		 "%s", nandr->name);
+
+	/* 2.5 has capacity in units of 512 bytes while still
+	   having BLOCK_SIZE_BITS set to 10. Just to keep us amused. */
+	set_capacity(gd, dev->size);
+
+	gd->private_data = dev;
+	dev->blkcore_priv = gd;
+	gd->queue = nandr->rq;
+
+	if (dev->readonly)
+		set_disk_ro(gd, 1);
+	add_disk(gd);
+	return 0;
+}
+
+static int nand_remove_dev(struct nand_blk_dev *dev)
+{
+	struct gendisk *gd;
+
+	if (!down_trylock(&nand_mutex)) {
+		up(&nand_mutex);
+		BUG();
+	}
+	gd = dev->blkcore_priv;
+	dev->blkcore_priv = NULL;
+	gd->queue = NULL;
+	del_gendisk(gd);
+	put_disk(gd);
+	return 0;
+}
+
+#ifdef NAND_CACHE_FLUSH_EVERY_SEC
+static int collect_thread(void *tmparg)
+{
+	unsigned long ret;
+	struct collect_ops *arg = tmparg;
+
+	current->flags |= PF_MEMALLOC | PF_NOFREEZE;
+	daemonize("%sd", "nfmt");
+
+	spin_lock_irq(&current->sighand->siglock);
+	sigfillset(&current->blocked);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+#if 0
+	while (!arg->quit)
+	{
+		ret = wait_event_interruptible_timeout(arg->wait, 0, arg->timeout*HZ);
+		if (0 ==  ret)
+		{
+			nand_flush(NULL);
+			IS_IDLE = 1;
+		}
+		arg->timeout = TIMEOUT;
+	}
+#else
+	while (!arg->quit){
+		ret = wait_event_interruptible(arg->wait,after_write);
+		if(ret==0){
+			do{
+				after_write = 0;
+				ssleep(arg->timeout);
+			}while(after_write);
+			//IS_IDLE = 1;
+			nand_flush(NULL);
+			//IS_IDLE = 1;
+		}
+	}
+#endif
+	complete_and_exit(&arg->thread_exit, 0);
+}
+#endif
+
+int nand_blk_register(struct nand_blk_ops *nandr)
+{
+	int ret;
+
+	down(&nand_mutex);
+
+	ret = register_blkdev(nandr->major, nandr->name);
+	if(ret){
+		dbg_err("\nfaild to register blk device\n");
+		up(&nand_mutex);
+		return -1;
+	}
+
+
+	spin_lock_init(&nandr->queue_lock);
+	init_completion(&nandr->thread_exit);
+	init_waitqueue_head(&nandr->thread_wq);
+	sema_init(&nandr->nand_ops_mutex, 1);
+
+	nandr->rq= blk_init_queue(nand_blk_request, &nandr->queue_lock);
+	if (!nandr->rq) {
+		unregister_blkdev(nandr->major, nandr->name);
+		up(&nand_mutex);
+		return  -1;
+	}
+
+	//for 2.6.29
+	//elevator_exit(nandr->rq->elevator);
+	//for 2.6.36
+	//null
+
+	ret = elevator_change(nandr->rq, "noop");
+	if(ret){
+		blk_cleanup_queue(nandr->rq);
+		return ret;
+	}
+
+	nandr->rq->queuedata = nandr;
+	ret = kernel_thread(nand_blktrans_thread, nandr, CLONE_KERNEL);
+	if (ret < 0) {
+		blk_cleanup_queue(nandr->rq);
+		unregister_blkdev(nandr->major, nandr->name);
+		up(&nand_mutex);
+		return ret;
+	}
+
+	#ifdef NAND_CACHE_FLUSH_EVERY_SEC
+	/*init wait queue*/
+	collect_arg.quit = 0;
+	collect_arg.timeout = TIMEOUT;
+	init_completion(&collect_arg.thread_exit);
+	init_waitqueue_head(&collect_arg.wait);
+	ret = kernel_thread(collect_thread, &collect_arg, CLONE_KERNEL);
+ 	if (ret < 0)
+	{
+		dbg_err("sorry,thread creat failed\n");
+		return 0;
+	}
+	#endif
+
+	//devfs_mk_dir(nandr->name);
+	memset(&nandr->dev,0,sizeof(nandr->dev));
+
+	nandr->add_dev(nandr);
+
+	up(&nand_mutex);
+
+	return 0;
+}
+
+
+void nand_blk_unregister(struct nand_blk_ops *nandr)
+{
+	down(&nand_mutex);
+	/* Clean up the kernel thread */
+	nandr->quit = 1;
+	wake_up(&nandr->thread_wq);
+	wait_for_completion(&nandr->thread_exit);
+
+#ifdef NAND_CACHE_FLUSH_EVERY_SEC
+	collect_arg.quit =1;
+	wake_up(&collect_arg.wait);
+	wait_for_completion(&collect_arg.thread_exit);
+#endif
+	/* Remove it from the list of active majors */
+	nandr->remove_dev(&nandr->dev);
+
+	//devfs_remove(nandr->name);
+	blk_cleanup_queue(nandr->rq);
+
+	unregister_blkdev(nandr->major, nandr->name);
+
+	up(&nand_mutex);
+}
+
+static int nand_getgeo(struct nand_blk_dev *dev,  struct hd_geometry *geo)
+{
+	geo->heads = dev->heads;
+	geo->sectors = dev->sectors;
+	geo->cylinders = dev->cylinders;
+
+	return 0;
+}
+
+static struct nand_blk_ops mytr = {
+	.name 			=  "nand",
+	.major 			= 93,
+	.minorbits		= 4, /* âlogâ(MAX_PART_COUNT + 1)â */
+	.getgeo 			= nand_getgeo,
+	.add_dev			= nand_add_dev,
+	.remove_dev 		= nand_remove_dev,
+	.flush 			= nand_flush,
+	.owner 			= THIS_MODULE,
+};
+
+
+static int nand_flush(struct nand_blk_dev *dev)
+{
+	if (0 == down_trylock(&mytr.nand_ops_mutex))
+	{
+		IS_IDLE = 0;
+	#ifdef NAND_CACHE_RW
+		NAND_CacheFlush();
+	#else
+		LML_FlushPageCache();
+	#endif
+		up(&mytr.nand_ops_mutex);
+		IS_IDLE = 1;
+
+		dbg_inf("nand_flush \n");
+	}
+	return 0;
+}
+
+
+static void nand_flush_all(void)
+{
+    int     timeout = 0;
+
+    /* wait write finish */
+    for(timeout=0; timeout<10; timeout++) {
+        if(after_write) {
+            msleep(500);
+        }
+        else {
+            break;
+        }
+    }
+    printk("nand try to shutdown %d time\n", timeout);
+
+    /* get nand ops mutex */
+    down(&mytr.nand_ops_mutex);
+
+    #ifdef NAND_CACHE_RW
+    NAND_CacheFlush();
+    #else
+    LML_FlushPageCache();
+    #endif
+    BMM_WriteBackAllMapTbl();
+    printk("Nand flash shutdown ok!\n");
+}
+
+
+int cal_partoff_within_disk(char *name,struct inode *i)
+{
+	struct gendisk *gd = i->i_bdev->bd_disk;
+	int current_minor = MINOR(i->i_bdev->bd_dev)  ;
+	int index = current_minor & ((1<<mytr.minorbits) - 1) ;
+	if(!index)
+		return 0;
+	return ( gd->part_tbl->part[ index - 1]->start_sect);
+}
+
+void set_nand_pio(void)
+{
+	#ifndef USE_SYS_PIN
+			__u32	cfg0;
+			__u32	cfg1;
+			__u32	cfg2;
+
+			void* gpio_base;
+
+		/*
+			gpio_base = ioremap(PIOC_REGS_pBASE, 4096 );
+			if (gpio_base == NULL) {
+				printk(KERN_ERR "gpio failed to remap register block\n");
+				return ;
+			}
+		*/
+			//modify for f20
+			gpio_base = (void *)SW_VA_PORTC_IO_BASE;
+
+			cfg0 = *(volatile __u32 *)(gpio_base + 0x48);
+			cfg1 = *(volatile __u32 *)(gpio_base + 0x4c);
+			cfg2 = *(volatile __u32 *)(gpio_base + 0x50);
+
+			/*set PIOC for nand*/
+			cfg0 &= 0x0;
+			cfg0 |= 0x22222222;
+			cfg1 &= 0x0;
+			cfg1 |= 0x22222222;
+			cfg2 &= 0x0;
+			cfg2 |= 0x22222222;
+
+			*(volatile __u32 *)(gpio_base + 0x48) = cfg0;
+			*(volatile __u32 *)(gpio_base + 0x4c) = cfg1;
+			*(volatile __u32 *)(gpio_base + 0x50) = cfg2;
+
+			//iounmap(gpio_base);
+	#else
+			nand_handle = gpio_request_ex("nand_para",NULL);
+	#endif
+}
+
+void release_nand_pio(void)
+{
+
+	#ifndef USE_SYS_PIN
+			void* gpio_base;
+
+			/*
+			gpio_base = ioremap(PIOC_REGS_pBASE, 4096 );
+			if (gpio_base == NULL) {
+				printk(KERN_ERR "gpio failed to remap register block\n");
+				return ;
+			}
+			*/
+			//modify for f20
+			gpio_base = (void *)SW_VA_PORTC_IO_BASE;
+
+
+
+			*(volatile __u32 *)(gpio_base + 0x48) = 0;
+			*(volatile __u32 *)(gpio_base + 0x4c) = 0;
+			*(volatile __u32 *)(gpio_base + 0x50) = 0;
+
+			//iounmap(gpio_base);
+	#else
+			//printk("[NAND] nand gpio_release\n");
+			//gpio_release("nand_para",NULL);
+	#endif
+}
+
+
+#ifndef USE_SYS_CLK
+__u32 get_cmu_clk(void)
+{
+	__u32 reg_val;
+	__u32 div_p, factor_n;
+	__u32 factor_k, factor_m;
+	__u32 clock;
+
+	reg_val  = *(volatile unsigned int *)(0xf1c20000 + 0x20);
+	div_p    = (reg_val >> 16) & 0x3;
+	factor_n = (reg_val >> 8) & 0x1f;
+	factor_k = ((reg_val >> 4) & 0x3) + 1;
+	factor_m = ((reg_val >> 0) & 0x3) + 1;
+
+	clock = 24 * factor_n * factor_k/div_p/factor_m;
+
+	return clock;
+}
+
+void set_nand_clock(__u32 nand_max_clock)
+{
+	__u32 edo_clk, cmu_clk;
+	__u32 cfg;
+	__u32 nand_clk_divid_ratio;
+
+	/*open ahb nand clk */
+	cfg = *(volatile __u32 *)(0xf1c20000 + 0x60);
+	cfg |= (0x1<<13);
+	*(volatile __u32 *)(0xf1c20000 + 0x60) = cfg;
+
+	/*set nand clock*/
+	//edo_clk = (nand_max_clock > 20)?(nand_max_clock-10):nand_max_clock;
+	edo_clk = nand_max_clock * 2;
+
+    cmu_clk = get_cmu_clk( );
+	nand_clk_divid_ratio = cmu_clk / edo_clk;
+	if (cmu_clk % edo_clk)
+			nand_clk_divid_ratio++;
+	if (nand_clk_divid_ratio){
+		if (nand_clk_divid_ratio > 16)
+			nand_clk_divid_ratio = 15;
+		else
+			nand_clk_divid_ratio--;
+	}
+	/*set nand clock gate on*/
+	cfg = *(volatile __u32 *)(0xf1c20000 + 0x80);
+
+	/*gate on nand clock*/
+	cfg |= (1U << 31);
+	/*take cmu pll as nand src block*/
+	cfg &= ~(0x3 << 24);
+	cfg |=  (0x2 << 24);
+	//set divn = 0
+	cfg &= ~(0x03 << 12);
+
+	/*set ratio*/
+	cfg &= ~(0x0f << 0);
+	cfg |= (nand_clk_divid_ratio & 0xf) << 0;
+
+	*(volatile __u32 *)(0xf1c20000 + 0x80) = cfg;
+}
+
+
+void release_nand_clock(void)
+{
+	__u32 cfg;
+	__u32 ccmu_base;
+
+	ccmu_base = 0xf1c20000;
+
+	/*set nand clock gate on*/
+	cfg = *(volatile __u32 *)(ccmu_base + 0x14);
+	cfg &= (~(0x1<<15));
+	*(volatile __u32 *)(ccmu_base + 0x14) = cfg;
+}
+
+void active_nand_clock(void)
+{
+	__u32 cfg;
+	__u32 ccmu_base;
+
+	ccmu_base = 0xf1c20000;
+
+	/*set nand clock gate on*/
+	cfg = *(volatile __u32 *)(ccmu_base + 0x14);
+	cfg |= (0x1<<15);
+	*(volatile __u32 *)(ccmu_base + 0x14) = cfg;
+}
+#else
+
+int nand_request_clk(void)
+{
+	ahb_nand_clk = clk_get(NULL,"ahb_nfc");
+	if(!ahb_nand_clk) {
+		return -1;
+	}
+	mod_nand_clk = clk_get(NULL,"nfc");
+		if(!mod_nand_clk) {
+		return -1;
+	}
+	return 0;
+}
+
+void nand_release_clk(void)
+{
+	clk_put(ahb_nand_clk);
+	clk_put(mod_nand_clk);
+}
+
+
+int nand_ahb_clk_enable(void)
+{
+	return clk_enable(ahb_nand_clk);
+}
+
+int nand_module_clk_enable(void)
+{
+	return clk_enable(mod_nand_clk);
+}
+
+void nand_ahb_clk_disable(void)
+{
+		clk_disable(ahb_nand_clk);
+}
+
+void nand_module_clk_disable(void)
+{
+	clk_disable(mod_nand_clk);
+}
+
+int nand_set_module_clk(__u32 nand_clk)
+{
+	return clk_set_rate(mod_nand_clk, nand_clk*2);
+}
+
+__u32 nand_get_module_clk(void)
+{
+	return clk_get_rate(mod_nand_clk);
+}
+
+
+#endif
+
+#ifndef CONFIG_SUNXI_NAND_TEST
+static int __init init_blklayer(void)
+{
+	int ret;
+	unsigned long irqflags;
+
+	#ifndef USE_SYS_CLK
+		__u32 nand_clk;
+		set_nand_clock(20);
+	#else
+		ret = nand_request_clk();
+		if(ret)
+		{
+			printk("[NAND] nand_request_clk fail \n");
+			return -1;
+		}
+
+		ret = nand_ahb_clk_enable();
+		if(ret)
+		{
+			printk("[NAND] nand_ahb_clk_enable fail \n");
+			return -1;
+		}
+
+		ret = nand_module_clk_enable();
+		if(ret)
+		{
+			printk("[NAND] nand_module_clk_enable fail \n");
+			return -1;
+		}
+
+		ret = nand_set_module_clk(20000000);
+		if(ret)
+		{
+			printk("[NAND] nand_set_module_clk fail \n");
+			return -1;
+		}
+
+	#endif
+	//set nand pio
+	set_nand_pio();
+
+
+	clear_NAND_ZI();
+
+	printk("[NAND] nand driver version: 0x%x 0x%x \n", NAND_VERSION_0,NAND_VERSION_1);
+    NAND_ClearRbInt();
+    spin_lock_init(&nand_rb_lock);
+	irqflags = IRQF_DISABLED;
+
+	if (request_irq(SW_INT_IRQNO_NAND, nand_rb_interrupt, irqflags, mytr.name, &mytr))
+	{
+	    printk("nand interrupte register error\n");
+	    return -EAGAIN;
+	}
+
+	ret = PHY_Init();
+	if (ret) {
+		PHY_Exit();
+		return -1;
+	}
+
+	ret = SCN_AnalyzeNandSystem();
+	if (ret < 0)
+		return ret;
+
+	//set nand clk
+	#ifndef USE_SYS_CLK
+		nand_clk =NandStorageInfo.FrequencePar;
+		if(nand_clk>30)
+			nand_clk = 30;
+		set_nand_clock(nand_clk);
+		dbg_inf("set nand clk to %x \n", nand_clk);
+	#else
+		ret = nand_set_module_clk((NandStorageInfo.FrequencePar)*1000000);
+		if(ret)
+		{
+			printk("[NAND] nand_set_module_clk fail \n");
+			return -1;
+		}
+	#endif
+
+
+	ret = PHY_ChangeMode(1);
+	if (ret < 0)
+		return ret;
+
+    ret = PHY_ScanDDRParam();
+    if (ret < 0)
+        return ret;
+
+	ret = FMT_Init();
+	if (ret < 0)
+		return ret;
+
+	ret = FMT_FormatNand();
+	if (ret < 0)
+		return ret;
+	FMT_Exit();
+
+	/*init logic layer*/
+	ret = LML_Init();
+	if (ret < 0)
+		return ret;
+
+	#ifdef NAND_CACHE_RW
+		NAND_CacheOpen();
+	#endif
+
+	return nand_blk_register(&mytr);
+}
+
+static void  __exit exit_blklayer(void)
+{
+	nand_flush(NULL);
+	nand_blk_unregister(&mytr);
+	#ifdef NAND_CACHE_RW
+		NAND_CacheClose();
+	#endif
+	LML_Exit();
+	FMT_Exit();
+	PHY_Exit();
+}
+
+#else
+static int __init init_blklayer(void)
+{
+	printk("[NAND] for nand test, init_blklayer \n");
+	return 0;
+}
+
+static void  __exit exit_blklayer(void)
+{
+
+}
+#endif
+
+#ifdef CONFIG_SUNXI_NAND_TEST
+int nand_suspend(struct platform_device *plat_dev, pm_message_t state)
+#else
+static int nand_suspend(struct platform_device *plat_dev, pm_message_t state)
+#endif
+{
+	int i=0;
+
+	printk("[NAND] nand_suspend \n");
+
+	if(!IS_IDLE){
+		for(i=0;i<10;i++){
+			msleep(200);
+			if(IS_IDLE)
+				break;
+		}
+	}
+	if(i==10){
+		return -EBUSY;
+	}else{
+		down(&mytr.nand_ops_mutex);
+		#ifndef USE_SYS_CLK
+			release_nand_clock();
+		#else
+			nand_module_clk_disable();
+		#endif
+
+		release_nand_pio();
+		printk("[NAND] nand_suspend ok \n");
+		return 0;
+	}
+}
+
+#ifdef CONFIG_SUNXI_NAND_TEST
+int nand_resume(struct platform_device *plat_dev)
+#else
+static int nand_resume(struct platform_device *plat_dev)
+#endif
+{
+
+	printk("[NAND] nand_resume \n");
+	set_nand_pio();
+
+	#ifndef USE_SYS_CLK
+		active_nand_clock();
+	#else
+		nand_module_clk_enable();
+	#endif
+
+	up(&mytr.nand_ops_mutex);
+
+
+	return 0;
+}
+
+
+static int nand_probe(struct platform_device *plat_dev)
+{
+	return 0;
+}
+
+static int nand_remove(struct platform_device *plat_dev)
+{
+	return 0;
+}
+
+void nand_shutdown(struct platform_device *plat_dev)
+{
+    printk("[NAND]shutdown\n");
+	nand_flush_all();
+}
+
+static struct platform_driver nand_driver = {
+	.probe = nand_probe,
+	.remove = nand_remove,
+	.shutdown =  nand_shutdown,
+	.suspend = nand_suspend,
+	.resume = nand_resume,
+	.driver = {
+		.name = "sw_nand",
+		.owner = THIS_MODULE,
+	}
+};
+
+/****************************************************************************
+ *
+ * Module stuff
+ *
+ ****************************************************************************/
+
+static int __init nand_init(void)
+{
+	s32 ret;
+	int nand_used = 0;
+
+    ret = script_parser_fetch("nand_para","nand_used", &nand_used, sizeof(int));
+    if (ret)
+    {
+    	printk("nand init fetch emac using configuration failed\n");
+
+    }
+
+    if(nand_used == 0)
+    {
+        printk("nand driver is disabled \n");
+        return 0;
+    }
+
+
+	ret = init_blklayer();
+	if(ret)
+	{
+		dbg_err("init_blklayer fail \n");
+		return -1;
+	}
+
+	ret = platform_driver_register(&nand_driver);
+	if(ret)
+	{
+		dbg_err("platform_driver_register fail \n");
+		return -1;
+	}
+	printk("[NAND]nand driver, ok.\n");
+	return 0;
+}
+
+static void __exit nand_exit(void)
+{
+    s32 ret;
+	int nand_used = 0;
+
+    ret = script_parser_fetch("nand_para","nand_used", &nand_used, sizeof(int));
+    if (ret)
+    {
+    	printk("nand init fetch emac using configuration failed\n");
+
+    }
+
+    if(nand_used == 0)
+    {
+        printk("nand driver is disabled \n");
+        return ;
+    }
+
+	printk("[NAND]nand driver : bye bye\n");
+	platform_driver_unregister(&nand_driver);
+	//platform_device_unregister(&nand_device);
+	exit_blklayer();
+
+}
+
+module_init(nand_init);
+module_exit(nand_exit);
+MODULE_LICENSE ("GPL");
+MODULE_AUTHOR ("nand flash groups");
+MODULE_DESCRIPTION ("Generic NAND flash driver code");
+
diff --git a/drivers/block/sunxi_nand/nfd/nand_blk.h b/drivers/block/sunxi_nand/nfd/nand_blk.h
new file mode 100644
index 0000000..b6367d4
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfd/nand_blk.h
@@ -0,0 +1,74 @@
+/*
+ * drivers/block/sunxi_nand/nfd/nand_blk.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/semaphore.h>
+
+struct nand_blk_ops;
+struct list_head;
+struct semaphore;
+struct hd_geometry;
+
+struct nand_blk_dev{
+	struct nand_blk_ops *nandr;
+
+	unsigned char heads;
+	unsigned char sectors;
+	unsigned short cylinders;
+
+	int devnum;
+	unsigned long size;
+	unsigned long off_size;
+	int readonly;
+	int writeonly;
+	int disable_access;
+	void *blkcore_priv;
+};
+struct nand_blk_ops{
+	/* blk device ID */
+	char *name;
+	int major;
+	int minorbits;
+
+	/* add/remove nandflash devparts,use gendisk */
+	int (*add_dev)(struct nand_blk_ops *nandr);
+	int (*remove_dev)(struct nand_blk_dev *dev);
+
+	/* Block layer ioctls */
+	int (*getgeo)(struct nand_blk_dev *dev, struct hd_geometry *geo);
+	int (*flush)(struct nand_blk_dev *dev);
+
+	/* Called with mtd_table_mutex held; no race with add/remove */
+	int (*open)(struct nand_blk_dev *dev);
+	int (*release)(struct nand_blk_dev *dev);
+
+	/* synchronization variable */
+	struct completion thread_exit;
+	int quit;
+	wait_queue_head_t thread_wq;
+	struct request_queue *rq;
+	spinlock_t queue_lock;
+	struct semaphore nand_ops_mutex;
+
+	struct nand_blk_dev dev;
+	struct module *owner;
+};
+
diff --git a/drivers/block/sunxi_nand/nfd/nand_private.h b/drivers/block/sunxi_nand/nfd/nand_private.h
new file mode 100644
index 0000000..b254067
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfd/nand_private.h
@@ -0,0 +1,76 @@
+/*
+ * drivers/block/sunxi_nand/nfd/nand_private.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef	_NAND_PRIVATE_H_
+#define	_NAND_PRIVATE_H_
+
+#include    "../include/type_def.h"
+#include	"../src/include/nand_physic.h"
+#include	"../src/include/nand_format.h"
+#include	"../src/include/nand_logic.h"
+#include	"../src/include/nand_scan.h"
+
+extern struct __NandDriverGlobal_t NandDriverInfo;
+
+extern struct __NandStorageInfo_t  NandStorageInfo;
+
+#define DiskSize  (SECTOR_CNT_OF_SINGLE_PAGE * PAGE_CNT_OF_PHY_BLK * BLOCK_CNT_OF_DIE * \
+            DIE_CNT_OF_CHIP * NandStorageInfo.ChipCnt  / 1024 * DATA_BLK_CNT_OF_ZONE)
+
+/*
+typedef struct
+{
+	__u8    mid;
+	__u32   used;
+
+} __drv_nand_t;
+
+typedef struct
+{
+	__u32             offset;
+	__u8              used;
+	char			  major_name[24];
+	char              minor_name[24];
+
+   __hdle            hReg;
+   device_block info;
+   //__dev_blkinfo_t   info;
+}__dev_nand_t;
+*/
+/*
+extern __s32 nand_drv_init  (void);
+extern __s32 nand_drv_exit  (void);
+extern __mp* nand_drv_open(__u32 mid, __u32 mode);
+extern __s32 nand_drv_close(__mp * pDev);
+extern __u32 nand_drv_read(void * pBuffer, __u32 blk, __u32 n, __mp * pDev);
+extern __u32 nand_drv_write(const void * pBuffer, __u32 blk, __u32 n, __mp * pDev) ;
+extern __s32 nand_drv_ioctrl(__mp * pDev, __u32 Cmd, __s32 Aux, void *pBuffer);
+
+
+extern block_device_operations nand_dev_op;
+*/
+
+
+//extern __dev_devop_t nand_dev_op;
+
+#endif /*_NAND_PRIVATE_H_*/
+
diff --git a/drivers/block/sunxi_nand/nfd/nand_user_cfg.h b/drivers/block/sunxi_nand/nfd/nand_user_cfg.h
new file mode 100644
index 0000000..9105763
--- /dev/null
+++ b/drivers/block/sunxi_nand/nfd/nand_user_cfg.h
@@ -0,0 +1,30 @@
+/*
+ * drivers/block/sunxi_nand/nfd/nand_user_cfg.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef	__NAND_SYS_CFG__
+#define	__NAND_SYS_CFG__
+
+#define OS_KERNEL
+
+//#define NAND_CACHE_RW
+
+#endif
diff --git a/drivers/block/sunxi_nand/src/format/nand_format.c b/drivers/block/sunxi_nand/src/format/nand_format.c
new file mode 100644
index 0000000..fe485b5
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/format/nand_format.c
@@ -0,0 +1,2623 @@
+/*
+ * drivers/block/sunxi_nand/src/format/nand_format.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_format.h"
+#include "../include/nand_logic.h"
+
+#define DBG_DUMP_DIE_INFO       (1)
+
+extern  struct __NandDriverGlobal_t     NandDriverInfo;
+extern  struct __LogicArchitecture_t    LogicArchiPar;
+extern  struct __ZoneTblPstInfo_t       ZoneTblPstInfo[MAX_ZONE_CNT];
+
+extern  struct __NandStorageInfo_t  NandStorageInfo;
+extern  struct __NandPageCachePool_t    PageCachePool;
+
+
+//define some local variable
+static __u32 DieCntOfNand = 0;          //the count of dies in a nand chip
+static __u32 SuperBlkCntOfDie = 0;      //the count of the super blocks in a Die
+
+blk_for_boot1_t blks_array[ ] = {
+	{ 16,  4, 16 },
+	{ 32,  4, 8 },
+	{ 128, 4, 3 },
+	{ 256, 4, 3 },
+	{ 512, 4, 3 },
+	{ 0xffffffff,   4, 3 },
+};
+__u32 DIE0_FIRST_BLK_NUM;
+
+/*
+************************************************************************************************************************
+*                       CALCULATE PHYSICAL OPERATION PARAMETER
+*
+*Description: Calculate the paramter for physical operation with the number of zone, number of
+*             super block and number of page in the super block.
+*
+*Arguments  : pPhyPar   the pointer to the physical operation parameter;
+*             nZone     the number of the zone which the super block blonged to;
+*             nBlock    the number of the super block;
+*             nPage     the number of the super page in the super block.
+*
+*Return     : calculate parameter result;
+*               = 0     calculate parameter successful;
+*               < 0     calcualte parameter failed.
+************************************************************************************************************************
+*/
+#if(0)
+__s32 _CalculatePhyOpPar(struct __PhysicOpPara_t *pPhyPar, __u32 nZone, __u32 nBlock, __u32 nPage)
+{
+
+
+    __u32   tmpDieNum, tmpBnkNum, tmpBlkNum, tmpPageNum;
+
+//    FORMAT_DBG("[FORMAT_DBG] Calculate the physical operation parameters.\n"
+//               "             ZoneNum:0x%x, BlockNum:0x%x, PageNum: 0x%x\n", nZone, nBlock, nPage);
+
+    //calcualte the Die number by the zone number
+    tmpDieNum = nZone / ZONE_CNT_OF_DIE;
+
+    if(SUPPORT_INT_INTERLEAVE && SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support internal inter-leave and external iner-leave, the block number is
+        //same as the virtual block number in the die, the bank number is the virtual page number
+        //model the inter-leave bank count, and the page number is the virtual page number
+        //divide the inter-leave bank count
+        tmpBnkNum = nPage % INTERLEAVE_BANK_CNT;
+        tmpBlkNum = nBlock;
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else if(SUPPORT_INT_INTERLEAVE && !SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support internal inter-leave but don't support external inter-leave, the block
+        //number if same as the vitual block number, the bank number is virtual page number model
+        //inter-leave count and add the chip bank base, the page number is the virtual page number
+        //divide the inter-leave bank count
+        tmpBnkNum = (nPage % INTERLEAVE_BANK_CNT) + (tmpDieNum * INTERLEAVE_BANK_CNT);
+        tmpBlkNum = nBlock;
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else if(!SUPPORT_INT_INTERLEAVE && SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support external inter-leave but don't support internal inter-leave, the block
+        //number is virtual block number add the die block base, the bank number is the page number
+        //model the inter-leave bank count, the page number is vitual page number divide the inter-leave
+        //bank count
+        tmpBnkNum = nPage % INTERLEAVE_BANK_CNT;
+        tmpBlkNum = nBlock + (tmpDieNum * (BLOCK_CNT_OF_DIE / PLANE_CNT_OF_DIE));
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else//if(!SUPPORT_INT_INTERLEAVE && !SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash don't internal inter-leave and extern inter-leave either, the bank number is the
+        //die number divide the die count of chip, the block number is the virtual block number add
+        //the die block base in the chip, the page number is same as the virtual page number
+        tmpBnkNum = tmpDieNum / DIE_CNT_OF_CHIP;
+        tmpBlkNum = nBlock + (tmpDieNum % DIE_CNT_OF_CHIP) * (BLOCK_CNT_OF_DIE / PLANE_CNT_OF_DIE);
+        tmpPageNum = nPage;
+    }
+
+    //set the physical operation paramter by the bank number, block number and page number
+    pPhyPar->BankNum = tmpBnkNum;
+    pPhyPar->PageNum = tmpPageNum;
+    pPhyPar->BlkNum = tmpBlkNum;
+
+//    FORMAT_DBG("         Calculate Result: BankNum 0x%x, BlkNum 0x%x, PageNum 0x%x\n", tmpBnkNum, tmpBlkNum, tmpPageNum);
+
+    //calculate physical operation parameter successful
+    return 0;
+}
+#elif(1)
+__s32 _CalculatePhyOpPar(struct __PhysicOpPara_t *pPhyPar, __u32 nZone, __u32 nBlock, __u32 nPage)
+{
+
+
+    __u32   tmpDieNum, tmpBnkNum, tmpBlkNum, tmpPageNum;
+
+//    FORMAT_DBG("[FORMAT_DBG] Calculate the physical operation parameters.\n"
+//               "             ZoneNum:0x%x, BlockNum:0x%x, PageNum: 0x%x\n", nZone, nBlock, nPage);
+
+    //calcualte the Die number by the zone number
+    tmpDieNum = nZone / ZONE_CNT_OF_DIE;
+
+    if(SUPPORT_INT_INTERLEAVE && SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support internal inter-leave and external iner-leave, the block number is
+        //same as the virtual block number in the die, the bank number is the virtual page number
+        //model the inter-leave bank count, and the page number is the virtual page number
+        //divide the inter-leave bank count
+        tmpBnkNum = (nPage % INTERLEAVE_BANK_CNT) + (tmpDieNum * INTERLEAVE_BANK_CNT);
+        tmpBlkNum = nBlock ;
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else if(SUPPORT_INT_INTERLEAVE && !SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support internal inter-leave but don't support external inter-leave, the block
+        //number if same as the vitual block number, the bank number is virtual page number model
+        //inter-leave count and add the chip bank base, the page number is the virtual page number
+        //divide the inter-leave bank count
+        tmpBnkNum = (nPage % INTERLEAVE_BANK_CNT) + (tmpDieNum * INTERLEAVE_BANK_CNT);
+        tmpBlkNum = nBlock;
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else if(!SUPPORT_INT_INTERLEAVE && SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support external inter-leave but don't support internal inter-leave, the block
+        //number is virtual block number add the die block base, the bank number is the page number
+        //model the inter-leave bank count, the page number is vitual page number divide the inter-leave
+        //bank count
+        //tmpBnkNum =  (nPage % INTERLEAVE_BANK_CNT) + (tmpDieNum * INTERLEAVE_BANK_CNT);
+        tmpBnkNum =  (nPage % INTERLEAVE_BANK_CNT) + (tmpDieNum/DIE_CNT_OF_CHIP )*INTERLEAVE_BANK_CNT;
+        tmpBlkNum = nBlock + ((tmpDieNum % DIE_CNT_OF_CHIP) * (BLOCK_CNT_OF_DIE / PLANE_CNT_OF_DIE));
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else//if(!SUPPORT_INT_INTERLEAVE && !SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash don't internal inter-leave and extern inter-leave either, the bank number is the
+        //die number divide the die count of chip, the block number is the virtual block number add
+        //the die block base in the chip, the page number is same as the virtual page number
+        tmpBnkNum = tmpDieNum / DIE_CNT_OF_CHIP;
+        tmpBlkNum = nBlock + (tmpDieNum % DIE_CNT_OF_CHIP) * (BLOCK_CNT_OF_DIE / PLANE_CNT_OF_DIE);
+        tmpPageNum = nPage;
+    }
+
+    //set the physical operation paramter by the bank number, block number and page number
+    pPhyPar->BankNum = tmpBnkNum;
+    pPhyPar->PageNum = tmpPageNum;
+    pPhyPar->BlkNum = tmpBlkNum;
+
+//    FORMAT_DBG("         Calculate Result: BankNum 0x%x, BlkNum 0x%x, PageNum 0x%x\n", tmpBnkNum, tmpBlkNum, tmpPageNum);
+
+    //calculate physical operation parameter successful
+    return 0;
+}
+
+#endif
+
+
+/*
+************************************************************************************************************************
+*                       READ PAGE DATA FROM VIRTUAL BLOCK
+*
+*Description: Read page data from virtual block, the block is composed by several physical block.
+*             It is named super block too.
+*
+*Arguments  : nDieNum   the number of the DIE, which the page is belonged to;
+*             nBlkNum   the number of the virtual block in the die;
+*             nPage     the number of the page in the virtual block;
+*             Bitmap    the bitmap of the sectors need access in the page;
+*             pBuf      the pointer to the page data buffer;
+*             pSpare    the pointer to the spare data buffer.
+*
+*Return     : read result;
+*               = 0     read page data successful;
+*               < 0     read page data failed.
+************************************************************************************************************************
+*/
+static __s32 _VirtualPageRead(__u32 nDieNum, __u32 nBlkNum, __u32 nPage, __u32 SectBitmap, void *pBuf, void *pSpare)
+{
+    __s32 i, result;
+    __u8  *tmpSrcData, *tmpDstData, *tmpSrcPtr[4], *tmpDstPtr[4];
+    struct __PhysicOpPara_t tmpPhyPage;
+
+    //calculate the physical operation parameter by te die number, block number and page number
+    _CalculatePhyOpPar(&tmpPhyPage, nDieNum * ZONE_CNT_OF_DIE, nBlkNum, nPage);
+
+    //set the sector bitmap in the page, the main data buffer and the spare data buffer
+    tmpPhyPage.SectBitmap = SectBitmap;
+    tmpPhyPage.MDataPtr = pBuf;
+    if(pSpare)
+    {
+        tmpPhyPage.SDataPtr = FORMAT_SPARE_BUF;
+
+        //process the pointer to spare area data
+        for(i=0; i<2; i++)
+        {
+            if(SectBitmap & (1<<i))
+            {
+                tmpSrcPtr[i] = FORMAT_SPARE_BUF + 4 * i;
+                tmpDstPtr[i] = (__u8 *)pSpare + 4 * i;
+            }
+            else
+            {
+                tmpDstPtr[i] = NULL;
+            }
+        }
+
+        for(i=0; i<2; i++)
+        {
+            if(SectBitmap & (1<<(i + SECTOR_CNT_OF_SINGLE_PAGE)))
+            {
+                tmpSrcPtr[i+2] = LML_SPARE_BUF + 4 * (i + SECTOR_CNT_OF_SINGLE_PAGE);
+                tmpDstPtr[i+2] = (__u8 *)pSpare + 8 + 4 * i;
+            }
+            else
+            {
+                tmpDstPtr[i+2] = NULL;
+            }
+        }
+#if(1)
+		result = PHY_PageReadSpare(&tmpPhyPage);
+#else
+		result = PHY_PageRead(&tmpPhyPage);
+#endif
+    }
+    else
+    {
+        tmpPhyPage.SDataPtr = NULL;
+		result = PHY_PageRead(&tmpPhyPage);
+    }
+
+
+
+    //process spare area data
+    if(pSpare)
+    {
+        //get the spare area data
+        for(i=0; i<4; i++)
+        {
+            if(tmpDstPtr[i] != NULL)
+            {
+                tmpSrcData = tmpSrcPtr[i];
+                tmpDstData = tmpDstPtr[i];
+
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+            }
+        }
+    }
+
+	return result;
+
+    #if 0
+    if(result < 0)
+    {
+        //some error happen when read the virtual page data, report the error type
+        return result;
+    }
+    else
+    {
+        return 0;
+    }
+	#endif
+}
+
+
+/*
+************************************************************************************************************************
+*                       WRITE PAGE DATA TO VIRTUAL BLOCK
+*
+*Description: Write page data to virtual block, the block is composed by several physical block.
+*             It is named super block too.
+*
+*Arguments  : nDieNum   the number of the DIE, which the page is belonged to;
+*             nBlkNum   the number of the virtual block in the die;
+*             nPage     the number of the page in the virtual block;
+*             Bitmap    the bitmap of the sectors need access in the page;
+*             pBuf      the pointer to the page data buffer;
+*             pSpare    the pointer to the spare data buffer.
+*
+*Return     : write result;
+*               = 0     write page data successful;
+*               < 0     write page data failed.
+************************************************************************************************************************
+*/
+static __s32 _VirtualPageWrite(__u32 nDieNum, __u32 nBlkNum, __u32 nPage, __u32 SectBitmap, void *pBuf, void *pSpare)
+{
+    __s32 i, result;
+    __u8  *tmpSrcData, *tmpDstData, *tmpSrcPtr[4], *tmpDstPtr[4];
+    struct __PhysicOpPara_t tmpPhyPage;
+
+    //calculate the physical operation parameter by te die number, block number and page number
+    _CalculatePhyOpPar(&tmpPhyPage, nDieNum * ZONE_CNT_OF_DIE, nBlkNum, nPage);
+
+    //set the sector bitmap in the page, the main data buffer and the spare data buffer
+    tmpPhyPage.SectBitmap = SectBitmap;
+    tmpPhyPage.MDataPtr = pBuf;
+    tmpPhyPage.SDataPtr = FORMAT_SPARE_BUF;
+
+    //process spare area data
+    if(pSpare)
+    {
+        //process the pointer to spare area data
+        for(i=0; i<2; i++)
+        {
+            if(SectBitmap & (1<<i))
+            {
+                tmpSrcPtr[i] = (__u8 *)pSpare + 4 * i;
+                tmpDstPtr[i] = FORMAT_SPARE_BUF + 4 * i;
+            }
+            else
+            {
+                tmpDstPtr[i] = NULL;
+            }
+        }
+
+        for(i=0; i<2; i++)
+        {
+            if(SectBitmap & (1<<(i + SECTOR_CNT_OF_SINGLE_PAGE)))
+            {
+                tmpSrcPtr[i+2] = (__u8 *)pSpare + 8 + 4 * i;
+                tmpDstPtr[i+2] = LML_SPARE_BUF + 4 * (i + SECTOR_CNT_OF_SINGLE_PAGE);
+            }
+            else
+            {
+                tmpDstPtr[i+2] = NULL;
+            }
+        }
+
+        MEMSET(FORMAT_SPARE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * 4);
+
+        for(i=0; i<4; i++)
+        {
+            tmpSrcData = tmpSrcPtr[i];
+            tmpDstData = tmpDstPtr[i];
+
+            if(tmpDstData != NULL)
+            {
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+            }
+        }
+    }
+    else
+    {
+        MEMSET(FORMAT_SPARE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * 4);
+    }
+
+    PHY_PageWrite(&tmpPhyPage);
+    //physical page write module is successful, synch the operation result to check if write successful true
+    result = PHY_SynchBank(tmpPhyPage.BankNum, SYNC_CHIP_MODE);
+    if(result < 0)
+    {
+        //some error happens when synch the write operation, report the error type
+        return result;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+
+/*
+************************************************************************************************************************
+*                       ERASE VIRTUAL BLOCK
+*
+*Description: Erase a virtual blcok.
+*
+*Arguments  : nDieNum   the number of the DIE, which the block is belonged to;
+*             nBlkNum   the number of the virtual block in the die.
+*
+*Return     : erase result;
+*               = 0     virtual block erase successful;
+*               < 0     virtual block erase failed.
+************************************************************************************************************************
+*/
+static __s32 _VirtualBlockErase(__u32 nDieNum, __u32 nBlkNum)
+{
+    __s32 i, result = 0;
+    struct __PhysicOpPara_t tmpPhyBlk;
+
+    //erase every block belonged to different banks
+    for(i=0; i<INTERLEAVE_BANK_CNT; i++)
+    {
+        //calculate the physical operation parameter by te die number, block number and page number
+        _CalculatePhyOpPar(&tmpPhyBlk, nDieNum * ZONE_CNT_OF_DIE, nBlkNum, i);
+
+        PHY_BlockErase(&tmpPhyBlk);
+    }
+
+    //check the result of the block erase
+    for(i=0; i<INTERLEAVE_BANK_CNT; i++)
+    {
+        result = PHY_SynchBank(i, SYNC_CHIP_MODE);
+        if(result < 0)
+        {
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       COPY ONE VIRTUAL BLOCK TO ANOTERH BLOCK
+*
+*Description: Copy the whole block data from one virtual block to another virtual, the
+*             source block and the destination block should be in the same DIE.
+*
+*Arguments  : nDieNum   the number of the DIE, which the blocks belonged to;
+*             nSrcBlk   the number of the source virtual block;
+*             nDstBlk   the number of the destination virtual block.
+*
+*Return     : block copy result;
+*               = 0     copy block data successful;
+*               < 0     copy block data failed.
+************************************************************************************************************************
+*/
+static __s32 _VirtualBlockCopy(__u32 nDieNum, __u32 nSrcBlk, __u32 nDstBlk)
+{
+    __s32 i, result = 0;
+    struct __PhysicOpPara_t tmpSrcBlk, tmpDstBlk;
+
+    //copy every page from source block to destination block
+    for(i=0; i<PAGE_CNT_OF_SUPER_BLK; i++)
+    {
+        //calculate the physical operation paramter for the source page and destination page
+        _CalculatePhyOpPar(&tmpSrcBlk, nDieNum * ZONE_CNT_OF_DIE, nSrcBlk, i);
+        _CalculatePhyOpPar(&tmpDstBlk, nDieNum * ZONE_CNT_OF_DIE, nDstBlk, i);
+
+        PHY_PageCopyback(&tmpSrcBlk, &tmpDstBlk);
+
+        result = PHY_SynchBank(tmpDstBlk.BankNum, SYNC_CHIP_MODE);
+        if(result < 0)
+        {
+            FORMAT_ERR("[FORMAT_ERR] Copy page write failed!\n");
+
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       WRITE THE BAD BLOCK FLAG TO A VIRTUAL BLOCK
+*
+*Description: Write bad block flag to a virtual block, because there is some error happen when write
+*             erase the block, because we don't know which single physical block in the virtual block
+*             is bad, so, should write the bad block flag to every single physical block in the virtual
+*             block, the bad block will be kicked out anyway.
+*
+*Arguments  : nDieNum   the number of the DIE, which the virtual block belonged to;
+*             nBlock    the number of the virtual block in the die;
+*
+*Return     : write result;
+*             return 0 always.
+************************************************************************************************************************
+*/
+static __s32 _WriteBadBlkFlag(__u32 nDieNum, __u32 nBlock)
+{
+    __s32   i;
+    struct __NandUserData_t tmpSpare[2];
+
+    //set bad block flag to the spare data write to nand flash
+    tmpSpare[0].BadBlkFlag = 0x00;
+    tmpSpare[1].BadBlkFlag = 0x00;
+    tmpSpare[0].LogicInfo = 0x00;
+    tmpSpare[1].LogicInfo = 0x00;
+    tmpSpare[0].LogicPageNum = 0x00;
+    tmpSpare[1].LogicPageNum = 0x00;
+    tmpSpare[0].PageStatus = 0x00;
+    tmpSpare[1].PageStatus = 0x00;
+
+    for(i=0; i<INTERLEAVE_BANK_CNT; i++)
+    {
+        //write the bad block flag on the first page
+        _VirtualPageWrite(nDieNum, nBlock, i, FULL_BITMAP_OF_SUPER_PAGE, FORMAT_PAGE_BUF, (void *)&tmpSpare);
+
+        //write the bad block flag on the last page
+        _VirtualPageWrite(nDieNum, nBlock, PAGE_CNT_OF_SUPER_BLK - INTERLEAVE_BANK_CNT + i, \
+                        FULL_BITMAP_OF_SUPER_PAGE, FORMAT_PAGE_BUF, (void *)&tmpSpare);
+    }
+
+    return 0;
+}
+
+
+#if DBG_DUMP_DIE_INFO
+
+/*
+************************************************************************************************************************
+*                       DUMP DIE INFORMATION FOR DEBUG
+*
+*Description: Dump die information for debug nand format.
+*
+*Arguments  : pDieInfo   the pointer to the die information.
+*
+*Return     : none
+************************************************************************************************************************
+*/
+static void _DumpDieInfo(struct __ScanDieInfo_t *pDieInfo)
+{
+    int tmpZone, tmpLog;
+	struct __ScanZoneInfo_t *tmpZoneInfo;
+	struct __LogBlkType_t   *tmpLogBlk;
+
+    FORMAT_DBG("\n");
+    FORMAT_DBG("[FORMAT_DBG] ================== Die information ================\n");
+    FORMAT_DBG("[FORMAT_DBG]    Die number:         0x%x\n", pDieInfo->nDie);
+    FORMAT_DBG("[FORMAT_DBG]    Super block count:  0x%x\n", SuperBlkCntOfDie);
+    FORMAT_DBG("[FORMAT_DBG]    Free block count:   0x%x\n", pDieInfo->nFreeCnt);
+    FORMAT_DBG("[FORMAT_DBG]    Bad block count:    0x%x\n", pDieInfo->nBadCnt);
+
+    for(tmpZone=0; tmpZone<ZONE_CNT_OF_DIE; tmpZone++)
+    {
+        tmpZoneInfo = &pDieInfo->ZoneInfo[tmpZone];
+        FORMAT_DBG("[FORMAT_DBG] ---------------------------------------------------\n");
+        FORMAT_DBG("[FORMAT_DBG] ZoneNum:    0x%x\n", tmpZone);
+        FORMAT_DBG("[FORMAT_DBG]    Data block Count:    0x%x\n", tmpZoneInfo->nDataBlkCnt);
+        FORMAT_DBG("[FORMAT_DBG]    Free block Count:    0x%x\n", tmpZoneInfo->nFreeBlkCnt);
+        FORMAT_DBG("[FORMAT_DBG]    Log block table: \n");
+		FORMAT_DBG("       [Index]             [LogicalBlk]         [LogBlk]        [DataBlk]\n");
+        for(tmpLog=0; tmpLog<MAX_LOG_BLK_CNT; tmpLog++)
+        {
+            tmpLogBlk = tmpLogBlk;
+            tmpLogBlk = &tmpZoneInfo->LogBlkTbl[tmpLog];
+            FORMAT_DBG("      %x           %x          %x        %x\n", tmpLog, tmpLogBlk->LogicBlkNum,
+    		    tmpLogBlk->PhyBlk.PhyBlkNum,
+    		    (tmpLogBlk->LogicBlkNum == 0xffff)? 0xffff : tmpZoneInfo->ZoneTbl[tmpLogBlk->LogicBlkNum].PhyBlkNum);
+        }
+    }
+
+    FORMAT_DBG("[FORMAT_DBG] ===================================================\n");
+}
+
+#endif
+
+
+/*
+************************************************************************************************************************
+*                           GET FREE BLOCK FROM DIE INFORMATION
+*
+*Description: Get free block from the die information.
+*
+*Arguments  : pDieInfo  the pointer to the die information;
+*
+*Return     : the free block number;
+*               >= 0    get free block successful, return the block number;
+*               < 0     get free block failed.
+************************************************************************************************************************
+*/
+static __s32 _GetFreeBlkFromDieInfo(struct __ScanDieInfo_t *pDieInfo)
+{
+    __s32   i, tmpFreeBlk;
+
+    tmpFreeBlk = -1;
+
+    //scan the logical information array, look for a free block
+    for(i=pDieInfo->nFreeIndex; i<SuperBlkCntOfDie; i++)
+    {
+        if(pDieInfo->pPhyBlk[i] == FREE_BLOCK_INFO)
+        {
+            tmpFreeBlk = i;
+
+            pDieInfo->pPhyBlk[i] = NULL_BLOCK_INFO;
+
+            pDieInfo->nFreeIndex = i;
+
+            pDieInfo->nFreeCnt--;
+
+            break;
+        }
+    }
+
+    return tmpFreeBlk;
+}
+
+
+/*
+************************************************************************************************************************
+*                           GET THE ZONE NUMBEB WHICH HAS LEAST BLOCK
+*
+*Description: Get the number of zone, which has the least count blocks, include data block, free
+*             block and log block; assure the blocks is proportioned in every block mapping table.
+*
+*Arguments  : pDieInfo  the pointer to the die information;
+*
+*Return     : the number of the zone which has least blocks;
+************************************************************************************************************************
+*/
+static __s32 _LeastBlkCntZone(struct __ScanDieInfo_t *pDieInfo)
+{
+    __s32 i, tmpZone, tmpBlkCnt, tmpLeastCntBlkZone = 0, tmpLeastBlkCnt = 0xffff;
+    struct __LogBlkType_t *tmpLogBlkTbl;
+
+    for(tmpZone=0; tmpZone<ZONE_CNT_OF_DIE; tmpZone++)
+    {
+        //skip valid block mapping table
+        if(pDieInfo->TblBitmap & (1 << tmpZone))
+        {
+            continue;
+        }
+
+        tmpBlkCnt = DATA_BLK_CNT_OF_ZONE + pDieInfo->ZoneInfo[tmpZone].nFreeBlkCnt;
+
+        //check the log block count of the zone
+        tmpLogBlkTbl = pDieInfo->ZoneInfo[tmpZone].LogBlkTbl;
+        for(i=0; i<MAX_LOG_BLK_CNT; i++)
+        {
+            if(tmpLogBlkTbl[i].LogicBlkNum != 0xffff)
+            {
+                tmpBlkCnt++;
+            }
+        }
+
+        if(tmpBlkCnt < tmpLeastBlkCnt)
+        {
+            tmpLeastBlkCnt = tmpBlkCnt;
+            tmpLeastCntBlkZone = tmpZone;
+        }
+    }
+
+    return tmpLeastCntBlkZone;
+}
+
+
+/*
+************************************************************************************************************************
+*                           MERGE DATA BLOCK TO FREE BLOCK
+*
+*Description: Merge a data block to a free block, for block replace.
+*
+*Arguments  : pDieInfo  the pointer to the die information;
+*             nDataBlk  the number of the data block;
+*             nFreeBlk  the number of the free block.
+*
+*Return     : merge result;
+*               = 0     merge successful;
+*               < 0     merge failed.
+************************************************************************************************************************
+*/
+static __s32 _MergeDataBlkToFreeBlk(struct __ScanDieInfo_t *pDieInfo, __u32 nDataBlk, __u32 nFreeBlk)
+{
+    __s32 result;
+
+    //copy the data in the data block to the free block
+    result = _VirtualBlockCopy(pDieInfo->nDie, nDataBlk, nFreeBlk);
+    if(result < 0)
+    {
+        //copy the data failed, the free block may be a bad block
+        _WriteBadBlkFlag(pDieInfo->nDie, nFreeBlk);
+
+        return -1;
+    }
+
+    //modify the logical information of the free block in the die information
+    pDieInfo->pPhyBlk[nFreeBlk] = pDieInfo->pPhyBlk[nDataBlk];
+    pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+            pPhyBlk[nDataBlk])].ZoneTbl[GET_LOGIC_INFO_BLK(pDieInfo->pPhyBlk[nDataBlk])].PhyBlkNum = nFreeBlk;
+
+    //erase the data block for saving block mapping table
+    result = _VirtualBlockErase(pDieInfo->nDie, nDataBlk);
+    if(result < 0)
+    {
+        //erase the data block failed, the block may be a bad block
+        _WriteBadBlkFlag(pDieInfo->nDie, nDataBlk);
+
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       LOOK FOR THE BLOCK MAPPING TABLE POSITION
+*
+*Description: Look for the block-mapping-table position in the virtual block.
+*
+*Arguments  : nDieNum   the number of the DIE, which the virtual block belonged to;
+*             nBlock    the number of the virtual block in the die;
+*
+*Return     : the page number which is the block-mapping-table position;
+*               >=0     find the last group;
+*               < 0     look for the last group failed.
+************************************************************************************************************************
+*/
+static __u32 _SearchBlkTblPst(__u32 nDieNum, __u32 nBlock)
+{
+    struct __NandUserData_t tmpSpare;
+
+    __s32   tmpLowPage, tmpHighPage, tmpMidPage;
+    __u32   tmpPage;
+
+    //use bisearch algorithm to look for the last group of the block mapping table in the super block
+    tmpLowPage = 0;
+    tmpHighPage = PAGE_CNT_OF_SUPER_BLK / PAGE_CNT_OF_TBL_GROUP - 1;
+    while(tmpLowPage <= tmpHighPage)
+    {
+        //calcualte the number of the page which need be read currently
+        tmpMidPage = (tmpLowPage + tmpHighPage) / 2;
+        tmpPage = tmpMidPage * PAGE_CNT_OF_TBL_GROUP;
+
+        //get the spare data of the page to check if the page has been used
+        _VirtualPageRead(nDieNum, nBlock, tmpPage, 0x3, FORMAT_PAGE_BUF, (void *)&tmpSpare);
+
+        if(tmpSpare.PageStatus == FREE_PAGE_MARK)
+        {
+            //look for the last table group in the front pages
+            tmpHighPage = tmpMidPage - 1;
+        }
+        else
+        {
+            //look for the last table group in the hind pages
+            tmpLowPage = tmpMidPage + 1;
+        }
+    }
+
+    //calculate the number of the page which is the first page in the last table page group
+    tmpPage = ((tmpLowPage + tmpHighPage) / 2) * PAGE_CNT_OF_TBL_GROUP;
+
+    return tmpPage;
+}
+
+
+/*
+************************************************************************************************************************
+*                       LOOK FOR THE LAST USED PAGE IN A SUPER BLOCK
+*
+*Description: Look for the last used page, which is the last page page in the used group.
+*
+*Arguments  : nDieNum   the number of the DIE, which the virtual block belonged to;
+*             nBlock    the number of the virtual block in the die;
+*
+*Return     : the page number of the last page in the used group;
+*               >= 0    find the last used page;
+*               <  0    look for the last used page failed.
+************************************************************************************************************************
+*/
+static __s32 _GetLastUsedPage(__u32 nDieNum, __u32 nBlock)
+{
+    __s32   tmpLowPage, tmpHighPage, tmpMidPage, tmpPage, tmpUsedPage = 0;
+    struct __NandUserData_t tmpSpare;
+
+    //use bisearch algorithm to look for the last page in the used page group
+
+    if(SUPPORT_ALIGN_NAND_BNK)
+    {
+        __u32   tmpBnkNum;
+        __u8    tmpPageStatus;
+
+        tmpLowPage = 0;
+        tmpHighPage = PAGE_CNT_OF_PHY_BLK - 1;
+
+        while(tmpLowPage <= tmpHighPage)
+        {
+            tmpPageStatus = FREE_PAGE_MARK;
+            tmpMidPage = (tmpLowPage + tmpHighPage) / 2;
+
+            //if support bank align, there may be some free pages in the used page group
+            for(tmpBnkNum=0; tmpBnkNum<INTERLEAVE_BANK_CNT; tmpBnkNum++)
+            {
+                //read pages to check if the page is free
+                tmpPage = tmpMidPage * INTERLEAVE_BANK_CNT + tmpBnkNum;
+                _VirtualPageRead(nDieNum, nBlock, tmpPage, 0x3, FORMAT_PAGE_BUF, (void *)&tmpSpare);
+
+                if((tmpSpare.PageStatus == FREE_PAGE_MARK) && (tmpSpare.LogicPageNum == 0xffff))
+                {
+                    //current page is a free page
+                    continue;
+                }
+
+                tmpPageStatus &= DATA_PAGE_MARK;
+                tmpUsedPage = tmpPage;
+            }
+
+            if(tmpPageStatus == FREE_PAGE_MARK)
+            {
+                //look for the last table group in the front pages
+                tmpHighPage = tmpMidPage - 1;
+            }
+            else
+            {
+                //look for the last table group in the hind pages
+                tmpLowPage = tmpMidPage + 1;
+            }
+        }
+
+    }
+    else
+    {
+
+        tmpLowPage = 0;
+        tmpHighPage = PAGE_CNT_OF_SUPER_BLK - 1;
+
+        while(tmpLowPage <= tmpHighPage)
+        {
+            tmpMidPage = (tmpLowPage + tmpHighPage) / 2;
+
+            //get the spare area data of the page to check if the page is free
+            _VirtualPageRead(nDieNum, nBlock, tmpMidPage, 0x3, FORMAT_PAGE_BUF, (void *)&tmpSpare);
+            tmpUsedPage = tmpMidPage;
+
+            if((tmpSpare.PageStatus == FREE_PAGE_MARK) && (tmpSpare.LogicPageNum == 0xffff))
+            {
+     		    //look for the last table group in the front pages
+                tmpHighPage = tmpMidPage - 1;
+                //tmpUsedPage = tmpMidPage;
+            }
+            else
+            {
+                //look for the last table group in the hind pages
+                tmpLowPage = tmpMidPage + 1;
+            }
+        }
+
+    }
+
+    return tmpUsedPage;
+}
+
+
+/*
+************************************************************************************************************************
+*                       CALCULATE THE CHECKSUM FOR A MAPPING TABLE
+*
+*Description: Calculate the checksum for a mapping table, based on word.
+*
+*Arguments  : pTblBuf   the pointer to the table data buffer;
+*             nLength   the size of the table data, based on word.
+*
+*Return     : table checksum;
+************************************************************************************************************************
+*/
+static __u32 _CalCheckSum(__u32 *pTblBuf, __u32 nLength)
+{
+    __s32 i;
+    __u32 tmpCheckSum = 0;
+    __u32 *tmpItem = pTblBuf;
+
+    for(i=0; i<nLength; i++)
+    {
+        tmpCheckSum += *tmpItem;
+        tmpItem++;
+    }
+
+    return tmpCheckSum;
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET THE LOGICAL INFORMATION OF PHYSICAL BLOCKS
+*
+*Description: Get the logical information of every physial block of the die.
+*
+*Arguments  : pDieInfo   the pointer to the die information whose logical block information need be got.
+*
+*Return     : get logical information result;
+*               = 0     get logical information successful;
+*               < 0     get logical information failed.
+************************************************************************************************************************
+*/
+static __s32 _GetBlkLogicInfo(struct __ScanDieInfo_t *pDieInfo)
+{
+    __u32   tmpBlkNum, tmpBnkNum, tmpPage, tmpBadFlag;
+    __s32   i;
+    __s16   tmpPageNum[4];
+    __u16   tmpLogicInfo;
+    __u32   spare_bitmap;
+    struct  __NandUserData_t tmpSpare[2];
+
+
+    //initiate the number of the pages which need be read, the first page is read always, because the
+    //the logical information is stored in the first page, other pages is read for check bad block flag
+    tmpPageNum[0] = 0;
+    tmpPageNum[1] = -1;
+    tmpPageNum[2] = -1;
+    tmpPageNum[3] = -1;
+
+	tmpLogicInfo = 0xffff;
+
+    //analyze the number of pages which need be read
+    switch(BAD_BLK_FLAG_PST & 0x03)
+    {
+        case 0x00:
+            //the bad block flag is in the first page, same as the logical information, just read 1 page is ok
+            break;
+
+        case 0x01:
+            //the bad block flag is in the first page or the second page, need read the first page and the second page
+            tmpPageNum[1] = 1;
+            break;
+
+        case 0x02:
+            //the bad block flag is in the last page, need read the first page and the last page
+            tmpPageNum[1] = PAGE_CNT_OF_PHY_BLK - 1;
+            break;
+
+        case 0x03:
+            //the bad block flag is in the last 2 page, so, need read the first page, the last page and the last-1 page
+            tmpPageNum[1] = PAGE_CNT_OF_PHY_BLK - 1;
+            tmpPageNum[2] = PAGE_CNT_OF_PHY_BLK - 2;
+            break;
+    }
+
+    //read every super block to get the logical information and the bad block flag
+    for(tmpBlkNum=0; tmpBlkNum<SuperBlkCntOfDie; tmpBlkNum++)
+    {
+        //initiate the bad block flag
+        tmpBadFlag = 0;
+
+        //the super block is composed of several physical blocks in several banks
+        for(tmpBnkNum=0; tmpBnkNum<INTERLEAVE_BANK_CNT; tmpBnkNum++)
+        {
+            for(i=3; i>=0; i--)
+            {
+                if(tmpPageNum[i] == -1)
+                {
+                    //need not check page
+                    continue;
+                }
+
+                //calculate the number of the page in the super block to get spare data
+                tmpPage = tmpPageNum[i] * INTERLEAVE_BANK_CNT + tmpBnkNum;
+                //_VirtualPageRead(pDieInfo->nDie, tmpBlkNum, tmpPage, LOGIC_INFO_BITMAP, FORMAT_PAGE_BUF, (void *)&tmpSpare);
+                spare_bitmap = (SUPPORT_MULTI_PROGRAM ? (0x3 | (0x3 << SECTOR_CNT_OF_SINGLE_PAGE)) : 0x3);
+                _VirtualPageRead(pDieInfo->nDie, tmpBlkNum, tmpPage, spare_bitmap, FORMAT_PAGE_BUF, (void *)&tmpSpare);
+
+				//check if the block is a bad block
+                if((tmpSpare[0].BadBlkFlag != 0xff) || (SUPPORT_MULTI_PROGRAM && (tmpSpare[1].BadBlkFlag != 0xff)))
+                {
+                    //set the bad flag of the physical block
+                    tmpBadFlag = 1;
+                }
+
+                if(tmpPage == 0)
+                {
+                    //get the logical information of the physical block
+                    tmpLogicInfo = tmpSpare[0].LogicInfo;
+                }
+            }
+        }
+
+        if(tmpBadFlag == 1)
+        {
+            //the physical block is a bad block, set bad block flag in the logical information buffer
+            FORMAT_DBG("[FORMAT_DBG] Find a bad block (NO. 0x%x) in the Die 0x%x\n", tmpBlkNum, pDieInfo->nDie);
+            pDieInfo->pPhyBlk[tmpBlkNum] = BAD_BLOCK_INFO;
+
+            continue;
+        }
+
+        //set the logical information for the valid physical block
+        pDieInfo->pPhyBlk[tmpBlkNum] = tmpLogicInfo;
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET LOG AGE FROM PHYSICAL BLOCK
+*
+*Description: Get log age from physical block. the log age is stored in the spare area of the physical block.
+*
+*Arguments  : nDie      the number of the die which the physical block is belonged to;
+*             nPhyBlk   the number of the physical block whose log age need be get.
+*
+*Return     : the log age of the physical block;
+************************************************************************************************************************
+*/
+static __u8 _GetLogAge(__u32 nDie, __u16 nPhyBlk)
+{
+    __u8    tmpLogAge;
+    struct __NandUserData_t tmpSpareData;
+
+    //read the first page of the super block to get spare area data
+    _VirtualPageRead(nDie, nPhyBlk, 0, 0x3, FORMAT_PAGE_BUF, (void *)&tmpSpareData);
+
+    //the log age area is same as the page status area
+    tmpLogAge = tmpSpareData.PageStatus;
+
+    return tmpLogAge;
+}
+
+
+/*
+************************************************************************************************************************
+*               FILL A PHYSCIAL BLOCK TO THE BLOCK MAPPING TABLE
+*
+*Description: Fill a physical block to the block mapping table, one logical block may be related with
+*             one data block and one log block at most. if the logical block contain a data and a log
+*             block, check the age value to decide which block is the data block and which is the log block.
+*
+*Arguments  : pDieInfo      the pointer to the die information the physical block is belonged to;
+*             pLogicInfo    the logical information of the super block;
+*             nPhyBlk       the number of the physical block in the die;
+*             pEraseBlk     the pointer to the block which need be erased;
+*
+*Return     : fill result;
+*               = 0     fill block successful;
+*               < 0     fill block failed.
+************************************************************************************************************************
+*/
+static __s32 _FillBlkToZoneTbl(struct __ScanDieInfo_t *pDieInfo, __u16 nLogicInfo, __u16 nPhyBlk, __u32 *pEraseBlk)
+{
+    __s32   i, tmpLogPst;
+    __u32   tmpZone, tmpLogicBlk;
+    __u16   tmpDataBlk, tmpLogBlk, tmpNewBlk;
+    //__u8    tmpAgeData, tmpAgeLog, tmpAgeNew;
+    __u8    tmpAgeData, tmpAgeNew;
+    __s32   tmpLastPageOfData, tmpLastPageOfLog, tmpLastPageOfNew;
+    struct __SuperPhyBlkType_t *tmpSuperBlk;
+
+    tmpZone = GET_LOGIC_INFO_ZONE(nLogicInfo);
+    tmpLogicBlk = GET_LOGIC_INFO_BLK(nLogicInfo);
+    tmpSuperBlk = (struct __SuperPhyBlkType_t *)&pDieInfo->ZoneInfo[tmpZone].ZoneTbl[tmpLogicBlk];
+
+    *pEraseBlk = 0xffff;
+
+    //check if there is a data block in the data block table already
+    if(tmpSuperBlk->PhyBlkNum == 0xffff)
+    {
+        //the block is the first physical block related to the logical block, we consider it is a data block
+        tmpSuperBlk->PhyBlkNum = nPhyBlk;
+        tmpSuperBlk->BlkEraseCnt = 0;
+        pDieInfo->ZoneInfo[tmpZone].nDataBlkCnt++;
+
+        return 0;
+    }
+
+    tmpDataBlk = tmpSuperBlk->PhyBlkNum;
+    tmpNewBlk = nPhyBlk;
+    tmpLogBlk = 0xffff;
+    //get the log age from the data block and the new block
+    tmpAgeData = _GetLogAge(pDieInfo->nDie, tmpDataBlk);
+    tmpAgeNew = _GetLogAge(pDieInfo->nDie, tmpNewBlk);
+    tmpLogPst = -1;
+
+    //there is a data block in the data block table already, check if the logical block contain a log block
+    for(i=0; i<MAX_LOG_BLK_CNT; i++)
+    {
+        if(pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[i].LogicBlkNum == tmpLogicBlk)
+        {
+            //find the item in the log block table
+            tmpLogBlk = pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[i].PhyBlk.PhyBlkNum;
+            tmpLogPst = i;
+            break;
+        }
+    }
+    //if(tmpLogPst != -1)
+    //{
+        //get the log age from the log block
+    //    tmpAgeLog = _GetLogAge(pDieInfo->nDie, tmpLogBlk);
+    //}
+
+    //compare the log age of current block with the data block
+    if(COMPARE_AGE(tmpAgeNew, tmpAgeData) == 0)
+    {
+        //the log age of current block is same as the data block
+        tmpLastPageOfData = _GetLastUsedPage(pDieInfo->nDie, tmpDataBlk);
+        tmpLastPageOfNew = _GetLastUsedPage(pDieInfo->nDie, tmpNewBlk);
+
+        if(tmpLastPageOfNew > tmpLastPageOfData)
+        {
+            //replace the the data block with the new block, because the new page has more used pages
+            tmpSuperBlk->PhyBlkNum = tmpNewBlk;
+            *pEraseBlk = tmpDataBlk;
+
+            return 0;
+        }
+        else
+        {
+            //the new block has less pages than the data block
+            *pEraseBlk = tmpNewBlk;
+
+            return 0;
+        }
+    }
+    else if(COMPARE_AGE(tmpAgeNew, tmpAgeData) > 0)
+    {
+        //the log age of current block is larger than the data block
+        if(tmpAgeNew == ((tmpAgeData+1) & 0xff))
+        {
+            //the log age of the new block is sequential with the data block, need check the log block
+            if(tmpLogPst != -1)
+            {
+                //there is a log block already, need check which block need be erased
+                tmpLastPageOfNew = _GetLastUsedPage(pDieInfo->nDie, tmpNewBlk);
+                tmpLastPageOfLog = _GetLastUsedPage(pDieInfo->nDie, tmpLogBlk);
+
+                if(tmpLastPageOfNew > tmpLastPageOfLog)
+                {
+                    //the new block has more used page than the log block, replace it
+                    pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[i].PhyBlk.PhyBlkNum = tmpNewBlk;
+                    *pEraseBlk = tmpLogBlk;
+
+                    return 0;
+                }
+                else
+                {
+                    //the new block need be erased
+                    *pEraseBlk = tmpNewBlk;
+
+                    return 0;
+                }
+            }
+            else
+            {
+                //the new block should be the log block, look for a empty item in the log block table
+                for(i=0; i<MAX_LOG_BLK_CNT; i++)
+                {
+                    if(pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[i].LogicBlkNum == 0xffff)
+                    {
+                        //find and empty item in the log block table
+                        tmpLogPst = i;
+                        break;
+                    }
+                }
+
+                if(tmpLogPst != -1)
+                {
+                    //add the new bock to the log block table
+                    pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[tmpLogPst].LogicBlkNum = GET_LOGIC_INFO_BLK(nLogicInfo);
+                    pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[tmpLogPst].PhyBlk.PhyBlkNum = tmpNewBlk;
+
+                    return 0;
+                }
+                else
+                {
+                    //there is no free item in the log block table, add the log block failed, erase the block
+                    *pEraseBlk = tmpNewBlk;
+
+                    return 0;
+                }
+            }
+        }
+        else
+        {
+            FORMAT_DBG("[FORMAT_DBG] The log age of block(logicInfo:0x%x) are not sequential, "
+                "age is:0x%x, 0x%x\n", nLogicInfo, tmpAgeData, tmpAgeNew);
+
+            //the new block need be erased
+            *pEraseBlk = tmpNewBlk;
+
+            return 0;
+        }
+    }
+    else
+    {
+        //the log age of the new block is smaller than the data block
+        if(tmpAgeData == ((tmpAgeNew+1) & 0xff))
+        {
+            //the new block should be the data block
+            tmpSuperBlk->PhyBlkNum = tmpNewBlk;
+            if(tmpLogPst != -1)
+            {
+                //the log block should be erased
+                *pEraseBlk = tmpLogBlk;
+            }
+            else
+            {
+                //look for a free empty item in the log block table
+                for(i=0; i<MAX_LOG_BLK_CNT; i++)
+                {
+                    if(pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[i].LogicBlkNum == 0xffff)
+                    {
+                        //find and empty item in the log block table
+                        tmpLogPst = i;
+                        break;
+                    }
+                }
+
+                if(tmpLogPst == -1)
+                {
+                    //look for free item in the log block table failed, erase the new block
+                    *pEraseBlk = tmpDataBlk;
+
+                    return 0;
+                }
+
+                //make a new log block item in the log block table
+                pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[tmpLogPst].LogicBlkNum = GET_LOGIC_INFO_BLK(nLogicInfo);
+            }
+
+            //the data block should be log block
+            pDieInfo->ZoneInfo[tmpZone].LogBlkTbl[tmpLogPst].PhyBlk.PhyBlkNum = tmpDataBlk;
+
+            return 0;
+        }
+        else
+        {
+            FORMAT_DBG("[FORMAT_DBG] The log age of block(logicInfo:0x%x) are not sequential, "
+                "age is:0x%x, 0x%x\n", nLogicInfo, tmpAgeNew, tmpAgeData);
+
+            //replace the data block with the new block, because the new block has a lower log age
+            tmpSuperBlk->PhyBlkNum = tmpNewBlk;
+            //the data block need be erased
+            *pEraseBlk = tmpDataBlk;
+
+            return 0;
+        }
+    }
+
+    //return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET A NEW PHYSICAL BLOCK FOR SAVING TABLE
+*
+*Description: Get a new physical block for saving block mapping table, the block should be in the
+*             table block area, if can't find block in the block table area anyway, then, get a
+*             free block not in the block area is ok, in this case, it will need rebuild the block
+*             mapping table when installed the nand flash driver every time.
+*
+*Arguments  : pDieInfo  the pointer to the die information;
+*             nZone     the number of the zone in the die.
+*
+*Return     : the block number.
+*               >=0     get block successful, the return value is the number of the block.
+*               < 0     get block failed.
+************************************************************************************************************************
+*/
+static __s32 _GetNewTableBlk(struct __ScanDieInfo_t *pDieInfo, __u32 nZone)
+{
+    __s32   i, tmpBlk, tmpFreeBlk, tmpStartBlk, result;
+    __s32   tmpValidTblBlk, tmpInvalidTblBlk, tmpValidTblFreeBlk;
+
+    if(pDieInfo->nDie == 0)
+    {
+        tmpStartBlk = DIE0_FIRST_BLK_NUM;
+    }
+    else
+    {
+        tmpStartBlk = 0;
+    }
+
+    //try to find a free block in the block mapping table block area
+    for(tmpBlk=tmpStartBlk; tmpBlk<TBL_AREA_BLK_NUM; tmpBlk++)
+    {
+        if(pDieInfo->pPhyBlk[tmpBlk] == FREE_BLOCK_INFO)
+        {
+            //find a free block in the table block area
+            pDieInfo->pPhyBlk[tmpBlk] = NULL_BLOCK_INFO;
+            pDieInfo->nFreeCnt--;
+
+            return tmpBlk;
+        }
+    }
+
+    //can't find a free block in the block mapping table block area
+
+    tmpValidTblBlk = -1;
+    tmpInvalidTblBlk = -1;
+    tmpValidTblFreeBlk = -1;
+
+    for(tmpBlk=tmpStartBlk; tmpBlk<TBL_AREA_BLK_NUM; tmpBlk++)
+    {
+        if((pDieInfo->pPhyBlk[tmpBlk] & ALLOC_BLK_MARK) == ALLOC_BLK_MARK)
+        {
+            //current block is a free block that has been allocated to a valid block mapping table
+            if(tmpValidTblFreeBlk == -1)
+            {
+                tmpValidTblFreeBlk = tmpBlk;
+            }
+
+            continue;
+        }
+
+        if(!GET_LOGIC_INFO_TYPE(pDieInfo->pPhyBlk[tmpBlk]))
+        {
+            //skip the special used type block for boot code, other block mapping table ex...
+            if((tmpValidTblBlk == -1) && (pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+                pPhyBlk[tmpBlk])].ZoneTbl[GET_LOGIC_INFO_BLK(pDieInfo->pPhyBlk[tmpBlk])].PhyBlkNum == tmpBlk))
+            {
+                //get the first valid block in the die, we need select a data block, skip the log block
+                tmpValidTblBlk = tmpBlk;
+            }
+
+            if((tmpInvalidTblBlk == -1) && (pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+                pPhyBlk[tmpBlk])].ZoneTbl[GET_LOGIC_INFO_BLK(pDieInfo->pPhyBlk[tmpBlk])].PhyBlkNum == tmpBlk))
+            {
+                if(!(pDieInfo->TblBitmap & (1 << GET_LOGIC_INFO_ZONE(pDieInfo->pPhyBlk[tmpBlk]))))
+                {
+                    tmpInvalidTblBlk = tmpBlk;
+
+                    break;
+                }
+            }
+        }
+    }
+
+    //look for a free block to replace the data block
+    tmpFreeBlk = _GetFreeBlkFromDieInfo(pDieInfo);
+    if(tmpFreeBlk < 0)
+    {
+        //look for a free block failed, there is too less free block
+        FORMAT_ERR("[FORMAT_ERR] Look for a free block  failed, not enough valid blocks\n");
+
+        return -1;
+    }
+
+    pDieInfo->nFreeCnt--;
+
+    if(tmpInvalidTblBlk != -1)
+    {
+        result = _MergeDataBlkToFreeBlk(pDieInfo, tmpInvalidTblBlk, tmpFreeBlk);
+        if(result < 0)
+        {
+            //replace the data block with the free block failed
+            return -1;
+        }
+
+        return tmpInvalidTblBlk;
+    }
+    else if (tmpValidTblFreeBlk != -1)
+    {
+        struct __SuperPhyBlkType_t *tmpMapTbl = pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+                                pPhyBlk[tmpValidTblFreeBlk])].ZoneTbl;
+
+        //set the valid block mapping table to invlalid
+        pDieInfo->TblBitmap &= ~(1 << GET_LOGIC_INFO_ZONE(pDieInfo->pPhyBlk[tmpValidTblFreeBlk]));
+
+        //replace the block in the table by the free block
+        for(i=0; i<DATA_BLK_CNT_OF_ZONE - 1; i++)
+        {
+            if(tmpMapTbl[i].PhyBlkNum == tmpValidTblFreeBlk)
+            {
+                pDieInfo->pPhyBlk[tmpFreeBlk] = pDieInfo->pPhyBlk[tmpValidTblFreeBlk];
+
+                tmpMapTbl[i].PhyBlkNum = tmpFreeBlk;
+            }
+        }
+
+        for(i=DATA_BLK_CNT_OF_ZONE; i<BLOCK_CNT_OF_ZONE - 1; i++)
+        {
+            if(tmpMapTbl[i].PhyBlkNum == tmpValidTblFreeBlk)
+            {
+                pDieInfo->pPhyBlk[tmpFreeBlk] = pDieInfo->pPhyBlk[tmpValidTblFreeBlk];
+
+                tmpMapTbl[i].PhyBlkNum = tmpFreeBlk;
+            }
+
+            if(tmpMapTbl[i].PhyBlkNum != 0xffff)
+            {
+                //release the blocks in the free block table
+                pDieInfo->pPhyBlk[tmpMapTbl[i].PhyBlkNum] = FREE_BLOCK_INFO;
+                pDieInfo->nFreeCnt++;
+
+                tmpMapTbl[i].PhyBlkNum = 0xffff;
+            }
+        }
+
+        //set the data block count and the free block count
+        pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+                                pPhyBlk[tmpValidTblFreeBlk])].nDataBlkCnt = DATA_BLK_CNT_OF_ZONE;
+
+        pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+                                pPhyBlk[tmpValidTblFreeBlk])].nFreeBlkCnt = 0;
+
+        return tmpValidTblFreeBlk;
+    }
+    else if(tmpValidTblBlk != -1)
+    {
+        struct __SuperPhyBlkType_t *tmpMapTbl = pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+                                pPhyBlk[tmpValidTblBlk])].ZoneTbl;
+
+        //set the valid block mapping table to invlalid
+        pDieInfo->TblBitmap &= ~(1 << GET_LOGIC_INFO_ZONE(pDieInfo->pPhyBlk[tmpBlk]));
+        pDieInfo->nFreeCnt--;
+
+        result = _MergeDataBlkToFreeBlk(pDieInfo, tmpValidTblBlk, tmpFreeBlk);
+
+        //release the blocks in the free block table
+        for(i=DATA_BLK_CNT_OF_ZONE; i<BLOCK_CNT_OF_ZONE - 1; i++)
+        {
+            if(tmpMapTbl[i].PhyBlkNum != 0xffff)
+            {
+                //release the blocks in the free block table
+                pDieInfo->pPhyBlk[tmpMapTbl[i].PhyBlkNum] = FREE_BLOCK_INFO;
+                pDieInfo->nFreeCnt++;
+
+                tmpMapTbl[i].PhyBlkNum = 0xffff;
+            }
+        }
+
+        //set the data block count and the free block count
+        pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+                                pPhyBlk[tmpValidTblFreeBlk])].nDataBlkCnt = DATA_BLK_CNT_OF_ZONE;
+
+        pDieInfo->ZoneInfo[GET_LOGIC_INFO_ZONE(pDieInfo-> \
+                                pPhyBlk[tmpValidTblFreeBlk])].nFreeBlkCnt = 0;
+
+        if(result < 0)
+        {
+            return -1;
+        }
+
+        return tmpValidTblBlk;
+    }
+    else
+    {
+        //look for a valid block in the table block area for table failed
+        FORMAT_DBG("[FORMAT_DBG] Look for a block in table block area for table failed\n");
+
+        return tmpFreeBlk;
+    }
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET PHYSICAL BLOCK FOR SAVING BLOCK MAPPING TABLE
+*
+*Description: Get physical block for saving block mapping table, the physical block should be in
+*             the block mapping table block area, which is in front of the die.
+*
+*Arguments  : pDieInfo   the pointer to the die information.
+*
+*Return     : get mapping table block result;
+*               = 0     get mapping table block successful;
+*               < 0     get mapping table block failed.
+************************************************************************************************************************
+*/
+static __s32 _GetMapTblBlock(struct __ScanDieInfo_t *pDieInfo)
+{
+    __s32   i, result, tmpTryGet;
+
+    for(i=0; i<ZONE_CNT_OF_DIE; i++)
+    {
+        //check if the physical block for saving block mapping table is already exist
+        if(pDieInfo->TblBitmap & (1 << i))
+        {
+            //the block mapping table is valid, the mapping table block is already ok
+            continue;
+        }
+
+        if(ZoneTblPstInfo[i + pDieInfo->nDie * ZONE_CNT_OF_DIE].PhyBlkNum < TBL_AREA_BLK_NUM)
+        {
+            //the block for saving block mapping table is ok
+            continue;
+        }
+
+        tmpTryGet = 0;
+        while(tmpTryGet < 5)
+        {
+            //try to get several times
+            tmpTryGet++;
+
+            //get a new physical block for saving block mapping table
+            result = _GetNewTableBlk(pDieInfo, i);
+            if(!(result < 0))
+            {
+                break;
+            }
+        }
+
+        if(result < 0)
+        {
+            //get new physical block in table area for saving block mapping table failed
+            FORMAT_ERR("[FORMAT_ERR] Get new physical block for mapping table failed in die 0x%x!\n", pDieInfo->nDie);
+            return -1;
+        }
+
+
+        //set the block mapping table position parameter
+        ZoneTblPstInfo[i + pDieInfo->nDie * ZONE_CNT_OF_DIE].PhyBlkNum = result;
+        ZoneTblPstInfo[i + pDieInfo->nDie * ZONE_CNT_OF_DIE].TablePst = 0xffff;
+
+        //mark the physical block as a block mapping table block in the die informaion
+        pDieInfo->pPhyBlk[result] = TABLE_BLK_MARK | (i<<10) | (1<<14);
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       KICK FREE BLOCKS FROM VALID BLOCK TABLE
+*
+*Description: Kick free blocks from valid block table, the other free blocks is used for allocating to
+*             the block tables which need be rebuiled.
+*
+*Arguments  : pDieInfo   the pointer to the die information.
+*
+*Return     : kick free block result;
+*               = 0     kick free block successful;
+*               < 0     kick free block failed.
+************************************************************************************************************************
+*/
+static __s32 _KickValidTblBlk(struct __ScanDieInfo_t *pDieInfo)
+{
+    __s32   i, j;
+    __u32   tmpTblBlk, tmpTblPage;
+    __u16   tmpPhyBlk;
+
+    for(i=0; i<ZONE_CNT_OF_DIE; i++)
+    {
+        //check if the block mapping table of the zone is valid
+        if(!(pDieInfo->TblBitmap & (1 << i)))
+        {
+            //block mapping table is invalid, ignore the zone table
+            continue;
+        }
+
+        tmpTblBlk = ZoneTblPstInfo[i + pDieInfo->nDie * ZONE_CNT_OF_DIE].PhyBlkNum;
+        tmpTblPage = ZoneTblPstInfo[i + pDieInfo->nDie * ZONE_CNT_OF_DIE].TablePst;
+        //read the block mapping table to the block mapping table buffer
+        _VirtualPageRead(pDieInfo->nDie, tmpTblBlk, tmpTblPage+DATA_TBL_OFFSET, DATA_TABLE_BITMAP, FORMAT_PAGE_BUF, NULL);
+        MEMCPY(pDieInfo->ZoneInfo[i].ZoneTbl, FORMAT_PAGE_BUF, SECTOR_SIZE * 4);
+        _VirtualPageRead(pDieInfo->nDie, tmpTblBlk, tmpTblPage+DATA_TBL_OFFSET+1, DATA_TABLE_BITMAP, FORMAT_PAGE_BUF, NULL);
+        MEMCPY(&pDieInfo->ZoneInfo[i].ZoneTbl[BLOCK_CNT_OF_ZONE / 2], FORMAT_PAGE_BUF, SECTOR_SIZE * 4);
+        //read the log table the block mapping table buffer
+        _VirtualPageRead(pDieInfo->nDie, tmpTblBlk, tmpTblPage+LOG_TBL_OFFSET, LOG_TABLE_BITMAP, FORMAT_PAGE_BUF, NULL);
+        MEMCPY(&pDieInfo->ZoneInfo[i].LogBlkTbl, FORMAT_PAGE_BUF, MAX_LOG_BLK_CNT * sizeof(struct __LogBlkType_t));
+
+        for(j=0; j<BLOCK_CNT_OF_ZONE-1; j++)
+        {
+            tmpPhyBlk = pDieInfo->ZoneInfo[i].ZoneTbl[j].PhyBlkNum;
+
+            if(tmpPhyBlk == 0xffff)
+            {
+                //the table item is empty
+                continue;
+            }
+
+            if(pDieInfo->pPhyBlk[tmpPhyBlk] == FREE_BLOCK_INFO)
+            {
+                //the free block has been used by current valid zone, kick the free block
+                pDieInfo->pPhyBlk[tmpPhyBlk] = (ALLOC_BLK_MARK | (i<<10));
+                pDieInfo->nFreeCnt--;
+            }
+        }
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       REPAIR THE LOG BLOCK TABLE FOR A DIE
+*
+*Description: Repair the log block table for a die.
+*
+*Arguments  : pDieInfo   the pointer to the die information.
+*
+*Return     : repair log block table result;
+*               = 0     repair log block table successful;
+*               < 0     repair log block table failed.
+************************************************************************************************************************
+*/
+static __s32 _RepairLogBlkTbl(struct __ScanDieInfo_t *pDieInfo)
+{
+
+    __s32 i, tmpZone, tmpLastUsedPage;
+    struct __LogBlkType_t *tmpLogTbl;
+
+    for(tmpZone=0; tmpZone<ZONE_CNT_OF_DIE; tmpZone++)
+    {
+        //skip the valid block mapping table
+        if(pDieInfo->TblBitmap & (1 << tmpZone))
+        {
+            continue;
+        }
+
+        tmpLogTbl = pDieInfo->ZoneInfo[tmpZone].LogBlkTbl;
+
+        for(i=0; i<MAX_LOG_BLK_CNT; i++)
+        {
+            if(tmpLogTbl->LogicBlkNum != 0xffff)
+            {
+                tmpLastUsedPage = _GetLastUsedPage(pDieInfo->nDie, tmpLogTbl->PhyBlk.PhyBlkNum);
+
+                tmpLogTbl->LastUsedPage = tmpLastUsedPage;
+            }
+
+            tmpLogTbl++;
+        }
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       DISTRIBUTE FREE BLOCKS TO BLOCK MAPPING TABLES
+*
+*Description: Destribute the free blocks to the block mapping tables, distribute free block to fill
+*             the empty items in the data block table at first, assure every data block table item
+*             has a block; then distribute the free blocks to the free block table items.
+*
+*Arguments  : pDieInfo   the pointer to the die information.
+*
+*Return     : distribute free block result;
+*               = 0     distribute free block successful;
+*               < 0     distribute free block failed.
+************************************************************************************************************************
+*/
+static __s32 _DistributeFreeBlk(struct __ScanDieInfo_t *pDieInfo)
+{
+    __s32   i, tmpZone, tmpFreeBlk;
+
+    struct __SuperPhyBlkType_t *tmpZoneTbl;
+
+    //initiate the first super block of the die
+    if(pDieInfo->nDie == 0)
+    {
+        pDieInfo->nFreeIndex = DIE0_FIRST_BLK_NUM;
+    }
+    else
+    {
+        pDieInfo->nFreeIndex = 0;
+    }
+
+    //look for free block to fill the empty item in the data block table
+    for(tmpZone=0; tmpZone<ZONE_CNT_OF_DIE; tmpZone++)
+    {
+        //skip the valid block mapping table
+        if(pDieInfo->TblBitmap & (1 << tmpZone))
+        {
+            continue;
+        }
+
+        //check if the free block is enough to fill the empty item in the data block table
+        if(pDieInfo->nFreeCnt < (DATA_BLK_CNT_OF_ZONE - pDieInfo->ZoneInfo[tmpZone].nDataBlkCnt))
+        {
+            FORMAT_ERR("[FORMAT_ERR] There is not enough valid block for using!\n");
+
+            return -1;
+        }
+
+        tmpZoneTbl = pDieInfo->ZoneInfo[tmpZone].ZoneTbl;
+
+        //init the free block table item index
+        pDieInfo->ZoneInfo[tmpZone].nFreeBlkIndex = DATA_BLK_CNT_OF_ZONE;
+
+        for(i=0; i<DATA_BLK_CNT_OF_ZONE; i++)
+        {
+            if(tmpZoneTbl[i].PhyBlkNum == 0xffff)
+            {
+                //current data block is empty
+                tmpFreeBlk = _GetFreeBlkFromDieInfo(pDieInfo);
+                if(tmpFreeBlk < 0)
+                {
+                    FORMAT_ERR("[FORMAT_ERR] There is not enough valid block for using!\n");
+
+                    return -1;
+                }
+
+                tmpZoneTbl[i].PhyBlkNum = tmpFreeBlk;
+                pDieInfo->ZoneInfo[tmpZone].nDataBlkCnt++;
+                pDieInfo->pPhyBlk[tmpFreeBlk] = (tmpZone<<10) | ALLOC_BLK_MARK;
+            }
+        }
+    }
+
+    //look for the free block to distribute to the free block table
+
+	while(pDieInfo->nFreeCnt > 0)
+    {
+        tmpZone = _LeastBlkCntZone(pDieInfo);
+
+        tmpZoneTbl =  pDieInfo->ZoneInfo[tmpZone].ZoneTbl;
+
+        if(pDieInfo->ZoneInfo[tmpZone].nFreeBlkIndex < BLOCK_CNT_OF_ZONE)
+        {
+            tmpFreeBlk = _GetFreeBlkFromDieInfo(pDieInfo);
+            if(tmpFreeBlk < 0)
+            {
+                FORMAT_DBG("[FORMAT_WARNNING] Get free block failed when it should be successful!\n");
+                continue;
+            }
+
+            tmpZoneTbl[pDieInfo->ZoneInfo[tmpZone].nFreeBlkIndex].PhyBlkNum = tmpFreeBlk;
+            pDieInfo->ZoneInfo[tmpZone].nFreeBlkIndex++;
+            pDieInfo->ZoneInfo[tmpZone].nFreeBlkCnt++;
+
+            pDieInfo->pPhyBlk[tmpFreeBlk] = (tmpZone<<10) | ALLOC_BLK_MARK;
+        }
+        else
+        {
+            FORMAT_DBG("[FORMAT_WARNNING] There is some blocks more than we used!\n");
+        }
+    }
+
+    return 0;
+
+}
+
+
+/*
+************************************************************************************************************************
+*                       FILL BLOCK MAPPING TABLE INFORMATION
+*
+*Description: Fill the block mapping table information with the logical informaton buffer of the die.
+*
+*Arguments  : pDieInfo   the pointer to the die information whose mapping table information need be filled.
+*
+*Return     : fill block mapping table result;
+*               = 0     fill block mapping table successful;
+*               < 0     fill block mapping table failed.
+************************************************************************************************************************
+*/
+static __s32 _FillZoneTblInfo(struct __ScanDieInfo_t *pDieInfo)
+{
+    __u16   tmpLogicInfo;
+    __u32   tmpPhyBlk, tmpBlkErase;
+    __s32   result;
+
+    //calculte the first block is used in the die
+    if(pDieInfo->nDie == 0)
+    {
+        tmpPhyBlk = DIE0_FIRST_BLK_NUM;
+    }
+    else
+    {
+        tmpPhyBlk = 0;
+    }
+
+    //check the logical information of every physical block in the logical information buffer to fill the zone table
+    for( ; tmpPhyBlk<SuperBlkCntOfDie; tmpPhyBlk++)
+    {
+        tmpLogicInfo = pDieInfo->pPhyBlk[tmpPhyBlk];
+
+        //added by penggang 20101206
+        //the last block is degenrous, if it is free block, kick it as a bad block
+        if(tmpPhyBlk == SuperBlkCntOfDie-1)
+        {
+            if(tmpLogicInfo == FREE_BLOCK_INFO)
+            {
+                FORMAT_DBG("[FORMAT_DBG] mark the last block as bad block \n");
+                pDieInfo->pPhyBlk[tmpPhyBlk] = BAD_BLOCK_INFO;
+                _WriteBadBlkFlag(pDieInfo->nDie, tmpPhyBlk);
+
+            }
+        }
+
+        tmpLogicInfo = pDieInfo->pPhyBlk[tmpPhyBlk];
+
+
+        //check if the block is a bad block
+        if(tmpLogicInfo == BAD_BLOCK_INFO)
+        {
+            pDieInfo->nBadCnt++;
+
+            continue;
+        }
+
+        //check if the block is a free block
+        if(tmpLogicInfo == FREE_BLOCK_INFO)
+        {
+            pDieInfo->nFreeCnt++;
+            continue;
+        }
+
+        //check if the block is a special type block
+        if(GET_LOGIC_INFO_TYPE(tmpLogicInfo) == 1)
+        {
+            //check if the block is a boot block
+            if(GET_LOGIC_INFO_BLK(tmpLogicInfo) == BOOT_BLK_MARK)
+            {
+                if(pDieInfo->nDie == 0)
+                {
+                    continue;
+                }
+                else
+                {
+                    //the boot type block should be in the die0, in other die is invalid
+                    FORMAT_DBG("[FORMAT_DBG] Find a boot type block(0x%x) not in die0!\n", tmpPhyBlk);
+                    //erase the super block for other use
+                    result = _VirtualBlockErase(pDieInfo->nDie, tmpPhyBlk);
+                    if(result < 0)
+                    {
+                        //erase the virtual block failed, the block is a bad block, need write bad block flag
+                        pDieInfo->pPhyBlk[tmpPhyBlk] = BAD_BLOCK_INFO;
+                        _WriteBadBlkFlag(pDieInfo->nDie, tmpPhyBlk);
+
+                        continue;
+                    }
+
+                    //the block will be a new free block, modify the logical information
+                    pDieInfo->pPhyBlk[tmpPhyBlk] = FREE_BLOCK_INFO;
+                    pDieInfo->nFreeCnt++;
+
+                    continue;
+                }
+            }
+            //check if the block is a block mapping table block
+            else if(GET_LOGIC_INFO_BLK(tmpLogicInfo) == TABLE_BLK_MARK)
+            {
+                //check if the block mapping table is valid, check the logical information and the position
+                if((GET_LOGIC_INFO_ZONE(tmpLogicInfo) < ZONE_CNT_OF_DIE)
+                    && (tmpPhyBlk < TBL_AREA_BLK_NUM))
+                {
+                    //the block mapping table block is valid
+                    continue;
+                }
+                else
+                {
+                    //the block mapping table block is invalid, need erase it for other use
+                    FORMAT_DBG("[FORMAT_DBG] Find an invalid block mapping table in Die 0x%x !\n", pDieInfo->nDie);
+
+                    result = _VirtualBlockErase(pDieInfo->nDie, tmpPhyBlk);
+                    if(result < 0)
+                    {
+                        //erase the virtual block failed, the block is a bad block, need write bad block flag
+                        pDieInfo->pPhyBlk[tmpPhyBlk] = BAD_BLOCK_INFO;
+                        _WriteBadBlkFlag(pDieInfo->nDie, tmpPhyBlk);
+
+                        continue;
+                    }
+
+                    //the block will be a new free block, modify the logical information
+                    pDieInfo->pPhyBlk[tmpPhyBlk] = FREE_BLOCK_INFO;
+                    pDieInfo->nFreeCnt++;
+
+                    continue;
+                }
+            }
+            else
+            {
+                //the block is an unrecgnized special block, need erased it for other used
+                FORMAT_DBG("[FORMAT_DBG] Find an recgnized special type block in die 0x%x!\n", pDieInfo->nDie);
+
+                result = _VirtualBlockErase(pDieInfo->nDie, tmpPhyBlk);
+                if(result < 0)
+                {
+                    //erase the virtual block failed, the block is a bad block, need write bad block flag
+                    pDieInfo->pPhyBlk[tmpPhyBlk] = BAD_BLOCK_INFO;
+                    _WriteBadBlkFlag(pDieInfo->nDie, tmpPhyBlk);
+
+                    continue;
+                }
+
+                //the block will be a new free block, modify the logical information
+                pDieInfo->pPhyBlk[tmpPhyBlk] = FREE_BLOCK_INFO;
+                pDieInfo->nFreeCnt++;
+
+                continue;
+            }
+        }
+
+        //check if the logical information of the physical block is valid
+        if((GET_LOGIC_INFO_ZONE(tmpLogicInfo) >= ZONE_CNT_OF_DIE) || \
+                    (GET_LOGIC_INFO_BLK(tmpLogicInfo) >= DATA_BLK_CNT_OF_ZONE))
+        {
+            //the logic information of the physical block is invalid, erase it for other use
+            result = _VirtualBlockErase(pDieInfo->nDie, tmpPhyBlk);
+            if(result < 0)
+            {
+                //erase the virtual block failed, the block is a bad block, need write bad block flag
+                pDieInfo->pPhyBlk[tmpPhyBlk] = BAD_BLOCK_INFO;
+                _WriteBadBlkFlag(pDieInfo->nDie, tmpPhyBlk);
+
+                continue;
+            }
+
+            //the block will be a new free block, modify the logical information
+            pDieInfo->pPhyBlk[tmpPhyBlk] = FREE_BLOCK_INFO;
+            pDieInfo->nFreeCnt++;
+
+            continue;
+        }
+
+        //check if the super block is used by the zone which need not rebuiled
+        if((1 << GET_LOGIC_INFO_ZONE(tmpLogicInfo)) & (pDieInfo->TblBitmap))
+        {
+            continue;
+        }
+
+        //fill the physical block to the zone table which the block is belonged to
+        result = _FillBlkToZoneTbl(pDieInfo, tmpLogicInfo, tmpPhyBlk, &tmpBlkErase);
+        if(tmpBlkErase != 0xffff)
+        {
+            //fill the physical block to the zone table failed, erase it for other use
+            result = _VirtualBlockErase(pDieInfo->nDie, tmpBlkErase);
+            if(result < 0)
+            {
+                //erase the virtual block failed, the block is a bad block, need write bad block flag
+                pDieInfo->pPhyBlk[tmpBlkErase] = BAD_BLOCK_INFO;
+                _WriteBadBlkFlag(pDieInfo->nDie, tmpBlkErase);
+
+                continue;
+            }
+
+            //the block will be a new free block, modify the logical information
+            pDieInfo->pPhyBlk[tmpBlkErase] = FREE_BLOCK_INFO;
+            pDieInfo->nFreeCnt++;
+
+            continue;
+        }
+    }
+
+#if DBG_DUMP_DIE_INFO
+
+    _DumpDieInfo(pDieInfo);
+
+#endif
+
+    //fill the data block item finish
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       WRITE BLOCK MAPPING TABLE TO NAND FLASH
+*
+*Description: Write the block mapping table to nand flash, the block mapping table is stored
+*             in the buffer indexed by the die information.
+*
+*Arguments  : pDieInfo   the pointer to the die information
+*
+*Return     : write block mapping table result;
+*               = 0     write block mapping table successful;
+*               < 0     write block mapping table failed.
+************************************************************************************************************************
+*/
+static __s32 _WriteBlkMapTbl(struct __ScanDieInfo_t *pDieInfo)
+{
+    __s32   i, tmpZone, tmpTblBlk, tmpTblPage, tmpGlobzone, result;
+    struct __NandUserData_t tmpSpare[2];
+    struct __SuperPhyBlkType_t *tmpDataBlk;
+    struct __LogBlkType_t *tmpLogBlk;
+
+    for(tmpZone=0; tmpZone<ZONE_CNT_OF_DIE; tmpZone++)
+    {
+        //skip the valid block mapping tables
+        if(pDieInfo->TblBitmap & (1 << tmpZone))
+        {
+            continue;
+        }
+
+        tmpGlobzone = (pDieInfo->nDie) * ZONE_CNT_OF_DIE + tmpZone;
+
+        tmpTblBlk = ZoneTblPstInfo[tmpGlobzone].PhyBlkNum;
+        tmpTblPage = ZoneTblPstInfo[tmpGlobzone].TablePst;
+
+        //calculate the number of the page will be used for writing table
+        if(tmpTblPage == 0xffff)
+        {
+            tmpTblPage = 0;
+        }
+        else
+        {
+            tmpTblPage += PAGE_CNT_OF_TBL_GROUP;
+        }
+
+        //check if the table block need be erased
+        if(!(tmpTblPage < PAGE_CNT_OF_SUPER_BLK))
+        {
+            result = _VirtualBlockErase(pDieInfo->nDie, tmpTblBlk);
+            if(result < 0)
+            {
+                FORMAT_DBG("[FORMAT_DBG] Erase block failed when write block mapping table!\n");
+                //erase the virtual block failed, the block is a bad block, need write bad block flag
+                _WriteBadBlkFlag(pDieInfo->nDie, tmpTblBlk);
+
+                return -1;
+            }
+
+            tmpTblPage = 0;
+        }
+
+        //clear the block erase count of every physical block in the block mapping table
+        tmpDataBlk = pDieInfo->ZoneInfo[tmpZone].ZoneTbl;
+        tmpLogBlk = pDieInfo->ZoneInfo[tmpZone].LogBlkTbl;
+        for(i=0; i<BLOCK_CNT_OF_ZONE; i++)
+        {
+            if(tmpDataBlk[i].PhyBlkNum != 0xffff)
+            {
+                tmpDataBlk[i].BlkEraseCnt = 0;
+            }
+        }
+
+        for(i=0; i<MAX_LOG_BLK_CNT; i++)
+        {
+            if(tmpLogBlk[i].LogicBlkNum != 0xffff)
+            {
+                tmpLogBlk[i].PhyBlk.BlkEraseCnt = 0;
+            }
+        }
+
+        //set spare area data for write zone table
+        tmpSpare[0].BadBlkFlag = 0xff;
+        tmpSpare[1].BadBlkFlag = 0xff;
+        tmpSpare[0].LogicInfo = (1<<14) | (tmpZone<<10) | TABLE_BLK_MARK;
+        tmpSpare[1].LogicInfo = (1<<14) | (tmpZone<<10) | TABLE_BLK_MARK;
+        tmpSpare[0].LogicPageNum = 0xffff;
+        tmpSpare[1].LogicPageNum = 0xffff;
+        tmpSpare[0].PageStatus = 0x55;
+        tmpSpare[1].PageStatus = 0x55;
+
+        //set table data checksum for data block table
+        result = _CalCheckSum((__u32 *)tmpDataBlk, BLOCK_CNT_OF_ZONE - 1);
+        *(__u32 *)&tmpDataBlk[BLOCK_CNT_OF_ZONE - 1] = (__u32)result;
+
+        //write data block table to nand flash
+        MEMSET(FORMAT_PAGE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * SECTOR_SIZE);
+        MEMCPY(FORMAT_PAGE_BUF, (__u32 *)tmpDataBlk, SECTOR_SIZE * 4);
+
+
+        result = _VirtualPageWrite(pDieInfo->nDie, tmpTblBlk, tmpTblPage + DATA_TBL_OFFSET, \
+                            FULL_BITMAP_OF_SUPER_PAGE, FORMAT_PAGE_BUF, (void *)tmpSpare);
+        if(result < 0)
+        {
+            FORMAT_DBG("[FORMAT_DBG] Write page failed when write block mapping table!\n");
+            //write page failed, the block is a bad block, need write bad block flag
+            _WriteBadBlkFlag(pDieInfo->nDie, tmpTblBlk);
+
+            return -1;
+        }
+
+
+        MEMCPY(FORMAT_PAGE_BUF, (__u32 *)&tmpDataBlk[BLOCK_CNT_OF_ZONE / 2], SECTOR_SIZE * 4);
+        result = _VirtualPageWrite(pDieInfo->nDie, tmpTblBlk, tmpTblPage + DATA_TBL_OFFSET + 1, \
+                            FULL_BITMAP_OF_SUPER_PAGE, FORMAT_PAGE_BUF, (void *)tmpSpare);
+        if(result < 0)
+        {
+            FORMAT_DBG("[FORMAT_DBG] Write page failed when write block mapping table!\n");
+            //write page failed, the block is a bad block, need write bad block flag
+            _WriteBadBlkFlag(pDieInfo->nDie, tmpTblBlk);
+
+            return -1;
+        }
+
+        //process log block table data
+        MEMSET(FORMAT_PAGE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * SECTOR_SIZE);
+        MEMCPY(FORMAT_PAGE_BUF, (__u32 *)tmpLogBlk, LOG_BLK_CNT_OF_ZONE*sizeof(struct __LogBlkType_t));
+        //set table data checksum for log block table
+        result = _CalCheckSum((__u32 *)FORMAT_PAGE_BUF, LOG_BLK_CNT_OF_ZONE*sizeof(struct __LogBlkType_t)/sizeof(__u32));
+        ((__u32*)FORMAT_PAGE_BUF)[511] = (__u32)result;
+        result = _VirtualPageWrite(pDieInfo->nDie, tmpTblBlk, tmpTblPage + LOG_TBL_OFFSET, \
+                            FULL_BITMAP_OF_SUPER_PAGE, FORMAT_PAGE_BUF, (void *)tmpSpare);
+        if(result < 0)
+        {
+            FORMAT_DBG("[FORMAT_DBG] Write page failed when write block mapping table!\n");
+            //write page failed, the block is a bad block, need write bad block flag
+            _WriteBadBlkFlag(pDieInfo->nDie, tmpTblBlk);
+
+            return -1;
+        }
+
+        //set the data block group position in the table block
+        ZoneTblPstInfo[tmpGlobzone].TablePst = tmpTblPage;
+    }
+
+    //write every block mapping table successful
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       SEARCH ZONE TABLES FROM ONE NAND DIE
+*
+*Description: Search zone tables from one nand flash die.
+*
+*Arguments  : pDieInfo   the pointer to the die information whose block mapping table need be searched
+*
+*Return     : search result;
+*               = 0     search zone table successful;
+*               < 0     search zone table failed.
+************************************************************************************************************************
+*/
+static __s32 _SearchZoneTbls(struct __ScanDieInfo_t *pDieInfo)
+{
+    __u32   tmpSuperBlk, tmpZoneInDie, tmpPage, tmpVar;
+    __s32   result;
+    struct  __NandUserData_t tmpSpareData[2];
+    struct  __SuperPhyBlkType_t *tmpDataBlkTbl;
+
+    FORMAT_DBG("[FORMAT_DBG] Search the block mapping table on DIE 0x%x\n", pDieInfo->nDie);
+
+    if(pDieInfo->nDie == 0)
+    {
+        //some physical blocks of die 0 is used for boot, so need ignore this blocks for efficiency
+        tmpSuperBlk = DIE0_FIRST_BLK_NUM;
+    }
+    else
+    {
+        //the physical blocks of other die all used for block mapping
+        tmpSuperBlk = 0;
+    }
+
+    for( ; tmpSuperBlk<TBL_AREA_BLK_NUM; tmpSuperBlk++)
+    {
+        //init the bad block flag for the tmpSpareData
+        tmpSpareData[0].BadBlkFlag = tmpSpareData[1].BadBlkFlag = 0xff;
+
+        //read page0 to get the block logical information
+        _VirtualPageRead(pDieInfo->nDie, tmpSuperBlk, 0, SPARE_DATA_BITMAP, FORMAT_PAGE_BUF, (void *)&tmpSpareData);
+
+        //check if the bock is a valid block-mapping-table block
+        if((tmpSpareData[0].BadBlkFlag != 0xff) || (tmpSpareData[1].BadBlkFlag != 0xff) || \
+                (GET_LOGIC_INFO_TYPE(tmpSpareData[0].LogicInfo) != 1) || \
+                        (GET_LOGIC_INFO_BLK(tmpSpareData[0].LogicInfo) != 0xaa))
+        {
+            //the block is not a valid block-mapping-table block, ignore it
+            continue;
+        }
+
+        tmpZoneInDie = GET_LOGIC_INFO_ZONE(tmpSpareData[0].LogicInfo);
+        //check if the zone number in the logicial information of the block is valid
+        if(!(tmpZoneInDie < ZONE_CNT_OF_DIE))
+        {
+            //the zone number in the logical infomation of the block is invalid, not a valid block-mapping-table block
+            result = _VirtualBlockErase(pDieInfo->nDie, tmpSuperBlk);
+            if(result < 0)
+            {
+                //erase the virtual block failed, the block is a bad block, need write bad block flag
+                _WriteBadBlkFlag(pDieInfo->nDie, tmpSuperBlk);
+            }
+
+            continue;
+        }
+
+        //check if there is a block-mapping-table block for the zone already
+        if(ZoneTblPstInfo[tmpZoneInDie + pDieInfo->nDie * ZONE_CNT_OF_DIE].PhyBlkNum != 0xffff)
+        {
+            //there is a block-mapping-table block for the zone already, so, need erase current block
+            result = _VirtualBlockErase(pDieInfo->nDie, tmpSuperBlk);
+            if(result < 0)
+            {
+                //erase the virtual block failed, the block is a bad block, need write bad block flag
+                _WriteBadBlkFlag(pDieInfo->nDie, tmpSuperBlk);
+            }
+
+            continue;
+        }
+
+        //look for the position of the last block-mpping-table in the block
+        tmpPage = _SearchBlkTblPst(pDieInfo->nDie, tmpSuperBlk);
+
+        //set the block-mapping-talbe position information
+        ZoneTblPstInfo[tmpZoneInDie + pDieInfo->nDie * ZONE_CNT_OF_DIE].PhyBlkNum = tmpSuperBlk;
+        ZoneTblPstInfo[tmpZoneInDie + pDieInfo->nDie * ZONE_CNT_OF_DIE].TablePst = tmpPage;
+
+        //check the dirty flag of the block mapping table to find if the block mapping table is valid
+        _VirtualPageRead(pDieInfo->nDie, tmpSuperBlk, tmpPage+DIRTY_FLAG_OFFSET, DIRTY_FLAG_BITMAP, FORMAT_PAGE_BUF, NULL);
+        if(FORMAT_PAGE_BUF[0] != 0xff)
+        {
+            //the block mapping table is invalid
+            FORMAT_DBG("[FORMAT_DBG] Find the table block %d for zone 0x%x of die 0x%x, but the table is invalid!\n",
+                        tmpSuperBlk,tmpZoneInDie, pDieInfo->nDie);
+            continue;
+        }
+
+        //check the data block table data, the size of the table is 4k byte, stored in two pages
+        tmpDataBlkTbl = (struct  __SuperPhyBlkType_t *)MALLOC(BLOCK_CNT_OF_ZONE * sizeof(struct __SuperPhyBlkType_t));
+        _VirtualPageRead(pDieInfo->nDie, tmpSuperBlk, tmpPage+DATA_TBL_OFFSET, DATA_TABLE_BITMAP, FORMAT_PAGE_BUF, NULL);
+        MEMCPY(&tmpDataBlkTbl[0], FORMAT_PAGE_BUF, SECTOR_SIZE * 4);
+        _VirtualPageRead(pDieInfo->nDie, tmpSuperBlk, tmpPage+DATA_TBL_OFFSET+1, DATA_TABLE_BITMAP, FORMAT_PAGE_BUF, NULL);
+        MEMCPY(&tmpDataBlkTbl[BLOCK_CNT_OF_ZONE / 2], FORMAT_PAGE_BUF, SECTOR_SIZE * 4);
+        //calculate the data block table data checksum
+        tmpVar = _CalCheckSum((__u32 *)tmpDataBlkTbl, BLOCK_CNT_OF_ZONE - 1);
+        if(tmpVar != ((__u32 *)tmpDataBlkTbl)[BLOCK_CNT_OF_ZONE - 1])
+        {
+            //the checksum of the data block table is invalid
+            FORMAT_DBG("[FORMAT_DBG] Find the table block %d for zone 0x%x of die 0x%x,"
+                       " but the data block table is invalid!\n",tmpSuperBlk,tmpZoneInDie, pDieInfo->nDie);
+
+            //release the data block table buffer
+            FREE(tmpDataBlkTbl,BLOCK_CNT_OF_ZONE * sizeof(struct __SuperPhyBlkType_t));
+            continue;
+        }
+        FREE(tmpDataBlkTbl,BLOCK_CNT_OF_ZONE * sizeof(struct __SuperPhyBlkType_t));
+
+        //check the log block table data, the size of the log block table is only 0.5k byte
+        _VirtualPageRead(pDieInfo->nDie, tmpSuperBlk, tmpPage+LOG_TBL_OFFSET, LOG_TABLE_BITMAP, FORMAT_PAGE_BUF, NULL);
+        //calcluate the log block table data checksum
+        tmpVar = _CalCheckSum((__u32 *)FORMAT_PAGE_BUF, LOG_BLK_CNT_OF_ZONE*sizeof(struct __LogBlkType_t)/sizeof(__u32));
+        if(tmpVar != ((__u32 *)FORMAT_PAGE_BUF)[511])
+        {
+            //the checksum of the log block table is invalid
+            FORMAT_DBG("[FORMAT_DBG] Find the table block for zone 0x%x of die 0x%x,"
+                       "but the log block tabl is invalid!\n",tmpZoneInDie, pDieInfo->nDie);
+            continue;
+        }
+
+        //set the flag that which mark the zone table status, the current block mapping table is valid
+        pDieInfo->TblBitmap |= (1 << tmpZoneInDie);
+
+        FORMAT_DBG("[FORMAT_DBG] Search block mapping table for zone 0x%x of die 0x%x successfully!\n",
+                    tmpZoneInDie, pDieInfo->nDie);
+    }
+
+    //check if all of the block mapping table of the die has been seared successfully
+    for(tmpVar=0; tmpVar<ZONE_CNT_OF_DIE; tmpVar++)
+    {
+        if(!(pDieInfo->TblBitmap & (1 << tmpVar)))
+        {
+            //search block mapping table of the die failed, report result
+            FORMAT_DBG("[FORMAT_DBG] Search block mapping table for die 0x%x failed!\n", pDieInfo->nDie);
+            return -1;
+        }
+    }
+
+    //search block mapping table of the die successful
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       REBUILD ZONE TABLES FOR ONE NAND FLASH DIE
+*
+*Description: Rebuild zone tables for one nand flash die.
+*
+*Arguments  : pDieInfo   the pointer to the die information whose block mapping table need be rebuiled.
+*
+*Return     :  rebuild result;
+*               = 0     rebuild zone tables successful;
+*               < 0     rebuild zone tables failed.
+************************************************************************************************************************
+*/
+static __s32 _RebuildZoneTbls(struct __ScanDieInfo_t *pDieInfo)
+{
+    __s32 i, result;
+
+    //request buffer for get the logical information of every physical block in the die
+    pDieInfo->pPhyBlk = (__u16 *)MALLOC(SuperBlkCntOfDie * sizeof(__u16));
+    if(!pDieInfo->pPhyBlk)
+    {
+        //request buffer failed, reprot error
+        FORMAT_ERR("[FORMAT_ERR] Malloc buffer for logical information of physical block failed!\n");
+
+        return -1;
+    }
+    //request buffer for process the block mapping table data of a die
+    pDieInfo->ZoneInfo = (struct __ScanZoneInfo_t *) MALLOC(ZONE_CNT_OF_DIE * sizeof(struct __ScanZoneInfo_t));
+    if(!pDieInfo->ZoneInfo)
+    {
+        //request buffer failed, release the buffer which has been got, and report error
+        FORMAT_ERR("[FORMAT_ERR] Malloc buffer for proccess the block mapping table data failed!\n");
+        FREE(pDieInfo->pPhyBlk,SuperBlkCntOfDie * sizeof(__u16));
+
+        return -1;
+    }
+
+    //initiate the buffer data to default value
+    MEMSET(pDieInfo->pPhyBlk, 0xff, SuperBlkCntOfDie * sizeof(__u16));
+    for(i=0; i<ZONE_CNT_OF_DIE; i++)
+    {
+        //initiate every zone information structure of the die
+        pDieInfo->ZoneInfo[i].nDataBlkCnt = 0;
+        pDieInfo->ZoneInfo[i].nFreeBlkCnt = 0;
+        pDieInfo->ZoneInfo[i].nFreeBlkIndex = 0;
+        MEMSET(pDieInfo->ZoneInfo[i].ZoneTbl, 0xff, BLOCK_CNT_OF_ZONE * sizeof(__u32));
+        MEMSET(pDieInfo->ZoneInfo[i].LogBlkTbl, 0xff, MAX_LOG_BLK_CNT * sizeof(struct __LogBlkType_t));
+    }
+
+    //initiate the first super block of the die
+    if(pDieInfo->nDie == 0)
+    {
+        pDieInfo->nFreeIndex = DIE0_FIRST_BLK_NUM;
+    }
+    else
+    {
+        pDieInfo->nFreeIndex = 0;
+    }
+
+    //read the logical information of every physical block of the die
+    result = _GetBlkLogicInfo(pDieInfo);
+
+    //fill the zone table information structure with the logical block information in the Die informaton buffer
+    result = _FillZoneTblInfo(pDieInfo);
+
+    //kick the free blocks that has been used by the valid zone table
+    result = _KickValidTblBlk(pDieInfo);
+
+    //get a physical block in the table block area for every mapping table to save block mapping table
+    result = _GetMapTblBlock(pDieInfo);
+    if(result < 0)
+    {
+        FORMAT_ERR("[FORMAT_ERR] Get block for saving block mapping table failed in die 0x%x!\n", pDieInfo->nDie);
+        FREE(pDieInfo->pPhyBlk,SuperBlkCntOfDie * sizeof(__u16));
+        FREE(pDieInfo->ZoneInfo,ZONE_CNT_OF_DIE * sizeof(struct __ScanZoneInfo_t));
+
+        return -1;
+    }
+
+    //repair the log block table
+    result = _RepairLogBlkTbl(pDieInfo);
+
+    //allocate the free block to every block mapping table
+    result = _DistributeFreeBlk(pDieInfo);
+    if(result < 0)
+    {
+        FORMAT_ERR("[FORMAT_ERR] There is not enough free blocks for distribute!\n");
+
+        FREE(pDieInfo->pPhyBlk,SuperBlkCntOfDie * sizeof(__u16));
+        FREE(pDieInfo->ZoneInfo,ZONE_CNT_OF_DIE * sizeof(struct __ScanZoneInfo_t));
+
+        return -1;
+    }
+
+    //write block mapping table to nand flash
+    result = _WriteBlkMapTbl(pDieInfo);
+    if(result < 0)
+    {
+        FORMAT_ERR("[FORMAT_DBG] Write block mapping table failed!\n");
+
+        FREE(pDieInfo->pPhyBlk,SuperBlkCntOfDie * sizeof(__u16));
+        FREE(pDieInfo->ZoneInfo,ZONE_CNT_OF_DIE * sizeof(struct __ScanZoneInfo_t));
+
+        return RET_FORMAT_TRY_AGAIN;
+    }
+
+#if DBG_DUMP_DIE_INFO
+
+    _DumpDieInfo(pDieInfo);
+
+#endif
+
+    //release the memory resouce
+    FREE(pDieInfo->pPhyBlk,SuperBlkCntOfDie * sizeof(__u16));
+    FREE(pDieInfo->ZoneInfo,ZONE_CNT_OF_DIE * sizeof(struct __ScanZoneInfo_t));
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                                   FORMAT NAND FLASH DISK MODULE INIT
+*
+*Description: Init the nand disk format module, initiate some variables and request resource.
+*
+*Arguments  : none
+*
+*Return     : init result;
+*               = 0     format module init successful;
+*               < 0     format module init failed.
+************************************************************************************************************************
+*/
+#if(0)
+__s32 FMT_Init(void)
+{
+    __s32 i;
+	__u32 TmpBlkSize;
+
+	DIE0_FIRST_BLK_NUM = 0;
+	/*get block number for boot*/
+	for (i = 0; ; i++)
+	{
+		TmpBlkSize = blks_array[i].blk_size;
+		if ( (TmpBlkSize == 0xffffffff) || (TmpBlkSize == SECTOR_CNT_OF_SINGLE_PAGE*PAGE_CNT_OF_PHY_BLK/2))
+		{
+			DIE0_FIRST_BLK_NUM = blks_array[i].blks_boot0 + blks_array[i].blks_boot1;
+			break;
+		}
+
+	}
+
+	//init the global nand flash dirver paramter structure
+    NandDriverInfo.NandStorageInfo = &NandStorageInfo;
+    NandDriverInfo.ZoneTblPstInfo = ZoneTblPstInfo;
+    NandDriverInfo.LogicalArchitecture = &LogicArchiPar;
+    NandDriverInfo.PageCachePool = &PageCachePool;
+
+    //init the logical architecture paramters
+    LogicArchiPar.LogicBlkCntPerZone = NandStorageInfo.ValidBlkRatio;
+    LogicArchiPar.SectCntPerLogicPage = NandStorageInfo.SectorCntPerPage * NandStorageInfo.PlaneCntPerDie;
+    LogicArchiPar.PageCntPerLogicBlk = NandStorageInfo.PageCntPerPhyBlk * NandStorageInfo.BankCntPerChip;
+    if(SUPPORT_EXT_INTERLEAVE)
+    {
+        LogicArchiPar.PageCntPerLogicBlk *= NandStorageInfo.ChipCnt;
+    }
+    LogicArchiPar.ZoneCntPerDie = (NandStorageInfo.BlkCntPerDie / NandStorageInfo.PlaneCntPerDie) / BLOCK_CNT_OF_ZONE;
+
+    //init block mapping table position information
+    for(i=0; i<MAX_ZONE_CNT; i++)
+    {
+        ZoneTblPstInfo[i].PhyBlkNum = 0xffff;
+        ZoneTblPstInfo[i].TablePst = 0xffff;
+    }
+
+    //init some local variable
+    DieCntOfNand = NandStorageInfo.DieCntPerChip / NandStorageInfo.BankCntPerChip;
+    if(!SUPPORT_EXT_INTERLEAVE)
+    {
+        DieCntOfNand *= NandStorageInfo.ChipCnt;
+    }
+    SuperBlkCntOfDie = NandStorageInfo.BlkCntPerDie / NandStorageInfo.PlaneCntPerDie;
+
+    MEMSET(FORMAT_SPARE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * 4);
+
+    FORMAT_DBG("\n");
+    FORMAT_DBG("[FORMAT_DBG] ===========Logical Architecture Paramter===========\n");
+    FORMAT_DBG("[FORMAT_DBG]    Logic Block Count of Zone:  0x%x\n", LogicArchiPar.LogicBlkCntPerZone);
+    FORMAT_DBG("[FORMAT_DBG]    Page Count of Logic Block:  0x%x\n", LogicArchiPar.PageCntPerLogicBlk);
+    FORMAT_DBG("[FORMAT_DBG]    Sector Count of Logic Page: 0x%x\n", LogicArchiPar.SectCntPerLogicPage);
+    FORMAT_DBG("[FORMAT_DBG]    Zone Count of Die:          0x%x\n", LogicArchiPar.ZoneCntPerDie);
+    FORMAT_DBG("[FORMAT_DBG] ===================================================\n");
+
+    return 0;
+}
+#elif(1)
+__s32 FMT_Init(void)
+{
+    __s32 i;
+	__u32 TmpBlkSize;
+
+	DIE0_FIRST_BLK_NUM = 0;
+	/*get block number for boot*/
+	for (i = 0; ; i++)
+	{
+		TmpBlkSize = blks_array[i].blk_size;
+		if ( (TmpBlkSize == 0xffffffff) || (TmpBlkSize == SECTOR_CNT_OF_SINGLE_PAGE*PAGE_CNT_OF_PHY_BLK/2))
+		{
+			DIE0_FIRST_BLK_NUM = blks_array[i].blks_boot0 + blks_array[i].blks_boot1;
+			break;
+		}
+
+	}
+
+	//init the global nand flash dirver paramter structure
+    NandDriverInfo.NandStorageInfo = &NandStorageInfo;
+    NandDriverInfo.ZoneTblPstInfo = ZoneTblPstInfo;
+    NandDriverInfo.LogicalArchitecture = &LogicArchiPar;
+    NandDriverInfo.PageCachePool = &PageCachePool;
+
+    //init the logical architecture paramters
+    LogicArchiPar.LogicBlkCntPerZone = NandStorageInfo.ValidBlkRatio;
+    LogicArchiPar.SectCntPerLogicPage = NandStorageInfo.SectorCntPerPage * NandStorageInfo.PlaneCntPerDie;
+    LogicArchiPar.PageCntPerLogicBlk = NandStorageInfo.PageCntPerPhyBlk * NandStorageInfo.BankCntPerChip;
+    if(SUPPORT_EXT_INTERLEAVE)
+    {
+       if(NandStorageInfo.ChipCnt >=2)
+          LogicArchiPar.PageCntPerLogicBlk *= 2;
+    }
+    LogicArchiPar.ZoneCntPerDie = (NandStorageInfo.BlkCntPerDie / NandStorageInfo.PlaneCntPerDie) / BLOCK_CNT_OF_ZONE;
+
+    //init block mapping table position information
+    for(i=0; i<MAX_ZONE_CNT; i++)
+    {
+        ZoneTblPstInfo[i].PhyBlkNum = 0xffff;
+        ZoneTblPstInfo[i].TablePst = 0xffff;
+    }
+
+    //init some local variable
+    DieCntOfNand = NandStorageInfo.DieCntPerChip / NandStorageInfo.BankCntPerChip;
+    if(!SUPPORT_EXT_INTERLEAVE)
+    {
+        DieCntOfNand *= NandStorageInfo.ChipCnt;
+    }
+    if(SUPPORT_EXT_INTERLEAVE)
+    {
+       if(NandStorageInfo.ChipCnt >=2)
+	   DieCntOfNand *= (NandStorageInfo.ChipCnt/2);
+    }
+    SuperBlkCntOfDie = NandStorageInfo.BlkCntPerDie / NandStorageInfo.PlaneCntPerDie;
+
+    MEMSET(FORMAT_SPARE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * 4);
+
+    FORMAT_DBG("\n");
+    FORMAT_DBG("[FORMAT_DBG] ===========Logical Architecture Paramter===========\n");
+    FORMAT_DBG("[FORMAT_DBG]    Logic Block Count of Zone:  0x%x\n", LogicArchiPar.LogicBlkCntPerZone);
+    FORMAT_DBG("[FORMAT_DBG]    Page Count of Logic Block:  0x%x\n", LogicArchiPar.PageCntPerLogicBlk);
+    FORMAT_DBG("[FORMAT_DBG]    Sector Count of Logic Page: 0x%x\n", LogicArchiPar.SectCntPerLogicPage);
+    FORMAT_DBG("[FORMAT_DBG]    Zone Count of Die:          0x%x\n", LogicArchiPar.ZoneCntPerDie);
+    FORMAT_DBG("[FORMAT_DBG] ===================================================\n");
+
+    return 0;
+}
+#endif
+
+/*
+************************************************************************************************************************
+*                                   FORMAT NAND FLASH DISK MODULE EXIT
+*
+*Description: Exit the nand disk format module, release some resource.
+*
+*Arguments  : none
+*
+*Return     : exit result;
+*               = 0     format module exit successful;
+*               < 0     format module exit failed.
+************************************************************************************************************************
+*/
+__s32 FMT_Exit(void)
+{
+    //release memory resource
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                                   FORMAT NAND FLASH DISK
+*
+*Description: Format the nand flash disk, create a logical disk area.
+*
+*Arguments  : none
+*
+*Return     : format result;
+*               = 0     format nand successful;
+*               < 0     format nand failed.
+*
+*Note       : This function look for the mapping information on the nand flash first, if the find all
+*             mapping information and check successful, format nand disk successful; if the mapping
+*             information has some error, need repair it. If find none mapping information, create it!
+************************************************************************************************************************
+*/
+__s32 FMT_FormatNand(void)
+{
+    __s32 tmpDie, result, tmpTryAgain;
+    struct __ScanDieInfo_t tmpDieInfo;
+
+	result = 0;
+
+    //process tables in every die in the nand storage system
+    for(tmpDie=0; tmpDie<DieCntOfNand; tmpDie++)
+    {
+        //init the die information data structure
+        MEMSET(&tmpDieInfo, 0, sizeof(struct __ScanDieInfo_t));
+        tmpDieInfo.nDie = tmpDie;
+
+        //search zone tables on the nand flash from several blocks in front of the die
+        result = _SearchZoneTbls(&tmpDieInfo);
+		//tmpDieInfo.TblBitmap = 0;
+		//result = -1;
+        if(result < 0)
+        {
+            tmpTryAgain = 5;
+            while(tmpTryAgain > 0)
+            {
+                //search zone tables from the nand flash failed, need repair or build it
+                result = _RebuildZoneTbls(&tmpDieInfo);
+
+                if(result != RET_FORMAT_TRY_AGAIN)
+                {
+                    break;
+                }
+
+                tmpTryAgain--;
+            }
+        }
+    }
+
+    if(result < 0)
+    {
+        //format nand disk failed, report error
+        FORMAT_ERR("[FORMAT_ERR] Format nand disk failed!\n");
+        return -1;
+    }
+
+    //format nand disk successful
+    return 0;
+}
+
+void clear_NAND_ZI( void )
+{
+    MEMSET(&PageCachePool, 0x00, sizeof(struct __NandPageCachePool_t));
+}
+
+
+
diff --git a/drivers/block/sunxi_nand/src/include/nand_drv_cfg.h b/drivers/block/sunxi_nand/src/include/nand_drv_cfg.h
new file mode 100644
index 0000000..dff1d77
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/include/nand_drv_cfg.h
@@ -0,0 +1,220 @@
+/*
+ * drivers/block/sunxi_nand/src/include/nand_drv_cfg.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAND_DRV_CFG_H
+#define __NAND_DRV_CFG_H
+
+#include "nand_oal.h"
+//==============================================================================
+//  define the value of some variable for
+//==============================================================================
+
+#define  NAND_VERSION_0                 0x02
+#define  NAND_VERSION_1                 0x09
+
+
+//define the max value of the count of chip select
+#if(0)
+  #define MAX_CHIP_SELECT_CNT                 (4)
+#elif(1)
+  #define MAX_CHIP_SELECT_CNT                 (8)
+#endif
+
+//define the max value the count of the zone
+#define MAX_ZONE_CNT                        (32)
+
+//define the max value of the count of the log block in a zone, the recommended value is 8
+#define MAX_LOG_BLK_CNT                     (16)
+
+//define the value of the count of the block mapping table cache
+#define BLOCK_MAP_TBL_CACHE_CNT             (MAX_ZONE_CNT)
+
+//define the max value of the count of the page mapping table cache
+#define PAGE_MAP_TBL_CACHE_CNT              (MAX_LOG_BLK_CNT * MAX_ZONE_CNT)
+
+//check if block mapping table cache is valid
+#if (BLOCK_MAP_TBL_CACHE_CNT < 1)
+#error BLOCK_MAP_TBL_CACHE_CNT config error, the value must be larger than 0!!!
+#endif
+//check if page mapping table cache is valid
+#if (PAGE_MAP_TBL_CACHE_CNT < 1)
+#error PAGE_MAP_TBL_CACHE_CNT config error, the value must be larger than 0!!!
+#endif
+
+//define the frequency of the doing wear-levelling
+#define WEAR_LEVELLING_FREQUENCY            (10)
+
+//define the number of the chip select which connecting the boot chip
+#define BOOT_CHIP_SELECT_NUM                (0)
+
+//define the default value the count of the data block in one zone
+#define DEFAUL_DATA_BLK_CNT_PER_ZONE        (1000)
+#if (DEFAUL_DATA_BLK_CNT_PER_ZONE > 1000)
+#error  DEFAUL_DATA_BLK_CNT_PER_ZONE config error, the value must not be larger than 1000!!!
+#endif
+
+//==============================================================================
+//  define some sitch to decide if need support some operation
+//==============================================================================
+
+//define the switch that if need support multi-plane program
+#define CFG_SUPPORT_MULTI_PLANE_PROGRAM         (1)
+
+//define the switch that if need support multi-plane read
+#define CFG_SUPPORT_MULTI_PLANE_READ            (0)
+
+//define the switch that if need support internal inter-leave
+#define CFG_SUPPORT_INT_INTERLEAVE              (0)
+
+//define the switch that if need support external inter-leave
+#define CFG_SUPPORT_EXT_INTERLEAVE              (1)
+
+//define the switch that if need support cache program
+#define CFG_SUPPORT_CACHE_PROGRAM               (0)
+
+//define the switch that if need support doing page copyback by send command
+#define CFG_SUPPORT_PAGE_COPYBACK               (1)
+
+//define the switch that if need support wear-levelling
+#define CFG_SUPPORT_WEAR_LEVELLING              (0)
+
+//define the switch that if need support read-reclaim
+#define CFG_SUPPORT_READ_RECLAIM                (1)
+
+//define if need check the page program status after page program immediately
+#define CFG_SUPPORT_CHECK_WRITE_SYNCH           (0)
+
+//define if need support align bank when allocating the log page
+#define CFG_SUPPORT_ALIGN_NAND_BNK              (1)
+
+//define if need support Randomizer
+#define CFG_SUPPORT_RANDOM                      (1)
+
+//define if need support ReadRetry
+#define CFG_SUPPORT_READ_RETRY                  (1)
+
+
+#define SUPPORT_DMA_IRQ							(0)
+#define SUPPORT_RB_IRQ							(0)
+
+//==============================================================================
+//  define some pr__s32 switch
+//==============================================================================
+
+//define if need pr__s32 the physic operation module debug message
+#define PHY_DBG_MESSAGE_ON                  (0)
+
+//define if need pr__s32 the physic operation module error message
+#define PHY_ERR_MESSAGE_ON                  (1)
+
+//define if need pr__s32 the nand hardware scan module debug message
+#define SCAN_DBG_MESSAGE_ON                 (0)
+
+//define if need pr__s32 the nand hardware scan module error message
+#define SCAN_ERR_MESSAGE_ON                 (1)
+
+//define if need pr__s32 the nand disk format module debug message
+#define FORMAT_DBG_MESSAGE_ON               (0)
+
+//define if need pr__s32 the nand disk format module error message
+#define FORMAT_ERR_MESSAGE_ON               (1)
+
+//define if need pr__s32 the mapping manage module debug message
+#define MAPPING_DBG_MESSAGE_ON              (0)
+
+//define if need pr__s32 the mapping manage module error message
+#define MAPPING_ERR_MESSAGE_ON              (1)
+
+//define if need pr__s32 the logic control layer debug message
+#define LOGICCTL_DBG_MESSAGE_ON             (0)
+
+//define if need pr__s32 the logic control layer error message
+#define LOGICCTL_ERR_MESSAGE_ON             (1)
+
+
+#if PHY_DBG_MESSAGE_ON
+#define	   PHY_DBG(...)        			PRINT(__VA_ARGS__)
+#else
+#define     PHY_DBG(...)
+#endif
+
+#if PHY_ERR_MESSAGE_ON
+#define     PHY_ERR(...)        		PRINT(__VA_ARGS__)
+#else
+#define     PHY_ERR(...)
+#endif
+
+
+#if SCAN_DBG_MESSAGE_ON
+#define     SCAN_DBG(...)          		PRINT(__VA_ARGS__)
+#else
+#define     SCAN_DBG(...)
+#endif
+
+#if SCAN_ERR_MESSAGE_ON
+#define     SCAN_ERR(...)         		PRINT(__VA_ARGS__)
+#else
+#define     SCAN_ERR(...)
+#endif
+
+
+#if FORMAT_DBG_MESSAGE_ON
+#define     FORMAT_DBG(...)         	PRINT(__VA_ARGS__)
+#else
+#define     FORMAT_DBG(...)
+#endif
+
+#if FORMAT_ERR_MESSAGE_ON
+#define     FORMAT_ERR(...)        		PRINT(__VA_ARGS__)
+#else
+#define     FORMAT_ERR(...)
+#endif
+
+
+#if MAPPING_DBG_MESSAGE_ON
+#define     MAPPING_DBG(...)        	PRINT(__VA_ARGS__)
+#else
+#define     MAPPING_DBG(...)
+#endif
+
+#if MAPPING_ERR_MESSAGE_ON
+#define     MAPPING_ERR(...)       		PRINT(__VA_ARGS__)
+#else
+#define     MAPPING_ERR(...)
+#endif
+
+
+#if LOGICCTL_DBG_MESSAGE_ON
+#define     LOGICCTL_DBG(...)       	PRINT(__VA_ARGS__)
+#else
+#define     LOGICCTL_DBG(...)
+#endif
+
+#if LOGICCTL_ERR_MESSAGE_ON
+#define     LOGICCTL_ERR(...)       	PRINT(__VA_ARGS__)
+#else
+#define     LOGICCTL_ERR(...)
+#endif
+
+
+#endif //ifndef __NAND_DRV_CFG_H
+
diff --git a/drivers/block/sunxi_nand/src/include/nand_format.h b/drivers/block/sunxi_nand/src/include/nand_format.h
new file mode 100644
index 0000000..4248dea
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/include/nand_format.h
@@ -0,0 +1,173 @@
+/*
+ * drivers/block/sunxi_nand/src/include/nand_format.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAND_FORMAT_H__
+#define __NAND_FORMAT_H__
+
+#include "nand_type.h"
+#include "nand_physic.h"
+
+
+//define the structure for a zone detail information
+struct __ScanZoneInfo_t
+{
+    __u16   nDataBlkCnt;                //the count of data blocks in a zone
+    __u16   nFreeBlkCnt;                //the count of free blocks in a zone
+    __u16   nFreeBlkIndex;              //the index of the free blocks in a zone
+    __u16   Reserved;                   //reserved for 32bit aligned
+    struct __SuperPhyBlkType_t ZoneTbl[BLOCK_CNT_OF_ZONE];  //the zone table buffer
+	struct __LogBlkType_t LogBlkTbl[MAX_LOG_BLK_CNT];       //the log block mapping table buffer
+};
+
+
+//define the structure for a nand flash die detail information
+struct __ScanDieInfo_t
+{
+    __u8    nDie;                       //the number of the die in the nand flash storage system
+    __u8    TblBitmap;                  //the bitmap that mark the block mapping table status in a die
+    __u16   nBadCnt;                    //the count of the bad block in a nand die
+    __u16   nFreeCnt;                   //the count of the free block in a nand die
+    __u16   nFreeIndex;                 //the free block allocate index
+    __u16   *pPhyBlk;                   //the pointer to the physical block information buffer of a whole die
+    struct __ScanZoneInfo_t *ZoneInfo;  //the pointer to the zone table detail information of the whole die
+};
+
+//define the first super block used for block mapping, the front used for boot
+typedef struct _blk_for_boot1_t
+{
+	__u32 blk_size; //unit by k
+	__u32 blks_boot0;
+	__u32 blks_boot1;
+}blk_for_boot1_t;
+
+//define the max value of the default position of the block mapping table
+#define TBL_AREA_BLK_NUM    32
+
+//define the sector bitmap in a super page to get the user data
+#if (0)
+#define SPARE_DATA_BITMAP   (SUPPORT_MULTI_PROGRAM ? (0x3 | (0x3 << SECTOR_CNT_OF_SINGLE_PAGE)) : 0x1)
+#elif (1)
+#define SPARE_DATA_BITMAP   FULL_BITMAP_OF_SUPER_PAGE
+#endif
+//define the sector bitmap in a super page to get the logical information in the spare area
+#if (0)
+#define LOGIC_INFO_BITMAP   (SUPPORT_MULTI_PROGRAM ? (0x1 | (0x1 << SECTOR_CNT_OF_SINGLE_PAGE)) : 0x1)
+#elif (1)
+#define LOGIC_INFO_BITMAP   FULL_BITMAP_OF_SUPER_PAGE
+#endif
+//define the sector bitmap in a super page for table data operation
+#define DATA_TABLE_BITMAP   0xf         //the bitmap for check data block table of block mapping table
+#define LOG_TABLE_BITMAP    0xf         //the bitmap for check log block table of block mapping table
+#define DIRTY_FLAG_BITMAP   0x1         //the bitmap for check dirty flag of block mapping table
+
+//define the offset of tables in one table group
+#define DATA_TBL_OFFSET     0           //page0 and page1 of a table group are used for data & free block table
+#define LOG_TBL_OFFSET      2           //page2 of a table group is used for log block table
+#define DIRTY_FLAG_OFFSET   3           //page3 of a table group is used for dirty flag
+#define PAGE_CNT_OF_TBL_GROUP       4   //one table group contain 4 pages
+
+//define the page buffer for cache the super page data for read or write
+#define FORMAT_PAGE_BUF     (PageCachePool.PageCache0)
+
+#define FORMAT_SPARE_BUF    (PageCachePool.SpareCache)
+
+//define the empty item in the logical information buffer
+#define NULL_BLOCK_INFO     0xfffd
+//define the bad block information in the logcial information buffer
+#define BAD_BLOCK_INFO      0xfffe
+//define the free block infomation in the logical information buffer
+#define FREE_BLOCK_INFO     0xffff
+
+//define the mark for allocate the free block
+#define ALLOC_BLK_MARK      ((0x1<<14) | 0xff)
+
+
+//define the macro for compare the log age of the blocks
+#define COMPARE_AGE(a, b)           ((signed char)((signed char)(a) - (signed char)(b)))
+
+//define the macro for get the zone number in the logical information of physical block
+#define GET_LOGIC_INFO_ZONE(a)      ((((unsigned int)(a))>>10) & 0x0f)
+//define the macro for get the block used type in the logical information of physical block
+#define GET_LOGIC_INFO_TYPE(a)      ((((unsigned int)(a))>>14) & 0x01)
+//define the macro for get the logical block number in the logical information of physical block
+#define GET_LOGIC_INFO_BLK(a)       (((unsigned int)(a)) & 0x03ff)
+
+//define the return value of format error when we should try format again
+#define RET_FORMAT_TRY_AGAIN        (-2)
+
+/*
+************************************************************************************************************************
+*                                   FORMAT NAND FLASH DISK MODULE INIT
+*
+*Description: Init the nand disk format module, initiate some variables and request resource.
+*
+*Arguments  : none
+*
+*Return     : init result;
+*               = 0     format module init successful;
+*               < 0     format module init failed.
+************************************************************************************************************************
+*/
+__s32 FMT_Init(void);
+
+
+/*
+************************************************************************************************************************
+*                                   FORMAT NAND FLASH DISK MODULE EXIT
+*
+*Description: Exit the nand disk format module, release some resource.
+*
+*Arguments  : none
+*
+*Return     : exit result;
+*               = 0     format module exit successful;
+*               < 0     format module exit failed.
+************************************************************************************************************************
+*/
+__s32 FMT_Exit(void);
+
+
+/*
+************************************************************************************************************************
+*                                   FORMAT NAND FLASH DISK
+*
+*Description: Format the nand flash disk, create a logical disk area.
+*
+*Arguments  : none
+*
+*Return     : format result;
+*               = 0     format nand successful;
+*               < 0     format nand failed.
+*
+*Note       : This function look for the mapping information on the nand flash first, if the find all
+*             mapping information and check successful, format nand disk successful; if the mapping
+*             information has some error, need repair it. If find none mapping information, create it!
+************************************************************************************************************************
+*/
+__s32 FMT_FormatNand(void);
+
+
+void clear_NAND_ZI( void );
+
+#endif  //ifndef __NAND_FORMAT_H__
+
+
diff --git a/drivers/block/sunxi_nand/src/include/nand_logic.h b/drivers/block/sunxi_nand/src/include/nand_logic.h
new file mode 100644
index 0000000..e5413ea
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/include/nand_logic.h
@@ -0,0 +1,573 @@
+/*
+ * drivers/block/sunxi_nand/src/include/nand_logic.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAND_LOGIC_H__
+#define __NAND_LOGIC_H__
+
+#include "nand_type.h"
+#include "nand_physic.h"
+
+
+//==============================================================================
+//  define the logical architecture export parameter
+//==============================================================================
+
+//define the count of the sectors in the logical page
+#define SECTOR_CNT_OF_LOGIC_PAGE    SECTOR_CNT_OF_SUPER_PAGE
+
+//define the full bitmap of sector in the logical page
+#define FULL_BITMAP_OF_LOGIC_PAGE   FULL_BITMAP_OF_SUPER_PAGE
+
+//define the count of the pages in a logical block
+#define PAGE_CNT_OF_LOGIC_BLK       (NandDriverInfo.LogicalArchitecture->PageCntPerLogicBlk)
+
+//define the count of the pages in a super physical block, size is same as the logical block
+#define PAGE_CNT_OF_SUPER_BLK       PAGE_CNT_OF_LOGIC_BLK
+
+//define the count of the data block in a zone, the value is based on the ration of the invalid blocks
+#define DATA_BLK_CNT_OF_ZONE        (NandDriverInfo.LogicalArchitecture->LogicBlkCntPerZone)
+
+//define the count of the free block item in a free block table of a zone
+#define FREE_BLK_CNT_OF_ZONE        (BLOCK_CNT_OF_ZONE - DATA_BLK_CNT_OF_ZONE - 1)
+
+
+//define the count of the log block in a zone, the value is configurable, recommended value is 8
+#define LOG_BLK_CNT_OF_ZONE         MAX_LOG_BLK_CNT
+
+//define the count of the free block in a zone
+#define FREE_BLK_CNT_OF_ZONE        (BLOCK_CNT_OF_ZONE - DATA_BLK_CNT_OF_ZONE - 1)
+
+//define the count of the zone in a die
+#define ZONE_CNT_OF_DIE             (NandDriverInfo.LogicalArchitecture->ZoneCntPerDie)
+
+//define the total count of inter-leave banks
+#define INTERLEAVE_BANK_CNT         (PAGE_CNT_OF_LOGIC_BLK / NandDriverInfo.NandStorageInfo->PageCntPerPhyBlk)
+
+//define the buffer for cache data when write loigcal sector
+
+//define the buffer for processing the data of mapping table
+#define LML_PROCESS_TBL_BUF         (NandDriverInfo.PageCachePool->PageCache2)
+
+//define the buffer for copy page data or process other data
+#define LML_TEMP_BUF                (NandDriverInfo.PageCachePool->PageCache0)
+#define LML_WRITE_PAGE_CACHE        (NandDriverInfo.PageCachePool->PageCache1)
+
+#define LML_SPARE_BUF               (NandDriverInfo.PageCachePool->SpareCache)
+
+//==============================================================================
+//  define the mapping table access export parameter
+//==============================================================================
+
+//define the pointer for block mapping table cache pool accessing
+#define BLK_MAP_CACHE_POOL          (NandDriverInfo.BlkMapTblCachePool)
+
+//define the counter of the super block erase, for do wear-levelling
+#define BLK_ERASE_CNTER             (BLK_MAP_CACHE_POOL->SuperBlkEraseCnt)
+
+//define the log block access timer for set log block access age
+#define LOG_ACCESS_TIMER            (BLK_MAP_CACHE_POOL->LogBlkAccessTimer)
+
+//define the log block access age array
+#define LOG_ACCESS_AGE              (BLK_MAP_CACHE_POOL->LogBlkAccessAge)
+
+//define the pointer for active block mapping table accessing
+#define BLK_MAP_CACHE               (BLK_MAP_CACHE_POOL->ActBlkMapTbl)
+
+//define the free block position that get free block last time
+#define LAST_FREE_BLK_PST           (BLK_MAP_CACHE->LastFreeBlkPst)
+
+//define the pointer for active data block table accessing
+#define DATA_BLK_TBL                (BLK_MAP_CACHE->DataBlkTbl)
+
+//define the pointer for active log block table accessing
+#define LOG_BLK_TBL                 (BLK_MAP_CACHE->LogBlkTbl)
+
+//define the pointer for active free block table accessing
+#define FREE_BLK_TBL                (BLK_MAP_CACHE->FreeBlkTbl)
+
+//define the zone number of the active block mapping table
+#define CUR_MAP_ZONE                (BLK_MAP_CACHE->ZoneNum)
+
+//define the pointer for page mapping table cahce pool accessing
+#define PAGE_MAP_CACHE_POOL         (NandDriverInfo.PageMapTblCachePool)
+
+//define the pointer for active page mapping table cache accessing
+#define PAGE_MAP_CACHE              (NandDriverInfo.PageMapTblCachePool->ActPageMapTbl)
+
+//define the pointer for active page mapping table accessing
+#define PAGE_MAP_TBL                (PAGE_MAP_CACHE->PageMapTbl)
+
+//define the type of merger operation
+#define NORMAL_MERGE_MODE       0x00                //normal merge mode, there is not enough log item
+#define SPECIAL_MERGE_MODE      0x01                //special merge mode, there is not enough log page
+
+//define the invalid page number
+#define INVALID_PAGE_NUM        0xffff
+
+//define the type for get free block from free block table
+#define LOWEST_EC_TYPE          0x00
+#define HIGHEST_EC_TYPE         0x01
+
+
+//==============================================================================
+//  define the function interface for logic manage module
+//==============================================================================
+
+/*
+************************************************************************************************************************
+*                           INITIATE NAND FLASH LOGIC MANAGE LAYER
+*
+*Description: initiate the logic manage layer for nand flash driver.
+*
+*Arguments  : none;
+*
+*Return     : intiate result;
+*               = 0     init successful;
+*               = -1    init failed.
+************************************************************************************************************************
+*/
+__s32 LML_Init(void);
+
+
+/*
+************************************************************************************************************************
+*                           NAND FLASH LOGIC MANAGE LAYER EXIT
+*
+*Description: exit nand flash logic manage layer.
+*
+*Arguments  : none;
+*
+*Return     : exit result;
+*               = 0     exit successfu;
+*               = -1    exit failed.
+************************************************************************************************************************
+*/
+__s32 LML_Exit(void);
+
+
+/*
+************************************************************************************************************************
+*                           NAND FLASH LOGIC MANAGE LAYER READ
+*
+*Description: Read data from logic disk area to buffer.
+*
+*Arguments  : nLba      the logic block address on the logic area from where to read;
+*             nLength   the size of the data need be read, based on sector;
+*             pBuf      the pointer to the buffer where will store the data readout of nand.
+*
+*Return     : read result;
+*               = 0     read successful;
+*               = -1    read failed.
+************************************************************************************************************************
+*/
+__s32 LML_Read(__u32 nLba, __u32 nLength, void* pBuf);
+
+
+/*
+************************************************************************************************************************
+*                           NAND FLASH LOGIC MANAGE LAYER WRITE
+*
+*Description: Write data from buffer to logic disk area.
+*
+*Arguments  : nLba      the logic block address on the logic area from where to write;
+*             nLength   the size of the data need to be write, based on sector;
+*             pBuf      the pointer to the buffer where stored the data write to nand flash.
+*
+*Return     : write result;
+*               = 0     write successful;
+*               = -1    write failed.
+************************************************************************************************************************
+*/
+__s32 LML_Write(__u32 nLba, __u32 nLength, void* pBuf);
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER FLUSH PAGE CACHE
+*
+*Description: Flush the data in the cache buffer to nand flash.
+*
+*Arguments  : none
+
+*Return     : flush result;
+*               = 0     flush successful;
+*               = -1    flush failed.
+************************************************************************************************************************
+*/
+__s32 LML_FlushPageCache(void);
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER PAGE READ
+*
+*Description: Read data from logic disk to buffer based page.
+*
+*Arguments  : nPage     the page address which need be read;
+*             nBitmap   the bitmap of the sectors in the page which need be read data;
+*             pBuf      the pointer to the buffer where will store the data read out.
+*
+*Return     : page read result;
+*               = 0     read successful;
+*               > 0     read successful, but need do some process;
+*               < 0     read failed.
+************************************************************************************************************************
+*/
+__s32 LML_PageRead(__u32 nPage, __u32 nBitmap, void* pBuf);
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER PAGE WRITE
+*
+*Description: Write data from buffer to logic area based on page.
+*
+*Arguments  : nPage     the page address which need be write;
+*             nBitmap   the bitmap of sectors in the page which need be write, it is always full;
+*             pBuf      the pointer to the buffer where is storing the data.
+*
+*Return     : write result;
+*               = 0     write successful;
+*               > 0     write successful, but need do some process;
+*               < 0     write failed.
+************************************************************************************************************************
+*/
+__s32 LML_PageWrite(__u32 nPage, __u32 nBitmap, void* pBuf);
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER READ-RECLAIM
+*
+*Description: Repair the logic block whose data has reach the limit of the ability of
+*             the HW ECC module correct.
+*
+*Arguments  : nPage     the page address where need be repaired.
+*
+*Return     : read-reclaim result;
+*               = 0     do read-reclaim successful;
+*               = -1    do read-reclaim failed.
+*
+*Notes      : if read a physical page millions of times, there may be some bit error in
+*             the page, and the error bit number will increase along with the read times,
+*             so, if the number of the error bit reachs the ECC limit, the data should be
+*             read out and write to another physical blcok.
+************************************************************************************************************************
+*/
+__s32 LML_ReadReclaim(__u32 nPage);
+
+
+/*
+************************************************************************************************************************
+*                   NAND FLASH LOGIC MANAGE LAYER WEAR-LEVELLING
+*
+*Description: Equate the erase cycles among all physical blocks.
+*
+*Arguments  : none
+*
+*Return     : do wear-levelling result;
+*               = 0     do wear-levelling successful;
+*               = -1    do wear-levelling failed.
+*
+*Notes      : The erase cycle of a physical block is limited, if the erase cycle overun this
+*             limit, the physical block may be invalid. so a policy is needed to equate the
+*             millions of erase cycles to ervery physical block.
+************************************************************************************************************************
+*/
+__s32 LML_WearLevelling(void);
+
+
+/*
+************************************************************************************************************************
+*                   NAND FLASH LOGIC MANAGE LAYER CALCULATE PHYSICAL ADDRESS
+*
+*Description: Calculate the physical address parameter.
+*
+*Arguments  : pPhyPar   the pointer to the physical address parameter;
+*             nZone     the zone number which the superblock belonged to;
+*             nBlock    the number of the super block in a DIE;
+*             nPage     the page number in the super block.
+*
+*Return     : calculate result;
+*               = 0     calculate successful;
+*               = -1    calculate failed.
+************************************************************************************************************************
+*/
+__s32 LML_CalPhyPar(struct __PhysicOpPara_t *pPhyPar, __u32 nZone, __u32 nBlock, __u32 nPage);
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER BAD BLOCK MANAGE
+*
+*Description: Nand flash bad block manage.
+*
+*Arguments  : pBadBlk   the pointer to the bad physical block parameter;
+*             nZoneNum  the number of the zone which the bad block belonged to;
+*             nErrPage  the number of the error page;
+*             pNewBlk   the pointer to the new valid block parameter.
+*
+*Return     : bad block manage result;
+*               = 0     do bad block manage successful;
+*               = -1    do bad block manage failed.
+************************************************************************************************************************
+*/
+__s32 LML_BadBlkManage(struct __SuperPhyBlkType_t *pBadBlk, __u32 nZoneNum, __u32 nErrPage, struct __SuperPhyBlkType_t *pNewBlk);
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER MERGE LOG BLOCK
+*
+*Description: Merge the log block whoes mapping table is active.
+*
+*Arguments  : nMode         the type of the merge;
+*                           = 0     normal merge, the log block  table is not full;
+*                           = 1     special merge, the log block table is full;
+*             nLogicBlk     the number of the logical block, which need be merged.
+*
+*Return     : merge result;
+*               = 0     merge log successful;
+*               = -1    do bad block manage failed.
+************************************************************************************************************************
+*/
+__s32 LML_MergeLogBlk(__u32 nMode, __u32 nLogicBlk);
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER ERASE SUPER BLOCK
+*
+*Description: Erase the given super block.
+*
+*Arguments  : nZone         the number of the zone which the super block belonged to;
+*             nSuperBlk     the number of the super block which need be erased.
+*
+*Return     : erase result
+*               = 0     super block erase successful;
+*               =-1     super block erase failed.
+************************************************************************************************************************
+*/
+__s32 LML_SuperBlkErase(__u32 nZone, __u32 nSuperBlk);
+
+
+/*
+************************************************************************************************************************
+*                       CALCULATE PHYSICAL OPERATION PARAMETER
+*
+*Description: Calculate the paramter for physical operation with the number of zone, number of
+*             super block and number of page in the super block.
+*
+*Arguments  : pPhyPar   the pointer to the physical operation parameter;
+*             nZone     the number of the zone which the super block blonged to;
+*             nBlock    the number of the super block;
+*             nPage     the number of the super page in the super block.
+*
+*Return     : calculate parameter result;
+*               = 0     calculate parameter successful;
+*               < 0     calcualte parameter failed.
+************************************************************************************************************************
+*/
+__s32 LML_CalculatePhyOpPar(struct __PhysicOpPara_t *pPhyPar, __u32 nZone, __u32 nBlock, __u32 nPage);
+
+
+/*
+************************************************************************************************************************
+*                       INIT BLOCK MAPPING TABLE CACHE
+*
+*Description: Initiate block mapping talbe cache.
+*
+*Arguments  : none.
+*
+*Return     : init result;
+*               = 0     init successful;
+*               = -1    init failed.
+************************************************************************************************************************
+*/
+__s32 BMM_InitMapTblCache(void);
+
+
+/*
+************************************************************************************************************************
+*                       BLOCK MAPPING TABLE CACHE EXIT
+*
+*Description: exit block mapping table cache.
+*
+*Arguments  : none.
+*
+*Return     : exit result;
+*               = 0     exit successful;
+*               = -1    exit failed.
+************************************************************************************************************************
+*/
+__s32 BMM_ExitMapTblCache(void);
+
+
+/*
+************************************************************************************************************************
+*                       SWITCH BLOCK MAPPING TABLE
+*
+*Description: Switch block mapping table.
+*
+*Arguments  : nZone     zone number which block mapping table need be accessed.
+*
+*Return     : switch result;
+*               = 0     switch successful;
+*               = -1    switch failed.
+************************************************************************************************************************
+*/
+__s32 BMM_SwitchMapTbl(__u32 nZone);
+
+
+/*
+************************************************************************************************************************
+*                           WRITE BACK ALL MAPPING TABLE
+*
+*Description: Write back all mapping table.
+*
+*Arguments  : none.
+*
+*Return     : write table result;
+*               = 0     write successful;
+*               = -1    write failed.
+************************************************************************************************************************
+*/
+__s32 BMM_WriteBackAllMapTbl(void);
+
+
+/*
+************************************************************************************************************************
+*                       SET DIRTY FLAG FOR BLOCK MAPPING TABLE
+*
+*Description: Set dirty flag for block mapping table.
+*
+*Arguments  : none.
+*
+*Return     : set dirty flag result;
+*               = 0     set dirty flag successful;
+*               = -1    set dirty flag failed.
+************************************************************************************************************************
+*/
+__s32 BMM_SetDirtyFlag(void);
+
+
+/*
+************************************************************************************************************************
+*                       CALCULATE BLOCK MAPPING TABLE ACCESS COUNT
+*
+*Description: Calculate block mapping table access count for cache switch.
+*
+*Arguments  : none.
+*
+*Return     : none;
+************************************************************************************************************************
+*/
+void BMM_CalAccessCount(void);
+
+
+/*
+************************************************************************************************************************
+*                       INIT PAGE MAPPING TABLE CACHE
+*
+*Description: Init page mapping table cache.
+*
+*Arguments  : none.
+*
+*Return     : init result;
+*               = 0         init page mapping table cache successful;
+*               = -1        init page mapping table cache failed.
+************************************************************************************************************************
+*/
+__s32 PMM_InitMapTblCache(void);
+
+
+/*
+************************************************************************************************************************
+*                       EXIT PAGE MAPPING TABLE CACHE
+*
+*Description: Exit page mapping table cache.
+*
+*Arguments  : none.
+*
+*Return     : exit result;
+*               = 0         exit page mapping table cache successful;
+*               = -1        exit page mapping table cache failed.
+************************************************************************************************************************
+*/
+__s32 PMM_ExitMapTblCache(void);
+
+
+/*
+************************************************************************************************************************
+*                      SWITCH PAGE MAPPING TABLE
+*
+*Description: Switch page mapping table cache.
+*
+*Arguments  : nLogBlkPst    the position of the log block in the log block table.
+*
+*Return     : switch result;
+*               = 0     switch table successful;
+*               = -1    switch table failed.
+************************************************************************************************************************
+*/
+__s32 PMM_SwitchMapTbl(__u32 nLogBlkPst);
+
+
+/*
+************************************************************************************************************************
+*                      CALCUALTE PAGE MAPPING TABLE ACCESS COUNT
+*
+*Description: Calculate page mapping table access count for table cache switch.
+*
+*Arguments  : none.
+*
+*Return     : none.
+************************************************************************************************************************
+*/
+void PMM_CalAccessCount(void);
+
+__s32 BMM_GetDataBlk(__u32 nBlk, struct __SuperPhyBlkType_t *pDataBlk);
+__s32 BMM_SetDataBlk(__u32 nBlk, struct __SuperPhyBlkType_t *pDataBlk);
+__s32 BMM_GetFreeBlk(__u32 nType, struct __SuperPhyBlkType_t *pFreeBlk);
+__s32 BMM_SetFreeBlk(struct __SuperPhyBlkType_t *pFreeBlk);
+__s32 BMM_GetLogBlk(__u32 nLogicBlk, struct __LogBlkType_t *pLogBlk);
+__s32 BMM_SetLogBlk(__u32 nLogicBlk, struct __LogBlkType_t *pLogBlk);
+__u32 PMM_GetLogPage(__u32 nBlk, __u32 nPage, __u8 nMode);
+void PMM_ClearCurMapTbl(void);
+__u32 PMM_GetCurMapPage(__u16 nLogicalPage);
+void PMM_SetCurMapPage(__u16 nLogicalPage,__u16 nPhysicPage);
+__s32 LML_VirtualBlkErase(__u32 nZone, __u32 nSuperBlk);
+__s32 LML_VirtualPageWrite( struct __PhysicOpPara_t *pVirtualPage);
+__s32 LML_VirtualPageRead(struct __PhysicOpPara_t *pVirtualPage);
+
+__s32 NAND_CacheFlush(void);
+__s32 NAND_CacheRead(__u32 blk, __u32 nblk, void *buf);
+__s32 NAND_CacheWrite(__u32 blk, __u32 nblk, void *buf);
+__s32 NAND_CacheOpen(void);
+__s32 NAND_CacheClose(void);
+
+
+// 2010-12-04 modified
+__u32 NAND_GetDiskSize(void);
+
+
+#endif  //ifndef __NAND_LOGIC_H__
+
diff --git a/drivers/block/sunxi_nand/src/include/nand_oal.h b/drivers/block/sunxi_nand/src/include/nand_oal.h
new file mode 100644
index 0000000..9c8fdf9
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/include/nand_oal.h
@@ -0,0 +1,101 @@
+/*
+ * drivers/block/sunxi_nand/src/include/nand_oal.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef 	__NAND_OAL__
+#define  	__NAND_OAL__
+
+#include "../../include/type_def.h"
+#include "../../nfd/nand_user_cfg.h"
+#include <linux/string.h>
+#include <linux/slab.h>
+//#include "../../sys_include/epdk.h"
+
+
+//define the memory set interface
+#define MEMSET(x,y,z)            			memset((x),(y),(z))
+
+//define the memory copy interface
+#define MEMCPY(x,y,z)                   	memcpy((x),(y),(z))
+
+//define the memory alocate interface
+#define MALLOC(x)                       	kmalloc((x), GFP_KERNEL)
+
+//define the memory release interface
+#define FREE(x,size)                    	kfree((x))
+//define the message print interface
+#define PRINT(...)							printk(__VA_ARGS__)
+
+
+#if 0
+#ifdef		OS_KERNEL
+
+////define the memory set interface
+//#define MEMSET(x,y,z)            			eLIBs_memset(x,y,z)
+//
+////define the memory copy interface
+//#define MEMCPY(x,y,z)                   	eLIBs_memcpy(x,y,z)
+//
+////define the memory alocate interface
+//#define MALLOC(x)                       	esMEMS_Balloc(x)
+//
+////define the memory release interface
+//#define FREE(x,size)                    	esMEMS_Bfree(x,size)
+////define the message print interface
+//#define PRINT(...)							__inf(__VA_ARGS__)
+
+
+//define the memory set interface
+#define MEMSET(x,y,z)            			memset(x,y,z)
+
+//define the memory copy interface
+#define MEMCPY(x,y,z)                   	memcpy(x,y,z)
+
+//define the memory alocate interface
+#define MALLOC(x)                       	kmalloc(x, GFP_KERNEL)
+
+//define the memory release interface
+#define FREE(x,size)                    	kfree(x)
+//define the message print interface
+#define PRINT(...)							printk(__VA_ARGS__)
+#else
+#include "enviroment.h"
+//#include "..\\..\\..\\..\\..\\interinc\\efex\\efex_libs.h"
+
+//define the memory set interface
+#define MEMSET(x,y,z)                   	kmemset(x,y,z)
+
+//define the memory copy interface
+#define MEMCPY(x,y,z)                   	kmemcpy(x,y,z)
+
+//define the memory alocate interface
+#define MALLOC(x)                       	kmalloc(x)
+
+//define the memory release interface
+#define FREE(x,size)                   		kfree(x)
+//define the message print interface
+#define PRINT(...)								eFG_printf(__VA_ARGS__)
+//#define PRINT(...)
+#endif
+
+#endif
+
+#endif
diff --git a/drivers/block/sunxi_nand/src/include/nand_physic.h b/drivers/block/sunxi_nand/src/include/nand_physic.h
new file mode 100644
index 0000000..08dbdf3
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/include/nand_physic.h
@@ -0,0 +1,336 @@
+/*
+ * drivers/block/sunxi_nand/src/include/nand_physic.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAND_PHYSIC_H__
+#define __NAND_PHYSIC_H__
+
+#include "nand_type.h"
+
+//===========================================
+extern struct __NandStorageInfo_t  NandStorageInfo;
+extern struct __NandPageCachePool_t PageCachePool;
+//===========================================
+
+
+
+//==============================================================================
+//  define the physical archictecture export parameter
+//==============================================================================
+
+//define the Ecc Mode
+#define ECC_MODE           (NandStorageInfo.EccMode)
+
+//define the DDR tyep
+#define DDR_TYPE           (NandStorageInfo.DDRType)
+
+//define the sector count of a single physical page
+#define SECTOR_CNT_OF_SINGLE_PAGE           (NandStorageInfo.SectorCntPerPage)
+
+//define the sector count of a super physical page, the super page may be based on multi-plane
+#define SECTOR_CNT_OF_SUPER_PAGE            (NandStorageInfo.SectorCntPerPage * NandStorageInfo.PlaneCntPerDie)
+
+//define the sector bitmap for a single page
+#define FULL_BITMAP_OF_SINGLE_PAGE          ((__u32)((1<<SECTOR_CNT_OF_SINGLE_PAGE) - 1))
+
+//define the sector bitmap for a super page, the sector count of a super page may be equal to 32
+#define FULL_BITMAP_OF_SUPER_PAGE           ((__u32)((1<<(SECTOR_CNT_OF_SUPER_PAGE - 1)) | ((1<<(SECTOR_CNT_OF_SUPER_PAGE - 1)) - 1)))
+
+//define the block number offset for the multi-plane operation
+#define MULTI_PLANE_BLOCK_OFFSET            (NandStorageInfo.OptPhyOpPar.MultiPlaneBlockOffset)
+
+//define the position of the bad block flag in a physical block
+#define BAD_BLOCK_FLAG_PST                  (NandStorageInfo.OptPhyOpPar.BadBlockFlagPosition)
+
+//define if the nand flash can support cache read operation
+#define SUPPORT_CACHE_READ                  (NAND_CACHE_READ & NandStorageInfo.OperationOpt)
+
+//define if the nand flash can support cache program operation
+#define SUPPORT_CACHE_PROGRAM               (NAND_CACHE_PROGRAM & NandStorageInfo.OperationOpt)
+
+//define if the nand flash can support multi-plane read operation
+#define SUPPORT_MULTI_READ                  (NAND_MULTI_READ & NandStorageInfo.OperationOpt)
+
+//define if the nand flash can support multi-plane program operation
+#define SUPPORT_MULTI_PROGRAM               (NAND_MULTI_PROGRAM & NandStorageInfo.OperationOpt)
+
+//define if the nand flash can support page copy-back with command operation
+#define SUPPORT_PAGE_COPYBACK               (NAND_PAGE_COPYBACK & NandStorageInfo.OperationOpt)
+
+//define if the nand flash can support __s32ernal __s32er-leave operation
+#define SUPPORT_INT_INTERLEAVE              (NAND_INT_INTERLEAVE & NandStorageInfo.OperationOpt)
+
+//define if the nand flash system can support external __s32er-leave operation
+#define SUPPORT_EXT_INTERLEAVE              (NAND_EXT_INTERLEAVE & NandStorageInfo.OperationOpt)
+
+//define if the nand flash system can support randomizer
+#define SUPPORT_RANDOM                      (NAND_RANDOM & NandStorageInfo.OperationOpt)
+
+//define if the nand flash system can support read retry
+#define SUPPORT_READ_RETRY                  (NAND_READ_RETRY & NandStorageInfo.OperationOpt)
+
+//define if the nand flash system can support read unique id
+#define SUPPORT_READ_UNIQUE_ID              (NAND_READ_UNIQUE_ID & NandStorageInfo.OperationOpt)
+
+//define if the nand flash system can support bank align
+#define SUPPORT_ALIGN_NAND_BNK              (!(NAND_PAGE_ADR_NO_SKIP & NandStorageInfo.OperationOpt))
+
+//define the count of the nand flash DIE in a nand flash chip
+#define DIE_CNT_OF_CHIP                     (NandStorageInfo.DieCntPerChip)
+
+//define the count of the nand flash bank in a nand flas hchip
+#define BNK_CNT_OF_CHIP                     (NandStorageInfo.BankCntPerChip)
+
+//define the Rb connect Mode
+#define RB_CONNECT_MODE                    (NandStorageInfo.RbConnectMode)
+
+//define the count of the total nand flash bank in the nand flash storage system
+#define TOTAL_BANK_CNT                      (NandStorageInfo.BankCntPerChip * NandStorageInfo.ChipCnt)
+
+//define the count of the physical block in a nand flash DIE
+#define BLOCK_CNT_OF_DIE                    (NandStorageInfo.BlkCntPerDie)
+
+//define the count of the nand flash plane in a nand flash DIE
+#define PLANE_CNT_OF_DIE                    (NandStorageInfo.PlaneCntPerDie)
+
+//define the count of the physical page in a physical block
+#define PAGE_CNT_OF_PHY_BLK                 (NandStorageInfo.PageCntPerPhyBlk)
+
+//define the information of the nand chip connect in the nand storage system
+#define CHIP_CONNECT_INFO                   (NandStorageInfo.ChipConnectInfo)
+
+//define the ReadRetryType of the nand chip connect in the nand storage system
+#define READ_RETRY_TYPE                   (NandStorageInfo.ReadRetryType)
+
+//define the ReadRetryType of the nand chip connect in the nand storage system
+#define READ_RETRY_MODE                   ((READ_RETRY_TYPE>>16)&0xff)
+
+//define the ReadRetryType of the nand chip connect in the nand storage system
+#define READ_RETRY_CYCLE                   ((READ_RETRY_TYPE>>8)&0xff)
+
+//define the ReadRetryType of the nand chip connect in the nand storage system
+#define READ_RETRY_REG_CNT                   ((READ_RETRY_TYPE>>0)&0xff)
+
+//define the nand flash access frequence parameter
+#define NAND_ACCESS_FREQUENCE               (NandStorageInfo.FrequencePar)
+
+#define BAD_BLK_FLAG_PST                    (NandStorageInfo.OptPhyOpPar.BadBlockFlagPosition)
+
+//sync bank with chip mode, need wait whole chip true ready
+#define SYNC_CHIP_MODE                      0x00
+
+//sync bank with bank mode, only check the status of the bank to wait bank ready
+#define SYNC_BANK_MODE                      0x01
+
+//define the page cache for physical module processing page data
+#define PHY_TMP_PAGE_CACHE                  (PageCachePool.PageCache0)
+
+//define the spare data cache for physical module processing spare area data
+#define PHY_TMP_SPARE_CACHE                 (PageCachePool.SpareCache)
+//==============================================================================
+//  define the functions __s32erface for the physic operation module
+//==============================================================================
+
+/*
+************************************************************************************************************************
+*                       INIT NAND FLASH DRIVER PHYSICAL MODULE
+*
+* Description: init nand flash driver physical module.
+*
+* Aguments   : none
+*
+* Returns    : the resutl of initial.
+*                   = 0     initiate successful;
+*                   = -1    initiate failed.
+************************************************************************************************************************
+*/
+__s32 PHY_Init(void);
+__s32 PHY_ChangeMode(__u8 serial_mode);
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH DRIVER PHYSICAL MODULE EXIT
+*
+* Description: nand flash driver physical module exit.
+*
+* Aguments   : none
+*
+* Returns    : the resutl of exit.
+*                   = 0     exit successful;
+*                   = -1    exit failed.
+************************************************************************************************************************
+*/
+__s32 PHY_Exit(void);
+
+
+/*
+************************************************************************************************************************
+*                       RESET ONE NAND FLASH CHIP
+*
+*Description: Reset the given nand chip;
+*
+*Arguments  : nChip     the chip select number, which need be reset.
+*
+*Return     : the result of chip reset;
+*               = 0     reset nand chip successful;
+*               = -1    reset nand chip failed.
+************************************************************************************************************************
+*/
+__s32 PHY_ResetChip(__u32 nChip);
+
+
+/*
+************************************************************************************************************************
+*                       READ NAND FLASH ID
+*
+*Description: Read nand flash ID from the given nand chip.
+*
+*Arguments  : nChip         the chip number whoes ID need be read;
+*             pChipID       the po__s32er to the chip ID buffer.
+*
+*Return     : read nand chip ID result;
+*               = 0     read chip ID successful, the chip ID has been stored in given buffer;
+*               = -1    read chip ID failed.
+************************************************************************************************************************
+*/
+__s32 PHY_ReadNandId(__s32 nChip, void *pChipID);
+__s32 PHY_ReadNandUniqueId(__s32 bank, void *pChipID);
+
+
+/*
+************************************************************************************************************************
+*                       CHECK WRITE PROTECT STATUS
+*
+*Description: check the status of write protect.
+*
+*Arguments  : nChip     the number of chip, which nand chip need be checked.
+*
+*Return     : the result of status check;
+*             = 0       the nand flash is not write proteced;
+*             = 1       the nand flash is write proteced;
+*             = -1      check status failed.
+************************************************************************************************************************
+*/
+__s32 PHY_CheckWp(__u32 nChip);
+
+
+/*
+************************************************************************************************************************
+*                           PHYSICAL BLOCK ERASE
+*
+*Description: Erase one nand flash physical block.
+*
+*Arguments  : pBlkAdr   the parameter of the physical block which need be erased.
+*
+*Return     : the result of the block erase;
+*               = 0     erase physical block successful;
+*               = -1    erase physical block failed.
+************************************************************************************************************************
+*/
+__s32 PHY_BlockErase(struct __PhysicOpPara_t *pBlkAdr);
+
+
+/*
+************************************************************************************************************************
+*                       READ NAND FLASH PHYSICAL PAGE DATA
+*
+*Description: Read a page from a nand flash physical page to buffer.
+*
+*Arguments  : pPageAdr      the po__s32er to the accessed page parameter.
+*
+*Return     : the result of physical page read;
+*               = 0     read physical page successful;
+*               > 0     read physical page successful, but need do some process;
+*               < 0     read physical page failed.
+************************************************************************************************************************
+*/
+__s32 PHY_PageRead(struct __PhysicOpPara_t *pPageAdr);
+
+
+__s32  PHY_PageReadSpare(struct __PhysicOpPara_t *pPageAdr);
+
+/*
+************************************************************************************************************************
+*                       WRITE NAND FLASH PHYSICAL PAGE DATA
+*
+*Description: Write a page from buffer to a nand flash physical page.
+*
+*Arguments  : pPageAdr      the po__s32er to the accessed page parameter.
+*
+*Return     : The result of the page write;
+*               = 0     page write successful;
+*               > 0     page write successful, but need do some process;
+*               < 0     page write failed.
+************************************************************************************************************************
+*/
+__s32 PHY_PageWrite(struct __PhysicOpPara_t  *pPageAdr);
+
+
+/*
+************************************************************************************************************************
+*                           PHYSIC PAGE COPY-BACK
+*
+*Description: copy one physical page from one physical block to another physical block.
+*
+*Arguments  : pSrcPage      the parameter of the source page which need be copied;
+*             pDstPage      the parameter of the destination page which copied to.
+*
+*Return     : the result of the page copy-back;
+*               = 0         page copy-back successful;
+*               = -1        page copy-back failed.
+************************************************************************************************************************
+*/
+__s32 PHY_PageCopyback(struct __PhysicOpPara_t *pSrcPage, struct __PhysicOpPara_t *pDstPage);
+
+
+/*
+************************************************************************************************************************
+*                       SYNCH NAND FLASH PHYSIC OPERATION
+*
+*Description: Synch nand flash operation, check nand flash program/erase operation status.
+*
+*Arguments  : nBank     the number of the bank which need be synchronized;
+*             bMode     the type of synch,
+*                       = 0     synch the chip which the bank belonged to, wait the whole chip
+*                               to be ready, and report status. if the chip support cacheprogram,
+*                               need check if the chip is true ready;
+*                       = 1     only synch the the bank, wait the bank ready and report the status,
+*                               if the chip support cache program, need not check if the cache is
+*                               true ready.
+*
+*Return     : the result of synch;
+*               = 0     synch nand flash successful, nand operation ok;
+*               = -1    synch nand flash failed.
+************************************************************************************************************************
+*/
+__s32 PHY_SynchBank(__u32 nBank, __u32 bMode);
+
+
+__s32 PHY_GetDefaultParam(__u32 bank);
+__s32 PHY_SetDefaultParam(__u32 bank);
+
+__s32 PHY_ScanDDRParam(void);
+
+#endif  //ifnedf __NAND_PHYSIC_H__
+
+
+
+
diff --git a/drivers/block/sunxi_nand/src/include/nand_scan.h b/drivers/block/sunxi_nand/src/include/nand_scan.h
new file mode 100644
index 0000000..e1329e6
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/include/nand_scan.h
@@ -0,0 +1,63 @@
+/*
+ * drivers/block/sunxi_nand/src/include/nand_scan.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAND_SCAN_H__
+#define __NAND_SCAN_H__
+
+#include "nand_type.h"
+#include "nand_physic.h"
+
+//==============================================================================
+//  define nand flash manufacture ID number
+//==============================================================================
+
+#define TOSHIBA_NAND            0x98                //Toshiba nand flash manufacture number
+#define SAMSUNG_NAND            0xec                //Samsunt nand flash manufacture number
+#define HYNIX_NAND              0xad                //Hynix nand flash manufacture number
+#define MICRON_NAND             0x2c                //Micron nand flash manufacture number
+#define ST_NAND                 0x20                //ST nand flash manufacture number
+#define INTEL_NAND              0x89                //Intel nand flash manufacture number
+#define SPANSION_NAND           0x01                //spansion nand flash manufacture number
+#define POWER_NAND              0x92                //power nand flash manufacture number
+
+//==============================================================================
+//  define the function __s32erface for nand storage scan module
+//==============================================================================
+
+/*
+************************************************************************************************************************
+*                           ANALYZE NAND FLASH STORAGE SYSTEM
+*
+*Description: Analyze nand flash storage system, generate the nand flash physical
+*             architecture parameter and connect information.
+*
+*Arguments  : none
+*
+*Return     : analyze result;
+*               = 0     analyze successful;
+*               < 0     analyze failed, can't recognize or some other error.
+************************************************************************************************************************
+*/
+__s32  SCN_AnalyzeNandSystem(void);
+
+
+#endif  //ifndef __NAND_SCAN_H__
diff --git a/drivers/block/sunxi_nand/src/include/nand_simple.h b/drivers/block/sunxi_nand/src/include/nand_simple.h
new file mode 100644
index 0000000..9adcd33
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/include/nand_simple.h
@@ -0,0 +1,48 @@
+/*
+ * drivers/block/sunxi_nand/src/include/nand_simple.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __PHY_BOOT__
+#define  __PHY_BOOT__
+
+#include "nand_oal.h"
+
+#define SUCESS	0
+#define FAIL	-1;
+#define BADBLOCK -2
+
+struct boot_physical_param{
+	__u8   chip; //chip no
+	__u16  block; // block no within chip
+	__u16  page; // apge no within block
+	__u16  sectorbitmap; //done't care
+	void   *mainbuf; //data buf
+	void   *oobbuf; //oob buf
+};
+
+extern __s32 PHY_SimpleErase(struct boot_physical_param * eraseop);
+extern __s32 PHY_SimpleRead(struct boot_physical_param * readop);
+extern __s32 PHY_SimpleWrite(struct boot_physical_param * writeop);
+extern __s32 PHY_SimpleWrite_1K(struct boot_physical_param * writeop);
+extern __s32 PHY_SimpleWrite_Seq(struct boot_physical_param * writeop);
+extern __s32 PHY_SimpleRead_Seq(struct boot_physical_param * readop);
+extern __s32 PHY_SimpleRead_1K(struct boot_physical_param * readop);
+#endif
diff --git a/drivers/block/sunxi_nand/src/include/nand_type.h b/drivers/block/sunxi_nand/src/include/nand_type.h
new file mode 100644
index 0000000..0c0fd24
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/include/nand_type.h
@@ -0,0 +1,353 @@
+/*
+ * drivers/block/sunxi_nand/src/include/nand_type.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __NAND_TYPE_H
+#define __NAND_TYPE_H
+
+#include "nand_drv_cfg.h"
+
+//==============================================================================
+//  define the data structure for physic layer module
+//==============================================================================
+
+//define the optional physical operation parameter
+struct __OptionalPhyOpPar_t
+{
+    __u8        MultiPlaneReadCmd[2];               //the command for multi-plane read, the sequence is [0] -ADDR- [0] -ADDR- [1] - DATA
+    __u8        MultiPlaneWriteCmd[2];              //the command for multi-plane program, the sequence is 80 -ADDR- DATA - [0] - [1] -ADDR- DATA - 10/15
+    __u8        MultiPlaneCopyReadCmd[3];           //the command for multi-plane page copy-back read, the sequence is [0] -ADDR- [1] -ADDR- [2]
+    __u8        MultiPlaneCopyWriteCmd[3];          //the command for multi-plane page copy-back program, the sequence is [0] -ADDR- [1] - [2] -ADDR- 10
+    __u8        MultiPlaneStatusCmd;                //the command for multi-plane operation status read, the command may be 0x70/0x71/0x78/...
+    __u8        InterBnk0StatusCmd;                 //the command for inter-leave bank0 operation status read, the command may be 0xf1/0x78/...
+    __u8        InterBnk1StatusCmd;                 //the command for inter-leave bank1 operation status read, the command may be 0xf2/0x78/...
+    __u8        BadBlockFlagPosition;               //the flag that marks the position of the bad block flag,0x00-1stpage/ 0x01-1st&2nd page/ 0x02-last page/ 0x03-last 2 page
+    __u16       MultiPlaneBlockOffset;              //the value of the block number offset between the left-plane block and the right pane block
+};
+
+typedef struct
+{
+    __u8        ChipCnt;                            //the count of the total nand flash chips are currently connecting on the CE pin
+    __u16       ChipConnectInfo;                    //chip connect information, bit == 1 means there is a chip connecting on the CE pin
+	__u8		RbCnt;
+	__u8		RbConnectInfo;						//the connect  information of the all rb  chips are connected
+    __u8        RbConnectMode;						//the rb connect  mode
+	__u8        BankCntPerChip;                     //the count of the banks in one nand chip, multiple banks can support Inter-Leave
+    __u8        DieCntPerChip;                      //the count of the dies in one nand chip, block management is based on Die
+    __u8        PlaneCntPerDie;                     //the count of planes in one die, multiple planes can support multi-plane operation
+    __u8        SectorCntPerPage;                   //the count of sectors in one single physic page, one sector is 0.5k
+    __u16       PageCntPerPhyBlk;                   //the count of physic pages in one physic block
+    __u16       BlkCntPerDie;                       //the count of the physic blocks in one die, include valid block and invalid block
+    __u16       OperationOpt;                       //the mask of the operation types which current nand flash can support support
+    __u8        FrequencePar;                       //the parameter of the hardware access clock, based on 'MHz'
+    __u8        EccMode;                            //the Ecc Mode for the nand flash chip, 0: bch-16, 1:bch-28, 2:bch_32
+    __u8        NandChipId[8];                      //the nand chip id of current connecting nand chip
+    __u16       ValidBlkRatio;                      //the ratio of the valid physical blocks, based on 1024
+	__u32 		good_block_ratio;					//good block ratio get from hwscan
+	__u32		ReadRetryType;						//the read retry type
+	__u32       DDRType;
+	__u32		Reserved[32];
+}boot_nand_para_t;
+
+typedef struct boot_flash_info{
+	__u32 chip_cnt;
+	__u32 blk_cnt_per_chip;
+	__u32 blocksize;
+	__u32 pagesize;
+	__u32 pagewithbadflag; /*bad block flag was written at the first byte of spare area of this page*/
+}boot_flash_info_t;
+
+//define the nand flash storage system information
+struct __NandStorageInfo_t
+{
+    __u8        ChipCnt;                            //the count of the total nand flash chips are currently connecting on the CE pin
+    __u16       ChipConnectInfo;                    //chip connect information, bit == 1 means there is a chip connecting on the CE pin
+	__u8		RbCnt;
+	__u8		RbConnectInfo;						//the connect  information of the all rb  chips are connected
+    __u8        RbConnectMode;						//the rb connect  mode
+	__u8        BankCntPerChip;                     //the count of the banks in one nand chip, multiple banks can support Inter-Leave
+    __u8        DieCntPerChip;                      //the count of the dies in one nand chip, block management is based on Die
+    __u8        PlaneCntPerDie;                     //the count of planes in one die, multiple planes can support multi-plane operation
+    __u8        SectorCntPerPage;                   //the count of sectors in one single physic page, one sector is 0.5k
+    __u16       PageCntPerPhyBlk;                   //the count of physic pages in one physic block
+    __u16       BlkCntPerDie;                       //the count of the physic blocks in one die, include valid block and invalid block
+    __u16       OperationOpt;                       //the mask of the operation types which current nand flash can support support
+    __u8        FrequencePar;                       //the parameter of the hardware access clock, based on 'MHz'
+    __u8        EccMode;                            //the Ecc Mode for the nand flash chip, 0: bch-16, 1:bch-28, 2:bch_32
+    __u8        NandChipId[8];                      //the nand chip id of current connecting nand chip
+    __u16       ValidBlkRatio;                         //the ratio of the valid physical blocks, based on 1024
+    __u32		ReadRetryType;						//the read retry type
+    __u32       DDRType;
+    struct __OptionalPhyOpPar_t OptPhyOpPar;        //the parameters for some optional operation
+};
+
+
+//define the page buffer pool for nand flash driver
+struct __NandPageCachePool_t
+{
+    __u8        *PageCache0;                        //the pointer to the first page size ram buffer
+    __u8        *PageCache1;                        //the pointer to the second page size ram buffer
+    __u8        *PageCache2;                        //the pointer to the third page size ram buffer
+    __u8		*SpareCache;
+
+	__u8		*TmpPageCache;
+};
+
+
+//define the User Data structure for nand flash driver
+struct __NandUserData_t
+{
+    __u8        BadBlkFlag;                         //the flag that marks if a physic block is a valid block or a invalid block
+    __u16       LogicInfo;                          //the logical information of the physical block
+    __u8        Reserved0;                          //reserved for 32bit align
+    __u16       LogicPageNum;                       //the value of the logic page number, which the physic page is mapping to
+    __u8        PageStatus;                         //the logical information of the physical page
+    __u8        Reserved1;                          //reserved for 32bit align
+} __attribute__ ((packed));
+
+
+//define the paramter structure for physic operation function
+struct __PhysicOpPara_t
+{
+    __u8        BankNum;                            //the number of the bank current accessed, bank NO. is different of chip NO.
+    __u8        PageNum;                            //the number of the page current accessed, the page is based on single-plane or multi-plane
+    __u16       BlkNum;                             //the number of the physic block, the block is based on single-plane or multi-plane
+    __u32       SectBitmap;                         //the bitmap of the sector in the page which need access data
+    void        *MDataPtr;                          //the pointer to main data buffer, it is the start address of a page size based buffer
+    void        *SDataPtr;                          //the pointer to spare data buffer, it will be set to NULL if needn't access spare data
+};
+
+
+//==============================================================================
+//  define the data structure for logic management module
+//==============================================================================
+
+//define the logical architecture parameter structure
+struct __LogicArchitecture_t
+{
+    __u16       LogicBlkCntPerZone;                 //the counter that marks how many logic blocks in one zone
+    __u16       PageCntPerLogicBlk;                 //the counter that marks how many pages in one logical block
+    __u8        SectCntPerLogicPage;                //the counter that marks how many  sectors in one logical page
+    __u8        ZoneCntPerDie;                      //the counter that marks how many zones in one die
+    __u16       Reserved;                           //reserved for 32bit align
+};
+
+//define the super block type
+struct __SuperPhyBlkType_t
+{
+    __u16       PhyBlkNum;                          //the super physic block offset number in a die,the first block of the die is 0
+    __u16       BlkEraseCnt;                        //the erase count of the super physic block,record how many times it has been erased
+};
+
+
+//define the log block table item type
+struct __LogBlkType_t
+{
+    __u16       LogicBlkNum;                        //the logic block number which the log block is belonged to
+    __u16       LastUsedPage;                       //the number of the page which is the last used in the super physic block
+    struct __SuperPhyBlkType_t PhyBlk;              //the super physic block number which the log block is mapping to
+};
+
+
+//define the zone table position information type
+struct __ZoneTblPstInfo_t
+{
+    __u16       PhyBlkNum;                          //the physic block number in the chip which stored the block mapping table
+    __u16       TablePst;                           //the page number in the physic block which stored the valid block mapping table
+};
+
+
+//define the block mapping table cache access type
+struct __BlkMapTblCache_t
+{
+    __u8        ZoneNum;                            //the number of the zone which is the block mapping table belonged to
+    __u8        DirtyFlag;                          //the flag that marks the status of the table in the nand, notes if the table need write back
+    __u16       AccessCnt;                          //the counter that record how many times the block mapping table has been accessed
+    struct __SuperPhyBlkType_t *DataBlkTbl;         //the pointer to the data block table of the block mapping table
+    struct __LogBlkType_t *LogBlkTbl;               //the pointer to the log block table of the block mapping table
+    struct __SuperPhyBlkType_t *FreeBlkTbl;         //the pointer to the free block table of the block mapping table
+    __u16       LastFreeBlkPst;                     //the pointer to the free block position which is got last time
+    __u16       Reserved;                           //reserved for 32bit align
+};
+
+//define the block mapping table cache management parameter type
+struct __BlkMapTblCachePool_t
+{
+    struct __BlkMapTblCache_t *ActBlkMapTbl;                                //the pointer to the active block mapping table
+    struct __BlkMapTblCache_t BlkMapTblCachePool[BLOCK_MAP_TBL_CACHE_CNT];  //the pool of the block mapping table cache
+    __u16       LogBlkAccessAge[MAX_LOG_BLK_CNT];   //the time of accessing log block for the log block
+    __u16       LogBlkAccessTimer;                  //the timer of the access time for recording the log block accessing time
+    __u16       SuperBlkEraseCnt;                   //the counter of the super block erase, for do wear-levelling
+};
+
+
+//define the page mapping table item type
+struct __PageMapTblItem_t
+{
+    __u16       PhyPageNum;                         //the physic page number which the logic page mapping to
+};
+
+//define the page mapping table access type
+struct __PageMapTblCache_t
+{
+    __u8        ZoneNum;                            //the zone number which the page mapping table is belonged to
+    __u8        LogBlkPst;                          //the position of the log block in the log block table
+    __u16       AccessCnt;                          //the counter that the page mapping table has been accessed
+	struct __PageMapTblItem_t *PageMapTbl;          //the pointer to the page mapping table
+    __u8        DirtyFlag;                          //the flag that marks if the page mapping table need be writen back to nand flash
+    __u8        Reserved[3];                        //reserved for 32bit align
+};
+
+//define the page mapping table cache management parameter type
+struct __PageMapTblCachePool_t
+{
+    struct __PageMapTblCache_t *ActPageMapTbl;                              //the poninter to the active page mapping table
+    struct __PageMapTblCache_t PageMapTblCachePool[PAGE_MAP_TBL_CACHE_CNT]; //the pool of the page mapping table cache
+};
+
+
+//define the global logical page parameter type
+struct __GlobalLogicPageType_t
+{
+    __u32       LogicPageNum;                       //the global page number of the logic page, it is based on super page size
+    __u32       SectorBitmap;                       //the bitmap of the sector in the logic page which data need access
+};
+
+
+//define the global logcial page based on zone and block parameter type
+struct __LogicPageType_t
+{
+    __u32       SectBitmap;                         //the bitmap marks which sectors' data in the logical page need access
+    __u16       BlockNum;                           //the value of the number of the logical block which the page is belonged to
+    __u16       PageNum;                            //the value of the number of the page in the logical block
+    __u8        ZoneNum;                            //the value of the number of the zone, which the page is belonged to
+    __u8        Reserved[3];                        //reserved for 32bit align
+};
+
+
+//define the logical control layer management parameter type
+struct __LogicCtlPar_t
+{
+    __u8        OpMode;                             //record nand flash driver last operation, may be read, write, or none.
+    __u8        ZoneNum;                            //the number of the zone which is accessed last time
+    __u16       LogicBlkNum;                        //the number of the logic block which is accessed last time
+    __u16       LogicPageNum;                       //the number of the logic page which is accessed last time
+    __u16       LogPageNum;                         //the number of the log page, which is accessed last time
+    struct __SuperPhyBlkType_t  DataBlkNum;         //the number of the data block, which is accessed last time
+    struct __SuperPhyBlkType_t  LogBlkNum;          //the number of the log block, which is accessed last time
+    __u32       DiskCap;                            //the capacity of the logical disk
+};
+
+
+//define the nand flash physical information parameter type
+struct __NandPhyInfoPar_t
+{
+    __u8        NandID[8];                          //the ID number of the nand flash chip
+    __u8        DieCntPerChip;                      //the count of the Die in one nand flash chip
+    __u8        SectCntPerPage;                     //the count of the sectors in one single physical page
+    __u16       PageCntPerBlk;                      //the count of the pages in one single physical block
+    __u16       BlkCntPerDie;                       //the count fo the physical blocks in one nand flash Die
+    __u16       OperationOpt;                       //the bitmap that marks which optional operation that the nand flash can support
+    __u16       ValidBlkRatio;                      //the valid block ratio, based on 1024 blocks
+    __u16       AccessFreq;                         //the highest access frequence of the nand flash chip, based on MHz
+    __u16       EccMode;                            //the Ecc Mode for the nand flash chip, 0: bch-16, 1:bch-28, 2:bch_32
+    __u32 		ReadRetryType;
+    __u32       DDRType;
+    struct __OptionalPhyOpPar_t *OptionOp;          //the pointer point to the optional operation parameter
+};
+
+
+//define the global paramter for nand flash driver to access all parameter
+struct __NandDriverGlobal_t
+{
+    struct __NandStorageInfo_t  *NandStorageInfo;               //the pointer to the nand flash hardware information parameter
+    struct __ZoneTblPstInfo_t   *ZoneTblPstInfo;                //the pointer to the block mapping table information parameter
+    struct __BlkMapTblCachePool_t   *BlkMapTblCachePool;        //the pointer to the block mapping thable cache pool management parameter
+    struct __PageMapTblCachePool_t  *PageMapTblCachePool;       //the pointer to the page mapping table cache pool management parameter
+    struct __LogicArchitecture_t    *LogicalArchitecture;       //the pointer to the logical archtecture parameter
+    struct __NandPageCachePool_t    *PageCachePool;             //the pointer to the page cache pool parameter
+};
+
+
+//==============================================================================
+//  define some constant variable for the nand flash driver used
+//==============================================================================
+
+//define the mask for the nand flash optional operation
+#define NAND_CACHE_READ         (1<<0)              //nand flash support cache read operation
+#define NAND_CACHE_PROGRAM      (1<<1)              //nand flash support page cache program operation
+#define NAND_MULTI_READ         (1<<2)              //nand flash support multi-plane page read operation
+#define NAND_MULTI_PROGRAM      (1<<3)              //nand flash support multi-plane page program operation
+#define NAND_PAGE_COPYBACK      (1<<4)              //nand flash support page copy-back command mode operation
+#define NAND_INT_INTERLEAVE     (1<<5)              //nand flash support internal inter-leave operation, it based multi-bank
+#define NAND_EXT_INTERLEAVE     (1<<6)              //nand flash support external inter-leave operation, it based multi-chip
+#define NAND_RANDOM		        (1<<7)			    //nand flash support RANDOMIZER
+#define NAND_READ_RETRY	        (1<<8)			    //nand falsh support READ RETRY
+#define NAND_READ_UNIQUE_ID	    (1<<9)			    //nand falsh support READ UNIQUE_ID
+#define NAND_PAGE_ADR_NO_SKIP	(1<<10)			    //nand falsh page adr no skip is requiered
+
+
+//define the mask for the nand flash operation status
+#define NAND_OPERATE_FAIL       (1<<0)              //nand flash program/erase failed mask
+#define NAND_CACHE_READY        (1<<5)              //nand flash cache program true ready mask
+#define NAND_STATUS_READY       (1<<6)              //nand flash ready/busy status mask
+#define NAND_WRITE_PROTECT      (1<<7)              //nand flash write protected mask
+
+
+//define the mark for physical page status
+#define FREE_PAGE_MARK          0xff                //the page is storing no data, is not used
+#define DATA_PAGE_MARK          0x55                //the physical page is used for storing the update data
+#define TABLE_PAGE_MARK         0xaa                //the physical page is used for storing page mapping table
+
+#define TABLE_BLK_MARK          0xaa                //the mark for the block mapping table block which is a special type block
+#define BOOT_BLK_MARK           0xbb                //the mark for the boot block which is a special type block
+
+//define the count of the physical blocks managed by one zone
+#define BLOCK_CNT_OF_ZONE       1024                //one zone is organized based on 1024 blocks
+
+//define the size of the sector
+#define SECTOR_SIZE             512                 //the size of a sector, based on byte
+
+
+//==============================================================================
+//  define the function return value for different modules
+//==============================================================================
+
+#define NAND_OP_TRUE            (0)                     //define the successful return value
+#define NAND_OP_FALSE           (-1)                    //define the failed return value
+
+
+//define the return value
+#define ECC_LIMIT               10                  //reach the limit of the ability of ECC
+#define ERR_MALLOC              11                  //request buffer failed
+#define ERR_ECC                 12                  //too much ecc error
+#define ERR_NANDFAIL            13                  //nand flash program or erase fail
+#define ERR_TIMEOUT             14                  //hardware timeout
+#define ERR_PHYSIC              15                  //physical operation module error
+#define ERR_SCAN                16                  //scan module error
+#define ERR_FORMAT              17                  //format module error
+#define ERR_MAPPING             18                  //mapping module error
+#define ERR_LOGICCTL            19                  //logic control module error
+#define ERR_ADDRBEYOND          20                  //the logical sectors need be accessed is beyond the logical disk
+#define ERR_INVALIDPHYADDR		  21
+
+#endif //ifndef __NAND_TYPE_H
+
diff --git a/drivers/block/sunxi_nand/src/logic/bad_manage.c b/drivers/block/sunxi_nand/src/logic/bad_manage.c
new file mode 100644
index 0000000..3c803aa
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/logic/bad_manage.c
@@ -0,0 +1,186 @@
+/*
+ * drivers/block/sunxi_nand/src/logic/bad_manage.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_logic.h"
+
+extern struct __NandDriverGlobal_t     NandDriverInfo;
+
+/*
+************************************************************************************************************************
+*                       RESTORE VALID PAGE DATA FROM BAD BLOCK
+*
+*Description: Restore the valid page data from the bad block.
+*
+*Arguments  : pBadBlk   the pointer to the bad physical block parameter;
+*             nErrPage  the number of the error page;
+*             pNewBlk   the pointer to the new valid block parameter.
+*
+*Return     : restore page data result;
+*               = 0     restore data successful;
+*               = -1    restore data failed.
+************************************************************************************************************************
+*/
+static __s32 _RestorePageData(struct __SuperPhyBlkType_t *pBadBlk, __u32 nZoneNum, __u32 nErrPage, struct __SuperPhyBlkType_t *pNewBlk)
+{
+    __s32 i, result;
+    struct __PhysicOpPara_t tmpSrcPage, tmpDstPage;
+
+    //set sector bitmap and buffer pointer for copy nand flash page
+    tmpSrcPage.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+    tmpDstPage.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+    tmpSrcPage.MDataPtr = NULL;
+    tmpSrcPage.SDataPtr = NULL;
+
+    for(i=0; i<nErrPage; i++)
+    {
+        //calculate source page and destination page parameter for copy nand page
+        LML_CalculatePhyOpPar(&tmpSrcPage, nZoneNum, pBadBlk->PhyBlkNum, i);
+        LML_CalculatePhyOpPar(&tmpDstPage, nZoneNum, pNewBlk->PhyBlkNum, i);
+
+        PHY_PageCopyback(&tmpSrcPage, &tmpDstPage);
+        //check page copy result
+        result = PHY_SynchBank(tmpDstPage.BankNum, SYNC_CHIP_MODE);
+        if(result < 0)
+        {
+            LOGICCTL_DBG("[LOGICCTL_DBG] Copy page failed when restore bad block data!\n");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       WRITE BAD FLAG TO BAD BLOCK
+*
+*Description: Write bad block flag to bad block.
+*
+*Arguments  : pBadBlk   the pointer to the bad physical block parameter.
+*
+*Return     : mark bad block result;
+*               = 0     mark bad block successful;
+*               = -1    mark bad block failed.
+************************************************************************************************************************
+*/
+static __s32 _MarkBadBlk(struct __SuperPhyBlkType_t *pBadBlk, __u32 nZoneNum)
+{
+    __s32   i;
+	__s32   ret;
+    struct __PhysicOpPara_t tmpPage;
+    struct __NandUserData_t tmpSpare[2];
+
+	//add by neil 20101201
+	/* erase bad blcok */
+	ret = LML_VirtualBlkErase(nZoneNum, pBadBlk->PhyBlkNum);
+	if(ret)
+	{
+		LOGICCTL_DBG("[LOGICCTL_DBG] erase bad block fail!\n");
+	}
+
+
+    //set the spare area data for write
+    MEMSET((void *)tmpSpare, 0x00, 2*sizeof(struct __NandUserData_t));
+
+    tmpPage.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+    tmpPage.MDataPtr = LML_TEMP_BUF;
+    tmpPage.SDataPtr = (void *)tmpSpare;
+
+    //write the bad flag in ervery single physical block of the super block
+    for(i=0; i<INTERLEAVE_BANK_CNT; i++)
+    {
+        //write the bad flag in the first page of the physical block
+        LML_CalculatePhyOpPar(&tmpPage, nZoneNum, pBadBlk->PhyBlkNum, i);
+        LML_VirtualPageWrite(&tmpPage);
+        PHY_SynchBank(tmpPage.BankNum, SYNC_CHIP_MODE);
+
+        //write the bad flag in the last page of the physical block
+        LML_CalculatePhyOpPar(&tmpPage, nZoneNum, pBadBlk->PhyBlkNum, PAGE_CNT_OF_SUPER_BLK - INTERLEAVE_BANK_CNT + i);
+        LML_VirtualPageWrite(&tmpPage);
+        PHY_SynchBank(tmpPage.BankNum, SYNC_CHIP_MODE);
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER BAD BLOCK MANAGE
+*
+*Description: Nand flash bad block manage.
+*
+*Arguments  : pBadBlk   the pointer to the bad physical block parameter;
+*             nZoneNum  the number of the zone which the bad block belonged to;
+*             nErrPage  the number of the error page;
+*             pNewBlk   the pointer to the new valid block parameter.
+*
+*Return     : bad block manage result;
+*               = 0     do bad block manage successful;
+*               = -1    do bad block manage failed.
+************************************************************************************************************************
+*/
+__s32 LML_BadBlkManage(struct __SuperPhyBlkType_t *pBadBlk, __u32 nZoneNum, __u32 nErrPage, struct __SuperPhyBlkType_t *pNewBlk)
+{
+    __s32   result;
+    struct __SuperPhyBlkType_t tmpFreeBlk;
+    struct __SuperPhyBlkType_t tmpBadBlk;
+
+    tmpBadBlk = *pBadBlk;
+
+	LOGICCTL_ERR("%s : %d : bad block manage go\n",__FUNCTION__,__LINE__);
+
+__PROCESS_BAD_BLOCK:
+
+    if(pNewBlk)
+    {
+        //get a new free block to replace the bad block
+        BMM_GetFreeBlk(LOWEST_EC_TYPE, &tmpFreeBlk);
+        if(tmpFreeBlk.PhyBlkNum == 0xffff)
+        {
+            LOGICCTL_ERR("[LOGICCTL_ERR] Look for free block failed when replace bad block\n");
+            return -1;
+        }
+
+        //restore the valid page data from the bad block
+        if(nErrPage)
+        {
+            result = _RestorePageData(&tmpBadBlk, nZoneNum, nErrPage, &tmpFreeBlk);
+            if(result < 0)
+            {
+                //restore data failed, mark bad flag to the new free block
+                _MarkBadBlk(&tmpFreeBlk, nZoneNum);
+
+                goto __PROCESS_BAD_BLOCK;
+            }
+        }
+
+        *pNewBlk = tmpFreeBlk;
+    }
+
+    //write bad flag to the bad block
+    _MarkBadBlk(&tmpBadBlk, nZoneNum);
+
+    return 0;
+}
+
diff --git a/drivers/block/sunxi_nand/src/logic/logic_cache.c b/drivers/block/sunxi_nand/src/logic/logic_cache.c
new file mode 100644
index 0000000..7ca2a9c
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/logic/logic_cache.c
@@ -0,0 +1,458 @@
+/*
+ * drivers/block/sunxi_nand/src/logic/logic_cache.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include "../include/nand_logic.h"
+
+//#define CACHE_DBG
+
+#define NAND_W_CACHE_EN
+#define N_NAND_W_CACHE  8
+
+
+typedef struct
+{
+	__u8	*data;
+	__u32	size;
+
+	__u32	hit_page;
+	__u32   secbitmap;
+
+	__u32	access_count;
+}__nand_cache_t;
+
+__u32 g_w_access_cnt;
+
+__nand_cache_t nand_w_cache[N_NAND_W_CACHE];
+__nand_cache_t nand_r_cache;
+
+__u32 _get_valid_bits(__u32 secbitmap)
+{
+	__u32 validbit = 0;
+
+	while(secbitmap)
+	{
+		if(secbitmap & 0x1)
+			validbit++;
+		secbitmap >>= 1;
+	}
+
+	return validbit;
+}
+
+__u32 _get_first_valid_bit(__u32 secbitmap)
+{
+	__u32 firstbit = 0;
+
+	while(!(secbitmap & 0x1))
+	{
+		secbitmap >>= 1;
+		firstbit++;
+	}
+
+	return firstbit;
+}
+
+__s32 _flush_w_cache(void)
+{
+	__u32	i;
+
+	for(i = 0; i < N_NAND_W_CACHE; i++)
+	{
+		if(nand_w_cache[i].hit_page != 0xffffffff)
+		{
+			if(nand_w_cache[i].secbitmap != FULL_BITMAP_OF_LOGIC_PAGE)
+				LML_PageRead(nand_w_cache[i].hit_page,(nand_w_cache[i].secbitmap ^ FULL_BITMAP_OF_LOGIC_PAGE)&FULL_BITMAP_OF_LOGIC_PAGE,nand_w_cache[i].data);
+
+			LML_PageWrite(nand_w_cache[i].hit_page,FULL_BITMAP_OF_LOGIC_PAGE,nand_w_cache[i].data);
+			nand_w_cache[i].hit_page = 0xffffffff;
+			nand_w_cache[i].secbitmap = 0;
+			nand_w_cache[i].access_count = 0;
+
+			/*disable read cache with current page*/
+			if (nand_r_cache.hit_page == nand_w_cache[i].hit_page){
+					nand_r_cache.hit_page = 0xffffffff;
+					nand_r_cache.secbitmap = 0;
+			}
+
+		}
+	}
+
+
+	return 0;
+
+}
+
+__s32 _flush_w_cache_simple(__u32 i)
+{
+	if(nand_w_cache[i].hit_page != 0xffffffff)
+	{
+		if(nand_w_cache[i].secbitmap != FULL_BITMAP_OF_LOGIC_PAGE)
+			LML_PageRead(nand_w_cache[i].hit_page,(nand_w_cache[i].secbitmap ^ FULL_BITMAP_OF_LOGIC_PAGE)&FULL_BITMAP_OF_LOGIC_PAGE,nand_w_cache[i].data);
+
+		LML_PageWrite(nand_w_cache[i].hit_page,FULL_BITMAP_OF_LOGIC_PAGE,nand_w_cache[i].data);
+		nand_w_cache[i].hit_page = 0xffffffff;
+		nand_w_cache[i].secbitmap = 0;
+		nand_w_cache[i].access_count = 0;
+
+		/*disable read cache with current page*/
+		if (nand_r_cache.hit_page == nand_w_cache[i].hit_page){
+				nand_r_cache.hit_page = 0xffffffff;
+				nand_r_cache.secbitmap = 0;
+		}
+
+	}
+
+	return 0;
+
+}
+
+
+__s32 NAND_CacheFlush(void)
+{
+	//__u32	i;
+
+	_flush_w_cache();
+
+	return 0;
+
+}
+
+void _get_data_from_cache(__u32 blk, __u32 nblk, void *buf)
+{
+	__u32 i;
+	__u32 sec;
+	__u32 page,SecBitmap,SecWithinPage;
+
+	for(sec = blk; sec < blk + nblk; sec++)
+	{
+		SecWithinPage = sec % SECTOR_CNT_OF_LOGIC_PAGE;
+		SecBitmap = (1 << SecWithinPage);
+		page = sec / SECTOR_CNT_OF_LOGIC_PAGE;
+		for (i = 0; i < N_NAND_W_CACHE; i++)
+		{
+			if ((nand_w_cache[i].hit_page == page) && (nand_w_cache[i].secbitmap & SecBitmap))
+			{
+				MEMCPY((__u8 *)buf + (sec - blk) * 512, nand_w_cache[i].data + SecWithinPage * 512,512);
+				break;
+			}
+		}
+	}
+}
+
+void _get_one_page(__u32 page,__u32 SecBitmap,__u8 *data)
+{
+	__u32 i;
+	__u8 *tmp = data;
+
+
+	if(page == nand_r_cache.hit_page)
+	{
+		for(i = 0;i < SECTOR_CNT_OF_LOGIC_PAGE; i++)
+		{
+			if(SecBitmap & (1<<i))
+			{
+				MEMCPY(tmp + (i<<9),nand_r_cache.data + (i<<9),512);
+			}
+		}
+	}
+
+	else
+	{
+		if(SecBitmap == FULL_BITMAP_OF_LOGIC_PAGE)
+		{
+			LML_PageRead(page,FULL_BITMAP_OF_LOGIC_PAGE,tmp);
+		}
+		else
+		{
+			LML_PageRead(page,FULL_BITMAP_OF_LOGIC_PAGE,nand_r_cache.data);
+			nand_r_cache.hit_page = page;
+			nand_r_cache.secbitmap = FULL_BITMAP_OF_LOGIC_PAGE;
+
+			for(i = 0;i < SECTOR_CNT_OF_LOGIC_PAGE; i++)
+			{
+				if(SecBitmap & (1<<i))
+				{
+					MEMCPY(tmp + (i<<9),nand_r_cache.data + (i<<9),512);
+				}
+			}
+		}
+	}
+
+	SecBitmap = 0;
+}
+
+__s32 NAND_CacheRead(__u32 blk, __u32 nblk, void *buf)
+{
+	__u32	nSector,StartSec;
+	__u32	page;
+	__u32	SecBitmap,SecWithinPage;
+	__u8 	*pdata;
+
+	nSector 	= nblk;
+	StartSec 	= blk;
+	SecBitmap 	= 0;
+	page 		= 0xffffffff;
+	pdata		= (__u8 *)buf;
+
+	/*combind sectors to pages*/
+	while(nSector)
+	{
+		SecWithinPage = StartSec % SECTOR_CNT_OF_LOGIC_PAGE;
+		SecBitmap |= (1 << SecWithinPage);
+		page = StartSec / SECTOR_CNT_OF_LOGIC_PAGE;
+
+		/*close page if last sector*/
+		if (SecWithinPage == (SECTOR_CNT_OF_LOGIC_PAGE - 1))
+		{
+
+			__u8 *tmp = pdata + 512 - 512*_get_valid_bits(SecBitmap) - 512 * _get_first_valid_bit(SecBitmap);
+			_get_one_page(page, SecBitmap, tmp);
+			SecBitmap = 0;
+		}
+
+		/*reset variable*/
+		nSector--;
+		StartSec++;
+		pdata += 512;
+	}
+
+	/*fill opened page*/
+	if (SecBitmap)
+	{
+		__u8	*tmp = pdata - 512*_get_valid_bits(SecBitmap) - 512 * _get_first_valid_bit(SecBitmap);
+		_get_one_page(page, SecBitmap, tmp);
+	}
+
+	/*renew data from cache*/
+	_get_data_from_cache(blk,nblk,buf);
+
+	return 0;
+
+}
+
+__s32 _fill_nand_cache(__u32 page, __u32 secbitmap, __u8 *pdata)
+{
+	__u8	hit;
+	__u8	i;
+	__u8 	pos = 0xff;
+
+	g_w_access_cnt++;
+
+	hit = 0;
+
+	for (i = 0; i < N_NAND_W_CACHE; i++)
+	{
+		/*merge data if cache hit*/
+		if (nand_w_cache[i].hit_page == page){
+			hit = 1;
+			MEMCPY(nand_w_cache[i].data + 512 * _get_first_valid_bit(secbitmap),pdata, 512 * _get_valid_bits(secbitmap));
+			nand_w_cache[i].secbitmap |= secbitmap;
+			nand_w_cache[i].access_count = g_w_access_cnt;
+			pos = i;
+			break;
+		}
+	}
+
+	/*post data if cache miss*/
+	if (!hit)
+	{
+		/*find cache to post*/
+		for (i = 0; i < N_NAND_W_CACHE; i++)
+		{
+			if (nand_w_cache[i].hit_page == 0xffffffff)
+			{
+				pos = i;
+				break;
+			}
+		}
+
+		if (pos == 0xff)
+		{
+			__u32 access_cnt = nand_w_cache[0].access_count;
+			pos = 0;
+
+			for (i = 1; i < N_NAND_W_CACHE; i++)
+			{
+				if (access_cnt > nand_w_cache[i].access_count)
+				{
+					pos = i;
+					access_cnt = nand_w_cache[i].access_count;
+				}
+
+				if((nand_w_cache[i].hit_page == page-1)&&(page>0))
+				{
+				    pos = i;
+				    break;
+				}
+			}
+
+			if(nand_w_cache[pos].secbitmap != FULL_BITMAP_OF_LOGIC_PAGE)
+				LML_PageRead(nand_w_cache[pos].hit_page,nand_w_cache[pos].secbitmap ^ FULL_BITMAP_OF_LOGIC_PAGE,nand_w_cache[pos].data);
+
+			LML_PageWrite(nand_w_cache[pos].hit_page, FULL_BITMAP_OF_LOGIC_PAGE, nand_w_cache[pos].data);
+			nand_w_cache[pos].access_count = 0;
+
+			//add by penggang
+			/*disable read cache with current page*/
+			if (nand_r_cache.hit_page == nand_w_cache[pos].hit_page){
+				nand_r_cache.hit_page = 0xffffffff;
+				nand_r_cache.secbitmap = 0;
+			}
+
+		}
+
+		/*merge data*/
+		MEMCPY(nand_w_cache[pos].data + 512 * _get_first_valid_bit(secbitmap),pdata, 512 * _get_valid_bits(secbitmap));
+		nand_w_cache[pos].hit_page = page;
+		nand_w_cache[pos].secbitmap = secbitmap;
+		nand_w_cache[pos].access_count = g_w_access_cnt;
+
+	}
+
+	if (g_w_access_cnt == 0)
+	{
+		for (i = 0; i < N_NAND_W_CACHE; i++)
+			nand_w_cache[i].access_count = 0;
+		g_w_access_cnt = 1;
+		nand_w_cache[pos].access_count = g_w_access_cnt;
+	}
+
+	return 0;
+}
+
+__s32 NAND_CacheWrite(__u32 blk, __u32 nblk, void *buf)
+{
+	__u32	nSector,StartSec;
+	__u32	page;
+	__u32	SecBitmap,SecWithinPage;
+	__u32	i;
+	__u8 	*pdata;
+	//__u32  hit = 0;
+
+	nSector 	= nblk;
+	StartSec 	= blk;
+	SecBitmap 	= 0;
+	page 		= 0xffffffff;
+	pdata		= (__u8 *)buf;
+
+	/*combind sectors to pages*/
+	while(nSector)
+	{
+		SecWithinPage = StartSec % SECTOR_CNT_OF_LOGIC_PAGE;
+		SecBitmap |= (1 << SecWithinPage);
+		page = StartSec / SECTOR_CNT_OF_LOGIC_PAGE;
+
+
+		/*close page if last sector*/
+		if (SecWithinPage == (SECTOR_CNT_OF_LOGIC_PAGE - 1))
+		{
+			/*write to nand flash if align one logic page*/
+			if(SecBitmap == FULL_BITMAP_OF_LOGIC_PAGE)
+			{
+				/*disable write cache with current page*/
+				for (i = 0; i < N_NAND_W_CACHE; i++)
+				{
+					if(nand_w_cache[i].hit_page == page)
+					{
+						nand_w_cache[i].hit_page = 0xffffffff;
+						nand_w_cache[i].secbitmap = 0;
+						//hit=1;
+					}
+					else if((nand_w_cache[i].hit_page == page-1)&&(page>0))
+					{
+					    _flush_w_cache_simple(i);
+					}
+
+
+				}
+				/*disable read cache with current page*/
+				if (nand_r_cache.hit_page == page){
+					nand_r_cache.hit_page = 0xffffffff;
+					nand_r_cache.secbitmap = 0;
+				}
+
+                //if(!hit)
+                //    _flush_w_cache();
+
+				LML_PageWrite(page,FULL_BITMAP_OF_LOGIC_PAGE,pdata + 512 - 512*SECTOR_CNT_OF_LOGIC_PAGE);
+			}
+
+			/*fill to cache if unalign one logic page*/
+			else
+				_fill_nand_cache(page, SecBitmap, pdata + 512 - 512*_get_valid_bits(SecBitmap));
+
+			SecBitmap = 0;
+		}
+
+
+		/*reset variable*/
+		nSector--;
+		StartSec++;
+		pdata += 512;
+	}
+
+	/*fill opened page*/
+	if (SecBitmap)
+		_fill_nand_cache(page,SecBitmap,pdata - 512*_get_valid_bits(SecBitmap));
+
+	return 0;
+}
+
+
+__s32 NAND_CacheOpen(void)
+{
+	__u32 i;
+
+	g_w_access_cnt = 0;
+
+	for(i = 0; i < N_NAND_W_CACHE; i++)
+	{
+		nand_w_cache[i].size = 512 * SECTOR_CNT_OF_LOGIC_PAGE;
+		nand_w_cache[i].data = MALLOC(nand_w_cache[i].size);
+		nand_w_cache[i].hit_page = 0xffffffff;
+		nand_w_cache[i].secbitmap = 0;
+		nand_w_cache[i].access_count = 0;
+	}
+
+	nand_r_cache.size = 512 * SECTOR_CNT_OF_LOGIC_PAGE;
+	nand_r_cache.data = MALLOC(nand_r_cache.size);
+	nand_r_cache.hit_page = 0xffffffff;
+	nand_r_cache.secbitmap = 0;
+	nand_r_cache.access_count = 0;
+
+	return 0;
+}
+
+__s32 NAND_CacheClose(void)
+{
+	__u32 i;
+
+	NAND_CacheFlush();
+
+	#ifdef NAND_W_CACHE_EN
+		for(i = 0; i < N_NAND_W_CACHE; i++)
+			FREE(nand_w_cache[i].data,nand_w_cache[i].size);
+	#endif
+	FREE(nand_r_cache.data,nand_r_cache.size);
+	return 0;
+}
diff --git a/drivers/block/sunxi_nand/src/logic/logic_ctl.c b/drivers/block/sunxi_nand/src/logic/logic_ctl.c
new file mode 100644
index 0000000..af57d59
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/logic/logic_ctl.c
@@ -0,0 +1,1445 @@
+/*
+ * drivers/block/sunxi_nand/src/logic/logic_ctl.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include "../include/nand_logic.h"
+
+struct __NandDriverGlobal_t     NandDriverInfo;
+struct __LogicArchitecture_t    LogicArchiPar;
+struct __ZoneTblPstInfo_t       ZoneTblPstInfo[MAX_ZONE_CNT];
+//define the parameter for manage the cached page
+static struct __GlobalLogicPageType_t  CachePage;
+
+//define the parameter for manage the logical page read and write
+static struct __LogicCtlPar_t LogicalCtl;
+
+
+
+/*
+************************************************************************************************************************
+*                       CALCLUATE PROCESSING DATA PARAMETER
+*
+*Description: Calculate the loigcal pages number and the sector bitmap in the page for the sectors
+*             that pocessing currently.
+*
+*Arguments  : nSectNum      the number of the first sector of the sectors need be processed;
+*             nSectCnt      the count of the sectors that how many sectors need be processed;
+*             pHeadPage     the pointer to the paramter of the head page;
+*             pMidPageCnt   the pointer ot the count of full pages;
+*             pTailPage     the pointer to the paramter of the tail page.
+*
+*Return     : calculate sector parameter result;
+*               = 0     calculate sector parameter successful;
+*               < 0     calcualte sector parameter failed.
+************************************************************************************************************************
+*/
+static __s32 _CalculateSectPar(__u32 nSectNum, __u32 nSectCnt, struct __GlobalLogicPageType_t *pHeadPage,
+                                    __u32 *pMidPageCnt, struct __GlobalLogicPageType_t *pTailPage)
+{
+    __u32   tmpSectCnt, tmpBitmap;
+
+    LOGICCTL_DBG("[LOGICCTL_DBG]: Calculate logical sectors parameter, Lba:0x%x, Cnt:0x%x\n", nSectNum, nSectCnt);
+
+    //initiate the middle page and tail page parameters, because they may be empty
+    *pMidPageCnt = 0x00;
+    pTailPage->LogicPageNum = 0xffffffff;
+    pTailPage->SectorBitmap = 0x00;
+
+    //calculate the head page parameter
+    pHeadPage->LogicPageNum = nSectNum / SECTOR_CNT_OF_LOGIC_PAGE;
+    tmpSectCnt = nSectCnt + (nSectNum % SECTOR_CNT_OF_LOGIC_PAGE);
+    tmpBitmap = (FULL_BITMAP_OF_LOGIC_PAGE << (nSectNum % SECTOR_CNT_OF_LOGIC_PAGE));
+
+    if(tmpSectCnt > SECTOR_CNT_OF_LOGIC_PAGE)
+    {
+        //set the head page bitmap
+        pHeadPage->SectorBitmap = tmpBitmap & FULL_BITMAP_OF_LOGIC_PAGE;
+
+        //calcualte the count of full pages
+        tmpSectCnt -= SECTOR_CNT_OF_LOGIC_PAGE;
+        while(tmpSectCnt >= SECTOR_CNT_OF_LOGIC_PAGE)
+        {
+            ++*pMidPageCnt;
+            tmpSectCnt -= SECTOR_CNT_OF_LOGIC_PAGE;
+        }
+
+        //calculate parameter for the tail page
+        if(tmpSectCnt)
+        {
+            //calcualte the tail page sector bitmap
+            pTailPage->SectorBitmap = FULL_BITMAP_OF_LOGIC_PAGE >> (SECTOR_CNT_OF_LOGIC_PAGE - tmpSectCnt);
+
+            //calculate the number of the tail page
+            pTailPage->LogicPageNum = pHeadPage->LogicPageNum + *pMidPageCnt + 1;
+        }
+    }
+    else
+    {
+        //the head page is not a full page, reset the sector bitmap
+        pHeadPage->SectorBitmap = tmpBitmap & (FULL_BITMAP_OF_LOGIC_PAGE >> (SECTOR_CNT_OF_LOGIC_PAGE - tmpSectCnt));
+    }
+
+    LOGICCTL_DBG("   head page number:0x%x, head page bitmap:0x%x\n", pHeadPage->LogicPageNum, pHeadPage->SectorBitmap);
+    LOGICCTL_DBG("   the count of middle page:0x%x\n", *pMidPageCnt);
+    LOGICCTL_DBG("   tail page number:0x%x, tail page bitmap:0x%x\n\n", pTailPage->LogicPageNum, pTailPage->SectorBitmap);
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       CALCLUATE LOGICAL PAGE PARAMETER
+*
+*Description: Calculate the parameter for a logical page, the zone number, logic block number and
+*             and page number in logical block.
+*
+*Arguments  : pLogicPage    the pointer to the parameter of the logical page;
+*             nPage         the number of the global logical page;
+*             nBitmap       the bitmap of the valid sector in the logical page.
+*
+*Return     : calculate page parameter result;
+*               = 0     calculate page parameter successful;
+*               < 0     calcualte page parameter failed.
+************************************************************************************************************************
+*/
+static __s32 _CalculateLogicPagePar(struct __LogicPageType_t *pLogicPage, __u32 nPage, __u32 nBitmap)
+{
+    __u32   tmpPage, tmpBlk, tmpZone;
+
+    tmpPage = nPage % PAGE_CNT_OF_LOGIC_BLK;
+    tmpBlk = nPage / PAGE_CNT_OF_LOGIC_BLK;
+    tmpZone = tmpBlk / DATA_BLK_CNT_OF_ZONE;
+    tmpBlk %= DATA_BLK_CNT_OF_ZONE;
+
+    pLogicPage->ZoneNum = tmpZone;
+    pLogicPage->BlockNum = tmpBlk;
+    pLogicPage->PageNum = tmpPage;
+    pLogicPage->SectBitmap = nBitmap;
+
+    LOGICCTL_DBG("[LOGICCTL_DBG] The parameter of logical page 0x%x is : zone 0x%x, block 0x%x, page 0x%x\n",
+                    nPage, tmpZone, tmpBlk, tmpPage);
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       UPDATE USER DATA WITH THE CACHE PAGE
+*
+*Description: Update the user data with the cache page, because the number of the page read is
+*             same as the cached page, so need update the page data.
+*
+*Arguments  : nSectBitmap   the bitmap of the valid sectors in the user buffer;
+*             pBuf          the pointer to he user buffer;
+*
+*Return     : update page data result;
+*               = 0     update page data successful;
+*               < 0     update page data failed.
+************************************************************************************************************************
+*/
+static __s32 _UpdateReadPageData(__u32 nSectBitmap, void * pBuf)
+{
+    __s32   i;
+    __u8    *tmpSrc = LML_WRITE_PAGE_CACHE, *tmpDst = pBuf;
+
+    for(i=0; i<SECTOR_CNT_OF_LOGIC_PAGE; i++)
+    {
+        if(nSectBitmap & CachePage.SectorBitmap & (1<<i))
+        {
+            MEMCPY(tmpDst, tmpSrc, SECTOR_SIZE);
+        }
+
+        tmpSrc += SECTOR_SIZE;
+        tmpDst += SECTOR_SIZE;
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       MERGE WRITE PAGE DATA WITH CACHE PAGE DATA
+*
+*Description: Merge the data of write page with the cached page.
+*
+*Arguments  : nPage     the number of the logical page which need write to nand flash;
+*             nBitmap   the bitmap of the valid sectors in the write page;
+*             pBuf      the pointer to the page data buffer;
+*
+*Return     : merge page data result;
+*               = 0     merge page data successful;
+*               < 0     merge page data failed.
+************************************************************************************************************************
+*/
+static __s32 _MergeCachePageData(__u32 nPage, __u32 nBitmap, __u8 *pBuf)
+{
+    __s32   i;
+    __u8    *tmpSrc = pBuf, *tmpDst = LML_WRITE_PAGE_CACHE;
+
+    //check if the cache page is valid
+    if(CachePage.LogicPageNum == 0xffffffff)
+    {
+        //cache page is valid, set the logical page number, and reset the sector bitmap to null
+        CachePage.LogicPageNum = nPage;
+        CachePage.SectorBitmap = 0;
+    }
+
+    for(i=0; i<SECTOR_CNT_OF_LOGIC_PAGE; i++)
+    {
+        if(nBitmap & (1<<i))
+        {
+            //the sector of the write page is valid, copy data to the page cache
+            MEMCPY(tmpDst, tmpSrc, SECTOR_SIZE);
+        }
+
+        tmpSrc += SECTOR_SIZE;
+        tmpDst += SECTOR_SIZE;
+    }
+
+    //reset the sector bitmap for the cached page
+    CachePage.SectorBitmap |= nBitmap;
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       WRITE DATA OF PAGE CACHE TO NAND FLASH
+*
+*Description: Write the data of page cache to nand flash.
+*
+*Arguments  : none.
+*
+*Return     : write page cache result;
+*               = 0     write page cache successful;
+*               < 0     write page cache failed.
+************************************************************************************************************************
+*/
+static __s32 _WritePageCacheToNand(void)
+{
+    __s32   result = 0;
+    __u32   tmpPage, tmpBitmap;
+    __u8    *tmpBuf;
+
+    tmpPage = CachePage.LogicPageNum;
+    tmpBitmap = CachePage.SectorBitmap;
+    tmpBuf = LML_WRITE_PAGE_CACHE;
+
+    if(tmpPage != 0xffffffff)
+    {
+
+        if(tmpBitmap != FULL_BITMAP_OF_LOGIC_PAGE)
+        {
+            //get the data from logical page to fill the page cache
+            result = LML_PageRead(tmpPage, tmpBitmap ^ FULL_BITMAP_OF_LOGIC_PAGE, tmpBuf);
+            if(result < 0)
+            {
+                return -1;
+            }
+        }
+
+        //the data in the page cache is full, write it to nand flash
+        result = LML_PageWrite(tmpPage, FULL_BITMAP_OF_LOGIC_PAGE, tmpBuf);
+        if(result < 0)
+        {
+            return -1;
+        }
+
+        //clear the buffer page parameter
+        CachePage.LogicPageNum = 0xffffffff;
+        CachePage.SectorBitmap = 0x00;
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       CALCULATE PHYSICAL OPERATION PARAMETER
+*
+*Description: Calculate the paramter for physical operation with the number of zone, number of
+*             super block and number of page in the super block.
+*
+*Arguments  : pPhyPar   the pointer to the physical operation parameter;
+*             nZone     the number of the zone which the super block blonged to;
+*             nBlock    the number of the super block;
+*             nPage     the number of the super page in the super block.
+*
+*Return     : calculate parameter result;
+*               = 0     calculate parameter successful;
+*               < 0     calcualte parameter failed.
+************************************************************************************************************************
+*/
+#if(0)
+__s32 LML_CalculatePhyOpPar(struct __PhysicOpPara_t *pPhyPar, __u32 nZone, __u32 nBlock, __u32 nPage)
+{
+
+
+    __u32   tmpDieNum, tmpBnkNum, tmpBlkNum, tmpPageNum;
+
+    LOGICCTL_DBG("[LOGICCTL_DBG] Calculate the physical operation parameters.\n"
+                 "         ZoneNum:0x%x, BlockNum:0x%x, PageNum: 0x%x\n", nZone, nBlock, nPage);
+
+    //calcualte the Die number by the zone number
+    tmpDieNum = nZone / ZONE_CNT_OF_DIE;
+
+    if(SUPPORT_INT_INTERLEAVE && SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support internal inter-leave and external iner-leave, the block number is
+        //same as the virtual block number in the die, the bank number is the virtual page number
+        //model the inter-leave bank count, and the page number is the virtual page number
+        //divide the inter-leave bank count
+        tmpBnkNum = nPage % INTERLEAVE_BANK_CNT;
+        tmpBlkNum = nBlock;
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else if(SUPPORT_INT_INTERLEAVE && !SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support internal inter-leave but don't support external inter-leave, the block
+        //number if same as the vitual block number, the bank number is virtual page number model
+        //inter-leave count and add the chip bank base, the page number is the virtual page number
+        //divide the inter-leave bank count
+        tmpBnkNum = (nPage % INTERLEAVE_BANK_CNT) + (tmpDieNum * INTERLEAVE_BANK_CNT);
+        tmpBlkNum = nBlock;
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else if(!SUPPORT_INT_INTERLEAVE && SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support external inter-leave but don't support internal inter-leave, the block
+        //number is virtual block number add the die block base, the bank number is the page number
+        //model the inter-leave bank count, the page number is vitual page number divide the inter-leave
+        //bank count
+        tmpBnkNum = nPage % INTERLEAVE_BANK_CNT;
+        tmpBlkNum = nBlock + (tmpDieNum * (BLOCK_CNT_OF_DIE / PLANE_CNT_OF_DIE));
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else//(!SUPPORT_INT_INTERLEAVE && !SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash don't internal inter-leave and extern inter-leave either, the bank number is the
+        //die number divide the die count of chip, the block number is the virtual block number add
+        //the die block base in the chip, the page number is same as the virtual page number
+        tmpBnkNum = tmpDieNum / DIE_CNT_OF_CHIP;
+        tmpBlkNum = nBlock + (tmpDieNum % DIE_CNT_OF_CHIP) * (BLOCK_CNT_OF_DIE / PLANE_CNT_OF_DIE);
+        tmpPageNum = nPage;
+    }
+
+    //set the physical operation paramter by the bank number, block number and page number
+    pPhyPar->BankNum = tmpBnkNum;
+    pPhyPar->PageNum = tmpPageNum;
+    pPhyPar->BlkNum = tmpBlkNum;
+
+    LOGICCTL_DBG("         Calculate Result: BankNum 0x%x, BlkNum 0x%x, PageNum 0x%x\n", tmpBnkNum, tmpBlkNum, tmpPageNum);
+
+    //calculate physical operation parameter successful
+    return 0;
+}
+#elif(1)
+__s32 LML_CalculatePhyOpPar(struct __PhysicOpPara_t *pPhyPar, __u32 nZone, __u32 nBlock, __u32 nPage)
+{
+
+
+    __u32   tmpDieNum, tmpBnkNum, tmpBlkNum, tmpPageNum;
+
+    LOGICCTL_DBG("[LOGICCTL_DBG] Calculate the physical operation parameters.\n"
+                 "         ZoneNum:0x%x, BlockNum:0x%x, PageNum: 0x%x\n", nZone, nBlock, nPage);
+
+    //calcualte the Die number by the zone number
+    tmpDieNum = nZone / ZONE_CNT_OF_DIE;
+
+    if(SUPPORT_INT_INTERLEAVE && SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support internal inter-leave and external iner-leave, the block number is
+        //same as the virtual block number in the die, the bank number is the virtual page number
+        //model the inter-leave bank count, and the page number is the virtual page number
+        //divide the inter-leave bank count
+        tmpBnkNum = nPage % INTERLEAVE_BANK_CNT + (tmpDieNum * INTERLEAVE_BANK_CNT);
+        tmpBlkNum = nBlock ;
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else if(SUPPORT_INT_INTERLEAVE && !SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support internal inter-leave but don't support external inter-leave, the block
+        //number if same as the vitual block number, the bank number is virtual page number model
+        //inter-leave count and add the chip bank base, the page number is the virtual page number
+        //divide the inter-leave bank count
+        tmpBnkNum = (nPage % INTERLEAVE_BANK_CNT) + (tmpDieNum * INTERLEAVE_BANK_CNT);
+        tmpBlkNum = nBlock;
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else if(!SUPPORT_INT_INTERLEAVE && SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash support external inter-leave but don't support internal inter-leave, the block
+        //number is virtual block number add the die block base, the bank number is the page number
+        //model the inter-leave bank count, the page number is vitual page number divide the inter-leave
+        //bank count
+        //tmpBnkNum = nPage % INTERLEAVE_BANK_CNT + (tmpDieNum * INTERLEAVE_BANK_CNT);
+        tmpBnkNum = nPage % INTERLEAVE_BANK_CNT + (tmpDieNum/DIE_CNT_OF_CHIP) *INTERLEAVE_BANK_CNT;
+        tmpBlkNum = nBlock+ ((tmpDieNum % DIE_CNT_OF_CHIP) * (BLOCK_CNT_OF_DIE / PLANE_CNT_OF_DIE));
+        tmpPageNum = nPage / INTERLEAVE_BANK_CNT;
+    }
+
+    else//(!SUPPORT_INT_INTERLEAVE && !SUPPORT_EXT_INTERLEAVE)
+    {
+        //nand flash don't internal inter-leave and extern inter-leave either, the bank number is the
+        //die number divide the die count of chip, the block number is the virtual block number add
+        //the die block base in the chip, the page number is same as the virtual page number
+        tmpBnkNum = tmpDieNum / DIE_CNT_OF_CHIP;
+        tmpBlkNum = nBlock + (tmpDieNum % DIE_CNT_OF_CHIP) * (BLOCK_CNT_OF_DIE / PLANE_CNT_OF_DIE);
+        tmpPageNum = nPage;
+    }
+
+    //set the physical operation paramter by the bank number, block number and page number
+    pPhyPar->BankNum = tmpBnkNum;
+    pPhyPar->PageNum = tmpPageNum;
+    pPhyPar->BlkNum = tmpBlkNum;
+
+    LOGICCTL_DBG("         Calculate Result: BankNum 0x%x, BlkNum 0x%x, PageNum 0x%x\n", tmpBnkNum, tmpBlkNum, tmpPageNum);
+
+    //calculate physical operation parameter successful
+    return 0;
+}
+
+#endif
+
+
+
+
+
+
+/*
+************************************************************************************************************************
+*                       READ PAGE DATA FROM VIRTUAL BLOCK
+*
+*Description: Read page data from virtual block, the block is composed by several physical block.
+*             It is named super block too.
+*
+*Arguments  : pVirtualPage  the pointer to the virtual page paramter;
+*
+*Return     : read result;
+*               = 0     read page data successful;
+*               < 0     read page data failed.
+************************************************************************************************************************
+*/
+__s32 LML_VirtualPageRead(struct __PhysicOpPara_t *pVirtualPage)
+{
+    __s32 i, result;
+    __u32 tmpBitmap;
+    __u8  *tmpSpare, *tmpSrcData, *tmpDstData, *tmpSrcPtr[4], *tmpDstPtr[4];
+    struct __PhysicOpPara_t tmpPhyPage;
+
+    tmpPhyPage = *pVirtualPage;
+    tmpSpare = tmpPhyPage.SDataPtr;
+    tmpBitmap = tmpPhyPage.SectBitmap;
+
+    if(tmpSpare)
+    {
+        tmpPhyPage.SDataPtr = LML_SPARE_BUF;
+
+        //process the pointer to spare area data
+        for(i=0; i<2; i++)
+        {
+            if(tmpBitmap & (1<<i))
+            {
+                tmpSrcPtr[i] = LML_SPARE_BUF + 4 * i;
+                tmpDstPtr[i] = tmpSpare + 4 * i;
+            }
+            else
+            {
+                tmpDstPtr[i] = NULL;
+            }
+        }
+
+        for(i=0; i<2; i++)
+        {
+            if(tmpBitmap & (1<<(i + SECTOR_CNT_OF_SINGLE_PAGE)))
+            {
+                tmpSrcPtr[i+2] = LML_SPARE_BUF + 4 * (i + SECTOR_CNT_OF_SINGLE_PAGE);
+                tmpDstPtr[i+2] = tmpSpare + 8 + 4 * i;
+            }
+            else
+            {
+                tmpDstPtr[i+2] = NULL;
+            }
+        }
+    }
+    else
+    {
+        tmpPhyPage.SDataPtr = NULL;
+    }
+
+    result = PHY_PageRead(&tmpPhyPage);
+
+    //process spare area data
+    if(tmpSpare)
+    {
+        //get the spare area data
+        for(i=0; i<4; i++)
+        {
+            if(tmpDstPtr[i] != NULL)
+            {
+                tmpSrcData = tmpSrcPtr[i];
+                tmpDstData = tmpDstPtr[i];
+
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+            }
+        }
+    }
+
+	//add in 2010-05-21 by penggang, the logic layer needn't care the ecc error
+	if(result == -ERR_ECC)
+		result = 0;
+
+    return result;
+}
+
+
+/*
+************************************************************************************************************************
+*                       WRITE PAGE DATA TO VIRTUAL BLOCK
+*
+*Description: Write page data to virtual block, the block is composed by several physical block.
+*             It is named super block too.
+*
+*Arguments  : pVirtualPage  the pointer to the virtual page parameter.
+*
+*Return     : write result;
+*               = 0     write page data successful;
+*               < 0     write page data failed.
+************************************************************************************************************************
+*/
+__s32 LML_VirtualPageWrite( struct __PhysicOpPara_t *pVirtualPage)
+{
+    __s32 i, result;
+    __u32 tmpBitmap;
+    __u8  *tmpSpare, *tmpSrcData, *tmpDstData, *tmpSrcPtr[4], *tmpDstPtr[4];
+    struct __PhysicOpPara_t tmpPhyPage;
+
+    tmpPhyPage = *pVirtualPage;
+    tmpSpare = tmpPhyPage.SDataPtr;
+    //tmpBitmap = tmpPhyPage.SectBitmap;
+    tmpBitmap = FULL_BITMAP_OF_LOGIC_PAGE;
+    tmpPhyPage.SDataPtr = LML_SPARE_BUF;
+
+    //process spare area data
+    if(tmpSpare)
+    {
+        //process the pointer to spare area data
+        for(i=0; i<2; i++)
+        {
+            if(tmpBitmap & (1<<i))
+            {
+                tmpSrcPtr[i] = tmpSpare + 4 * i;
+                tmpDstPtr[i] = LML_SPARE_BUF + 4 * i;
+            }
+            else
+            {
+                tmpDstPtr[i] = NULL;
+            }
+        }
+
+        for(i=0; i<2; i++)
+        {
+            if(tmpBitmap & (1<<(i + SECTOR_CNT_OF_SINGLE_PAGE)))
+            {
+                tmpSrcPtr[i+2] = tmpSpare + 8 + 4 * i;
+                tmpDstPtr[i+2] = LML_SPARE_BUF + 4 * (i + SECTOR_CNT_OF_SINGLE_PAGE);
+            }
+            else
+            {
+                tmpDstPtr[i+2] = NULL;
+            }
+        }
+
+        MEMSET(LML_SPARE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * 4);
+
+        for(i=0; i<4; i++)
+        {
+            tmpSrcData = tmpSrcPtr[i];
+            tmpDstData = tmpDstPtr[i];
+
+            if(tmpDstData != NULL)
+            {
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+                *tmpDstData++ = *tmpSrcData++;
+            }
+        }
+    }
+    else
+    {
+        MEMSET(LML_SPARE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * 4);
+    }
+
+    result = PHY_PageWrite(&tmpPhyPage);
+
+    return result;
+}
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER ERASE SUPER BLOCK
+*
+*Description: Erase the given super block.
+*
+*Arguments  : nZone         the number of the zone which the super block belonged to;
+*             nSuperBlk     the number of the super block which need be erased.
+*
+*Return     : erase result
+*               = 0     super block erase successful;
+*               =-1     super block erase failed.
+************************************************************************************************************************
+*/
+__s32 LML_VirtualBlkErase(__u32 nZone, __u32 nSuperBlk)
+{
+    __s32 i, result = 0;
+    struct __PhysicOpPara_t tmpPhyBlk;
+
+    #if CFG_SUPPORT_WEAR_LEVELLING
+
+    //increase the erase counter of super block
+    BLK_ERASE_CNTER++;
+
+    #endif
+    //erase every block belonged to different banks
+    for(i=0; i<INTERLEAVE_BANK_CNT; i++)
+    {
+        //calculate the physical operation parameter by te die number, block number and page number
+        LML_CalculatePhyOpPar(&tmpPhyBlk, nZone, nSuperBlk, i);
+
+        PHY_BlockErase(&tmpPhyBlk);
+    }
+
+    //check the result of the block erase
+    for(i=0; i<INTERLEAVE_BANK_CNT; i++)
+    {
+        result = PHY_SynchBank(i, SYNC_BANK_MODE);
+        if(result < 0)
+        {
+        	//the operation of last page write is failed
+            LOGICCTL_ERR("[LOGICCTL_DBG] erase zone %x block %x bank %x fail\n",
+            				nZone,nSuperBlk,i);
+
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       LOGICAL MANAGE LAYER CLOSE WRITE PAGE
+*
+*Description: Close last write page, for switch nand flash operation mode.
+*
+*Arguments  : none.
+*
+*Return     : clase page result;
+*               = 0     close page successful;
+*               = -1    close page failed.
+************************************************************************************************************************
+*/
+static __s32 _CloseWritePage(void)
+{
+    __s32 result;
+    struct __PhysicOpPara_t tmpPage;
+    struct __LogBlkType_t tmpLogBlk;
+
+    //check if current mode is write mode
+    if(LogicalCtl.OpMode == 'w')
+    {
+        //calculate the paramter of last page
+        LML_CalculatePhyOpPar(&tmpPage, LogicalCtl.ZoneNum, LogicalCtl.LogBlkNum.PhyBlkNum, LogicalCtl.LogPageNum);
+
+        result = PHY_SynchBank(tmpPage.BankNum, SYNC_BANK_MODE);
+        if(result < 0)
+        {
+            //the operation of last page write is failed
+            LOGICCTL_DBG("[LOGICCTL_DBG] Write page failed when close write page! Bnk:0x%x, Blk:0x%x, Page:0x%x\n",
+                            tmpPage.BankNum, tmpPage.BlkNum, tmpPage.PageNum);
+
+            //process the bad block
+            result = LML_BadBlkManage(&LogicalCtl.LogBlkNum, LogicalCtl.ZoneNum, LogicalCtl.LogPageNum + 1, &LogicalCtl.LogBlkNum);
+            if(result < 0)
+            {
+                LOGICCTL_ERR("[LOGICCTL_ERR] Bad block proecess failed when close write page, Err:0x%x\n", result);
+                return -1;
+            }
+
+            //reset the physical block number of the log block with the new log block
+            BMM_GetLogBlk(LogicalCtl.LogicBlkNum, &tmpLogBlk);
+            tmpLogBlk.PhyBlk = LogicalCtl.LogBlkNum;
+            BMM_SetLogBlk(LogicalCtl.LogicBlkNum, &tmpLogBlk);
+        }
+
+        //wait the nand flash chip ready
+        PHY_SynchBank(tmpPage.BankNum, SYNC_CHIP_MODE);
+    }
+
+    LogicalCtl.OpMode = 'n';
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER PAGE READ
+*
+*Description: Read data from logic disk to buffer based page.
+*
+*Arguments  : nPage     the page address which need be read;
+*             nBitmap   the bitmap of the sectors in the page which need be read data;
+*             pBuf      the pointer to the buffer where will store the data read out.
+*
+*Return     : page read result;
+*               = 0     read successful;
+*               > 0     read successful, but need do some process;
+*               < 0     read failed.
+************************************************************************************************************************
+*/
+__s32 LML_PageRead(__u32 nPage, __u32 nBitmap, void* pBuf)
+{
+    __s32 result;
+    __u32 tmpSuperBlk, tmpSuperPage;
+    struct __LogicPageType_t tmpLogicPage;
+    struct __PhysicOpPara_t tmpPhyPage;
+    struct __LogBlkType_t tmpLogBlk;
+
+    _CalculateLogicPagePar(&tmpLogicPage, nPage, nBitmap);
+
+    //check if last operation is read, if not, need set to read mode
+    if(LogicalCtl.OpMode != 'r')
+    {
+        if(LogicalCtl.OpMode == 'w')
+        {
+            //last operation is write, need close last write logical page, switch to read mode
+            result = _CloseWritePage();
+            if(result < 0)
+            {
+                LOGICCTL_ERR("[LOGICCTL_ERR] Close write page failed, when read logical page!\n");
+                return -ERR_LOGICCTL;
+            }
+        }
+
+        //set operation mode to read
+        LogicalCtl.OpMode = 'r';
+    }
+
+    //check if access the same zone area as last access
+    if(tmpLogicPage.ZoneNum != LogicalCtl.ZoneNum)
+    {
+        //swap the block mapping table to ram which is need be accessing currently
+        result = BMM_SwitchMapTbl(tmpLogicPage.ZoneNum);
+        if(result < 0)
+        {
+            LOGICCTL_ERR("[LOGICCTL_ERR] Switch block mapping table failed when read logical page! Err:0x%x\n", result);
+            return -ERR_MAPPING;
+        }
+
+        //set the zone number that accessing currently
+        LogicalCtl.ZoneNum = tmpLogicPage.ZoneNum;
+        //reset the number of logical block
+        LogicalCtl.LogicBlkNum = 0xffff;
+    }
+
+    //check if accessing the same logical block as last access
+    if(tmpLogicPage.BlockNum != LogicalCtl.LogicBlkNum)
+    {
+        //get the data block number and log block number for read
+        BMM_GetDataBlk(tmpLogicPage.BlockNum, &LogicalCtl.DataBlkNum);
+
+        BMM_GetLogBlk(tmpLogicPage.BlockNum, &tmpLogBlk);
+        LogicalCtl.LogBlkNum = tmpLogBlk.PhyBlk;
+
+        //set the logical block number for logical control parameter
+        LogicalCtl.LogicBlkNum = tmpLogicPage.BlockNum;
+    }
+
+    //set the number for logical page that accessing currently
+    LogicalCtl.LogicPageNum = tmpLogicPage.PageNum;
+
+    //get the number of log page for read
+    if(LogicalCtl.LogBlkNum.PhyBlkNum != 0xffff)
+    {
+        //get log page with read mode
+        LogicalCtl.LogPageNum = PMM_GetLogPage(tmpLogicPage.BlockNum, LogicalCtl.LogicPageNum, 'r');
+    }
+    else
+    {
+        LogicalCtl.LogPageNum = 0xffff;
+    }
+
+    //set the number of super block and super page in the super block for get page data
+    if(LogicalCtl.LogPageNum != 0xffff)
+    {
+        tmpSuperBlk = LogicalCtl.LogBlkNum.PhyBlkNum;
+        tmpSuperPage = LogicalCtl.LogPageNum;
+    }
+    else
+    {
+        tmpSuperBlk = LogicalCtl.DataBlkNum.PhyBlkNum;
+        tmpSuperPage = LogicalCtl.LogicPageNum;
+    }
+
+    //calculate the parameter of physical operation for get page data
+    LML_CalculatePhyOpPar(&tmpPhyPage, LogicalCtl.ZoneNum, tmpSuperBlk, tmpSuperPage);
+    tmpPhyPage.SectBitmap = tmpLogicPage.SectBitmap;
+    tmpPhyPage.MDataPtr = pBuf;
+    tmpPhyPage.SDataPtr = NULL;
+
+    //get data from physical page with the physical operation
+    result = LML_VirtualPageRead(&tmpPhyPage);
+    if(result < 0)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Get page data failed when read logical page! Err:0x%x\n ", result);
+        return -1;
+    }
+
+    return result;
+}
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER PAGE WRITE
+*
+*Description: Write data from buffer to logic area based on page.
+*
+*Arguments  : nPage     the page address which need be write;
+*             nBitmap   the bitmap of sectors in the page which need be write, it is always full;
+*             pBuf      the pointer to the buffer where is storing the data.
+*
+*Return     : write result;
+*               = 0     write successful;
+*               > 0     write successful, but need do some process;
+*               < 0     write failed.
+************************************************************************************************************************
+*/
+__s32 LML_PageWrite(__u32 nPage, __u32 nBitmap, void* pBuf)
+{
+    __s32 result;
+    struct __LogicPageType_t tmpLogicPage;
+    struct __PhysicOpPara_t tmpPhyPage;
+    struct __NandUserData_t tmpSpare[2];
+    struct __LogBlkType_t tmpLogBlk;
+
+
+    //check if the bitmap of valid sectors is full, if not, report error
+    if(nBitmap != FULL_BITMAP_OF_LOGIC_PAGE)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Sector bitmap is not full when write logical page!\n");
+        return -ERR_LOGICCTL;
+    }
+
+    //calculate the pamater for the logical page
+    _CalculateLogicPagePar(&tmpLogicPage, nPage, nBitmap);
+
+    //check if access the same zone area as last access
+    if(tmpLogicPage.ZoneNum != LogicalCtl.ZoneNum)
+    {
+        //last operation is write, need close last write logical page, switch to read mode
+        result = _CloseWritePage();
+        if(result < 0)
+        {
+            LOGICCTL_ERR("[LOGICCTL_ERR] Close write page failed, when write logical page!\n");
+            return -ERR_LOGICCTL;
+        }
+
+        //swap the block mapping table to ram which is need be accessing currently
+        result = BMM_SwitchMapTbl(tmpLogicPage.ZoneNum);
+        if(result < 0)
+        {
+            LOGICCTL_ERR("[LOGICCTL_ERR] Switch block mapping table failed when write logical page! Err:0x%x\n", result);
+            return -ERR_MAPPING;
+        }
+
+        //set the zone number that accessing currently
+        LogicalCtl.ZoneNum = tmpLogicPage.ZoneNum;
+        //reset the number of logical block
+        LogicalCtl.LogicBlkNum = 0xffff;
+    }
+
+    //set dirty flag for block mapping table
+    BMM_SetDirtyFlag();
+
+    //check if accessing the same logical block as last access
+    if(tmpLogicPage.BlockNum != LogicalCtl.LogicBlkNum)
+    {
+        //last operation is write, need close last write logical page, switch to read mode
+        result = _CloseWritePage();
+        if(result < 0)
+        {
+            LOGICCTL_ERR("[LOGICCTL_ERR] Close write page failed, when write logical page!\n");
+            return -ERR_LOGICCTL;
+        }
+
+        //set the logical block number for logical control parameter
+        LogicalCtl.LogicBlkNum = tmpLogicPage.BlockNum;
+    }
+
+    //set the number of the logical page for logical control
+    LogicalCtl.LogicPageNum = tmpLogicPage.PageNum;
+
+    //get log page for write page data, log page is necessary when write logical page
+    LogicalCtl.LogPageNum = PMM_GetLogPage(LogicalCtl.LogicBlkNum, LogicalCtl.LogicPageNum, 'w');
+    if(LogicalCtl.LogPageNum == 0xffff)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Get log page failed when write logical page!\n");
+        return -ERR_MAPPING;
+    }
+
+    //get the data block number and log block number for write
+    BMM_GetDataBlk(tmpLogicPage.BlockNum, &LogicalCtl.DataBlkNum);
+
+    BMM_GetLogBlk(tmpLogicPage.BlockNum, &tmpLogBlk);
+    LogicalCtl.LogBlkNum = tmpLogBlk.PhyBlk;
+
+
+    //check if the log block is valid, log block is nessesary necessary when write logical page
+    if(LogicalCtl.LogBlkNum.PhyBlkNum == 0xffff)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Get log block failed when write logical page!\n");
+        return -ERR_MAPPING;
+    }
+
+    //set spare area data for writing to the spare area of nand flash
+    if(LogicalCtl.LogPageNum == 0)
+    {
+        //log page is the page0 of the super block, the meaning of the page status is log age
+        LML_CalculatePhyOpPar(&tmpPhyPage, LogicalCtl.ZoneNum, LogicalCtl.DataBlkNum.PhyBlkNum, 0);
+        tmpPhyPage.SectBitmap = 0x3;
+        tmpPhyPage.MDataPtr = LML_TEMP_BUF;
+        tmpPhyPage.SDataPtr = (void *)tmpSpare;
+        result = LML_VirtualPageRead(&tmpPhyPage);
+        if(result < 0)
+        {
+            LOGICCTL_ERR("[LOGICCTL_ERR] Get log age of data block failed when write logical page, Err:0x%x!\n", result);
+            return -ERR_PHYSIC;
+        }
+
+        //increase the log age
+        tmpSpare[0].PageStatus = tmpSpare[0].PageStatus + 1;
+        tmpSpare[1].PageStatus = tmpSpare[0].PageStatus;
+    }
+    else
+    {
+        //set page used mark to the spare area data
+        tmpSpare[0].PageStatus = 0x55;
+        tmpSpare[1].PageStatus = 0x55;
+    }
+    tmpSpare[0].BadBlkFlag = 0xff;
+    tmpSpare[1].BadBlkFlag = 0xff;
+    tmpSpare[0].LogicInfo = ((LogicalCtl.ZoneNum % ZONE_CNT_OF_DIE)<<10) | LogicalCtl.LogicBlkNum;
+    tmpSpare[1].LogicInfo = ((LogicalCtl.ZoneNum % ZONE_CNT_OF_DIE)<<10) | LogicalCtl.LogicBlkNum;
+    tmpSpare[0].LogicPageNum = LogicalCtl.LogicPageNum;
+    tmpSpare[1].LogicPageNum = LogicalCtl.LogicPageNum;
+
+__TRY_WRITE_PHYSIC_PAGE:
+    //calculate the parameter for writing page to nand flash
+    LML_CalculatePhyOpPar(&tmpPhyPage, LogicalCtl.ZoneNum, LogicalCtl.LogBlkNum.PhyBlkNum, LogicalCtl.LogPageNum);
+    tmpPhyPage.SectBitmap = tmpLogicPage.SectBitmap;
+    tmpPhyPage.MDataPtr = pBuf;
+    tmpPhyPage.SDataPtr = (void *)tmpSpare;
+
+    #if !CFG_SUPPORT_CHECK_WRITE_SYNCH
+
+	if (LogicalCtl.OpMode == 'w')
+    {
+    	//synch currently write bank
+    	result = PHY_SynchBank(tmpPhyPage.BankNum, SYNC_BANK_MODE);
+    	if(result < 0)
+    	{
+        	//the last write operation on current bank is failed, the block is bad, need proccess it
+        	LOGICCTL_DBG("[LOGICCTL_DBG] Find a bad block when write logical page! bank:0x%x, block:0x%x, page:0x%x\n",
+                tmpPhyPage.BankNum, tmpPhyPage.BlkNum, tmpPhyPage.PageNum);
+
+        	//process the bad block
+        	result = LML_BadBlkManage(&LogicalCtl.LogBlkNum, LogicalCtl.ZoneNum, LogicalCtl.LogPageNum, &LogicalCtl.LogBlkNum);
+        	if(result < 0)
+        	{
+            	LOGICCTL_ERR("[LOGICCTL_ERR] Bad block proecess failed when write page, Err:0x%x\n", result);
+            	return -1;
+        	}
+
+        	//reset the physical block number of the log block with the new log block
+        	BMM_GetLogBlk(LogicalCtl.LogicBlkNum, &tmpLogBlk);
+        	tmpLogBlk.PhyBlk = LogicalCtl.LogBlkNum;
+        	BMM_SetLogBlk(LogicalCtl.LogicBlkNum, &tmpLogBlk);
+
+        	goto __TRY_WRITE_PHYSIC_PAGE;
+    	}
+    }
+#endif
+
+	 result = LML_VirtualPageWrite(&tmpPhyPage);
+    if(result < 0)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Physical write module failed when write logical page, Err:0x%x!\n", result);
+        return -ERR_LOGICCTL;
+    }
+
+#if CFG_SUPPORT_CHECK_WRITE_SYNCH
+
+    //synch currently write bank
+    result = PHY_SynchBank(tmpPhyPage.BankNum, SYNC_BANK_MODE);
+    if(result < 0)
+    {
+        //the last write operation on current bank is failed, the block is bad, need proccess it
+        LOGICCTL_DBG("[LOGICCTL_DBG] Find a bad block when write logical page! bank:0x%x, block:0x%x, page:0x%x\n",
+                tmpPhyPage.BankNum, tmpPhyPage.BlkNum, tmpPhyPage.PageNum);
+
+        //process the bad block
+        result = LML_BadBlkManage(&LogicalCtl.LogBlkNum, LogicalCtl.ZoneNum, LogicalCtl.LogPageNum, &LogicalCtl.LogBlkNum);
+        if(result < 0)
+        {
+            LOGICCTL_ERR("[LOGICCTL_ERR] Bad block proecess failed when write page, Err:0x$x\n", result);
+            return -1;
+        }
+
+        //reset the physical block number of the log block with the new log block
+        BMM_GetLogBlk(LogicalCtl.LogicBlkNum, &tmpLogBlk);
+        tmpLogBlk.PhyBlk = LogicalCtl.LogBlkNum;
+        BMM_SetLogBlk(LogicalCtl.LogicBlkNum, &tmpLogBlk);
+
+        goto __TRY_WRITE_PHYSIC_PAGE;
+    }
+
+#endif
+
+    //set the mode of operation
+    LogicalCtl.OpMode = 'w';
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER FLUSH PAGE CACHE
+*
+*Description: Flush the data in the cache buffer to nand flash.
+*
+*Arguments  : none
+
+*Return     : flush result;
+*               = 0     flush successful;
+*               = -1    flush failed.
+************************************************************************************************************************
+*/
+__s32 LML_FlushPageCache(void)
+{
+    __s32   result;
+
+    result = _WritePageCacheToNand();
+    if(result < 0)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Write page cache to nand failed when flush page cache! Error:0x%x\n", result);
+        return -1;
+    }
+
+    result = _CloseWritePage();
+    if(result < 0)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Close write page failed when flush page cache! Error:0x%x\n", result);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                           NAND FLASH LOGIC MANAGE LAYER READ
+*
+*Description: Read data from logic disk area to buffer.
+*
+*Arguments  : nSectNum      the logic block address on the logic area from where to read;
+*             nSectorCnt    the size of the data need be read, based on sector;
+*             pBuf          the pointer to the buffer where will store the data readout of nand.
+*
+*Return     : read result;
+*               = 0     read successful;
+*               = -1    read failed.
+************************************************************************************************************************
+*/
+__s32 LML_Read(__u32 nSectNum, __u32 nSectorCnt, void* pBuf)
+{
+    __s32   i, result;
+    __u32   tmpMidPageCnt, tmpPageNum, tmpBitmap, tmpPageCnt;
+    __u8    *tmpBuf;
+    struct __GlobalLogicPageType_t tmpHeadPage, tmpTailPage;
+
+    LOGICCTL_DBG("[LOGICCTL_DBG] LML_Read, sector number:0x%x, sector cnt:0x%x, Buffer:0x%x\n", nSectNum, nSectorCnt, pBuf);
+
+		if(((__u32)pBuf)&0x3)
+	  {
+	      LOGICCTL_ERR("[LOGICCTL_ERR] LML_Write, invalid bufaddr: 0x%x \n", (__u32)(pBuf));
+				return -ERR_ADDRBEYOND;
+	  }
+
+    //check if the parameter is valid
+    if(((nSectNum + nSectorCnt) > LogicalCtl.DiskCap)||(nSectNum>LogicalCtl.DiskCap-1)||(nSectorCnt>LogicalCtl.DiskCap-1))
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] LML_Read, the addr of read(start:%x, cnt:%x) is beyond the disk volume %x!!!\n",
+						nSectNum, nSectorCnt,LogicalCtl.DiskCap);
+        return -ERR_ADDRBEYOND;
+    }
+    if(!nSectorCnt)
+    {
+        LOGICCTL_DBG("[WARNING] LML_Read, sector count of read is 0!!!\n");
+        return 0;
+    }
+    //calculate logical parameter of the sectors
+    _CalculateSectPar(nSectNum, nSectorCnt, &tmpHeadPage, &tmpMidPageCnt, &tmpTailPage);
+
+    tmpBuf = pBuf;
+
+    //calculate the buffer address for page align
+    for(i=0; i<SECTOR_CNT_OF_LOGIC_PAGE; i++)
+    {
+        if(tmpHeadPage.SectorBitmap & (1<<i))
+        {
+            break;
+        }
+        tmpBuf -= SECTOR_SIZE;
+    }
+
+    tmpPageNum = tmpHeadPage.LogicPageNum;
+    tmpBitmap = tmpHeadPage.SectorBitmap;
+
+    //calculate the whole count the logical pages
+    tmpPageCnt = 1 + tmpMidPageCnt;
+    if(tmpTailPage.SectorBitmap)
+    {
+        tmpPageCnt++;
+    }
+
+    for(i=0; i<tmpPageCnt; i++)
+    {
+        //read data from the logical page
+        result = LML_PageRead(tmpPageNum, tmpBitmap, tmpBuf);
+        if(result < 0)
+        {
+            //get page data failed!
+            LOGICCTL_ERR("[LOGICCTL_ERR] LML_Read, read page data faild! the page number:0x%x, sector bitmap:0x%x, buffer:0x%x, "
+                    "error number:0x%x\n",tmpPageNum, tmpBitmap, (__u32)tmpBuf, result);
+            return -1;
+        }
+
+        #if CFG_SUPPORT_READ_RECLAIM
+        if(result == ECC_LIMIT)
+        {
+            LML_ReadReclaim(tmpPageNum);
+        }
+        #endif
+
+        //check if need update the page data with the cache page
+        if(tmpPageNum == CachePage.LogicPageNum)
+        {
+            _UpdateReadPageData(tmpBitmap, tmpBuf);
+        }
+
+        //increase the logical page number and the buffer address
+        tmpPageNum++;
+        tmpBuf += SECTOR_SIZE * SECTOR_CNT_OF_LOGIC_PAGE;
+
+        //check if read data from the tail page
+        if(tmpTailPage.SectorBitmap && (i == tmpPageCnt - 2))
+        {
+            tmpBitmap = tmpTailPage.SectorBitmap;
+        }
+        else
+        {
+            tmpBitmap = FULL_BITMAP_OF_LOGIC_PAGE;
+        }
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL(LML_Read);
+
+/*
+extern dump(void * buf, __u32 len, __u8 nbyte, __u8 linelen);
+
+void echo_write_data (__u32 nSectNum, __u32 nSectorCnt, void* pBuf)
+{
+	__u32 i,j;
+	__u8 *buf;
+
+	for (i = 0,j = nSectNum; i < nSectorCnt; i++,j++)
+	{
+		buf = (__u8 *)pBuf + i*512;
+		PRINT("***********echo data from sector %d***************\n",j);
+		dump(buf, 16,1, 16);
+	}
+
+	return;
+
+}*/
+
+/*
+************************************************************************************************************************
+*                           NAND FLASH LOGIC MANAGE LAYER WRITE
+*
+*Description: Write data from buffer to logic disk area.
+*
+*Arguments  : nSectNum      the logic block address on the logic area from where to write;
+*             nSectorCnt    the size of the data need to be write, based on sector;
+*             pBuf          the pointer to the buffer where stored the data write to nand flash.
+*
+*Return     : write result;
+*               = 0     write successful;
+*               = -1    write failed.
+************************************************************************************************************************
+*/
+__s32 LML_Write(__u32 nSectNum, __u32 nSectorCnt, void* pBuf)
+{
+    __s32   i, result;
+    __u32   tmpMidPageCnt, tmpPageNum, tmpBitmap, tmpPageCnt;
+    __u8    *tmpBuf;
+    struct __GlobalLogicPageType_t tmpHeadPage, tmpTailPage;
+
+	 	if(((__u32)pBuf)&0x3)
+	  {
+	      LOGICCTL_ERR("[LOGICCTL_ERR] LML_Write, invalid bufaddr: 0x%x \n", (__u32)(pBuf));
+				return -ERR_ADDRBEYOND;
+	  }
+
+    if(((nSectNum + nSectorCnt) > LogicalCtl.DiskCap)||(nSectNum>LogicalCtl.DiskCap-1)||(nSectorCnt>LogicalCtl.DiskCap-1))
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] LML_Write, the addr of write(start:%x, cnt:%x) is beyond the disk volume %x!!!\n",
+						nSectNum, nSectorCnt,LogicalCtl.DiskCap);
+				return -ERR_ADDRBEYOND;
+    }
+    if(!nSectorCnt)
+    {
+        LOGICCTL_DBG("[WARNING] LML_Write, sector count of write is 0!!!\n");
+        return 0;
+    }
+    //calculate the logical parameter for the sectors
+    _CalculateSectPar(nSectNum, nSectorCnt, &tmpHeadPage, &tmpMidPageCnt, &tmpTailPage);
+
+    tmpBuf = pBuf;
+
+    //calculate the buffer address for page align
+    for(i=0; i<SECTOR_CNT_OF_LOGIC_PAGE; i++)
+    {
+        if(tmpHeadPage.SectorBitmap & (1<<i))
+        {
+            break;
+        }
+        tmpBuf -= SECTOR_SIZE;
+    }
+
+    tmpPageNum = tmpHeadPage.LogicPageNum;
+    tmpBitmap = tmpHeadPage.SectorBitmap;
+
+    //calculate the whole count the logical pages
+    tmpPageCnt = 1 + tmpMidPageCnt;
+    if(tmpTailPage.SectorBitmap)
+    {
+        tmpPageCnt++;
+    }
+
+    for(i=0; i<tmpPageCnt; i++)
+    {
+        //check if current write page is same as the cached page
+        if(tmpPageNum == CachePage.LogicPageNum)
+        {
+            //merge current page data with the cached page
+            _MergeCachePageData(tmpPageNum, tmpBitmap, tmpBuf);
+        }
+        else
+        {
+            //flush cached page to nand flash
+            result = _WritePageCacheToNand();
+            if(result < 0)
+            {
+                LOGICCTL_ERR("[LOGICCTL_ERR] Write page cache to nand flash failed!\n");
+                return -1;
+            }
+
+            if(tmpBitmap == FULL_BITMAP_OF_LOGIC_PAGE)
+            {
+                //write the full page to nand flash
+                result = LML_PageWrite(tmpPageNum, tmpBitmap, tmpBuf);
+                if(result < 0)
+                {
+                    LOGICCTL_ERR("[LOGICCTL_ERR] Write logical page failed! Error:0x%x\n", result);
+                    return -1;
+                }
+            }
+            else
+            {
+                //write page is not full, merge the data to page cache
+                _MergeCachePageData(tmpPageNum, tmpBitmap, tmpBuf);
+            }
+        }
+
+        //increase the logical page number and the buffer address
+        tmpPageNum++;
+        tmpBuf += SECTOR_SIZE * SECTOR_CNT_OF_LOGIC_PAGE;
+
+        //reset the sector bitmap in the logical page
+        if(tmpTailPage.SectorBitmap && (i == tmpPageCnt - 2))
+        {
+            tmpBitmap = tmpTailPage.SectorBitmap;
+        }
+        else
+        {
+            tmpBitmap = FULL_BITMAP_OF_LOGIC_PAGE;
+        }
+    }
+	 return 0;
+}
+EXPORT_SYMBOL(LML_Write);
+
+
+/*
+************************************************************************************************************************
+*                           INITIATE NAND FLASH LOGIC MANAGE LAYER
+*
+*Description: initiate the logic manage layer for nand flash driver.
+*
+*Arguments  : none;
+*
+*Return     : intiate result;
+*               = 0     init successful;
+*               = -1    init failed.
+************************************************************************************************************************
+*/
+__s32 LML_Init(void)
+{
+    __s32   result;
+
+    CachePage.LogicPageNum = 0xffffffff;
+    CachePage.SectorBitmap = 0x00000000;
+
+    LogicalCtl.OpMode = 'n';
+    LogicalCtl.ZoneNum = 0xff;
+    LogicalCtl.LogicBlkNum = 0xffff;
+    LogicalCtl.LogicPageNum = 0xffff;
+    LogicalCtl.LogPageNum = 0xffff;
+    LogicalCtl.DataBlkNum.BlkEraseCnt = 0xffff;
+    LogicalCtl.DataBlkNum.PhyBlkNum = 0xffff;
+    LogicalCtl.LogBlkNum.BlkEraseCnt = 0xffff;
+    LogicalCtl.LogBlkNum.PhyBlkNum = 0xffff;
+    LogicalCtl.DiskCap = SECTOR_CNT_OF_SINGLE_PAGE * PAGE_CNT_OF_PHY_BLK * BLOCK_CNT_OF_DIE * \
+            DIE_CNT_OF_CHIP * NandDriverInfo.NandStorageInfo->ChipCnt  / BLOCK_CNT_OF_ZONE * DATA_BLK_CNT_OF_ZONE;
+
+
+    //request page buffer for process data
+    NandDriverInfo.PageCachePool->PageCache1 = (__u8 *)MALLOC(SECTOR_CNT_OF_LOGIC_PAGE * SECTOR_SIZE);
+    if(!NandDriverInfo.PageCachePool->PageCache1)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Request memory for nand flash page cache failed!!");
+        return -ERR_MALLOC;
+    }
+    //NandDriverInfo.PageCachePool->PageCache2 = NULL;
+     NandDriverInfo.PageCachePool->PageCache2 = (__u8 *)MALLOC(SECTOR_CNT_OF_LOGIC_PAGE * SECTOR_SIZE);
+    if(!NandDriverInfo.PageCachePool->PageCache2)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Request memory for nand flash page cache failed!!");
+        return -ERR_MALLOC;
+    }
+
+    //request buffer for process spare area data
+    MEMSET(LML_SPARE_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * 4);
+
+    //init the mapping tabel manage module
+    result = BMM_InitMapTblCache();
+    if(result < 0)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Init the mapping table manage module failed! Err:0x%x\n", result);
+        return -ERR_MAPPING;
+    }
+
+    result = PMM_InitMapTblCache();
+    if(result < 0)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Init the mapping table manage module failed! Err:0x%x\n", result);
+        return -ERR_MAPPING;
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                           NAND FLASH LOGIC MANAGE LAYER EXIT
+*
+*Description: exit nand flash logic manage layer.
+*
+*Arguments  : none;
+*
+*Return     : exit result;
+*               = 0     exit successfu;
+*               = -1    exit failed.
+************************************************************************************************************************
+*/
+__s32 LML_Exit(void)
+{
+     //flush page cache to nand flash
+    LML_FlushPageCache();
+
+    //write all mapping table to nand flash
+    BMM_WriteBackAllMapTbl();
+
+    //free the mapping module
+    PMM_ExitMapTblCache();
+    BMM_ExitMapTblCache();
+
+    FREE(NandDriverInfo.PageCachePool->PageCache1,SECTOR_CNT_OF_LOGIC_PAGE * SECTOR_SIZE);
+	FREE(NandDriverInfo.PageCachePool->PageCache2,SECTOR_CNT_OF_LOGIC_PAGE * SECTOR_SIZE);
+
+    return 0;
+}
+
+// 2010-12-04 modified
+__u32 NAND_GetDiskSize(void)
+{
+    __u32 disksize;
+
+    disksize = (SECTOR_CNT_OF_SINGLE_PAGE * PAGE_CNT_OF_PHY_BLK * BLOCK_CNT_OF_DIE * \
+            DIE_CNT_OF_CHIP * NandStorageInfo.ChipCnt  / 1024 * DATA_BLK_CNT_OF_ZONE);
+
+    return disksize;
+}
+
diff --git a/drivers/block/sunxi_nand/src/logic/mapping.c b/drivers/block/sunxi_nand/src/logic/mapping.c
new file mode 100644
index 0000000..6a441d8
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/logic/mapping.c
@@ -0,0 +1,1007 @@
+/*
+ * drivers/block/sunxi_nand/src/logic/mapping.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_logic.h"
+
+extern struct __NandDriverGlobal_t     NandDriverInfo;
+
+struct __BlkMapTblCachePool_t BlkMapTblCachePool;
+struct __PageMapTblCachePool_t PageMapTblCachePool;
+
+void dump(void *buf, __u32 len , __u8 nbyte,__u8 linelen)
+{
+	__u32 i;
+	__u32 tmplen = len/nbyte;
+
+	PRINT("/********************************************/\n");
+
+	for (i = 0; i < tmplen; i++)
+	{
+		if (nbyte == 1)
+			PRINT("%x  ",((__u8 *)buf)[i]);
+		else if (nbyte == 2)
+			PRINT("%x  ",((__u16 *)buf)[i]);
+		else if (nbyte == 4)
+			PRINT("%x  ",((__u32 *)buf)[i]);
+		else
+			break;
+
+		if(i%linelen == (linelen - 1))
+			PRINT("\n");
+	}
+
+	return;
+
+}
+
+/*
+************************************************************************************************************************
+*                       CALCULATE THE CHECKSUM FOR A MAPPING TABLE
+*
+*Description: Calculate the checksum for a mapping table, based on word.
+*
+*Arguments  : pTblBuf   the pointer to the table data buffer;
+*             nLength   the size of the table data, based on word.
+*
+*Return     : table checksum;
+************************************************************************************************************************
+*/
+static __u32 _GetTblCheckSum(__u32 *pTblBuf, __u32 nLength)
+{
+    __u32   i;
+    __u32   tmpCheckSum = 0;
+
+    for(i= 0; i<nLength; i++)
+    {
+        tmpCheckSum += pTblBuf[i];
+    }
+
+    return tmpCheckSum;
+}
+
+
+/*
+************************************************************************************************************************
+*                       INIT PAGE MAPPING TABLE CACHE
+*
+*Description: Init page mapping table cache.
+*
+*Arguments  : none.
+*
+*Return     : init result;
+*               = 0         init page mapping table cache successful;
+*               = -1        init page mapping table cache failed.
+************************************************************************************************************************
+*/
+__s32 PMM_InitMapTblCache(void)
+{
+    __u32   i;
+
+    PAGE_MAP_CACHE_POOL = &PageMapTblCachePool;
+
+    for(i = 0; i<PAGE_MAP_TBL_CACHE_CNT; i++)
+    {
+        PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].AccessCnt = 0;
+        PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].DirtyFlag = 0;
+        PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].LogBlkPst = 0xff;
+        PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].ZoneNum = 0xff;
+        PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].PageMapTbl = \
+                (void *)MALLOC(PAGE_CNT_OF_SUPER_BLK * sizeof(struct __PageMapTblItem_t));
+        if (!PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].PageMapTbl)
+        {
+            return  -ERR_MAPPING;
+        }
+    }
+
+    return NAND_OP_TRUE;
+}
+
+
+/*
+************************************************************************************************************************
+*                      CALCUALTE PAGE MAPPING TABLE ACCESS COUNT
+*
+*Description: Calculate page mapping table access count for table cache switch.
+*
+*Arguments  : none.
+*
+*Return     : none.
+************************************************************************************************************************
+*/
+static void _CalPageTblAccessCount(void)
+{
+    __u32   i;
+
+    for(i=0; i<PAGE_MAP_TBL_CACHE_CNT; i++)
+    {
+        PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].AccessCnt++;
+    }
+
+    PAGE_MAP_CACHE->AccessCnt = 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       EXIT PAGE MAPPING TABLE CACHE
+*
+*Description: Exit page mapping table cache.
+*
+*Arguments  : none.
+*
+*Return     : exit result;
+*               = 0         exit page mapping table cache successful;
+*               = -1        exit page mapping table cache failed.
+************************************************************************************************************************
+*/
+__s32 PMM_ExitMapTblCache(void)
+{
+    __u32   i;
+
+    for (i = 0; i<PAGE_MAP_TBL_CACHE_CNT; i++)
+    {
+        FREE(PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].PageMapTbl,PAGE_CNT_OF_SUPER_BLK * sizeof(struct __PageMapTblItem_t));
+    }
+
+    return NAND_OP_TRUE;
+}
+
+
+/*the page map table in the cahce pool? cahce hit?*/
+static __s32 _page_map_tbl_cache_hit(__u32 nLogBlkPst)
+{
+    __u32 i;
+
+    for(i=0; i<PAGE_MAP_TBL_CACHE_CNT; i++)
+    {
+        if((PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].ZoneNum == CUR_MAP_ZONE)\
+            && (PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].LogBlkPst == nLogBlkPst))
+        {
+
+            PAGE_MAP_CACHE = &(PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i]);
+            return NAND_OP_TRUE;
+        }
+    }
+
+    return NAND_OP_FALSE;
+
+}
+
+/*find post cache, clear cache or LRU cache */
+static __u32 _find_page_tbl_post_location(void)
+{
+    __u32   i, location = 0;
+    __u16   access_cnt;
+
+    /*try to find clear cache*/
+    for(i=0; i<PAGE_MAP_TBL_CACHE_CNT; i++)
+    {
+        if(PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].ZoneNum == 0xff)
+        {
+            return i;
+        }
+    }
+
+    /*try to find least used cache recently*/
+    access_cnt = PAGE_MAP_CACHE_POOL->PageMapTblCachePool[0].AccessCnt;
+
+    for (i = 1; i < PAGE_MAP_TBL_CACHE_CNT; i++){
+        if (access_cnt < PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].AccessCnt){
+            location = i;
+            access_cnt = PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].AccessCnt;
+        }
+    }
+
+    /*clear access counter*/
+    for (i = 0; i < PAGE_MAP_TBL_CACHE_CNT; i++)
+        PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].AccessCnt = 0;
+
+    return location;
+
+}
+
+static __s32 _write_back_page_map_tbl(__u32 nLogBlkPst)
+{
+    __u16 TablePage;
+    __u32 TableBlk;
+    struct  __NandUserData_t  UserData[2];
+    struct  __PhysicOpPara_t  param;
+    struct  __SuperPhyBlkType_t BadBlk,NewBlk;
+
+
+    /*check page poisition, merge if no free page*/
+    TablePage = LOG_BLK_TBL[nLogBlkPst].LastUsedPage + 1;
+    TableBlk = LOG_BLK_TBL[nLogBlkPst].PhyBlk.PhyBlkNum;
+    if (TablePage == PAGE_CNT_OF_SUPER_BLK){
+        /*block id full,need merge*/
+        if (LML_MergeLogBlk(SPECIAL_MERGE_MODE,LOG_BLK_TBL[nLogBlkPst].LogicBlkNum)){
+            MAPPING_ERR("write back page tbl : merge err\n");
+            return NAND_OP_FALSE;
+        }
+
+        if (PAGE_MAP_CACHE->ZoneNum != 0xff){
+            /*move merge*/
+            TablePage = LOG_BLK_TBL[nLogBlkPst].LastUsedPage + 1;
+            TableBlk = LOG_BLK_TBL[nLogBlkPst].PhyBlk.PhyBlkNum;
+        }
+        else
+            return NAND_OP_TRUE;
+    }
+
+rewrite:
+//PRINT("-------------------write back page tbl for blk %x\n",TableBlk);
+    /*write page map table*/
+    MEMSET((void *)&UserData,0xff,sizeof(struct __NandUserData_t) * 2);
+    UserData[0].PageStatus = 0xaa;
+    MEMSET(LML_PROCESS_TBL_BUF,0xff,SECTOR_CNT_OF_SUPER_PAGE * SECTOR_SIZE);
+
+	if(PAGE_CNT_OF_SUPER_BLK >= 512)
+	{
+		__u32 page;
+
+		for(page = 0; page < PAGE_CNT_OF_SUPER_BLK; page++)
+			*((__u16 *)LML_PROCESS_TBL_BUF + page) = PAGE_MAP_TBL[page].PhyPageNum;
+
+		((__u32 *)LML_PROCESS_TBL_BUF)[511] = \
+        	_GetTblCheckSum((__u32 *)LML_PROCESS_TBL_BUF, PAGE_CNT_OF_SUPER_BLK*2/(sizeof (__u32)));
+	}
+
+	else
+	{
+		MEMCPY(LML_PROCESS_TBL_BUF, PAGE_MAP_TBL,PAGE_CNT_OF_SUPER_BLK*sizeof(struct __PageMapTblItem_t));
+    	((__u32 *)LML_PROCESS_TBL_BUF)[511] = \
+        	_GetTblCheckSum((__u32 *)LML_PROCESS_TBL_BUF, PAGE_CNT_OF_SUPER_BLK*sizeof(struct __PageMapTblItem_t)/(sizeof (__u32)));
+	}
+
+    param.MDataPtr = LML_PROCESS_TBL_BUF;
+    param.SDataPtr = (void *)&UserData;
+    param.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+
+//rewrite:
+    LML_CalculatePhyOpPar(&param, CUR_MAP_ZONE, TableBlk, TablePage);
+    LML_VirtualPageWrite(&param);
+    if (NAND_OP_TRUE != PHY_SynchBank(param.BankNum, SYNC_CHIP_MODE)){
+        BadBlk.PhyBlkNum = TableBlk;
+        if (NAND_OP_TRUE != LML_BadBlkManage(&BadBlk,CUR_MAP_ZONE,TablePage,&NewBlk)){
+            MAPPING_ERR("write page map table : bad block mange err after write\n");
+            return NAND_OP_FALSE;
+        }
+        TableBlk = NewBlk.PhyBlkNum;
+        LOG_BLK_TBL[nLogBlkPst].PhyBlk = NewBlk;
+        goto rewrite;
+    }
+
+    LOG_BLK_TBL[nLogBlkPst].LastUsedPage = TablePage;
+    PAGE_MAP_CACHE->ZoneNum = 0xff;
+    PAGE_MAP_CACHE->LogBlkPst = 0xff;
+
+    return NAND_OP_TRUE;
+
+}
+
+static __s32 _rebuild_page_map_tbl(__u32 nLogBlkPst)
+{
+    __s32 ret;
+    __u16 TablePage;
+    __u32 TableBlk;
+    __u16 logicpagenum;
+    //__u8  status;
+    struct  __NandUserData_t  UserData[2];
+    struct  __PhysicOpPara_t  param;
+
+    MEMSET(PAGE_MAP_TBL,0xff, PAGE_CNT_OF_SUPER_BLK*sizeof(struct __PageMapTblItem_t));
+    TableBlk = LOG_BLK_TBL[nLogBlkPst].PhyBlk.PhyBlkNum;
+
+    param.MDataPtr = LML_PROCESS_TBL_BUF;
+    param.SDataPtr = (void *)&UserData;
+    param.SectBitmap = 0x3;
+
+	//PRINT("-----------------------rebuild page table for blk %x\n",TableBlk);
+
+    for(TablePage = 0; TablePage < PAGE_CNT_OF_SUPER_BLK; TablePage++){
+        LML_CalculatePhyOpPar(&param, CUR_MAP_ZONE, TableBlk, TablePage);
+        ret = LML_VirtualPageRead(&param);
+        if (ret < 0){
+            MAPPING_ERR("rebuild logic block %x page map table : read err\n",LOG_BLK_TBL[nLogBlkPst].LogicBlkNum);
+            return NAND_OP_FALSE;
+        }
+
+        //status = UserData[0].PageStatus;
+        logicpagenum = UserData[0].LogicPageNum;
+
+        //if(((!TablePage || (status == 0x55))) && (logicpagenum != 0xffff) && (logicpagenum < PAGE_CNT_OF_SUPER_BLK)) /*legal page*/
+		if((logicpagenum != 0xffff) && (logicpagenum < PAGE_CNT_OF_SUPER_BLK)) /*legal page*/
+		{
+            PAGE_MAP_TBL[logicpagenum].PhyPageNum = TablePage; /*l2p:logical to physical*/
+        }
+    }
+
+    PAGE_MAP_CACHE->DirtyFlag = 1;
+	BMM_SetDirtyFlag();
+
+	return NAND_OP_TRUE;
+}
+
+static __s32 _read_page_map_tbl(__u32 nLogBlkPst)
+{
+    __s32 ret;
+    __u16 TablePage;
+    __u32 TableBlk, checksum;
+    __u16 logicpagenum;
+    __u8  status;
+    struct  __NandUserData_t  UserData[2];
+    struct  __PhysicOpPara_t  param;
+
+
+    /*check page poisition, merge if no free page*/
+    TablePage = LOG_BLK_TBL[nLogBlkPst].LastUsedPage;
+    TableBlk = LOG_BLK_TBL[nLogBlkPst].PhyBlk.PhyBlkNum;
+
+    if (TablePage == 0xffff){
+        /*log block is empty*/
+        MEMSET(PAGE_MAP_TBL, 0xff,PAGE_CNT_OF_SUPER_BLK*sizeof(struct __PageMapTblItem_t) );
+        return NAND_OP_TRUE;
+    }
+
+    /*read page map table*/
+    param.MDataPtr = LML_PROCESS_TBL_BUF;
+    param.SDataPtr = (void *)&UserData;
+    param.SectBitmap = 0xf;
+
+    LML_CalculatePhyOpPar(&param, CUR_MAP_ZONE, TableBlk, TablePage);
+    ret = LML_VirtualPageRead(&param);
+
+	if(PAGE_CNT_OF_SUPER_BLK >= 512)
+	{
+		checksum = _GetTblCheckSum((__u32 *)LML_PROCESS_TBL_BUF,  \
+                	PAGE_CNT_OF_SUPER_BLK*2/sizeof(__u32));
+	}
+	else
+	{
+		checksum = _GetTblCheckSum((__u32 *)LML_PROCESS_TBL_BUF,  \
+                	PAGE_CNT_OF_SUPER_BLK*sizeof(struct __PageMapTblItem_t)/sizeof(__u32));
+	}
+
+    status = UserData[0].PageStatus;
+    logicpagenum = UserData[0].LogicPageNum;
+
+    if((ret < 0) || (status != 0xaa) || (logicpagenum != 0xffff) || (checksum != ((__u32 *)LML_PROCESS_TBL_BUF)[511]))
+    {
+        if(NAND_OP_TRUE != _rebuild_page_map_tbl(nLogBlkPst))
+        {
+            MAPPING_ERR("rebuild page map table err\n");
+            return NAND_OP_FALSE;
+        }
+    }
+    else
+    {
+    	if(PAGE_CNT_OF_SUPER_BLK >= 512)
+    	{
+			__u32 page;
+
+			for(page = 0; page < PAGE_CNT_OF_SUPER_BLK; page++)
+				PAGE_MAP_TBL[page].PhyPageNum = *((__u16 *)LML_PROCESS_TBL_BUF + page);
+		}
+		else
+        	MEMCPY(PAGE_MAP_TBL,LML_PROCESS_TBL_BUF, PAGE_CNT_OF_SUPER_BLK*sizeof(struct __PageMapTblItem_t));
+    }
+
+    return NAND_OP_TRUE;
+}
+
+
+/*post current zone map table in cache*/
+static __s32 _page_map_tbl_cache_post(__u32 nLogBlkPst)
+{
+    __u8 poisition;
+    __u8 i;
+
+    struct __BlkMapTblCache_t *TmpBmt = BLK_MAP_CACHE;
+
+    /*find the cache to be post*/
+    poisition = _find_page_tbl_post_location();
+    PAGE_MAP_CACHE = &(PAGE_MAP_CACHE_POOL->PageMapTblCachePool[poisition]);
+
+    if (PAGE_MAP_CACHE->DirtyFlag && (PAGE_MAP_CACHE->ZoneNum != 0xff)){
+    /*write back page  map table*/
+        if (PAGE_MAP_CACHE->ZoneNum != TmpBmt->ZoneNum){
+            for (i = 0; i < BLOCK_MAP_TBL_CACHE_CNT; i++)
+            {
+                if (BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].ZoneNum == PAGE_MAP_CACHE->ZoneNum){
+                    BLK_MAP_CACHE = &(BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i]);
+                    break;
+                }
+            }
+
+            if (i == BLOCK_MAP_TBL_CACHE_CNT){
+                MAPPING_ERR("_page_map_tbl_cache_post : position %d ,page map zone %d,blk map zone %d\n",
+							poisition,PAGE_MAP_CACHE->ZoneNum,BLK_MAP_CACHE->ZoneNum);
+                return NAND_OP_FALSE;
+            }
+
+        }
+        /* write back new table in flash if dirty*/
+		BMM_SetDirtyFlag();
+        if (NAND_OP_TRUE != _write_back_page_map_tbl(PAGE_MAP_CACHE->LogBlkPst)){
+            MAPPING_ERR("write back page tbl err\n");
+            return NAND_OP_FALSE;
+        }
+
+        BLK_MAP_CACHE = TmpBmt;
+
+    }
+
+    PAGE_MAP_CACHE->DirtyFlag = 0;
+
+    /*fetch current page map table*/
+    if (NAND_OP_TRUE != _read_page_map_tbl(nLogBlkPst)){
+        MAPPING_ERR("read page map tbl err\n");
+        return NAND_OP_FALSE;
+    }
+
+    PAGE_MAP_CACHE->ZoneNum = CUR_MAP_ZONE;
+    PAGE_MAP_CACHE->LogBlkPst = nLogBlkPst;
+
+    return NAND_OP_TRUE;
+}
+
+/*
+************************************************************************************************************************
+*                      SWITCH PAGE MAPPING TABLE
+*
+*Description: Switch page mapping table cache.
+*
+*Arguments  : nLogBlkPst    the position of the log block in the log block table.
+*
+*Return     : switch result;
+*               = 0     switch table successful;
+*               = -1    switch table failed.
+************************************************************************************************************************
+*/
+__s32 PMM_SwitchMapTbl(__u32 nLogBlkPst)
+{
+    __s32   result = NAND_OP_TRUE;
+    if (NAND_OP_TRUE !=_page_map_tbl_cache_hit(nLogBlkPst))
+    {
+        result = (_page_map_tbl_cache_post(nLogBlkPst));
+    }
+
+    _CalPageTblAccessCount();
+
+    return result;
+}
+
+
+/*
+************************************************************************************************************************
+*                       INIT BLOCK MAPPING TABLE CACHE
+*
+*Description: Initiate block mapping talbe cache.
+*
+*Arguments  : none.
+*
+*Return     : init result;
+*               = 0     init successful;
+*               = -1    init failed.
+************************************************************************************************************************
+*/
+__s32 BMM_InitMapTblCache(void)
+{
+    __u32 i;
+
+    BLK_MAP_CACHE_POOL = &BlkMapTblCachePool;
+
+    BLK_MAP_CACHE_POOL->LogBlkAccessTimer = 0x0;
+    BLK_MAP_CACHE_POOL->SuperBlkEraseCnt = 0x0;
+
+    /*init block map table cache*/
+    for(i=0; i<BLOCK_MAP_TBL_CACHE_CNT; i++)
+    {
+        //init the parmater for block mapping table cache management
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].ZoneNum = 0xff;
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].DirtyFlag = 0x0;
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].AccessCnt = 0x0;
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].LastFreeBlkPst = 0xff;
+
+        //request buffer for data block table and free block table
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].DataBlkTbl = \
+                    (struct __SuperPhyBlkType_t *)MALLOC(sizeof(struct __SuperPhyBlkType_t)*BLOCK_CNT_OF_ZONE);
+        if(NULL == BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].DataBlkTbl)
+        {
+            MAPPING_ERR("BMM_InitMapTblCache : allocate memory err\n");
+            return -ERR_MALLOC;
+        }
+        //set free block table pointer
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].FreeBlkTbl = \
+                    BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].DataBlkTbl + DATA_BLK_CNT_OF_ZONE;
+
+        //request buffer for log block table
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].LogBlkTbl =  \
+                    (struct __LogBlkType_t *)MALLOC(sizeof(struct __LogBlkType_t)*LOG_BLK_CNT_OF_ZONE);
+        if(NULL == BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].LogBlkTbl)
+        {
+            MAPPING_ERR("BMM_InitMapTblCache : allocate memory err\n");
+            FREE(BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].DataBlkTbl,sizeof(struct __SuperPhyBlkType_t)*BLOCK_CNT_OF_ZONE);
+            return -ERR_MALLOC;
+        }
+    }
+
+    /*init log block access time*/
+    MEMSET(BLK_MAP_CACHE_POOL->LogBlkAccessAge, 0x0, MAX_LOG_BLK_CNT);
+
+    return NAND_OP_TRUE;
+}
+
+
+/*
+************************************************************************************************************************
+*                       CALCULATE BLOCK MAPPING TABLE ACCESS COUNT
+*
+*Description: Calculate block mapping table access count for cache switch.
+*
+*Arguments  : none.
+*
+*Return     : none;
+************************************************************************************************************************
+*/
+static void _CalBlkTblAccessCount(void)
+{
+    __u32   i;
+
+    for (i=0; i<BLOCK_MAP_TBL_CACHE_CNT; i++)
+    {
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].AccessCnt++;
+    }
+
+    BLK_MAP_CACHE->AccessCnt = 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       BLOCK MAPPING TABLE CACHE EXIT
+*
+*Description: exit block mapping table cache.
+*
+*Arguments  : none.
+*
+*Return     : exit result;
+*               = 0     exit successful;
+*               = -1    exit failed.
+************************************************************************************************************************
+*/
+__s32 BMM_ExitMapTblCache(void)
+{
+    __u32 i;
+
+    for (i=0; i<BLOCK_MAP_TBL_CACHE_CNT; i++)
+    {
+
+        FREE(BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].DataBlkTbl,sizeof(struct __SuperPhyBlkType_t)*BLOCK_CNT_OF_ZONE);
+        FREE(BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].LogBlkTbl,sizeof(struct __LogBlkType_t)*LOG_BLK_CNT_OF_ZONE);
+    }
+
+    return NAND_OP_TRUE;
+}
+
+/*the zone table in the cahce pool? cahce hit?*/
+static __s32 _blk_map_tbl_cache_hit(__u32 nZone)
+{
+    __u32 i;
+
+    for (i = 0; i < BLOCK_MAP_TBL_CACHE_CNT; i++){
+        if (BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].ZoneNum == nZone){
+            BLK_MAP_CACHE = &(BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i]);
+            return NAND_OP_TRUE;
+        }
+    }
+
+    return NAND_OP_FALSE;
+
+}
+
+/*find post cache, clear cache or LRU cache */
+static __u32 _find_blk_tbl_post_location(void)
+{
+    __u32 i;
+    __u8 location;
+    __u16 access_cnt ;
+
+    /*try to find clear cache*/
+    for (i = 0; i < BLOCK_MAP_TBL_CACHE_CNT; i++)
+    {
+        if (BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].ZoneNum == 0xff)
+            return i;
+    }
+    /*try to find least used cache recently*/
+    location = 0;
+    access_cnt = BLK_MAP_CACHE_POOL->BlkMapTblCachePool[0].AccessCnt;
+
+    for (i = 1; i < BLOCK_MAP_TBL_CACHE_CNT; i++){
+        if (access_cnt < BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].AccessCnt){
+            location = i;
+            access_cnt = BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].AccessCnt;
+        }
+    }
+
+    /*clear access counter*/
+    for (i = 0; i < BLOCK_MAP_TBL_CACHE_CNT; i++)
+        BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].AccessCnt = 0;
+
+    return location;
+
+}
+
+static __s32 _write_back_all_page_map_tbl(__u8 nZone)
+{
+    __u32 i;
+
+    for(i=0; i<PAGE_MAP_TBL_CACHE_CNT; i++)
+    {
+        if((PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].ZoneNum == nZone)\
+            && (PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i].DirtyFlag == 1))
+        {
+            PAGE_MAP_CACHE = &(PAGE_MAP_CACHE_POOL->PageMapTblCachePool[i]);
+            if (NAND_OP_TRUE != _write_back_page_map_tbl(PAGE_MAP_CACHE->LogBlkPst))
+            {
+                MAPPING_ERR("write back all page tbl : write page map table err \n");
+                return NAND_OP_FALSE;
+            }
+            PAGE_MAP_CACHE->DirtyFlag = 0;
+        }
+    }
+
+    return NAND_OP_TRUE;
+}
+
+
+
+/*write block map table to flash*/
+static __s32 _write_back_block_map_tbl(__u8 nZone)
+{
+    __s32 TablePage;
+    __u32 TableBlk;
+    struct  __NandUserData_t  UserData[2];
+    struct  __PhysicOpPara_t  param;
+    struct __SuperPhyBlkType_t BadBlk,NewBlk;
+
+    /*write back all page map table within this zone*/
+    if (NAND_OP_TRUE != _write_back_all_page_map_tbl(nZone)){
+        MAPPING_ERR("write back all page map tbl err\n");
+        return NAND_OP_FALSE;
+    }
+
+    /*set table block number and table page number*/
+    TableBlk = NandDriverInfo.ZoneTblPstInfo[nZone].PhyBlkNum;
+    TablePage = NandDriverInfo.ZoneTblPstInfo[nZone].TablePst;
+    if(TablePage >= PAGE_CNT_OF_SUPER_BLK - 4)
+    {
+        if(NAND_OP_TRUE != LML_VirtualBlkErase(nZone, TableBlk))
+        {
+            BadBlk.PhyBlkNum = TableBlk;
+
+            if(NAND_OP_TRUE != LML_BadBlkManage(&BadBlk,CUR_MAP_ZONE,0,&NewBlk))
+            {
+                MAPPING_ERR("write back block tbl : bad block manage err erase data block\n");
+                return NAND_OP_FALSE;
+            }
+
+            TableBlk = NewBlk.PhyBlkNum;
+        }
+        TablePage = -4;
+    }
+
+    TablePage += 4;
+
+    //calculate checksum for data block table and free block table
+    ((__u32 *)DATA_BLK_TBL)[1023] = \
+        _GetTblCheckSum((__u32 *)DATA_BLK_TBL, (DATA_BLK_CNT_OF_ZONE + FREE_BLK_CNT_OF_ZONE));
+    //clear full page data
+    MEMSET(LML_PROCESS_TBL_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * SECTOR_SIZE);
+
+rewrite:
+    /*write back data block and free block map table*/
+    MEMSET((void *)&UserData,0xff,sizeof(struct __NandUserData_t) * 2);
+    MEMCPY(LML_PROCESS_TBL_BUF,DATA_BLK_TBL,2048);
+    /*write page 0, need set spare info*/
+    if (TablePage == 0)
+    {
+        UserData[0].LogicInfo = (1<<14) | ((nZone % ZONE_CNT_OF_DIE) << 10) | 0xaa ;
+    }
+    UserData[0].PageStatus = 0x55;
+    param.MDataPtr = LML_PROCESS_TBL_BUF;
+    param.SDataPtr = (void *)&UserData;
+    param.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+    LML_CalculatePhyOpPar(&param, nZone, TableBlk, TablePage);
+    LML_VirtualPageWrite(&param);
+    if (NAND_OP_TRUE !=  PHY_SynchBank(param.BankNum, SYNC_CHIP_MODE)){
+        BadBlk.PhyBlkNum = TableBlk;
+        if (NAND_OP_TRUE != LML_BadBlkManage(&BadBlk,nZone,0,&NewBlk)){
+            MAPPING_ERR("write blk map table : bad block mange err after write\n");
+            return NAND_OP_FALSE;
+        }
+        TableBlk = NewBlk.PhyBlkNum;
+        TablePage = 0;
+        goto rewrite;
+    }
+
+    MEMCPY(LML_PROCESS_TBL_BUF, &DATA_BLK_TBL[512], 2048);
+    TablePage ++;
+    param.MDataPtr = LML_PROCESS_TBL_BUF;
+    MEMSET((void *)&UserData,0xff,sizeof(struct __NandUserData_t) * 2);
+    UserData[0].PageStatus = 0x55;
+    LML_CalculatePhyOpPar(&param, nZone, TableBlk, TablePage);
+    LML_VirtualPageWrite(&param);
+    if(NAND_OP_TRUE != PHY_SynchBank(param.BankNum, SYNC_CHIP_MODE))
+    {
+        BadBlk.PhyBlkNum = TableBlk;
+        if(NAND_OP_TRUE != LML_BadBlkManage(&BadBlk,nZone,0,&NewBlk))
+        {
+            MAPPING_ERR("write blk map table : bad block mange err after write\n");
+            return NAND_OP_FALSE;
+        }
+        TableBlk = NewBlk.PhyBlkNum;
+        TablePage = 0;
+        goto rewrite;
+    }
+
+
+    /*write back log block map table*/
+    TablePage++;
+    MEMSET(LML_PROCESS_TBL_BUF, 0xff, SECTOR_CNT_OF_SUPER_PAGE * SECTOR_SIZE);
+    MEMCPY(LML_PROCESS_TBL_BUF,LOG_BLK_TBL,LOG_BLK_CNT_OF_ZONE*sizeof(struct __LogBlkType_t));
+    /*cal checksum*/
+    ((__u32 *)LML_PROCESS_TBL_BUF)[511] = \
+        _GetTblCheckSum((__u32 *)LML_PROCESS_TBL_BUF, LOG_BLK_CNT_OF_ZONE*sizeof(struct __LogBlkType_t)/sizeof(__u32));
+    LML_CalculatePhyOpPar(&param, nZone, TableBlk, TablePage);
+    LML_VirtualPageWrite(&param);
+    if(NAND_OP_TRUE !=  PHY_SynchBank(param.BankNum, SYNC_CHIP_MODE))
+    {
+        BadBlk.PhyBlkNum = TableBlk;
+        if(NAND_OP_TRUE != LML_BadBlkManage(&BadBlk,nZone,0,&NewBlk))
+        {
+            MAPPING_ERR("write blk map table : bad block mange err after write\n");
+            return NAND_OP_FALSE;
+        }
+        TableBlk = NewBlk.PhyBlkNum;
+        TablePage = 0;
+        goto rewrite;
+    }
+
+    /*reset zone info*/
+    NandDriverInfo.ZoneTblPstInfo[nZone].PhyBlkNum = TableBlk;
+    NandDriverInfo.ZoneTblPstInfo[nZone].TablePst = TablePage - 2;
+
+    return NAND_OP_TRUE;
+}
+
+/* fetch block map table from flash */
+static __s32 _read_block_map_tbl(__u8 nZone)
+{
+    __s32 TablePage;
+    __u32 TableBlk;
+    struct  __PhysicOpPara_t  param;
+
+    /*set table block number and table page number*/
+    TableBlk = NandDriverInfo.ZoneTblPstInfo[nZone].PhyBlkNum;
+    TablePage = NandDriverInfo.ZoneTblPstInfo[nZone].TablePst;
+
+    /*read data block and free block map tbl*/
+
+	param.MDataPtr = LML_PROCESS_TBL_BUF;
+    param.SDataPtr = NULL;
+    param.SectBitmap = 0xf;
+    LML_CalculatePhyOpPar(&param, nZone, TableBlk, TablePage);
+    if(LML_VirtualPageRead(&param) < 0)
+    {
+        MAPPING_ERR("_read_block_map_tbl :read block map table0 err\n");
+        return NAND_OP_FALSE;
+    }
+
+    MEMCPY(DATA_BLK_TBL,LML_PROCESS_TBL_BUF,2048);
+
+    TablePage++;
+    param.MDataPtr = LML_PROCESS_TBL_BUF;
+    LML_CalculatePhyOpPar(&param, nZone, TableBlk, TablePage);
+    if( LML_VirtualPageRead(&param) < 0)
+    {
+        MAPPING_ERR("_read_block_map_tbl : read block map table1 err\n");
+        return NAND_OP_FALSE;
+    }
+
+    MEMCPY(&DATA_BLK_TBL[512],LML_PROCESS_TBL_BUF,2048);
+    if(((__u32 *)DATA_BLK_TBL)[1023] != \
+        _GetTblCheckSum((__u32 *)DATA_BLK_TBL,(DATA_BLK_CNT_OF_ZONE+FREE_BLK_CNT_OF_ZONE)))
+    {
+    	MAPPING_ERR("_read_block_map_tbl : read data block map table checksum err\n");
+		dump((void*)DATA_BLK_TBL,1024*4,4,8);
+		return NAND_OP_FALSE;
+    }
+
+    /*read log block table*/
+    TablePage++;
+    param.MDataPtr = LML_PROCESS_TBL_BUF;
+    LML_CalculatePhyOpPar(&param, nZone, TableBlk, TablePage);
+    if ( LML_VirtualPageRead(&param) < 0){
+        MAPPING_ERR("_read_block_map_tbl : read block map table2 err\n");
+        return NAND_OP_FALSE;
+    }
+    if (((__u32 *)LML_PROCESS_TBL_BUF)[511] != \
+        _GetTblCheckSum((__u32 *)LML_PROCESS_TBL_BUF, LOG_BLK_CNT_OF_ZONE*sizeof(struct __LogBlkType_t)/sizeof(__u32)))
+    {
+    	MAPPING_ERR("_read_block_map_tbl : read log block table checksum err\n");
+		dump((void*)LML_PROCESS_TBL_BUF,512*8,2,8);
+        return NAND_OP_FALSE;
+    }
+    MEMCPY(LOG_BLK_TBL,LML_PROCESS_TBL_BUF,LOG_BLK_CNT_OF_ZONE*sizeof(struct __LogBlkType_t));
+
+    return NAND_OP_TRUE;
+}
+
+/*post current zone map table in cache*/
+static __s32 _blk_map_tbl_cache_post(__u32 nZone)
+{
+    __u8 poisition;
+
+    /*find the cache to be post*/
+    poisition = _find_blk_tbl_post_location();
+    BLK_MAP_CACHE = &(BLK_MAP_CACHE_POOL->BlkMapTblCachePool[poisition]);
+
+    /* write back new table in flash if dirty*/
+    if (BLK_MAP_CACHE->DirtyFlag){
+        if (NAND_OP_TRUE != _write_back_block_map_tbl(CUR_MAP_ZONE)){
+            MAPPING_ERR("_blk_map_tbl_cache_post : write back zone tbl err\n");
+            return NAND_OP_FALSE;
+        }
+    }
+
+    /*fetch current zone map table*/
+    if (NAND_OP_TRUE != _read_block_map_tbl(nZone)){
+        MAPPING_ERR("_blk_map_tbl_cache_post : read zone tbl err\n");
+            return NAND_OP_FALSE;
+    }
+    CUR_MAP_ZONE = nZone;
+    BLK_MAP_CACHE->DirtyFlag = 0;
+
+    return NAND_OP_TRUE;
+}
+
+/*
+************************************************************************************************************************
+*                       SWITCH BLOCK MAPPING TABLE
+*
+*Description: Switch block mapping table.
+*
+*Arguments  : nZone     zone number which block mapping table need be accessed.
+*
+*Return     : switch result;
+*               = 0     switch successful;
+*               = -1    switch failed.
+************************************************************************************************************************
+*/
+__s32 BMM_SwitchMapTbl(__u32 nZone)
+{
+    __s32   result = NAND_OP_TRUE;
+
+    if(NAND_OP_TRUE != _blk_map_tbl_cache_hit(nZone))
+    {
+        MAPPING_DBG("BMM_SwitchMapTbl : post zone %d cache\n",nZone);
+		result = (_blk_map_tbl_cache_post(nZone));
+    }
+
+    _CalBlkTblAccessCount();
+
+    return result;
+}
+
+
+/*
+************************************************************************************************************************
+*                           WRITE BACK ALL MAPPING TABLE
+*
+*Description: Write back all mapping table.
+*
+*Arguments  : none.
+*
+*Return     : write table result;
+*               = 0     write successful;
+*               = -1    write failed.
+************************************************************************************************************************
+*/
+__s32 BMM_WriteBackAllMapTbl(void)
+{
+     __u8 i;
+
+        /*save current scene*/
+        struct __BlkMapTblCache_t *TmpBmt = BLK_MAP_CACHE;
+        struct __PageMapTblCache_t *TmpPmt = PAGE_MAP_CACHE;
+
+        for (i = 0; i < BLOCK_MAP_TBL_CACHE_CNT; i++)
+        {
+            if (BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i].DirtyFlag){
+                   BLK_MAP_CACHE = &(BLK_MAP_CACHE_POOL->BlkMapTblCachePool[i]);
+                   if (NAND_OP_TRUE != _write_back_block_map_tbl(CUR_MAP_ZONE))
+                        return NAND_OP_FALSE;
+                    BLK_MAP_CACHE->DirtyFlag = 0;
+            }
+       }
+
+        /*resore current scene*/
+        BLK_MAP_CACHE  = TmpBmt;
+        PAGE_MAP_CACHE = TmpPmt;
+
+        return NAND_OP_TRUE;
+}
+
+static __s32 _write_dirty_flag(__u8 nZone)
+{
+    __s32 TablePage;
+    __u32 TableBlk;
+    struct  __PhysicOpPara_t  param;
+    struct  __NandUserData_t  UserData[2];
+
+    /*set table block number and table page number*/
+    TableBlk = NandDriverInfo.ZoneTblPstInfo[nZone].PhyBlkNum;
+    TablePage = NandDriverInfo.ZoneTblPstInfo[nZone].TablePst;
+
+    TablePage += 3;
+    MEMSET((void *)&UserData,0xff,sizeof(struct __NandUserData_t) * 2);
+    UserData[0].PageStatus = 0x55;
+    MEMSET(LML_PROCESS_TBL_BUF,0x55,512);
+    param.MDataPtr = LML_PROCESS_TBL_BUF;
+    param.SDataPtr = (void *)&UserData;
+
+    LML_CalculatePhyOpPar(&param, nZone, TableBlk, TablePage);
+    LML_VirtualPageWrite(&param);
+    PHY_SynchBank(param.BankNum, SYNC_CHIP_MODE);
+
+    return NAND_OP_TRUE;
+
+}
+
+
+/*
+************************************************************************************************************************
+*                       SET DIRTY FLAG FOR BLOCK MAPPING TABLE
+*
+*Description: Set dirty flag for block mapping table.
+*
+*Arguments  : none.
+*
+*Return     : set dirty flag result;
+*               = 0     set dirty flag successful;
+*               = -1    set dirty flag failed.
+************************************************************************************************************************
+*/
+__s32 BMM_SetDirtyFlag(void)
+{
+    if (0 == BLK_MAP_CACHE->DirtyFlag){
+       _write_dirty_flag(CUR_MAP_ZONE);
+       BLK_MAP_CACHE->DirtyFlag = 1;
+    }
+
+    return NAND_OP_TRUE;
+}
+
+
+
+
diff --git a/drivers/block/sunxi_nand/src/logic/mapping_base.c b/drivers/block/sunxi_nand/src/logic/mapping_base.c
new file mode 100644
index 0000000..09efad3
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/logic/mapping_base.c
@@ -0,0 +1,761 @@
+/*
+ * drivers/block/sunxi_nand/src/logic/mapping_base.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_logic.h"
+
+extern struct __NandDriverGlobal_t     NandDriverInfo;
+
+
+/*
+************************************************************************************************************************
+*                           CALCULATE THE ACCESS COUNT OF THE LOG BLOCK
+*
+*Description: Calculate the access count of the log block for make a rule to choose
+*             the log for merge.
+*
+*Arguments  : nLogPst   the position of the log block in the log block table.
+*
+*Return     : none.
+************************************************************************************************************************
+*/
+static void _CalLogAccessCnt(__u32 nLogPst)
+{
+    __s32   i;
+
+    if(LOG_ACCESS_TIMER == 0xffff)
+    {
+        LOG_ACCESS_TIMER = 0;
+
+        //the timer of the log block access is overflow, need clear all
+        for(i=0; i<LOG_BLK_CNT_OF_ZONE; i++)
+        {
+            LOG_ACCESS_AGE[i] = 0;
+
+        }
+    }
+
+    //increase the log access timer
+    LOG_ACCESS_TIMER++;
+
+    LOG_ACCESS_AGE[nLogPst] = LOG_ACCESS_TIMER;
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET THE PARAMETER OF DATA BLOCK
+*
+*Description: Get the parameter of the data block from the data block mapping table.
+*
+*Arguments  : nBlk      the number of the logical block whose data block need be got;
+*             pDataBlk  the pointer to the super block parameter.
+*
+*Return     : get data block result;
+*               = 0    get data block successful;
+*               =-1    get data block failed.
+************************************************************************************************************************
+*/
+__s32 BMM_GetDataBlk(__u32 nBlk, struct __SuperPhyBlkType_t *pDataBlk)
+{
+    if(nBlk > DATA_BLK_CNT_OF_ZONE)
+    {
+        MAPPING_ERR("[MAPPING_ERR] Logical block number(0x%x) is invalid when get data block!\n", nBlk);
+        pDataBlk->BlkEraseCnt = 0xffff;
+        pDataBlk->PhyBlkNum = 0xffff;
+        return -1;
+    }
+    else
+    {
+        pDataBlk->BlkEraseCnt = DATA_BLK_TBL[nBlk].BlkEraseCnt;
+        pDataBlk->PhyBlkNum = DATA_BLK_TBL[nBlk].PhyBlkNum;
+        return 0;
+    }
+}
+
+
+/*
+************************************************************************************************************************
+*                       SET THE PARAMETER OF DATA BLOCK
+*
+*Description: set the parameter of the data block to the data block mapping table.
+*
+*Arguments  : nBlk      the number of the logical block whose data block need be set;
+*             pDataBlk  the pointer to the usper block parameter.
+*
+*Return     : set data block result;
+*               = 0    set data block successful;
+*               =-1    set data block failed.
+************************************************************************************************************************
+*/
+__s32 BMM_SetDataBlk(__u32 nBlk, struct __SuperPhyBlkType_t *pDataBlk)
+{
+    if(nBlk > DATA_BLK_CNT_OF_ZONE)
+    {
+        MAPPING_ERR("[MAPPING_ERR] Logical block number(0x%x) is invalid when set data block!\n", nBlk);
+        DATA_BLK_TBL[nBlk].BlkEraseCnt = 0xffff;
+        DATA_BLK_TBL[nBlk].PhyBlkNum = 0xffff;
+
+        return -1;
+    }
+    else
+    {
+        DATA_BLK_TBL[nBlk].BlkEraseCnt = pDataBlk->BlkEraseCnt;
+        DATA_BLK_TBL[nBlk].PhyBlkNum = pDataBlk->PhyBlkNum;
+        return 0;
+    }
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET FREE BLOCK FROM FREE BLOCK TABLE
+*
+*Description: Get a free block from the free block table with highest erase counter or lowest
+*             erase counter.
+*
+*Arguments  : nType     the type of the free block which need be got;
+*             pFreeBlk  the pointer to the free block pointer for return.
+*
+*Return     : get free block result;
+*               = 0     get free block successful;
+*               =-1     get free block failed.
+************************************************************************************************************************
+*/
+__s32 BMM_GetFreeBlk(__u32 nType, struct __SuperPhyBlkType_t *pFreeBlk)
+{
+    __s32   i, tmpFreePst = -1;
+    __u16   tmpItem = LAST_FREE_BLK_PST + 1;
+    __u32   tmpEraseCnt;
+
+    if(nType == LOWEST_EC_TYPE)
+    {
+        //need look for the free block with the lowest erase count
+        tmpEraseCnt = 0xffff;
+    }
+    else
+    {
+        //need look for the free block with the highest erase count
+        tmpEraseCnt = 0x0000;
+    }
+
+    for(i=0; i<FREE_BLK_CNT_OF_ZONE; i++, tmpItem++)
+    {
+        if(tmpItem >= FREE_BLK_CNT_OF_ZONE)
+        {
+            tmpItem = 0;
+        }
+
+        if(FREE_BLK_TBL[tmpItem].PhyBlkNum != 0xffff)
+        {
+            //current free block item is valid
+            if(((nType == LOWEST_EC_TYPE) && (FREE_BLK_TBL[tmpItem].BlkEraseCnt <= tmpEraseCnt))
+                || ((nType != LOWEST_EC_TYPE) && (FREE_BLK_TBL[tmpItem].BlkEraseCnt >= tmpEraseCnt)))
+            {
+                tmpEraseCnt = FREE_BLK_TBL[tmpItem].BlkEraseCnt;
+
+                tmpFreePst = tmpItem;
+            }
+        }
+    }
+
+    if(tmpFreePst < 0)
+    {
+        MAPPING_ERR("[MAPPING_ERR] There is none free block in the free block table!\n");
+        pFreeBlk->PhyBlkNum = 0xffff;
+        pFreeBlk->BlkEraseCnt = 0xffff;
+
+        return -1;
+    }
+
+    pFreeBlk->PhyBlkNum = FREE_BLK_TBL[tmpFreePst].PhyBlkNum;
+    pFreeBlk->BlkEraseCnt = FREE_BLK_TBL[tmpFreePst].BlkEraseCnt;
+    LAST_FREE_BLK_PST = tmpFreePst;
+
+    //delete the free block item from the free block table
+    FREE_BLK_TBL[tmpFreePst].PhyBlkNum = 0xffff;
+    FREE_BLK_TBL[tmpFreePst].BlkEraseCnt = 0xffff;
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       SET FREE BLOCK TO FREE BLOCK TABLE
+*
+*Description: Fill a free block to the free block table.
+*
+*Arguments  : pFreeBlk      the pointer to the free block which need be fill free block table.
+*
+*Return     : set free block result;
+*               = 0     set free block successful;
+*               =-1     set free block failed.
+************************************************************************************************************************
+*/
+__s32 BMM_SetFreeBlk(struct __SuperPhyBlkType_t *pFreeBlk)
+{
+    __s32   i;
+
+    for(i=0; i<FREE_BLK_CNT_OF_ZONE; i++)
+    {
+        //look for a empty free block item in the free block table to fill the free block
+        if(FREE_BLK_TBL[i].PhyBlkNum == 0xffff)
+        {
+            FREE_BLK_TBL[i].PhyBlkNum = pFreeBlk->PhyBlkNum;
+            FREE_BLK_TBL[i].BlkEraseCnt = pFreeBlk->BlkEraseCnt;
+
+            return 0;
+        }
+    }
+
+    return -1;
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET POSITION OF LOG BLOCK IN LOG BLOCK TABLE
+*
+*Description: Get the position of the log block in the log block table.
+*
+*Arguments  : nBlk      the logical block number which the log block is belonged to;
+*
+*Return     : Log block position;
+*               >= 0    the position of the log block in log block table.
+*               = -1    there is no such log block;
+************************************************************************************************************************
+*/
+static __s32 _GetLogBlkPst(__u32 nBlk)
+{
+    __s32   i, tmpPst = -1;
+
+    for(i=0; i<LOG_BLK_CNT_OF_ZONE; i++)
+    {
+        if(LOG_BLK_TBL[i].LogicBlkNum == nBlk)
+        {
+            tmpPst = i;
+            break;
+        }
+    }
+
+    return tmpPst;
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET PARAMETER OF LOG BLOCK
+*
+*Description: Get parameter of log block.
+*
+*Arguments  : nLogicBlk     the logical block number which the log block is belonged to;
+*             pLogBlk       the pointer to the log block item for return;
+*
+*Return     : get log block result;
+*               = 0     get log block successful;
+*               =-1     get log block failed.
+*
+*Note       : Scan the log block table which is accessing in the buffer currently,
+*             to look for the log block, if the log block is exsit, return 0,
+*             else, return -1
+************************************************************************************************************************
+*/
+__s32 BMM_GetLogBlk(__u32 nLogicBlk, struct __LogBlkType_t *pLogBlk)
+{
+    __s32   tmpLogPst;
+
+    tmpLogPst = _GetLogBlkPst(nLogicBlk);
+    if(tmpLogPst < 0)
+    {
+        //if the logic block number is invalid, report error
+        if(nLogicBlk > DATA_BLK_CNT_OF_ZONE)
+        {
+            MAPPING_ERR("[MAPPING_ERR] Logical block number(0x%x) is invalid when get log block!\n", nLogicBlk);
+        }
+
+        if(pLogBlk != NULL)
+        {
+            pLogBlk->LogicBlkNum = 0xffff;
+            pLogBlk->LastUsedPage = 0xffff;
+            pLogBlk->PhyBlk.PhyBlkNum = 0xffff;
+            pLogBlk->PhyBlk.BlkEraseCnt = 0xffff;
+        }
+
+        return -1;
+    }
+    else
+    {
+        if(pLogBlk != NULL)
+        {
+            *pLogBlk = LOG_BLK_TBL[tmpLogPst];
+        }
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                   SET LOG BLOCK PARAMETER IN THE LOG BLOCK TABLE
+*
+*Description: Set the parameter for log block in the log block table.
+*
+*Arguments  : nLogicBlk     the logical block number which the log block is belonged to;
+*             pLogBlk       the pointer to log block parameter which need be set to log block table.
+*
+*Return     : set log block result;
+*               = 0     set log block successful;
+*               < 0     set log block failed.
+************************************************************************************************************************
+*/
+__s32 BMM_SetLogBlk(__u32 nLogicBlk, struct __LogBlkType_t *pLogBlk)
+{
+    __s32   tmpLogPst;
+
+    tmpLogPst = _GetLogBlkPst(nLogicBlk);
+    if(tmpLogPst < 0)
+    {
+        tmpLogPst = _GetLogBlkPst(0xffff);
+        if(tmpLogPst < 0)
+        {
+            MAPPING_ERR("[MAPPING_ERR] Set log block table item failed!\n");
+
+            return -1;
+        }
+    }
+
+    //set the log block item in the log block table
+    LOG_BLK_TBL[tmpLogPst] = *pLogBlk;
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       CREATE A NEW LOG BLOCK
+*
+*Description: Create a new log block.
+*
+*Arguments  : nBlk      the logical block number of the log block;
+*             pLogPst   the pointer to the log block position in the log block table.
+*
+*Return     : create new log block result.
+*               = 0     create new log block successful;
+*               =-1     create new log block failed.
+************************************************************************************************************************
+*/
+static __s32 _CreateNewLogBlk(__u32 nBlk, __u32 *pLogPst)
+{
+    __s32   i, result, tmpPst=-1;
+    __u16   tmpLogAccessAge = 0xffff;
+    struct __SuperPhyBlkType_t tmpFreeBlk;
+    struct __PhysicOpPara_t tmpPhyPage;
+    struct __NandUserData_t tmpSpare[2];
+
+    #if CFG_SUPPORT_WEAR_LEVELLING
+
+    //check if need do wear-levelling
+    if(BLK_ERASE_CNTER >= WEAR_LEVELLING_FREQUENCY)
+    {
+        LML_WearLevelling();
+    }
+
+    #endif
+    //try to search an empty item in the log block table
+    for(i=0; i<LOG_BLK_CNT_OF_ZONE; i++)
+    {
+        if(LOG_BLK_TBL[i].LogicBlkNum == 0xffff)
+        {
+            //find a empty item
+            tmpPst = i;
+            break;
+        }
+    }
+
+    //there is no empty item in the log block table, need merge a log block
+    if(tmpPst == -1)
+    {
+        //check if there is some full log block
+        for(i=0; i<LOG_BLK_CNT_OF_ZONE; i++)
+        {
+            if(LOG_BLK_TBL[i].LastUsedPage == PAGE_CNT_OF_SUPER_BLK-1)
+            {
+                tmpPst = i;
+                break;
+            }
+        }
+
+        if(tmpPst == -1)
+        {
+            //there is no full log block, look for an oldest log block to merge
+            for(i=0; i<LOG_BLK_CNT_OF_ZONE; i++)
+            {
+                if(LOG_ACCESS_AGE[i] < tmpLogAccessAge)
+                {
+                    tmpLogAccessAge = LOG_ACCESS_AGE[i];
+                    tmpPst = i;
+                }
+            }
+        }
+
+        //switch the page mapping table for merge the log block
+        result = PMM_SwitchMapTbl(tmpPst);
+        if(result < 0)
+        {
+            MAPPING_ERR("[MAPPING_ERR] Switch page mapping table failed when create new log block! Err:0x%x\n", result);
+            return -1;
+        }
+
+        //merge the log block with normal type, to make an empty item
+        result = LML_MergeLogBlk(NORMAL_MERGE_MODE, LOG_BLK_TBL[tmpPst].LogicBlkNum);
+        if(result < 0)
+        {
+            //merge log block failed, report error
+            MAPPING_ERR("[MAPPING_ERR] Merge log block failed when create new log block! Err:0x%x\n", result);
+            return -1;
+        }
+    }
+
+    //get a free block to create a new log block
+    result = BMM_GetFreeBlk(LOWEST_EC_TYPE, &tmpFreeBlk);
+    if(result < 0)
+    {
+        MAPPING_ERR("[MAPPING_ERR] Get free block failed when create new log block!\n");
+        return -1;
+    }
+
+    //make a new log item in the log block table
+    LOG_BLK_TBL[tmpPst].LogicBlkNum = nBlk;
+    LOG_BLK_TBL[tmpPst].LastUsedPage = 0xffff;
+    LOG_BLK_TBL[tmpPst].PhyBlk = tmpFreeBlk;
+    //set the return vaule of the log position
+    *pLogPst = tmpPst;
+
+__CHECK_LOGICAL_INFO_OF_DATA_BLOCK:
+    //check if the data block is an empty block, if so, need update the logic information in the spare area
+    LML_CalculatePhyOpPar(&tmpPhyPage, CUR_MAP_ZONE, DATA_BLK_TBL[nBlk].PhyBlkNum, 0);
+    tmpPhyPage.SectBitmap = 0x03;
+    tmpPhyPage.MDataPtr = LML_TEMP_BUF;
+    tmpPhyPage.SDataPtr = (void *)tmpSpare;
+    LML_VirtualPageRead(&tmpPhyPage);
+
+    if(tmpSpare[0].LogicInfo == 0xffff)
+    {
+        tmpSpare[0].BadBlkFlag = 0xff;
+        tmpSpare[1].BadBlkFlag = 0xff;
+        tmpSpare[0].LogicInfo = ((CUR_MAP_ZONE % ZONE_CNT_OF_DIE)<<10) | nBlk;
+        tmpSpare[1].LogicInfo = ((CUR_MAP_ZONE % ZONE_CNT_OF_DIE)<<10) | nBlk;
+        tmpSpare[0].LogicPageNum = 0xffff;
+        tmpSpare[1].LogicPageNum = 0xffff;
+        tmpSpare[0].PageStatus = 0xff;
+        tmpSpare[1].PageStatus = 0xff;
+
+        //write the logical information to the spare area of the data block
+        tmpPhyPage.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+        result = LML_VirtualPageWrite(&tmpPhyPage);
+        if(result < 0)
+        {
+            LOGICCTL_ERR("[MAPPING_ERR] Physical write module failed when write logical information, Err:0x%x!\n", result);
+            return -1;
+        }
+
+        result = PHY_SynchBank(tmpPhyPage.BankNum, SYNC_CHIP_MODE);
+        if(result < 0)
+        {
+            //the last write operation on current bank is failed, the block is bad, need proccess it
+            LOGICCTL_DBG("[LOGICCTL_DBG] Find a bad block when write logical page! bank:0x%x, block:0x%x, page:0x%x\n",
+                    tmpPhyPage.BankNum, tmpPhyPage.BlkNum, tmpPhyPage.PageNum);
+
+            //process the bad block
+            result = LML_BadBlkManage(&DATA_BLK_TBL[nBlk], CUR_MAP_ZONE, 0, &tmpFreeBlk);
+            if(result < 0)
+            {
+                LOGICCTL_ERR("[MAPPING_ERR] Bad block process failed when create new log block, Err:0x%x!\n", result);
+                return -1;
+            }
+            DATA_BLK_TBL[nBlk] = tmpFreeBlk;
+
+            goto __CHECK_LOGICAL_INFO_OF_DATA_BLOCK;
+        }
+    }
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET LOG PAGE FOR WRITE
+*
+*Description: Get a log page for write.
+*
+*Arguments  : nBlk      the logical block number of the log block;
+*             nPage     the number of the logical page, which page need log page;
+*             pLogPage  the pointer to the log page number, for return value;
+*             pLogPst   the pointer to the position of the log block in the log block table.
+*
+*Return     : get log page result.
+*               = 0     get log page for write successful;
+*               =-1     get log page for write failed.
+************************************************************************************************************************
+*/
+static __s32 _GetLogPageForWrite(__u32 nBlk, __u32 nPage, __u16 *pLogPage, __u32 *pLogPst)
+{
+    __s32   result, tmpLogPst;
+    __u16   tmpPage;
+    struct __PhysicOpPara_t tmpPhyPage;
+    struct __NandUserData_t tmpSpare[2];
+
+    tmpLogPst = _GetLogBlkPst(nBlk);
+    if(tmpLogPst < 0)
+    {
+        //get log block position failed, there is no such log block, need create a new one
+        result = _CreateNewLogBlk(nBlk, (__u32 *)&tmpLogPst);
+        if(result < 0)
+        {
+            MAPPING_ERR("[MAPPING_ERR] Create new log block failed!\n");
+            return -1;
+        }
+    }
+
+    //need swap the page mapping table to ram which is accessing currently
+    result = PMM_SwitchMapTbl(tmpLogPst);
+    if(result < 0)
+    {
+        MAPPING_ERR("[MAPPING_ERR] Switch page mapping table failed when get log page! Err:0x%x\n", result);
+        return -1;
+    }
+
+    //need get log page by write mode,
+    tmpPage = LOG_BLK_TBL[tmpLogPst].LastUsedPage;
+
+    if(SUPPORT_ALIGN_NAND_BNK)
+    {
+        if(tmpPage == 0xffff)
+        {
+            //the log block is empty, need get log page in the first page line
+            tmpPage = nPage % INTERLEAVE_BANK_CNT;
+        }
+        else
+        {
+            //need bank align, the log page and the data page should be in the same bank
+            if((nPage % INTERLEAVE_BANK_CNT) > (tmpPage % INTERLEAVE_BANK_CNT))
+            {
+                //get the log page in the same page line with last used page
+                tmpPage = tmpPage + ((nPage % INTERLEAVE_BANK_CNT) - (tmpPage % INTERLEAVE_BANK_CNT));
+            }
+            else
+            {
+                //need get the log page in the next page line of the last used page
+                tmpPage = tmpPage + (nPage % INTERLEAVE_BANK_CNT) + (INTERLEAVE_BANK_CNT - (tmpPage % INTERLEAVE_BANK_CNT));
+            }
+        }
+    }
+    else
+    {
+
+        //use the page which is the next of the last used page
+        tmpPage = tmpPage + 1;
+    }
+
+
+__CHECK_WRITE_LOGICAL_INFO_OF_LOG_BLOCK:
+    //check if need write the logical information in the first page of the log block
+    if((LOG_BLK_TBL[tmpLogPst].LastUsedPage == 0xffff) && (tmpPage != 0))
+    {
+        //get logical information from the data block
+        LML_CalculatePhyOpPar(&tmpPhyPage, CUR_MAP_ZONE, DATA_BLK_TBL[nBlk].PhyBlkNum, 0);
+        tmpPhyPage.SectBitmap = 0x03;
+        tmpPhyPage.MDataPtr = LML_TEMP_BUF;
+        tmpPhyPage.SDataPtr = (void *)tmpSpare;
+        LML_VirtualPageRead(&tmpPhyPage);
+
+        tmpSpare[0].BadBlkFlag = 0xff;
+        tmpSpare[1].BadBlkFlag = 0xff;
+        tmpSpare[0].LogicInfo = ((CUR_MAP_ZONE % ZONE_CNT_OF_DIE)<<10) | nBlk;
+        tmpSpare[1].LogicInfo = ((CUR_MAP_ZONE % ZONE_CNT_OF_DIE)<<10) | nBlk;
+        tmpSpare[0].LogicPageNum = 0xffff;
+        tmpSpare[1].LogicPageNum = 0xffff;
+        tmpSpare[0].PageStatus =  tmpSpare[0].PageStatus + 1;
+        tmpSpare[1].PageStatus = tmpSpare[0].PageStatus;
+
+       //write the logical information to the spare area of the data block
+        LML_CalculatePhyOpPar(&tmpPhyPage, CUR_MAP_ZONE, LOG_BLK_TBL[tmpLogPst].PhyBlk.PhyBlkNum, 0);
+        tmpPhyPage.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+        result = LML_VirtualPageWrite(&tmpPhyPage);
+        if(result < 0)
+        {
+            LOGICCTL_ERR("[MAPPING_ERR] Physical write module failed when write logical information, Err:0x%x!\n", result);
+            return -1;
+        }
+
+        result = PHY_SynchBank(tmpPhyPage.BankNum, SYNC_CHIP_MODE);
+        if(result < 0)
+        {
+            //the last write operation on current bank is failed, the block is bad, need proccess it
+            LOGICCTL_DBG("[LOGICCTL_DBG] Find a bad block when write logical page! bank:0x%x, block:0x%x, page:0x%x\n",
+                    tmpPhyPage.BankNum, tmpPhyPage.BlkNum, tmpPhyPage.PageNum);
+
+            //process the bad block
+            result = LML_BadBlkManage(&LOG_BLK_TBL[tmpLogPst].PhyBlk, CUR_MAP_ZONE, 0, &LOG_BLK_TBL[tmpLogPst].PhyBlk);
+            if(result < 0)
+            {
+                LOGICCTL_ERR("[MAPPING_ERR] Bad block process failed when get log page for write, Err:0x%x!\n", result);
+                return -1;
+            }
+
+           goto __CHECK_WRITE_LOGICAL_INFO_OF_LOG_BLOCK;
+        }
+    }
+
+    //set the log page number for return
+    *pLogPage = tmpPage;
+    *pLogPst = tmpLogPst;
+
+    return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       GET LOG PAGE PARAMETER
+*
+*Description: Get a page from log block for read or write.
+*
+*Arguments  : nBlk      the logical block number of the log block;
+*             nPage     the number of the logical page, which page need log page;
+*             nMode     the type of get log page, 'r' or 'w', others is invalid.
+*
+*Return     : the number of the log page;
+*               != 0xffff   get log page successful, return page number;
+*                = 0xffff   get log page failed.
+*
+*Note       : Scan the log block table to try to get the log block.
+*             when the get type is 'r', if the log block is exsit and the logical
+*             page contain a log page, return the number of the log page, else,
+*             return 0xffff;
+*             when the get type is 'w', if the log block is not exsit, need create
+*             log block, then, if get log page failed, need merge the log block, and
+*             try to get log page again, this mode should return a value page number
+*             except there is no enough valid blocks.
+************************************************************************************************************************
+*/
+__u32 PMM_GetLogPage(__u32 nBlk, __u32 nPage, __u8 nMode)
+{
+    __s32   result, tmpLogPst;
+    __u16   tmpPage;
+
+    if(nMode == 'r')
+    {
+        tmpLogPst = _GetLogBlkPst(nBlk);
+        if(tmpLogPst < 0)
+        {
+            //get log page by read mode, there is no log block, return invalid value
+            return INVALID_PAGE_NUM;
+        }
+
+        //need swap the page mapping table to ram which is accessing currently
+        result = PMM_SwitchMapTbl(tmpLogPst);
+        if(result < 0)
+        {
+            MAPPING_ERR("[MAPPING_ERR] Switch page mapping table failed when get log page! Err:0x%x\n", result);
+            return INVALID_PAGE_NUM;
+        }
+
+        _CalLogAccessCnt(tmpLogPst);
+
+        return PAGE_MAP_TBL[nPage].PhyPageNum;
+    }
+
+    result = _GetLogPageForWrite(nBlk, nPage, &tmpPage, (__u32 *)&tmpLogPst);
+    if(result < 0)
+    {
+        //get log page for write failed
+        MAPPING_ERR("[MAPPING_ERR] Get log page for write failed!\n");
+        return INVALID_PAGE_NUM;
+    }
+
+    //check if the log page is valid
+    if(!(tmpPage < PAGE_CNT_OF_SUPER_BLK))
+    {
+        //the log page is not invalid, need to merge the log block, and get again
+        result = LML_MergeLogBlk(SPECIAL_MERGE_MODE, nBlk);
+        if(result < 0)
+        {
+            //merge log block failed, report error
+            MAPPING_ERR("[MAPPING_ERR] Merge log block failed when get log page! Err:0x%x\n", result);
+            return INVALID_PAGE_NUM;
+        }
+
+        //try to get log page for write again
+        result = _GetLogPageForWrite(nBlk, nPage, &tmpPage, (__u32 *)&tmpLogPst);
+        if(result < 0)
+        {
+            //get log page for write failed
+            MAPPING_ERR("[MAPPING_ERR] Get log page for write failed!\n");
+            return INVALID_PAGE_NUM;
+        }
+    }
+
+    //check if the log page is valid
+    if(!(tmpPage < PAGE_CNT_OF_SUPER_BLK))
+    {
+        //get log page for write failed
+        MAPPING_ERR("[MAPPING_ERR] Get log page for write failed!\n");
+        return INVALID_PAGE_NUM;
+    }
+    else
+    {
+        LOG_BLK_TBL[tmpLogPst].LastUsedPage = tmpPage;
+    }
+
+    //update the page mapping table item
+    PAGE_MAP_TBL[nPage].PhyPageNum = tmpPage;
+
+    //set the flag that mark need update the page mapping table
+    PAGE_MAP_CACHE->DirtyFlag = 1;
+
+    _CalLogAccessCnt(tmpLogPst);
+
+    return tmpPage;
+}
+
+
+void PMM_ClearCurMapTbl(void)
+{
+	PAGE_MAP_CACHE->ZoneNum = 0xff;
+	PAGE_MAP_CACHE->LogBlkPst = 0xff;
+	PAGE_MAP_CACHE->DirtyFlag = 0x0;
+}
+
+__u32 PMM_GetCurMapPage(__u16 nLogicalPage)
+{
+	return PAGE_MAP_TBL[nLogicalPage].PhyPageNum;
+}
+
+void PMM_SetCurMapPage(__u16 nLogicalPage,__u16 nPhysicPage)
+{
+	PAGE_MAP_TBL[nLogicalPage].PhyPageNum = nPhysicPage;
+}
+
diff --git a/drivers/block/sunxi_nand/src/logic/merge.c b/drivers/block/sunxi_nand/src/logic/merge.c
new file mode 100644
index 0000000..8c13316
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/logic/merge.c
@@ -0,0 +1,492 @@
+/*
+ * drivers/block/sunxi_nand/src/logic/merge.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_logic.h"
+
+extern struct __NandDriverGlobal_t     NandDriverInfo;
+
+__s32 _copy_page0(__u32 SrcBlk,__u16 SrcDataPage,__u32 DstBlk,__u8 SeqPlus)
+{
+    __u8 seq;
+    __u16 LogicInfo;
+    struct __NandUserData_t UserData[2];
+    struct __PhysicOpPara_t SrcParam,DstParam;
+
+    SrcParam.MDataPtr = DstParam.MDataPtr = LML_TEMP_BUF;
+    SrcParam.SDataPtr = DstParam.SDataPtr = (void *)&UserData;
+    MEMSET((void *)&UserData,0xff,sizeof(struct __NandUserData_t) * 2);
+
+    /*get seq and logicinfo*/
+    SrcParam.SectBitmap = 0x3;
+    LML_CalculatePhyOpPar(&SrcParam,CUR_MAP_ZONE, SrcBlk, 0);
+    if (LML_VirtualPageRead(&SrcParam) < 0){
+        LOGICCTL_ERR("_copy_page0 : read user data err\n");
+        return NAND_OP_FALSE;
+    }
+    seq = UserData[0].PageStatus;
+    LogicInfo = UserData[0].LogicInfo;
+
+    /*copy main data */
+    SrcParam.SectBitmap = DstParam.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+    LML_CalculatePhyOpPar(&SrcParam, CUR_MAP_ZONE, SrcBlk, SrcDataPage);
+    LML_CalculatePhyOpPar(&DstParam, CUR_MAP_ZONE, DstBlk, 0);
+
+    if (LML_VirtualPageRead(&SrcParam) < 0){
+        LOGICCTL_ERR("_copy_page0 : read main data err\n");
+        return NAND_OP_FALSE;
+    }
+
+    UserData[0].LogicInfo = LogicInfo;
+    UserData[0].PageStatus = seq + SeqPlus;
+    if (NAND_OP_TRUE != LML_VirtualPageWrite(&DstParam)){
+        LOGICCTL_ERR("_copy_page0 : write err\n");
+        return NAND_OP_FALSE;
+    }
+
+    return NAND_OP_TRUE;
+}
+
+/*!
+*
+* \par  Description:
+*       This function copy valuable data from datablk to logblk,then change datablk to freeblk ,change logblk to datablk.
+*
+* \param  [in]       LogNum,serial number within log block space
+* \return      sucess or failed.
+* \note         this function was called when log block is in order,that is to say physical
+*             page number is same with logical page number.
+**/
+__s32  _log2data_swap_merge(__u32 nlogical)
+{
+    __u16 LastUsedPage,SuperPage;
+    struct __SuperPhyBlkType_t DataBlk;
+    struct __LogBlkType_t LogBlk;
+    struct __PhysicOpPara_t SrcParam,DstParam;
+
+    /* init info of data block and log block*/
+    BMM_GetDataBlk(nlogical, &DataBlk);
+    BMM_GetLogBlk(nlogical, &LogBlk);
+    LastUsedPage = LogBlk.LastUsedPage;
+
+    /*copy data from data block to log block*/
+    for (SuperPage = LastUsedPage + 1; SuperPage < PAGE_CNT_OF_SUPER_BLK; SuperPage++){
+        /*set source and destinate address*/
+        LML_CalculatePhyOpPar(&SrcParam,CUR_MAP_ZONE, DataBlk.PhyBlkNum, SuperPage);
+        LML_CalculatePhyOpPar(&DstParam,CUR_MAP_ZONE, LogBlk.PhyBlk.PhyBlkNum, SuperPage);
+        if (NAND_OP_TRUE != PHY_PageCopyback(&SrcParam,&DstParam)){
+            LOGICCTL_ERR("swap merge : copy back err\n");
+            return NAND_OP_FALSE;
+        }
+        if (NAND_OP_TRUE !=  PHY_SynchBank(DstParam.BankNum, SYNC_BANK_MODE)){
+            struct __SuperPhyBlkType_t SubBlk;
+            if (NAND_OP_TRUE != LML_BadBlkManage(&LogBlk.PhyBlk,CUR_MAP_ZONE,SuperPage,&SubBlk)){
+                LOGICCTL_ERR("swap merge : bad block manage err after copy back\n");
+                return NAND_OP_FALSE;
+            }
+            LogBlk.PhyBlk = SubBlk;
+            SuperPage -= 1;
+        }
+    }
+
+    /*move log block to data block*/
+    BMM_SetDataBlk(nlogical, &LogBlk.PhyBlk);
+    /*clear log block item*/
+    MEMSET(&LogBlk, 0xff, sizeof(struct __LogBlkType_t));
+    BMM_SetLogBlk(nlogical, &LogBlk);
+
+    /*erase data block*/
+    if ( NAND_OP_TRUE != LML_VirtualBlkErase(CUR_MAP_ZONE, DataBlk.PhyBlkNum)){
+        if (NAND_OP_TRUE != LML_BadBlkManage(&DataBlk,CUR_MAP_ZONE,0,NULL)){
+            LOGICCTL_ERR("swap merge : bad block manage err erase data block\n");
+            return NAND_OP_FALSE;
+        }
+    }
+    /*move erased data block to free block*/
+    if (DataBlk.BlkEraseCnt < 0xffff)
+        DataBlk.BlkEraseCnt ++;
+    BMM_SetFreeBlk(&DataBlk);
+
+    /*clear page map table*/
+    PMM_ClearCurMapTbl();
+
+    return  NAND_OP_TRUE;
+}
+
+/*!
+*
+* \par  Description:
+*       This function move valuable data from log block to free block,then replace them.
+*
+* \param  [in]       LogNum,serial number within log block space
+* \return      sucess or failed.
+* \note         this function was called when log block is full, and valid pages is less than half of one block.
+**/
+__s32  _free2log_move_merge(__u32 nlogical)
+{
+    __u8 bank;
+    __u16 LastUsedPage,SuperPage;
+    __u16 SrcPage,DstPage;
+    struct __SuperPhyBlkType_t FreeBlk;
+    struct __LogBlkType_t LogBlk;
+    struct __PhysicOpPara_t SrcParam,DstParam;
+	struct __NandUserData_t UserData[2];
+
+
+    /*init info of log block , and get one free block */
+    BMM_GetLogBlk(nlogical, &LogBlk);
+    if (NAND_OP_TRUE != BMM_GetFreeBlk(LOWEST_EC_TYPE, &FreeBlk))
+        return NAND_OP_FALSE;
+
+    SrcParam.MDataPtr = DstParam.MDataPtr = NULL;
+    SrcParam.SDataPtr = DstParam.SDataPtr = NULL;
+    SrcParam.SectBitmap = DstParam.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+
+    if(SUPPORT_ALIGN_NAND_BNK)
+    {
+        redo:
+        /*copy data bank by bank, for copy-back using*/
+        LastUsedPage = 0;
+        for (bank = 0; bank < INTERLEAVE_BANK_CNT; bank++)
+        {
+            DstPage = bank;
+            for (SuperPage  = bank; SuperPage < PAGE_CNT_OF_SUPER_BLK; SuperPage+= INTERLEAVE_BANK_CNT)
+            {
+                SrcPage = PMM_GetCurMapPage(SuperPage);
+                if (SrcPage != 0xffff)
+                {
+                	  /*set source and destinate address*/
+    		 		LML_CalculatePhyOpPar(&SrcParam,CUR_MAP_ZONE, LogBlk.PhyBlk.PhyBlkNum, SrcPage);
+                   	LML_CalculatePhyOpPar(&DstParam,CUR_MAP_ZONE, FreeBlk.PhyBlkNum, DstPage);
+                    if (DstPage == 0)
+                    {
+                        if ( NAND_OP_FALSE == _copy_page0(LogBlk.PhyBlk.PhyBlkNum,SrcPage,FreeBlk.PhyBlkNum,0))
+                        {
+                            LOGICCTL_ERR("move merge : copy page 0 err1\n");
+                            return NAND_OP_FALSE;
+                        }
+                    }
+                    else
+                    {
+                        if (NAND_OP_TRUE != PHY_PageCopyback(&SrcParam,&DstParam))
+                        {
+                            LOGICCTL_ERR("move merge : copy back err\n");
+                            return NAND_OP_FALSE;
+                        }
+                    }
+
+                    if (NAND_OP_TRUE !=  PHY_SynchBank(DstParam.BankNum, SYNC_BANK_MODE))
+                    {
+                        struct __SuperPhyBlkType_t SubBlk;
+                        if (NAND_OP_TRUE != LML_BadBlkManage(&FreeBlk,CUR_MAP_ZONE,0,&SubBlk))
+                        {
+                            LOGICCTL_ERR("move merge : bad block manage err after copy back\n");
+                            return NAND_OP_FALSE;
+                        }
+                        FreeBlk = SubBlk;
+                        goto redo;
+                    }
+
+                    PMM_SetCurMapPage(SuperPage,DstPage);
+                    DstPage += INTERLEAVE_BANK_CNT;
+                }
+            }
+
+            /*if bank 0 is empty, need write mange info in page 0*/
+            if ((bank == 0) && (DstPage == 0))
+            {
+                if ( NAND_OP_FALSE == _copy_page0(LogBlk.PhyBlk.PhyBlkNum,0,FreeBlk.PhyBlkNum,0))
+                {
+                    LOGICCTL_ERR("move merge : copy page 0 err2\n");
+                    return NAND_OP_FALSE;
+                }
+    			LML_CalculatePhyOpPar(&DstParam, CUR_MAP_ZONE, FreeBlk.PhyBlkNum, 0);
+                if (NAND_OP_TRUE !=  PHY_SynchBank(DstParam.BankNum, SYNC_BANK_MODE))
+                {
+                    struct __SuperPhyBlkType_t SubBlk;
+                    if (NAND_OP_TRUE != LML_BadBlkManage(&FreeBlk,CUR_MAP_ZONE,0,&SubBlk))
+                    {
+                        LOGICCTL_ERR("move merge : bad block manage err after copy back\n");
+                        return NAND_OP_FALSE;
+                    }
+                    FreeBlk = SubBlk;
+                    goto redo;
+                }
+            }
+
+            /*reset LastUsedPage*/
+            if ((DstPage - INTERLEAVE_BANK_CNT) > LastUsedPage)
+            {
+                LastUsedPage = DstPage - INTERLEAVE_BANK_CNT;
+            }
+        }
+    }
+    else
+    {
+    	/*copy data page by page*/
+    	DstPage = 0;
+        LastUsedPage = 0;
+    	for (SuperPage = 0; SuperPage < PAGE_CNT_OF_LOGIC_BLK; SuperPage++)
+    	{
+    		SrcPage = PMM_GetCurMapPage(SuperPage);
+    		if (SrcPage != 0xffff)
+    		{
+    			/*set source and destinate address*/
+    		 	LML_CalculatePhyOpPar(&SrcParam,CUR_MAP_ZONE, LogBlk.PhyBlk.PhyBlkNum, SrcPage);
+                LML_CalculatePhyOpPar(&DstParam,CUR_MAP_ZONE, FreeBlk.PhyBlkNum, DstPage);
+    			if (0 == DstPage)
+    			{
+    				if ( NAND_OP_FALSE == _copy_page0(LogBlk.PhyBlk.PhyBlkNum,SrcPage,FreeBlk.PhyBlkNum,0))
+                    {
+                         LOGICCTL_ERR("move merge : copy page 0 err1\n");
+                         return NAND_OP_FALSE;
+                    }
+    			}
+    			else
+    			{
+    				SrcParam.MDataPtr = DstParam.MDataPtr = LML_TEMP_BUF;
+    				SrcParam.SDataPtr = DstParam.SDataPtr = (void *)&UserData;
+        			MEMSET((void *)&UserData,0xff,sizeof(struct __NandUserData_t) * 2);
+    				SrcParam.SectBitmap = DstParam.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+    				if (LML_VirtualPageRead(&SrcParam) < 0){
+           				 LOGICCTL_ERR("move merge : read main data err\n");
+            			 return NAND_OP_FALSE;
+        			}
+
+       				if (NAND_OP_TRUE != LML_VirtualPageWrite(&DstParam)){
+            			LOGICCTL_ERR("move merge : write err\n");
+            			return NAND_OP_FALSE;
+        			}
+    			}
+    			if (NAND_OP_TRUE !=  PHY_SynchBank(DstParam.BankNum, SYNC_BANK_MODE))
+                {
+                	struct __SuperPhyBlkType_t SubBlk;
+                    if (NAND_OP_TRUE != LML_BadBlkManage(&FreeBlk,CUR_MAP_ZONE,LastUsedPage,&SubBlk))
+                    {
+                        LOGICCTL_ERR("move merge : bad block manage err after copy back\n");
+                    	return NAND_OP_FALSE;
+    				}
+    				FreeBlk = SubBlk;
+    				SuperPage -= 1;
+    			}
+    			PMM_SetCurMapPage(SuperPage,DstPage);
+    			LastUsedPage = DstPage;
+    			DstPage++;
+    		}
+    	}
+
+    }
+
+    /*erase log block*/
+    if(NAND_OP_TRUE != LML_VirtualBlkErase(CUR_MAP_ZONE, LogBlk.PhyBlk.PhyBlkNum))
+    {
+        if(NAND_OP_TRUE != LML_BadBlkManage(&LogBlk.PhyBlk,CUR_MAP_ZONE,0,NULL))
+        {
+            LOGICCTL_ERR("move merge : bad block manage err after erase log block\n");
+            return NAND_OP_FALSE;
+        }
+    }
+    /*move erased log block to free block*/
+    if(LogBlk.PhyBlk.BlkEraseCnt < 0xffff)
+    {
+        LogBlk.PhyBlk.BlkEraseCnt ++;
+    }
+    BMM_SetFreeBlk(&LogBlk.PhyBlk);
+
+    /*move free block to log block*/
+    LogBlk.PhyBlk = FreeBlk;
+    LogBlk.LastUsedPage = LastUsedPage;
+    BMM_SetLogBlk(nlogical, &LogBlk);
+
+    return NAND_OP_TRUE;
+}
+
+/*!
+*
+* \par  Description:
+*       This function copy valuable data from log block or dat block to free block, change free to data ,change
+*       data and log to free.
+*
+* \param  [in]       LogNum,serial number within log block space
+* \return      sucess or failed.
+* \note         this function was called when log block is not suit for swap or move.
+**/
+__s32  _free2data_simple_merge(__u32 nlogical)
+{
+    __u8 InData;
+    __u16 SuperPage;
+    __u16 SrcPage,DstPage;
+    __u32 SrcBlk,DstBlk;
+    struct __SuperPhyBlkType_t DataBlk;
+    struct __SuperPhyBlkType_t FreeBlk;
+    struct __LogBlkType_t LogBlk;
+    struct __PhysicOpPara_t SrcParam,DstParam;
+
+    /*init block info*/
+    BMM_GetDataBlk(nlogical,&DataBlk);
+    if (NAND_OP_TRUE != BMM_GetFreeBlk(LOWEST_EC_TYPE, &FreeBlk))
+        return NAND_OP_FALSE;
+    BMM_GetLogBlk(nlogical,&LogBlk);
+
+    /*copy data from data block or log block to free block*/
+    for (SuperPage = 0; SuperPage < PAGE_CNT_OF_LOGIC_BLK; SuperPage++)
+    {
+        /*set source address and destination address*/
+        DstPage = SuperPage;
+        DstBlk = FreeBlk.PhyBlkNum;
+        SrcPage = PMM_GetCurMapPage(SuperPage);
+        InData = (SrcPage == 0xffff)?1 : 0;
+        SrcBlk = InData?DataBlk.PhyBlkNum : LogBlk.PhyBlk.PhyBlkNum;
+        SrcPage = InData?SuperPage:SrcPage;
+		LML_CalculatePhyOpPar(&SrcParam, CUR_MAP_ZONE,SrcBlk, SrcPage);
+		LML_CalculatePhyOpPar(&DstParam, CUR_MAP_ZONE,DstBlk, DstPage);
+
+        if (DstPage == 0)
+        {
+            __u8 SeqPlus;
+            //SeqPlus = InData?1:0;
+            SeqPlus = InData?2:1;
+            if(NAND_OP_FALSE == _copy_page0(SrcBlk, SrcPage, DstBlk,SeqPlus))
+            {
+                LOGICCTL_ERR("simple_merge : copy page 0 err\n");
+                return NAND_OP_FALSE;
+            }
+        }
+        else
+        {
+            if(NAND_OP_TRUE != PHY_PageCopyback(&SrcParam,&DstParam))
+            {
+                LOGICCTL_ERR("simple merge : copy back err\n");
+                return NAND_OP_FALSE;
+            }
+        }
+
+        if(NAND_OP_TRUE != PHY_SynchBank(DstParam.BankNum, SYNC_BANK_MODE))
+        {
+            struct __SuperPhyBlkType_t SubBlk;
+            if(NAND_OP_TRUE != LML_BadBlkManage(&FreeBlk,CUR_MAP_ZONE,DstPage, &SubBlk))
+            {
+                LOGICCTL_ERR("simgple merge : bad block manage err after copy back\n");
+                return NAND_OP_FALSE;
+            }
+            FreeBlk = SubBlk;
+            SuperPage -= 1;
+        }
+    }
+
+    /*move free block to data block*/
+    BMM_SetDataBlk(nlogical, &FreeBlk);
+
+
+	/*move erased data block to free block*/
+    if ( NAND_OP_TRUE != LML_VirtualBlkErase(CUR_MAP_ZONE, DataBlk.PhyBlkNum)){
+        if (NAND_OP_TRUE != LML_BadBlkManage(&DataBlk,CUR_MAP_ZONE,0,NULL)){
+            LOGICCTL_ERR("swap merge : bad block manage err erase data block\n");
+            return NAND_OP_FALSE;
+        }
+    }
+    /*move erased data block to free block*/
+    if (DataBlk.BlkEraseCnt < 0xffff)
+        DataBlk.BlkEraseCnt ++;
+    BMM_SetFreeBlk(&DataBlk);
+
+
+    /*move erased log block to free block*/
+    if ( NAND_OP_TRUE != LML_VirtualBlkErase(CUR_MAP_ZONE, LogBlk.PhyBlk.PhyBlkNum)){
+        if (NAND_OP_TRUE != LML_BadBlkManage(&LogBlk.PhyBlk,CUR_MAP_ZONE,0,NULL)){
+            LOGICCTL_ERR("move merge : bad block manage err after erase log block\n");
+            return NAND_OP_FALSE;
+        }
+    }
+    if (LogBlk.PhyBlk.BlkEraseCnt < 0xffff)
+        LogBlk.PhyBlk.BlkEraseCnt ++;
+    BMM_SetFreeBlk(&LogBlk.PhyBlk);
+    MEMSET(&LogBlk, 0xff, sizeof(struct __LogBlkType_t));
+    BMM_SetLogBlk(nlogical, &LogBlk);
+
+
+
+    /*clear page map table*/
+    PMM_ClearCurMapTbl();
+
+    return NAND_OP_TRUE;
+
+}
+
+void _get_page_map_tbl_info(__u32 nlogical,__u8 *InOrder, __u16 *nValidPage)
+{
+    __u16 LastUsedPage,PhysicPage;
+    __u32 i;
+    struct __LogBlkType_t  LogBlk;
+
+    *InOrder = 1;
+    *nValidPage = 0;
+    BMM_GetLogBlk(nlogical, &LogBlk);
+    LastUsedPage = LogBlk.LastUsedPage;
+
+    for (i = 0; i < PAGE_CNT_OF_SUPER_BLK; i++)
+    {
+        PhysicPage = PMM_GetCurMapPage(i);
+        if (PhysicPage != 0xffff){
+            *nValidPage = *nValidPage + 1;
+            if (PhysicPage != i)
+                *InOrder = 0;
+        }
+    }
+
+    if (*nValidPage < LastUsedPage + 1)
+        *InOrder = 0;
+}
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER MERGE LOG BLOCK
+*
+*Description: Merge the log block whoes mapping table is active.
+*
+*Arguments  : nMode     the type of the merge;
+*                       = 0     normal merge, the log block  table is not full;
+*                       = 1     special merge, the log block table is full.
+*
+*Return     : merge result;
+*               = 0     merge log successful;
+*               = -1    do bad block manage failed.
+************************************************************************************************************************
+*/
+__s32 LML_MergeLogBlk(__u32 nMode, __u32 nlogical)
+{
+    __u8 InOrder;
+    __u16 nValidPage;
+
+    _get_page_map_tbl_info(nlogical,&InOrder,&nValidPage);
+
+    if (InOrder)
+        return (_log2data_swap_merge(nlogical));
+    else{
+        if ( (nMode == SPECIAL_MERGE_MODE) && (nValidPage < PAGE_CNT_OF_SUPER_BLK/(INTERLEAVE_BANK_CNT+1)))
+            return (_free2log_move_merge(nlogical));
+        else
+            return (_free2data_simple_merge(nlogical));
+    }
+
+}
+
+
diff --git a/drivers/block/sunxi_nand/src/logic/read_reclaim.c b/drivers/block/sunxi_nand/src/logic/read_reclaim.c
new file mode 100644
index 0000000..3b870bb
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/logic/read_reclaim.c
@@ -0,0 +1,80 @@
+/*
+ * drivers/block/sunxi_nand/src/logic/read_reclaim.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_logic.h"
+
+extern struct __NandDriverGlobal_t     NandDriverInfo;
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH LOGIC MANAGE LAYER READ-RECLAIM
+*
+*Description: Repair the logic block whose data has reach the limit of the ability of
+*             the HW ECC module correct.
+*
+*Arguments  : nPage     the page address where need be repaired.
+*
+*Return     : read-reclaim result;
+*               = 0     do read-reclaim successful;
+*               = -1    do read-reclaim failed.
+*
+*Notes      : if read a physical page millions of times, there may be some bit error in
+*             the page, and the error bit number will increase along with the read times,
+*             so, if the number of the error bit reachs the ECC limit, the data should be
+*             read out and write to another physical blcok.
+************************************************************************************************************************
+*/
+__s32 LML_ReadReclaim(__u32 nPage)
+{
+    __s32   result;
+
+    #if CFG_SUPPORT_READ_RECLAIM
+
+	LOGICCTL_ERR("[LOGICCTL_ERR] read reclaim go\n");
+
+    //flush the page cache to nand flash first, because need use the buffer
+    result = LML_FlushPageCache();
+    if(result < 0)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Flush page cache failed when do read reclaim! Error:0x%x\n", result);
+        return -1;
+    }
+
+    //read the full page data to buffer
+    result = LML_PageRead(nPage, FULL_BITMAP_OF_LOGIC_PAGE, LML_WRITE_PAGE_CACHE);
+    if(result < 0)
+    {
+        return -1;
+    }
+
+    //the data in the page cache is full, write it to nand flash
+    result = LML_PageWrite(nPage, FULL_BITMAP_OF_LOGIC_PAGE, LML_WRITE_PAGE_CACHE);
+    if(result < 0)
+    {
+        return -1;
+    }
+
+    #endif
+    return 0;
+}
+
+
diff --git a/drivers/block/sunxi_nand/src/logic/wear_levelling.c b/drivers/block/sunxi_nand/src/logic/wear_levelling.c
new file mode 100644
index 0000000..0702831
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/logic/wear_levelling.c
@@ -0,0 +1,192 @@
+/*
+ * drivers/block/sunxi_nand/src/logic/wear_levelling.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_logic.h"
+
+extern struct __NandDriverGlobal_t     NandDriverInfo;
+
+/*
+************************************************************************************************************************
+*                   NAND FLASH LOGIC MANAGE LAYER WEAR-LEVELLING
+*
+*Description: Equate the erase cycles among all physical blocks.
+*
+*Arguments  : none
+*
+*Return     : do wear-levelling result;
+*               = 0     do wear-levelling successful;
+*               = -1    do wear-levelling failed.
+*
+*Notes      : The erase cycle of a physical block is limited, if the erase cycle overun this
+*             limit, the physical block may be invalid. so a policy is needed to equate the
+*             millions of erase cycles to ervery physical block.
+************************************************************************************************************************
+*/
+__s32 LML_WearLevelling(void)
+{
+    #if CFG_SUPPORT_WEAR_LEVELLING
+
+    __s32   i, result;
+
+    __u32   tmpLogicBlk;
+    __u16   tmpLowEc = 0xffff;
+    struct __SuperPhyBlkType_t tmpFreeBlk, tmpDataBlk;
+    struct __NandUserData_t tmpSpare[2];
+    struct __PhysicOpPara_t tmpSrcPage, tmpDstPage;
+    BLK_ERASE_CNTER = 0;
+
+    //scan the data block table, to look for a physical block with lowest erase count
+    for(i=DATA_BLK_CNT_OF_ZONE-1; i>=0; i--)
+    {
+        if(DATA_BLK_TBL[i].BlkEraseCnt < tmpLowEc)
+        {
+            tmpLowEc = DATA_BLK_TBL[i].BlkEraseCnt;
+            tmpLogicBlk = i;
+        }
+    }
+
+    //get a free block which has the highest erase count
+    result = BMM_GetFreeBlk(HIGHEST_EC_TYPE, &tmpFreeBlk);
+    if(result < 0)
+    {
+        LOGICCTL_ERR("[LOGICCTL_ERR] Get free block failed when do wear-levelling!\n");
+        return -1;
+    }
+
+    //clear the block erase counter
+    BLK_ERASE_CNTER = 0;
+
+    if(tmpLowEc >= tmpFreeBlk.BlkEraseCnt)
+    {
+        if(tmpLowEc == 0xffff)
+        {
+            //the lowest erase count reach the highest value, clear erase count of all physical block
+            for(i=0; i<DATA_BLK_CNT_OF_ZONE; i++)
+            {
+                //clear the erase count for the data block
+                DATA_BLK_TBL[i].BlkEraseCnt = 0x00;
+            }
+
+            for(i=0; i<FREE_BLK_CNT_OF_ZONE; i++)
+            {
+                //clear the erase count for the free block
+                if(FREE_BLK_TBL[i].PhyBlkNum != 0xffff)
+                {
+                    FREE_BLK_TBL[i].BlkEraseCnt = 0x00;
+                }
+            }
+
+            for(i=0; i<MAX_LOG_BLK_CNT; i++)
+            {
+                //clear the erase count for the log block
+                if(LOG_BLK_TBL[i].LogicBlkNum != 0xffff)
+                {
+                    LOG_BLK_TBL[i].PhyBlk.BlkEraseCnt = 0x00;
+                }
+            }
+        }
+
+        BMM_SetFreeBlk(&tmpFreeBlk);
+
+        return 0;
+    }
+
+    BMM_GetDataBlk(tmpLogicBlk, &tmpDataBlk);
+    result = BMM_GetLogBlk(tmpLogicBlk, NULL);
+    if(result < 0)
+    {
+        //check if the data block is empty
+        LML_CalculatePhyOpPar(&tmpSrcPage, CUR_MAP_ZONE, tmpDataBlk.PhyBlkNum, 0);
+        tmpSrcPage.SectBitmap = 0x03;
+        tmpSrcPage.MDataPtr = LML_TEMP_BUF;
+        tmpSrcPage.SDataPtr = (void *)tmpSpare;
+        LML_VirtualPageRead(&tmpSrcPage);
+
+        if(tmpSpare[0].LogicInfo != 0xffff)
+        {
+            //need copy data from the data block to the free block
+            tmpSrcPage.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+            tmpSrcPage.MDataPtr = NULL;
+            tmpSrcPage.SDataPtr = NULL;
+
+            tmpDstPage.SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+            tmpDstPage.MDataPtr = NULL;
+            tmpDstPage.SDataPtr = NULL;
+
+            for(i=0; i<PAGE_CNT_OF_SUPER_BLK; i++)
+            {
+                LML_CalculatePhyOpPar(&tmpSrcPage, CUR_MAP_ZONE, tmpDataBlk.PhyBlkNum, i);
+                LML_CalculatePhyOpPar(&tmpDstPage, CUR_MAP_ZONE, tmpFreeBlk.PhyBlkNum, i);
+
+                PHY_PageCopyback(&tmpSrcPage, &tmpDstPage);
+                //check page copy result
+                result = PHY_SynchBank(tmpDstPage.BankNum, SYNC_CHIP_MODE);
+                if(result < 0)
+                {
+                    LOGICCTL_DBG("[LOGICCTL_DBG] Copy page failed when doing wear-levelling!\n");
+                    result = LML_BadBlkManage(&tmpFreeBlk, CUR_MAP_ZONE, 0, NULL);
+                    if(result < 0)
+                    {
+                        LOGICCTL_ERR("[LOGICCTL_ERR] Bad block manage failed when doing wear-levelling!\n");
+                        return -1;
+                    }
+
+                    return 0;
+                }
+            }
+        }
+
+        //set the data block item by the free block
+        BMM_SetDataBlk(tmpLogicBlk, &tmpFreeBlk);
+
+        if(tmpSpare[0].LogicInfo != 0xffff)
+        {
+            //erase the data block to a new free block
+            result = LML_VirtualBlkErase(CUR_MAP_ZONE, tmpDataBlk.PhyBlkNum);
+            if(result < 0)
+            {
+                LOGICCTL_DBG("[LOGICCTL_DBG] Erase super block failed when doing wear-levelling!\n");
+                result = LML_BadBlkManage(&tmpDataBlk, CUR_MAP_ZONE, 0, NULL);
+                if(result < 0)
+                {
+                    LOGICCTL_ERR("[LOGICCTL_ERR] Bad block manage failed when doing wear-levelling!\n");
+                   return -1;
+                }
+
+                return 0;
+            }
+        }
+
+        //set the the data block to free block table
+        tmpDataBlk.BlkEraseCnt++;
+        BMM_SetFreeBlk(&tmpDataBlk);
+    }
+    else
+    {
+        //set the free block back to free table
+        BMM_SetFreeBlk(&tmpFreeBlk);
+    }
+
+    #endif
+    return 0;
+}
+
diff --git a/drivers/block/sunxi_nand/src/physic/nand_phy.c b/drivers/block/sunxi_nand/src/physic/nand_phy.c
new file mode 100644
index 0000000..ab1cb03
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/physic/nand_phy.c
@@ -0,0 +1,1539 @@
+/*
+ * drivers/block/sunxi_nand/src/physic/nand_phy.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_type.h"
+#include "../include/nand_physic.h"
+#include "../include/nand_simple.h"
+#include "../../nfc/nfc.h"
+
+extern  __u32 RetryCount[8];
+extern void _add_cmd_list(NFC_CMD_LIST *cmd,__u32 value,__u32 addr_cycle,__u8 *addr,__u8 data_fetch_flag,
+	__u8 main_data_fetch,__u32 bytecnt,__u8 wait_rb_flag);
+extern void _cal_addr_in_chip(__u32 block, __u32 page, __u32 sector,__u8 *addr, __u8 cycle);
+extern __s32 _read_status(__u32 cmd_value, __u32 nBank);
+extern __s32 _write_signle_page (struct boot_physical_param *writeop,__u32 program1,__u32 program2,__u8 dma_wait_mode, __u8 rb_wait_mode);
+extern __s32 _read_single_page(struct boot_physical_param * readop,__u8 dma_wait_mode);
+extern void _pending_dma_irq_sem(void);
+extern __s32 _wait_rb_ready(__u32 chip);
+extern __s32 _wait_rb_ready_int(__u32 chip);
+extern __u8 _cal_real_chip(__u32 global_bank);
+extern __u8 _cal_real_rb(__u32 chip);
+extern __u32 _cal_random_seed(__u32 page);
+
+
+/**********************************************************************
+***********************translate block in bank into baock in chip**************
+***********************************************************************/
+__u32 _cal_block_in_chip(__u32 global_bank, __u32 super_blk_within_bank)
+{
+	__u32 blk_within_chip;
+	__u32 single_blk_within_bank;
+	__u32 bank_base;
+
+	/*translate block 0 within  bank into blcok number within chip*/
+	bank_base = global_bank%BNK_CNT_OF_CHIP*BLOCK_CNT_OF_DIE;
+
+	if (SUPPORT_MULTI_PROGRAM ){
+		 single_blk_within_bank = super_blk_within_bank * PLANE_CNT_OF_DIE -
+		 	super_blk_within_bank%MULTI_PLANE_BLOCK_OFFSET;
+	}
+
+	else{
+		single_blk_within_bank = super_blk_within_bank;
+	}
+
+	blk_within_chip = bank_base + single_blk_within_bank;
+
+	if (blk_within_chip >= DIE_CNT_OF_CHIP * BLOCK_CNT_OF_DIE)
+		blk_within_chip = 0xffffffff;
+
+	return blk_within_chip;
+}
+/*
+************************************************************************************************************************
+*                           PHYSICAL BLOCK ERASE
+*
+*Description: Erase one nand flash physical block.
+*
+*Arguments  : pBlkAdr   the parameter of the physical block which need be erased.
+*
+*Return     : the result of the block erase;
+*               = 0     erase physical block successful;
+*               = -1    erase physical block failed.
+************************************************************************************************************************
+*/
+__s32 _read_single_page_seq(struct boot_physical_param *readop,__u8 dma_wait_mode)
+{
+	__s32 ret;
+	__u32 rb;
+	__u32 random_seed;
+
+	//__u8 *sparebuf;
+	__u8 sparebuf[4*16];
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i;
+
+	//sparebuf = (__u8 *)MALLOC(SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	/*create cmd list*/
+	/*samll block*/
+	if (SECTOR_CNT_OF_SINGLE_PAGE == 1){
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,4);
+		_add_cmd_list(cmd_list,0x00,4,addr,NFC_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_WAIT_RB);
+	}
+	/*large block*/
+	else{
+		/*the cammand have no corresponding feature if IGNORE was set, */
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,5);
+		_add_cmd_list(cmd_list,0x00,5,addr,NFC_NO_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_NO_WAIT_RB);
+
+	}
+	_add_cmd_list(cmd_list + 1,0x05,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 2,0xe0,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 3,0x30,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	list_len = 4;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	/*wait rb ready*/
+	ret = _wait_rb_ready(readop->chip);
+	if (ret)
+		return ret;
+
+	rb = _cal_real_rb(readop->chip);
+	NFC_SelectChip(readop->chip);
+	NFC_SelectRb(rb);
+
+	if(SUPPORT_RANDOM)
+	{
+		//random_seed = _cal_random_seed(readop->page);
+		random_seed = 0x4a80;
+		NFC_SetRandomSeed(random_seed);
+		NFC_RandomEnable();
+		ret = NFC_Read_Seq(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+		NFC_RandomDisable();
+		if(ret)
+			ret = NFC_Read_Seq(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+	}
+	else
+	{
+		ret = NFC_Read_Seq(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+	}
+
+
+
+
+	if (dma_wait_mode)
+		_pending_dma_irq_sem();
+
+	if (readop->oobbuf){
+		MEMCPY(readop->oobbuf,sparebuf, 2 * 4);
+	}
+
+	NFC_DeSelectChip(readop->chip);
+	NFC_DeSelectRb(rb);
+
+	//FREE(sparebuf);
+	return ret;
+}
+
+__s32 _read_single_page_1K(struct boot_physical_param *readop,__u8 dma_wait_mode)
+{
+	__s32 ret;
+	__u32 rb;
+	__u32 random_seed;
+	__u8 sparebuf[4*16];
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i;
+
+	//sparebuf = (__u8 *)MALLOC(SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	/*create cmd list*/
+	/*samll block*/
+	if (SECTOR_CNT_OF_SINGLE_PAGE == 1){
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,4);
+		_add_cmd_list(cmd_list,0x00,4,addr,NFC_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_WAIT_RB);
+	}
+	/*large block*/
+	else{
+		/*the cammand have no corresponding feature if IGNORE was set, */
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,5);
+		_add_cmd_list(cmd_list,0x00,5,addr,NFC_NO_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_NO_WAIT_RB);
+
+	}
+	_add_cmd_list(cmd_list + 1,0x05,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 2,0xe0,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 3,0x30,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	list_len = 4;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	/*wait rb ready*/
+	ret = _wait_rb_ready(readop->chip);
+	if (ret)
+		return ret;
+
+	rb = _cal_real_rb(readop->chip);
+	NFC_SelectChip(readop->chip);
+	NFC_SelectRb(rb);
+
+
+	if(1)
+	{
+		//random_seed = _cal_random_seed(readop->page);
+		random_seed = 0x4a80;
+		NFC_SetRandomSeed(random_seed);
+		NFC_RandomEnable();
+		ret = NFC_Read_1K(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+		NFC_RandomDisable();
+		if(ret)
+			ret = NFC_Read_1K(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+
+	}
+	else
+	{
+		ret = NFC_Read_1K(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+	}
+
+
+
+	if (dma_wait_mode)
+		_pending_dma_irq_sem();
+
+	if (readop->oobbuf){
+		MEMCPY(readop->oobbuf,sparebuf, 2 * 4);
+	}
+
+	NFC_DeSelectChip(readop->chip);
+	NFC_DeSelectRb(rb);
+
+	//FREE(sparebuf);
+	return ret;
+}
+
+__s32 _read_single_page_spare(struct boot_physical_param *readop,__u8 dma_wait_mode)
+{
+	__s32 ret;
+	__u32 k = 0;
+	__u32 rb;
+	__u32 random_seed;
+	__u8 sparebuf[4*16];
+	__u8 default_value[16];
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i;
+
+	//sparebuf = (__u8 *)MALLOC(SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	/*create cmd list*/
+	/*samll block*/
+	if (SECTOR_CNT_OF_SINGLE_PAGE == 1){
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,4);
+		_add_cmd_list(cmd_list,0x00,4,addr,NFC_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_WAIT_RB);
+	}
+	/*large block*/
+	else{
+		/*the cammand have no corresponding feature if IGNORE was set, */
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,5);
+		_add_cmd_list(cmd_list,0x00,5,addr,NFC_NO_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_NO_WAIT_RB);
+
+	}
+	_add_cmd_list(cmd_list + 1,0x05,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 2,0xe0,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 3,0x30,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	list_len = 4;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	/*wait rb ready*/
+	ret = _wait_rb_ready(readop->chip);
+	if (ret)
+		return ret;
+
+	rb = _cal_real_rb(readop->chip);
+	NFC_SelectChip(readop->chip);
+	NFC_SelectRb(rb);
+
+    if(SUPPORT_READ_RETRY)
+    {
+        if((READ_RETRY_MODE>=0x10)&&(READ_RETRY_MODE<0x30))  //toshiba & samsung mode
+            RetryCount[readop->chip] = 0;
+
+        for( k = 0; k<READ_RETRY_CYCLE+1;k++)
+		{
+			if(RetryCount[readop->chip]==(READ_RETRY_CYCLE+1))
+				RetryCount[readop->chip] = 0;
+
+			if(k>0)
+			{
+			    if(NFC_ReadRetry(readop->chip,RetryCount[readop->chip],READ_RETRY_TYPE))
+			    {
+			        PHY_ERR("[Read_single_page_spare] NFC_ReadRetry fail \n");
+			        return -1;
+			    }
+			}
+
+			if(SUPPORT_RANDOM)
+			{
+				random_seed = _cal_random_seed(readop->page);
+				NFC_SetRandomSeed(random_seed);
+				NFC_RandomEnable();
+				ret = NFC_Read_Spare(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+				NFC_RandomDisable();
+				if(ret == -ERR_ECC)
+					ret = NFC_Read_Spare(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+
+				/**************************************************************************************
+				* 1. add by Neil, from v2.09
+				* 2. if spare area is all 0xff in random disable mode, it means the page is a clear page
+				* 3. because in toshiba 24nm nand, too many clear pages are not all 0xff
+				***************************************************************************************/
+				if((ret == -ERR_ECC)&&(sparebuf[0]==0xff)&&(sparebuf[1]==0xff)&&(sparebuf[2]==0xff)&&(sparebuf[3]==0xff)&&(sparebuf[4]==0xff)&&(sparebuf[5]==0xff)&&(sparebuf[6]==0xff)&&(sparebuf[7]==0xff))
+				{
+					//PHY_DBG("[Read_single_page_spare] find not all 0xff clear page!  chip = %d, block = %d, page = %d\n", readop->chip, readop->block, readop->page);
+					ret = 0;
+				}
+
+			}
+			else
+			{
+				ret = NFC_Read_Spare(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+			}
+
+			if((ret != -ERR_ECC)||(k==READ_RETRY_CYCLE))
+			{
+			    if((READ_RETRY_MODE>=0x10)&&(READ_RETRY_MODE<0x20))  //toshiba mode
+			    {
+    			    //exit toshiba readretry
+    				PHY_ResetChip(readop->chip);
+			    }
+			    else if((READ_RETRY_MODE>=0x20)&&(READ_RETRY_MODE<0x30))   //samsung mode
+			    {
+			        NFC_SetDefaultParam(readop->chip, default_value, READ_RETRY_TYPE);
+			    }
+
+				break;
+			}
+
+			RetryCount[readop->chip]++;
+		}
+
+    	if(k>0)
+    	{
+    		PHY_DBG("[Read_single_page_spare] NFC_ReadRetry %d cycles, chip = %d, block = %d, page = %d, RetryCount = %d  \n", k ,readop->chip,readop->block, readop->page, RetryCount[readop->chip]);
+    		if(ret == -ERR_ECC)
+    		    PHY_DBG("ecc error!\n");
+    		PHY_DBG("spare buf: %x, %x, %x, %x, %x, %x, %x, %x\n", sparebuf[0],sparebuf[1],sparebuf[2],sparebuf[3],sparebuf[4],sparebuf[5],sparebuf[6],sparebuf[7]);
+    	}
+
+    	if(ret == ECC_LIMIT)
+    		ret = 0;
+
+
+    }
+    else
+    {
+		if(SUPPORT_RANDOM)
+        {
+			random_seed = _cal_random_seed(readop->page);
+			NFC_SetRandomSeed(random_seed);
+			NFC_RandomEnable();
+			ret = NFC_Read_Spare(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+			NFC_RandomDisable();
+			if(ret == -ERR_ECC)
+				ret = NFC_Read_Spare(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+		}
+		else
+		{
+			ret = NFC_Read_Spare(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+		}
+
+    }
+
+	if (dma_wait_mode)
+		_pending_dma_irq_sem();
+
+	if (readop->oobbuf){
+		MEMCPY(readop->oobbuf,sparebuf, 2 * 4);
+	}
+
+	NFC_DeSelectChip(readop->chip);
+	NFC_DeSelectRb(rb);
+
+	//FREE(sparebuf);
+	return ret;
+}
+/*
+************************************************************************************************************************
+*                       READ NAND FLASH PHYSICAL PAGE DATA
+*
+*Description: Read a page from a nand flash physical page to buffer.
+*
+*Arguments  : pPageAdr      the po__s32er to the accessed page parameter.
+*
+*Return     : the result of physical page read;
+*               = 0     read physical page successful;
+*               > 0     read physical page successful, but need do some process;
+*               < 0     read physical page failed.
+************************************************************************************************************************
+*/
+
+
+__s32 PHY_SimpleRead_Seq (struct boot_physical_param *readop)
+{
+	return(_read_single_page_seq(readop,0));
+}
+__s32 PHY_SimpleRead_1K (struct boot_physical_param *readop)
+{
+	return(_read_single_page_1K(readop,0));
+}
+
+
+__s32  PHY_BlockErase(struct __PhysicOpPara_t *pBlkAdr)
+{
+	__u32 chip;
+	__u32 rb;
+	__u8 addr[4][5];
+	__s32 ret;
+	__u32 plane_cnt,i,list_len;
+	__u32 block_in_chip;
+	NFC_CMD_LIST cmd_list[8];
+
+	/*get chip no*/
+	chip = _cal_real_chip(pBlkAdr->BankNum);
+	  rb = _cal_real_rb(chip);
+	if (0xff == chip){
+		PHY_ERR("PHY_BlockErase : beyond chip count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	/*get block no within chip*/
+	block_in_chip = _cal_block_in_chip(pBlkAdr->BankNum,pBlkAdr->BlkNum);
+	if (0xffffffff == block_in_chip){
+		PHY_ERR("PHY_BlockErase : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+
+	/*create cmd list*/
+	plane_cnt = SUPPORT_MULTI_PROGRAM ? PLANE_CNT_OF_DIE : 1;
+
+	for (i = 0; i < plane_cnt; i++){
+		_cal_addr_in_chip(block_in_chip+ i*MULTI_PLANE_BLOCK_OFFSET,0, 0,addr[i], 3);
+		_add_cmd_list(cmd_list+i,0x60,3,addr[i],NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+
+	}
+	_add_cmd_list(cmd_list + i,0xd0,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	list_len = plane_cnt + 1;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+	_wait_rb_ready_int(chip);
+	NFC_SelectChip(chip);
+	NFC_SelectRb(rb);
+
+	ret = NFC_Erase(cmd_list, SUPPORT_RB_IRQ);
+	NFC_DeSelectChip(chip);
+	NFC_DeSelectRb(rb);
+
+	if (ret == -ERR_TIMEOUT)
+		PHY_ERR("PHY_BlockErase : erase timeout\n");
+	return ret;
+}
+
+__s32 _read_sectors(struct boot_physical_param *readop,__u8 dma_wait_mode)
+{
+       __s32 ret;
+	__u32  k;
+	__u32 rb;
+	__u32 random_seed;
+	__u8 sparebuf[4*16];
+	__u8 default_value[16];
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i;
+	__u8 *data_buf;
+
+	data_buf = PageCachePool.TmpPageCache;
+	//data_buf = (__u8 *)MALLOC(SECTOR_CNT_OF_SINGLE_PAGE*512);
+
+	//sparebuf = (__u8 *)MALLOC(SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	/*create cmd list*/
+	/*samll block*/
+	if (SECTOR_CNT_OF_SINGLE_PAGE == 1){
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,4);
+		_add_cmd_list(cmd_list,0x00,4,addr,NFC_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_WAIT_RB);
+	}
+	/*large block*/
+	else{
+		/*the cammand have no corresponding feature if IGNORE was set, */
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,5);
+		_add_cmd_list(cmd_list,0x00,5,addr,NFC_NO_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_NO_WAIT_RB);
+
+	}
+	_add_cmd_list(cmd_list + 1,0x05,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 2,0xe0,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 3,0x30,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	list_len = 4;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	/*wait rb ready*/
+	ret = _wait_rb_ready(readop->chip);
+	if (ret)
+		return ret;
+
+	rb = _cal_real_rb(readop->chip);
+	NFC_SelectChip(readop->chip);
+	NFC_SelectRb(rb);
+
+    if(SUPPORT_READ_RETRY)
+    {
+    	if((READ_RETRY_MODE>=0x10)&&(READ_RETRY_MODE<0x30))  //toshiba & samsung mode
+            RetryCount[readop->chip] = 0;
+
+        for( k = 0; k<(READ_RETRY_CYCLE+1);k++)
+		{
+
+			if(RetryCount[readop->chip]==(READ_RETRY_CYCLE+1))
+				RetryCount[readop->chip] = 0;
+
+			if(k>0)
+			{
+			    if(NFC_ReadRetry(readop->chip,RetryCount[readop->chip], READ_RETRY_TYPE))
+			    {
+			        PHY_ERR("[Read_sectors] NFC_ReadRetry fail \n");
+			        return -1;
+			    }
+			}
+
+			if(SUPPORT_RANDOM)
+			{
+				random_seed = _cal_random_seed(readop->page);
+				NFC_SetRandomSeed(random_seed);
+				NFC_RandomEnable();
+				ret = NFC_Read(cmd_list, data_buf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+				NFC_RandomDisable();
+				if(ret == -ERR_ECC)
+					ret = NFC_Read(cmd_list, data_buf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+
+					/**************************************************************************************
+					* 1. add by Neil, from v2.09
+					* 2. if spare area is all 0xff in random disable mode, it means the page is a clear page
+					* 3. because in toshiba 24nm nand, too many clear pages are not all 0xff
+					***************************************************************************************/
+					if((ret == -ERR_ECC)&&(sparebuf[0]==0xff)&&(sparebuf[1]==0xff)&&(sparebuf[2]==0xff)&&(sparebuf[3]==0xff)&&(sparebuf[4]==0xff)&&(sparebuf[5]==0xff)&&(sparebuf[6]==0xff)&&(sparebuf[7]==0xff))
+					{
+						//PHY_DBG("[Read_sectors] find not all 0xff clear page!  chip = %d, block = %d, page = %d\n", readop->chip, readop->block, readop->page);
+						ret = 0;
+					}
+			}
+			else
+			{
+				ret = NFC_Read(cmd_list, data_buf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+			}
+
+			if((ret != -ERR_ECC)||(k==(READ_RETRY_CYCLE)))
+			{
+			    if((READ_RETRY_MODE>=0x10)&&(READ_RETRY_MODE<0x20))  //toshiba mode
+			    {
+    			    //exit toshiba readretry
+    				PHY_ResetChip(readop->chip);
+			    }
+			    else if((READ_RETRY_MODE>=0x20)&&(READ_RETRY_MODE<0x30))   //samsung mode
+			    {
+			        NFC_SetDefaultParam(readop->chip, default_value, READ_RETRY_TYPE);
+			    }
+
+				break;
+			}
+
+			 RetryCount[readop->chip]++;
+
+
+		}
+
+        if(k>0)
+    	{
+    		PHY_DBG("[Read_sectors] NFC_ReadRetry %d cycles, chip = %d, block = %d, page = %d, RetryCount = %d  \n", k ,readop->chip,readop->block, readop->page, RetryCount[readop->chip]);
+    		if(ret == -ERR_ECC)
+    		    PHY_DBG("ecc error!\n");
+    		PHY_DBG("spare buf: %x, %x, %x, %x, %x, %x, %x, %x\n", sparebuf[0],sparebuf[1],sparebuf[2],sparebuf[3],sparebuf[4],sparebuf[5],sparebuf[6],sparebuf[7]);
+    	}
+
+	    if(ret == ECC_LIMIT)
+		    ret =0;
+
+    }
+    else
+    {
+
+		if(SUPPORT_RANDOM)
+        {
+			random_seed = _cal_random_seed(readop->page);
+			NFC_SetRandomSeed(random_seed);
+			NFC_RandomEnable();
+			ret = NFC_Read(cmd_list, data_buf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+			NFC_RandomDisable();
+			if(ret == -ERR_ECC)
+				ret = NFC_Read(cmd_list, data_buf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+
+		}
+		else
+		{
+			ret = NFC_Read(cmd_list, data_buf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+		}
+
+
+    }
+
+	if (dma_wait_mode)
+		_pending_dma_irq_sem();
+
+	if (readop->oobbuf){
+		MEMCPY(readop->oobbuf,sparebuf, 2 * 4);
+	}
+
+	for (i = 0; i < SECTOR_CNT_OF_SINGLE_PAGE; i++){
+		if (readop->sectorbitmap & (1 << i)){
+			MEMCPY( (__u8 *)readop->mainbuf+i*512,data_buf+i*512, 512);
+			}
+		}
+
+	NFC_DeSelectChip(readop->chip);
+	NFC_DeSelectRb(rb);
+
+	//FREE(data_buf,SECTOR_CNT_OF_SINGLE_PAGE*512);
+	return ret;
+
+
+
+}
+
+/*********************************************************************
+**************************two plane read operation***********************
+***********************************************************************/
+__s32 _two_plane_read(struct __PhysicOpPara_t *pPageAdr,__u8 dma_wait_mode)
+{
+	__u8 addr[2][5];
+	__s32 ret;
+	__u32 chip;
+	__u32 rb;
+	__u32 list_len,i,plane_cnt;
+	__u32 bitmap_in_single_page;
+	__u32 block_in_chip;
+
+	NFC_CMD_LIST cmd_list[8];
+	struct boot_physical_param readop;
+
+	/*get chip no*/
+	chip = _cal_real_chip(pPageAdr->BankNum);
+	if (0xff == chip){
+		PHY_ERR("PHY_PageRead : beyond chip count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	/*get block no within chip*/
+	block_in_chip = _cal_block_in_chip(pPageAdr->BankNum,pPageAdr->BlkNum);
+	if (0xffffffff == block_in_chip){
+		PHY_ERR("PHY_PageRead : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	plane_cnt = SUPPORT_MULTI_PROGRAM ? PLANE_CNT_OF_DIE : 1;
+
+	/*create cmd list*/
+	/*send 0x60+3addr - 0x60 + 3addr - 0x30 for samsung 4k page*/
+	for(i = 0; i< plane_cnt; i++){
+		_cal_addr_in_chip(block_in_chip+i*MULTI_PLANE_BLOCK_OFFSET, pPageAdr->PageNum,0,addr[i],3);
+		_add_cmd_list(cmd_list+i, 0x60,3,addr[i],NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+	}
+	_add_cmd_list(cmd_list+i,0x30, 0,NFC_IGNORE,NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_WAIT_RB);
+	list_len = plane_cnt + 1;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+	rb = _cal_real_rb(chip);
+	NFC_SelectChip(chip);
+	NFC_SelectRb(rb);
+	ret = _wait_rb_ready(chip);
+	if (ret)
+		return ret;
+
+	ret = NFC_Read(cmd_list, NULL, NULL, 0,NFC_NORMAL_MODE);
+
+	/*send 0x00 +5addr --(05+2addr-e0...)*/
+	for (i = 0; i < plane_cnt; i++){
+		/*init single page operation param*/
+		readop.chip = chip;
+		readop.block = block_in_chip+ i*MULTI_PLANE_BLOCK_OFFSET;
+		readop.page = pPageAdr->PageNum;
+		readop.mainbuf = (__u8 *)(pPageAdr->MDataPtr) + 512*SECTOR_CNT_OF_SINGLE_PAGE*i;
+		if (pPageAdr->SDataPtr)
+			readop.oobbuf = (__u8 *)(pPageAdr->SDataPtr) + 4*SECTOR_CNT_OF_SINGLE_PAGE*i;
+
+
+		bitmap_in_single_page = FULL_BITMAP_OF_SINGLE_PAGE &
+			(pPageAdr->SectBitmap >> (i*SECTOR_CNT_OF_SINGLE_PAGE));
+		readop.sectorbitmap = bitmap_in_single_page;
+		ret |= _read_sectors(&readop,dma_wait_mode);
+	}
+	NFC_DeSelectChip(chip);
+	NFC_DeSelectRb(rb);
+	return ret;
+}
+/*
+************************************************************************************************************************
+*                       READ NAND FLASH PHYSICAL PAGE DATA
+*
+*Description: Read a page from a nand flash physical page to buffer.
+*
+*Arguments  : pPageAdr      the po__s32er to the accessed page parameter.
+*
+*Return     : the result of physical page read;
+*               = 0     read physical page successful;
+*               > 0     read physical page successful, but need do some process;
+*               < 0     read physical page failed.
+************************************************************************************************************************
+*/
+__s32  PHY_PageRead(struct __PhysicOpPara_t *pPageAdr)
+{
+	__s32 ret;
+	__u32 chip;
+	__u32 block_in_chip;
+	__u32 plane_cnt,i;
+	__u32 bitmap_in_single_page;
+	struct boot_physical_param readop;
+
+	/*create cmd list*/
+	if (SUPPORT_MULTI_READ){
+	/*two plane read */
+		ret = _two_plane_read(pPageAdr,SUPPORT_DMA_IRQ);
+		goto PHY_PageRead_exit;
+	}
+
+	ret = 0;
+	plane_cnt = SUPPORT_MULTI_PROGRAM ? PLANE_CNT_OF_DIE : 1;
+
+	/*get chip no*/
+	chip = _cal_real_chip(pPageAdr->BankNum);
+	if (0xff == chip){
+		PHY_ERR("PHY_PageRead : beyond chip count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	/*get block no within chip*/
+	block_in_chip = _cal_block_in_chip(pPageAdr->BankNum,pPageAdr->BlkNum);
+	if (0xffffffff == block_in_chip){
+		PHY_ERR("PHY_PageRead : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+
+	for (i = 0; i < plane_cnt; i++){
+		/*init single page operation param*/
+		readop.chip = chip;
+		readop.block = block_in_chip  + i*MULTI_PLANE_BLOCK_OFFSET;
+		readop.page = pPageAdr->PageNum;
+
+			readop.mainbuf = (__u8 *)(pPageAdr->MDataPtr) + 512*SECTOR_CNT_OF_SINGLE_PAGE*i;
+		    if (pPageAdr->SDataPtr)
+			    readop.oobbuf = (__u8 *)(pPageAdr->SDataPtr) + 4*SECTOR_CNT_OF_SINGLE_PAGE*i;
+		    else
+			    readop.oobbuf = NULL;
+
+		bitmap_in_single_page = FULL_BITMAP_OF_SINGLE_PAGE &
+			(pPageAdr->SectBitmap >> (i*SECTOR_CNT_OF_SINGLE_PAGE));
+		readop.sectorbitmap = bitmap_in_single_page;
+
+		if (bitmap_in_single_page){
+		/*bitmap of this plane is valid */
+			if(bitmap_in_single_page == FULL_BITMAP_OF_SINGLE_PAGE)
+			/*align page, use page mode */
+				ret |= _read_single_page(&readop,SUPPORT_DMA_IRQ);
+			else
+			/*not align page , normal mode*/
+				ret |= _read_sectors(&readop,SUPPORT_DMA_IRQ);
+		}
+	}
+
+PHY_PageRead_exit:
+	if (ret == -ERR_TIMEOUT)
+		PHY_ERR("PHY_PageRead : read timeout\n");
+	if (ret == -ERR_ECC)
+	{
+		PHY_ERR("PHY_PageRead : too much ecc err,bank %x block %x,page %x \n",pPageAdr->BankNum,pPageAdr->BlkNum,
+					pPageAdr->PageNum);
+		ret = 0;
+	}
+
+	if(ret == ECC_LIMIT)
+	{
+		PHY_ERR("%s : %d : ecc limit\n",__FUNCTION__,__LINE__);
+	}
+	return ret;
+}
+
+
+void _cal_addr_in_chip_for_spare(__u32 block, __u32 page, __u32 sector,__u8 *addr, __u8 cycle)
+{
+	__u32 row;
+	__u32 column;
+	#if 0
+	__u32 ecc_size;
+
+	if(NandStorageInfo.EccMode == 0)
+	  ecc_size = 32;
+	else if(NandStorageInfo.EccMode == 1)
+	  ecc_size = 53;
+	else if(NandStorageInfo.EccMode == 2)
+	  ecc_size = 60;
+	else
+	  ecc_size = 32;
+	#endif
+
+	//column = (1024 + ecc_size)* (sector>>1);
+	column = 1024* (sector>>1);
+	row = block * PAGE_CNT_OF_PHY_BLK + page;
+
+	switch(cycle){
+		case 1:
+			addr[0] = 0x00;
+			break;
+		case 2:
+			addr[0] = column & 0xff;
+			addr[1] = (column >> 8) & 0xff;
+			break;
+		case 3:
+			addr[0] = row & 0xff;
+			addr[1] = (row >> 8) & 0xff;
+			addr[2] = (row >> 16) & 0xff;
+			break;
+		case 4:
+			addr[0] = column && 0xff;
+			addr[1] = (column >> 8) & 0xff;
+			addr[2] = row & 0xff;
+			addr[3] = (row >> 8) & 0xff;
+			break;
+		case 5:
+			addr[0] = column & 0xff;
+			addr[1] = (column >> 8) & 0xff;
+			addr[2] = row & 0xff;
+			addr[3] = (row >> 8) & 0xff;
+			addr[4] = (row >> 16) & 0xff;
+			break;
+		default:
+			break;
+	}
+
+}
+
+
+
+__s32 _read_sectors_for_spare(struct boot_physical_param *readop,__u8 dma_wait_mode)
+{
+	__u8 sparebuf[4*2];
+	__u8 default_value[16];
+	__u8 addr[5];
+	__u8 addr1[2],addr2[2];
+	__u32 column;
+	__u32 list_len,i,j, k;
+	__u32 rb;
+	__s32 ret, ret1 , free_page_flag, read_retry_exit_flag;
+	__u32 ecc_size;
+	__s32 random_seed;
+	NFC_CMD_LIST cmd_list[4];
+
+	if(NandStorageInfo.EccMode == 0)
+	  ecc_size = 32;
+	else if(NandStorageInfo.EccMode == 1)
+	  ecc_size = 46;
+	else if(NandStorageInfo.EccMode == 2)
+	  ecc_size = 54;
+	else if(NandStorageInfo.EccMode == 3)
+	  ecc_size = 60;
+	else
+	  ecc_size = 32;
+
+	for(i=0; i<8; i++)
+		sparebuf[i] = 0x3e;
+
+	ret = 0;
+	ret1 = 0;
+	read_retry_exit_flag = 0;
+
+	_cal_addr_in_chip(readop->block,readop->page, 0, addr, 5);
+	_add_cmd_list(cmd_list,0x00,5,addr, NFC_NO_DATA_FETCH,NFC_IGNORE,NFC_IGNORE, NFC_IGNORE);
+	if (SUPPORT_MULTI_READ){
+	/*send 0x00 + 5addr*/
+		list_len = 1;
+	}
+	else{
+	/*send 0x00 + 5addr --- 0x30*/
+		list_len = 2;
+		_add_cmd_list(cmd_list + 1,0x30,0,NFC_IGNORE,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE,NFC_WAIT_RB);
+	}
+
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	/*wait rb ready*/
+	ret = _wait_rb_ready(readop->chip);
+	if (ret)
+		return ret;
+
+	rb = _cal_real_rb(readop->chip);
+	NFC_SelectChip(readop->chip);
+	NFC_SelectRb(rb);
+
+	ret = NFC_Read(cmd_list, NULL, NULL, 0 , NFC_NORMAL_MODE);
+
+	/*send 05 + 2addr- e0 get 512 byte data*/
+	list_len = 4;
+	for (i = 0; i < 2; i++){
+		if (readop->sectorbitmap & (1 << i)){
+
+			/*get main data addr*/
+			_cal_addr_in_chip_for_spare(0,0,i<<1,addr1,2);
+			/*get spare data addr*/
+			//column = (1024 + ecc_size)*i +1024;
+			column = 512*SECTOR_CNT_OF_SINGLE_PAGE + i*ecc_size;
+			addr2[0] = column & 0xff;
+			addr2[1] = (column >> 8) & 0xff;
+
+			_add_cmd_list(cmd_list, 0x05, 2, addr1,NFC_NO_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+			_add_cmd_list(cmd_list+1,0xe0, 0,NFC_IGNORE,NFC_DATA_FETCH,NFC_MAIN_DATA_FETCH,1024,NFC_NO_WAIT_RB);
+			_add_cmd_list(cmd_list+2,0x05,2,addr2,NFC_NO_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+			_add_cmd_list(cmd_list+3,0xe0, 0,NFC_IGNORE,NFC_DATA_FETCH,NFC_SPARE_DATA_FETCH,NFC_IGNORE,NFC_NO_WAIT_RB);
+			for(j = 0; j < list_len - 1; j++){
+				cmd_list[j].next = &(cmd_list[j+1]);
+			}
+			if (_wait_rb_ready(readop->chip))
+				return ERR_TIMEOUT;
+
+	        if(SUPPORT_READ_RETRY)
+	        {
+                if((READ_RETRY_MODE>=0x10)&&(READ_RETRY_MODE<0x30))  //toshiba & samsung mode
+                    RetryCount[readop->chip] = 0;
+
+                for( k = 0; k<(READ_RETRY_CYCLE+1);k++)
+	    		{
+	    			if(RetryCount[readop->chip]==(READ_RETRY_CYCLE+1))
+	    				RetryCount[readop->chip] = 0;
+
+	    			if(k>0)
+	    			{
+	    			    if(NFC_ReadRetry(readop->chip,RetryCount[readop->chip],READ_RETRY_TYPE))
+	    			    {
+	    			        PHY_ERR("[Read_sectors] NFC_ReadRetry fail \n");
+	    			        return -1;
+	    			    }
+	    			}
+
+					if(SUPPORT_RANDOM)
+	    			{
+	    				random_seed = _cal_random_seed(readop->page);
+	    				NFC_SetRandomSeed(random_seed);
+	    				NFC_RandomEnable();
+	    				free_page_flag = 0;
+	    				ret1 = NFC_Read(cmd_list, (__u8 *)(readop->mainbuf)+i*1024,sparebuf+4*i, dma_wait_mode , NFC_NORMAL_MODE);
+	    				if(readop->page == 0)
+    					{
+    						if((sparebuf[4*i] == 0x0a)&&(sparebuf[4*i+1] == 0x53)&&(sparebuf[4*i+2] == 0xb8)&&(sparebuf[4*i+3] == 0xc2))
+    							free_page_flag = 1;
+
+    					}
+    					else if((readop->page%128) == 127)
+    					{
+    						if((sparebuf[4*i] == 0x32)&&(sparebuf[4*i+1] == 0x43)&&(sparebuf[4*i+2] == 0xaa)&&(sparebuf[4*i+3] == 0x4e))
+    							free_page_flag = 1;
+
+    					}
+
+    					if(free_page_flag)
+    					{
+    						ret1 = 0;
+    						sparebuf[4*i] = 0xff;
+    						sparebuf[4*i+1] = 0xff;
+    						sparebuf[4*i+2] = 0xff;
+    						sparebuf[4*i+3] = 0xff;
+    					}
+	    				NFC_RandomDisable();
+	    				if(ret1 == -ERR_ECC)
+	    					ret1 = NFC_Read(cmd_list, (__u8 *)(readop->mainbuf)+i*1024,sparebuf+4*i, dma_wait_mode , NFC_NORMAL_MODE);
+
+	    			    	/**************************************************************************************
+							* 1. add by Neil, from v2.09
+							* 2. if spare area is all 0xff in random disable mode, it means the page is a clear page
+							* 3. because in toshiba 24nm nand, too many clear pages are not all 0xff
+							***************************************************************************************/
+							if((ret1 == -ERR_ECC)&&(sparebuf[4*i]==0xff)&&(sparebuf[4*i+1]==0xff)&&(sparebuf[4*i+2]==0xff)&&(sparebuf[4*i+3]==0xff))
+							{
+								//PHY_DBG("[Read_sectors_for_spare] find not all 0xff clear page!  chip = %d, block = %d, page = %d\n, i = %d", readop->chip, readop->block, readop->page, i);
+								ret1 = 0;
+							}
+	    			}
+	    			else
+	    			{
+	    				ret1 = NFC_Read(cmd_list, (__u8 *)(readop->mainbuf)+i*1024,sparebuf+4*i, dma_wait_mode , NFC_NORMAL_MODE);
+	    			}
+
+	    			if((ret1 != -ERR_ECC)||(k==(READ_RETRY_CYCLE)))
+	    			{
+	    			    if((READ_RETRY_MODE>=0x10)&&(READ_RETRY_MODE<0x20))  //toshiba mode
+	    			    {
+    	    			    //exit toshiba readretry
+    	    			    read_retry_exit_flag = 1;
+	    			    }
+	    			    else if((READ_RETRY_MODE>=0x20)&&(READ_RETRY_MODE<0x30))   //samsung mode
+        			    {
+        			        NFC_SetDefaultParam(readop->chip, default_value, READ_RETRY_TYPE);
+        			    }
+
+	    				break;
+	    			}
+
+	    			RetryCount[readop->chip]++;
+	    		}
+
+    		    if(k>0)
+            	{
+            		PHY_DBG("[Read_sectors_for_spare] NFC_ReadRetry %d cycles, chip = %d, block = %d, page = %d, RetryCount = %d, i=%d  \n", k ,readop->chip,readop->block, readop->page, RetryCount[readop->chip], i);
+            		if(ret1 == -ERR_ECC)
+            		    PHY_DBG("ecc error!\n");
+            		PHY_DBG("spare buf: %x, %x, %x, %x\n", sparebuf[4*i],sparebuf[4*i+1],sparebuf[4*i+2],sparebuf[4*i+3]);
+            	}
+
+    			if(ret1 == ECC_LIMIT)
+    				ret1 = 0;
+	        }
+	        else
+	        {
+				if(SUPPORT_RANDOM)
+	            {
+	    			random_seed = _cal_random_seed(readop->page);
+	    			NFC_SetRandomSeed(random_seed);
+	    			NFC_RandomEnable();
+					free_page_flag = 0;
+	    			ret1 = NFC_Read(cmd_list, (__u8 *)(readop->mainbuf)+i*1024,sparebuf+4*i, dma_wait_mode , NFC_NORMAL_MODE);
+					if(readop->page == 0)
+					{
+						if((sparebuf[4*i] == 0x0a)&&(sparebuf[4*i+1] == 0x53)&&(sparebuf[4*i+2] == 0xb8)&&(sparebuf[4*i+3] == 0xc2))
+							free_page_flag = 1;
+
+					}
+					else if((readop->page%128) == 127)
+					{
+						if((sparebuf[4*i] == 0x32)&&(sparebuf[4*i+1] == 0x43)&&(sparebuf[4*i+2] == 0xaa)&&(sparebuf[4*i+3] == 0x4e))
+							free_page_flag = 1;
+
+					}
+
+					if(free_page_flag)
+					{
+						ret1 = 0;
+						sparebuf[4*i] = 0xff;
+						sparebuf[4*i+1] = 0xff;
+						sparebuf[4*i+2] = 0xff;
+						sparebuf[4*i+3] = 0xff;
+					}
+	    			NFC_RandomDisable();
+	    			if(ret1 == -ERR_ECC)
+	    				ret1 = NFC_Read(cmd_list, (__u8 *)(readop->mainbuf)+i*1024,sparebuf+4*i, dma_wait_mode , NFC_NORMAL_MODE);
+				}
+	    		else
+	    		{
+	    			ret1 = NFC_Read(cmd_list, (__u8 *)(readop->mainbuf)+i*1024,sparebuf+4*i, dma_wait_mode , NFC_NORMAL_MODE);
+	    		}
+
+
+	        }
+
+			ret |= ret1;
+
+			if (dma_wait_mode)
+				_pending_dma_irq_sem();
+
+			if (readop->oobbuf){
+				MEMCPY((__u8 *)(readop->oobbuf)+4*i,sparebuf+4*i,4);
+			}
+		}
+
+	}
+
+	if(read_retry_exit_flag)
+	    PHY_ResetChip(readop->chip);
+
+	NFC_DeSelectChip(readop->chip);
+	NFC_DeSelectRb(rb);
+
+	return ret;
+}
+
+
+
+__s32  PHY_PageReadSpare(struct __PhysicOpPara_t *pPageAdr)
+{
+	__s32 ret;
+	__u32 chip;
+	__u32 block_in_chip;
+	__u32 plane_cnt,i;
+	__u32 bitmap_in_single_page;
+	struct boot_physical_param readop;
+
+
+	ret = 0;
+	plane_cnt = SUPPORT_MULTI_PROGRAM ? PLANE_CNT_OF_DIE : 1;
+
+	/*get chip no*/
+	chip = _cal_real_chip(pPageAdr->BankNum);
+	if (0xff == chip){
+		PHY_ERR("PHY_PageRead : beyond chip count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	/*get block no within chip*/
+	block_in_chip = _cal_block_in_chip(pPageAdr->BankNum,pPageAdr->BlkNum);
+	if (0xffffffff == block_in_chip){
+		PHY_ERR("PHY_PageRead : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+
+	for (i = 0; i < plane_cnt; i++){
+		/*init single page operation param*/
+		readop.chip = chip;
+		readop.block = block_in_chip  + i*MULTI_PLANE_BLOCK_OFFSET;
+		readop.page = pPageAdr->PageNum;
+
+		readop.mainbuf = (__u8 *)(pPageAdr->MDataPtr) + 512*SECTOR_CNT_OF_SINGLE_PAGE*i;
+	    if (pPageAdr->SDataPtr)
+		    readop.oobbuf = (__u8 *)(pPageAdr->SDataPtr) + 4*SECTOR_CNT_OF_SINGLE_PAGE*i;
+	    else
+		    readop.oobbuf = NULL;
+
+		bitmap_in_single_page = FULL_BITMAP_OF_SINGLE_PAGE &
+			(pPageAdr->SectBitmap >> (i*SECTOR_CNT_OF_SINGLE_PAGE));
+		readop.sectorbitmap = bitmap_in_single_page;
+
+		if (bitmap_in_single_page){
+		/*bitmap of this plane is valid */
+			if(bitmap_in_single_page == FULL_BITMAP_OF_SINGLE_PAGE)
+			/*align page, use page mode */
+				ret |= _read_single_page(&readop,SUPPORT_DMA_IRQ);
+			else
+			/*not align page , normal mode*/
+				ret |= _read_single_page_spare(&readop,SUPPORT_DMA_IRQ);
+		}
+	}
+
+	if (ret == -ERR_TIMEOUT)
+		PHY_ERR("PHY_PageReadSpare : read timeout\n");
+	if (ret == -ERR_ECC)
+	{
+		PHY_ERR("PHY_PageReadSpare : too much ecc err,bank %x block %x,page %x \n",pPageAdr->BankNum,pPageAdr->BlkNum,
+					pPageAdr->PageNum);
+		ret = 0;
+	}
+
+	if(ret == ECC_LIMIT)
+	{
+		PHY_ERR("%s : %d : ecc limit\n",__FUNCTION__,__LINE__);
+	}
+	return ret;
+}
+
+void PHY_FreePageCheck(struct __PhysicOpPara_t  *pPageAdr)
+{
+	__u8 oob[8];
+	__u32 i;
+
+	struct __PhysicOpPara_t  param = *pPageAdr;
+	param.MDataPtr = (__u8 *)MALLOC(1024);
+	param.SDataPtr = oob;
+	param.SectBitmap = 0x3;
+
+	PHY_PageRead(&param);
+	for(i = 0; i < 8; i++)
+	{
+		if( (i%4 != 3) && (oob[i] != 0xff))
+		{
+			PRINT("%s : sorry, you can not write in dirty page\n",__FUNCTION__);
+			PRINT("oob data : --%x--%x--%x--%x--%x--%x--\n",
+				oob[0],oob[1],oob[2],oob[4],oob[5],oob[6]);
+			while(1);
+		}
+	}
+
+	FREE(param.MDataPtr,1024);
+}
+
+/*
+************************************************************************************************************************
+*                       WRITE NAND FLASH PHYSICAL PAGE DATA
+*
+*Description: Write a page from buffer to a nand flash physical page.
+*
+*Arguments  : pPageAdr      the po__s32er to the accessed page parameter.
+*
+*Return     : The result of the page write;
+*               = 0     page write successful;
+*               > 0     page write successful, but need do some process;
+*               < 0     page write failed.
+************************************************************************************************************************
+*/
+__s32  PHY_PageWrite(struct __PhysicOpPara_t  *pPageAdr)
+{
+	__s32 ret;
+	__u32 chip;
+	__u32 block_in_chip;
+	__u32 plane_cnt,i;
+	__u32 program1,program2;
+	struct boot_physical_param writeop;
+
+	//PHY_FreePageCheck(pPageAdr);
+
+	ret = 0;
+	plane_cnt = SUPPORT_MULTI_PROGRAM ? PLANE_CNT_OF_DIE : 1;
+	/*get chip no*/
+	chip = _cal_real_chip(pPageAdr->BankNum);
+	if (0xff == chip){
+		PHY_ERR("PHY_PageWrite : beyond chip count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	/*get block no within chip*/
+	block_in_chip = _cal_block_in_chip(pPageAdr->BankNum,pPageAdr->BlkNum);
+	if (0xffffffff == block_in_chip){
+		PHY_ERR("PHY_PageWrite : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+
+	//_wait_rb_ready(chip);
+
+	for (i = 0; i < plane_cnt; i++){
+		if(i == 0)
+			_wait_rb_ready_int(chip);
+		else
+		_wait_rb_ready(chip);
+
+		/*init single page operation param*/
+		writeop.chip = chip;
+		writeop.block = block_in_chip + i*MULTI_PLANE_BLOCK_OFFSET;
+		writeop.page = pPageAdr->PageNum;
+
+		    writeop.mainbuf = (__u8 *)(pPageAdr->MDataPtr) + 512*SECTOR_CNT_OF_SINGLE_PAGE*i;
+		    if (pPageAdr->SDataPtr)
+			    writeop.oobbuf = (__u8 *)(pPageAdr->SDataPtr) + 4*SECTOR_CNT_OF_SINGLE_PAGE*i;
+		    else
+			    writeop.oobbuf = NULL;
+
+
+		writeop.sectorbitmap = FULL_BITMAP_OF_SINGLE_PAGE;
+		if (i == 0){
+			program1 = 0x80;
+			if (SUPPORT_MULTI_PROGRAM)
+				program2 = NandStorageInfo.OptPhyOpPar.MultiPlaneWriteCmd[0];
+			else
+				program2 = 0x10;
+		}
+		else{
+			program1 = NandStorageInfo.OptPhyOpPar.MultiPlaneWriteCmd[1];
+			program2 = 0x10;
+		}
+		ret |= _write_signle_page(&writeop,program1,program2,SUPPORT_DMA_IRQ,SUPPORT_RB_IRQ);
+
+	}
+	if (ret == -ERR_TIMEOUT)
+		PHY_ERR("PHY_PageWrite : write timeout\n");
+	return ret;
+}
+
+__s32 _single_copy_back(struct __PhysicOpPara_t *pSrcPage, struct __PhysicOpPara_t *pDstPage)
+{
+	__u8 addr[5];
+	__s32 ret;
+	__u32 chip;
+	__u32 rb;
+	__u32 src_block_in_chip,dst_block_in_chip;
+	__u32 list_len,i,addr_cycle;
+	NFC_CMD_LIST cmd_list[8];
+
+	/*get chip no*/
+	chip = _cal_real_chip(pSrcPage->BankNum);
+	if (0xff == chip){
+		PHY_ERR("single_copy_back : beyond chip count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	/*get block no within chip*/
+	src_block_in_chip = _cal_block_in_chip(pSrcPage->BankNum,pSrcPage->BlkNum);
+	if (0xffffffff == src_block_in_chip){
+		PHY_ERR("single_copy_back : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	dst_block_in_chip = _cal_block_in_chip(pDstPage->BankNum,pDstPage->BlkNum);
+	if (0xffffffff == dst_block_in_chip){
+		PHY_ERR("single_copy_back : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+
+
+	/*create cmd list*/
+	addr_cycle = (SECTOR_CNT_OF_SINGLE_PAGE == 1) ?4:5;
+	list_len = 2;
+	/*copy back read*/
+	_cal_addr_in_chip(src_block_in_chip,pSrcPage->PageNum,0,addr,addr_cycle);
+	_add_cmd_list(cmd_list, 0x00,addr_cycle,addr,NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list+1,0x35, 0,NFC_IGNORE,NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	_wait_rb_ready(chip);
+	rb = _cal_real_rb(chip);
+	NFC_SelectChip(chip);
+	NFC_SelectRb(rb);
+	ret = NFC_CopyBackRead(cmd_list);
+	if (ret)
+		return -1;
+	/*copy back write*/
+	_cal_addr_in_chip(dst_block_in_chip,pDstPage->PageNum,0,addr,addr_cycle);
+	_add_cmd_list(cmd_list, 0x85,addr_cycle,addr,NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list+1,0x10, 0,NFC_IGNORE,NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+	ret = NFC_CopyBackWrite(cmd_list,0);
+
+	NFC_DeSelectChip(chip);
+	NFC_DeSelectRb(rb);
+	return ret;
+}
+
+__s32 _multi_copy_back(struct __PhysicOpPara_t *pSrcPage, struct __PhysicOpPara_t *pDstPage)
+{
+	__u8 addr[2][5];
+	__s32 ret;
+	__u32 chip;
+	__u32 rb;
+	__u32 src_block_in_chip,dst_block_in_chip;
+	__u32 list_len,i,addr_cycle,plane_cnt;
+	__u32 program1,program2;
+	NFC_CMD_LIST cmd_list[8];
+
+	/*get chip no*/
+	chip = _cal_real_chip(pSrcPage->BankNum);
+	if (0xff == chip){
+		PHY_ERR("single_copy_back : beyond chip count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	/*get block no within chip*/
+	src_block_in_chip = _cal_block_in_chip(pSrcPage->BankNum,pSrcPage->BlkNum);
+	if (0xffffffff == src_block_in_chip){
+		PHY_ERR("single_copy_back : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+	dst_block_in_chip = _cal_block_in_chip(pDstPage->BankNum,pDstPage->BlkNum);
+	if (0xffffffff == dst_block_in_chip){
+		PHY_ERR("single_copy_back : beyond block of per chip  count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+
+	plane_cnt = SUPPORT_MULTI_PROGRAM ? PLANE_CNT_OF_DIE : 1;
+	/*create cmd list*/
+	addr_cycle = (SECTOR_CNT_OF_SINGLE_PAGE == 1) ?4:5;
+	/*copy back read*/
+	if (NandStorageInfo.OptPhyOpPar.MultiPlaneCopyReadCmd[0] == 0x60){
+
+		for(i = 0; i< plane_cnt; i++){
+			_cal_addr_in_chip(src_block_in_chip+i*MULTI_PLANE_BLOCK_OFFSET, pSrcPage->PageNum,0,addr[i],addr_cycle);
+			_add_cmd_list(cmd_list+i, 0x60,addr_cycle,addr[i],NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+		}
+		_add_cmd_list(cmd_list+i,0x35, 0,NFC_IGNORE,NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+		list_len = plane_cnt + 1;
+	}
+	else{
+
+		for(i = 0; i< plane_cnt; i++){
+			_cal_addr_in_chip(src_block_in_chip+i*MULTI_PLANE_BLOCK_OFFSET,pSrcPage->PageNum,0,addr[i],addr_cycle);
+			_add_cmd_list(cmd_list+2*i, 0x00,addr_cycle,addr[i],NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+			_add_cmd_list(cmd_list+2*i+1,0x35, 0,NFC_IGNORE,NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+		}
+		list_len = plane_cnt * 2;
+	}
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	_wait_rb_ready(chip);
+	rb = _cal_real_rb(chip);
+	NFC_SelectChip(chip);
+	NFC_SelectRb(rb);
+	ret = NFC_CopyBackRead(cmd_list);
+	if (ret)
+		return -1;
+
+	/*copy back write*/
+	for(i = 0; i< plane_cnt; i++){
+		_cal_addr_in_chip(dst_block_in_chip+i*MULTI_PLANE_BLOCK_OFFSET,pSrcPage->PageNum,0,addr[i],addr_cycle);
+		if (i == 0){
+			program1 = NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[0];
+			program2 = NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[1];
+		}
+		else{
+			program1 = NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[2];
+			program2 = 0x10;
+		}
+		_add_cmd_list(cmd_list+2*i, program1,addr_cycle,addr[i],NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+		_add_cmd_list(cmd_list+2*i+1,program2, 0,NFC_IGNORE,NFC_NO_DATA_FETCH,NFC_IGNORE, NFC_IGNORE,NFC_IGNORE);
+	}
+	list_len = plane_cnt * 2;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+	ret = NFC_CopyBackWrite(cmd_list,0);
+	NFC_DeSelectChip(chip);
+	NFC_DeSelectRb(rb);
+
+	return ret;
+
+}
+
+/*
+************************************************************************************************************************
+*                           PHYSIC PAGE COPY-BACK
+*
+*Description: copy one physical page from one physical block to another physical block.
+*
+*Arguments  : pSrcPage      the parameter of the source page which need be copied;
+*             pDstPage      the parameter of the destination page which copied to.
+*
+*Return     : the result of the page copy-back;
+*               = 0         page copy-back successful;
+*               = -1        page copy-back failed.
+************************************************************************************************************************
+*/
+__s32  PHY_PageCopyback(struct __PhysicOpPara_t *pSrcPage, struct __PhysicOpPara_t *pDstPage)
+{
+	__s32 ret;
+
+	if ( (!SUPPORT_PAGE_COPYBACK) || ((pSrcPage->PageNum + pDstPage->PageNum) & 0x1) ){
+	/*cant not use copyback*/
+		pSrcPage->SectBitmap = pDstPage->SectBitmap = FULL_BITMAP_OF_SUPER_PAGE;
+		pSrcPage->MDataPtr = pDstPage->MDataPtr = PHY_TMP_PAGE_CACHE;
+		pSrcPage->SDataPtr = pDstPage->SDataPtr = PHY_TMP_SPARE_CACHE;
+		ret = PHY_PageRead(pSrcPage);
+
+		//add in 2010-06-18 by penggang, the logic layer needn't care the ecc error
+		if(ret == -ERR_ECC)
+			ret = 0;
+
+		if (ret < 0){
+
+			goto PHY_PageCopyback_exit;
+		}
+		ret = PHY_PageWrite(pDstPage);
+		goto PHY_PageCopyback_exit;
+	}
+
+	/*use copyback*/
+	if (!SUPPORT_MULTI_PROGRAM)
+	/*do not support two-plane copyback*/
+		ret = _single_copy_back(pSrcPage,pDstPage);
+
+	else
+		ret = _multi_copy_back(pSrcPage,pDstPage);
+PHY_PageCopyback_exit:
+	if (ret == -ERR_TIMEOUT)
+		PHY_ERR("PHY_PageCopyback : copy back timeout\n");
+	return ret;
+}
+
+__s32 PHY_ScanDDRParam(void)
+{
+	__u32 i, j, k,chip = 0;
+	__u32 good_ddr_param[64];
+	__u32 good_ddr_param_cnt;
+	__u8* main_buf = (__u8 *)MALLOC(8192);
+	__u8  oob_buf[32];
+	struct boot_physical_param readop;
+	__s32 ret;
+	__u32 sum, ddr_param;
+
+	if(DDR_TYPE)
+	{
+	    for(k=0;k<NandStorageInfo.ChipCnt;k++)
+	    {
+	        chip = _cal_real_chip(k);
+            readop.chip = chip;
+            readop.block = 0;
+            readop.page = 0;
+            readop.sectorbitmap = 0x3;
+            readop.mainbuf = main_buf;
+            readop.oobbuf = oob_buf;
+
+            for(i=1;i<16;i++) //delay_mode
+            {
+
+                good_ddr_param_cnt = 0;
+                for(j=0;j<64;j++)
+                {
+                    PHY_DBG("(%d, %d) ", i, j);
+                    NFC_InitDDRParam(chip, ((i<<8)|j));
+                    ret = PHY_SimpleRead_1K(&readop);
+
+                    if(!ret) //find good ddr param
+                    {
+                        good_ddr_param[good_ddr_param_cnt] = ((i<<8)|j);
+                        good_ddr_param_cnt++;
+                        PHY_DBG(" ok\n");
+                    }
+                    else
+                    {
+                        PHY_DBG(" fail\n");
+                    }
+
+                }
+
+                if(good_ddr_param_cnt)
+                    break;
+            }
+
+            if(good_ddr_param_cnt)
+            {
+                sum = 0;
+                for(i=0;i<good_ddr_param_cnt;i++)
+                    sum += good_ddr_param[i];
+
+                ddr_param = sum/good_ddr_param_cnt;
+                NFC_InitDDRParam(chip, ddr_param);
+
+                PHY_DBG("PHY_ScanDDRParam, find a good ddr_param 0x%x in chip %d\n", ddr_param, chip);
+            }
+            else
+            {
+                PHY_ERR("PHY_ScanDDRParam, can't find a good ddr_param in chip %d\n", chip);
+                FREE(main_buf, 8192);
+                return -1;
+            }
+	    }
+
+    }
+
+    FREE(main_buf, 8192);
+    return 0;
+}
diff --git a/drivers/block/sunxi_nand/src/physic/nand_simple_r.c b/drivers/block/sunxi_nand/src/physic/nand_simple_r.c
new file mode 100644
index 0000000..a98850f6
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/physic/nand_simple_r.c
@@ -0,0 +1,985 @@
+/*
+ * drivers/block/sunxi_nand/src/physic/nand_simple_r.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_type.h"
+#include "../include/nand_physic.h"
+#include "../include/nand_simple.h"
+#include "../../nfc/nfc.h"
+#include "../../nfc/nfc_i.h"
+
+#include <linux/io.h>
+
+struct __NandStorageInfo_t  NandStorageInfo;
+struct __NandPageCachePool_t PageCachePool;
+__u32 RetryCount[8];
+const __u16 random_seed[128] = {
+    //0        1      2       3        4      5        6       7       8       9
+	0x2b75, 0x0bd0, 0x5ca3, 0x62d1, 0x1c93, 0x07e9, 0x2162, 0x3a72, 0x0d67, 0x67f9,
+    0x1be7, 0x077d, 0x032f, 0x0dac, 0x2716, 0x2436, 0x7922, 0x1510, 0x3860, 0x5287,
+    0x480f, 0x4252, 0x1789, 0x5a2d, 0x2a49, 0x5e10, 0x437f, 0x4b4e, 0x2f45, 0x216e,
+    0x5cb7, 0x7130, 0x2a3f, 0x60e4, 0x4dc9, 0x0ef0, 0x0f52, 0x1bb9, 0x6211, 0x7a56,
+    0x226d, 0x4ea7, 0x6f36, 0x3692, 0x38bf, 0x0c62, 0x05eb, 0x4c55, 0x60f4, 0x728c,
+    0x3b6f, 0x2037, 0x7f69, 0x0936, 0x651a, 0x4ceb, 0x6218, 0x79f3, 0x383f, 0x18d9,
+    0x4f05, 0x5c82, 0x2912, 0x6f17, 0x6856, 0x5938, 0x1007, 0x61ab, 0x3e7f, 0x57c2,
+    0x542f, 0x4f62, 0x7454, 0x2eac, 0x7739, 0x42d4, 0x2f90, 0x435a, 0x2e52, 0x2064,
+    0x637c, 0x66ad, 0x2c90, 0x0bad, 0x759c, 0x0029, 0x0986, 0x7126, 0x1ca7, 0x1605,
+    0x386a, 0x27f5, 0x1380, 0x6d75, 0x24c3, 0x0f8e, 0x2b7a, 0x1418, 0x1fd1, 0x7dc1,
+    0x2d8e, 0x43af, 0x2267, 0x7da3, 0x4e3d, 0x1338, 0x50db, 0x454d, 0x764d, 0x40a3,
+    0x42e6, 0x262b, 0x2d2e, 0x1aea, 0x2e17, 0x173d, 0x3a6e, 0x71bf, 0x25f9, 0x0a5d,
+    0x7c57, 0x0fbe, 0x46ce, 0x4939, 0x6b17, 0x37bb, 0x3e91, 0x76db
+};
+void __iomem *nand_base;
+
+/**************************************************************************
+************************* add one cmd to cmd list******************************
+****************************************************************************/
+void _add_cmd_list(NFC_CMD_LIST *cmd,__u32 value,__u32 addr_cycle,__u8 *addr,__u8 data_fetch_flag,
+					__u8 main_data_fetch,__u32 bytecnt,__u8 wait_rb_flag)
+{
+	cmd->addr = addr;
+	cmd->addr_cycle = addr_cycle;
+	cmd->data_fetch_flag = data_fetch_flag;
+	cmd->main_data_fetch = main_data_fetch;
+	cmd->bytecnt = bytecnt;
+	cmd->value = value;
+	cmd->wait_rb_flag = wait_rb_flag;
+	cmd->next = NULL;
+}
+
+/****************************************************************************
+*********************translate (block + page+ sector) into 5 bytes addr***************
+*****************************************************************************/
+void _cal_addr_in_chip(__u32 block, __u32 page, __u32 sector,__u8 *addr, __u8 cycle)
+{
+	__u32 row;
+	__u32 column;
+
+	column = 512 * sector;
+	row = block * PAGE_CNT_OF_PHY_BLK + page;
+
+	switch(cycle){
+		case 1:
+			addr[0] = 0x00;
+			break;
+		case 2:
+			addr[0] = column & 0xff;
+			addr[1] = (column >> 8) & 0xff;
+			break;
+		case 3:
+			addr[0] = row & 0xff;
+			addr[1] = (row >> 8) & 0xff;
+			addr[2] = (row >> 16) & 0xff;
+			break;
+		case 4:
+			addr[0] = column && 0xff;
+			addr[1] = (column >> 8) & 0xff;
+			addr[2] = row & 0xff;
+			addr[3] = (row >> 8) & 0xff;
+			break;
+		case 5:
+			addr[0] = column & 0xff;
+			addr[1] = (column >> 8) & 0xff;
+			addr[2] = row & 0xff;
+			addr[3] = (row >> 8) & 0xff;
+			addr[4] = (row >> 16) & 0xff;
+			break;
+		default:
+			break;
+	}
+
+}
+
+
+
+#if 0
+__u8 _cal_real_chip(__u32 global_bank)
+{
+	__u8 chip;
+	__u8 i,cnt;
+
+	cnt = 0;
+	chip = global_bank / BNK_CNT_OF_CHIP;
+
+	for (i = 0; i <MAX_CHIP_SELECT_CNT; i++ ){
+		if (CHIP_CONNECT_INFO & (1 << i)) {
+			cnt++;
+			if (cnt == (chip+1)){
+				chip = i;
+				return chip;
+			}
+		}
+	}
+
+	PHY_ERR("wrong chip number ,chip = %d, chip info = %x\n",chip,CHIP_CONNECT_INFO);
+
+	return 0xff;
+}
+#endif
+
+__u8 _cal_real_chip(__u32 global_bank)
+{
+	__u8 chip = 0;
+
+	if((RB_CONNECT_MODE == 0)&&(global_bank<=2))
+	{
+	    if(global_bank)
+		chip = 7;
+	    else
+		chip = 0;
+
+	    return chip;
+	}
+	if((RB_CONNECT_MODE == 1)&&(global_bank<=1))
+      	{
+      	    chip = global_bank;
+	    return chip;
+      	}
+	if((RB_CONNECT_MODE == 2)&&(global_bank<=2))
+      	{
+      	    chip = global_bank;
+	    return chip;
+      	}
+	if((RB_CONNECT_MODE == 3)&&(global_bank<=2))
+      	{
+      	    chip = global_bank*2;
+	    return chip;
+      	}
+	if((RB_CONNECT_MODE == 4)&&(global_bank<=4))
+      	{
+      	    switch(global_bank){
+		  case 0:
+		  	chip = 0;
+			break;
+		  case 1:
+		  	chip = 2;
+			break;
+		  case 2:
+		  	chip = 1;
+			break;
+		  case 3:
+		  	chip = 3;
+			break;
+		  default :
+		  	chip =0;
+	    }
+
+	    return chip;
+      	}
+	if((RB_CONNECT_MODE == 5)&&(global_bank<=4))
+      	{
+      	    chip = global_bank*2;
+
+	    return chip;
+      	}
+	if((RB_CONNECT_MODE == 8)&&(global_bank<=8))
+      	{
+      	    switch(global_bank){
+		  case 0:
+		  	chip = 0;
+			break;
+		  case 1:
+		  	chip = 2;
+			break;
+		  case 2:
+		  	chip = 1;
+			break;
+		  case 3:
+		  	chip = 3;
+			break;
+		  case 4:
+		  	chip = 4;
+			break;
+		  case 5:
+		  	chip = 6;
+			break;
+		  case 6:
+		  	chip = 5;
+			break;
+		  case 7:
+		  	chip = 7;
+			break;
+		  default : chip =0;
+
+	    }
+
+	    return chip;
+      	}
+
+
+
+	PHY_ERR("wrong chip number ,rb_mode = %d, bank = %d, chip = %d, chip info = %x\n",RB_CONNECT_MODE, global_bank, chip, CHIP_CONNECT_INFO);
+
+	return 0xff;
+}
+
+__u8 _cal_real_rb(__u32 chip)
+{
+	__u8 rb;
+
+
+	rb = 0;
+
+	if(RB_CONNECT_MODE == 0)
+      	{
+      	    rb = 0;
+      	}
+      if(RB_CONNECT_MODE == 1)
+      	{
+      	    rb = chip;
+      	}
+	if(RB_CONNECT_MODE == 2)
+      	{
+      	    rb = chip;
+      	}
+	if(RB_CONNECT_MODE == 3)
+      	{
+      	    rb = chip/2;
+      	}
+	if(RB_CONNECT_MODE == 4)
+      	{
+      	    rb = chip/2;
+      	}
+	if(RB_CONNECT_MODE == 5)
+      	{
+      	    rb = (chip/2)%2;
+      	}
+	if(RB_CONNECT_MODE == 8)
+      	{
+      	    rb = (chip/2)%2;
+      	}
+
+	if((rb!=0)&&(rb!=1))
+	{
+	    PHY_ERR("wrong Rb connect Mode, chip = %d ,RbConnectMode = %d \n",chip,RB_CONNECT_MODE);
+	    return 0xff;
+	}
+
+	return rb;
+}
+
+/*******************************************************************
+**********************get status**************************************
+********************************************************************/
+__s32 _read_status(__u32 cmd_value, __u32 nBank)
+{
+	/*get status*/
+	__u8 addr[5];
+	__u32 addr_cycle;
+	NFC_CMD_LIST cmd_list;
+
+	addr_cycle = 0;
+
+	if(!(cmd_value == 0x70 || cmd_value == 0x71))
+	{
+        	/* not 0x70 or 0x71, need send some address cycle */
+       	 if(cmd_value == 0x78)
+	 		addr_cycle = 3;
+       	 else
+       		addr_cycle = 1;
+      		 _cal_addr_in_chip(nBank*BLOCK_CNT_OF_DIE,0,0,addr,addr_cycle);
+	}
+	_add_cmd_list(&cmd_list, cmd_value, addr_cycle, addr, 1,NFC_IGNORE,1,NFC_IGNORE);
+	return (NFC_GetStatus(&cmd_list));
+
+}
+
+/********************************************************************
+***************************wait rb ready*******************************
+*********************************************************************/
+__s32 _wait_rb_ready(__u32 chip)
+{
+	__s32 timeout = 0xffff;
+	__u32 rb;
+
+
+      rb = _cal_real_rb(chip);
+
+
+	/*wait rb ready*/
+	while((timeout--) && (NFC_CheckRbReady(rb)));
+	if (timeout < 0)
+		return -ERR_TIMEOUT;
+
+	return 0;
+}
+
+__s32 _wait_rb_ready_int(__u32 chip)
+{
+	__u32 rb;
+
+    rb = _cal_real_rb(chip);
+    NFC_SelectRb(rb);
+
+    if(NFC_CheckRbReady(rb))
+    {
+       NAND_WaitRbReady();
+    }
+    else
+    {
+        //printk("fast rb ready \n");
+    }
+
+    while(NFC_CheckRbReady(rb))
+    {
+        printk("rb int error!\n");
+    }
+
+
+	return 0;
+}
+
+void _pending_dma_irq_sem(void)
+{
+	return;
+}
+
+void _random_seed_init(void)
+{
+
+}
+
+__u32 _cal_random_seed(__u32 page)
+{
+	__u32 randomseed;
+
+	randomseed = random_seed[page%128];
+
+	return randomseed;
+}
+
+__s32 _read_single_page(struct boot_physical_param *readop,__u8 dma_wait_mode)
+{
+	__s32 ret;
+	__u32 k = 0;
+	__u32 rb;
+	__u32 random_seed;
+	__u8 sparebuf[4*16];
+	__u8 default_value[16];
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i;
+
+	//sparebuf = (__u8 *)MALLOC(SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	/*create cmd list*/
+	/*samll block*/
+	if (SECTOR_CNT_OF_SINGLE_PAGE == 1){
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,4);
+		_add_cmd_list(cmd_list,0x00,4,addr,NFC_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_WAIT_RB);
+	}
+	/*large block*/
+	else{
+		/*the cammand have no corresponding feature if IGNORE was set, */
+		_cal_addr_in_chip(readop->block,readop->page,0,addr,5);
+		_add_cmd_list(cmd_list,0x00,5,addr,NFC_NO_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_NO_WAIT_RB);
+
+	}
+	_add_cmd_list(cmd_list + 1,0x05,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 2,0xe0,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 3,0x30,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	list_len = 4;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	/*wait rb ready*/
+	ret = _wait_rb_ready(readop->chip);
+	if (ret)
+		return ret;
+
+	rb = _cal_real_rb(readop->chip);
+	NFC_SelectChip(readop->chip);
+	NFC_SelectRb(rb);
+
+    if(SUPPORT_READ_RETRY)
+    {
+        if((READ_RETRY_MODE>=0x10)&&(READ_RETRY_MODE<0x30))  //toshiba & Samsung mode
+            RetryCount[readop->chip] = 0;
+
+        for( k = 0; k<READ_RETRY_CYCLE+1;k++)
+		{
+			if(RetryCount[readop->chip]==(READ_RETRY_CYCLE+1))
+				RetryCount[readop->chip] = 0;
+
+			if(k>0)
+			{
+			    if(NFC_ReadRetry(readop->chip,RetryCount[readop->chip],READ_RETRY_TYPE))
+			    {
+			        PHY_ERR("[Read_single_page] NFC_ReadRetry fail \n");
+			        return -1;
+			    }
+			}
+
+			if(SUPPORT_RANDOM)
+			{
+				random_seed = _cal_random_seed(readop->page);
+				NFC_SetRandomSeed(random_seed);
+				NFC_RandomEnable();
+				ret = NFC_Read(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+				NFC_RandomDisable();
+				if(ret == -ERR_ECC)
+					ret = NFC_Read(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+
+				/**************************************************************************************
+				* 1. add by Neil, from v2.09
+				* 2. if spare area is all 0xff in random disable mode, it means the page is a clear page
+				* 3. because in toshiba 24nm nand, too many clear pages are not all 0xff
+				***************************************************************************************/
+				if((ret == -ERR_ECC)&&(sparebuf[0]==0xff)&&(sparebuf[1]==0xff)&&(sparebuf[2]==0xff)&&(sparebuf[3]==0xff)&&(sparebuf[4]==0xff)&&(sparebuf[5]==0xff)&&(sparebuf[6]==0xff)&&(sparebuf[7]==0xff))
+				{
+					//PHY_DBG("[Read_single_page] find not all 0xff clear page!  chip = %d, block = %d, page = %d\n", readop->chip, readop->block, readop->page);
+					ret = 0;
+				}
+
+			}
+			else
+			{
+				ret = NFC_Read(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+			}
+
+			if((ret != -ERR_ECC)||(k==READ_RETRY_CYCLE))
+			{
+			    if((READ_RETRY_MODE>=0x10)&&(READ_RETRY_MODE<0x20))  //toshiba mode
+			    {
+    			    //exit toshiba readretry
+    				PHY_ResetChip(readop->chip);
+			    }
+			    else if((READ_RETRY_MODE>=0x20)&&(READ_RETRY_MODE<0x30))   //samsung mode
+			    {
+			        NFC_SetDefaultParam(readop->chip, default_value, READ_RETRY_TYPE);
+			    }
+
+				break;
+			}
+
+			RetryCount[readop->chip]++;
+		}
+
+    	if(k>0)
+    	{
+    		PHY_DBG("[Read_single_page] NFC_ReadRetry %d cycles, chip = %d, block = %d, page = %d, RetryCount = %d  \n", k ,readop->chip,readop->block, readop->page, RetryCount[readop->chip]);
+    		if(ret == -ERR_ECC)
+    		    PHY_DBG("ecc error!\n");
+    		PHY_DBG("spare buf: %x, %x, %x, %x, %x, %x, %x, %x\n", sparebuf[0],sparebuf[1],sparebuf[2],sparebuf[3],sparebuf[4],sparebuf[5],sparebuf[6],sparebuf[7]);
+    	}
+
+    	if(ret == ECC_LIMIT)
+    		ret = 0;
+
+
+    }
+    else
+    {
+		if(SUPPORT_RANDOM)
+        {
+			random_seed = _cal_random_seed(readop->page);
+			NFC_SetRandomSeed(random_seed);
+			NFC_RandomEnable();
+			ret = NFC_Read(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+			NFC_RandomDisable();
+			if(ret == -ERR_ECC)
+				ret = NFC_Read(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+		}
+		else
+		{
+			ret = NFC_Read(cmd_list, readop->mainbuf, sparebuf, dma_wait_mode , NFC_PAGE_MODE);
+		}
+
+    }
+
+	if (dma_wait_mode)
+		_pending_dma_irq_sem();
+
+	if (readop->oobbuf){
+		MEMCPY(readop->oobbuf,sparebuf, 2 * 4);
+	}
+
+	NFC_DeSelectChip(readop->chip);
+	NFC_DeSelectRb(rb);
+
+	//FREE(sparebuf);
+	return ret;
+}
+
+
+
+/*
+************************************************************************************************************************
+*                       INIT NAND FLASH DRIVER PHYSICAL MODULE
+*
+* Description: init nand flash driver physical module.
+*
+* Aguments   : none
+*
+* Returns    : the resutl of initial.
+*                   = 0     initial successful;
+*                   = -1    initial failed.
+************************************************************************************************************************
+*/
+__s32 PHY_Init(void)
+{
+    __s32 ret;
+    __u32 i;
+	NFC_INIT_INFO nand_info;
+    //init RetryCount
+    for(i=0; i<8; i++)
+        RetryCount[i] = 0;
+	nand_info.bus_width = 0x0;
+	nand_info.ce_ctl = 0x0;
+	nand_info.ce_ctl1 = 0x0;
+	nand_info.debug = 0x0;
+	nand_info.pagesize = 4;
+	nand_info.rb_sel = 1;
+	nand_info.serial_access_mode = 1;
+	nand_info.ddr_type = 0;
+	ret = NFC_Init(&nand_info);
+
+    PHY_DBG("NFC Randomizer start. \n");
+	_random_seed_init();
+	NFC_RandomDisable();
+
+	return ret;
+}
+
+__s32 PHY_GetDefaultParam(__u32 bank)
+{
+	__u32 chip = 0;
+	__u8 default_value[16];
+
+	if(SUPPORT_READ_RETRY)
+	{
+	     if(READ_RETRY_MODE<0x10)  //hynix mode
+	     {
+            chip = _cal_real_chip(bank);
+            NFC_SelectChip(chip);
+            NFC_GetDefaultParam(chip, default_value, READ_RETRY_TYPE);
+        	NFC_SetDefaultParam(chip, default_value, READ_RETRY_TYPE);
+            PHY_DBG("PHY_GetDefaultParam: chip 0x%x, Read Retry Default Value is 0x%x, 0x%x, 0x%x, 0x%x \n", chip, default_value[0], default_value[1], default_value[2],default_value[3]);
+        }
+    }
+
+    return 0;
+}
+
+__s32 PHY_SetDefaultParam(__u32 bank)
+{
+	__u32 chip = 0;
+	__u8 default_value[16];
+	__u8 temp_value[16];
+
+	if(SUPPORT_READ_RETRY)
+	{
+	     if(READ_RETRY_MODE<0x10)  //hynix mode
+	     {
+        	chip = _cal_real_chip(bank);
+            NFC_SelectChip(chip);
+            NFC_SetDefaultParam(chip, default_value, READ_RETRY_TYPE);
+        	PHY_DBG("PHY_SetDefaultParam: Read Retry Type is : 0x%x \n", READ_RETRY_TYPE);
+            PHY_DBG("PHY_SetDefaultParam: chip 0x%x, Read Retry Default Value is 0x%x, 0x%x, 0x%x, 0x%x \n", chip, default_value[0], default_value[1], default_value[2],default_value[3]);
+        	NFC_GetDefaultParam(chip, temp_value, READ_RETRY_TYPE);
+            PHY_DBG("PHY_SetDefaultParam: chip 0x%x, Read Default Value After Set value is 0x%x, 0x%x, 0x%x, 0x%x \n", chip, temp_value[0], temp_value[1], temp_value[2],temp_value[3]);
+
+        }
+    }
+    return 0;
+}
+
+__s32 PHY_ChangeMode(__u8 serial_mode)
+{
+
+	NFC_INIT_INFO nand_info;
+
+	/*memory allocate*/
+	if (!PageCachePool.PageCache0){
+		PageCachePool.PageCache0 = (__u8 *)MALLOC(SECTOR_CNT_OF_SUPER_PAGE * 512);
+		if (!PageCachePool.PageCache0)
+			return -1;
+	}
+
+	if (!PageCachePool.SpareCache){
+		PageCachePool.SpareCache = (__u8 *)MALLOC(SECTOR_CNT_OF_SUPER_PAGE * 4);
+		if (!PageCachePool.SpareCache)
+			return -1;
+	}
+
+	if (!PageCachePool.TmpPageCache){
+		PageCachePool.TmpPageCache = (__u8 *)MALLOC(SECTOR_CNT_OF_SUPER_PAGE * 512);
+		if (!PageCachePool.TmpPageCache)
+			return -1;
+	}
+
+    NFC_SetEccMode(ECC_MODE);
+
+	nand_info.bus_width = 0x0;
+	nand_info.ce_ctl = 0x0;
+	nand_info.ce_ctl1 = 0x0;
+	nand_info.debug = 0x0;
+	nand_info.pagesize = SECTOR_CNT_OF_SINGLE_PAGE;
+	nand_info.serial_access_mode = serial_mode;
+	nand_info.ddr_type = DDR_TYPE;
+	return (NFC_ChangMode(&nand_info));
+}
+
+
+/*
+************************************************************************************************************************
+*                       NAND FLASH DRIVER PHYSICAL MODULE EXIT
+*
+* Description: nand flash driver physical module exit.
+*
+* Aguments   : none
+*
+* Returns    : the resutl of exit.
+*                   = 0     exit successful;
+*                   = -1    exit failed.
+************************************************************************************************************************
+*/
+__s32 PHY_Exit(void)
+{
+    __u32 i = 0;
+
+	if (PageCachePool.PageCache0){
+		FREE(PageCachePool.PageCache0,SECTOR_CNT_OF_SUPER_PAGE * 512);
+		PageCachePool.PageCache0 = NULL;
+	}
+	if (PageCachePool.SpareCache){
+		FREE(PageCachePool.SpareCache,SECTOR_CNT_OF_SUPER_PAGE * 4);
+		PageCachePool.SpareCache = NULL;
+	}
+	if (PageCachePool.TmpPageCache){
+		FREE(PageCachePool.TmpPageCache,SECTOR_CNT_OF_SUPER_PAGE * 512);
+		PageCachePool.TmpPageCache = NULL;
+	}
+
+	if(SUPPORT_READ_RETRY)
+	{
+	    for(i=0; i<NandStorageInfo.ChipCnt;i++)
+        {
+            PHY_SetDefaultParam(i);
+        }
+        NFC_ReadRetryExit(READ_RETRY_TYPE);
+	}
+
+
+	NFC_RandomDisable();
+
+	NFC_Exit();
+	return 0;
+}
+
+
+/*
+************************************************************************************************************************
+*                       RESET ONE NAND FLASH CHIP
+*
+*Description: Reset the given nand chip;
+*
+*Arguments  : nChip     the chip select number, which need be reset.
+*
+*Return     : the result of chip reset;
+*               = 0     reset nand chip successful;
+*               = -1    reset nand chip failed.
+************************************************************************************************************************
+*/
+__s32  PHY_ResetChip(__u32 nChip)
+{
+	__s32 ret;
+	__s32 timeout = 0xffff;
+
+
+	NFC_CMD_LIST cmd;
+
+	NFC_SelectChip(nChip);
+
+	_add_cmd_list(&cmd, 0xff, 0 , NFC_IGNORE, NFC_NO_DATA_FETCH, NFC_IGNORE, NFC_IGNORE, NFC_NO_WAIT_RB);
+	ret = NFC_ResetChip(&cmd);
+
+      	/*wait rb0 ready*/
+	NFC_SelectRb(0);
+	while((timeout--) && (NFC_CheckRbReady(0)));
+	if (timeout < 0)
+		return -ERR_TIMEOUT;
+
+      /*wait rb0 ready*/
+	NFC_SelectRb(1);
+	while((timeout--) && (NFC_CheckRbReady(1)));
+	if (timeout < 0)
+		return -ERR_TIMEOUT;
+
+	NFC_DeSelectChip(nChip);
+
+
+
+	return ret;
+}
+
+
+/*
+************************************************************************************************************************
+*                       READ NAND FLASH ID
+*
+*Description: Read nand flash ID from the given nand chip.
+*
+*Arguments  : nChip         the chip number whoes ID need be read;
+*             pChipID       the po__s32er to the chip ID buffer.
+*
+*Return     : read nand chip ID result;
+*               = 0     read chip ID successful, the chip ID has been stored in given buffer;
+*               = -1    read chip ID failed.
+************************************************************************************************************************
+*/
+
+__s32  PHY_ReadNandId(__s32 nChip, void *pChipID)
+{
+	__s32 ret;
+
+
+	NFC_CMD_LIST cmd;
+	__u8 addr = 0;
+
+	NFC_SelectChip(nChip);
+
+	//_add_cmd_list(&cmd, 0x90,1 , &addr, NFC_DATA_FETCH, NFC_IGNORE, 5, NFC_NO_WAIT_RB);
+	// toshiba 24nm flash has 6 bytes id
+	_add_cmd_list(&cmd, 0x90,1 , &addr, NFC_DATA_FETCH, NFC_IGNORE, 6, NFC_NO_WAIT_RB);
+	ret = NFC_GetId(&cmd, pChipID);
+
+	NFC_DeSelectChip(nChip);
+
+
+	return ret;
+}
+
+__s32  PHY_ReadNandUniqueId(__s32 bank, void *pChipID)
+{
+	__s32 ret, err_flag;
+	__u32 i, j,nChip, nRb;
+	__u8 *temp_id;
+
+
+	NFC_CMD_LIST cmd;
+	__u8 addr = 0;
+
+	nChip = _cal_real_chip(bank);
+	NFC_SelectChip(nChip);
+	nRb = _cal_real_rb(nChip);
+	NFC_SelectRb(nRb);
+
+	for(i=0;i<16; i++)
+	{
+		addr = i*32;
+		temp_id = (__u8*)(pChipID);
+		err_flag = 0;
+
+		_add_cmd_list(&cmd, 0xed,1 , &addr, NFC_DATA_FETCH, NFC_IGNORE, 32, NFC_WAIT_RB);
+		ret = NFC_GetUniqueId(&cmd, pChipID);
+
+		for(j=0; j<16;j++)
+		{
+			if((temp_id[j]^temp_id[j+16]) != 0xff)
+			{
+				err_flag = 1;
+				ret = -1;
+				break;
+			}
+		}
+
+		if(err_flag == 0)
+		{
+			ret = 0;
+			break;
+		}
+
+	}
+
+	if(ret)
+	{
+		for(j=0; j<32;j++)
+		{
+			temp_id[j] = 0x55;
+		}
+	}
+
+	PHY_DBG("Nand Unique ID of chip %u is : \n", nChip);
+	PHY_DBG("%x, %x, %x, %x\n", temp_id[0],temp_id[1],temp_id[2],temp_id[3]);
+	PHY_DBG("%x, %x, %x, %x\n", temp_id[4],temp_id[5],temp_id[6],temp_id[7]);
+	PHY_DBG("%x, %x, %x, %x\n", temp_id[8],temp_id[9],temp_id[10],temp_id[11]);
+	PHY_DBG("%x, %x, %x, %x\n", temp_id[12],temp_id[13],temp_id[14],temp_id[15]);
+	PHY_DBG("\n");
+	PHY_DBG("%x, %x, %x, %x\n", temp_id[16],temp_id[17],temp_id[18],temp_id[19]);
+	PHY_DBG("%x, %x, %x, %x\n", temp_id[20],temp_id[21],temp_id[22],temp_id[23]);
+	PHY_DBG("%x, %x, %x, %x\n", temp_id[24],temp_id[25],temp_id[26],temp_id[27]);
+	PHY_DBG("%x, %x, %x, %x\n", temp_id[28],temp_id[29],temp_id[30],temp_id[31]);
+	PHY_DBG("\n");
+
+	NFC_DeSelectChip(nChip);
+
+
+	return ret;
+}
+
+/*
+************************************************************************************************************************
+*                       CHECK WRITE PROTECT STATUS
+*
+*Description: check the status of write protect.
+*
+*Arguments  : nChip     the number of chip, which nand chip need be checked.
+*
+*Return     : the result of status check;
+*             = 0       the nand flash is not write proteced;
+*             = 1       the nand flash is write proteced;
+*             = -1      check status failed.
+************************************************************************************************************************
+*/
+__s32  PHY_CheckWp(__u32 nChip)
+{
+	__s32 status;
+	__u32 rb;
+
+
+	rb = _cal_real_rb(nChip);
+	NFC_SelectChip(nChip);
+	NFC_SelectRb(rb);
+
+
+	status = _read_status(0x70,nChip);
+	NFC_DeSelectChip(nChip);
+	NFC_DeSelectRb(rb);
+
+	if (status < 0)
+		return status;
+
+	if (status & NAND_WRITE_PROTECT){
+		return 1;
+	}
+	else
+		return 0;
+}
+
+void _pending_rb_irq_sem(void)
+{
+	return;
+}
+
+void _do_irq(void)
+{
+
+}
+
+
+__s32 PHY_SimpleRead (struct boot_physical_param *readop)
+{
+	//if (_read_single_page(readop,0) < 0)
+	//	return FAIL;
+	//return SUCESS;
+	return (_read_single_page(readop,0));
+}
+
+
+
+/*
+************************************************************************************************************************
+*                       SYNC NAND FLASH PHYSIC OPERATION
+*
+*Description: Sync nand flash operation, check nand flash program/erase operation status.
+*
+*Arguments  : nBank     the number of the bank which need be synchronized;
+*             bMode     the type of synch,
+*                       = 0     sync the chip which the bank belonged to, wait the whole chip
+*                               to be ready, and report status. if the chip support cacheprogram,
+*                               need check if the chip is true ready;
+*                       = 1     only sync the the bank, wait the bank ready and report the status,
+*                               if the chip support cache program, need not check if the cache is
+*                               true ready.
+*
+*Return     : the result of synch;
+*               = 0     synch nand flash successful, nand operation ok;
+*               = -1    synch nand flash failed.
+************************************************************************************************************************
+*/
+__s32 PHY_SynchBank(__u32 nBank, __u32 bMode)
+{
+	__s32 ret,status;
+	__u32 chip;
+	__u32 rb;
+	__u32 cmd_value;
+	__s32 timeout = 0xffff;
+
+	ret = 0;
+	/*get chip no*/
+	chip = _cal_real_chip(nBank);
+	rb = _cal_real_rb(chip);
+
+	if (0xff == chip){
+		PHY_ERR("PHY_SynchBank : beyond chip count\n");
+		return -ERR_INVALIDPHYADDR;
+	}
+
+	if ( (bMode == 1) && SUPPORT_INT_INTERLEAVE){
+		if (nBank%BNK_CNT_OF_CHIP == 0)
+			cmd_value = NandStorageInfo.OptPhyOpPar.InterBnk0StatusCmd;
+		else
+			cmd_value = NandStorageInfo.OptPhyOpPar.InterBnk1StatusCmd;
+	}
+	else{
+		if (SUPPORT_MULTI_PROGRAM)
+			cmd_value = NandStorageInfo.OptPhyOpPar.MultiPlaneStatusCmd;
+		else
+			cmd_value = 0x70;
+	}
+
+	/*if support rb irq , last op is erase or write*/
+	if (SUPPORT_RB_IRQ)
+		_pending_rb_irq_sem();
+
+	_wait_rb_ready_int(chip);
+
+	NFC_SelectChip(chip);
+	NFC_SelectRb(rb);
+
+	while(1){
+		status = _read_status(cmd_value,nBank%BNK_CNT_OF_CHIP);
+		if (status < 0)
+		{
+		    PHY_ERR("PHY_SynchBank : read status invalid ,chip = %x, bank = %x, cmd value = %x, status = %x\n",chip,nBank,cmd_value,status);
+		    return status;
+		}
+		if (status & NAND_STATUS_READY)
+			break;
+
+		if (timeout-- < 0){
+			PHY_ERR("PHY_SynchBank : wait nand ready timeout,chip = %x, bank = %x, cmd value = %x, status = %x\n",chip,nBank,cmd_value,status);
+			return -ERR_TIMEOUT;
+		}
+	}
+	if(status & NAND_OPERATE_FAIL)
+	{
+	    PHY_ERR("PHY_SynchBank : last W/E operation fail,chip = %x, bank = %x, cmd value = %x, status = %x\n",chip,nBank,cmd_value,status);
+	    ret = NAND_OP_FALSE;
+	}
+
+	NFC_DeSelectChip(chip);
+	NFC_DeSelectRb(rb);
+
+
+	return ret;
+}
diff --git a/drivers/block/sunxi_nand/src/physic/nand_simple_w.c b/drivers/block/sunxi_nand/src/physic/nand_simple_w.c
new file mode 100644
index 0000000..0ad0700
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/physic/nand_simple_w.c
@@ -0,0 +1,354 @@
+/*
+ * drivers/block/sunxi_nand/src/physic/nand_simple_w.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_type.h"
+#include "../include/nand_physic.h"
+#include "../include/nand_simple.h"
+#include "../../nfc/nfc.h"
+
+
+extern __s32 _read_status(__u32 cmd_value, __u32 nBank);
+extern void _add_cmd_list(NFC_CMD_LIST *cmd,__u32 value,__u32 addr_cycle,__u8 *addr,__u8 data_fetch_flag,
+					__u8 main_data_fetch,__u32 bytecnt,__u8 wait_rb_flag);
+extern __u8 _cal_real_chip(__u32 global_bank);
+extern __u8 _cal_real_rb(__u32 chip);
+extern void _cal_addr_in_chip(__u32 block, __u32 page, __u32 sector,__u8 *addr, __u8 cycle);
+extern void _pending_dma_irq_sem(void);
+extern void _pending_rb_irq_sem(void);
+extern __u32 _cal_random_seed(__u32 page);
+
+/***************************************************************************
+*************************write one align single page data**************************
+****************************************************************************/
+
+__s32 _write_signle_page (struct boot_physical_param *writeop,__u32 program1,__u32 program2,__u8 dma_wait_mode, __u8 rb_wait_mode )
+{
+	__s32 ret;
+	__u32 rb;
+	__u32 random_seed;
+	//__u8 *sparebuf;
+	__u8 sparebuf[4*16];
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i,addr_cycle;
+
+	MEMSET(sparebuf, 0xff, SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	if (writeop->oobbuf){
+		MEMCPY(sparebuf,writeop->oobbuf,SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	}
+	/*create cmd list*/
+	addr_cycle = (SECTOR_CNT_OF_SINGLE_PAGE == 1)?4:5;
+
+	/*the cammand have no corresponding feature if IGNORE was set, */
+	_cal_addr_in_chip(writeop->block,writeop->page,0,addr,addr_cycle);
+	_add_cmd_list(cmd_list,program1,addr_cycle,addr,NFC_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_NO_WAIT_RB);
+	_add_cmd_list(cmd_list + 1,0x85,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 2,program2,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+
+	list_len = 3;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+	rb = _cal_real_rb(writeop->chip);
+	NFC_SelectChip(writeop->chip);
+	NFC_SelectRb(rb);
+
+	if(SUPPORT_RANDOM)
+    {
+        random_seed = _cal_random_seed(writeop->page);
+		NFC_SetRandomSeed(random_seed);
+		NFC_RandomEnable();
+		ret = NFC_Write(cmd_list, writeop->mainbuf, sparebuf, dma_wait_mode, rb_wait_mode, NFC_PAGE_MODE);
+		NFC_RandomDisable();
+    }
+    else
+    {
+        ret = NFC_Write(cmd_list, writeop->mainbuf, sparebuf, dma_wait_mode, rb_wait_mode, NFC_PAGE_MODE);
+    }
+
+
+	NFC_DeSelectChip(writeop->chip);
+	NFC_DeSelectRb(rb);
+	if (dma_wait_mode)
+		_pending_dma_irq_sem();
+
+	return ret;
+
+}
+
+__s32 _write_signle_page_seq (struct boot_physical_param *writeop,__u32 program1,__u32 program2,__u8 dma_wait_mode, __u8 rb_wait_mode )
+{
+	__s32 ret;
+	__u32 rb;
+	__u32 random_seed;
+	//__u8 *sparebuf;
+	__u8 sparebuf[4*16];
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i,addr_cycle;
+
+	MEMSET(sparebuf, 0xff, SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	if (writeop->oobbuf){
+		MEMCPY(sparebuf,writeop->oobbuf,SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	}
+	/*create cmd list*/
+	addr_cycle = (SECTOR_CNT_OF_SINGLE_PAGE == 1)?4:5;
+
+	/*the cammand have no corresponding feature if IGNORE was set, */
+	_cal_addr_in_chip(writeop->block,writeop->page,0,addr,addr_cycle);
+	_add_cmd_list(cmd_list,program1,addr_cycle,addr,NFC_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_NO_WAIT_RB);
+	_add_cmd_list(cmd_list + 1,0x85,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 2,program2,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+
+	list_len = 3;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+	rb = _cal_real_rb(writeop->chip);
+	NFC_SelectChip(writeop->chip);
+	NFC_SelectRb(rb);
+
+
+	if(SUPPORT_RANDOM)
+	{
+	    random_seed = 0x4a80;
+		NFC_SetRandomSeed(random_seed);
+		NFC_RandomEnable();
+		ret = NFC_Write_Seq(cmd_list, writeop->mainbuf, sparebuf, dma_wait_mode, rb_wait_mode, NFC_PAGE_MODE);
+		NFC_RandomDisable();
+	}
+	else
+	{
+	    ret = NFC_Write_Seq(cmd_list, writeop->mainbuf, sparebuf, dma_wait_mode, rb_wait_mode, NFC_PAGE_MODE);
+	}
+
+
+	NFC_DeSelectChip(writeop->chip);
+	NFC_DeSelectRb(rb);
+	if (dma_wait_mode)
+		_pending_dma_irq_sem();
+
+	return ret;
+
+}
+
+__s32 _write_signle_page_1K (struct boot_physical_param *writeop,__u32 program1,__u32 program2,__u8 dma_wait_mode, __u8 rb_wait_mode )
+{
+	__s32 ret;
+	__u32 rb;
+	__u32 random_seed;
+	//__u8 *sparebuf;
+	__u8 sparebuf[4*16];
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i,addr_cycle;
+
+	MEMSET(sparebuf, 0xff, SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	if (writeop->oobbuf){
+		MEMCPY(sparebuf,writeop->oobbuf,SECTOR_CNT_OF_SINGLE_PAGE * 4);
+	}
+	/*create cmd list*/
+	addr_cycle = (SECTOR_CNT_OF_SINGLE_PAGE == 1)?4:5;
+
+	/*the cammand have no corresponding feature if IGNORE was set, */
+	_cal_addr_in_chip(writeop->block,writeop->page,0,addr,addr_cycle);
+	_add_cmd_list(cmd_list,program1,addr_cycle,addr,NFC_DATA_FETCH,NFC_IGNORE,NFC_IGNORE,NFC_NO_WAIT_RB);
+	_add_cmd_list(cmd_list + 1,0x85,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 2,program2,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+
+	list_len = 3;
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+	rb = _cal_real_rb(writeop->chip);
+	NFC_SelectChip(writeop->chip);
+	NFC_SelectRb(rb);
+
+
+	if(1)
+	{
+	    random_seed = 0x4a80;
+		NFC_SetRandomSeed(random_seed);
+		NFC_RandomEnable();
+		ret = NFC_Write_1K(cmd_list, writeop->mainbuf, sparebuf, dma_wait_mode, rb_wait_mode, NFC_PAGE_MODE);
+		NFC_RandomDisable();
+	}
+	else
+	{
+	    ret = NFC_Write_1K(cmd_list, writeop->mainbuf, sparebuf, dma_wait_mode, rb_wait_mode, NFC_PAGE_MODE);
+	}
+
+
+	NFC_DeSelectChip(writeop->chip);
+	NFC_DeSelectRb(rb);
+	if (dma_wait_mode)
+		_pending_dma_irq_sem();
+
+	return ret;
+
+}
+
+__s32 _erase_single_block(struct boot_physical_param *eraseop)
+{
+	__s32 ret;
+	__u32 rb;
+	__u8 addr[5];
+	NFC_CMD_LIST cmd_list[4];
+	__u32 list_len,i;
+
+	/*create cmd list*/
+	/*the cammand have no corresponding feature if IGNORE was set, */
+	list_len = 2;
+	_cal_addr_in_chip(eraseop->block,0,0,addr,3);
+	_add_cmd_list(cmd_list,0x60,3,addr,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+	_add_cmd_list(cmd_list + 1,0xd0,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE,NFC_IGNORE);
+
+	for(i = 0; i < list_len - 1; i++){
+		cmd_list[i].next = &(cmd_list[i+1]);
+	}
+
+	rb = _cal_real_rb(eraseop->chip);
+	NFC_SelectChip(eraseop->chip);
+	NFC_SelectRb(rb);
+	ret = NFC_Erase(cmd_list, 0);
+	NFC_DeSelectChip(eraseop->chip);
+	NFC_DeSelectRb(rb);
+	return ret;
+}
+__s32 PHY_SimpleWrite (struct boot_physical_param *writeop)
+{
+	__s32 status;
+	__u32 rb;
+
+	__s32 ret;
+
+	ret = _write_signle_page(writeop,0x80,0x10,0,0);
+	if (ret)
+		return FAIL;
+	rb = _cal_real_rb(writeop->chip);
+	NFC_SelectChip(writeop->chip);
+	NFC_SelectRb(rb);
+	/*get status*/
+	while(1){
+		status = _read_status(0x70,writeop->chip);
+		if (status < 0)
+			return status;
+
+		if (status & NAND_STATUS_READY)
+			break;
+	}
+	if (status & NAND_OPERATE_FAIL)
+		ret = BADBLOCK;
+	NFC_DeSelectChip(writeop->chip);
+	NFC_DeSelectRb(rb);
+
+	return ret;
+}
+
+__s32 PHY_SimpleWrite_Seq (struct boot_physical_param *writeop)
+{
+	__s32 status;
+	__u32 rb;
+
+	__s32 ret;
+
+	ret = _write_signle_page_seq(writeop,0x80,0x10,0,0);
+	if (ret)
+		return FAIL;
+	rb = _cal_real_rb(writeop->chip);
+	NFC_SelectChip(writeop->chip);
+	NFC_SelectRb(rb);
+	/*get status*/
+	while(1){
+		status = _read_status(0x70,writeop->chip);
+		if (status < 0)
+			return status;
+
+		if (status & NAND_STATUS_READY)
+			break;
+	}
+	if (status & NAND_OPERATE_FAIL)
+		ret = BADBLOCK;
+	NFC_DeSelectChip(writeop->chip);
+	NFC_DeSelectRb(rb);
+
+	return ret;
+}
+
+__s32 PHY_SimpleWrite_1K (struct boot_physical_param *writeop)
+{
+	__s32 status;
+	__u32 rb;
+
+	__s32 ret;
+
+	ret = _write_signle_page_1K(writeop,0x80,0x10,0,0);
+	if (ret)
+		return FAIL;
+	rb = _cal_real_rb(writeop->chip);
+	NFC_SelectChip(writeop->chip);
+	NFC_SelectRb(rb);
+	/*get status*/
+	while(1){
+		status = _read_status(0x70,writeop->chip);
+		if (status < 0)
+			return status;
+
+		if (status & NAND_STATUS_READY)
+			break;
+	}
+	if (status & NAND_OPERATE_FAIL)
+		ret = BADBLOCK;
+	NFC_DeSelectChip(writeop->chip);
+	NFC_DeSelectRb(rb);
+
+	return ret;
+}
+//#pragma arm section code="PHY_SimpleErase"
+__s32 PHY_SimpleErase (struct boot_physical_param *eraseop )
+{
+	__s32 status;
+	__s32 ret;
+	__u32 rb;
+
+
+	ret = _erase_single_block(eraseop);
+	if (ret)
+		return FAIL;
+	rb = _cal_real_rb(eraseop->chip);
+	NFC_SelectChip(eraseop->chip);
+	NFC_SelectRb(rb);
+	/*get status*/
+	while(1){
+		status = _read_status(0x70,eraseop->chip);
+		if (status & NAND_STATUS_READY)
+			break;
+	}
+	if (status & NAND_OPERATE_FAIL)
+		ret = BADBLOCK;
+
+	NFC_DeSelectChip(eraseop->chip);
+	NFC_DeSelectRb(rb);
+	return ret;
+
+}
+
diff --git a/drivers/block/sunxi_nand/src/scan/nand_id.c b/drivers/block/sunxi_nand/src/scan/nand_id.c
new file mode 100644
index 0000000..270055c
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/scan/nand_id.c
@@ -0,0 +1,431 @@
+/*
+ * drivers/block/sunxi_nand/src/scan/nand_id.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_scan.h"
+
+//==============================================================================
+// define the optional operation parameter for different kindes of nand flash
+//==============================================================================
+
+//the physical architecture parameter for Samsung 2K page SLC nand flash
+static struct __OptionalPhyOpPar_t PhysicArchiPara0 =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x81},           //multi-plane program command
+    {0x00, 0x00, 0x35},     //multi-plane page copy-back read command
+    {0x85, 0x11, 0x81},     //multi-plane page copy-back program command
+    0x70,                   //multi-plane operation status read command
+    0xf1,                   //inter-leave bank0 operation status read command
+    0xf2,                   //inter-leave bank1 operation status read command
+    0x01,                   //bad block flag position, in the fist 2 page
+    1                       //multi-plane block address offset
+};
+
+//the physical architecture parameter for Samsung 4K page SLC nand flash
+static struct __OptionalPhyOpPar_t PhysicArchiPara1 =
+{
+    {0x60, 0x30},           //multi-plane read command
+    {0x11, 0x81},           //multi-plane program command
+    {0x60, 0x60, 0x35},     //multi-plane page copy-back read command
+    {0x85, 0x11, 0x81},     //multi-plane page copy-back program command
+    0x70,                   //multi-plane operation status read command
+    0xf1,                   //inter-leave bank0 operation status read command
+    0xf2,                   //inter-leave bank1 operation status read command
+    0x00,                   //bad block flag position, in the fist page
+    1                       //multi-plane block address offset
+};
+
+//the physical architecture parameter for Samsung 2K page MLC nand flash
+static struct __OptionalPhyOpPar_t PhysicArchiPara2 =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x81},           //multi-plane program command
+    {0x00, 0x00, 0x35},     //multi-plane page copy-back read command
+    {0x85, 0x11, 0x81},     //multi-plane page copy-back program command
+    0x70,                   //multi-plane operation status read command
+    0xf1,                   //inter-leave bank0 operation status read command
+    0xf2,                   //inter-leave bank1 operation status read command
+    0x02,                   //bad block flag position, in the last page
+    1                       //multi-plane block address offset
+};
+
+//the physical architecture parameter for Samsung 4K page MLC nand flash
+static struct __OptionalPhyOpPar_t PhysicArchiPara3 =
+{
+    {0x60, 0x60},           //multi-plane read command
+    {0x11, 0x81},           //multi-plane program command
+    {0x60, 0x60, 0x35},     //multi-plane page copy-back read command
+    {0x85, 0x11, 0x81},     //multi-plane page copy-back program command
+    0x70,                   //multi-plane operation status read command
+    0xf1,                   //inter-leave bank0 operation status read command
+    0xf2,                   //inter-leave bank1 operation status read command
+    0x02,                   //bad block flag position, in the last page
+    1                       //multi-plane block address offset
+};
+
+//the physical architecture parameter for Micon nand flash
+static struct __OptionalPhyOpPar_t PhysicArchiPara4 =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x80},           //multi-plane program command
+    {0x00, 0x00, 0x35},     //multi-plane page copy-back read command
+    {0x85, 0x11, 0x80},     //multi-plane page copy-back program command
+    0x70,                   //multi-plane operation status read command
+    0x78,                   //inter-leave bank0 operation status read command
+    0x78,                   //inter-leave bank1 operation status read command
+    0x01,                   //bad block flag position, in the fist 2 page
+    1                       //multi-plane block address offset
+};
+
+//the physical architecture parameter for Toshiba SLC nand flash
+static struct __OptionalPhyOpPar_t PhysicArchiPara5 =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x80},           //multi-plane program command
+    {0x00, 0x00, 0x30},     //multi-plane page copy-back read command
+    {0x8c, 0x11, 0x8c},     //multi-plane page copy-back program command
+    0x71,                   //multi-plane operation status read command
+    0x70,                   //inter-leave bank0 operation status read command
+    0x70,                   //inter-leave bank1 operation status read command
+    0x00,                   //bad block flag position, in the fist page
+    0                       //multi-plane block address offset
+};
+
+//the physical architecture parameter for Toshiba MLC nand flash which multi-plane offset is 1024
+static struct __OptionalPhyOpPar_t PhysicArchiPara6 =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x80},           //multi-plane program command
+    {0x00, 0x00, 0x30},     //multi-plane page copy-back read command
+    {0x8c, 0x11, 0x8c},     //multi-plane page copy-back program command
+    0x71,                   //multi-plane operation status read command
+    0x70,                   //inter-leave bank0 operation status read command
+    0x70,                   //inter-leave bank1 operation status read command
+    0x00,                   //bad block flag position, in the fist page
+    1024                    //multi-plane block address offset
+};
+
+//the physical architecture parameter for Toshiba MLC nand flash which multi-plane offset is 2048
+static struct __OptionalPhyOpPar_t PhysicArchiPara7 =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x80},           //multi-plane program command
+    {0x00, 0x00, 0x30},     //multi-plane page copy-back read command
+    {0x8c, 0x11, 0x8c},     //multi-plane page copy-back program command
+    0x71,                   //multi-plane operation status read command
+    0x70,                   //inter-leave bank0 operation status read command
+    0x70,                   //inter-leave bank1 operation status read command
+    0x00,                   //bad block flag position, in the fist page
+    2048                    //multi-plane block address offset
+};
+
+static struct __OptionalPhyOpPar_t PhysicArchiPara8 =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x80},           //multi-plane program command
+    {0x00, 0x00, 0x30},     //multi-plane page copy-back read command
+    {0x8c, 0x11, 0x8c},     //multi-plane page copy-back program command
+    0x71,                   //multi-plane operation status read command
+    0x70,                   //inter-leave bank0 operation status read command
+    0x70,                   //inter-leave bank1 operation status read command
+    0x02,                   //bad block flag position, in the last page
+    1                       //multi-plane block address offset
+};
+
+static struct __OptionalPhyOpPar_t PhysicArchiPara9 =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x81},           //multi-plane program command
+    {0x00, 0x00, 0x30},     //multi-plane page copy-back read command
+    {0x8c, 0x11, 0x8c},     //multi-plane page copy-back program command
+    0x71,                   //multi-plane operation status read command
+    0x70,                   //inter-leave bank0 operation status read command
+    0x70,                   //inter-leave bank1 operation status read command
+    0x02,                   //bad block flag position, in the last page
+    1                       //multi-plane block address offset
+};
+
+static struct __OptionalPhyOpPar_t DefualtPhysicArchiPara =
+{
+    {0x00, 0x30},           //multi-plane read command
+    {0x11, 0x81},           //multi-plane program command
+    {0x00, 0x00, 0x35},     //multi-plane page copy-back read command
+    {0x85, 0x11, 0x81},     //multi-plane page copy-back program command
+    0x70,                   //multi-plane operation status read command
+    0xf1,                   //inter-leave bank0 operation status read command
+    0xf2,                   //inter-leave bank1 operation status read command
+    0x00,                   //bad block flag position, in the fist 2 page
+    1                       //multi-plane block address offset
+};
+
+
+//==============================================================================
+// define the physical architecture parameter for all kinds of nand flash
+//==============================================================================
+
+//==============================================================================
+//============================ SAMSUNG NAND FLASH ==============================
+//==============================================================================
+struct __NandPhyInfoPar_t SamsungNandTbl[] =
+{
+    //                NAND_CHIP_ID                     DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq   EccMode ReadRetry DDRType OperationPar
+    //--------------------------------------------------------------------------------------------------------------------------------
+    { {0xec, 0xf1, 0xff, 0x15, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    15,     0,       0,        0,     &PhysicArchiPara0 },   // K9F1G08
+    { {0xec, 0xf1, 0x00, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    15,     0,       0,        0,     &PhysicArchiPara0 },   // K9F1G08
+    { {0xec, 0xda, 0xff, 0x15, 0xff, 0xff, 0xff, 0xff }, 2,     4,      64,     1024,   0x0000,   974,    15,     0,       0,        0,     &PhysicArchiPara0 },   // K9K2G08
+    { {0xec, 0xda, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0008,   974,    15,     0,       0,        0,     &PhysicArchiPara0 },   // K9F2G08
+    { {0xec, 0xdc, 0xc1, 0x15, 0xff, 0xff, 0xff, 0xff }, 2,     4,      64,     2048,   0x0000,   974,    15,     0,       0,        0,     &PhysicArchiPara0 },   // K9K4G08
+    { {0xec, 0xdc, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     4096,   0x0008,   974,    15,     0,       0,        0,     &PhysicArchiPara0 },   // K9F4G08
+    { {0xec, 0xd3, 0x51, 0x95, 0xff, 0xff, 0xff, 0xff }, 2,     4,      64,     4096,   0x0008,   974,    30,     0,       0,        0,     &PhysicArchiPara0 },   // K9K8G08
+    //-----------------------------------------------------------------------------------------------------------------------------------
+    { {0xec, 0xd3, 0x50, 0xa6, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0018,   974,    30,     0,       0,        0,     &PhysicArchiPara1 },   // K9F8G08
+    { {0xec, 0xd5, 0x51, 0xa6, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0038,   974,    30,     0,       0,        0,     &PhysicArchiPara1 },   // K9KAG08
+    //-----------------------------------------------------------------------------------------------------------------------------------
+    { {0xec, 0xdc, 0x14, 0x25, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     2048,   0x0008,   974,    20,     0,       0,        0,     &PhysicArchiPara2 },   // K9G4G08
+    { {0xec, 0xdc, 0x14, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     2048,   0x0008,   974,    30,     0,       0,        0,     &PhysicArchiPara2 },   // K9G4G08
+    { {0xec, 0xd3, 0x55, 0x25, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     2048,   0x0008,   974,    20,     0,       0,        0,     &PhysicArchiPara2 },   // K9L8G08
+    { {0xec, 0xd3, 0x55, 0xa5, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     2048,   0x0008,   974,    30,     0,       0,        0,     &PhysicArchiPara2 },   // K9L8G08
+    { {0xec, 0xd3, 0x14, 0x25, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0008,   974,    20,     0,       0,        0,     &PhysicArchiPara2 },   // K9G8G08
+    { {0xec, 0xd3, 0x14, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0008,   974,    30,     0,       0,        0,     &PhysicArchiPara2 },   // K9G8G08
+    { {0xec, 0xd5, 0x55, 0x25, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0028,   974,    30,     0,       0,        0,     &PhysicArchiPara2 },   // K9LAG08
+    { {0xec, 0xd5, 0x55, 0xa5, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0028,   974,    30,     0,       0,        0,     &PhysicArchiPara2 },   // K9LAG08
+    //-----------------------------------------------------------------------------------------------------------------------------------
+    { {0xec, 0xd5, 0x14, 0xb6, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     4096,   0x0008,   974,    30,     0,       0,        0,     &PhysicArchiPara3 },   // K9GAG08
+    { {0xec, 0xd7, 0x55, 0xb6, 0xff, 0xff, 0xff, 0xff }, 2,     8,     128,     4096,   0x0028,   974,    30,     0,       0,        0,     &PhysicArchiPara3 },   // K9LBG08
+    { {0xec, 0xd7, 0xd5, 0x29, 0xff, 0xff, 0xff, 0xff }, 2,     8,     128,     4096,   0x0028,   974,    30,     0,       0,        0,     &PhysicArchiPara3 },   // K9LBG08
+    { {0xec, 0xd7, 0x94, 0x72, 0xff, 0xff, 0xff, 0xff }, 1,    16,     128,     4096,   0x0008,   974,    30,     2,       0,        0,     &PhysicArchiPara3 },   // K9GBG08
+    { {0xec, 0xd5, 0x98, 0x71, 0xff, 0xff, 0xff, 0xff }, 1,     8,     256,     2048,   0x0008,   950,    30,     3,       0,        0,     &PhysicArchiPara3 },   // K9AAG08
+
+    { {0xec, 0xd5, 0x94, 0x29, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     4096,   0x0008,   974,    30,     0,       0,        0,     &PhysicArchiPara3 },   // K9GAG08U0D
+    { {0xec, 0xd5, 0x84, 0x72, 0xff, 0xff, 0xff, 0xff }, 1,    16,     128,     2048,   0x0000,   950,    24,     2,       0,        0,     &PhysicArchiPara3 },   // K9GAG08U0E
+    { {0xec, 0xd5, 0x94, 0x76, 0x54, 0xff, 0xff, 0xff }, 1,    16,     128,     2048,   0x0408,   950,    30,     2,       0,        0,     &PhysicArchiPara3 },   // K9GAG08U0E
+    { {0xec, 0xd3, 0x84, 0x72, 0xff, 0xff, 0xff, 0xff }, 1,    16,     128,     1024,   0x0000,   950,    24,     2,       0,        0,     &PhysicArchiPara3 },   // K9G8G08U0C
+	{ {0xec, 0xd7, 0x94, 0x76, 0xff, 0xff, 0xff, 0xff }, 1,    16,     128,     4096,   0x0088,   974,    30,     3,       0,        0,     &PhysicArchiPara3 },   // K9GBG08U0A
+	{ {0xec, 0xd7, 0x94, 0x7A, 0xff, 0xff, 0xff, 0xff }, 1,    16,     128,     4096,   0x0088,   974,    30,     3,       0,        0,     &PhysicArchiPara3 },   // K9GBG08U0A
+	{ {0xec, 0xde, 0xd5, 0x7A, 0x58, 0xff, 0xff, 0xff }, 2,    16,	   128, 	4096,	0x0888,   974,	  30,	  3,	   0,		 0, 	&PhysicArchiPara3 },   // K9LCG08U0A
+
+	{ {0xec, 0xd7, 0x94, 0x7A, 0x54, 0xc3, 0xff, 0xff }, 1,    16,     128,     4096,   0x0088,   974,    60,     1,       0,        3,     &PhysicArchiPara3 },   // toogle nand 1.0
+	{ {0xec, 0xde, 0xa4, 0x7a, 0x68, 0xc4, 0xff, 0xff }, 1,    16,     128,     8192,   0x0588,   974,    60,     4,   0x200e04,     3,     &PhysicArchiPara3 },   // toogle nand 2.0 K9GCGD8U0A
+	{ {0xec, 0xd7, 0x94, 0x7E, 0x64, 0xc4, 0xff, 0xff }, 1,    16,     128,     4096,   0x0588,   974,    60,     4,   0x200e04,     3,     &PhysicArchiPara3 },   // toogle nand 2.0 K9GBGD8U0B
+    { {0xec, 0xd7, 0x94, 0x7e, 0x64, 0x44, 0xff, 0xff }, 1,    16,     128,     4096,   0x0588,   974,    40,     4,   0x200e04,     0,     &PhysicArchiPara3 },   // 21nm sdr K9GBG08U0B
+
+    //-----------------------------------------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,     0,       0,        0,      0                 },   // NULL
+};
+
+
+//==============================================================================
+//============================= HYNIX NAND FLASH ===============================
+//==============================================================================
+struct __NandPhyInfoPar_t HynixNandTbl[] =
+{
+    //                  NAND_CHIP_ID                  DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq  EccMode  ReadRetry  OperationPar
+    //---------------------------------------------------------------------------------------------------------------------------
+    { {0xad, 0xf1, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    15,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UF081G2M
+    { {0xad, 0xf1, 0x80, 0x1d, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    20,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UF081G2A
+    { {0xad, 0xf1, 0x00, 0x1d, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    20,     0,      0,         0,    &PhysicArchiPara0 },   // H27U1G8F2B
+    { {0xad, 0xda, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0000,   974,    15,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UF082G2M
+    { {0xad, 0xda, 0x80, 0x1d, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0000,   974,    20,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UF082G2A
+    { {0xad, 0xda, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0000,   974,    20,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UF082G2B
+    { {0xad, 0xdc, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,     4,      64,     1024,   0x0000,   974,    15,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UH084G2M
+    { {0xad, 0xdc, 0x80, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     4096,   0x0000,   974,    20,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UF084G2M, HY27UG088G5M
+    { {0xad, 0xdc, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     4096,   0x0008,   974,    20,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UF084G2B, HY27UG088G5B
+    { {0xad, 0xd3, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 4,     4,      64,     2048,   0x0000,   974,    20,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UG084G2M, HY27H088G2M
+    { {0xad, 0xd3, 0xc1, 0x95, 0xff, 0xff, 0xff, 0xff }, 2,     4,      64,     4096,   0x0000,   974,    20,     0,      0,         0,    &PhysicArchiPara0 },   // HY27UG088G2M, HY27UH08AG5M
+    //---------------------------------------------------------------------------------------------------------------------------
+    { {0xad, 0xdc, 0x84, 0x25, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     2048,   0x0000,   974,    12,     0,      0,         0,    &PhysicArchiPara2 },   // HY27UT084G2M, HY27UU088G5M
+    { {0xad, 0xdc, 0x14, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     2048,   0x0008,   974,    15,     0,      0,         0,    &PhysicArchiPara2 },   // HY27U4G8T2BTR
+    { {0xad, 0xd3, 0x85, 0x25, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     2048,   0x0000,   974,    10,     0,      0,         0,    &PhysicArchiPara2 },   // HY27UV08AG5M, HY27UW08BGFM
+    { {0xad, 0xd3, 0x14, 0x25, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0008,   974,    12,     0,      0,         0,    &PhysicArchiPara2 },   // HY27UT088G2M, HY27UU08AG5M
+    { {0xad, 0xd3, 0x14, 0x2d, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0008,   974,    25,     0,      0,         0,    &PhysicArchiPara2 },   // HY27UT088G2M, HY27UU08AG5M
+    { {0xad, 0xd3, 0x14, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0008,   974,    15,     0,      0,         0,    &PhysicArchiPara2 },   // HY27UT088G2M, HY27UU08AG5M
+    { {0xad, 0xd5, 0x55, 0x25, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0008,   974,    15,     0,      0,         0,    &PhysicArchiPara2 },   // HY27UV08BG5M, HY27UW08CGFM
+    { {0xad, 0xd5, 0x55, 0x2d, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0008,   974,    25,     0,      0,         0,    &PhysicArchiPara2 },   // HY27UV08BG5M, HY27UW08CGFM
+    { {0xad, 0xd5, 0x55, 0xa5, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     8192,   0x0008,   974,    30,     0,      0,         0,    &PhysicArchiPara2 },   // HY27UV08BG5M, HY27UW08CGFM
+    //---------------------------------------------------------------------------------------------------------------------------
+    { {0xad, 0xd3, 0x14, 0xb6, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     2048,   0x0008,   974,    30,     0,      0,         0,    &PhysicArchiPara3 },   // H27U8G8T2B
+    { {0xad, 0xd5, 0x14, 0xb6, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     4096,   0x0008,   974,    30,     0,      0,         0,    &PhysicArchiPara3 },   // H27UAG8T2M, H27UBG8U5M
+    { {0xad, 0xd7, 0x55, 0xb6, 0xff, 0xff, 0xff, 0xff }, 2,     8,     128,     4096,   0x0008,   974,    30,     0,      0,         0,    &PhysicArchiPara3 },   // H27UCG8V5M
+    //---------------------------------------------------------------------------------------------------------------------------
+    { {0xad, 0xd5, 0x94, 0x25, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     4096,   0x0008,   974,    30,     2,      0,         0,    &PhysicArchiPara3 },   // H27UBG8U5A
+    { {0xad, 0xd7, 0x95, 0x25, 0xff, 0xff, 0xff, 0xff }, 2,     8,     128,     4096,   0x0008,   974,    30,     2,      0,         0,    &PhysicArchiPara3 },   // H27UCG8V5A
+    { {0xad, 0xd5, 0x95, 0x25, 0xff, 0xff, 0xff, 0xff }, 2,     8,     128,     4096,   0x0008,   974,    30,     2,      0,         0,    &PhysicArchiPara3 },   // H27UCG8VFA
+    { {0xad, 0xd5, 0x94, 0x9A, 0xff, 0xff, 0xff, 0xff }, 1,    16,     256,     1024,   0x0000,   950,    30,     2,      0,         0,    &PhysicArchiPara3 },   // H27UAG8T2B
+    { {0xad, 0xd7, 0x94, 0x9A, 0xff, 0xff, 0xff, 0xff }, 1,    16,     256,     2048,   0x0008,   950,    30,     2,      0,         0,    &PhysicArchiPara3 },   // H27UBG8T2A H27UCG8U5(D)A H27UDG8VF(D)A
+    { {0xad, 0xde, 0xd5, 0x9A, 0xff, 0xff, 0xff, 0xff }, 2,    16,     256,     2048,   0x0008,   950,    30,     2,      0,         0,    &PhysicArchiPara3 },   // H27UDG8V5A
+    { {0xad, 0xd7, 0x94, 0x25, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     8192,   0x0008,   974,    30,     2,      0,         0,    &PhysicArchiPara3 },   // H27UBG8T2M
+    { {0xad, 0xde, 0x94, 0xd2, 0xff, 0xff, 0xff, 0xff }, 1,    16,     256,     4096,   0x0188,   950,    30,     2,  0x000604,      0,    &PhysicArchiPara3 },   // H27UCG8T2M
+    { {0xad, 0xd7, 0x18, 0x8d, 0xff, 0xff, 0xff, 0xff }, 1,     8,     256,     4096,   0x0188,   950,    30,     3,  0x000604,      0,    &PhysicArchiPara3 },   // H27UBG8M2A
+    { {0xad, 0xd7, 0x94, 0xda, 0xff, 0xff, 0xff, 0xff }, 1,    16,     256,     2048,   0x0188,   950,    30,     3,  0x010604,      0,    &PhysicArchiPara3 },   // H27UBG8M2A
+    { {0xad, 0xde, 0x94, 0xda, 0x74, 0xff, 0xff, 0xff }, 1,    16,     256,     4096,   0x0188,   960,    40,     4,  0x020708,      0,    &PhysicArchiPara3 },   // H27UCG8T2A
+    { {0xad, 0xd7, 0x94, 0x91, 0x60, 0xff, 0xff, 0xff }, 1,    16,     256,     2048,   0x0188,   960,    40,     4,  0x030708,      0,    &PhysicArchiPara3 },   // H27UBG8T2C
+    //---------------------------------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,     0,      0,         0,   0                 },   // NULL
+};
+
+
+//==============================================================================
+//============================= TOSHIBA NAND FLASH =============================
+//==============================================================================
+struct __NandPhyInfoPar_t ToshibaNandTbl[] =
+{
+    //                    NAND_CHIP_ID                 DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq   EccMode ReadRetry   OperationPar
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x98, 0xf1, 0x80, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    20,     0,     0,      0,   &PhysicArchiPara5 },   // TC58NVG0S3B
+    { {0x98, 0xda, 0xff, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0000,   974,    20,     0,     0,      0,   &PhysicArchiPara5 },   // TC58NVG1S3B
+    { {0x98, 0xdc, 0x81, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     4096,   0x0000,   974,    20,     0,     0,      0,   &PhysicArchiPara5 },   // TC58NVG2S3B
+    { {0x98, 0xd1, 0x90, 0x15, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    20,     0,     0,      0,   &PhysicArchiPara5 },   // TC58NVG0S3E
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x98, 0xda, 0x84, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     1024,   0x0000,   974,    20,     0,     0,      0,   &PhysicArchiPara6 },   // TC58NVG1D4B
+    { {0x98, 0xdc, 0x84, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     2048,   0x0008,   974,    20,     0,     0,      0,   &PhysicArchiPara6 },   // TC58NVG2D4B
+    { {0x98, 0xd3, 0x84, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0008,   974,    20,     0,     0,      0,   &PhysicArchiPara7 },   // TC58NVG3D4C
+    { {0x98, 0xd5, 0x85, 0xa5, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0008,   974,    20,     0,     0,      0,   &PhysicArchiPara7 },   // TC58NVG4D4C, TC58NVG5D4C
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x98, 0xd3, 0x94, 0xba, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     2048,   0x0008,   974,    20,     0,     0,      0,   &PhysicArchiPara6 },   // TC58NVG3D1DTG00
+    { {0x98, 0xd7, 0x95, 0xba, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     8192,   0x0008,   918,    30,     2,     0,      0,   &PhysicArchiPara7 },   // TC58NVG6D1DTG20
+    { {0x98, 0xd5, 0x94, 0xba, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     4096,   0x0008,   918,    30,     2,     0,      0,   &PhysicArchiPara7},    // TH58NVG5D1DTG20
+    { {0x98, 0xd5, 0x94, 0x32, 0xff, 0xff, 0xff, 0xff }, 1,    16,     128,     2048,   0x0008,   918,    25,     1,     0,      0,   &PhysicArchiPara8},    // TH58NVG4D2ETA20 TH58NVG4D2FTA20 TH58NVG5D2ETA00
+    { {0x98, 0xd7, 0x94, 0x32, 0xff, 0xff, 0xff, 0xff }, 1,    16,     128,     4096,   0x0008,   918,    25,     2,     0,      0,   &PhysicArchiPara8},    // TH58NVG5D2FTA00 TH58NVG6D2FTA20
+    { {0x98, 0xd7, 0x95, 0x32, 0xff, 0xff, 0xff, 0xff }, 2,    16,     128,     4096,   0x0008,   454,    25,     1,     0,      0,   &PhysicArchiPara8},    // TH58NVG6D2ETA20
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x98, 0xde, 0x94, 0x82, 0x76, 0xff, 0xff, 0xff }, 1,    16,     256,     4096,   0x0588,   918,    40,     4, 0x100504,   0,   &PhysicArchiPara9},    // TH58NVG6D2ETA20
+    { {0x98, 0xd7, 0x94, 0x32, 0x76, 0x56, 0xff, 0xff }, 1,    16,     128,     4096,   0x0588,   918,    40,     4, 0x100504,   0,   &PhysicArchiPara9},    // TH58NVG5D2HTA20
+    { {0x98, 0xd5, 0x84, 0x32, 0x72, 0x56, 0xff, 0xff }, 1,    16,     128,     2048,   0x0580,   918,    40,     4, 0x100504,   0,   &PhysicArchiPara9},    // TH58NVG4D2HTA20
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,     0,     0,      0,        0         },   // NULL
+};
+
+
+//==============================================================================
+//============================= MICON NAND FLASH ===============================
+//==============================================================================
+struct __NandPhyInfoPar_t MicronNandTbl[] =
+{
+    //                   NAND_CHIP_ID                 DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq  EccMode  ReadRetry  OperationPar
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x2c, 0xda, 0xff, 0x15, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0000,   974,    25,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F2G08AAC, JS29F02G08AAN
+    { {0x2c, 0xdc, 0xff, 0x15, 0xff, 0xff, 0xff, 0xff }, 2,     4,      64,     2048,   0x0000,   974,    25,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F4G08BAB, MT29F8G08FAB, JS29F04G08BAN, JS29F08G08FAN
+    { {0x2c, 0xdc, 0x90, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     4096,   0x0008,   974,    25,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F4G08AAA, MT29F8G08DAA, JS29F04G08AAN
+    { {0x2c, 0xd3, 0xd1, 0x95, 0xff, 0xff, 0xff, 0xff }, 2,     4,      64,     4096,   0x0008,   974,    25,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F8G08BAB, MT29F16G08FAB, JS29F08G08BAN, JS29F16G08FAN
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x2c, 0xdc, 0x84, 0x25, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     2048,   0x0000,   974,    20,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F4G08MAA, MT29F8G08QAA
+    { {0x2c, 0xd3, 0x85, 0x25, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     2048,   0x0000,   974,    20,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F16GTAA
+    { {0x2c, 0xd3, 0x94, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0008,   974,    30,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F8G08MAA, MT29F16G08QAA, JS29F08G08AAM, JS29F16G08CAM
+    { {0x2c, 0xd5, 0x95, 0xa5, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0008,   974,    20,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F32G08TAA, JS29F32G08FAM
+    { {0x2c, 0xd5, 0xd5, 0xa5, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0028,   974,    20,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F32G08TAA, JS29F32G08FAM
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x2c, 0xd5, 0x94, 0x3e, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     4096,   0x0008,   974,    30,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F16G08MAA, MT29F32G08QAA, JS29F32G08AAM, JS29F32G08CAM
+    { {0x2c, 0xd5, 0xd5, 0x3e, 0xff, 0xff, 0xff, 0xff }, 2,     8,     128,     4096,   0x0008,   974,    30,     0,     0,     0,   &PhysicArchiPara4 },   // MT29F64G08TAA, JS29F64G08FAM
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x2c, 0xd7, 0x94, 0x3e, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     8192,   0x0208,   950,    30,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F32G08CBAAA,MT29F64G08CFAAA
+    { {0x2c, 0xd7, 0xd5, 0x3e, 0xff, 0xff, 0xff, 0xff }, 2,     8,     128,     4096,   0x0008,   950,    30,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F64G08CTAA
+    { {0x2c, 0xd9, 0xd5, 0x3e, 0xff, 0xff, 0xff, 0xff }, 2,     8,     128,     8192,   0x0008,   950,    30,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F128G08,
+    { {0x2c, 0x68, 0x04, 0x46, 0xff, 0xff, 0xff, 0xff }, 1,     8,     256,     4096,   0x0208,   950,    30,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F32G08CBABA
+    { {0x2c, 0x88, 0x05, 0xC6, 0xff, 0xff, 0xff, 0xff }, 2,     8,     256,     4096,   0x0208,   950,    30,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F128G08CJABA
+    { {0x2c, 0x88, 0x04, 0x4B, 0xff, 0xff, 0xff, 0xff }, 1,    16,     256,     4096,   0x0208,   950,    40,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F64G08CBAAA
+    { {0x2c, 0x68, 0x04, 0x4A, 0xff, 0xff, 0xff, 0xff }, 1,     8,     256,     4096,   0x0208,   950,    40,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F32G08CBACA
+    { {0x2c, 0x48, 0x04, 0x4A, 0xff, 0xff, 0xff, 0xff }, 1,     8,     256,     2048,   0x0208,   950,    40,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F16G08CBACA
+    { {0x2c, 0x48, 0x04, 0x46, 0xff, 0xff, 0xff, 0xff }, 1,     8,     256,     2048,   0x0208,   950,    30,     2,     0,     0,   &PhysicArchiPara4 },   // MT29F16G08CBABA
+    { {0x2c, 0x64, 0x44, 0x4B, 0xA9, 0xff, 0xff, 0xff }, 1,    16,     256,     4096,   0x0208,   950,    40,     4,     0,     0,   &PhysicArchiPara4 },   // MT29F64G08CBABA
+	//-------------------------------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,    0,     0,      0,      0              },   // NULL
+};
+
+
+//==============================================================================
+//============================= INTEL NAND FLASH ===============================
+//==============================================================================
+struct __NandPhyInfoPar_t IntelNandTbl[] =
+{
+    //                 NAND_CHIP_ID                   DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq  EccMode  ReadRetry  OperationPar
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x89, 0xd3, 0x94, 0xa5, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     4096,   0x0008,   974,    30,     0,     0,    0,   &PhysicArchiPara4 },   // 29F08G08AAMB2, 29F16G08CAMB2
+    { {0x89, 0xd5, 0xd5, 0xa5, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     4096,   0x0028,   974,    20,     0,     0,    0,   &PhysicArchiPara4 },   // 29F32G08FAMB2
+    //-------------------------------------------------------------------------------------------------------------------------
+	{ {0x89, 0xd7, 0x94, 0x3e, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     8192,   0x0008,   918,    30,     2,     0,    0,   &PhysicArchiPara4 },   // MLC32GW8IMA,MLC64GW8IMA, 29F32G08AAMD2, 29F64G08CAMD2
+	{ {0x89, 0xd5, 0x94, 0x3e, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     4096,   0x0008,   918,    30,     2,     0,    0,   &PhysicArchiPara4 },   // 29F32G08CAMC1
+	{ {0x89, 0xd7, 0xd5, 0x3e, 0xff, 0xff, 0xff, 0xff }, 1,     8,     128,     8192,   0x0008,   918,    30,     2,     0,    0,   &PhysicArchiPara4 },   // 29F64G08FAMC1
+	{ {0x89, 0x68, 0x04, 0x46, 0xff, 0xff, 0xff, 0xff }, 1,     8,     256,     4096,   0x0208,   918,    30,     2,     0,    0,   &PhysicArchiPara4 },   // 29F32G08AAMDB
+	{ {0x89, 0x88, 0x24, 0x4B, 0xff, 0xff, 0xff, 0xff }, 1,    16,     256,     4096,   0x0208,   918,    30,     2,     0,    0,   &PhysicArchiPara4 },    //  29F64G08CBAAA 29F64G083AME1
+	{ {0x89, 0xA8, 0x25, 0xCB, 0xff, 0xff, 0xff, 0xff }, 2,    16,     256,     4096,   0x0208,   918,    30,     2,     0,    0,   &PhysicArchiPara4 },    //  29F64G08CBAAA 29F64G083AME1
+	//-------------------------------------------------------------------------------------------------------------------------
+	{ {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,     0,     0,    0,          0        },   // NULL
+};
+
+
+//==============================================================================
+//=============================== ST NAND FLASH ================================
+//==============================================================================
+struct __NandPhyInfoPar_t StNandTbl[] =
+{
+    //              NAND_CHIP_ID                       DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq  EccMode  ReadRetry  OperationPar
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x20, 0xf1, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara0 },  // NAND01GW3B
+    { {0x20, 0xf1, 0x00, 0x1d, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara0 },  // NAND01G001
+    { {0x20, 0xda, 0x80, 0x15, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara0 },  // NAND02GW3B
+    { {0x20, 0xda, 0x10, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara0 },  // NAND02GW3B2DN6
+    { {0x20, 0xdc, 0x80, 0x95, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     4096,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara0 },  // NAND04GW3B
+    { {0x20, 0xd3, 0xc1, 0x95, 0xff, 0xff, 0xff, 0xff }, 2,     4,      64,     4096,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara0 },  // NAND08GW3B
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0x20, 0xdc, 0x84, 0x25, 0xff, 0xff, 0xff, 0xff }, 1,     4,     128,     2048,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara2 },  // NAND04GW3C
+    { {0x20, 0xd3, 0x85, 0x25, 0xff, 0xff, 0xff, 0xff }, 2,     4,     128,     2048,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara2 },  // NAND08GW3C
+    { {0x20, 0xd3, 0x85, 0x25, 0xff, 0xff, 0xff, 0xff }, 4,     4,     128,     2048,   0x0000,   974,    15,    0,       0,   0,   &PhysicArchiPara2 },  // NAND16GW3C
+    //-------------------------------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,    0,       0,   0,           0          },   // NULL
+};
+
+//==============================================================================
+//============================ SPANSION NAND FLASH ==============================
+//==============================================================================
+struct __NandPhyInfoPar_t SpansionNandTbl[] =
+{
+    //                   NAND_CHIP_ID                 DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq  EccMode   ReadRetry OperationPar
+    //------------------------------------------------------------------------------------------------------------------------
+    { {0x01, 0xaa, 0x10, 0x00, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     2048,   0x0000,   974,    30,     0,      0,   0,   &PhysicArchiPara0 },   // S39MS02G
+    { {0x01, 0xa1, 0x10, 0x00, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    30,     0,      0,   0,   &PhysicArchiPara0 },   // S39MS01G
+    { {0x01, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    30,     0,      0,   0,   &PhysicArchiPara0 },   // DFT01GR08P1PM0
+    //------------------------------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,     0,      0,   0,          0        },   // NULL
+};
+
+//==============================================================================
+//============================ POWER NAND FLASH ==============================
+//==============================================================================
+struct __NandPhyInfoPar_t PowerNandTbl[] =
+{
+    //                   NAND_CHIP_ID                 DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq  EccMode   ReadRetry OperationPar
+    //------------------------------------------------------------------------------------------------------------------------
+    { {0x92, 0xf1, 0x80, 0x95, 0x40, 0xff, 0xff, 0xff }, 1,     4,      64,     1024,   0x0000,   974,    30,     0,      0,   0,   &PhysicArchiPara0 },   // ASU1GA
+    //------------------------------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,     0,      0,   0,          0        },   // NULL
+};
+
+//==============================================================================
+//============================= DEFAULT NAND FLASH =============================
+//==============================================================================
+struct __NandPhyInfoPar_t DefaultNandTbl[] =
+{
+    //                    NAND_CHIP_ID                DieCnt SecCnt  PagCnt   BlkCnt    OpOpt   DatBlk  Freq  EccMode  ReadRetry  OperationPar
+    //-----------------------------------------------------------------------------------------------------------------------
+    { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, 0,     0,       0,        0,   0x0000,     0,     0,     0,     0,    0,  &DefualtPhysicArchiPara }, //default
+};
+
diff --git a/drivers/block/sunxi_nand/src/scan/nand_scan.c b/drivers/block/sunxi_nand/src/scan/nand_scan.c
new file mode 100644
index 0000000..c164def
--- /dev/null
+++ b/drivers/block/sunxi_nand/src/scan/nand_scan.c
@@ -0,0 +1,454 @@
+/*
+ * drivers/block/sunxi_nand/src/scan/nand_scan.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "../include/nand_scan.h"
+#include"../../nfc/nfc.h"
+
+
+extern  struct __NandStorageInfo_t  NandStorageInfo;
+
+extern struct __NandPhyInfoPar_t SamsungNandTbl;
+extern struct __NandPhyInfoPar_t HynixNandTbl;
+extern struct __NandPhyInfoPar_t ToshibaNandTbl;
+extern struct __NandPhyInfoPar_t MicronNandTbl;
+extern struct __NandPhyInfoPar_t IntelNandTbl;
+extern struct __NandPhyInfoPar_t StNandTbl;
+extern struct __NandPhyInfoPar_t DefaultNandTbl;
+extern struct __NandPhyInfoPar_t SpansionNandTbl;
+extern struct __NandPhyInfoPar_t PowerNandTbl;
+
+__s32 NAND_Detect(boot_nand_para_t *nand_connect);
+
+
+/*
+************************************************************************************************************************
+*                           SEARCH NAND PHYSICAL ARCHITECTURE PARAMETER
+*
+*Description: Search the nand flash physical architecture parameter from the parameter table
+*             by nand chip ID.
+*
+*Arguments  : pNandID           the pointer to nand flash chip ID;
+*             pNandArchiInfo    the pointer to nand flash physical architecture parameter.
+*
+*Return     : search result;
+*               = 0     search successful, find the parameter in the table;
+*               < 0     search failed, can't find the parameter in the table.
+************************************************************************************************************************
+*/
+__s32 _SearchNandArchi(__u8 *pNandID, struct __NandPhyInfoPar_t *pNandArchInfo)
+{
+    __s32 i=0, j=0, k=0;
+    __u32 id_match_tbl[3]={0xffff, 0xffff, 0xffff};
+    __u32 id_bcnt;
+    struct __NandPhyInfoPar_t *tmpNandManu;
+
+    //analyze the manufacture of the nand flash
+    switch(pNandID[0])
+    {
+        //manufacture is Samsung, search parameter from Samsung nand table
+        case SAMSUNG_NAND:
+            tmpNandManu = &SamsungNandTbl;
+            break;
+
+        //manufacture is Hynix, search parameter from Hynix nand table
+        case HYNIX_NAND:
+            tmpNandManu = &HynixNandTbl;
+            break;
+
+        //manufacture is Micron, search parameter from Micron nand table
+        case MICRON_NAND:
+            tmpNandManu = &MicronNandTbl;
+            break;
+
+        //manufacture is Intel, search parameter from Intel nand table
+        case INTEL_NAND:
+            tmpNandManu = &IntelNandTbl;
+            break;
+
+        //manufacture is Toshiba, search parameter from Toshiba nand table
+        case TOSHIBA_NAND:
+            tmpNandManu = &ToshibaNandTbl;
+            break;
+
+        //manufacture is St, search parameter from St nand table
+        case ST_NAND:
+            tmpNandManu = &StNandTbl;
+            break;
+
+		//manufacture is Spansion, search parameter from Spansion nand table
+        case SPANSION_NAND:
+            tmpNandManu = &SpansionNandTbl;
+            break;
+
+       //manufacture is power, search parameter from Spansion nand table
+        case POWER_NAND:
+            tmpNandManu = &PowerNandTbl;
+            break;
+
+        //manufacture is unknown, search parameter from default nand table
+        default:
+            tmpNandManu = &DefaultNandTbl;
+            break;
+    }
+
+    //search the nand architecture parameter from the given manufacture nand table by nand ID
+    while(tmpNandManu[i].NandID[0] != 0xff)
+    {
+        //compare 6 byte id
+        id_bcnt = 1;
+        for(j=1; j<6; j++)
+        {
+            //0xff is matching all ID value
+            if((pNandID[j] != tmpNandManu[i].NandID[j]) && (tmpNandManu[i].NandID[j] != 0xff))
+            break;
+
+            if(tmpNandManu[i].NandID[j] != 0xff)
+                id_bcnt++;
+        }
+
+        if(j == 6)
+        {
+             /*4 bytes of the nand chip ID are all matching, search parameter successful*/
+            if(id_bcnt == 4)
+                id_match_tbl[0] = i;
+            else if(id_bcnt == 5)
+                id_match_tbl[1] = i;
+            else if(id_bcnt == 6)
+                id_match_tbl[2] = i;
+        }
+
+        //prepare to search the next table item
+        i++;
+    }
+
+    for(k=2; k>=0;k--)
+    {
+
+        if(id_match_tbl[k]!=0xffff)
+        {
+            i= id_match_tbl[k];
+            MEMCPY(pNandArchInfo,tmpNandManu+i,sizeof(struct __NandPhyInfoPar_t));
+            return 0;
+        }
+    }
+
+    //search nand architecture parameter failed
+    return -1;
+}
+
+
+/*
+************************************************************************************************************************
+*                           ANALYZE NAND FLASH STORAGE SYSTEM
+*
+*Description: Analyze nand flash storage system, generate the nand flash physical
+*             architecture parameter and connect information.
+*
+*Arguments  : none
+*
+*Return     : analyze result;
+*               = 0     analyze successful;
+*               < 0     analyze failed, can't recognize or some other error.
+************************************************************************************************************************
+*/
+__s32  SCN_AnalyzeNandSystem(void)
+{
+    __s32 i,result;
+    __u8  tmpChipID[8];
+	__u8  uniqueID[32];
+    struct __NandPhyInfoPar_t tmpNandPhyInfo;
+
+    //init nand flash storage information to default value
+    NandStorageInfo.ChipCnt = 1;
+    NandStorageInfo.ChipConnectInfo = 1;
+    NandStorageInfo.RbConnectMode= 1;
+    NandStorageInfo.RbCnt= 1;
+    NandStorageInfo.RbConnectInfo= 1;
+    NandStorageInfo.BankCntPerChip = 1;
+    NandStorageInfo.DieCntPerChip = 1;
+    NandStorageInfo.PlaneCntPerDie = 1;
+    NandStorageInfo.SectorCntPerPage = 4;
+    NandStorageInfo.PageCntPerPhyBlk = 64;
+    NandStorageInfo.BlkCntPerDie = 1024;
+    NandStorageInfo.OperationOpt = 0;
+    NandStorageInfo.FrequencePar = 10;
+    NandStorageInfo.EccMode = 0;
+	NandStorageInfo.ReadRetryType= 0;
+
+    //reset the nand flash chip on boot chip select
+    result = PHY_ResetChip(BOOT_CHIP_SELECT_NUM);
+    result |= PHY_SynchBank(BOOT_CHIP_SELECT_NUM, SYNC_CHIP_MODE);
+    if(result)
+    {
+        SCAN_ERR("[SCAN_ERR] Reset boot nand flash chip failed!\n");
+        return -1;
+    }
+
+    //read nand flash chip ID from boot chip
+    result = PHY_ReadNandId(BOOT_CHIP_SELECT_NUM, tmpChipID);
+    if(result)
+    {
+        SCAN_ERR("[SCAN_ERR] Read chip ID from boot chip failed!\n");
+        return -1;
+    }
+    SCAN_DBG("[SCAN_DBG] Nand flash chip id is:0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+            tmpChipID[0],tmpChipID[1],tmpChipID[2],tmpChipID[3], tmpChipID[4],tmpChipID[5]);
+
+    //search the nand flash physical architecture parameter by nand ID
+    result = _SearchNandArchi(tmpChipID, &tmpNandPhyInfo);
+    if(result)
+    {
+        SCAN_ERR("[SCAN_ERR] search nand physical architecture parameter failed!\n");
+        return -1;
+    }
+
+    //set the nand flash physical architecture parameter
+    NandStorageInfo.BankCntPerChip = tmpNandPhyInfo.DieCntPerChip;
+    NandStorageInfo.DieCntPerChip = tmpNandPhyInfo.DieCntPerChip;
+    NandStorageInfo.PlaneCntPerDie = 2;
+    NandStorageInfo.SectorCntPerPage = tmpNandPhyInfo.SectCntPerPage;
+    NandStorageInfo.PageCntPerPhyBlk = tmpNandPhyInfo.PageCntPerBlk;
+    NandStorageInfo.BlkCntPerDie = tmpNandPhyInfo.BlkCntPerDie;
+    NandStorageInfo.OperationOpt = tmpNandPhyInfo.OperationOpt;
+    NandStorageInfo.FrequencePar = tmpNandPhyInfo.AccessFreq;
+    NandStorageInfo.EccMode = tmpNandPhyInfo.EccMode;
+    NandStorageInfo.NandChipId[0] = tmpNandPhyInfo.NandID[0];
+    NandStorageInfo.NandChipId[1] = tmpNandPhyInfo.NandID[1];
+    NandStorageInfo.NandChipId[2] = tmpNandPhyInfo.NandID[2];
+    NandStorageInfo.NandChipId[3] = tmpNandPhyInfo.NandID[3];
+    NandStorageInfo.NandChipId[4] = tmpNandPhyInfo.NandID[4];
+    NandStorageInfo.NandChipId[5] = tmpNandPhyInfo.NandID[5];
+    NandStorageInfo.NandChipId[6] = tmpNandPhyInfo.NandID[6];
+    NandStorageInfo.NandChipId[7] = tmpNandPhyInfo.NandID[7];
+    NandStorageInfo.ValidBlkRatio = tmpNandPhyInfo.ValidBlkRatio;
+	NandStorageInfo.ReadRetryType = tmpNandPhyInfo.ReadRetryType;
+	NandStorageInfo.DDRType       = tmpNandPhyInfo.DDRType;
+    //set the optional operation parameter
+    NandStorageInfo.OptPhyOpPar.MultiPlaneReadCmd[0] = tmpNandPhyInfo.OptionOp->MultiPlaneReadCmd[0];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneReadCmd[1] = tmpNandPhyInfo.OptionOp->MultiPlaneReadCmd[1];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneWriteCmd[0] = tmpNandPhyInfo.OptionOp->MultiPlaneWriteCmd[0];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneWriteCmd[1] = tmpNandPhyInfo.OptionOp->MultiPlaneWriteCmd[1];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneCopyReadCmd[0] = tmpNandPhyInfo.OptionOp->MultiPlaneCopyReadCmd[0];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneCopyReadCmd[1] = tmpNandPhyInfo.OptionOp->MultiPlaneCopyReadCmd[1];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneCopyReadCmd[2] = tmpNandPhyInfo.OptionOp->MultiPlaneCopyReadCmd[2];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[0] = tmpNandPhyInfo.OptionOp->MultiPlaneCopyWriteCmd[0];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[1] = tmpNandPhyInfo.OptionOp->MultiPlaneCopyWriteCmd[1];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[2] = tmpNandPhyInfo.OptionOp->MultiPlaneCopyWriteCmd[2];
+    NandStorageInfo.OptPhyOpPar.MultiPlaneStatusCmd = tmpNandPhyInfo.OptionOp->MultiPlaneStatusCmd;
+    NandStorageInfo.OptPhyOpPar.InterBnk0StatusCmd = tmpNandPhyInfo.OptionOp->InterBnk0StatusCmd;
+    NandStorageInfo.OptPhyOpPar.InterBnk1StatusCmd = tmpNandPhyInfo.OptionOp->InterBnk1StatusCmd;
+    NandStorageInfo.OptPhyOpPar.BadBlockFlagPosition = tmpNandPhyInfo.OptionOp->BadBlockFlagPosition;
+    NandStorageInfo.OptPhyOpPar.MultiPlaneBlockOffset = tmpNandPhyInfo.OptionOp->MultiPlaneBlockOffset;
+
+    //set some configurable  optional operation parameter
+    if(!CFG_SUPPORT_MULTI_PLANE_PROGRAM)
+    {
+        NandStorageInfo.OperationOpt &= ~NAND_MULTI_READ;
+        NandStorageInfo.OperationOpt &= ~NAND_MULTI_PROGRAM;
+    }
+
+    if(!CFG_SUPPORT_INT_INTERLEAVE)
+    {
+        NandStorageInfo.OperationOpt &= ~NAND_INT_INTERLEAVE;
+    }
+
+    if(!CFG_SUPPORT_RANDOM)
+    {
+        NandStorageInfo.OperationOpt &= ~NAND_RANDOM;
+    }
+
+    if(!CFG_SUPPORT_READ_RETRY)
+    {
+        NandStorageInfo.OperationOpt &= ~NAND_READ_RETRY;
+    }
+
+    if(!CFG_SUPPORT_ALIGN_NAND_BNK)
+    {
+        NandStorageInfo.OperationOpt |= NAND_PAGE_ADR_NO_SKIP;
+    }
+
+    //process the plane count of a die and the bank count of a chip
+    if(!SUPPORT_MULTI_PROGRAM)
+    {
+        NandStorageInfo.PlaneCntPerDie = 1;
+    }
+
+    if(!SUPPORT_INT_INTERLEAVE)
+    {
+        NandStorageInfo.BankCntPerChip = 1;
+    }
+
+     //process the rb connect infomation
+    for(i=1; i<MAX_CHIP_SELECT_CNT; i++)
+    {
+        //reset current nand flash chip
+        PHY_ResetChip((__u32)i);
+
+        //read the nand chip ID from current nand flash chip
+        PHY_ReadNandId((__u32)i, tmpChipID);
+        //check if the nand flash id same as the boot chip
+        if((tmpChipID[0] == NandStorageInfo.NandChipId[0]) && (tmpChipID[1] == NandStorageInfo.NandChipId[1])
+            && (tmpChipID[2] == NandStorageInfo.NandChipId[2]) && (tmpChipID[3] == NandStorageInfo.NandChipId[3])
+            && ((tmpChipID[4] == NandStorageInfo.NandChipId[4])||(NandStorageInfo.NandChipId[4]==0xff))
+            && ((tmpChipID[5] == NandStorageInfo.NandChipId[5])||(NandStorageInfo.NandChipId[5]==0xff)))
+        {
+            NandStorageInfo.ChipCnt++;
+            NandStorageInfo.ChipConnectInfo |= (1<<i);
+        }
+    }
+
+    //process the rb connect infomation
+    {
+        NandStorageInfo.RbConnectMode = 0xff;
+
+        if((NandStorageInfo.ChipCnt == 1) && (NandStorageInfo.ChipConnectInfo & (1<<0)))
+        {
+             NandStorageInfo.RbConnectMode =1;
+        }
+        else if(NandStorageInfo.ChipCnt == 2)
+        {
+    	      if((NandStorageInfo.ChipConnectInfo & (1<<0)) && (NandStorageInfo.ChipConnectInfo & (1<<1)))
+		    NandStorageInfo.RbConnectMode =2;
+	      else if((NandStorageInfo.ChipConnectInfo & (1<<0)) && (NandStorageInfo.ChipConnectInfo & (1<<2)))
+		    NandStorageInfo.RbConnectMode =3;
+		else if((NandStorageInfo.ChipConnectInfo & (1<<0)) && (NandStorageInfo.ChipConnectInfo & (1<<7)))
+		    NandStorageInfo.RbConnectMode =0; 	//special use, only one rb
+
+        }
+
+        else if(NandStorageInfo.ChipCnt == 4)
+        {
+    	      if((NandStorageInfo.ChipConnectInfo & (1<<0)) && (NandStorageInfo.ChipConnectInfo & (1<<1))
+			  	&&  (NandStorageInfo.ChipConnectInfo & (1<<2)) &&  (NandStorageInfo.ChipConnectInfo & (1<<3)) )
+		    NandStorageInfo.RbConnectMode =4;
+	      else if((NandStorageInfo.ChipConnectInfo & (1<<0)) && (NandStorageInfo.ChipConnectInfo & (1<<2))
+			  	&&  (NandStorageInfo.ChipConnectInfo & (1<<4)) &&  (NandStorageInfo.ChipConnectInfo & (1<<6)) )
+		    NandStorageInfo.RbConnectMode =5;
+        }
+        else if(NandStorageInfo.ChipCnt == 8)
+        {
+	      NandStorageInfo.RbConnectMode =8;
+        }
+
+		if( NandStorageInfo.RbConnectMode == 0xff)
+            {
+        	    SCAN_ERR("%s : check nand rb connect fail, ChipCnt =  %x, ChipConnectInfo = %x \n",__FUNCTION__, NandStorageInfo.ChipCnt, NandStorageInfo.ChipConnectInfo);
+        	    return -1;
+		}
+
+
+    }
+
+
+    //process the external inter-leave operation
+    if(CFG_SUPPORT_EXT_INTERLEAVE)
+    {
+        if(NandStorageInfo.ChipCnt > 1)
+        {
+            NandStorageInfo.OperationOpt |= NAND_EXT_INTERLEAVE;
+        }
+    }
+    else
+    {
+        NandStorageInfo.OperationOpt &= ~NAND_EXT_INTERLEAVE;
+    }
+
+	if(SUPPORT_READ_UNIQUE_ID)
+	{
+		for(i=0; i<NandStorageInfo.ChipCnt; i++)
+		{
+			PHY_ReadNandUniqueId(i, uniqueID);
+		}
+
+	}
+
+	/*configure page size*/
+	{
+		NFC_INIT_INFO nand_info;
+		nand_info.bus_width = 0x0;
+		nand_info.ce_ctl = 0x0;
+		nand_info.ce_ctl1 = 0x0;
+		nand_info.debug = 0x0;
+		nand_info.pagesize = SECTOR_CNT_OF_SINGLE_PAGE;
+		nand_info.rb_sel = 1;
+		nand_info.serial_access_mode = 1;
+		nand_info.ddr_type = DDR_TYPE;
+		NFC_ChangMode(&nand_info);
+	}
+
+	if(SUPPORT_READ_RETRY)
+	{
+	    PHY_DBG("NFC Read Retry Init. \n");
+		NFC_ReadRetryInit(READ_RETRY_TYPE);
+
+		for(i=0; i<NandStorageInfo.ChipCnt;i++)
+	    {
+	        PHY_GetDefaultParam(i);
+	    }
+
+	}
+    //print nand flash physical architecture parameter
+    SCAN_DBG("\n\n");
+    SCAN_DBG("[SCAN_DBG] ==============Nand Architecture Parameter==============\n");
+    SCAN_DBG("[SCAN_DBG]    Nand Chip ID:         0x%x 0x%x\n",
+        (NandStorageInfo.NandChipId[0] << 0) | (NandStorageInfo.NandChipId[1] << 8)
+        | (NandStorageInfo.NandChipId[2] << 16) | (NandStorageInfo.NandChipId[3] << 24),
+        (NandStorageInfo.NandChipId[4] << 0) | (NandStorageInfo.NandChipId[5] << 8)
+        | (NandStorageInfo.NandChipId[6] << 16) | (NandStorageInfo.NandChipId[7] << 24));
+    SCAN_DBG("[SCAN_DBG]    Nand Chip Count:      0x%x\n", NandStorageInfo.ChipCnt);
+    SCAN_DBG("[SCAN_DBG]    Nand Chip Connect:    0x%x\n", NandStorageInfo.ChipConnectInfo);
+	SCAN_DBG("[SCAN_DBG]    Nand Rb Connect Mode:      0x%x\n", NandStorageInfo.RbConnectMode);
+    SCAN_DBG("[SCAN_DBG]    Sector Count Of Page: 0x%x\n", NandStorageInfo.SectorCntPerPage);
+    SCAN_DBG("[SCAN_DBG]    Page Count Of Block:  0x%x\n", NandStorageInfo.PageCntPerPhyBlk);
+    SCAN_DBG("[SCAN_DBG]    Block Count Of Die:   0x%x\n", NandStorageInfo.BlkCntPerDie);
+    SCAN_DBG("[SCAN_DBG]    Plane Count Of Die:   0x%x\n", NandStorageInfo.PlaneCntPerDie);
+    SCAN_DBG("[SCAN_DBG]    Die Count Of Chip:    0x%x\n", NandStorageInfo.DieCntPerChip);
+    SCAN_DBG("[SCAN_DBG]    Bank Count Of Chip:   0x%x\n", NandStorageInfo.BankCntPerChip);
+    SCAN_DBG("[SCAN_DBG]    Optional Operation:   0x%x\n", NandStorageInfo.OperationOpt);
+    SCAN_DBG("[SCAN_DBG]    Access Frequence:     0x%x\n", NandStorageInfo.FrequencePar);
+    SCAN_DBG("[SCAN_DBG]    ECC Mode:             0x%x\n", NandStorageInfo.EccMode);
+	SCAN_DBG("[SCAN_DBG]    Read Retry Type:      0x%x\n", NandStorageInfo.ReadRetryType);
+	SCAN_DBG("[SCAN_DBG]    DDR Type:             0x%x\n", NandStorageInfo.DDRType);
+    SCAN_DBG("[SCAN_DBG] =======================================================\n\n");
+
+    //print nand flash optional operation parameter
+    SCAN_DBG("[SCAN_DBG] ==============Optional Operaion Parameter==============\n");
+    SCAN_DBG("[SCAN_DBG]    MultiPlaneReadCmd:      0x%x, 0x%x\n",
+        NandStorageInfo.OptPhyOpPar.MultiPlaneReadCmd[0],NandStorageInfo.OptPhyOpPar.MultiPlaneReadCmd[1]);
+    SCAN_DBG("[SCAN_DBG]    MultiPlaneWriteCmd:     0x%x, 0x%x\n",
+        NandStorageInfo.OptPhyOpPar.MultiPlaneWriteCmd[0],NandStorageInfo.OptPhyOpPar.MultiPlaneWriteCmd[1]);
+    SCAN_DBG("[SCAN_DBG]    MultiPlaneCopyReadCmd:  0x%x, 0x%x, 0x%x\n",
+        NandStorageInfo.OptPhyOpPar.MultiPlaneCopyReadCmd[0],NandStorageInfo.OptPhyOpPar.MultiPlaneCopyReadCmd[1],
+        NandStorageInfo.OptPhyOpPar.MultiPlaneCopyReadCmd[2]);
+    SCAN_DBG("[SCAN_DBG]    MultiPlaneCopyWriteCmd: 0x%x, 0x%x, 0x%x\n",
+        NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[0], NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[1],
+        NandStorageInfo.OptPhyOpPar.MultiPlaneCopyWriteCmd[2]);
+    SCAN_DBG("[SCAN_DBG]    MultiPlaneStatusCmd:    0x%x\n", NandStorageInfo.OptPhyOpPar.MultiPlaneStatusCmd);
+    SCAN_DBG("[SCAN_DBG]    InterBnk0StatusCmd:     0x%x\n", NandStorageInfo.OptPhyOpPar.InterBnk0StatusCmd);
+    SCAN_DBG("[SCAN_DBG]    InterBnk1StatusCmd:     0x%x\n", NandStorageInfo.OptPhyOpPar.InterBnk1StatusCmd);
+    SCAN_DBG("[SCAN_DBG]    BadBlockFlagPosition:   0x%x\n", NandStorageInfo.OptPhyOpPar.BadBlockFlagPosition);
+    SCAN_DBG("[SCAN_DBG]    MultiPlaneBlockOffset:  0x%x\n", NandStorageInfo.OptPhyOpPar.MultiPlaneBlockOffset);
+    SCAN_DBG("[SCAN_DBG] =======================================================\n");
+
+    return 0;
+}
+
