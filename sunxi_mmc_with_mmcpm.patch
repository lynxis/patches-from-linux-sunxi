diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index f2eeb38..3931c4e 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -26,5 +26,7 @@ source "drivers/mmc/core/Kconfig"
 source "drivers/mmc/card/Kconfig"
 
 source "drivers/mmc/host/Kconfig"
+source "drivers/mmc/mmc-pm/Kconfig"
+source "drivers/mmc/sunxi-host/Kconfig"
 
 endif # MMC
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 400756e..5be478e 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -7,3 +7,5 @@ subdir-ccflags-$(CONFIG_MMC_DEBUG) := -DDEBUG
 obj-$(CONFIG_MMC)		+= core/
 obj-$(CONFIG_MMC)		+= card/
 obj-$(subst m,y,$(CONFIG_MMC))	+= host/
+obj-$(CONFIG_MMC)		+= mmc-pm/
+obj-$(CONFIG_MMC)		+= sunxi-host/
diff --git a/drivers/mmc/card/Kconfig b/drivers/mmc/card/Kconfig
index 3b1f783..ebb4afe 100644
--- a/drivers/mmc/card/Kconfig
+++ b/drivers/mmc/card/Kconfig
@@ -50,6 +50,15 @@ config MMC_BLOCK_BOUNCE
 
 	  If unsure, say Y here.
 
+config MMC_BLOCK_DEFERRED_RESUME
+	bool "Deferr MMC layer resume until I/O is requested"
+	depends on MMC_BLOCK
+	default n
+	help
+	  Say Y here to enable deferred MMC resume until I/O
+	  is requested. This will reduce overall resume latency and
+	  save power when theres an SD card inserted but not being used.
+
 config SDIO_UART
 	tristate "SDIO UART/GPS class support"
 	help
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 833ff16..117b98a 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -143,11 +143,7 @@ static struct mmc_blk_data *mmc_blk_get(struct gendisk *disk)
 
 static inline int mmc_get_devidx(struct gendisk *disk)
 {
-	int devmaj = MAJOR(disk_devt(disk));
-	int devidx = MINOR(disk_devt(disk)) / perdev_minors;
-
-	if (!devmaj)
-		devidx = disk->first_minor / perdev_minors;
+	int devidx = disk->first_minor / perdev_minors;
 	return devidx;
 }
 
@@ -660,18 +656,22 @@ static int mmc_blk_cmd_error(struct request *req, const char *name, int error,
 			req->rq_disk->disk_name, "timed out", name, status);
 
 		/* If the status cmd initially failed, retry the r/w cmd */
-		if (!status_valid)
+		if (!status_valid) {
+			pr_err("%s: status not valid, retrying timeout\n", req->rq_disk->disk_name);
 			return ERR_RETRY;
-
+		}
 		/*
 		 * If it was a r/w cmd crc error, or illegal command
 		 * (eg, issued in wrong state) then retry - we should
 		 * have corrected the state problem above.
 		 */
-		if (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND))
+		if (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND)) {
+			pr_err("%s: command error, retrying timeout\n", req->rq_disk->disk_name);
 			return ERR_RETRY;
+		}
 
 		/* Otherwise abort the command */
+		pr_err("%s: not retrying timeout\n", req->rq_disk->disk_name);
 		return ERR_ABORT;
 
 	default:
@@ -1405,12 +1405,22 @@ static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
 	return 0;
 }
 
+static int
+mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card);
+
 static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 {
 	int ret;
 	struct mmc_blk_data *md = mq->data;
 	struct mmc_card *card = md->queue.card;
 
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	if (mmc_bus_needs_resume(card->host)) {
+		mmc_resume_bus(card->host);
+		mmc_blk_set_blksize(md, card);
+	}
+#endif
+
 	if (req && !mq->mqrq_prev->req)
 		/* claim host only for the first request */
 		mmc_claim_host(card->host);
@@ -1523,6 +1533,7 @@ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
 	md->disk->queue = md->queue.queue;
 	md->disk->driverfs_dev = parent;
 	set_disk_ro(md->disk, md->read_only || default_ro);
+	md->disk->flags = GENHD_FL_EXT_DEVT;
 
 	/*
 	 * As discussed on lkml, GENHD_FL_REMOVABLE should:
@@ -1820,6 +1831,9 @@ static int mmc_blk_probe(struct mmc_card *card)
 	mmc_set_drvdata(card, md);
 	mmc_fixup_device(card, blk_fixups);
 
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	mmc_set_bus_resume_policy(card->host, 1);
+#endif
 	if (mmc_add_disk(md))
 		goto out;
 
@@ -1845,6 +1859,9 @@ static void mmc_blk_remove(struct mmc_card *card)
 	mmc_release_host(card->host);
 	mmc_blk_remove_req(md);
 	mmc_set_drvdata(card, NULL);
+#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
+	mmc_set_bus_resume_policy(card->host, 0);
+#endif
 }
 
 #ifdef CONFIG_PM
diff --git a/drivers/mmc/core/Kconfig b/drivers/mmc/core/Kconfig
index ef10387..85c2e1a 100644
--- a/drivers/mmc/core/Kconfig
+++ b/drivers/mmc/core/Kconfig
@@ -27,3 +27,20 @@ config MMC_CLKGATE
 	  support handling this in order for it to be of any use.
 
 	  If unsure, say N.
+
+config MMC_EMBEDDED_SDIO
+	boolean "MMC embedded SDIO device support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  If you say Y here, support will be added for embedded SDIO
+	  devices which do not contain the necessary enumeration
+	  support in hardware to be properly detected.
+
+config MMC_PARANOID_SD_INIT
+	bool "Enable paranoid SD card initialization (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  If you say Y here, the MMC layer will be extra paranoid
+	  about re-trying SD init requests. This can be a useful
+	  work-around for buggy controllers and hardware. Enable
+	  if you are experiencing issues with SD detection.
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index ba821fe..95902a7 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -26,6 +26,7 @@
 #include <linux/suspend.h>
 #include <linux/fault-inject.h>
 #include <linux/random.h>
+#include <linux/wakelock.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -1285,6 +1286,36 @@ static inline void mmc_bus_put(struct mmc_host *host)
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
+int mmc_resume_bus(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	if (!mmc_bus_needs_resume(host))
+		return -EINVAL;
+
+	printk("%s: Starting deferred resume\n", mmc_hostname(host));
+	spin_lock_irqsave(&host->lock, flags);
+	host->bus_resume_flags &= ~MMC_BUSRESUME_NEEDS_RESUME;
+	host->rescan_disable = 0;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	mmc_bus_get(host);
+	if (host->bus_ops && !host->bus_dead) {
+		mmc_power_up(host);
+		BUG_ON(!host->bus_ops->resume);
+		host->bus_ops->resume(host);
+	}
+
+	if (host->bus_ops->detect && !host->bus_dead)
+		host->bus_ops->detect(host);
+
+	mmc_bus_put(host);
+	printk("%s: Deferred resume completed\n", mmc_hostname(host));
+	return 0;
+}
+
+EXPORT_SYMBOL(mmc_resume_bus);
+
 /*
  * Assign a mmc bus handler to a host. Only one bus handler may control a
  * host at any given time.
@@ -1350,6 +1381,8 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 	host->detect_change = 1;
+
+	wake_lock(&host->detect_wake_lock);
 	mmc_schedule_delayed_work(&host->detect, delay);
 }
 
@@ -2009,6 +2042,7 @@ void mmc_rescan(struct work_struct *work)
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
 	int i;
+	bool extend_wakelock = false;
 
 	if (host->rescan_disable)
 		return;
@@ -2025,6 +2059,12 @@ void mmc_rescan(struct work_struct *work)
 
 	host->detect_change = 0;
 
+	/* If the card was removed the bus will be marked
+	 * as dead - extend the wakelock so userspace
+	 * can respond */
+	if (host->bus_dead)
+		extend_wakelock = 1;
+
 	/*
 	 * Let mmc_bus_put() free the bus/bus_ops if we've found that
 	 * the card is no longer present.
@@ -2049,16 +2089,24 @@ void mmc_rescan(struct work_struct *work)
 
 	mmc_claim_host(host);
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
-		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min)))
+		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min))) {
+			extend_wakelock = true;
 			break;
+		}
 		if (freqs[i] <= host->f_min)
 			break;
 	}
 	mmc_release_host(host);
 
  out:
-	if (host->caps & MMC_CAP_NEEDS_POLL)
+	if (extend_wakelock)
+		wake_lock_timeout(&host->detect_wake_lock, HZ / 2);
+	else
+		wake_unlock(&host->detect_wake_lock);
+	if (host->caps & MMC_CAP_NEEDS_POLL) {
+		wake_lock(&host->detect_wake_lock);
 		mmc_schedule_delayed_work(&host->detect, HZ);
+	}
 }
 
 void mmc_start_host(struct mmc_host *host)
@@ -2076,7 +2124,8 @@ void mmc_stop_host(struct mmc_host *host)
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
-	cancel_delayed_work_sync(&host->detect);
+	if (cancel_delayed_work_sync(&host->detect))
+		wake_unlock(&host->detect_wake_lock);
 	mmc_flush_scheduled_work();
 
 	/* clear pm flags now and let card drivers set them as needed */
@@ -2272,7 +2321,11 @@ int mmc_suspend_host(struct mmc_host *host)
 {
 	int err = 0;
 
-	cancel_delayed_work(&host->detect);
+	if (mmc_bus_needs_resume(host))
+		return 0;
+
+	if (cancel_delayed_work(&host->detect))
+		wake_unlock(&host->detect_wake_lock);
 	mmc_flush_scheduled_work();
 
 	err = mmc_cache_ctrl(host, 0);
@@ -2322,6 +2375,12 @@ int mmc_resume_host(struct mmc_host *host)
 	int err = 0;
 
 	mmc_bus_get(host);
+	if (mmc_bus_manual_resume(host)) {
+		host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
+		mmc_bus_put(host);
+		return 0;
+	}
+
 	if (host->bus_ops && !host->bus_dead) {
 		if (!mmc_card_keep_power(host)) {
 			mmc_power_up(host);
@@ -2372,10 +2431,15 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	case PM_SUSPEND_PREPARE:
 
 		spin_lock_irqsave(&host->lock, flags);
+		if (mmc_bus_needs_resume(host)) {
+			spin_unlock_irqrestore(&host->lock, flags);
+			break;
+		}
 		host->rescan_disable = 1;
 		host->power_notify_type = MMC_HOST_PW_NOTIFY_SHORT;
 		spin_unlock_irqrestore(&host->lock, flags);
-		cancel_delayed_work_sync(&host->detect);
+		if (cancel_delayed_work_sync(&host->detect))
+			wake_unlock(&host->detect_wake_lock);
 
 		if (!host->bus_ops || host->bus_ops->suspend)
 			break;
@@ -2396,6 +2460,10 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 	case PM_POST_RESTORE:
 
 		spin_lock_irqsave(&host->lock, flags);
+		if (mmc_bus_manual_resume(host)) {
+			spin_unlock_irqrestore(&host->lock, flags);
+			break;
+		}
 		host->rescan_disable = 0;
 		host->power_notify_type = MMC_HOST_PW_NOTIFY_LONG;
 		spin_unlock_irqrestore(&host->lock, flags);
@@ -2407,6 +2475,22 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 }
 #endif
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+void mmc_set_embedded_sdio_data(struct mmc_host *host,
+				struct sdio_cis *cis,
+				struct sdio_cccr *cccr,
+				struct sdio_embedded_func *funcs,
+				int num_funcs)
+{
+	host->embedded_sdio_data.cis = cis;
+	host->embedded_sdio_data.cccr = cccr;
+	host->embedded_sdio_data.funcs = funcs;
+	host->embedded_sdio_data.num_funcs = num_funcs;
+}
+
+EXPORT_SYMBOL(mmc_set_embedded_sdio_data);
+#endif
+
 static int __init mmc_init(void)
 {
 	int ret;
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 91c84c7..dd7b120 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -329,6 +329,8 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 
 	spin_lock_init(&host->lock);
 	init_waitqueue_head(&host->wq);
+	wake_lock_init(&host->detect_wake_lock, WAKE_LOCK_SUSPEND,
+		kasprintf(GFP_KERNEL, "%s_detect", mmc_hostname(host)));
 	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
 #ifdef CONFIG_PM
 	host->pm_notify.notifier_call = mmc_pm_notify;
@@ -381,7 +383,8 @@ int mmc_add_host(struct mmc_host *host)
 	mmc_host_clk_sysfs_init(host);
 
 	mmc_start_host(host);
-	register_pm_notifier(&host->pm_notify);
+	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
+		register_pm_notifier(&host->pm_notify);
 
 	return 0;
 }
@@ -398,7 +401,9 @@ EXPORT_SYMBOL(mmc_add_host);
  */
 void mmc_remove_host(struct mmc_host *host)
 {
-	unregister_pm_notifier(&host->pm_notify);
+	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
+		unregister_pm_notifier(&host->pm_notify);
+
 	mmc_stop_host(host);
 
 #ifdef CONFIG_DEBUG_FS
@@ -425,6 +430,7 @@ void mmc_free_host(struct mmc_host *host)
 	spin_lock(&mmc_host_lock);
 	idr_remove(&mmc_host_idr, host->index);
 	spin_unlock(&mmc_host_lock);
+	wake_lock_destroy(&host->detect_wake_lock);
 
 	put_device(&host->class_dev);
 }
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c272c686..7c76a45 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -806,6 +806,9 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 	bool reinit)
 {
 	int err;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	if (!reinit) {
 		/*
@@ -832,7 +835,26 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 		/*
 		 * Fetch switch information from card.
 		 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+		for (retries = 1; retries <= 3; retries++) {
+			err = mmc_read_switch(card);
+			if (!err) {
+				if (retries > 1) {
+					printk(KERN_WARNING
+					       "%s: recovered\n", 
+					       mmc_hostname(host));
+				}
+				break;
+			} else {
+				printk(KERN_WARNING
+				       "%s: read switch failed (attempt %d)\n",
+				       mmc_hostname(host), retries);
+			}
+		}
+#else
 		err = mmc_read_switch(card);
+#endif
+
 		if (err)
 			return err;
 	}
@@ -1046,18 +1068,36 @@ static int mmc_sd_alive(struct mmc_host *host)
  */
 static void mmc_sd_detect(struct mmc_host *host)
 {
-	int err;
+	int err = 0;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+        int retries = 5;
+#endif
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
-
+       
 	mmc_claim_host(host);
 
 	/*
 	 * Just check if our card has been removed.
 	 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	while(retries) {
+		err = mmc_send_status(host->card, NULL);
+		if (err) {
+			retries--;
+			udelay(5);
+			continue;
+		}
+		break;
+	}
+	if (!retries) {
+		printk(KERN_ERR "%s(%s): Unable to re-detect card (%d)\n",
+		       __func__, mmc_hostname(host), err);
+	}
+#else
 	err = _mmc_detect_card_removed(host);
-
+#endif
 	mmc_release_host(host);
 
 	if (err) {
@@ -1096,12 +1136,31 @@ static int mmc_sd_suspend(struct mmc_host *host)
 static int mmc_sd_resume(struct mmc_host *host)
 {
 	int err;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	retries = 5;
+	while (retries) {
+		err = mmc_sd_init_card(host, host->ocr, host->card);
+
+		if (err) {
+			printk(KERN_ERR "%s: Re-init card rc = %d (retries = %d)\n",
+			       mmc_hostname(host), err, retries);
+			mdelay(5);
+			retries--;
+			continue;
+		}
+		break;
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, host->card);
+#endif
 	mmc_release_host(host);
 
 	return err;
@@ -1155,6 +1214,9 @@ int mmc_attach_sd(struct mmc_host *host)
 {
 	int err;
 	u32 ocr;
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	int retries;
+#endif
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -1217,9 +1279,27 @@ int mmc_attach_sd(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
+#ifdef CONFIG_MMC_PARANOID_SD_INIT
+	retries = 5;
+	while (retries) {
+		err = mmc_sd_init_card(host, host->ocr, NULL);
+		if (err) {
+			retries--;
+			continue;
+		}
+		break;
+	}
+
+	if (!retries) {
+		printk(KERN_ERR "%s: mmc_sd_init_card() failure (err = %d)\n",
+		       mmc_hostname(host), err);
+		goto err;
+	}
+#else
 	err = mmc_sd_init_card(host, host->ocr, NULL);
 	if (err)
 		goto err;
+#endif
 
 	mmc_release_host(host);
 	err = mmc_add_card(host->card);
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 13d0e95..341b4c0 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/err.h>
+#include <linux/module.h>
 #include <linux/pm_runtime.h>
 
 #include <linux/mmc/host.h>
@@ -28,6 +29,10 @@
 #include "sdio_ops.h"
 #include "sdio_cis.h"
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+#include <linux/mmc/sdio_ids.h>
+#endif
+
 static int sdio_read_fbr(struct sdio_func *func)
 {
 	int ret;
@@ -713,19 +718,35 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		goto finish;
 	}
 
-	/*
-	 * Read the common registers.
-	 */
-	err = sdio_read_cccr(card, ocr);
-	if (err)
-		goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.cccr)
+		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
+	else {
+#endif
+		/*
+		 * Read the common registers.
+		 */
+		err = sdio_read_cccr(card,  ocr);
+		if (err)
+			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	}
+#endif
 
-	/*
-	 * Read the common CIS tuples.
-	 */
-	err = sdio_read_common_cis(card);
-	if (err)
-		goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.cis)
+		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
+	else {
+#endif
+		/*
+		 * Read the common CIS tuples.
+		 */
+		err = sdio_read_common_cis(card);
+		if (err)
+			goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	}
+#endif
 
 	if (oldcard) {
 		int same = (card->cis.vendor == oldcard->cis.vendor &&
@@ -1124,14 +1145,36 @@ int mmc_attach_sdio(struct mmc_host *host)
 	funcs = (ocr & 0x70000000) >> 28;
 	card->sdio_funcs = 0;
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	if (host->embedded_sdio_data.funcs)
+		card->sdio_funcs = funcs = host->embedded_sdio_data.num_funcs;
+#endif
+
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */
 	for (i = 0; i < funcs; i++, card->sdio_funcs++) {
-		err = sdio_init_func(host->card, i + 1);
-		if (err)
-			goto remove;
-
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		if (host->embedded_sdio_data.funcs) {
+			struct sdio_func *tmp;
+
+			tmp = sdio_alloc_func(host->card);
+			if (IS_ERR(tmp))
+				goto remove;
+			tmp->num = (i + 1);
+			card->sdio_func[i] = tmp;
+			tmp->class = host->embedded_sdio_data.funcs[i].f_class;
+			tmp->max_blksize = host->embedded_sdio_data.funcs[i].f_maxblksize;
+			tmp->vendor = card->cis.vendor;
+			tmp->device = card->cis.device;
+		} else {
+#endif
+			err = sdio_init_func(host->card, i + 1);
+			if (err)
+				goto remove;
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		}
+#endif
 		/*
 		 * Enable Runtime PM for this func (if supported)
 		 */
@@ -1179,3 +1222,39 @@ err:
 	return err;
 }
 
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	int err;
+
+	printk("%s():\n", __func__);
+	mmc_claim_host(host);
+
+	mmc_go_idle(host);
+
+	mmc_set_clock(host, host->f_min);
+
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		goto err;
+
+	host->ocr = mmc_select_voltage(host, ocr);
+	if (!host->ocr) {
+		err = -EINVAL;
+		goto err;
+	}
+
+	err = mmc_sdio_init_card(host, host->ocr, card, 0);
+	if (err)
+		goto err;
+
+	mmc_release_host(host);
+	return 0;
+err:
+	printk("%s: Error resetting SDIO communications (%d)\n",
+	       mmc_hostname(host), err);
+	mmc_release_host(host);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index 236842e..56d020e 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -24,6 +24,10 @@
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+#include <linux/mmc/host.h>
+#endif
+
 /* show configuration fields */
 #define sdio_config_attr(field, format_string)				\
 static ssize_t								\
@@ -263,7 +267,14 @@ static void sdio_release_func(struct device *dev)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 
-	sdio_free_func_cis(func);
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+	/*
+	 * If this device is embedded then we never allocated
+	 * cis tables for this func
+	 */
+	if (!func->card->host->embedded_sdio_data.funcs)
+#endif
+		sdio_free_func_cis(func);
 
 	if (func->info)
 		kfree(func->info);
diff --git a/drivers/mmc/core/sdio_io.c b/drivers/mmc/core/sdio_io.c
old mode 100644
new mode 100755
index 8f6f5ac..01fa6e8
--- a/drivers/mmc/core/sdio_io.c
+++ b/drivers/mmc/core/sdio_io.c
@@ -388,6 +388,39 @@ u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret)
 EXPORT_SYMBOL_GPL(sdio_readb);
 
 /**
+ *	sdio_readb_ext - read a single byte from a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address to read
+ *	@err_ret: optional status value from transfer
+ *	@in: value to add to argument
+ *
+ *	Reads a single byte from the address space of a given SDIO
+ *	function. If there is a problem reading the address, 0xff
+ *	is returned and @err_ret will contain the error code.
+ */
+unsigned char sdio_readb_ext(struct sdio_func *func, unsigned int addr,
+	int *err_ret, unsigned in)
+{
+	int ret;
+	unsigned char val;
+
+	BUG_ON(!func);
+
+	if (err_ret)
+		*err_ret = 0;
+
+	ret = mmc_io_rw_direct(func->card, 0, func->num, addr, (u8)in, &val);
+	if (ret) {
+		if (err_ret)
+			*err_ret = ret;
+		return 0xFF;
+	}
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(sdio_readb_ext);
+
+/**
  *	sdio_writeb - write a single byte to a SDIO function
  *	@func: SDIO function to access
  *	@b: byte to write
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index 3d8ceb4..e8398849 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -40,11 +40,11 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 	 * and we know an IRQ was signaled then call irq handler directly.
 	 * Otherwise do the full probe.
 	 */
-	func = card->sdio_single_irq;
-	if (func && host->sdio_irq_pending) {
-		func->irq_handler(func);
-		return 1;
-	}
+//	func = card->sdio_single_irq;
+//	if (func && host->sdio_irq_pending) {
+//		func->irq_handler(func);
+//		return 1;
+//	}
 
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
 	if (ret) {
@@ -266,7 +266,7 @@ int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
 	ret = sdio_card_irq_get(func->card);
 	if (ret)
 		func->irq_handler = NULL;
-	sdio_single_irq_set(func->card);
+//	sdio_single_irq_set(func->card);
 
 	return ret;
 }
@@ -291,7 +291,7 @@ int sdio_release_irq(struct sdio_func *func)
 	if (func->irq_handler) {
 		func->irq_handler = NULL;
 		sdio_card_irq_put(func->card);
-		sdio_single_irq_set(func->card);
+//		sdio_single_irq_set(func->card);
 	}
 
 	ret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);
diff --git a/drivers/mmc/core/sdio_ops.c b/drivers/mmc/core/sdio_ops.c
index d29e206..5fa546d 100644
--- a/drivers/mmc/core/sdio_ops.c
+++ b/drivers/mmc/core/sdio_ops.c
@@ -118,6 +118,7 @@ int mmc_io_rw_direct(struct mmc_card *card, int write, unsigned fn,
 	return mmc_io_rw_direct_host(card->host, write, fn, addr, in, out);
 }
 
+extern int sunximmc_check_r1_ready(struct mmc_host *mmc);
 int mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,
 	unsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz)
 {
@@ -177,6 +178,18 @@ int mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,
 			return -ERANGE;
 	}
 
+#if defined CONFIG_MMC_SUNXI || defined CONFIG_MMC_SUNXI_MODULE
+	if (write) {
+		int i = 0;
+		int r1_ready = 0;
+		do {
+			r1_ready = sunximmc_check_r1_ready(card->host);
+			i++;
+		} while (!r1_ready && i < 3000);
+		if (i > 50)
+			printk("[sdio]: busy %d !!\n", i);
+	}
+#endif
 	return 0;
 }
 
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 2bc06e7..fbcecfd 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -566,6 +566,25 @@ config MMC_SH_MMCIF
 
 	  This driver supports MMCIF in sh7724/sh7757/sh7372.
 
+config MMC_SUNXI_NEW
+	tristate "SUNXI MMC Card Interface support (new driver)"
+	depends on MMC && (ARCH_SUN5I || ARCH_SUN7I)
+	default y
+	help
+	  This selects support for the SD/MMC controller on AllWinner SoCs.
+	  If you have a board based on such a SoC and with a SD/MMC slot,
+	  say Y or M here.
+
+config MMC_DEBUG_SUNXI
+	bool "Winner's(SUNXI) MMC Host Debug support"
+	depends on MMC && MMC_SUNXI_NEW
+	default n
+
+config MMC_PRE_DBGLVL_SUNXI
+	int "Pre-defined debug level for SUNXI MMC driver"
+	depends on MMC && MMC_SUNXI_NEW
+	default 0
+
 config MMC_JZ4740
 	tristate "JZ4740 SD/Multimedia Card Interface support"
 	depends on MACH_JZ4740
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 3e7e26d..19689b1 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -54,6 +54,8 @@ obj-$(CONFIG_MMC_SDHCI_TEGRA)		+= sdhci-tegra.o
 obj-$(CONFIG_MMC_SDHCI_OF_ESDHC)	+= sdhci-of-esdhc.o
 obj-$(CONFIG_MMC_SDHCI_OF_HLWD)		+= sdhci-of-hlwd.o
 
+obj-$(CONFIG_MMC_SUNXI_NEW)		+= sunxi-mci.o
+
 ifeq ($(CONFIG_CB710_DEBUG),y)
 	CFLAGS-cb710-mmc	+= -DDEBUG
 endif
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 1fe0ca9..4b970ad 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -680,11 +680,8 @@ static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd)
 			break;
 	}
 
-	if (count >= 0xF) {
-		pr_warning("%s: Too large timeout requested for CMD%d!\n",
-		       mmc_hostname(host->mmc), cmd->opcode);
+	if (count >= 0xF)
 		count = 0xE;
-	}
 
 	return count;
 }
diff --git a/drivers/mmc/host/sunxi-mci.c b/drivers/mmc/host/sunxi-mci.c
new file mode 100644
index 0000000..fec9b7f
--- /dev/null
+++ b/drivers/mmc/host/sunxi-mci.c
@@ -0,0 +1,2228 @@
+/*
+ * drivers/mmc/host/sunxi-mci.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * Aaron.Maoye <leafy.myeh@reuuimllatech.com>
+ * James Deng <csjamesdeng@reuuimllatech.com>
+ *
+ * description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+
+#include <asm/cacheflush.h>
+#include <asm/uaccess.h>
+
+#include <plat/system.h>
+#include <plat/sys_config.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <mach/gpio.h>
+#include <mach/clock.h>
+
+#include "sunxi-mci.h"
+
+#if defined CONFIG_MMC_SUNXI || defined CONFIG_MMC_SUNXI_MODULE
+#error Only one of the old and new SUNXI MMC drivers may be selected
+#endif
+
+#define sw_host_num (sunxi_is_sun5i() ? 3 : 4)
+
+static DEFINE_MUTEX(sw_host_rescan_mutex);
+static int sw_host_rescan_pending[4] = { 0, };
+static struct sunxi_mmc_host* sw_host[4] = {NULL, NULL, NULL, NULL};
+
+static const char * const mmc_para_io[10] = { "sdc_clk", "sdc_cmd", "sdc_d0",
+	"sdc_d1", "sdc_d2", "sdc_d3", "sdc_d4", "sdc_d5", "sdc_d6", "sdc_d7" };
+
+#if 0
+static void dumphex32(char* name, char* base, int len)
+{
+	u32 i;
+
+	printk("dump %s registers:", name);
+	for (i=0; i<len; i+=4) {
+		if (!(i&0xf))
+			printk("\n0x%p : ", base + i);
+		printk("0x%08x ", readl(base + i));
+	}
+	printk("\n");
+}
+
+static void hexdump(char* name, char* base, int len)
+{
+	u32 i;
+
+	printk("%s :", name);
+	for (i=0; i<len; i++) {
+		if (!(i&0x1f))
+			printk("\n0x%p : ", base + i);
+		if (!(i&0xf))
+			printk(" ");
+		printk("%02x ", readb(base + i));
+	}
+	printk("\n");
+}
+#endif
+
+static s32 sw_mci_init_host(struct sunxi_mmc_host* smc_host)
+{
+	u32 rval;
+
+	SMC_DBG(smc_host, "MMC Driver init host %d\n", smc_host->pdev->id);
+
+	/* reset controller */
+	rval = mci_readl(smc_host, REG_GCTRL) | SDXC_HWReset;
+	mci_writel(smc_host, REG_GCTRL, rval);
+
+	mci_writel(smc_host, REG_FTRGL, 0x70008);
+	mci_writel(smc_host, REG_TMOUT, 0xffffffff);
+	mci_writel(smc_host, REG_IMASK, 0);
+	mci_writel(smc_host, REG_RINTR, 0xffffffff);
+	mci_writel(smc_host, REG_DBGC, 0xdeb);
+	mci_writel(smc_host, REG_FUNS, 0xceaa0000);
+	rval = mci_readl(smc_host, REG_GCTRL)|SDXC_INTEnb;
+	mci_writel(smc_host, REG_GCTRL, rval);
+
+	smc_host->voltage = SDC_WOLTAGE_OFF;
+	return 0;
+}
+
+s32 sw_mci_exit_host(struct sunxi_mmc_host* smc_host)
+{
+	u32 rval;
+
+	SMC_DBG(smc_host, "MMC Driver exit host %d\n", smc_host->pdev->id);
+	smc_host->ferror = 0;
+	smc_host->voltage = SDC_WOLTAGE_OFF;
+
+	rval = mci_readl(smc_host, REG_GCTRL) | SDXC_HWReset;
+	mci_writel(smc_host, REG_GCTRL, SDXC_HWReset);
+	return 0;
+}
+
+s32 sw_mci_set_vddio(struct sunxi_mmc_host* smc_host, u32 vdd)
+{
+	char* vddstr[] = {"3.3V", "1.8V", "1.2V", "OFF"};
+	static u32 on[4] = {0};
+	u32 id = smc_host->pdev->id;
+
+	if (smc_host->regulator == NULL)
+		return 0;
+	BUG_ON(vdd > SDC_WOLTAGE_OFF);
+	switch (vdd) {
+		case SDC_WOLTAGE_3V3:
+			regulator_set_voltage(smc_host->regulator, 3300000, 3300000);
+			if (!on[id]) {
+				SMC_DBG(smc_host, "regulator on\n");
+				regulator_enable(smc_host->regulator);
+				on[id] = 1;
+			}
+			break;
+		case SDC_WOLTAGE_1V8:
+			regulator_set_voltage(smc_host->regulator, 1800000, 1800000);
+			if (!on[id]) {
+				SMC_DBG(smc_host, "regulator on\n");
+				regulator_enable(smc_host->regulator);
+				on[id] = 1;
+			}
+			break;
+		case SDC_WOLTAGE_1V2:
+			regulator_set_voltage(smc_host->regulator, 1200000, 1200000);
+			if (!on[id]) {
+				SMC_DBG(smc_host, "regulator on\n");
+				regulator_enable(smc_host->regulator);
+				on[id] = 1;
+			}
+			break;
+		case SDC_WOLTAGE_OFF:
+			if (on[id]) {
+				SMC_DBG(smc_host, "regulator off\n");
+				regulator_force_disable(smc_host->regulator);
+				on[id] = 0;
+			}
+			break;
+	}
+	SMC_MSG(smc_host, "sdc%d switch io voltage to %s\n", smc_host->pdev->id, vddstr[vdd]);
+	return 0;
+}
+
+s32 sw_mci_update_clk(struct sunxi_mmc_host* smc_host)
+{
+  	u32 rval;
+  	s32 expire = jiffies + msecs_to_jiffies(1000);	//1000ms timeout
+  	s32 ret = 0;
+
+  	rval = SDXC_Start|SDXC_UPCLKOnly|SDXC_WaitPreOver;
+	if (smc_host->voltage_switching)
+		rval |= SDXC_VolSwitch;
+	mci_writel(smc_host, REG_CMDR, rval);
+
+	do {
+		rval = mci_readl(smc_host, REG_CMDR);
+	} while (jiffies < expire && (rval & SDXC_Start));
+
+	if (rval & SDXC_Start) {
+		smc_host->ferror = 1;
+		SMC_ERR(smc_host, "update clock timeout, fatal error\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+/* UHS-I Operation Modes
+ * DS		25MHz	12.5MB/s	3.3V
+ * HS		50MHz	25MB/s		3.3V
+ * SDR12	25MHz	12.5MB/s	1.8V
+ * SDR25	50MHz	25MB/s		1.8V
+ * SDR50	100MHz	50MB/s		1.8V
+ * SDR104	208MHz	104MB/s		1.8V
+ * DDR50	50MHz	50MB/s		1.8V
+ * MMC Operation Modes
+ * DS		26MHz	26MB/s		3/1.8/1.2V
+ * HS		52MHz	52MB/s		3/1.8/1.2V
+ * HSDDR	52MHz	104MB/s		3/1.8/1.2V
+ * HS200	200MHz	200MB/s		1.8/1.2V
+ *
+ * Spec. Timing
+ * SD3.0
+ * Fcclk    Tcclk   Fsclk   Tsclk   Tis     Tih     odly  RTis     RTih
+ * 400K     2.5us   24M     41ns    5ns     5ns     1     2209ns   41ns
+ * 25M      40ns    600M    1.67ns  5ns     5ns     3     14.99ns  5.01ns
+ * 50M      20ns    600M    1.67ns  6ns     2ns     3     14.99ns  5.01ns
+ * 50MDDR   20ns    600M    1.67ns  6ns     0.8ns   2     6.67ns   3.33ns
+ * 104M     9.6ns   600M    1.67ns  3ns     0.8ns   1     7.93ns   1.67ns
+ * 208M     4.8ns   600M    1.67ns  1.4ns   0.8ns   1     3.33ns   1.67ns
+
+ * 25M      40ns    300M    3.33ns  5ns     5ns     2     13.34ns   6.66ns
+ * 50M      20ns    300M    3.33ns  6ns     2ns     2     13.34ns   6.66ns
+ * 50MDDR   20ns    300M    3.33ns  6ns     0.8ns   1     6.67ns    3.33ns
+ * 104M     9.6ns   300M    3.33ns  3ns     0.8ns   0     7.93ns    1.67ns
+ * 208M     4.8ns   300M    3.33ns  1.4ns   0.8ns   0     3.13ns    1.67ns
+
+ * eMMC4.5
+ * 400K     2.5us   24M     41ns    3ns     3ns     1     2209ns    41ns
+ * 25M      40ns    600M    1.67ns  3ns     3ns     3     14.99ns   5.01ns
+ * 50M      20ns    600M    1.67ns  3ns     3ns     3     14.99ns   5.01ns
+ * 50MDDR   20ns    600M    1.67ns  2.5ns   2.5ns   2     6.67ns    3.33ns
+ * 200M     5ns     600M    1.67ns  1.4ns   0.8ns   1     3.33ns    1.67ns
+ */
+struct sw_mmc_clk_dly {
+	u32 mode;
+#define MMC_CLK_400K		0
+#define MMC_CLK_25M		1
+#define MMC_CLK_50M		2
+#define MMC_CLK_50MDDR		3
+#define MMC_CLK_50MDDR_8BIT	4
+#define MMC_CLK_100M		5
+#define MMC_CLK_200M		6
+#define MMC_CLK_MOD_NUM		7
+	u32 oclk_dly;
+	u32 sclk_dly;
+} mmc_clk_dly [MMC_CLK_MOD_NUM] = {
+	{MMC_CLK_400K,        0, 7},
+	{MMC_CLK_25M,         0, 5},
+	{MMC_CLK_50M,         3, 5},
+	{MMC_CLK_50MDDR,      2, 4},
+	{MMC_CLK_50MDDR_8BIT, 2, 4},
+	{MMC_CLK_100M,        1, 4},
+	{MMC_CLK_200M,        1, 4},
+};
+
+s32 sw_mci_set_clk_dly(struct sunxi_mmc_host* smc_host, u32 oclk_dly, u32 sclk_dly)
+{
+	u32 smc_no = smc_host->pdev->id;
+	void __iomem *mclk_base = __io_address(0x01c20088 + 0x4 * smc_no);
+	u32 rval;
+	unsigned long iflags;
+
+	spin_lock_irqsave(&smc_host->lock, iflags);
+	rval = readl(mclk_base);
+	rval &= ~((0x7U << 8) | (0x7U << 20));
+	rval |= (oclk_dly << 8) | (sclk_dly << 20);
+	writel(rval, mclk_base);
+	spin_unlock_irqrestore(&smc_host->lock, iflags);
+
+	smc_host->oclk_dly = oclk_dly;
+	smc_host->sclk_dly = sclk_dly;
+	SMC_DBG(smc_host, "oclk_dly %d, sclk_dly %d\n", oclk_dly, sclk_dly);
+	return 0;
+}
+
+s32 sw_mci_oclk_onoff(struct sunxi_mmc_host* smc_host, u32 oclk_en, u32 pwr_save)
+{
+	u32 rval = mci_readl(smc_host, REG_CLKCR);
+	rval &= ~(SDXC_CardClkOn | SDXC_LowPowerOn);
+	if (oclk_en)
+		rval |= SDXC_CardClkOn;
+	if (pwr_save || !smc_host->io_flag)
+		rval |= SDXC_LowPowerOn;
+	mci_writel(smc_host, REG_CLKCR, rval);
+	sw_mci_update_clk(smc_host);
+	return 0;
+}
+
+static void sw_mci_send_cmd(struct sunxi_mmc_host* smc_host, struct mmc_command* cmd)
+{
+	u32 imask = SDXC_IntErrBit;
+	u32 cmd_val = SDXC_Start|(cmd->opcode&0x3f);
+	unsigned long iflags;
+	u32 wait = SDC_WAIT_NONE;
+
+	wait = SDC_WAIT_CMD_DONE;
+	if (cmd->opcode == MMC_GO_IDLE_STATE) {
+		cmd_val |= SDXC_SendInitSeq;
+		imask |= SDXC_CmdDone;
+	}
+
+	if (cmd->opcode == SD_SWITCH_VOLTAGE) {
+		cmd_val |= SDXC_VolSwitch;
+		imask |= SDXC_VolChgDone;
+		smc_host->voltage_switching = 1;
+		wait = SDC_WAIT_SWITCH1V8;
+		/* switch controller to high power mode */
+		sw_mci_oclk_onoff(smc_host, 1, 0);
+	}
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		cmd_val |= SDXC_RspExp;
+		if (cmd->flags & MMC_RSP_136)
+			cmd_val |= SDXC_LongRsp;
+		if (cmd->flags & MMC_RSP_CRC)
+			cmd_val |= SDXC_CheckRspCRC;
+
+		if ((cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC) {
+			cmd_val |= SDXC_DataExp | SDXC_WaitPreOver;
+			wait = SDC_WAIT_DATA_OVER;
+			if (cmd->data->flags & MMC_DATA_STREAM) {
+				imask |= SDXC_AutoCMDDone;
+				cmd_val |= SDXC_Seqmod | SDXC_SendAutoStop;
+				wait = SDC_WAIT_AUTOCMD_DONE;
+			}
+			if (cmd->data->stop) {
+				imask |= SDXC_AutoCMDDone;
+				cmd_val |= SDXC_SendAutoStop;
+				wait = SDC_WAIT_AUTOCMD_DONE;
+			} else
+				imask |= SDXC_DataOver;
+
+			if (cmd->data->flags & MMC_DATA_WRITE)
+				cmd_val |= SDXC_Write;
+			else
+				wait |= SDC_WAIT_DMA_DONE;
+		} else
+			imask |= SDXC_CmdDone;
+
+	} else
+		imask |= SDXC_CmdDone;
+	SMC_DBG(smc_host, "smc %d cmd %d(%08x) arg %x ie 0x%08x wt %x len %d\n",
+		smc_host->pdev->id, cmd_val&0x3f, cmd->arg, cmd_val, imask, wait,
+		smc_host->mrq->data ? smc_host->mrq->data->blksz * smc_host->mrq->data->blocks : 0);
+	spin_lock_irqsave(&smc_host->lock, iflags);
+	smc_host->wait = wait;
+	smc_host->state = SDC_STATE_SENDCMD;
+	mci_writew(smc_host, REG_IMASK, imask);
+	mci_writel(smc_host, REG_CARG, cmd->arg);
+	mci_writel(smc_host, REG_CMDR, cmd_val);
+	smp_wmb();
+	spin_unlock_irqrestore(&smc_host->lock, iflags);
+}
+
+static void sw_mci_init_idma_des(struct sunxi_mmc_host* smc_host, struct mmc_data* data)
+{
+	struct sunxi_mmc_idma_des* pdes = (struct sunxi_mmc_idma_des*)smc_host->sg_cpu;
+	struct sunxi_mmc_idma_des* pdes_pa = (struct sunxi_mmc_idma_des*)smc_host->sg_dma;
+	u32 des_idx = 0;
+	u32 buff_frag_num = 0;
+	u32 remain;
+	u32 i, j;
+	u32 config;
+
+	for (i=0; i<data->sg_len; i++) {
+		buff_frag_num = data->sg[i].length >> SDXC_DES_NUM_SHIFT;
+		remain = data->sg[i].length & (SDXC_DES_BUFFER_MAX_LEN-1);
+		if (remain)
+			buff_frag_num ++;
+		else
+			remain = SDXC_DES_BUFFER_MAX_LEN;
+
+		for (j=0; j < buff_frag_num; j++, des_idx++) {
+			memset((void*)&pdes[des_idx], 0, sizeof(struct sunxi_mmc_idma_des));
+			config = SDXC_IDMAC_DES0_CH|SDXC_IDMAC_DES0_OWN|SDXC_IDMAC_DES0_DIC;
+
+		    	if (buff_frag_num > 1 && j != buff_frag_num-1)
+				pdes[des_idx].data_buf1_sz = SDXC_DES_BUFFER_MAX_LEN;
+		    	else
+				pdes[des_idx].data_buf1_sz = remain;
+
+			pdes[des_idx].buf_addr_ptr1 = sg_dma_address(&data->sg[i])
+							+ j * SDXC_DES_BUFFER_MAX_LEN;
+			if (i==0 && j==0)
+				config |= SDXC_IDMAC_DES0_FD;
+
+			if ((i == data->sg_len-1) && (j == buff_frag_num-1)) {
+				config &= ~SDXC_IDMAC_DES0_DIC;
+				config |= SDXC_IDMAC_DES0_LD|SDXC_IDMAC_DES0_ER;
+				pdes[des_idx].buf_addr_ptr2 = 0;
+			} else {
+				pdes[des_idx].buf_addr_ptr2 = (u32)&pdes_pa[des_idx+1];
+			}
+			pdes[des_idx].config = config;
+			SMC_INF(smc_host, "sg %d, frag %d, remain %d, des[%d](%08x): "
+		    		"[0] = %08x, [1] = %08x, [2] = %08x, [3] = %08x\n", i, j, remain,
+				des_idx, (u32)&pdes[des_idx],
+				(u32)((u32*)&pdes[des_idx])[0], (u32)((u32*)&pdes[des_idx])[1],
+				(u32)((u32*)&pdes[des_idx])[2], (u32)((u32*)&pdes[des_idx])[3]);
+		}
+	}
+	smp_wmb();
+	return;
+}
+
+static int sw_mci_prepare_dma(struct sunxi_mmc_host* smc_host, struct mmc_data* data)
+{
+	u32 dma_len;
+	u32 i;
+	u32 temp;
+	struct scatterlist *sg;
+
+	if (smc_host->sg_cpu == NULL)
+		return -ENOMEM;
+
+	dma_len = dma_map_sg(mmc_dev(smc_host->mmc), data->sg, data->sg_len,
+			(data->flags & MMC_DATA_WRITE) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	if (dma_len == 0) {
+		SMC_ERR(smc_host, "no dma map memory\n");
+		return -ENOMEM;
+	}
+
+	for_each_sg(data->sg, sg, data->sg_len, i) {
+		if (sg->offset & 3 || sg->length & 3) {
+			SMC_ERR(smc_host, "unaligned scatterlist: os %x length %d\n",
+				sg->offset, sg->length);
+			return -EINVAL;
+		}
+	}
+
+	sw_mci_init_idma_des(smc_host, data);
+	temp = mci_readl(smc_host, REG_GCTRL);
+	temp |= SDXC_DMAEnb;
+	mci_writel(smc_host, REG_GCTRL, temp);
+	temp |= SDXC_DMAReset;
+	mci_writel(smc_host, REG_GCTRL, temp);
+	mci_writel(smc_host, REG_DMAC, SDXC_IDMACSoftRST);
+	temp = SDXC_IDMACFixBurst|SDXC_IDMACIDMAOn;
+	mci_writel(smc_host, REG_DMAC, temp);
+	temp = mci_readl(smc_host, REG_IDIE);
+	temp &= ~(SDXC_IDMACReceiveInt|SDXC_IDMACTransmitInt);
+	if (data->flags & MMC_DATA_WRITE)
+		temp |= SDXC_IDMACTransmitInt;
+	else
+		temp |= SDXC_IDMACReceiveInt;
+	mci_writel(smc_host, REG_IDIE, temp);
+
+	//write descriptor address to register
+	mci_writel(smc_host, REG_DLBA, smc_host->sg_dma);
+	mci_writel(smc_host, REG_FTRGL, smc_host->pdata->dma_tl);
+
+	return 0;
+}
+
+int sw_mci_send_manual_stop(struct sunxi_mmc_host* smc_host, struct mmc_request* req)
+{
+	struct mmc_data* data = req->data;
+	u32 cmd_val = SDXC_Start | SDXC_RspExp | SDXC_StopAbortCMD
+			| SDXC_CheckRspCRC | MMC_STOP_TRANSMISSION;
+	u32 iflags = 0;
+	u32 imask = 0;
+	int ret = 0;
+	u32 expire = jiffies + msecs_to_jiffies(1000);
+
+	if (!data) {
+		SMC_ERR(smc_host, "no data request\n");
+		return -1;
+	}
+	/* disable interrupt */
+	imask = mci_readw(smc_host, REG_IMASK);
+	mci_writew(smc_host, REG_IMASK, 0);
+
+	mci_writel(smc_host, REG_CARG, 0);
+	mci_writel(smc_host, REG_CMDR, cmd_val);
+	do {
+		iflags = mci_readw(smc_host, REG_RINTR);
+	} while(!(iflags & (SDXC_CmdDone | SDXC_IntErrBit)) && jiffies < expire);
+
+	if (iflags & SDXC_IntErrBit) {
+		SMC_ERR(smc_host, "sdc %d send stop command failed\n", smc_host->pdev->id);
+		ret = -1;
+	}
+
+	if (req->stop)
+		req->stop->resp[0] = mci_readl(smc_host, REG_RESP0);
+
+	mci_writew(smc_host, REG_RINTR, iflags);
+
+	/* enable interrupt */
+	mci_writew(smc_host, REG_IMASK, imask);
+
+	return ret;
+}
+
+void sw_mci_dump_errinfo(struct sunxi_mmc_host* smc_host)
+{
+	SMC_ERR(smc_host, "smc %d err, cmd %d, %s%s%s%s%s%s%s%s%s%s\n",
+		smc_host->pdev->id, smc_host->mrq->cmd ? smc_host->mrq->cmd->opcode : -1,
+		smc_host->int_sum & SDXC_RespErr     ? " RE"     : "",
+		smc_host->int_sum & SDXC_RespCRCErr  ? " RCE"    : "",
+		smc_host->int_sum & SDXC_DataCRCErr  ? " DCE"    : "",
+		smc_host->int_sum & SDXC_RespTimeout ? " RTO"    : "",
+		smc_host->int_sum & SDXC_DataTimeout ? " DTO"    : "",
+		smc_host->int_sum & SDXC_DataStarve  ? " DS"     : "",
+		smc_host->int_sum & SDXC_FIFORunErr  ? " FE"     : "",
+		smc_host->int_sum & SDXC_HardWLocked ? " HL"     : "",
+		smc_host->int_sum & SDXC_StartBitErr ? " SBE"    : "",
+		smc_host->int_sum & SDXC_EndBitErr   ? " EBE"    : ""
+		);
+}
+
+s32 sw_mci_request_done(struct sunxi_mmc_host* smc_host)
+{
+	struct mmc_request* req = smc_host->mrq;
+	u32 temp;
+	s32 ret = 0;
+
+	if (smc_host->int_sum & SDXC_IntErrBit) {
+		/* if we got response timeout error information, we should check 
+		   if the command done status has been set. if there is no command
+		   done information, we should wait this bit to be set */
+		if ((smc_host->int_sum & SDXC_RespTimeout) && !(smc_host->int_sum & SDXC_CmdDone)) {
+			u32 rint;
+			u32 expire = jiffies + 1;
+			do {
+				rint = mci_readl(smc_host, REG_RINTR);
+			} while (jiffies < expire && !(rint & SDXC_CmdDone));
+		}
+			
+		sw_mci_dump_errinfo(smc_host);
+		if (req->data)
+			SMC_ERR(smc_host, "In data %s operation\n",
+				req->data->flags & MMC_DATA_WRITE ? "write" : "read");
+		ret = -1;
+		goto out;
+	}
+
+	if (req->cmd) {
+		if (req->cmd->flags & MMC_RSP_136) {
+			req->cmd->resp[0] = mci_readl(smc_host, REG_RESP3);
+			req->cmd->resp[1] = mci_readl(smc_host, REG_RESP2);
+			req->cmd->resp[2] = mci_readl(smc_host, REG_RESP1);
+			req->cmd->resp[3] = mci_readl(smc_host, REG_RESP0);
+		} else {
+			req->cmd->resp[0] = mci_readl(smc_host, REG_RESP0);
+		}
+	}
+
+out:
+	if (req->data) {
+		struct mmc_data* data = req->data;
+		mci_writel(smc_host, REG_IDST, 0x337);
+		mci_writel(smc_host, REG_IDIE, 0);
+		mci_writel(smc_host, REG_DMAC, 0);
+		temp = mci_readl(smc_host, REG_GCTRL);
+		mci_writel(smc_host, REG_GCTRL, temp|SDXC_DMAReset);
+		temp &= ~SDXC_DMAEnb;
+		mci_writel(smc_host, REG_GCTRL, temp);
+		temp |= SDXC_FIFOReset;
+		mci_writel(smc_host, REG_GCTRL, temp);
+		dma_unmap_sg(mmc_dev(smc_host->mmc), data->sg, data->sg_len,
+				data->flags & MMC_DATA_WRITE ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	}
+
+	mci_writew(smc_host, REG_IMASK, 0);
+	if (smc_host->int_sum & (SDXC_RespErr | SDXC_HardWLocked | SDXC_RespTimeout)) {
+		SMC_DBG(smc_host, "sdc %d abnormal status: %s\n", smc_host->pdev->id,
+			smc_host->int_sum & SDXC_HardWLocked ? "HardWLocked" : "RespErr");
+	}
+
+	mci_writew(smc_host, REG_RINTR, 0xffff);
+
+	SMC_DBG(smc_host, "smc %d done, resp %08x %08x %08x %08x\n", smc_host->pdev->id,
+		req->cmd->resp[0], req->cmd->resp[1], req->cmd->resp[2], req->cmd->resp[3]);
+
+	if (req->data  && (smc_host->int_sum & SDXC_IntErrBit)) {
+		SMC_MSG(smc_host, "found data error, need to send stop command\n");
+		sw_mci_send_manual_stop(smc_host, req);
+	}
+
+	return ret;
+}
+
+/* static s32 sw_mci_set_clk(struct sunxi_mmc_host* smc_host, u32 clk);
+ * set clock and the phase of output/input clock incording on
+ * the different timing condition
+ */
+static int sw_mci_set_clk(struct sunxi_mmc_host* smc_host, u32 clk)
+{
+	struct clk *sclk = NULL;
+	u32 mod_clk = 0;
+	u32 src_clk = 0;
+	u32 temp;
+	u32 oclk_dly = 2;
+	u32 sclk_dly = 2;
+	struct sw_mmc_clk_dly* dly = NULL;
+	s32 err;
+	u32 rate;
+
+	if (clk <= 400000) {
+		mod_clk = smc_host->mod_clk;
+		sclk = clk_get(&smc_host->pdev->dev, MMC_SRCCLK_HOSC);
+	} else {
+		mod_clk = smc_host->mod_clk;
+		sclk = clk_get(&smc_host->pdev->dev, MMC_SRCCLK_PLL6);
+	}
+	if (IS_ERR(sclk)) {
+		SMC_ERR(smc_host, "Error to get source clock for clk %dHz\n", clk);
+		return -1;
+	}
+	err = clk_set_parent(smc_host->mclk, sclk);
+	if (err) {
+		SMC_ERR(smc_host, "sdc%d set mclk parent error\n", smc_host->pdev->id);
+		clk_put(sclk);
+		return -1;
+	}
+	err = clk_set_rate(smc_host->mclk, mod_clk);
+	if (err) {
+		SMC_ERR(smc_host, "sdc%d set mclk rate error, rate %dHz\n",
+						smc_host->pdev->id, mod_clk);
+		clk_put(sclk);
+		return -1;
+	}
+	rate = clk_get_rate(smc_host->mclk);
+	if (0 == rate) {
+		SMC_ERR(smc_host, "sdc%d get mclk rate error\n",
+			smc_host->pdev->id);
+		clk_put(sclk);
+		return -1;
+	}
+	src_clk = clk_get_rate(sclk);
+	clk_put(sclk);
+	smc_host->mod_clk = smc_host->card_clk = rate;
+
+	SMC_MSG(smc_host, "sdc%d set round clock %d, src %d\n", smc_host->pdev->id, rate, src_clk);
+	sw_mci_oclk_onoff(smc_host, 0, 0);
+	/* clear internal divider */
+	temp = mci_readl(smc_host, REG_CLKCR);
+	temp &= ~0xff;
+	mci_writel(smc_host, REG_CLKCR, temp);
+	sw_mci_oclk_onoff(smc_host, 0, 0);
+
+	if (clk <= 400000) {
+		dly = &mmc_clk_dly[MMC_CLK_400K];
+	} else if (clk <= 25000000) {
+		dly = &mmc_clk_dly[MMC_CLK_25M];
+	} else if (clk <= 50000000) {
+		if (smc_host->ddr) {
+			if (smc_host->bus_width == 8)
+				dly = &mmc_clk_dly[MMC_CLK_50MDDR_8BIT];
+			else
+				dly = &mmc_clk_dly[MMC_CLK_50MDDR];
+		} else {
+			dly = &mmc_clk_dly[MMC_CLK_50M];
+		}
+	} else if (clk <= 104000000) {
+		dly = &mmc_clk_dly[MMC_CLK_100M];
+	} else if (clk <= 208000000) {
+		dly = &mmc_clk_dly[MMC_CLK_200M];
+	} else
+		dly = &mmc_clk_dly[MMC_CLK_50M];
+	oclk_dly = dly->oclk_dly;
+	sclk_dly = dly->sclk_dly;
+	if (src_clk >= 300000000 && src_clk <= 400000000) {
+		if (oclk_dly)
+			oclk_dly--;
+		if (sclk_dly)
+			sclk_dly--;
+	}
+	sw_mci_set_clk_dly(smc_host, oclk_dly, sclk_dly);
+	sw_mci_oclk_onoff(smc_host, 1, 0);
+	return 0;
+}
+
+static void sw_mci_update_io_driving(struct sunxi_mmc_host *smc_host, u32 drv)
+{
+	u32 smc_no = smc_host->pdev->id;
+	struct sunxi_mmc_platform_data *pdata = smc_host->pdata;
+	int i, r;
+
+	for (i = 0; i < pdata->width + 2; i++) {
+		r = gpio_set_one_pin_driver_level(pdata->mmcio[i], drv,
+						  mmc_para_io[i]);
+		if (r != 0) {
+			SMC_ERR(smc_host, "sdc%u set %s drvlvl failed\n",
+				smc_no, mmc_para_io[i]);
+		}
+	}
+	SMC_DBG(smc_host, "sdc%u set mmcio driving to %d\n", smc_no, drv);
+}
+
+static int sw_mci_resource_request(struct sunxi_mmc_host *smc_host)
+{
+	struct platform_device *pdev = smc_host->pdev;
+	u32 smc_no = pdev->id;
+	char hclk_name[16] = {0};
+	char mclk_name[8] = {0};
+	struct resource* res = NULL;
+	s32 ret;
+
+	/* io mapping */
+	res = request_mem_region(SMC_BASE(smc_no), SMC_BASE_OS, pdev->name);
+	if (!res) {
+		SMC_ERR(smc_host, "Failed to request io memory region.\n");
+		return -ENOENT;
+	}
+	smc_host->reg_base = ioremap(res->start, SMC_BASE_OS);
+	if (!smc_host->reg_base) {
+		SMC_ERR(smc_host, "Failed to ioremap() io memory region.\n");
+		ret = -EINVAL;
+		goto free_mem_region;
+	}
+	/* hclk */
+	sprintf(hclk_name, MMC_AHBCLK_PREFIX"%d", smc_no);
+	smc_host->hclk = clk_get(&pdev->dev, hclk_name);
+	if (IS_ERR(smc_host->hclk)) {
+		ret = PTR_ERR(smc_host->hclk);
+		SMC_ERR(smc_host, "Error to get ahb clk for %s\n", hclk_name);
+		goto iounmap;
+	}
+	/* mclk */
+	sprintf(mclk_name, MMC_MODCLK_PREFIX"%d", smc_no);
+	smc_host->mclk = clk_get(&pdev->dev, mclk_name);
+	if (IS_ERR(smc_host->mclk)) {
+		ret = PTR_ERR(smc_host->mclk);
+		SMC_ERR(smc_host, "Error to get clk for %s\n", mclk_name);
+		goto free_hclk;
+	}
+
+	/* alloc idma descriptor structure */
+	smc_host->sg_cpu = dma_alloc_writecombine(NULL, PAGE_SIZE,
+					&smc_host->sg_dma, GFP_KERNEL);
+	if (smc_host->sg_cpu == NULL) {
+		SMC_ERR(smc_host, "alloc dma des failed\n");
+		goto free_mclk;
+	}
+
+	/* get power regulator */
+	if (smc_host->pdata->regulator[0]) {
+		smc_host->regulator = regulator_get(NULL, smc_host->pdata->regulator);
+		if (!smc_host->regulator) {
+			SMC_ERR(smc_host, "Get regulator %s failed\n", smc_host->pdata->regulator);
+			goto free_sgbuff;
+		}
+	}
+
+	return 0;
+free_sgbuff:
+	dma_free_coherent(NULL, PAGE_SIZE, smc_host->sg_cpu, smc_host->sg_dma);
+	smc_host->sg_cpu = NULL;
+	smc_host->sg_dma = 0;
+free_mclk:
+	clk_put(smc_host->mclk);
+	smc_host->mclk = NULL;
+free_hclk:
+	clk_put(smc_host->hclk);
+	smc_host->hclk = NULL;
+iounmap:
+	iounmap(smc_host->reg_base);
+free_mem_region:
+	release_mem_region(SMC_BASE(smc_no), SMC_BASE_OS);
+
+	return -1;
+}
+
+
+static int sw_mci_resource_release(struct sunxi_mmc_host *smc_host)
+{
+	/* free power regulator */
+	if (smc_host->regulator) {
+		regulator_put(smc_host->regulator);
+		smc_host->regulator = NULL;
+	}
+	/* free idma descriptor structrue */
+	if (smc_host->sg_cpu) {
+		dma_free_coherent(NULL, PAGE_SIZE,
+				  smc_host->sg_cpu, smc_host->sg_dma);
+		smc_host->sg_cpu = NULL;
+		smc_host->sg_dma = 0;
+	}
+
+	clk_put(smc_host->hclk);
+	smc_host->hclk = NULL;
+	clk_put(smc_host->mclk);
+	smc_host->mclk = NULL;
+
+	iounmap(smc_host->reg_base);
+	release_mem_region(SMC_BASE(smc_host->pdev->id), SMC_BASE_OS);
+
+	return 0;
+}
+
+static void sw_mci_hold_io(struct sunxi_mmc_host* smc_host)
+{
+	int ret;
+	u32 i;
+	struct sunxi_mmc_platform_data *pdata = smc_host->pdata;
+
+	for (i = 0; i < pdata->width + 2; i++) {
+		user_gpio_set_t settings = pdata->mmcio_settings[i];
+		settings.mul_sel = 0;
+		settings.pull = 0;
+		ret = gpio_set_one_pin_status(pdata->mmcio[i], &settings,
+					      mmc_para_io[i], 1);
+		if (ret != 0) {
+			SMC_ERR(smc_host, "sdc%d hold mmcio%d failed\n",
+						smc_host->pdev->id, i);
+			return;
+		}
+	}
+	SMC_DBG(smc_host, "mmc %d suspend pins\n", smc_host->pdev->id);
+
+	return;
+}
+
+static void sw_mci_restore_io(struct sunxi_mmc_host* smc_host)
+{
+	int ret;
+	u32 i;
+	struct sunxi_mmc_platform_data *pdata = smc_host->pdata;
+
+	for (i = 0; i < pdata->width + 2; i++) {
+		ret = gpio_set_one_pin_status(pdata->mmcio[i], NULL,
+					      mmc_para_io[i], 0);
+		if (ret) {
+			SMC_ERR(smc_host, "sdc%d restore mmcio%d failed\n",
+						smc_host->pdev->id, i);
+			return;
+		}
+	}
+
+	SMC_DBG(smc_host, "mmc %d resume pins\n", smc_host->pdev->id);
+}
+
+static void sw_mci_finalize_request(struct sunxi_mmc_host *smc_host)
+{
+	struct mmc_request* mrq = smc_host->mrq;
+	unsigned long iflags;
+
+	spin_lock_irqsave(&smc_host->lock, iflags);
+	if (smc_host->wait != SDC_WAIT_FINALIZE) {
+		spin_unlock_irqrestore(&smc_host->lock, iflags);
+		SMC_MSG(smc_host, "nothing finalize, wt %x, st %d\n",
+				smc_host->wait, smc_host->state);
+		return;
+	}
+	smc_host->wait = SDC_WAIT_NONE;
+	smc_host->state = SDC_STATE_IDLE;
+	smc_host->trans_done = 0;
+	smc_host->dma_done = 0;
+	spin_unlock_irqrestore(&smc_host->lock, iflags);
+
+	sw_mci_request_done(smc_host);
+	if (smc_host->error) {
+		mrq->cmd->error = -ETIMEDOUT;
+		if (mrq->data)
+			mrq->data->error = -ETIMEDOUT;
+		if (mrq->stop)
+			mrq->stop->error = -ETIMEDOUT;
+	} else {
+		if (mrq->data)
+			mrq->data->bytes_xfered = (mrq->data->blocks * mrq->data->blksz);
+	}
+
+	smc_host->mrq = NULL;
+	smc_host->error = 0;
+	smc_host->int_sum = 0;
+	smp_wmb();
+	mmc_request_done(smc_host->mmc, mrq);
+	return;
+}
+
+static s32 sw_mci_get_ro(struct mmc_host *mmc)
+{
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+	struct sunxi_mmc_platform_data *pdata = smc_host->pdata;
+	u32 wp_val;
+
+	if (pdata->wpmode) {
+		wp_val = gpio_read_one_pin_value(pdata->wp, "sdc_wp");
+		SMC_DBG(smc_host, "sdc fetch card wp pin status: %d \n", wp_val);
+		if (!wp_val) {
+			smc_host->read_only = 0;
+			return 0;
+		} else {
+			SMC_MSG(smc_host, "Card is write-protected\n");
+			smc_host->read_only = 1;
+			return 1;
+		}
+	} else {
+		smc_host->read_only = 0;
+		return 0;
+	}
+	return 0;
+}
+
+static void sw_mci_cd_cb(unsigned long data)
+{
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+	struct sunxi_mmc_platform_data *pdata = smc_host->pdata;
+	u32 gpio_val = 0;
+	u32 present;
+	u32 i = 0;
+
+	for (i=0; i<5; i++) {
+		gpio_val += gpio_read_one_pin_value(pdata->cd, "sdc_det");
+		mdelay(1);
+	}
+	if (gpio_val==5) {
+		present = 0;
+	} else if (gpio_val==0)
+		present = 1;
+	else
+		goto modtimer;
+	SMC_DBG(smc_host, "cd %d, host present %d, cur present %d\n",
+			gpio_val, smc_host->present, present);
+
+	if (smc_host->present ^ present) {
+		SMC_MSG(smc_host, "mmc %d detect change, present %d\n",
+				smc_host->pdev->id, present);
+		smc_host->present = present;
+		smp_wmb();
+		if (smc_host->present)
+			mmc_detect_change(smc_host->mmc, msecs_to_jiffies(500));
+		else
+			mmc_detect_change(smc_host->mmc, msecs_to_jiffies(50));
+	}
+
+modtimer:
+	if (smc_host->cd_mode == CARD_DETECT_BY_GPIO_POLL)
+		mod_timer(&smc_host->cd_timer, jiffies + msecs_to_jiffies(300));
+
+	return;
+}
+
+#if 0
+static u32 sw_mci_cd_irq(void *data)
+{
+	sw_mci_cd_cb((unsigned long)data);
+	return 0;
+}
+#endif
+
+static int sw_mci_card_present(struct mmc_host *mmc)
+{
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+	return smc_host->present;
+}
+
+static irqreturn_t sw_mci_irq(int irq, void *dev_id)
+{
+	struct sunxi_mmc_host *smc_host = dev_id;
+	u32 sdio_int = 0;
+	u32 raw_int;
+	u32 msk_int;
+	u32 idma_inte;
+	u32 idma_int;
+
+	spin_lock(&smc_host->lock);
+
+	idma_int  = mci_readl(smc_host, REG_IDST);
+	idma_inte = mci_readl(smc_host, REG_IDIE);
+	raw_int   = mci_readl(smc_host, REG_RINTR);
+	msk_int   = mci_readl(smc_host, REG_MISTA);
+	if (!msk_int && !idma_int) {
+		SMC_MSG(smc_host, "sdc%d nop irq: ri %08x mi %08x ie %08x idi %08x\n",
+			smc_host->pdev->id, raw_int, msk_int, idma_inte, idma_int);
+		spin_unlock(&smc_host->lock);
+		return IRQ_HANDLED;
+	}
+
+	smc_host->int_sum |= raw_int;
+	SMC_INF(smc_host, "smc %d irq, ri %08x(%08x) mi %08x ie %08x idi %08x\n",
+		smc_host->pdev->id, raw_int, smc_host->int_sum,
+		msk_int, idma_inte, idma_int);
+
+	if (msk_int & SDXC_SDIOInt) {
+		sdio_int = 1;
+		mci_writel(smc_host, REG_RINTR, SDXC_SDIOInt);
+		goto sdio_out;
+	}
+
+	if (smc_host->wait == SDC_WAIT_NONE && !sdio_int) {
+		SMC_ERR(smc_host, "smc %x, nothing to complete, ri %08x, "
+			"mi %08x\n", smc_host->pdev->id, raw_int, msk_int);
+		goto irq_out;
+	}
+
+	if ((raw_int & SDXC_IntErrBit) || (idma_int & SDXC_IDMA_ERR)) {
+		smc_host->error = raw_int & SDXC_IntErrBit;
+		smc_host->wait = SDC_WAIT_FINALIZE;
+		smc_host->state = SDC_STATE_CMDDONE;
+		goto irq_out;
+	}
+	if (idma_int & (SDXC_IDMACTransmitInt|SDXC_IDMACReceiveInt))
+		smc_host->dma_done = 1;
+	if (msk_int & (SDXC_AutoCMDDone|SDXC_DataOver|SDXC_CmdDone|SDXC_VolChgDone))
+		smc_host->trans_done = 1;
+	if ((smc_host->trans_done && (smc_host->wait == SDC_WAIT_AUTOCMD_DONE
+					|| smc_host->wait == SDC_WAIT_DATA_OVER
+					|| smc_host->wait == SDC_WAIT_CMD_DONE
+					|| smc_host->wait == SDC_WAIT_SWITCH1V8))
+		|| (smc_host->trans_done && smc_host->dma_done && (smc_host->wait & SDC_WAIT_DMA_DONE))) {
+		smc_host->wait = SDC_WAIT_FINALIZE;
+		smc_host->state = SDC_STATE_CMDDONE;
+	}
+
+irq_out:
+	mci_writel(smc_host, REG_RINTR, msk_int&(~SDXC_SDIOInt));
+	mci_writel(smc_host, REG_IDST, idma_int);
+
+	if (smc_host->wait == SDC_WAIT_FINALIZE) {
+		smp_wmb();
+		mci_writew(smc_host, REG_IMASK, 0);
+		tasklet_schedule(&smc_host->tasklet);
+	}
+
+sdio_out:
+	spin_unlock(&smc_host->lock);
+
+	if (sdio_int)
+		mmc_signal_sdio_irq(smc_host->mmc);
+
+	return IRQ_HANDLED;
+}
+
+static void sw_mci_tasklet(unsigned long data)
+{
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *) data;
+	sw_mci_finalize_request(smc_host);
+}
+
+static void sw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+	char* bus_mode[] = {"", "OD", "PP"};
+	char* pwr_mode[] = {"OFF", "UP", "ON"};
+	char* vdd[] = {"3.3V", "1.8V", "1.2V"};
+	char* timing[] = {"LEGACY(SDR12)", "MMC-HS(SDR20)", "SD-HS(SDR25)",
+			"UHS-SDR50", "UHS-SDR104", "UHS-DDR50", "MMC-HS200"};
+	char* drv_type[] = {"B", "A", "C", "D"};
+	static u32 last_clock[4] = {0};
+	u32 id = smc_host->pdev->id;
+	u32 temp;
+	s32 err;
+
+	BUG_ON(ios->bus_mode >= sizeof(bus_mode)/sizeof(bus_mode[0]));
+	BUG_ON(ios->power_mode >= sizeof(pwr_mode)/sizeof(pwr_mode[0]));
+	BUG_ON(ios->signal_voltage >= sizeof(vdd)/sizeof(vdd[0]));
+	BUG_ON(ios->timing >= sizeof(timing)/sizeof(timing[0]));
+	SMC_MSG(smc_host, "sdc%d set ios: "
+		"clk %dHz bm %s pm %s vdd %s width %d timing %s dt %s\n",
+		smc_host->pdev->id, ios->clock, bus_mode[ios->bus_mode],
+		pwr_mode[ios->power_mode], vdd[ios->signal_voltage],
+		1 << ios->bus_width, timing[ios->timing], drv_type[ios->drv_type]);
+
+	/* Set the power state */
+	switch (ios->power_mode) {
+		case MMC_POWER_ON:
+			break;
+		case MMC_POWER_UP:
+			if (!smc_host->power_on) {
+				SMC_MSG(smc_host, "sdc%d power on\n", smc_host->pdev->id);
+				sw_mci_restore_io(smc_host);
+				err = clk_enable(smc_host->hclk);
+				if (err) {
+					SMC_ERR(smc_host, "Failed to enable sdc%d hclk\n",
+								smc_host->pdev->id);
+				}
+				err = clk_enable(smc_host->mclk);
+				if (err) {
+					SMC_ERR(smc_host, "Failed to enable sdc%d mclk\n",
+								smc_host->pdev->id);
+				}
+				err = clk_reset(smc_host->mclk, AW_CCU_CLK_NRESET);
+				if (err) {
+					SMC_ERR(smc_host, "Failed to release sdc%d reset\n",
+								smc_host->pdev->id);
+				}
+				mdelay(1);
+				sw_mci_init_host(smc_host);
+				enable_irq(smc_host->irq);
+				smc_host->power_on = 1;
+			}
+			break;
+		case MMC_POWER_OFF:
+			if (smc_host->power_on) {
+				SMC_MSG(smc_host, "sdc%d power off\n", smc_host->pdev->id);
+				disable_irq(smc_host->irq);
+				sw_mci_exit_host(smc_host);
+				err = clk_reset(smc_host->mclk, AW_CCU_CLK_RESET);
+				if (err) {
+					SMC_ERR(smc_host, "Failed to set sdc%d reset\n",
+								smc_host->pdev->id);
+				}
+				clk_disable(smc_host->mclk);
+				clk_disable(smc_host->hclk);
+				sw_mci_hold_io(smc_host);
+				smc_host->power_on = 0;
+				smc_host->ferror = 0;
+				last_clock[id] = 0;
+			}
+			break;
+	}
+	/* set bus width */
+	switch (ios->bus_width) {
+		case MMC_BUS_WIDTH_1:
+			mci_writel(smc_host, REG_WIDTH, SDXC_WIDTH1);
+			smc_host->bus_width = 1;
+			break;
+		case MMC_BUS_WIDTH_4:
+			mci_writel(smc_host, REG_WIDTH, SDXC_WIDTH4);
+			smc_host->bus_width = 4;
+			break;
+		case MMC_BUS_WIDTH_8:
+			mci_writel(smc_host, REG_WIDTH, SDXC_WIDTH8);
+			smc_host->bus_width = 8;
+			break;
+	}
+
+	/* set ddr mode */
+	temp = mci_readl(smc_host, REG_GCTRL);
+	if (ios->timing == MMC_TIMING_UHS_DDR50) {
+		temp |= SDXC_DDR_MODE;
+		smc_host->ddr = 1;
+		/* change io driving */
+		sw_mci_update_io_driving(smc_host, 3);
+	} else {
+		temp &= ~SDXC_DDR_MODE;
+		smc_host->ddr = 0;
+	}
+	mci_writel(smc_host, REG_GCTRL, temp);
+
+	/* set up clock */
+	if (ios->clock && ios->clock != last_clock[id]) {
+		if (smc_host->ddr)
+			ios->clock = smc_host->pdata->f_ddr_max;
+		/* 8bit ddr, mod_clk = 2 * card_clk */
+		if (smc_host->ddr && smc_host->bus_width == 8)
+			smc_host->mod_clk = ios->clock << 1;
+		else
+			smc_host->mod_clk = ios->clock;
+		smc_host->card_clk = ios->clock;
+		if (smc_host->mod_clk > 45000000)
+			smc_host->mod_clk = 45000000;
+		sw_mci_set_clk(smc_host, smc_host->card_clk);
+		last_clock[id] = ios->clock;
+		usleep_range(50000, 55000);
+	} else if (!ios->clock) {
+		last_clock[id] = 0;
+		sw_mci_update_clk(smc_host);
+	}
+}
+
+static void sw_mci_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+	unsigned long flags;
+	u32 imask;
+
+	spin_lock_irqsave(&smc_host->lock, flags);
+	imask = mci_readl(smc_host, REG_IMASK);
+	if (enable)
+		imask |= SDXC_SDIOInt;
+	else
+		imask &= ~SDXC_SDIOInt;
+	mci_writel(smc_host, REG_IMASK, imask);
+	spin_unlock_irqrestore(&smc_host->lock, flags);
+}
+
+void sw_mci_hw_reset(struct mmc_host *mmc)
+{
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+	u32 id = smc_host->pdev->id;
+
+	if (id == 2 || id == 3) {
+		mci_writel(smc_host, REG_HWRST, 0);
+		udelay(10);
+		mci_writel(smc_host, REG_HWRST, 1);
+		udelay(300);
+	}
+}
+
+static void sw_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+	struct mmc_command* cmd = mrq->cmd;
+	struct mmc_data* data = mrq->data;
+	u32 byte_cnt = 0;
+	int ret;
+
+	if (sw_mci_card_present(mmc) == 0 || smc_host->ferror || 
+			smc_host->suspend || !smc_host->power_on) {
+		SMC_DBG(smc_host, "no medium present, ferr %d, suspend %d pwd %d\n",
+			    smc_host->ferror, smc_host->suspend, smc_host->power_on);
+		mrq->cmd->error = -ENOMEDIUM;
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+	smc_host->mrq = mrq;
+	if (data) {
+		byte_cnt = data->blksz * data->blocks;
+		mci_writel(smc_host, REG_BLKSZ, data->blksz);
+		mci_writel(smc_host, REG_BCNTR, byte_cnt);
+		ret = sw_mci_prepare_dma(smc_host, data);
+		if (ret < 0) {
+			SMC_ERR(smc_host, "smc %d prepare DMA failed\n", smc_host->pdev->id);
+			cmd->error = ret;
+			cmd->data->error = ret;
+			smp_wmb();
+			mmc_request_done(smc_host->mmc, mrq);
+			return;
+		}
+	}
+	sw_mci_send_cmd(smc_host, cmd);
+}
+
+static int sw_mci_do_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+
+	if (smc_host->voltage != SDC_WOLTAGE_3V3 &&
+			ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {
+		sw_mci_set_vddio(smc_host, SDC_WOLTAGE_3V3);
+		/* wait for 5ms */
+		usleep_range(1000, 1500);
+		smc_host->voltage = SDC_WOLTAGE_3V3;
+		return 0;
+	} else if (smc_host->voltage != SDC_WOLTAGE_1V8 &&
+			(ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180)) {
+		u32 data_down;
+		/* clock off */
+		sw_mci_oclk_onoff(smc_host, 0, 0);
+		/* check whether data[3:0] is 0000 */
+		data_down = mci_readl(smc_host, REG_STAS);
+		if (!(data_down & SDXC_CardPresent)) {
+			/* switch voltage of card vdd to 1.8V */
+			sw_mci_set_vddio(smc_host, SDC_WOLTAGE_1V8);
+			/* the standard defines the time limit is 5ms, here we
+			   wait for 8ms to make sure that the card completes the
+			   voltage switching */
+			usleep_range(8000, 8500);
+			/* clock on again */
+			sw_mci_oclk_onoff(smc_host, 1, 0);
+			/* wait for 1ms */
+			usleep_range(2000, 2500);
+
+			/* check whether data[3:0] is 1111 */
+			data_down = mci_readl(smc_host, REG_STAS);
+			if (data_down & SDXC_CardPresent) {
+				u32 rval = mci_readl(smc_host, REG_RINTR);
+				if ((rval & SDXC_VolChgDone & SDXC_CmdDone)
+						== (SDXC_VolChgDone & SDXC_CmdDone)) {
+					smc_host->voltage = SDC_WOLTAGE_1V8;
+					mci_writew(smc_host, REG_RINTR,
+						SDXC_VolChgDone | SDXC_CmdDone);
+					smc_host->voltage_switching = 0;
+					return 0;
+				}
+			}
+		}
+
+		/*
+		 * If we are here, that means the switch to 1.8V signaling
+		 * failed. We power cycle the card, and retry initialization
+		 * sequence by setting S18R to 0.
+		 */
+		usleep_range(5000, 5500);
+		sw_mci_set_vddio(smc_host, SDC_WOLTAGE_OFF);
+		usleep_range(1000, 1500);
+		sw_mci_set_vddio(smc_host, SDC_WOLTAGE_3V3);
+		SMC_ERR(smc_host, ": Switching to 1.8V signalling "
+			"voltage failed, retrying with S18R set to 0\n");
+		mci_writel(smc_host, REG_GCTRL, mci_readl(smc_host, REG_GCTRL)|SDXC_HWReset);
+		mci_writew(smc_host, REG_RINTR, SDXC_VolChgDone | SDXC_CmdDone);
+		sw_mci_oclk_onoff(smc_host, 1, 0);
+		smc_host->voltage_switching = 0;
+		return -EAGAIN;
+	} else
+		return 0;
+}
+
+/*
+ * Here we execute a tuning operation to find the sample window of MMC host.
+ * Then we select the best sampling point in the host for DDR50, SDR50, and
+ * SDR104 modes.
+ */
+static int sw_mci_execute_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	static const char tuning_blk_4b[] = {
+		0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+		0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+		0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+		0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+		0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+		0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+		0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+		0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde
+	};
+	static const char tuning_blk_8b[] = {
+		0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+		0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+		0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+		0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+		0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+		0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+		0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+		0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+		0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+		0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+		0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+		0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+		0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+		0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+		0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+		0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee
+	};
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+	u32 sample_min = 1;
+	u32 sample_max = 0;
+	u32 sample_bak = smc_host->sclk_dly;
+	u32 sample_dly = 0;
+	u32 sample_win = 0;
+	u32 loops = 64;
+	u32 tuning_done = 0;
+	char* rcv_pattern = (char*)kmalloc(128, GFP_KERNEL|GFP_DMA);
+	char* std_pattern = NULL;
+	int err = 0;
+
+	if (!rcv_pattern) {
+		SMC_ERR(smc_host, "sdc%d malloc tuning pattern buffer failed\n",
+				smc_host->pdev->id);
+		return -EIO;
+	}
+	SMC_MSG(smc_host, "sdc%d executes tuning operation\n", smc_host->pdev->id);
+	/*
+	 * The Host Controller needs tuning only in case of SDR104 mode
+	 * and for SDR50 mode. Issue CMD19 repeatedly till get all of the
+	 * sample points or the number of loops reaches 40 times or a
+	 * timeout of 150ms occurs.
+	 */
+	do {
+		struct mmc_command cmd = {0};
+		struct mmc_data data = {0};
+		struct mmc_request mrq = {0};
+		struct scatterlist sg;
+
+		sw_mci_set_clk_dly(smc_host, smc_host->oclk_dly, sample_dly);
+		cmd.opcode = opcode;
+		cmd.arg = 0;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+		if (opcode == MMC_SEND_TUNING_BLOCK_HS200) {
+			if (mmc->ios.bus_width == MMC_BUS_WIDTH_8) {
+				sg.length = 128;
+				data.blksz = 128;
+				std_pattern = (char*)tuning_blk_8b;
+			} else if (mmc->ios.bus_width == MMC_BUS_WIDTH_4) {
+				sg.length = 64;
+				data.blksz = 64;
+				std_pattern = (char*)tuning_blk_4b;
+			}
+		} else {
+			sg.length = 64;
+			data.blksz = 64;
+			std_pattern = (char*)tuning_blk_4b;
+		}
+		data.blocks = 1;
+		data.flags = MMC_DATA_READ;
+		data.sg = &sg;
+		data.sg_len = 1;
+		sg_init_one(&sg, rcv_pattern, sg.length);
+
+		mrq.cmd = &cmd;
+		mrq.data = &data;
+
+		mmc_wait_for_req(mmc, &mrq);
+		/*
+		 * If no error happened in the transmission, compare data with
+		 * the tuning pattern. If there is no error, record the minimal
+		 * and the maximal value of the sampling clock delay to find
+		 * the best sampling point in the sampling window.
+		 */
+		if (!cmd.error && !data.error) {
+			if (!memcmp(rcv_pattern, std_pattern, data.blksz)) {
+				SMC_MSG(smc_host, "sdc%d tuning ok, sclk_dly %d\n",
+					smc_host->pdev->id, sample_dly);
+				if (!sample_win)
+					sample_min = sample_dly;
+				sample_win++;
+				if (sample_dly == 7) {
+					SMC_MSG(smc_host, "sdc%d tuning reach to max sclk_dly 7\n",
+						smc_host->pdev->id);
+					tuning_done = 1;
+					sample_max = sample_dly;
+					break;
+				}
+			} else if (sample_win) {
+				SMC_MSG(smc_host, "sdc%d tuning data failed, sclk_dly %d\n",
+					smc_host->pdev->id, sample_dly);
+				tuning_done = 1;
+				sample_max = sample_dly-1;
+				break;
+			}
+		} else if (sample_win) {
+			SMC_MSG(smc_host, "sdc%d tuning trans fail, sclk_dly %d\n",
+				smc_host->pdev->id, sample_dly);
+			tuning_done = 1;
+			sample_max = sample_dly-1;
+			break;
+		}
+		sample_dly++;
+		/* if sclk_dly reach to 7(maximum), down the clock and tuning again */
+		if (sample_dly == 8 && loops)
+			break;
+	} while (!tuning_done && loops--);
+
+	/* select the best sampling point from the sampling window */
+	if (sample_win) {
+		sample_dly = sample_min + sample_win/2;
+		SMC_MSG(smc_host, "sdc%d sample_window:[%d, %d], sample_point %d\n",
+				smc_host->pdev->id, sample_min, sample_max, sample_dly);
+		sw_mci_set_clk_dly(smc_host, smc_host->oclk_dly, sample_dly);
+		err = 0;
+	} else {
+		SMC_ERR(smc_host, "sdc%d cannot find a sample point\n", smc_host->pdev->id);
+		sw_mci_set_clk_dly(smc_host, smc_host->oclk_dly, sample_bak);
+		mmc->ios.bus_width = MMC_BUS_WIDTH_1;
+		mmc->ios.timing = MMC_TIMING_LEGACY;
+		err = -EIO;
+	}
+
+	kfree(rcv_pattern);
+	return err;
+}
+
+/*
+ * Here provide a function to scan card, for some SDIO cards that
+ * may stay in busy status after writing operations. MMC host does
+ * not wait for ready itself. So the driver of this kind of cards
+ * should call this function to check the real status of the card.
+ */
+void sunximmc_rescan_card(unsigned id, unsigned insert)
+{
+	struct sunxi_mmc_host *smc_host = NULL;
+	if (id > 3) {
+		pr_err("%s: card id more than 3.\n", __func__);
+		return;
+	}
+
+	mutex_lock(&sw_host_rescan_mutex);
+	smc_host = sw_host[id];
+	if (!smc_host)
+		sw_host_rescan_pending[id] = insert;
+	mutex_unlock(&sw_host_rescan_mutex);
+	if (!smc_host)
+		return;
+
+	smc_host->present = insert ? 1 : 0;
+	mmc_detect_change(smc_host->mmc, 0);
+	return;
+}
+EXPORT_SYMBOL_GPL(sunximmc_rescan_card);
+
+int sw_mci_check_r1_ready(struct mmc_host* mmc, unsigned ms)
+{
+	struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+	unsigned expire = jiffies + msecs_to_jiffies(ms);
+	do {
+		if (!(mci_readl(smc_host, REG_STAS) & SDXC_CardDataBusy))
+			break;
+	} while (jiffies < expire);
+
+	if ((mci_readl(smc_host, REG_STAS) & SDXC_CardDataBusy)) {
+		SMC_MSG(smc_host, "wait r1 rdy %d ms timeout\n", ms);
+		return -1;
+	} else
+		return 0;
+}
+EXPORT_SYMBOL_GPL(sw_mci_check_r1_ready);
+
+static struct mmc_host_ops sw_mci_ops = {
+	.request	= sw_mci_request,
+	.set_ios	= sw_mci_set_ios,
+	.get_ro		= sw_mci_get_ro,
+	.get_cd		= sw_mci_card_present,
+	.enable_sdio_irq= sw_mci_enable_sdio_irq,
+	.hw_reset	= sw_mci_hw_reset,
+	.start_signal_voltage_switch = sw_mci_do_voltage_switch,
+	.execute_tuning = sw_mci_execute_tuning,
+};
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+static int sw_mci_proc_drvversion(char *page, char **start, off_t off,
+					int count, int *eof, void *data)
+{
+	char *p = page;
+
+	p += sprintf(p, "%s\n", DRIVER_VERSION);
+	return p - page;
+}
+
+static int sw_mci_proc_hostinfo(char *page, char **start, off_t off,
+					int count, int *eof, void *data)
+{
+	char *p = page;
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+	struct device* dev = &smc_host->pdev->dev;
+	char* cd_mode[] = {"None", "GPIO Check", "GPIO IRQ", "Always In", "Manual"};
+	char* state[] = {"Idle", "Sending CMD", "CMD Done"};
+	char* vol[] = {"3.3V", "1.8V", "1.2V", "off"};
+	u32 Fmclk_MHz = (smc_host->mod_clk == 24000000 ? 24000000 : 600000000)/1000000;
+	u32 Tmclk_ns = Fmclk_MHz ? 10000/Fmclk_MHz : 0;
+	u32 odly = smc_host->oclk_dly ? Tmclk_ns*smc_host->oclk_dly : Tmclk_ns >> 1;
+	u32 sdly = smc_host->sclk_dly ? Tmclk_ns*smc_host->sclk_dly : Tmclk_ns >> 1;
+
+	p += sprintf(p, " %s Host Info:\n", dev_name(dev));
+	p += sprintf(p, " REG Base  : %p\n", smc_host->reg_base);
+	p += sprintf(p, " DMA Desp  : %p(%08x)\n", smc_host->sg_cpu, smc_host->sg_dma);
+	p += sprintf(p, " Mod Clock : %d\n", smc_host->mod_clk);
+	p += sprintf(p, " Card Clock: %d\n", smc_host->card_clk);
+	p += sprintf(p, " Oclk Delay: %d(%d.%dns)\n", smc_host->oclk_dly, odly/10, odly%10);
+	p += sprintf(p, " Sclk Delay: %d(%d.%dns)\n", smc_host->sclk_dly, sdly/10, odly%10);
+	p += sprintf(p, " Bus Width : %d\n", smc_host->bus_width);
+	p += sprintf(p, " DDR Mode  : %d\n", smc_host->ddr);
+	p += sprintf(p, " Voltage   : %s\n", vol[smc_host->voltage]);
+	p += sprintf(p, " Present   : %d\n", smc_host->present);
+	p += sprintf(p, " CD Mode   : %s\n", cd_mode[smc_host->cd_mode]);
+	p += sprintf(p, " Read Only : %d\n", smc_host->read_only);
+	p += sprintf(p, " State     : %s\n", state[smc_host->state]);
+	p += sprintf(p, " Regulator : %s\n", smc_host->pdata->regulator);
+
+	return p - page;
+}
+
+static int sw_mci_proc_read_regs(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	char *p = page;
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+	u32 i;
+
+	p += sprintf(p, "Dump smc regs:\n");
+	for (i=0; i<0x100; i+=4) {
+		if (!(i&0xf))
+			p += sprintf(p, "\n0x%08x : ", (u32)(smc_host->reg_base + i));
+		p += sprintf(p, "%08x ", readl(smc_host->reg_base + i));
+	}
+	p += sprintf(p, "\n");
+
+	p += sprintf(p, "Dump ccmu regs:\n");
+	for (i=0; i<0x170; i+=4) {
+		if (!(i&0xf))
+			p += sprintf(p, "\n0x%08x : ", SW_VA_CCM_IO_BASE + i);
+		p += sprintf(p, "%08x ", readl(SW_VA_CCM_IO_BASE + i));
+	}
+	p += sprintf(p, "\n");
+
+	p += sprintf(p, "Dump gpio regs:\n");
+	for (i=0; i<0x120; i+=4) {
+		if (!(i&0xf))
+			p += sprintf(p, "\n0x%08x : ", SW_VA_PORTC_IO_BASE + i);
+		p += sprintf(p, "%08x ", readl(SW_VA_PORTC_IO_BASE + i));
+	}
+	p += sprintf(p, "\n");
+
+	p += sprintf(p, "Dump gpio irqc:\n");
+	for (i=0x200; i<0x300; i+=4) {
+		if (!(i&0xf))
+			p += sprintf(p, "\n0x%08x : ", SW_VA_PORTC_IO_BASE + i);
+		p += sprintf(p, "%08x ", readl(SW_VA_PORTC_IO_BASE + i));
+	}
+	p += sprintf(p, "\n");
+
+	return p - page;
+}
+
+static int sw_mci_proc_read_dbglevel(char *page, char **start, off_t off,
+					int count, int *eof, void *data)
+{
+	char *p = page;
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+
+	p += sprintf(p, "Debug-Level : 0- msg&err, 1- +info, 2- +dbg, 3- all\n");
+	p += sprintf(p, "current debug-level : %d\n", smc_host->debuglevel);
+	return p - page;
+}
+
+static int sw_mci_proc_write_dbglevel(struct file *file, const char __user *buffer,
+					unsigned long count, void *data)
+{
+	u32 smc_debug;
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+	smc_debug = simple_strtoul(buffer, NULL, 10);
+
+	smc_host->debuglevel = smc_debug;
+	return sizeof(smc_debug);
+}
+
+static int sw_mci_proc_read_cdmode(char *page, char **start, off_t off,
+					int count, int *eof, void *data)
+{
+	char *p = page;
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+
+	p += sprintf(p, "card detect mode: %d\n", smc_host->cd_mode);
+	return p - page;
+}
+
+static int sw_mci_proc_write_cdmode(struct file *file, const char __user *buffer,
+					unsigned long count, void *data)
+{
+	u32 cdmode;
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+	cdmode = simple_strtoul(buffer, NULL, 10);
+
+	smc_host->cd_mode = cdmode;
+	return sizeof(cdmode);
+}
+
+static int sw_mci_proc_read_insert_status(char *page, char **start, off_t off,
+					int coutn, int *eof, void *data)
+{
+	char *p = page;
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+
+	p += sprintf(p, "Usage: \"echo 1 > insert\" to scan card and "
+			"\"echo 0 > insert\" to remove card\n");
+	if (smc_host->cd_mode != CARD_DETECT_BY_FS)
+		p += sprintf(p, "Sorry, this node if only for manual "
+				"attach mode(cd mode 4)\n");
+
+	p += sprintf(p, "card attach status: %s\n",
+		smc_host->present ? "inserted" : "removed");
+
+
+	return p - page;
+}
+
+static int sw_mci_proc_card_insert_ctrl(struct file *file, const char __user *buffer,
+					unsigned long count, void *data)
+{
+	u32 insert = simple_strtoul(buffer, NULL, 10);
+	struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+	u32 present = insert ? 1 : 0;
+
+	if (smc_host->present ^ present) {
+		smc_host->present = present;
+		mmc_detect_change(smc_host->mmc, msecs_to_jiffies(300));
+	}
+
+	return sizeof(insert);
+}
+
+void sw_mci_procfs_attach(struct sunxi_mmc_host *smc_host)
+{
+	struct device *dev = &smc_host->pdev->dev;
+	char sw_mci_proc_rootname[32] = {0};
+
+	//make mmc dir in proc fs path
+	snprintf(sw_mci_proc_rootname, sizeof(sw_mci_proc_rootname),
+			"driver/%s", dev_name(dev));
+	smc_host->proc_root = proc_mkdir(sw_mci_proc_rootname, NULL);
+	if (IS_ERR(smc_host->proc_root))
+		SMC_MSG(smc_host, "%s: failed to create procfs \"driver/mmc\".\n", dev_name(dev));
+
+	smc_host->proc_drvver = create_proc_read_entry("drv-version", 0444,
+				smc_host->proc_root, sw_mci_proc_drvversion, NULL);
+	if (IS_ERR(smc_host->proc_root))
+		SMC_MSG(smc_host, "%s: failed to create procfs \"drv-version\".\n", dev_name(dev));
+
+	smc_host->proc_hostinfo = create_proc_read_entry("hostinfo", 0444,
+				smc_host->proc_root, sw_mci_proc_hostinfo, smc_host);
+	if (IS_ERR(smc_host->proc_hostinfo))
+		SMC_MSG(smc_host, "%s: failed to create procfs \"hostinfo\".\n", dev_name(dev));
+
+	smc_host->proc_regs = create_proc_read_entry("register", 0444,
+				smc_host->proc_root, sw_mci_proc_read_regs, smc_host);
+	if (IS_ERR(smc_host->proc_regs))
+		SMC_MSG(smc_host, "%s: failed to create procfs \"hostinfo\".\n", dev_name(dev));
+
+	smc_host->proc_dbglevel = create_proc_entry("debug-level", 0644, smc_host->proc_root);
+	if (IS_ERR(smc_host->proc_dbglevel))
+		SMC_MSG(smc_host, "%s: failed to create procfs \"debug-level\".\n", dev_name(dev));
+
+	smc_host->proc_dbglevel->data = smc_host;
+	smc_host->proc_dbglevel->read_proc = sw_mci_proc_read_dbglevel;
+	smc_host->proc_dbglevel->write_proc = sw_mci_proc_write_dbglevel;
+
+	smc_host->proc_cdmode = create_proc_entry("cdmode", 0644, smc_host->proc_root);
+	if (IS_ERR(smc_host->proc_cdmode))
+		SMC_MSG(smc_host, "%s: failed to create procfs \"cdmode\".\n", dev_name(dev));
+
+	smc_host->proc_cdmode->data = smc_host;
+	smc_host->proc_cdmode->read_proc = sw_mci_proc_read_cdmode;
+	smc_host->proc_cdmode->write_proc = sw_mci_proc_write_cdmode;
+
+	smc_host->proc_insert = create_proc_entry("insert", 0644, smc_host->proc_root);
+	if (IS_ERR(smc_host->proc_insert))
+		SMC_MSG(smc_host, "%s: failed to create procfs \"insert\".\n", dev_name(dev));
+
+	smc_host->proc_insert->data = smc_host;
+	smc_host->proc_insert->read_proc = sw_mci_proc_read_insert_status;
+	smc_host->proc_insert->write_proc = sw_mci_proc_card_insert_ctrl;
+}
+
+void sw_mci_procfs_remove(struct sunxi_mmc_host *smc_host)
+{
+	struct device *dev = &smc_host->pdev->dev;
+	char sw_mci_proc_rootname[32] = {0};
+
+	snprintf(sw_mci_proc_rootname, sizeof(sw_mci_proc_rootname),
+		"driver/%s", dev_name(dev));
+	remove_proc_entry("io-drive", smc_host->proc_root);
+	remove_proc_entry("insert", smc_host->proc_root);
+	remove_proc_entry("cdmode", smc_host->proc_root);
+	remove_proc_entry("debug-level", smc_host->proc_root);
+	remove_proc_entry("register", smc_host->proc_root);
+	remove_proc_entry("hostinfo", smc_host->proc_root);
+	remove_proc_entry("drv-version", smc_host->proc_root);
+	remove_proc_entry(sw_mci_proc_rootname, NULL);
+}
+
+#else
+
+void sw_mci_procfs_attach(struct sunxi_mmc_host *smc_host) { }
+void sw_mci_procfs_remove(struct sunxi_mmc_host *smc_host) { }
+
+#endif	//PROC_FS
+
+static int __devinit sw_mci_probe(struct platform_device *pdev)
+{
+	struct sunxi_mmc_host *smc_host = NULL;
+	struct mmc_host	*mmc = NULL;
+	int ret = 0;
+
+	mmc = mmc_alloc_host(sizeof(struct sunxi_mmc_host), &pdev->dev);
+	if (!mmc) {
+		SMC_ERR(smc_host, "mmc alloc host failed\n");
+		ret = -ENOMEM;
+		goto probe_out;
+	}
+
+	smc_host = mmc_priv(mmc);
+	memset((void*)smc_host, 0, sizeof(smc_host));
+	smc_host->mmc	= mmc;
+	smc_host->pdev	= pdev;
+	smc_host->pdata	= pdev->dev.platform_data;
+	smc_host->cd_mode = smc_host->pdata->cdmode;
+	smc_host->io_flag = smc_host->pdata->isiodev ? 1 : 0;
+	smc_host->debuglevel = CONFIG_MMC_PRE_DBGLVL_SUNXI;
+
+	spin_lock_init(&smc_host->lock);
+	tasklet_init(&smc_host->tasklet, sw_mci_tasklet, (unsigned long) smc_host);
+
+	if (sw_mci_resource_request(smc_host)) {
+		SMC_ERR(smc_host, "%s: Failed to get resouce.\n", dev_name(&pdev->dev));
+		goto probe_free_host;
+	}
+
+	smc_host->mod_clk = 400000;
+	if (sw_mci_set_clk(smc_host, 400000)) {
+		SMC_ERR(smc_host, "Failed to set clock to 400KHz\n");
+		ret = -ENOENT;
+		goto probe_free_resource;
+	}
+	clk_enable(smc_host->mclk);
+	clk_enable(smc_host->hclk);
+	sw_mci_init_host(smc_host);
+
+	sw_mci_procfs_attach(smc_host);
+
+	smc_host->irq = SMC_IRQNO(pdev->id);
+	if (request_irq(smc_host->irq, sw_mci_irq, 0, DRIVER_NAME, smc_host)) {
+		SMC_ERR(smc_host, "Failed to request smc card interrupt.\n");
+		ret = -ENOENT;
+		goto probe_free_resource;
+	}
+	disable_irq(smc_host->irq);
+
+	if (smc_host->cd_mode == CARD_ALWAYS_PRESENT) {
+		smc_host->present = 1;
+	} else if (smc_host->cd_mode == CARD_DETECT_BY_GPIO_IRQ) {
+#if 0 // FIXME
+		u32 cd_hdle;
+		cd_hdle = sw_gpio_irq_request(smc_host->pdata->cd.gpio, TRIG_EDGE_DOUBLE,
+					&sw_mci_cd_irq, smc_host);
+		if (!cd_hdle) {
+			SMC_ERR(smc_host, "Failed to get gpio irq for card detection\n");
+		}
+		smc_host->cd_hdle = cd_hdle;
+		smc_host->present = !__gpio_get_value(smc_host->pdata->cd.gpio);
+#else
+		SMC_ERR(smc_host, "irq based card detect not supported\n");
+		ret = -ENOENT;
+		goto probe_free_resource;
+#endif
+	} else if (smc_host->cd_mode == CARD_DETECT_BY_GPIO_POLL) {
+		init_timer(&smc_host->cd_timer);
+		smc_host->cd_timer.expires = jiffies + 1*HZ;
+		smc_host->cd_timer.function = &sw_mci_cd_cb;
+		smc_host->cd_timer.data = (unsigned long)smc_host;
+		add_timer(&smc_host->cd_timer);
+		smc_host->present = 0;
+	}
+
+	mmc->ops        = &sw_mci_ops;
+	mmc->ocr_avail	= smc_host->pdata->ocr_avail;
+	mmc->caps	= smc_host->pdata->caps;
+	mmc->caps2	= smc_host->pdata->caps2;
+	mmc->pm_caps	= MMC_PM_KEEP_POWER|MMC_PM_WAKE_SDIO_IRQ;
+	mmc->f_min	= smc_host->pdata->f_min;
+	mmc->f_max      = smc_host->pdata->f_max;
+	mmc->max_blk_count	= 8192;
+	mmc->max_blk_size	= 4096;
+	mmc->max_req_size	= mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size	= mmc->max_req_size;
+	mmc->max_segs	    	= 128;
+	if (smc_host->io_flag)
+		mmc->pm_flags = MMC_PM_IGNORE_PM_NOTIFY;
+
+	ret = mmc_add_host(mmc);
+	if (ret) {
+		SMC_ERR(smc_host, "Failed to add mmc host.\n");
+		goto probe_free_irq;
+	}
+	platform_set_drvdata(pdev, mmc);
+
+	mutex_lock(&sw_host_rescan_mutex);
+	if (sw_host_rescan_pending[pdev->id]) {
+		smc_host->present = 1;
+		mmc_detect_change(smc_host->mmc, msecs_to_jiffies(300));
+	}
+	sw_host[pdev->id] = smc_host;
+	mutex_unlock(&sw_host_rescan_mutex);
+
+	SMC_MSG(smc_host, "sdc%d Probe: base:0x%p irq:%u sg_cpu:%p(%x) ret %d.\n",
+		pdev->id, smc_host->reg_base, smc_host->irq,
+		smc_host->sg_cpu, smc_host->sg_dma, ret);
+
+	goto probe_out;
+
+probe_free_irq:
+	if (smc_host->irq)
+		free_irq(smc_host->irq, smc_host);
+probe_free_resource:
+	sw_mci_resource_release(smc_host);
+probe_free_host:
+	mmc_free_host(mmc);
+probe_out:
+	return ret;
+}
+
+static int __devexit sw_mci_remove(struct platform_device *pdev)
+{
+	struct mmc_host    	*mmc  = platform_get_drvdata(pdev);
+	struct sunxi_mmc_host	*smc_host = mmc_priv(mmc);
+
+	SMC_MSG(smc_host, "%s: Remove.\n", dev_name(&pdev->dev));
+
+	sw_mci_exit_host(smc_host);
+
+	sw_mci_procfs_remove(smc_host);
+	mmc_remove_host(mmc);
+
+	tasklet_disable(&smc_host->tasklet);
+	free_irq(smc_host->irq, smc_host);
+	if (smc_host->cd_mode == CARD_DETECT_BY_GPIO_POLL)
+		del_timer(&smc_host->cd_timer);
+#if 0
+	else if (smc_host->cd_mode == CARD_DETECT_BY_GPIO_IRQ)
+		sw_gpio_irq_free(smc_host->cd_hdle);
+#endif
+
+	sw_mci_resource_release(smc_host);
+
+	mmc_free_host(mmc);
+	sw_host[pdev->id] = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+void sw_mci_regs_save(struct sunxi_mmc_host* smc_host)
+{
+	struct sunxi_mmc_ctrl_regs* bak_regs = &smc_host->bak_regs;
+
+	bak_regs->gctrl		= mci_readl(smc_host, REG_GCTRL);
+	bak_regs->clkc		= mci_readl(smc_host, REG_CLKCR);
+	bak_regs->timeout	= mci_readl(smc_host, REG_TMOUT);
+	bak_regs->buswid	= mci_readl(smc_host, REG_WIDTH);
+	bak_regs->waterlvl	= mci_readl(smc_host, REG_FTRGL);
+	bak_regs->funcsel	= mci_readl(smc_host, REG_FUNS);
+	bak_regs->debugc	= mci_readl(smc_host, REG_DBGC);
+	bak_regs->idmacc	= mci_readl(smc_host, REG_DMAC);
+}
+
+void sw_mci_regs_restore(struct sunxi_mmc_host* smc_host)
+{
+	struct sunxi_mmc_ctrl_regs* bak_regs = &smc_host->bak_regs;
+
+	mci_writel(smc_host, REG_GCTRL, bak_regs->gctrl   );
+	mci_writel(smc_host, REG_CLKCR, bak_regs->clkc    );
+	mci_writel(smc_host, REG_TMOUT, bak_regs->timeout );
+	mci_writel(smc_host, REG_WIDTH, bak_regs->buswid  );
+	mci_writel(smc_host, REG_FTRGL, bak_regs->waterlvl);
+	mci_writel(smc_host, REG_FUNS , bak_regs->funcsel );
+	mci_writel(smc_host, REG_DBGC , bak_regs->debugc  );
+	mci_writel(smc_host, REG_DMAC , bak_regs->idmacc  );
+}
+
+static int sw_mci_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (mmc) {
+		struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+		ret = mmc_suspend_host(mmc);
+		smc_host->suspend = ret ? 0 : 1;
+		if (!ret && mmc_card_keep_power(mmc)) {
+			sw_mci_regs_save(smc_host);
+			/* gate clock for lower power */
+			clk_disable(smc_host->hclk);
+			clk_disable(smc_host->mclk);
+		}
+		SMC_MSG(NULL, "smc %d suspend\n", pdev->id);
+	}
+
+	return ret;
+}
+
+static int sw_mci_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (mmc) {
+		struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+		smc_host->suspend = 0;
+		if (mmc_card_keep_power(mmc)) {
+			/* enable clock for resotre */
+			clk_enable(smc_host->mclk);
+			clk_enable(smc_host->hclk);
+			sw_mci_regs_restore(smc_host);
+			sw_mci_update_clk(smc_host);
+		}
+		if (smc_host->cd_mode == CARD_DETECT_BY_GPIO_IRQ)
+			sw_mci_cd_cb((unsigned long)smc_host);
+		ret = mmc_resume_host(mmc);
+		smc_host->suspend = ret ? 1 : 0;
+		SMC_MSG(NULL, "smc %d resume\n", pdev->id);
+	}
+
+	return ret;
+}
+
+static const struct dev_pm_ops sw_mci_pm = {
+	.suspend	= sw_mci_suspend,
+	.resume		= sw_mci_resume,
+};
+#define sw_mci_pm_ops &sw_mci_pm
+
+#else /* CONFIG_PM */
+
+#define sw_mci_pm_ops NULL
+
+#endif /* CONFIG_PM */
+
+static struct sunxi_mmc_platform_data sw_mci_pdata[4] = {
+	[0] = {
+		.ocr_avail = MMC_VDD_28_29 | MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32
+				| MMC_VDD_32_33 | MMC_VDD_33_34,
+		.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED
+			| MMC_CAP_SDIO_IRQ
+			| MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50
+			| MMC_CAP_UHS_DDR50
+			| MMC_CAP_SET_XPC_330 | MMC_CAP_DRIVER_TYPE_A,
+		.f_min = 400000,
+		.f_max = 50000000,
+		.f_ddr_max = 47000000,
+		.dma_tl= 0x20070008,
+	},
+	[1] = {
+		.ocr_avail = MMC_VDD_28_29 | MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32
+				| MMC_VDD_32_33 | MMC_VDD_33_34,
+		.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED
+			| MMC_CAP_SDIO_IRQ,
+		.f_min = 400000,
+		.f_max = 50000000,
+		.dma_tl= 0x20070008,
+	},
+	[2] = {
+		.ocr_avail = MMC_VDD_28_29 | MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32
+				| MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195,
+		.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_NONREMOVABLE
+			| MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED
+			| MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50
+			| MMC_CAP_UHS_DDR50
+			| MMC_CAP_1_8V_DDR
+			#ifndef CONFIG_AW_FPGA_PLATFORM
+			| MMC_CAP_8_BIT_DATA
+			#endif
+			| MMC_CAP_SDIO_IRQ
+			| MMC_CAP_SET_XPC_330 | MMC_CAP_DRIVER_TYPE_A,
+		.caps2 = MMC_CAP2_HS200_1_8V_SDR,
+		.f_min = 400000,
+		.f_max = 120000000,
+		.f_ddr_max = 50000000,
+		.dma_tl= 0x20070008,
+	},
+	[3] = {
+		.ocr_avail = MMC_VDD_28_29 | MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32
+				| MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195,
+		.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE
+			| MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED
+			| MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50
+			| MMC_CAP_UHS_DDR50
+			| MMC_CAP_1_8V_DDR
+			| MMC_CAP_8_BIT_DATA
+			| MMC_CAP_SDIO_IRQ
+			| MMC_CAP_SET_XPC_330 | MMC_CAP_DRIVER_TYPE_A,
+		.caps2 = MMC_CAP2_HS200_1_8V_SDR,
+		.f_min = 400000,
+		.f_max = 120000000,
+		.f_ddr_max = 50000000,
+		.dma_tl= MMC3_DMA_TL,
+	},
+};
+static struct platform_device sw_mci_device[4] = {
+	[0] = {.name = DRIVER_NAME, .id = 0, .dev.platform_data = &sw_mci_pdata[0]},
+	[1] = {.name = DRIVER_NAME, .id = 1, .dev.platform_data = &sw_mci_pdata[1]},
+	[2] = {.name = DRIVER_NAME, .id = 2, .dev.platform_data = &sw_mci_pdata[2]},
+	[3] = {.name = DRIVER_NAME, .id = 3, .dev.platform_data = &sw_mci_pdata[3]},
+};
+
+static struct platform_driver sw_mci_driver = {
+	.driver.name    = DRIVER_NAME,
+	.driver.owner   = THIS_MODULE,
+	.driver.pm	= sw_mci_pm_ops,
+	.probe          = sw_mci_probe,
+	.remove         = __devexit_p(sw_mci_remove),
+};
+
+static int __init sw_mci_get_mmcinfo(int i)
+{
+	int j, r, val;
+	char p[16];
+	struct sunxi_mmc_platform_data* mmcinfo;
+	script_parser_value_type_t type;
+
+	mmcinfo = &sw_mci_pdata[i];
+	sprintf(p, "mmc%d_para", i);
+
+	/* get used information */
+	r = script_parser_fetch(p, "sdc_used", &val, 1);
+	if (r != 0) {
+		SMC_MSG(NULL, "get mmc%d's used failed\n", i);
+		goto fail;
+	}
+	mmcinfo->used = val;
+	if (!mmcinfo->used)
+		return 0;
+
+	/* get cdmode information */
+	r = script_parser_fetch(p, "sdc_detmode", &val, 1);
+	if (r != 0) {
+		SMC_MSG(NULL, "get mmc%d's detmode failed\n", i);
+		goto fail;
+	}
+	mmcinfo->cdmode = val;
+	if (mmcinfo->cdmode == CARD_DETECT_BY_GPIO_POLL ||
+		mmcinfo->cdmode == CARD_DETECT_BY_GPIO_IRQ) {
+		mmcinfo->cd = gpio_request_ex(p, "sdc_det");
+		if (!mmcinfo->cd) {
+			SMC_MSG(NULL, "get mmc%d's IO(det) failed\n", i);
+			goto fail;
+		}
+	}
+	/* get buswidth information */
+	r = script_parser_fetch(p, "sdc_buswidth", &val, 1);
+	if (r == 0) {
+		mmcinfo->width = val;
+	} else {
+		/* No bus_width info, use old driver hardcoded defaults */
+		mmcinfo->width = 4;
+	}
+
+	/* get mmc IOs information */
+	for (j = 0; j < mmcinfo->width + 2; j++) {
+		mmcinfo->mmcio[j] = gpio_request_ex(p, mmc_para_io[j]);
+		if (!mmcinfo->mmcio[j]) {
+			SMC_MSG(NULL, "get mmc%d's IO(%s) failed\n", i,
+				mmc_para_io[j]);
+			goto fail;
+		}
+		r = gpio_get_one_pin_status(mmcinfo->mmcio[j],
+			&mmcinfo->mmcio_settings[j], mmc_para_io[j], 0);
+		if (r != 0) {
+			SMC_MSG(NULL, "get mmc%d's IO(%s) settings failed\n",
+				i, mmc_para_io[j]);
+			goto fail;
+		}
+	}
+
+	/* get wpmode information */
+	r = script_parser_fetch(p, "sdc_use_wp", &val, 1);
+	if (r == 0) {
+		mmcinfo->wpmode = val;
+	} else {
+		SMC_MSG(NULL, "get mmc%d's use_wp failed\n", i);
+		mmcinfo->wpmode = 0;
+	}
+	if (mmcinfo->wpmode) {
+		/* if wpmode==1 but cann't get the wp IO, we assume there is no
+		   write protect detection */
+		mmcinfo->wp = gpio_request_ex(p, "sdc_wp");
+		if (!mmcinfo->wp) {
+			SMC_MSG(NULL, "get mmc%d's IO(sdc_wp) failed\n", i);
+			mmcinfo->wpmode = 0;
+		}
+	}
+
+	/* get emmc-rst information */
+	mmcinfo->hwrst = gpio_request_ex(p, "emmc_rst");
+	mmcinfo->has_hwrst = mmcinfo->hwrst != 0;
+
+	/* get sdio information */
+	r = script_parser_fetch(p, "sdc_isio", &val, 1);
+	if (r == 0) {
+		mmcinfo->isiodev = val;
+	} else {
+		/* No sdio info, use old driver hardcoded defaults */
+		int default_iodev = sunxi_is_sun5i() ? 1 : 3;
+		mmcinfo->isiodev = i == default_iodev;
+	}
+
+	/* get regulator information */
+	type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+	r = script_parser_fetch_ex(p, "sdc_regulator",
+		(int *)&mmcinfo->regulator, &type,
+		sizeof(mmcinfo->regulator)/sizeof(int));
+	if (r |= 0 || type != SCRIPT_PARSER_VALUE_TYPE_STRING ||
+		      strcmp(mmcinfo->regulator, "none") == 0) {
+		/* No regulator, clear all of the UHS features support */
+		mmcinfo->caps &= ~(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
+				   MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_DDR50);
+		mmcinfo->regulator[0] = 0;
+	} else
+		mmcinfo->regulator[sizeof(mmcinfo->regulator) - 1] = 0;
+
+	return 0;
+fail:
+	SMC_MSG(NULL, "Not using mmc%d due to script.bin parse failure\n", i);
+	mmcinfo->used = 0;
+	return -1;
+}
+
+static int __init sw_mci_init(void)
+{
+	int i;
+	int sdc_used = 0;
+	int boot_card = 0;
+	int io_used = 0;
+	struct sunxi_mmc_platform_data* mmcinfo;
+
+	SMC_MSG(NULL, "sw_mci_init\n");
+	/* get devices information from sys_config.fex */
+	for (i = 0; i < sw_host_num; i++)
+		sw_mci_get_mmcinfo(i);
+
+	/*
+	 * Here we check whether there is a boot card. If the boot card exists,
+	 * we register it firstly to make it be associatiated with the device
+	 * node 'mmcblk0'. Then the applicantions of Android can fix the boot,
+	 * system, data patitions on mmcblk0p1, mmcblk0p2... etc.
+	 */
+	for (i = 0; i < sw_host_num; i++) {
+		mmcinfo = &sw_mci_pdata[i];
+		if (mmcinfo->used) {
+			sdc_used |= 1 << i;
+			if (mmcinfo->cdmode == CARD_ALWAYS_PRESENT)
+				boot_card |= 1 << i;
+			if (mmcinfo->isiodev)
+				io_used |= 1 << i;
+		}
+	}
+
+	SMC_MSG(NULL, "MMC host used card: 0x%x, boot card: 0x%x, io_card %d\n",
+					sdc_used, boot_card, io_used);
+	/* register boot card firstly */
+	for (i = 0; i < sw_host_num; i++) {
+		if (boot_card & (1 << i))
+			platform_device_register(&sw_mci_device[i]);
+	}
+	/* register other cards */
+	for (i = 0; i < sw_host_num; i++) {
+		if (boot_card & (1 << i))
+			continue;
+		if (sdc_used & (1 << i))
+			platform_device_register(&sw_mci_device[i]);
+	}
+
+	return platform_driver_register(&sw_mci_driver);
+}
+
+static void __exit sw_mci_exit(void)
+{
+	SMC_MSG(NULL, "sw_mci_exit\n");
+	platform_driver_unregister(&sw_mci_driver);
+}
+
+
+module_init(sw_mci_init);
+module_exit(sw_mci_exit);
+
+MODULE_DESCRIPTION("Winner's SD/MMC Card Controller Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Aaron.maoye<leafy.myeh@reuuimllatech.com>");
+MODULE_ALIAS("platform:sunxi-mmc");
diff --git a/drivers/mmc/host/sunxi-mci.h b/drivers/mmc/host/sunxi-mci.h
new file mode 100644
index 0000000..8e385c5
--- /dev/null
+++ b/drivers/mmc/host/sunxi-mci.h
@@ -0,0 +1,405 @@
+/*
+ * drivers/mmc/host/sunxi-mci.h
+ * (C) Copyright 2007-2011
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * Aaron.Maoye <leafy.myeh@reuuimllatech.com>
+ *
+ * description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _SW_HOST_OP_H_
+#define _SW_HOST_OP_H_ "host_op.h"
+
+#include <plat/sys_config.h>
+
+#define DRIVER_NAME "sunxi-mmc"
+#define DRIVER_RIVISION "Rev3.1"
+#define DRIVER_VERSION " SD/MMC/SDIO Host Controller Driver(" DRIVER_RIVISION ")\n" \
+			" Compatible with SD3.0/eMMC4.5/SDIO2.0\n" \
+			" Compiled in " __DATE__ " at " __TIME__ ""
+
+/*========== platform define ==========*/
+/*---------- for sun5i ----------*/
+#ifdef CONFIG_ARCH_SUN5I
+#define REG_FIFO_OS		(0x100)
+#define SMC_IRQNO(x)		(SW_INT_IRQNO_SDMC0 + (x))
+
+#define MMC_SRCCLK_HOSC		"hosc"
+#define MMC_SRCCLK_PLL5		"sdram_pll_p"
+#define MMC_SRCCLK_PLL6		"sata_pll_2"
+#define MMC_AHBCLK_PREFIX	"ahb_sdc"
+#define MMC_MODCLK_PREFIX	"sdc"
+#define MMC3_DMA_TL		(0x20070008)
+#endif
+
+/*---------- for sun6i ----------*/
+#ifdef CONFIG_ARCH_SUN6I
+#define REG_FIFO_OS	            (0x200)
+#define SMC_IRQNO(x)	        (SW_INT_IRQNO_SDMC0 + (x))
+
+#define MMC_SRCCLK_HOSC         CLK_SYS_HOSC
+#define MMC_SRCCLK_PLL6         CLK_SYS_PLL6
+#define MMC_AHBCLK_PREFIX       "ahb_sdmmc"
+#define MMC_MODCLK_PREFIX       "mod_sdc"
+#define MMC3_DMA_TL             (0x2007000f)
+
+#ifdef CONFIG_AW_FPGA_PLATFORM
+#undef SMC_IRQNO
+#define SMC_IRQNO(x)	        ((x) & 2 ? AW_IRQ_MMC2 : AW_IRQ_MMC0)
+#define SMC_FPGA_MMC_PREUSED(x)	((x) == 2 || (x) == 0)
+#endif
+#endif
+
+/*---------- for sun7i ----------*/
+#ifdef CONFIG_ARCH_SUN7I
+#define REG_FIFO_OS	            (0x100)
+#define SMC_IRQNO(x)	        (SW_INT_IRQNO_SDMC0 + (x))
+
+#define MMC_SRCCLK_HOSC         "hosc"
+#define MMC_SRCCLK_PLL5         "sdram_pll_p"
+#define MMC_SRCCLK_PLL6         "sata_pll"
+#define MMC_AHBCLK_PREFIX       "ahb_sdc"
+#define MMC_MODCLK_PREFIX       "sdc"
+#define MMC3_DMA_TL             (0x20070008)
+
+#ifdef CONFIG_AW_FPGA_PLATFORM
+#undef SMC_IRQNO
+#define SMC_IRQNO(x)	        ((x) & 2 ? AW_IRQ_MMC2 : AW_IRQ_MMC0)
+#define SMC_FPGA_MMC_PREUSED(x)	((x) == 0 || (x) == 2)
+#endif
+#endif
+
+/* SDXC register operation */
+#define SMC0_BASE	(0x01C0f000)
+#define SMC_BASE_OS	(0x1000)
+#define SMC_BASE(x)	(SMC0_BASE + 0x1000 * (x))
+
+/* register offset define */
+#define SDXC_REG_GCTRL	( 0x00 ) // SMC Global Control Register
+#define SDXC_REG_CLKCR	( 0x04 ) // SMC Clock Control Register
+#define SDXC_REG_TMOUT	( 0x08 ) // SMC Time Out Register
+#define SDXC_REG_WIDTH	( 0x0C ) // SMC Bus Width Register
+#define SDXC_REG_BLKSZ	( 0x10 ) // SMC Block Size Register
+#define SDXC_REG_BCNTR	( 0x14 ) // SMC Byte Count Register
+#define SDXC_REG_CMDR	( 0x18 ) // SMC Command Register
+#define SDXC_REG_CARG	( 0x1C ) // SMC Argument Register
+#define SDXC_REG_RESP0	( 0x20 ) // SMC Response Register 0
+#define SDXC_REG_RESP1	( 0x24 ) // SMC Response Register 1
+#define SDXC_REG_RESP2	( 0x28 ) // SMC Response Register 2
+#define SDXC_REG_RESP3	( 0x2C ) // SMC Response Register 3
+#define SDXC_REG_IMASK	( 0x30 ) // SMC Interrupt Mask Register
+#define SDXC_REG_MISTA	( 0x34 ) // SMC Masked Interrupt Status Register
+#define SDXC_REG_RINTR	( 0x38 ) // SMC Raw Interrupt Status Register
+#define SDXC_REG_STAS	( 0x3C ) // SMC Status Register
+#define SDXC_REG_FTRGL	( 0x40 ) // SMC FIFO Threshold Watermark Registe
+#define SDXC_REG_FUNS	( 0x44 ) // SMC Function Select Register
+#define SDXC_REG_CBCR	( 0x48 ) // SMC CIU Byte Count Register
+#define SDXC_REG_BBCR	( 0x4C ) // SMC BIU Byte Count Register
+#define SDXC_REG_DBGC	( 0x50 ) // SMC Debug Enable Register
+#define SDXC_REG_HWRST	( 0x78 ) // SMC Card Hardware Reset for Register
+#define SDXC_REG_DMAC	( 0x80 ) // SMC IDMAC Control Register
+#define SDXC_REG_DLBA	( 0x84 ) // SMC IDMAC Descriptor List Base Addre
+#define SDXC_REG_IDST	( 0x88 ) // SMC IDMAC Status Register
+#define SDXC_REG_IDIE	( 0x8C ) // SMC IDMAC Interrupt Enable Register
+#define SDXC_REG_CHDA	( 0x90 )
+#define SDXC_REG_CBDA	( 0x94 )
+#define SDXC_REG_FIFO	( REG_FIFO_OS ) // SMC FIFO Access Address
+
+#define mci_readl(host, reg) \
+	__raw_readl((host)->reg_base + SDXC_##reg)
+#define mci_writel(host, reg, value) \
+	__raw_writel((value), (host)->reg_base + SDXC_##reg)
+#define mci_readw(host, reg) \
+	__raw_readw((host)->reg_base + SDXC_##reg)
+#define mci_writew(host, reg, value) \
+	__raw_writew((value), (host)->reg_base + SDXC_##reg)
+
+/* bit field for registers */
+/* global control register */
+#define SDXC_SoftReset		BIT(0)
+#define SDXC_FIFOReset		BIT(1)
+#define SDXC_DMAReset		BIT(2)
+#define SDXC_HWReset		(SDXC_SoftReset|SDXC_FIFOReset|SDXC_DMAReset)
+#define SDXC_INTEnb		BIT(4)
+#define SDXC_DMAEnb		BIT(5)
+#define SDXC_DebounceEnb	BIT(8)
+#define SDXC_DDR_MODE		BIT(10)
+#define SDXC_WaitMemAccessDone	BIT(30)
+#define SDXC_ACCESS_BY_AHB	BIT(31)
+#define SDXC_ACCESS_BY_DMA	(0U << 31)
+/* Clock control */
+#define SDXC_CardClkOn		BIT(16)
+#define SDXC_LowPowerOn		BIT(17)
+/* bus width */
+#define SDXC_WIDTH1		(0)
+#define SDXC_WIDTH4		(1)
+#define SDXC_WIDTH8		(2)
+/* Struct for SMC Commands */
+#define SDXC_RspExp		BIT(6) //0x40
+#define SDXC_LongRsp		BIT(7) //0x80
+#define SDXC_CheckRspCRC	BIT(8) //0x100
+#define SDXC_DataExp		BIT(9) //0x200
+#define SDXC_Write		BIT(10) //0x400
+#define SDXC_Seqmod		BIT(11) //0x800
+#define SDXC_SendAutoStop	BIT(12) //0x1000
+#define SDXC_WaitPreOver	BIT(13) //0x2000
+#define SDXC_StopAbortCMD	BIT(14) //0x4000
+#define SDXC_SendInitSeq	BIT(15) //0x8000
+#define SDXC_UPCLKOnly		BIT(21) //0x200000
+#define SDXC_RdCEATADev		BIT(22) //0x400000
+#define SDXC_CCSExp		BIT(23) //0x800000
+#define SDXC_EnbBoot		BIT(24) //0x1000000
+#define SDXC_AltBootOpt		BIT(25) //0x2000000
+#define SDXC_BootACKExp		BIT(26) //0x4000000
+#define SDXC_BootAbort		BIT(27) //0x8000000
+#define SDXC_VolSwitch	        BIT(28) //0x10000000
+#define SDXC_UseHoldReg	        BIT(29) //0x20000000
+#define SDXC_Start	        BIT(31) //0x80000000
+/* Struct for Intrrrupt Information */
+#define SDXC_RespErr		BIT(1) //0x2
+#define SDXC_CmdDone		BIT(2) //0x4
+#define SDXC_DataOver		BIT(3) //0x8
+#define SDXC_TxDataReq		BIT(4) //0x10
+#define SDXC_RxDataReq		BIT(5) //0x20
+#define SDXC_RespCRCErr		BIT(6) //0x40
+#define SDXC_DataCRCErr		BIT(7) //0x80
+#define SDXC_RespTimeout	BIT(8) //0x100
+#define SDXC_ACKRcv		BIT(8)	//0x100
+#define SDXC_DataTimeout	BIT(9)	//0x200
+#define SDXC_BootStart		BIT(9)	//0x200
+#define SDXC_DataStarve		BIT(10) //0x400
+#define SDXC_VolChgDone		BIT(10) //0x400
+#define SDXC_FIFORunErr		BIT(11) //0x800
+#define SDXC_HardWLocked	BIT(12)	//0x1000
+#define SDXC_StartBitErr	BIT(13)	//0x2000
+#define SDXC_AutoCMDDone	BIT(14)	//0x4000
+#define SDXC_EndBitErr		BIT(15)	//0x8000
+#define SDXC_SDIOInt		BIT(16)	//0x10000
+#define SDXC_CardInsert		BIT(30) //0x40000000
+#define SDXC_CardRemove		BIT(31) //0x80000000
+#define SDXC_IntErrBit		(SDXC_RespErr | SDXC_RespCRCErr | SDXC_DataCRCErr \
+				| SDXC_RespTimeout | SDXC_DataTimeout | SDXC_FIFORunErr \
+				| SDXC_HardWLocked | SDXC_StartBitErr | SDXC_EndBitErr)  //0xbfc2
+/* status */
+#define SDXC_RXWLFlag		BIT(0)
+#define SDXC_TXWLFlag		BIT(1)
+#define SDXC_FIFOEmpty		BIT(2)
+#define SDXC_FIFOFull		BIT(3)
+#define SDXC_CardPresent	BIT(8)
+#define SDXC_CardDataBusy	BIT(9)
+#define SDXC_DataFSMBusy	BIT(10)
+#define SDXC_DMAReq		BIT(31)
+#define SDXC_FIFO_SIZE		(16)
+/* Function select */
+#define SDXC_CEATAOn		(0xceaaU << 16)
+#define SDXC_SendIrqRsp		BIT(0)
+#define SDXC_SDIORdWait		BIT(1)
+#define SDXC_AbtRdData		BIT(2)
+#define SDXC_SendCCSD		BIT(8)
+#define SDXC_SendAutoStopCCSD	BIT(9)
+#define SDXC_CEATADevIntEnb	BIT(10)
+/* IDMA controller bus mod bit field */
+#define SDXC_IDMACSoftRST	BIT(0)
+#define SDXC_IDMACFixBurst	BIT(1)
+#define SDXC_IDMACIDMAOn	BIT(7)
+#define SDXC_IDMACRefetchDES	BIT(31)
+/* IDMA status bit field */
+#define SDXC_IDMACTransmitInt	BIT(0)
+#define SDXC_IDMACReceiveInt	BIT(1)
+#define SDXC_IDMACFatalBusErr	BIT(2)
+#define SDXC_IDMACDesInvalid	BIT(4)
+#define SDXC_IDMACCardErrSum	BIT(5)
+#define SDXC_IDMACNormalIntSum	BIT(8)
+#define SDXC_IDMACAbnormalIntSum BIT(9)
+#define SDXC_IDMACHostAbtInTx	BIT(10)
+#define SDXC_IDMACHostAbtInRx	BIT(10)
+#define SDXC_IDMACIdle		(0U << 13)
+#define SDXC_IDMACSuspend	(1U << 13)
+#define SDXC_IDMACDESCRd	(2U << 13)
+#define SDXC_IDMACDESCCheck	(3U << 13)
+#define SDXC_IDMACRdReqWait	(4U << 13)
+#define SDXC_IDMACWrReqWait	(5U << 13)
+#define SDXC_IDMACRd		(6U << 13)
+#define SDXC_IDMACWr		(7U << 13)
+#define SDXC_IDMACDESCClose	(8U << 13)
+
+#define SDXC_IDMA_OVER (SDXC_IDMACTransmitInt|SDXC_IDMACReceiveInt|SDXC_IDMACNormalIntSum)
+#define SDXC_IDMA_ERR (SDXC_IDMACFatalBusErr|SDXC_IDMACDesInvalid \
+			|SDXC_IDMACCardErrSum|SDXC_IDMACAbnormalIntSum)
+
+#define SDXC_DES_NUM_SHIFT	(15)
+#define SDXC_DES_BUFFER_MAX_LEN	(1U << SDXC_DES_NUM_SHIFT)
+struct sunxi_mmc_idma_des {
+	u32	config;
+#define SDXC_IDMAC_DES0_DIC	BIT(1) // disable interrupt on completion
+#define SDXC_IDMAC_DES0_LD	BIT(2) // last descriptor
+#define SDXC_IDMAC_DES0_FD	BIT(3) // first descriptor
+#define SDXC_IDMAC_DES0_CH	BIT(4) // chain mode
+#define SDXC_IDMAC_DES0_ER	BIT(5) // end of ring
+#define SDXC_IDMAC_DES0_CES	BIT(30) // card error summary
+#define SDXC_IDMAC_DES0_OWN	BIT(31) // des owner:1-idma owns it, 0-host owns it
+
+	u32	data_buf1_sz    :16,
+		data_buf2_sz    :16;
+	u32	buf_addr_ptr1;
+	u32	buf_addr_ptr2;
+};
+
+struct sunxi_mmc_ctrl_regs {
+	u32 gctrl;
+	u32 clkc;
+	u32 timeout;
+	u32 buswid;
+	u32 waterlvl;
+	u32 funcsel;
+	u32 debugc;
+	u32 idmacc;
+};
+
+struct sunxi_mmc_platform_data {
+	/* predefine information */
+	u32 ocr_avail;
+	u32 caps;
+	u32 caps2;
+	u32 f_min;
+	u32 f_max;
+	u32 f_ddr_max;
+	u32 dma_tl;
+	char regulator[32];
+
+	/* sys config information */
+	u32 used:8,
+	    cdmode:8,
+	    width:4,
+	    wpmode:4,
+	    has_hwrst:4,
+	    isiodev:4;
+	u32 mmcio[10];
+	user_gpio_set_t mmcio_settings[10];
+	u32 hwrst;
+	u32 cd;
+	u32 wp;
+};
+
+struct sunxi_mmc_host {
+
+	struct platform_device  *pdev;
+	struct mmc_host *mmc;
+	struct sunxi_mmc_platform_data  *pdata;
+
+	/* IO mapping base */
+	void __iomem 	*reg_base;
+	spinlock_t 	lock;
+	struct tasklet_struct tasklet;
+
+	/* clock management */
+	struct clk 	*hclk;
+	struct clk 	*mclk;
+
+	/* ios information */
+	u32 		mod_clk;
+	u32 		card_clk;
+	u32 		oclk_dly;
+	u32 		sclk_dly;
+	u32 		bus_width;
+	u32 		ddr;
+	u32 		voltage;
+#define SDC_WOLTAGE_3V3 (0)
+#define SDC_WOLTAGE_1V8 (1)
+#define SDC_WOLTAGE_1V2 (2)
+#define SDC_WOLTAGE_OFF (3)
+	u32 		voltage_switching;
+	struct regulator *regulator;
+	u32 		present;
+
+	/* irq */
+	int 		irq;
+	volatile u32	int_sum;
+
+	volatile u32 	trans_done:1;
+	volatile u32 	dma_done:1;
+	dma_addr_t	sg_dma;
+	void		*sg_cpu;
+
+	struct mmc_request *mrq;
+	volatile u32	error;
+	volatile u32	ferror;
+	volatile u32	wait;
+#define SDC_WAIT_NONE		(1<<0)
+#define SDC_WAIT_CMD_DONE	(1<<1)
+#define SDC_WAIT_DATA_OVER	(1<<2)
+#define SDC_WAIT_AUTOCMD_DONE	(1<<3)
+#define SDC_WAIT_DMA_DONE	(1<<4)
+#define SDC_WAIT_RXDATA_OVER	(SDC_WAIT_DATA_OVER|SDC_WAIT_DMA_DONE)
+#define SDC_WAIT_RXAUTOCMD_DONE	(SDC_WAIT_AUTOCMD_DONE|SDC_WAIT_DMA_DONE)
+#define SDC_WAIT_ERROR		(1<<6)
+#define SDC_WAIT_SWITCH1V8	(1<<7)
+#define SDC_WAIT_FINALIZE	(1<<8)
+	volatile u32	state;
+#define SDC_STATE_IDLE		(0)
+#define SDC_STATE_SENDCMD	(1)
+#define SDC_STATE_CMDDONE	(2)
+
+	struct timer_list cd_timer;
+	u32 pio_hdle;
+	s32 cd_hdle;
+	s32 cd_mode;
+#define CARD_DETECT_BY_GPIO_POLL (1)	/* mmc detected by gpio check */
+#define CARD_DETECT_BY_GPIO_IRQ  (2)	/* mmc detected by gpio irq */
+#define CARD_ALWAYS_PRESENT      (3)	/* mmc always present, without detect pin */
+#define CARD_DETECT_BY_FS        (4)	/* mmc insert/remove by fs, /proc/sunxi-mmc.x/insert node */
+
+	u32 power_on:8;
+	u32 read_only:8;
+	u32 io_flag:8;
+	u32 suspend:8;
+
+	u32 debuglevel;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc_root;
+	struct proc_dir_entry *proc_drvver;
+	struct proc_dir_entry *proc_hostinfo;
+	struct proc_dir_entry *proc_dbglevel;
+	struct proc_dir_entry *proc_regs;
+	struct proc_dir_entry *proc_insert;
+	struct proc_dir_entry *proc_cdmode;
+#endif
+
+	/* backup register structrue */
+	struct sunxi_mmc_ctrl_regs bak_regs;
+};
+
+#define SMC_MSG(d, ...) \
+    do { \
+        pr_info("[mmc-msg] "__VA_ARGS__); \
+    } while(0)
+#define SMC_ERR(d, ...) \
+    do { \
+		pr_err("[mmc-err] "__VA_ARGS__); \
+    } while(0)
+
+#define SMC_DEBUG_INFO	BIT(0)
+#define SMC_DEBUG_DBG	BIT(1)
+
+#ifdef CONFIG_MMC_DEBUG_SUNXI
+#define SMC_INF(d, ...) \
+    do { \
+        if ((d)->debuglevel & SMC_DEBUG_INFO) \
+			pr_info("[mmc-inf] "__VA_ARGS__); \
+    } while(0)
+#define SMC_DBG(d, ...) \
+    do { \
+        if ((d)->debuglevel & SMC_DEBUG_DBG) \
+			printk("[mmc-dbg] "__VA_ARGS__); \
+    } while(0)
+#else
+#define SMC_INF(d, ...)     do {} while (0)
+#define SMC_DBG(d, ...)     do {} while (0)
+#endif
+
+#endif
diff --git a/drivers/mmc/mmc-pm/Kconfig b/drivers/mmc/mmc-pm/Kconfig
new file mode 100644
index 0000000..084ed2a
--- /dev/null
+++ b/drivers/mmc/mmc-pm/Kconfig
@@ -0,0 +1,13 @@
+#
+# MMC/SD host controller drivers
+#
+
+comment "MMC/SD/SDIO Card Power Management Drivers"
+
+config MMC_SUNXI_POWER_CONTROL
+	tristate "SUNXI Card Power Management support"
+	depends on MMC_SUNXI || MMC_SUNXI_NEW
+	help
+	  This selects Allwinner MMC Card Power Management support.  
+	  All power relative gpio control here.
+	  
\ No newline at end of file
diff --git a/drivers/mmc/mmc-pm/Makefile b/drivers/mmc/mmc-pm/Makefile
new file mode 100644
index 0000000..5e04e52
--- /dev/null
+++ b/drivers/mmc/mmc-pm/Makefile
@@ -0,0 +1,10 @@
+
+#
+# Makefile for MMC/SD host controller drivers
+#
+
+obj-$(CONFIG_MMC_SUNXI_POWER_CONTROL)    += mmc_power.o
+
+mmc_power-y := mmc_pm.o mmc_pm_swl_n20.o mmc_pm_usi_bm01a.o \
+                mmc_pm_apm6xxx.o mmc_pm_swb_b23.o mmc_pm_hw_mw269x.o mmc_pm_bcm40181.o \
+                mmc_pm_bcm40183.o mmc_pm_rtl8723as.o mmc_pm_rtl8189es.o
diff --git a/drivers/mmc/mmc-pm/mmc_pm.c b/drivers/mmc/mmc-pm/mmc_pm.c
new file mode 100644
index 0000000..600004c
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm.c
@@ -0,0 +1,375 @@
+/*
+ * drivers/mmc/mmc-pm/mmc_pm.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <plat/sys_config.h>
+#include <linux/proc_fs.h>
+#include "mmc_pm.h"
+
+#define mmc_pm_msg(...)    do {printk("[mmc_pm]: "__VA_ARGS__);} while(0)
+
+
+struct mmc_pm_ops mmc_card_pm_ops;
+static char* wifi_para = "sdio_wifi_para";
+static char* wifi_mod[] = {" ", 
+							"swl-n20", 	 /* 1 - SWL-N20(Nanoradio NRX600)*/
+							"usi-bm01a", /* 2 - USI-BM01A(BCM4329)*/
+							"ar6302qfn", /* 3 - AR6302(Atheros 6xxx) */
+							"apm6xxx", 	 /* 4 - APM6981/6658 */
+							"swb-b23",	 /* 5 - SWB-B23(BCM4329) */
+							"hw-mw269",	 /* 6 - HW-MW269X(269/269V2/269V3) */
+							"bcm40181",  /* 7 - BCM40181(BCM4330) */
+							"bcm40183",  /* 8 - BCM40183(BCM4330) */
+							"rtl8723as",  /* 9 - RTL8723AS(RF-SM02B) */
+							"rtl8189es"  /* 10 - RTL8189ES(SM89E00) */
+							};
+
+static int mmc_pm_get_res(void);
+
+int mmc_pm_get_mod_type(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+	mmc_pm_get_res();
+    if (ops->sdio_card_used)
+        return ops->module_sel;
+    else {
+        mmc_pm_msg("No sdio card, please check your config !!\n");
+        return 0;
+    }
+}
+EXPORT_SYMBOL(mmc_pm_get_mod_type);
+
+int mmc_pm_gpio_ctrl(char* name, int level)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    if (ops->sdio_card_used)
+        return ops->gpio_ctrl(name, level);
+    else {
+        mmc_pm_msg("No sdio card, please check your config !!\n");
+        return -1;
+    }
+}
+EXPORT_SYMBOL(mmc_pm_gpio_ctrl);
+
+int mmc_pm_get_io_val(char* name)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    if (ops->sdio_card_used)
+        return ops->get_io_val(name);
+    else {
+        mmc_pm_msg("No sdio card, please check your config !!\n");
+        return -1;
+    }
+}
+EXPORT_SYMBOL(mmc_pm_get_io_val);
+
+void mmc_pm_power(int mode, int* updown)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    if (ops->sdio_card_used && ops->power)
+        return ops->power(mode, updown);
+    else {
+        mmc_pm_msg("No sdio card, please check your config !!\n");
+        return;
+    }
+}
+EXPORT_SYMBOL(mmc_pm_power);
+
+int mmc_pm_io_shd_suspend_host(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    return (ops->module_sel!=2) && (ops->module_sel!=5)
+    		 && (ops->module_sel!=6) && (ops->module_sel!=7
+    		 && (ops->module_sel!=8));
+}
+EXPORT_SYMBOL(mmc_pm_io_shd_suspend_host);
+
+#ifdef CONFIG_PROC_FS
+static int mmc_pm_power_stat(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    struct mmc_pm_ops *ops = (struct mmc_pm_ops *)data;
+    char *p = page;
+    int power = 0;
+    
+    if (ops->power)
+        ops->power(0, &power);
+    p += sprintf(p, "%s : power state %s\n", ops->mod_name, power ? "on" : "off");
+    return p - page;
+}
+
+static int mmc_pm_power_ctrl(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+    struct mmc_pm_ops *ops = (struct mmc_pm_ops *)data;
+    int power = simple_strtoul(buffer, NULL, 10);
+    
+    power = power ? 1 : 0;
+    if (ops->power)
+        ops->power(1, &power);
+    else
+        mmc_pm_msg("No power control for %s\n", ops->mod_name);
+    return sizeof(power);
+}
+
+static inline void awsmc_procfs_attach(void)
+{
+    char proc_rootname[] = "driver/mmc-pm";
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+
+    ops->proc_root = proc_mkdir(proc_rootname, NULL);
+    if (IS_ERR(ops->proc_root))
+    {
+        mmc_pm_msg("failed to create procfs \"driver/mmc-pm\".\n");
+    }
+
+    ops->proc_power = create_proc_entry("power", 0644, ops->proc_root);
+    if (IS_ERR(ops->proc_power))
+    {
+        mmc_pm_msg("failed to create procfs \"power\".\n");
+    }
+    ops->proc_power->data = ops;
+    ops->proc_power->read_proc = mmc_pm_power_stat;
+    ops->proc_power->write_proc = mmc_pm_power_ctrl;
+}
+
+static inline void awsmc_procfs_remove(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char proc_rootname[] = "driver/mmc-pm";
+    
+    remove_proc_entry("power", ops->proc_root);
+    remove_proc_entry(proc_rootname, NULL);
+}
+#else
+static inline void awsmc_procfs_attach(void) {}
+static inline void awsmc_procfs_remove(void) {}
+#endif
+
+static int __mmc_pm_get_res(void)
+{
+    int ret = 0;
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    ret = script_parser_fetch(wifi_para, "sdio_wifi_used", &ops->sdio_card_used, sizeof(unsigned)); 
+    if (ret) {
+        mmc_pm_msg("failed to fetch sdio card configuration!\n");
+        return -1;
+    }
+    if (!ops->sdio_card_used) {
+        mmc_pm_msg("no sdio card used in configuration\n");
+        return -1;
+    }
+    
+    ret = script_parser_fetch(wifi_para, "sdio_wifi_sdc_id", &ops->sdio_cardid, sizeof(unsigned));
+    if (ret) {
+        mmc_pm_msg("failed to fetch sdio card's sdcid\n");
+        return -1;
+    }
+
+    ret = script_parser_fetch(wifi_para, "sdio_wifi_mod_sel", &ops->module_sel, sizeof(unsigned));
+    if (ret) {
+        mmc_pm_msg("failed to fetch sdio module select\n");
+        return -1;
+    }
+    ops->mod_name = wifi_mod[ops->module_sel];
+    printk("[wifi]: Select sdio wifi: %s !!\n", wifi_mod[ops->module_sel]);
+    
+    ops->pio_hdle = gpio_request_ex(wifi_para, NULL);
+    if (!ops->pio_hdle) {
+        mmc_pm_msg("failed to fetch sdio card's io handler, please check it !!\n");
+        return -1;
+    }
+    
+    return 0;
+}
+
+static int mmc_pm_get_res(void)
+{
+	static DEFINE_MUTEX(mmc_pm_get_res_mutex);
+	static int get_res = 1;
+
+	mutex_lock(&mmc_pm_get_res_mutex);
+	if (get_res == 1)
+		get_res = __mmc_pm_get_res();
+	mutex_unlock(&mmc_pm_get_res_mutex);
+
+	return get_res;
+}
+
+static int __devinit mmc_pm_probe(struct platform_device *pdev)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    switch (ops->module_sel) {
+        case 1: /* nano wifi */
+            nano_wifi_gpio_init();
+            break;
+        case 2: /* usi bm01a */
+            usi_bm01a_gpio_init();
+            break;
+        case 3: /* ar6302qfn */
+            //ar6302qfn_gpio_init();
+            break;
+        case 4: /* apm 6xxx */
+            apm_6xxx_gpio_init();
+            break;
+        case 5: /* swb b23 */
+            swbb23_gpio_init();
+            break;
+        case 6: /* huawei mw269x */
+            hwmw269_gpio_init();
+            break;
+        case 7: /* BCM40181 */
+            bcm40181_wifi_gpio_init();
+            break;
+	case 8: /* BCM40183 */
+	    bcm40183_gpio_init();
+	    break;
+	case 9: /* rtl8723as */
+	    rtl8723as_gpio_init();
+	    break;
+	case 10: /* rtl8189es */
+	    rtl8189es_wifi_gpio_init();
+	    break;
+        default:
+            mmc_pm_msg("Wrong sdio module select %d !!\n", ops->module_sel);
+    }
+    
+    awsmc_procfs_attach();
+    mmc_pm_msg("SDIO card gpio init is OK !!\n");
+    return 0;
+}
+
+static int __devexit mmc_pm_remove(struct platform_device *pdev)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    switch (ops->module_sel) {
+        case 1: /* nano wifi */
+            nano_wifi_gpio_init();
+            break;
+        case 2: /* usi bm01a */
+            usi_bm01a_gpio_init();
+            break;
+        case 3: /* ar6302qfn */
+            //ar6302qfn_gpio_init();
+            break;
+        case 4: /* usi bm01a */
+            apm_6xxx_gpio_init();
+            break;
+        case 5: /* swb b23 */
+            swbb23_gpio_init();
+            break;
+        case 6: /* huawei mw269x */
+            hwmw269_gpio_init();
+            break;
+        case 7: /* BCM40181 */
+            bcm40181_wifi_gpio_init();
+            break;
+	case 8: /* BCM40183 */
+	    bcm40183_gpio_init();
+	    break;
+	case 9: /* rtl8723as */
+	    rtl8723as_gpio_init();
+	    break;
+	case 10: /* rtl8189es */
+	    rtl8189es_wifi_gpio_init();
+	    break;
+        default:
+            mmc_pm_msg("Wrong sdio module select %d !!\n", ops->module_sel);
+    }
+    
+    awsmc_procfs_remove();
+    mmc_pm_msg("SDIO card gpio is released !!\n");
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int mmc_pm_suspend(struct device *dev)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    if (ops->standby)
+        ops->standby(1);
+    return 0;
+}
+static int mmc_pm_resume(struct device *dev)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    if (ops->standby)
+        ops->standby(0);
+    return 0;
+}
+
+static struct dev_pm_ops mmc_pm_ops = {
+    .suspend	= mmc_pm_suspend,
+    .resume		= mmc_pm_resume,
+};
+#endif
+
+static struct platform_device mmc_pm_dev = {
+    .name           = "mmc_pm",
+};
+
+static struct platform_driver mmc_pm_driver = {
+    .driver.name    = "mmc_pm",
+    .driver.owner   = THIS_MODULE,
+#ifdef CONFIG_PM
+    .driver.pm	    = &mmc_pm_ops,
+#endif
+    .probe          = mmc_pm_probe,
+    .remove         = __devexit_p(mmc_pm_remove),
+};
+
+static int __init mmc_pm_init(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    memset(ops, 0, sizeof(struct mmc_pm_ops));
+    mmc_pm_get_res();
+    if (!ops->sdio_card_used)
+        return 0;
+        
+    platform_device_register(&mmc_pm_dev);
+    return platform_driver_register(&mmc_pm_driver);
+}
+
+static void __exit mmc_pm_exit(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    if (!ops->sdio_card_used)
+        return;
+        
+    if (ops->pio_hdle)
+        gpio_release(ops->pio_hdle, 2);
+    
+    memset(ops, 0, sizeof(struct mmc_pm_ops));
+    platform_driver_unregister(&mmc_pm_driver);
+}
+
+module_init(mmc_pm_init);
+module_exit(mmc_pm_exit);
+
diff --git a/drivers/mmc/mmc-pm/mmc_pm.h b/drivers/mmc/mmc-pm/mmc_pm.h
new file mode 100644
index 0000000..76cf604
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm.h
@@ -0,0 +1,62 @@
+/*
+ * drivers/mmc/mmc-pm/mmc_pm.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef MMC_PM_H
+#define MMC_PM_H
+
+#define SDIO_WIFI_POWERUP   (1)
+#define SDIO_WIFI_INSUSPEND (2)
+
+struct mmc_pm_ops {
+    char*   mod_name;
+    u32     sdio_card_used;
+    u32     sdio_cardid;
+    u32     module_sel;
+    u32     pio_hdle;
+    int     (*gpio_ctrl)(char* name, int level);
+    int     (*get_io_val)(char* name);
+    void    (*standby)(int in);
+    void    (*power)(int mode, int *updown);
+    
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry		*proc_root;
+	struct proc_dir_entry		*proc_power;
+#endif
+};
+
+void mmc_pm_ops_register(struct mmc_pm_ops* ops);
+void mmc_pm_ops_register(struct mmc_pm_ops* ops);
+
+void nano_wifi_gpio_init(void);
+void usi_bm01a_gpio_init(void);
+void apm_6xxx_gpio_init(void);
+void swbb23_gpio_init(void);
+void hwmw269_gpio_init(void);
+void bcm40181_wifi_gpio_init(void);
+void bcm40183_gpio_init(void);
+void rtl8723as_gpio_init(void);
+void rtl8189es_wifi_gpio_init(void);
+
+extern struct mmc_pm_ops mmc_card_pm_ops;
+extern void sunximmc_rescan_card(unsigned id, unsigned insert);
+
+#endif
diff --git a/drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c b/drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c
new file mode 100644
index 0000000..b4f8bee
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c
@@ -0,0 +1,80 @@
+/*
+ * drivers/mmc/mmc-pm/mmc_pm_apm6xxx.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+/*
+ * USI wm-bn-bm-01-5(bcm4329) sdio wifi power management API
+ * gpio define
+ * apm_6981_vcc_en         = port:PA09<1><default><default><0>
+ * apm_6981_vdd_en         = port:PA10<1><default><default><0>
+ * apm_6981_wakeup         = port:PA11<1><default><default><0>
+ * apm_6981_rst_n          = port:PA12<1><default><default><0>
+ * apm_6981_pwd_n          = port:PA13<1><default><default><0>
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <plat/sys_config.h>
+
+#include "mmc_pm.h"
+
+#define apm_msg(...)    do {printk("[apm_wifi]: "__VA_ARGS__);} while(0)
+
+static int apm_6xxx_gpio_ctrl(char* name, int level)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* gpio_cmd[5] = {"apm_6981_vcc_en", "apm_6981_vdd_en", "apm_6981_wakeup", 
+                               "apm_6981_rst_n", "apm_6981_pwd_n"};
+    int i = 0;
+    int ret = 0;
+    
+    for (i=0; i<5; i++) {
+        if (strcmp(name, gpio_cmd[i])==0)
+            break;
+    }
+    if (i==5) {
+        apm_msg("No gpio %s for APM 6XXX module\n", name);
+        return -1;
+    }
+    
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        apm_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    }
+    apm_msg("Set gpio %s to %d !\n", name, level);
+    return 0;
+}
+
+int apm_6xxx_get_gpio_value(char* name)
+{
+    return -1;
+}
+
+void apm_6xxx_gpio_init(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    apm_6xxx_gpio_ctrl("apm_6981_wakeup", 1);
+    apm_6xxx_gpio_ctrl("apm_6981_pwd_n", 0);
+    apm_6xxx_gpio_ctrl("apm_6981_rst_n", 0);
+    ops->gpio_ctrl = apm_6xxx_gpio_ctrl;
+    ops->get_io_val = apm_6xxx_get_gpio_value;
+}
diff --git a/drivers/mmc/mmc-pm/mmc_pm_bcm40181.c b/drivers/mmc/mmc-pm/mmc_pm_bcm40181.c
new file mode 100644
index 0000000..8319eee
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_bcm40181.c
@@ -0,0 +1,96 @@
+/*
+ * drivers/mmc/mmc-pm/mmc_pm_bcm40181.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * bcm40181 sdio wifi power management API
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <plat/sys_config.h>
+
+#include "mmc_pm.h"
+
+#define bcm40181_msg(...)    do {printk("[bcm40181]: "__VA_ARGS__);} while(0)
+
+static int bcm40181_powerup = 0;
+static int bcm40181_suspend = 0;
+
+static int bcm40181_gpio_ctrl(char* name, int level)
+{
+	int i = 0, ret = 0;
+	struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+	char* gpio_name[4] = {"bcm40181_wakeup",
+						"bcm40181_shdn",
+						"bcm40181_vcc_en",
+						"bcm40181_vdd_en"
+						};
+
+    for (i=0; i<4; i++) {
+        if (strcmp(name, gpio_name[i])==0)
+            break;
+    }
+    if (i==4) {
+        bcm40181_msg("No gpio %s for bcm40181-wifi module\n", name);
+        return -1;
+    }
+
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        bcm40181_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    } else
+		bcm40181_msg("Succeed to set gpio %s to %d !\n", name, level);
+
+    if (strcmp(name, "bcm40181_vdd_en") == 0) {
+        bcm40181_powerup = level;
+        bcm40181_msg("BCM40181 SDIO Wifi Power %s !!\n", level ? "UP" : "Off");
+    }
+
+    return 0;
+}
+
+static int bcm40181_get_io_value(char* name)
+{
+	int ret = -1;
+	struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+	
+    if (strcmp(name, "bcm40181_wakeup")) {
+        bcm40181_msg("No gpio %s for BCM40181\n", name);
+        return -1;
+    }
+	ret = gpio_read_one_pin_value(ops->pio_hdle, name);
+	bcm40181_msg("Succeed to get gpio %s value: %d !\n", name, ret);
+
+	return ret;
+}
+
+void bcm40181_wifi_gpio_init(void)
+{
+	struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+
+	bcm40181_msg("exec bcm40181_wifi_gpio_init...\n");
+	bcm40181_powerup = 0;
+	bcm40181_suspend = 0;
+	ops->gpio_ctrl = bcm40181_gpio_ctrl;
+	ops->get_io_val = bcm40181_get_io_value;
+}
diff --git a/drivers/mmc/mmc-pm/mmc_pm_bcm40183.c b/drivers/mmc/mmc-pm/mmc_pm_bcm40183.c
new file mode 100644
index 0000000..26f96e0
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_bcm40183.c
@@ -0,0 +1,180 @@
+
+/*
+ * USI wm-bn-bm-01-5(bcm4329) sdio wifi power management API
+ * evb gpio define
+ * A10 gpio define:
+ * bcm40183_pwr        = port:PH12<1><default><default><0>
+ * bcm40183_wl_regon      = port:PH11<1><default><default><0>
+ *          = port:PH10<1><default><default><0>
+ *          = port:PH9<1><default><default><0>
+ * bcm40183_bt_rst        = port:PB05<1><default><default><0>
+ * bcm40183_bt_regon      = port:PI20<1><default><default><0>
+ *          = port:PI21<0><default><default><0>
+ */
+ 
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <plat/sys_config.h>
+#include <linux/delay.h>
+
+#include "mmc_pm.h"
+
+#define bcm_msg(...)    do {printk("[bcm40183]: "__VA_ARGS__);} while(0)
+static int bcm40183_wl_on = 0;
+static int bcm40183_bt_on = 0;
+
+#define CONFIG_CHIP_ID 1125
+#if CONFIG_CHIP_ID==1125
+#include <linux/regulator/consumer.h>
+static int bcm40183_power_onoff(int onoff)
+{
+	struct regulator* wifi_ldo = NULL;
+	static int first = 1;
+	  
+#ifndef CONFIG_AW_AXP
+	bcm_msg("AXP driver is disabled, pls check !!\n");
+	return 0;
+#endif
+
+	bcm_msg("bcm40183_power_onoff\n");
+	wifi_ldo = regulator_get(NULL, "axp20_pll");
+	if (!wifi_ldo)
+		bcm_msg("Get power regulator failed\n");
+	if (first) {
+		bcm_msg("first time\n");
+		regulator_force_disable(wifi_ldo);
+		first = 0;
+	}
+	if (onoff) {
+		bcm_msg("regulator on\n");
+		regulator_set_voltage(wifi_ldo, 3300000, 3300000);
+		regulator_enable(wifi_ldo);
+	} else {
+		bcm_msg("regulator off\n");
+		regulator_disable(wifi_ldo);
+	}
+	return 0;
+}
+
+#endif
+
+static int bcm40183_gpio_ctrl(char* name, int level)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* gpio_cmd[3] = {"bcm40183_wl_regon", "bcm40183_bt_regon", "bcm40183_bt_rst"};
+    int i = 0;
+    int ret = 0;
+    
+    for (i=0; i<3; i++) {
+        if (strcmp(name, gpio_cmd[i])==0)
+            break;
+    }
+    if (i==3) {
+        bcm_msg("No gpio %s for BCM40183 module\n", name);
+        return -1;
+    }
+    
+    bcm_msg("Set GPIO %s to %d !\n", name, level);
+    if (strcmp(name, "bcm40183_wl_regon") == 0) {
+        if (level) {
+            if (bcm40183_bt_on) {
+                bcm_msg("BCM40183 is already powered up by bluetooth\n");
+                goto change_state;
+            } else {
+                bcm_msg("BCM40183 is powered up by wifi\n");
+                goto power_change;
+            }
+        } else {
+            if (bcm40183_bt_on) {
+                bcm_msg("BCM40183 should stay on because of bluetooth\n");
+                goto change_state;
+            } else {
+                bcm_msg("BCM40183 is powered off by wifi\n");
+                goto power_change;
+            }
+        }
+    }
+    
+    if (strcmp(name, "bcm40183_bt_regon") == 0) {
+        if (level) {
+            if (bcm40183_wl_on) {
+                bcm_msg("BCM40183 is already powered up by wifi\n");
+                goto change_state;
+            } else {
+                bcm_msg("BCM40183 is powered up by bt\n");
+                goto power_change;
+            }
+        } else {
+            if (bcm40183_wl_on) {
+                bcm_msg("BCM40183 should stay on because of wifi\n");
+                goto change_state;
+            } else {
+                bcm_msg("BCM40183 is powered off by bt\n");
+                goto power_change;
+            }
+        }
+    }
+    
+gpio_state_change:
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        bcm_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    }
+    
+    return 0;
+    
+power_change:
+    #if CONFIG_CHIP_ID==1123
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, "bcm40183_pwr");
+    #elif CONFIG_CHIP_ID==1125
+    ret = bcm40183_power_onoff(level);
+    #else
+    #error "Found wrong chip id in wifi onoff\n"
+    #endif
+    if (ret) {
+        bcm_msg("Failed to power off BCM40183 module!\n");
+        return -1;
+    }
+    udelay(500);
+    
+change_state:
+    if (strcmp(name, "bcm40183_wl_regon")==0)
+        bcm40183_wl_on = level;
+    if (strcmp(name, "bcm40183_bt_regon")==0)
+        bcm40183_bt_on = level;
+    bcm_msg("BCM40183 power state change: wifi %d, bt %d !!\n", bcm40183_wl_on, bcm40183_bt_on);
+    goto gpio_state_change;
+}
+
+static int bcm40183_get_gpio_value(char* name)
+{
+    return 0;
+}
+
+static void bcm40183_power(int mode, int* updown)
+{
+	if (mode) {
+		if (*updown) {
+            bcm40183_gpio_ctrl("bcm40183_wl_regon", 1);
+		} else {
+            bcm40183_gpio_ctrl("bcm40183_wl_regon", 0);
+		}
+	} else {
+        if (bcm40183_wl_on)
+            *updown = 1;
+        else
+            *updown = 0;
+		bcm_msg("sdio wifi power state: %s\n", bcm40183_wl_on ? "on" : "off");
+	}
+}
+
+void bcm40183_gpio_init(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    bcm40183_wl_on = 0;
+    bcm40183_bt_on = 0;
+    ops->gpio_ctrl = bcm40183_gpio_ctrl;
+    ops->get_io_val = bcm40183_get_gpio_value;
+    ops->power = bcm40183_power;
+}
diff --git a/drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c b/drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c
new file mode 100644
index 0000000..8ebb4ad
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c
@@ -0,0 +1,161 @@
+/*
+ * drivers/mmc/mmc-pm/mmc_pm_hw_mw269x.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+; 6 - huawei mw269x(v1/v2) sdio wifi gpio config
+;hw_mw269x_wl_pwr        = port:PH12<1><default><default><0>
+;hw_mw269x_wl_enb        = port:PH11<1><default><default><0>
+;hw_mw269x_wl_hostwake   = port:PH10<0><default><default><0>
+;hw_mw269x_wl_wake       = port:PH09<1><default><default><0>
+;hw_mw269x_bt_enb        = port:PB05<1><default><default><0>
+;hw_mw269x_bt_wake       = port:PI20<1><default><default><0>
+;hw_mw269x_bt_hostwake   = port:PI21<0><default><default><0>
+
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <plat/sys_config.h>
+
+#include "mmc_pm.h"
+
+#define SDIO_MODULE_NAME "HW-MW269"
+#define hw_msg(...)    do {printk("[hw-mw269]: "__VA_ARGS__);} while(0)
+static int hwmw269_wl_on = 0;
+static int hwmw269_bt_on = 0;
+
+static int hwmw269_gpio_ctrl(char* name, int level)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* gpio_cmd[5] = {"hw_mw269x_wl_pwr", "hw_mw269x_wl_enb", "hw_mw269x_wl_wake", 
+                         "hw_mw269x_bt_enb", "hw_mw269x_bt_wake"};
+    int i = 0;
+    int ret = 0;
+    
+    for (i=0; i<5; i++) {
+        if (strcmp(name, gpio_cmd[i])==0)
+            break;
+    }
+    if (i==5) {
+        hw_msg("No gpio %s for %s module\n", name, SDIO_MODULE_NAME);
+        return -1;
+    }
+    
+    hw_msg("Set GPIO %s to %d !\n", name, level);
+    if (strcmp(name, "hw_mw269x_wl_enb") == 0) {
+        if ((level && !hwmw269_bt_on)
+            || (!level && !hwmw269_bt_on)) {
+            hw_msg("%s is powered %s by wifi\n", SDIO_MODULE_NAME, level ? "up" : "down");
+            goto power_change;
+        } else {
+            if (level) {
+                hw_msg("%s is already on by bt\n", SDIO_MODULE_NAME);
+            } else {
+                hw_msg("%s should stay on because of bt\n", SDIO_MODULE_NAME);
+            }
+            goto state_change;
+        }
+    }
+    if (strcmp(name, "hw_mw269x_bt_enb") == 0) {
+        if ((level && !hwmw269_wl_on)
+            || (!level && !hwmw269_wl_on)) {
+            hw_msg("%s is powered %s by bt\n", SDIO_MODULE_NAME, level ? "up" : "down");
+            goto power_change;
+        } else {
+            if (level) {
+                hw_msg("%s is already on by wifi\n", SDIO_MODULE_NAME);
+            } else {
+                hw_msg("%s should stay on because of wifi\n", SDIO_MODULE_NAME);
+            }
+            goto state_change;
+        }
+    }
+
+gpio_state_change:
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        hw_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    }
+    
+    return 0;
+    
+power_change:
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, "hw_mw269x_wl_pwr");
+    if (ret) {
+        hw_msg("Failed to power off %s module!\n", SDIO_MODULE_NAME);
+        return -1;
+    }
+    udelay(500);
+    
+state_change:
+    if (strcmp(name, "hw_mw269x_wl_enb")==0)
+        hwmw269_wl_on = level;
+    if (strcmp(name, "hw_mw269x_bt_enb")==0)
+        hwmw269_bt_on = level;
+    hw_msg("%s power state change: wifi %d, bt %d !!\n", SDIO_MODULE_NAME, hwmw269_wl_on, hwmw269_bt_on);
+    
+    goto gpio_state_change;
+}
+
+static int hwmw269_get_gpio_value(char* name)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    if (strcmp(name, "hw_mw269x_wl_hostwake") || strcmp(name, "hw_mw269x_bt_hostwake")) {
+        hw_msg("No gpio %s for %s\n", name, SDIO_MODULE_NAME);
+        return -1;
+    }
+    
+    return gpio_read_one_pin_value(ops->pio_hdle, name);
+}
+
+void hwmw269_power(int mode, int* updown)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    if (mode) {
+        if (*updown) {
+            hw_msg("power up module %s\n", ops->mod_name);
+        } else {
+            hw_msg("power down module %s\n", ops->mod_name);
+        }
+    } else {
+        if (hwmw269_wl_on || hwmw269_bt_on)
+            *updown = 1;
+        else
+            *updown = 0;
+    }
+    return;
+}
+void hwmw269_gpio_init(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    hwmw269_wl_on = 0;
+    hwmw269_bt_on = 0;
+    ops->gpio_ctrl = hwmw269_gpio_ctrl;
+    ops->get_io_val = hwmw269_get_gpio_value;
+    ops->power = hwmw269_power;
+}
+
+#undef SDIO_MODULE_NAME
diff --git a/drivers/mmc/mmc-pm/mmc_pm_rtl8189es.c b/drivers/mmc/mmc-pm/mmc_pm_rtl8189es.c
new file mode 100644
index 0000000..d166b2f
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_rtl8189es.c
@@ -0,0 +1,132 @@
+/*
+ * rtl8189es sdio wifi power management API
+ *
+ * ; 10 - realtek rtl8189es sdio wifi gpio config
+ * rtl8189es_shdn       = port:PH09<1><default><default><0>
+ * rtl8189es_wakeup     = port:PH10<1><default><default><1>
+ * rtl8189es_vdd_en     = port:PH11<1><default><default><0>
+ * rtl8189es_vcc_en     = port:PH12<1><default><default><0>
+ */
+ 
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <plat/sys_config.h>
+
+#include "mmc_pm.h"
+
+#define rtl8189es_msg(...)    do {printk("[rtl8189es]: "__VA_ARGS__);} while(0)
+
+static int rtl8189es_powerup = 0;
+static int rtl8189es_suspend = 0;
+
+static int rtl8189es_gpio_ctrl(char* name, int level)
+{
+	int i = 0, ret = 0;
+	struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+	char* gpio_name[4] = {	"rtl8189es_wakeup",
+							"rtl8189es_shdn",
+							"rtl8189es_vcc_en",
+							"rtl8189es_vdd_en"
+						};
+
+    for (i=0; i<4; i++) {
+        if (strcmp(name, gpio_name[i])==0)
+            break;
+    }
+    if (i==4) {
+        rtl8189es_msg("No gpio %s for rtl8189es-wifi module\n", name);
+        return -1;
+    }
+
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        rtl8189es_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    } else
+		rtl8189es_msg("Succeed to set gpio %s to %d !\n", name, level);
+
+    if (strcmp(name, "rtl8189es_vdd_en") == 0) {
+        rtl8189es_powerup = level;
+        rtl8189es_msg("rtl8189es SDIO Wifi Power %s !!\n", level ? "UP" : "Off");
+    }
+
+    return 0;
+}
+
+static int rtl8189es_get_io_value(char* name)
+{
+	int ret = -1;
+	struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+	
+    if (strcmp(name, "rtl8189es_wakeup")) {
+        rtl8189es_msg("No gpio %s for rtl8189es\n", name);
+        return -1;
+    }
+	ret = gpio_read_one_pin_value(ops->pio_hdle, name);
+	rtl8189es_msg("Succeed to get gpio %s value: %d !\n", name, ret);
+
+	return ret;
+}
+
+static void rtl8189es_standby(int instadby)
+{
+    if (instadby) {
+        if (rtl8189es_powerup) {
+            rtl8189es_gpio_ctrl("rtl8189es_shdn", 0);
+            rtl8189es_gpio_ctrl("rtl8189es_vcc_en", 0);
+            rtl8189es_gpio_ctrl("rtl8189es_vdd_en", 0);
+            rtl8189es_suspend = 1;
+        }
+    } else {
+        if (rtl8189es_suspend) {
+            rtl8189es_gpio_ctrl("rtl8189es_vdd_en", 1);
+            udelay(100);
+            rtl8189es_gpio_ctrl("rtl8189es_vcc_en", 1);
+            udelay(50);
+            rtl8189es_gpio_ctrl("rtl8189es_shdn", 1);
+            sunximmc_rescan_card(3, 1);
+            rtl8189es_suspend = 0;
+        }
+    }
+}
+
+static void rtl8189es_power(int mode, int* updown)
+{
+    if (mode) {
+        if (*updown) {
+			rtl8189es_gpio_ctrl("rtl8189es_vdd_en", 1);
+			udelay(100);
+			rtl8189es_gpio_ctrl("rtl8189es_vcc_en", 1);
+			udelay(50);
+			rtl8189es_gpio_ctrl("rtl8189es_shdn", 1);
+        } else {
+			rtl8189es_gpio_ctrl("rtl8189es_shdn", 0);
+			rtl8189es_gpio_ctrl("rtl8189es_vcc_en", 0);
+			rtl8189es_gpio_ctrl("rtl8189es_vdd_en", 0);
+        }
+    } else {
+        if (rtl8189es_powerup)
+            *updown = 1;
+        else
+            *updown = 0;
+		rtl8189es_msg("sdio wifi power state: %s\n", rtl8189es_powerup ? "on" : "off");
+    }
+    return;
+}
+void rtl8189es_wifi_gpio_init(void)
+{
+	struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+	int updown = 1;
+
+	rtl8189es_msg("exec rtl8189es_wifi_gpio_init...\n");
+	rtl8189es_powerup = 0;
+	rtl8189es_suspend = 0;
+	ops->gpio_ctrl 	  = rtl8189es_gpio_ctrl;
+	ops->get_io_val   = rtl8189es_get_io_value;
+	ops->standby      = rtl8189es_standby;
+	ops->power        = rtl8189es_power;
+	rtl8189es_power(1, &updown);
+	sunximmc_rescan_card(ops->sdio_cardid, 1);
+	rtl8189es_msg("power up, rescan card.\n");
+}
diff --git a/drivers/mmc/mmc-pm/mmc_pm_rtl8723as.c b/drivers/mmc/mmc-pm/mmc_pm_rtl8723as.c
new file mode 100644
index 0000000..aa508f6
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_rtl8723as.c
@@ -0,0 +1,160 @@
+/*
+; 9 - realtek rtl8723as(combo) sdio wifi + bt gpio config
+;rtk_rtl8723as_wb_pwr       = port:PH12<1><default><default><0>
+;rtk_rtl8723as_wl_dis       = port:PH11<1><default><default><0>
+;rtk_rtl8723as_wl_wps       = port:PH09<0><default><default><0>
+;rtk_rtl8723as_bt_dis       = port:PB05<1><default><default><0>*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <plat/sys_config.h>
+
+#include "mmc_pm.h"
+
+#define SDIO_MODULE_NAME "RTL8723AS"
+#define rtw_msg(...)    do {printk("[RTL8723AS]: "__VA_ARGS__);} while(0)
+static int rtl8723as_wl_on = 0;
+static int rtl8723as_bt_on = 0;
+
+static int rtk_suspend = 0;
+
+static int rtl8723as_gpio_ctrl(char* name, int level)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* gpio_cmd[4] = {"rtk_rtl8723as_wb_pwr", "rtk_rtl8723as_wl_dis", "rtk_rtl8723as_bt_dis", "rtk_rtl8723as_wl_wps"};
+    int i = 0;
+    int ret = 0;
+    
+    for (i=0; i<4; i++) {
+        if (strcmp(name, gpio_cmd[i])==0)
+            break;
+    }
+    if (i==4) {
+        rtw_msg("No gpio %s for %s module\n", name, SDIO_MODULE_NAME);
+        return -1;
+    }
+    
+    rtw_msg("Set GPIO %s to %d !\n", name, level);
+    if (strcmp(name, "rtk_rtl8723as_wl_dis") == 0) {
+        if ((level && !rtl8723as_bt_on)
+            || (!level && !rtl8723as_bt_on)) {
+            rtw_msg("%s is powered %s by wifi\n", SDIO_MODULE_NAME, level ? "up" : "down");
+            goto power_change;
+        } else {
+            if (level) {
+                rtw_msg("%s is already on by bt\n", SDIO_MODULE_NAME);
+            } else {
+                rtw_msg("%s should stay on because of bt\n", SDIO_MODULE_NAME);
+            }
+            goto state_change;
+        }
+    }
+    if (strcmp(name, "rtk_rtl8723as_bt_dis") == 0) {
+        if ((level && !rtl8723as_wl_on)
+            || (!level && !rtl8723as_wl_on)) {
+            rtw_msg("%s is powered %s by bt\n", SDIO_MODULE_NAME, level ? "up" : "down");
+            goto power_change;
+        } else {
+            if (level) {
+                rtw_msg("%s is already on by wifi\n", SDIO_MODULE_NAME);
+            } else {
+                rtw_msg("%s should stay on because of wifi\n", SDIO_MODULE_NAME);
+            }
+            goto state_change;
+        }
+    }
+
+gpio_state_change:
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        rtw_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    }
+    
+    return 0;
+    
+power_change:
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, "rtk_rtl8723as_wb_pwr");
+    if (ret) {
+        rtw_msg("Failed to power off %s module!\n", SDIO_MODULE_NAME);
+        return -1;
+    }
+    udelay(500);
+    
+state_change:
+    if (strcmp(name, "rtk_rtl8723as_wl_dis")==0)
+        rtl8723as_wl_on = level;
+    if (strcmp(name, "rtk_rtl8723as_bt_dis")==0)
+        rtl8723as_bt_on = level;
+    rtw_msg("%s power state change: wifi %d, bt %d !!\n", SDIO_MODULE_NAME, rtl8723as_wl_on, rtl8723as_bt_on);
+    
+    goto gpio_state_change;
+}
+
+static int rtl8723as_get_gpio_value(char* name)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    
+    if (strcmp(name, "rtk_rtl8723as_wl_wps")) {
+        rtw_msg("No gpio %s for %s\n", name, SDIO_MODULE_NAME);
+        return -1;
+    }
+    
+    return gpio_read_one_pin_value(ops->pio_hdle, name);
+}
+
+void rtl8723as_power(int mode, int* updown)
+{
+    if (mode) {
+        if (*updown) {
+        	rtl8723as_gpio_ctrl("rtk_rtl8723as_wl_dis", 1);
+        } else {
+        	rtl8723as_gpio_ctrl("rtk_rtl8723as_wl_dis", 0);
+        }
+    } else {
+        if (rtl8723as_wl_on)
+            *updown = 1;
+        else
+            *updown = 0;
+		rtw_msg("sdio wifi power state: %s\n", rtl8723as_wl_on ? "on" : "off");
+    }
+    return;
+}
+
+static void rtl8723as_standby(int instadby)
+{
+    if (instadby) {
+        if (rtl8723as_wl_on) {
+            rtl8723as_gpio_ctrl("rtk_rtl8723as_wl_dis", 0);
+            printk("%s: mmc_pm_suspend.\n", __FUNCTION__);
+            rtk_suspend = 1;
+        }
+    } else {
+        if (rtk_suspend) {
+            rtl8723as_gpio_ctrl("rtk_rtl8723as_wl_dis", 1);
+            sunximmc_rescan_card(3, 1);
+            printk("%s: mmc_pm_resume.\n", __FUNCTION__);
+            rtk_suspend = 0;
+        }
+    }
+}
+
+void rtl8723as_gpio_init(void)
+{
+	struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+	int updown = 1;
+
+	rtl8723as_wl_on = 0;
+	rtl8723as_bt_on = 0;
+	rtk_suspend	= 0;
+	ops->gpio_ctrl	= rtl8723as_gpio_ctrl;
+	ops->get_io_val = rtl8723as_get_gpio_value;
+	ops->power	= rtl8723as_power;
+	ops->standby	= rtl8723as_standby;
+	rtl8723as_power(1, &updown);
+	sunximmc_rescan_card(ops->sdio_cardid, 1);
+	rtw_msg("power up, rescan card.\n");
+}
+
+#undef SDIO_MODULE_NAME
diff --git a/drivers/mmc/mmc-pm/mmc_pm_swb_b23.c b/drivers/mmc/mmc-pm/mmc_pm_swb_b23.c
new file mode 100644
index 0000000..4de2723
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_swb_b23.c
@@ -0,0 +1,138 @@
+/*
+ * drivers/mmc/mmc-pm/mmc_pm_swb_b23.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+/*
+ * USI wm-bn-bm-01-5(bcm4329) sdio wifi power management API
+ * gpio define                                 
+ * swbb23_wl_pwr           = port:PH12<1><default><default><0>
+ * swbb23_wl_shdn          = port:PH09<1><default><default><0>
+ * swbb23_wl_wake          = port:PB10<1><default><default><0>
+ * swbb23_bt_shdn          = port:PB05<1><default><default><0>
+ * swbb23_bt_wake          = port:PI20<1><default><default><0>
+ * swbb23_bt_hostwake      = port:PI21<0><default><default><0>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <plat/sys_config.h>
+
+#include "mmc_pm.h"
+
+#define swb_msg(...)    do {printk("[swbb23]: "__VA_ARGS__);} while(0)
+static int swbb23_wl_on = 0;
+static int swbb23_bt_on = 0;
+
+static int swbb23_gpio_ctrl(char* name, int level)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* gpio_cmd[5] = {"swbb23_wl_shdn", "swbb23_wl_wake", "swbb23_bt_shdn", 
+                               "swbb23_bt_wake", "swbb23_bt_hostwake"};
+    int i = 0;
+    int ret = 0;
+    
+    for (i=0; i<5; i++) {
+        if (strcmp(name, gpio_cmd[i])==0)
+            break;
+    }
+    if (i==5) {
+        swb_msg("No gpio %s for SWB-B23 module\n", name);
+        return -1;
+    }
+    
+//    swb_msg("Set GPIO %s to %d !\n", name, level);
+    if (strcmp(name, "swbb23_wl_shdn") == 0) {
+        if ((level && !swbb23_bt_on)
+            || (!level && !swbb23_bt_on)) {
+            swb_msg("SWB-B23 is powered %s by wifi\n", level ? "up" : "down");
+            goto power_change;
+        } else {
+            if (level) {
+                swb_msg("SWB-B23 is already on by bt\n");
+            } else {
+                swb_msg("SWB-B23 should stay on because of bt\n");
+            }
+            goto state_change;
+        }
+    }
+    if (strcmp(name, "swbb23_bt_shdn") == 0) {
+        if ((level && !swbb23_wl_on)
+            || (!level && !swbb23_wl_on)) {
+            swb_msg("SWB-B23 is powered %s by bt\n", level ? "up" : "down");
+            goto power_change;
+        } else {
+            if (level) {
+                swb_msg("SWB-B23 is already on by wifi\n");
+            } else {
+                swb_msg("SWB-B23 should stay on because of wifi\n");
+            }
+            goto state_change;
+        }
+    }
+
+gpio_state_change:
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        swb_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    }
+    
+    return 0;
+    
+power_change:
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, "swbb23_wl_pwr");
+    if (ret) {
+        swb_msg("Failed to power off SWB-B23 module!\n");
+        return -1;
+    }
+    
+state_change:
+    if (strcmp(name, "swbb23_wl_shdn")==0)
+        swbb23_wl_on = level;
+    if (strcmp(name, "swbb23_bt_shdn")==0)
+        swbb23_bt_on = level;
+    swb_msg("SWB-B23 power state change: wifi %d, bt %d !!\n", swbb23_wl_on, swbb23_bt_on);
+    
+    goto gpio_state_change;
+}
+
+static int swbb23_get_gpio_value(char* name)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* bt_hostwake =  "swbb23_bt_hostwake";
+    
+    if (strcmp(name, bt_hostwake)) {
+        swb_msg("No gpio %s for SWB-B23\n", name);
+        return -1;
+    }
+    
+    return gpio_read_one_pin_value(ops->pio_hdle, name);
+}
+
+void swbb23_gpio_init(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    swbb23_wl_on = 0;
+    swbb23_bt_on = 0;
+    ops->gpio_ctrl = swbb23_gpio_ctrl;
+    ops->get_io_val = swbb23_get_gpio_value;
+}
diff --git a/drivers/mmc/mmc-pm/mmc_pm_swl_n20.c b/drivers/mmc/mmc-pm/mmc_pm_swl_n20.c
new file mode 100644
index 0000000..b3867ce
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_swl_n20.c
@@ -0,0 +1,111 @@
+/*
+ * drivers/mmc/mmc-pm/mmc_pm_swl_n20.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Nanoradio sdio wifi power management API
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <plat/sys_config.h>
+
+#include "mmc_pm.h"
+
+#define nano_msg(...)    do {printk("[nano]: "__VA_ARGS__);} while(0)
+
+static int nano_powerup = 0;
+static int nano_suspend = 0;
+
+static int nano_gpio_ctrl(char* name, int level)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* gpio_name[4] = {"swl_n20_host_wakeup", "swl_n20_shdn",
+                               "swl_n20_vcc_en", "swl_n20_vdd_en"};
+    
+    int i = 0;
+    int ret = 0;
+    
+    for (i=0; i<4; i++) {
+        if (strcmp(name, gpio_name[i])==0)
+            break;
+    }
+    if (i==4) {
+        nano_msg("No gpio %s for nano-wifi module\n", name);
+        return -1;
+    }
+    
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        nano_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    }
+    if (strcmp(name, "swl_n20_vdd_en")==0) {
+        nano_powerup = level;
+        nano_msg("Wifi Power %s !!\n", level ? "UP" : "Off");
+    }
+    return 0;
+}
+
+static int nano_get_io_value(char* name)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* hostwake = "swl_n20_host_wakeup";
+    
+    if (strcmp(name, hostwake)) {
+        nano_msg("No gpio %s for swl-n20\n", name);
+        return -1;
+    }
+    
+    return gpio_read_one_pin_value(ops->pio_hdle, name);
+}
+
+static void nano_standby(int instadby)
+{
+    if (instadby) {
+        if (nano_powerup) {
+            nano_gpio_ctrl("swl_n20_shdn", 0);
+            nano_gpio_ctrl("swl_n20_vdd_en", 0);
+            nano_gpio_ctrl("swl_n20_vcc_en", 0);
+            nano_suspend = 1;
+        }
+    } else {
+        if (nano_suspend) {
+            nano_gpio_ctrl("swl_n20_vcc_en", 1);
+            udelay(100);
+            nano_gpio_ctrl("swl_n20_shdn", 1);
+            udelay(50);
+            nano_gpio_ctrl("swl_n20_vdd_en", 1);
+            sunximmc_rescan_card(3, 1);
+            nano_suspend = 0;
+        }
+    }
+}
+
+void nano_wifi_gpio_init(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    nano_powerup = 0;
+    nano_suspend = 0;
+    ops->gpio_ctrl = nano_gpio_ctrl;
+    ops->get_io_val = nano_get_io_value;
+    ops->standby = nano_standby;
+}
diff --git a/drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c b/drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c
new file mode 100644
index 0000000..4b76d2f
--- /dev/null
+++ b/drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c
@@ -0,0 +1,204 @@
+/*
+ * drivers/mmc/mmc-pm/mmc_pm_usi_bm01a.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+/*
+ * USI wm-bn-bm-01-5(bcm4329) sdio wifi power management API
+ * evb gpio define
+ * A10 gpio define:
+ * usi_bm01a_wl_pwr        = port:PH12<1><default><default><0>
+ * usi_bm01a_wlbt_regon    = port:PI11<1><default><default><0>
+ * usi_bm01a_wl_rst        = port:PI10<1><default><default><0>
+ * usi_bm01a_wl_wake       = port:PI12<1><default><default><0>
+ * usi_bm01a_bt_rst        = port:PB05<1><default><default><0>
+ * usi_bm01a_bt_wake       = port:PI20<1><default><default><0>
+ * usi_bm01a_bt_hostwake   = port:PI21<0><default><default><0>
+ * -----------------------------------------------------------
+ * A12 gpio define:
+ * usi_bm01a_wl_pwr        = LDO3
+ * usi_bm01a_wl_wake       = port:PA01<1><default><default><0>
+ * usi_bm01a_wlbt_regon    = port:PA02<1><default><default><0>
+ * usi_bm01a_wl_rst        = port:PA03<1><default><default><0>
+ * usi_bm01a_bt_rst        = port:PA04<1><default><default><0>
+ * usi_bm01a_bt_wake       = port:PA05<1><default><default><0>
+ * usi_bm01a_bt_hostwake   = 
+ */
+ 
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <plat/sys_config.h>
+
+#include "mmc_pm.h"
+
+#define usi_msg(...)    do {printk("[usi_bm01a]: "__VA_ARGS__);} while(0)
+static int usi_bm01a_wl_on = 0;
+static int usi_bm01a_bt_on = 0;
+
+#ifdef CONFIG_ARCH_SUN5I
+#include <linux/regulator/consumer.h>
+static int usi_bm01a_power_onoff(int onoff)
+{
+	struct regulator* wifi_ldo = NULL;
+	static int first = 1;
+
+#ifndef CONFIG_AW_AXP
+	usi_msg("AXP driver is disabled, pls check !!\n");
+	return 0;
+#endif
+
+	usi_msg("usi_bm01a_power_onoff\n");
+	wifi_ldo = regulator_get(NULL, "axp20_pll");
+	if (!wifi_ldo)
+		usi_msg("Get power regulator failed\n");
+	if (first) {
+		usi_msg("first time\n");
+		regulator_force_disable(wifi_ldo);
+		first = 0;
+	}
+	if (onoff) {
+		usi_msg("regulator on\n");
+		regulator_set_voltage(wifi_ldo, 3300000, 3300000);
+		regulator_enable(wifi_ldo);
+	} else {
+		usi_msg("regulator off\n");
+		regulator_disable(wifi_ldo);
+	}
+	return 0;
+}
+
+#endif
+
+static int usi_bm01a_gpio_ctrl(char* name, int level)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* gpio_cmd[6] = {"usi_bm01a_wl_regon", "usi_bm01a_bt_regon", "usi_bm01a_wl_rst", 
+                               "usi_bm01a_wl_wake", "usi_bm01a_bt_rst", "usi_bm01a_bt_wake"};
+    int i = 0;
+    int ret = 0;
+    
+    for (i=0; i<6; i++) {
+        if (strcmp(name, gpio_cmd[i])==0)
+            break;
+    }
+    if (i==6) {
+        usi_msg("No gpio %s for USI-BM01A module\n", name);
+        return -1;
+    }
+    
+//    usi_msg("Set GPIO %s to %d !\n", name, level);
+    if (strcmp(name, "usi_bm01a_wl_regon") == 0) {
+        if (level) {
+            if (usi_bm01a_bt_on) {
+                usi_msg("USI-BM01A is already powered up by bluetooth\n");
+                goto change_state;
+            } else {
+                usi_msg("USI-BM01A is powered up by wifi\n");
+                goto power_change;
+            }
+        } else {
+            if (usi_bm01a_bt_on) {
+                usi_msg("USI-BM01A should stay on because of bluetooth\n");
+                goto change_state;
+            } else {
+                usi_msg("USI-BM01A is powered off by wifi\n");
+                goto power_change;
+            }
+        }
+    }
+    
+    if (strcmp(name, "usi_bm01a_bt_regon") == 0) {
+        if (level) {
+            if (usi_bm01a_wl_on) {
+                usi_msg("USI-BM01A is already powered up by wifi\n");
+                goto change_state;
+            } else {
+                usi_msg("USI-BM01A is powered up by bt\n");
+                goto power_change;
+            }
+        } else {
+            if (usi_bm01a_wl_on) {
+                usi_msg("USI-BM01A should stay on because of wifi\n");
+                goto change_state;
+            } else {
+                usi_msg("USI-BM01A is powered off by bt\n");
+                goto power_change;
+            }
+        }
+    }
+    
+    
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, name);
+    if (ret) {
+        usi_msg("Failed to set gpio %s to %d !\n", name, level);
+        return -1;
+    }
+    
+    return 0;
+    
+power_change:
+#if defined(CONFIG_ARCH_SUN4I) || defined(CONFIG_ARCH_SUN7I)
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, "usi_bm01a_wl_pwr");
+#elif defined(CONFIG_ARCH_SUN5I)
+    ret = usi_bm01a_power_onoff(level);
+#else
+#error "Found wrong chip id in wifi onoff\n"
+#endif
+    if (ret) {
+        usi_msg("Failed to power off USI-BM01A module!\n");
+        return -1;
+    }
+    ret = gpio_write_one_pin_value(ops->pio_hdle, level, "usi_bm01a_wlbt_regon");
+    if (ret) {
+        usi_msg("Failed to regon off for  USI-BM01A module!\n");
+        return -1;
+    }
+    
+change_state:
+    if (strcmp(name, "usi_bm01a_wl_regon")==0)
+        usi_bm01a_wl_on = level;
+    if (strcmp(name, "usi_bm01a_bt_regon")==0)
+        usi_bm01a_bt_on = level;
+    usi_msg("USI-BM01A power state change: wifi %d, bt %d !!\n", usi_bm01a_wl_on, usi_bm01a_bt_on);
+    return 0;
+}
+
+static int usi_bm01a_get_gpio_value(char* name)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    char* bt_hostwake =  "usi_bm01a_bt_hostwake";
+    
+    if (strcmp(name, bt_hostwake)) {
+        usi_msg("No gpio %s for USI-BM01A\n", name);
+        return -1;
+    }
+    
+    return gpio_read_one_pin_value(ops->pio_hdle, name);
+}
+
+void usi_bm01a_gpio_init(void)
+{
+    struct mmc_pm_ops *ops = &mmc_card_pm_ops;
+    usi_bm01a_wl_on = 0;
+    usi_bm01a_bt_on = 0;
+    ops->gpio_ctrl = usi_bm01a_gpio_ctrl;
+    ops->get_io_val = usi_bm01a_get_gpio_value;
+}
diff --git a/drivers/mmc/sunxi-host/Kconfig b/drivers/mmc/sunxi-host/Kconfig
new file mode 100644
index 0000000..31dcb04
--- /dev/null
+++ b/drivers/mmc/sunxi-host/Kconfig
@@ -0,0 +1,18 @@
+#
+# MMC/SD host controller drivers
+#
+
+comment "SUNXI MMC/SD/SDIO Host Controller Drivers"
+
+config MMC_SUNXI
+	tristate "SUNXI MMC Card Interface support (old driver)"
+	depends on MMC
+	help
+	  This selects Allwinner SUNXI card support.  If you have an SUNXI
+	  platform with a Multimedia Card slot, say Y or M here.
+
+	  If unsure, say N.
+
+config MMC_SUNXI_DBG
+	bool "SUNXI MMC Card Host driver debug control"
+	depends on MMC_SUNXI
diff --git a/drivers/mmc/sunxi-host/Makefile b/drivers/mmc/sunxi-host/Makefile
new file mode 100644
index 0000000..14732a2
--- /dev/null
+++ b/drivers/mmc/sunxi-host/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for MMC/SD host controller drivers
+#
+
+ifeq ($(CONFIG_MMC_DEBUG),y)
+	EXTRA_CFLAGS		+= -DDEBUG
+endif
+
+obj-$(CONFIG_MMC_SUNXI)    += mmc_host.o
+
+mmc_host-y := sdxc.o host_op.o host_fs.o
diff --git a/drivers/mmc/sunxi-host/host_fs.c b/drivers/mmc/sunxi-host/host_fs.c
new file mode 100644
index 0000000..df790ff
--- /dev/null
+++ b/drivers/mmc/sunxi-host/host_fs.c
@@ -0,0 +1,242 @@
+/*
+ * drivers/mmc/sunxi-host/host_fs.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Aaron.Maoye <leafy.myeh@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+
+#include "host_op.h"
+
+extern unsigned int smc_debug;
+
+void dumphex32(char* name, char* base, int len)
+{
+    __u32 i;
+
+    printk("dump %s registers:", name);
+    for (i=0; i<len; i+=4)
+    {
+        if (!(i&0xf))
+            printk("\n0x%p : ", base + i);
+        printk("0x%08x ", readl(base + i));
+    }
+    printk("\n");
+}
+
+void hexdump(char* name, char* base, int len)
+{
+    __u32 i;
+
+    printk("%s :", name);
+    for (i=0; i<len; i++)
+    {
+        if (!(i&0x1f))
+            printk("\n0x%p : ", base + i);
+        if (!(i&0xf))
+            printk(" ");
+        printk("%02x ", readb(base + i));
+    }
+    printk("\n");
+}
+
+#ifdef CONFIG_PROC_FS
+static const char sunximmc_drv_version[] = DRIVER_VERSION;
+
+static int sunximmc_proc_read_drvversion(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    char *p = page;
+
+    p += sprintf(p, "%s\n", sunximmc_drv_version);
+    return p - page;
+}
+
+static int sunximmc_proc_read_hostinfo(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    char *p = page;
+    struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+    struct device* dev = &smc_host->pdev->dev;
+    char* clksrc[] = {"hosc", "satapll_2", "sdrampll_p", "hosc"};
+    char* cd_mode[] = {"none", "gpio mode", "data3 mode", "always in", "manual"};
+
+    p += sprintf(p, "%s controller information:\n", dev_name(dev));
+    p += sprintf(p, "reg base \t : %p\n", smc_host->smc_base);
+    p += sprintf(p, "clock source\t : %s\n", clksrc[smc_host->clk_source]);
+    p += sprintf(p, "mod clock\t : %d\n", smc_host->mod_clk);
+    p += sprintf(p, "card clock\t : %d\n", smc_host->real_cclk);
+    p += sprintf(p, "bus width\t : %d\n", smc_host->bus_width);
+    p += sprintf(p, "present  \t : %d\n", smc_host->present);
+    p += sprintf(p, "cd mode  \t : %s\n", cd_mode[smc_host->cd_mode]);
+    p += sprintf(p, "read only\t : %d\n", smc_host->read_only);
+
+    return p - page;
+}
+
+
+static int sunximmc_proc_read_regs(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    char *p = page;
+    struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+    u32 i;
+
+    p += sprintf(p, "Dump smc regs:\n");
+
+    for (i=0; i<0x100; i+=4)
+    {
+        if (!(i&0xf))
+            p += sprintf(p, "\n0x%08x : ", i);
+        p += sprintf(p, "%08x ", readl(smc_host->smc_base + i));
+    }
+    p += sprintf(p, "\n");
+
+    p += sprintf(p, "Dump ccmu regs:\n");
+    for (i=0; i<0x200; i+=4)
+    {
+        if (!(i&0xf))
+            p += sprintf(p, "\n0x%08x : ", i);
+        p += sprintf(p, "%08x ", readl(SW_VA_CCM_IO_BASE + i));
+    }
+    p += sprintf(p, "\n");
+
+    p += sprintf(p, "Dump gpio regs:\n");
+    for (i=0; i<0x200; i+=4)
+    {
+        if (!(i&0xf))
+            p += sprintf(p, "\n0x%08x : ", i);
+        p += sprintf(p, "%08x ", readl(SW_VA_PORTC_IO_BASE+ i));
+    }
+    p += sprintf(p, "\n");
+
+
+    return p - page;
+}
+
+static int sunximmc_proc_read_dbglevel(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    char *p = page;
+
+    p += sprintf(p, "debug-level : %d\n", smc_debug);
+    return p - page;
+}
+
+static int sunximmc_proc_write_dbglevel(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+    smc_debug = simple_strtoul(buffer, NULL, 10);
+
+    return sizeof(smc_debug);
+}
+
+static int sunximmc_proc_read_insert_status(char *page, char **start, off_t off, int coutn, int *eof, void *data)
+{
+	char *p = page;
+    struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+
+	p += sprintf(p, "Usage: \"echo 1 > insert\" to scan card and \"echo 0 > insert\" to remove card\n");
+	if (smc_host->cd_mode != CARD_DETECT_BY_FS)
+	{
+		p += sprintf(p, "Sorry, this node if only for manual attach mode(cd mode 4)\n");
+	}
+
+	p += sprintf(p, "card attach status: %s\n", smc_host->present ? "inserted" : "removed");
+
+
+	return p - page;
+}
+
+static int sunximmc_proc_card_insert_ctrl(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	u32 insert = simple_strtoul(buffer, NULL, 10);
+    struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+	u32 present = insert ? 1 : 0;
+
+	if (smc_host->present ^ present)
+	{
+		smc_host->present = present;
+		mmc_detect_change(smc_host->mmc, msecs_to_jiffies(300));
+	}
+
+	return sizeof(insert);
+}
+
+void sunximmc_procfs_attach(struct sunxi_mmc_host *smc_host)
+{
+    struct device *dev = &smc_host->pdev->dev;
+    char sunximmc_proc_rootname[32] = {0};
+
+    //make mmc dir in proc fs path
+    snprintf(sunximmc_proc_rootname, sizeof(sunximmc_proc_rootname), "driver/%s", dev_name(dev));
+    smc_host->proc_root = proc_mkdir(sunximmc_proc_rootname, NULL);
+    if (IS_ERR(smc_host->proc_root))
+    {
+        SMC_MSG("%s: failed to create procfs \"driver/mmc\".\n", dev_name(dev));
+    }
+
+    smc_host->proc_drvver = create_proc_read_entry("drv-version", 0444, smc_host->proc_root, sunximmc_proc_read_drvversion, NULL);
+    if (IS_ERR(smc_host->proc_root))
+    {
+        SMC_MSG("%s: failed to create procfs \"drv-version\".\n", dev_name(dev));
+    }
+
+    smc_host->proc_hostinfo = create_proc_read_entry("hostinfo", 0444, smc_host->proc_root, sunximmc_proc_read_hostinfo, smc_host);
+    if (IS_ERR(smc_host->proc_hostinfo))
+    {
+        SMC_MSG("%s: failed to create procfs \"hostinfo\".\n", dev_name(dev));
+    }
+
+    smc_host->proc_regs = create_proc_read_entry("register", 0444, smc_host->proc_root, sunximmc_proc_read_regs, smc_host);
+    if (IS_ERR(smc_host->proc_regs))
+    {
+        SMC_MSG("%s: failed to create procfs \"hostinfo\".\n", dev_name(dev));
+    }
+
+    smc_host->proc_dbglevel = create_proc_entry("debug-level", 0644, smc_host->proc_root);
+    if (IS_ERR(smc_host->proc_dbglevel))
+    {
+        SMC_MSG("%s: failed to create procfs \"debug-level\".\n", dev_name(dev));
+    }
+    smc_host->proc_dbglevel->data = smc_host;
+    smc_host->proc_dbglevel->read_proc = sunximmc_proc_read_dbglevel;
+    smc_host->proc_dbglevel->write_proc = sunximmc_proc_write_dbglevel;
+
+	smc_host->proc_insert = create_proc_entry("insert", 0644, smc_host->proc_root);
+	if (IS_ERR(smc_host->proc_insert))
+	{
+		SMC_MSG("%s: failed to create procfs \"insert\".\n", dev_name(dev));
+	}
+	smc_host->proc_insert->data = smc_host;
+	smc_host->proc_insert->read_proc = sunximmc_proc_read_insert_status;
+	smc_host->proc_insert->write_proc = sunximmc_proc_card_insert_ctrl;
+
+}
+
+void sunximmc_procfs_remove(struct sunxi_mmc_host *smc_host)
+{
+    struct device *dev = &smc_host->pdev->dev;
+    char sunximmc_proc_rootname[32] = {0};
+
+    snprintf(sunximmc_proc_rootname, sizeof(sunximmc_proc_rootname), "driver/%s", dev_name(dev));
+    remove_proc_entry("insert", smc_host->proc_root);
+    remove_proc_entry("debug-level", smc_host->proc_root);
+    remove_proc_entry("register", smc_host->proc_root);
+    remove_proc_entry("hostinfo", smc_host->proc_root);
+    remove_proc_entry("drv-version", smc_host->proc_root);
+    remove_proc_entry(sunximmc_proc_rootname, NULL);
+}
+
+#else
+
+void sunximmc_procfs_attach(struct sunxi_mmc_host *smc_host) { }
+void sunximmc_procfs_remove(struct sunxi_mmc_host *smc_host) { }
+
+#endif
+
+
diff --git a/drivers/mmc/sunxi-host/host_op.c b/drivers/mmc/sunxi-host/host_op.c
new file mode 100644
index 0000000..a98a0c8
--- /dev/null
+++ b/drivers/mmc/sunxi-host/host_op.c
@@ -0,0 +1,999 @@
+/*
+ * drivers/mmc/sunxi-host/host_op.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Aaron.Maoye <leafy.myeh@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "smc_syscall.h"
+#include "host_op.h"
+#include "sdxc.h"
+#include <asm/uaccess.h>
+#include <mach/clock.h>
+
+static DEFINE_MUTEX(sw_host_rescan_mutex);
+static int sw_host_rescan_pending[4] = { 0, };
+struct sunxi_mmc_host* sw_host[4] = {NULL, NULL, NULL, NULL};
+
+static int sdc_used;
+
+unsigned int smc_debug = 0;
+module_param_named(debuglevel, smc_debug, int, 0);
+
+s32 sunximmc_init_controller(struct sunxi_mmc_host* smc_host)
+{
+    SMC_INFO("MMC Driver init host %d\n", smc_host->pdev->id);
+
+    sdxc_init(smc_host);
+
+    return 0;
+}
+
+/* static s32 sunximmc_set_src_clk(struct sunxi_mmc_host* smc_host)
+ * è®¾ç½®SDå¡æ§å¶å¨æºæ¶éé¢ç, ç®æ ä¸º100MHzï¼clockæºæsmc_hostçclk_sourceå³å®
+ * clk_source: 0-video PLL, 2-dram PLL, 3-core pll
+ */
+static int sunximmc_set_src_clk(struct sunxi_mmc_host* smc_host)
+{
+    struct clk *source_clock = NULL;
+    char* name[] = {"hosc", "sata_pll_2", "sdram_pll_p", "hosc"};
+    int ret;
+
+    switch (smc_host->clk_source)
+    {
+        case 0:
+        case 3:
+            source_clock = clk_get(&smc_host->pdev->dev, "hosc");
+            break;
+        case 1:
+            source_clock = clk_get(&smc_host->pdev->dev, "sata_pll_2");
+            break;
+        case 2:
+            source_clock = clk_get(&smc_host->pdev->dev, "sdram_pll_p");
+            break;
+    }
+    if (IS_ERR(source_clock))
+    {
+    	ret = PTR_ERR(source_clock);
+    	SMC_ERR("Error to get source clock %s\n", name[smc_host->clk_source]);
+    	return ret;
+    }
+
+    clk_set_parent(smc_host->mclk, source_clock);
+    clk_set_rate(smc_host->mclk, smc_host->mod_clk);
+    clk_enable(smc_host->mclk);
+
+    smc_host->mod_clk = clk_get_rate(smc_host->mclk);
+    clk_enable(smc_host->hclk);
+
+    SMC_INFO("smc %d, source = %s, src_clk = %u, mclk %u, \n", smc_host->pdev->id, name[smc_host->clk_source], (unsigned)clk_get_rate(source_clock), smc_host->mod_clk);
+    clk_put(source_clock);
+
+    return 0;
+}
+
+static int sunximmc_resource_request(struct sunxi_mmc_host *smc_host)
+{
+    struct platform_device *pdev = smc_host->pdev;
+    u32 smc_no = pdev->id;
+    char hclk_name[16] = {0};
+    char mclk_name[8] = {0};
+    char pio_para[16] = {0};
+    u32 pio_hdle = 0;
+    s32 ret = 0;
+
+    sprintf(pio_para, "mmc%d_para", smc_no);
+    pio_hdle = gpio_request_ex(pio_para, NULL);
+    if (!pio_hdle)
+    {
+        SMC_ERR("sdc %d request pio parameter failed\n", smc_no);
+        goto out;
+    }
+    smc_host->pio_hdle = pio_hdle;
+
+    //iomap
+    smc_host->smc_base_res  = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!smc_host->smc_base_res)
+    {
+    	SMC_ERR("Failed to get io memory region resouce.\n");
+
+    	ret = -ENOENT;
+    	goto release_pin;
+    }
+    /* smc address remap */
+    smc_host->smc_base_res = request_mem_region(smc_host->smc_base_res->start, RESSIZE(smc_host->smc_base_res), pdev->name);
+    if (!smc_host->smc_base_res)
+    {
+    	SMC_ERR("Failed to request io memory region.\n");
+    	ret = -ENOENT;
+    	goto release_pin;
+    }
+    smc_host->smc_base = ioremap(smc_host->smc_base_res->start, RESSIZE(smc_host->smc_base_res));
+    if (!smc_host->smc_base)
+    {
+    	SMC_ERR("Failed to ioremap() io memory region.\n");
+    	ret = -EINVAL;
+    	goto free_mem_region;
+    }
+
+    //get hclock
+    sprintf(hclk_name, "ahb_sdc%d", smc_no);
+    smc_host->hclk = clk_get(&pdev->dev, hclk_name);
+    if (IS_ERR(smc_host->hclk))
+    {
+    	ret = PTR_ERR(smc_host->hclk);
+    	SMC_ERR("Error to get ahb clk for %s\n", hclk_name);
+    	goto iounmap;
+    }
+
+    sprintf(mclk_name, "sdc%d", smc_no);
+    smc_host->mclk = clk_get(&pdev->dev, mclk_name);
+    if (IS_ERR(smc_host->mclk))
+    {
+    	ret = PTR_ERR(smc_host->mclk);
+    	SMC_ERR("Error to get clk for mux_mmc\n");
+    	goto free_hclk;
+    }
+
+    goto out;
+
+free_hclk:
+    clk_put(smc_host->hclk);
+
+iounmap:
+    iounmap(smc_host->smc_base);
+
+free_mem_region:
+    release_mem_region(smc_host->smc_base_res->start, RESSIZE(smc_host->smc_base_res));
+
+release_pin:
+    gpio_release(smc_host->pio_hdle, 1);
+
+out:
+    return ret;
+}
+
+
+static int sunximmc_resource_release(struct sunxi_mmc_host *smc_host)
+{
+    //close clock resource
+    clk_disable(smc_host->hclk);
+    clk_put(smc_host->hclk);
+
+    clk_disable(smc_host->mclk);
+    clk_put(smc_host->mclk);
+
+    //free memory region
+    iounmap(smc_host->smc_base);
+    release_mem_region(smc_host->smc_base_res->start, RESSIZE(smc_host->smc_base_res));
+
+    gpio_release(smc_host->pio_hdle, 1);
+    return 0;
+}
+
+
+static inline void sunximmc_suspend_pins(struct sunxi_mmc_host* smc_host)
+{
+    int ret;
+    user_gpio_set_t suspend_gpio_set = {"suspend_pins_sdio", 0, 0, 0, 2, 1, 0};     //for sdio
+    user_gpio_set_t suspend_gpio_set_card = {"suspend_pins_mmc", 0, 0, 0, 0, 1, 0};    //for mmc card
+    u32 i;
+
+    SMC_DBG("mmc %d suspend pins\n", smc_host->pdev->id);
+    /* backup gpios' current config */
+    ret = gpio_get_all_pin_status(smc_host->pio_hdle, smc_host->bak_gpios, 6, 1);
+    if (ret)
+    {
+        SMC_ERR("fail to fetch current gpio cofiguration\n");
+        return;
+    }
+
+//    {
+//        SMC_MSG("printk backup gpio configuration: \n");
+//        for (i=0; i<6; i++)
+//        {
+//            SMC_MSG("gpio[%d]: name %s, port %c[%d], cfg %d, pull %d, drvl %d, data %d\n",
+//                         i, smc_host->bak_gpios[i].gpio_name,
+//                            smc_host->bak_gpios[i].port + 'A' - 1,
+//                            smc_host->bak_gpios[i].port_num,
+//                            smc_host->bak_gpios[i].mul_sel,
+//                            smc_host->bak_gpios[i].pull,
+//                            smc_host->bak_gpios[i].drv_level,
+//                            smc_host->bak_gpios[i].data);
+//        }
+//    }
+
+    switch(smc_host->pdev->id)
+    {
+        case 0:
+        case 1:
+        case 2:
+            /* setup all pins to input and no pull to save power */
+            for (i=0; i<6; i++)
+            {
+                ret = gpio_set_one_pin_status(smc_host->pio_hdle, &suspend_gpio_set_card, smc_host->bak_gpios[i].gpio_name, 1);
+                if (ret)
+                {
+                    SMC_ERR("fail to set IO(%s) into suspend status\n", smc_host->bak_gpios[i].gpio_name);
+                }
+            }
+            break;
+        case 3:
+            /* setup all pins to input and pulldown to save power */
+            for (i=0; i<6; i++)
+            {
+                ret = gpio_set_one_pin_status(smc_host->pio_hdle, &suspend_gpio_set, smc_host->bak_gpios[i].gpio_name, 1);
+                if (ret)
+                {
+                    SMC_ERR("fail to set IO(%s) into suspend status\n", smc_host->bak_gpios[i].gpio_name);
+                }
+            }
+            break;
+    }
+
+//    {
+//        user_gpio_set_t post_cfg[6];
+//
+//        gpio_get_all_pin_status(smc_host->pio_hdle, post_cfg, 6, 1);
+//        for (i=0; i<6; i++)
+//        {
+//            SMC_MSG("post suspend, gpio[%d]: name %s, port %c[%d], cfg %d, pull %d, drvl %d, data %d\n",
+//                         i, post_cfg[i].gpio_name,
+//                            post_cfg[i].port + 'A' - 1,
+//                            post_cfg[i].port_num,
+//                            post_cfg[i].mul_sel,
+//                            post_cfg[i].pull,
+//                            post_cfg[i].drv_level,
+//                            post_cfg[i].data);
+//        }
+//    }
+
+    smc_host->gpio_suspend_ok = 1;
+    return;
+}
+
+static inline void sunximmc_resume_pins(struct sunxi_mmc_host* smc_host)
+{
+    int ret;
+    u32 i;
+
+    SMC_DBG("mmc %d resume pins\n", smc_host->pdev->id);
+    switch(smc_host->pdev->id)
+    {
+        case 0:
+        case 1:
+        case 2:
+        case 3:
+            /* restore gpios' backup configuration */
+            if (smc_host->gpio_suspend_ok)
+            {
+                smc_host->gpio_suspend_ok = 0;
+                for (i=0; i<6; i++)
+                {
+                    ret = gpio_set_one_pin_status(smc_host->pio_hdle, &smc_host->bak_gpios[i], smc_host->bak_gpios[i].gpio_name, 1);
+                    if (ret)
+                    {
+                        SMC_ERR("fail to restore IO(%s) to resume status\n", smc_host->bak_gpios[i].gpio_name);
+                    }
+                }
+            }
+
+            break;
+    }
+}
+
+
+static void sunximmc_finalize_request(struct sunxi_mmc_host *smc_host)
+{
+    struct mmc_request* mrq = smc_host->mrq;
+
+    if (smc_host->wait != SDC_WAIT_FINALIZE)
+    {
+	    SMC_MSG("nothing finalize\n");
+        return;
+	}
+
+    SMC_DBG("request finalize !!\n");
+    sdxc_request_done(smc_host);
+
+    if (smc_host->error)
+    {
+        mrq->cmd->error = ETIMEDOUT;
+        if (mrq->data)
+        	mrq->data->error = ETIMEDOUT;
+        if (mrq->stop)
+            mrq->data->error = ETIMEDOUT;
+    }
+    else
+    {
+    	if (mrq->data)
+    	    mrq->data->bytes_xfered = (mrq->data->blocks * mrq->data->blksz);
+    }
+
+    smc_host->wait = SDC_WAIT_NONE;
+    smc_host->mrq = NULL;
+    smc_host->error = 0;
+    smc_host->todma = 0;
+    smc_host->pio_active = XFER_NONE;
+    mmc_request_done(smc_host->mmc, mrq);
+
+    return;
+}
+
+static s32 sunximmc_get_ro(struct mmc_host *mmc)
+{
+    struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+    char mmc_para[16] = {0};
+    int card_wp = 0;
+    int ret;
+    u32 gpio_val;
+
+    sprintf(mmc_para, "mmc%d_para", smc_host->pdev->id);
+    ret = script_parser_fetch(mmc_para, "sdc_use_wp", &card_wp, sizeof(int));
+    if (ret)
+    {
+    	SMC_ERR("sdc fetch card write protect mode failed\n");
+    }
+    if (card_wp)
+    {
+        gpio_val = gpio_read_one_pin_value(smc_host->pio_hdle, "sdc_wp");
+        SMC_DBG("sdc fetch card write protect pin status val = %d \n", gpio_val);
+        if (!gpio_val)
+        {
+            smc_host->read_only = 0;
+            return 0;
+        }
+        else
+        {
+            SMC_MSG("Card is write-protected\n");
+            smc_host->read_only = 1;
+            return 1;
+        }
+    }
+    else
+    {
+        smc_host->read_only = 0;
+        return 0;
+    }
+}
+
+static void sunximmc_cd_timer(unsigned long data)
+{
+    struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *)data;
+    u32 gpio_val;
+    u32 present;
+
+    gpio_val = gpio_read_one_pin_value(smc_host->pio_hdle, "sdc_det");
+    gpio_val += gpio_read_one_pin_value(smc_host->pio_hdle, "sdc_det");
+    gpio_val += gpio_read_one_pin_value(smc_host->pio_hdle, "sdc_det");
+    gpio_val += gpio_read_one_pin_value(smc_host->pio_hdle, "sdc_det");
+    gpio_val += gpio_read_one_pin_value(smc_host->pio_hdle, "sdc_det");
+    if (gpio_val==5)
+        present = 0;
+    else if (gpio_val==0)
+        present = 1;
+    else
+        goto modtimer;
+//    SMC_DBG("cd %d, host present %d, cur present %d\n", gpio_val, smc_host->present, present);
+
+    if (smc_host->present ^ present) {
+        SMC_MSG("mmc %d detect change, present %d\n", smc_host->pdev->id, present);
+        smc_host->present = present;
+        if (smc_host->present)
+            mmc_detect_change(smc_host->mmc, msecs_to_jiffies(300));
+        else
+            mmc_detect_change(smc_host->mmc, msecs_to_jiffies(10));
+    } else {
+//        SMC_DBG("card detect no change\n");
+    }
+
+modtimer:
+    mod_timer(&smc_host->cd_timer, jiffies + 30);
+    return;
+}
+
+static int sunximmc_card_present(struct mmc_host *mmc)
+{
+    struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+
+    if (smc_host->cd_mode == CARD_ALWAYS_PRESENT) {
+        return 1;
+    }
+    else
+        return smc_host->present;
+}
+
+static irqreturn_t sunximmc_irq(int irq, void *dev_id)
+{
+    struct sunxi_mmc_host *smc_host = dev_id;
+    unsigned long iflags;
+
+    spin_lock_irqsave(&smc_host->lock, iflags);
+
+    smc_host->sdio_int = 0;
+    if (smc_host->cd_mode == CARD_DETECT_BY_DATA3)
+    {
+        smc_host->change = 0;
+    }
+
+    sdxc_check_status(smc_host);
+
+    if (smc_host->wait == SDC_WAIT_FINALIZE)
+    {
+        tasklet_schedule(&smc_host->tasklet);
+    }
+
+    spin_unlock_irqrestore(&smc_host->lock, iflags);
+
+    /* sdio interrupt call */
+    if (smc_host->sdio_int)
+    {
+        mmc_signal_sdio_irq(smc_host->mmc);
+//    	SMC_MSG("- sdio int -\n");
+    }
+
+    /* card detect change */
+    if (smc_host->cd_mode == CARD_DETECT_BY_DATA3)
+    {
+        if (smc_host->change)
+        {
+            mmc_detect_change(smc_host->mmc, msecs_to_jiffies(300));
+        }
+    }
+
+    return IRQ_HANDLED;
+}
+
+static void sunximmc_tasklet(unsigned long data)
+{
+    struct sunxi_mmc_host *smc_host = (struct sunxi_mmc_host *) data;
+
+	sdxc_int_disable(smc_host);
+
+	if (smc_host->pio_active == XFER_WRITE)
+		sdxc_do_pio_write(smc_host);
+
+	if (smc_host->pio_active == XFER_READ)
+		sdxc_do_pio_read(smc_host);
+
+    if (smc_host->wait == SDC_WAIT_FINALIZE)
+    {
+        sdxc_int_enable(smc_host);
+        sunximmc_finalize_request(smc_host);
+    }
+    else
+        sdxc_int_enable(smc_host);
+}
+
+static void sunximmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+    struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+    s32 ret = -1;
+
+    /* Set the power state */
+    switch (ios->power_mode)
+    {
+        case MMC_POWER_ON:
+        case MMC_POWER_UP:
+            if (!smc_host->power_on)
+            {
+                SMC_MSG("mmc %d power on !!\n", smc_host->pdev->id);
+                /* resume pins to correct status */
+                sunximmc_resume_pins(smc_host);
+            	/* enable mmc hclk */
+            	clk_enable(smc_host->hclk);
+            	/* enable mmc mclk */
+            	clk_enable(smc_host->mclk);
+                /* restore registers */
+                sdxc_regs_restore(smc_host);
+                sdxc_program_clk(smc_host);
+                /* enable irq */
+                enable_irq(smc_host->irq);
+                smc_host->power_on = 1;
+            }
+        	break;
+        case MMC_POWER_OFF:
+            if (smc_host->power_on)
+            {
+                SMC_MSG("mmc %d power off !!\n", smc_host->pdev->id);
+                /* disable irq */
+                disable_irq(smc_host->irq);
+                /* backup registers */
+                sdxc_regs_save(smc_host);
+            	/* disable mmc mclk */
+            	clk_disable(smc_host->mclk);
+            	/* disable mmc hclk */
+            	clk_disable(smc_host->hclk);
+                /* suspend pins to save power */
+                sunximmc_suspend_pins(smc_host);
+                smc_host->power_on = 0;
+                smc_host->ferror = 0;
+            }
+        default:
+        	break;
+    }
+
+    /* set clock */
+    if (smc_host->power_on)
+    {
+        /* set clock */
+        if (ios->clock)
+        {
+            smc_host->cclk = ios->clock;
+            ret = sdxc_update_clk(smc_host, smc_host->mod_clk, smc_host->cclk);
+            if (ret == -1) {
+                SMC_ERR("Fatal error, please check your pin configuration.\n");
+                smc_host->ferror = 1;
+            }
+            if ((ios->power_mode == MMC_POWER_ON) || (ios->power_mode == MMC_POWER_UP))
+            {
+            	SMC_DBG("running at %dkHz (requested: %dkHz).\n", smc_host->real_cclk/1000, ios->clock/1000);
+            }
+            else
+            {
+            	SMC_DBG("powered down.\n");
+            }
+        }
+
+        /* set bus width */
+        if (smc_host->bus_width != (1<<ios->bus_width))
+        {
+            sdxc_set_buswidth(smc_host, 1<<ios->bus_width);
+            smc_host->bus_width = 1<<ios->bus_width;
+        }
+    }
+}
+
+static void sunximmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+    struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+    unsigned long flags;
+
+    spin_lock_irqsave(&smc_host->lock, flags);
+    sdxc_enable_sdio_irq(smc_host, enable);
+    spin_unlock_irqrestore(&smc_host->lock, flags);
+}
+
+static void sunximmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+    struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+
+    smc_host->mrq = mrq;
+
+    if (sunximmc_card_present(mmc) == 0
+        || smc_host->ferror || !smc_host->power_on)
+    {
+    	SMC_DBG("no medium present, ferr %d, pwd %d\n",
+    	        smc_host->ferror, smc_host->power_on);
+    	smc_host->mrq->cmd->error = -ENOMEDIUM;
+    	mmc_request_done(mmc, mrq);
+    }
+    else
+    {
+        sdxc_request(smc_host, mrq);
+    }
+}
+
+void sunximmc_rescan_card(unsigned id, unsigned insert)
+{
+	struct sunxi_mmc_host *smc_host = NULL;
+	if (id > 3) {
+		pr_err("%s: card id more than 3.\n", __func__);
+		return;
+	}
+
+	mutex_lock(&sw_host_rescan_mutex);
+	smc_host = sw_host[id];
+	if (!smc_host)
+		sw_host_rescan_pending[id] = insert;
+	mutex_unlock(&sw_host_rescan_mutex);
+	if (!smc_host)
+		return;
+
+	smc_host->present = insert ? 1 : 0;
+	mmc_detect_change(smc_host->mmc, 0);
+	return;
+}
+EXPORT_SYMBOL_GPL(sunximmc_rescan_card);
+
+int sunximmc_check_r1_ready(struct mmc_host *mmc)
+{
+    struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+    return sdxc_check_r1_ready(smc_host);
+}
+EXPORT_SYMBOL_GPL(sunximmc_check_r1_ready);
+
+static struct mmc_host_ops sunximmc_ops = {
+    .request	     = sunximmc_request,
+    .set_ios	     = sunximmc_set_ios,
+    .get_ro		     = sunximmc_get_ro,
+    .get_cd		     = sunximmc_card_present,
+    .enable_sdio_irq = sunximmc_enable_sdio_irq
+};
+
+#ifdef CONFIG_MMC_SUNXI_POWER_CONTROL
+extern int mmc_pm_io_shd_suspend_host(void);
+#else
+static inline int mmc_pm_io_shd_suspend_host(void) {return 1;}
+#endif
+
+static int __devinit sunximmc_probe(struct platform_device *pdev)
+{
+    struct sunxi_mmc_host *smc_host = NULL;
+    struct mmc_host	*mmc = NULL;
+    int ret = 0;
+    char mmc_para[16] = {0};
+    int card_detmode = 0;
+
+    SMC_MSG("%s: pdev->name: %s, pdev->id: %d\n", dev_name(&pdev->dev), pdev->name, pdev->id);
+    mmc = mmc_alloc_host(sizeof(struct sunxi_mmc_host), &pdev->dev);
+    if (!mmc)
+    {
+        SMC_ERR("mmc alloc host failed\n");
+    	ret = -ENOMEM;
+    	goto probe_out;
+    }
+
+    smc_host = mmc_priv(mmc);
+    memset((void*)smc_host, 0, sizeof(smc_host));
+    smc_host->mmc = mmc;
+    smc_host->pdev = pdev;
+
+    spin_lock_init(&smc_host->lock);
+    tasklet_init(&smc_host->tasklet, sunximmc_tasklet, (unsigned long) smc_host);
+
+    smc_host->cclk  = 400000;
+    smc_host->mod_clk = SMC_MAX_MOD_CLOCK(pdev->id);
+    smc_host->clk_source = SMC_MOD_CLK_SRC(pdev->id);
+
+    mmc->ops        = &sunximmc_ops;
+    mmc->ocr_avail	= MMC_VDD_32_33 | MMC_VDD_33_34;
+    mmc->caps	    = MMC_CAP_4_BIT_DATA|MMC_CAP_MMC_HIGHSPEED|MMC_CAP_SD_HIGHSPEED|MMC_CAP_SDIO_IRQ;
+    mmc->f_min 	    = 400000;
+    mmc->f_max      = SMC_MAX_IO_CLOCK(pdev->id);
+#ifdef MMC_PM_IGNORE_PM_NOTIFY
+    if (pdev->id==3 && !mmc_pm_io_shd_suspend_host())
+        mmc->pm_flags = MMC_PM_IGNORE_PM_NOTIFY;
+#endif
+
+    mmc->max_blk_count	= 4095;
+    mmc->max_blk_size	= 4095;
+    mmc->max_req_size	= 4095 * 512;              //32bit byte counter = 2^32 - 1
+    mmc->max_seg_size	= mmc->max_req_size;
+    mmc->max_segs	    = 256;
+
+    if (sunximmc_resource_request(smc_host))
+    {
+        SMC_ERR("%s: Failed to get resouce.\n", dev_name(&pdev->dev));
+        goto probe_free_host;
+    }
+
+    if (sunximmc_set_src_clk(smc_host))
+    {
+        goto probe_free_host;
+    }
+    sunximmc_init_controller(smc_host);
+    smc_host->power_on = 1;
+    sunximmc_procfs_attach(smc_host);
+
+    /* irq */
+    smc_host->irq = platform_get_irq(pdev, 0);
+    if (smc_host->irq == 0)
+    {
+    	dev_err(&pdev->dev, "Failed to get interrupt resouce.\n");
+    	ret = -EINVAL;
+    	goto probe_free_resource;
+    }
+
+    if (request_irq(smc_host->irq, sunximmc_irq, 0, DRIVER_NAME, smc_host))
+    {
+    	dev_err(&pdev->dev, "Failed to request smc card interrupt.\n");
+    	ret = -ENOENT;
+    	goto probe_free_irq;
+    }
+    disable_irq(smc_host->irq);
+
+    /* add host */
+    ret = mmc_add_host(mmc);
+    if (ret)
+    {
+    	dev_err(&pdev->dev, "Failed to add mmc host.\n");
+    	goto probe_free_irq;
+    }
+    platform_set_drvdata(pdev, mmc);
+
+    //fetch card detecetd mode
+    sprintf(mmc_para, "mmc%d_para", pdev->id);
+    ret = script_parser_fetch(mmc_para, "sdc_detmode", &card_detmode, sizeof(int));
+    if (ret)
+    {
+    	SMC_ERR("sdc fetch card detect mode failed\n");
+    }
+
+    smc_host->cd_mode = card_detmode;
+    if (smc_host->cd_mode == CARD_DETECT_BY_GPIO)
+    {
+        //initial card detect timer
+        init_timer(&smc_host->cd_timer);
+        smc_host->cd_timer.expires = jiffies + 1*HZ;
+        smc_host->cd_timer.function = &sunximmc_cd_timer;
+        smc_host->cd_timer.data = (unsigned long)smc_host;
+        add_timer(&smc_host->cd_timer);
+        smc_host->present = 0;
+    }
+
+    enable_irq(smc_host->irq);
+
+	mutex_lock(&sw_host_rescan_mutex);
+	if (smc_host->cd_mode == CARD_ALWAYS_PRESENT ||
+	    sw_host_rescan_pending[pdev->id]) {
+		smc_host->present = 1;
+        mmc_detect_change(smc_host->mmc, msecs_to_jiffies(300));
+    }
+
+    sw_host[pdev->id] = smc_host;
+	mutex_unlock(&sw_host_rescan_mutex);
+
+    SMC_MSG("mmc%d Probe: base:0x%p irq:%u dma:%u pdes:0x%p, ret %d.\n",
+            pdev->id, smc_host->smc_base, smc_host->irq, smc_host->dma_no, smc_host->pdes, ret);
+
+    goto probe_out;
+
+probe_free_irq:
+    if (smc_host->irq)
+    {
+        free_irq(smc_host->irq, smc_host);
+    }
+
+probe_free_resource:
+    sunximmc_resource_release(smc_host);
+
+probe_free_host:
+    mmc_free_host(mmc);
+
+probe_out:
+    return ret;
+}
+
+static void sunximmc_shutdown(struct platform_device *pdev)
+{
+    struct mmc_host    *mmc = platform_get_drvdata(pdev);
+    struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+
+    SMC_MSG("%s: ShutDown.\n", dev_name(&pdev->dev));
+
+    sunximmc_procfs_remove(smc_host);
+    mmc_remove_host(mmc);
+}
+
+static int __devexit sunximmc_remove(struct platform_device *pdev)
+{
+    struct mmc_host    	*mmc  = platform_get_drvdata(pdev);
+    struct sunxi_mmc_host	*smc_host = mmc_priv(mmc);
+
+    SMC_MSG("%s: Remove.\n", dev_name(&pdev->dev));
+
+	sdxc_exit(smc_host);
+
+	sunximmc_shutdown(pdev);
+
+    //dma
+    tasklet_disable(&smc_host->tasklet);
+
+    //irq
+    free_irq(smc_host->irq, smc_host);
+
+    if (smc_host->cd_mode == CARD_DETECT_BY_GPIO)
+    {
+        del_timer(&smc_host->cd_timer);
+    }
+
+    sunximmc_resource_release(smc_host);
+
+    mmc_free_host(mmc);
+    sw_host[pdev->id] = NULL;
+
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int sunximmc_suspend(struct device *dev)
+{
+    struct platform_device *pdev = to_platform_device(dev);
+    struct mmc_host *mmc = platform_get_drvdata(pdev);
+    int ret = 0;
+
+    if (mmc)
+    {
+        struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+
+        if (mmc->card && (mmc->card->type!=MMC_TYPE_SDIO || mmc_pm_io_shd_suspend_host()))
+            ret = mmc_suspend_host(mmc);
+
+        if (smc_host->power_on) {
+            /* disable irq */
+            disable_irq(smc_host->irq);
+
+            /* backup registers */
+            sdxc_regs_save(smc_host);
+
+        	/* disable mmc mclk */
+        	clk_disable(smc_host->mclk);
+
+        	/* disable mmc hclk */
+            if (mmc->card && mmc->card->type!=MMC_TYPE_SDIO)
+        	    clk_disable(smc_host->hclk);
+
+            /* suspend pins to save power */
+            sunximmc_suspend_pins(smc_host);
+        }
+    }
+
+    SMC_DBG("smc %d suspend\n", pdev->id);
+    return ret;
+}
+
+static int sunximmc_resume(struct device *dev)
+{
+    struct platform_device *pdev = to_platform_device(dev);
+    struct mmc_host *mmc = platform_get_drvdata(pdev);
+    int ret = 0;
+
+    if (mmc)
+    {
+        struct sunxi_mmc_host *smc_host = mmc_priv(mmc);
+
+        if (smc_host->power_on) {
+            /* resume pins to correct status */
+            sunximmc_resume_pins(smc_host);
+
+        	/* enable mmc hclk */
+            if (mmc->card && mmc->card->type!=MMC_TYPE_SDIO)
+        	    clk_enable(smc_host->hclk);
+
+        	/* enable mmc mclk */
+        	clk_enable(smc_host->mclk);
+
+            /* restore registers */
+            if (mmc->card && mmc->card->type!=MMC_TYPE_SDIO)
+                sdxc_regs_restore(smc_host);
+            sdxc_program_clk(smc_host);
+
+            /* enable irq */
+            enable_irq(smc_host->irq);
+        }
+
+        if (mmc->card && (mmc->card->type!=MMC_TYPE_SDIO || mmc_pm_io_shd_suspend_host()))
+            ret = mmc_resume_host(mmc);
+    }
+
+    SMC_DBG("smc %d resume\n", pdev->id);
+    return ret;
+}
+
+static const struct dev_pm_ops sunximmc_pm = {
+    .suspend	= sunximmc_suspend,
+    .resume		= sunximmc_resume,
+};
+#define sunximmc_pm_ops &sunximmc_pm
+
+#else /* CONFIG_PM */
+
+#define sunximmc_pm_ops NULL
+
+#endif /* CONFIG_PM */
+
+static struct resource sunximmc_resources[SUNXI_MMC_HOST_NUM][2] = {
+    #if (SUNXI_MMC_USED_CTRL & SUNXI_MMC0_USED)
+        {/* mmc0 */
+            { .start	= SMC_BASE(0),      .end = SMC_BASE(0)+0x1000-1,  .flags	= IORESOURCE_MEM},  /* reg resource */
+            { .start	= INTC_IRQNO_SMC0,  .end = INTC_IRQNO_SMC0,     .flags	= IORESOURCE_IRQ},  /* irq resource */
+        },
+    #endif
+    #if (SUNXI_MMC_USED_CTRL & SUNXI_MMC1_USED)
+        {/* mmc1 */
+            { .start	= SMC_BASE(1),      .end = SMC_BASE(1)+0x1000-1,  .flags	= IORESOURCE_MEM},  /* reg resource */
+            { .start	= INTC_IRQNO_SMC1,  .end = INTC_IRQNO_SMC1,     .flags	= IORESOURCE_IRQ},  /* irq resource */
+        },
+    #endif
+    #if (SUNXI_MMC_USED_CTRL & SUNXI_MMC2_USED)
+        {/* mmc2 */
+            { .start	= SMC_BASE(2),      .end = SMC_BASE(2)+0x1000-1,  .flags	= IORESOURCE_MEM},  /* reg resource */
+            { .start	= INTC_IRQNO_SMC2,  .end = INTC_IRQNO_SMC2,     .flags	= IORESOURCE_IRQ},  /* irq resource */
+        },
+    #endif
+    #if (SUNXI_MMC_USED_CTRL & SUNXI_MMC3_USED)
+        {/* mmc3 */
+            { .start	= SMC_BASE(3),      .end = SMC_BASE(3)+0x1000-1,  .flags	= IORESOURCE_MEM},  /* reg resource */
+            { .start	= INTC_IRQNO_SMC3,  .end = INTC_IRQNO_SMC3,     .flags	= IORESOURCE_IRQ},  /* irq resource */
+        },
+    #endif
+};
+
+static struct platform_device awmmc_device[SUNXI_MMC_HOST_NUM] = {
+    #if (SUNXI_MMC_USED_CTRL & SUNXI_MMC0_USED)
+    [0] = {.name = DRIVER_NAME, .id = 0, .num_resources	= ARRAY_SIZE(sunximmc_resources[0]), .resource = &sunximmc_resources[0][0], .dev = {}},
+    #endif
+    #if (SUNXI_MMC_USED_CTRL & SUNXI_MMC1_USED)
+    [1] = {.name = DRIVER_NAME, .id = 1, .num_resources	= ARRAY_SIZE(sunximmc_resources[1]), .resource = &sunximmc_resources[1][0], .dev = {}},
+    #endif
+    #if (SUNXI_MMC_USED_CTRL & SUNXI_MMC2_USED)
+    [2] = {.name = DRIVER_NAME, .id = 2, .num_resources	= ARRAY_SIZE(sunximmc_resources[2]), .resource = &sunximmc_resources[2][0], .dev = {}},
+    #endif
+    #if (SUNXI_MMC_USED_CTRL & SUNXI_MMC3_USED)
+    [3] = {.name = DRIVER_NAME, .id = 3, .num_resources	= ARRAY_SIZE(sunximmc_resources[3]), .resource = &sunximmc_resources[3][0], .dev = {}},
+    #endif
+};
+
+static struct platform_driver sunximmc_driver = {
+    .driver.name    = DRIVER_NAME,
+    .driver.owner   = THIS_MODULE,
+    .driver.pm	    = sunximmc_pm_ops,
+    .probe          = sunximmc_probe,
+    .remove         = __devexit_p(sunximmc_remove),
+};
+
+static int __init sunximmc_init(void)
+{
+    int ret;
+    int i;
+    char mmc_para[16] = {0};
+    int used = 0;
+
+    SMC_MSG("sunximmc_init\n");
+    for (i=0; i<SUNXI_MMC_HOST_NUM; i++)
+    {
+        memset(mmc_para, 0, sizeof(mmc_para));
+        sprintf(mmc_para, "mmc%d_para", i);
+        used = 0;
+
+        ret = script_parser_fetch(mmc_para,"sdc_used", &used, sizeof(int));
+        if (ret)
+        {
+        	printk("sunximmc_init fetch mmc%d using configuration failed\n", i);
+        }
+
+        if (used)
+        {
+            sdc_used |= 1 << i;
+            platform_device_register(&awmmc_device[i]);
+        }
+
+    }
+
+    SMC_MSG("sunxi mmc controller using config : 0x%x\n", sdc_used);
+
+    if (sdc_used)
+    {
+        return platform_driver_register(&sunximmc_driver);
+    }
+    else
+    {
+        SMC_ERR("cannot find any using configuration for controllers, return directly!\n");
+        return 0;
+    }
+}
+
+static void __exit sunximmc_exit(void)
+{
+    if (sdc_used)
+    {
+        sdc_used = 0;
+        platform_driver_unregister(&sunximmc_driver);
+    }
+}
+
+
+module_init(sunximmc_init);
+module_exit(sunximmc_exit);
+
+MODULE_DESCRIPTION("Winner's SD/MMC Card Controller Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Aaron.maoye<leafy.myeh@allwinnertech.com>");
+MODULE_ALIAS("platform:sunxi-mmc");
diff --git a/drivers/mmc/sunxi-host/host_op.h b/drivers/mmc/sunxi-host/host_op.h
new file mode 100644
index 0000000..44ccc82
--- /dev/null
+++ b/drivers/mmc/sunxi-host/host_op.h
@@ -0,0 +1,163 @@
+/*
+ * drivers/mmc/sunxi-host/host_op.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Aaron.Maoye <leafy.myeh@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _SW_HOST_OP_H_
+#define _SW_HOST_OP_H_ "host_op.h"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+
+#include <asm/cacheflush.h>
+#include <plat/dma.h>
+#include <plat/sys_config.h>
+
+#include "host_plat.h"
+#include "smc_syscall.h"
+
+#define CARD_DETECT_BY_GPIO     (1)
+#define CARD_DETECT_BY_DATA3    (2)        /* mmc detected by status of data3 */
+#define CARD_ALWAYS_PRESENT     (3)        /* mmc always present, without detect pin */
+#define CARD_DETECT_BY_FS		(4)		   /* mmc insert/remove by manual mode, from /proc/awsmc.x/insert node */
+
+struct sunxi_mmc_host;
+struct mmc_request;
+struct sunxi_mmc_idma_des;
+
+struct sunximmc_ctrl_regs {
+	u32		gctrl;
+	u32		clkc;
+	u32		timeout;
+	u32		buswid;
+	u32		waterlvl;
+	u32		funcsel;
+	u32		debugc;
+	u32		idmacc;
+};
+
+struct sunxi_mmc_host {
+
+    struct platform_device      *pdev;
+    struct mmc_host             *mmc;
+
+    void __iomem	            *smc_base;          /* sdc I/O base address  */
+
+    struct resource	            *smc_base_res;      /* resources found       */
+
+    /* clock management */
+    struct clk                  *hclk;              //
+    struct clk                  *mclk;              //
+    u32                         clk_source;         // clock, source, 0-video pll, 1-ac320 pll
+
+    u32                         power_on;         // power save, 0-normal, 1-power save
+    u32                         power_save;         // power save, 0-normal, 1-power save
+    u32                         mod_clk;            // source clock of controller
+    u32                         cclk;               // requested card clock frequence
+    u32                         real_cclk;          // real card clock to output
+    u32                         bus_width;
+
+    /* irq */
+    int                         irq;                // irq number
+    volatile u32				irq_flag;
+    volatile u32                sdio_int;
+    volatile u32                int_sum;
+
+    int                         dma_no;             //dma number
+    volatile u32                dodma;              //transfer with dma mode
+    volatile u32                todma;
+    volatile u32                dma_done;           //dma complete
+    volatile u32                ahb_done;           //dma complete
+    volatile u32                dataover;           //dma complete
+    struct sunxi_mmc_idma_des*  pdes;
+
+	u32                         pio_sgptr;
+	u32                         pio_bytes;
+	u32                         pio_count;
+	u32                         *pio_ptr;
+	u32                         pio_active;
+#define XFER_NONE 0
+#define XFER_READ 1
+#define XFER_WRITE 2
+
+    struct mmc_request	        *mrq;
+
+    volatile u32                with_autostop;
+    volatile u32                wait;
+#define SDC_WAIT_NONE           (1<<0)
+#define SDC_WAIT_CMD_DONE       (1<<1)
+#define SDC_WAIT_DATA_OVER      (1<<2)
+#define SDC_WAIT_AUTOCMD_DONE   (1<<3)
+#define SDC_WAIT_READ_DONE      (1<<4)
+#define SDC_WAIT_DMA_ERR        (1<<5)
+#define SDC_WAIT_ERROR          (1<<6)
+#define SDC_WAIT_FINALIZE       (1<<7)
+
+    volatile u32                error;
+    volatile u32                ferror;
+    spinlock_t		            lock;
+	struct tasklet_struct       tasklet;
+
+    volatile u32                present;
+    volatile u32                change;
+
+    struct timer_list           cd_timer;
+    s32                         cd_gpio;
+    s32                         cd_mode;
+    u32                         pio_hdle;
+    u32                         read_only;
+
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry		*proc_root;
+	struct proc_dir_entry		*proc_drvver;
+	struct proc_dir_entry		*proc_hostinfo;
+	struct proc_dir_entry		*proc_dbglevel;
+	struct proc_dir_entry		*proc_regs;
+	struct proc_dir_entry		*proc_insert;
+#endif
+
+	/* backup register structrue */
+	struct sunximmc_ctrl_regs   bak_regs;
+	user_gpio_set_t             bak_gpios[6];
+	u32                         gpio_suspend_ok;
+};
+
+
+static __inline void eLIBs_CleanFlushDCacheRegion(void *adr, __u32 bytes)
+{
+	__cpuc_flush_dcache_area(adr, bytes + (1 << 5) * 2 - 2);
+}
+
+#define RESSIZE(res)        (((res)->end - (res)->start)+1)
+
+void hexdump(char* name, char* base, int len);
+void sunximmc_procfs_attach(struct sunxi_mmc_host *smc_host);
+void sunximmc_procfs_remove(struct sunxi_mmc_host *smc_host);
+
+#endif
diff --git a/drivers/mmc/sunxi-host/host_plat.h b/drivers/mmc/sunxi-host/host_plat.h
new file mode 100644
index 0000000..18dfe44
--- /dev/null
+++ b/drivers/mmc/sunxi-host/host_plat.h
@@ -0,0 +1,104 @@
+/*
+ * drivers/mmc/sunxi-host/host_plat.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Aaron.Maoye <leafy.myeh@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef HOST_PLAT_H
+#define HOST_PLAT_H
+
+#include <mach/irqs.h>
+
+#define DRIVER_NAME "sunxi-mmc"
+#define DRIVER_RIVISION "V2.0"
+#define DRIVER_VERSION "SUNXI MMC Controller, Version: " DRIVER_RIVISION "(Compiled in " __DATE__ " at " __TIME__ ")"
+
+/* SDMMC Control registers definition */
+#define  SMC0_BASE              0x01C0f000
+#define  SMC1_BASE              0x01C10000
+#define  SMC2_BASE              0x01C11000
+#define  SMC3_BASE              0x01C12000
+
+#define SMC_BASE_OS             (0x1000)
+#define SMC_BASE(x)             (SMC0_BASE + 0x1000 * (x))
+
+/* interrupt number */
+#define  INTC_IRQNO_SMC0	SW_INT_IRQNO_SDMC0
+#define  INTC_IRQNO_SMC1	SW_INT_IRQNO_SDMC1
+#define  INTC_IRQNO_SMC2	SW_INT_IRQNO_SDMC2
+#define  INTC_IRQNO_SMC3	SW_INT_IRQNO_SDMC3
+
+#define  SUNXI_MMC_USED_MASK       (0xf)
+#define  SUNXI_MMC0_USED           (0x1 << 0)
+#define  SUNXI_MMC1_USED           (0x1 << 1)
+#define  SUNXI_MMC2_USED           (0x1 << 2)
+#define  SUNXI_MMC3_USED           (0x1 << 3)
+
+#if defined(CONFIG_ARCH_SUN4I)
+#define  SUNXI_MMC_HOST_NUM        4
+#define  SUNXI_MMC_USED_CTRL       (SUNXI_MMC0_USED | SUNXI_MMC1_USED | SUNXI_MMC2_USED | SUNXI_MMC3_USED)
+#define  SUNXI_MMC_MAX_DMA_DES_BIT  13
+#define  SUNXI_MMC_DMA_DES_BIT_LEFT 6
+
+enum mclk_src {
+	SMC_MCLK_SRC_HOSC,
+	SMC_MCLK_SRC_SATAPLL,
+	SMC_MCLK_SRC_DRAMPLL
+};
+#define SMC_MAX_MOD_CLOCK(n)    ((n)==3 ? 90000000 : 90000000)
+#define SMC_MAX_IO_CLOCK(n)     ((n)==3 ? 45000000 : 45000000)
+#define SMC_MOD_CLK_SRC(n)      ((n)==3 ? SMC_MCLK_SRC_DRAMPLL : SMC_MCLK_SRC_DRAMPLL)
+
+#elif defined(CONFIG_ARCH_SUN5I)
+#define  SUNXI_MMC_HOST_NUM     3
+#define  SUNXI_MMC_USED_CTRL    (SUNXI_MMC0_USED | SUNXI_MMC1_USED | SUNXI_MMC2_USED)
+#define  SUNXI_MMC_MAX_DMA_DES_BIT  16
+#define  SUNXI_MMC_DMA_DES_BIT_LEFT 0
+enum mclk_src {
+	SMC_MCLK_SRC_HOSC,
+	SMC_MCLK_SRC_SATAPLL,
+	SMC_MCLK_SRC_DRAMPLL
+};
+#define SMC_MAX_MOD_CLOCK(n)    (104000000)
+#define SMC_MAX_IO_CLOCK(n)     (52000000)
+#define SMC_MOD_CLK_SRC(n)      (SMC_MCLK_SRC_SATAPLL)
+
+#elif defined(CONFIG_ARCH_SUN7I)
+#define  SUNXI_MMC_HOST_NUM     4
+#define  SUNXI_MMC_USED_CTRL    (SUNXI_MMC0_USED | SUNXI_MMC1_USED | SUNXI_MMC2_USED | SUNXI_MMC3_USED)
+#define  SUNXI_MMC_MAX_DMA_DES_BIT  16
+#define  SUNXI_MMC_DMA_DES_BIT_LEFT 0
+enum mclk_src {
+	SMC_MCLK_SRC_HOSC,
+	SMC_MCLK_SRC_SATAPLL,
+	SMC_MCLK_SRC_DRAMPLL
+};
+#define SMC_MAX_MOD_CLOCK(n)    (104000000)
+#define SMC_MAX_IO_CLOCK(n)     (52000000)
+#define SMC_MOD_CLK_SRC(n)      (SMC_MCLK_SRC_DRAMPLL)
+
+#endif
+
+#define SMC_DBG_ERR     (1 << 0)
+#define SMC_DBG_MSG     (1 << 1)
+#define SMC_DBG_INFO	(1 << 2)
+
+#define SMC_MSG(...)    do { printk("[mmc]: "__VA_ARGS__); } while(0)
+#define SMC_ERR(...)    do { printk("[mmc]: %s(L%d): ", __FUNCTION__, __LINE__); printk(__VA_ARGS__);} while(0)
+
+#ifdef CONFIG_MMC_SUNXI_DBG
+#define SMC_INFO(...)   do {if (smc_debug) SMC_MSG(__VA_ARGS__); } while(0)
+#define SMC_DBG(...)    do {if (smc_debug) SMC_MSG(__VA_ARGS__); } while(0)
+#else  //#ifdef CONFIG_MMC_SUNXI_DBG
+#define SMC_INFO(...)
+#define SMC_DBG(...)
+#endif  //#ifdef CONFIG_MMC_SUNXI_DBG
+
+#endif
diff --git a/drivers/mmc/sunxi-host/sdxc.c b/drivers/mmc/sunxi-host/sdxc.c
new file mode 100644
index 0000000..47a216a
--- /dev/null
+++ b/drivers/mmc/sunxi-host/sdxc.c
@@ -0,0 +1,1326 @@
+/*
+ * drivers/mmc/sunxi-host/sdxc.c
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Aaron.Maoye <leafy.myeh@allwinnertech.com>
+ *
+ * sdxc.c - operation for register level control of mmc controller
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include "host_op.h"
+#include "sdxc.h"
+#include "smc_syscall.h"
+
+#if defined CONFIG_MMC_SUNXI_NEW || defined CONFIG_MMC_SUNXI_NEW_MODULE
+#error Only one of the old and new SUNXI MMC drivers may be selected
+#endif
+
+extern unsigned int smc_debug;
+
+/******************************************************************************************************
+ *                                       SD3.0 controller operation                                   *
+ ******************************************************************************************************/
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_fifo_reset(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL)|SDXC_FIFOReset, SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_dma_reset(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL)|SDXC_DMAReset, SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_int_enable(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL)|SDXC_INTEnb, SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_int_disable(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL)&(~SDXC_INTEnb), SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_dma_enable(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL)|SDXC_DMAEnb, SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_dma_disable(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL)|SDXC_DMAReset, SDXC_REG_GCTRL);
+    writel(readl(SDXC_REG_GCTRL)&(~SDXC_DMAEnb), SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_idma_reset(struct sunxi_mmc_host* smc_host)
+{
+    writel(SDXC_IDMACSoftRST, SDXC_REG_DMAC);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_idma_on(struct sunxi_mmc_host* smc_host)
+{
+    writel(SDXC_IDMACFixBurst | SDXC_IDMACIDMAOn, SDXC_REG_DMAC);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_idma_off(struct sunxi_mmc_host* smc_host)
+{
+    writel(0, SDXC_REG_DMAC);
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_idma_int_enable(struct sunxi_mmc_host* smc_host, u32 int_mask)
+{
+    writel(readl(SDXC_REG_IDIE)|int_mask, SDXC_REG_IDIE);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_idma_int_disable(struct sunxi_mmc_host* smc_host, u32 int_mask)
+{
+    writel(readl(SDXC_REG_IDIE) & (~int_mask), SDXC_REG_IDIE);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_cd_debounce_on(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL)|SDXC_DebounceEnb, SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_cd_debounce_off(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL)&(~SDXC_DebounceEnb), SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_sel_access_mode(struct sunxi_mmc_host* smc_host, u32 access_mode)
+{
+    writel((readl(SDXC_REG_GCTRL)&(~SDXC_ACCESS_BY_AHB)) | access_mode, SDXC_REG_GCTRL);
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline u32 sdxc_enable_imask(struct sunxi_mmc_host* smc_host, u32 imask)
+{
+	u32 newmask = readl(SDXC_REG_IMASK) | imask;
+	if (!(imask & SDXC_SDIOInt))
+		writew(newmask, SDXC_REG_IMASK);
+	else
+		writel(newmask, SDXC_REG_IMASK);
+	return newmask;
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline u32 sdxc_disable_imask(struct sunxi_mmc_host* smc_host, u32 imask)
+{
+    u32 newmask = readl(SDXC_REG_IMASK) & (~imask);
+	if (!(imask & SDXC_SDIOInt))
+		writew(newmask, SDXC_REG_IMASK);
+	else
+		writel(newmask, SDXC_REG_IMASK);
+	return newmask;
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static __inline void sdxc_clear_imask(struct sunxi_mmc_host* smc_host)
+{
+	/* use 16bit read/write operation to enable/disable other interrupt bits
+	 * sdio/card-det bits are controlled by it self operation.
+	 * If you want use 32bit operation, you must do an atomic operation on
+	 * this read and write back operation.
+	 */
+	writew(0, SDXC_REG_IMASK);
+//	writel(readl(SDXC_REG_IMASK)&(SDXC_SDIOInt|SDXC_CardInsert|SDXC_CardRemove), SDXC_REG_IMASK);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_enable_sdio_irq(struct sunxi_mmc_host* smc_host, u32 enable)
+{
+    if (enable)
+        sdxc_enable_imask(smc_host, SDXC_SDIOInt);
+    else
+        sdxc_disable_imask(smc_host, SDXC_SDIOInt);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_sel_ddr_mode(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL) | SDXC_DDR_MODE, SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_sel_sdr_mode(struct sunxi_mmc_host* smc_host)
+{
+    writel(readl(SDXC_REG_GCTRL) & (~SDXC_DDR_MODE), SDXC_REG_GCTRL);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_set_buswidth(struct sunxi_mmc_host* smc_host, u32 width)
+{
+    switch(width)
+    {
+        case 1:
+            writel(SDXC_WIDTH1, SDXC_REG_WIDTH);
+            break;
+        case 4:
+            writel(SDXC_WIDTH4, SDXC_REG_WIDTH);
+            break;
+        case 8:
+            writel(SDXC_WIDTH8, SDXC_REG_WIDTH);
+            break;
+    }
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+s32 sdxc_reset(struct sunxi_mmc_host* smc_host)
+{
+    u32 rval = readl(SDXC_REG_GCTRL) | SDXC_SoftReset | SDXC_FIFOReset | SDXC_DMAReset;
+    s32 time = 0xffff;
+
+    writel(rval, SDXC_REG_GCTRL);
+    while((readl(SDXC_REG_GCTRL) & 0x7) && time--);
+    if (time <= 0)
+    {
+        SMC_ERR("sdc %d reset failed\n", smc_host->pdev->id);
+        return -1;
+    }
+    return 0;
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+s32 sdxc_program_clk(struct sunxi_mmc_host* smc_host)
+{
+  	u32 rval;
+  	s32 time = 0xf000;
+  	s32 ret = 0;
+
+	//disable command done interrupt
+	sdxc_disable_imask(smc_host, SDXC_CmdDone);
+
+  	rval = SDXC_Start|SDXC_UPCLKOnly|SDXC_WaitPreOver;
+  	writel(rval, SDXC_REG_CMDR);
+
+	do {
+	    rval = readl(SDXC_REG_CMDR);
+	    time--;
+	} while(time && (rval & SDXC_Start));
+
+	if (time <= 0)
+	{
+		ret = -1;
+	}
+
+	//clear command cone flag
+	rval = readl(SDXC_REG_RINTR) & (~SDXC_SDIOInt);
+	writel(rval, SDXC_REG_RINTR);
+
+	//enable command done interrupt
+	sdxc_enable_imask(smc_host, SDXC_CmdDone);
+
+	return ret;
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+s32 sdxc_update_clk(struct sunxi_mmc_host* smc_host, u32 sclk, u32 cclk)
+{
+    u32 rval;
+    u32 clk_div;
+    u32 real_clk;
+
+    //caculate new clock divider
+    clk_div = (sclk / cclk)>>1;
+    real_clk = clk_div ? sclk/(clk_div<<1) : sclk;
+    while (real_clk > cclk)
+    {
+        clk_div++;
+        real_clk = sclk/(clk_div<<1);
+    }
+
+    SMC_DBG("sdc %d change clock over, src_clk %d, req_clk %d, real_clk %d, div %d\n", smc_host->pdev->id, sclk, cclk, real_clk, clk_div);
+
+    //update new clock
+    //disable clock
+    rval = readl(SDXC_REG_CLKCR) & (~SDXC_CardClkOn) & (~SDXC_LowPowerOn);
+    writel(rval, SDXC_REG_CLKCR);
+    if (-1 == sdxc_program_clk(smc_host))
+    {
+        SMC_ERR("clock program failed in step 1\n");
+        return -1;
+    }
+
+    //update divider
+    rval = readl(SDXC_REG_CLKCR);
+    rval &= ~0xff;
+    rval |= clk_div & 0xff;
+    writel(rval, SDXC_REG_CLKCR);
+    if (-1 == sdxc_program_clk(smc_host))
+    {
+        SMC_ERR("clock program failed in step 2\n");
+        return -1;
+    }
+
+    //re-enable clock
+    rval = readl(SDXC_REG_CLKCR) | SDXC_CardClkOn ;//| SDXC_LowPowerOn;
+    writel(rval, SDXC_REG_CLKCR);
+    if (-1 == sdxc_program_clk(smc_host))
+    {
+        SMC_ERR("clock program failed in step 3\n");
+        return -1;
+    }
+
+    smc_host->real_cclk = real_clk;
+    return real_clk;
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static void sdxc_send_cmd(struct sunxi_mmc_host* smc_host, struct mmc_command* cmd)
+{
+    u32 imask;
+    u32 cmd_val = SDXC_Start|(cmd->opcode&0x3f);
+
+    imask = SDXC_CmdDone|SDXC_IntErrBit|SDXC_WaitPreOver;
+
+    if (cmd->opcode == MMC_GO_IDLE_STATE)
+    {
+        cmd_val |= SDXC_SendInitSeq;
+        smc_host->wait = SDC_WAIT_CMD_DONE;
+    }
+    else
+    {
+        if ((cmd->flags & MMC_CMD_MASK) != MMC_CMD_BC) //with response
+        {
+            cmd_val |= SDXC_RspExp;
+
+            if (cmd->flags & MMC_RSP_136)                                   //long response
+                cmd_val |= SDXC_LongRsp;
+
+            if (cmd->flags & MMC_RSP_CRC)                                   //check response CRC
+                cmd_val |= SDXC_CheckRspCRC;
+
+            smc_host->wait = SDC_WAIT_CMD_DONE;
+
+            if ((cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC)                //with data transfer
+            {
+                cmd_val |= SDXC_DataExp | SDXC_WaitPreOver;
+                smc_host->wait = SDC_WAIT_DATA_OVER;
+                imask |= SDXC_DataOver;
+
+                if (cmd->data->flags & MMC_DATA_STREAM)        //sequence mode
+                {
+                    imask |= SDXC_AutoCMDDone;
+                    cmd_val |= SDXC_Seqmod | SDXC_SendAutoStop;
+                    smc_host->wait = SDC_WAIT_AUTOCMD_DONE;
+                }
+
+                if (smc_host->with_autostop)
+                {
+                    imask |= SDXC_AutoCMDDone;
+                    cmd_val |= SDXC_SendAutoStop;
+                    smc_host->wait = SDC_WAIT_AUTOCMD_DONE;
+                }
+
+                if (cmd->data->flags & MMC_DATA_WRITE)           //read
+                {
+                    cmd_val |= SDXC_Write;
+                    if (!smc_host->dodma) {
+//                        SMC_MSG("SDXC_TxDataReq\n");
+                        imask |= SDXC_TxDataReq;
+                    }
+                }
+                else
+                {
+                    if (!smc_host->dodma) {
+                        //imask &= ~(SDXC_AutoCMDDone | SDXC_DataOver);
+                        imask |= SDXC_RxDataReq;
+                        smc_host->wait = SDC_WAIT_READ_DONE;
+//                        SMC_MSG("SDXC_RxDataReq\n");
+                    }
+                }
+            }
+        }
+    }
+
+    sdxc_enable_imask(smc_host, imask);
+
+	//SMC_INFO("smc %d send cmd %d(%08x), imask = 0x%08x, wait = %d\n", smc_host->pdev->id, cmd_val&0x3f, cmd_val, imask, smc_host->wait);
+
+    writel(cmd->arg, SDXC_REG_CARG);
+    writel(cmd_val, SDXC_REG_CMDR);
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static void  sdxc_init_idma_des(struct sunxi_mmc_host* smc_host, struct mmc_data* data)
+{
+    struct sunxi_mmc_idma_des* pdes = smc_host->pdes;
+    u32 des_idx = 0;
+    u32 buff_frag_num = 0;
+    u32 remain;
+    u32 i, j;
+
+    /* åå§åIDMA Descriptor */
+    #if SDXC_DES_MODE == 0      //chain mode
+    for (i=0; i<data->sg_len; i++)
+    {
+        buff_frag_num = data->sg[i].length >> SDXC_DES_NUM_SHIFT;   //SDXC_DES_NUM_SHIFT == 13, num = len/8192 = len>>13
+        remain = data->sg[i].length & (SDXC_DES_BUFFER_MAX_LEN-1);
+        if (remain)
+        {
+            buff_frag_num ++;
+        }
+        else
+        {
+            remain = SDXC_DES_BUFFER_MAX_LEN;
+        }
+
+        eLIBs_CleanFlushDCacheRegion(sg_virt(&data->sg[i]), data->sg[i].length);
+        for (j=0; j < buff_frag_num; j++, des_idx++)
+        {
+			memset((void*)&pdes[des_idx], 0, sizeof(struct sunxi_mmc_idma_des));
+            pdes[des_idx].des_chain = 1;
+            pdes[des_idx].own = 1;
+            pdes[des_idx].dic = 1;
+            if (buff_frag_num > 1 && j != buff_frag_num-1)
+            {
+                pdes[des_idx].data_buf1_sz = 0x1fff & SDXC_DES_BUFFER_MAX_LEN;
+            }
+            else
+            {
+                pdes[des_idx].data_buf1_sz = remain;
+            }
+
+            pdes[des_idx].buf_addr_ptr1 = sg_dma_address(&data->sg[i]) + j * SDXC_DES_BUFFER_MAX_LEN;
+            if (i==0 && j==0)
+            {
+                pdes[des_idx].first_des = 1;
+            }
+
+            if ((i == data->sg_len-1) && (j == buff_frag_num-1))
+            {
+                pdes[des_idx].dic = 0;
+                pdes[des_idx].last_des = 1;
+                pdes[des_idx].end_of_ring = 1;
+                pdes[des_idx].buf_addr_ptr2 = 0;
+            }
+            else
+            {
+                pdes[des_idx].buf_addr_ptr2 = __pa(&pdes[des_idx+1]);
+            }
+			/*
+            SMC_INFO("sg %d, frag %d, remain %d, des[%d](%08x): [0] = %08x, [1] = %08x, [2] = %08x, [3] = %08x\n", i, j, remain,
+                                                                             des_idx, (u32)&pdes[des_idx],
+                                                                             (u32)((u32*)&pdes[des_idx])[0], (u32)((u32*)&pdes[des_idx])[1],
+                                                                             (u32)((u32*)&pdes[des_idx])[2], (u32)((u32*)&pdes[des_idx])[3]);
+			*/
+        }
+    }
+    #else      //fix length skip mode
+
+    #endif
+
+    eLIBs_CleanFlushDCacheRegion(pdes, sizeof(struct sunxi_mmc_idma_des) * (des_idx+1));
+
+    return;
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+static int sdxc_prepare_dma(struct sunxi_mmc_host* smc_host, struct mmc_data* data)
+{
+    u32 dma_len;
+    u32 i;
+
+	if (smc_host->pdes == NULL)
+	{
+		return -ENOMEM;
+	}
+
+	dma_len = dma_map_sg(mmc_dev(smc_host->mmc), data->sg, data->sg_len, (data->flags & MMC_DATA_WRITE) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	if (dma_len == 0)
+	{
+		SMC_ERR("no dma map memory\n");
+		return -ENOMEM;
+	}
+
+    for (i=0; i<data->sg_len; i++)
+    {
+        if (sg_dma_address(&data->sg[i]) & 3)
+        {
+		    SMC_ERR("unaligned dma address[%d] %p\n", i, (void*)sg_dma_address(&data->sg[i]));
+			return -EINVAL;
+        }
+    }
+
+    sdxc_init_idma_des(smc_host, data);
+	sdxc_dma_enable(smc_host);
+    sdxc_dma_reset(smc_host);
+    sdxc_idma_reset(smc_host);
+    sdxc_idma_on(smc_host);
+    sdxc_idma_int_disable(smc_host, SDXC_IDMACTransmitInt|SDXC_IDMACReceiveInt);
+    if (data->flags & MMC_DATA_WRITE)
+    {
+        sdxc_idma_int_enable(smc_host, SDXC_IDMACTransmitInt);
+    }
+    else
+    {
+        sdxc_idma_int_enable(smc_host, SDXC_IDMACReceiveInt);
+    }
+
+    //write descriptor address to register
+    writel(__pa(smc_host->pdes), SDXC_REG_DLBA);
+
+    //write water level
+    writel((2U<<28)|(7<<16)|8, SDXC_REG_FTRGL);
+
+    return 0;
+}
+
+static inline int sdxc_get_data_buffer(struct sunxi_mmc_host *smc_host, u32 *bytes, u32 **pointer)
+{
+	struct scatterlist *sg;
+
+	if (smc_host->pio_active == XFER_NONE)
+		return -EINVAL;
+
+	if ((!smc_host->mrq) || (!smc_host->mrq->data))
+		return -EINVAL;
+
+	if (smc_host->pio_sgptr >= smc_host->mrq->data->sg_len) {
+		SMC_DBG("no more buffers (%i/%i)\n",
+		      smc_host->pio_sgptr, smc_host->mrq->data->sg_len);
+		return -EBUSY;
+	}
+	sg = &smc_host->mrq->data->sg[smc_host->pio_sgptr];
+
+	*bytes = sg->length;
+	*pointer = sg_virt(sg);
+
+	smc_host->pio_sgptr++;
+
+	SMC_DBG("new buffer (%i/%i)\n", smc_host->pio_sgptr, smc_host->mrq->data->sg_len);
+
+	return 0;
+}
+
+void sdxc_do_pio_read(struct sunxi_mmc_host* smc_host)
+{
+	int res;
+	u32 fifo;
+	u32 fifo_count;
+	u32 *ptr;
+	u32 fifo_words;
+	void __iomem *from_ptr;
+
+	from_ptr = SDXC_REG_FIFO;
+
+    fifo_count = (readl(SDXC_REG_STAS)>>17)&0x1f;
+	while (fifo_count) {
+	    fifo = fifo_count << 2;
+		if (!smc_host->pio_bytes) {
+			res = sdxc_get_data_buffer(smc_host, &smc_host->pio_bytes, &smc_host->pio_ptr);
+			if (res) {
+				smc_host->pio_active = XFER_NONE;
+				smc_host->wait = SDC_WAIT_FINALIZE;
+
+				SMC_DBG("pio_read(): complete (no more data).\n");
+				return;
+			}
+
+			SMC_DBG("pio_read(): new target: [%i]@[%p]\n",
+			    smc_host->pio_bytes, smc_host->pio_ptr);
+		}
+
+//		SMC_DBG("pio_read(): fifo:[%02i] buffer:[%03i] dcnt:[%08X]\n",
+//		    fifo, smc_host->pio_bytes, readl(SDXC_REG_BBCR));
+
+		/* If we have reached the end of the block, we can
+		 * read a word and get 1 to 3 bytes.  If we in the
+		 * middle of the block, we have to read full words,
+		 * otherwise we will write garbage, so round down to
+		 * an even multiple of 4. */
+		if (fifo >= smc_host->pio_bytes)
+			fifo = smc_host->pio_bytes;
+		else
+			fifo -= fifo & 3;
+
+		smc_host->pio_bytes -= fifo;
+		smc_host->pio_count += fifo;
+
+		fifo_words = fifo >> 2;
+		ptr = smc_host->pio_ptr;
+		while (fifo_words--)
+			*ptr++ = readl(from_ptr);
+		smc_host->pio_ptr = ptr;
+
+		if (fifo & 3) {
+			u32 n = fifo & 3;
+			u32 data = readl(from_ptr);
+			u8 *p = (u8 *)smc_host->pio_ptr;
+
+			while (n--) {
+				*p++ = data;
+				data >>= 8;
+			}
+		}
+
+        fifo_count = (readl(SDXC_REG_STAS)>>17)&0x1f;
+	}
+
+	if (!smc_host->pio_bytes) {
+		res = sdxc_get_data_buffer(smc_host, &smc_host->pio_bytes, &smc_host->pio_ptr);
+		if (res) {
+			SMC_DBG("pio_read(): complete (no more buffers).\n");
+			smc_host->pio_active = XFER_NONE;
+			smc_host->wait = SDC_WAIT_FINALIZE;
+			return;
+		}
+	}
+
+	sdxc_enable_imask(smc_host, SDXC_RxDataReq);
+}
+
+void sdxc_do_pio_write(struct sunxi_mmc_host *smc_host)
+{
+	void __iomem *to_ptr;
+	int ret;
+	u32 fifo;
+	u32 fifo_free = 0;
+	u32 *ptr;
+
+	to_ptr = SDXC_REG_FIFO;
+
+    fifo_free = SDXC_FIFO_SIZE - ((readl(SDXC_REG_STAS)>>17)&0x1f);
+	while (fifo_free) {
+	    fifo = fifo_free << 2;
+		if (!smc_host->pio_bytes) {
+			ret = sdxc_get_data_buffer(smc_host, &smc_host->pio_bytes, &smc_host->pio_ptr);
+			if (ret) {
+				SMC_DBG("pio_write(): complete (no more data).\n");
+				smc_host->pio_active = XFER_NONE;
+
+				return;
+			}
+
+			SMC_DBG("pio_write(): new source: [%i]@[%p]\n", smc_host->pio_bytes, smc_host->pio_ptr);
+		}
+
+		/* If we have reached the end of the block, we have to
+		 * write exactly the remaining number of bytes.  If we
+		 * in the middle of the block, we have to write full
+		 * words, so round down to an even multiple of 4. */
+		if (fifo >= smc_host->pio_bytes)
+			fifo = smc_host->pio_bytes;
+		else
+			fifo -= fifo & 3;
+
+		smc_host->pio_bytes -= fifo;
+		smc_host->pio_count += fifo;
+
+		fifo = (fifo + 3) >> 2;
+		ptr = smc_host->pio_ptr;
+		while (fifo--)
+			writel(*ptr++, to_ptr);
+		smc_host->pio_ptr = ptr;
+
+        fifo_free = SDXC_FIFO_SIZE - ((readl(SDXC_REG_STAS)>>17)&0x1f);
+	}
+
+	sdxc_enable_imask(smc_host, SDXC_TxDataReq);
+}
+
+#define BOTH_DIR (MMC_DATA_WRITE | MMC_DATA_READ)
+static int sdxc_prepare_pio(struct sunxi_mmc_host* smc_host, struct mmc_data* data)
+{
+	int rw = (data->flags & MMC_DATA_WRITE) ? 1 : 0;
+
+	if ((data->flags & BOTH_DIR) == BOTH_DIR)
+		return -EINVAL;
+
+	smc_host->pio_sgptr = 0;
+	smc_host->pio_bytes = 0;
+	smc_host->pio_count = 0;
+	smc_host->pio_active = rw ? XFER_WRITE : XFER_READ;
+
+	if (rw)
+		sdxc_do_pio_write(smc_host);
+
+	return 0;
+}
+
+int sdxc_check_r1_ready(struct sunxi_mmc_host* smc_host)
+{
+    return readl(SDXC_REG_STAS) & SDXC_CardDataBusy ? 0 : 1;
+}
+
+int sdxc_send_manual_stop(struct sunxi_mmc_host* smc_host, struct mmc_request* request)
+{
+	struct mmc_data* data = request->data;
+	u32 cmd_val = SDXC_Start | SDXC_RspExp | SDXC_CheckRspCRC | MMC_STOP_TRANSMISSION;
+	u32 iflags = 0;
+	int ret = 0;
+
+	if (!data || !data->stop)
+	{
+		SMC_ERR("no stop cmd request\n");
+		return -1;
+	}
+
+	sdxc_int_disable(smc_host);
+
+	writel(0, SDXC_REG_CARG);
+	writel(cmd_val, SDXC_REG_CMDR);
+	do {
+		iflags = readl(SDXC_REG_RINTR);
+	} while(!(iflags & (SDXC_CmdDone | SDXC_IntErrBit)));
+
+	if (iflags & SDXC_IntErrBit)
+	{
+		SMC_ERR("sdc %d send stop command failed\n", smc_host->pdev->id);
+		data->stop->error = ETIMEDOUT;
+		ret = -1;
+	}
+
+	writel(iflags & (~SDXC_SDIOInt), SDXC_REG_RINTR);
+    data->stop->resp[0] = readl(SDXC_REG_RESP0);
+
+	sdxc_int_enable(smc_host);
+
+	return ret;
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_request(struct sunxi_mmc_host* smc_host, struct mmc_request* request)
+{
+    struct mmc_command* cmd = request->cmd;
+    struct mmc_data* data = request->data;
+    struct scatterlist* sg = NULL;
+    u32 byte_cnt = 0;
+    int ret;
+
+    smc_host->mrq = request;
+    smc_host->int_sum = 0;
+    SMC_DBG("smc %d, cmd %d, arg %08x\n", smc_host->pdev->id, cmd->opcode, cmd->arg);
+    if (data)
+    {
+        sg = data->sg;
+        byte_cnt = data->blksz * data->blocks;
+
+        writel(data->blksz, SDXC_REG_BLKSZ);
+        writel(byte_cnt, SDXC_REG_BCNTR);
+
+        SMC_DBG("-> with data %d bytes, sg_len %d\n", byte_cnt, data->sg_len);
+        if (byte_cnt > 0)
+        {
+//            SMC_MSG("-> trans by dma\n");
+            sdxc_sel_access_mode(smc_host, SDXC_ACCESS_BY_DMA);
+            smc_host->todma = 0;
+            ret = sdxc_prepare_dma(smc_host, data);
+            if (ret < 0)
+            {
+                SMC_ERR("smc %d prepare DMA failed\n", smc_host->pdev->id);
+		        smc_host->dodma = 0;
+
+                SMC_ERR("data prepare error %d\n", ret);
+    			cmd->error = ret;
+    			cmd->data->error = ret;
+    			mmc_request_done(smc_host->mmc, request);
+    			return;
+            }
+            smc_host->dodma = 1;
+        }
+        else
+        {
+//            SMC_MSG("-> trans by ahb\n");
+            sdxc_sel_access_mode(smc_host, SDXC_ACCESS_BY_AHB);
+            smc_host->todma = 0;
+            ret = sdxc_prepare_pio(smc_host, data);
+            if (ret < 0)
+            {
+                SMC_ERR("smc %d prepare ahb failed\n", smc_host->pdev->id);
+    			cmd->error = ret;
+    			cmd->data->error = ret;
+    			mmc_request_done(smc_host->mmc, request);
+    			return;
+            }
+		    smc_host->dodma = 0;
+        }
+
+        if (data->stop)
+            smc_host->with_autostop = 1;
+        else
+            smc_host->with_autostop = 0;
+    }
+
+    /* disable card detect debounce */
+    sdxc_cd_debounce_off(smc_host);
+    sdxc_send_cmd(smc_host, cmd);
+}
+
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_check_status(struct sunxi_mmc_host* smc_host)
+{
+    u32 raw_int;
+    u32 msk_int;
+	u32 idma_inte;
+    u32 idma_int;
+
+    sdxc_int_disable(smc_host);
+
+    idma_int = readl(SDXC_REG_IDST);
+    idma_inte = readl(SDXC_REG_IDIE);
+    raw_int = readl(SDXC_REG_RINTR);
+    msk_int = readl(SDXC_REG_MISTA);
+
+    smc_host->int_sum |= raw_int;
+    //SMC_INFO("smc %d int, ri %08x(%08x) mi %08x ie %08x idi %08x\n", smc_host->pdev->id, raw_int, smc_host->int_sum, msk_int, idma_inte, idma_int);
+
+	if (msk_int & SDXC_SDIOInt)
+	{
+		smc_host->sdio_int = 1;
+		writel(SDXC_SDIOInt, SDXC_REG_RINTR);
+	}
+
+	if (smc_host->cd_gpio == CARD_DETECT_BY_DATA3)
+    {
+        if (msk_int&SDXC_CardInsert)
+        {
+    	    SMC_DBG("card detect insert\n");
+    	    smc_host->present = 1;
+    	    smc_host->change = 1;
+    	    writel(SDXC_CardInsert, SDXC_REG_RINTR);
+    		goto irq_out;
+    	}
+    	if (msk_int&SDXC_CardRemove)
+    	{
+    	    SMC_DBG("card detect remove\n");
+    	    smc_host->present = 0;
+    	    smc_host->change = 1;
+    	    writel(SDXC_CardRemove, SDXC_REG_RINTR);
+    		goto irq_out;
+    	}
+    }
+
+    if (smc_host->wait == SDC_WAIT_NONE && !smc_host->sdio_int)
+    {
+    	SMC_ERR("smc %x, nothing to complete, raw_int = %08x, mask_int = %08x\n", smc_host->pdev->id, raw_int, msk_int);
+    	sdxc_clear_imask(smc_host);
+		goto irq_normal_out;
+    }
+
+    if ((raw_int & SDXC_IntErrBit) || (idma_int & SDXC_IDMA_ERR))
+    {
+        smc_host->error = raw_int & SDXC_IntErrBit;
+        smc_host->wait = SDC_WAIT_FINALIZE;
+        goto irq_normal_out;
+    }
+
+	if (!smc_host->dodma) {
+		if ((smc_host->pio_active == XFER_WRITE) && (raw_int & SDXC_TxDataReq)) {
+			sdxc_disable_imask(smc_host, SDXC_TxDataReq);
+			tasklet_schedule(&smc_host->tasklet);
+		}
+
+		if ((smc_host->pio_active == XFER_READ) && (raw_int & SDXC_RxDataReq)) {
+			sdxc_disable_imask(smc_host, SDXC_RxDataReq);
+			tasklet_schedule(&smc_host->tasklet);
+		}
+
+		if (msk_int&SDXC_DataOver) {
+		    sdxc_disable_imask(smc_host, SDXC_TxDataReq|SDXC_RxDataReq);
+			tasklet_schedule(&smc_host->tasklet);
+		}
+
+	}
+
+	if (smc_host->wait == SDC_WAIT_AUTOCMD_DONE && (msk_int&SDXC_AutoCMDDone))
+	{
+	    smc_host->wait = SDC_WAIT_FINALIZE;
+	}
+	else if (smc_host->wait == SDC_WAIT_DATA_OVER && (msk_int&SDXC_DataOver))
+	{
+	    smc_host->wait = SDC_WAIT_FINALIZE;
+	}
+	else if (smc_host->wait == SDC_WAIT_CMD_DONE && (msk_int&SDXC_CmdDone) && !(smc_host->int_sum&SDXC_IntErrBit))
+	{
+	    smc_host->wait = SDC_WAIT_FINALIZE;
+	}
+
+irq_normal_out:
+    writel((~SDXC_SDIOInt) & msk_int, SDXC_REG_RINTR);
+	writel(idma_int, SDXC_REG_IDST);
+
+irq_out:
+
+    sdxc_int_enable(smc_host);
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+s32 sdxc_request_done(struct sunxi_mmc_host* smc_host)
+{
+    struct mmc_request* req = smc_host->mrq;
+    u32 temp;
+    s32 ret = 0;
+
+    if (smc_host->int_sum & SDXC_IntErrBit)
+    {
+        SMC_ERR("smc %d err, cmd %d, %s%s%s%s%s%s%s%s%s%s !!\n",
+            smc_host->pdev->id, req->cmd->opcode,
+    		smc_host->int_sum & SDXC_RespErr     ? " RE"     : "",
+    		smc_host->int_sum & SDXC_RespCRCErr  ? " RCE"    : "",
+    		smc_host->int_sum & SDXC_DataCRCErr  ? " DCE"    : "",
+    		smc_host->int_sum & SDXC_RespTimeout ? " RTO"    : "",
+    		smc_host->int_sum & SDXC_DataTimeout ? " DTO"    : "",
+    		smc_host->int_sum & SDXC_DataStarve  ? " DS"     : "",
+    		smc_host->int_sum & SDXC_FIFORunErr  ? " FE"     : "",
+    		smc_host->int_sum & SDXC_HardWLocked ? " HL"     : "",
+    		smc_host->int_sum & SDXC_StartBitErr ? " SBE"    : "",
+    		smc_host->int_sum & SDXC_EndBitErr   ? " EBE"    : ""
+    		);
+
+        if (req->data)
+        {
+            SMC_ERR("In data %s operation\n", req->data->flags & MMC_DATA_WRITE ? "write" : "read");
+        }
+    	ret = -1;
+        goto _out_;
+    }
+
+    if (req->cmd)
+    {
+        if (req->cmd->flags & MMC_RSP_136)
+    	{
+    		req->cmd->resp[0] = readl(SDXC_REG_RESP3);
+    		req->cmd->resp[1] = readl(SDXC_REG_RESP2);
+    		req->cmd->resp[2] = readl(SDXC_REG_RESP1);
+    		req->cmd->resp[3] = readl(SDXC_REG_RESP0);
+    	}
+    	else
+    	{
+    		req->cmd->resp[0] = readl(SDXC_REG_RESP0);
+    	}
+    }
+
+_out_:
+    if (req->data)
+    {
+        if (!(req->data->flags & MMC_DATA_WRITE) && (readl(SDXC_REG_STAS) & SDXC_DataFSMBusy))
+        {
+            if ((readl(SDXC_REG_STAS) & SDXC_DataFSMBusy)
+                && (readl(SDXC_REG_STAS) & SDXC_DataFSMBusy)
+                && (readl(SDXC_REG_STAS) & SDXC_DataFSMBusy)
+                && (readl(SDXC_REG_STAS) & SDXC_DataFSMBusy)
+                && (readl(SDXC_REG_STAS) & SDXC_DataFSMBusy))
+                    SMC_DBG("mmc %d fsm busy 0x%x len %d\n",
+                        smc_host->pdev->id, readl(SDXC_REG_STAS), req->data->blksz * req->data->blocks);
+        }
+        if (smc_host->dodma)
+        {
+    		smc_host->dma_done = 0;
+            writel(0x337, SDXC_REG_IDST);
+            writel(0, SDXC_REG_IDIE);
+            sdxc_idma_off(smc_host);
+            sdxc_dma_disable(smc_host);
+        }
+
+        sdxc_fifo_reset(smc_host);
+        #if 0
+        if (smc_host->pdev->id == 3)
+        {
+            int i = 0;
+            char* dirstr = req->data->flags & MMC_DATA_WRITE ? "== Tx Data ==" : "== Rx Data ==";
+            u32 sg_len = req->data->sg_len;
+
+            SMC_MSG("%s\n", dirstr);
+            for (i=0; i<sg_len; i++) {
+                char sgstr[8] = {0};
+                sprintf(sgstr, "sg[%d]", i);
+                hexdump(sgstr, sg_virt(&req->data->sg[i]), req->data->sg[i].length > 64 ? 64 : req->data->sg[i].length);
+            }
+        }
+        #endif
+    }
+
+    temp = readl(SDXC_REG_STAS);
+    if ((temp & SDXC_DataFSMBusy) || (smc_host->int_sum & (SDXC_RespErr | SDXC_HardWLocked | SDXC_RespTimeout)))
+    {
+        SMC_DBG("sdc %d abnormal status: %s %s\n", smc_host->pdev->id,
+                                                  temp & SDXC_DataFSMBusy ? "DataFSMBusy" : "",
+                                                  smc_host->int_sum & SDXC_HardWLocked ? "HardWLocked" : "");
+        sdxc_reset(smc_host);
+        sdxc_program_clk(smc_host);
+    }
+
+    writel(0xffff, SDXC_REG_RINTR);
+    sdxc_clear_imask(smc_host);
+    //re-enable card detect debounce
+    if (smc_host->cd_gpio == CARD_DETECT_BY_DATA3)
+    {
+        sdxc_cd_debounce_on(smc_host);
+    }
+
+    SMC_DBG("smc %d done, resp %08x %08x %08x %08x\n", smc_host->pdev->id, req->cmd->resp[0], req->cmd->resp[1], req->cmd->resp[2], req->cmd->resp[3]);
+
+	if (req->data && req->data->stop && (smc_host->int_sum & SDXC_IntErrBit))
+	{
+		SMC_MSG("found data error, need to send stop command !!\n");
+		sdxc_send_manual_stop(smc_host, req);
+	}
+
+    return ret;
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_regs_save(struct sunxi_mmc_host* smc_host)
+{
+	struct sunximmc_ctrl_regs* bak_regs = &smc_host->bak_regs;
+
+	bak_regs->gctrl		= readl(SDXC_REG_GCTRL);
+	bak_regs->clkc		= readl(SDXC_REG_CLKCR);
+	bak_regs->timeout	= readl(SDXC_REG_TMOUT);
+	bak_regs->buswid	= readl(SDXC_REG_WIDTH);
+	bak_regs->waterlvl	= readl(SDXC_REG_FTRGL);
+	bak_regs->funcsel	= readl(SDXC_REG_FUNS);
+	bak_regs->debugc	= readl(SDXC_REG_DBGC);
+	bak_regs->idmacc	= readl(SDXC_REG_DMAC);
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+void sdxc_regs_restore(struct sunxi_mmc_host* smc_host)
+{
+	struct sunximmc_ctrl_regs* bak_regs = &smc_host->bak_regs;
+
+    writel(bak_regs->gctrl   , SDXC_REG_GCTRL);
+    writel(bak_regs->clkc    , SDXC_REG_CLKCR);
+    writel(bak_regs->timeout , SDXC_REG_TMOUT);
+    writel(bak_regs->buswid  , SDXC_REG_WIDTH);
+    writel(bak_regs->waterlvl, SDXC_REG_FTRGL);
+    writel(bak_regs->funcsel , SDXC_REG_FUNS );
+    writel(bak_regs->debugc  , SDXC_REG_DBGC );
+    writel(bak_regs->idmacc  , SDXC_REG_DMAC );
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+s32 sdxc_init(struct sunxi_mmc_host* smc_host)
+{
+	struct sunxi_mmc_idma_des* pdes = NULL;
+
+    /* reset controller */
+    if (-1 == sdxc_reset(smc_host))
+    {
+        return -1;
+    }
+
+    writel(SDXC_PosedgeLatchData, SDXC_REG_GCTRL);
+
+    /* config DMA/Interrupt Trigger threshold */
+    writel(0x70008, SDXC_REG_FTRGL);
+
+    /* config timeout register */
+    writel(0xffffffff, SDXC_REG_TMOUT);
+
+    /* clear interrupt flags */
+    writel(0xffffffff, SDXC_REG_RINTR);
+
+    writel(0xdeb, SDXC_REG_DBGC);
+    writel(0xceaa0000, SDXC_REG_FUNS);
+
+    sdxc_int_enable(smc_host);
+
+   	/* alloc idma descriptor structure */
+	pdes = (struct sunxi_mmc_idma_des*)kmalloc(sizeof(struct sunxi_mmc_idma_des) * SDXC_MAX_DES_NUM, GFP_DMA | GFP_KERNEL);
+	if (pdes == NULL)
+	{
+	    SMC_ERR("alloc dma des failed\n");
+	    return -1;
+	}
+	smc_host->pdes = pdes;
+    return 0;
+}
+
+/*
+ * Method	  :
+ * Description:
+ * Parameters :
+ *
+ * Returns    :
+ * Note       :
+ */
+s32 sdxc_exit(struct sunxi_mmc_host* smc_host)
+{
+	/* free idma descriptor structrue */
+	if (smc_host->pdes)
+	{
+    	kfree((void*)smc_host->pdes);
+		smc_host->pdes = NULL;
+	}
+
+    /* reset controller */
+    if (-1 == sdxc_reset(smc_host))
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
diff --git a/drivers/mmc/sunxi-host/sdxc.h b/drivers/mmc/sunxi-host/sdxc.h
new file mode 100644
index 0000000..0d83e7c
--- /dev/null
+++ b/drivers/mmc/sunxi-host/sdxc.h
@@ -0,0 +1,242 @@
+/*
+ * drivers/mmc/sunxi-host/sdxc.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Aaron.Maoye <leafy.myeh@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _SUNXI_SDXC_H_
+#define _SUNXI_SDXC_H_
+
+/******************************************************************************************************
+ *                                   Define For SD3.0 Controller                                      *
+ ******************************************************************************************************/
+/* register offset define */
+#define SDXC_REG_o_GCTRL              (0x00)              // SMC Global Control Register
+#define SDXC_REG_o_CLKCR              (0x04)              // SMC Clock Control Register
+#define SDXC_REG_o_TMOUT              (0x08)              // SMC Time Out Register
+#define SDXC_REG_o_WIDTH              (0x0C)              // SMC Bus Width Register
+#define SDXC_REG_o_BLKSZ              (0x10)              // SMC Block Size Register
+#define SDXC_REG_o_BCNTR              (0x14)              // SMC Byte Count Register
+#define SDXC_REG_o_CMDR               (0x18)              // SMC Command Register
+#define SDXC_REG_o_CARG               (0x1C)              // SMC Argument Register
+#define SDXC_REG_o_RESP0              (0x20)              // SMC Response Register 0
+#define SDXC_REG_o_RESP1              (0x24)              // SMC Response Register 1
+#define SDXC_REG_o_RESP2              (0x28)              // SMC Response Register 2
+#define SDXC_REG_o_RESP3              (0x2C)              // SMC Response Register 3
+#define SDXC_REG_o_IMASK              (0x30)              // SMC Interrupt Mask Register
+#define SDXC_REG_o_MISTA              (0x34)              // SMC Masked Interrupt Status Register
+#define SDXC_REG_o_RINTR              (0x38)              // SMC Raw Interrupt Status Register
+#define SDXC_REG_o_STAS               (0x3C)              // SMC Status Register
+#define SDXC_REG_o_FTRGL              (0x40)              // SMC FIFO Threshold Watermark Register
+#define SDXC_REG_o_FUNS               (0x44)              // SMC Function Select Register
+#define SDXC_REG_o_CBCR               (0x48)              // SMC CIU Byte Count Register
+#define SDXC_REG_o_BBCR               (0x4C)              // SMC BIU Byte Count Register
+#define SDXC_REG_o_DBGC               (0x50)              // SMC Debug Enable Register
+#define SDXC_REG_o_DMAC               (0x80)              // SMC IDMAC Control Register
+#define SDXC_REG_o_DLBA               (0x84)              // SMC IDMAC Descriptor List Base Address Register
+#define SDXC_REG_o_IDST               (0x88)              // SMC IDMAC Status Register
+#define SDXC_REG_o_IDIE               (0x8C)              // SMC IDMAC Interrupt Enable Register
+#define SDXC_REG_o_CHDA               (0x90)
+#define SDXC_REG_o_CBDA               (0x94)
+#define SDXC_REG_o_FIFO               (0x100)             // SMC FIFO Access Address
+
+#define SDXC_REG_GCTRL                  (smc_host->smc_base + SDXC_REG_o_GCTRL)
+#define SDXC_REG_CLKCR                  (smc_host->smc_base + SDXC_REG_o_CLKCR)
+#define SDXC_REG_TMOUT                  (smc_host->smc_base + SDXC_REG_o_TMOUT)
+#define SDXC_REG_WIDTH                  (smc_host->smc_base + SDXC_REG_o_WIDTH)
+#define SDXC_REG_BLKSZ                  (smc_host->smc_base + SDXC_REG_o_BLKSZ)
+#define SDXC_REG_BCNTR                  (smc_host->smc_base + SDXC_REG_o_BCNTR)
+#define SDXC_REG_CMDR                   (smc_host->smc_base + SDXC_REG_o_CMDR )
+#define SDXC_REG_CARG                   (smc_host->smc_base + SDXC_REG_o_CARG )
+#define SDXC_REG_RESP0                  (smc_host->smc_base + SDXC_REG_o_RESP0)
+#define SDXC_REG_RESP1                  (smc_host->smc_base + SDXC_REG_o_RESP1)
+#define SDXC_REG_RESP2                  (smc_host->smc_base + SDXC_REG_o_RESP2)
+#define SDXC_REG_RESP3                  (smc_host->smc_base + SDXC_REG_o_RESP3)
+#define SDXC_REG_IMASK                  (smc_host->smc_base + SDXC_REG_o_IMASK)
+#define SDXC_REG_MISTA                  (smc_host->smc_base + SDXC_REG_o_MISTA)
+#define SDXC_REG_RINTR                  (smc_host->smc_base + SDXC_REG_o_RINTR)
+#define SDXC_REG_STAS                   (smc_host->smc_base + SDXC_REG_o_STAS )
+#define SDXC_REG_FTRGL                  (smc_host->smc_base + SDXC_REG_o_FTRGL)
+#define SDXC_REG_FUNS                   (smc_host->smc_base + SDXC_REG_o_FUNS )
+#define SDXC_REG_CBCR                   (smc_host->smc_base + SDXC_REG_o_CBCR )
+#define SDXC_REG_BBCR                   (smc_host->smc_base + SDXC_REG_o_BBCR )
+#define SDXC_REG_DBGC                   (smc_host->smc_base + SDXC_REG_o_DBGC )
+#define SDXC_REG_DMAC                   (smc_host->smc_base + SDXC_REG_o_DMAC )
+#define SDXC_REG_DLBA                   (smc_host->smc_base + SDXC_REG_o_DLBA )
+#define SDXC_REG_IDST                   (smc_host->smc_base + SDXC_REG_o_IDST )
+#define SDXC_REG_IDIE                   (smc_host->smc_base + SDXC_REG_o_IDIE )
+#define SDXC_REG_CHDA                   (smc_host->smc_base + SDXC_REG_o_CHDA )
+#define SDXC_REG_CBDA                   (smc_host->smc_base + SDXC_REG_o_CBDA )
+#define SDXC_REG_FIFO                   (smc_host->smc_base + SDXC_REG_o_FIFO )
+
+/* bit field for registers */
+/* global control register */
+#define SDXC_SoftReset                (0x1U<<0)
+#define SDXC_FIFOReset                (0x1U<<1)
+#define SDXC_DMAReset                 (0x1U<<2)
+#define SDXC_INTEnb                   (0x1U<<4)
+#define SDXC_DMAEnb                   (0x1U<<5)
+#define SDXC_DebounceEnb              (0x1U<<8)
+#define SDXC_PosedgeLatchData         (0x1U<<9)
+#define SDXC_NegedgeLatchData         (0x0U<<9)
+#define SDXC_DDR_MODE                 (0x1U<<10)
+#define SDXC_ACCESS_BY_AHB            (0x1U<<31)
+#define SDXC_ACCESS_BY_DMA            (0x0U<<31)
+/* Clock control */
+#define SDXC_CardClkOn                (1U<<16)
+#define SDXC_LowPowerOn               (1U<<17)
+/* bus width */
+#define SDXC_WIDTH1                   (0)
+#define SDXC_WIDTH4                   (1)
+#define SDXC_WIDTH8                   (2)
+/* Struct for SMC Commands */
+#define SDXC_RspExp                   (0x1U<<6)  //0x40
+#define SDXC_LongRsp                  (0x1U<<7)  //0x80
+#define SDXC_CheckRspCRC              (0x1U<<8)  //0x100
+#define SDXC_DataExp                  (0x1U<<9)  //0x200
+#define SDXC_Read                     (0x0U<<10) //0x000
+#define SDXC_Write                    (0x1U<<10) //0x400
+#define SDXC_Blockmod                 (0x0U<<11) //0x000
+#define SDXC_Seqmod                   (0x1U<<11) //0x800
+#define SDXC_SendAutoStop             (0x1U<<12) //0x1000
+#define SDXC_WaitPreOver              (0x1U<<13) //0x2000
+#define SDXC_StopAbortCMD             (0x1U<<14) //0x4000
+#define SDXC_SendInitSeq              (0x1U<<15) //0x8000
+#define SDXC_UPCLKOnly                (0x1U<<21) //0x200000
+#define SDXC_RdCEATADev               (0x1U<<22) //0x400000
+#define SDXC_CCSExp                   (0x1U<<23) //0x800000
+#define SDXC_EnbBoot                  (0x1U<<24) //0x1000000
+#define SDXC_AltBootOpt               (0x1U<<25) //0x2000000
+#define SDXC_MandBootOpt              (0x0U<<25) //0x0000000
+#define SDXC_BootACKExp               (0x1U<<26) //0x4000000
+#define SDXC_DisableBoot              (0x1U<<27) //0x8000000
+#define SDXC_VolSwitch                (0x1U<<28) //0x10000000
+#define SDXC_Start                    (0x1U<<31) //0x80000000
+/* Struct for Intrrrupt Information */
+#define SDXC_RespErr                  (0x1U<<1)  //0x2
+#define SDXC_CmdDone                  (0x1U<<2)  //0x4
+#define SDXC_DataOver                 (0x1U<<3)  //0x8
+#define SDXC_TxDataReq                (0x1U<<4)  //0x10
+#define SDXC_RxDataReq                (0x1U<<5)  //0x20
+#define SDXC_RespCRCErr               (0x1U<<6)  //0x40
+#define SDXC_DataCRCErr               (0x1U<<7)  //0x80
+#define SDXC_RespTimeout              (0x1U<<8)  //0x100
+#define SDXC_ACKRcv                   (0x1U<<8)  //0x100
+#define SDXC_DataTimeout              (0x1U<<9)  //0x200
+#define SDXC_BootStart                (0x1U<<9)  //0x200
+#define SDXC_DataStarve               (0x1U<<10) //0x400
+#define SDXC_VolChgDone               (0x1U<<10) //0x400
+#define SDXC_FIFORunErr               (0x1U<<11) //0x800
+#define SDXC_HardWLocked              (0x1U<<12) //0x1000
+#define SDXC_StartBitErr              (0x1U<<13) //0x2000
+#define SDXC_AutoCMDDone              (0x1U<<14) //0x4000
+#define SDXC_EndBitErr                (0x1U<<15) //0x8000
+#define SDXC_SDIOInt                  (0x1U<<16) //0x10000
+#define SDXC_CardInsert               (0x1U<<30) //0x40000000
+#define SDXC_CardRemove               (0x1U<<31) //0x80000000
+#define SDXC_IntErrBit                (SDXC_RespErr | SDXC_RespCRCErr | SDXC_DataCRCErr | SDXC_RespTimeout | SDXC_DataTimeout  \
+                                        | SDXC_FIFORunErr | SDXC_HardWLocked | SDXC_StartBitErr | SDXC_EndBitErr)  //0xbfc2
+/* status */
+#define SDXC_RXWLFlag                 (0x1U<<0)
+#define SDXC_TXWLFlag                 (0x1U<<1)
+#define SDXC_FIFOEmpty                (0x1U<<2)
+#define SDXC_FIFOFull                 (0x1U<<3)
+#define SDXC_CardPresent              (0x1U<<8)
+#define SDXC_CardDataBusy             (0x1U<<9)
+#define SDXC_DataFSMBusy              (0x1U<<10)
+#define SDXC_DMAReq                   (0x1U<<31)
+#define SDXC_FIFO_SIZE                (16)
+/* Function select */
+#define SDXC_CEATAOn                  (0xceaaU<<16)
+#define SDXC_SendIrqRsp               (0x1U<<0)
+#define SDXC_SDIORdWait               (0x1U<<1)
+#define SDXC_AbtRdData                (0x1U<<2)
+#define SDXC_SendCCSD                 (0x1U<<8)
+#define SDXC_SendAutoStopCCSD         (0x1U<<9)
+#define SDXC_CEATADevIntEnb           (0x1U<<10)
+/* IDMA controller bus mod bit field */
+#define SDXC_IDMACSoftRST             (0x1U<<0)
+#define SDXC_IDMACFixBurst            (0x1U<<1)
+#define SDXC_IDMACIDMAOn              (0x1U<<7)
+#define SDXC_IDMACRefetchDES          (0x1U<<31)
+/* IDMA status bit field */
+#define SDXC_IDMACTransmitInt         (0x1U<<0)
+#define SDXC_IDMACReceiveInt          (0x1U<<1)
+#define SDXC_IDMACFatalBusErr         (0x1U<<2)
+#define SDXC_IDMACDesInvalid          (0x1U<<4)
+#define SDXC_IDMACCardErrSum          (0x1U<<5)
+#define SDXC_IDMACNormalIntSum        (0x1U<<8)
+#define SDXC_IDMACAbnormalIntSum      (0x1U<<9)
+#define SDXC_IDMACHostAbtInTx         (0x1U<<10)
+#define SDXC_IDMACHostAbtInRx         (0x1U<<10)
+#define SDXC_IDMACIdle                (0x0U<<13)
+#define SDXC_IDMACSuspend             (0x1U<<13)
+#define SDXC_IDMACDESCRd              (0x2U<<13)
+#define SDXC_IDMACDESCCheck           (0x3U<<13)
+#define SDXC_IDMACRdReqWait           (0x4U<<13)
+#define SDXC_IDMACWrReqWait           (0x5U<<13)
+#define SDXC_IDMACRd                  (0x6U<<13)
+#define SDXC_IDMACWr                  (0x7U<<13)
+#define SDXC_IDMACDESCClose           (0x8U<<13)
+
+#define SDXC_IDMA_OVER       (SDXC_IDMACTransmitInt|SDXC_IDMACReceiveInt|SDXC_IDMACNormalIntSum)
+#define SDXC_IDMA_ERR        (SDXC_IDMACFatalBusErr|SDXC_IDMACDesInvalid|SDXC_IDMACCardErrSum|SDXC_IDMACAbnormalIntSum)
+
+/*
+ * IDMAæè¿°ç¬¦ä¸­æ¯ææå¤§çbufferé¿åº¦ä¸º8192ï¼å¦æåæ¬¡ä¼ è¾>8192éè¦å°bufferæå®å°ä¸åçæè¿°ç¬¦ä¸­
+ * è¿éæ¯ææå¤§1024ä¸ªæè¿°ç¬¦ï¼å³æ¯æåæ¬¡ä¼ è¾çæå¤§é¿åº¦ä¸º1024*8192 = 8Mæ°æ®ï¼å¨ä¼ è¾ä¸­ä¸æ¬¡æ§åé
+ * æè¿°ç¬¦ç©ºé´ï¼é¿åå¤æ¬¡åéä½¿æçä½ä¸ï¼æè¿°ç¬¦å±å ç¨1024*16 = 16Kç©ºé´ï¼ä¼ è¾å®æ¯åéæ¾
+ */
+#define SDXC_DES_BUFFER_MAX_LEN       (1 << SUNXI_MMC_MAX_DMA_DES_BIT) //16bits in aw1625, 13bit in aw1623
+#define SDXC_DES_NUM_SHIFT            (SUNXI_MMC_MAX_DMA_DES_BIT)  //65536 == 1<<16; change to 16bits, 13bit used in aw1623
+#define SDXC_MAX_DES_NUM              (1024)
+#define SDXC_DES_MODE                 0 //0-chain mode, 1-fix length skip
+
+struct sunxi_mmc_idma_des{
+    u32                     :1,
+            dic             :1,     //disable interrupt on completion
+            last_des        :1,     //1-this data buffer is the last buffer
+            first_des       :1,     //1-data buffer is the first buffer, 0-data buffer contained in the next descriptor is the first data buffer
+            des_chain       :1,     //1-the 2nd address in the descriptor is the next descriptor address
+            end_of_ring     :1,     //1-last descriptor flag when using dual data buffer in descriptor
+                            :24,
+            card_err_sum    :1,     //transfer error flag
+            own             :1;     //des owner:1-idma owns it, 0-host owns it
+
+    u32     data_buf1_sz    :SUNXI_MMC_MAX_DMA_DES_BIT,    //change to 16bits, 13bit used in aw1623
+            data_buf2_sz    :SUNXI_MMC_MAX_DMA_DES_BIT,    //change to 16bits, 13bit used in aw1623
+                            :SUNXI_MMC_DMA_DES_BIT_LEFT;
+    u32     buf_addr_ptr1;
+    u32     buf_addr_ptr2;
+};
+
+struct sunxi_mmc_host;
+
+s32 sdxc_init(struct sunxi_mmc_host* smc_host);
+s32 sdxc_exit(struct sunxi_mmc_host* smc_host);
+s32 sdxc_reset(struct sunxi_mmc_host* smc_host);
+void sdxc_int_enable(struct sunxi_mmc_host* smc_host);
+void sdxc_int_disable(struct sunxi_mmc_host* smc_host);
+s32 sdxc_program_clk(struct sunxi_mmc_host* smc_host);
+s32 sdxc_update_clk(struct sunxi_mmc_host* smc_host, u32 sclk, u32 cclk);
+void sdxc_request(struct sunxi_mmc_host* smc_host, struct mmc_request* request);
+void sdxc_check_status(struct sunxi_mmc_host* smc_host);
+s32 sdxc_request_done(struct sunxi_mmc_host* smc_host);
+void sdxc_set_buswidth(struct sunxi_mmc_host* smc_host, u32 width);
+void sdxc_sel_ddr_mode(struct sunxi_mmc_host* smc_host);
+void sdxc_sel_sdr_mode(struct sunxi_mmc_host* smc_host);
+u32 sdxc_check_card_busy(struct sunxi_mmc_host* smc_host);
+void sdxc_enable_sdio_irq(struct sunxi_mmc_host* smc_host, u32 enable);
+void sdxc_regs_save(struct sunxi_mmc_host* smc_host);
+void sdxc_regs_restore(struct sunxi_mmc_host* smc_host);
+int sdxc_check_r1_ready(struct sunxi_mmc_host* smc_host);
+void sdxc_do_pio_read(struct sunxi_mmc_host* smc_host);
+void sdxc_do_pio_write(struct sunxi_mmc_host *smc_host);
+
+#endif
diff --git a/drivers/mmc/sunxi-host/smc_syscall.h b/drivers/mmc/sunxi-host/smc_syscall.h
new file mode 100644
index 0000000..e7e909a
--- /dev/null
+++ b/drivers/mmc/sunxi-host/smc_syscall.h
@@ -0,0 +1,325 @@
+/*
+ * drivers/mmc/sunxi-host/smc_syscall.h
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Aaron.Maoye <leafy.myeh@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _SUNXI_SDC_SYSCALL_H_
+#define _SUNXI_SDC_SYSCALL_H_
+
+#include <mach/platform.h>
+#include <linux/io.h>
+
+#define GPIO_BASE            		SW_PA_PORTC_IO_BASE
+
+#define PA_CFG0_REG        			(gpio_base+0x000)
+#define PA_CFG1_REG           	    (gpio_base+0x004)
+#define PA_CFG2_REG         		(gpio_base+0x008)
+#define PA_CFG3_REG         		(gpio_base+0x00C)
+#define PA_DAT_REG         			(gpio_base+0x010)
+#define PA_DRV0_REG        			(gpio_base+0x014)
+#define PA_DRV1_REG        			(gpio_base+0x018)
+#define PA_PULL0_REG     			(gpio_base+0x01C)
+#define PA_PULL1_REG     			(gpio_base+0x020)
+#define PB_CFG0_REG        			(gpio_base+0x024)
+#define PB_CFG1_REG           	    (gpio_base+0x028)
+#define PB_CFG2_REG         		(gpio_base+0x02C)
+#define PB_CFG3_REG         		(gpio_base+0x030)
+#define PB_DAT_REG         			(gpio_base+0x034)
+#define PB_DRV0_REG        			(gpio_base+0x038)
+#define PB_DRV1_REG        			(gpio_base+0x03C)
+#define PB_PULL0_REG     			(gpio_base+0x040)
+#define PB_PULL1_REG     			(gpio_base+0x044)
+#define PC_CFG0_REG        			(gpio_base+0x048)
+#define PC_CFG1_REG           	    (gpio_base+0x04C)
+#define PC_CFG2_REG         		(gpio_base+0x050)
+#define PC_CFG3_REG         		(gpio_base+0x054)
+#define PC_DAT_REG         			(gpio_base+0x058)
+#define PC_DRV0_REG        			(gpio_base+0x05C)
+#define PC_DRV1_REG        			(gpio_base+0x060)
+#define PC_PULL0_REG     			(gpio_base+0x064)
+#define PC_PULL1_REG     			(gpio_base+0x068)
+#define PD_CFG0_REG        			(gpio_base+0x06C)
+#define PD_CFG1_REG           	    (gpio_base+0x070)
+#define PD_CFG2_REG         		(gpio_base+0x074)
+#define PD_CFG3_REG         		(gpio_base+0x078)
+#define PD_DAT_REG         			(gpio_base+0x07C)
+#define PD_DRV0_REG        			(gpio_base+0x080)
+#define PD_DRV1_REG        			(gpio_base+0x084)
+#define PD_PULL0_REG     			(gpio_base+0x088)
+#define PD_PULL1_REG     			(gpio_base+0x08C)
+#define PE_CFG0_REG        			(gpio_base+0x090)
+#define PE_CFG1_REG           	    (gpio_base+0x094)
+#define PE_CFG2_REG         		(gpio_base+0x098)
+#define PE_CFG3_REG         		(gpio_base+0x09C)
+#define PE_DAT_REG         			(gpio_base+0x0A0)
+#define PE_DRV0_REG        			(gpio_base+0x0A4)
+#define PE_DRV1_REG        			(gpio_base+0x0A8)
+#define PE_PULL0_REG     			(gpio_base+0x0AC)
+#define PE_PULL1_REG     			(gpio_base+0x0B0)
+#define PF_CFG0_REG        			(gpio_base+0x0B4)
+#define PF_CFG1_REG           	    (gpio_base+0x0B8)
+#define PF_CFG2_REG         		(gpio_base+0x0BC)
+#define PF_CFG3_REG         		(gpio_base+0x0C0)
+#define PF_DAT_REG         			(gpio_base+0x0C4)
+#define PF_DRV0_REG        			(gpio_base+0x0C8)
+#define PF_DRV1_REG        			(gpio_base+0x0CC)
+#define PF_PULL0_REG     			(gpio_base+0x0D0)
+#define PF_PULL1_REG     			(gpio_base+0x0D4)
+#define PG_CFG0_REG        			(gpio_base+0x0D8)
+#define PG_CFG1_REG           	    (gpio_base+0x0DC)
+#define PG_CFG2_REG         		(gpio_base+0x0E0)
+#define PG_CFG3_REG         		(gpio_base+0x0E4)
+#define PG_DAT_REG         			(gpio_base+0x0E8)
+#define PG_DRV0_REG        			(gpio_base+0x0EC)
+#define PG_DRV1_REG        			(gpio_base+0x0F0)
+#define PG_PULL0_REG     			(gpio_base+0x0F4)
+#define PG_PULL1_REG     			(gpio_base+0x0F8)
+#define PH_CFG0_REG         		(gpio_base+0x0FC)
+#define PH_CFG1_REG           	    (gpio_base+0x100)
+#define PH_CFG2_REG         		(gpio_base+0x104)
+#define PH_CFG3_REG         		(gpio_base+0x108)
+#define PH_DAT_REG         		    (gpio_base+0x10C)
+#define PH_DRV0_REG        		    (gpio_base+0x110)
+#define PH_DRV1_REG        		    (gpio_base+0x114)
+#define PH_PULL0_REG     			(gpio_base+0x118)
+#define PH_PULL1_REG     			(gpio_base+0x11C)
+#define PI_CFG0_REG         		(gpio_base+0x120)
+#define PI_CFG1_REG           	    (gpio_base+0x124)
+#define PI_CFG2_REG         		(gpio_base+0x128)
+#define PI_CFG3_REG         		(gpio_base+0x12C)
+#define PI_DAT_REG         		    (gpio_base+0x130)
+#define PI_DRV0_REG        		    (gpio_base+0x134)
+#define PI_DRV1_REG        		    (gpio_base+0x138)
+#define PI_PULL0_REG     			(gpio_base+0x13C)
+#define PI_PULL1_REG     			(gpio_base+0x140)
+
+//SRAMC register
+#define SRAMC_BASE              0x01c00000
+#define SRAMC_CFG_REG           (SRAMC_BASE+0x00)
+#define SRAMC_ITCM_AWC_REG      (SRAMC_BASE+0xb4)
+
+static const void __iomem* gpio_base = (void __iomem*)SW_VA_PORTC_IO_BASE;;
+
+static inline void aw_gpio_trigger_single(void)
+{
+	u32 rval;
+    u32 backup;
+    void __iomem* cfg_base  = (void __iomem*)PI_CFG0_REG;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //config gpio to output
+    backup = readl(cfg_base);
+    rval = readl(cfg_base);
+    rval &= ~(0x7 << 12);
+    rval |= 1 << 12;
+    writel(rval, cfg_base);
+
+    rval = readl(data_base);
+ 	rval |= 1 << 3;
+    writel(rval, data_base);
+	rval &= ~(1 << 3);
+	writel(rval, data_base);
+	rval |= 1 << 3;
+	writel(rval, data_base);
+
+    //restore pio config
+    writel(backup, cfg_base);
+}
+
+static inline void aw_gpio_trigger_single1(void)
+{
+	u32 rval;
+    u32 backup;
+    void __iomem* cfg_base  = (void __iomem*)PI_CFG0_REG;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //config gpio to output
+    backup = readl(cfg_base);
+    rval = readl(cfg_base);
+    rval &= ~(0x7 << 8);
+    rval |= 1 << 8;
+    writel(rval, cfg_base);
+
+    rval = readl(data_base);
+ 	rval |= 1 << 2;
+    writel(rval, data_base);
+	rval &= ~(1 << 2);
+	writel(rval, data_base);
+	rval |= 1 << 2;
+	writel(rval, data_base);
+
+    //restore pio config
+    writel(backup, cfg_base);
+}
+
+static inline void aw_gpio_cfg_pi1(void)
+{
+	u32 rval;
+    void __iomem* cfg_base  = (void __iomem*)PI_CFG0_REG;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //pull high data
+    rval = readl(data_base);
+ 	rval |= 0xf;
+    writel(rval, data_base);
+
+    rval = readl(cfg_base);
+    rval &= ~(0x7777);
+    rval |= 0x1111;
+    writel(rval, cfg_base);
+}
+
+static inline void aw_gpio_one_pulse_on_pi0(void)
+{
+	u32 rval;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //pull low data
+    rval = readl(data_base);
+	rval &= ~(1 << 0);
+	writel(rval, data_base);
+
+    //pull high data
+ 	rval |= 1 << 0;
+    writel(rval, data_base);
+}
+
+static inline void aw_gpio_one_pulse_on_pi1(void)
+{
+	u32 rval;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //pull low data
+    rval = readl(data_base);
+	rval &= ~(1 << 1);
+	writel(rval, data_base);
+
+    //pull high data
+ 	rval |= 1 << 1;
+    writel(rval, data_base);
+}
+
+static inline void aw_gpio_one_pulse_on_pi2(void)
+{
+	u32 rval;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //pull low data
+    rval = readl(data_base);
+	rval &= ~(1 << 2);
+	writel(rval, data_base);
+
+    //pull high data
+ 	rval |= 1 << 2;
+    writel(rval, data_base);
+}
+
+static inline void aw_gpio_one_pulse_on_pi3(void)
+{
+	u32 rval;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //pull low data
+    rval = readl(data_base);
+	rval &= ~(1 << 3);
+	writel(rval, data_base);
+
+    //pull high data
+ 	rval |= 1 << 3;
+    writel(rval, data_base);
+}
+
+static inline void aw_gpio_trigger_single2(void)
+{
+	u32 rval;
+    u32 backup;
+    void __iomem* cfg_base  = (void __iomem*)PI_CFG0_REG;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //config gpio to output
+    backup = readl(cfg_base);
+    rval = readl(cfg_base);
+    rval &= ~(0x7 << 4);
+    rval |= 1 << 4;
+    writel(rval, cfg_base);
+
+    rval = readl(data_base);
+ 	rval |= 1 << 1;
+    writel(rval, data_base);
+	rval &= ~(1 << 1);
+	writel(rval, data_base);
+	rval |= 1 << 1;
+	writel(rval, data_base);
+
+    //restore pio config
+    writel(backup, cfg_base);
+}
+
+static inline void aw_gpio_trigger_single3(void)
+{
+	u32 rval;
+    u32 backup;
+    void __iomem* cfg_base  = (void __iomem*)PI_CFG0_REG;
+    void __iomem* data_base = (void __iomem*)PI_DAT_REG;
+
+    //config gpio to output
+    backup = readl(cfg_base);
+    rval = readl(cfg_base);
+    rval &= ~(0x7 << 0);
+    rval |= 1 << 0;
+    writel(rval, cfg_base);
+
+    rval = readl(data_base);
+ 	rval |= 1 << 0;
+    writel(rval, data_base);
+	rval &= ~(1 << 0);
+	writel(rval, data_base);
+	rval |= 1 << 0;
+	writel(rval, data_base);
+
+    //restore pio config
+    writel(backup, cfg_base);
+}
+
+static inline void aw_gpio_trigger_by_pf4(void)
+{
+	u32 rval;
+    u32 backup;
+    void __iomem* cfg_base  = (void __iomem*)PF_CFG0_REG;
+    void __iomem* data_base = (void __iomem*)PF_DAT_REG;
+
+    //config gpio to output
+    backup = readl(cfg_base);
+    rval = readl(cfg_base);
+    rval &= ~(0x7 << 16);
+    rval |= 1 << 16;
+    writel(rval, cfg_base);
+
+    rval = readl(data_base);
+ 	rval |= 1 << 4;
+    writel(rval, data_base);
+	rval &= ~(1 << 4);
+	writel(rval, data_base);
+	rval |= 1 << 4;
+	writel(rval, data_base);
+
+    //restore pio config
+    writel(backup, cfg_base);
+}
+
+static inline void uart_send_char(char c)
+{
+    while (!(readl(SW_VA_UART0_IO_BASE + 0x7c) &  (1<<1)));
+	writel(c, SW_VA_UART0_IO_BASE);
+}
+
+#endif
+
