diff --git a/drivers/Kconfig b/drivers/Kconfig
index d236aef..715f0ba 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -44,6 +44,7 @@ source "drivers/isdn/Kconfig"
 
 source "drivers/input/Kconfig"
 
+source "drivers/gsensor/Kconfig"
 source "drivers/char/Kconfig"
 
 source "drivers/i2c/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 95952c8..d18aab6 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -74,10 +74,11 @@ obj-$(CONFIG_USB_OTG_UTILS)	+= usb/
 obj-$(CONFIG_USB)		+= usb/
 obj-$(CONFIG_PCI)		+= usb/
 obj-$(CONFIG_USB_GADGET)	+= usb/
 obj-$(CONFIG_USB_SW_SUNXI_USB) += usb/sunxi_usb/
 obj-$(CONFIG_SERIO)		+= input/serio/
 obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
+obj-$(CONFIG_GSENSOR)		+= gsensor/
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
 obj-y				+= i2c/ media/
diff --git a/drivers/gsensor/Kconfig b/drivers/gsensor/Kconfig
new file mode 100644
index 0000000..cbb4b81
--- /dev/null
+++ b/drivers/gsensor/Kconfig
@@ -0,0 +1,47 @@
+#
+# I2C gsensor chip drivers configuration
+#
+
+menuconfig GSENSOR 
+	bool "Gsensor support"
+
+if GSENSOR
+
+config SENSORS_BMA250
+	tristate "BMA250 acceleration sensor support"
+	depends on I2C
+	help
+	  If you say yes here you get support for Bosch Sensortec's 
+	  acceleration sensors BMA250.
+
+config MEMSIC_ECOMPASS
+	tristate "MEMSIC eCompass Driver Support"
+	depends on I2C
+	help
+	  If you say yes here you get support for the MEMSIC eCompass
+
+config SENSORS_MXC622X
+	tristate "MEMSIC Accelerometer Sensor MXC622X Driver Support"
+	depends on I2C && MEMSIC_ECOMPASS
+	help
+	  If you say yes here you get support for the MEMSIC accelerometer sensor
+
+
+###### not supported yet ######
+if 0
+config SENSORS_MXC6202X
+	tristate "MEMSIC Accelerometer Sensor MXC6202X Driver Support"
+	depends on I2C
+	help
+	  If you say yes here you get support for the MEMSIC accelerometer sensor
+
+config SENSORS_MMC31XX
+	tristate "MEMSIC Magnetic Sensor MMC31XX Driver Support"
+	depends on I2C
+	help
+	  If you say yes here you get support for the MEMSIC magnateic sensor
+endif
+###### not supported yet ########
+
+
+endif
diff --git a/drivers/gsensor/Makefile b/drivers/gsensor/Makefile
new file mode 100644
index 0000000..801a910
--- /dev/null
+++ b/drivers/gsensor/Makefile
@@ -0,0 +1,14 @@
+#
+# Makefile for I2C gsensor chip drivers.
+#
+
+obj-$(CONFIG_MEMSIC_ECOMPASS)	+= mecs.o
+obj-$(CONFIG_SENSORS_MXC6202X)	+= mxc6202x.o
+obj-$(CONFIG_SENSORS_MXC622X)	+= mxc622x.o
+obj-$(CONFIG_SENSORS_MMC31XX)	+= mmc31xx.o
+
+obj-$(CONFIG_SENSORS_BMA250)		+= bma250.o
+
+ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff --git a/drivers/gsensor/bma250.c b/drivers/gsensor/bma250.c
new file mode 100644
index 0000000..d0938c5
--- /dev/null
+++ b/drivers/gsensor/bma250.c
@@ -0,0 +1,1047 @@
+/*  Date: 2011/4/8 11:00:00
+ *  Revision: 2.5
+ */
+
+/*
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+
+ * (C) Copyright 2011 Bosch Sensortec GmbH
+ * All Rights Reserved
+ */
+
+
+/* file BMA250.c
+   brief This file contains all function implementations for the BMA250 in linux
+
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+
+//#define BMA250_DEBUG
+
+#ifdef BMA250_DEBUG
+#define bma_dbg(x...)	printk(x)
+#else
+#define bma_dbg(x...)
+#endif
+
+#define SENSOR_NAME 			"bma250"
+#define GRAVITY_EARTH                   9806550
+#define ABSMIN_2G                       (-GRAVITY_EARTH * 2)
+#define ABSMAX_2G                       (GRAVITY_EARTH * 2)
+#define SLOPE_THRESHOLD_VALUE 		32
+#define SLOPE_DURATION_VALUE 		1
+#define INTERRUPT_LATCH_MODE 		13
+#define INTERRUPT_ENABLE 		1
+#define INTERRUPT_DISABLE 		0
+#define MAP_SLOPE_INTERRUPT 		2
+#define SLOPE_X_INDEX 			5
+#define SLOPE_Y_INDEX 			6
+#define SLOPE_Z_INDEX 			7
+#define BMA250_MAX_DELAY		200
+#define BMA150_CHIP_ID			2
+#define BMA250_CHIP_ID			3
+#define BMA250_RANGE_SET		0
+#define BMA250_BW_SET			4
+
+
+/*
+ *
+ *      register definitions
+ *
+ */
+
+#define BMA250_CHIP_ID_REG                      0x00
+#define BMA250_VERSION_REG                      0x01
+#define BMA250_X_AXIS_LSB_REG                   0x02
+#define BMA250_X_AXIS_MSB_REG                   0x03
+#define BMA250_Y_AXIS_LSB_REG                   0x04
+#define BMA250_Y_AXIS_MSB_REG                   0x05
+#define BMA250_Z_AXIS_LSB_REG                   0x06
+#define BMA250_Z_AXIS_MSB_REG                   0x07
+#define BMA250_TEMP_RD_REG                      0x08
+#define BMA250_STATUS1_REG                      0x09
+#define BMA250_STATUS2_REG                      0x0A
+#define BMA250_STATUS_TAP_SLOPE_REG             0x0B
+#define BMA250_STATUS_ORIENT_HIGH_REG           0x0C
+#define BMA250_RANGE_SEL_REG                    0x0F
+#define BMA250_BW_SEL_REG                       0x10
+#define BMA250_MODE_CTRL_REG                    0x11
+#define BMA250_LOW_NOISE_CTRL_REG               0x12
+#define BMA250_DATA_CTRL_REG                    0x13
+#define BMA250_RESET_REG                        0x14
+#define BMA250_INT_ENABLE1_REG                  0x16
+#define BMA250_INT_ENABLE2_REG                  0x17
+#define BMA250_INT1_PAD_SEL_REG                 0x19
+#define BMA250_INT_DATA_SEL_REG                 0x1A
+#define BMA250_INT2_PAD_SEL_REG                 0x1B
+#define BMA250_INT_SRC_REG                      0x1E
+#define BMA250_INT_SET_REG                      0x20
+#define BMA250_INT_CTRL_REG                     0x21
+#define BMA250_LOW_DURN_REG                     0x22
+#define BMA250_LOW_THRES_REG                    0x23
+#define BMA250_LOW_HIGH_HYST_REG                0x24
+#define BMA250_HIGH_DURN_REG                    0x25
+#define BMA250_HIGH_THRES_REG                   0x26
+#define BMA250_SLOPE_DURN_REG                   0x27
+#define BMA250_SLOPE_THRES_REG                  0x28
+#define BMA250_TAP_PARAM_REG                    0x2A
+#define BMA250_TAP_THRES_REG                    0x2B
+#define BMA250_ORIENT_PARAM_REG                 0x2C
+#define BMA250_THETA_BLOCK_REG                  0x2D
+#define BMA250_THETA_FLAT_REG                   0x2E
+#define BMA250_FLAT_HOLD_TIME_REG               0x2F
+#define BMA250_STATUS_LOW_POWER_REG             0x31
+#define BMA250_SELF_TEST_REG                    0x32
+#define BMA250_EEPROM_CTRL_REG                  0x33
+#define BMA250_SERIAL_CTRL_REG                  0x34
+#define BMA250_CTRL_UNLOCK_REG                  0x35
+#define BMA250_OFFSET_CTRL_REG                  0x36
+#define BMA250_OFFSET_PARAMS_REG                0x37
+#define BMA250_OFFSET_FILT_X_REG                0x38
+#define BMA250_OFFSET_FILT_Y_REG                0x39
+#define BMA250_OFFSET_FILT_Z_REG                0x3A
+#define BMA250_OFFSET_UNFILT_X_REG              0x3B
+#define BMA250_OFFSET_UNFILT_Y_REG              0x3C
+#define BMA250_OFFSET_UNFILT_Z_REG              0x3D
+#define BMA250_SPARE_0_REG                      0x3E
+#define BMA250_SPARE_1_REG                      0x3F
+
+
+
+
+#define BMA250_ACC_X_LSB__POS           6
+#define BMA250_ACC_X_LSB__LEN           2
+#define BMA250_ACC_X_LSB__MSK           0xC0
+#define BMA250_ACC_X_LSB__REG           BMA250_X_AXIS_LSB_REG
+
+#define BMA250_ACC_X_MSB__POS           0
+#define BMA250_ACC_X_MSB__LEN           8
+#define BMA250_ACC_X_MSB__MSK           0xFF
+#define BMA250_ACC_X_MSB__REG           BMA250_X_AXIS_MSB_REG
+
+#define BMA250_ACC_Y_LSB__POS           6
+#define BMA250_ACC_Y_LSB__LEN           2
+#define BMA250_ACC_Y_LSB__MSK           0xC0
+#define BMA250_ACC_Y_LSB__REG           BMA250_Y_AXIS_LSB_REG
+
+#define BMA250_ACC_Y_MSB__POS           0
+#define BMA250_ACC_Y_MSB__LEN           8
+#define BMA250_ACC_Y_MSB__MSK           0xFF
+#define BMA250_ACC_Y_MSB__REG           BMA250_Y_AXIS_MSB_REG
+
+#define BMA250_ACC_Z_LSB__POS           6
+#define BMA250_ACC_Z_LSB__LEN           2
+#define BMA250_ACC_Z_LSB__MSK           0xC0
+#define BMA250_ACC_Z_LSB__REG           BMA250_Z_AXIS_LSB_REG
+
+#define BMA250_ACC_Z_MSB__POS           0
+#define BMA250_ACC_Z_MSB__LEN           8
+#define BMA250_ACC_Z_MSB__MSK           0xFF
+#define BMA250_ACC_Z_MSB__REG           BMA250_Z_AXIS_MSB_REG
+
+#define BMA250_RANGE_SEL__POS             0
+#define BMA250_RANGE_SEL__LEN             4
+#define BMA250_RANGE_SEL__MSK             0x0F
+#define BMA250_RANGE_SEL__REG             BMA250_RANGE_SEL_REG
+
+#define BMA250_BANDWIDTH__POS             0
+#define BMA250_BANDWIDTH__LEN             5
+#define BMA250_BANDWIDTH__MSK             0x1F
+#define BMA250_BANDWIDTH__REG             BMA250_BW_SEL_REG
+
+#define BMA250_EN_LOW_POWER__POS          6
+#define BMA250_EN_LOW_POWER__LEN          1
+#define BMA250_EN_LOW_POWER__MSK          0x40
+#define BMA250_EN_LOW_POWER__REG          BMA250_MODE_CTRL_REG
+
+#define BMA250_EN_SUSPEND__POS            7
+#define BMA250_EN_SUSPEND__LEN            1
+#define BMA250_EN_SUSPEND__MSK            0x80
+#define BMA250_EN_SUSPEND__REG            BMA250_MODE_CTRL_REG
+
+#define BMA250_GET_BITSLICE(regvar, bitname)\
+			((regvar & bitname##__MSK) >> bitname##__POS)
+
+
+#define BMA250_SET_BITSLICE(regvar, bitname, val)\
+	((regvar & ~bitname##__MSK) | ((val<<bitname##__POS)&bitname##__MSK))
+
+
+/* range and bandwidth */
+
+#define BMA250_RANGE_2G                 0
+#define BMA250_RANGE_4G                 1
+#define BMA250_RANGE_8G                 2
+#define BMA250_RANGE_16G                3
+
+
+#define BMA250_BW_7_81HZ        0x08
+#define BMA250_BW_15_63HZ       0x09
+#define BMA250_BW_31_25HZ       0x0A
+#define BMA250_BW_62_50HZ       0x0B
+#define BMA250_BW_125HZ         0x0C
+#define BMA250_BW_250HZ         0x0D
+#define BMA250_BW_500HZ         0x0E
+#define BMA250_BW_1000HZ        0x0F
+
+/* mode settings */
+
+#define BMA250_MODE_NORMAL      0
+#define BMA250_MODE_LOWPOWER    1
+#define BMA250_MODE_SUSPEND     2
+
+
+
+struct bma250acc{
+	s16	x,
+		y,
+		z;
+} ;
+
+struct bma250_data {
+	struct i2c_client *bma250_client;
+	atomic_t delay;
+	atomic_t enable;
+	unsigned char mode;
+	struct input_dev *input;
+	struct bma250acc value;
+	struct mutex value_mutex;
+	struct mutex enable_mutex;
+	struct mutex mode_mutex;
+	struct delayed_work work;
+	struct work_struct irq_work;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+};
+
+/* Addresses to scan */
+static union{
+	unsigned short dirty_addr_buf[2];
+	const unsigned short normal_i2c[2];
+}u_i2c_addr = {{0x00},};
+static __u32 twi_id = 0;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma250_early_suspend(struct early_suspend *h);
+static void bma250_late_resume(struct early_suspend *h);
+#endif
+
+/**
+ * gsensor_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int gsensor_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int device_used = -1;
+	__u32 twi_addr = 0;
+	char name[I2C_NAME_SIZE];
+	script_parser_value_type_t type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+		
+	printk("========%s===================\n", __func__);
+	 
+	if(SCRIPT_PARSER_OK != (ret = script_parser_fetch("gsensor_para", "gsensor_used", &device_used, 1))){
+	                pr_err("%s: script_parser_fetch err.ret = %d. \n", __func__, ret);
+	                goto script_parser_fetch_err;
+	}
+	if(1 == device_used){
+		if(SCRIPT_PARSER_OK != script_parser_fetch_ex("gsensor_para", "gsensor_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+			pr_err("%s: line: %d script_parser_fetch err. \n", __func__, __LINE__);
+			goto script_parser_fetch_err;
+		}
+		if(strcmp(SENSOR_NAME, name)){
+			pr_err("%s: name %s does not match SENSOR_NAME. \n", __func__, name);
+			pr_err(SENSOR_NAME);
+			//ret = 1;
+			return ret;
+		}
+		if(SCRIPT_PARSER_OK != script_parser_fetch("gsensor_para", "gsensor_twi_addr", &twi_addr, sizeof(twi_addr)/sizeof(__u32))){
+			pr_err("%s: line: %d: script_parser_fetch err. \n", name, __LINE__);
+			goto script_parser_fetch_err;
+		}
+		u_i2c_addr.dirty_addr_buf[0] = twi_addr;
+		u_i2c_addr.dirty_addr_buf[1] = I2C_CLIENT_END;
+		printk("%s: after: gsensor_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", \
+			__func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+
+		if(SCRIPT_PARSER_OK != script_parser_fetch("gsensor_para", "gsensor_twi_id", &twi_id, 1)){
+			pr_err("%s: script_parser_fetch err. \n", name);
+			goto script_parser_fetch_err;
+		}
+		printk("%s: twi_id is %d. \n", __func__, twi_id);
+		
+		ret = 0;
+		
+	}else{
+		pr_err("%s: gsensor_unused. \n",  __func__);
+		ret = -1;
+	}
+
+	return ret;
+
+script_parser_fetch_err:
+	pr_notice("=========script_parser_fetch_err============\n");
+	return ret;
+
+}
+
+/**
+ * gsensor_detect - Device detection callback for automatic device creation
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int gsensor_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if(twi_id == adapter->nr){
+		pr_info("%s: Detected chip %s at adapter %d, address 0x%02x\n",
+			 __func__, SENSOR_NAME, i2c_adapter_id(adapter), client->addr);
+
+		strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+		return 0;
+	}else{
+		return -ENODEV;
+	}
+}
+
+static int bma250_smbus_read_byte(struct i2c_client *client,
+		unsigned char reg_addr, unsigned char *data)
+{
+	s32 dummy;
+	dummy = i2c_smbus_read_byte_data(client, reg_addr);
+	if (dummy < 0)
+		return -1;
+	*data = dummy & 0x000000ff;
+
+	return 0;
+}
+
+static int bma250_smbus_write_byte(struct i2c_client *client,
+		unsigned char reg_addr, unsigned char *data)
+{
+	s32 dummy;
+	dummy = i2c_smbus_write_byte_data(client, reg_addr, *data);
+	if (dummy < 0)
+		return -1;
+	return 0;
+}
+
+static int bma250_smbus_read_byte_block(struct i2c_client *client,
+		unsigned char reg_addr, unsigned char *data, unsigned char len)
+{
+	s32 dummy;
+	dummy = i2c_smbus_read_i2c_block_data(client, reg_addr, len, data);
+	if (dummy < 0)
+		return -1;
+	return 0;
+}
+
+static int bma250_set_mode(struct i2c_client *client, unsigned char Mode)
+{
+	int comres = 0;
+	unsigned char data1 = '\0';
+
+	if (client == NULL) {
+		comres = -1;
+	} else{
+		if (Mode < 3) {
+			comres = bma250_smbus_read_byte(client,
+					BMA250_EN_LOW_POWER__REG, &data1);
+			switch (Mode) {
+			case BMA250_MODE_NORMAL:
+				data1  = BMA250_SET_BITSLICE(data1,
+					BMA250_EN_LOW_POWER, 0);
+				data1  = BMA250_SET_BITSLICE(data1,
+					BMA250_EN_SUSPEND, 0);
+				break;
+			case BMA250_MODE_LOWPOWER:
+				data1  = BMA250_SET_BITSLICE(data1,
+					BMA250_EN_LOW_POWER, 1);
+				data1  = BMA250_SET_BITSLICE(data1,
+					BMA250_EN_SUSPEND, 0);
+				break;
+			case BMA250_MODE_SUSPEND:
+				data1  = BMA250_SET_BITSLICE(data1,
+					BMA250_EN_LOW_POWER, 0);
+				data1  = BMA250_SET_BITSLICE(data1,
+					BMA250_EN_SUSPEND, 1);
+				break;
+			default:
+				break;
+			}
+
+			comres += bma250_smbus_write_byte(client,
+					BMA250_EN_LOW_POWER__REG, &data1);
+		} else{
+			comres = -1;
+		}
+	}
+
+	return comres;
+}
+
+static int bma250_get_mode(struct i2c_client *client, unsigned char *Mode)
+{
+	int comres = 0;
+
+	if (client == NULL) {
+		comres = -1;
+	} else{
+		comres = bma250_smbus_read_byte(client,
+				BMA250_EN_LOW_POWER__REG, Mode);
+		*Mode  = (*Mode) >> 6;
+	}
+
+	return comres;
+}
+
+static int bma250_set_range(struct i2c_client *client, unsigned char Range)
+{
+	int comres = 0;
+	unsigned char data1 = '\0';
+
+	if (client == NULL) {
+		comres = -1;
+	} else{
+		if (Range < 4) {
+			comres = bma250_smbus_read_byte(client,
+					BMA250_RANGE_SEL_REG, &data1);
+			switch (Range) {
+			case 0:
+				data1  = BMA250_SET_BITSLICE(data1,
+						BMA250_RANGE_SEL, 0);
+				break;
+			case 1:
+				data1  = BMA250_SET_BITSLICE(data1,
+						BMA250_RANGE_SEL, 5);
+				break;
+			case 2:
+				data1  = BMA250_SET_BITSLICE(data1,
+						BMA250_RANGE_SEL, 8);
+				break;
+			case 3:
+				data1  = BMA250_SET_BITSLICE(data1,
+						BMA250_RANGE_SEL, 12);
+				break;
+			default:
+					break;
+			}
+			comres += bma250_smbus_write_byte(client,
+					BMA250_RANGE_SEL_REG, &data1);
+		} else{
+			comres = -1;
+		}
+	}
+
+	return comres;
+}
+
+static int bma250_get_range(struct i2c_client *client, unsigned char *Range)
+{
+	int comres = 0;
+	unsigned char data;
+
+	if (client == NULL) {
+		comres = -1;
+	} else{
+		comres = bma250_smbus_read_byte(client, BMA250_RANGE_SEL__REG,
+				&data);
+		data = BMA250_GET_BITSLICE(data, BMA250_RANGE_SEL);
+		*Range = data;
+	}
+
+	return comres;
+}
+
+
+static int bma250_set_bandwidth(struct i2c_client *client, unsigned char BW)
+{
+	int comres = 0;
+	unsigned char data = '\0';
+	int Bandwidth = 0;
+
+	if (client == NULL) {
+		comres = -1;
+	} else{
+		if (BW < 8) {
+			switch (BW) {
+			case 0:
+				Bandwidth = BMA250_BW_7_81HZ;
+				break;
+			case 1:
+				Bandwidth = BMA250_BW_15_63HZ;
+				break;
+			case 2:
+				Bandwidth = BMA250_BW_31_25HZ;
+				break;
+			case 3:
+				Bandwidth = BMA250_BW_62_50HZ;
+				break;
+			case 4:
+				Bandwidth = BMA250_BW_125HZ;
+				break;
+			case 5:
+				Bandwidth = BMA250_BW_250HZ;
+				break;
+			case 6:
+				Bandwidth = BMA250_BW_500HZ;
+				break;
+			case 7:
+				Bandwidth = BMA250_BW_1000HZ;
+				break;
+			default:
+					break;
+			}
+			comres = bma250_smbus_read_byte(client,
+					BMA250_BANDWIDTH__REG, &data);
+			data = BMA250_SET_BITSLICE(data, BMA250_BANDWIDTH,
+					Bandwidth);
+			comres += bma250_smbus_write_byte(client,
+					BMA250_BANDWIDTH__REG, &data);
+		} else{
+			comres = -1;
+		}
+	}
+
+	return comres;
+}
+
+static int bma250_get_bandwidth(struct i2c_client *client, unsigned char *BW)
+{
+	int comres = 0;
+	unsigned char data = '\0';
+
+	if (client == NULL) {
+		comres = -1;
+	} else{
+		comres = bma250_smbus_read_byte(client, BMA250_BANDWIDTH__REG,
+				&data);
+		data = BMA250_GET_BITSLICE(data, BMA250_BANDWIDTH);
+		if (data <= 8) {
+			*BW = 0;
+		} else{
+			if (data >= 0x0F)
+				*BW = 7;
+			else
+				*BW = data - 8;
+
+		}
+	}
+
+	return comres;
+}
+
+static int bma250_read_accel_xyz(struct i2c_client *client,
+							struct bma250acc *acc)
+{
+	int comres;
+	unsigned char data[6] = {0};
+	if (client == NULL) {
+		comres = -1;
+	} else{
+		comres = bma250_smbus_read_byte_block(client,
+				BMA250_ACC_X_LSB__REG, data, 6);
+
+		acc->x = BMA250_GET_BITSLICE(data[0], BMA250_ACC_X_LSB)
+			|(BMA250_GET_BITSLICE(data[1],
+				BMA250_ACC_X_MSB)<<BMA250_ACC_X_LSB__LEN);
+		acc->x = acc->x << (sizeof(short)*8-(BMA250_ACC_X_LSB__LEN
+					+ BMA250_ACC_X_MSB__LEN));
+		acc->x = acc->x >> (sizeof(short)*8-(BMA250_ACC_X_LSB__LEN
+					+ BMA250_ACC_X_MSB__LEN));
+		acc->y = BMA250_GET_BITSLICE(data[2], BMA250_ACC_Y_LSB)
+			| (BMA250_GET_BITSLICE(data[3],
+				BMA250_ACC_Y_MSB)<<BMA250_ACC_Y_LSB__LEN);
+		acc->y = acc->y << (sizeof(short)*8-(BMA250_ACC_Y_LSB__LEN
+					+ BMA250_ACC_Y_MSB__LEN));
+		acc->y = acc->y >> (sizeof(short)*8-(BMA250_ACC_Y_LSB__LEN
+					+ BMA250_ACC_Y_MSB__LEN));
+
+		acc->z = BMA250_GET_BITSLICE(data[4], BMA250_ACC_Z_LSB)
+			| (BMA250_GET_BITSLICE(data[5],
+				BMA250_ACC_Z_MSB)<<BMA250_ACC_Z_LSB__LEN);
+		acc->z = acc->z << (sizeof(short)*8-(BMA250_ACC_Z_LSB__LEN
+					+ BMA250_ACC_Z_MSB__LEN));
+		acc->z = acc->z >> (sizeof(short)*8-(BMA250_ACC_Z_LSB__LEN
+					+ BMA250_ACC_Z_MSB__LEN));
+	}
+
+	return comres;
+}
+
+static void bma250_work_func(struct work_struct *work)
+{
+	struct bma250_data *bma250 = container_of((struct delayed_work *)work,
+			struct bma250_data, work);
+	static struct bma250acc acc;
+	unsigned long delay = msecs_to_jiffies(atomic_read(&bma250->delay));
+
+	bma250_read_accel_xyz(bma250->bma250_client, &acc);
+	input_report_abs(bma250->input, ABS_X, acc.x);
+	input_report_abs(bma250->input, ABS_Y, acc.y);
+	input_report_abs(bma250->input, ABS_Z, acc.z);
+	bma_dbg("acc.x %d, acc.y %d, acc.z %d\n", acc.x, acc.y, acc.z);
+	input_sync(bma250->input);
+	mutex_lock(&bma250->value_mutex);
+	bma250->value = acc;
+	mutex_unlock(&bma250->value_mutex);
+	schedule_delayed_work(&bma250->work, delay);
+}
+
+static ssize_t bma250_range_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	if (bma250_get_range(bma250->bma250_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	bma_dbg("%d, %s\n", data, __FUNCTION__);
+	return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma250_range_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma250_set_range(bma250->bma250_client, (unsigned char) data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma250_bandwidth_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	if (bma250_get_bandwidth(bma250->bma250_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	bma_dbg("%d, %s\n", data, __FUNCTION__);
+	return sprintf(buf, "%d\n", data);
+
+}
+
+static ssize_t bma250_bandwidth_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma250_set_bandwidth(bma250->bma250_client,
+						 (unsigned char) data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t bma250_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned char data;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	if (bma250_get_mode(bma250->bma250_client, &data) < 0)
+		return sprintf(buf, "Read error\n");
+
+	bma_dbg("%d, %s\n", data, __FUNCTION__);
+	return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t bma250_mode_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (bma250_set_mode(bma250->bma250_client, (unsigned char) data) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+
+static ssize_t bma250_value_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct input_dev *input = to_input_dev(dev);
+	struct bma250_data *bma250 = input_get_drvdata(input);
+	struct bma250acc acc_value;
+
+	mutex_lock(&bma250->value_mutex);
+	acc_value = bma250->value;
+	mutex_unlock(&bma250->value_mutex);
+
+	bma_dbg("x=%d, y=%d, z=%d ,%s\n", acc_value.x, acc_value.y, acc_value.z, __FUNCTION__);
+	return sprintf(buf, "%d %d %d\n", acc_value.x, acc_value.y,
+			acc_value.z);
+}
+
+static ssize_t bma250_delay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	bma_dbg("%d, %s\n", atomic_read(&bma250->delay), __FUNCTION__);
+	return sprintf(buf, "%d\n", atomic_read(&bma250->delay));
+
+}
+
+static ssize_t bma250_delay_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if (data > BMA250_MAX_DELAY)
+		data = BMA250_MAX_DELAY;
+	atomic_set(&bma250->delay, (unsigned int) data);
+
+	return count;
+}
+
+
+static ssize_t bma250_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+
+	bma_dbg("%d, %s\n", atomic_read(&bma250->enable), __FUNCTION__);
+	return sprintf(buf, "%d\n", atomic_read(&bma250->enable));
+
+}
+
+static void bma250_set_enable(struct device *dev, int enable)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bma250_data *bma250 = i2c_get_clientdata(client);
+	int pre_enable = atomic_read(&bma250->enable);
+
+	mutex_lock(&bma250->enable_mutex);
+	if (enable) {
+		if (pre_enable ==0) {
+			bma250_set_mode(bma250->bma250_client, 
+							BMA250_MODE_NORMAL);
+			schedule_delayed_work(&bma250->work,
+				msecs_to_jiffies(atomic_read(&bma250->delay)));
+			atomic_set(&bma250->enable, 1);
+		}
+		
+	} else {
+		if (pre_enable ==1) {
+			bma250_set_mode(bma250->bma250_client, 
+							BMA250_MODE_SUSPEND);
+			cancel_delayed_work_sync(&bma250->work);
+			atomic_set(&bma250->enable, 0);
+		} 
+	}
+	mutex_unlock(&bma250->enable_mutex);
+	
+}
+
+static ssize_t bma250_enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned long data;
+	int error;
+
+	error = strict_strtoul(buf, 10, &data);
+	if (error)
+		return error;
+	if ((data == 0)||(data==1)) {
+		bma250_set_enable(dev,data);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(range, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma250_range_show, bma250_range_store);
+static DEVICE_ATTR(bandwidth, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma250_bandwidth_show, bma250_bandwidth_store);
+static DEVICE_ATTR(mode, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma250_mode_show, bma250_mode_store);
+static DEVICE_ATTR(value, S_IRUGO,
+		bma250_value_show, NULL);
+static DEVICE_ATTR(delay, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma250_delay_show, bma250_delay_store);
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR|S_IWGRP|S_IWOTH,
+		bma250_enable_show, bma250_enable_store);
+
+static struct attribute *bma250_attributes[] = {
+	&dev_attr_range.attr,
+	&dev_attr_bandwidth.attr,
+	&dev_attr_mode.attr,
+	&dev_attr_value.attr,
+	&dev_attr_delay.attr,
+	&dev_attr_enable.attr,
+	NULL
+};
+
+static struct attribute_group bma250_attribute_group = {
+	.attrs = bma250_attributes
+};
+
+static int bma250_input_init(struct bma250_data *bma250)
+{
+	struct input_dev *dev;
+	int err;
+
+	dev = input_allocate_device();
+	if (!dev)
+		return -ENOMEM;
+	dev->name = SENSOR_NAME;
+	dev->id.bustype = BUS_I2C;
+
+	input_set_capability(dev, EV_ABS, ABS_MISC);
+	input_set_abs_params(dev, ABS_X, ABSMIN_2G, ABSMAX_2G, 0, 0);
+	input_set_abs_params(dev, ABS_Y, ABSMIN_2G, ABSMAX_2G, 0, 0);
+	input_set_abs_params(dev, ABS_Z, ABSMIN_2G, ABSMAX_2G, 0, 0);
+	input_set_drvdata(dev, bma250);
+
+	err = input_register_device(dev);
+	if (err < 0) {
+		input_free_device(dev);
+		return err;
+	}
+	bma250->input = dev;
+
+	return 0;
+}
+
+static void bma250_input_delete(struct bma250_data *bma250)
+{
+	struct input_dev *dev = bma250->input;
+
+	input_unregister_device(dev);
+	input_free_device(dev);
+}
+
+static int bma250_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int err = 0;
+	int tempvalue;
+	struct bma250_data *data;
+
+	bma_dbg("bma250: probe\n");
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_INFO "i2c_check_functionality error\n");
+		goto exit;
+	}
+	data = kzalloc(sizeof(struct bma250_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	/* read chip id */
+	tempvalue = 0;
+	tempvalue = i2c_smbus_read_word_data(client, BMA250_CHIP_ID_REG);
+
+	if ((tempvalue&0x00FF) == BMA250_CHIP_ID) {
+		printk(KERN_INFO "Bosch Sensortec Device detected!\n" \
+				"BMA250 registered I2C driver!\n");
+	} else if ((tempvalue&0x00FF) == BMA150_CHIP_ID) {
+		printk(KERN_INFO "Bosch Sensortec Device detected!\n" \
+				"BMA150 registered I2C driver!\n");
+	}
+	else {
+		printk(KERN_INFO "Bosch Sensortec Device not found, \
+				i2c error %d \n", tempvalue);
+		err = -1;
+		goto kfree_exit;
+	}
+	i2c_set_clientdata(client, data);
+	data->bma250_client = client;
+	mutex_init(&data->value_mutex);
+	mutex_init(&data->mode_mutex);
+	mutex_init(&data->enable_mutex);
+	bma250_set_bandwidth(client, BMA250_BW_SET);
+	bma250_set_range(client, BMA250_RANGE_SET);
+
+	INIT_DELAYED_WORK(&data->work, bma250_work_func);
+	bma_dbg("bma: INIT_DELAYED_WORK\n");
+	atomic_set(&data->delay, BMA250_MAX_DELAY);
+	atomic_set(&data->enable, 0);
+	err = bma250_input_init(data);
+	if (err < 0)
+	{
+		bma_dbg("bma: bma250_input_init err\n");
+		goto kfree_exit;
+	}
+	err = sysfs_create_group(&data->input->dev.kobj,
+						 &bma250_attribute_group);
+	if (err < 0)
+	{
+		bma_dbg("bma: sysfs_create_group err\n");
+		goto error_sysfs;
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	data->early_suspend.suspend = bma250_early_suspend;
+	data->early_suspend.resume = bma250_late_resume;
+	register_early_suspend(&data->early_suspend);
+#endif
+	return 0;
+
+error_sysfs:
+	bma250_input_delete(data);
+
+kfree_exit:
+	kfree(data);
+exit:
+	return err;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void bma250_early_suspend(struct early_suspend *h)
+{
+	struct bma250_data *data =
+		container_of(h, struct bma250_data, early_suspend);	
+
+	mutex_lock(&data->enable_mutex);
+	if (atomic_read(&data->enable)==1) {
+		bma250_set_mode(data->bma250_client, BMA250_MODE_SUSPEND);
+		cancel_delayed_work_sync(&data->work);
+	}
+	mutex_unlock(&data->enable_mutex);
+}
+
+
+static void bma250_late_resume(struct early_suspend *h)
+{
+	struct bma250_data *data =
+		container_of(h, struct bma250_data, early_suspend);
+
+	mutex_lock(&data->enable_mutex);
+	if (atomic_read(&data->enable)==1) {
+		bma250_set_mode(data->bma250_client, BMA250_MODE_NORMAL);
+		schedule_delayed_work(&data->work,
+			msecs_to_jiffies(atomic_read(&data->delay)));
+	}
+	mutex_unlock(&data->enable_mutex);
+}
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+static int bma250_remove(struct i2c_client *client)
+{
+	struct bma250_data *data = i2c_get_clientdata(client);
+
+	bma250_set_enable(&client->dev, 0);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&data->early_suspend);
+#endif
+	sysfs_remove_group(&data->input->dev.kobj, &bma250_attribute_group);
+	bma250_input_delete(data);
+	kfree(data);
+	return 0;
+}
+
+
+static const struct i2c_device_id bma250_id[] = {
+	{ SENSOR_NAME, 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, bma250_id);
+
+static struct i2c_driver bma250_driver = {
+	.class = I2C_CLASS_HWMON,
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= SENSOR_NAME,
+	},
+	.id_table	= bma250_id,
+	.probe		= bma250_probe,
+	.remove		= bma250_remove,
+	.address_list	= u_i2c_addr.normal_i2c,
+};
+
+static int __init BMA250_init(void)
+{
+	int ret = -1;
+	bma_dbg("bma250: init\n");
+	
+	if(gsensor_fetch_sysconfig_para()){
+		printk("%s: err.\n", __func__);
+		return -1;
+	}
+
+	printk("%s: after fetch_sysconfig_para:  normal_i2c: 0x%hx. normal_i2c[1]: 0x%hx \n", \
+	__func__, u_i2c_addr.normal_i2c[0], u_i2c_addr.normal_i2c[1]);
+
+	bma250_driver.detect = gsensor_detect;
+	
+	ret = i2c_add_driver(&bma250_driver);
+
+	return ret;
+}
+
+static void __exit BMA250_exit(void)
+{
+	i2c_del_driver(&bma250_driver);
+}
+
+MODULE_AUTHOR("Albert Zhang <xu.zhang@bosch-sensortec.com>");
+MODULE_DESCRIPTION("BMA250 driver");
+MODULE_LICENSE("GPL");
+
+module_init(BMA250_init);
+module_exit(BMA250_exit);
+
diff --git a/drivers/gsensor/mecs.c b/drivers/gsensor/mecs.c
new file mode 100644
index 0000000..71ae2e8
--- /dev/null
+++ b/drivers/gsensor/mecs.c
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/freezer.h>
+#include <asm/uaccess.h>
+
+#include "mecs.h"
+
+#define DEBUG			1
+
+#define ECS_DATA_DEV_NAME	"ecompass_data"
+#define ECS_CTRL_DEV_NAME	"ecompass_ctrl"
+
+static int ecs_ctrl_open(struct inode *inode, struct file *file);
+static int ecs_ctrl_release(struct inode *inode, struct file *file);
+static long ecs_ctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
+static DECLARE_WAIT_QUEUE_HEAD(open_wq);
+
+static atomic_t	open_count;
+static atomic_t	open_flag;
+static atomic_t	reserve_open_flag;
+
+static atomic_t	a_flag;
+static atomic_t	m_flag;
+static atomic_t	o_flag;
+
+static short ecompass_delay = 0;
+
+
+static struct input_dev *ecs_data_device;
+
+static struct file_operations ecs_ctrl_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ecs_ctrl_open,
+	.release	= ecs_ctrl_release,
+	.unlocked_ioctl		= ecs_ctrl_ioctl,
+};
+
+static struct miscdevice ecs_ctrl_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = ECS_CTRL_DEV_NAME,
+	.fops = &ecs_ctrl_fops,
+};
+
+static int ecs_ctrl_open(struct inode *inode, struct file *file)
+{
+#if 1
+	atomic_set(&reserve_open_flag, 1);
+	atomic_set(&open_flag, 1);
+	atomic_set(&open_count, 1);
+	wake_up(&open_wq);
+
+	return 0;
+#else
+	int ret = -1;
+
+	if (atomic_cmpxchg(&open_count, 0, 1) == 0) {
+		if (atomic_cmpxchg(&open_flag, 0, 1) == 0) {
+			atomic_set(&reserve_open_flag, 1);
+			wake_up(&open_wq);
+			ret = 0;
+		}
+	}
+
+	return ret;
+#endif
+}
+
+static int ecs_ctrl_release(struct inode *inode, struct file *file)
+{
+	atomic_set(&reserve_open_flag, 0);
+	atomic_set(&open_flag, 0);
+	atomic_set(&open_count, 0);
+	wake_up(&open_wq);
+
+	return 0;
+}
+
+static long ecs_ctrl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void __user *pa = (void __user *)arg;
+	short flag;
+	short delay;
+	int parms[4];
+	int ypr[12];
+
+	switch (cmd) {
+	case ECOMPASS_IOC_SET_MODE:
+		break;
+	case ECOMPASS_IOC_SET_DELAY:
+		if (copy_from_user(&delay, pa, sizeof(delay)))
+			return -EFAULT;
+		ecompass_delay = delay;
+		break;
+	case ECOMPASS_IOC_GET_DELAY:
+		delay = ecompass_delay;
+		if (copy_to_user(pa, &delay, sizeof(delay)))
+			return -EFAULT;
+		break;
+
+	case ECOMPASS_IOC_SET_AFLAG:
+		if (copy_from_user(&flag, pa, sizeof(flag)))
+			return -EFAULT;
+		if (flag < 0 || flag > 1)
+			return -EINVAL;
+		atomic_set(&a_flag, flag);
+		break;
+	case ECOMPASS_IOC_GET_AFLAG:
+		flag = atomic_read(&a_flag);
+		if (copy_to_user(pa, &flag, sizeof(flag)))
+			return -EFAULT;
+		break;
+	case ECOMPASS_IOC_SET_MFLAG:
+		if (copy_from_user(&flag, pa, sizeof(flag)))
+			return -EFAULT;
+		if (flag < 0 || flag > 1)
+			return -EINVAL;
+		atomic_set(&m_flag, flag);
+		break;
+	case ECOMPASS_IOC_GET_MFLAG:
+		flag = atomic_read(&m_flag);
+		if (copy_to_user(pa, &flag, sizeof(flag)))
+			return -EFAULT;
+		break;
+	case ECOMPASS_IOC_SET_OFLAG:
+		if (copy_from_user(&flag, pa, sizeof(flag)))
+			return -EFAULT;
+		if (flag < 0 || flag > 1)
+			return -EINVAL;
+		atomic_set(&o_flag, flag);
+		break;
+	case ECOMPASS_IOC_GET_OFLAG:
+		flag = atomic_read(&o_flag);
+		if (copy_to_user(pa, &flag, sizeof(flag)))
+			return -EFAULT;
+		break;
+
+	case ECOMPASS_IOC_SET_APARMS:
+		if (copy_from_user(parms, pa, sizeof(parms)))
+			return -EFAULT;
+		/* acceleration x-axis */
+		input_set_abs_params(ecs_data_device, ABS_X, 
+			parms[0], parms[1], parms[2], parms[3]);
+		/* acceleration y-axis */
+		input_set_abs_params(ecs_data_device, ABS_Y, 
+			parms[0], parms[1], parms[2], parms[3]);
+		/* acceleration z-axis */
+		input_set_abs_params(ecs_data_device, ABS_Z, 
+			parms[0], parms[1], parms[2], parms[3]);
+		break;
+	case ECOMPASS_IOC_GET_APARMS:
+		break;
+	case ECOMPASS_IOC_SET_MPARMS:
+		if (copy_from_user(parms, pa, sizeof(parms)))
+			return -EFAULT;
+		/* magnetic raw x-axis */
+		input_set_abs_params(ecs_data_device, ABS_HAT0X, 
+			parms[0], parms[1], parms[2], parms[3]);
+		/* magnetic raw y-axis */
+		input_set_abs_params(ecs_data_device, ABS_HAT0Y, 
+			parms[0], parms[1], parms[2], parms[3]);
+		/* magnetic raw z-axis */
+		input_set_abs_params(ecs_data_device, ABS_BRAKE, 
+			parms[0], parms[1], parms[2], parms[3]);
+		break;
+	case ECOMPASS_IOC_GET_MPARMS:
+		break;
+	case ECOMPASS_IOC_SET_OPARMS_YAW:
+		if (copy_from_user(parms, pa, sizeof(parms)))
+			return -EFAULT;
+		/* orientation yaw */
+		input_set_abs_params(ecs_data_device, ABS_RX, 
+			parms[0], parms[1], parms[2], parms[3]);
+		break;
+	case ECOMPASS_IOC_GET_OPARMS_YAW:
+		break;
+	case ECOMPASS_IOC_SET_OPARMS_PITCH:
+		if (copy_from_user(parms, pa, sizeof(parms)))
+			return -EFAULT;
+		/* orientation pitch */
+		input_set_abs_params(ecs_data_device, ABS_RY, 
+			parms[0], parms[1], parms[2], parms[3]);
+		break;
+	case ECOMPASS_IOC_GET_OPARMS_PITCH:
+		break;
+	case ECOMPASS_IOC_SET_OPARMS_ROLL:
+		if (copy_from_user(parms, pa, sizeof(parms)))
+			return -EFAULT;
+		/* orientation roll */
+		input_set_abs_params(ecs_data_device, ABS_RZ, 
+			parms[0], parms[1], parms[2], parms[3]);
+		break;
+	case ECOMPASS_IOC_GET_OPARMS_ROLL:
+		break;
+
+	case ECOMPASS_IOC_SET_YPR:
+		if (copy_from_user(ypr, pa, sizeof(ypr)))
+			return -EFAULT;
+		/* Report acceleration sensor information */
+		if (atomic_read(&a_flag)) {
+			input_report_abs(ecs_data_device, ABS_X, ypr[0]);
+			input_report_abs(ecs_data_device, ABS_Y, ypr[1]);
+			input_report_abs(ecs_data_device, ABS_Z, ypr[2]);
+			input_report_abs(ecs_data_device, ABS_WHEEL, ypr[3]);
+			//printk(KERN_INFO"acc x:%d  y:%d z:%d\n", ypr[0], ypr[1], ypr[2]);
+		}
+
+		/* Report magnetic sensor information */
+		if (atomic_read(&m_flag)) {
+			input_report_abs(ecs_data_device, ABS_HAT0X, ypr[4]);
+			input_report_abs(ecs_data_device, ABS_HAT0Y, ypr[5]);
+			input_report_abs(ecs_data_device, ABS_BRAKE, ypr[6]);
+			input_report_abs(ecs_data_device, ABS_GAS, ypr[7]);
+			//printk(KERN_INFO"mag x:%d  y:%d z:%d\n", ypr[4], ypr[5], ypr[6]);
+		}
+
+		/* Report orientation information */
+		if (atomic_read(&o_flag)) {
+			input_report_abs(ecs_data_device, ABS_RX, ypr[8]);
+			input_report_abs(ecs_data_device, ABS_RY, ypr[9]);
+			input_report_abs(ecs_data_device, ABS_RZ, ypr[10]);
+			input_report_abs(ecs_data_device, ABS_RUDDER, ypr[11]);
+			//printk(KERN_INFO"ori x:%d  y:%d z:%d\n", ypr[8], ypr[9], ypr[10]);
+		}
+
+		input_sync(ecs_data_device);
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t ecs_ctrl_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "ecompass_ctrl");
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static DEVICE_ATTR(ecs_ctrl, S_IRUGO, ecs_ctrl_show, NULL);
+
+static int __init ecompass_init(void)
+{
+	int res = 0;
+
+	pr_info("ecompass driver: init\n");
+
+	ecs_data_device = input_allocate_device();
+	if (!ecs_data_device) {
+		res = -ENOMEM;
+		pr_err("%s: failed to allocate input device\n", __FUNCTION__);
+		goto out;
+	}
+
+	set_bit(EV_ABS, ecs_data_device->evbit);
+
+	/* 32768 == 1g, range -4g ~ +4g */
+	/* acceleration x-axis */
+	input_set_abs_params(ecs_data_device, ABS_X, 
+		-32768*4, 32768*4, 0, 0);
+	/* acceleration y-axis */
+	input_set_abs_params(ecs_data_device, ABS_Y, 
+		-32768*4, 32768*4, 0, 0);
+	/* acceleration z-axis */
+	input_set_abs_params(ecs_data_device, ABS_Z, 
+		-32768*4, 32768*4, 0, 0);
+
+	/* 32768 == 1gauss, range -4gauss ~ +4gauss */
+	/* magnetic raw x-axis */
+	input_set_abs_params(ecs_data_device, ABS_HAT0X, 
+		-32768*4, 32768*4, 0, 0);
+	/* magnetic raw y-axis */
+	input_set_abs_params(ecs_data_device, ABS_HAT0Y, 
+		-32768*4, 32768*4, 0, 0);
+	/* magnetic raw z-axis */
+	input_set_abs_params(ecs_data_device, ABS_BRAKE, 
+		-32768*4, 32768*4, 0, 0);
+
+	/* 65536 == 360degree */
+	/* orientation yaw, 0 ~ 360 */
+	input_set_abs_params(ecs_data_device, ABS_RX, 
+		0, 65536, 0, 0);
+	/* orientation pitch, -180 ~ 180 */
+	input_set_abs_params(ecs_data_device, ABS_RY, 
+		-65536/2, 65536/2, 0, 0);
+	/* orientation roll, -90 ~ 90 */
+	input_set_abs_params(ecs_data_device, ABS_RZ, 
+		-65536/4, 65536/4, 0, 0);
+
+	ecs_data_device->name = ECS_DATA_DEV_NAME;
+	res = input_register_device(ecs_data_device);
+	if (res) {
+		pr_err("%s: unable to register input device: %s\n",
+			__FUNCTION__, ecs_data_device->name);
+		goto out_free_input;
+	}
+
+	res = misc_register(&ecs_ctrl_device);
+	if (res) {
+		pr_err("%s: ecs_ctrl_device register failed\n", __FUNCTION__);
+		goto out_free_input;
+	}
+	res = device_create_file(ecs_ctrl_device.this_device, &dev_attr_ecs_ctrl);
+	if (res) {
+		pr_err("%s: device_create_file failed\n", __FUNCTION__);
+		goto out_deregister_misc;
+	}
+
+	return 0;
+
+out_deregister_misc:
+	misc_deregister(&ecs_ctrl_device);
+out_free_input:
+	input_free_device(ecs_data_device);
+out:
+	return res;
+}
+
+static void __exit ecompass_exit(void)
+{
+	pr_info("ecompass driver: exit\n");
+	device_remove_file(ecs_ctrl_device.this_device, &dev_attr_ecs_ctrl);
+	misc_deregister(&ecs_ctrl_device);
+	input_free_device(ecs_data_device);
+}
+
+module_init(ecompass_init);
+module_exit(ecompass_exit);
+
+MODULE_AUTHOR("Robbie Cao<hjcao@memsic.com>");
+MODULE_DESCRIPTION("MEMSIC eCompass Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/gsensor/mecs.h b/drivers/gsensor/mecs.h
new file mode 100644
index 0000000..3989039
--- /dev/null
+++ b/drivers/gsensor/mecs.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * Definitions for ECOMPASS magnetic sensor chip.
+ */
+#ifndef __ECOMPASS_H__
+#define __ECOMPASS_H__
+
+#include <linux/ioctl.h>
+
+/* Use 'e' as magic number */
+#define ECOMPASS_IOM			'e'
+
+/* IOCTLs for ECOMPASS device */
+#define ECOMPASS_IOC_SET_MODE		_IOW(ECOMPASS_IOM, 0x00, short)
+#define ECOMPASS_IOC_SET_DELAY		_IOW(ECOMPASS_IOM, 0x01, short)
+#define ECOMPASS_IOC_GET_DELAY		_IOR(ECOMPASS_IOM, 0x02, short)
+
+#define ECOMPASS_IOC_SET_AFLAG		_IOW(ECOMPASS_IOM, 0x10, short)
+#define ECOMPASS_IOC_GET_AFLAG		_IOR(ECOMPASS_IOM, 0x11, short)
+#define ECOMPASS_IOC_SET_MFLAG		_IOW(ECOMPASS_IOM, 0x12, short)
+#define ECOMPASS_IOC_GET_MFLAG		_IOR(ECOMPASS_IOM, 0x13, short)
+#define ECOMPASS_IOC_SET_OFLAG		_IOW(ECOMPASS_IOM, 0x14, short)
+#define ECOMPASS_IOC_GET_OFLAG		_IOR(ECOMPASS_IOM, 0x15, short)
+
+#define ECOMPASS_IOC_SET_APARMS		_IOW(ECOMPASS_IOM, 0x20, int[4])
+#define ECOMPASS_IOC_GET_APARMS		_IOR(ECOMPASS_IOM, 0x21, int[4])
+#define ECOMPASS_IOC_SET_MPARMS		_IOW(ECOMPASS_IOM, 0x22, int[4])
+#define ECOMPASS_IOC_GET_MPARMS		_IOR(ECOMPASS_IOM, 0x23, int[4])
+#define ECOMPASS_IOC_SET_OPARMS_YAW	_IOW(ECOMPASS_IOM, 0x24, int[4])
+#define ECOMPASS_IOC_GET_OPARMS_YAW	_IOR(ECOMPASS_IOM, 0x25, int[4])
+#define ECOMPASS_IOC_SET_OPARMS_PITCH	_IOW(ECOMPASS_IOM, 0x26, int[4])
+#define ECOMPASS_IOC_GET_OPARMS_PITCH	_IOR(ECOMPASS_IOM, 0x27, int[4])
+#define ECOMPASS_IOC_SET_OPARMS_ROLL	_IOW(ECOMPASS_IOM, 0x28, int[4])
+#define ECOMPASS_IOC_GET_OPARMS_ROLL	_IOR(ECOMPASS_IOM, 0x29, int[4])
+
+#define ECOMPASS_IOC_SET_YPR		_IOW(ECOMPASS_IOM, 0x30, int[12])
+
+
+#endif /* __ECOMPASS_H__ */
+
diff --git a/drivers/gsensor/mmc31xx.c b/drivers/gsensor/mmc31xx.c
new file mode 100644
index 0000000..52247af
--- /dev/null
+++ b/drivers/gsensor/mmc31xx.c
@@ -0,0 +1,401 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+
+#include <linux/mmc31xx.h>
+#include <linux/platform_device.h>
+
+#define DEBUG			0
+#define MAX_FAILURE_COUNT	3
+
+#define MMC31XX_DELAY_TM	10	/* ms */
+#define MMC31XX_DELAY_SET	10	/* ms */
+#define MMC31XX_DELAY_RST	10	/* ms */
+#define MMC31XX_DELAY_STDN	1	/* ms */
+
+#define MMC31XX_RETRY_COUNT	3
+#define MMC31XX_RESET_INTV	10
+
+#define MMC31XX_DEV_NAME	"mmc31xx"
+
+static unsigned short mmc31xx_force[] = {2, MMC31XX_I2C_ADDR, I2C_CLIENT_END, I2C_CLIENT_END};
+static const unsigned short *const mmc31xx_forces[] = { mmc31xx_force, NULL };
+static struct i2c_client_address_data mmc31xx_addr_data = { .forces = mmc31xx_forces,};
+
+static u32 read_idx = 0;
+
+static struct i2c_client *this_client;
+
+static int mmc31xx_i2c_rx_data(char *buf, int len)
+{
+	uint8_t i;
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= buf,
+		},
+		{
+			.addr	= this_client->addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+
+	for (i = 0; i < MMC31XX_RETRY_COUNT; i++) {
+		if (i2c_transfer(this_client->adapter, msgs, 2) >= 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (i >= MMC31XX_RETRY_COUNT) {
+		pr_err("%s: retry over %d\n", __FUNCTION__, MMC31XX_RETRY_COUNT);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int mmc31xx_i2c_tx_data(char *buf, int len)
+{
+	uint8_t i;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+	
+	for (i = 0; i < MMC31XX_RETRY_COUNT; i++) {
+		if (i2c_transfer(this_client->adapter, msg, 1) >= 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (i >= MMC31XX_RETRY_COUNT) {
+		pr_err("%s: retry over %d\n", __FUNCTION__, MMC31XX_RETRY_COUNT);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int mmc31xx_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static int mmc31xx_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int mmc31xx_ioctl(struct inode *inode, struct file *file, 
+	unsigned int cmd, unsigned long arg)
+{
+	void __user *pa = (void __user *)arg;
+	unsigned char data[16] = {0};
+	int vec[3] = {0};
+
+	switch (cmd) {
+	case MMC31XX_IOC_TM:
+		data[0] = MMC31XX_REG_CTRL;
+		data[1] = MMC31XX_CTRL_TM;
+		if (mmc31xx_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait TM done for coming data read */
+		msleep(MMC31XX_DELAY_TM);
+		break;
+	case MMC31XX_IOC_SET:
+		data[0] = MMC31XX_REG_CTRL;
+		data[1] = MMC31XX_CTRL_SET;
+		if (mmc31xx_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait external capacitor charging done for next SET/RESET */
+		msleep(MMC31XX_DELAY_SET);
+		break;
+	case MMC31XX_IOC_RESET:
+		data[0] = MMC31XX_REG_CTRL;
+		data[1] = MMC31XX_CTRL_RST;
+		if (mmc31xx_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait external capacitor charging done for next SET/RESET */
+		msleep(MMC31XX_DELAY_RST);
+		break;
+	case MMC31XX_IOC_READ:
+		data[0] = MMC31XX_REG_DATA;
+		if (mmc31xx_i2c_rx_data(data, 6) < 0) {
+			return -EFAULT;
+		}
+		vec[0] = data[0] << 8 | data[1];
+		vec[1] = data[2] << 8 | data[3];
+		vec[2] = data[4] << 8 | data[5];
+	#if DEBUG
+		printk("[X - %04x] [Y - %04x] [Z - %04x]\n", 
+			vec[0], vec[1], vec[2]);
+	#endif
+		if (copy_to_user(pa, vec, sizeof(vec))) {
+			return -EFAULT;
+		}
+		break;
+	case MMC31XX_IOC_READXYZ:
+		/* do RESET/SET every MMC31XX_RESET_INTV times read */
+		if (!(read_idx % MMC31XX_RESET_INTV)) {
+			/* RESET */
+			data[0] = MMC31XX_REG_CTRL;
+			data[1] = MMC31XX_CTRL_RST;
+			/* not check return value here, assume it always OK */
+			mmc31xx_i2c_tx_data(data, 2);
+			/* wait external capacitor charging done for next SET/RESET */
+			msleep(MMC31XX_DELAY_SET);
+			/* SET */
+			data[0] = MMC31XX_REG_CTRL;
+			data[1] = MMC31XX_CTRL_SET;
+			/* not check return value here, assume it always OK */
+			mmc31xx_i2c_tx_data(data, 2);
+			msleep(MMC31XX_DELAY_STDN);
+		}
+		/* send TM cmd before read */
+		data[0] = MMC31XX_REG_CTRL;
+		data[1] = MMC31XX_CTRL_TM;
+		/* not check return value here, assume it always OK */
+		mmc31xx_i2c_tx_data(data, 2);
+		/* wait TM done for coming data read */
+		msleep(MMC31XX_DELAY_TM);
+		/* read xyz raw data */
+		read_idx++;
+		data[0] = MMC31XX_REG_DATA;
+		if (mmc31xx_i2c_rx_data(data, 6) < 0) {
+			return -EFAULT;
+		}
+		vec[0] = data[0] << 8 | data[1];
+		vec[1] = data[2] << 8 | data[3];
+		vec[2] = data[4] << 8 | data[5];
+	#if DEBUG
+		printk("[X - %04x] [Y - %04x] [Z - %04x]\n", 
+			vec[0], vec[1], vec[2]);
+	#endif
+		if (copy_to_user(pa, vec, sizeof(vec))) {
+			return -EFAULT;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t mmc31xx_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "MMC31XX");
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static DEVICE_ATTR(mmc31xx, S_IRUGO, mmc31xx_show, NULL);
+
+static struct file_operations mmc31xx_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mmc31xx_open,
+	.release	= mmc31xx_release,
+	.ioctl		= mmc31xx_ioctl,
+};
+
+static struct miscdevice mmc31xx_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = MMC31XX_DEV_NAME,
+	.fops = &mmc31xx_fops,
+};
+
+static int mmc31xx_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	unsigned char data[16] = {0};
+	int res = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("%s: functionality check failed\n", __FUNCTION__);
+		res = -ENODEV;
+		goto out;
+	}
+	this_client = client;
+
+	res = misc_register(&mmc31xx_device);
+	if (res) {
+		pr_err("%s: mmc31xx_device register failed\n", __FUNCTION__);
+		goto out;
+	}
+	res = device_create_file(&client->dev, &dev_attr_mmc31xx);
+	if (res) {
+		pr_err("%s: device_create_file failed\n", __FUNCTION__);
+		goto out_deregister;
+	}
+
+	/* send ST cmd to mag sensor first of all */
+	data[0] = MMC31XX_REG_CTRL;
+	data[1] = MMC31XX_CTRL_SET;
+	if (mmc31xx_i2c_tx_data(data, 2) < 0) {
+		/* assume SET always success */
+	}
+	/* wait external capacitor charging done for next SET/RESET */
+	msleep(MMC31XX_DELAY_SET);
+
+	return 0;
+
+out_deregister:
+	misc_deregister(&mmc31xx_device);
+out:
+	return res;
+}
+
+static int mmc31xx_remove(struct i2c_client *client)
+{
+	device_remove_file(&client->dev, &dev_attr_mmc31xx);
+	misc_deregister(&mmc31xx_device);
+
+	return 0;
+}
+static int mmc31xx_detect(struct i2c_client *client, int kind, struct i2c_board_info *info) 
+{    
+	strcpy(info->type, MMC31XX_DEV_NAME);
+	return 0;
+}
+/*----------------------------------------------------------------------------*/
+static const struct i2c_device_id mmc31xx_id[] = {
+	{ MMC31XX_I2C_NAME, 0 },
+	{ }
+};
+
+
+/*----------------------------------------------------------------------------*/
+static struct i2c_driver mmc31xx_i2c_driver = {
+    .driver = {
+        .owner = THIS_MODULE, 
+        .name  = MMC31XX_DEV_NAME,
+    },
+	.probe      = mmc31xx_probe,
+	.remove     = mmc31xx_remove,
+	.detect     = mmc31xx_detect,
+#if 0
+	.suspend    = mmc31xx_suspend,
+	.resume     = mmc31xx_resume,
+#endif 
+	.id_table = mmc31xx_id,
+	.address_data = &mmc31xx_addr_data,
+};
+
+static int mmc31xx_platform_probe(struct platform_device *pdev) 
+{
+	if(i2c_add_driver(&mmc31xx_i2c_driver))
+	{
+		pr_info("add driver error\n");
+		return -1;
+	} 
+	return 0;
+}
+
+static int mmc31xx_platform_remove(struct platform_device *pdev)
+{
+	i2c_del_driver(&mmc31xx_i2c_driver);
+	return 0;
+}
+/*----------------------------------------------------------------------------*/
+
+
+/*
+static struct i2c_driver mmc31xx_driver = {
+	.probe 		= mmc31xx_probe,
+	.remove 	= mmc31xx_remove,
+	.id_table	= mmc31xx_id,
+	.driver 	= {
+		.owner	= THIS_MODULE,
+		.name	= MMC31XX_I2C_NAME,
+	},
+};
+*/
+/*----------------------------------------------------------------------------*/
+static struct platform_driver mmc31xx_sensor_driver = {
+	.probe      = mmc31xx_platform_probe,
+	.remove     = mmc31xx_platform_remove,    
+	.driver     = {
+		.name  = "mmc31xx",
+		.owner = THIS_MODULE,
+	}
+};
+
+static int __init mmc31xx_init(void)
+{
+	pr_info("mmc31xx driver: init\n");
+	
+	if(platform_driver_register(&mmc31xx_sensor_driver))
+	{
+		pr_info("failed to register driver");
+		return 0;
+	}
+	return 0;   
+	//return i2c_add_driver(&mmc31xx_driver);
+}
+
+static void __exit mmc31xx_exit(void)
+{
+	pr_info("mmc31xx driver: exit\n");
+	
+	platform_driver_unregister(&mmc31xx_sensor_driver);
+	
+
+
+	//i2c_del_driver(&mmc31xx_driver);
+}
+
+module_init(mmc31xx_init);
+module_exit(mmc31xx_exit);
+
+MODULE_AUTHOR("Robbie Cao<hjcao@memsic.com>");
+MODULE_DESCRIPTION("MEMSIC MMC31XX Magnetic Sensor Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/gsensor/mmc31xx.h b/drivers/gsensor/mmc31xx.h
new file mode 100644
index 0000000..fe48483
--- /dev/null
+++ b/drivers/gsensor/mmc31xx.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * Definitions for mmc31xx magnetic sensor chip.
+ */
+#ifndef __MMC31XX_H__
+#define __MMC31XX_H__
+
+#include <linux/ioctl.h>
+
+#define MMC31XX_I2C_NAME		"mmc31xx"
+
+/*
+ * This address comes must match the part# on your target.
+ * Address to the sensor part# support as following list:
+ *   MMC3140	- 0x30
+ *   MMC3141	- 0x32
+ *   MMC3142	- 0x34
+ *   MMC3143	- 0x36
+ *   MMC3120	- 0x30
+ *   MMC3121	- 0x32
+ *   MMC3122	- 0x34
+ *   MMC3123	- 0x36
+ * Please refer to sensor datasheet for detail.
+ */
+#define MMC31XX_I2C_ADDR		0x30
+
+/* MMC31XX register address */
+#define MMC31XX_REG_CTRL		0x00
+#define MMC31XX_REG_DATA		0x01
+
+/* MMC31XX control bit */
+#define MMC31XX_CTRL_TM			0x01
+#define MMC31XX_CTRL_SET		0x02
+#define MMC31XX_CTRL_RST		0x04
+
+/* Use 'm' as magic number */
+#define MMC31XX_IOM			'm'
+
+/* IOCTLs for MMC31XX device */
+#define MMC31XX_IOC_TM			_IO (MMC31XX_IOM, 0x00)
+#define MMC31XX_IOC_SET			_IO (MMC31XX_IOM, 0x01)
+#define MMC31XX_IOC_RESET		_IO (MMC31XX_IOM, 0x02)
+#define MMC31XX_IOC_READ		_IOR(MMC31XX_IOM, 0x03, int[3])
+#define MMC31XX_IOC_READXYZ		_IOR(MMC31XX_IOM, 0x04, int[3])
+
+#endif /* __MMC31XX_H__ */
+
diff --git a/drivers/gsensor/mmc328x.c b/drivers/gsensor/mmc328x.c
new file mode 100644
index 0000000..a98c520
--- /dev/null
+++ b/drivers/gsensor/mmc328x.c
@@ -0,0 +1,344 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ * 	Dale Hou
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+
+#include <linux/mmc328x.h>
+
+#define DEBUG			0
+#define MAX_FAILURE_COUNT	3
+#define READMD			1
+
+#define MMC328X_DELAY_TM	10	/* ms */
+#define MMC328X_DELAY_RM	10	/* ms */
+#define MMC328X_DELAY_STDN	1	/* ms */
+
+#define MMC328X_RETRY_COUNT	3
+#define MMC328X_RESET_INTV	10
+
+#define MMC328X_DEV_NAME	"mmc328x"
+
+static u32 read_idx = 0;
+
+static struct i2c_client *this_client;
+
+static int mmc328x_i2c_rx_data(char *buf, int len)
+{
+	uint8_t i;
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= buf,
+		},
+		{
+			.addr	= this_client->addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+
+	for (i = 0; i < MMC328X_RETRY_COUNT; i++) {
+		if (i2c_transfer(this_client->adapter, msgs, 2) >= 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (i >= MMC328X_RETRY_COUNT) {
+		pr_err("%s: retry over %d\n", __FUNCTION__, MMC328X_RETRY_COUNT);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int mmc328x_i2c_tx_data(char *buf, int len)
+{
+	uint8_t i;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+	
+	for (i = 0; i < MMC328X_RETRY_COUNT; i++) {
+		if (i2c_transfer(this_client->adapter, msg, 1) >= 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (i >= MMC328X_RETRY_COUNT) {
+		pr_err("%s: retry over %d\n", __FUNCTION__, MMC328X_RETRY_COUNT);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int mmc328x_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static int mmc328x_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int mmc328x_ioctl(struct inode *inode, struct file *file, 
+	unsigned int cmd, unsigned long arg)
+{
+	void __user *pa = (void __user *)arg;
+	unsigned char data[16] = {0};
+	int vec[3] = {0};
+	int MD_times = 0;
+
+	switch (cmd) {
+	case MMC328X_IOC_TM:
+		data[0] = MMC328X_REG_CTRL;
+		data[1] = MMC328X_CTRL_TM;
+		if (mmc328x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait TM done for coming data read */
+		msleep(MMC328X_DELAY_TM);
+		break;
+	case MMC328X_IOC_RM:
+		data[0] = MMC328X_REG_CTRL;
+		data[1] = MMC328X_CTRL_RM;
+		if (mmc328x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait external capacitor charging done for next SET/RESET */
+		msleep(MMC328X_DELAY_RM);
+		break;
+	case MMC328X_IOC_READ:
+		data[0] = MMC328X_REG_DATA;
+		if (mmc328x_i2c_rx_data(data, 6) < 0) {
+			return -EFAULT;
+		}
+		vec[0] = data[1] << 8 | data[0];
+		vec[1] = data[3] << 8 | data[2];
+		vec[2] = data[5] << 8 | data[4];
+	#if DEBUG
+		printk("[X - %04x] [Y - %04x] [Z - %04x]\n", 
+			vec[0], vec[1], vec[2]);
+	#endif
+		if (copy_to_user(pa, vec, sizeof(vec))) {
+			return -EFAULT;
+		}
+		break;
+	case MMC328X_IOC_READXYZ:
+		/* do RM every MMC328X_RESET_INTV times read */
+		if (!(read_idx % MMC328X_RESET_INTV)) {
+			/* RM */
+			data[0] = MMC328X_REG_CTRL;
+			data[1] = MMC328X_CTRL_RM;
+			/* not check return value here, assume it always OK */
+			mmc328x_i2c_tx_data(data, 2);
+			/* wait external capacitor charging done for next RM */
+			msleep(MMC328X_DELAY_RM);
+		}
+		/* send TM cmd before read */
+		data[0] = MMC328X_REG_CTRL;
+		data[1] = MMC328X_CTRL_TM;
+		/* not check return value here, assume it always OK */
+		mmc328x_i2c_tx_data(data, 2);
+		/* wait TM done for coming data read */
+		msleep(MMC328X_DELAY_TM);
+#if READMD
+		/* Read MD */
+		data[0] = MMC328X_REG_DS;
+		if (mmc328x_i2c_rx_data(data, 1) < 0) {
+			return -EFAULT;
+		}
+		while (!(data[0] & 0x01)) {
+			msleep(1);
+			/* Read MD again*/
+			data[0] = MMC328X_REG_DS;
+			if (mmc328x_i2c_rx_data(data, 1) < 0) {
+				return -EFAULT;
+			}
+			if (data[0] & 0x01) break;
+			MD_times++;
+			if (MD_times > 2) {
+		#if DEBUG
+				printk("TM not work!!");
+		#endif
+				return -EFAULT;
+			}
+		}
+#endif		
+		/* read xyz raw data */
+		read_idx++;
+		data[0] = MMC328X_REG_DATA;
+		if (mmc328x_i2c_rx_data(data, 6) < 0) {
+			return -EFAULT;
+		}
+		vec[0] = data[1] << 8 | data[0];
+		vec[1] = data[3] << 8 | data[2];
+		vec[2] = data[5] << 8 | data[4];
+	#if DEBUG
+		printk("[X - %04x] [Y - %04x] [Z - %04x]\n", 
+			vec[0], vec[1], vec[2]);
+	#endif
+		if (copy_to_user(pa, vec, sizeof(vec))) {
+			return -EFAULT;
+		}
+
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t mmc328x_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "MMC328X");
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static DEVICE_ATTR(mmc328x, S_IRUGO, mmc328x_show, NULL);
+
+static struct file_operations mmc328x_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mmc328x_open,
+	.release	= mmc328x_release,
+	.ioctl		= mmc328x_ioctl,
+};
+
+static struct miscdevice mmc328x_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = MMC328X_DEV_NAME,
+	.fops = &mmc328x_fops,
+};
+
+static int mmc328x_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	unsigned char data[16] = {0};
+	int res = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("%s: functionality check failed\n", __FUNCTION__);
+		res = -ENODEV;
+		goto out;
+	}
+	this_client = client;
+
+	res = misc_register(&mmc328x_device);
+	if (res) {
+		pr_err("%s: mmc328x_device register failed\n", __FUNCTION__);
+		goto out;
+	}
+	res = device_create_file(&client->dev, &dev_attr_mmc328x);
+	if (res) {
+		pr_err("%s: device_create_file failed\n", __FUNCTION__);
+		goto out_deregister;
+	}
+
+	/* send ST cmd to mag sensor first of all */
+	data[0] = MMC328X_REG_CTRL;
+	data[1] = MMC328X_CTRL_RM;
+	if (mmc328x_i2c_tx_data(data, 2) < 0) {
+		/* assume RM always success */
+	}
+	/* wait external capacitor charging done for next RM */
+	msleep(MMC328X_DELAY_RM);
+
+	return 0;
+
+out_deregister:
+	misc_deregister(&mmc328x_device);
+out:
+	return res;
+}
+
+static int mmc328x_remove(struct i2c_client *client)
+{
+	device_remove_file(&client->dev, &dev_attr_mmc328x);
+	misc_deregister(&mmc328x_device);
+
+	return 0;
+}
+
+static const struct i2c_device_id mmc328x_id[] = {
+	{ MMC328X_I2C_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver mmc328x_driver = {
+	.probe 		= mmc328x_probe,
+	.remove 	= mmc328x_remove,
+	.id_table	= mmc328x_id,
+	.driver 	= {
+		.owner	= THIS_MODULE,
+		.name	= MMC328X_I2C_NAME,
+	},
+};
+
+
+static int __init mmc328x_init(void)
+{
+	pr_info("mmc328x driver: init\n");
+	return i2c_add_driver(&mmc328x_driver);
+}
+
+static void __exit mmc328x_exit(void)
+{
+	pr_info("mmc328x driver: exit\n");
+	i2c_del_driver(&mmc328x_driver);
+}
+
+module_init(mmc328x_init);
+module_exit(mmc328x_exit);
+
+MODULE_AUTHOR("Dale Hou<byhou@memsic.com>");
+MODULE_DESCRIPTION("MEMSIC MMC328X Magnetic Sensor Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/gsensor/mmc328x.h b/drivers/gsensor/mmc328x.h
new file mode 100644
index 0000000..3d21498
--- /dev/null
+++ b/drivers/gsensor/mmc328x.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *	Dale Hou
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * Definitions for mmc328x magnetic sensor chip.
+ */
+#ifndef __MMC328X_H__
+#define __MMC328X_H__
+
+#include <linux/ioctl.h>
+
+#define MMC328X_I2C_NAME		"mmc328x"
+
+/*
+ * This address comes must match the part# on your target.
+ * Address to the sensor part# support as following list:
+ *	MMC3280MS - 0110000b
+ *	MMC3281MS - 0110001b
+ *	MMC3282MS - 0110010b
+ *	MMC3283MS - 0110011b
+ *	MMC3284MS - 0110100b
+ *	MMC3285MS - 0110101b
+ *	MMC3286MS - 0110110b
+ *	MMC3287MS - 0110111b
+ * Please refer to sensor datasheet for detail.
+ */
+#define MMC328X_I2C_ADDR		0x30
+
+/* MMC328X register address */
+#define MMC328X_REG_CTRL		0x07
+#define MMC328X_REG_DATA		0x00
+#define MMC328X_REG_DS			0x06
+
+/* MMC328X control bit */
+#define MMC328X_CTRL_TM			0x01
+#define MMC328X_CTRL_RM			0x20
+
+/* Use 'm' as magic number */
+#define MMC328X_IOM			'm'
+
+/* IOCTLs for MMC328X device */
+#define MMC328X_IOC_TM			_IO (MMC328X_IOM, 0x00)
+#define MMC328X_IOC_RM			_IO (MMC328X_IOM, 0x01)
+#define MMC328X_IOC_READ		_IOR(MMC328X_IOM, 0x02, int[3])
+#define MMC328X_IOC_READXYZ		_IOR(MMC328X_IOM, 0x03, int[3])
+
+#endif /* __MMC328X_H__ */
+
diff --git a/drivers/gsensor/mxc6202x.c b/drivers/gsensor/mxc6202x.c
new file mode 100644
index 0000000..b1f3d57
--- /dev/null
+++ b/drivers/gsensor/mxc6202x.c
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+
+#include <linux/mxc6202x.h>
+
+#define DEBUG			0
+#define MAX_FAILURE_COUNT	3
+
+#define MXC6202X_DELAY_PWRON	100	/* ms, >= 75 ms */
+#define MXC6202X_DELAY_PWRDN	1	/* ms */
+#define MXC6202X_DELAY_ST	100	/* ms */
+#define MXC6202X_DELAY_BGTST	100	/* ms */
+#define MXC6202X_DELAY_TOEN	100	/* ms */
+
+#define MXC6202X_RETRY_COUNT	3
+
+static struct i2c_client *this_client;
+
+static int mxc6202x_i2c_rx_data(char *buf, int len)
+{
+	uint8_t i;
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= buf,
+		},
+		{
+			.addr	= this_client->addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+
+	for (i = 0; i < MXC6202X_RETRY_COUNT; i++) {
+		if (i2c_transfer(this_client->adapter, msgs, 2) > 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (i >= MXC6202X_RETRY_COUNT) {
+		pr_err("%s: retry over %d\n", __FUNCTION__, MXC6202X_RETRY_COUNT);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int mxc6202x_i2c_tx_data(char *buf, int len)
+{
+	uint8_t i;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+	
+	for (i = 0; i < MXC6202X_RETRY_COUNT; i++) {
+		if (i2c_transfer(this_client->adapter, msg, 1) > 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (i >= MXC6202X_RETRY_COUNT) {
+		pr_err("%s: retry over %d\n", __FUNCTION__, MXC6202X_RETRY_COUNT);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int mxc6202x_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static int mxc6202x_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int mxc6202x_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	void __user *pa = (void __user *)arg;
+	unsigned char data[16] = {0};
+	int vec[3] = {0};
+	int temperature;
+
+	switch (cmd) {
+	case MXC6202X_IOC_PWRON:
+		data[0] = MXC6202X_REG_CTRL;
+		data[1] = MXC6202X_CTRL_PWRON;
+		if (mxc6202x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait PWRON done */
+		msleep(MXC6202X_DELAY_PWRON);
+		break;
+	case MXC6202X_IOC_PWRDN:
+		data[0] = MXC6202X_REG_CTRL;
+		data[1] = MXC6202X_CTRL_PWRDN;
+		if (mxc6202x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait PWRDN done */
+		msleep(MXC6202X_DELAY_PWRDN);
+		break;
+	case MXC6202X_IOC_ST:
+		data[0] = MXC6202X_REG_CTRL;
+		data[1] = MXC6202X_CTRL_ST;
+		if (mxc6202x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait ST done */
+		msleep(MXC6202X_DELAY_ST);
+		break;
+	case MXC6202X_IOC_BGTST:
+		data[0] = MXC6202X_REG_CTRL;
+		data[1] = MXC6202X_CTRL_BGTST;
+		if (mxc6202x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait BGTST done */
+		msleep(MXC6202X_DELAY_BGTST);
+		break;
+	case MXC6202X_IOC_TOEN:
+		data[0] = MXC6202X_REG_CTRL;
+		data[1] = MXC6202X_CTRL_TOEN;
+		if (mxc6202x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait TOEN done */
+		msleep(MXC6202X_DELAY_TOEN);
+		break;
+	case MXC6202X_IOC_READXYZ:
+		data[0] = MXC6202X_REG_DATA;
+		if (mxc6202x_i2c_rx_data(data, 4) < 0) {
+			return -EFAULT;
+		}
+		vec[0] = data[0] << 8 | data[1];
+		vec[1] = data[2] << 8 | data[3];
+		vec[2] = data[4] << 8 | data[5];
+	#if DEBUG
+		printk("[X - %04x] [Y - %04x] [Z - %04x]\n", 
+			vec[0], vec[1], vec[2]);
+	#endif
+		if (copy_to_user(pa, vec, sizeof(vec))) {
+			return -EFAULT;
+		}
+		break;
+	case MXC6202X_IOC_READTEMP:
+		data[0] = MXC6202X_REG_DATA;
+		if (mxc6202x_i2c_rx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		temperature = data[0] << 8 | data[1];
+		if (copy_to_user(pa, &temperature, 1)) {
+			return -EFAULT;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t mxc6202x_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "MXC6202X");
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static DEVICE_ATTR(mxc6202x, S_IRUGO, mxc6202x_show, NULL);
+
+static struct file_operations mxc6202x_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mxc6202x_open,
+	.release	= mxc6202x_release,
+	.ioctl		= mxc6202x_ioctl,
+};
+
+static struct miscdevice mxc6202x_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "mxc6202x",
+	.fops = &mxc6202x_fops,
+};
+
+int mxc6202x_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int res = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("%s: functionality check failed\n", __FUNCTION__);
+		res = -ENODEV;
+		goto out;
+	}
+	this_client = client;
+
+	res = misc_register(&mxc6202x_device);
+	if (res) {
+		pr_err("%s: mxc6202x_device register failed\n", __FUNCTION__);
+		goto out;
+	}
+	res = device_create_file(&client->dev, &dev_attr_mxc6202x);
+	if (res) {
+		pr_err("%s: device_create_file failed\n", __FUNCTION__);
+		goto out_deregister;
+	}
+
+	return 0;
+
+out_deregister:
+	misc_deregister(&mxc6202x_device);
+out:
+	return res;
+}
+
+static int mxc6202x_remove(struct i2c_client *client)
+{
+	device_remove_file(&client->dev, &dev_attr_mxc6202x);
+	misc_deregister(&mxc6202x_device);
+
+	return 0;
+}
+
+static const struct i2c_device_id mxc6202x_id[] = {
+	{ MXC6202X_I2C_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver mxc6202x_driver = {
+	.probe 		= mxc6202x_probe,
+	.remove 	= mxc6202x_remove,
+	.id_table	= mxc6202x_id,
+	.driver 	= {
+		.owner	= THIS_MODULE,
+		.name = MXC6202X_I2C_NAME,
+	},
+};
+
+static int __init mxc6202x_init(void)
+{
+	pr_info("mxc6202x driver: init\n");
+	return i2c_add_driver(&mxc6202x_driver);
+}
+
+static void __exit mxc6202x_exit(void)
+{
+	pr_info("mxc6202x driver: exit\n");
+	i2c_del_driver(&mxc6202x_driver);
+}
+
+module_init(mxc6202x_init);
+module_exit(mxc6202x_exit);
+
+MODULE_AUTHOR("Robbie Cao<hjcao@memsic.com>");
+MODULE_DESCRIPTION("MEMSIC MXC6202X Accelerometer Sensor Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/gsensor/mxc6202x.h b/drivers/gsensor/mxc6202x.h
new file mode 100644
index 0000000..48c7132
--- /dev/null
+++ b/drivers/gsensor/mxc6202x.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * Definitions for mxc6202x accelorometer sensor chip.
+ */
+#ifndef __MXC6202X_H__
+#define __MXC6202X_H__
+
+#include <linux/ioctl.h>
+
+#define MXC6202X_I2C_NAME		"mxc6202x"
+
+/*
+ * This address comes must match the part# on your target.
+ * Address to the sensor part# support as following list:
+ *   MXC62020	- 0x10
+ *   MXC62021	- 0x11
+ *   MXC62022	- 0x12
+ *   MXC62023	- 0x13
+ *   MXC62024	- 0x14
+ *   MXC62025	- 0x15
+ *   MXC62026	- 0x16
+ *   MXC62027	- 0x17
+ * Please refer to sensor datasheet for detail.
+ */
+#define MXC6202X_I2C_ADDR		0x10
+
+/* MXC6202X register address */
+#define MXC6202X_REG_CTRL		0x00
+#define MXC6202X_REG_DATA		0x01
+
+/* MXC6202X control bit */
+#define MXC6202X_CTRL_PWRON		0x00	/* power on */
+#define MXC6202X_CTRL_PWRDN		0x01	/* power donw */
+#define MXC6202X_CTRL_ST		0x02	/* self test */
+#define MXC6202X_CTRL_BGTST		0x04	/* bandgap test */
+#define MXC6202X_CTRL_TOEN		0x08	/* temperature out en */
+
+/* Use 'm' as magic number */
+#define MXC6202X_IOM			'm'
+
+/* IOCTLs for MXC6202X device */
+#define MXC6202X_IOC_PWRON		_IO (MXC6202X_IOM, 0x00)
+#define MXC6202X_IOC_PWRDN		_IO (MXC6202X_IOM, 0x01)
+#define MXC6202X_IOC_ST			_IO (MXC6202X_IOM, 0x02)
+#define MXC6202X_IOC_BGTST		_IO (MXC6202X_IOM, 0x03)
+#define MXC6202X_IOC_TOEN		_IO (MXC6202X_IOM, 0x04)
+#define MXC6202X_IOC_READXYZ		_IOR(MXC6202X_IOM, 0x05, int[3])
+#define MXC6202X_IOC_READTEMP		_IOR(MXC6202X_IOM, 0x06, int)
+
+#endif /* __MXC6202X_H__ */
+
diff --git a/drivers/gsensor/mxc622x.c b/drivers/gsensor/mxc622x.c
new file mode 100644
index 0000000..683f2c7
--- /dev/null
+++ b/drivers/gsensor/mxc622x.c
@@ -0,0 +1,457 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+#include "mxc622x.h"
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#define DEBUG			0
+#define MAX_FAILURE_COUNT	3
+
+#define MXC622X_DELAY_PWRON	300	/* ms, >= 300 ms */
+#define MXC622X_DELAY_PWRDN	1	/* ms */
+#define MXC622X_DELAY_SETDETECTION	MXC622X_DELAY_PWRON
+
+#define MXC622X_RETRY_COUNT	3
+#define SENSOR_NAME	MXC622X_I2C_NAME
+static struct i2c_client *this_client;
+
+struct mxc622x_data {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+} this_data;
+
+
+/* Addresses to scan */
+static union{
+	unsigned short dirty_addr_buf[2];
+	const unsigned short normal_i2c[2];
+}u_i2c_addr = {{0x00},};
+static __u32 twi_id = 0;
+
+/**
+ * gsensor_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int gsensor_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int device_used = -1;
+	__u32 twi_addr = 0;
+	char name[I2C_NAME_SIZE];
+	script_parser_value_type_t type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+		
+	printk("========%s===================\n", __func__);
+	 
+	if(SCRIPT_PARSER_OK != (ret = script_parser_fetch("gsensor_para", "gsensor_used", &device_used, 1))){
+	                pr_err("%s: script_parser_fetch err.ret = %d. \n", __func__, ret);
+	                goto script_parser_fetch_err;
+	}
+	if(1 == device_used){
+		if(SCRIPT_PARSER_OK != script_parser_fetch_ex("gsensor_para", "gsensor_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+			pr_err("%s: line: %d script_parser_fetch err. \n", __func__, __LINE__);
+			goto script_parser_fetch_err;
+		}
+		if(strcmp(SENSOR_NAME, name)){
+			pr_err("%s: name %s does not match SENSOR_NAME. \n", __func__, name);
+			pr_err(SENSOR_NAME);
+			//ret = 1;
+			return ret;
+		}
+		if(SCRIPT_PARSER_OK != script_parser_fetch("gsensor_para", "gsensor_twi_addr", &twi_addr, sizeof(twi_addr)/sizeof(__u32))){
+			pr_err("%s: line: %d: script_parser_fetch err. \n", name, __LINE__);
+			goto script_parser_fetch_err;
+		}
+		u_i2c_addr.dirty_addr_buf[0] = twi_addr;
+		u_i2c_addr.dirty_addr_buf[1] = I2C_CLIENT_END;
+		printk("%s: after: gsensor_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", \
+			__func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+
+		if(SCRIPT_PARSER_OK != script_parser_fetch("gsensor_para", "gsensor_twi_id", &twi_id, 1)){
+			pr_err("%s: script_parser_fetch err. \n", name);
+			goto script_parser_fetch_err;
+		}
+		printk("%s: tkey_twi_id is %d. \n", __func__, twi_id);
+
+		ret = 0;
+		
+	}else{
+		pr_err("%s: gsensor_unused. \n",  __func__);
+		ret = -1;
+	}
+
+	return ret;
+
+script_parser_fetch_err:
+	pr_notice("=========script_parser_fetch_err============\n");
+	return ret;
+
+}
+
+/**
+ * gsensor_detect - Device detection callback for automatic device creation
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int gsensor_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	
+	if(twi_id == adapter->nr){
+		pr_info("%s: Detected chip %s at adapter %d, address 0x%02x\n",
+			 __func__, SENSOR_NAME, i2c_adapter_id(adapter), client->addr);
+
+		strlcpy(info->type, SENSOR_NAME, I2C_NAME_SIZE);
+		return 0;
+	}else{
+		return -ENODEV;
+	}
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mxc622x_early_suspend(struct early_suspend *h);
+static void mxc622x_late_resume(struct early_suspend *h);
+#endif
+
+
+static int mxc622x_i2c_rx_data(char *buf, int len)
+{
+	uint8_t i;
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= buf,
+		},
+		{
+			.addr	= this_client->addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+
+	for (i = 0; i < MXC622X_RETRY_COUNT; i++) {
+		if (i2c_transfer(this_client->adapter, msgs, 2) > 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (i >= MXC622X_RETRY_COUNT) {
+		pr_err("%s: retry over %d\n", __FUNCTION__, MXC622X_RETRY_COUNT);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int mxc622x_i2c_tx_data(char *buf, int len)
+{
+	uint8_t i;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+	
+	for (i = 0; i < MXC622X_RETRY_COUNT; i++) {
+		if (i2c_transfer(this_client->adapter, msg, 1) > 0) {
+			break;
+		}
+		mdelay(10);
+	}
+
+	if (i >= MXC622X_RETRY_COUNT) {
+		pr_err("%s: retry over %d\n", __FUNCTION__, MXC622X_RETRY_COUNT);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int mxc622x_open(struct inode *inode, struct file *file)
+{
+	return nonseekable_open(inode, file);
+}
+
+static int mxc622x_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long mxc622x_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void __user *pa = (void __user *)arg;
+	unsigned char data[16] = {0};
+	int vec[3] = {0};
+
+	switch (cmd) {
+	case MXC622X_IOC_PWRON:
+		data[0] = MXC622X_REG_CTRL;
+		data[1] = MXC622X_CTRL_PWRON;
+		if (mxc622x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait PWRON done */
+		msleep(MXC622X_DELAY_PWRON);
+		break;
+	case MXC622X_IOC_PWRDN:
+		data[0] = MXC622X_REG_CTRL;
+		data[1] = MXC622X_CTRL_PWRDN;
+		if (mxc622x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait PWRDN done */
+		msleep(MXC622X_DELAY_PWRDN);
+		break;
+	case MXC622X_IOC_READXYZ:
+		data[0] = MXC622X_REG_DATA;
+		if (mxc622x_i2c_rx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		vec[0] = (int)data[0];
+		vec[1] = (int)data[1];
+		vec[2] = (int)data[2];
+	#if DEBUG
+		printk("[X - %04x] [Y - %04x] [Z - %04x]\n", 
+			vec[0], vec[1], vec[2]);
+	#endif
+		if (copy_to_user(pa, vec, sizeof(vec))) {
+			return -EFAULT;
+		}
+		break;
+	case MXC622X_IOC_READSTATUS:
+		data[0] = MXC622X_REG_DATA;
+		if (mxc622x_i2c_rx_data(data, 3) < 0) {
+			return -EFAULT;
+		}
+		vec[0] = (int)data[0];
+		vec[1] = (int)data[1];
+		vec[2] = (unsigned int)data[2];
+	#if DEBUG
+		printk("[X - %04x] [Y - %04x] [STATUS - %04x]\n", 
+			vec[0], vec[1], vec[2]);
+	#endif
+		if (copy_to_user(pa, vec, sizeof(vec))) {
+			return -EFAULT;
+		}
+		break;
+	case MXC622X_IOC_SETDETECTION:
+		data[0] = MXC622X_REG_CTRL;
+		if (copy_from_user(&(data[1]), pa, sizeof(unsigned char))) {
+			return -EFAULT;
+		}
+		if (mxc622x_i2c_tx_data(data, 2) < 0) {
+			return -EFAULT;
+		}
+		/* wait SETDETECTION done */
+		msleep(MXC622X_DELAY_SETDETECTION);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t mxc622x_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+
+	sprintf(buf, "MXC622X");
+	ret = strlen(buf) + 1;
+
+	return ret;
+}
+
+static DEVICE_ATTR(mxc622x, S_IRUGO, mxc622x_show, NULL);
+
+static struct file_operations mxc622x_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mxc622x_open,
+	.release	= mxc622x_release,
+	.unlocked_ioctl		= mxc622x_ioctl,
+};
+
+static struct miscdevice mxc622x_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = MXC622X_I2C_NAME,
+	.fops = &mxc622x_fops,
+};
+
+int mxc622x_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int res = 0;
+
+	printk("%s, line is: %d. \n", __func__, __LINE__);
+	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		pr_err("%s: functionality check failed\n", __FUNCTION__);
+		res = -ENODEV;
+		goto out;
+	}
+	this_client = client;
+
+	res = misc_register(&mxc622x_device);
+	if (res) {
+		pr_err("%s: mxc622x_device register failed\n", __FUNCTION__);
+		goto out;
+	}
+	res = device_create_file(&client->dev, &dev_attr_mxc622x);
+	if (res) {
+		pr_err("%s: device_create_file failed\n", __FUNCTION__);
+		goto out_deregister;
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	this_data.early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	this_data.early_suspend.suspend = mxc622x_early_suspend;
+	this_data.early_suspend.resume = mxc622x_late_resume;
+	register_early_suspend(&this_data.early_suspend);
+#endif
+
+	return 0;
+
+out_deregister:
+	misc_deregister(&mxc622x_device);
+out:
+	return res;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void mxc622x_early_suspend(struct early_suspend *h)
+{
+	unsigned char data[4] = {0};
+
+	data[0] = MXC622X_REG_CTRL;
+	data[1] = MXC622X_CTRL_PWRDN;
+	if (mxc622x_i2c_tx_data(data, 2) < 0) {
+		pr_warning("mxc622x_early_suspend: power down mxc622x err\n");
+	}
+	/* wait PWRDN done */
+	msleep(MXC622X_DELAY_PWRDN);
+}
+
+static void mxc622x_late_resume(struct early_suspend *h)
+{
+	unsigned char data[4] = {0};
+
+	data[0] = MXC622X_REG_CTRL;
+	data[1] = MXC622X_CTRL_PWRON;
+	if (mxc622x_i2c_tx_data(data, 2) < 0) {
+		pr_err("mxc622x_late_resume: power on mxc622x err\n");
+	}
+	/* wait PWRON done */
+	msleep(MXC622X_DELAY_PWRON);
+}
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+static int mxc622x_remove(struct i2c_client *client)
+{
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&this_data.early_suspend);
+#endif
+	device_remove_file(&client->dev, &dev_attr_mxc622x);
+	misc_deregister(&mxc622x_device);
+
+	return 0;
+}
+
+static const struct i2c_device_id mxc622x_id[] = {
+	{ MXC622X_I2C_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver mxc622x_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe 		= mxc622x_probe,
+	.remove 	= mxc622x_remove,
+	.id_table	= mxc622x_id,
+	.driver 	= {
+		.owner	= THIS_MODULE,
+		.name = MXC622X_I2C_NAME,
+	},
+	.address_list	= u_i2c_addr.normal_i2c,
+};
+
+static int __init mxc622x_init(void)
+{
+	int ret = -1;
+	pr_info("mxc622x driver: init\n");
+	
+	if(gsensor_fetch_sysconfig_para()){
+		printk("%s: err.\n", __func__);
+		return -1;
+	}
+
+	printk("%s: after fetch_sysconfig_para:  normal_i2c: 0x%hx. normal_i2c[1]: 0x%hx \n", \
+	__func__, u_i2c_addr.normal_i2c[0], u_i2c_addr.normal_i2c[1]);
+
+	mxc622x_driver.detect = gsensor_detect;
+	
+	ret = i2c_add_driver(&mxc622x_driver);
+
+	return ret;
+}
+
+static void __exit mxc622x_exit(void)
+{
+	pr_info("mxc622x driver: exit\n");
+	i2c_del_driver(&mxc622x_driver);
+}
+
+module_init(mxc622x_init);
+module_exit(mxc622x_exit);
+
+MODULE_AUTHOR("Robbie Cao<hjcao@memsic.com>");
+MODULE_DESCRIPTION("MEMSIC MXC622X (DTOS) Accelerometer Sensor Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/gsensor/mxc622x.h b/drivers/gsensor/mxc622x.h
new file mode 100644
index 0000000..4339deb
--- /dev/null
+++ b/drivers/gsensor/mxc622x.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2010 MEMSIC, Inc.
+ *
+ * Initial Code:
+ *	Robbie Cao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*
+ * Definitions for mxc622x accelorometer sensor chip.
+ */
+#ifndef __MXC622X_H__
+#define __MXC622X_H__
+
+#include <linux/ioctl.h>
+
+#define MXC622X_I2C_NAME		"mxc622x"
+
+/*
+ * This address comes must match the part# on your target.
+ * Address to the sensor part# support as following list:
+ *   MXC6220	- 0x10
+ *   MXC6221	- 0x11
+ *   MXC6222	- 0x12
+ *   MXC6223	- 0x13
+ *   MXC6224	- 0x14
+ *   MXC6225	- 0x15
+ *   MXC6226	- 0x16
+ *   MXC6227	- 0x17
+ * Please refer to sensor datasheet for detail.
+ */
+#define MXC622X_I2C_ADDR		0x15
+
+/* MXC622X register address */
+#define MXC622X_REG_CTRL		0x04
+#define MXC622X_REG_DATA		0x00
+
+/* MXC622X control bit */
+#define MXC622X_CTRL_PWRON		0x00	/* power on */
+#define MXC622X_CTRL_PWRDN		0x80	/* power donw */
+
+/* Use 'm' as magic number */
+#define MXC622X_IOM			'm'
+
+/* IOCTLs for MXC622X device */
+#define MXC622X_IOC_PWRON		_IO (MXC622X_IOM, 0x00)
+#define MXC622X_IOC_PWRDN		_IO (MXC622X_IOM, 0x01)
+#define MXC622X_IOC_READXYZ		_IOR(MXC622X_IOM, 0x05, int[3])
+#define MXC622X_IOC_READSTATUS		_IOR(MXC622X_IOM, 0x07, int[3])
+#define MXC622X_IOC_SETDETECTION	_IOW(MXC622X_IOM, 0x08, unsigned char)
+
+#endif /* __MXC622X_H__ */
+
