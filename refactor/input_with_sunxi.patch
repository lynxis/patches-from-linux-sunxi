diff --git a/drivers/input/Kconfig b/drivers/input/Kconfig
index 3325979..69d3686 100644
--- a/drivers/input/Kconfig
+++ b/drivers/input/Kconfig
@@ -165,6 +165,15 @@ config INPUT_APMPOWER
 	  To compile this driver as a module, choose M here: the
 	  module will be called apm-power.
 
+config INPUT_KEYRESET
+	tristate "Reset key"
+	depends on INPUT
+	---help---
+	  Say Y here if you want to reboot when some keys are pressed;
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keyreset.
+
 comment "Input Device Drivers"
 
 source "drivers/input/keyboard/Kconfig"
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index b173a13a..cf643be 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_INPUT_MISC)	+= misc/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
 obj-$(CONFIG_INPUT_OF_MATRIX_KEYMAP) += of_keymap.o
+obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
index 4b2e10d..a937438 100644
--- a/drivers/input/evdev.c
+++ b/drivers/input/evdev.c
@@ -23,6 +23,7 @@
 #include <linux/input/mt.h>
 #include <linux/major.h>
 #include <linux/device.h>
+#include <linux/wakelock.h>
 #include "input-compat.h"
 
 struct evdev {
@@ -43,6 +44,9 @@ struct evdev_client {
 	unsigned int tail;
 	unsigned int packet_head; /* [future] position of the first element of next packet */
 	spinlock_t buffer_lock; /* protects access to buffer, head and tail */
+	struct wake_lock wake_lock;
+	bool use_wake_lock;
+	char name[28];
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
 	struct list_head node;
@@ -80,10 +84,14 @@ static void evdev_pass_event(struct evdev_client *client,
 		client->buffer[client->tail].value = 0;
 
 		client->packet_head = client->tail;
+		if (client->use_wake_lock)
+			wake_unlock(&client->wake_lock);
 	}
 
 	if (event->type == EV_SYN && event->code == SYN_REPORT) {
 		client->packet_head = client->head;
+		if (client->use_wake_lock)
+			wake_lock(&client->wake_lock);
 		kill_fasync(&client->fasync, SIGIO, POLL_IN);
 	}
 
@@ -264,6 +272,8 @@ static int evdev_release(struct inode *inode, struct file *file)
 	mutex_unlock(&evdev->mutex);
 
 	evdev_detach_client(evdev, client);
+	if (client->use_wake_lock)
+		wake_lock_destroy(&client->wake_lock);
 	kfree(client);
 
 	evdev_close_device(evdev);
@@ -315,6 +325,8 @@ static int evdev_open(struct inode *inode, struct file *file)
 
 	client->bufsize = bufsize;
 	spin_lock_init(&client->buffer_lock);
+	snprintf(client->name, sizeof(client->name), "%s-%d",
+			dev_name(&evdev->dev), task_tgid_vnr(current));
 	client->evdev = evdev;
 	evdev_attach_client(evdev, client);
 
@@ -382,6 +394,9 @@ static int evdev_fetch_next_event(struct evdev_client *client,
 	if (have_event) {
 		*event = client->buffer[client->tail++];
 		client->tail &= client->bufsize - 1;
+		if (client->use_wake_lock &&
+		    client->packet_head == client->tail)
+			wake_unlock(&client->wake_lock);
 	}
 
 	spin_unlock_irq(&client->buffer_lock);
@@ -654,6 +669,35 @@ static int evdev_handle_mt_request(struct input_dev *dev,
 	return 0;
 }
 
+static int evdev_enable_suspend_block(struct evdev *evdev,
+				      struct evdev_client *client)
+{
+	if (client->use_wake_lock)
+		return 0;
+
+	spin_lock_irq(&client->buffer_lock);
+	wake_lock_init(&client->wake_lock, WAKE_LOCK_SUSPEND, client->name);
+	client->use_wake_lock = true;
+	if (client->packet_head != client->tail)
+		wake_lock(&client->wake_lock);
+	spin_unlock_irq(&client->buffer_lock);
+	return 0;
+}
+
+static int evdev_disable_suspend_block(struct evdev *evdev,
+				       struct evdev_client *client)
+{
+	if (!client->use_wake_lock)
+		return 0;
+
+	spin_lock_irq(&client->buffer_lock);
+	client->use_wake_lock = false;
+	wake_lock_destroy(&client->wake_lock);
+	spin_unlock_irq(&client->buffer_lock);
+
+	return 0;
+}
+
 static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 			   void __user *p, int compat_mode)
 {
@@ -735,6 +779,15 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 
 	case EVIOCSKEYCODE_V2:
 		return evdev_handle_set_keycode_v2(dev, p);
+
+	case EVIOCGSUSPENDBLOCK:
+		return put_user(client->use_wake_lock, ip);
+
+	case EVIOCSSUSPENDBLOCK:
+		if (p)
+			return evdev_enable_suspend_block(evdev, client);
+		else
+			return evdev_disable_suspend_block(evdev, client);
 	}
 
 	size = _IOC_SIZE(cmd);
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 8921c61..108cc82 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -26,6 +26,11 @@
 #include <linux/device.h>
 #include <linux/mutex.h>
 #include <linux/rcupdate.h>
+
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+#include <linux/cpufreq.h>
+#endif
+
 #include "input-compat.h"
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
@@ -45,6 +50,17 @@ static LIST_HEAD(input_handler_list);
  */
 static DEFINE_MUTEX(input_mutex);
 
+
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+static struct workqueue_struct	*cpufreq_usrevent;
+static void cpufreq_notify(struct work_struct *work)
+{
+    cpufreq_user_event_notify();
+}
+static DECLARE_WORK(request_cpufreq_notify, cpufreq_notify);
+#endif
+
+
 static struct input_handler *input_table[8];
 
 static inline int is_event_supported(unsigned int code,
@@ -69,6 +85,13 @@ static int input_defuzz_abs_event(int value, int old_val, int fuzz)
 	return value;
 }
 
+static const char *gsensor_name_list[] = {
+	"mma7660",
+	"bma250",
+	"ecompass_data",
+	NULL
+};
+
 /*
  * Pass event first through all filters and then, if event has not been
  * filtered out, through all open handles. This function is called with
@@ -79,6 +102,21 @@ static void input_pass_event(struct input_dev *dev,
 {
 	struct input_handler *handler;
 	struct input_handle *handle;
+	int i;
+	bool not_gsensor = true;
+
+    #ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+	for(i = 0; i < ARRAY_SIZE(gsensor_name_list) - 1; i++) {
+		if(!strcmp(gsensor_name_list[i], dev->name)) {
+			not_gsensor = false;
+			break;
+		}
+	}
+    /* notify cpu-freq sub-system that some user event happend */
+	if(not_gsensor) {
+		queue_work(cpufreq_usrevent, &request_cpufreq_notify);
+	}
+    #endif
 
 	rcu_read_lock();
 
@@ -2156,8 +2194,20 @@ static int __init input_init(void)
 		goto fail2;
 	}
 
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+	cpufreq_usrevent = create_workqueue("cpufreq_uevent");
+	if (!cpufreq_usrevent) {
+		printk(KERN_ERR "Creation of cpufreq_usrevent failed\n");
+		goto fail3;
+	}
+#endif
+
 	return 0;
 
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+ fail3: unregister_chrdev(INPUT_MAJOR, "input");
+#endif
+
  fail2:	input_proc_exit();
  fail1:	class_unregister(&input_class);
 	return err;
@@ -2165,6 +2215,10 @@ static int __init input_init(void)
 
 static void __exit input_exit(void)
 {
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+    destroy_workqueue(cpufreq_usrevent);
+#endif
+
 	input_proc_exit();
 	unregister_chrdev(INPUT_MAJOR, "input");
 	class_unregister(&input_class);
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index f354813..2ffffa6 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -580,4 +580,42 @@ config KEYBOARD_W90P910
 	  To compile this driver as a module, choose M here: the
 	  module will be called w90p910_keypad.
 
+config KEYBOARD_SUN4IKEYPAD
+	tristate "sunxi matrix keypad support"
+	help
+	  Say Y here to enable matrix keypad support for sunxi devices using
+	  the same keypad wiring as the sunxi evaluation boards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sun4i-keypad.
+
+config KEYBOARD_SUN4I_KEYBOARD
+	tristate "sunxi tablet keys on adc0 support"
+	help
+	  Say Y here to enable support for tablet keys (vol up/down, menu,
+	  home, search, enter, esc.), wired to adc0 through a resistor
+	  array, such as used on the sunxi evaluation boards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sun4i-keyboard.
+
+config KEYBOARD_SUN4I_KEYBOARD_FEX
+	bool "sunxi tablet keys on adc0 controlled throuh fex"
+	default n
+	depends on KEYBOARD_SUN4I_KEYBOARD
+	help
+	  Say Y here to only have the "sunxi tablet keys" input device
+	  register itself when the sunxi fex file contains a "tabletkeys_para"
+	  section with "tabletkeys_used = 1" in there.
+
+	  If unsure, say N.
+
+config KEYBOARD_HV2605_KEYBOARD
+        tristate "SUN4I HV2605 KEY BOARD support"
+        depends on I2C
+        help
+          Say Y here to enable the keyboard, support 5 keys.
+
+config IR_SUNXI
+	tristate "sunxi IR support"
 endif
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index df7061f..dd85327 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -52,3 +52,7 @@ obj-$(CONFIG_KEYBOARD_TNETV107X)	+= tnetv107x-keypad.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
+obj-$(CONFIG_KEYBOARD_SUN4IKEYPAD)      += sun4i-keypad.o
+obj-$(CONFIG_KEYBOARD_SUN4I_KEYBOARD)	+= sun4i-keyboard.o
+obj-$(CONFIG_IR_SUNXI)			+= sunxi-ir.o
+obj-$(CONFIG_KEYBOARD_HV2605_KEYBOARD)  += hv2605.o
diff --git a/drivers/input/keyboard/hv2605.c b/drivers/input/keyboard/hv2605.c
new file mode 100644
index 0000000..0c280d4
--- /dev/null
+++ b/drivers/input/keyboard/hv2605.c
@@ -0,0 +1,527 @@
+/*
+ * drivers/input/keyboard/hv2605_keypad.c
+ *
+ * HV2605 KEYPAD driver.
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *	note: only support mulititouch	Wenfs 2010-10-01
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include "hv2605.h"
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    #include <linux/pm.h>
+    #include <linux/earlysuspend.h>
+#endif
+
+//#define KEY_DEBUG
+//#define PRINT_STATUS_INFO
+#define LOW_POWER_WORK_MODE
+//#define FULL_SPEED_WORK_MODE
+#define PRINT_SUSPEND_INFO
+
+static struct i2c_client *this_client;
+static struct hv_keypad_data *hv_keypad;
+
+
+struct key_event {
+	int	key_val;
+	int key_last;
+	int	key_status;
+};
+
+struct hv_keypad_data {
+	struct input_dev     *input_dev;
+	struct key_event     event;
+ 	struct delayed_work  work;
+  	struct workqueue_struct *queue;
+};
+
+#ifdef PRINT_STATUS_INFO
+#define print_status_info(fmt, args...)   \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_status_info(fmt, args...)   //
+#endif
+
+static struct i2c_msg tx_msg[] = {{0},};
+static 	struct i2c_msg rx_msgs[] = {{0},{0},};
+
+/* Addresses to scan */
+static union{
+	unsigned short dirty_addr_buf[2];
+	const unsigned short normal_i2c[2];
+}u_i2c_addr = {{0x00},};
+static __u32 twi_id = 0;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+struct hv2605_keyboard_data {
+    struct early_suspend early_suspend;
+};
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct hv2605_keyboard_data *keyboard_data;
+#endif
+
+/**
+ * tkey_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int tkey_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int device_used = -1;
+	__u32 twi_addr = 0;
+
+	char name[I2C_NAME_SIZE];
+	script_parser_value_type_t type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+	
+	//__u32 twi_id = 0;
+
+	printk("========HV Inital ===================\n");
+	if(SCRIPT_PARSER_OK != script_parser_fetch("tkey_para", "tkey_used", &device_used, 1)){
+	                pr_err("hv_keyboard: script_parser_fetch err. \n");
+	                goto script_parser_fetch_err;
+	}
+	if(1 == device_used){
+		if(SCRIPT_PARSER_OK != script_parser_fetch_ex("tkey_para", "tkey_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+			pr_err("%s: script_parser_fetch err. \n", __func__);
+			goto script_parser_fetch_err;
+		}
+		if(strcmp(HV_NAME, name)){
+			pr_err("%s: name %s does not match HV_NAME. \n", __func__, name);
+			pr_err(HV_NAME);
+			//ret = 1;
+			return ret;
+		}
+		if(SCRIPT_PARSER_OK != script_parser_fetch("tkey_para", "tkey_twi_addr", &twi_addr, sizeof(twi_addr)/sizeof(__u32))){
+			pr_err("%s: script_parser_fetch err. \n", name);
+			goto script_parser_fetch_err;
+		}
+		u_i2c_addr.dirty_addr_buf[0] = twi_addr;
+		u_i2c_addr.dirty_addr_buf[1] = I2C_CLIENT_END;
+		printk("%s: after: tkey_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", \
+		__func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+		
+		if(SCRIPT_PARSER_OK != script_parser_fetch("tkey_para", "tkey_twi_id", &twi_id, 1)){
+			pr_err("%s: script_parser_fetch err. \n", name);
+			goto script_parser_fetch_err;
+		}
+		printk("%s: tkey_twi_id is %d. \n", __func__, twi_id);
+		
+	}else{
+		pr_err("%s: tkey_unused. \n",  __func__);
+		ret = -1;
+	}
+
+	return 0;
+
+script_parser_fetch_err:
+	pr_notice("=========script_parser_fetch_err============\n");
+	return ret;
+
+}
+
+/**
+ * tkey_detect - Device detection callback for automatic device creation
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+int tkey_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if(twi_id == adapter->nr)
+	{
+		pr_info("%s: Detected chip %s at adapter %d, address 0x%02x\n",
+			 __func__, HV_NAME, i2c_adapter_id(adapter), client->addr);
+
+		strlcpy(info->type, HV_NAME, I2C_NAME_SIZE);
+		return 0;
+	}else{
+		return -ENODEV;
+	}
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void hv2605_keyboard_suspend(struct early_suspend *h)
+{
+#ifdef PRINT_SUSPEND_INFO
+	printk("enter earlysuspend: hv2605_keyboard_suspend. \n");
+#endif
+	cancel_delayed_work_sync(&hv_keypad->work);
+	return ;
+}
+static void hv2605_keyboard_resume(struct early_suspend *h)
+{
+#ifdef PRINT_SUSPEND_INFO
+	printk("enter laterresume: hv2605_keyboard_resume. \n");
+#endif
+	queue_delayed_work(hv_keypad->queue, &hv_keypad->work, DELAY_PERIOD);
+	return ;
+}
+#else
+#endif
+
+static int hv_i2c_rxdata(char *rxdata, int length)
+{
+	int ret;
+
+	rx_msgs[0].addr	= this_client->addr;
+	rx_msgs[0].flags	= I2C_M_RD;
+	rx_msgs[0].len	= 1;
+	rx_msgs[0].buf	= rxdata;
+
+    //msleep(1);
+	ret = i2c_transfer(this_client->adapter, rx_msgs, 1);
+	//printk("msg i2c read: 0x%x\n", this_client->addr);
+	//printk("HV IIC read data\n");
+	if (ret < 0){
+#ifdef LOW_POWER_WORK_MODE
+		;
+#elif defined(FULL_SPEED_WORK_MODE)
+		pr_info("msg %s i2c read error: 0x%x\n", __func__, this_client->addr);
+#endif
+	}
+
+	return ret;
+}
+
+static int hv_i2c_txdata(char *txdata, int length)
+{
+	int ret;
+	tx_msg[0].addr   = this_client->addr;
+	tx_msg[0].flags  = 0;
+	tx_msg[0].len    = length;
+	tx_msg[0].buf    = txdata;
+
+   	//msleep(1);
+	ret = i2c_transfer(this_client->adapter, tx_msg, 1);
+	if (ret < 0)
+		pr_err("%s i2c write error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int hv_init(void)
+{
+#ifdef LOW_POWER_WORK_MODE
+	//low power work mode
+	u8 buf[12] = {0x88,0x05,0x40,0x40,0x40,0x40,0x40,0xf8,0x00,0x05,0x00,0x42};
+#elif defined(FULL_SPEED_WORK_MODE)
+	//full speed work mode
+	u8 buf[12] = {0x88,0x00,0x40,0x40,0x40,0x40,0x40,0xf8,0x00,0x05,0x00,0x3d};
+#endif
+	//u8 buf[12] =   {0x88,0x05,0x90,0x90,0x90,0x90,0x90,0xf8,0x00,0x40,0x00,0x0d};
+	//u8 buf[12] = {0x88,0x05,0x40,0x40,0x40,0x40,0xff,0xf8,0x00,0x00,0x00,0xfc};
+
+
+	int ret = -1;
+	struct hv_keypad_data *data = i2c_get_clientdata(this_client);
+	struct key_event *event = &data->event;
+	
+	printk("===%s===.\n",  __func__);
+	event->key_status = 2;
+	event->key_last = 0;
+	ret = hv_i2c_txdata(buf, 12);
+	if (ret > 1) {
+		printk("%s: write reg failed! %#x ret: %d", __func__, buf[0], ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void hv_keypad_release(void)
+{
+	struct hv_keypad_data *data = i2c_get_clientdata(this_client);
+	struct key_event *event = &data->event;
+	input_report_key(data->input_dev,event->key_val, 0);
+	#ifdef KEY_DEBUG
+		printk("======Release the key %d=====\n",event->key_val);
+	#endif
+	input_sync(data->input_dev);
+	event->key_status = 2;
+	event->key_last = 0;
+}
+
+
+static int hv_read_data(void)
+{
+	struct hv_keypad_data *data = i2c_get_clientdata(this_client);
+	struct key_event *event = &data->event;
+	u8 buf[2] = {0};
+	int ret = -1;
+	//memset(event, 0, sizeof(struct key_event));
+	ret = hv_i2c_rxdata(buf, 1);
+	if(ret==1){
+		if((0xff != buf[0])&& (0 != buf[0])){
+			event->key_val    = buf[0];
+		}else if(0xff == buf[0]){
+			//event->key_val = event->key_last;
+			event->key_val    = buf[0];
+			//printk("receive 0xff. \n");
+		}
+		print_status_info("157 event->key_status = %d, event->key_val = %d.\n",event->key_status, event->key_val);
+
+	}else{
+		if(event->key_status ==1){
+			event->key_status = 0;
+		}
+		print_status_info("163 event->key_status = %d\n",event->key_status);
+
+	}
+
+	return ret;
+}
+
+static void hv_report_value(void)
+{
+	struct hv_keypad_data *data = i2c_get_clientdata(this_client);
+	struct key_event *event = &data->event;
+
+	input_report_key(data->input_dev, event->key_val, 1);
+	#ifdef KEY_DEBUG
+		printk("Press the key %d\n",event->key_val);
+	#endif
+	input_sync(data->input_dev);
+	event->key_status = 1;
+}
+
+static void hv_read_loop(struct work_struct *work)
+{
+	int ret = -1;
+	struct hv_keypad_data *data = i2c_get_clientdata(this_client);
+	struct key_event *event = &data->event;
+	//printk("==========Begin Read Data============\n");
+	ret = hv_read_data();
+	if(ret==1)
+	{
+		switch(event->key_val)
+		{
+			case 1:
+			case 2:
+			case 3:
+			case 4:
+			case 5:
+			if(event->key_last != event->key_val){
+			event->key_last = event->key_val;
+			hv_report_value();
+			}
+			break;
+
+			case 0xff:
+			if(event->key_status == 1){
+			event->key_val = event->key_last;
+			hv_keypad_release();
+			}
+			break;
+
+			default :
+			//hv_keypad_release();
+			break;
+
+		}
+
+		print_status_info("225 event->key_status = %d, event->key_val = %d.\n",event->key_status, event->key_val);
+	}else if(event->key_status ==0){
+		hv_keypad_release();
+		print_status_info("233 event->key_status = %d\n",event->key_status);
+	}
+
+	queue_delayed_work(hv_keypad->queue, &hv_keypad->work, DELAY_PERIOD);
+
+}
+
+static int hv_keypad_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+
+	struct input_dev *input_dev;
+	int err = 0;
+	int i;
+
+	printk("======================================hv_keypad_probe Begin=============================================\n");
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	hv_keypad = kzalloc(sizeof(*hv_keypad), GFP_KERNEL);
+	if (!hv_keypad)	{
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	this_client = client;
+	i2c_set_clientdata(client, hv_keypad);
+
+	hv_init();
+	
+	INIT_DELAYED_WORK(&hv_keypad->work, hv_read_loop);
+	hv_keypad->queue = create_singlethread_workqueue(dev_name(&client->dev));
+	if (!hv_keypad->queue) {
+		err = -ESRCH;
+		goto exit_create_singlethread;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+
+	hv_keypad->input_dev = input_dev;
+
+	input_dev->name = HV_NAME;
+	input_dev->phys = "sun4ikbd/inputx";
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+
+	for (i = 1; i < 6; i++)
+		set_bit(i, input_dev->keybit);
+
+	err = input_register_device(input_dev);
+	if (err) {
+		dev_err(&client->dev,
+		"hv_ts_probe: failed to register input device: %s\n",
+		dev_name(&client->dev));
+		goto exit_input_register_device_failed;
+	}
+
+	queue_delayed_work(hv_keypad->queue, &hv_keypad->work, DELAY_PERIOD);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	printk("==register_early_suspend =\n");
+	keyboard_data = kzalloc(sizeof(*keyboard_data), GFP_KERNEL);
+	if (keyboard_data == NULL) {
+		err = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+	keyboard_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	keyboard_data->early_suspend.suspend = hv2605_keyboard_suspend;
+	keyboard_data->early_suspend.resume	= hv2605_keyboard_resume;
+	register_early_suspend(&keyboard_data->early_suspend);
+#endif
+	printk("==probe ======over =\n");
+
+    return 0;
+
+exit_input_register_device_failed:
+	input_free_device(input_dev);
+exit_input_dev_alloc_failed:
+exit_create_singlethread:
+	printk("==singlethread error =\n");
+	i2c_set_clientdata(client, NULL);
+	kfree(hv_keypad);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+#ifdef CONFIG_HAS_EARLYSUSPEND
+ err_alloc_data_failed:
+#endif
+	return err;
+}
+
+static int __devexit hv_keypad_remove(struct i2c_client *client)
+{
+
+	struct hv_keypad_data *hv_keypadc = i2c_get_clientdata(client);
+	input_unregister_device(hv_keypadc->input_dev);
+	kfree(hv_keypad);
+	printk("==hv_keypad_remove=\n");
+	//cancel_work_sync(&zt_ts->work);
+	//destroy_workqueue(zt_ts->queue);
+	cancel_delayed_work_sync(&hv_keypad->work);
+	destroy_workqueue(hv_keypad->queue);
+	i2c_set_clientdata(client, NULL);
+	return 0;
+}
+
+static const struct i2c_device_id hv_keypad_id[] = {
+	{ HV_NAME, 0 },{ }
+};
+MODULE_DEVICE_TABLE(i2c, hv_keypad_id);
+
+static struct i2c_driver hv_keypad_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe		= hv_keypad_probe,
+	.remove		= __devexit_p(hv_keypad_remove),
+	.id_table	= hv_keypad_id,
+	.driver	= {
+		.name	=    HV_NAME,
+		.owner	=    THIS_MODULE,
+	},
+	.address_list	= u_i2c_addr.normal_i2c,
+};
+
+static int __init hv_keypad_init(void)
+{
+	int ret = -1;
+	//int err = -1;
+
+	printk("===========================%s=====================\n", __func__);
+
+	if(tkey_fetch_sysconfig_para()){
+		printk("%s: err.\n", __func__);
+		return -1;
+	}
+
+	printk("%s: after fetch_sysconfig_para:  normal_i2c: 0x%hx. normal_i2c[1]: 0x%hx \n", \
+	__func__, u_i2c_addr.normal_i2c[0], u_i2c_addr.normal_i2c[1]);
+
+	hv_keypad_driver.detect = tkey_detect;
+	
+	ret = i2c_add_driver(&hv_keypad_driver);
+
+	return ret;
+}
+
+static void __exit hv_keypad_exit(void)
+{
+	i2c_del_driver(&hv_keypad_driver);
+	return;
+}
+module_init(hv_keypad_init);
+module_exit(hv_keypad_exit);
+
+MODULE_AUTHOR("<zhengdixu@allwinnertech.com>");
+MODULE_DESCRIPTION("hv keypad driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/keyboard/hv2605.h b/drivers/input/keyboard/hv2605.h
new file mode 100644
index 0000000..9b582ae
--- /dev/null
+++ b/drivers/input/keyboard/hv2605.h
@@ -0,0 +1,41 @@
+/*
+ * drivers/input/keyboard/hv2605.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LINUX_HV_KEYPAD_H__
+#define __LINUX_HV_KEYPAD_H__
+
+
+
+#define HV_NAME	"hv_keypad"
+
+struct hv_keypad_platform_data{
+	u16	intr;		/* irq number	*/
+};
+
+#define PIO_BASE_ADDRESS (0xf1c20800)
+#define PIOA_CFG1_REG    (PIO_BASE_ADDRESS+0x4)
+#define PIOA_DATA        (PIO_BASE_ADDRESS+0x10)  
+#define DELAY_PERIOD     (5)
+
+
+#endif //__LINUX_HV_KEYPAD_H__
+
diff --git a/drivers/input/keyboard/ir-keymap.h b/drivers/input/keyboard/ir-keymap.h
new file mode 100644
index 0000000..d813311
--- /dev/null
+++ b/drivers/input/keyboard/ir-keymap.h
@@ -0,0 +1,573 @@
+/*
+ * drivers/input/keyboard/ir-keymap.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __IR_KEYMAP_H__
+
+#define __IR_KEYMAP_H__
+
+
+/*IR IO Mapping Config*/
+//0--PIOB10, 1--PIOB17
+#define IR_IO_MAPPING			1
+
+/*IR Key Match Config*/
+//#define IR_CHECK_ADDR_CODE  
+#define IR_ADDR_CODE		(0x7f80) //(addr|((~addr)<<8))
+//#define INPUT_VALUE_MAPPING
+
+/*
+0x0d -- KEY_ESC
+0x12 -- KEY_UP
+0x18 -- KEY_DOWN
+0x16 -- KEY_LEFT
+0x14 -- KEY_RIGHT
+0x15 -- KEY_ENTER
+0x1F -- KEY_VOLUMEDOWN
+0x1E -- KEY_VOLUMEUP
+0x00 -- KEY_POWER
+
+*/
+#ifdef INPUT_VALUE_MAPPING
+static const unsigned int ir_keycodes[]=
+{
+	[0x00] = KEY_POWER,		
+	[0x01] = KEY_RESERVED,			
+	[0x02] = KEY_RESERVED,			
+	[0x03] = KEY_RESERVED,				
+	[0x04] = KEY_RESERVED,			
+	[0x05] = KEY_RESERVED,			
+	[0x06] = KEY_RESERVED,			
+	[0x07] = KEY_RESERVED,	
+	[0x08] = KEY_RESERVED,		
+	[0x09] = KEY_RESERVED,			
+	[0x0A] = KEY_RESERVED,			
+	[0x0B] = KEY_RESERVED,				
+	[0x0C] = KEY_RESERVED,			
+	[0x0D] = KEY_ESC,			
+	[0x0E] = KEY_RESERVED,			
+	[0x0F] = KEY_RESERVED,	
+	[0x10] = KEY_RESERVED,		
+	[0x11] = KEY_RESERVED,			
+	[0x12] = KEY_UP,			
+	[0x13] = KEY_RESERVED,				
+	[0x14] = KEY_RIGHT,			
+	[0x15] = KEY_ENTER,			
+	[0x16] = KEY_LEFT,			
+	[0x17] = KEY_RESERVED,	
+	[0x18] = KEY_DOWN,		
+	[0x19] = KEY_RESERVED,			
+	[0x1A] = KEY_RESERVED,			
+	[0x1B] = KEY_RESERVED,				
+	[0x1C] = KEY_RESERVED,			
+	[0x1D] = KEY_RESERVED,			
+	[0x1E] = KEY_VOLUMEUP,			
+	[0x1F] = KEY_VOLUMEDOWN,	
+	[0x20] = KEY_RESERVED,		
+	[0x21] = KEY_RESERVED,			
+	[0x22] = KEY_RESERVED,			
+	[0x23] = KEY_RESERVED,				
+	[0x24] = KEY_RESERVED,			
+	[0x25] = KEY_RESERVED,			
+	[0x26] = KEY_RESERVED,			
+	[0x27] = KEY_RESERVED,	
+	[0x28] = KEY_RESERVED,		
+	[0x29] = KEY_RESERVED,			
+	[0x2A] = KEY_RESERVED,			
+	[0x2B] = KEY_RESERVED,				
+	[0x2C] = KEY_RESERVED,			
+	[0x2D] = KEY_RESERVED,			
+	[0x2E] = KEY_RESERVED,			
+	[0x2F] = KEY_RESERVED,	
+	[0x30] = KEY_RESERVED,		
+	[0x31] = KEY_RESERVED,			
+	[0x32] = KEY_RESERVED,			
+	[0x33] = KEY_RESERVED,				
+	[0x34] = KEY_RESERVED,			
+	[0x35] = KEY_RESERVED,			
+	[0x36] = KEY_RESERVED,			
+	[0x37] = KEY_RESERVED,	
+	[0x38] = KEY_RESERVED,		
+	[0x39] = KEY_RESERVED,			
+	[0x3A] = KEY_RESERVED,			
+	[0x3B] = KEY_RESERVED,				
+	[0x3C] = KEY_RESERVED,			
+	[0x3D] = KEY_RESERVED,			
+	[0x3E] = KEY_RESERVED,			
+	[0x3F] = KEY_RESERVED,	
+	[0x40] = KEY_RESERVED,		
+	[0x41] = KEY_RESERVED,			
+	[0x42] = KEY_RESERVED,			
+	[0x43] = KEY_RESERVED,				
+	[0x44] = KEY_RESERVED,			
+	[0x45] = KEY_RESERVED,			
+	[0x46] = KEY_RESERVED,			
+	[0x47] = KEY_RESERVED,	
+	[0x48] = KEY_RESERVED,		
+	[0x49] = KEY_RESERVED,			
+	[0x4A] = KEY_RESERVED,			
+	[0x4B] = KEY_RESERVED,				
+	[0x4C] = KEY_RESERVED,			
+	[0x4D] = KEY_RESERVED,			
+	[0x4E] = KEY_RESERVED,			
+	[0x4F] = KEY_RESERVED,	
+	[0x50] = KEY_RESERVED,		
+	[0x51] = KEY_RESERVED,			
+	[0x52] = KEY_RESERVED,			
+	[0x53] = KEY_RESERVED,				
+	[0x54] = KEY_RESERVED,			
+	[0x55] = KEY_RESERVED,			
+	[0x56] = KEY_RESERVED,			
+	[0x57] = KEY_RESERVED,	
+	[0x58] = KEY_RESERVED,		
+	[0x59] = KEY_RESERVED,			
+	[0x5A] = KEY_RESERVED,			
+	[0x5B] = KEY_RESERVED,				
+	[0x5C] = KEY_RESERVED,			
+	[0x5D] = KEY_RESERVED,			
+	[0x5E] = KEY_RESERVED,			
+	[0x5F] = KEY_RESERVED,	
+	[0x60] = KEY_RESERVED,		
+	[0x61] = KEY_RESERVED,			
+	[0x62] = KEY_RESERVED,			
+	[0x63] = KEY_RESERVED,				
+	[0x64] = KEY_RESERVED,			
+	[0x65] = KEY_RESERVED,			
+	[0x66] = KEY_RESERVED,			
+	[0x67] = KEY_RESERVED,	
+	[0x68] = KEY_RESERVED,		
+	[0x69] = KEY_RESERVED,			
+	[0x6A] = KEY_RESERVED,			
+	[0x6B] = KEY_RESERVED,				
+	[0x6C] = KEY_RESERVED,			
+	[0x6D] = KEY_RESERVED,			
+	[0x6E] = KEY_RESERVED,			
+	[0x6F] = KEY_RESERVED,	
+	[0x70] = KEY_RESERVED,		
+	[0x71] = KEY_RESERVED,			
+	[0x72] = KEY_RESERVED,			
+	[0x73] = KEY_RESERVED,				
+	[0x74] = KEY_RESERVED,			
+	[0x75] = KEY_RESERVED,			
+	[0x76] = KEY_RESERVED,			
+	[0x77] = KEY_RESERVED,	
+	[0x78] = KEY_RESERVED,		
+	[0x79] = KEY_RESERVED,			
+	[0x7A] = KEY_RESERVED,			
+	[0x7B] = KEY_RESERVED,				
+	[0x7C] = KEY_RESERVED,			
+	[0x7D] = KEY_RESERVED,			
+	[0x7E] = KEY_RESERVED,			
+	[0x7F] = KEY_RESERVED,
+	[0x80] = KEY_RESERVED,		
+	[0x81] = KEY_RESERVED,			
+	[0x82] = KEY_RESERVED,			
+	[0x83] = KEY_RESERVED,				
+	[0x84] = KEY_RESERVED,			
+	[0x85] = KEY_RESERVED,			
+	[0x86] = KEY_RESERVED,			
+	[0x87] = KEY_RESERVED,	
+	[0x88] = KEY_RESERVED,		
+	[0x89] = KEY_RESERVED,			
+	[0x8A] = KEY_RESERVED,			
+	[0x8B] = KEY_RESERVED,				
+	[0x8C] = KEY_RESERVED,			
+	[0x8D] = KEY_RESERVED,			
+	[0x8E] = KEY_RESERVED,			
+	[0x8F] = KEY_RESERVED,	
+	[0x90] = KEY_RESERVED,		
+	[0x91] = KEY_RESERVED,			
+	[0x92] = KEY_RESERVED,			
+	[0x93] = KEY_RESERVED,				
+	[0x94] = KEY_RESERVED,			
+	[0x95] = KEY_RESERVED,			
+	[0x96] = KEY_RESERVED,			
+	[0x97] = KEY_RESERVED,	
+	[0x98] = KEY_RESERVED,		
+	[0x99] = KEY_RESERVED,			
+	[0x9A] = KEY_RESERVED,			
+	[0x9B] = KEY_RESERVED,				
+	[0x9C] = KEY_RESERVED,			
+	[0x9D] = KEY_RESERVED,			
+	[0x9E] = KEY_RESERVED,			
+	[0x9F] = KEY_RESERVED,	
+	[0xA0] = KEY_RESERVED,		
+	[0xA1] = KEY_RESERVED,			
+	[0xA2] = KEY_RESERVED,			
+	[0xA3] = KEY_RESERVED,				
+	[0xA4] = KEY_RESERVED,			
+	[0xA5] = KEY_RESERVED,			
+	[0xA6] = KEY_RESERVED,			
+	[0xA7] = KEY_RESERVED,	
+	[0xA8] = KEY_RESERVED,		
+	[0xA9] = KEY_RESERVED,			
+	[0xAA] = KEY_RESERVED,			
+	[0xAB] = KEY_RESERVED,				
+	[0xAC] = KEY_RESERVED,			
+	[0xAD] = KEY_RESERVED,			
+	[0xAE] = KEY_RESERVED,			
+	[0xAF] = KEY_RESERVED,	
+	[0xB0] = KEY_RESERVED,		
+	[0xB1] = KEY_RESERVED,			
+	[0xB2] = KEY_RESERVED,			
+	[0xB3] = KEY_RESERVED,				
+	[0xB4] = KEY_RESERVED,			
+	[0xB5] = KEY_RESERVED,			
+	[0xB6] = KEY_RESERVED,			
+	[0xB7] = KEY_RESERVED,	
+	[0xB8] = KEY_RESERVED,		
+	[0xB9] = KEY_RESERVED,			
+	[0xBA] = KEY_RESERVED,			
+	[0xBB] = KEY_RESERVED,				
+	[0xBC] = KEY_RESERVED,			
+	[0xBD] = KEY_RESERVED,			
+	[0xBE] = KEY_RESERVED,			
+	[0xBF] = KEY_RESERVED,	
+	[0xC0] = KEY_RESERVED,		
+	[0xC1] = KEY_RESERVED,			
+	[0xC2] = KEY_RESERVED,			
+	[0xC3] = KEY_RESERVED,				
+	[0xC4] = KEY_RESERVED,			
+	[0xC5] = KEY_RESERVED,			
+	[0xC6] = KEY_RESERVED,			
+	[0xC7] = KEY_RESERVED,	
+	[0xC8] = KEY_RESERVED,		
+	[0xC9] = KEY_RESERVED,			
+	[0xCA] = KEY_RESERVED,			
+	[0xCB] = KEY_RESERVED,				
+	[0xCC] = KEY_RESERVED,			
+	[0xCD] = KEY_RESERVED,			
+	[0xCE] = KEY_RESERVED,			
+	[0xCF] = KEY_RESERVED,	
+	[0xD0] = KEY_RESERVED,		
+	[0xD1] = KEY_RESERVED,			
+	[0xD2] = KEY_RESERVED,			
+	[0xD3] = KEY_RESERVED,				
+	[0xD4] = KEY_RESERVED,			
+	[0xD5] = KEY_RESERVED,			
+	[0xD6] = KEY_RESERVED,			
+	[0xD7] = KEY_RESERVED,	
+	[0xD8] = KEY_RESERVED,		
+	[0xD9] = KEY_RESERVED,			
+	[0xDA] = KEY_RESERVED,			
+	[0xDB] = KEY_RESERVED,				
+	[0xDC] = KEY_RESERVED,			
+	[0xDD] = KEY_RESERVED,			
+	[0xDE] = KEY_RESERVED,			
+	[0xDF] = KEY_RESERVED,	
+	[0xE0] = KEY_RESERVED,		
+	[0xE1] = KEY_RESERVED,			
+	[0xE2] = KEY_RESERVED,			
+	[0xE3] = KEY_RESERVED,				
+	[0xE4] = KEY_RESERVED,			
+	[0xE5] = KEY_RESERVED,			
+	[0xE6] = KEY_RESERVED,			
+	[0xE7] = KEY_RESERVED,	
+	[0xE8] = KEY_RESERVED,		
+	[0xE9] = KEY_RESERVED,			
+	[0xEA] = KEY_RESERVED,			
+	[0xEB] = KEY_RESERVED,				
+	[0xEC] = KEY_RESERVED,			
+	[0xED] = KEY_RESERVED,			
+	[0xEE] = KEY_RESERVED,			
+	[0xEF] = KEY_RESERVED,	
+	[0xF0] = KEY_RESERVED,		
+	[0xF1] = KEY_RESERVED,			
+	[0xF2] = KEY_RESERVED,			
+	[0xF3] = KEY_RESERVED,				
+	[0xF4] = KEY_RESERVED,			
+	[0xF5] = KEY_RESERVED,			
+	[0xF6] = KEY_RESERVED,			
+	[0xF7] = KEY_RESERVED,	
+	[0xF8] = KEY_RESERVED,		
+	[0xF9] = KEY_RESERVED,			
+	[0xFA] = KEY_RESERVED,			
+	[0xFB] = KEY_RESERVED,				
+	[0xFC] = KEY_RESERVED,			
+	[0xFD] = KEY_RESERVED,			
+	[0xFE] = KEY_RESERVED,			
+	[0xFF] = KEY_RESERVED				
+};
+#else
+static const unsigned int ir_keycodes[]=
+{
+	[0x00] = 0xff,
+	[0x01] = 0x01,	
+	[0x02] = 0x02,	
+	[0x03] = 0x03,		
+	[0x04] = 0x04,	
+	[0x05] = 0x05,	
+	[0x06] = 0x06,	
+	[0x07] = 0x07,
+	[0x08] = 0x08,
+	[0x09] = 0x09,	
+	[0x0A] = 0x0A,	
+	[0x0B] = 0x0B,		
+	[0x0C] = 0x0C,	
+	[0x0D] = 0x0D,
+	[0x0E] = 0x0E,	
+	[0x0F] = 0x0F,
+	[0x10] = 0x10,
+	[0x11] = 0x11,	
+	[0x12] = 0x12,
+	[0x13] = 0x13,		
+	[0x14] = 0x14,
+	[0x15] = 0x15,
+	[0x16] = 0x16,
+	[0x17] = 0x17,
+	[0x18] = 0x18,
+	[0x19] = 0x19,	
+	[0x1A] = 0x1A,	
+	[0x1B] = 0x1B,		
+	[0x1C] = 0x1C,	
+	[0x1D] = 0x1D,	
+	[0x1E] = 0x1E,	
+	[0x1F] = 0x1F,	
+	[0x20] = 0x20,
+	[0x21] = 0x21,	
+	[0x22] = 0x22,	
+	[0x23] = 0x23,		
+	[0x24] = 0x24,	
+	[0x25] = 0x25,	
+	[0x26] = 0x26,	
+	[0x27] = 0x27,
+	[0x28] = 0x28,
+	[0x29] = 0x29,	
+	[0x2A] = 0x2A,	
+	[0x2B] = 0x2B,		
+	[0x2C] = 0x2C,	
+	[0x2D] = 0x2D,	
+	[0x2E] = 0x2E,	
+	[0x2F] = 0x2F,
+	[0x30] = 0x30,
+	[0x31] = 0x31,	
+	[0x32] = 0x32,	
+	[0x33] = 0x33,		
+	[0x34] = 0x34,	
+	[0x35] = 0x35,	
+	[0x36] = 0x36,	
+	[0x37] = 0x37,
+	[0x38] = 0x38,
+	[0x39] = 0x39,	
+	[0x3A] = 0x3A,	
+	[0x3B] = 0x3B,		
+	[0x3C] = 0x3C,	
+	[0x3D] = 0x3D,	
+	[0x3E] = 0x3E,	
+	[0x3F] = 0x3F,
+	[0x40] = 0x40,
+	[0x41] = 0x41,	
+	[0x42] = 0x42,	
+	[0x43] = 0x43,		
+	[0x44] = 0x44,	
+	[0x45] = 0x45,	
+	[0x46] = 0x46,	
+	[0x47] = 0x47,
+	[0x48] = 0x48,
+	[0x49] = 0x49,	
+	[0x4A] = 0x4A,	
+	[0x4B] = 0x4B,		
+	[0x4C] = 0x4C,	
+	[0x4D] = 0x4D,	
+	[0x4E] = 0x4E,	
+	[0x4F] = 0x4F,
+	[0x50] = 0x50,
+	[0x51] = 0x51,	
+	[0x52] = 0x52,	
+	[0x53] = 0x53,		
+	[0x54] = 0x54,	
+	[0x55] = 0x55,	
+	[0x56] = 0x56,	
+	[0x57] = 0x57,
+	[0x58] = 0x58,
+	[0x59] = 0x59,	
+	[0x5A] = 0x5A,	
+	[0x5B] = 0x5B,		
+	[0x5C] = 0x5C,	
+	[0x5D] = 0x5D,	
+	[0x5E] = 0x5E,	
+	[0x5F] = 0x5F,
+	[0x60] = 0x60,
+	[0x61] = 0x61,	
+	[0x62] = 0x62,	
+	[0x63] = 0x63,		
+	[0x64] = 0x64,	
+	[0x65] = 0x65,	
+	[0x66] = 0x66,	
+	[0x67] = 0x67,
+	[0x68] = 0x68,
+	[0x69] = 0x69,	
+	[0x6A] = 0x6A,	
+	[0x6B] = 0x6B,		
+	[0x6C] = 0x6C,	
+	[0x6D] = 0x6D,	
+	[0x6E] = 0x6E,	
+	[0x6F] = 0x6F,
+	[0x70] = 0x70,
+	[0x71] = 0x71,	
+	[0x72] = 0x72,	
+	[0x73] = 0x73,		
+	[0x74] = 0x74,	
+	[0x75] = 0x75,	
+	[0x76] = 0x76,	
+	[0x77] = 0x77,
+	[0x78] = 0x78,
+	[0x79] = 0x79,	
+	[0x7A] = 0x7A,	
+	[0x7B] = 0x7B,		
+	[0x7C] = 0x7C,	
+	[0x7D] = 0x7D,	
+	[0x7E] = 0x7E,	
+	[0x7F] = 0x7F,
+	[0x80] = 0x80,
+	[0x81] = 0x81,	
+	[0x82] = 0x82,	
+	[0x83] = 0x83,		
+	[0x84] = 0x84,	
+	[0x85] = 0x85,	
+	[0x86] = 0x86,	
+	[0x87] = 0x87,
+	[0x88] = 0x88,
+	[0x89] = 0x89,	
+	[0x8A] = 0x8A,	
+	[0x8B] = 0x8B,		
+	[0x8C] = 0x8C,	
+	[0x8D] = 0x8D,	
+	[0x8E] = 0x8E,	
+	[0x8F] = 0x8F,
+	[0x90] = 0x90,
+	[0x91] = 0x91,	
+	[0x92] = 0x92,	
+	[0x93] = 0x93,		
+	[0x94] = 0x94,	
+	[0x95] = 0x95,	
+	[0x96] = 0x96,	
+	[0x97] = 0x97,
+	[0x98] = 0x98,
+	[0x99] = 0x99,	
+	[0x9A] = 0x9A,	
+	[0x9B] = 0x9B,		
+	[0x9C] = 0x9C,	
+	[0x9D] = 0x9D,	
+	[0x9E] = 0x9E,	
+	[0x9F] = 0x9F,
+	[0xA0] = 0xA0,
+	[0xA1] = 0xA1,	
+	[0xA2] = 0xA2,	
+	[0xA3] = 0xA3,		
+	[0xA4] = 0xA4,	
+	[0xA5] = 0xA5,	
+	[0xA6] = 0xA6,	
+	[0xA7] = 0xA7,
+	[0xA8] = 0xA8,
+	[0xA9] = 0xA9,	
+	[0xAA] = 0xAA,	
+	[0xAB] = 0xAB,		
+	[0xAC] = 0xAC,	
+	[0xAD] = 0xAD,	
+	[0xAE] = 0xAE,	
+	[0xAF] = 0xAF,
+	[0xB0] = 0xB0,
+	[0xB1] = 0xB1,	
+	[0xB2] = 0xB2,	
+	[0xB3] = 0xB3,		
+	[0xB4] = 0xB4,	
+	[0xB5] = 0xB5,	
+	[0xB6] = 0xB6,	
+	[0xB7] = 0xB7,
+	[0xB8] = 0xB8,
+	[0xB9] = 0xB9,	
+	[0xBA] = 0xBA,	
+	[0xBB] = 0xBB,		
+	[0xBC] = 0xBC,	
+	[0xBD] = 0xBD,	
+	[0xBE] = 0xBE,	
+	[0xBF] = 0xBF,
+	[0xC0] = 0xC0,
+	[0xC1] = 0xC1,	
+	[0xC2] = 0xC2,	
+	[0xC3] = 0xC3,		
+	[0xC4] = 0xC4,	
+	[0xC5] = 0xC5,	
+	[0xC6] = 0xC6,	
+	[0xC7] = 0xC7,
+	[0xC8] = 0xC8,
+	[0xC9] = 0xC9,	
+	[0xCA] = 0xCA,	
+	[0xCB] = 0xCB,		
+	[0xCC] = 0xCC,	
+	[0xCD] = 0xCD,	
+	[0xCE] = 0xCE,	
+	[0xCF] = 0xCF,
+	[0xD0] = 0xD0,
+	[0xD1] = 0xD1,	
+	[0xD2] = 0xD2,	
+	[0xD3] = 0xD3,		
+	[0xD4] = 0xD4,	
+	[0xD5] = 0xD5,	
+	[0xD6] = 0xD6,	
+	[0xD7] = 0xD7,
+	[0xD8] = 0xD8,
+	[0xD9] = 0xD9,	
+	[0xDA] = 0xDA,	
+	[0xDB] = 0xDB,		
+	[0xDC] = 0xDC,	
+	[0xDD] = 0xDD,	
+	[0xDE] = 0xDE,	
+	[0xDF] = 0xDF,
+	[0xE0] = 0xE0,
+	[0xE1] = 0xE1,	
+	[0xE2] = 0xE2,	
+	[0xE3] = 0xE3,		
+	[0xE4] = 0xE4,	
+	[0xE5] = 0xE5,	
+	[0xE6] = 0xE6,	
+	[0xE7] = 0xE7,
+	[0xE8] = 0xE8,
+	[0xE9] = 0xE9,	
+	[0xEA] = 0xEA,	
+	[0xEB] = 0xEB,		
+	[0xEC] = 0xEC,	
+	[0xED] = 0xED,	
+	[0xEE] = 0xEE,	
+	[0xEF] = 0xEF,
+	[0xF0] = 0xF0,
+	[0xF1] = 0xF1,	
+	[0xF2] = 0xF2,	
+	[0xF3] = 0xF3,		
+	[0xF4] = 0xF4,	
+	[0xF5] = 0xF5,	
+	[0xF6] = 0xF6,	
+	[0xF7] = 0xF7,
+	[0xF8] = 0xF8,
+	[0xF9] = 0xF9,	
+	[0xFA] = 0xFA,	
+	[0xFB] = 0xFB,		
+	[0xFC] = 0xFC,	
+	[0xFD] = 0xFD,	
+	[0xFE] = 0xFE,	
+	[0xFF] = 0xFF     	
+};
+
+#endif
+
+#endif /*__IR_KEYMAP_H__*/
diff --git a/drivers/input/keyboard/sun4i-keyboard.c b/drivers/input/keyboard/sun4i-keyboard.c
new file mode 100644
index 0000000..74869e1
--- /dev/null
+++ b/drivers/input/keyboard/sun4i-keyboard.c
@@ -0,0 +1,458 @@
+/*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+*
+* Copyright (c) 2011
+*
+* ChangeLog
+*
+*
+*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/keyboard.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/timer.h>
+#include <plat/sys_config.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    #include <linux/pm.h>
+    #include <linux/earlysuspend.h>
+#endif
+//#define  KEY_DEBUG
+//#define  KEY_DEBUG_LEVEL2
+#define  PRINT_SUSPEND_INFO
+
+#define  KEY_MAX_CNT  		(13)
+
+#define  KEY_BASSADDRESS	(0xf1c22800)
+#define  LRADC_CTRL		(0x00)
+#define  LRADC_INTC		(0x04)
+#define  LRADC_INT_STA 		(0x08)
+#define  LRADC_DATA0		(0x0c)
+#define  LRADC_DATA1		(0x10)
+
+#define  FIRST_CONCERT_DLY		(2<<24)
+#define  CHAN				(0x3)
+#define  ADC_CHAN_SELECT		(CHAN<<22)
+#define  LRADC_KEY_MODE		(0)
+#define  KEY_MODE_SELECT		(LRADC_KEY_MODE<<12)
+#define  LEVELB_VOL			(0<<4)
+
+#define  LRADC_HOLD_EN		(1<<6)
+
+#define  LRADC_SAMPLE_32HZ		(3<<2)
+#define  LRADC_SAMPLE_62HZ		(2<<2)
+#define  LRADC_SAMPLE_125HZ		(1<<2)
+#define  LRADC_SAMPLE_250HZ		(0<<2)
+
+
+#define  LRADC_EN			(1<<0)
+
+#define  LRADC_ADC1_UP_EN		(1<<12)
+#define  LRADC_ADC1_DOWN_EN		(1<<9)
+#define  LRADC_ADC1_DATA_EN		(1<<8)
+
+#define  LRADC_ADC0_UP_EN		(1<<4)
+#define  LRADC_ADC0_DOWN_EN		(1<<1)
+#define  LRADC_ADC0_DATA_EN		(1<<0)
+
+#define  LRADC_ADC1_UPPEND		(1<<12)
+#define  LRADC_ADC1_DOWNPEND	(1<<9)
+#define  LRADC_ADC1_DATAPEND		(1<<8)
+
+
+#define  LRADC_ADC0_UPPEND 		(1<<4)
+#define  LRADC_ADC0_DOWNPEND	(1<<1)
+#define  LRADC_ADC0_DATAPEND		(1<<0)
+
+#define EVB
+//#define CUSTUM
+#define ONE_CHANNEL
+#define MODE_0V2
+//#define MODE_0V15
+//#define TWO_CHANNEL
+#ifdef MODE_0V2
+//standard of key maping
+//0.2V mode
+
+#define REPORT_START_NUM			(5)
+#define REPORT_KEY_LOW_LIMIT_COUNT		(3)
+#define MAX_CYCLE_COUNTER			(100)
+//#define REPORT_REPEAT_KEY_BY_INPUT_CORE
+//#define REPORT_REPEAT_KEY_FROM_HW
+#define INITIAL_VALUE				(0Xff)
+
+static unsigned char keypad_mapindex[64] =
+{
+    0,0,0,0,0,0,0,0,               //key 1, 8ä¸ªï¼ 0-7
+    1,1,1,1,1,1,1,                 //key 2, 7ä¸ªï¼ 8-14
+    2,2,2,2,2,2,2,                 //key 3, 7ä¸ªï¼ 15-21
+    3,3,3,3,3,3,                   //key 4, 6ä¸ªï¼ 22-27
+    4,4,4,4,4,4,                   //key 5, 6ä¸ªï¼ 28-33
+    5,5,5,5,5,5,                   //key 6, 6ä¸ªï¼ 34-39
+    6,6,6,6,6,6,6,6,6,6,           //key 7, 10ä¸ªï¼40-49
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7    //key 8, 17ä¸ªï¼50-63
+};
+#endif
+
+#ifdef MODE_0V15
+//0.15V mode
+static unsigned char keypad_mapindex[64] =
+{
+	0,0,0,                      //key1
+	1,1,1,1,1,                  //key2
+	2,2,2,2,2,
+	3,3,3,3,
+	4,4,4,4,4,
+	5,5,5,5,5,
+	6,6,6,6,6,
+	7,7,7,7,
+	8,8,8,8,8,
+	9,9,9,9,9,
+	10,10,10,10,
+	11,11,11,11,
+	12,12,12,12,12,12,12,12,12,12 //key13
+};
+#endif
+
+#ifdef EVB
+static unsigned int sun4i_scankeycodes[KEY_MAX_CNT]=
+{
+	[0 ] = KEY_VOLUMEUP,
+	[1 ] = KEY_VOLUMEDOWN,
+	[2 ] = KEY_MENU,
+	[3 ] = KEY_SEARCH,
+	[4 ] = KEY_HOME,
+	[5 ] = KEY_ESC,
+	[6 ] = KEY_ENTER,
+	[7 ] = KEY_RESERVED,
+	[8 ] = KEY_RESERVED,
+	[9 ] = KEY_RESERVED,
+	[10] = KEY_RESERVED,
+	[11] = KEY_RESERVED,
+	[12] = KEY_RESERVED,
+};
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+struct sun4i_keyboard_data {
+    struct early_suspend early_suspend;
+};
+#endif
+
+static volatile unsigned int key_val;
+static struct input_dev *sun4ikbd_dev;
+static unsigned char scancode;
+
+static unsigned char key_cnt = 0;
+static unsigned char cycle_buffer[REPORT_START_NUM] = {0};
+static unsigned char transfer_code = INITIAL_VALUE;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct sun4i_keyboard_data *keyboard_data;
+#endif
+
+//åç¨è®¾å¤
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sun4i_keyboard_suspend(struct early_suspend *h)
+{
+	/*int ret;
+	struct sun4i_keyboard_data *ts = container_of(h, struct sun4i_keyboard_data, early_suspend);
+      */
+    #ifdef PRINT_SUSPEND_INFO
+        printk("enter earlysuspend: sun4i_keyboard_suspend. \n");
+    #endif
+
+    writel(0,KEY_BASSADDRESS + LRADC_CTRL);
+	return ;
+}
+
+//éæ°å¤é
+static void sun4i_keyboard_resume(struct early_suspend *h)
+{
+/*int ret;
+	struct sun4i_keyboard_data *ts = container_of(h, struct sun4i_keyboard_data, early_suspend);
+*/
+#ifdef PRINT_SUSPEND_INFO
+	printk("enter laterresume: sun4i_keyboard_resume. \n");
+#endif
+
+	writel(FIRST_CONCERT_DLY|LEVELB_VOL|KEY_MODE_SELECT|LRADC_HOLD_EN|ADC_CHAN_SELECT|LRADC_SAMPLE_62HZ|LRADC_EN,KEY_BASSADDRESS + LRADC_CTRL);
+	return ;
+}
+#else
+
+#endif
+
+
+static irqreturn_t sun4i_isr_key(int irq, void *dummy)
+{
+	unsigned int  reg_val;
+	int judge_flag = 0;
+	int loop = 0;
+
+	#ifdef KEY_DEBUG
+	    printk("Key Interrupt\n");
+  	#endif
+	reg_val  = readl(KEY_BASSADDRESS + LRADC_INT_STA);
+	//writel(reg_val,KEY_BASSADDRESS + LRADC_INT_STA);
+	if(reg_val&LRADC_ADC0_DOWNPEND)
+	{
+		#ifdef KEY_DEBUG
+		    printk("key down\n");
+		#endif
+	}
+
+	if(reg_val&LRADC_ADC0_DATAPEND)
+	{
+		key_val = readl(KEY_BASSADDRESS+LRADC_DATA0);
+		if(key_val < 0x3f)
+		{
+		/*key_val = readl(KEY_BASSADDRESS + LRADC_DATA0);
+		cancode = keypad_mapindex[key_val&0x3f];
+#ifdef KEY_DEBUG
+		printk("raw data: key_val == %u , scancode == %u \n", key_val, scancode);
+#endif
+		*/
+		cycle_buffer[key_cnt%REPORT_START_NUM] = key_val&0x3f;
+		if((key_cnt + 1) < REPORT_START_NUM)
+		{
+			//do not report key message
+
+		}else{
+			//scancode = cycle_buffer[(key_cnt-2)%REPORT_START_NUM];
+			if(cycle_buffer[(key_cnt - REPORT_START_NUM + 1)%REPORT_START_NUM] \
+			== cycle_buffer[(key_cnt - REPORT_START_NUM + 2)%REPORT_START_NUM])
+			{
+			key_val = cycle_buffer[(key_cnt - REPORT_START_NUM + 1)%REPORT_START_NUM];
+			scancode = keypad_mapindex[key_val&0x3f];
+			judge_flag = 1;
+
+			}
+			if((!judge_flag) && cycle_buffer[(key_cnt - REPORT_START_NUM + 4)%REPORT_START_NUM] \
+			== cycle_buffer[(key_cnt - REPORT_START_NUM + 5)%REPORT_START_NUM])
+			{
+			key_val = cycle_buffer[(key_cnt - REPORT_START_NUM + 5)%REPORT_START_NUM];
+			scancode = keypad_mapindex[key_val&0x3f];
+			judge_flag = 1;
+
+			}
+			if(1 == judge_flag)
+			{
+#ifdef KEY_DEBUG_LEVEL2
+				printk("report data: key_val :%8d transfer_code: %8d , scancode: %8d\n",\
+				key_val, transfer_code, scancode);
+#endif
+
+				if(transfer_code == scancode){
+				//report repeat key value
+#ifdef REPORT_REPEAT_KEY_FROM_HW
+				input_report_key(sun4ikbd_dev, sun4i_scankeycodes[scancode], 0);
+				input_sync(sun4ikbd_dev);
+				input_report_key(sun4ikbd_dev, sun4i_scankeycodes[scancode], 1);
+				input_sync(sun4ikbd_dev);
+#else
+				//do not report key value
+#endif
+				}else if(INITIAL_VALUE != transfer_code){
+				//report previous key value up signal + report current key value down
+				input_report_key(sun4ikbd_dev, sun4i_scankeycodes[transfer_code], 0);
+				input_sync(sun4ikbd_dev);
+				input_report_key(sun4ikbd_dev, sun4i_scankeycodes[scancode], 1);
+				input_sync(sun4ikbd_dev);
+				transfer_code = scancode;
+
+				}else{
+				//INITIAL_VALUE == transfer_code, first time to report key event
+				input_report_key(sun4ikbd_dev, sun4i_scankeycodes[scancode], 1);
+				input_sync(sun4ikbd_dev);
+				transfer_code = scancode;
+				}
+
+			}
+
+			}
+			key_cnt++;
+			if(key_cnt > 2 * MAX_CYCLE_COUNTER ){
+			key_cnt -= MAX_CYCLE_COUNTER;
+			}
+
+		}
+	}
+
+	if(reg_val&LRADC_ADC0_UPPEND)
+	{
+		if(key_cnt > REPORT_START_NUM)
+		{
+			if(INITIAL_VALUE != transfer_code)
+			{
+#ifdef KEY_DEBUG_LEVEL2
+			printk("report data: key_val :%8d transfer_code: %8d \n",key_val, transfer_code);
+#endif
+			input_report_key(sun4ikbd_dev, sun4i_scankeycodes[transfer_code], 0);
+			input_sync(sun4ikbd_dev);
+			}
+
+		}else if((key_cnt + 1) >= REPORT_KEY_LOW_LIMIT_COUNT){
+			//rely on hardware first_delay work, need to be verified!
+			if(cycle_buffer[0] == cycle_buffer[1]){
+				key_val = cycle_buffer[0];
+				scancode = keypad_mapindex[key_val&0x3f];
+#ifdef KEY_DEBUG_LEVEL2
+				printk("report data: key_val :%8d scancode: %8d \n",key_val, scancode);
+#endif
+				input_report_key(sun4ikbd_dev, sun4i_scankeycodes[scancode], 1);
+				input_sync(sun4ikbd_dev);
+				input_report_key(sun4ikbd_dev, sun4i_scankeycodes[scancode], 0);
+				input_sync(sun4ikbd_dev);
+			}
+
+		}
+
+#ifdef KEY_DEBUG
+		printk("key up \n");
+#endif
+
+		key_cnt = 0;
+		judge_flag = 0;
+		transfer_code = INITIAL_VALUE;
+		for(loop = 0; loop < REPORT_START_NUM; loop++)
+		{
+			cycle_buffer[loop] = 0;
+		}
+
+	}
+
+	writel(reg_val,KEY_BASSADDRESS + LRADC_INT_STA);
+	return IRQ_HANDLED;
+}
+
+static int __init sun4ikbd_init(void)
+{
+	int i, val, err = 0;
+	char key[16];
+
+#ifdef CONFIG_KEYBOARD_SUN4I_KEYBOARD_FEX
+	err = script_parser_fetch("tabletkeys_para", "tabletkeys_used", &i, 1);
+	if (err != 0 || i == 0)
+		return -ENODEV;
+
+	for (i = 0; i < KEY_MAX_CNT; i++) {
+		snprintf(key, sizeof(key), "key%d_code", i);
+		err = script_parser_fetch("tabletkeys_para", key, &val, 1);
+		if (err == 0)
+			sun4i_scankeycodes[i] = val;
+	}
+#endif
+
+#ifdef KEY_DEBUG
+	printk("sun4ikbd_init \n");
+#endif
+	sun4ikbd_dev = input_allocate_device();
+	if (!sun4ikbd_dev) {
+		printk(KERN_ERR "sun4ikbd: not enough memory for input device\n");
+		err = -ENOMEM;
+		goto fail1;
+	}
+
+	sun4ikbd_dev->name = "sun4i-keyboard";
+	sun4ikbd_dev->phys = "sun4ikbd/input0";
+	sun4ikbd_dev->id.bustype = BUS_HOST;
+	sun4ikbd_dev->id.vendor = 0x0001;
+	sun4ikbd_dev->id.product = 0x0001;
+	sun4ikbd_dev->id.version = 0x0100;
+
+#ifdef REPORT_REPEAT_KEY_BY_INPUT_CORE
+	sun4ikbd_dev->evbit[0] = BIT_MASK(EV_KEY)|BIT_MASK(EV_REP);
+	printk("REPORT_REPEAT_KEY_BY_INPUT_CORE is defined, support report repeat key value. \n");
+#else
+	sun4ikbd_dev->evbit[0] = BIT_MASK(EV_KEY);
+#endif
+
+	for (i = 0; i < KEY_MAX_CNT; i++)
+		set_bit(sun4i_scankeycodes[i], sun4ikbd_dev->keybit);
+
+#ifdef ONE_CHANNEL
+	writel(LRADC_ADC0_DOWN_EN|LRADC_ADC0_UP_EN|LRADC_ADC0_DATA_EN,KEY_BASSADDRESS + LRADC_INTC);
+	writel(FIRST_CONCERT_DLY|LEVELB_VOL|KEY_MODE_SELECT|LRADC_HOLD_EN|ADC_CHAN_SELECT|LRADC_SAMPLE_62HZ|LRADC_EN,KEY_BASSADDRESS + LRADC_CTRL);
+	//writel(FIRST_CONCERT_DLY|LEVELB_VOL|KEY_MODE_SELECT|ADC_CHAN_SELECT|LRADC_SAMPLE_62HZ|LRADC_EN,KEY_BASSADDRESS + LRADC_CTRL);
+
+#else
+#endif
+
+
+	if (request_irq(SW_INT_IRQNO_LRADC, sun4i_isr_key, 0, "sun4ikbd", NULL)){
+		err = -EBUSY;
+		printk("request irq failure. \n");
+		goto fail2;
+	}
+
+	err = input_register_device(sun4ikbd_dev);
+	if (err)
+		goto fail3;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	printk("==register_early_suspend =\n");
+	keyboard_data = kzalloc(sizeof(*keyboard_data), GFP_KERNEL);
+	if (keyboard_data == NULL) {
+		err = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	keyboard_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 3;
+	keyboard_data->early_suspend.suspend = sun4i_keyboard_suspend;
+	keyboard_data->early_suspend.resume	= sun4i_keyboard_resume;
+	register_early_suspend(&keyboard_data->early_suspend);
+#endif
+
+	return 0;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+ err_alloc_data_failed:
+#endif
+ fail3:
+	free_irq(SW_INT_IRQNO_LRADC, sun4i_isr_key);
+ fail2:
+	input_free_device(sun4ikbd_dev);
+ fail1:
+     ;
+#ifdef KEY_DEBUG
+	printk("sun4ikbd_init failed. \n");
+#endif
+
+ return err;
+}
+
+static void __exit sun4ikbd_exit(void)
+{
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	 unregister_early_suspend(&keyboard_data->early_suspend);
+#endif
+	free_irq(SW_INT_IRQNO_LRADC, sun4i_isr_key);
+	input_unregister_device(sun4ikbd_dev);
+}
+
+module_init(sun4ikbd_init);
+module_exit(sun4ikbd_exit);
+
+
+MODULE_AUTHOR(" <@>");
+MODULE_DESCRIPTION("sun4i-keyboard driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/keyboard/sun4i-keypad.c b/drivers/input/keyboard/sun4i-keypad.c
new file mode 100644
index 0000000..5e84c68
--- /dev/null
+++ b/drivers/input/keyboard/sun4i-keypad.c
@@ -0,0 +1,563 @@
+/*
+ * Sun4i keypad driver
+ *
+ * Copyright (C) 2011 Allwinner Co.Ltd
+ * Author: Aaron.maoye <leafy.myeh@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/input/matrix_keypad.h>
+
+#include <mach/clock.h>
+#include <plat/sys_config.h>
+
+//#define AW1623_FPGA
+#define swkp_msg(...)       printk("[kpad]: "__VA_ARGS__);
+
+/* register define */
+#define SW_KP_PBASE         (0x01c23000)
+#define SW_KP_CTL           (0x00)
+#define SW_KP_TIMING       	(0x04)
+#define SW_KP_INT_CFG      	(0x08)
+#define SW_KP_INT_STA      	(0x0c)
+#define SW_KP_IN0          	(0x10)
+#define SW_KP_IN1          	(0x14)
+#define SW_KP_DEB          	(0x18)
+
+/* SW_KP_CTL */
+#define SW_KPCTL_IFENB      (1)
+#define SW_KPCTL_COLMASK    (0xff << 8)
+#define SW_KPCTL_ROWMASK    (0xff << 16)
+
+/* SW_KP_INT_CFG */
+#define SW_KPINT_F_EN		(1 << 0)
+#define SW_KPINT_R_EN		(1 << 1)
+
+/* SW_KP_INT_STA */
+#define SW_KP_PRESS         1
+#define SW_KP_RELEASE       2
+#define SW_KP_PRESS_RELEASE 3
+
+#define SW_MAX_ROWS        8
+#define SW_MAX_COLS        8
+
+struct sw_keypad {
+	struct input_dev        *input_dev;
+	struct platform_device  *pdev;
+	struct clk              *pclk;
+	struct clk              *mclk;
+	void __iomem            *base;
+	u32                 mod_clk;
+	u32                 pio_hdle;
+	int                 irq;
+	unsigned int        row_shift;
+	unsigned int        rows;
+	unsigned int        cols;
+	unsigned int        row_state[SW_MAX_COLS];
+	unsigned short      keycodes[];
+};
+
+struct sw_keypad_platdata {
+        const struct matrix_keymap_data *keymap_data;
+        unsigned int rows;
+        unsigned int cols;
+        bool no_autorepeat;
+};
+
+static const uint32_t sw_keymap[] = {
+    KEY(0, 0, KEY_1),  KEY(0, 1, KEY_2),  KEY(0, 2, KEY_3),  KEY(0, 3, KEY_4),  KEY(0, 4, KEY_5),  KEY(0, 5, KEY_6),  KEY(0, 6, KEY_7),  KEY(0, 7, KEY_8),
+    KEY(1, 0, KEY_A),  KEY(1, 1, KEY_B),  KEY(1, 2, KEY_C),  KEY(1, 3, KEY_D),  KEY(1, 4, KEY_E),  KEY(1, 5, KEY_F),  KEY(1, 6, KEY_G),  KEY(1, 7, KEY_H),
+    KEY(2, 0, KEY_A),  KEY(2, 1, KEY_B),  KEY(2, 2, KEY_C),  KEY(2, 3, KEY_D),  KEY(2, 4, KEY_E),  KEY(2, 5, KEY_F),  KEY(2, 6, KEY_G),  KEY(2, 7, KEY_H),
+    KEY(3, 0, KEY_A),  KEY(3, 1, KEY_B),  KEY(3, 2, KEY_C),  KEY(3, 3, KEY_D),  KEY(3, 4, KEY_E),  KEY(3, 5, KEY_F),  KEY(3, 6, KEY_G),  KEY(3, 7, KEY_H),
+    KEY(4, 0, KEY_A),  KEY(4, 1, KEY_B),  KEY(4, 2, KEY_C),  KEY(4, 3, KEY_D),  KEY(4, 4, KEY_E),  KEY(4, 5, KEY_F),  KEY(4, 6, KEY_G),  KEY(4, 7, KEY_H),
+    KEY(5, 0, KEY_A),  KEY(5, 1, KEY_B),  KEY(5, 2, KEY_C),  KEY(5, 3, KEY_D),  KEY(5, 4, KEY_E),  KEY(5, 5, KEY_F),  KEY(5, 6, KEY_G),  KEY(5, 7, KEY_H),
+    KEY(6, 0, KEY_A),  KEY(6, 1, KEY_B),  KEY(6, 2, KEY_C),  KEY(6, 3, KEY_D),  KEY(6, 4, KEY_E),  KEY(6, 5, KEY_F),  KEY(6, 6, KEY_G),  KEY(6, 7, KEY_H),
+    KEY(7, 0, KEY_F1), KEY(7, 1, KEY_F2), KEY(7, 2, KEY_F3), KEY(7, 3, KEY_F4), KEY(7, 3, KEY_F4), KEY(7, 5, KEY_F),  KEY(7, 6, KEY_G),  KEY(7, 7, KEY_H),
+};
+
+static struct matrix_keymap_data sw_keymap_data = {
+        .keymap         = sw_keymap,
+        .keymap_size    = ARRAY_SIZE(sw_keymap),
+};
+
+static struct sw_keypad_platdata sw_keypad_data = {
+        .keymap_data    = &sw_keymap_data,
+        .rows           = 8,
+        .cols           = 8,
+};
+
+static int kp_used = 0;
+
+static int sw_keypad_gpio_request(struct sw_keypad *keypad)
+{
+    #ifndef AW1623_FPGA
+	keypad->pio_hdle = gpio_request_ex("keypad_para", NULL);
+    if (!keypad->pio_hdle)
+    {
+        swkp_msg("request pio parameter failed\n");
+        return -1;
+    }
+    #else
+    {
+        #include <mach/platform.h>
+        void __iomem* pi_cfg0 = (void __iomem*)(SW_VA_PORTC_IO_BASE+0x120);
+        void __iomem* pi_cfg1 = (void __iomem*)(SW_VA_PORTC_IO_BASE+0x124);
+
+        writel(0x22222222, pi_cfg0);
+        writel(0x22222222, pi_cfg1);
+    }
+    #endif
+    return 0;
+}
+
+static void sw_keypad_gpio_release(struct sw_keypad *keypad)
+{
+    gpio_release(keypad->pio_hdle, 1);
+    keypad->pio_hdle = 0;
+}
+
+static void sw_keypad_scan(struct sw_keypad *keypad, unsigned int *row_state)
+{
+	unsigned int col;
+	unsigned int val;
+    u32 kp_iflag0 = readl(keypad->base + SW_KP_IN0);
+    u32 kp_iflag1 = readl(keypad->base + SW_KP_IN1);
+
+    //swkp_msg("scan key status, st0 %08x, st1 %08x\n", kp_iflag0, kp_iflag1);
+    //recode row information
+    for (col = 0; col < keypad->cols; col++) {
+		if (col < 4)
+		    val = kp_iflag0 >> (col << 3);
+		else
+		    val = kp_iflag1 >> ((col - 4) << 3);;
+		row_state[col] = (~val) & ((1 << keypad->rows) - 1);
+		//swkp_msg("rowstat[%d] %02x, keypad->row_state[%d] %02x, change %d\n", col, row_state[col], col, keypad->row_state[col], row_state[col] ^ keypad->row_state[col]);
+	}
+}
+
+static bool sw_keypad_report(struct sw_keypad *keypad, unsigned int *row_state, unsigned action)
+{
+	struct input_dev *input_dev = keypad->input_dev;
+	unsigned int changed;
+	unsigned int key_down = 0;
+	unsigned int val;
+	unsigned int col, row;
+
+    //swkp_msg("action %d\n", action);
+    for (col = 0; col < keypad->cols; col++) {
+        if (action & SW_KP_RELEASE) {
+            for (row = 0; row < keypad->rows; row++) {
+                if (row_state[col] & (1 << row)) {
+                    swkp_msg("key %dx%d, up(all up)\n", row, col);
+                    val = MATRIX_SCAN_CODE(row, col, keypad->row_shift);
+                    input_event(input_dev, EV_MSC, MSC_SCAN, val);
+        			input_report_key(input_dev, keypad->keycodes[val], 0);
+                }
+            }
+            keypad->row_state[col] = 0;
+            //swkp_msg("clr old sta keypad->row_state[%d] %02x\n", col, keypad->row_state[col]);
+        } else if (action == SW_KP_PRESS) {
+            changed = row_state[col] ^ keypad->row_state[col];
+            if (changed) {
+                //swkp_msg("col %d changed\n", col);
+                for (row = 0; row < keypad->rows; row++) {
+                    u32 cur = (row_state[col] >> row) & 1;
+                    u32 last = (keypad->row_state[col] >> row) & 1;
+                    u32 press = 0;
+
+                    //swkp_msg("%d x %d last %d cur %d\n", row, col, last, cur);
+
+                    if (last && !cur) {                 //1 --> 0
+                        press = 0;
+                    } else if (!last && cur) {          //0 --> 1
+                        press = 1;
+                    } else {
+                        continue;
+                    }
+
+                    swkp_msg("key %dx%d, %s\n", row, col, press ? "down" : "up");
+                    val = MATRIX_SCAN_CODE(row, col, keypad->row_shift);
+                    input_event(input_dev, EV_MSC, MSC_SCAN, val);
+        			input_report_key(input_dev, keypad->keycodes[val], press);
+                }
+            }
+            keypad->row_state[col] = row_state[col];
+        }
+        input_sync(keypad->input_dev);
+    }
+
+	return key_down;
+}
+
+static irqreturn_t sw_keypad_irq(int irq, void *dev_id)
+{
+	struct sw_keypad *keypad = dev_id;
+	unsigned int row_state[SW_MAX_COLS];
+	unsigned int val;
+	bool key_down;
+
+
+	val = readl(keypad->base + SW_KP_INT_STA);
+
+	sw_keypad_scan(keypad, row_state);
+
+	key_down = sw_keypad_report(keypad, row_state, val);
+
+	writel(val, keypad->base + SW_KP_INT_STA);
+
+	return IRQ_HANDLED;
+}
+
+static int sw_keypad_set_mclk(struct sw_keypad *keypad, u32 mod_clk)
+{
+    struct clk* sclk = NULL;
+    int ret;
+
+    sclk = clk_get(&keypad->pdev->dev, "hosc");
+    if (IS_ERR(sclk))
+    {
+        ret = PTR_ERR(sclk);
+        swkp_msg("Error to get source clock hosc\n");
+        return ret;
+    }
+
+    clk_set_parent(keypad->mclk, sclk);
+    clk_set_rate(keypad->mclk, mod_clk);
+    clk_enable(keypad->mclk);
+
+    #ifdef AW1623_FPGA
+    keypad->mod_clk = 24000000;//fpga
+    #else
+    keypad->mod_clk = clk_get_rate(keypad->mclk);
+    #endif
+
+    clk_put(sclk);
+
+    return 0;
+}
+
+static void sw_keypad_start(struct sw_keypad *keypad)
+{
+    swkp_msg("sw keypad start\n");
+
+    sw_keypad_set_mclk(keypad, 1000000);
+	clk_enable(keypad->pclk);
+
+	/* Enable interrupt bits. */
+    writel(SW_KPINT_F_EN|SW_KPINT_R_EN, keypad->base + SW_KP_INT_CFG);
+    writel(SW_KPCTL_IFENB, keypad->base + SW_KP_CTL);
+
+    enable_irq(keypad->irq);
+}
+
+static void sw_keypad_stop(struct sw_keypad *keypad)
+{
+    swkp_msg("sw keypad stop\n");
+
+	disable_irq(keypad->irq);
+	clk_disable(keypad->mclk);
+	clk_disable(keypad->pclk);
+}
+
+
+static int sw_keypad_open(struct input_dev *input_dev)
+{
+	struct sw_keypad *keypad = input_get_drvdata(input_dev);
+
+    swkp_msg("sw keypad open\n");
+	sw_keypad_start(keypad);
+
+	return 0;
+}
+
+static void sw_keypad_close(struct input_dev *input_dev)
+{
+	struct sw_keypad *keypad = input_get_drvdata(input_dev);
+
+    swkp_msg("sw keypad close\n");
+	sw_keypad_stop(keypad);
+}
+
+static int __devinit sw_keypad_probe(struct platform_device *pdev)
+{
+	const struct sw_keypad_platdata *pdata;
+	const struct matrix_keymap_data *keymap_data;
+	struct sw_keypad *keypad;
+	struct resource *res;
+	struct input_dev *input_dev;
+	unsigned int row_shift;
+	unsigned int keymap_size;
+	int error;
+
+    swkp_msg("sw keypad probe\n");
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		swkp_msg("no platform data defined\n");
+		return -EINVAL;
+	}
+
+	keymap_data = pdata->keymap_data;
+
+	if (!pdata->rows || pdata->rows > SW_MAX_ROWS)
+		return -EINVAL;
+
+	if (!pdata->cols || pdata->cols > SW_MAX_COLS)
+		return -EINVAL;
+
+	row_shift = get_count_order(pdata->cols);
+	keymap_size = (pdata->rows << row_shift) * sizeof(keypad->keycodes[0]);
+
+	keypad = kzalloc(sizeof(*keypad) + keymap_size, GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!keypad || !input_dev) {
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	/* initialize the gpio */
+	if (sw_keypad_gpio_request(keypad))
+	{
+	    error = -ENODEV;
+		goto err_free_mem;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		error = -ENODEV;
+		goto err_free_gpio;
+	}
+
+	keypad->base = ioremap(res->start, resource_size(res));
+	if (!keypad->base) {
+		error = -EBUSY;
+		goto err_free_gpio;
+	}
+	keypad->pclk = clk_get(&pdev->dev, "apb_key_pad");
+	if (IS_ERR(keypad->pclk)) {
+		swkp_msg("failed to get keypad hclk\n");
+		error = PTR_ERR(keypad->pclk);
+		goto err_unmap_base;
+	}
+
+	keypad->mclk = clk_get(&pdev->dev, "key_pad");
+	if (IS_ERR(keypad->mclk)) {
+		swkp_msg("failed to get keypad mclk\n");
+		error = PTR_ERR(keypad->mclk);
+		goto err_put_pclk;
+	}
+
+	keypad->input_dev = input_dev;
+	keypad->row_shift = row_shift;
+	keypad->rows = pdata->rows;
+	keypad->cols = pdata->cols;
+
+	input_dev->name = pdev->name;
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->dev.parent = &pdev->dev;
+	input_set_drvdata(input_dev, keypad);
+
+	input_dev->open = sw_keypad_open;
+	input_dev->close = sw_keypad_close;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	if (!pdata->no_autorepeat)
+		input_dev->evbit[0] |= BIT_MASK(EV_REP);
+
+	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
+
+	input_dev->keycode = keypad->keycodes;
+	input_dev->keycodesize = sizeof(keypad->keycodes[0]);
+	input_dev->keycodemax = pdata->rows << row_shift;
+
+	matrix_keypad_build_keymap(keymap_data, row_shift, input_dev->keycode, input_dev->keybit);
+
+	keypad->irq = platform_get_irq(pdev, 0);
+	if (keypad->irq < 0) {
+		error = keypad->irq;
+		goto err_put_mclk;
+	}
+
+	error = request_irq(keypad->irq, sw_keypad_irq, 0, dev_name(&pdev->dev), keypad);
+	if (error) {
+		swkp_msg("failed to register keypad interrupt\n");
+		goto err_put_mclk;
+	}
+    disable_irq(keypad->irq);
+
+	error = input_register_device(keypad->input_dev);
+	if (error)
+		goto err_free_irq;
+
+	platform_set_drvdata(pdev, keypad);
+	keypad->pdev = pdev;
+
+	swkp_msg("sw keypad probe done, base %p, irq %d\n", keypad->base, keypad->irq);
+	return 0;
+
+err_free_irq:
+	free_irq(keypad->irq, keypad);
+err_put_mclk:
+	clk_put(keypad->mclk);
+err_put_pclk:
+	clk_put(keypad->pclk);
+err_unmap_base:
+	iounmap(keypad->base);
+err_free_gpio:
+    gpio_release(keypad->pio_hdle, 1);
+    keypad->pio_hdle = 0;
+err_free_mem:
+	input_free_device(input_dev);
+	kfree(keypad);
+
+	return error;
+}
+
+static int __devexit sw_keypad_remove(struct platform_device *pdev)
+{
+	struct sw_keypad *keypad = platform_get_drvdata(pdev);
+
+    swkp_msg("sw keypad remove\n");
+
+	platform_set_drvdata(pdev, NULL);
+
+	input_unregister_device(keypad->input_dev);
+
+	free_irq(keypad->irq, keypad);
+	clk_put(keypad->pclk);
+	clk_put(keypad->mclk);
+	iounmap(keypad->base);
+
+    sw_keypad_gpio_release(keypad);
+	kfree(keypad);
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+static int sw_keypad_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sw_keypad *keypad = platform_get_drvdata(pdev);
+	struct input_dev *input_dev = keypad->input_dev;
+
+	mutex_lock(&input_dev->mutex);
+
+	if (input_dev->users)
+		sw_keypad_stop(keypad);
+
+	mutex_unlock(&input_dev->mutex);
+
+	return 0;
+}
+
+static int sw_keypad_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sw_keypad *keypad = platform_get_drvdata(pdev);
+	struct input_dev *input_dev = keypad->input_dev;
+
+	mutex_lock(&input_dev->mutex);
+
+	if (input_dev->users)
+		sw_keypad_start(keypad);
+
+	mutex_unlock(&input_dev->mutex);
+
+	return 0;
+}
+
+static const struct dev_pm_ops sw_keypad_pm_ops = {
+	.suspend	= sw_keypad_suspend,
+	.resume		= sw_keypad_resume,
+};
+#endif
+
+static struct resource sw_keypad_resources[] = {
+        [0] = {
+                .start  = SW_KP_PBASE,
+                .end    = SW_KP_PBASE + 0x400 - 1,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = SW_INT_IRQNO_KEYPAD,
+                .end    = SW_INT_IRQNO_KEYPAD,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static struct platform_device sw_device_keypad = {
+        .name           = "sw-keypad",
+        .id             = -1,
+        .num_resources  = ARRAY_SIZE(sw_keypad_resources),
+        .resource       = sw_keypad_resources,
+        .dev.platform_data = &sw_keypad_data,
+};
+
+static struct platform_driver sw_keypad_driver = {
+	.probe		= sw_keypad_probe,
+	.remove		= __devexit_p(sw_keypad_remove),
+	.driver		= {
+		.name	= "sw-keypad",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm	= &sw_keypad_pm_ops,
+#endif
+	},
+};
+
+static int __init sw_keypad_init(void)
+{
+    int ret;
+
+    swkp_msg("sw keypad init\n");
+    kp_used  = 0;
+    ret = script_parser_fetch("keypad_para", "ke_used", &kp_used, sizeof(int));
+    if (ret)
+    {
+        printk("sw keypad fetch keypad uning configuration failed\n");
+    }
+    if (kp_used)
+    {
+        platform_device_register(&sw_device_keypad);
+        return platform_driver_register(&sw_keypad_driver);
+    }
+    else
+    {
+        pr_warning("keypad: cannot find using configuration, return without doing anything!\n");
+        return 0;
+    }
+}
+module_init(sw_keypad_init);
+
+static void __exit sw_keypad_exit(void)
+{
+    swkp_msg("sw keypad exit\n");
+    if (kp_used)
+    {
+        kp_used = 0;
+        platform_driver_unregister(&sw_keypad_driver);
+    }
+}
+module_exit(sw_keypad_exit);
+
+MODULE_DESCRIPTION("SW keypad driver");
+MODULE_AUTHOR("Aaron.maoye<leafy.myeh@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sw-keypad");
diff --git a/drivers/input/keyboard/sunxi-ir.c b/drivers/input/keyboard/sunxi-ir.c
new file mode 100644
index 0000000..8b3c5f3
--- /dev/null
+++ b/drivers/input/keyboard/sunxi-ir.c
@@ -0,0 +1,672 @@
+/*
+ * drivers/input/keyboard/sunxi-ir.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/keyboard.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <mach/clock.h>
+
+#include <mach/irqs.h>
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+
+#include <linux/clk.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    #include <linux/pm.h>
+    #include <linux/earlysuspend.h>
+#endif
+
+#include "ir-keymap.h"
+
+static struct clk *apb_ir_clk;
+static struct clk *ir_clk;
+static u32 ir_gpio_hdle;
+
+#define SYS_CLK_CFG_EN
+
+#define SYS_GPIO_CFG_EN
+/* #define DEBUG_IR */
+#define PRINT_SUSPEND_INFO
+
+#ifdef DEBUG_IR
+#define DEBUG_IR_LEVEL0
+#define DEBUG_IR_LEVEL2
+#define DEBUG_IR_LEVEL1
+#define dprintk(level, fmt, arg...)	(if (debug >= level) \
+	printk(KERN_DEBUG fmt , ## arg))
+#else
+#undef DEBUG_IR_LEVEL0
+#undef DEBUG_IR_LEVEL2
+#undef DEBUG_IR_LEVEL1
+#define dprintk(level, fmt, arg...)
+#endif
+
+/* Registers */
+#define IR_REG(x)	(x)
+#define IR0_BASE	(0xf1c21800)
+#define IR1_BASE	(0xf1c21c00)
+#define IR_BASE		IR0_BASE
+#define IR_IRQNO	(SW_INT_IRQNO_IR0)
+
+/* CCM register */
+#define CCM_BASE	0xf1c20000
+/* PIO register */
+#define PI_BASE		0xf1c20800
+
+#define IR_CTRL_REG	IR_REG(0x00) /* IR Control */
+#define IR_RXCFG_REG	IR_REG(0x10) /* Rx Config */
+#define IR_RXDAT_REG	IR_REG(0x20) /* Rx Data */
+#define IR_RXINTE_REG	IR_REG(0x2c) /* Rx Interrupt Enable */
+#define IR_RXINTS_REG	IR_REG(0x30) /* Rx Interrupt Status */
+#define IR_SPLCFG_REG	IR_REG(0x34) /* IR Sample Config */
+
+/* Bit Definition of IR_RXINTS_REG Register */
+#define IR_RXINTS_RXOF	(0x1 << 0)	/* Rx FIFO Overflow */
+#define IR_RXINTS_RXPE	(0x1 << 1)	/* Rx Packet End */
+#define IR_RXINTS_RXDA	(0x1 << 4)	/* Rx FIFO Data Available */
+
+#ifdef CONFIG_ARCH_SUN5I
+#define IR_FIFO_SIZE	(64)	/* 64Bytes */
+#else
+#define IR_FIFO_SIZE	(16)	/* 16Bytes */
+#endif
+/* Frequency of Sample Clock = 23437.5Hz, Cycle is 42.7us */
+/* Pulse of NEC Remote >560us */
+#define IR_RXFILT_VAL	(8)	/* Filter Threshold = 8*42.7 = ~341us	< 500us */
+#define IR_RXIDLE_VAL	(2)	/* Idle Threshold = (2+1)*128*42.7 = ~16.4ms > 9ms */
+
+#define IR_L1_MIN	(80)	/* 80*42.7 = ~3.4ms, Lead1(4.5ms) > IR_L1_MIN */
+#define IR_L0_MIN	(40)	/* 40*42.7 = ~1.7ms, Lead0(4.5ms) Lead0R(2.25ms)> IR_L0_MIN */
+#define IR_PMAX		(26)	/* 26*42.7 = ~1109us ~= 561*2, Pluse < IR_PMAX */
+#define IR_DMID		(26)	/* 26*42.7 = ~1109us ~= 561*2, D1 > IR_DMID, D0 =< IR_DMID */
+#define IR_DMAX		(53)	/* 53*42.7 = ~2263us ~= 561*4, D < IR_DMAX */
+
+#define	IR_RAW_BUF_SIZE	128
+#define IR_ERROR_CODE	(0xffffffff)
+#define IR_REPEAT_CODE	(0x00000000)
+#define DRV_VERSION	"1.00"
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+struct sunxi_ir_data {
+	struct early_suspend early_suspend;
+};
+#endif
+
+struct ir_raw_buffer {
+	unsigned long dcnt;	/*Packet Count*/
+	unsigned char buf[IR_RAW_BUF_SIZE];
+};
+
+#ifdef DEBUG_IR
+static int debug = 8;
+#endif
+
+static unsigned int ir_cnt;
+static struct input_dev *ir_dev;
+static struct timer_list *s_timer;
+static unsigned long ir_code;
+static int timer_used;
+static struct ir_raw_buffer ir_rawbuf;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct sunxi_ir_data *ir_data;
+#endif
+
+
+static inline void ir_reset_rawbuffer(void)
+{
+	ir_rawbuf.dcnt = 0;
+}
+
+static inline void ir_write_rawbuffer(unsigned char data)
+{
+	if (ir_rawbuf.dcnt < IR_RAW_BUF_SIZE)
+		ir_rawbuf.buf[ir_rawbuf.dcnt++] = data;
+	else
+		printk("ir_write_rawbuffer: IR Rx buffer full\n");
+}
+
+static inline unsigned char ir_read_rawbuffer(void)
+{
+	unsigned char data = 0x00;
+
+	if (ir_rawbuf.dcnt > 0)
+		data = ir_rawbuf.buf[--ir_rawbuf.dcnt];
+
+	return data;
+}
+
+static inline int ir_rawbuffer_empty(void)
+{
+	return (ir_rawbuf.dcnt == 0);
+}
+
+static inline int ir_rawbuffer_full(void)
+{
+	return (ir_rawbuf.dcnt >= IR_RAW_BUF_SIZE);
+}
+
+static void ir_clk_cfg(void)
+{
+#ifdef SYS_CLK_CFG_EN
+	unsigned long rate = 3000000; /* 3 MHz */
+#else
+	unsigned long tmp = 0;
+#endif
+
+#ifdef SYS_CLK_CFG_EN
+	apb_ir_clk = clk_get(NULL, "apb_ir0");
+	if (!apb_ir_clk) {
+		printk("try to get apb_ir0 clock failed\n");
+		return;
+	}
+
+	ir_clk = clk_get(NULL, "ir0");
+	if (!ir_clk) {
+		printk("try to get ir0 clock failed\n");
+		return;
+	}
+
+	if (clk_set_rate(ir_clk, rate))
+		printk("set ir0 clock freq to 3M failed\n");
+
+	if (clk_enable(apb_ir_clk))
+		printk("try to enable apb_ir_clk failed\n");
+
+	if (clk_enable(ir_clk))
+		printk("try to enable apb_ir_clk failed\n");
+
+#else
+	/* Enable APB Clock for IR */
+	tmp = readl(CCM_BASE + 0x10);
+	tmp |= 0x1 << 10;  /* IR */
+	writel(tmp, CCM_BASE + 0x10);
+
+	/* config Special Clock for IR (24/8=3MHz) */
+	tmp = readl(CCM_BASE + 0x34);
+	tmp &= ~(0x3 << 8);
+	tmp |= (0x1 << 8);	/* Select 24MHz */
+	tmp |= (0x1 << 7);	/* Open Clock */
+	tmp &= ~(0x3f << 0);
+	tmp |= (7 << 0);	/* Divisor = 8 */
+	writel(tmp, CCM_BASE + 0x34);
+#endif
+
+	return;
+}
+
+static void ir_clk_uncfg(void)
+{
+#ifdef SYS_CLK_CFG_EN
+	clk_put(apb_ir_clk);
+	clk_put(ir_clk);
+#endif
+
+	return;
+}
+static void ir_sys_cfg(void)
+{
+#ifdef SYS_GPIO_CFG_EN
+	ir_gpio_hdle = gpio_request_ex("ir_para", "ir0_rx");
+	if (0 == ir_gpio_hdle)
+		printk("try to request ir_para gpio failed\n");
+#else
+	/* config IO: PIOB4 to IR_Rx */
+	tmp = readl(PI_BASE + 0x24); /* PIOB_CFG0_REG */
+	tmp &= ~(0xf << 16);
+	tmp |= (0x2 << 16);
+	writel(tmp, PI_BASE + 0x24);
+#endif
+
+	ir_clk_cfg();
+
+	return;
+}
+
+static void ir_sys_uncfg(void)
+{
+#ifdef SYS_GPIO_CFG_EN
+	gpio_release(ir_gpio_hdle, 2);
+#endif
+	ir_clk_uncfg();
+
+	return;
+}
+
+static void ir_reg_cfg(void)
+{
+	unsigned long tmp = 0;
+	/* Enable IR Mode */
+	tmp = 0x3 << 4;
+	writel(tmp, IR_BASE + IR_CTRL_REG);
+
+	/* Config IR Sample Register */
+	tmp = 0x1 << 0; /* Fsample = 3MHz/128 =23437.5Hz (42.7us) */
+
+
+	tmp |= (IR_RXFILT_VAL & 0x3f) << 2; /* Set Filter Threshold */
+	tmp |= (IR_RXIDLE_VAL & 0xff) << 8; /* Set Idle Threshold */
+	writel(tmp, IR_BASE + IR_SPLCFG_REG);
+
+	/* Invert Input Signal */
+	writel(0x1 << 2, IR_BASE + IR_RXCFG_REG);
+
+	/* Clear All Rx Interrupt Status */
+	writel(0xff, IR_BASE + IR_RXINTS_REG);
+
+	/* Set Rx Interrupt Enable */
+	tmp = (0x1 << 4) | 0x3;
+#ifdef CONFIG_ARCH_SUN5I
+	tmp |= ((IR_FIFO_SIZE >> 2) - 1) << 8; /* Rx FIFO Threshold = FIFOsz/4 */
+#else
+	tmp |= ((IR_FIFO_SIZE >> 1) - 1) << 8; /* Rx FIFO Threshold = FIFOsz/2 */
+#endif
+	writel(tmp, IR_BASE + IR_RXINTE_REG);
+
+	/* Enable IR Module */
+	tmp = readl(IR_BASE + IR_CTRL_REG);
+	tmp |= 0x3;
+	writel(tmp, IR_BASE + IR_CTRL_REG);
+
+	return;
+}
+
+static void ir_setup(void)
+{
+	dprintk(2, "ir_setup: ir setup start!!\n");
+
+	ir_code = 0;
+	timer_used = 0;
+	ir_reset_rawbuffer();
+	ir_sys_cfg();
+	ir_reg_cfg();
+
+	dprintk(2, "ir_setup: ir setup end!!\n");
+
+	return;
+}
+
+static inline unsigned char ir_get_data(void)
+{
+	return (unsigned char)(readl(IR_BASE + IR_RXDAT_REG));
+}
+
+static inline unsigned long ir_get_intsta(void)
+{
+	return readl(IR_BASE + IR_RXINTS_REG);
+}
+
+static inline void ir_clr_intsta(unsigned long bitmap)
+{
+	unsigned long tmp = readl(IR_BASE + IR_RXINTS_REG);
+
+	tmp &= ~0xff;
+	tmp |= bitmap&0xff;
+	writel(tmp, IR_BASE + IR_RXINTS_REG);
+}
+
+static unsigned long ir_packet_handler(unsigned char *buf, unsigned long dcnt)
+{
+	unsigned long len;
+	unsigned char val = 0x00;
+	unsigned char last = 0x00;
+	unsigned long code = 0;
+	int bitcnt = 0;
+	unsigned long i = 0;
+
+	dprintk(2, "dcnt = %d\n", (int)dcnt);
+
+	/* Find Lead '1' */
+	len = 0;
+	for (i = 0; i < dcnt; i++) {
+		val = buf[i];
+		if (val & 0x80) {
+			len += val & 0x7f;
+		} else {
+			if (len > IR_L1_MIN)
+				break;
+			len = 0;
+		}
+	}
+
+	if ((val & 0x80) || (len <= IR_L1_MIN))
+		return IR_ERROR_CODE; /* Invalid Code */
+
+	/*Find Lead '0'*/
+	len = 0;
+	for (; i < dcnt; i++) {
+		val = buf[i];
+		if (val & 0x80) {
+			if (len > IR_L0_MIN)
+				break;
+			len = 0;
+		} else {
+			len += val & 0x7f;
+		}
+	}
+
+	if ((!(val & 0x80)) || (len <= IR_L0_MIN))
+		return IR_ERROR_CODE; /* Invalid Code */
+
+	/* go decoding */
+	code = 0;  /* 0 for Repeat Code */
+	bitcnt = 0;
+	last = 1;
+	len = 0;
+	for (; i < dcnt; i++) {
+		val = buf[i];
+		if (last) {
+			if (val & 0x80) {
+				len += val & 0x7f;
+			} else {
+				if (len > IR_PMAX) /* Error Pulse */
+					return IR_ERROR_CODE;
+				last = 0;
+				len = val & 0x7f;
+			}
+		} else {
+			if (val & 0x80) {
+				if (len > IR_DMAX) { /* Error Distant */
+					return IR_ERROR_CODE;
+				} else {
+					if (len > IR_DMID)
+						/*data '1'*/
+						code |= 1 << bitcnt;
+					bitcnt++;
+					if (bitcnt == 32)
+						break;  /* decode over */
+				}
+				last = 1;
+				len = val & 0x7f;
+			} else {
+				len += val & 0x7f;
+			}
+		}
+	}
+
+	return code;
+}
+
+static int ir_code_valid(unsigned long code)
+{
+	unsigned long tmp1, tmp2;
+
+#ifdef IR_CHECK_ADDR_CODE
+	/* Check Address Value */
+	if ((code & 0xffff) != (IR_ADDR_CODE & 0xffff))
+		return 0; /* Address Error */
+
+	tmp1 = code & 0x00ff0000;
+	tmp2 = (code & 0xff000000) >> 8;
+
+	return ((tmp1 ^ tmp2) == 0x00ff0000);  /* Check User Code */
+#else
+	/* Do Not Check Address Value */
+	tmp1 = code & 0x00ff00ff;
+	tmp2 = (code & 0xff00ff00) >> 8;
+
+	return (((tmp1 ^ tmp2) & 0x00ff0000) == 0x00ff0000);
+#endif /* IR_CHECK_ADDR_CODE */
+}
+
+static irqreturn_t ir_irq_service(int irqno, void *dev_id)
+{
+	unsigned long dcnt;
+	unsigned long i = 0;
+	unsigned long intsta;
+
+	intsta = ir_get_intsta();
+
+#ifdef DEBUG_IR_LEVEL2
+	printk("IR IRQ Serve\n");
+#endif
+	ir_clr_intsta(intsta);
+
+	/* Read Data Every Time Enter this Routine*/
+#ifdef CONFIG_ARCH_SUN5I
+	dcnt = (ir_get_intsta() >> 8) & 0x3f;
+#else
+	dcnt = (ir_get_intsta() >> 8) & 0x1f;
+#endif
+
+	/* Read FIFO */
+	for (i = 0; i < dcnt; i++) {
+		if (ir_rawbuffer_full()) {
+#ifdef DEBUG_IR_LEVEL0
+			printk("ir_irq_service: raw buffer full\n");
+#endif
+			break;
+		} else {
+			ir_write_rawbuffer(ir_get_data());
+		}
+	}
+
+	if (intsta & IR_RXINTS_RXPE) { /* Packet End */
+		unsigned long code;
+		int code_valid;
+
+		code = ir_packet_handler(ir_rawbuf.buf, ir_rawbuf.dcnt);
+		ir_rawbuf.dcnt = 0;
+		code_valid = ir_code_valid(code);
+
+		if (timer_used) {
+			if (code_valid) { /* the pre-key is released */
+#ifdef CONFIG_ARCH_SUN5I
+				input_report_key(ir_dev, ir_keycodes[(ir_code >> 16) & 0xff], 0);
+				input_sync(ir_dev);
+#endif
+#ifdef DEBUG_IR_LEVEL1
+				printk("IR KEY UP\n");
+#endif
+				ir_cnt = 0;
+			}
+			if ((code == IR_REPEAT_CODE) || (code_valid)) /* Error, may interfere from other sources */
+				mod_timer(s_timer, jiffies + (HZ/5));
+		} else {
+			if (code_valid) {
+				s_timer->expires = jiffies + (HZ/5); /* 200ms timeout */
+				add_timer(s_timer);
+				timer_used = 1;
+			}
+		}
+
+		if (timer_used) {
+			ir_cnt++;
+			if (ir_cnt == 1) {
+				if (code_valid)
+					ir_code = code; /* update saved code with a new valid code */
+#ifdef DEBUG_IR_LEVEL0
+				printk("IR RAW CODE : %lu\n", (ir_code >> 16) & 0xff);
+#endif
+				input_report_key(ir_dev, ir_keycodes[(ir_code >> 16) & 0xff], 1);
+#ifdef DEBUG_IR_LEVEL0
+				printk("IR CODE : %d\n", ir_keycodes[(ir_code >> 16) & 0xff]);
+#endif
+				input_sync(ir_dev);
+#ifdef DEBUG_IR_LEVEL1
+				printk("IR KEY VALE %d\n", ir_keycodes[(ir_code >> 16) & 0xff]);
+#endif
+			}
+		}
+
+		dprintk(1, "ir_irq_service: Rx Packet End, code=0x%x, ir_code=0x%x, timer_used=%d\n", (int)code, (int)ir_code, timer_used);
+	}
+
+	if (intsta & IR_RXINTS_RXOF) {/* FIFO Overflow */
+		/* flush raw buffer */
+		ir_reset_rawbuffer();
+#ifdef DEBUG_IR_LEVEL0
+		printk("ir_irq_service: Rx FIFO Overflow!!\n");
+#endif
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void ir_timer_handle(unsigned long arg)
+{
+	del_timer(s_timer);
+	timer_used = 0;
+	/* Time Out, means that the key is up */
+	input_report_key(ir_dev, ir_keycodes[(ir_code >> 16) & 0xff], 0);
+	input_sync(ir_dev);
+#ifdef DEBUG_IR_LEVEL1
+	printk("IR KEY TIMER OUT UP\n");
+#endif
+	ir_cnt = 0;
+
+	dprintk(2, "ir_timer_handle: timeout\n");
+}
+
+/* åç¨è®¾å¤ */
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sunxi_ir_suspend(struct early_suspend *h)
+{
+#ifdef PRINT_SUSPEND_INFO
+	printk("enter earlysuspend: sunxi_ir_suspend\n");
+#endif
+	clk_disable(ir_clk);
+	clk_disable(apb_ir_clk);
+}
+
+/* éæ°å¤é */
+static void sunxi_ir_resume(struct early_suspend *h)
+{
+#ifdef PRINT_SUSPEND_INFO
+	printk("enter laterresume: sunxi_ir_resume\n");
+#endif
+
+	ir_code = 0;
+	timer_used = 0;
+	ir_reset_rawbuffer();
+	ir_clk_cfg();
+	ir_reg_cfg();
+}
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+static int __init ir_init(void)
+{
+	int i, ret;
+	int err = 0;
+
+	ir_dev = input_allocate_device();
+	if (!ir_dev) {
+		printk(KERN_ERR "ir_dev: not enough memory for input device\n");
+		err = -ENOMEM;
+		goto fail1;
+	}
+
+	ir_dev->name = "sunxi-ir";
+	ir_dev->phys = "RemoteIR/input1";
+	ir_dev->id.bustype = BUS_HOST;
+	ir_dev->id.vendor = 0x0001;
+	ir_dev->id.product = 0x0001;
+	ir_dev->id.version = 0x0100;
+
+#ifdef REPORT_REPEAT_KEY_VALUE
+	ir_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
+#else
+	ir_dev->evbit[0] = BIT_MASK(EV_KEY);
+#endif
+
+	for (i = 0; i < 256; i++)
+		set_bit(ir_keycodes[i], ir_dev->keybit);
+
+	if (request_irq(IR_IRQNO, ir_irq_service, 0, "RemoteIR",
+			ir_dev)) {
+		err = -EBUSY;
+		goto fail2;
+	}
+
+	ir_setup();
+
+	s_timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+	if (!s_timer) {
+		ret =  -ENOMEM;
+		printk("IR FAIL TO Request Time\n");
+		goto fail3;
+	}
+	init_timer(s_timer);
+	s_timer->function = &ir_timer_handle;
+
+	err = input_register_device(ir_dev);
+	if (err)
+		goto fail4;
+	printk("IR Initial OK\n");
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	printk("==register_early_suspend =\n");
+	ir_data = kzalloc(sizeof(*ir_data), GFP_KERNEL);
+	if (ir_data == NULL) {
+		err = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	ir_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ir_data->early_suspend.suspend = sunxi_ir_suspend;
+	ir_data->early_suspend.resume = sunxi_ir_resume;
+	register_early_suspend(&ir_data->early_suspend);
+#endif
+
+	return 0;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+ err_alloc_data_failed:
+#endif
+ fail4:
+	kfree(s_timer);
+ fail3:
+	free_irq(IR_IRQNO, ir_dev);
+ fail2:
+	input_free_device(ir_dev);
+ fail1:
+	return err;
+}
+
+static void __exit ir_exit(void)
+{
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ir_data->early_suspend);
+#endif
+
+	free_irq(IR_IRQNO, ir_dev);
+	input_unregister_device(ir_dev);
+	ir_sys_uncfg();
+	kfree(s_timer);
+}
+
+module_init(ir_init);
+module_exit(ir_exit);
+
+MODULE_DESCRIPTION("Remote IR driver");
+MODULE_AUTHOR("DanielWang");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/keyreset.c b/drivers/input/keyreset.c
new file mode 100644
index 0000000..36208fe
--- /dev/null
+++ b/drivers/input/keyreset.c
@@ -0,0 +1,239 @@
+/* drivers/input/keyreset.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/keyreset.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/syscalls.h>
+
+
+struct keyreset_state {
+	struct input_handler input_handler;
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long upbit[BITS_TO_LONGS(KEY_CNT)];
+	unsigned long key[BITS_TO_LONGS(KEY_CNT)];
+	spinlock_t lock;
+	int key_down_target;
+	int key_down;
+	int key_up;
+	int restart_disabled;
+	int (*reset_fn)(void);
+};
+
+int restart_requested;
+static void deferred_restart(struct work_struct *dummy)
+{
+	restart_requested = 2;
+	sys_sync();
+	restart_requested = 3;
+	kernel_restart(NULL);
+}
+static DECLARE_WORK(restart_work, deferred_restart);
+
+static void keyreset_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	unsigned long flags;
+	struct keyreset_state *state = handle->private;
+
+	if (type != EV_KEY)
+		return;
+
+	if (code >= KEY_MAX)
+		return;
+
+	if (!test_bit(code, state->keybit))
+		return;
+
+	spin_lock_irqsave(&state->lock, flags);
+	if (!test_bit(code, state->key) == !value)
+		goto done;
+	__change_bit(code, state->key);
+	if (test_bit(code, state->upbit)) {
+		if (value) {
+			state->restart_disabled = 1;
+			state->key_up++;
+		} else
+			state->key_up--;
+	} else {
+		if (value)
+			state->key_down++;
+		else
+			state->key_down--;
+	}
+	if (state->key_down == 0 && state->key_up == 0)
+		state->restart_disabled = 0;
+
+	pr_debug("reset key changed %d %d new state %d-%d-%d\n", code, value,
+		 state->key_down, state->key_up, state->restart_disabled);
+
+	if (value && !state->restart_disabled &&
+	    state->key_down == state->key_down_target) {
+		state->restart_disabled = 1;
+		if (restart_requested)
+			panic("keyboard reset failed, %d", restart_requested);
+		if (state->reset_fn) {
+			restart_requested = state->reset_fn();
+		} else {
+			pr_info("keyboard reset\n");
+			schedule_work(&restart_work);
+			restart_requested = 1;
+		}
+	}
+done:
+	spin_unlock_irqrestore(&state->lock, flags);
+}
+
+static int keyreset_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i;
+	int ret;
+	struct input_handle *handle;
+	struct keyreset_state *state =
+		container_of(handler, struct keyreset_state, input_handler);
+
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, state->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "keyreset";
+	handle->private = state;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("using input dev %s for key reset\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keyreset_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id keyreset_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(input, keyreset_ids);
+
+static int keyreset_probe(struct platform_device *pdev)
+{
+	int ret;
+	int key, *keyp;
+	struct keyreset_state *state;
+	struct keyreset_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!pdata)
+		return -EINVAL;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	spin_lock_init(&state->lock);
+	keyp = pdata->keys_down;
+	while ((key = *keyp++)) {
+		if (key >= KEY_MAX)
+			continue;
+		state->key_down_target++;
+		__set_bit(key, state->keybit);
+	}
+	if (pdata->keys_up) {
+		keyp = pdata->keys_up;
+		while ((key = *keyp++)) {
+			if (key >= KEY_MAX)
+				continue;
+			__set_bit(key, state->keybit);
+			__set_bit(key, state->upbit);
+		}
+	}
+
+	if (pdata->reset_fn)
+		state->reset_fn = pdata->reset_fn;
+
+	state->input_handler.event = keyreset_event;
+	state->input_handler.connect = keyreset_connect;
+	state->input_handler.disconnect = keyreset_disconnect;
+	state->input_handler.name = KEYRESET_NAME;
+	state->input_handler.id_table = keyreset_ids;
+	ret = input_register_handler(&state->input_handler);
+	if (ret) {
+		kfree(state);
+		return ret;
+	}
+	platform_set_drvdata(pdev, state);
+	return 0;
+}
+
+int keyreset_remove(struct platform_device *pdev)
+{
+	struct keyreset_state *state = platform_get_drvdata(pdev);
+	input_unregister_handler(&state->input_handler);
+	kfree(state);
+	return 0;
+}
+
+
+struct platform_driver keyreset_driver = {
+	.driver.name = KEYRESET_NAME,
+	.probe = keyreset_probe,
+	.remove = keyreset_remove,
+};
+
+static int __init keyreset_init(void)
+{
+	return platform_driver_register(&keyreset_driver);
+}
+
+static void __exit keyreset_exit(void)
+{
+	return platform_driver_unregister(&keyreset_driver);
+}
+
+module_init(keyreset_init);
+module_exit(keyreset_exit);
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 7faf4a7..66550c2 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -279,6 +279,17 @@ config INPUT_ATI_REMOTE2
 	  To compile this driver as a module, choose M here: the module will be
 	  called ati_remote2.
 
+config INPUT_KEYCHORD
+	tristate "Key chord input driver support"
+	help
+	  Say Y here if you want to enable the key chord driver
+	  accessible at /dev/keychord.  This driver can be used
+	  for receiving notifications when client specified key
+	  combinations are pressed.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called keychord.
+
 config INPUT_KEYSPAN_REMOTE
 	tristate "Keyspan DMR USB remote control (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -407,6 +418,11 @@ config INPUT_SGI_BTNS
 	  To compile this driver as a module, choose M here: the
 	  module will be called sgi_btns.
 
+config INPUT_GPIO
+	tristate "GPIO driver support"
+	help
+	  Say Y here if you want to support gpio based keys, wheels etc...
+
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
 	depends on (GSC || HP300) && SERIO
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index f55cdf4..f8cb522 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -25,8 +25,10 @@ obj-$(CONFIG_INPUT_DA9052_ONKEY)	+= da9052_onkey.o
 obj-$(CONFIG_INPUT_DM355EVM)		+= dm355evm_keys.o
 obj-$(CONFIG_INPUT_GP2A)		+= gp2ap002a00f.o
 obj-$(CONFIG_INPUT_GPIO_TILT_POLLED)	+= gpio_tilt_polled.o
+obj-$(CONFIG_INPUT_GPIO)		+= gpio_event.o gpio_matrix.o gpio_input.o gpio_output.o gpio_axis.o
 obj-$(CONFIG_HP_SDC_RTC)		+= hp_sdc_rtc.o
 obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
+obj-$(CONFIG_INPUT_KEYCHORD)		+= keychord.o
 obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
 obj-$(CONFIG_INPUT_KXTJ9)		+= kxtj9.o
 obj-$(CONFIG_INPUT_M68K_BEEP)		+= m68kspkr.o
diff --git a/drivers/input/misc/gpio_axis.c b/drivers/input/misc/gpio_axis.c
new file mode 100644
index 0000000..0acf4a5
--- /dev/null
+++ b/drivers/input/misc/gpio_axis.c
@@ -0,0 +1,192 @@
+/* drivers/input/misc/gpio_axis.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+struct gpio_axis_state {
+	struct gpio_event_input_devs *input_devs;
+	struct gpio_event_axis_info *info;
+	uint32_t pos;
+};
+
+uint16_t gpio_axis_4bit_gray_map_table[] = {
+	[0x0] = 0x0, [0x1] = 0x1, /* 0000 0001 */
+	[0x3] = 0x2, [0x2] = 0x3, /* 0011 0010 */
+	[0x6] = 0x4, [0x7] = 0x5, /* 0110 0111 */
+	[0x5] = 0x6, [0x4] = 0x7, /* 0101 0100 */
+	[0xc] = 0x8, [0xd] = 0x9, /* 1100 1101 */
+	[0xf] = 0xa, [0xe] = 0xb, /* 1111 1110 */
+	[0xa] = 0xc, [0xb] = 0xd, /* 1010 1011 */
+	[0x9] = 0xe, [0x8] = 0xf, /* 1001 1000 */
+};
+uint16_t gpio_axis_4bit_gray_map(struct gpio_event_axis_info *info, uint16_t in)
+{
+	return gpio_axis_4bit_gray_map_table[in];
+}
+
+uint16_t gpio_axis_5bit_singletrack_map_table[] = {
+	[0x10] = 0x00, [0x14] = 0x01, [0x1c] = 0x02, /*     10000 10100 11100 */
+	[0x1e] = 0x03, [0x1a] = 0x04, [0x18] = 0x05, /*     11110 11010 11000 */
+	[0x08] = 0x06, [0x0a] = 0x07, [0x0e] = 0x08, /*    01000 01010 01110  */
+	[0x0f] = 0x09, [0x0d] = 0x0a, [0x0c] = 0x0b, /*    01111 01101 01100  */
+	[0x04] = 0x0c, [0x05] = 0x0d, [0x07] = 0x0e, /*   00100 00101 00111   */
+	[0x17] = 0x0f, [0x16] = 0x10, [0x06] = 0x11, /*   10111 10110 00110   */
+	[0x02] = 0x12, [0x12] = 0x13, [0x13] = 0x14, /*  00010 10010 10011    */
+	[0x1b] = 0x15, [0x0b] = 0x16, [0x03] = 0x17, /*  11011 01011 00011    */
+	[0x01] = 0x18, [0x09] = 0x19, [0x19] = 0x1a, /* 00001 01001 11001     */
+	[0x1d] = 0x1b, [0x15] = 0x1c, [0x11] = 0x1d, /* 11101 10101 10001     */
+};
+uint16_t gpio_axis_5bit_singletrack_map(
+	struct gpio_event_axis_info *info, uint16_t in)
+{
+	return gpio_axis_5bit_singletrack_map_table[in];
+}
+
+static void gpio_event_update_axis(struct gpio_axis_state *as, int report)
+{
+	struct gpio_event_axis_info *ai = as->info;
+	int i;
+	int change;
+	uint16_t state = 0;
+	uint16_t pos;
+	uint16_t old_pos = as->pos;
+	for (i = ai->count - 1; i >= 0; i--)
+		state = (state << 1) | gpio_get_value(ai->gpio[i]);
+	pos = ai->map(ai, state);
+	if (ai->flags & GPIOEAF_PRINT_RAW)
+		pr_info("axis %d-%d raw %x, pos %d -> %d\n",
+			ai->type, ai->code, state, old_pos, pos);
+	if (report && pos != old_pos) {
+		if (ai->type == EV_REL) {
+			change = (ai->decoded_size + pos - old_pos) %
+				  ai->decoded_size;
+			if (change > ai->decoded_size / 2)
+				change -= ai->decoded_size;
+			if (change == ai->decoded_size / 2) {
+				if (ai->flags & GPIOEAF_PRINT_EVENT)
+					pr_info("axis %d-%d unknown direction, "
+						"pos %d -> %d\n", ai->type,
+						ai->code, old_pos, pos);
+				change = 0; /* no closest direction */
+			}
+			if (ai->flags & GPIOEAF_PRINT_EVENT)
+				pr_info("axis %d-%d change %d\n",
+					ai->type, ai->code, change);
+			input_report_rel(as->input_devs->dev[ai->dev],
+						ai->code, change);
+		} else {
+			if (ai->flags & GPIOEAF_PRINT_EVENT)
+				pr_info("axis %d-%d now %d\n",
+					ai->type, ai->code, pos);
+			input_event(as->input_devs->dev[ai->dev],
+					ai->type, ai->code, pos);
+		}
+		input_sync(as->input_devs->dev[ai->dev]);
+	}
+	as->pos = pos;
+}
+
+static irqreturn_t gpio_axis_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_axis_state *as = dev_id;
+	gpio_event_update_axis(as, 1);
+	return IRQ_HANDLED;
+}
+
+int gpio_event_axis_func(struct gpio_event_input_devs *input_devs,
+			 struct gpio_event_info *info, void **data, int func)
+{
+	int ret;
+	int i;
+	int irq;
+	struct gpio_event_axis_info *ai;
+	struct gpio_axis_state *as;
+
+	ai = container_of(info, struct gpio_event_axis_info, info);
+	if (func == GPIO_EVENT_FUNC_SUSPEND) {
+		for (i = 0; i < ai->count; i++)
+			disable_irq(gpio_to_irq(ai->gpio[i]));
+		return 0;
+	}
+	if (func == GPIO_EVENT_FUNC_RESUME) {
+		for (i = 0; i < ai->count; i++)
+			enable_irq(gpio_to_irq(ai->gpio[i]));
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		*data = as = kmalloc(sizeof(*as), GFP_KERNEL);
+		if (as == NULL) {
+			ret = -ENOMEM;
+			goto err_alloc_axis_state_failed;
+		}
+		as->input_devs = input_devs;
+		as->info = ai;
+		if (ai->dev >= input_devs->count) {
+			pr_err("gpio_event_axis: bad device index %d >= %d "
+				"for %d:%d\n", ai->dev, input_devs->count,
+				ai->type, ai->code);
+			ret = -EINVAL;
+			goto err_bad_device_index;
+		}
+
+		input_set_capability(input_devs->dev[ai->dev],
+				     ai->type, ai->code);
+		if (ai->type == EV_ABS) {
+			input_set_abs_params(input_devs->dev[ai->dev], ai->code,
+					     0, ai->decoded_size - 1, 0, 0);
+		}
+		for (i = 0; i < ai->count; i++) {
+			ret = gpio_request(ai->gpio[i], "gpio_event_axis");
+			if (ret < 0)
+				goto err_request_gpio_failed;
+			ret = gpio_direction_input(ai->gpio[i]);
+			if (ret < 0)
+				goto err_gpio_direction_input_failed;
+			ret = irq = gpio_to_irq(ai->gpio[i]);
+			if (ret < 0)
+				goto err_get_irq_num_failed;
+			ret = request_irq(irq, gpio_axis_irq_handler,
+					  IRQF_TRIGGER_RISING |
+					  IRQF_TRIGGER_FALLING,
+					  "gpio_event_axis", as);
+			if (ret < 0)
+				goto err_request_irq_failed;
+		}
+		gpio_event_update_axis(as, 0);
+		return 0;
+	}
+
+	ret = 0;
+	as = *data;
+	for (i = ai->count - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(ai->gpio[i]), as);
+err_request_irq_failed:
+err_get_irq_num_failed:
+err_gpio_direction_input_failed:
+		gpio_free(ai->gpio[i]);
+err_request_gpio_failed:
+		;
+	}
+err_bad_device_index:
+	kfree(as);
+	*data = NULL;
+err_alloc_axis_state_failed:
+	return ret;
+}
diff --git a/drivers/input/misc/gpio_event.c b/drivers/input/misc/gpio_event.c
new file mode 100644
index 0000000..c7f396a
--- /dev/null
+++ b/drivers/input/misc/gpio_event.c
@@ -0,0 +1,239 @@
+/* drivers/input/misc/gpio_event.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+struct gpio_event {
+	struct gpio_event_input_devs *input_devs;
+	const struct gpio_event_platform_data *info;
+	void *state[0];
+};
+
+static int gpio_input_event(
+	struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	int i;
+	int devnr;
+	int ret = 0;
+	int tmp_ret;
+	struct gpio_event_info **ii;
+	struct gpio_event *ip = input_get_drvdata(dev);
+
+	for (devnr = 0; devnr < ip->input_devs->count; devnr++)
+		if (ip->input_devs->dev[devnr] == dev)
+			break;
+	if (devnr == ip->input_devs->count) {
+		pr_err("gpio_input_event: unknown device %p\n", dev);
+		return -EIO;
+	}
+
+	for (i = 0, ii = ip->info->info; i < ip->info->info_count; i++, ii++) {
+		if ((*ii)->event) {
+			tmp_ret = (*ii)->event(ip->input_devs, *ii,
+						&ip->state[i],
+						devnr, type, code, value);
+			if (tmp_ret)
+				ret = tmp_ret;
+		}
+	}
+	return ret;
+}
+
+static int gpio_event_call_all_func(struct gpio_event *ip, int func)
+{
+	int i;
+	int ret;
+	struct gpio_event_info **ii;
+
+	if (func == GPIO_EVENT_FUNC_INIT || func == GPIO_EVENT_FUNC_RESUME) {
+		ii = ip->info->info;
+		for (i = 0; i < ip->info->info_count; i++, ii++) {
+			if ((*ii)->func == NULL) {
+				ret = -ENODEV;
+				pr_err("gpio_event_probe: Incomplete pdata, "
+					"no function\n");
+				goto err_no_func;
+			}
+			if (func == GPIO_EVENT_FUNC_RESUME && (*ii)->no_suspend)
+				continue;
+			ret = (*ii)->func(ip->input_devs, *ii, &ip->state[i],
+					  func);
+			if (ret) {
+				pr_err("gpio_event_probe: function failed\n");
+				goto err_func_failed;
+			}
+		}
+		return 0;
+	}
+
+	ret = 0;
+	i = ip->info->info_count;
+	ii = ip->info->info + i;
+	while (i > 0) {
+		i--;
+		ii--;
+		if ((func & ~1) == GPIO_EVENT_FUNC_SUSPEND && (*ii)->no_suspend)
+			continue;
+		(*ii)->func(ip->input_devs, *ii, &ip->state[i], func & ~1);
+err_func_failed:
+err_no_func:
+		;
+	}
+	return ret;
+}
+
+static void __maybe_unused gpio_event_suspend(struct gpio_event *ip)
+{
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_SUSPEND);
+	if (ip->info->power)
+		ip->info->power(ip->info, 0);
+}
+
+static void __maybe_unused gpio_event_resume(struct gpio_event *ip)
+{
+	if (ip->info->power)
+		ip->info->power(ip->info, 1);
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_RESUME);
+}
+
+static int gpio_event_probe(struct platform_device *pdev)
+{
+	int err;
+	struct gpio_event *ip;
+	struct gpio_event_platform_data *event_info;
+	int dev_count = 1;
+	int i;
+	int registered = 0;
+
+	event_info = pdev->dev.platform_data;
+	if (event_info == NULL) {
+		pr_err("gpio_event_probe: No pdata\n");
+		return -ENODEV;
+	}
+	if ((!event_info->name && !event_info->names[0]) ||
+	    !event_info->info || !event_info->info_count) {
+		pr_err("gpio_event_probe: Incomplete pdata\n");
+		return -ENODEV;
+	}
+	if (!event_info->name)
+		while (event_info->names[dev_count])
+			dev_count++;
+	ip = kzalloc(sizeof(*ip) +
+		     sizeof(ip->state[0]) * event_info->info_count +
+		     sizeof(*ip->input_devs) +
+		     sizeof(ip->input_devs->dev[0]) * dev_count, GFP_KERNEL);
+	if (ip == NULL) {
+		err = -ENOMEM;
+		pr_err("gpio_event_probe: Failed to allocate private data\n");
+		goto err_kp_alloc_failed;
+	}
+	ip->input_devs = (void*)&ip->state[event_info->info_count];
+	platform_set_drvdata(pdev, ip);
+
+	for (i = 0; i < dev_count; i++) {
+		struct input_dev *input_dev = input_allocate_device();
+		if (input_dev == NULL) {
+			err = -ENOMEM;
+			pr_err("gpio_event_probe: "
+				"Failed to allocate input device\n");
+			goto err_input_dev_alloc_failed;
+		}
+		input_set_drvdata(input_dev, ip);
+		input_dev->name = event_info->name ?
+					event_info->name : event_info->names[i];
+		input_dev->event = gpio_input_event;
+		ip->input_devs->dev[i] = input_dev;
+	}
+	ip->input_devs->count = dev_count;
+	ip->info = event_info;
+	if (event_info->power)
+		ip->info->power(ip->info, 1);
+
+	err = gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_INIT);
+	if (err)
+		goto err_call_all_func_failed;
+
+	for (i = 0; i < dev_count; i++) {
+		err = input_register_device(ip->input_devs->dev[i]);
+		if (err) {
+			pr_err("gpio_event_probe: Unable to register %s "
+				"input device\n", ip->input_devs->dev[i]->name);
+			goto err_input_register_device_failed;
+		}
+		registered++;
+	}
+
+	return 0;
+
+err_input_register_device_failed:
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_UNINIT);
+err_call_all_func_failed:
+	if (event_info->power)
+		ip->info->power(ip->info, 0);
+	for (i = 0; i < registered; i++)
+		input_unregister_device(ip->input_devs->dev[i]);
+	for (i = dev_count - 1; i >= registered; i--) {
+		input_free_device(ip->input_devs->dev[i]);
+err_input_dev_alloc_failed:
+		;
+	}
+	kfree(ip);
+err_kp_alloc_failed:
+	return err;
+}
+
+static int gpio_event_remove(struct platform_device *pdev)
+{
+	struct gpio_event *ip = platform_get_drvdata(pdev);
+	int i;
+
+	gpio_event_call_all_func(ip, GPIO_EVENT_FUNC_UNINIT);
+	if (ip->info->power)
+		ip->info->power(ip->info, 0);
+	for (i = 0; i < ip->input_devs->count; i++)
+		input_unregister_device(ip->input_devs->dev[i]);
+	kfree(ip);
+	return 0;
+}
+
+static struct platform_driver gpio_event_driver = {
+	.probe		= gpio_event_probe,
+	.remove		= gpio_event_remove,
+	.driver		= {
+		.name	= GPIO_EVENT_DEV_NAME,
+	},
+};
+
+static int __devinit gpio_event_init(void)
+{
+	return platform_driver_register(&gpio_event_driver);
+}
+
+static void __exit gpio_event_exit(void)
+{
+	platform_driver_unregister(&gpio_event_driver);
+}
+
+module_init(gpio_event_init);
+module_exit(gpio_event_exit);
+
+MODULE_DESCRIPTION("GPIO Event Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/misc/gpio_input.c b/drivers/input/misc/gpio_input.c
new file mode 100644
index 0000000..eefd027
--- /dev/null
+++ b/drivers/input/misc/gpio_input.c
@@ -0,0 +1,390 @@
+/* drivers/input/misc/gpio_input.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pm_wakeup.h>
+
+enum {
+	DEBOUNCE_UNSTABLE     = BIT(0),	/* Got irq, while debouncing */
+	DEBOUNCE_PRESSED      = BIT(1),
+	DEBOUNCE_NOTPRESSED   = BIT(2),
+	DEBOUNCE_WAIT_IRQ     = BIT(3),	/* Stable irq state */
+	DEBOUNCE_POLL         = BIT(4),	/* Stable polling state */
+
+	DEBOUNCE_UNKNOWN =
+		DEBOUNCE_PRESSED | DEBOUNCE_NOTPRESSED,
+};
+
+struct gpio_key_state {
+	struct gpio_input_state *ds;
+	uint8_t debounce;
+};
+
+struct gpio_input_state {
+	struct gpio_event_input_devs *input_devs;
+	const struct gpio_event_input_info *info;
+	struct hrtimer timer;
+	int use_irq;
+	int debounce_count;
+	spinlock_t irq_lock;
+	struct wakeup_source *ws;
+	struct gpio_key_state key_state[0];
+};
+
+static enum hrtimer_restart gpio_event_input_timer_func(struct hrtimer *timer)
+{
+	int i;
+	int pressed;
+	struct gpio_input_state *ds =
+		container_of(timer, struct gpio_input_state, timer);
+	unsigned gpio_flags = ds->info->flags;
+	unsigned npolarity;
+	int nkeys = ds->info->keymap_size;
+	const struct gpio_event_direct_entry *key_entry;
+	struct gpio_key_state *key_state;
+	unsigned long irqflags;
+	uint8_t debounce;
+	bool sync_needed;
+
+#if 0
+	key_entry = kp->keys_info->keymap;
+	key_state = kp->key_state;
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++)
+		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
+			gpio_read_detect_status(key_entry->gpio));
+#endif
+	key_entry = ds->info->keymap;
+	key_state = ds->key_state;
+	sync_needed = false;
+	spin_lock_irqsave(&ds->irq_lock, irqflags);
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
+		debounce = key_state->debounce;
+		if (debounce & DEBOUNCE_WAIT_IRQ)
+			continue;
+		if (key_state->debounce & DEBOUNCE_UNSTABLE) {
+			debounce = key_state->debounce = DEBOUNCE_UNKNOWN;
+			enable_irq(gpio_to_irq(key_entry->gpio));
+			if (gpio_flags & GPIOEDF_PRINT_KEY_UNSTABLE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) continue debounce\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+		}
+		npolarity = !(gpio_flags & GPIOEDF_ACTIVE_HIGH);
+		pressed = gpio_get_value(key_entry->gpio) ^ npolarity;
+		if (debounce & DEBOUNCE_POLL) {
+			if (pressed == !(debounce & DEBOUNCE_PRESSED)) {
+				ds->debounce_count++;
+				key_state->debounce = DEBOUNCE_UNKNOWN;
+				if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+					pr_info("gpio_keys_scan_keys: key %x-"
+						"%x, %d (%d) start debounce\n",
+						ds->info->type, key_entry->code,
+						i, key_entry->gpio);
+			}
+			continue;
+		}
+		if (pressed && (debounce & DEBOUNCE_NOTPRESSED)) {
+			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) debounce pressed 1\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+			key_state->debounce = DEBOUNCE_PRESSED;
+			continue;
+		}
+		if (!pressed && (debounce & DEBOUNCE_PRESSED)) {
+			if (gpio_flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_keys_scan_keys: key %x-%x, %d "
+					"(%d) debounce pressed 0\n",
+					ds->info->type, key_entry->code,
+					i, key_entry->gpio);
+			key_state->debounce = DEBOUNCE_NOTPRESSED;
+			continue;
+		}
+		/* key is stable */
+		ds->debounce_count--;
+		if (ds->use_irq)
+			key_state->debounce |= DEBOUNCE_WAIT_IRQ;
+		else
+			key_state->debounce |= DEBOUNCE_POLL;
+		if (gpio_flags & GPIOEDF_PRINT_KEYS)
+			pr_info("gpio_keys_scan_keys: key %x-%x, %d (%d) "
+				"changed to %d\n", ds->info->type,
+				key_entry->code, i, key_entry->gpio, pressed);
+		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
+			    key_entry->code, pressed);
+		sync_needed = true;
+	}
+	if (sync_needed) {
+		for (i = 0; i < ds->input_devs->count; i++)
+			input_sync(ds->input_devs->dev[i]);
+	}
+
+#if 0
+	key_entry = kp->keys_info->keymap;
+	key_state = kp->key_state;
+	for (i = 0; i < nkeys; i++, key_entry++, key_state++) {
+		pr_info("gpio_read_detect_status %d %d\n", key_entry->gpio,
+			gpio_read_detect_status(key_entry->gpio));
+	}
+#endif
+
+	if (ds->debounce_count)
+		hrtimer_start(timer, ds->info->debounce_time, HRTIMER_MODE_REL);
+	else if (!ds->use_irq)
+		hrtimer_start(timer, ds->info->poll_time, HRTIMER_MODE_REL);
+	else
+		__pm_relax(ds->ws);
+
+	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gpio_event_input_irq_handler(int irq, void *dev_id)
+{
+	struct gpio_key_state *ks = dev_id;
+	struct gpio_input_state *ds = ks->ds;
+	int keymap_index = ks - ds->key_state;
+	const struct gpio_event_direct_entry *key_entry;
+	unsigned long irqflags;
+	int pressed;
+
+	if (!ds->use_irq)
+		return IRQ_HANDLED;
+
+	key_entry = &ds->info->keymap[keymap_index];
+
+	if (ds->info->debounce_time.tv64) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ks->debounce & DEBOUNCE_WAIT_IRQ) {
+			ks->debounce = DEBOUNCE_UNKNOWN;
+			if (ds->debounce_count++ == 0) {
+				__pm_stay_awake(ds->ws);
+				hrtimer_start(
+					&ds->timer, ds->info->debounce_time,
+					HRTIMER_MODE_REL);
+			}
+			if (ds->info->flags & GPIOEDF_PRINT_KEY_DEBOUNCE)
+				pr_info("gpio_event_input_irq_handler: "
+					"key %x-%x, %d (%d) start debounce\n",
+					ds->info->type, key_entry->code,
+					keymap_index, key_entry->gpio);
+		} else {
+			disable_irq_nosync(irq);
+			ks->debounce = DEBOUNCE_UNSTABLE;
+		}
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+	} else {
+		pressed = gpio_get_value(key_entry->gpio) ^
+			!(ds->info->flags & GPIOEDF_ACTIVE_HIGH);
+		if (ds->info->flags & GPIOEDF_PRINT_KEYS)
+			pr_info("gpio_event_input_irq_handler: key %x-%x, %d "
+				"(%d) changed to %d\n",
+				ds->info->type, key_entry->code, keymap_index,
+				key_entry->gpio, pressed);
+		input_event(ds->input_devs->dev[key_entry->dev], ds->info->type,
+			    key_entry->code, pressed);
+		input_sync(ds->input_devs->dev[key_entry->dev]);
+	}
+	return IRQ_HANDLED;
+}
+
+static int gpio_event_input_request_irqs(struct gpio_input_state *ds)
+{
+	int i;
+	int err;
+	unsigned int irq;
+	unsigned long req_flags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
+
+	for (i = 0; i < ds->info->keymap_size; i++) {
+		err = irq = gpio_to_irq(ds->info->keymap[i].gpio);
+		if (err < 0)
+			goto err_gpio_get_irq_num_failed;
+		err = request_irq(irq, gpio_event_input_irq_handler,
+				  req_flags, "gpio_keys", &ds->key_state[i]);
+		if (err) {
+			pr_err("gpio_event_input_request_irqs: request_irq "
+				"failed for input %d, irq %d\n",
+				ds->info->keymap[i].gpio, irq);
+			goto err_request_irq_failed;
+		}
+		if (ds->info->info.no_suspend) {
+			err = enable_irq_wake(irq);
+			if (err) {
+				pr_err("gpio_event_input_request_irqs: "
+					"enable_irq_wake failed for input %d, "
+					"irq %d\n",
+					ds->info->keymap[i].gpio, irq);
+				goto err_enable_irq_wake_failed;
+			}
+		}
+	}
+	return 0;
+
+	for (i = ds->info->keymap_size - 1; i >= 0; i--) {
+		irq = gpio_to_irq(ds->info->keymap[i].gpio);
+		if (ds->info->info.no_suspend)
+			disable_irq_wake(irq);
+err_enable_irq_wake_failed:
+		free_irq(irq, &ds->key_state[i]);
+err_request_irq_failed:
+err_gpio_get_irq_num_failed:
+		;
+	}
+	return err;
+}
+
+int gpio_event_input_func(struct gpio_event_input_devs *input_devs,
+			struct gpio_event_info *info, void **data, int func)
+{
+	int ret;
+	int i;
+	unsigned long irqflags;
+	struct gpio_event_input_info *di;
+	struct gpio_input_state *ds = *data;
+	char *wlname;
+
+	di = container_of(info, struct gpio_event_input_info, info);
+
+	if (func == GPIO_EVENT_FUNC_SUSPEND) {
+		if (ds->use_irq)
+			for (i = 0; i < di->keymap_size; i++)
+				disable_irq(gpio_to_irq(di->keymap[i].gpio));
+		hrtimer_cancel(&ds->timer);
+		return 0;
+	}
+	if (func == GPIO_EVENT_FUNC_RESUME) {
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		if (ds->use_irq)
+			for (i = 0; i < di->keymap_size; i++)
+				enable_irq(gpio_to_irq(di->keymap[i].gpio));
+		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		if (ktime_to_ns(di->poll_time) <= 0)
+			di->poll_time = ktime_set(0, 20 * NSEC_PER_MSEC);
+
+		*data = ds = kzalloc(sizeof(*ds) + sizeof(ds->key_state[0]) *
+					di->keymap_size, GFP_KERNEL);
+		if (ds == NULL) {
+			ret = -ENOMEM;
+			pr_err("gpio_event_input_func: "
+				"Failed to allocate private data\n");
+			goto err_ds_alloc_failed;
+		}
+		ds->debounce_count = di->keymap_size;
+		ds->input_devs = input_devs;
+		ds->info = di;
+		wlname = kasprintf(GFP_KERNEL, "gpio_input:%s%s",
+				   input_devs->dev[0]->name,
+				   (input_devs->count > 1) ? "..." : "");
+
+		ds->ws = wakeup_source_register(wlname);
+		kfree(wlname);
+		if (!ds->ws) {
+			ret = -ENOMEM;
+			pr_err("gpio_event_input_func: "
+				"Failed to allocate wakeup source\n");
+			goto err_ws_failed;
+		}
+
+		spin_lock_init(&ds->irq_lock);
+
+		for (i = 0; i < di->keymap_size; i++) {
+			int dev = di->keymap[i].dev;
+			if (dev >= input_devs->count) {
+				pr_err("gpio_event_input_func: bad device "
+					"index %d >= %d for key code %d\n",
+					dev, input_devs->count,
+					di->keymap[i].code);
+				ret = -EINVAL;
+				goto err_bad_keymap;
+			}
+			input_set_capability(input_devs->dev[dev], di->type,
+					     di->keymap[i].code);
+			ds->key_state[i].ds = ds;
+			ds->key_state[i].debounce = DEBOUNCE_UNKNOWN;
+		}
+
+		for (i = 0; i < di->keymap_size; i++) {
+			ret = gpio_request(di->keymap[i].gpio, "gpio_kp_in");
+			if (ret) {
+				pr_err("gpio_event_input_func: gpio_request "
+					"failed for %d\n", di->keymap[i].gpio);
+				goto err_gpio_request_failed;
+			}
+			ret = gpio_direction_input(di->keymap[i].gpio);
+			if (ret) {
+				pr_err("gpio_event_input_func: "
+					"gpio_direction_input failed for %d\n",
+					di->keymap[i].gpio);
+				goto err_gpio_configure_failed;
+			}
+		}
+
+		ret = gpio_event_input_request_irqs(ds);
+
+		spin_lock_irqsave(&ds->irq_lock, irqflags);
+		ds->use_irq = ret == 0;
+
+		pr_info("GPIO Input Driver: Start gpio inputs for %s%s in %s "
+			"mode\n", input_devs->dev[0]->name,
+			(input_devs->count > 1) ? "..." : "",
+			ret == 0 ? "interrupt" : "polling");
+
+		hrtimer_init(&ds->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ds->timer.function = gpio_event_input_timer_func;
+		hrtimer_start(&ds->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+		spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+		return 0;
+	}
+
+	ret = 0;
+	spin_lock_irqsave(&ds->irq_lock, irqflags);
+	hrtimer_cancel(&ds->timer);
+	if (ds->use_irq) {
+		for (i = di->keymap_size - 1; i >= 0; i--) {
+			int irq = gpio_to_irq(di->keymap[i].gpio);
+			if (ds->info->info.no_suspend)
+				disable_irq_wake(irq);
+			free_irq(irq, &ds->key_state[i]);
+		}
+	}
+	spin_unlock_irqrestore(&ds->irq_lock, irqflags);
+
+	for (i = di->keymap_size - 1; i >= 0; i--) {
+err_gpio_configure_failed:
+		gpio_free(di->keymap[i].gpio);
+err_gpio_request_failed:
+		;
+	}
+err_bad_keymap:
+	wakeup_source_unregister(ds->ws);
+err_ws_failed:
+	kfree(ds);
+err_ds_alloc_failed:
+	return ret;
+}
diff --git a/drivers/input/misc/gpio_matrix.c b/drivers/input/misc/gpio_matrix.c
new file mode 100644
index 0000000..eaa9e89
--- /dev/null
+++ b/drivers/input/misc/gpio_matrix.c
@@ -0,0 +1,441 @@
+/* drivers/input/misc/gpio_matrix.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+#include <linux/hrtimer.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/wakelock.h>
+
+struct gpio_kp {
+	struct gpio_event_input_devs *input_devs;
+	struct gpio_event_matrix_info *keypad_info;
+	struct hrtimer timer;
+	struct wake_lock wake_lock;
+	int current_output;
+	unsigned int use_irq:1;
+	unsigned int key_state_changed:1;
+	unsigned int last_key_state_changed:1;
+	unsigned int some_keys_pressed:2;
+	unsigned int disabled_irq:1;
+	unsigned long keys_pressed[0];
+};
+
+static void clear_phantom_key(struct gpio_kp *kp, int out, int in)
+{
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	int key_index = out * mi->ninputs + in;
+	unsigned short keyentry = mi->keymap[key_index];
+	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+
+	if (!test_bit(keycode, kp->input_devs->dev[dev]->key)) {
+		if (mi->flags & GPIOKPF_PRINT_PHANTOM_KEYS)
+			pr_info("gpiomatrix: phantom key %x, %d-%d (%d-%d) "
+				"cleared\n", keycode, out, in,
+				mi->output_gpios[out], mi->input_gpios[in]);
+		__clear_bit(key_index, kp->keys_pressed);
+	} else {
+		if (mi->flags & GPIOKPF_PRINT_PHANTOM_KEYS)
+			pr_info("gpiomatrix: phantom key %x, %d-%d (%d-%d) "
+				"not cleared\n", keycode, out, in,
+				mi->output_gpios[out], mi->input_gpios[in]);
+	}
+}
+
+static int restore_keys_for_input(struct gpio_kp *kp, int out, int in)
+{
+	int rv = 0;
+	int key_index;
+
+	key_index = out * kp->keypad_info->ninputs + in;
+	while (out < kp->keypad_info->noutputs) {
+		if (test_bit(key_index, kp->keys_pressed)) {
+			rv = 1;
+			clear_phantom_key(kp, out, in);
+		}
+		key_index += kp->keypad_info->ninputs;
+		out++;
+	}
+	return rv;
+}
+
+static void remove_phantom_keys(struct gpio_kp *kp)
+{
+	int out, in, inp;
+	int key_index;
+
+	if (kp->some_keys_pressed < 3)
+		return;
+
+	for (out = 0; out < kp->keypad_info->noutputs; out++) {
+		inp = -1;
+		key_index = out * kp->keypad_info->ninputs;
+		for (in = 0; in < kp->keypad_info->ninputs; in++, key_index++) {
+			if (test_bit(key_index, kp->keys_pressed)) {
+				if (inp == -1) {
+					inp = in;
+					continue;
+				}
+				if (inp >= 0) {
+					if (!restore_keys_for_input(kp, out + 1,
+									inp))
+						break;
+					clear_phantom_key(kp, out, inp);
+					inp = -2;
+				}
+				restore_keys_for_input(kp, out, in);
+			}
+		}
+	}
+}
+
+static void report_key(struct gpio_kp *kp, int key_index, int out, int in)
+{
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	int pressed = test_bit(key_index, kp->keys_pressed);
+	unsigned short keyentry = mi->keymap[key_index];
+	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+
+	if (pressed != test_bit(keycode, kp->input_devs->dev[dev]->key)) {
+		if (keycode == KEY_RESERVED) {
+			if (mi->flags & GPIOKPF_PRINT_UNMAPPED_KEYS)
+				pr_info("gpiomatrix: unmapped key, %d-%d "
+					"(%d-%d) changed to %d\n",
+					out, in, mi->output_gpios[out],
+					mi->input_gpios[in], pressed);
+		} else {
+			if (mi->flags & GPIOKPF_PRINT_MAPPED_KEYS)
+				pr_info("gpiomatrix: key %x, %d-%d (%d-%d) "
+					"changed to %d\n", keycode,
+					out, in, mi->output_gpios[out],
+					mi->input_gpios[in], pressed);
+			input_report_key(kp->input_devs->dev[dev], keycode, pressed);
+		}
+	}
+}
+
+static void report_sync(struct gpio_kp *kp)
+{
+	int i;
+
+	for (i = 0; i < kp->input_devs->count; i++)
+		input_sync(kp->input_devs->dev[i]);
+}
+
+static enum hrtimer_restart gpio_keypad_timer_func(struct hrtimer *timer)
+{
+	int out, in;
+	int key_index;
+	int gpio;
+	struct gpio_kp *kp = container_of(timer, struct gpio_kp, timer);
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	unsigned gpio_keypad_flags = mi->flags;
+	unsigned polarity = !!(gpio_keypad_flags & GPIOKPF_ACTIVE_HIGH);
+
+	out = kp->current_output;
+	if (out == mi->noutputs) {
+		out = 0;
+		kp->last_key_state_changed = kp->key_state_changed;
+		kp->key_state_changed = 0;
+		kp->some_keys_pressed = 0;
+	} else {
+		key_index = out * mi->ninputs;
+		for (in = 0; in < mi->ninputs; in++, key_index++) {
+			gpio = mi->input_gpios[in];
+			if (gpio_get_value(gpio) ^ !polarity) {
+				if (kp->some_keys_pressed < 3)
+					kp->some_keys_pressed++;
+				kp->key_state_changed |= !__test_and_set_bit(
+						key_index, kp->keys_pressed);
+			} else
+				kp->key_state_changed |= __test_and_clear_bit(
+						key_index, kp->keys_pressed);
+		}
+		gpio = mi->output_gpios[out];
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(gpio, !polarity);
+		else
+			gpio_direction_input(gpio);
+		out++;
+	}
+	kp->current_output = out;
+	if (out < mi->noutputs) {
+		gpio = mi->output_gpios[out];
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(gpio, polarity);
+		else
+			gpio_direction_output(gpio, polarity);
+		hrtimer_start(timer, mi->settle_time, HRTIMER_MODE_REL);
+		return HRTIMER_NORESTART;
+	}
+	if (gpio_keypad_flags & GPIOKPF_DEBOUNCE) {
+		if (kp->key_state_changed) {
+			hrtimer_start(&kp->timer, mi->debounce_delay,
+				      HRTIMER_MODE_REL);
+			return HRTIMER_NORESTART;
+		}
+		kp->key_state_changed = kp->last_key_state_changed;
+	}
+	if (kp->key_state_changed) {
+		if (gpio_keypad_flags & GPIOKPF_REMOVE_SOME_PHANTOM_KEYS)
+			remove_phantom_keys(kp);
+		key_index = 0;
+		for (out = 0; out < mi->noutputs; out++)
+			for (in = 0; in < mi->ninputs; in++, key_index++)
+				report_key(kp, key_index, out, in);
+		report_sync(kp);
+	}
+	if (!kp->use_irq || kp->some_keys_pressed) {
+		hrtimer_start(timer, mi->poll_time, HRTIMER_MODE_REL);
+		return HRTIMER_NORESTART;
+	}
+
+	/* No keys are pressed, reenable interrupt */
+	for (out = 0; out < mi->noutputs; out++) {
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(mi->output_gpios[out], polarity);
+		else
+			gpio_direction_output(mi->output_gpios[out], polarity);
+	}
+	for (in = 0; in < mi->ninputs; in++)
+		enable_irq(gpio_to_irq(mi->input_gpios[in]));
+	wake_unlock(&kp->wake_lock);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gpio_keypad_irq_handler(int irq_in, void *dev_id)
+{
+	int i;
+	struct gpio_kp *kp = dev_id;
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+	unsigned gpio_keypad_flags = mi->flags;
+
+	if (!kp->use_irq) {
+		/* ignore interrupt while registering the handler */
+		kp->disabled_irq = 1;
+		disable_irq_nosync(irq_in);
+		return IRQ_HANDLED;
+	}
+
+	for (i = 0; i < mi->ninputs; i++)
+		disable_irq_nosync(gpio_to_irq(mi->input_gpios[i]));
+	for (i = 0; i < mi->noutputs; i++) {
+		if (gpio_keypad_flags & GPIOKPF_DRIVE_INACTIVE)
+			gpio_set_value(mi->output_gpios[i],
+				!(gpio_keypad_flags & GPIOKPF_ACTIVE_HIGH));
+		else
+			gpio_direction_input(mi->output_gpios[i]);
+	}
+	wake_lock(&kp->wake_lock);
+	hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+	return IRQ_HANDLED;
+}
+
+static int gpio_keypad_request_irqs(struct gpio_kp *kp)
+{
+	int i;
+	int err;
+	unsigned int irq;
+	unsigned long request_flags;
+	struct gpio_event_matrix_info *mi = kp->keypad_info;
+
+	switch (mi->flags & (GPIOKPF_ACTIVE_HIGH|GPIOKPF_LEVEL_TRIGGERED_IRQ)) {
+	default:
+		request_flags = IRQF_TRIGGER_FALLING;
+		break;
+	case GPIOKPF_ACTIVE_HIGH:
+		request_flags = IRQF_TRIGGER_RISING;
+		break;
+	case GPIOKPF_LEVEL_TRIGGERED_IRQ:
+		request_flags = IRQF_TRIGGER_LOW;
+		break;
+	case GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_ACTIVE_HIGH:
+		request_flags = IRQF_TRIGGER_HIGH;
+		break;
+	}
+
+	for (i = 0; i < mi->ninputs; i++) {
+		err = irq = gpio_to_irq(mi->input_gpios[i]);
+		if (err < 0)
+			goto err_gpio_get_irq_num_failed;
+		err = request_irq(irq, gpio_keypad_irq_handler, request_flags,
+				  "gpio_kp", kp);
+		if (err) {
+			pr_err("gpiomatrix: request_irq failed for input %d, "
+				"irq %d\n", mi->input_gpios[i], irq);
+			goto err_request_irq_failed;
+		}
+		err = enable_irq_wake(irq);
+		if (err) {
+			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
+				"irq %d\n", mi->input_gpios[i], irq);
+		}
+		disable_irq(irq);
+		if (kp->disabled_irq) {
+			kp->disabled_irq = 0;
+			enable_irq(irq);
+		}
+	}
+	return 0;
+
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+		free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
+err_request_irq_failed:
+err_gpio_get_irq_num_failed:
+		;
+	}
+	return err;
+}
+
+int gpio_event_matrix_func(struct gpio_event_input_devs *input_devs,
+	struct gpio_event_info *info, void **data, int func)
+{
+	int i;
+	int err;
+	int key_count;
+	struct gpio_kp *kp;
+	struct gpio_event_matrix_info *mi;
+
+	mi = container_of(info, struct gpio_event_matrix_info, info);
+	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME) {
+		/* TODO: disable scanning */
+		return 0;
+	}
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		if (mi->keymap == NULL ||
+		   mi->input_gpios == NULL ||
+		   mi->output_gpios == NULL) {
+			err = -ENODEV;
+			pr_err("gpiomatrix: Incomplete pdata\n");
+			goto err_invalid_platform_data;
+		}
+		key_count = mi->ninputs * mi->noutputs;
+
+		*data = kp = kzalloc(sizeof(*kp) + sizeof(kp->keys_pressed[0]) *
+				     BITS_TO_LONGS(key_count), GFP_KERNEL);
+		if (kp == NULL) {
+			err = -ENOMEM;
+			pr_err("gpiomatrix: Failed to allocate private data\n");
+			goto err_kp_alloc_failed;
+		}
+		kp->input_devs = input_devs;
+		kp->keypad_info = mi;
+		for (i = 0; i < key_count; i++) {
+			unsigned short keyentry = mi->keymap[i];
+			unsigned short keycode = keyentry & MATRIX_KEY_MASK;
+			unsigned short dev = keyentry >> MATRIX_CODE_BITS;
+			if (dev >= input_devs->count) {
+				pr_err("gpiomatrix: bad device index %d >= "
+					"%d for key code %d\n",
+					dev, input_devs->count, keycode);
+				err = -EINVAL;
+				goto err_bad_keymap;
+			}
+			if (keycode && keycode <= KEY_MAX)
+				input_set_capability(input_devs->dev[dev],
+							EV_KEY, keycode);
+		}
+
+		for (i = 0; i < mi->noutputs; i++) {
+			err = gpio_request(mi->output_gpios[i], "gpio_kp_out");
+			if (err) {
+				pr_err("gpiomatrix: gpio_request failed for "
+					"output %d\n", mi->output_gpios[i]);
+				goto err_request_output_gpio_failed;
+			}
+			if (gpio_cansleep(mi->output_gpios[i])) {
+				pr_err("gpiomatrix: unsupported output gpio %d,"
+					" can sleep\n", mi->output_gpios[i]);
+				err = -EINVAL;
+				goto err_output_gpio_configure_failed;
+			}
+			if (mi->flags & GPIOKPF_DRIVE_INACTIVE)
+				err = gpio_direction_output(mi->output_gpios[i],
+					!(mi->flags & GPIOKPF_ACTIVE_HIGH));
+			else
+				err = gpio_direction_input(mi->output_gpios[i]);
+			if (err) {
+				pr_err("gpiomatrix: gpio_configure failed for "
+					"output %d\n", mi->output_gpios[i]);
+				goto err_output_gpio_configure_failed;
+			}
+		}
+		for (i = 0; i < mi->ninputs; i++) {
+			err = gpio_request(mi->input_gpios[i], "gpio_kp_in");
+			if (err) {
+				pr_err("gpiomatrix: gpio_request failed for "
+					"input %d\n", mi->input_gpios[i]);
+				goto err_request_input_gpio_failed;
+			}
+			err = gpio_direction_input(mi->input_gpios[i]);
+			if (err) {
+				pr_err("gpiomatrix: gpio_direction_input failed"
+					" for input %d\n", mi->input_gpios[i]);
+				goto err_gpio_direction_input_failed;
+			}
+		}
+		kp->current_output = mi->noutputs;
+		kp->key_state_changed = 1;
+
+		hrtimer_init(&kp->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		kp->timer.function = gpio_keypad_timer_func;
+		wake_lock_init(&kp->wake_lock, WAKE_LOCK_SUSPEND, "gpio_kp");
+		err = gpio_keypad_request_irqs(kp);
+		kp->use_irq = err == 0;
+
+		pr_info("GPIO Matrix Keypad Driver: Start keypad matrix for "
+			"%s%s in %s mode\n", input_devs->dev[0]->name,
+			(input_devs->count > 1) ? "..." : "",
+			kp->use_irq ? "interrupt" : "polling");
+
+		if (kp->use_irq)
+			wake_lock(&kp->wake_lock);
+		hrtimer_start(&kp->timer, ktime_set(0, 0), HRTIMER_MODE_REL);
+
+		return 0;
+	}
+
+	err = 0;
+	kp = *data;
+
+	if (kp->use_irq)
+		for (i = mi->noutputs - 1; i >= 0; i--)
+			free_irq(gpio_to_irq(mi->input_gpios[i]), kp);
+
+	hrtimer_cancel(&kp->timer);
+	wake_lock_destroy(&kp->wake_lock);
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+err_gpio_direction_input_failed:
+		gpio_free(mi->input_gpios[i]);
+err_request_input_gpio_failed:
+		;
+	}
+	for (i = mi->noutputs - 1; i >= 0; i--) {
+err_output_gpio_configure_failed:
+		gpio_free(mi->output_gpios[i]);
+err_request_output_gpio_failed:
+		;
+	}
+err_bad_keymap:
+	kfree(kp);
+err_kp_alloc_failed:
+err_invalid_platform_data:
+	return err;
+}
diff --git a/drivers/input/misc/gpio_output.c b/drivers/input/misc/gpio_output.c
new file mode 100644
index 0000000..2aac2fa
--- /dev/null
+++ b/drivers/input/misc/gpio_output.c
@@ -0,0 +1,97 @@
+/* drivers/input/misc/gpio_output.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/gpio_event.h>
+
+int gpio_event_output_event(
+	struct gpio_event_input_devs *input_devs, struct gpio_event_info *info,
+	void **data, unsigned int dev, unsigned int type,
+	unsigned int code, int value)
+{
+	int i;
+	struct gpio_event_output_info *oi;
+	oi = container_of(info, struct gpio_event_output_info, info);
+	if (type != oi->type)
+		return 0;
+	if (!(oi->flags & GPIOEDF_ACTIVE_HIGH))
+		value = !value;
+	for (i = 0; i < oi->keymap_size; i++)
+		if (dev == oi->keymap[i].dev && code == oi->keymap[i].code)
+			gpio_set_value(oi->keymap[i].gpio, value);
+	return 0;
+}
+
+int gpio_event_output_func(
+	struct gpio_event_input_devs *input_devs, struct gpio_event_info *info,
+	void **data, int func)
+{
+	int ret;
+	int i;
+	struct gpio_event_output_info *oi;
+	oi = container_of(info, struct gpio_event_output_info, info);
+
+	if (func == GPIO_EVENT_FUNC_SUSPEND || func == GPIO_EVENT_FUNC_RESUME)
+		return 0;
+
+	if (func == GPIO_EVENT_FUNC_INIT) {
+		int output_level = !(oi->flags & GPIOEDF_ACTIVE_HIGH);
+
+		for (i = 0; i < oi->keymap_size; i++) {
+			int dev = oi->keymap[i].dev;
+			if (dev >= input_devs->count) {
+				pr_err("gpio_event_output_func: bad device "
+					"index %d >= %d for key code %d\n",
+					dev, input_devs->count,
+					oi->keymap[i].code);
+				ret = -EINVAL;
+				goto err_bad_keymap;
+			}
+			input_set_capability(input_devs->dev[dev], oi->type,
+					     oi->keymap[i].code);
+		}
+
+		for (i = 0; i < oi->keymap_size; i++) {
+			ret = gpio_request(oi->keymap[i].gpio,
+					   "gpio_event_output");
+			if (ret) {
+				pr_err("gpio_event_output_func: gpio_request "
+					"failed for %d\n", oi->keymap[i].gpio);
+				goto err_gpio_request_failed;
+			}
+			ret = gpio_direction_output(oi->keymap[i].gpio,
+						    output_level);
+			if (ret) {
+				pr_err("gpio_event_output_func: "
+					"gpio_direction_output failed for %d\n",
+					oi->keymap[i].gpio);
+				goto err_gpio_direction_output_failed;
+			}
+		}
+		return 0;
+	}
+
+	ret = 0;
+	for (i = oi->keymap_size - 1; i >= 0; i--) {
+err_gpio_direction_output_failed:
+		gpio_free(oi->keymap[i].gpio);
+err_gpio_request_failed:
+		;
+	}
+err_bad_keymap:
+	return ret;
+}
+
diff --git a/drivers/input/misc/keychord.c b/drivers/input/misc/keychord.c
new file mode 100644
index 0000000..a5ea27a
--- /dev/null
+++ b/drivers/input/misc/keychord.c
@@ -0,0 +1,391 @@
+/*
+ *  drivers/input/misc/keychord.c
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+*/
+
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/keychord.h>
+#include <linux/sched.h>
+
+#define KEYCHORD_NAME		"keychord"
+#define BUFFER_SIZE			16
+
+MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
+MODULE_DESCRIPTION("Key chord input driver");
+MODULE_SUPPORTED_DEVICE("keychord");
+MODULE_LICENSE("GPL");
+
+#define NEXT_KEYCHORD(kc) ((struct input_keychord *) \
+		((char *)kc + sizeof(struct input_keychord) + \
+		kc->count * sizeof(kc->keycodes[0])))
+
+struct keychord_device {
+	struct input_handler	input_handler;
+	int			registered;
+
+	/* list of keychords to monitor */
+	struct input_keychord	*keychords;
+	int			keychord_count;
+
+	/* bitmask of keys contained in our keychords */
+	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
+	/* current state of the keys */
+	unsigned long keystate[BITS_TO_LONGS(KEY_CNT)];
+	/* number of keys that are currently pressed */
+	int key_down;
+
+	/* second input_device_id is needed for null termination */
+	struct input_device_id  device_ids[2];
+
+	spinlock_t		lock;
+	wait_queue_head_t	waitq;
+	unsigned char		head;
+	unsigned char		tail;
+	__u16			buff[BUFFER_SIZE];
+};
+
+static int check_keychord(struct keychord_device *kdev,
+		struct input_keychord *keychord)
+{
+	int i;
+
+	if (keychord->count != kdev->key_down)
+		return 0;
+
+	for (i = 0; i < keychord->count; i++) {
+		if (!test_bit(keychord->keycodes[i], kdev->keystate))
+			return 0;
+	}
+
+	/* we have a match */
+	return 1;
+}
+
+static void keychord_event(struct input_handle *handle, unsigned int type,
+			   unsigned int code, int value)
+{
+	struct keychord_device *kdev = handle->private;
+	struct input_keychord *keychord;
+	unsigned long flags;
+	int i, got_chord = 0;
+
+	if (type != EV_KEY || code >= KEY_MAX)
+		return;
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* do nothing if key state did not change */
+	if (!test_bit(code, kdev->keystate) == !value)
+		goto done;
+	__change_bit(code, kdev->keystate);
+	if (value)
+		kdev->key_down++;
+	else
+		kdev->key_down--;
+
+	/* don't notify on key up */
+	if (!value)
+		goto done;
+	/* ignore this event if it is not one of the keys we are monitoring */
+	if (!test_bit(code, kdev->keybit))
+		goto done;
+
+	keychord = kdev->keychords;
+	if (!keychord)
+		goto done;
+
+	/* check to see if the keyboard state matches any keychords */
+	for (i = 0; i < kdev->keychord_count; i++) {
+		if (check_keychord(kdev, keychord)) {
+			kdev->buff[kdev->head] = keychord->id;
+			kdev->head = (kdev->head + 1) % BUFFER_SIZE;
+			got_chord = 1;
+			break;
+		}
+		/* skip to next keychord */
+		keychord = NEXT_KEYCHORD(keychord);
+	}
+
+done:
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	if (got_chord) {
+		pr_info("keychord: got keychord id %d. Any tasks: %d\n",
+			keychord->id,
+			!list_empty_careful(&kdev->waitq.task_list));
+		wake_up_interruptible(&kdev->waitq);
+	}
+}
+
+static int keychord_connect(struct input_handler *handler,
+					  struct input_dev *dev,
+					  const struct input_device_id *id)
+{
+	int i, ret;
+	struct input_handle *handle;
+	struct keychord_device *kdev =
+		container_of(handler, struct keychord_device, input_handler);
+
+	/*
+	 * ignore this input device if it does not contain any keycodes
+	 * that we are monitoring
+	 */
+	for (i = 0; i < KEY_MAX; i++) {
+		if (test_bit(i, kdev->keybit) && test_bit(i, dev->keybit))
+			break;
+	}
+	if (i == KEY_MAX)
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = KEYCHORD_NAME;
+	handle->private = kdev;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_input_register_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_input_open_device;
+
+	pr_info("keychord: using input dev %s for fevent\n", dev->name);
+
+	return 0;
+
+err_input_open_device:
+	input_unregister_handle(handle);
+err_input_register_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void keychord_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+/*
+ * keychord_read is used to read keychord events from the driver
+ */
+static ssize_t keychord_read(struct file *file, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct keychord_device *kdev = file->private_data;
+	__u16   id;
+	int retval;
+	unsigned long flags;
+
+	if (count < sizeof(id))
+		return -EINVAL;
+	count = sizeof(id);
+
+	if (kdev->head == kdev->tail && (file->f_flags & O_NONBLOCK))
+		return -EAGAIN;
+
+	retval = wait_event_interruptible(kdev->waitq,
+			kdev->head != kdev->tail);
+	if (retval)
+		return retval;
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* pop a keychord ID off the queue */
+	id = kdev->buff[kdev->tail];
+	kdev->tail = (kdev->tail + 1) % BUFFER_SIZE;
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	if (copy_to_user(buffer, &id, count))
+		return -EFAULT;
+
+	return count;
+}
+
+/*
+ * keychord_write is used to configure the driver
+ */
+static ssize_t keychord_write(struct file *file, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	struct keychord_device *kdev = file->private_data;
+	struct input_keychord *keychords = 0;
+	struct input_keychord *keychord, *next, *end;
+	int ret, i, key;
+	unsigned long flags;
+
+	if (count < sizeof(struct input_keychord))
+		return -EINVAL;
+	keychords = kzalloc(count, GFP_KERNEL);
+	if (!keychords)
+		return -ENOMEM;
+
+	/* read list of keychords from userspace */
+	if (copy_from_user(keychords, buffer, count)) {
+		kfree(keychords);
+		return -EFAULT;
+	}
+
+	/* unregister handler before changing configuration */
+	if (kdev->registered) {
+		input_unregister_handler(&kdev->input_handler);
+		kdev->registered = 0;
+	}
+
+	spin_lock_irqsave(&kdev->lock, flags);
+	/* clear any existing configuration */
+	kfree(kdev->keychords);
+	kdev->keychords = 0;
+	kdev->keychord_count = 0;
+	kdev->key_down = 0;
+	memset(kdev->keybit, 0, sizeof(kdev->keybit));
+	memset(kdev->keystate, 0, sizeof(kdev->keystate));
+	kdev->head = kdev->tail = 0;
+
+	keychord = keychords;
+	end = (struct input_keychord *)((char *)keychord + count);
+
+	while (keychord < end) {
+		next = NEXT_KEYCHORD(keychord);
+		if (keychord->count <= 0 || next > end) {
+			pr_err("keychord: invalid keycode count %d\n",
+				keychord->count);
+			goto err_unlock_return;
+		}
+		if (keychord->version != KEYCHORD_VERSION) {
+			pr_err("keychord: unsupported version %d\n",
+				keychord->version);
+			goto err_unlock_return;
+		}
+
+		/* keep track of the keys we are monitoring in keybit */
+		for (i = 0; i < keychord->count; i++) {
+			key = keychord->keycodes[i];
+			if (key < 0 || key >= KEY_CNT) {
+				pr_err("keychord: keycode %d out of range\n",
+					key);
+				goto err_unlock_return;
+			}
+			__set_bit(key, kdev->keybit);
+		}
+
+		kdev->keychord_count++;
+		keychord = next;
+	}
+
+	kdev->keychords = keychords;
+	spin_unlock_irqrestore(&kdev->lock, flags);
+
+	ret = input_register_handler(&kdev->input_handler);
+	if (ret) {
+		kfree(keychords);
+		kdev->keychords = 0;
+		return ret;
+	}
+	kdev->registered = 1;
+
+	return count;
+
+err_unlock_return:
+	spin_unlock_irqrestore(&kdev->lock, flags);
+	kfree(keychords);
+	return -EINVAL;
+}
+
+static unsigned int keychord_poll(struct file *file, poll_table *wait)
+{
+	struct keychord_device *kdev = file->private_data;
+
+	poll_wait(file, &kdev->waitq, wait);
+
+	if (kdev->head != kdev->tail)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+static int keychord_open(struct inode *inode, struct file *file)
+{
+	struct keychord_device *kdev;
+
+	kdev = kzalloc(sizeof(struct keychord_device), GFP_KERNEL);
+	if (!kdev)
+		return -ENOMEM;
+
+	spin_lock_init(&kdev->lock);
+	init_waitqueue_head(&kdev->waitq);
+
+	kdev->input_handler.event = keychord_event;
+	kdev->input_handler.connect = keychord_connect;
+	kdev->input_handler.disconnect = keychord_disconnect;
+	kdev->input_handler.name = KEYCHORD_NAME;
+	kdev->input_handler.id_table = kdev->device_ids;
+
+	kdev->device_ids[0].flags = INPUT_DEVICE_ID_MATCH_EVBIT;
+	__set_bit(EV_KEY, kdev->device_ids[0].evbit);
+
+	file->private_data = kdev;
+
+	return 0;
+}
+
+static int keychord_release(struct inode *inode, struct file *file)
+{
+	struct keychord_device *kdev = file->private_data;
+
+	if (kdev->registered)
+		input_unregister_handler(&kdev->input_handler);
+	kfree(kdev);
+
+	return 0;
+}
+
+static const struct file_operations keychord_fops = {
+	.owner		= THIS_MODULE,
+	.open		= keychord_open,
+	.release	= keychord_release,
+	.read		= keychord_read,
+	.write		= keychord_write,
+	.poll		= keychord_poll,
+};
+
+static struct miscdevice keychord_misc = {
+	.fops		= &keychord_fops,
+	.name		= KEYCHORD_NAME,
+	.minor		= MISC_DYNAMIC_MINOR,
+};
+
+static int __init keychord_init(void)
+{
+	return misc_register(&keychord_misc);
+}
+
+static void __exit keychord_exit(void)
+{
+	misc_deregister(&keychord_misc);
+}
+
+module_init(keychord_init);
+module_exit(keychord_exit);
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 2a21419..14766f8 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -451,6 +451,12 @@ config TOUCHSCREEN_TNETV107X
 	  To compile this driver as a module, choose M here: the
 	  module will be called tnetv107x-ts.
 
+config TOUCHSCREEN_SYNAPTICS_I2C_RMI
+	tristate "Synaptics i2c touchscreen"
+	depends on I2C
+	help
+	  This enables support for Synaptics RMI over I2C based touchscreens.
+
 config TOUCHSCREEN_TOUCHRIGHT
 	tristate "Touchright serial touchscreen"
 	select SERIO
@@ -845,4 +851,41 @@ config TOUCHSCREEN_TPS6507X
 	  To compile this driver as a module, choose M here: the
 	  module will be called tps6507x_ts.
 
+config  TOUCHSCREEN_GT801
+       tristate  "dpt microelctronics gt801 touchscreen driver"
+       depends on I2C
+       help
+          GT801 touchscreen driver
+
+config  TOUCHSCREEN_GT811
+       tristate  "dpt microelctronics gt811 touchscreen driver"
+       depends on I2C
+       help
+          GT811 touchscreen driver
+
+config  TOUCHSCREEN_GT818
+       tristate  "dpt microelctronics gt818 touchscreen driver"
+       depends on I2C
+       help
+          GT801 touchscreen driver
+
+config  TOUCHSCREEN_SUN4I_TS
+       tristate  "sun4i-ts touchscreen driver"
+       help
+           sun4i-ts touchscreen driver
+
+config TOUCHSCREEN_FT5X_TS
+       tristate  "ft5x touchscreen driver"
+       help
+         byd0x7ets touchscreen driver
+
+config  TOUCHSCREEN_ZT8031
+       tristate  "ZT8031 touchscreen driver"
+       help
+          ZT8031 touchscreen driver
+          
+config  TOUCHSCREEN_COASIA
+       tristate  "COASIA touchscreen driver"
+       help
+          COASIA touchscreen driver
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 3d5cf8c..ede86ce 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -51,6 +51,7 @@ obj-$(CONFIG_TOUCHSCREEN_ST1232)	+= st1232.o
 obj-$(CONFIG_TOUCHSCREEN_STMPE)		+= stmpe-ts.o
 obj-$(CONFIG_TOUCHSCREEN_TI_TSCADC)	+= ti_tscadc.o
 obj-$(CONFIG_TOUCHSCREEN_TNETV107X)	+= tnetv107x-ts.o
+obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
@@ -69,3 +70,11 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5X_TS) += ft5x_ts.o
+obj-$(CONFIG_TOUCHSCREEN_GT801)         += goodix_touch.o
+obj-$(CONFIG_TOUCHSCREEN_GT811)         += gt811_ts.o
+obj-$(CONFIG_TOUCHSCREEN_GT818)         += gt818_ts.o
+obj-$(CONFIG_TOUCHSCREEN_ZT8031)         += zt8031.o
+obj-$(CONFIG_TOUCHSCREEN_COASIA)         += coasia_i2c.o
+obj-$(CONFIG_TOUCHSCREEN_SUN4I_TS)         += sun4i-ts.o
+
diff --git a/drivers/input/touchscreen/ctp_platform_ops.h b/drivers/input/touchscreen/ctp_platform_ops.h
new file mode 100644
index 0000000..eef3c4a
--- /dev/null
+++ b/drivers/input/touchscreen/ctp_platform_ops.h
@@ -0,0 +1,122 @@
+/*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*
+* Copyright (c) 2009
+*
+* ChangeLog
+*
+*
+*/
+#ifndef _CTP_PLATFORM_OPS_H_
+#define _CTP_PLATFORM_OPS_H_
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <mach/irqs.h>
+#include <linux/i2c.h>
+
+// gpio base address
+#define PIO_BASE_ADDRESS	(0x01c20800)
+#define PIO_RANGE_SIZE		(0x400)
+#define GPIO_ENABLE
+#define SYSCONFIG_GPIO_ENABLE
+
+#define PIO_INT_STAT_OFFSET          (0x214)
+#define PIO_INT_CTRL_OFFSET          (0x210)
+
+#define PIO_PN_DAT_OFFSET(n)         ((n)*0x24 + 0x10)
+//#define PIOI_DATA                    (0x130)
+#define PIOH_DATA                    (0x10c)
+#define PIOI_CFG3_OFFSET             (0x12c)
+
+#define PRESS_DOWN	(1)
+#define FREE_UP		(0)
+
+#define IRQ_EINT0	(0)
+#define IRQ_EINT1	(1)
+#define IRQ_EINT2	(2)
+#define IRQ_EINT3	(3)
+#define IRQ_EINT4	(4)
+#define IRQ_EINT5	(5)
+#define IRQ_EINT6	(6)
+#define IRQ_EINT7	(7)
+#define IRQ_EINT8	(8)
+#define IRQ_EINT9	(9)
+#define IRQ_EINT10	(10)
+#define IRQ_EINT11	(11)
+#define IRQ_EINT12	(12)
+#define IRQ_EINT13	(13)
+#define IRQ_EINT14	(14)
+#define IRQ_EINT15	(15)
+#define IRQ_EINT16	(16)
+#define IRQ_EINT17	(17)
+#define IRQ_EINT18	(18)
+#define IRQ_EINT19	(19)
+#define IRQ_EINT20	(20)
+#define IRQ_EINT21	(21)
+#define IRQ_EINT22	(22)
+#define IRQ_EINT23	(23)
+#define IRQ_EINT24	(24)
+#define IRQ_EINT25	(25)
+#define IRQ_EINT26	(26)
+#define IRQ_EINT27	(27)
+#define IRQ_EINT28	(28)
+#define IRQ_EINT29	(29)
+#define IRQ_EINT30	(30)
+#define IRQ_EINT31	(31)
+
+typedef enum {
+     PIO_INT_CFG0_OFFSET = 0x200,
+     PIO_INT_CFG1_OFFSET = 0x204,
+     PIO_INT_CFG2_OFFSET = 0x208,
+     PIO_INT_CFG3_OFFSET = 0x20c,
+} int_cfg_offset;
+
+typedef enum{
+	POSITIVE_EDGE = 0x0,
+	NEGATIVE_EDGE = 0x1,
+	HIGH_LEVEL = 0x2,
+	LOW_LEVEL = 0x3,
+	DOUBLE_EDGE = 0x4
+} ext_int_mode;
+
+struct ctp_platform_ops{
+	int         irq;
+	bool        pendown;
+	int	(*get_pendown_state)(void);
+	void        (*clear_penirq)(void);
+	int         (*set_irq_mode)(char *major_key , char *subkey, ext_int_mode int_mode);
+	int         (*set_gpio_mode)(void);
+	int         (*judge_int_occur)(void);
+	int         (*init_platform_resource)(void);
+	void        (*free_platform_resource)(void);
+	int         (*fetch_sysconfig_para)(void);
+	void        (*ts_reset)(void);
+	void        (*ts_wakeup)(void);
+	int (*ts_detect)(struct i2c_client *client, struct i2c_board_info *info);
+};
+
+#endif /*_CTP_PLATFORM_OPS_H_*/
+
diff --git a/drivers/input/touchscreen/ft5x_ts.c b/drivers/input/touchscreen/ft5x_ts.c
new file mode 100644
index 0000000..5d8dc97
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x_ts.c
@@ -0,0 +1,2001 @@
+/*
+ * drivers/input/touchscreen/ft5x0x_ts.c
+ *
+ * FocalTech ft5x TouchScreen driver.
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *	note: only support mulititouch	Wenfs 2010-10-01
+ *  for this touchscreen to work, it's slave addr must be set to 0x7e | 0x70
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include "ft5x_ts.h"
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    #include <linux/pm.h>
+    #include <linux/earlysuspend.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/async.h>
+#include <linux/hrtimer.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <mach/irqs.h>
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+#include "ctp_platform_ops.h"
+
+#define FOR_TSLIB_TEST
+//#define PRINT_INT_INFO
+//#define PRINT_POINT_INFO
+//#define DEBUG
+//#define TOUCH_KEY_SUPPORT
+#ifdef TOUCH_KEY_SUPPORT
+//#define TOUCH_KEY_LIGHT_SUPPORT
+//#define TOUCH_KEY_FOR_EVB13
+//#define TOUCH_KEY_FOR_ANGDA
+#ifdef TOUCH_KEY_FOR_ANGDA
+#define TOUCH_KEY_X_LIMIT	(60000)
+#define TOUCH_KEY_NUMBER	(4)
+#endif
+#ifdef TOUCH_KEY_FOR_EVB13
+#define TOUCH_KEY_LOWER_X_LIMIT	(848)
+#define TOUCH_KEY_HIGHER_X_LIMIT	(852)
+#define TOUCH_KEY_NUMBER	(5)
+#endif
+#endif
+
+//#define CONFIG_SUPPORT_FTS_CTP_UPG
+
+struct i2c_dev{
+struct list_head list;
+struct i2c_adapter *adap;
+struct device *dev;
+};
+
+static struct class *i2c_dev_class;
+static LIST_HEAD (i2c_dev_list);
+static DEFINE_SPINLOCK(i2c_dev_list_lock);
+
+#define FT5X_NAME	"ft5x_ts"//"synaptics_i2c_rmi"//"synaptics-rmi-ts"//
+#define CHARDEV_NAME    "aw_i2c_ts"
+
+static struct i2c_client *this_client;
+#ifdef TOUCH_KEY_LIGHT_SUPPORT
+static int gpio_light_hdle = 0;
+#endif
+#ifdef TOUCH_KEY_SUPPORT
+static int key_tp  = 0;
+static int key_val = 0;
+#endif
+
+#ifdef PRINT_POINT_INFO
+#define print_point_info(fmt, args...)   \
+        do{                              \
+                pr_info(fmt, ##args);     \
+        }while(0)
+#else
+#define print_point_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_INT_INFO
+#define print_int_info(fmt, args...)     \
+        do{                              \
+                pr_info(fmt, ##args);     \
+        }while(0)
+#else
+#define print_int_info(fmt, args...)   //
+#endif
+///////////////////////////////////////////////
+//specific tp related macro: need be configured for specific tp
+#define CTP_IRQ_NO			(gpio_int_info[0].port_num)
+
+#define CTP_IRQ_MODE			(NEGATIVE_EDGE)
+#define CTP_NAME			FT5X_NAME
+#define TS_RESET_LOW_PERIOD		(1)
+#define TS_INITIAL_HIGH_PERIOD		(30)
+#define TS_WAKEUP_LOW_PERIOD	(20)
+#define TS_WAKEUP_HIGH_PERIOD	(20)
+#define TS_POLL_DELAY			(10)	/* ms delay between samples */
+#define TS_POLL_PERIOD			(10)	/* ms delay between samples */
+#define SCREEN_MAX_X			(screen_max_x)
+#define SCREEN_MAX_Y			(screen_max_y)
+#define PRESS_MAX			(255)
+
+
+static void* __iomem gpio_addr = NULL;
+static int gpio_int_hdle = 0;
+static int gpio_wakeup_hdle = 0;
+static int gpio_reset_hdle = 0;
+static int gpio_wakeup_enable = 1;
+static int gpio_reset_enable = 1;
+static int gpio_power_hdle;
+static user_gpio_set_t gpio_int_info[1];
+
+static int screen_max_x = 0;
+static int screen_max_y = 0;
+static int revert_x_flag = 0;
+static int revert_y_flag = 0;
+static int exchange_x_y_flag = 0;
+static int	int_cfg_addr[]={PIO_INT_CFG0_OFFSET,PIO_INT_CFG1_OFFSET,
+			PIO_INT_CFG2_OFFSET, PIO_INT_CFG3_OFFSET};
+/* Addresses to scan */
+static union{
+	unsigned short dirty_addr_buf[2];
+	const unsigned short normal_i2c[2];
+}u_i2c_addr = {{0x00},};
+static __u32 twi_id = 0;
+
+/*
+ * ctp_get_pendown_state  : get the int_line data state,
+ *
+ * return value:
+ *             return PRESS_DOWN: if down
+ *             return FREE_UP: if up,
+ *             return 0: do not need process, equal free up.
+ */
+static int ctp_get_pendown_state(void)
+{
+	unsigned int reg_val;
+	static int state = FREE_UP;
+
+	//get the input port state
+	reg_val = readl(gpio_addr + PIOH_DATA);
+	//pr_info("reg_val = %x\n",reg_val);
+	if(!(reg_val & (1<<CTP_IRQ_NO))){
+		state = PRESS_DOWN;
+		print_int_info("pen down. \n");
+	}else{ //touch panel is free up
+		state = FREE_UP;
+		print_int_info("free up. \n");
+	}
+	return state;
+}
+
+/**
+ * ctp_clear_penirq - clear int pending
+ *
+ */
+static void ctp_clear_penirq(void)
+{
+	int reg_val;
+	//clear the IRQ_EINT29 interrupt pending
+	//pr_info("clear pend irq pending\n");
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val&(1<<(IRQ_EINT21)),gpio_addr + PIO_INT_STAT_OFFSET);
+	if((reg_val = (reg_val&(1<<(CTP_IRQ_NO))))){
+		print_int_info("==CTP_IRQ_NO=\n");
+		writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+	}
+	return;
+}
+
+/**
+ * ctp_set_irq_mode - according sysconfig's subkey "ctp_int_port" to config int port.
+ *
+ * return value:
+ *              0:      success;
+ *              others: fail;
+ */
+static int ctp_set_irq_mode(char *major_key, char *subkey, ext_int_mode int_mode)
+{
+	int ret = 0;
+	__u32 reg_num = 0;
+	__u32 reg_addr = 0;
+	__u32 reg_val = 0;
+	//config gpio to int mode
+	pr_info("%s: config gpio to int mode. \n", __func__);
+#ifndef SYSCONFIG_GPIO_ENABLE
+#else
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	gpio_int_hdle = gpio_request_ex(major_key, subkey);
+	if(!gpio_int_hdle){
+		pr_info("request tp_int_port failed. \n");
+		ret = -1;
+		goto request_tp_int_port_failed;
+	}
+	gpio_get_one_pin_status(gpio_int_hdle, gpio_int_info, subkey, 1);
+	pr_info("%s, %d: gpio_int_info, port = %d, port_num = %d. \n", __func__, __LINE__, \
+		gpio_int_info[0].port, gpio_int_info[0].port_num);
+#endif
+
+#ifdef AW_GPIO_INT_API_ENABLE
+#else
+	pr_info(" INTERRUPT CONFIG\n");
+	reg_num = (gpio_int_info[0].port_num)%8;
+	reg_addr = (gpio_int_info[0].port_num)/8;
+	reg_val = readl(gpio_addr + int_cfg_addr[reg_addr]);
+	reg_val &= (~(7 << (reg_num * 4)));
+	reg_val |= (int_mode << (reg_num * 4));
+	writel(reg_val,gpio_addr+int_cfg_addr[reg_addr]);
+
+	ctp_clear_penirq();
+
+	reg_val = readl(gpio_addr+PIO_INT_CTRL_OFFSET);
+	reg_val |= (1 << (gpio_int_info[0].port_num));
+	writel(reg_val,gpio_addr+PIO_INT_CTRL_OFFSET);
+
+	udelay(1);
+#endif
+
+request_tp_int_port_failed:
+	return ret;
+}
+
+/**
+ * ctp_set_gpio_mode - according sysconfig's subkey "ctp_io_port" to config io port.
+ *
+ * return value:
+ *              0:      success;
+ *              others: fail;
+ */
+static int ctp_set_gpio_mode(void)
+{
+	//int reg_val;
+	int ret = 0;
+	//config gpio to io mode
+	pr_info("%s: config gpio to io mode. \n", __func__);
+#ifndef SYSCONFIG_GPIO_ENABLE
+#else
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	gpio_int_hdle = gpio_request_ex("ctp_para", "ctp_io_port");
+	if(!gpio_int_hdle){
+		pr_info("request ctp_io_port failed. \n");
+		ret = -1;
+		goto request_tp_io_port_failed;
+	}
+#endif
+	return ret;
+
+request_tp_io_port_failed:
+	return ret;
+}
+
+/**
+ * ctp_judge_int_occur - whether interrupt occur.
+ *
+ * return value:
+ *              0:      int occur;
+ *              others: no int occur;
+ */
+static int ctp_judge_int_occur(void)
+{
+	//int reg_val[3];
+	int reg_val;
+	int ret = -1;
+
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	if(reg_val&(1<<(CTP_IRQ_NO))){
+		ret = 0;
+	}
+	return ret;
+}
+
+/**
+ * ctp_free_platform_resource - corresponding with ctp_init_platform_resource
+ *
+ */
+static void ctp_free_platform_resource(void)
+{
+	if(gpio_addr){
+		iounmap(gpio_addr);
+	}
+
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+
+	if(gpio_wakeup_hdle){
+		gpio_release(gpio_wakeup_hdle, 2);
+	}
+
+	if(gpio_reset_hdle){
+		gpio_release(gpio_reset_hdle, 2);
+	}
+	if (gpio_power_hdle)
+		gpio_release(gpio_power_hdle, 2);
+	return;
+}
+
+
+/**
+ * ctp_init_platform_resource - initialize platform related resource
+ * return value: 0 : success
+ *               -EIO :  i/o err.
+ *
+ */
+static int ctp_init_platform_resource(void)
+{
+	int ret = 0;
+
+	gpio_addr = ioremap(PIO_BASE_ADDRESS, PIO_RANGE_SIZE);
+	//pr_info("%s, gpio_addr = 0x%x. \n", __func__, gpio_addr);
+	if(!gpio_addr) {
+		ret = -EIO;
+		goto exit_ioremap_failed;
+	}
+	//    gpio_wakeup_enable = 1;
+	gpio_wakeup_hdle = gpio_request_ex("ctp_para", "ctp_wakeup");
+	if(!gpio_wakeup_hdle) {
+		pr_warning("%s: tp_wakeup request gpio fail!\n", __func__);
+		gpio_wakeup_enable = 0;
+	}
+
+	gpio_reset_hdle = gpio_request_ex("ctp_para", "ctp_reset");
+	if(!gpio_reset_hdle) {
+		pr_warning("%s: tp_reset request gpio fail!\n", __func__);
+		gpio_reset_enable = 0;
+	}
+	/* On some tables (for example: Explay informer 801) ts powered over*/
+	/* MOSFET switch, with gate connected to GPIO pin. */
+	gpio_power_hdle = gpio_request_ex("ctp_para", "ctp_power_port");
+	if (!gpio_power_hdle)
+		pr_info("%s: No power port feature present.\n", __func__);
+	else {
+		ret = gpio_write_one_pin_value(gpio_power_hdle, 1, "ctp_power_port");
+		if (ret != EGPIO_SUCCESS)
+			pr_info("%s: ctp_power_port gpio set error.\n", __func__);
+		else
+			pr_info("%s: power port enabled\n", __func__);
+	}
+	return ret;
+
+exit_ioremap_failed:
+	ctp_free_platform_resource();
+	return ret;
+}
+
+
+/**
+ * ctp_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int ctp_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int ctp_used = -1;
+	char name[I2C_NAME_SIZE];
+	__u32 twi_addr = 0;
+	//__u32 twi_id = 0;
+	script_parser_value_type_t type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+
+	pr_info("%s. \n", __func__);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_used", &ctp_used, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	if(1 != ctp_used){
+		pr_err("%s: ctp_unused. \n",  __func__);
+		//ret = 1;
+		return ret;
+	}
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch_ex("ctp_para", "ctp_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	if(strcmp(CTP_NAME, name)){
+		pr_err("%s: name %s does not match CTP_NAME. \n", __func__, name);
+		pr_err(CTP_NAME);
+		//ret = 1;
+		return ret;
+	}
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_twi_addr", &twi_addr, sizeof(twi_addr)/sizeof(__u32))){
+		pr_err("%s: script_parser_fetch err. \n", name);
+		goto script_parser_fetch_err;
+	}
+	//big-endian or small-endian?
+	//pr_info("%s: before: ctp_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+	u_i2c_addr.dirty_addr_buf[0] = twi_addr;
+	u_i2c_addr.dirty_addr_buf[1] = I2C_CLIENT_END;
+	pr_info("%s: after: ctp_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+	//pr_info("%s: after: ctp_twi_addr is 0x%x, u32_dirty_addr_buf: 0x%hx. u32_dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u32_dirty_addr_buf[0],u32_dirty_addr_buf[1]);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_twi_id", &twi_id, sizeof(twi_id)/sizeof(__u32))){
+		pr_err("%s: script_parser_fetch err. \n", name);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: ctp_twi_id is %d. \n", __func__, twi_id);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_x", &screen_max_x, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: screen_max_x = %d. \n", __func__, screen_max_x);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_y", &screen_max_y, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: screen_max_y = %d. \n", __func__, screen_max_y);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_x_flag", &revert_x_flag, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: revert_x_flag = %d. \n", __func__, revert_x_flag);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_y_flag", &revert_y_flag, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: revert_y_flag = %d. \n", __func__, revert_y_flag);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_exchange_x_y_flag", &exchange_x_y_flag, 1)){
+		pr_err("ft5x_ts: script_parser_fetch err. \n");
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: exchange_x_y_flag = %d. \n", __func__, exchange_x_y_flag);
+
+	return 0;
+
+script_parser_fetch_err:
+	pr_notice("=========script_parser_fetch_err============\n");
+	return ret;
+}
+
+/**
+ * ctp_reset - function
+ *
+ */
+static void ctp_reset(void)
+{
+	if(gpio_reset_enable){
+		pr_info("%s. \n", __func__);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 0, "ctp_reset")){
+			pr_info("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_RESET_LOW_PERIOD);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 1, "ctp_reset")){
+			pr_info("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_INITIAL_HIGH_PERIOD);
+	}
+}
+
+/**
+ * ctp_wakeup - function
+ *
+ */
+static void ctp_wakeup(void)
+{
+	if(1 == gpio_wakeup_enable){
+		pr_info("%s. \n", __func__);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup")){
+			pr_info("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_WAKEUP_LOW_PERIOD);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 1, "ctp_wakeup")){
+			pr_info("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_WAKEUP_HIGH_PERIOD);
+
+	}
+	return;
+}
+/**
+ * ctp_detect - Device detection callback for automatic device creation
+ * return value:
+ *                    = 0; success;
+ *                    < 0; err
+ */
+int ctp_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if(twi_id == adapter->nr)
+	{
+		pr_info("%s: Detected chip %s at adapter %d, address 0x%02x\n",
+			 __func__, CTP_NAME, i2c_adapter_id(adapter), client->addr);
+
+		strlcpy(info->type, CTP_NAME, I2C_NAME_SIZE);
+		return 0;
+	}else{
+		return -ENODEV;
+	}
+}
+////////////////////////////////////////////////////////////////
+
+static struct ctp_platform_ops ctp_ops = {
+	.get_pendown_state = ctp_get_pendown_state,
+	.clear_penirq	   = ctp_clear_penirq,
+	.set_irq_mode      = ctp_set_irq_mode,
+	.set_gpio_mode     = ctp_set_gpio_mode,
+	.judge_int_occur   = ctp_judge_int_occur,
+	.init_platform_resource = ctp_init_platform_resource,
+	.free_platform_resource = ctp_free_platform_resource,
+	.fetch_sysconfig_para = ctp_fetch_sysconfig_para,
+	.ts_reset =          ctp_reset,
+	.ts_wakeup =         ctp_wakeup,
+	.ts_detect = ctp_detect,
+};
+
+int fts_ctpm_fw_upgrade_with_i_file(void);
+
+static struct i2c_dev *i2c_dev_get_by_minor(unsigned index)
+{
+	struct i2c_dev *i2c_dev;
+	spin_lock(&i2c_dev_list_lock);
+
+	list_for_each_entry(i2c_dev,&i2c_dev_list,list){
+		pr_info("--line = %d ,i2c_dev->adapt->nr = %d,index = %d.\n",__LINE__,i2c_dev->adap->nr,index);
+		if(i2c_dev->adap->nr == index){
+		     goto found;
+		}
+	}
+	i2c_dev = NULL;
+
+found:
+	spin_unlock(&i2c_dev_list_lock);
+
+	return i2c_dev ;
+}
+
+static struct i2c_dev *get_free_i2c_dev(struct i2c_adapter *adap)
+{
+	struct i2c_dev *i2c_dev;
+
+	if (adap->nr >= I2C_MINORS){
+		pr_info("i2c-dev:out of device minors (%d) \n",adap->nr);
+		return ERR_PTR (-ENODEV);
+	}
+
+	i2c_dev = kzalloc(sizeof(*i2c_dev), GFP_KERNEL);
+	if (!i2c_dev){
+		return ERR_PTR(-ENOMEM);
+	}
+	i2c_dev->adap = adap;
+
+	spin_lock(&i2c_dev_list_lock);
+	list_add_tail(&i2c_dev->list, &i2c_dev_list);
+	spin_unlock(&i2c_dev_list_lock);
+
+	return i2c_dev;
+}
+
+
+static int ft5x_i2c_rxdata(char *rxdata, int length);
+
+struct ts_event {
+	u16	x1;
+	u16	y1;
+	u16	x2;
+	u16	y2;
+	u16	x3;
+	u16	y3;
+	u16	x4;
+	u16	y4;
+	u16	x5;
+	u16	y5;
+	u16	pressure;
+	s16 touch_ID1;
+	s16 touch_ID2;
+	s16 touch_ID3;
+	s16 touch_ID4;
+	s16 touch_ID5;
+    u8  touch_point;
+};
+
+struct ft5x_ts_data {
+	struct input_dev	*input_dev;
+	struct ts_event		event;
+	struct work_struct 	pen_event_work;
+	struct workqueue_struct *ts_workqueue;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend	early_suspend;
+#endif
+};
+
+
+/* ---------------------------------------------------------------------
+*
+*   Focal Touch panel upgrade related driver
+*
+*
+----------------------------------------------------------------------*/
+
+typedef enum
+{
+	ERR_OK,
+	ERR_MODE,
+	ERR_READID,
+	ERR_ERASE,
+	ERR_STATUS,
+	ERR_ECC,
+	ERR_DL_ERASE_FAIL,
+	ERR_DL_PROGRAM_FAIL,
+	ERR_DL_VERIFY_FAIL
+}E_UPGRADE_ERR_TYPE;
+
+typedef unsigned char         FTS_BYTE;     //8 bit
+typedef unsigned short        FTS_WORD;    //16 bit
+typedef unsigned int          FTS_DWRD;    //16 bit
+typedef unsigned char         FTS_BOOL;    //8 bit
+
+#define FTS_NULL                0x0
+#define FTS_TRUE                0x01
+#define FTS_FALSE               0x0
+
+#define I2C_CTPM_ADDRESS        (0x70>>1)
+
+void delay_ms(FTS_WORD  w_ms)
+{
+	//platform related, please implement this function
+	msleep( w_ms );
+}
+
+
+/*
+[function]:
+    callback: read data from ctpm by i2c interface,implemented by special user;
+[parameters]:
+    bt_ctpm_addr[in]    :the address of the ctpm;
+    pbt_buf[out]        :data buffer;
+    dw_lenth[in]        :the length of the data buffer;
+[return]:
+    FTS_TRUE     :success;
+    FTS_FALSE    :fail;
+*/
+int i2c_read_interface(u8 bt_ctpm_addr, u8* pbt_buf, u16 dw_lenth)
+{
+	int ret;
+
+	ret=i2c_master_recv(this_client, pbt_buf, dw_lenth);
+
+	if(ret != dw_lenth){
+		pr_info("ret = %d. \n", ret);
+		pr_info("i2c_read_interface error\n");
+		return FTS_FALSE;
+	}
+
+	return FTS_TRUE;
+}
+
+/*
+[function]:
+    callback: write data to ctpm by i2c interface,implemented by special user;
+[parameters]:
+    bt_ctpm_addr[in]    :the address of the ctpm;
+    pbt_buf[in]        :data buffer;
+    dw_lenth[in]        :the length of the data buffer;
+[return]:
+    FTS_TRUE     :success;
+    FTS_FALSE    :fail;
+*/
+int i2c_write_interface(u8 bt_ctpm_addr, u8* pbt_buf, u16 dw_lenth)
+{
+	int ret;
+	ret=i2c_master_send(this_client, pbt_buf, dw_lenth);
+	if(ret != dw_lenth){
+		pr_info("i2c_write_interface error\n");
+		return FTS_FALSE;
+	}
+
+	return FTS_TRUE;
+}
+
+
+/***************************************************************************************/
+
+/*
+[function]:
+    read out the register value.
+[parameters]:
+    e_reg_name[in]    :register name;
+    pbt_buf[out]    :the returned register value;
+    bt_len[in]        :length of pbt_buf, should be set to 2;
+[return]:
+    FTS_TRUE    :success;
+    FTS_FALSE    :io fail;
+*/
+u8 fts_register_read(u8 e_reg_name, u8* pbt_buf, u8 bt_len)
+{
+	u8 read_cmd[3]= {0};
+	u8 cmd_len     = 0;
+
+	read_cmd[0] = e_reg_name;
+	cmd_len = 1;
+
+	/*call the write callback function*/
+	//    if(!i2c_write_interface(I2C_CTPM_ADDRESS, &read_cmd, cmd_len))
+	//    {
+	//        return FTS_FALSE;
+	//    }
+
+
+	if(!i2c_write_interface(I2C_CTPM_ADDRESS, read_cmd, cmd_len))	{//change by zhengdixu
+		return FTS_FALSE;
+	}
+
+	/*call the read callback function to get the register value*/
+	if(!i2c_read_interface(I2C_CTPM_ADDRESS, pbt_buf, bt_len)){
+		return FTS_FALSE;
+	}
+	return FTS_TRUE;
+}
+
+/*
+[function]:
+    write a value to register.
+[parameters]:
+    e_reg_name[in]    :register name;
+    pbt_buf[in]        :the returned register value;
+[return]:
+    FTS_TRUE    :success;
+    FTS_FALSE    :io fail;
+*/
+int fts_register_write(u8 e_reg_name, u8 bt_value)
+{
+	FTS_BYTE write_cmd[2] = {0};
+
+	write_cmd[0] = e_reg_name;
+	write_cmd[1] = bt_value;
+
+	/*call the write callback function*/
+	//return i2c_write_interface(I2C_CTPM_ADDRESS, &write_cmd, 2);
+	return i2c_write_interface(I2C_CTPM_ADDRESS, write_cmd, 2); //change by zhengdixu
+}
+
+/*
+[function]:
+    send a command to ctpm.
+[parameters]:
+    btcmd[in]        :command code;
+    btPara1[in]    :parameter 1;
+    btPara2[in]    :parameter 2;
+    btPara3[in]    :parameter 3;
+    num[in]        :the valid input parameter numbers, if only command code needed and no parameters followed,then the num is 1;
+[return]:
+    FTS_TRUE    :success;
+    FTS_FALSE    :io fail;
+*/
+int cmd_write(u8 btcmd,u8 btPara1,u8 btPara2,u8 btPara3,u8 num)
+{
+	FTS_BYTE write_cmd[4] = {0};
+
+	write_cmd[0] = btcmd;
+	write_cmd[1] = btPara1;
+	write_cmd[2] = btPara2;
+	write_cmd[3] = btPara3;
+	//return i2c_write_interface(I2C_CTPM_ADDRESS, &write_cmd, num);
+	return i2c_write_interface(I2C_CTPM_ADDRESS, write_cmd, num);//change by zhengdixu
+}
+
+/*
+[function]:
+    write data to ctpm , the destination address is 0.
+[parameters]:
+    pbt_buf[in]    :point to data buffer;
+    bt_len[in]        :the data numbers;
+[return]:
+    FTS_TRUE    :success;
+    FTS_FALSE    :io fail;
+*/
+int byte_write(u8* pbt_buf, u16 dw_len)
+{
+	return i2c_write_interface(I2C_CTPM_ADDRESS, pbt_buf, dw_len);
+}
+
+/*
+[function]:
+    read out data from ctpm,the destination address is 0.
+[parameters]:
+    pbt_buf[out]    :point to data buffer;
+    bt_len[in]        :the data numbers;
+[return]:
+    FTS_TRUE    :success;
+    FTS_FALSE    :io fail;
+*/
+int byte_read(u8* pbt_buf, u8 bt_len)
+{
+	return i2c_read_interface(I2C_CTPM_ADDRESS, pbt_buf, bt_len);
+	//ft5x_i2c_rxdata
+}
+
+
+/*
+[function]:
+    burn the FW to ctpm.
+[parameters]:(ref. SPEC)
+    pbt_buf[in]    :point to Head+FW ;
+    dw_lenth[in]:the length of the FW + 6(the Head length);
+    bt_ecc[in]    :the ECC of the FW
+[return]:
+    ERR_OK        :no error;
+    ERR_MODE    :fail to switch to UPDATE mode;
+    ERR_READID    :read id fail;
+    ERR_ERASE    :erase chip fail;
+    ERR_STATUS    :status error;
+    ERR_ECC        :ecc error.
+*/
+
+
+#define    FTS_PACKET_LENGTH       128 //2//4//8//16//32//64//128//256
+
+static unsigned char CTPM_FW[]=
+{
+#include "ft_app.i"
+};
+unsigned char fts_ctpm_get_i_file_ver(void)
+{
+    unsigned int ui_sz;
+    ui_sz = sizeof(CTPM_FW);
+    if (ui_sz > 2)
+    {
+        return CTPM_FW[ui_sz - 2];
+    }
+    else
+    {
+        //TBD, error handling?
+        return 0xff; //default value
+    }
+}
+E_UPGRADE_ERR_TYPE  fts_ctpm_fw_upgrade(u8* pbt_buf, u16 dw_lenth)
+{
+    u8 reg_val[2] = {0};
+    FTS_BOOL i_ret = 0;
+    u16 i = 0;
+
+
+    u16  packet_number;
+    u16  j;
+    u16  temp;
+    u16  lenght;
+    u8  packet_buf[FTS_PACKET_LENGTH + 6];
+    u8  auc_i2c_write_buf[10];
+    u8 bt_ecc;
+
+    /*********Step 1:Reset  CTPM *****/
+    /*write 0xaa to register 0xfc*/
+    delay_ms(100);
+    fts_register_write(0xfc,0xaa);
+    delay_ms(50);
+     /*write 0x55 to register 0xfc*/
+    fts_register_write(0xfc,0x55);
+    pr_info("Step 1: Reset CTPM test\n");
+
+    delay_ms(30);
+
+    /*********Step 2:Enter upgrade mode *****/
+     auc_i2c_write_buf[0] = 0x55;
+     auc_i2c_write_buf[1] = 0xaa;
+     i = 0;
+     do{
+        i++;
+        i_ret = i2c_write_interface(I2C_CTPM_ADDRESS, auc_i2c_write_buf, 2);
+        pr_info("Step 2: Enter update mode. \n");
+        delay_ms(5);
+     }while((FTS_FALSE == i_ret) && i<5);
+
+    /*********Step 3:check READ-ID***********************/
+    /*send the opration head*/
+    i = 0;
+    do{
+        if(i > 3)
+        {
+          cmd_write(0x07,0x00,0x00,0x00,1);
+		  return ERR_READID;
+        }
+        /*read out the CTPM ID*/
+        pr_info("====Step 3:check READ-ID====");
+        cmd_write(0x90,0x00,0x00,0x00,4);
+        byte_read(reg_val,2);
+        i++;
+        delay_ms(5);
+        pr_info("Step 3: CTPM ID,ID1 = 0x%x,ID2 = 0x%x\n",reg_val[0],reg_val[1]);
+    }while(reg_val[1] != 0x03);//while(reg_val[0] != 0x79 || reg_val[1] != 0x03);
+
+     /*********Step 4:erase app*******************************/
+    cmd_write(0x61,0x00,0x00,0x00,1);
+    delay_ms(1500);
+    pr_info("Step 4: erase. \n");
+
+    /*********Step 5:write firmware(FW) to ctpm flash*********/
+    bt_ecc = 0;
+    pr_info("Step 5: start upgrade. \n");
+    dw_lenth = dw_lenth - 8;
+    packet_number = (dw_lenth) / FTS_PACKET_LENGTH;
+    packet_buf[0] = 0xbf;
+    packet_buf[1] = 0x00;
+    for (j=0;j<packet_number;j++)
+    {
+        temp = j * FTS_PACKET_LENGTH;
+        packet_buf[2] = (FTS_BYTE)(temp>>8);
+        packet_buf[3] = (FTS_BYTE)temp;
+        lenght = FTS_PACKET_LENGTH;
+        packet_buf[4] = (FTS_BYTE)(lenght>>8);
+        packet_buf[5] = (FTS_BYTE)lenght;
+
+        for (i=0;i<FTS_PACKET_LENGTH;i++)
+        {
+            packet_buf[6+i] = pbt_buf[j*FTS_PACKET_LENGTH + i];
+            bt_ecc ^= packet_buf[6+i];
+        }
+
+        byte_write(&packet_buf[0],FTS_PACKET_LENGTH + 6);
+        delay_ms(FTS_PACKET_LENGTH/6 + 1);
+        if ((j * FTS_PACKET_LENGTH % 1024) == 0)
+        {
+              pr_info("upgrade the 0x%x th byte.\n", ((unsigned int)j) * FTS_PACKET_LENGTH);
+        }
+    }
+
+    if ((dw_lenth) % FTS_PACKET_LENGTH > 0)
+    {
+        temp = packet_number * FTS_PACKET_LENGTH;
+        packet_buf[2] = (FTS_BYTE)(temp>>8);
+        packet_buf[3] = (FTS_BYTE)temp;
+
+        temp = (dw_lenth) % FTS_PACKET_LENGTH;
+        packet_buf[4] = (FTS_BYTE)(temp>>8);
+        packet_buf[5] = (FTS_BYTE)temp;
+
+        for (i=0;i<temp;i++)
+        {
+            packet_buf[6+i] = pbt_buf[ packet_number*FTS_PACKET_LENGTH + i];
+            bt_ecc ^= packet_buf[6+i];
+        }
+
+        byte_write(&packet_buf[0],temp+6);
+        delay_ms(20);
+    }
+
+    //send the last six byte
+    for (i = 0; i<6; i++)
+    {
+        temp = 0x6ffa + i;
+        packet_buf[2] = (FTS_BYTE)(temp>>8);
+        packet_buf[3] = (FTS_BYTE)temp;
+        temp =1;
+        packet_buf[4] = (FTS_BYTE)(temp>>8);
+        packet_buf[5] = (FTS_BYTE)temp;
+        packet_buf[6] = pbt_buf[ dw_lenth + i];
+        bt_ecc ^= packet_buf[6];
+
+        byte_write(&packet_buf[0],7);
+        delay_ms(20);
+    }
+
+    /*********Step 6: read out checksum***********************/
+    /*send the opration head*/
+    //cmd_write(0xcc,0x00,0x00,0x00,1);//æ0xccå½ä½å¯å­å¨å°åï¼å»è¯»åºä¸ä¸ªå­è
+   // byte_read(reg_val,1);//change by zhengdixu
+
+	fts_register_read(0xcc, reg_val,1);
+
+    pr_info("Step 6:  ecc read 0x%x, new firmware 0x%x. \n", reg_val[0], bt_ecc);
+    if(reg_val[0] != bt_ecc)
+    {
+       cmd_write(0x07,0x00,0x00,0x00,1);
+		return ERR_ECC;
+    }
+
+    /*********Step 7: reset the new FW***********************/
+    cmd_write(0x07,0x00,0x00,0x00,1);
+    msleep(30);
+    return ERR_OK;
+}
+
+int fts_ctpm_auto_clb(void)
+{
+    unsigned char uc_temp;
+    unsigned char i ;
+
+    pr_info("[FTS] start auto CLB.\n");
+    msleep(200);
+    fts_register_write(0, 0x40);
+    delay_ms(100);                       //make sure already enter factory mode
+    fts_register_write(2, 0x4);               //write command to start calibration
+    delay_ms(300);
+    for(i=0;i<100;i++)
+    {
+        fts_register_read(0,&uc_temp,1);
+        if ( ((uc_temp&0x70)>>4) == 0x0)    //return to normal mode, calibration finish
+        {
+            break;
+        }
+        delay_ms(200);
+        pr_info("[FTS] waiting calibration %d\n",i);
+    }
+
+    pr_info("[FTS] calibration OK.\n");
+
+    msleep(300);
+    fts_register_write(0, 0x40);              //goto factory mode
+    delay_ms(100);                       //make sure already enter factory mode
+   fts_register_write(2, 0x5);               //store CLB result
+    delay_ms(300);
+    fts_register_write(0, 0x0);               //return to normal mode
+    msleep(300);
+    pr_info("[FTS] store CLB result OK.\n");
+    return 0;
+}
+void getVerNo(u8* buf, int len)
+{
+	u8 start_reg=0x0;
+	int ret = -1;
+	//int status = 0;
+	int i = 0;
+	start_reg = 0xa6;
+
+#if 0
+	pr_info("read 0xa6 one time. \n");
+	if(FTS_FALSE == fts_register_read(0xa6, buf, len)){
+        return ;
+	}
+
+	for (i=0; i< len; i++)
+	{
+		pr_info("=========buf[%d] = 0x%x \n", i, buf[i]);
+	}
+
+	pr_info("read 0xa8. \n");
+	if(FTS_FALSE == fts_register_read(0xa8, buf, len)){
+        return ;
+	}
+	for (i=0; i< len; i++)
+	{
+		pr_info("=========buf[%d] = 0x%x \n", i, buf[i]);
+	}
+
+	ft5x_i2c_rxdata(buf, len);
+
+    for (i=0; i< len; i++)
+        {
+            pr_info("=========buf[%d] = 0x%x \n", i, buf[i]);
+        }
+
+    byte_read(buf, len);
+    for (i=0; i< len; i++)
+    {
+        pr_info("=========buf[%d] = 0x%x \n", i, buf[i]);
+    }
+
+#endif
+
+	ret =fts_register_read(0xa6, buf, len);
+	//et = ft5406_read_regs(ft5x0x_ts_data_test->client,start_reg, buf, 2);
+	if (ret < 0)
+	{
+		pr_info("%s read_data i2c_rxdata failed: %d\n", __func__, ret);
+		return;
+	}
+	for (i=0; i<2; i++)
+	{
+		pr_info("=========buf[%d] = 0x%x \n", i, buf[i]);
+	}
+
+
+	return;
+}
+
+int fts_ctpm_fw_upgrade_with_i_file(void)
+{
+	FTS_BYTE*     pbt_buf = FTS_NULL;
+	int i_ret = 0;
+	unsigned char a;
+	unsigned char b;
+#define BUFFER_LEN (2)            //len == 2
+	unsigned char buf[BUFFER_LEN] = {0};
+
+	//=========FW upgrade========================*/
+	pr_info("%s. \n", __func__);
+
+	pbt_buf = CTPM_FW;
+	//msleep(200);
+   // cmd_write(0x07,0x00,0x00,0x00,1);
+	msleep(100);
+	getVerNo(buf, BUFFER_LEN);
+	a = buf[0];
+	b = fts_ctpm_get_i_file_ver();
+	pr_info("a == %hu,  b== %hu \n",a, b);
+
+	/*
+	  * when the firmware in touch panel maybe corrupted,
+	  * or the firmware in host flash is new, need upgrade
+	  */
+	if ( 0xa6 == a ||a < b ){
+		/*call the upgrade function*/
+		i_ret =  fts_ctpm_fw_upgrade(&pbt_buf[0],sizeof(CTPM_FW));
+		if (i_ret != 0){
+			pr_info("[FTS] upgrade failed i_ret = %d.\n", i_ret);
+		} else {
+			pr_info("[FTS] upgrade successfully.\n");
+			fts_ctpm_auto_clb();  //start auto CLB
+		}
+
+	}
+
+	return i_ret;
+
+}
+
+unsigned char fts_ctpm_get_upg_ver(void)
+{
+	unsigned int ui_sz;
+	ui_sz = sizeof(CTPM_FW);
+	if (ui_sz > 2){
+		return CTPM_FW[0];
+	}
+	else{
+		//TBD, error handling?
+		return 0xff; //default value
+	}
+}
+
+static int ft5x_i2c_rxdata(char *rxdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= rxdata,
+		},
+		{
+			.addr	= this_client->addr,
+			.flags	= I2C_M_RD,
+			.len	= length,
+			.buf	= rxdata,
+		},
+	};
+
+        //pr_info("IIC add = %x\n",this_client->addr);
+	ret = i2c_transfer(this_client->adapter, msgs, 2);
+	if (ret < 0)
+		pr_info("msg %s i2c read error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int ft5x_i2c_txdata(char *txdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= length,
+			.buf	= txdata,
+		},
+	};
+
+   	//msleep(1);
+	ret = i2c_transfer(this_client->adapter, msg, 1);
+	if (ret < 0)
+		pr_err("%s i2c write error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int ft5x_set_reg(u8 addr, u8 para)
+{
+	u8 buf[3];
+	int ret = -1;
+
+	buf[0] = addr;
+	buf[1] = para;
+	ret = ft5x_i2c_txdata(buf, 2);
+	if (ret < 0) {
+		pr_err("write reg failed! %#x ret: %d", buf[0], ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void ft5x_ts_release(void)
+{
+	struct ft5x_ts_data *data = i2c_get_clientdata(this_client);
+
+#ifdef TOUCH_KEY_SUPPORT
+	if(1 == key_tp){
+		input_report_key(data->input_dev, key_val, 0);
+		print_point_info("Release Key = %d\n",key_val);
+	} else{
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+	}
+#else
+	input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+#endif
+	input_report_abs(data->input_dev, ABS_PRESSURE, 0);
+	input_report_key(data->input_dev, BTN_TOUCH, 0);
+
+	input_sync(data->input_dev);
+	return;
+
+}
+
+/**
+ * Data format:
+ * 16b, padding
+ *  8b, pressed count
+ *
+ *  4b, 0x0 pressed, 0x8 kept, 0x4 released, 0xf N/A
+ * 12b, x
+ *  4b, id
+ * 12b, y
+ * 16b, padding
+ */
+static int ft5x_read_data(void)
+{
+	struct ft5x_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+	unsigned char buf[32]={0};
+	int ret = -1;
+
+	ret = ft5x_i2c_rxdata(buf, 31);
+
+	if (ret < 0) {
+		pr_info("%s read_data i2c_rxdata failed: %d\n", __func__, ret);
+		return ret;
+	}
+
+	memset(event, 0, sizeof(struct ts_event));
+
+	event->touch_point = buf[2] & 0x07;// 000 0111
+	print_point_info("touch point = %d\n",event->touch_point);
+
+	if (event->touch_point == 0) {
+		ft5x_ts_release();
+		return 1;
+	}
+
+	switch (event->touch_point) {
+	case 5:
+		event->x5 = (s16)(buf[0x1b] & 0x0F)<<8 | (s16)buf[0x1c];
+		event->y5 = (s16)(buf[0x1d] & 0x0F)<<8 | (s16)buf[0x1e];
+		if(1 == revert_x_flag){
+			event->x5 = SCREEN_MAX_X - event->x5;
+		}
+		if(1 == revert_y_flag){
+			event->y5 = SCREEN_MAX_Y - event->y5;
+		}
+		//pr_info("before swap: event->x5 = %d, event->y5 = %d. \n", event->x5, event->y5);
+		if(1 == exchange_x_y_flag){
+			swap(event->x5, event->y5);
+		}
+		//pr_info("after swap: event->x5 = %d, event->y5 = %d. \n", event->x5, event->y5);
+		event->touch_ID5=(s16)(buf[0x1D] & 0xF0)>>4;
+	case 4:
+		event->x4 = (s16)(buf[0x15] & 0x0F)<<8 | (s16)buf[0x16];
+		event->y4 = (s16)(buf[0x17] & 0x0F)<<8 | (s16)buf[0x18];
+		if(1 == revert_x_flag){
+			event->x4 = SCREEN_MAX_X - event->x4;
+		}
+		if(1 == revert_y_flag){
+			event->y4 = SCREEN_MAX_Y - event->y4;
+		}
+		//pr_info("before swap: event->x4 = %d, event->y4 = %d. \n", event->x4, event->y4);
+		if(1 == exchange_x_y_flag){
+			swap(event->x4, event->y4);
+		}
+		//pr_info("after swap: event->x4 = %d, event->y4 = %d. \n", event->x4, event->y4);
+		event->touch_ID4=(s16)(buf[0x17] & 0xF0)>>4;
+	case 3:
+		event->x3 = (s16)(buf[0x0f] & 0x0F)<<8 | (s16)buf[0x10];
+		event->y3 = (s16)(buf[0x11] & 0x0F)<<8 | (s16)buf[0x12];
+		if(1 == revert_x_flag){
+			event->x3 = SCREEN_MAX_X - event->x3;
+		}
+		if(1 == revert_y_flag){
+			event->y3 = SCREEN_MAX_Y - event->y3;
+		}
+		//pr_info("before swap: event->x3 = %d, event->y3 = %d. \n", event->x3, event->y3);
+		if(1 == exchange_x_y_flag){
+			swap(event->x3, event->y3);
+		}
+		//pr_info("after swap: event->x3 = %d, event->y3 = %d. \n", event->x3, event->y3);
+		event->touch_ID3=(s16)(buf[0x11] & 0xF0)>>4;
+	case 2:
+		event->x2 = (s16)(buf[9] & 0x0F)<<8 | (s16)buf[10];
+		event->y2 = (s16)(buf[11] & 0x0F)<<8 | (s16)buf[12];
+		if(1 == revert_x_flag){
+			event->x2 = SCREEN_MAX_X - event->x2;
+		}
+		if(1 == revert_y_flag){
+			event->y2 = SCREEN_MAX_Y - event->y2;
+		}
+		//pr_info("before swap: event->x2 = %d, event->y2 = %d. \n", event->x2, event->y2);
+		if(1 == exchange_x_y_flag){
+			swap(event->x2, event->y2);
+		}
+		//pr_info("after swap: event->x2 = %d, event->y2 = %d. \n", event->x2, event->y2);
+		event->touch_ID2=(s16)(buf[0x0b] & 0xF0)>>4;
+	case 1:
+		event->x1 = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+		event->y1 = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+#ifdef TOUCH_KEY_FOR_ANGDA
+		if(event->x1 < TOUCH_KEY_X_LIMIT)
+		{
+			if(1 == revert_x_flag){
+				event->x1 = SCREEN_MAX_X - event->x1;
+			}
+			if(1 == revert_y_flag){
+				event->y1 = SCREEN_MAX_Y - event->y1;
+			}
+			//pr_info("before swap: event->x1 = %d, event->y1 = %d. \n", event->x1, event->y1);
+			if(1 == exchange_x_y_flag){
+				swap(event->x1, event->y1);
+			}
+		}
+#elif defined(TOUCH_KEY_FOR_EVB13)
+		if((event->x1 > TOUCH_KEY_LOWER_X_LIMIT)&&(event->x1<TOUCH_KEY_HIGHER_X_LIMIT))
+		{
+			if(1 == revert_x_flag){
+				event->x1 = SCREEN_MAX_X - event->x1;
+			}
+			if(1 == revert_y_flag){
+				event->y1 = SCREEN_MAX_Y - event->y1;
+			}
+			//pr_info("before swap: event->x1 = %d, event->y1 = %d. \n", event->x1, event->y1);
+			if(1 == exchange_x_y_flag){
+				swap(event->x1, event->y1);
+			}
+		}
+#else
+		if(1 == revert_x_flag){
+			event->x1 = SCREEN_MAX_X - event->x1;
+		}
+		if(1 == revert_y_flag){
+			event->y1 = SCREEN_MAX_Y - event->y1;
+		}
+		//pr_info("before swap: event->x1 = %d, event->y1 = %d. \n", event->x1, event->y1);
+		if(1 == exchange_x_y_flag){
+			swap(event->x1, event->y1);
+		}
+#endif
+
+		//pr_info("after swap: event->x1 = %d, event->y1 = %d. \n", event->x1, event->y1);
+		event->touch_ID1=(s16)(buf[0x05] & 0xF0)>>4;
+		break;
+	default:
+		return -1;
+	}
+
+	event->pressure = 200;
+
+	dev_dbg(&this_client->dev, "%s: 1:%d %d 2:%d %d\n", __func__,
+			event->x1, event->y1, event->x2, event->y2);
+
+
+    return 0;
+}
+
+#ifdef TOUCH_KEY_LIGHT_SUPPORT
+static void ft5x_lighting(void)
+{
+	if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_light_hdle, 1, "ctp_light")){
+		pr_info("ft5x_ts_light: err when operate gpio. \n");
+	}
+	msleep(15);
+	if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_light_hdle, 0, "ctp_light")){
+		pr_info("ft5x_ts_light: err when operate gpio. \n");
+	}
+
+	return;
+}
+#endif
+
+static void ft5x_report_multitouch(void)
+{
+	struct ft5x_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+
+#ifdef TOUCH_KEY_SUPPORT
+	if(1 == key_tp){
+		return;
+	}
+#endif
+
+	switch(event->touch_point) {
+	case 5:
+		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID5);
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 1);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x5);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y5);
+		input_report_abs(data->input_dev, ABS_MT_PRESSURE, event->pressure);
+		input_report_key(data->input_dev, BTN_TOUCH, 1);
+		input_mt_sync(data->input_dev);
+		print_point_info("===x5 = %d,y5 = %d ====\n",event->x5,event->y5);
+	case 4:
+		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID4);
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 1);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x4);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y4);
+		input_report_abs(data->input_dev, ABS_MT_PRESSURE, event->pressure);
+		input_report_key(data->input_dev, BTN_TOUCH, 1);
+		input_mt_sync(data->input_dev);
+		print_point_info("===x4 = %d,y4 = %d ====\n",event->x4,event->y4);
+	case 3:
+		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID3);
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 1);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x3);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y3);
+		input_report_abs(data->input_dev, ABS_MT_PRESSURE, event->pressure);
+		input_report_key(data->input_dev, BTN_TOUCH, 1);
+		input_mt_sync(data->input_dev);
+		print_point_info("===x3 = %d,y3 = %d ====\n",event->x3,event->y3);
+	case 2:
+		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID2);
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 1);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x2);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y2);
+		input_report_abs(data->input_dev, ABS_MT_PRESSURE, event->pressure);
+		input_report_key(data->input_dev, BTN_TOUCH, 1);
+		input_mt_sync(data->input_dev);
+		print_point_info("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+	case 1:
+		input_report_abs(data->input_dev, ABS_X, event->x1);
+		input_report_abs(data->input_dev, ABS_Y, event->y1);
+		input_report_abs(data->input_dev, ABS_PRESSURE, event->pressure);
+
+		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID1);
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 1);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x1);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y1);
+		input_report_abs(data->input_dev, ABS_MT_PRESSURE, event->pressure);
+		input_report_key(data->input_dev, BTN_TOUCH, 1);
+		input_mt_sync(data->input_dev);
+		print_point_info("===x1 = %d,y1 = %d, pressure = %d ====\n",event->x1,event->y1,event->pressure);
+		break;
+	default:
+		print_point_info("==touch_point default =\n");
+		break;
+	}
+
+	input_sync(data->input_dev);
+	dev_dbg(&this_client->dev, "%s: 1:%d %d 2:%d %d\n", __func__,
+		event->x1, event->y1, event->x2, event->y2);
+	return;
+}
+
+#ifdef TOUCH_KEY_SUPPORT
+static void ft5x_report_touchkey(void)
+{
+	struct ft5x_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+	//print_point_info("x=%d===Y=%d\n",event->x1,event->y1);
+
+#ifdef TOUCH_KEY_FOR_ANGDA
+	if((1==event->touch_point)&&(event->x1 > TOUCH_KEY_X_LIMIT)){
+		key_tp = 1;
+		if(event->y1 < 40){
+			key_val = 1;
+			input_report_key(data->input_dev, key_val, 1);
+			input_sync(data->input_dev);
+			print_point_info("===KEY 1====\n");
+		}else if(event->y1 < 90){
+			key_val = 2;
+			input_report_key(data->input_dev, key_val, 1);
+			input_sync(data->input_dev);
+			print_point_info("===KEY 2 ====\n");
+		}else{
+			key_val = 3;
+			input_report_key(data->input_dev, key_val, 1);
+			input_sync(data->input_dev);
+			print_point_info("===KEY 3====\n");
+		}
+	} else{
+		key_tp = 0;
+	}
+#endif
+#ifdef TOUCH_KEY_FOR_EVB13
+	if((1==event->touch_point)&&((event->x1 > TOUCH_KEY_LOWER_X_LIMIT)&&(event->x1<TOUCH_KEY_HIGHER_X_LIMIT))){
+		key_tp = 1;
+		if(event->y1 < 5){
+			key_val = 1;
+			input_report_key(data->input_dev, key_val, 1);
+			input_sync(data->input_dev);
+			print_point_info("===KEY 1====\n");
+		}else if((event->y1 < 45)&&(event->y1>35)){
+			key_val = 2;
+			input_report_key(data->input_dev, key_val, 1);
+			input_sync(data->input_dev);
+			print_point_info("===KEY 2 ====\n");
+		}else if((event->y1 < 75)&&(event->y1>65)){
+			key_val = 3;
+			input_report_key(data->input_dev, key_val, 1);
+			input_sync(data->input_dev);
+			print_point_info("===KEY 3====\n");
+		}else if ((event->y1 < 105)&&(event->y1>95))	{
+			key_val = 4;
+			input_report_key(data->input_dev, key_val, 1);
+			input_sync(data->input_dev);
+			print_point_info("===KEY 4====\n");
+		}
+	}else{
+		key_tp = 0;
+	}
+#endif
+
+#ifdef TOUCH_KEY_LIGHT_SUPPORT
+	ft5x_lighting();
+#endif
+	return;
+}
+#endif
+
+static void ft5x_report_value(void)
+{
+
+	//pr_info("==ft5x_report_value =\n");
+#ifdef TOUCH_KEY_SUPPORT
+	ft5x_report_touchkey();
+#endif
+	ft5x_report_multitouch();
+	return;
+}	/*end ft5x_report_value*/
+
+static void ft5x_ts_pen_irq_work(struct work_struct *work)
+{
+	int ret = -1;
+	//pr_info("==work 1=\n");
+	ret = ft5x_read_data();
+	if (ret == 0) {
+		ft5x_report_value();
+	}
+	//enable_irq(SW_INT_IRQNO_PIO);
+
+}
+
+static irqreturn_t ft5x_ts_interrupt(int irq, void *dev_id)
+{
+	struct ft5x_ts_data *ft5x_ts = dev_id;
+
+	print_int_info("==========------ft5x_ts TS Interrupt-----============\n");
+	if(!ctp_ops.judge_int_occur()){
+		print_int_info("==IRQ_EINT21=\n");
+		ctp_ops.clear_penirq();
+		if (!work_pending(&ft5x_ts->pen_event_work))
+		{
+			print_int_info("Enter work\n");
+			queue_work(ft5x_ts->ts_workqueue, &ft5x_ts->pen_event_work);
+		}
+	}else{
+		print_int_info("Other Interrupt\n");
+		return IRQ_NONE;
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+
+static void ft5x_ts_suspend(struct early_suspend *handler)
+{
+//	struct ft5x_ts_data *ts;
+//	ts =  container_of(handler, struct ft5x_ts_data, early_suspend);
+
+	pr_info("==ft5x_ts_suspend=\n");
+//	disable_irq(this_client->irq);
+//	disable_irq(IRQ_EINT(6));
+//	cancel_work_sync(&ts->pen_event_work);
+//	flush_workqueue(ts->ts_workqueue);
+	// ==set mode ==,
+//    	ft5x_set_reg(FT5X0X_REG_PMODE, PMODE_HIBERNATE);
+
+   /*    //gpio i28 output low
+	pr_info("==ft5x_ts_suspend=\n");
+	//enter HIBERNATE mode
+    ft5x_set_reg(0x3a,PMODE_HIBERNATE);
+	*/
+    //suspend
+    //gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+    // ==set mode ==,
+/*if device support power port feature simply poweroff ts chip */
+	if (gpio_power_hdle) {
+		pr_info("ft5x_ts_suspend: poweroff ts.\n");
+		gpio_write_one_pin_value(gpio_power_hdle, 0, "ctp_power_port");
+	} else {
+		pr_info("ft5x_ts_suspend: write FT5X0X_REG_PMODE.\n");
+		ft5x_set_reg(FT5X0X_REG_PMODE, PMODE_HIBERNATE);
+	}
+}
+
+static void ft5x_ts_resume(struct early_suspend *handler)
+{
+	pr_info("==ft5x_ts_resume==\n");
+	if (gpio_power_hdle) {
+		gpio_write_one_pin_value(gpio_power_hdle, 1, "ctp_power_port");
+		mdelay(48);
+	} else {
+		ctp_ops.ts_reset();
+		ctp_ops.ts_wakeup();
+	}
+}
+#endif  //CONFIG_HAS_EARLYSUSPEND
+
+static int
+ft5x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct ft5x_ts_data *ft5x_ts;
+	struct input_dev *input_dev;
+	struct device *dev;
+	struct i2c_dev *i2c_dev;
+	int err = 0;
+
+#ifdef TOUCH_KEY_SUPPORT
+	int i = 0;
+#endif
+
+	pr_info("====%s begin=====.  \n", __func__);
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+
+	ft5x_ts = kzalloc(sizeof(*ft5x_ts), GFP_KERNEL);
+	if (!ft5x_ts)	{
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	//pr_info("touch panel gpio addr: = 0x%x", gpio_addr);
+	this_client = client;
+
+	//pr_info("ft5x_ts_probe : client->addr = %d. \n", client->addr);
+	this_client->addr = client->addr;
+	//pr_info("ft5x_ts_probe : client->addr = %d. \n", client->addr);
+	i2c_set_clientdata(client, ft5x_ts);
+
+#ifdef TOUCH_KEY_LIGHT_SUPPORT
+	gpio_light_hdle = gpio_request_ex("ctp_para", "ctp_light");
+#endif
+
+#ifdef CONFIG_SUPPORT_FTS_CTP_UPG
+	fts_ctpm_fw_upgrade_with_i_file();
+#endif
+
+
+//	pr_info("==INIT_WORK=\n");
+	INIT_WORK(&ft5x_ts->pen_event_work, ft5x_ts_pen_irq_work);
+	ft5x_ts->ts_workqueue = create_singlethread_workqueue(dev_name(&client->dev));
+	if (!ft5x_ts->ts_workqueue) {
+		err = -ESRCH;
+		goto exit_create_singlethread;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+
+	ft5x_ts->input_dev = input_dev;
+
+	set_bit(EV_ABS, input_dev->evbit);
+	set_bit(EV_KEY, input_dev->evbit);
+
+	set_bit(ABS_X, input_dev->absbit);
+	set_bit(ABS_Y, input_dev->absbit);
+	set_bit(ABS_PRESSURE, input_dev->absbit);
+
+	set_bit(BTN_TOUCH, input_dev->keybit);
+
+	input_set_abs_params(input_dev,
+			ABS_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(input_dev,
+			ABS_Y, 0, SCREEN_MAX_Y, 0, 0);
+	input_set_abs_params(input_dev,
+			ABS_PRESSURE, 0, PRESS_MAX, 0 , 0);
+	input_set_abs_params(input_dev,
+			ABS_MT_PRESSURE, 0, PRESS_MAX, 0 , 0);
+
+	set_bit(ABS_MT_TOUCH_MAJOR, input_dev->absbit);
+	set_bit(ABS_MT_POSITION_X, input_dev->absbit);
+	set_bit(ABS_MT_POSITION_Y, input_dev->absbit);
+
+	input_set_abs_params(input_dev,
+			     ABS_MT_POSITION_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_POSITION_Y, 0, SCREEN_MAX_Y, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_TOUCH_MAJOR, 0, 1, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_TRACKING_ID, 0, 4, 0, 0);
+#ifdef TOUCH_KEY_SUPPORT
+	key_tp = 0;
+	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	for (i = 1; i < TOUCH_KEY_NUMBER; i++)
+		set_bit(i, input_dev->keybit);
+#endif
+
+	input_dev->name		= CTP_NAME;		//dev_name(&client->dev)
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &client->dev;
+	err = input_register_device(input_dev);
+	if (err) {
+		dev_err(&client->dev,
+		"ft5x_ts_probe: failed to register input device: %s\n",
+		dev_name(&client->dev));
+		goto exit_input_register_device_failed;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	pr_info("==register_early_suspend =\n");
+	ft5x_ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ft5x_ts->early_suspend.suspend = ft5x_ts_suspend;
+	ft5x_ts->early_suspend.resume	= ft5x_ts_resume;
+	register_early_suspend(&ft5x_ts->early_suspend);
+#endif
+
+	err = ctp_ops.set_irq_mode("ctp_para", "ctp_int_port", CTP_IRQ_MODE);
+	if(0 != err){
+		pr_info("%s:ctp_ops.set_irq_mode err.\n", __func__);
+		goto exit_set_irq_mode;
+	}
+	err = request_irq(SW_INT_IRQNO_PIO, ft5x_ts_interrupt, IRQF_TRIGGER_FALLING | IRQF_SHARED, "ft5x_ts", ft5x_ts);
+
+	if (err < 0) {
+		dev_err(&client->dev, "ft5x_ts_probe: request irq failed\n");
+		goto exit_irq_request_failed;
+	}
+
+    	i2c_dev = get_free_i2c_dev(client->adapter);
+	if (IS_ERR(i2c_dev)){
+		err = PTR_ERR(i2c_dev);
+		return err;
+	}
+	dev = device_create(i2c_dev_class, &client->adapter->dev, MKDEV(I2C_MAJOR,client->adapter->nr), NULL, "aw_i2c_ts%d", client->adapter->nr);
+	if (IS_ERR(dev))	{
+			err = PTR_ERR(dev);
+			return err;
+	}
+
+	pr_info("==%s over =\n", __func__);
+
+	return 0;
+
+exit_irq_request_failed:
+exit_set_irq_mode:
+	cancel_work_sync(&ft5x_ts->pen_event_work);
+	destroy_workqueue(ft5x_ts->ts_workqueue);
+	enable_irq(SW_INT_IRQNO_PIO);
+exit_input_register_device_failed:
+	input_free_device(input_dev);
+exit_input_dev_alloc_failed:
+	free_irq(SW_INT_IRQNO_PIO, ft5x_ts);
+exit_create_singlethread:
+	pr_info("==singlethread error =\n");
+	i2c_set_clientdata(client, NULL);
+	kfree(ft5x_ts);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	return err;
+}
+
+static int __devexit ft5x_ts_remove(struct i2c_client *client)
+{
+
+	struct ft5x_ts_data *ft5x_ts = i2c_get_clientdata(client);
+	ft5x_set_reg(FT5X0X_REG_PMODE, PMODE_HIBERNATE);
+
+	pr_info("==ft5x_ts_remove=\n");
+	free_irq(SW_INT_IRQNO_PIO, ft5x_ts);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ft5x_ts->early_suspend);
+#endif
+	input_unregister_device(ft5x_ts->input_dev);
+	unregister_chrdev(I2C_MAJOR, CHARDEV_NAME);
+	input_free_device(ft5x_ts->input_dev);
+	cancel_work_sync(&ft5x_ts->pen_event_work);
+	destroy_workqueue(ft5x_ts->ts_workqueue);
+	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR,client->adapter->nr));
+	class_destroy(i2c_dev_class);	
+	kfree(ft5x_ts);
+
+	i2c_set_clientdata(client, NULL);
+	ctp_ops.free_platform_resource();
+
+	return 0;
+
+}
+
+static const struct i2c_device_id ft5x_ts_id[] = {
+	{ CTP_NAME, 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ft5x_ts_id);
+
+static struct i2c_driver ft5x_ts_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe		= ft5x_ts_probe,
+	.remove		= __devexit_p(ft5x_ts_remove),
+	.id_table	= ft5x_ts_id,
+	.driver	= {
+		.name	= CTP_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.address_list	= u_i2c_addr.normal_i2c,
+};
+
+static int aw_open(struct inode *inode, struct file *file)
+{
+	int subminor;
+	int ret = 0;
+	struct i2c_client *client;
+	struct i2c_adapter *adapter;
+	struct i2c_dev *i2c_dev;
+
+	pr_info("====%s======.\n", __func__);
+
+	#ifdef AW_DEBUG
+	        pr_info("enter aw_open function\n");
+	#endif
+
+	subminor = iminor(inode);
+	#ifdef AW_DEBUG
+	      pr_info("subminor=%d\n",subminor);
+	#endif
+
+	//lock_kernel();
+	i2c_dev = i2c_dev_get_by_minor(2);
+	if (!i2c_dev)	{
+		pr_info("error i2c_dev\n");
+		return -ENODEV;
+	}
+
+	adapter = i2c_get_adapter(i2c_dev->adap->nr);
+	if (!adapter)	{
+		return -ENODEV;
+	}
+
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
+
+	if (!client)	{
+		i2c_put_adapter(adapter);
+		ret = -ENOMEM;
+	}
+	snprintf(client->name, I2C_NAME_SIZE, "pctp_i2c_ts%d", adapter->nr);
+	client->driver = &ft5x_ts_driver;
+	client->adapter = adapter;
+	file->private_data = client;
+
+	return 0;
+}
+
+static long aw_ioctl(struct file *file, unsigned int cmd,unsigned long arg )
+{
+	//struct i2c_client *client = (struct i2c_client *) file->private_data;
+
+	pr_info("====%s====.\n",__func__);
+
+	#ifdef AW_DEBUG
+	       pr_info("line :%d,cmd = %d,arg = %d.\n",__LINE__,cmd,arg);
+	#endif
+
+	switch (cmd) {
+		case UPGRADE:
+		pr_info("==UPGRADE_WORK=\n");
+		fts_ctpm_fw_upgrade_with_i_file();
+		// calibrate();
+
+		break;
+
+		default:
+		break;
+
+	}
+
+	return 0;
+}
+
+static int aw_release (struct inode *inode, struct file *file)
+{
+	struct i2c_client *client = file->private_data;
+	#ifdef AW_DEBUG
+	    pr_info("enter aw_release function.\n");
+	#endif
+
+	i2c_put_adapter(client->adapter);
+	kfree(client);
+	file->private_data = NULL;
+	return 0;
+}
+
+static const struct file_operations aw_i2c_ts_fops ={
+	.owner = THIS_MODULE,
+	//.read = aw_read,
+	//.write = aw_write,
+	.open = aw_open,
+	.unlocked_ioctl = aw_ioctl,
+	.release = aw_release,
+};
+
+static int __init ft5x_ts_init(void)
+{
+	int ret = -1;
+	int err = -1;
+
+	pr_info("===========================%s=====================\n", __func__);
+
+	if (ctp_ops.fetch_sysconfig_para)
+	{
+		if(ctp_ops.fetch_sysconfig_para()){
+			pr_info("%s: err.\n", __func__);
+			return -1;
+		}
+	}
+	pr_info("%s: after fetch_sysconfig_para:  normal_i2c: 0x%hx. normal_i2c[1]: 0x%hx \n", \
+	__func__, u_i2c_addr.normal_i2c[0], u_i2c_addr.normal_i2c[1]);
+
+	err = ctp_ops.init_platform_resource();
+	if(0 != err){
+	    pr_info("%s:ctp_ops.init_platform_resource err. \n", __func__);
+	}
+
+	//reset
+	ctp_ops.ts_reset();
+	//wakeup
+	ctp_ops.ts_wakeup();
+
+	ft5x_ts_driver.detect = ctp_ops.ts_detect;
+
+	ret= register_chrdev(I2C_MAJOR,CHARDEV_NAME,&aw_i2c_ts_fops );
+	if(ret) {
+		pr_info(KERN_ERR "%s:register chrdev failed\n",__FILE__);
+		return ret;
+	}
+
+	i2c_dev_class = class_create(THIS_MODULE,"aw_i2c_dev");
+	if (IS_ERR(i2c_dev_class)) {
+		ret = PTR_ERR(i2c_dev_class);
+		class_destroy(i2c_dev_class);
+	}
+
+	ret = i2c_add_driver(&ft5x_ts_driver);
+
+	return ret;
+}
+
+static void __exit ft5x_ts_exit(void)
+{
+	pr_info("==ft5x_ts_exit==\n");
+	i2c_del_driver(&ft5x_ts_driver);
+}
+
+late_initcall(ft5x_ts_init);
+module_exit(ft5x_ts_exit);
+
+MODULE_AUTHOR("<wenfs@Focaltech-systems.com>");
+MODULE_DESCRIPTION("FocalTech ft5x TouchScreen driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/ft5x_ts.h b/drivers/input/touchscreen/ft5x_ts.h
new file mode 100644
index 0000000..80f3cf4
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x_ts.h
@@ -0,0 +1,72 @@
+/*
+ * drivers/input/touchscreen/ft5x_ts.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LINUX_FT5X_TS_H__
+#define __LINUX_FT5X_TS_H__
+
+// gpio base address
+#define CONFIG_FT5X0X_MULTITOUCH     (1)
+#define CALIBRATION  (1)
+#define UPGRADE   (5)
+//#define CALIBRATION _IO(CALIBRATION_FLAG,0)
+//#define UPDRAGE _IO(UPDRAGE_FLAG,0)
+#define I2C_MINORS 	256
+#define I2C_MAJOR 	125
+                                
+#undef  AW_GPIO_INT_API_ENABLE
+//#define AW_FPGA_SIM
+#ifdef AW_FPGA_SIM
+#endif
+
+#define AW_GPIO_API_ENABLE
+//#undef CONFIG_HAS_EARLYSUSPEND
+//#define CONFIG_HAS_EARLYSUSPEND
+struct ft5x_ts_platform_data{
+	u16	intr;		/* irq number	*/
+};
+
+enum ft5x_ts_regs {
+	FT5X0X_REG_PMODE	= 0xA5,	/* Power Consume Mode		*/	
+};
+
+//FT5X0X_REG_PMODE
+#define PMODE_ACTIVE        0x00
+#define PMODE_MONITOR       0x01
+#define PMODE_STANDBY       0x02
+#define PMODE_HIBERNATE     0x03
+
+
+#ifndef ABS_MT_TOUCH_MAJOR
+    #define ABS_MT_TOUCH_MAJOR	0x30	/* touching ellipse */
+    #define ABS_MT_TOUCH_MINOR	0x31	/* (omit if circular) */
+    #define ABS_MT_WIDTH_MAJOR	0x32	/* approaching ellipse */
+    #define ABS_MT_WIDTH_MINOR	0x33	/* (omit if circular) */
+    #define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
+    #define ABS_MT_POSITION_X	0x35	/* Center X ellipse position */
+    #define ABS_MT_POSITION_Y	0x36	/* Center Y ellipse position */
+    #define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
+    #define ABS_MT_BLOB_ID		0x38	/* Group set of pkts as blob */
+#endif /* ABS_MT_TOUCH_MAJOR */
+
+
+#endif
+
diff --git a/drivers/input/touchscreen/ft_app.i b/drivers/input/touchscreen/ft_app.i
new file mode 100644
index 0000000..11b239d
--- /dev/null
+++ b/drivers/input/touchscreen/ft_app.i
@@ -0,0 +1,1667 @@
+/*
+ * drivers/input/touchscreen/ft_app.i
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+0x2, 0x5, 0xe9,0x2, 0x52,0xde,0xc3,0xee,0x64,0x80,0x94,0x80,0x40,0x2, 0x80,0x7,
+0xc3,0xe4,0x9f,0xff,0xe4,0x9e,0xfe,0x22,0x22,0x22,0xff,0x2, 0x30,0xa, 0x8f,0xd9,
+0x8d,0xda,0x22,0x2, 0x4f,0xdb,0xbd,0x77,0xb, 0xef,0xc3,0x94,0x13,0x40,0x19,0x74,
+0xf3,0x2f,0xff,0x22,0xbd,0x78,0xb, 0xef,0xc3,0x94,0x13,0x40,0xb, 0x74,0xf8,0x2f,
+0xff,0x22,0xbd,0x79,0x1, 0x22,0x7f,0xff,0x22,0xff,0xff,0x2, 0x50,0x34,0x2, 0x30,
+0xf0,0xff,0xff,0x2, 0x62,0x31,0xe7,0x9, 0xf6,0x8, 0xdf,0xfa,0x80,0x46,0xe7,0x9,
+0xf2,0x8, 0xdf,0xfa,0x80,0x3e,0x88,0x82,0x8c,0x83,0xe7,0x9, 0xf0,0xa3,0xdf,0xfa,
+0x80,0x32,0xe3,0x9, 0xf6,0x8, 0xdf,0xfa,0x80,0x78,0xe3,0x9, 0xf2,0x8, 0xdf,0xfa,
+0x80,0x70,0x88,0x82,0x8c,0x83,0xe3,0x9, 0xf0,0xa3,0xdf,0xfa,0x80,0x64,0x89,0x82,
+0x8a,0x83,0xe0,0xa3,0xf6,0x8, 0xdf,0xfa,0x80,0x58,0x89,0x82,0x8a,0x83,0xe0,0xa3,
+0xf2,0x8, 0xdf,0xfa,0x80,0x4c,0x80,0xd2,0x80,0xfa,0x80,0xc6,0x80,0xd4,0x80,0x69,
+0x80,0xf2,0x80,0x33,0x80,0x10,0x80,0xa6,0x80,0xea,0x80,0x9a,0x80,0xa8,0x80,0xda,
+0x80,0xe2,0x80,0xca,0x80,0x33,0x89,0x82,0x8a,0x83,0xec,0xfa,0xe4,0x93,0xa3,0xc8,
+0xc5,0x82,0xc8,0xcc,0xc5,0x83,0xcc,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xcc,0xc5,0x83,
+0xcc,0xdf,0xe9,0xde,0xe7,0x80,0xd, 0x89,0x82,0x8a,0x83,0xe4,0x93,0xa3,0xf6,0x8,
+0xdf,0xf9,0xec,0xfa,0xa9,0xf0,0xed,0xfb,0x22,0x89,0x82,0x8a,0x83,0xec,0xfa,0xe0,
+0xa3,0xc8,0xc5,0x82,0xc8,0xcc,0xc5,0x83,0xcc,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xcc,
+0xc5,0x83,0xcc,0xdf,0xea,0xde,0xe8,0x80,0xdb,0x89,0x82,0x8a,0x83,0xe4,0x93,0xa3,
+0xf2,0x8, 0xdf,0xf9,0x80,0xcc,0x88,0xf0,0xef,0x60,0x1, 0xe, 0x4e,0x60,0xc3,0x88,
+0xf0,0xed,0x24,0x2, 0xb4,0x4, 0x0, 0x50,0xb9,0xf5,0x82,0xeb,0x24,0x2, 0xb4,0x4,
+0x0, 0x50,0xaf,0x23,0x23,0x45,0x82,0x23,0x90,0x0, 0xa6,0x73,0xbb,0x1, 0x6, 0x89,
+0x82,0x8a,0x83,0xe0,0x22,0x50,0x2, 0xe7,0x22,0xbb,0xfe,0x2, 0xe3,0x22,0x89,0x82,
+0x8a,0x83,0xe4,0x93,0x22,0xbb,0x1, 0xc, 0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
+0xf5,0x83,0xe0,0x22,0x50,0x6, 0xe9,0x25,0x82,0xf8,0xe6,0x22,0xbb,0xfe,0x6, 0xe9,
+0x25,0x82,0xf8,0xe2,0x22,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe4,
+0x93,0x22,0xbb,0x1, 0xf, 0xf8,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,
+0xe0,0x28,0xf0,0x22,0x50,0x9, 0xc5,0x82,0x29,0xf8,0xe5,0x82,0x26,0xf6,0x22,0xbb,
+0xfe,0x9, 0xc5,0x82,0x29,0xf8,0xe2,0x25,0x82,0xf2,0x22,0xf8,0xea,0x25,0x83,0xf5,
+0x83,0xe9,0x93,0x28,0x22,0xbb,0x1, 0x6, 0x89,0x82,0x8a,0x83,0xf0,0x22,0x50,0x2,
+0xf7,0x22,0xbb,0xfe,0x1, 0xf3,0x22,0xf8,0xbb,0x1, 0xd, 0xe5,0x82,0x29,0xf5,0x82,
+0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0x22,0x50,0x6, 0xe9,0x25,0x82,0xc8,0xf6,0x22,
+0xbb,0xfe,0x5, 0xe9,0x25,0x82,0xc8,0xf2,0x22,0xef,0x8d,0xf0,0xa4,0xa8,0xf0,0xcf,
+0x8c,0xf0,0xa4,0x28,0xce,0x8d,0xf0,0xa4,0x2e,0xfe,0x22,0xbc,0x0, 0xb, 0xbe,0x0,
+0x29,0xef,0x8d,0xf0,0x84,0xff,0xad,0xf0,0x22,0xe4,0xcc,0xf8,0x75,0xf0,0x8, 0xef,
+0x2f,0xff,0xee,0x33,0xfe,0xec,0x33,0xfc,0xee,0x9d,0xec,0x98,0x40,0x5, 0xfc,0xee,
+0x9d,0xfe,0xf, 0xd5,0xf0,0xe9,0xe4,0xce,0xfd,0x22,0xed,0xf8,0xf5,0xf0,0xee,0x84,
+0x20,0xd2,0x1c,0xfe,0xad,0xf0,0x75,0xf0,0x8, 0xef,0x2f,0xff,0xed,0x33,0xfd,0x40,
+0x7, 0x98,0x50,0x6, 0xd5,0xf0,0xf2,0x22,0xc3,0x98,0xfd,0xf, 0xd5,0xf0,0xea,0x22,
+0xc5,0xf0,0xf8,0xa3,0xe0,0x28,0xf0,0xc5,0xf0,0xf8,0xe5,0x82,0x15,0x82,0x70,0x2,
+0x15,0x83,0xe0,0x38,0xf0,0x22,0xa3,0xf8,0xe0,0xc5,0xf0,0x25,0xf0,0xf0,0xe5,0x82,
+0x15,0x82,0x70,0x2, 0x15,0x83,0xe0,0xc8,0x38,0xf0,0xe8,0x22,0xbb,0x1, 0xa, 0x89,
+0x82,0x8a,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,0x50,0x6, 0x87,0xf0,0x9, 0xe7,0x19,
+0x22,0xbb,0xfe,0x7, 0xe3,0xf5,0xf0,0x9, 0xe3,0x19,0x22,0x89,0x82,0x8a,0x83,0xe4,
+0x93,0xf5,0xf0,0x74,0x1, 0x93,0x22,0xbb,0x1, 0x10,0xe5,0x82,0x29,0xf5,0x82,0xe5,
+0x83,0x3a,0xf5,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,0x50,0x9, 0xe9,0x25,0x82,0xf8,
+0x86,0xf0,0x8, 0xe6,0x22,0xbb,0xfe,0xa, 0xe9,0x25,0x82,0xf8,0xe2,0xf5,0xf0,0x8,
+0xe2,0x22,0xe5,0x83,0x2a,0xf5,0x83,0xe9,0x93,0xf5,0xf0,0xa3,0xe9,0x93,0x22,0xbb,
+0x1, 0xd, 0xc5,0x82,0x29,0xc5,0x82,0xc5,0x83,0x3a,0xc5,0x83,0x2, 0x2, 0x60,0x50,
+0x11,0xc5,0x82,0x29,0xf8,0x8, 0xe5,0xf0,0x26,0xf6,0x18,0xf5,0xf0,0xe5,0x82,0x36,
+0xf6,0x22,0xbb,0xfe,0x11,0xc5,0x82,0x29,0xf8,0x8, 0xe2,0x25,0xf0,0xf5,0xf0,0xf2,
+0x18,0xe2,0x35,0x82,0xf2,0x22,0xf8,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x2a,0xf5,
+0x83,0x74,0x1, 0x93,0x25,0xf0,0xf5,0xf0,0xe4,0x93,0x38,0x22,0xbb,0x1, 0xa, 0x89,
+0x82,0x8a,0x83,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x6, 0xf7,0x9, 0xa7,0xf0,0x19,
+0x22,0xbb,0xfe,0x6, 0xf3,0xe5,0xf0,0x9, 0xf3,0x19,0x22,0xf8,0xbb,0x1, 0x11,0xe5,
+0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,
+0x50,0x9, 0xe9,0x25,0x82,0xc8,0xf6,0x8, 0xa6,0xf0,0x22,0xbb,0xfe,0x9, 0xe9,0x25,
+0x82,0xc8,0xf2,0xe5,0xf0,0x8, 0xf2,0x22,0xe8,0x8f,0xf0,0xa4,0xcc,0x8b,0xf0,0xa4,
+0x2c,0xfc,0xe9,0x8e,0xf0,0xa4,0x2c,0xfc,0x8a,0xf0,0xed,0xa4,0x2c,0xfc,0xea,0x8e,
+0xf0,0xa4,0xcd,0xa8,0xf0,0x8b,0xf0,0xa4,0x2d,0xcc,0x38,0x25,0xf0,0xfd,0xe9,0x8f,
+0xf0,0xa4,0x2c,0xcd,0x35,0xf0,0xfc,0xeb,0x8e,0xf0,0xa4,0xfe,0xa9,0xf0,0xeb,0x8f,
+0xf0,0xa4,0xcf,0xc5,0xf0,0x2e,0xcd,0x39,0xfe,0xe4,0x3c,0xfc,0xea,0xa4,0x2d,0xce,
+0x35,0xf0,0xfd,0xe4,0x3c,0xfc,0x22,0x75,0xf0,0x8, 0x75,0x82,0x0, 0xef,0x2f,0xff,
+0xee,0x33,0xfe,0xcd,0x33,0xcd,0xcc,0x33,0xcc,0xc5,0x82,0x33,0xc5,0x82,0x9b,0xed,
+0x9a,0xec,0x99,0xe5,0x82,0x98,0x40,0xc, 0xf5,0x82,0xee,0x9b,0xfe,0xed,0x9a,0xfd,
+0xec,0x99,0xfc,0xf, 0xd5,0xf0,0xd6,0xe4,0xce,0xfb,0xe4,0xcd,0xfa,0xe4,0xcc,0xf9,
+0xa8,0x82,0x22,0xb8,0x0, 0xc1,0xb9,0x0, 0x59,0xba,0x0, 0x2d,0xec,0x8b,0xf0,0x84,
+0xcf,0xce,0xcd,0xfc,0xe5,0xf0,0xcb,0xf9,0x78,0x18,0xef,0x2f,0xff,0xee,0x33,0xfe,
+0xed,0x33,0xfd,0xec,0x33,0xfc,0xeb,0x33,0xfb,0x10,0xd7,0x3, 0x99,0x40,0x4, 0xeb,
+0x99,0xfb,0xf, 0xd8,0xe5,0xe4,0xf9,0xfa,0x22,0x78,0x18,0xef,0x2f,0xff,0xee,0x33,
+0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xc9,0x33,0xc9,0x10,0xd7,0x5, 0x9b,0xe9,0x9a,
+0x40,0x7, 0xec,0x9b,0xfc,0xe9,0x9a,0xf9,0xf, 0xd8,0xe0,0xe4,0xc9,0xfa,0xe4,0xcc,
+0xfb,0x22,0x75,0xf0,0x10,0xef,0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xcc,0x33,
+0xcc,0xc8,0x33,0xc8,0x10,0xd7,0x7, 0x9b,0xec,0x9a,0xe8,0x99,0x40,0xa, 0xed,0x9b,
+0xfd,0xec,0x9a,0xfc,0xe8,0x99,0xf8,0xf, 0xd5,0xf0,0xda,0xe4,0xcd,0xfb,0xe4,0xcc,
+0xfa,0xe4,0xc8,0xf9,0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,
+0xf0,0xec,0x64,0x80,0xc8,0x64,0x80,0x98,0x45,0xf0,0x22,0xeb,0x9f,0xf5,0xf0,0xea,
+0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,0xe8,0x9c,0x45,0xf0,0x22,0xe8,0x60,0xf, 0xec,
+0xc3,0x13,0xfc,0xed,0x13,0xfd,0xee,0x13,0xfe,0xef,0x13,0xff,0xd8,0xf1,0x22,0xe8,
+0x60,0xf, 0xef,0xc3,0x33,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xd8,
+0xf1,0x22,0xec,0xf0,0xa3,0xed,0xf0,0xa3,0xee,0xf0,0xa3,0xef,0xf0,0x22,0xa8,0x82,
+0x85,0x83,0xf0,0xd0,0x83,0xd0,0x82,0x12,0x5, 0x15,0x12,0x5, 0x15,0x12,0x5, 0x15,
+0x12,0x5, 0x15,0xe4,0x73,0xe4,0x93,0xa3,0xc5,0x83,0xc5,0xf0,0xc5,0x83,0xc8,0xc5,
+0x82,0xc8,0xf0,0xa3,0xc5,0x83,0xc5,0xf0,0xc5,0x83,0xc8,0xc5,0x82,0xc8,0x22,0xf5,
+0xf0,0xc5,0x82,0xa4,0xc5,0x82,0xc5,0xf0,0xc5,0x83,0xa4,0x25,0x83,0xf5,0x83,0x22,
+0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,0x22,0xbb,0x1, 0x7, 0x89,
+0x82,0x8a,0x83,0x2, 0x5, 0xcb,0x50,0x5, 0xe9,0xf8,0x2, 0x5, 0xc2,0xbb,0xfe,0x5,
+0xe9,0xf8,0x2, 0x5, 0xd4,0x89,0x82,0x8a,0x83,0x2, 0x5, 0xdd,0xbb,0x1, 0xd, 0xe5,
+0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0x2, 0x5, 0xcb,0x50,0x7, 0xe9,0x25,
+0x82,0xf8,0x2, 0x5, 0xc2,0xbb,0xfe,0x7, 0xe9,0x25,0x82,0xf8,0x2, 0x5, 0xd4,0xe5,
+0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0x2, 0x5, 0xdd,0xd0,0x83,0xd0,0x82,
+0xf8,0xe4,0x93,0x70,0x12,0x74,0x1, 0x93,0x70,0xd, 0xa3,0xa3,0x93,0xf8,0x74,0x1,
+0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x2, 0x93,0x68,0x60,0xef,0xa3,0xa3,0xa3,
+0x80,0xdf,0xe6,0xfb,0x8, 0xe6,0xfa,0x8, 0xe6,0xf9,0x22,0xe0,0xfb,0xa3,0xe0,0xfa,
+0xa3,0xe0,0xf9,0x22,0xe2,0xfb,0x8, 0xe2,0xfa,0x8, 0xe2,0xf9,0x22,0xe4,0x93,0xfb,
+0x74,0x1, 0x93,0xfa,0x74,0x2, 0x93,0xf9,0x22,0x78,0xff,0xe4,0xf6,0xd8,0xfd,0x75,
+0x81,0x96,0x2, 0x6, 0x30,0x2, 0x35,0xf3,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0x40,
+0x3, 0xf6,0x80,0x1, 0xf2,0x8, 0xdf,0xf4,0x80,0x29,0xe4,0x93,0xa3,0xf8,0x54,0x7,
+0x24,0xc, 0xc8,0xc3,0x33,0xc4,0x54,0xf, 0x44,0x20,0xc8,0x83,0x40,0x4, 0xf4,0x56,
+0x80,0x1, 0x46,0xf6,0xdf,0xe4,0x80,0xb, 0x1, 0x2, 0x4, 0x8, 0x10,0x20,0x40,0x80,
+0x90,0x6, 0x75,0xe4,0x7e,0x1, 0x93,0x60,0xbc,0xa3,0xff,0x54,0x3f,0x30,0xe5,0x9,
+0x54,0x1f,0xfe,0xe4,0x93,0xa3,0x60,0x1, 0xe, 0xcf,0x54,0xc0,0x25,0xe0,0x60,0xa8,
+0x40,0xb8,0xe4,0x93,0xa3,0xfa,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0xc8,0xc5,0x82,
+0xc8,0xca,0xc5,0x83,0xca,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xdf,
+0xe9,0xde,0xe7,0x80,0xbe,0x1, 0x13,0x0, 0x41,0xc, 0x6e,0x1, 0x41,0xa, 0xdd,0x0,
+0x41,0xc, 0x67,0x0, 0x41,0xc, 0x69,0x0, 0x41,0xc, 0x6d,0x0, 0x41,0xc, 0x6a,0x0,
+0x41,0xc, 0x32,0x1, 0x41,0xc, 0xc5,0x2, 0x41,0xc, 0xc6,0x0, 0x1, 0x14,0x0, 0x41,
+0xc, 0xc7,0x0, 0x1, 0x15,0x0, 0x0, 0xab,0x40,0xaa,0x41,0xa9,0x42,0x85,0x45,0x82,
+0x75,0x83,0x0, 0x22,0xab,0x58,0xaa,0x59,0xa9,0x5a,0x85,0x5d,0x82,0x75,0x83,0x0,
+0x22,0xe5,0x44,0xab,0x40,0xaa,0x41,0xa9,0x42,0x22,0xe5,0x5c,0xab,0x58,0xaa,0x59,
+0xa9,0x5a,0x22,0xbd,0x77,0xb, 0xef,0xc3,0x94,0x6, 0x40,0x19,0x74,0xd, 0x2f,0xff,
+0x22,0xbd,0x78,0xb, 0xef,0xc3,0x94,0xb, 0x40,0xb, 0x74,0x8, 0x2f,0xff,0x22,0xbd,
+0x79,0x1, 0x22,0x7f,0xff,0x22,0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9,
+0xa, 0xb, 0xc, 0xd, 0xe, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0x8,
+0xb, 0xc, 0xe, 0x10,0x12,0x14,0x18,0x19,0x1c,0x1e,0x20,0x24,0x28,0x32,0x0, 0x0,
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32,0x35,0x32,0x32,0x32,
+0x32,0x32,0x32,0x32,0x32,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x44,0x44,0x44,0x44,0x44,
+0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x79,0xb8,0xb7,0xb6,0x88,0x0, 0x0,
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10,0x10,0x10,
+0x1c,0x19,0x14,0x10,0xe, 0xc, 0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x1, 0x2, 0x4, 0x8,
+0x10,0x20,0x40,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0x8b,0x3d,0x8a,0x3e,0x89,0x3f,0xe4,0xf5,0x45,0xe5,0x45,0xc3,0x95,0x43,0x40,0x3,
+0x2, 0xa, 0x56,0xab,0x3d,0xaa,0x3e,0xa9,0x3f,0x12,0x6, 0xad,0x12,0x1, 0x65,0xb4,
+0x1c,0x0, 0x40,0x3, 0x2, 0xa, 0x51,0x90,0x8, 0x2e,0xf8,0x28,0x28,0x73,0x2, 0x8,
+0x82,0x2, 0x8, 0x89,0x2, 0x8, 0x91,0x2, 0x8, 0x99,0x2, 0x8, 0xa1,0x2, 0x8, 0xa9,
+0x2, 0x8, 0xb1,0x2, 0x8, 0xc7,0x2, 0x8, 0xdd,0x2, 0x8, 0xf3,0x2, 0x9, 0x9, 0x2,
+0x9, 0x1f,0x2, 0x9, 0x42,0x2, 0x9, 0x65,0x2, 0x9, 0x88,0x2, 0x9, 0xab,0x2, 0x9,
+0xc1,0x2, 0x9, 0xd7,0x2, 0x9, 0xed,0x2, 0xa, 0x3, 0x2, 0xa, 0x18,0x2, 0xa, 0x1f,
+0x2, 0xa, 0x26,0x2, 0xa, 0x2d,0x2, 0xa, 0x34,0x2, 0xa, 0x3b,0x2, 0xa, 0x42,0x2,
+0xa, 0x49,0x12,0x6, 0xa7,0xe4,0x2, 0xa, 0x4e,0x12,0x6, 0xa7,0x74,0x1, 0x2, 0xa,
+0x4e,0x12,0x6, 0xa7,0x74,0x2, 0x2, 0xa, 0x4e,0x12,0x6, 0xa7,0x74,0x3, 0x2, 0xa,
+0x4e,0x12,0x6, 0xa7,0x74,0x4, 0x2, 0xa, 0x4e,0x12,0x6, 0xa7,0x74,0x5, 0x2, 0xa,
+0x4e,0x12,0x6, 0xc1,0xb4,0x77,0x8, 0x12,0x6, 0xad,0x74,0x13,0x2, 0xa, 0x4e,0x12,
+0x6, 0xad,0x74,0x6, 0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x77,0x8, 0x12,0x6, 0xad,
+0x74,0x14,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0x7, 0x2, 0xa, 0x4e,0x12,0x6, 0xc1,
+0xb4,0x77,0x8, 0x12,0x6, 0xad,0x74,0x15,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0x8,
+0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x77,0x8, 0x12,0x6, 0xad,0x74,0x16,0x2, 0xa,
+0x4e,0x12,0x6, 0xad,0x74,0x9, 0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x77,0x8, 0x12,
+0x6, 0xad,0x74,0x17,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0xa, 0x2, 0xa, 0x4e,0xe5,
+0x44,0xb4,0x77,0x8, 0x12,0x6, 0xa7,0x74,0x18,0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,
+0x78,0x8, 0x12,0x6, 0xad,0x74,0x13,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0xb, 0x2,
+0xa, 0x4e,0xe5,0x44,0xb4,0x77,0x8, 0x12,0x6, 0xa7,0x74,0x19,0x2, 0xa, 0x4e,0x12,
+0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x14,0x2, 0xa, 0x4e,0x12,0x6, 0xad,
+0x74,0xc, 0x2, 0xa, 0x4e,0xe5,0x44,0xb4,0x77,0x8, 0x12,0x6, 0xa7,0x74,0x1a,0x2,
+0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x15,0x2, 0xa, 0x4e,
+0x12,0x6, 0xad,0x74,0xd, 0x2, 0xa, 0x4e,0xe5,0x44,0xb4,0x77,0x8, 0x12,0x6, 0xa7,
+0x74,0x1b,0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x16,
+0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0xe, 0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,
+0x8, 0x12,0x6, 0xad,0x74,0x17,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0xf, 0x2, 0xa,
+0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x18,0x2, 0xa, 0x4e,0x12,
+0x6, 0xad,0x74,0x10,0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,
+0x74,0x19,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0x11,0x2, 0xa, 0x4e,0x12,0x6, 0xc1,
+0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x1a,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0x12,
+0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x1b,0x2, 0xa,
+0x4e,0x12,0x6, 0xad,0x74,0x13,0x80,0x36,0x12,0x6, 0xa7,0x74,0x14,0x80,0x2f,0x12,
+0x6, 0xa7,0x74,0x15,0x80,0x28,0x12,0x6, 0xa7,0x74,0x16,0x80,0x21,0x12,0x6, 0xa7,
+0x74,0x17,0x80,0x1a,0x12,0x6, 0xa7,0x74,0x18,0x80,0x13,0x12,0x6, 0xa7,0x74,0x19,
+0x80,0xc, 0x12,0x6, 0xa7,0x74,0x1a,0x80,0x5, 0x12,0x6, 0xa7,0x74,0x1b,0x12,0x1,
+0xd7,0x5, 0x45,0x2, 0x8, 0x9, 0x22,0x8b,0x55,0x8a,0x56,0x89,0x57,0xe4,0xf5,0x5d,
+0xe5,0x5d,0xc3,0x95,0x5b,0x40,0x3, 0x2, 0xc, 0x53,0xab,0x55,0xaa,0x56,0xa9,0x57,
+0x12,0x6, 0xba,0x12,0x1, 0x65,0xb4,0x10,0x0, 0x40,0x3, 0x2, 0xc, 0x4e,0x90,0xa,
+0x85,0xf8,0x28,0x28,0x73,0x2, 0xa, 0xb5,0x2, 0xa, 0xcf,0x2, 0xa, 0xf2,0x2, 0xb,
+0x15,0x2, 0xb, 0x38,0x2, 0xb, 0x5b,0x2, 0xb, 0x7e,0x2, 0xb, 0xa1,0x2, 0xb, 0xc4,
+0x2, 0xb, 0xe7,0x2, 0xc, 0x9, 0x2, 0xc, 0x1d,0x2, 0xc, 0x31,0x2, 0xc, 0x38,0x2,
+0xc, 0x3f,0x2, 0xc, 0x46,0xe5,0x5c,0xb4,0x77,0x5, 0x12,0x6, 0xcc,0x80,0x23,0x12,
+0x6, 0xca,0xb4,0x78,0x3, 0x2, 0xb, 0x30,0x12,0x6, 0xba,0xe4,0x2, 0xc, 0x4b,0xe5,
+0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0x5, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,
+0x78,0x8, 0x12,0x6, 0xba,0x74,0x4, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,0x1, 0x2,
+0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0x6, 0x2, 0xc, 0x4b,0x12,
+0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0x5, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,
+0x74,0x2, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0x7, 0x2,
+0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0x6, 0x2, 0xc, 0x4b,
+0x12,0x6, 0xba,0x74,0x3, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,
+0x74,0x8, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0x7,
+0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,0x4, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8,
+0x12,0x6, 0xb4,0x74,0x9, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6,
+0xba,0x74,0x8, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,0x5, 0x2, 0xc, 0x4b,0xe5,0x5c,
+0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0xa, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,
+0x8, 0x12,0x6, 0xba,0x74,0x9, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,0x6, 0x2, 0xc,
+0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0xb, 0x2, 0xc, 0x4b,0x12,0x6,
+0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0xa, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,
+0x7, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0xc, 0x2, 0xc,
+0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0xb, 0x2, 0xc, 0x4b,0x12,
+0x6, 0xba,0x74,0x8, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,
+0xd, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0xc, 0x2,
+0xc, 0x4b,0x12,0x6, 0xba,0x74,0x9, 0x80,0x42,0x12,0x6, 0xca,0xb4,0x78,0x7, 0x12,
+0x6, 0xba,0x74,0xd, 0x80,0x35,0x12,0x6, 0xba,0x74,0xa, 0x80,0x2e,0x12,0x6, 0xca,
+0xb4,0x78,0x7, 0x12,0x6, 0xba,0x74,0xe, 0x80,0x21,0x12,0x6, 0xba,0x74,0xb, 0x80,
+0x1a,0x12,0x6, 0xb4,0x74,0xc, 0x80,0x13,0x12,0x6, 0xb4,0x74,0xd, 0x80,0xc, 0x12,
+0x6, 0xb4,0x74,0xe, 0x80,0x5, 0x12,0x6, 0xb4,0x74,0xf, 0x12,0x1, 0xd7,0x5, 0x5d,
+0x2, 0xa, 0x60,0x22,0xc0,0x0, 0xc0,0x3f,0xdf,0xbf,0xdf,0xbf,0xc0,0x1, 0xc0,0x82,
+0xc1,0x2, 0xc1,0x1, 0xc0,0x3f,0xdf,0x3d,0xde,0x3c,0xde,0xbe,0xc0,0x2, 0xc1,0x85,
+0xc2,0x85,0xc2,0x2, 0xc0,0x3e,0xde,0x3a,0xdd,0x3a,0xdd,0xbd,0xc0,0x3, 0xc2,0x87,
+0xc4,0x7, 0xc3,0x3, 0xc0,0x3d,0xdd,0x38,0xdb,0xb7,0xdc,0xbc,0xc0,0x4, 0xc3,0x8a,
+0xc5,0x8a,0xc4,0x4, 0xc0,0x3c,0xdc,0x35,0xda,0x35,0xdb,0xbb,0xc0,0x5, 0xc4,0x8c,
+0xc6,0x8d,0xc5,0x5, 0xc0,0x3b,0xdb,0x32,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
+0xc7,0x8d,0xc5,0x5, 0xc0,0x3b,0xdb,0x34,0xd9,0xb4,0xdb,0xbb,0xc0,0x5, 0xc4,0x8b,
+0xc6,0xb, 0xc4,0x4, 0xc0,0x3c,0xdc,0x36,0xdb,0x36,0xdc,0xbc,0xc0,0x4, 0xc3,0x89,
+0xc4,0x88,0xc3,0x3, 0xc0,0x3d,0xdd,0x39,0xdc,0x39,0xdd,0xbd,0xc0,0x3, 0xc2,0x86,
+0xc3,0x6, 0xc2,0x2, 0xc0,0x3e,0xde,0x3b,0xdd,0xbc,0xde,0xbe,0xc0,0x2, 0xc1,0x83,
+0xc1,0x83,0xc1,0x1, 0xc0,0x3f,0xdf,0x3e,0xdf,0x3e,0xdf,0xbf,0xc0,0x0, 0xc0,0x81,
+0xc0,0x80,0xc0,0x0, 0x8b,0x33,0x8a,0x34,0x89,0x35,0xe5,0x37,0xd3,0x94,0xa, 0x50,
+0x36,0xed,0x94,0xf, 0x50,0x31,0xe5,0x37,0xc3,0x94,0xa, 0x50,0x2a,0xe5,0x37,0x90,
+0x7, 0x5, 0x93,0xff,0x24,0x4, 0xab,0x33,0x20,0xe0,0xd, 0xf1,0xec,0xfa,0xef,0xd1,
+0xac,0x54,0xf0,0xd1,0x98,0x4d,0x80,0xc, 0xd1,0x9d,0x54,0xf, 0xd1,0x98,0xff,0xed,
+0xc4,0x54,0xf0,0x4f,0x12,0x1, 0xc5,0x22,0x12,0x1, 0xc5,0xab,0x33,0xe5,0x35,0x24,
+0x10,0xf9,0xe4,0x35,0x34,0xfa,0xe5,0x37,0x90,0x7, 0x5, 0x93,0x24,0x4, 0xff,0xe4,
+0x33,0xa2,0xe7,0x13,0xfe,0xef,0x13,0x29,0xf9,0xea,0x3e,0xfa,0x2, 0x1, 0x4c,0xf1,
+0xcd,0xe4,0xf5,0x2d,0xe5,0x2d,0x20,0xe0,0x13,0xab,0x29,0xf1,0xaf,0xe5,0x2d,0xc3,
+0x13,0x7e,0x0, 0x29,0xf9,0xee,0x3a,0xfa,0xe4,0x12,0x1, 0xc5,0xe5,0x2d,0xc3,0x94,
+0xa, 0x50,0x1c,0x74,0x2d,0x25,0x2d,0xf1,0xe4,0xe0,0xff,0xe5,0x2d,0x90,0x7, 0x5,
+0x93,0x24,0x4, 0xf5,0x82,0xe4,0x33,0xf5,0x83,0xf1,0xba,0xef,0x12,0x1, 0xd7,0x5,
+0x2d,0xe5,0x2d,0xb4,0x10,0xbe,0xe4,0xf5,0x2d,0xe5,0x2d,0x20,0xe0,0x5, 0xf1,0xc1,
+0xe0,0x80,0x9, 0xe5,0x2d,0xf1,0xc1,0xe0,0x54,0xf0,0xff,0xc4,0x54,0xf, 0xf5,0x2c,
+0xe5,0x2d,0xc3,0x94,0xa, 0x50,0x2a,0xe5,0x2d,0x90,0x7, 0x5, 0x93,0xff,0x24,0x4,
+0xab,0x29,0x20,0xe0,0x9, 0xf1,0xaf,0xef,0xd1,0xac,0x45,0x2c,0x80,0x10,0xf1,0xaf,
+0xe5,0x2d,0x90,0x7, 0x5, 0xd1,0xab,0xff,0xe5,0x2c,0xc4,0x54,0xf0,0x4f,0x12,0x1,
+0xc5,0x5, 0x2d,0xe5,0x2d,0x64,0x10,0x70,0xb0,0x90,0xa, 0xe7,0xf1,0xb9,0x90,0x0,
+0x18,0x12,0x1, 0xd7,0x90,0xb, 0x11,0xe0,0x90,0x0, 0x19,0xf1,0xdc,0x90,0x0, 0x1a,
+0x12,0x1, 0xd7,0x90,0x0, 0x1b,0xe4,0xf1,0xd4,0x90,0x0, 0x1c,0x12,0x1, 0xd7,0x90,
+0x0, 0x1e,0x74,0x13,0x12,0x1, 0xd7,0x90,0x0, 0x20,0x74,0x3, 0x12,0x1, 0xd7,0x90,
+0x0, 0x21,0x74,0x3f,0x12,0x1, 0xd7,0x90,0x0, 0x22,0x74,0x3f,0x12,0x1, 0xd7,0x90,
+0x0, 0x1d,0xf1,0xf5,0x74,0x1, 0x12,0x1, 0xd7,0x12,0x61,0x61,0x8f,0x2c,0x22,0xe5,
+0x2b,0x24,0x10,0xf9,0xe4,0x35,0x2a,0xfa,0x22,0xe0,0xab,0x29,0xaa,0x2a,0xa9,0x2b,
+0x22,0xc3,0x13,0x24,0x4b,0xf5,0x82,0xe4,0x34,0xb, 0xf5,0x83,0x22,0x8b,0x29,0x8a,
+0x2a,0x89,0x2b,0x22,0x12,0x1, 0xd7,0x90,0xa, 0xe9,0xe0,0x22,0x12,0x1, 0xd7,0x90,
+0xb, 0x3d,0xe0,0x22,0xf5,0x82,0xe4,0x34,0xb, 0xf5,0x83,0x22,0xe5,0x35,0x24,0x10,
+0xf9,0xe4,0x35,0x34,0x22,0x74,0xa, 0x12,0x1, 0xd7,0x90,0x0, 0x1f,0x22,0x7b,0x1,
+0x7a,0xa, 0x79,0xe5,0xf1,0xfa,0x90,0x0, 0x52,0xf1,0xdf,0xf5,0x30,0x12,0x46,0x4f,
+0xf5,0x31,0x74,0x1, 0x12,0x65,0x30,0xe4,0x12,0x1, 0xd7,0xe4,0xf5,0x2d,0xab,0x21,
+0xe5,0x23,0x24,0x58,0x12,0x62,0x44,0xf5,0x83,0xed,0xf0,0x5, 0x2d,0xe5,0x2d,0xb4,
+0xe, 0xec,0xe4,0xf5,0x2f,0xf5,0x2d,0xb1,0x81,0xe0,0xff,0xc3,0x95,0x2f,0x40,0x2,
+0x8f,0x2f,0x5, 0x2d,0xe5,0x2d,0xb4,0xf, 0xee,0xe5,0x2f,0xc3,0x94,0xf, 0x50,0x9,
+0xc3,0x74,0xf, 0x95,0x2f,0xf5,0x2f,0x80,0x3, 0xe4,0xf5,0x2f,0xe4,0xf5,0x2d,0xab,
+0x21,0xe5,0x23,0x24,0x66,0x12,0x62,0x44,0xf5,0x83,0xed,0xf0,0x5, 0x2d,0xe5,0x2d,
+0xb4,0x8, 0xec,0x85,0x2f,0x2e,0xaf,0x2e,0x15,0x2e,0xef,0x70,0x2, 0x21,0xd6,0x12,
+0x0, 0x4e,0x12,0x47,0x5b,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x12,0x61,0x61,0x12,0x45,
+0xc, 0x85,0x27,0x49,0x85,0x28,0x4a,0x85,0x29,0x4b,0xb1,0xb1,0x12,0x45,0xe2,0x60,
+0xf0,0xe4,0xf5,0x2d,0xb1,0xb1,0x12,0x66,0xf, 0x50,0x58,0xe4,0xfd,0xf1,0xdc,0xff,
+0xed,0xc3,0x9f,0x50,0x4a,0xe5,0x2d,0x70,0xc, 0x12,0x64,0xb0,0xe4,0xf0,0xed,0x51,
+0x23,0xe4,0xf0,0xa3,0xf0,0xb1,0x1c,0xe5,0x2d,0x12,0x4c,0x3c,0xed,0xb1,0x56,0xd3,
+0x94,0xf8,0xee,0x64,0x80,0x94,0xaa,0x50,0x23,0xc3,0xef,0x94,0x70,0xee,0x64,0x80,
+0x94,0x97,0x40,0x18,0xef,0x78,0x5, 0x12,0x46,0x55,0xd8,0xfb,0xff,0xed,0x51,0x23,
+0xee,0x8f,0xf0,0x12,0x2, 0x60,0x12,0x64,0xb0,0xe0,0x4, 0xf0,0xd, 0x80,0xae,0x5,
+0x2d,0x80,0xa1,0xe4,0xf5,0x32,0xf5,0x2d,0xf1,0xdc,0xff,0xe5,0x2d,0xc3,0x9f,0x40,
+0x2, 0x21,0xce,0x74,0x8a,0x25,0x2d,0x12,0x64,0xb3,0xe0,0xfd,0x70,0x9, 0xe5,0x2d,
+0x51,0x23,0x12,0x66,0x9f,0x80,0x3a,0xe5,0x2d,0x51,0x23,0xc0,0x83,0xc0,0x82,0xe0,
+0xfe,0xa3,0xe0,0xff,0x7c,0x0, 0x12,0x2, 0xb, 0xd0,0x82,0xd0,0x83,0xee,0xf0,0xa3,
+0xef,0xf0,0xe5,0x2d,0x51,0x23,0xc0,0x83,0xc0,0x82,0xe0,0xfe,0xa3,0xe0,0x78,0x5,
+0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xd0,0x82,0xd0,0x83,0xee,0xf0,0xa3,0xef,
+0xf0,0xf1,0x63,0x90,0x0, 0x73,0xb1,0x5c,0x90,0x0, 0xe, 0x12,0x65,0x84,0xe5,0x2d,
+0x51,0x23,0x12,0x66,0x21,0x50,0x12,0xb1,0x81,0xe0,0xc3,0x95,0x2f,0x50,0x6, 0xb1,
+0x81,0xe0,0x4, 0x80,0x2c,0x5, 0x32,0x80,0x41,0xf1,0x63,0x90,0x0, 0x73,0xb1,0x5c,
+0x90,0x0, 0xe, 0x12,0x2, 0xb7,0x2f,0xff,0xe5,0xf0,0x3e,0xfe,0xe5,0x2d,0x51,0x23,
+0x12,0x66,0x2a,0x40,0x23,0xb1,0x81,0xe0,0xd3,0x94,0x0, 0x40,0x17,0xb1,0x81,0xe0,
+0x14,0xf0,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0xb1,0x81,0xe0,0xfd,0x85,0x2d,0x37,0x12,
+0xe, 0x54,0x80,0x6, 0x5, 0x32,0x80,0x2, 0x5, 0x32,0x5, 0x2d,0x21,0x8, 0xf1,0xdc,
+0x65,0x32,0x60,0x2, 0x1, 0x76,0xe4,0xf5,0x2d,0x12,0x62,0x75,0xf5,0x83,0xe0,0xc4,
+0x54,0xf0,0xfd,0x74,0x6e,0x2f,0xf5,0x82,0x74,0xa, 0x3e,0xf5,0x83,0xe0,0x54,0xf,
+0x4d,0xff,0xab,0x21,0xe5,0x23,0x24,0x66,0xf9,0xe4,0x35,0x22,0xfa,0xe5,0x2d,0x12,
+0x25,0xec,0xef,0x12,0x1, 0xc5,0x5, 0x2d,0xe5,0x2d,0xb4,0x8, 0xcc,0xb1,0xb1,0xe5,
+0x30,0x12,0x65,0x30,0xe5,0x31,0x12,0x1, 0xd7,0x7f,0x1, 0x22,0x12,0x4, 0xf2,0xe5,
+0x2f,0x25,0xe0,0x25,0xe0,0x24,0x36,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x12,
+0x65,0xd1,0xe4,0x90,0xa, 0x4a,0xf0,0xf5,0x2a,0xb1,0x38,0x90,0x0, 0x4, 0x74,0xff,
+0x12,0x1, 0xd7,0xb1,0x63,0x74,0xff,0xf0,0xe5,0x2a,0x51,0x23,0x74,0xff,0xf0,0xa3,
+0xf0,0xb1,0x75,0xe4,0xf0,0x5, 0x2a,0xe5,0x2a,0xb4,0x5, 0xdd,0xb1,0x1c,0xb1,0x6f,
+0x70,0x2d,0x90,0x0, 0x42,0x12,0x1, 0x65,0x70,0x2, 0x81,0x72,0xe4,0xf5,0x2a,0xb1,
+0x1c,0x90,0x0, 0x2d,0xe5,0x2a,0x12,0x52,0x10,0xb1,0x1c,0x90,0x0, 0x37,0x75,0xf0,
+0x2, 0xe5,0x2a,0x12,0x52,0x13,0x5, 0x2a,0xe5,0x2a,0xb4,0x5, 0xe2,0x81,0x72,0xb1,
+0x1c,0x90,0x0, 0x42,0x12,0x1, 0x65,0x70,0x39,0xf5,0x2a,0xb1,0x1c,0xb1,0x6f,0xff,
+0xe5,0x2a,0xc3,0x9f,0x40,0x2, 0x81,0x72,0x75,0xf0,0x7, 0xe5,0x2a,0xb1,0x98,0xb1,
+0x5c,0x12,0x66,0x6, 0xb1,0x2f,0x90,0x0, 0x2, 0x12,0x2, 0xb7,0xff,0xe5,0x2a,0xb1,
+0x23,0x90,0x0, 0x4, 0xe5,0x2a,0x12,0x1, 0xd7,0xb1,0x75,0x74,0x1, 0xf0,0x5, 0x2a,
+0x80,0xc9,0xe4,0xf5,0x2a,0xb1,0x1c,0xb1,0x6f,0xff,0xe5,0x2a,0xc3,0x9f,0x50,0x66,
+0xe4,0xf5,0x2b,0xb1,0x1c,0x90,0x0, 0x37,0xe5,0x2b,0x12,0x65,0xa0,0x12,0x1b,0xf6,
+0xe5,0x2a,0x75,0xf0,0x7, 0x12,0x2e,0x6, 0xfa,0x90,0x0, 0x2, 0x12,0x2, 0xb7,0x12,
+0x47,0x7a,0xc0,0x6, 0xc0,0x7, 0xb1,0x1c,0x12,0x66,0x3b,0xb1,0x59,0x75,0xf0,0x7,
+0xe5,0x2a,0xb1,0x98,0x12,0x65,0x84,0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xff,0xd0,0xe0,
+0x3e,0xfe,0xe5,0x2a,0x51,0x23,0x12,0x66,0x2a,0x40,0xe, 0xb1,0x63,0xe5,0x2b,0xf0,
+0xe5,0x2a,0x51,0x23,0xee,0xf0,0xa3,0xef,0xf0,0x5, 0x2b,0xe5,0x2b,0xc3,0x94,0x5,
+0x40,0xa1,0x5, 0x2a,0x80,0x8f,0xe4,0xf5,0x2a,0xb1,0x1c,0xb1,0x6f,0xff,0xe5,0x2a,
+0xc3,0x9f,0x40,0x2, 0x61,0xf0,0x90,0xa, 0x4a,0x74,0x1, 0xf0,0xe4,0xf5,0x2b,0xb1,
+0x1c,0xb1,0x6f,0xff,0xe5,0x2b,0xc3,0x9f,0x50,0x31,0xe5,0x2a,0x65,0x2b,0x60,0x27,
+0x74,0x40,0x25,0x2b,0xb1,0x67,0xe0,0xff,0xb1,0x63,0xe0,0xb5,0x7, 0x19,0xe5,0x2b,
+0x51,0x23,0xe0,0xfe,0xa3,0xe0,0xff,0xe5,0x2a,0x51,0x23,0x12,0x66,0x21,0x40,0x7,
+0xe4,0x90,0xa, 0x4a,0xf0,0x80,0x4, 0x5, 0x2b,0x80,0xc4,0x90,0xa, 0x4a,0xe0,0x64,
+0x1, 0x70,0x49,0xb1,0x63,0xe0,0x24,0x45,0xb1,0x79,0x74,0x1, 0xf0,0xb1,0x63,0xe0,
+0xfd,0xb1,0x38,0x90,0x0, 0x4, 0xed,0x12,0x1, 0xd7,0xb1,0x1c,0x75,0xf0,0x7, 0xe5,
+0x2a,0xb1,0x98,0xb1,0x5c,0xe9,0x24,0x2d,0xf9,0xe4,0x3a,0xfa,0xb1,0x63,0xe0,0xb1,
+0x95,0xb1,0x32,0x90,0x0, 0x2, 0xb1,0x5c,0xe5,0x29,0x24,0x37,0xf9,0xe4,0x35,0x28,
+0xfa,0xb1,0x63,0xe0,0xb1,0x95,0xee,0x8f,0xf0,0x12,0x3, 0x5b,0x5, 0x2a,0x61,0x49,
+0xe4,0xf5,0x2a,0xb1,0x1c,0xb1,0x6f,0xff,0xe5,0x2a,0xc3,0x9f,0x50,0x50,0xe5,0x2a,
+0x75,0xf0,0x7, 0x12,0x2e,0x6, 0xfa,0xf1,0xee,0xf4,0x70,0x3e,0xf5,0x2b,0x74,0x45,
+0x25,0x2b,0xb1,0x79,0xe0,0x70,0x2b,0x74,0x45,0x25,0x2b,0xb1,0x79,0x74,0x1, 0xf0,
+0xb1,0x1c,0x75,0xf0,0x7, 0xe5,0x2a,0xb1,0x98,0xb1,0x5c,0x12,0x66,0x3b,0xb1,0x2f,
+0x90,0x0, 0x2, 0x12,0x3f,0xa8,0xb1,0x23,0x90,0x0, 0x4, 0xe5,0x2b,0x12,0x1, 0xd7,
+0x80,0x8, 0x5, 0x2b,0xe5,0x2b,0x64,0x5, 0x70,0xc4,0x5, 0x2a,0x80,0xa5,0xe4,0xf5,
+0x2a,0xb1,0x75,0xe0,0x70,0x15,0xb1,0x1c,0x12,0x66,0x6, 0x12,0x52,0x13,0xb1,0x1c,
+0x90,0x0, 0x37,0x75,0xf0,0x2, 0xe5,0x2a,0x12,0x52,0x13,0x5, 0x2a,0xe5,0x2a,0xb4,
+0x5, 0xdf,0xb1,0x1c,0xb1,0x6f,0xf5,0x2b,0xe4,0xf5,0x2a,0xb1,0x75,0xe0,0x64,0x1,
+0x70,0x2e,0xab,0x27,0xe5,0x29,0x24,0x28,0xf1,0xcd,0x12,0x1, 0x4c,0xb4,0x1, 0x5,
+0x74,0x3, 0x12,0x1, 0xc5,0x12,0x1, 0x4c,0xff,0xb4,0x3, 0xb, 0x12,0x65,0x49,0xe5,
+0x2a,0x12,0x25,0xec,0xe4,0x80,0x38,0xef,0x70,0x38,0xf1,0xc7,0x74,0x2, 0x80,0x2f,
+0xab,0x27,0xe5,0x29,0x24,0x28,0xf1,0xcd,0x12,0x1, 0x4c,0xff,0x64,0x2, 0x60,0x3,
+0xef,0x70,0x18,0xf1,0xc7,0x74,0x1, 0x12,0x1, 0xc5,0xaf,0x2b,0x5, 0x2b,0xef,0xb1,
+0x3a,0x90,0x0, 0x4, 0xe5,0x2a,0x12,0x1, 0xd7,0x80,0x7, 0xf1,0xc7,0x74,0x3, 0x12,
+0x1, 0xc5,0x12,0x65,0x49,0xaf,0x2a,0x7e,0x0, 0x12,0x63,0x7a,0x12,0x1, 0x4c,0xfd,
+0xe5,0x29,0x24,0x28,0x12,0x63,0x75,0xed,0x12,0x1, 0xc5,0x5, 0x2a,0xe5,0x2a,0x64,
+0x5, 0x60,0x2, 0x81,0x7b,0x22,0xef,0x25,0xe0,0xff,0xee,0x33,0xfe,0xe5,0x3f,0x2f,
+0xf5,0x82,0xe5,0x3e,0x3e,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0xff,0xab,0x27,0xaa,0x28,
+0xa9,0x29,0x22,0xae,0xf0,0xaa,0x28,0xa9,0x29,0x90,0x0, 0x37,0x75,0xf0,0x2, 0x12,
+0x5, 0x40,0xee,0x8f,0xf0,0x12,0x3, 0x5b,0xe5,0x2a,0x75,0xf0,0x7, 0xa4,0xab,0x27,
+0x25,0x29,0xf9,0xe5,0x28,0x35,0xf0,0xfa,0x22,0x90,0x3, 0x80,0x75,0xf0,0x20,0xe5,
+0x26,0x12,0x5, 0x40,0xe5,0x24,0x75,0xf0,0x2, 0x12,0x5, 0x40,0x12,0x2, 0xb7,0xff,
+0xae,0xf0,0x22,0x74,0x40,0x25,0x2a,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x90,
+0x0, 0x41,0x2, 0x1, 0x65,0x74,0x45,0x25,0x2a,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,
+0x22,0x74,0x6e,0x25,0x2d,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0xe5,0x2f,0xab,
+0x2a,0xaa,0x2b,0xa9,0x2c,0x75,0xf0,0x2, 0xa4,0xf5,0x82,0x85,0xf0,0x83,0x22,0x85,
+0x27,0x33,0x85,0x28,0x34,0x85,0x29,0x35,0x85,0x2a,0x36,0x85,0x2b,0x37,0x85,0x2c,
+0x38,0xab,0x24,0xaa,0x25,0xa9,0x26,0x22,0xf1,0xfa,0xb1,0xb1,0x90,0x0, 0x49,0xe4,
+0x12,0x1, 0xd7,0xf1,0xe8,0xff,0x60,0x5, 0xd3,0x94,0x2, 0x40,0x9, 0xb1,0xb1,0x90,
+0x0, 0x4a,0xe4,0x2, 0x1, 0xd7,0xef,0x64,0x2, 0x70,0x39,0xb1,0xb1,0xf1,0xf4,0xc3,
+0x94,0x2, 0x50,0x30,0xf1,0x42,0x90,0x0, 0x2, 0xf1,0xc0,0x90,0x0, 0xa, 0xf1,0x59,
+0x90,0x0, 0x4, 0xf1,0xc0,0xb1,0xb1,0x90,0x0, 0xc, 0xf1,0x5f,0x90,0x0, 0x6, 0xf1,
+0xc0,0xab,0x24,0xe5,0x26,0x24,0x4f,0xf9,0xe4,0x35,0x25,0xfa,0x12,0x1, 0x4c,0x44,
+0x20,0x12,0x1, 0xc5,0xb1,0xb1,0x12,0x1e,0x6, 0xc4,0x54,0xf, 0x30,0xe0,0x9, 0xf1,
+0x42,0x90,0x0, 0x2, 0xf1,0xc0,0xe1,0xc, 0xb1,0xb1,0xf1,0xe8,0x64,0x2, 0x60,0x2,
+0xe1,0xc, 0xf1,0xf4,0x64,0x2, 0x60,0x2, 0xe1,0xc, 0xb1,0x1c,0x12,0x1, 0x4c,0x64,
+0x1, 0x70,0x2, 0xe1,0x41,0xf1,0x63,0x90,0x0, 0x4, 0xb1,0x5c,0x12,0x2, 0x8c,0xfd,
+0xac,0xf0,0xc3,0xef,0x9d,0xf5,0x2b,0xee,0x9c,0xf5,0x2a,0x90,0x0, 0x2, 0xb1,0x5c,
+0x90,0x0, 0x6, 0x12,0x65,0x41,0xf5,0x2d,0xec,0x9e,0xf5,0x2c,0xb1,0xb1,0x90,0x0,
+0x3, 0xb1,0x5c,0x90,0x0, 0xa, 0x12,0x65,0x41,0xf5,0x2f,0xec,0x9e,0xf5,0x2e,0x90,
+0x0, 0x5, 0xb1,0x5c,0x90,0x0, 0xc, 0x12,0x65,0x41,0xf5,0x31,0xec,0x9e,0xf5,0x30,
+0x12,0x65,0xcb,0x70,0x77,0xaf,0x2d,0xae,0x2c,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7,
+0xaf,0x2b,0xae,0x2a,0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xf5,0x33,0xd0,0xe0,0x3e,0xf5,
+0x32,0xaf,0x31,0xae,0x30,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0xaf,0x2f,0xae,0x2e,
+0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xff,0xd0,0xe0,0x3e,0xfe,0xb1,0x1c,0xf1,0xee,0x7c,
+0x0, 0x25,0x33,0xfd,0xec,0x35,0x32,0xfc,0xc3,0xef,0x9d,0xec,0x12,0x43,0x3b,0x40,
+0x9, 0xb1,0xb1,0x90,0x0, 0x49,0x74,0x48,0x80,0x1f,0xb1,0x1c,0xf1,0xee,0x2f,0xff,
+0xe4,0x3e,0xfe,0xc3,0xe5,0x33,0x9f,0xee,0x64,0x80,0xf8,0xe5,0x32,0x64,0x80,0x98,
+0x40,0xa, 0xb1,0xb1,0x90,0x0, 0x49,0x74,0x49,0x12,0x1, 0xd7,0xb1,0xb1,0x12,0x65,
+0xcb,0x60,0x2e,0x12,0x5b,0x70,0x44,0x2, 0x12,0x1, 0xc5,0xb1,0xb1,0xf1,0x42,0x90,
+0x0, 0x2, 0xf1,0xc0,0xb1,0xb1,0xf1,0xe8,0xb4,0x2, 0x16,0x90,0x0, 0xa, 0xf1,0x5f,
+0x90,0x0, 0x4, 0xf1,0xc0,0xb1,0xb1,0x90,0x0, 0xc, 0xf1,0x5f,0x90,0x0, 0x6, 0xf1,
+0xc0,0x22,0x90,0x0, 0x3, 0x12,0x2, 0xb7,0xff,0xab,0x21,0xaa,0x22,0xa9,0x23,0xe5,
+0xf0,0x8f,0xf0,0x12,0x3, 0x3c,0x90,0x0, 0x5, 0xab,0x24,0xaa,0x25,0xa9,0x26,0x12,
+0x2, 0xb7,0xff,0xab,0x21,0xaa,0x22,0xa9,0x23,0x22,0xf1,0xfa,0xb1,0xb1,0x12,0x4c,
+0x59,0xf1,0x63,0x90,0x0, 0x41,0x12,0x1, 0xd7,0xab,0x24,0x12,0x66,0x4d,0xfa,0xa8,
+0x23,0xac,0x22,0xad,0x21,0x12,0x65,0x3a,0xf1,0x63,0x51,0x2f,0xf1,0x63,0x90,0x0,
+0x43,0x12,0x5, 0x6c,0x8b,0x2a,0x8a,0x2b,0x89,0x2c,0xf1,0x63,0x12,0x38,0xcc,0x12,
+0x66,0x4d,0xa8,0x1, 0xfc,0xad,0x24,0xf1,0x63,0x12,0x65,0x3a,0xf1,0x63,0xb1,0x6f,
+0x90,0x0, 0x42,0x12,0x1, 0xd7,0xb1,0x6f,0xb1,0xb1,0x90,0x0, 0x2d,0x2, 0x1, 0xd7,
+0xe5,0xf0,0x8f,0xf0,0x2, 0x3, 0x5b,0xab,0x27,0xe5,0x29,0x24,0x23,0xf9,0xe4,0x35,
+0x28,0xfa,0x7e,0x0, 0xe9,0x25,0x2a,0xf9,0xee,0x3a,0xfa,0x22,0x90,0x0, 0x1, 0xab,
+0x24,0xaa,0x25,0xa9,0x26,0x2, 0x1, 0x65,0x90,0x0, 0x4b,0x2, 0x1, 0x65,0x90,0x0,
+0x4, 0x2, 0x1, 0x65,0x90,0x0, 0x4c,0x2, 0x1, 0x65,0x8b,0x21,0x8a,0x22,0x89,0x23,
+0x22,0xc3,0xee,0x94,0x0, 0x40,0x2, 0x80,0x3, 0xe4,0xfe,0xff,0xe4,0x7b,0x34,0x12,
+0x20,0x2b,0x12,0x4, 0xbb,0x70,0x3, 0x12,0x20,0x58,0xe4,0xff,0x7e,0x3, 0x12,0x20,
+0x4c,0x12,0x4, 0xbb,0x40,0xb, 0xe4,0x75,0x34,0xff,0x75,0x33,0x2, 0xf5,0x32,0xf5,
+0x31,0xae,0x33,0xaf,0x34,0x22,0x12,0x17,0xfa,0x12,0x15,0x1c,0x12,0x17,0xe8,0xf5,
+0x2f,0x12,0x17,0xf4,0xf5,0x30,0xe4,0xf5,0x2c,0xb1,0xf6,0x74,0xff,0xf0,0xb1,0xd6,
+0x12,0x12,0x25,0x12,0x66,0x5f,0x12,0x63,0x81,0x12,0x66,0x5f,0x5, 0x2c,0xe5,0x2c,
+0xb4,0x5, 0xe6,0xe5,0x2f,0x70,0x32,0xe5,0x30,0xd3,0x94,0x0, 0x50,0x2, 0x61,0xdb,
+0xe4,0xf5,0x2d,0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x2a,0x74,0xff,0x12,0x1, 0xd7,
+0x5, 0x2d,0xe5,0x2d,0xb4,0x5, 0xec,0x12,0x63,0xa0,0x44,0x4, 0x12,0x1, 0xc5,0x54,
+0xf7,0x12,0x1, 0xc5,0x54,0xdf,0x2, 0x1, 0xc5,0xe4,0xf5,0x2d,0xe5,0x2d,0xc3,0x95,
+0x2f,0x50,0x28,0xe5,0x2d,0x75,0xf0,0x7, 0xa4,0xfd,0xac,0xf0,0x12,0x62,0xea,0x3c,
+0xfa,0xe9,0x24,0xa, 0x12,0x63,0xae,0xab,0x21,0xe5,0x23,0x2d,0xf9,0xe5,0x22,0x3c,
+0xfa,0xe9,0x24,0xc, 0x12,0x63,0xae,0x5, 0x2d,0x80,0xd1,0xe5,0x30,0x70,0x8, 0x12,
+0x63,0xa0,0x44,0x10,0x12,0x1, 0xc5,0xe4,0xf5,0x2c,0xf5,0x2d,0xe4,0xf5,0x2e,0xe5,
+0x2e,0xc3,0x95,0x2f,0x50,0x3a,0x71,0xe2,0xb1,0xc4,0xfd,0xe5,0x2d,0x12,0x15,0x3a,
+0xf1,0xf3,0xff,0x6d,0x70,0x26,0xef,0xf4,0x60,0x22,0xb1,0xef,0xef,0xf0,0x90,0x0,
+0x26,0x12,0x15,0x5c,0xb1,0xd6,0x12,0x12,0x25,0xee,0xf0,0xa3,0xef,0xf0,0x90,0x0,
+0x28,0x12,0x15,0x5c,0x12,0x63,0x81,0x12,0x66,0x6f,0x80,0x4, 0x5, 0x2e,0x80,0xbf,
+0x5, 0x2d,0xe5,0x2d,0x64,0x5, 0x70,0xb4,0xe4,0xf5,0x2d,0x85,0x2f,0x2e,0xe5,0x2e,
+0xc3,0x94,0x5, 0x50,0x3a,0x71,0xe2,0xb1,0xc4,0xfd,0xe5,0x2d,0x12,0x15,0x3a,0xf1,
+0xf3,0xff,0x6d,0x70,0x26,0xef,0xf4,0x60,0x22,0xb1,0xef,0xef,0xf0,0x90,0x0, 0x26,
+0x12,0x15,0x5c,0xb1,0xd6,0x12,0x12,0x25,0xee,0xf0,0xa3,0xef,0xf0,0x90,0x0, 0x28,
+0x12,0x15,0x5c,0x12,0x63,0x81,0x12,0x66,0x6f,0x80,0x4, 0x5, 0x2e,0x80,0xbf,0x5,
+0x2d,0xe5,0x2d,0x64,0x5, 0x70,0xb4,0xe4,0xf5,0x2e,0xe4,0xf5,0x2d,0xe5,0x2d,0xc3,
+0x95,0x2c,0x50,0x11,0x71,0xe2,0xb1,0xc4,0xff,0xe5,0x2d,0xb1,0xf8,0xe0,0x6f,0x60,
+0x4, 0x5, 0x2d,0x80,0xe8,0xe5,0x2d,0x65,0x2c,0x70,0x23,0x12,0x65,0x6d,0xe5,0x2e,
+0x75,0xf0,0x7, 0x12,0x2e,0x6, 0xfa,0xc0,0x1, 0xb1,0xd6,0x24,0x36,0xf9,0x74,0xa,
+0x35,0xf0,0xa8,0x1, 0xfc,0x7d,0x1, 0xd0,0x1, 0x12,0x3f,0xa1,0x5, 0x2c,0x5, 0x2e,
+0xe5,0x2e,0x64,0x5, 0x70,0xb4,0x12,0x66,0x56,0x7f,0x23,0x12,0x63,0x5f,0xe5,0x30,
+0x70,0x18,0x12,0x65,0x6d,0xc0,0x2, 0xc0,0x1, 0x12,0x66,0x56,0xa8,0x1, 0xfc,0xad,
+0x27,0xd0,0x1, 0xd0,0x2, 0x12,0x65,0x3a,0x61,0x5b,0x12,0x15,0x1c,0xd1,0x6, 0x13,
+0x13,0x13,0x54,0x1f,0x30,0xe0,0x2, 0x61,0x5b,0xe4,0xf5,0x2e,0xe5,0x2e,0xc3,0x95,
+0x2f,0x40,0x2, 0x61,0x5b,0xe4,0xf5,0x2d,0x71,0xe2,0xb1,0xc4,0xfd,0xe5,0x2d,0x12,
+0x15,0x3a,0xf1,0xf3,0x6d,0x60,0x7, 0x5, 0x2d,0xe5,0x2d,0xb4,0x5, 0xea,0x71,0xe2,
+0x90,0x0, 0xc, 0x12,0x15,0x5c,0xc0,0x6, 0xc0,0x7, 0xe5,0x2d,0x12,0x15,0x3a,0x71,
+0xf3,0xd0,0x7, 0xd0,0x6, 0xb1,0xdd,0xc0,0x6, 0xc0,0x7, 0x71,0xe2,0x90,0x0, 0xa,
+0x12,0x15,0x5c,0xc0,0x6, 0xc0,0x7, 0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x26,0x71,
+0xf6,0xd0,0x7, 0xd0,0x6, 0xb1,0xdd,0xd0,0xe0,0x2f,0xf5,0x2b,0xd0,0xe0,0x3e,0xf5,
+0x2a,0x12,0x15,0xb1,0x90,0x0, 0x1, 0x71,0xf6,0xae,0x4, 0x78,0x3, 0xce,0xc3,0x13,
+0xce,0x13,0xd8,0xf9,0x12,0x64,0xf3,0x50,0x5, 0x75,0x2c,0x4, 0x80,0x3c,0xed,0xae,
+0x4, 0x78,0x2, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0x12,0x64,0xf3,0x50,0x5, 0x75,
+0x2c,0x3, 0x80,0x26,0x90,0x0, 0x1, 0x71,0xf6,0xec,0xc3,0x13,0xfe,0xed,0x13,0x12,
+0x64,0xf3,0x50,0x5, 0x75,0x2c,0x2, 0x80,0x11,0xc3,0xe5,0x2b,0x9d,0xe5,0x2a,0x9c,
+0x50,0x5, 0x75,0x2c,0x1, 0x80,0x3, 0xe4,0xf5,0x2c,0x71,0xe2,0x90,0x0, 0xa, 0x12,
+0x15,0x5c,0xc0,0x6, 0xc0,0x7, 0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x26,0x71,0xf6,
+0xd0,0x7, 0xd0,0x6, 0x12,0x65,0x23,0x80,0x5, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,
+0xf5,0x2b,0x8e,0x2a,0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x26,0x71,0xdc,0x90,0x0,
+0xa, 0x12,0x64,0xc9,0x40,0xb, 0x12,0x15,0x3d,0x90,0x0, 0x26,0x12,0x66,0x33,0x80,
+0x9, 0x12,0x15,0x3d,0xe9,0x24,0x26,0x12,0x63,0xd3,0x71,0xe2,0x90,0x0, 0xc, 0x12,
+0x15,0x5c,0xc0,0x6, 0xc0,0x7, 0xe5,0x2d,0x12,0x15,0x3a,0x71,0xf3,0xd0,0x7, 0xd0,
+0x6, 0x12,0x65,0x23,0x80,0x5, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf5,0x2b,0x8e,
+0x2a,0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x28,0x71,0xdc,0x90,0x0, 0xc, 0x12,0x64,
+0xc9,0x40,0xb, 0x12,0x15,0x3d,0x90,0x0, 0x28,0x12,0x66,0x33,0x80,0x9, 0x12,0x15,
+0x3d,0xe9,0x24,0x28,0x12,0x63,0xd3,0x5, 0x2e,0x21,0xfc,0xe4,0xf5,0x2e,0xe5,0x2e,
+0x12,0x15,0x3a,0x90,0x0, 0x26,0x12,0x62,0xce,0x3e,0xfa,0x90,0x0, 0xa, 0xf1,0xe0,
+0x12,0x3f,0xbf,0xfa,0x90,0x0, 0x28,0x12,0x62,0xce,0x3e,0xfa,0x90,0x0, 0xc, 0xf1,
+0xe0,0x90,0x0, 0x2a,0x12,0x3c,0xb8,0xfd,0x12,0x64,0x37,0x90,0x0, 0xe, 0x12,0x65,
+0xfd,0x64,0x5, 0x70,0xc9,0x12,0x63,0xa0,0x44,0x1, 0x12,0x1, 0xc5,0xe5,0x2f,0xd3,
+0x94,0x0, 0x40,0x37,0xe4,0xf5,0x2e,0x71,0xe2,0x90,0x0, 0xa, 0x12,0x15,0x5c,0x11,
+0x1, 0x90,0x0, 0x3, 0xf1,0xca,0x12,0x64,0x37,0x90,0x0, 0xc, 0x12,0x15,0x5c,0xf1,
+0xf9,0x90,0x0, 0x5, 0xf1,0xca,0x12,0x64,0x37,0xb1,0xc4,0xfd,0x12,0x3f,0xbf,0xfa,
+0x90,0x0, 0x7, 0x12,0x65,0xfd,0xc3,0x94,0x5, 0x40,0xcc,0x22,0x12,0x2, 0xb7,0xfd,
+0xac,0xf0,0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0xab,0x21,0x25,0x23,0xf9,0xe5,0x22,0x35,
+0xf0,0xfa,0x22,0x90,0x0, 0x28,0x12,0x2, 0xb7,0xfd,0xac,0xf0,0x22,0x12,0x17,0xfa,
+0xe4,0xf5,0x2d,0x12,0x5, 0x4c,0xaf,0x1, 0x8a,0x2f,0x8f,0x30,0x12,0x17,0x63,0xd1,
+0x6, 0x20,0xe0,0x10,0x13,0x13,0x54,0x3f,0x20,0xe0,0x9, 0xd1,0x6, 0xc3,0x13,0x20,
+0xe0,0x2, 0xa1,0xa5,0x20,0x1, 0x8, 0x75,0x2b,0xc, 0x75,0x2c,0x33,0x80,0x6, 0x75,
+0x2b,0xc, 0x75,0x2c,0x4d,0xe4,0xf5,0x27,0xb1,0xca,0x74,0xff,0xf0,0x5, 0x27,0xe5,
+0x27,0xb4,0x1a,0xf4,0xd1,0xc, 0x74,0xaa,0xf0,0xa3,0xf0,0xd1,0xc, 0xa3,0xa3,0x74,
+0x1a,0xf0,0x12,0x17,0x63,0x12,0x65,0xcb,0xff,0xe5,0x2c,0x24,0x4, 0xb1,0xce,0xef,
+0xf0,0xe4,0xf5,0x2e,0xf5,0x27,0x12,0x15,0xb1,0x12,0x1, 0x4c,0xff,0xe5,0x27,0xc3,
+0x9f,0x40,0x2, 0xa1,0x47,0xe5,0x27,0x71,0xe4,0x90,0x0, 0x7, 0x12,0x1, 0x65,0x54,
+0xf0,0xff,0xd3,0x94,0x0, 0x40,0x27,0xef,0x64,0xb0,0x60,0x2, 0xa1,0x43,0xd1,0x1c,
+0xff,0xe9,0x24,0x7, 0x12,0x5b,0x73,0x54,0xf, 0x12,0x1, 0xc5,0xab,0x21,0xe5,0x23,
+0x2f,0x71,0xec,0xd1,0x13,0xd1,0x23,0xe0,0x64,0x1, 0x60,0x2, 0xa1,0x43,0xe5,0x27,
+0x71,0xe4,0xd1,0x13,0xd1,0x23,0xe0,0x64,0x3, 0x70,0x2, 0xa1,0x43,0xe5,0x2e,0x25,
+0xe0,0x25,0xe0,0xf5,0x28,0x90,0x0, 0x5, 0x12,0x2, 0xb7,0x12,0x65,0x8f,0xb1,0xb0,
+0xef,0xf0,0xe5,0x28,0x24,0x6, 0xb1,0xb5,0xe5,0x2a,0xf0,0xe5,0x27,0x71,0xe4,0xf1,
+0xed,0x12,0x65,0x8f,0xff,0xe5,0x28,0x24,0x7, 0xb1,0xb5,0xef,0xf0,0xe5,0x28,0x24,
+0x8, 0xb1,0xb5,0xe5,0x2a,0xd1,0x1b,0x71,0xea,0x90,0x0, 0x7, 0x12,0x1, 0x65,0xc4,
+0x54,0xf0,0xff,0xe5,0x28,0x24,0x7, 0xb1,0xb5,0xe0,0x2f,0xd1,0x1b,0x71,0xea,0xd1,
+0x13,0xf4,0x60,0x17,0xd1,0x23,0xe0,0xff,0x64,0x1, 0x60,0x2, 0x5, 0x2d,0xef,0xc4,
+0x33,0x33,0x54,0xc0,0xb1,0xb0,0xe0,0x2f,0xf0,0x80,0x16,0xe5,0x28,0x24,0x5, 0xff,
+0xe4,0x33,0xfe,0xe5,0x2c,0x2f,0xf5,0x82,0xe5,0x2b,0x3e,0xf5,0x83,0xe0,0x24,0xc0,
+0xf0,0x5, 0x2e,0x5, 0x27,0x81,0x66,0xd1,0xc, 0xa3,0xa3,0xa3,0xe5,0x2d,0xf0,0xe5,
+0x2c,0x24,0x19,0xb1,0xce,0xe4,0xf0,0xf5,0x27,0xe5,0x2c,0x24,0x19,0xb1,0xce,0xc0,
+0x83,0xc0,0x82,0xe0,0xff,0xb1,0xca,0xe0,0xfe,0xef,0x6e,0xd0,0x82,0xd0,0x83,0xf0,
+0x5, 0x27,0xe5,0x27,0xb4,0x19,0xe2,0xb2,0x1, 0x7f,0x1, 0xb1,0xa7,0x12,0x17,0x63,
+0xd1,0x6, 0xff,0x13,0x13,0x54,0x3f,0x30,0xe0,0x9, 0xaa,0x2f,0xa9,0x30,0x7b,0x1,
+0x12,0x51,0xbe,0x12,0x4a,0xb2,0x54,0xfe,0x12,0x1, 0xc5,0x54,0xfb,0x12,0x1, 0xc5,
+0x54,0xfd,0x2, 0x1, 0xc5,0xe4,0xff,0xef,0x70,0x3, 0xd2,0x98,0x22,0xc2,0x98,0x22,
+0xff,0xe5,0x28,0x24,0x5, 0xfd,0xe4,0x33,0xfc,0xe5,0x2c,0x2d,0xf5,0x82,0xe5,0x2b,
+0x3c,0xf5,0x83,0x22,0x90,0x0, 0xe, 0x2, 0x1, 0x65,0xe5,0x2c,0x25,0x27,0xf5,0x82,
+0xe4,0x35,0x2b,0xf5,0x83,0x22,0xe5,0x2c,0x75,0xf0,0x7, 0xa4,0x22,0xd3,0xef,0x9d,
+0xee,0x9c,0x40,0x3, 0x2, 0x3f,0xb8,0xc3,0xed,0x9f,0xff,0xec,0x9e,0xfe,0x22,0x90,
+0x0, 0x2a,0x12,0x1, 0x65,0xff,0xe5,0x2c,0x75,0xf0,0x7, 0xa4,0x24,0x3a,0xf5,0x82,
+0xe4,0x34,0xa, 0xf5,0x83,0x22,0x90,0x0, 0x4f,0x2, 0x1, 0x65,0x85,0x2c,0x82,0x85,
+0x2b,0x83,0x22,0x90,0x0, 0x7, 0x12,0x1, 0x65,0xff,0x22,0xf0,0xe5,0x27,0x75,0xf0,
+0x7, 0xa4,0x22,0xe5,0x30,0x24,0x23,0xf5,0x82,0xe4,0x35,0x2f,0xf5,0x83,0xe5,0x82,
+0x2f,0xf5,0x82,0xe4,0x35,0x83,0xf5,0x83,0x22,0x12,0x17,0xfa,0x12,0x17,0xe8,0xff,
+0x12,0x5, 0x4c,0xad,0x1, 0x8a,0x2a,0x8d,0x2b,0xef,0x70,0x2, 0xe1,0xa1,0xe4,0xf5,
+0x24,0xe5,0x24,0x71,0xe4,0x12,0x65,0xb0,0x60,0x4a,0x12,0x63,0xe7,0xe5,0x82,0x25,
+0x25,0xd1,0x31,0xe0,0xff,0x70,0x20,0xf1,0xed,0xfd,0xf1,0xb0,0xf1,0xe6,0xed,0xf0,
+0x90,0x0, 0x5, 0x12,0x2, 0xb7,0xfd,0xf1,0xa2,0xf1,0xe6,0xed,0xf0,0x74,0xb5,0x25,
+0x24,0xf1,0xc2,0xe4,0xf0,0x80,0x1d,0xef,0xb4,0x1, 0x19,0xf1,0xb0,0xf5,0x83,0xe0,
+0xff,0xa3,0xe0,0x90,0x0, 0x3, 0xcf,0x8f,0xf0,0x12,0x3, 0x5b,0xf1,0xa2,0x12,0x65,
+0x9, 0x12,0x3, 0x5b,0x5, 0x24,0xe5,0x24,0x64,0x5, 0x70,0xa5,0xe4,0xf5,0x24,0xe5,
+0x24,0x71,0xe4,0x12,0x65,0xb0,0x70,0x2, 0xe1,0x96,0x12,0x63,0xe7,0xe5,0x82,0x25,
+0x25,0xd1,0x31,0xe0,0x64,0x2, 0x60,0x2, 0xe1,0x96,0x90,0x0, 0x3, 0x12,0x15,0x5c,
+0xf1,0xb0,0x12,0x3b,0x1c,0xc3,0xef,0x9d,0xf5,0x27,0xee,0x9c,0xf5,0x26,0x90,0x0,
+0x5, 0x12,0x15,0x5c,0xf1,0xa2,0x12,0x3b,0x1c,0xc3,0xef,0x9d,0xf5,0x29,0xee,0x9c,
+0xf5,0x28,0xaf,0x29,0xfe,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0xaf,0x27,0xae,0x26,
+0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xff,0xd0,0xe0,0x3e,0xfe,0xc3,0xef,0x94,0x2, 0xee,
+0x64,0x80,0x94,0x80,0x50,0x62,0xf1,0xbe,0xe0,0xd3,0x94,0x78,0x40,0x3d,0xf1,0xb0,
+0x12,0x47,0x63,0xfd,0xac,0x6, 0xe5,0x26,0xa2,0xe7,0x13,0xfe,0xe5,0x27,0x12,0x65,
+0x61,0x50,0x3, 0xe4,0xfc,0xfd,0xf1,0xb0,0x12,0x66,0xa7,0xf1,0xa2,0x12,0x3b,0x1c,
+0xe5,0x28,0xa2,0xe7,0x13,0xfe,0xe5,0x29,0x12,0x65,0x61,0x50,0x3, 0xe4,0xfc,0xfd,
+0xf1,0xa2,0x12,0x66,0xa7,0xf1,0xbe,0xe4,0xf0,0x80,0x5, 0xf1,0xbe,0xe0,0x4, 0xf0,
+0xf1,0xb0,0x12,0x3b,0x1c,0xe5,0x24,0x71,0xe4,0x90,0x0, 0x3, 0xf1,0xe0,0xf1,0xa2,
+0x12,0x65,0x9, 0x12,0x3, 0x5b,0x80,0x1e,0xf1,0xbe,0xe4,0xf0,0xe5,0x24,0x71,0xe4,
+0xf1,0xed,0xff,0xf1,0xb0,0xf1,0xe6,0xef,0xf0,0x90,0x0, 0x5, 0x12,0x2, 0xb7,0xff,
+0xf1,0xa2,0xf1,0xe6,0xef,0xf0,0x5, 0x24,0xe5,0x24,0xc3,0x94,0x5, 0x50,0x2, 0xc1,
+0xaf,0x22,0xe5,0x25,0x25,0xe0,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0xc, 0x22,
+0xe5,0x25,0x25,0xe0,0x25,0xe0,0x24,0xa1,0xf5,0x82,0xe4,0x34,0xc, 0x22,0x74,0xb5,
+0x25,0x25,0xf5,0x82,0xe4,0x34,0xc, 0xf5,0x83,0x22,0xac,0x6, 0xad,0x7, 0xe5,0x2e,
+0x75,0xf0,0x7, 0xa4,0xff,0xae,0xf0,0xab,0x27,0x25,0x29,0xf9,0xe5,0x28,0x3e,0xfa,
+0xec,0x8d,0xf0,0x2, 0x3, 0x5b,0xf5,0x83,0xe5,0xf0,0xf0,0xa3,0x22,0x90,0x0, 0x3,
+0x2, 0x2, 0xb7,0x90,0x0, 0x2a,0x2, 0x1, 0x65,0xc3,0xee,0x94,0x0, 0x40,0x2, 0x80,
+0x3, 0xe4,0xfe,0xff,0xe4,0x7b,0x11,0x11,0x2b,0x12,0x4, 0xbb,0x70,0x2, 0x11,0x58,
+0xe4,0xff,0x7e,0x4, 0x11,0x4c,0x12,0x4, 0xbb,0x40,0xb, 0xe4,0x75,0x34,0xff,0x75,
+0x33,0x3, 0xf5,0x32,0xf5,0x31,0xae,0x33,0xaf,0x34,0x22,0xfc,0xfd,0x7a,0x1, 0xf9,
+0xf8,0x12,0x3, 0x88,0x8f,0x34,0x8e,0x33,0x8d,0x32,0x8c,0x31,0x78,0x8, 0x12,0x4,
+0xcc,0x8f,0x34,0x8e,0x33,0x8d,0x32,0x8c,0x31,0xe4,0xff,0xfe,0xfd,0xfc,0xab,0x34,
+0xaa,0x33,0xa9,0x32,0xa8,0x31,0xc3,0x22,0x75,0x34,0x1, 0xf5,0x33,0xf5,0x32,0xf5,
+0x31,0x22,0x8e,0x25,0x8f,0x26,0x12,0x65,0xd1,0xc3,0xe5,0x25,0x94,0x0, 0x50,0x5,
+0xe4,0xf5,0x25,0xf5,0x26,0xc3,0xec,0x94,0x0, 0x50,0x3, 0xe4,0xfc,0xfd,0xd3,0xe5,
+0x26,0x94,0x2f,0xe5,0x25,0x94,0x0, 0x50,0x17,0xe5,0x26,0x25,0xe0,0xff,0xe5,0x25,
+0x33,0xfe,0xef,0x24,0xd1,0x31,0x40,0x50,0x38,0xe4,0xf5,0x2a,0xf5,0x2b,0x80,0x31,
+0xc3,0xe5,0x26,0x94,0x50,0xe5,0x25,0x94,0x2, 0x40,0x2c,0xe5,0x26,0x24,0xb0,0xcf,
+0xe5,0x25,0x34,0xfd,0xcf,0x25,0x26,0xf5,0x2b,0xef,0x35,0x25,0xf5,0x2a,0xd3,0xe5,
+0x2b,0x94,0x7d,0xe5,0x2a,0x64,0x80,0x94,0x82,0x40,0x6, 0x75,0x2a,0x2, 0x75,0x2b,
+0x7f,0x85,0x2a,0x25,0x85,0x2b,0x26,0xd3,0xed,0x94,0x31,0xec,0x94,0x0, 0x50,0x11,
+0x12,0x3f,0xaf,0xef,0x24,0xcf,0x31,0x40,0x50,0x32,0xe4,0xf5,0x2a,0xf5,0x2b,0x80,
+0x2b,0xc3,0xed,0x94,0x8e,0xec,0x94,0x3, 0x40,0x26,0xed,0x24,0x72,0xff,0xec,0x34,
+0xfc,0xcf,0x2d,0xf5,0x2b,0xef,0x3c,0xf5,0x2a,0xd3,0xe5,0x2b,0x94,0xbd,0xe5,0x2a,
+0x64,0x80,0x94,0x83,0x40,0x6, 0x75,0x2a,0x3, 0x75,0x2b,0xbf,0xac,0x2a,0xad,0x2b,
+0x12,0x15,0x1c,0xe5,0x25,0x85,0x26,0xf0,0x12,0x3, 0x3c,0xab,0x27,0x74,0x2, 0x25,
+0x29,0xf9,0xf5,0x29,0xe4,0x35,0x28,0xfa,0xf5,0x28,0xec,0x8d,0xf0,0x2, 0x3, 0x3c,
+0xf5,0x2b,0xee,0x34,0xff,0xf5,0x2a,0xc3,0xe5,0x2b,0x94,0x2, 0xe5,0x2a,0x64,0x80,
+0x94,0x80,0x22,0x12,0x17,0xfa,0xe4,0xf5,0x24,0x12,0x17,0x63,0x12,0x4c,0x59,0xff,
+0xe5,0x24,0xc3,0x9f,0x50,0x22,0xe5,0x24,0x75,0xf0,0x7, 0x12,0x2e,0x6, 0xfa,0x90,
+0x0, 0xa, 0x12,0x15,0x5c,0x90,0x0, 0xc, 0x12,0x1b,0xf6,0xe9,0x24,0xa, 0xf9,0xe4,
+0x3a,0xfa,0x11,0x62,0x5, 0x24,0x80,0xd1,0x22,0x12,0x64,0x1a,0x74,0x5a,0x12,0x63,
+0x48,0x7a,0x9, 0x79,0x19,0x12,0x49,0x22,0xd1,0xff,0x12,0x28,0x4b,0x75,0x35,0x1,
+0x75,0x36,0x8, 0x75,0x37,0xc6,0xb1,0xf4,0x12,0x38,0x1d,0x7b,0x1, 0x7a,0x9, 0x79,
+0xe8,0x12,0x51,0xbe,0xe4,0x90,0xc, 0xba,0xf0,0x7b,0x1, 0x7a,0x9, 0x79,0x3c,0x12,
+0xe, 0xbf,0x90,0xb, 0xf0,0x74,0xa, 0xf0,0x90,0xb, 0xf0,0xe0,0x70,0xfa,0x12,0x65,
+0xf6,0x7b,0x1, 0x7a,0x9, 0x79,0x5f,0xb1,0xfb,0x7b,0x1, 0x7a,0x9, 0x79,0x5f,0x91,
+0xc9,0x12,0x45,0xc, 0x90,0xb, 0x58,0x74,0x3, 0xf0,0x74,0xe8,0x12,0x28,0x3c,0x12,
+0x64,0x57,0x75,0x2b,0x9, 0x75,0x2c,0x3c,0x12,0xf, 0xfe,0x7e,0x0, 0x7f,0x83,0x12,
+0x47,0xc5,0x91,0xab,0x12,0x46,0xf9,0x12,0x36,0x69,0x90,0xa, 0xd8,0xf0,0xa3,0x74,
+0x64,0xf0,0x75,0x35,0x1, 0x75,0x36,0x0, 0x75,0x37,0x83,0xd1,0xff,0x12,0x45,0x3d,
+0xe4,0x90,0x0, 0x52,0xf0,0xa3,0x4, 0x12,0x65,0xec,0x12,0x37,0x44,0xe4,0x90,0xa,
+0xe0,0xf0,0xa3,0xf0,0x90,0xc, 0x18,0xe0,0x64,0x1, 0x60,0x2, 0x81,0x60,0x12,0x36,
+0x6a,0x90,0xa, 0xd8,0xf0,0x74,0x64,0x12,0x63,0x48,0x7a,0x9, 0x79,0x19,0x12,0x3d,
+0xeb,0xe4,0xf5,0xd, 0xf5,0xc, 0x90,0xc, 0x16,0xe0,0x70,0x5, 0x90,0x8, 0x2c,0x80,
+0x3, 0x90,0x8, 0x2e,0xe0,0xf5,0xe, 0x90,0xc, 0x11,0xe0,0xf4,0x60,0x1b,0x7e,0x0,
+0x7f,0x0, 0x7c,0x9, 0x7d,0x3c,0x7a,0x0, 0x7b,0x83,0x75,0x27,0x9, 0x75,0x28,0x5f,
+0x12,0x45,0xf2,0x90,0xc, 0x11,0x74,0xff,0xf0,0xd1,0xf6,0x12,0x45,0xe2,0x60,0xf9,
+0x90,0x8, 0x28,0xe0,0x90,0xc, 0x1a,0xf0,0x90,0x8, 0x33,0xe0,0xb4,0x1, 0x5, 0xe4,
+0xff,0x12,0x1d,0xa7,0x12,0x28,0x3e,0x12,0x64,0x42,0x75,0x2c,0x34,0x91,0xab,0x12,
+0x53,0x72,0x12,0x28,0x3e,0x12,0x64,0x57,0x75,0x2b,0x9, 0x75,0x2c,0x19,0xb1,0xf4,
+0x12,0x4c,0x5f,0x90,0x8, 0x27,0xe0,0x90,0xb, 0xf4,0xf0,0x90,0x8, 0x20,0xe0,0x90,
+0xb, 0xf5,0xf0,0x64,0x6, 0x70,0x51,0x12,0x64,0x7, 0x12,0x4, 0xa5,0x40,0x20,0x75,
+0x33,0x1, 0x75,0x34,0x0, 0x75,0x35,0x83,0x75,0x36,0x1, 0x75,0x37,0x9, 0x75,0x38,
+0x19,0x75,0x39,0x1, 0x75,0x3a,0x0, 0x75,0x3b,0x0, 0xb1,0xf4,0x12,0x2b,0xe, 0x90,
+0x8, 0x63,0xe0,0x20,0xe0,0x5, 0x91,0xab,0x12,0x3f,0xe8,0x12,0x64,0x61,0x12,0x65,
+0xd8,0x12,0x64,0x48,0x75,0x2c,0x34,0x91,0x9b,0x12,0x46,0x66,0x90,0x8, 0x63,0xe0,
+0x30,0xe0,0x5, 0xe4,0x90,0x8, 0x20,0xf0,0x90,0x8, 0x27,0xe0,0x70,0x10,0x90,0x8,
+0x20,0xe0,0xb4,0x4, 0x9, 0x90,0xa, 0xe0,0xe4,0xf0,0xa3,0x74,0xa, 0xf0,0xd3,0x90,
+0xa, 0xe1,0xe0,0x94,0x0, 0x90,0xa, 0xe0,0xe0,0x94,0x0, 0x40,0x12,0xa3,0xe0,0x24,
+0xff,0xf0,0x90,0xa, 0xe0,0xe0,0x34,0xff,0xf0,0x90,0x8, 0x20,0x74,0x4, 0xf0,0x91,
+0xa2,0x12,0x4a,0xd3,0x90,0x9, 0x16,0xef,0x12,0x28,0x3d,0x12,0x64,0x42,0x75,0x2c,
+0x34,0x91,0xab,0x12,0x5b,0x7a,0xb1,0xf4,0x31,0x53,0x90,0x8, 0x20,0xe0,0xb4,0x6,
+0xe, 0x90,0x8, 0x61,0xe0,0xd3,0x94,0x1, 0x40,0x5, 0xe4,0x90,0x8, 0x20,0xf0,0x12,
+0x64,0x61,0x75,0x27,0x1, 0x75,0x28,0x9, 0x75,0x29,0x19,0xd1,0xff,0x12,0x3b,0x24,
+0x90,0x8, 0x27,0xe0,0x70,0xf, 0x90,0x8, 0x62,0xe0,0xff,0x90,0x8, 0x61,0xe0,0xd3,
+0x9f,0x40,0x7, 0x80,0x0, 0x91,0xa2,0x12,0x3c,0xc5,0x90,0x8, 0x61,0xe0,0xa3,0xf0,
+0x90,0x9, 0x11,0xf0,0x91,0x9b,0x91,0x65,0x91,0x9b,0xb1,0x9e,0x90,0x9, 0x11,0xe0,
+0x90,0x8, 0x61,0xf0,0x90,0xa, 0x2b,0x74,0x1, 0xf0,0xa3,0x74,0xa, 0xf0,0xa3,0x74,
+0x2e,0xf0,0x75,0x24,0x1, 0x75,0x25,0x8, 0x75,0x26,0x34,0x7b,0x1, 0x7a,0x9, 0x79,
+0xe8,0x12,0x17,0x6a,0x90,0x8, 0xc6,0x74,0x1, 0xf0,0xa3,0x74,0x9, 0xf0,0xa3,0x74,
+0xe8,0xf0,0x90,0x8, 0x61,0xe0,0x90,0x9, 0x11,0xf0,0x12,0x65,0xe2,0x75,0x27,0x1,
+0x75,0x28,0x8, 0x75,0x29,0xc6,0xb1,0xf4,0x12,0x18,0x36,0x75,0x24,0x1, 0x75,0x25,
+0x8, 0x75,0x26,0xc6,0x12,0x63,0x53,0x7a,0x9, 0x79,0xe0,0x12,0x15,0xb8,0x91,0x9b,
+0x12,0x1e,0x39,0x12,0x65,0xe2,0x91,0x9b,0x12,0x1b,0xfd,0x75,0x24,0x1, 0x75,0x25,
+0x8, 0x75,0x26,0x29,0x12,0x65,0xd8,0x75,0x2a,0x1, 0x75,0x2b,0x0, 0x75,0x2c,0x83,
+0x75,0x2d,0x1, 0x75,0x2e,0x8, 0x75,0x2f,0x34,0x91,0x9b,0x12,0x47,0xf5,0x41,0x34,
+0xf1,0xdf,0x2, 0x0, 0x18,0x12,0x17,0xfa,0x12,0x17,0xe8,0x70,0x23,0x12,0x17,0xf4,
+0xff,0xd3,0x94,0x0, 0x40,0x1a,0xe5,0x13,0x70,0x12,0x90,0x0, 0x4b,0xef,0x12,0x1,
+0xd7,0x12,0x5b,0x70,0x44,0x8, 0x12,0x1, 0xc5,0x5, 0x13,0x22,0xe4,0xf5,0x13,0x22,
+0xe4,0xf5,0x13,0x12,0x4a,0xb2,0x54,0xf7,0x2, 0x1, 0xc5,0x7b,0x1, 0x7a,0x8, 0x79,
+0xc6,0x22,0x75,0x24,0x1, 0x75,0x25,0x8, 0x75,0x26,0x34,0x7b,0x1, 0x7a,0x0, 0x79,
+0x83,0x22,0x7b,0x1, 0x7a,0x8, 0x79,0x29,0x12,0xe, 0xbf,0x7b,0x1, 0x7a,0x8, 0x79,
+0x4c,0xb1,0xfb,0x7b,0x1, 0x7a,0x8, 0x79,0x4c,0x12,0xf, 0xcd,0xe4,0xf5,0x2c,0x12,
+0xf, 0xba,0x85,0x2c,0x82,0x12,0x2f,0x64,0xfd,0xaf,0x2c,0x12,0x0, 0x1e,0xe5,0x2c,
+0x24,0x1c,0x12,0x66,0x87,0xb1,0xe5,0x12,0x65,0xa6,0x24,0x38,0xb1,0xde,0x12,0x65,
+0xa6,0x24,0x54,0x12,0x66,0x7f,0xb1,0xe5,0xd1,0xe9,0x94,0x1c,0x40,0xd1,0x90,0x0,
+0x70,0x12,0x62,0x86,0xfd,0x7f,0x7e,0x12,0x0, 0x1e,0x12,0xf, 0xba,0x90,0x0, 0x71,
+0x12,0x1, 0x65,0xfd,0x7f,0x7f,0x12,0x0, 0x1e,0x12,0xf, 0xba,0x90,0x0, 0x73,0x12,
+0x1, 0x65,0xfd,0x7f,0x81,0x12,0x0, 0x1e,0x12,0xf, 0xba,0x90,0x0, 0x74,0x12,0x1,
+0x65,0x7f,0x82,0x12,0x66,0x77,0xe5,0x2c,0x24,0x83,0xff,0xab,0x29,0xe5,0x2b,0x24,
+0x75,0xb1,0xe5,0xd1,0xe9,0x94,0x4, 0x40,0xed,0xe4,0xf5,0x2c,0xe5,0x2c,0x24,0x87,
+0xff,0xab,0x29,0xe5,0x2b,0x24,0x79,0xb1,0xe5,0xd1,0xe9,0x94,0x2, 0x40,0xed,0x12,
+0xf, 0xba,0x90,0x0, 0x7b,0x12,0x1, 0x65,0xfd,0x7f,0x89,0x12,0x0, 0x1e,0x12,0xf,
+0xba,0x90,0x0, 0x7c,0x12,0x1, 0x65,0x7f,0x8c,0x12,0x66,0x77,0xe5,0x2c,0x24,0x8d,
+0xff,0xab,0x29,0xe5,0x2b,0x24,0x7d,0xb1,0xe5,0xd1,0xe9,0x94,0x3, 0x40,0xed,0x12,
+0xf, 0xba,0x90,0x0, 0x80,0x12,0x1, 0x65,0xfd,0x7f,0x90,0x2, 0x0, 0x1e,0x12,0x17,
+0xf4,0xff,0xd3,0x94,0x0, 0x50,0x36,0x12,0x17,0xe8,0xd3,0x9f,0x40,0x1d,0x90,0x0,
+0x50,0x12,0x1, 0x65,0xff,0x90,0xc, 0xba,0xe0,0xc3,0x9f,0x50,0x13,0xe0,0x4, 0xf0,
+0x12,0x17,0xf4,0x90,0x0, 0x4b,0x12,0x1, 0xd7,0x80,0x5, 0xe4,0x90,0xc, 0xba,0xf0,
+0x12,0x17,0xe8,0x70,0x8, 0x12,0x5b,0x70,0x54,0xfe,0x12,0x1, 0xc5,0x22,0xff,0xab,
+0x29,0xe5,0x2b,0x24,0x38,0xf9,0xe4,0x35,0x2a,0xfa,0xe5,0x2c,0x7c,0x0, 0x29,0xf9,
+0xec,0x3a,0xfa,0x22,0x7b,0x1, 0x7a,0x8, 0x79,0x34,0x22,0x12,0xf, 0xcd,0x78,0x2d,
+0x7c,0x0, 0x7d,0x0, 0x7b,0xff,0x7a,0x7, 0x79,0x51,0x7e,0x0, 0x7f,0x1c,0x12,0x1,
+0x26,0xe4,0xf5,0x2c,0x12,0x29,0xe6,0xe0,0xff,0xc3,0x94,0x1c,0x50,0x55,0x12,0x64,
+0x77,0x12,0xf, 0xb9,0x8f,0x82,0x75,0x83,0x0, 0x12,0x1, 0xd7,0xe5,0x2c,0x20,0xe0,
+0xf, 0x12,0x64,0x6b,0xe0,0x54,0xf, 0xff,0xe9,0x24,0x1c,0xf9,0xe4,0x3a,0x80,0x10,
+0xe5,0x2c,0x12,0x64,0x6b,0xe0,0xc4,0x54,0xf, 0x12,0x66,0x87,0xf9,0xe4,0x35,0x2a,
+0xfa,0x12,0x29,0xe6,0xe0,0xb1,0xec,0xef,0x12,0x1, 0xc5,0x74,0x2d,0x25,0x2c,0xf8,
+0xe6,0x12,0x66,0x7f,0xf9,0xe4,0x35,0x2a,0xfa,0x12,0x29,0xe6,0xe0,0xb1,0xec,0xef,
+0x12,0x1, 0xc5,0x90,0xa, 0xe9,0xe0,0xb1,0xde,0xef,0x12,0x1, 0xc5,0x5, 0x2c,0xe5,
+0x2c,0x64,0x1c,0x70,0x8f,0x12,0xf, 0xba,0x90,0x0, 0x70,0xe4,0x12,0x1, 0xd7,0x90,
+0x0, 0x71,0x74,0x7, 0x12,0x1, 0xd7,0x90,0x0, 0x72,0x74,0x17,0x12,0x1, 0xd7,0x90,
+0x0, 0x73,0x74,0x2, 0x12,0x1, 0xd7,0x90,0x0, 0x74,0x74,0x7f,0x12,0x1, 0xd7,0xe4,
+0xfd,0x12,0x29,0xf2,0x12,0xf, 0xba,0x7d,0x1, 0x12,0x29,0xf2,0x12,0xf, 0xba,0x90,
+0x0, 0x7b,0x74,0xf, 0x12,0x1, 0xd7,0x90,0x0, 0x7c,0x74,0x21,0x12,0x66,0x97,0xff,
+0x90,0x0, 0x7d,0x12,0x1, 0xd7,0x90,0x0, 0x7e,0xef,0x12,0x1, 0xd7,0x90,0x0, 0x7f,
+0xef,0x12,0x2f,0x4b,0x74,0x5d,0x2, 0x1, 0xd7,0x12,0x1, 0x4c,0xfd,0x12,0x0, 0x1e,
+0x5, 0x2c,0xe5,0x2c,0xc3,0x22,0x75,0x49,0x1, 0x75,0x4a,0x0, 0x75,0x4b,0x83,0x7b,
+0x1, 0x7a,0x0, 0x79,0x0, 0x22,0x75,0xf, 0x4, 0x75,0x10,0x3, 0x12,0x64,0x1a,0xa3,
+0x74,0x5a,0xf0,0x12,0x37,0xec,0x12,0x30,0x0, 0xd1,0xff,0x12,0x28,0x4b,0x7b,0x1,
+0x7a,0x8, 0x79,0x29,0x12,0xe, 0xbf,0x12,0x65,0xf6,0x91,0xbb,0x12,0x45,0xc, 0x90,
+0x0, 0x1, 0xe0,0x90,0xc, 0x96,0xf0,0x90,0x0, 0x0, 0xe0,0x90,0xc, 0x95,0xf0,0x12,
+0x46,0xe7,0xe4,0x90,0x0, 0x52,0xf0,0xa3,0x12,0x65,0xec,0x90,0xc, 0x93,0x74,0x3,
+0xf0,0x12,0x46,0xe7,0x90,0xc, 0x92,0xe0,0x70,0x2d,0x12,0x0, 0x4e,0x90,0xc, 0x92,
+0x74,0x1, 0xf0,0x7f,0x0, 0x7e,0x7c,0x12,0x53,0x20,0x12,0x64,0x61,0x75,0x27,0x4,
+0xd1,0xff,0x12,0x43,0x43,0xe4,0xfd,0xff,0xfe,0x12,0x44,0xcf,0x7f,0x4, 0x12,0x35,
+0x74,0x90,0xc, 0x92,0x74,0xff,0xf0,0x90,0xc, 0x93,0xe0,0x64,0x3, 0x70,0x48,0x90,
+0xc, 0x6c,0xe0,0xff,0xc4,0x13,0x13,0x13,0x54,0x1, 0x30,0xe0,0xb4,0xd1,0xff,0x12,
+0x28,0x4b,0x12,0x47,0x5b,0x91,0xb2,0x12,0x45,0xc, 0x90,0xc, 0x9b,0xe0,0x90,0x0,
+0x52,0x70,0x3, 0xf0,0x80,0x3, 0x74,0x1, 0xf0,0xe4,0x90,0x0, 0x53,0xf0,0x12,0x65,
+0xf6,0xd1,0xf6,0x12,0x45,0xe2,0x60,0xf9,0x75,0xf, 0x4, 0x75,0x10,0x3, 0x90,0xc,
+0x6c,0xe0,0x54,0x7f,0xf0,0xe1,0x51,0x90,0xc, 0x93,0xe0,0x90,0xc, 0x18,0xf0,0xe4,
+0xff,0xfd,0xfc,0xe5,0xdb,0x20,0xe1,0xf, 0xf, 0xbf,0xff,0x5, 0xd, 0xbd,0x0, 0x1,
+0xc, 0xbc,0x3, 0xef,0xbd,0xe8,0xec,0x53,0xdb,0xfe,0x53,0xdb,0xfd,0xc2,0xba,0x22,
+0x12,0x46,0xe7,0x12,0x64,0x1a,0xa3,0x74,0x5a,0xf0,0x12,0x26,0xff,0x11,0x4b,0x12,
+0x24,0xb2,0x53,0xdb,0xf0,0x12,0x45,0xc, 0x90,0xb, 0x58,0x74,0x1, 0xf0,0x74,0x2c,
+0x11,0x3c,0x12,0x64,0x57,0x75,0x2b,0x8, 0x75,0x2c,0x29,0x12,0xf, 0xfe,0x12,0x27,
+0xdf,0x12,0x37,0x44,0x90,0xc, 0x6c,0xe0,0x54,0x8f,0xf0,0x22,0xa3,0xf0,0x75,0x24,
+0x1, 0x75,0x25,0x0, 0x75,0x26,0x0, 0x75,0x27,0x1, 0x22,0x12,0xf, 0xcd,0x75,0x47,
+0xff,0xe4,0xf5,0x48,0x75,0x49,0xff,0xf5,0x4a,0xf5,0x58,0x75,0x59,0x0, 0x75,0x5a,
+0x4b,0xf1,0xf1,0x12,0xf, 0xba,0x90,0x0, 0x52,0xe4,0x12,0x65,0x33,0x74,0x1, 0x12,
+0x66,0x97,0x90,0x0, 0x54,0x12,0x1, 0xd7,0x90,0xa, 0xe5,0xe0,0x12,0x1, 0xc5,0x90,
+0xa, 0xe6,0x12,0xf, 0xb9,0x12,0x4a,0xa3,0xe4,0xf5,0x2c,0x12,0xf, 0xba,0x12,0x1,
+0x4c,0xff,0xe5,0x2c,0xc3,0x9f,0x50,0x31,0x12,0x64,0x77,0xe0,0xff,0xe9,0x24,0x31,
+0xf9,0xe4,0x3a,0xfa,0xe5,0x2c,0xfd,0x12,0x25,0xec,0x31,0xe2,0xe0,0xff,0xab,0x29,
+0xe5,0x2b,0x24,0x4, 0xf9,0xe4,0x35,0x2a,0xfa,0xe9,0x2d,0xf9,0xec,0x3a,0xfa,0x31,
+0xe2,0xe0,0xff,0x74,0x2e,0x31,0xc3,0x80,0xc2,0xe4,0xf5,0x2c,0x90,0x0, 0x1, 0x12,
+0x62,0x86,0xff,0xe5,0x2c,0xc3,0x9f,0x50,0x17,0x31,0xcb,0xe9,0x24,0x20,0xf9,0xe4,
+0x3a,0x12,0x25,0xe9,0xef,0x12,0x1, 0xc5,0x31,0xcb,0x74,0x3d,0x31,0xc3,0x80,0xdc,
+0xe4,0xf5,0x2c,0x90,0xa, 0xe6,0xe0,0xff,0xe5,0x2c,0xc3,0x9f,0x50,0x3e,0xe4,0xf5,
+0x2d,0x90,0xa, 0xe6,0xe0,0xff,0xe5,0x2d,0xc3,0x9f,0x50,0x15,0x74,0x3d,0x25,0x2d,
+0xf8,0xe6,0xff,0xc3,0x95,0x49,0x50,0x5, 0x8f,0x49,0x85,0x2d,0x4a,0x5, 0x2d,0x80,
+0xe0,0x74,0x3d,0x25,0x4a,0xf8,0x76,0xff,0x75,0x49,0xff,0xab,0x29,0xe5,0x2b,0x24,
+0x72,0x31,0xd3,0xe5,0x4a,0x12,0x1, 0xc5,0x5, 0x2c,0x80,0xb7,0xe4,0xf5,0x2c,0x90,
+0xa, 0xe5,0xe0,0xff,0xe5,0x2c,0xc3,0x9f,0x50,0x3e,0xe4,0xf5,0x2d,0x90,0xa, 0xe5,
+0xe0,0xff,0xe5,0x2d,0xc3,0x9f,0x50,0x15,0x74,0x2e,0x25,0x2d,0xf8,0xe6,0xff,0xc3,
+0x95,0x47,0x50,0x5, 0x8f,0x47,0x85,0x2d,0x48,0x5, 0x2d,0x80,0xe0,0x74,0x2e,0x25,
+0x48,0xf8,0x76,0xff,0x75,0x47,0xff,0xab,0x29,0xe5,0x2b,0x24,0x56,0x31,0xd3,0xe5,
+0x48,0x12,0x1, 0xc5,0x5, 0x2c,0x80,0xb7,0x90,0xa, 0xe8,0x12,0xf, 0xb9,0x90,0x0,
+0x30,0x12,0x1, 0xd7,0x90,0x0, 0x31,0x12,0x1, 0x65,0x90,0x0, 0x51,0x12,0xf, 0xdc,
+0x90,0x0, 0x4d,0x12,0xf, 0xd4,0xff,0x90,0x0, 0x4e,0x12,0x1, 0xd7,0x90,0x0, 0x4f,
+0xef,0x12,0x1, 0xd7,0x90,0x0, 0x50,0xef,0x12,0x1, 0xd7,0x90,0x0, 0x82,0x74,0x1,
+0x2, 0x1, 0xd7,0x25,0x2c,0xf8,0xa6,0x7, 0x5, 0x2c,0x22,0x74,0x4b,0x25,0x2c,0xf8,
+0xe6,0xff,0x22,0xf9,0xe4,0x35,0x2a,0xfa,0x7e,0x0, 0xe9,0x25,0x2c,0xf9,0xee,0x3a,
+0xfa,0x22,0xef,0x12,0x1, 0xc5,0x74,0xf5,0x25,0x2c,0xf5,0x82,0xe4,0x34,0xa, 0xf5,
+0x83,0x22,0x8b,0x49,0x8a,0x4a,0x89,0x4b,0x8d,0x4c,0x90,0xa, 0x36,0x12,0x4, 0xfe,
+0x0, 0x0, 0x0, 0x0, 0x90,0xa, 0x3a,0x12,0x4, 0xfe,0x0, 0x0, 0x0, 0x1, 0x75,0x58,
+0x1, 0x75,0x59,0xa, 0x75,0x5a,0x42,0xf1,0xf1,0x90,0xa, 0xe5,0xe0,0xf5,0x4e,0xa3,
+0xe0,0xf5,0x4d,0xe5,0x4c,0x70,0x39,0xf5,0x4f,0xe5,0x4f,0xc3,0x95,0x4e,0x50,0x1d,
+0x51,0xc6,0xc0,0x0, 0xc0,0x1, 0xa3,0x71,0x2, 0x74,0xf5,0x25,0x4f,0x31,0xea,0xe0,
+0xf9,0xf8,0x12,0x4, 0xdf,0xd0,0x1, 0xd0,0x0, 0x51,0xd5,0x80,0xdc,0xe4,0xf5,0x4f,
+0x51,0xea,0x78,0x8, 0x12,0x4, 0xcc,0x51,0xe1,0xe5,0x4f,0xb4,0x4, 0xf2,0x80,0x3d,
+0xe4,0xf5,0x4f,0xe5,0x4f,0xc3,0x95,0x4d,0x50,0x22,0x51,0xc6,0xc0,0x0, 0xc0,0x1,
+0xa3,0x71,0x2, 0x74,0x42,0x25,0x4f,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0xe0,0xf9,
+0xf8,0x12,0x4, 0xdf,0xd0,0x1, 0xd0,0x0, 0x51,0xd5,0x80,0xd7,0xe4,0xf5,0x4f,0x51,
+0xea,0x78,0x8, 0x12,0x4, 0xcc,0x51,0xe1,0xe5,0x4f,0xb4,0x2, 0xf2,0xe5,0x4c,0x70,
+0x12,0xf5,0x4f,0x12,0x64,0x25,0x24,0x75,0xf1,0x59,0x12,0x25,0xec,0xf1,0xb0,0xb4,
+0x4, 0xf1,0x22,0xe4,0xf5,0x4f,0x12,0x64,0x25,0x24,0x79,0xf1,0x59,0x12,0x25,0xec,
+0xf1,0xb0,0xb4,0x2, 0xf1,0x22,0x90,0xa, 0x36,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
+0xfa,0xa3,0xe0,0xfb,0x22,0xeb,0x4f,0xff,0xea,0x4e,0xfe,0xe9,0x4d,0xfd,0xe8,0x4c,
+0xfc,0x90,0xa, 0x36,0x12,0x4, 0xf2,0x5, 0x4f,0x22,0x90,0xa, 0x36,0xa3,0xa3,0xa3,
+0xe0,0xff,0x74,0x3e,0x25,0x4f,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0xef,0xf0,0x90,
+0xa, 0x36,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x22,0x8b,0x30,
+0x8a,0x31,0x89,0x32,0x12,0x4c,0x59,0xf5,0x42,0x12,0x4d,0x67,0xf5,0x43,0xe5,0x42,
+0xd3,0x94,0x0, 0x50,0x8, 0xe5,0x43,0x94,0x0, 0x50,0x2, 0xa1,0xc2,0xf1,0xc3,0x74,
+0x1, 0x12,0x1, 0x92,0x90,0x0, 0x82,0x12,0x1, 0x65,0x64,0x5, 0x60,0x2, 0xa1,0xcb,
+0xf1,0xc3,0xf1,0x4b,0x12,0x1, 0x65,0x60,0x2, 0x81,0x20,0x90,0x0, 0x81,0x12,0x4f,
+0x81,0x60,0x2, 0x81,0x20,0x90,0x0, 0x83,0xf1,0x4b,0xe5,0x42,0x12,0x1, 0xd7,0x90,
+0x0, 0x81,0xe5,0x43,0x12,0x1, 0xd7,0xe4,0xf5,0x3c,0xe5,0x42,0x25,0x43,0xff,0xe4,
+0x33,0xfe,0xc3,0xe5,0x3c,0xf1,0x90,0x98,0x40,0x2, 0xa1,0xcb,0xe5,0x3c,0xc3,0x95,
+0x42,0x50,0x29,0xe5,0x32,0x24,0x30,0xf9,0xe4,0x35,0x31,0xd1,0x0, 0xb1,0xe7,0xab,
+0x30,0xaa,0x31,0xa9,0x32,0x75,0xf0,0x2, 0xe5,0x3c,0x12,0x15,0x98,0xf1,0x9f,0xe5,
+0x3c,0x75,0xf0,0x2, 0xd1,0x6, 0xfa,0x90,0x0, 0x1, 0x80,0x3c,0xab,0x30,0xe5,0x32,
+0x24,0x58,0xf9,0xe4,0x35,0x31,0xfa,0xc3,0xe5,0x3c,0x95,0x42,0xfd,0xe4,0x94,0x0,
+0xfc,0xed,0xae,0x4, 0x78,0x3, 0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0x29,0xf9,0xea,
+0x3e,0xb1,0xe7,0x12,0x3f,0xaf,0xab,0x30,0xe5,0x32,0x2f,0xf9,0xe5,0x31,0x3e,0xfa,
+0x90,0x0, 0x87,0xf1,0x9f,0x90,0x0, 0x88,0x12,0x1, 0x65,0xc3,0x13,0xf5,0x40,0xb1,
+0xd3,0xa3,0xe5,0x41,0xf0,0xb1,0xd3,0xe5,0x40,0xf0,0xb1,0xdb,0x74,0x1, 0xf0,0xab,
+0x33,0xaa,0x34,0xa9,0x35,0xe5,0x41,0xf1,0xa7,0xe5,0x40,0x12,0x65,0xa0,0x12,0x2,
+0xb7,0xff,0xb1,0xd3,0xa3,0xa3,0xe5,0xf0,0xf0,0xa3,0xef,0xf0,0x5, 0x3c,0x61,0x6a,
+0x90,0x0, 0x81,0xb1,0xf1,0xff,0x90,0x0, 0x80,0x12,0x1, 0x65,0x2f,0xf5,0x3d,0xe4,
+0xf5,0x3c,0xf1,0x74,0x98,0x40,0x2, 0xa1,0x6e,0xe5,0x3c,0xc3,0x9d,0x50,0x4, 0xb1,
+0xfa,0x80,0x11,0xb1,0xee,0xf1,0xcd,0xef,0x78,0x3, 0xc3,0x33,0xce,0x33,0xce,0xd8,
+0xf9,0x12,0x64,0xe5,0xb1,0xe7,0xf1,0xd8,0xb1,0xd2,0xa3,0xe0,0x75,0xf0,0x20,0xb1,
+0xcc,0xe0,0x12,0x15,0x95,0x12,0x2, 0xb7,0xf5,0x3f,0x85,0xf0,0x3e,0xb1,0xdb,0xe0,
+0x70,0x4, 0x15,0x3d,0xa1,0x6a,0xe4,0xf5,0x47,0xf5,0x46,0xf1,0x52,0x12,0x1, 0x4c,
+0xff,0xe5,0x46,0xc3,0x9f,0x40,0x2, 0xa1,0x20,0xb1,0xd3,0xa3,0xe0,0xff,0x65,0x46,
+0x70,0x2, 0xa1,0x1c,0xf1,0xd8,0xfa,0x75,0xf0,0x20,0xef,0xb1,0xcc,0xe0,0x12,0x15,
+0x95,0x12,0x1b,0xf6,0xb1,0xd3,0xa3,0xe0,0x75,0xf0,0x10,0xa4,0xff,0xb1,0xd3,0xe0,
+0x2f,0x12,0x43,0x2b,0xf1,0xea,0x33,0xaa,0x34,0xa9,0x35,0xf1,0xbc,0x2d,0xfd,0xec,
+0x35,0xf0,0xfc,0xc0,0x4, 0xc0,0x5, 0xe5,0x46,0xf1,0xa7,0xc0,0x83,0xc0,0x82,0xb1,
+0xd3,0xe0,0xff,0xd0,0x82,0xd0,0x83,0x12,0x41,0xf, 0x12,0x1b,0xf6,0xef,0xfb,0x7a,
+0x0, 0xe5,0x46,0x75,0xf0,0x10,0xa4,0x2b,0xff,0xea,0x35,0xf0,0xf1,0xea,0x33,0xab,
+0x33,0xaa,0x34,0xf1,0xbc,0x12,0x65,0xc4,0xc3,0xd0,0xe0,0x9f,0xff,0xd0,0xe0,0x9e,
+0xfe,0xb1,0xee,0xfd,0xe5,0x3c,0xc3,0x9d,0x50,0x12,0xd1,0x10,0x12,0x2, 0x8c,0xfd,
+0xd3,0xef,0x9d,0xe5,0xf0,0x12,0x43,0x3b,0x40,0x2, 0x5, 0x47,0x5, 0x46,0x81,0x7b,
+0xf1,0x52,0x12,0x1, 0x4c,0xc3,0x13,0xff,0xe5,0x47,0xc3,0x9f,0x40,0xe, 0x90,0x7,
+0x9d,0x12,0x4f,0x8a,0x64,0x6, 0x60,0x4, 0xb1,0xdb,0xe4,0xf0,0xb1,0xd3,0xa3,0x71,
+0x7, 0xc3,0xe5,0x3f,0x9f,0xff,0xe5,0x3e,0x9e,0xfe,0x12,0x0, 0x6, 0x8e,0x3e,0x8f,
+0x3f,0xd1,0x10,0x90,0x0, 0x20,0x12,0x1, 0x65,0xff,0xd3,0xe5,0x3f,0x9f,0x74,0x80,
+0xf8,0x65,0x3e,0x98,0x40,0x4, 0xb1,0xdb,0xe4,0xf0,0x5, 0x3c,0x81,0x32,0xe5,0x3d,
+0x70,0xb, 0xab,0x30,0xaa,0x31,0xa9,0x32,0x90,0x0, 0x80,0x80,0x4b,0xf1,0x6a,0x12,
+0x1, 0x65,0xc3,0x94,0x4, 0x40,0x34,0xe4,0xf5,0x3c,0xf1,0x74,0x98,0x50,0x3c,0xe5,
+0x3c,0xc3,0x9d,0x50,0x4, 0xb1,0xfa,0x80,0x11,0xb1,0xee,0xf1,0xcd,0xef,0x78,0x3,
+0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0x12,0x64,0xe5,0xb1,0xe7,0xb1,0xdb,0xe0,0xb4,
+0x1, 0x5, 0xb1,0xdb,0x74,0x2, 0xf0,0x5, 0x3c,0x80,0xcf,0xf1,0x6a,0x74,0x1, 0x2,
+0x1, 0x92,0xf1,0x6a,0xe4,0xf1,0x4b,0xe4,0x12,0x4f,0x93,0x22,0xa4,0x29,0xf9,0xe5,
+0xf0,0x3a,0xfa,0x85,0x45,0x82,0x85,0x44,0x83,0xa3,0x22,0xe5,0x45,0x24,0x7, 0xf5,
+0x82,0xe4,0x35,0x44,0xf5,0x83,0x22,0xaf,0x1, 0xf5,0x44,0x8f,0x45,0x22,0x90,0x0,
+0x80,0xab,0x30,0xaa,0x31,0xa9,0x32,0x2, 0x1, 0x65,0xe9,0x24,0x30,0xf9,0xe4,0x3a,
+0xfa,0xe5,0x3c,0x75,0xf0,0x8, 0xa4,0x29,0xf9,0xea,0x35,0xf0,0x22,0xfd,0xd1,0x74,
+0xab,0x36,0xaa,0x37,0xa9,0x38,0x22,0x8b,0x36,0x8a,0x37,0x89,0x38,0x90,0x0, 0x19,
+0x12,0x1, 0x65,0x7f,0x6, 0xd1,0xd, 0x90,0x0, 0x1a,0x12,0x1, 0x65,0xfd,0x7f,0xa,
+0xd1,0xe, 0x90,0x0, 0x20,0x12,0x1, 0x65,0xfd,0x7f,0x8, 0xd1,0xe, 0x90,0x0, 0x1c,
+0x12,0x1, 0x65,0xfd,0x7f,0xc, 0xd1,0xe, 0x90,0x0, 0x1d,0x12,0x1, 0x65,0xfd,0x7f,
+0x2a,0xd1,0x74,0x12,0x4f,0x75,0xfd,0x7f,0x2e,0xd1,0x74,0xe4,0xfd,0x7f,0x1c,0xd1,
+0xe, 0x90,0x0, 0x21,0x12,0x1, 0x65,0x7f,0x2, 0xd1,0xd, 0x90,0x0, 0x22,0x12,0x1,
+0x65,0xfd,0x7f,0x4, 0xf1,0x98,0xef,0x44,0x40,0xf5,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,
+0x53,0xdb,0xf3,0x8d,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,0x53,0xdb,0xf3,0x43,0xab,0x4,
+0x22,0x8b,0x36,0x8a,0x37,0x89,0x38,0xe4,0xf5,0x3c,0xd1,0x10,0xf1,0x61,0xfd,0xe4,
+0xff,0x12,0x61,0x2c,0x8e,0x3d,0x8f,0x3e,0xe5,0x3c,0x70,0x3, 0x43,0x3d,0x20,0xf1,
+0x3e,0x94,0x10,0x40,0xe5,0x75,0x3c,0x10,0xe4,0xfd,0x7f,0xc0,0xf1,0x43,0x94,0x20,
+0x40,0xf6,0xe4,0xf5,0x3c,0xf1,0x52,0xf1,0x61,0xfe,0x54,0xf, 0xff,0xee,0xc4,0x54,
+0xf, 0xfd,0x12,0x61,0x38,0x8e,0x3d,0x8f,0x3e,0xf1,0x3e,0x94,0x8, 0x40,0xe6,0x75,
+0x3c,0x8, 0xe4,0xfd,0x7f,0xc0,0xf1,0x43,0x94,0x20,0x40,0xf6,0xe4,0xf5,0x3c,0x75,
+0xf0,0x2, 0xe5,0x3c,0xa4,0x24,0x54,0xf5,0x82,0xe5,0xf0,0x34,0xc, 0xf5,0x83,0xe4,
+0x93,0xf5,0x3d,0x74,0x1, 0x93,0xf5,0x3e,0xf1,0x3e,0x94,0xff,0x40,0xe1,0x90,0xe,
+0x52,0xe4,0x93,0xfc,0x74,0x1, 0x93,0xfd,0xec,0xff,0xf1,0x98,0x8f,0xa1,0xe5,0xdb,
+0x30,0xe3,0xfb,0x85,0xa1,0x11,0x53,0xdb,0xf3,0x8d,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,
+0x85,0xa1,0x12,0x53,0xdb,0xf3,0x43,0xab,0x4, 0xae,0x11,0xaf,0x12,0x22,0xe5,0x3d,
+0xff,0xad,0x3e,0xf1,0x1a,0x5, 0x3c,0xe5,0x3c,0xc3,0x22,0x12,0x1, 0xd7,0x90,0x0,
+0x80,0x22,0xab,0x39,0xaa,0x3a,0xa9,0x3b,0x22,0xf9,0xe4,0x35,0x4a,0xfa,0xe5,0x4f,
+0x22,0x85,0x3c,0x82,0x75,0x83,0x0, 0x2, 0x1, 0x65,0xab,0x30,0xaa,0x31,0xa9,0x32,
+0x90,0x0, 0x83,0x22,0xab,0x30,0xaa,0x31,0xa9,0x32,0x90,0x0, 0x81,0x12,0x1, 0x65,
+0xff,0x90,0x0, 0x80,0x12,0x1, 0x65,0xfd,0x2f,0xff,0xe4,0x33,0xfe,0xe5,0x3c,0xc3,
+0x9f,0xee,0x64,0x80,0xf8,0x74,0x80,0x22,0x53,0xab,0x3, 0x53,0xdb,0xf3,0x22,0x12,
+0x1, 0x65,0xc3,0x13,0xf5,0x41,0x22,0x90,0x3, 0x80,0x75,0xf0,0x20,0x2, 0x5, 0x40,
+0xef,0x12,0x1, 0xc5,0x5, 0x4f,0xe5,0x4f,0x22,0x33,0xaa,0x22,0x8f,0x82,0xf5,0x83,
+0x2, 0x2, 0xb7,0xab,0x30,0xaa,0x31,0xa9,0x32,0x90,0x0, 0x82,0x22,0xff,0xc3,0xe5,
+0x3c,0x9f,0xff,0xe4,0x94,0x0, 0xfe,0x22,0xab,0x33,0xe5,0x35,0x24,0x80,0xf9,0xe5,
+0x34,0x34,0x3, 0x22,0xaf,0x3c,0xef,0x33,0x95,0xe0,0xfe,0xef,0x25,0xe0,0xff,0xee,
+0x22,0x75,0x5b,0xa, 0x75,0x5c,0x77,0x7b,0xff,0x7a,0x7, 0x79,0x5, 0x2, 0xa, 0x57,
+0xe4,0x90,0xc, 0x9c,0xf0,0x90,0xc, 0x6f,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,
+0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x0, 0xc0,0x0, 0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 0xc0,
+0x4, 0xc0,0x5, 0xc0,0x6, 0xc0,0x7, 0x11,0xf9,0x90,0xb, 0xf0,0xe0,0x60,0x2, 0x14,
+0xf0,0x90,0xa, 0xdf,0xe0,0x4, 0xf0,0x70,0x6, 0x90,0xa, 0xde,0xe0,0x4, 0xf0,0x90,
+0xa, 0xd8,0xe0,0xfe,0xa3,0xe0,0xff,0xc3,0x90,0xa, 0xdf,0xe0,0x9f,0x90,0xa, 0xde,
+0xe0,0x9e,0x50,0x3, 0x12,0x0, 0x4e,0x90,0xa, 0xe3,0xe0,0xfe,0xa3,0xe0,0xff,0x4e,
+0x60,0x16,0xef,0x64,0x1, 0x4e,0x70,0x2, 0xd2,0x0, 0x90,0xa, 0xe4,0xe0,0x24,0xff,
+0xf0,0x90,0xa, 0xe3,0xe0,0x34,0xff,0xf0,0x12,0x64,0x7, 0x12,0x4, 0xa5,0x40,0xe,
+0x90,0xa, 0xdc,0xe0,0x4, 0xf0,0x70,0x6, 0x90,0xa, 0xdb,0xe0,0x4, 0xf0,0x90,0xc,
+0x18,0xe0,0xb4,0xaa,0xf, 0x90,0xa, 0xda,0xe0,0xff,0x4, 0xf0,0xef,0xd3,0x94,0x64,
+0x40,0x2, 0xf1,0x44,0xe5,0xd, 0xc3,0x95,0xe, 0x50,0x12,0x5, 0xd, 0xe5,0xc9,0x54,
+0x3, 0xff,0xbf,0x1, 0xb, 0x74,0x3, 0x25,0xd, 0xf5,0xd, 0x80,0x3, 0x75,0xc, 0x1,
+0x90,0xc, 0x68,0xe0,0xff,0x60,0xe, 0xc3,0x94,0x28,0x50,0x5, 0xe0,0x4, 0xf0,0x80,
+0x4, 0x31,0x4, 0x11,0x0, 0xd0,0x7, 0xd0,0x6, 0xd0,0x5, 0xd0,0x4, 0xd0,0x3, 0xd0,
+0x2, 0xd0,0x1, 0xd0,0x0, 0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,
+0xe5,0x92,0x60,0x4, 0xd2,0xae,0xd2,0xbe,0x22,0xc2,0x8e,0x75,0xa6,0xf0,0x75,0xa5,
+0x5f,0xd2,0x8e,0x22,0xe4,0x90,0xc, 0x6b,0xf0,0x90,0xc, 0x67,0x51,0x74,0x70,0x5,
+0xa3,0x51,0x7d,0x80,0x9, 0x51,0x75,0xff,0xbf,0x4, 0x3, 0xa3,0x51,0x84,0xe4,0x90,
+0xc, 0x69,0xf0,0x90,0xc, 0x68,0xf0,0x90,0xc, 0x33,0x74,0xaa,0xf0,0xa3,0xf0,0x90,
+0xc, 0x4d,0xf0,0xa3,0xf0,0x22,0x71,0xc1,0xff,0xc3,0x94,0x80,0x40,0x10,0xef,0xd3,
+0x94,0xbf,0x50,0xa, 0x74,0x71,0x2f,0xf5,0x82,0xe4,0x34,0xb, 0x21,0xe7,0xa8,0x16,
+0xe6,0x24,0x4, 0x60,0xb, 0x24,0xfc,0x70,0xe, 0x90,0xc, 0x6c,0xe0,0xff,0x21,0xef,
+0x90,0xc, 0x18,0xe0,0xff,0x21,0xef,0x30,0x1, 0x8, 0x75,0xa, 0xc, 0x75,0xb, 0x33,
+0x80,0x6, 0x75,0xa, 0xc, 0x75,0xb, 0x4d,0xa8,0x16,0xe6,0xfe,0x24,0xfe,0x60,0x2b,
+0x24,0xfb,0x50,0x34,0x24,0xfe,0x24,0xfc,0x50,0x38,0x24,0xfe,0x24,0xfc,0x50,0x3e,
+0x24,0xfe,0x24,0xfc,0x50,0x41,0x24,0xfe,0x24,0xfc,0x50,0x44,0x24,0x1e,0x70,0x4d,
+0xe5,0xb, 0x24,0x4, 0xf5,0x82,0xe4,0x35,0xa, 0x80,0x3c,0x85,0xb, 0x82,0x85,0xa,
+0x83,0xa3,0xa3,0xa3,0xe0,0xff,0x80,0x37,0xee,0x24,0x2, 0xff,0xe4,0x33,0x31,0xf6,
+0x80,0x25,0xa8,0x16,0xe6,0x25,0xb, 0xf5,0x82,0xe4,0x35,0xa, 0x80,0x19,0xa8,0x16,
+0xe6,0x24,0xfe,0x31,0xf2,0x80,0x10,0xa8,0x16,0xe6,0x24,0xfc,0x31,0xf2,0x80,0x7,
+0xa8,0x16,0xe6,0x24,0xfa,0x31,0xf2,0xf5,0x83,0xe0,0xff,0x80,0x2, 0x7f,0x0, 0x5,
+0x16,0x22,0xff,0xe4,0x34,0xff,0xfe,0xe5,0xb, 0x2f,0xf5,0x82,0xe5,0xa, 0x3e,0x22,
+0x30,0x95,0x54,0x90,0xc, 0x69,0xe0,0x4, 0xf0,0xe0,0xff,0xb4,0x1, 0x8, 0x90,0xc,
+0x6d,0xe5,0x95,0xf0,0x80,0x29,0x90,0xc, 0x6c,0xe0,0xfe,0xc4,0x54,0x7, 0x70,0xc,
+0xa3,0xe0,0x2f,0x24,0xfe,0xff,0xad,0x95,0xd1,0xe4,0x80,0x13,0x51,0x75,0xff,0xbf,
+0x4, 0xd, 0x90,0xc, 0x69,0x71,0xb9,0x24,0xfe,0xff,0xad,0x95,0x12,0x50,0x4c,0x51,
+0x75,0xfd,0x70,0xb, 0x71,0xaf,0x60,0xf, 0x90,0xc, 0x6d,0x51,0x7d,0x80,0x8, 0xbd,
+0x4, 0x5, 0x90,0xc, 0x6d,0x51,0x84,0x30,0x94,0x19,0x90,0xc, 0x67,0xe0,0x4, 0x51,
+0x74,0xfd,0x70,0x8, 0x71,0xaf,0x60,0xb, 0x71,0xb6,0x80,0x12,0xbd,0x4, 0x4, 0x71,
+0xb6,0x51,0x85,0x22,0xf0,0x90,0xc, 0x6c,0xe0,0xc4,0x54,0x7, 0x22,0xe0,0xff,0x31,
+0x36,0x8f,0x95,0x22,0xe0,0xff,0x51,0x8b,0x8f,0x95,0x22,0x71,0xc1,0xfe,0x12,0x5,
+0x9c,0x32,0xb6,0x0, 0x32,0xbd,0x1, 0x32,0xc4,0x2, 0x32,0xc8,0x3, 0x32,0xcf,0x4,
+0x32,0xd6,0x5, 0x32,0xdd,0x6, 0x32,0xe4,0x7, 0x32,0xeb,0x4c,0x32,0xf9,0x4e,0x32,
+0xf2,0xea,0x0, 0x0, 0x33,0x0, 0x90,0xc, 0x6c,0xe0,0xff,0x61,0xac,0x90,0xc, 0x6a,
+0xe0,0xff,0x61,0xac,0x7f,0xff,0x61,0xac,0x90,0xa, 0xe5,0xe0,0xff,0x61,0xac,0x90,
+0xa, 0xe6,0xe0,0xff,0x61,0xac,0x90,0xa, 0xe7,0xe0,0xff,0x61,0xac,0x90,0xa, 0xe8,
+0xe0,0xff,0x61,0xac,0x90,0xa, 0xe9,0xe0,0xff,0x61,0xac,0x90,0xa, 0xf2,0xe0,0xff,
+0x61,0xac,0x90,0xc, 0x9b,0xe0,0xff,0x61,0xac,0x90,0xb, 0x57,0xe0,0xff,0x61,0xac,
+0xee,0xc3,0x94,0x10,0x40,0x1e,0xa8,0x16,0xe6,0xff,0x94,0x24,0x50,0x16,0xe5,0x9,
+0x2f,0xf5,0x82,0xe4,0x35,0x8, 0xf5,0x83,0xe5,0x82,0x24,0xf0,0xf5,0x82,0xe5,0x83,
+0x34,0xff,0x61,0xa4,0xa8,0x16,0xe6,0xff,0xc3,0x94,0x50,0x40,0x15,0xef,0xd3,0x94,
+0x77,0x50,0xf, 0x74,0xa5,0x2f,0x12,0x51,0xa2,0xe0,0xff,0x7d,0x77,0x12,0x0, 0x26,
+0x80,0x6a,0xa8,0x16,0xe6,0xff,0xc3,0x94,0x78,0x40,0x10,0xef,0xd3,0x94,0x9f,0x50,
+0xa, 0x74,0x99,0x2f,0xf5,0x82,0xe4,0x34,0xa, 0x80,0x49,0xa8,0x16,0xe6,0xff,0xc3,
+0x94,0xa0,0x40,0x10,0xef,0xd3,0x94,0xbe,0x50,0xa, 0x74,0x8d,0x2f,0xf5,0x82,0xe4,
+0x34,0xa, 0x80,0x30,0xa8,0x16,0xe6,0xff,0xc3,0x94,0xbf,0x40,0x10,0xef,0xd3,0x94,
+0xd2,0x50,0xa, 0x74,0x7e,0x2f,0xf5,0x82,0xe4,0x34,0xa, 0x80,0x17,0xa8,0x16,0xe6,
+0xff,0xc3,0x94,0xd3,0x40,0x14,0xef,0xd3,0x94,0xe1,0x50,0xe, 0x74,0x78,0x2f,0xf5,
+0x82,0xe4,0x34,0xa, 0xf5,0x83,0xe0,0xff,0x80,0x2, 0x7f,0xff,0x5, 0x16,0x22,0xff,
+0x31,0x36,0xef,0x64,0x10,0x22,0x90,0xc, 0x67,0xe0,0xff,0x90,0xc, 0x6d,0xe0,0x2f,
+0x22,0x15,0x16,0xa8,0x16,0xa6,0x7, 0xa8,0x16,0xe6,0x22,0xe4,0x90,0xc, 0x6c,0xf0,
+0x71,0xd4,0x21,0x4, 0x75,0x32,0x70,0x75,0x90,0x4, 0x7f,0x0, 0x7e,0x78,0x91,0x17,
+0x8f,0x33,0x7f,0x1, 0x7e,0x78,0x91,0x17,0xe5,0x33,0xf4,0x60,0xa, 0xe5,0x33,0x6f,
+0xff,0xbf,0xff,0x3, 0x85,0x33,0x32,0xe5,0x32,0xc3,0x13,0x54,0xf, 0xc4,0x54,0xf0,
+0xf5,0x93,0xd2,0xac,0x53,0xe8,0x3f,0x43,0xe8,0xc0,0xd2,0xec,0xd2,0xb9,0xc2,0xc1,
+0x43,0xb9,0x10,0x53,0xa9,0xef,0x22,0xe4,0xfd,0xab,0x7, 0xaa,0x6, 0xc2,0xaf,0x43,
+0xfc,0x3, 0xed,0xc4,0x54,0xf0,0xf5,0xf8,0x8a,0xf9,0x8b,0xfa,0x43,0xfc,0x3, 0x44,
+0xe0,0xf5,0xf8,0xaf,0xfb,0xf1,0x55,0xd2,0xaf,0x22,0x12,0x47,0x72,0x80,0xd8,0x75,
+0x40,0x0, 0x75,0x41,0x0, 0x75,0x42,0x2e,0x75,0x43,0xf, 0x75,0x44,0x77,0x7b,0xff,
+0x7a,0x6, 0x79,0xf6,0x12,0x8, 0x0, 0xe4,0xff,0xfe,0x91,0x3a,0x8f,0x2d,0x90,0xc,
+0x11,0xe0,0x70,0x3, 0x75,0x2d,0xff,0xe5,0x2d,0xf4,0x60,0x49,0x7f,0xf0,0x7e,0x3,
+0x91,0x3a,0x8f,0x29,0x7f,0xf1,0x7e,0x3, 0x91,0x3a,0x8f,0x2a,0xe5,0x29,0x45,0x2a,
+0xf4,0x60,0x3, 0x75,0x2d,0xff,0xe4,0xf5,0x2a,0xf5,0x2b,0xf5,0x2c,0xe5,0x2c,0x24,
+0x4, 0xff,0xe4,0x35,0x2b,0xfe,0x91,0x3a,0xef,0x62,0x2a,0x5, 0x2c,0xe5,0x2c,0x70,
+0x2, 0x5, 0x2b,0xc3,0x94,0xb, 0xe5,0x2b,0x94,0x1, 0x40,0xe1,0xe5,0x29,0x65,0x2a,
+0x60,0x3, 0x75,0x2d,0xff,0x90,0xa, 0xe5,0x74,0xf, 0xf0,0xa3,0x74,0xa, 0xf0,0xa3,
+0x74,0x2, 0xf0,0x90,0xb, 0x57,0x74,0x5, 0xf0,0xe4,0x90,0xa, 0xe8,0xf0,0xa3,0x74,
+0x3e,0xf0,0x90,0xa, 0xf3,0x12,0x66,0x9f,0x90,0xb, 0x58,0xf1,0x4b,0xe4,0xff,0x90,
+0xa, 0xe5,0xe0,0xfe,0xef,0xc3,0x9e,0x40,0xb, 0x74,0xf5,0x2f,0x12,0x29,0xea,0x74,
+0xff,0xf0,0x80,0xe, 0x74,0x2e,0x2f,0xf8,0xe6,0xfe,0x74,0xf5,0x2f,0x12,0x29,0xea,
+0xee,0xf0,0xef,0x90,0x7, 0xf, 0x93,0xfe,0x74,0x11,0x2f,0x12,0x64,0x7b,0xee,0xf0,
+0xf, 0xbf,0x1c,0xcb,0xe4,0xff,0xef,0x90,0x7, 0x3b,0x93,0xfe,0x74,0x3d,0x2f,0x12,
+0x64,0x6f,0xee,0xf0,0xf, 0xbf,0xe, 0xee,0xe4,0xff,0xef,0x90,0x7, 0x2b,0x93,0xfe,
+0x74,0x2d,0x2f,0x12,0xf, 0xe4,0xee,0xf0,0xf, 0xbf,0x10,0xee,0xe4,0xff,0xef,0x90,
+0x7, 0x49,0x93,0xfe,0x74,0x4b,0x2f,0x12,0xf, 0xc5,0xee,0xf0,0xf, 0xbf,0x8, 0xee,
+0xe4,0xf5,0x2b,0xf5,0x2c,0x74,0x5a,0x25,0x2c,0x12,0x47,0x8e,0x5, 0x2c,0xe5,0x2c,
+0x70,0x2, 0x5, 0x2b,0x64,0x96,0x45,0x2b,0x70,0xeb,0xe5,0x2d,0xf4,0x60,0x4, 0x7f,
+0x4, 0xb1,0x74,0x22,0x8f,0x3d,0x75,0x3e,0xb, 0x75,0x3f,0x4b,0xb1,0xd9,0xb1,0xb1,
+0x70,0x2, 0x5, 0x3e,0xb1,0xcd,0x70,0x2, 0x5, 0x40,0xc3,0x94,0x8, 0xe5,0x40,0x94,
+0x0, 0x40,0xeb,0x75,0x3e,0xb, 0x75,0x3f,0x5a,0xb1,0xd9,0xb1,0xb1,0x70,0x2, 0x5,
+0x3e,0xb1,0xcd,0x70,0x2, 0x5, 0x40,0xc3,0x94,0x96,0xe5,0x40,0x94,0x0, 0x40,0xeb,
+0x22,0xaf,0x3d,0x7e,0x0, 0xe5,0x41,0x25,0x3d,0xcf,0xee,0x35,0x40,0xcf,0x25,0x43,
+0xcf,0x35,0x42,0xfe,0x91,0x3a,0x5, 0x3f,0xe5,0x3f,0xac,0x3e,0x22,0x14,0xf5,0x82,
+0x8c,0x83,0xef,0xf0,0x5, 0x41,0xe5,0x41,0x22,0x75,0x42,0xa, 0x75,0x43,0xe5,0xc3,
+0xe5,0x3f,0x95,0x43,0xff,0xe5,0x3e,0x95,0x42,0xf5,0x42,0x8f,0x43,0xe4,0xf5,0x40,
+0xf5,0x41,0x22,0x12,0x46,0xe7,0xd1,0x71,0xf1,0x37,0x7f,0x1, 0x12,0x60,0xf7,0x71,
+0xcb,0x91,0x3f,0xf1,0x44,0x90,0xc, 0x18,0xe0,0x24,0xfd,0x60,0x14,0x14,0x60,0x16,
+0x24,0xaf,0x60,0x2e,0x24,0xab,0x60,0x13,0x24,0xa9,0x70,0xe9,0x12,0x21,0x89,0x80,
+0xe4,0x12,0x27,0x6, 0x80,0xdf,0x12,0x28,0x0, 0x80,0xda,0xd1,0x69,0x90,0xa, 0xe2,
+0xe0,0x64,0xaa,0x60,0xd0,0xe4,0x90,0xa, 0xda,0xf0,0x90,0xa, 0xe2,0x74,0xaa,0xf0,
+0x80,0xc3,0xd1,0x69,0x90,0xa, 0xe2,0xe0,0xb4,0xaa,0xba,0x74,0x55,0xf0,0x90,0xc,
+0xc8,0xf1,0x4b,0x90,0xc, 0xc8,0x74,0xff,0xf5,0xf0,0x12,0x2, 0x76,0x45,0xf0,0x70,
+0xf2,0x12,0x53,0x23,0x75,0xe9,0xff,0x80,0x9c,0xe4,0x90,0xa, 0xde,0xf0,0xa3,0xf0,
+0x22,0x2, 0x0, 0x19,0x8d,0x69,0xef,0xc3,0x94,0xa, 0x50,0xa, 0x74,0x92,0x2f,0xf5,
+0x82,0xe4,0x34,0xc, 0x80,0x4e,0xef,0x24,0xf6,0xf5,0x6a,0xc3,0x94,0xb, 0x74,0x80,
+0x94,0x81,0x50,0x45,0xe5,0x6a,0xb4,0x4f,0x1d,0x90,0xc, 0x6e,0xe0,0x60,0xb, 0x7f,
+0x1, 0x12,0x1d,0xa7,0xe4,0x90,0xc, 0x6e,0xf0,0x22,0xe4,0xff,0x12,0x1d,0xa7,0x90,
+0xc, 0x6e,0x74,0x1, 0xf0,0x22,0xe5,0x6a,0xc3,0x94,0x10,0x40,0x15,0xe5,0x6a,0xd3,
+0x94,0x1f,0x50,0xe, 0x7d,0x77,0xaf,0x69,0x12,0x6, 0xd3,0xd1,0xda,0xf5,0x83,0xef,
+0xf0,0x22,0xd1,0xda,0xf5,0x83,0xe5,0x69,0xf0,0x22,0x74,0xe5,0x25,0x6a,0xf5,0x82,
+0xe4,0x34,0xa, 0x22,0x8f,0x67,0x8d,0x68,0xe5,0x67,0xc3,0x94,0x80,0x40,0xe, 0xe5,
+0x67,0xd3,0x94,0xbf,0x50,0x7, 0xe5,0x67,0x24,0x80,0xff,0x80,0x36,0xe5,0x67,0x24,
+0x4, 0x60,0x2c,0x24,0xfc,0x70,0x2f,0x12,0x51,0xaa,0xf5,0x68,0xb4,0x4, 0xf, 0x90,
+0xc, 0x18,0xe0,0x7d,0x3, 0xb4,0x3, 0x2, 0x80,0xd, 0x7f,0x27,0x80,0x15,0x90,0xc,
+0x18,0xe0,0x7d,0x1, 0xb4,0x3, 0x4, 0x7f,0x1, 0xc1,0x74,0x7f,0x27,0x80,0x4, 0xad,
+0x68,0x7f,0x27,0x12,0x4f,0xa7,0x22,0x12,0x52,0x2e,0xc2,0x8e,0x43,0xa2,0x10,0x11,
+0xfb,0xd2,0xab,0x22,0x90,0xc, 0x18,0x74,0x1, 0xf0,0x22,0x74,0x3, 0xf0,0xa3,0x74,
+0xe8,0xf0,0x22,0xf1,0x97,0x43,0xfc,0x3, 0xe4,0xf5,0xf8,0x22,0xab,0x7, 0xaa,0x6,
+0xc2,0xaf,0xf1,0x55,0x8a,0xf9,0x8b,0xfa,0x8d,0xfb,0x43,0xfc,0x3, 0x75,0xf8,0x82,
+0x7f,0xa, 0xf1,0x97,0xd2,0xf8,0x7f,0x4, 0xf1,0x97,0xd2,0xfe,0x7f,0x26,0xf1,0x97,
+0xc2,0xfe,0xc2,0xf9,0x7f,0xc, 0xf1,0x97,0xc2,0xf8,0x7f,0x1, 0xf1,0x53,0xd2,0xaf,
+0x22,0x7f,0xfa,0xf1,0x97,0x7f,0xfa,0xae,0x7, 0x1f,0xee,0x60,0xf, 0x0, 0x0, 0x0,
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80,0xeb,0x22,0xad,0x7, 0xac,
+0x6, 0xc2,0xaf,0xf1,0x55,0x8c,0xf9,0x8d,0xfa,0x43,0xfc,0x3, 0x75,0xf8,0x88,0x7f,
+0x14,0xf1,0x97,0x75,0xf8,0x89,0x7f,0x2d,0xf1,0xd9,0xc2,0xfb,0x7f,0x14,0xf1,0x97,
+0xc2,0xf8,0x7f,0xa, 0xf1,0x53,0xd2,0xaf,0x22,0xad,0x7, 0xaf,0x5, 0x1d,0xef,0x60,
+0xa, 0xf1,0x91,0x7f,0xfa,0xf1,0x97,0xf1,0x91,0x80,0xf0,0x22,0x90,0xc, 0x93,0x74,
+0x3, 0xf0,0xe4,0x90,0xc, 0x9a,0xf0,0x90,0xc, 0x92,0x74,0xff,0xf0,0x90,0xc, 0x9b,
+0x74,0x1, 0xf0,0x22,0x74,0xff,0xf5,0xf0,0x12,0x3, 0x3c,0x90,0x0, 0x2, 0x74,0xff,
+0xf5,0xf0,0x12,0x3, 0x5b,0x90,0x0, 0x4, 0x74,0xff,0x2, 0x1, 0xd7,0x8b,0x32,0x8a,
+0x33,0x89,0x34,0xe4,0xf5,0x38,0xf5,0x39,0x12,0x64,0xa1,0x70,0x2, 0x5, 0x38,0x64,
+0x92,0x45,0x38,0x70,0xf3,0xab,0x35,0xaa,0x36,0xa9,0x37,0xe4,0xf5,0x38,0xf5,0x39,
+0x12,0x64,0xa1,0x70,0x2, 0x5, 0x38,0x64,0x53,0x45,0x38,0x70,0xf3,0xe4,0xf5,0x38,
+0xf5,0x39,0xab,0x32,0xe5,0x34,0x24,0xa, 0xf9,0xe4,0x35,0x33,0xfa,0xae,0x38,0xaf,
+0x39,0x7c,0x0, 0x7d,0x7, 0x11,0xc2,0x11,0xb2,0x24,0x3, 0x11,0xb9,0x11,0xb2,0x24,
+0x26,0x11,0xb9,0x11,0x4, 0x5, 0x39,0xe5,0x39,0x70,0x2, 0x5, 0x38,0xc3,0x94,0x5,
+0xe5,0x38,0x94,0x0, 0x40,0xcc,0xab,0x35,0xaa,0x36,0xa9,0x37,0x90,0x0, 0x51,0x74,
+0x1, 0x12,0x1, 0xd7,0xe4,0xf5,0xd, 0xf5,0xe, 0xf5,0xc, 0x12,0x46,0xe8,0xe4,0xa3,
+0xf0,0x90,0xa, 0xe2,0xf0,0xa3,0xf0,0xa3,0xf0,0xc2,0x0, 0x90,0xa, 0xdb,0xf0,0xa3,
+0xf0,0x22,0x11,0x4, 0xab,0x35,0xe5,0x37,0x22,0xf9,0xe4,0x35,0x36,0xfa,0xae,0x38,
+0xaf,0x39,0x12,0x1, 0xf9,0xe9,0x2f,0xf9,0xea,0x3e,0xfa,0x22,0x12,0x65,0xd1,0xe4,
+0xf5,0x2f,0xf5,0x30,0x12,0x15,0x6f,0xf5,0x31,0x70,0x42,0xf5,0x2d,0xe5,0x2d,0xfd,
+0x33,0x95,0xe0,0xfc,0xf1,0xaf,0x74,0xc9,0x2f,0xf5,0x82,0x74,0xa, 0x12,0x47,0x6a,
+0x90,0xa, 0xaa,0x75,0xf0,0x7, 0xed,0x12,0x5, 0x40,0xec,0x75,0xf0,0x7, 0xa4,0x25,
+0x83,0xf5,0x83,0x74,0xff,0xf0,0x71,0x4, 0xfe,0x74,0xd3,0x2f,0xf5,0x82,0x74,0xa,
+0x3e,0xf5,0x83,0x74,0x2, 0xf0,0x5, 0x2d,0xe5,0x2d,0xb4,0x5, 0xc0,0xe4,0xf5,0x2d,
+0x12,0x15,0x1c,0x12,0x15,0x6f,0xfd,0x71,0x4, 0xfe,0xc3,0xef,0x9d,0x74,0x80,0xf8,
+0x6e,0x98,0x40,0x2, 0x41,0xcd,0x7c,0x0, 0x7d,0x7, 0x11,0xc2,0x12,0x17,0xee,0xff,
+0xf4,0x70,0x2, 0x41,0xc9,0x12,0x63,0x6f,0x12,0x1, 0x4c,0x60,0x6, 0x64,0x2, 0x60,
+0x2, 0x41,0xc9,0xe4,0xf5,0x2e,0x91,0xa7,0xff,0x51,0xe8,0xe0,0x6f,0x60,0x2, 0x41,
+0xbe,0x90,0x0, 0x2, 0x12,0x15,0x5c,0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0x24,0xa8,0xf5,
+0x82,0xe4,0x34,0xa, 0x71,0x1c,0xf1,0xb7,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0x12,
+0x15,0x1c,0x71,0x4, 0x8f,0x82,0xf5,0x83,0x74,0x7, 0x12,0x5, 0x2f,0x12,0x15,0x5c,
+0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0x24,0xa6,0xf5,0x82,0xe4,0x34,0xa, 0x71,0x1c,0xf1,
+0xb7,0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xf5,0x30,0xd0,0xe0,0x3e,0xf5,0x2f,0x51,0xe8,
+0xe0,0xff,0xf1,0xdd,0xd3,0x94,0x0, 0x40,0xe, 0xef,0x51,0xfa,0xf1,0xc9,0x51,0xe8,
+0xe0,0xf1,0xdd,0x14,0xf0,0x41,0xc9,0x51,0xe8,0x51,0xf8,0x71,0x1c,0xd3,0x94,0x64,
+0xec,0x94,0x0, 0x40,0xd, 0xd3,0xe5,0x30,0x94,0x64,0xe5,0x2f,0x94,0x0, 0x40,0x2,
+0x80,0x22,0xed,0x24,0x32,0xff,0xe4,0x3c,0xfe,0xd3,0xe5,0x30,0x9f,0xe5,0x2f,0x9e,
+0x40,0x15,0x51,0xe8,0x51,0xf8,0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xd3,0x94,0x32,0xec,
+0x94,0x0, 0x40,0x3, 0xef,0x41,0xb8,0x51,0xe8,0xe0,0xfd,0x51,0xfa,0xf5,0x83,0xa3,
+0xe0,0x12,0x65,0x99,0xff,0x5, 0x82,0xd5,0x82,0x2, 0x15,0x83,0x15,0x82,0xe0,0xc4,
+0x54,0xf0,0x48,0xfe,0xc3,0xe5,0x30,0x9f,0xe5,0x2f,0x9e,0x50,0x3, 0xed,0x41,0xb8,
+0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x90,0x0, 0x6, 0x12,0x2, 0xb7,0xff,0xd3,0xe5,0x30,
+0x9f,0xe5,0x2f,0x95,0xf0,0x40,0x6e,0x91,0xa7,0xff,0x12,0x63,0x6f,0x12,0x1, 0x4c,
+0x70,0x4, 0x74,0x3, 0x80,0x2, 0x74,0x1, 0x12,0x1, 0xc5,0x91,0xa7,0xfd,0xe5,0x29,
+0x24,0x28,0xf9,0xe4,0x35,0x28,0x12,0x52,0x1e,0xf1,0xbf,0xfa,0x78,0x36,0x7c,0xa,
+0x7d,0x1, 0xf1,0xa1,0xe5,0x31,0xd3,0x94,0x0, 0x40,0x3a,0x15,0x31,0xe5,0x31,0x12,
+0x15,0x3a,0xc0,0x3, 0xc0,0x2, 0xc0,0x1, 0x71,0x4, 0xfe,0x7c,0x0, 0x7d,0x7, 0x12,
+0x1, 0xf9,0xf1,0xc1,0xa8,0x1, 0xfc,0xad,0x3, 0xd0,0x1, 0xd0,0x2, 0xd0,0x3, 0xf1,
+0xa1,0xe5,0x31,0x75,0xf0,0x7, 0xa4,0x25,0x29,0xf9,0xe5,0x28,0x35,0xf0,0x7f,0x7,
+0x12,0x63,0x5f,0x15,0x2d,0x51,0xe8,0xe0,0x51,0xfa,0xf1,0xc9,0x80,0xb, 0x5, 0x2e,
+0xe5,0x2e,0xc3,0x94,0x5, 0x50,0x2, 0x21,0x56,0x5, 0x2d,0x21,0x20,0x12,0x15,0x1c,
+0x90,0x0, 0x41,0xe5,0x31,0x12,0x1, 0xd7,0x78,0xa6,0x7c,0xa, 0x7d,0x1, 0x12,0x15,
+0x1c,0x7e,0x0, 0x7f,0x23,0x2, 0x1, 0x26,0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0x24,0xaa,
+0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0xe0,0xff,0x25,0xe0,0x24,0xc9,0xf5,0x82,
+0xe4,0x34,0xa, 0x22,0xaf,0x2d,0xef,0x33,0x95,0xe0,0x22,0xe5,0x2d,0x25,0xe0,0xff,
+0xe5,0x2c,0x33,0xfe,0xe5,0x31,0x2f,0xf5,0x82,0xe5,0x30,0x3e,0xf5,0x83,0xe0,0xfc,
+0xa3,0xe0,0xfd,0x22,0x12,0x17,0xfa,0x12,0x15,0xb1,0x90,0x7, 0x9d,0x12,0x1, 0x65,
+0xff,0xf5,0x34,0x12,0x15,0x1c,0x90,0x0, 0x15,0x12,0x1, 0x65,0xf5,0x35,0x90,0x0,
+0x16,0x12,0x1, 0x65,0xf5,0x36,0xef,0x70,0x2, 0x81,0x89,0x12,0x15,0xb1,0x90,0x7,
+0x9d,0x12,0x1, 0x65,0xb4,0x4, 0x8, 0xe5,0x35,0x25,0xe0,0x25,0xe0,0xf5,0x35,0xae,
+0x2, 0xaf,0x1, 0x8e,0x2e,0x8f,0x2f,0x12,0x4f,0x9d,0xf5,0x30,0x8f,0x31,0xe5,0x26,
+0x24,0x60,0xf9,0xe5,0x25,0x34,0x7, 0xaf,0x1, 0xf5,0x32,0x8f,0x33,0xe4,0xf5,0x2a,
+0x12,0x17,0x63,0x12,0x1, 0x4c,0xff,0xe5,0x2a,0xc3,0x9f,0x40,0x2, 0x81,0x89,0xe5,
+0x2a,0x75,0xf0,0x10,0xa4,0x85,0xf0,0x2c,0xf5,0x2d,0xe4,0xf5,0x2b,0x12,0x17,0x63,
+0x12,0x47,0xbf,0xff,0xe5,0x2b,0xc3,0x9f,0x40,0x2, 0x81,0x85,0xe5,0x34,0xb4,0x3,
+0x2, 0x81,0x46,0xe5,0x34,0xb4,0x2, 0x11,0x91,0x8a,0xf5,0x83,0xc0,0x83,0xc0,0x82,
+0x91,0x9c,0xd5,0x82,0x2, 0x15,0x83,0x81,0x6d,0xe5,0x34,0xb4,0x5, 0x4, 0x71,0xb,
+0x80,0x2e,0xe5,0x34,0x64,0x6, 0x70,0x69,0xe5,0x2d,0xae,0x2c,0x78,0x3, 0xce,0xc3,
+0x13,0xce,0x13,0xd8,0xf9,0xf1,0xd3,0x12,0x63,0x34,0xfe,0xef,0x5e,0x60,0x32,0x12,
+0x63,0x1, 0x40,0x13,0xe5,0x35,0xfd,0xe5,0x2d,0x25,0xe0,0xff,0xe5,0x2c,0x33,0xfe,
+0x91,0x93,0xf5,0x83,0xec,0x80,0x47,0x71,0xb, 0x12,0x64,0xd7,0xf1,0x99,0x50,0x69,
+0x91,0x93,0xf5,0x83,0xc0,0x83,0xc0,0x82,0x91,0x9c,0xd5,0x82,0x2, 0x15,0x83,0x80,
+0x4c,0xe5,0x2d,0xae,0x2c,0x78,0x3, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf1,0xd3,
+0xc0,0x83,0xc0,0x82,0x12,0x63,0x34,0xfe,0xef,0x4e,0xd0,0x82,0xd0,0x83,0xf0,0x80,
+0x38,0x12,0x63,0x1, 0x40,0xf, 0xe5,0x35,0xfd,0x91,0x8a,0xf5,0x83,0xe4,0x8d,0xf0,
+0x12,0x2, 0x60,0x80,0x24,0x71,0xb, 0x12,0x64,0xd7,0xf1,0x99,0x50,0x1b,0x91,0x93,
+0xf5,0x83,0xc0,0x83,0xc0,0x82,0x91,0x9c,0xd5,0x82,0x2, 0x15,0x83,0x15,0x82,0xe0,
+0x9e,0xd0,0x82,0xd0,0x83,0xf0,0xa3,0xef,0xf0,0x5, 0x2d,0xe5,0x2d,0x70,0x2, 0x5,
+0x2c,0x5, 0x2b,0x61,0x9d,0x5, 0x2a,0x61,0x80,0x22,0xe5,0x2d,0x25,0xe0,0xff,0xe5,
+0x2c,0x33,0xfe,0xe5,0x2f,0x2f,0xf5,0x82,0xe5,0x2e,0x3e,0x22,0x7e,0x0, 0xc3,0xa3,
+0xe0,0x95,0x35,0xff,0x5, 0x82,0x22,0xaf,0x2d,0xef,0x33,0x95,0xe0,0xfe,0x7c,0x0,
+0x7d,0x7, 0x12,0x1, 0xf9,0x90,0x0, 0x4, 0xab,0x27,0xe5,0x29,0x2f,0xf9,0xe5,0x28,
+0x3e,0xfa,0x2, 0x1, 0x65,0x12,0x17,0xfa,0xe4,0xf5,0x29,0xe5,0x29,0xc3,0x94,0x5,
+0x50,0x10,0xe5,0x26,0x24,0x30,0xf9,0xe4,0x35,0x25,0xfa,0xe5,0x29,0x12,0x2e,0x3,
+0x80,0x14,0xe5,0x29,0x75,0xf0,0x8, 0xa4,0x24,0x30,0xff,0xe4,0x35,0xf0,0xfe,0xe5,
+0x26,0x2f,0xf9,0xe5,0x25,0x3e,0xaf,0x1, 0xf5,0x2a,0x8f,0x2b,0xb1,0xde,0x64,0x2,
+0x60,0x2, 0xa1,0xd3,0xe5,0x2b,0x24,0x7, 0x12,0x63,0xeb,0xe4,0xf0,0xf1,0x7f,0xa3,
+0xe0,0x24,0xfe,0xf5,0x27,0xf1,0x7f,0xa3,0xe0,0x24,0x2, 0xff,0xe4,0xad,0x27,0xf1,
+0x8e,0x40,0x2, 0xa1,0xd3,0xf1,0x7f,0xe0,0x24,0xfe,0xf5,0x28,0xf1,0x7f,0xe0,0x24,
+0x2, 0xff,0xe4,0x33,0xfe,0xad,0x28,0xf1,0x90,0x40,0x2, 0xa1,0xcf,0xc3,0xe5,0x27,
+0x64,0x80,0x94,0x80,0x50,0x2, 0xa1,0xcb,0xe5,0x27,0x64,0x80,0x94,0x9c,0x50,0x7b,
+0xc3,0xe5,0x28,0x64,0x80,0x94,0x80,0x40,0x72,0xe5,0x28,0x64,0x80,0x94,0x90,0x50,
+0x6a,0xab,0x21,0xe5,0x23,0x24,0x80,0xf9,0xe5,0x22,0x12,0x63,0xc7,0x78,0x5, 0xc3,
+0x33,0xce,0x33,0xce,0xd8,0xf9,0x29,0xf9,0xea,0x3e,0xfa,0xf1,0xaf,0x11,0xc5,0x12,
+0x2, 0x8c,0xfd,0xaf,0x27,0x12,0x62,0xba,0xab,0x28,0xeb,0x33,0x95,0xe0,0xfa,0xef,
+0x2b,0xff,0xee,0x3a,0x12,0x2f,0xea,0x33,0x12,0x17,0x63,0x8f,0x82,0xf5,0x83,0xe5,
+0xf0,0x8d,0xf0,0x12,0x2, 0xef,0xe9,0x24,0x80,0xf9,0xea,0x12,0x63,0xc7,0x78,0x5,
+0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0x29,0xf9,0xea,0x3e,0xfa,0xaf,0x28,0x12,0x2f,
+0xe6,0x33,0xfe,0x11,0xc5,0xe4,0xf5,0xf0,0x12,0x3, 0x3c,0x5, 0x28,0xa1,0x2c,0x5,
+0x27,0xa1,0x15,0x5, 0x29,0xe5,0x29,0x64,0xa, 0x60,0x2, 0x81,0xcb,0x22,0xe5,0x2b,
+0x24,0x7, 0xf5,0x82,0xe4,0x35,0x2a,0xf5,0x83,0xe0,0x22,0x12,0x17,0xfa,0x75,0x2a,
+0xb, 0x75,0x2b,0xf1,0x90,0xc, 0x31,0xe0,0x20,0xe0,0x2, 0xe1,0x77,0x54,0xfe,0xf0,
+0x90,0x0, 0x2, 0x12,0x1, 0x65,0xff,0x85,0x2b,0x82,0x85,0x2a,0x83,0xe0,0x6f,0x60,
+0x15,0xe0,0xff,0x90,0x0, 0x2, 0x12,0x1, 0xd7,0xef,0x75,0xf0,0x4, 0xa4,0xff,0xe5,
+0xf0,0x8f,0xf0,0x12,0x3, 0x3c,0x12,0x17,0x63,0x12,0x1f,0xed,0xff,0xf1,0x7f,0xe0,
+0xfd,0x7c,0x0, 0x6f,0x70,0x2, 0xe5,0xf0,0x60,0x6, 0x90,0x0, 0x3, 0x12,0x1f,0xe0,
+0x12,0x15,0x1c,0x90,0x0, 0x3, 0xf1,0x78,0x24,0x5, 0xb1,0xe2,0xfe,0x6f,0x60,0x14,
+0x90,0x0, 0x3, 0xf1,0x87,0x24,0x5, 0xb1,0xe2,0x75,0xf0,0x20,0xa4,0xff,0x90,0x0,
+0x1, 0x12,0x17,0xc0,0x12,0x15,0x1c,0x90,0x0, 0x5, 0xf1,0x78,0x24,0x17,0xb1,0xe2,
+0xfe,0x6f,0x60,0xf, 0x90,0x0, 0x5, 0xf1,0x87,0x24,0x17,0xb1,0xe2,0x90,0x0, 0x4,
+0x12,0x1, 0xd7,0x12,0x15,0x1c,0x90,0x0, 0x6, 0xf1,0xa8,0x24,0x2e,0xb1,0xe2,0xfd,
+0x7c,0x0, 0x6f,0x70,0x2, 0xe5,0xf0,0x60,0x6, 0x90,0x0, 0x6, 0x12,0x1f,0xe0,0x12,
+0x15,0xb1,0x12,0x1, 0x4c,0xff,0xe5,0x2b,0x24,0x25,0xb1,0xe2,0xfe,0x6f,0x60,0x4,
+0xee,0x12,0x1, 0xc5,0x12,0x17,0xdc,0xff,0xe5,0x2b,0x24,0x6, 0xb1,0xe2,0xfe,0x6f,
+0x60,0x4, 0xee,0x12,0x4a,0xa3,0x90,0x0, 0x4, 0xf1,0x78,0x24,0x8, 0xb1,0xe2,0xfe,
+0x6f,0x60,0x27,0x90,0x0, 0x4, 0xf1,0x87,0x24,0x8, 0xb1,0xe2,0xc3,0x94,0xf, 0x40,
+0x9, 0xe5,0x2b,0x24,0x8, 0x12,0x63,0xeb,0xe4,0xf0,0xe5,0x2b,0x24,0x8, 0xb1,0xe2,
+0x90,0x7, 0x6d,0x93,0x90,0x0, 0x3, 0x12,0x1, 0xd7,0x12,0x15,0xb1,0x90,0x0, 0x6,
+0xf1,0x78,0x24,0x9, 0xb1,0xe2,0xfe,0x6f,0x60,0xf, 0x90,0x0, 0x6, 0xf1,0x87,0x24,
+0x9, 0xb1,0xe2,0x90,0x0, 0x5, 0x12,0x1, 0xd7,0x12,0x15,0xb1,0x90,0x0, 0x8, 0x12,
+0x1, 0x65,0xff,0xb1,0xde,0xfe,0x6f,0x60,0x7, 0x90,0x0, 0x8, 0xee,0x12,0x1, 0xd7,
+0x90,0x0, 0xa, 0xf1,0x78,0x24,0x24,0xb1,0xe2,0xfe,0x6f,0x60,0x7, 0x90,0x0, 0xa,
+0xee,0x12,0x1, 0xd7,0x12,0x17,0x63,0x90,0x0, 0xb, 0xf1,0xa8,0x24,0x33,0xb1,0xe2,
+0xfd,0x7c,0x0, 0x6f,0x70,0x2, 0xe5,0xf0,0x60,0x6, 0x90,0x0, 0xb, 0x12,0x1f,0xe0,
+0x12,0x17,0x63,0x90,0x0, 0xd, 0xf1,0x78,0x24,0x34,0xb1,0xe2,0xfe,0x6f,0x60,0x7,
+0x90,0x0, 0xd, 0xee,0x12,0x1, 0xd7,0x22,0x12,0x1, 0x65,0xff,0xe5,0x2b,0x22,0x85,
+0x2b,0x82,0x85,0x2a,0x83,0xa3,0x22,0xee,0x12,0x1, 0xd7,0xe5,0x2b,0x22,0x33,0xfe,
+0xed,0x33,0x95,0xe0,0xfc,0xd3,0xed,0x9f,0xee,0x64,0x80,0xf8,0xec,0x64,0x80,0x98,
+0x22,0x7e,0x0, 0x7f,0x7, 0x2, 0x1, 0x26,0x12,0x2, 0xb7,0xff,0xe5,0x2b,0x22,0xed,
+0x25,0xe0,0xff,0xec,0x33,0xfe,0x22,0xc3,0xef,0x9d,0xff,0xee,0x9c,0xfe,0x22,0xab,
+0x27,0xe5,0x29,0x2f,0xf9,0xe5,0x28,0x3e,0x22,0xf5,0x83,0xe5,0x2f,0xf0,0xa3,0xe5,
+0x30,0xf0,0x22,0x25,0x33,0xf5,0x82,0xe5,0x32,0x3e,0xf5,0x83,0x22,0x24,0xd3,0xf5,
+0x82,0xe4,0x34,0xa, 0xf5,0x83,0xe0,0x22,0x12,0x17,0xfa,0xe4,0xf5,0x24,0xe4,0xf5,
+0x25,0x12,0x17,0x63,0x12,0x41,0x2, 0x12,0x2, 0xb7,0x12,0x47,0x9b,0x40,0x2, 0x1,
+0xe9,0xe4,0xf5,0x27,0x85,0x25,0x26,0x12,0x17,0x63,0x12,0x15,0x49,0xb1,0x1, 0x94,
+0x80,0x50,0x5, 0x75,0x27,0x1, 0x80,0xb, 0xe5,0x26,0xd3,0x94,0x0, 0x40,0x4, 0x15,
+0x26,0x80,0xe4,0xe5,0x27,0x70,0x21,0xe5,0x25,0x4, 0xf5,0x26,0xe5,0x26,0xc3,0x94,
+0xf, 0x50,0x15,0x12,0x17,0x63,0x12,0x15,0x49,0xb1,0x1, 0x94,0x80,0x50,0x5, 0x75,
+0x27,0x1, 0x80,0x4, 0x5, 0x26,0x80,0xe4,0xe5,0x27,0x64,0x1, 0x60,0x2, 0x1, 0xe9,
+0x12,0x17,0x63,0x31,0x2, 0x12,0x1b,0xf6,0x71,0x23,0x12,0x2f,0xea,0x12,0x2f,0xb9,
+0xae,0xf0,0x2d,0xf5,0x29,0xec,0x3e,0xf5,0x28,0xe5,0x26,0x31,0x4, 0x12,0x1b,0xf6,
+0xe5,0x26,0x71,0x25,0x12,0x2f,0xea,0x12,0x2f,0xb9,0xae,0xf0,0x2d,0xf5,0x2b,0xec,
+0x3e,0xf5,0x2a,0xe5,0x26,0xb1,0x30,0x12,0x2f,0xea,0x33,0x8f,0x82,0xf5,0x83,0x12,
+0x1b,0xf6,0x71,0x23,0x12,0x2f,0xea,0x12,0x2f,0xb9,0xf1,0x7a,0xc0,0x6, 0xc0,0x7,
+0xc3,0xe5,0x29,0x95,0x2b,0xff,0xe5,0x28,0x95,0x2a,0xfe,0x12,0x0, 0x6, 0xd0,0x5,
+0xd0,0x4, 0xd3,0xef,0x9d,0xec,0x71,0x3b,0x40,0x2f,0xab,0x21,0xf1,0x84,0xfa,0xe5,
+0x25,0xb1,0x30,0xfe,0xef,0x78,0x3, 0xd1,0x55,0xd8,0xfc,0x12,0xe, 0xb7,0xff,0xe5,
+0x25,0xc4,0x54,0xf0,0x25,0x24,0x54,0x7, 0xfe,0x74,0x1, 0xa8,0x6, 0x8, 0x80,0x2,
+0xc3,0x33,0xd8,0xfc,0xf4,0x5f,0x12,0x1, 0xc5,0x5, 0x25,0xe5,0x25,0xc3,0x94,0xf,
+0x50,0x3, 0x2, 0x3f,0xf1,0x5, 0x24,0xe5,0x24,0xc3,0x94,0xa, 0x50,0x3, 0x2, 0x3f,
+0xee,0x22,0xe5,0x25,0x90,0x3, 0x80,0x75,0xf0,0x20,0x12,0x5, 0x40,0xe5,0x24,0x75,
+0xf0,0x2, 0x2, 0x5, 0x40,0x8b,0x46,0x8a,0x47,0x89,0x48,0x75,0x4f,0x20,0x90,0x0,
+0x55,0x12,0x1, 0x65,0xf5,0x57,0xf1,0xbf,0xf5,0x5e,0x12,0x1, 0x4c,0xf5,0x5f,0x85,
+0x5e,0x60,0xe5,0x5e,0x25,0xe0,0xf5,0x61,0xd1,0x4f,0xf5,0x62,0x90,0x0, 0x52,0x12,
+0x1, 0x65,0xf5,0x65,0x90,0x0, 0x82,0x12,0x1, 0x65,0xf5,0x66,0xab,0x49,0xaa,0x4a,
+0xa9,0x4b,0x90,0x7, 0xa5,0xe5,0x15,0x12,0x1, 0xd7,0xf1,0xa5,0xef,0x70,0x3, 0x7f,
+0xaa,0x22,0xab,0x49,0xaa,0x4a,0xa9,0x4b,0x90,0x7, 0x9a,0x12,0x5, 0x6c,0xaf,0x1,
+0x8a,0x63,0x8f,0x64,0xaf,0x5f,0x7e,0x0, 0xab,0x46,0xe5,0x48,0x24,0x56,0xf9,0xe4,
+0x78,0x6b,0x7c,0x0, 0x91,0xe0,0xaf,0x5e,0x7e,0x0, 0xab,0x46,0xe5,0x48,0x24,0x72,
+0xf9,0xe4,0x78,0x87,0x7c,0x0, 0x91,0xe0,0xe5,0x57,0x54,0x30,0x60,0x75,0x75,0x4c,
+0x10,0x75,0x4d,0x0, 0xe4,0x25,0x4b,0xf9,0xe5,0x4a,0x34,0x7, 0xaf,0x1, 0xf5,0x5a,
+0x8f,0x5b,0xe4,0xf5,0x4e,0xe5,0x4e,0xc3,0x95,0x5e,0x50,0x57,0x71,0x1c,0xe0,0xfe,
+0xa3,0xe0,0xff,0x91,0xf8,0x25,0x4e,0xf8,0xe6,0x31,0xf, 0xee,0xf0,0xa3,0xef,0xf0,
+0xe5,0x57,0x30,0xe5,0x14,0x71,0x1c,0xe5,0x60,0x91,0xd4,0xe5,0x5b,0x24,0x20,0x91,
+0xf0,0xe6,0x31,0xf, 0xee,0xf0,0xa3,0xef,0xf0,0xe5,0x57,0x54,0x30,0x64,0x30,0x70,
+0x1c,0x71,0x1c,0x75,0xf0,0x2, 0xe5,0x61,0x91,0xd7,0xe5,0x5b,0x24,0x40,0x91,0xf0,
+0x74,0x87,0x25,0x4e,0xf8,0xe6,0x31,0xf, 0xee,0xf0,0xa3,0xef,0xf0,0xb1,0x24,0x5,
+0x4e,0x80,0xa2,0xe5,0x57,0x54,0x3, 0xf5,0x56,0x70,0x2, 0x61,0x17,0xe5,0x66,0xb4,
+0x1, 0x8, 0x75,0x4c,0x10,0x75,0x4d,0x60,0x80,0x6, 0x75,0x4c,0x10,0x75,0x4d,0x48,
+0x85,0x4c,0x50,0x85,0x4d,0x51,0xe5,0x4b,0x24,0x80,0xf9,0xe5,0x4a,0x34,0x3, 0xaf,
+0x1, 0xf5,0x52,0x8f,0x53,0x85,0x4a,0x54,0x85,0x4b,0x55,0xe4,0xf5,0x4e,0xe5,0x4e,
+0xc3,0x95,0x5f,0x40,0x2, 0x61,0x17,0x85,0x4f,0xf0,0x91,0xe8,0xff,0xae,0xf0,0x25,
+0x53,0xfd,0xe5,0x52,0x3e,0xf5,0x58,0x8d,0x59,0xe5,0x55,0x2f,0xff,0xe5,0x54,0x3e,
+0xf5,0x5a,0x8f,0x5b,0xe4,0xfd,0xed,0xc3,0x95,0x5e,0x50,0x7d,0x71,0x1c,0xe0,0xf5,
+0x5c,0xa3,0xe0,0xf5,0x5d,0xe5,0x65,0x70,0x29,0x85,0x5e,0xf0,0x91,0xe8,0x25,0x64,
+0xf5,0x82,0xe5,0x63,0x35,0xf0,0xf5,0x83,0x74,0x87,0x2d,0xf8,0xe6,0x25,0x82,0x12,
+0x1e,0x31,0xe0,0x75,0xf0,0x8, 0xa4,0xae,0xf0,0x25,0x5d,0xf5,0x5d,0xee,0x35,0x5c,
+0xf5,0x5c,0xe5,0x62,0x60,0x2a,0x91,0xf8,0x2d,0xf8,0xe6,0xff,0x31,0xf, 0xe0,0xfa,
+0xa3,0xe0,0xfb,0xc3,0xe5,0x5d,0x9b,0xfb,0xe5,0x5c,0x9a,0xfa,0x85,0x58,0x83,0x85,
+0x59,0x82,0x75,0xf0,0x2, 0xef,0x12,0x5, 0x40,0xea,0xf0,0xa3,0xeb,0xf0,0x80,0x14,
+0x85,0x59,0x82,0x85,0x58,0x83,0x74,0x87,0x2d,0xf8,0xe6,0x31,0xf, 0xe5,0x5c,0xf0,
+0xa3,0xe5,0x5d,0xf0,0xb1,0x24,0xd, 0x41,0x76,0xe5,0x66,0xb4,0x1, 0x4, 0x74,0x20,
+0x80,0x2, 0x74,0x48,0x25,0x51,0xf5,0x51,0xe4,0x35,0x50,0xf5,0x50,0x85,0x50,0x4c,
+0x85,0x51,0x4d,0x5, 0x4e,0x41,0x4e,0xb1,0xc, 0x7f,0x0, 0x22,0x85,0x4d,0x82,0x85,
+0x4c,0x83,0x22,0xe5,0x25,0x75,0xf0,0x10,0xa4,0x25,0x24,0x7a,0x0, 0xff,0xea,0x35,
+0xf0,0x22,0xfe,0xa3,0xe0,0xff,0xd3,0x95,0x30,0xe5,0x2f,0x64,0x80,0xf8,0xee,0x64,
+0x80,0x98,0x22,0x12,0x17,0xfa,0xe4,0xf5,0x42,0xf5,0x43,0x74,0x5a,0x25,0x43,0xf1,
+0x8e,0x5, 0x43,0xe5,0x43,0x70,0x2, 0x5, 0x42,0x64,0x96,0x45,0x42,0x70,0xec,0x12,
+0x27,0xdf,0xb1,0xc, 0x85,0x24,0x49,0x85,0x25,0x4a,0x85,0x26,0x4b,0x12,0x17,0x63,
+0xb1,0xe2,0x60,0xf0,0xe5,0x26,0x24,0x80,0xf9,0xe5,0x25,0x34,0x3, 0xaf,0x1, 0xf5,
+0xf, 0x8f,0x10,0xe4,0xf5,0x2a,0xf5,0x2b,0xe4,0xf5,0x41,0xe5,0x2b,0x45,0x2a,0x70,
+0x6, 0x91,0xc7,0xe4,0xf6,0x8, 0xf6,0xe5,0x2b,0xae,0x2a,0x78,0x5, 0xc3,0x33,0xce,
+0x33,0xce,0xd8,0xf9,0xb1,0x18,0x31,0xf, 0xe0,0xfe,0xa3,0xe0,0xff,0x91,0xc7,0xe6,
+0xfc,0x8, 0xe6,0xfd,0xd3,0xef,0x9d,0xee,0x9c,0x40,0xf, 0xef,0x94,0x1c,0xee,0x94,
+0x25,0x50,0x7, 0x91,0xc7,0xa6,0x6, 0x8, 0xa6,0x7, 0x5, 0x41,0xe5,0x41,0xb4,0xa,
+0xba,0x5, 0x2b,0xe5,0x2b,0x70,0x2, 0x5, 0x2a,0x64,0xf, 0x45,0x2a,0x70,0xa9,0xe4,
+0xf5,0x44,0xf5,0x45,0xf5,0x2a,0xf5,0x2b,0xe4,0xf5,0x41,0xe5,0x2b,0xae,0x2a,0x78,
+0x5, 0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xb1,0x18,0x91,0xd4,0xd3,0x94,0x1c,0xee,
+0x94,0x25,0x40,0xa, 0x5, 0x45,0xe5,0x45,0x70,0x2, 0x5, 0x44,0x80,0x45,0x91,0xc7,
+0xe6,0xfc,0x8, 0xe6,0xc3,0x9f,0xf5,0x43,0xec,0x9e,0xf5,0x42,0xe5,0x43,0xae,0x42,
+0x78,0x3, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf5,0x43,0x8e,0x42,0xd3,0x94,0xff,
+0xe5,0x42,0x94,0x0, 0x40,0x6, 0x75,0x42,0x0, 0x75,0x43,0xff,0x5, 0x45,0xe5,0x45,
+0xac,0x44,0x70,0x2, 0x5, 0x44,0x14,0x24,0x5a,0xf5,0x82,0x74,0xb, 0x3c,0xf5,0x83,
+0xe5,0x43,0xf0,0x5, 0x41,0xe5,0x41,0x64,0xa, 0x70,0x90,0x5, 0x2b,0xe5,0x2b,0x70,
+0x2, 0x5, 0x2a,0x64,0xf, 0x45,0x2a,0x60,0x2, 0x61,0xe8,0x75,0x28,0xa, 0x75,0x29,
+0xe5,0xe4,0xf5,0x2c,0xf5,0x2a,0xf5,0x2b,0x85,0x29,0x82,0x85,0x28,0x83,0xe0,0x62,
+0x2c,0x7e,0x0, 0xe5,0x2b,0x25,0x27,0xff,0xee,0x35,0x2a,0xfe,0x5, 0x29,0xe5,0x29,
+0xac,0x28,0x70,0x2, 0x5, 0x28,0x14,0xf5,0x82,0x8c,0x83,0xe0,0xfd,0x91,0xcf,0x5,
+0x2b,0xe5,0x2b,0x70,0x2, 0x5, 0x2a,0xc3,0x94,0xb, 0xe5,0x2a,0x94,0x1, 0x40,0xc8,
+0xad,0x2c,0x7f,0xf0,0x7e,0x3, 0x91,0xcf,0xc3,0x74,0xff,0x95,0x2c,0xfd,0x7f,0xf1,
+0x7e,0x3, 0x91,0xcf,0x7f,0x1, 0x22,0xe5,0x41,0x25,0xe0,0x24,0x2d,0xf8,0x22,0xf1,
+0x72,0x2, 0x37,0x5c,0x75,0xf0,0x2, 0x12,0x5, 0x40,0xe0,0xfe,0xa3,0xe0,0xff,0x22,
+0x35,0x47,0xfa,0x7d,0x0, 0x2, 0x1, 0x26,0x74,0x6b,0x25,0x4e,0xf8,0xe6,0xa4,0x22,
+0xf5,0x82,0xe4,0x35,0x5a,0xf5,0x83,0x22,0x85,0x5b,0x82,0x85,0x5a,0x83,0x74,0x87,
+0x22,0x12,0x0, 0x6, 0xc3,0xef,0x94,0x14,0xee,0x64,0x80,0x22,0x53,0xdb,0xfd,0xd2,
+0xba,0x43,0xdb,0x1, 0x43,0xdb,0x20,0x22,0x25,0x10,0xf5,0x82,0xe5,0xf, 0x3e,0xf5,
+0x83,0xe5,0x41,0x22,0x74,0x2, 0x25,0x4d,0xf5,0x4d,0xe4,0x35,0x4c,0xf5,0x4c,0x22,
+0x75,0xf0,0x10,0xa4,0x25,0x24,0x7c,0x0, 0xff,0xec,0x35,0xf0,0x22,0x8b,0x32,0x8a,
+0x33,0x89,0x34,0xd1,0x4f,0xf5,0x3f,0x90,0x0, 0x52,0x12,0x1, 0x65,0xf5,0x40,0x90,
+0x0, 0x53,0xe4,0x12,0x1, 0xd7,0x90,0x0, 0x52,0xe4,0x12,0x1, 0xd7,0xe5,0x37,0x24,
+0x80,0xf9,0xe5,0x36,0x34,0x3, 0xaf,0x1, 0xf5,0x3d,0x8f,0x3e,0x85,0x36,0x3b,0x85,
+0x37,0x3c,0x75,0x38,0x1, 0x85,0x35,0x49,0x85,0x36,0x4a,0x85,0x37,0x4b,0xab,0x32,
+0xaa,0x33,0xa9,0x34,0xb1,0xe2,0x60,0xed,0xe4,0xf5,0x39,0xf5,0x3a,0xb1,0xe8,0xe5,
+0x3e,0x2f,0xf5,0x82,0xe5,0x3d,0xf1,0x62,0x78,0x2, 0xd1,0x55,0xd8,0xfc,0xfd,0xac,
+0x6, 0xb1,0xe8,0xe5,0x3c,0x2f,0xf5,0x82,0xe5,0x3b,0x3e,0xf5,0x83,0xec,0x8d,0xf0,
+0x12,0x2, 0x60,0x5, 0x3a,0xe5,0x3a,0x70,0x2, 0x5, 0x39,0xb4,0xc0,0xcf,0xe5,0x39,
+0xb4,0x1, 0xca,0x5, 0x38,0xe5,0x38,0xd3,0x94,0x4, 0x40,0xa9,0xab,0x32,0xaa,0x33,
+0xa9,0x34,0x90,0x0, 0x53,0xe5,0x3f,0x12,0x1, 0xd7,0x90,0x0, 0x52,0xe5,0x40,0x2,
+0x1, 0xd7,0x31,0x15,0xef,0x64,0xaa,0x22,0xe5,0x3a,0x25,0xe0,0xff,0xe5,0x39,0x33,
+0xfe,0x22,0x8e,0x21,0x8f,0x22,0x8c,0x23,0x8d,0x24,0x8a,0x25,0x8b,0x26,0xf1,0x5b,
+0x12,0x34,0x3f,0xaa,0x21,0xa9,0x22,0x7b,0x1, 0x12,0x28,0x4b,0xaa,0x23,0xa9,0x24,
+0x7b,0x1, 0x12,0xe, 0xbf,0xe5,0x22,0x24,0x55,0xf5,0x82,0xe4,0x35,0x21,0xf5,0x83,
+0x74,0x21,0xf0,0xaa,0x27,0xa9,0x28,0x7b,0x1, 0x12,0x25,0xfb,0xaa,0x27,0xa9,0x28,
+0x7b,0x1, 0x12,0x24,0xc9,0xb1,0xc, 0xaa,0x25,0xa9,0x26,0x7b,0x1, 0xd1,0xe5,0xaa,
+0x21,0xa9,0x22,0x7b,0x1, 0xc0,0x3, 0x8b,0x35,0xd1,0x5f,0xd0,0x3, 0xa1,0x3d,0x90,
+0x0, 0x53,0x2, 0x1, 0x65,0xce,0xa2,0xe7,0x13,0xce,0x13,0x22,0x85,0x24,0x35,0x85,
+0x25,0x36,0x85,0x26,0x37,0x22,0x12,0x17,0xfa,0x90,0x0, 0x2f,0xf1,0x52,0x30,0xe0,
+0x34,0x12,0x17,0x63,0x90,0x0, 0x4d,0x12,0x2, 0xb7,0xc3,0x94,0x3c,0xe5,0xf0,0x94,
+0x0, 0x50,0xc, 0x90,0x0, 0x4d,0xe4,0x75,0xf0,0x1, 0x12,0x2, 0xef,0x80,0x16,0x12,
+0x15,0xb1,0xd1,0xe5,0xd1,0x5c,0x12,0x15,0x1c,0xb1,0x3d,0x90,0xa, 0xe3,0x74,0x5,
+0xf0,0xa3,0x74,0xdc,0xf0,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x90,0x0, 0x2f,0x12,0x1,
+0x65,0x20,0xe0,0x30,0x12,0x17,0x63,0x90,0x0, 0x4d,0xe4,0xf5,0xf0,0x12,0x3, 0x5b,
+0xf1,0x4f,0xff,0x70,0x8, 0x90,0xa, 0xe3,0xf0,0xa3,0xf0,0xc2,0x0, 0x30,0x0, 0x14,
+0xc2,0x0, 0xef,0xd3,0x94,0x0, 0x40,0xc, 0x12,0x15,0xb1,0xd1,0xe5,0xd1,0x5c,0x12,
+0x15,0x1c,0xb1,0x3d,0x22,0xd1,0xf9,0xe4,0x90,0xa, 0xde,0xf0,0xa3,0xf0,0x90,0xa,
+0xd8,0x74,0xd, 0xf0,0xa3,0x74,0xac,0xf0,0x22,0x90,0xc, 0x12,0x74,0x30,0xf0,0xa3,
+0x74,0x3, 0xf0,0xae,0x2, 0xaf,0x1, 0xad,0x7, 0xac,0x6, 0xe9,0x24,0x60,0xf9,0xea,
+0x34,0x7, 0xfa,0xe4,0xf5,0x32,0xf5,0x33,0xe5,0x33,0x25,0xe0,0xff,0xe5,0x32,0x33,
+0xfe,0xed,0x2f,0xf5,0x82,0xec,0xf1,0x6a,0xe5,0x33,0xae,0x32,0x78,0x3, 0xce,0xc3,
+0x13,0xce,0x13,0xd8,0xf9,0xf5,0x82,0x8e,0x83,0x74,0xff,0x12,0x1, 0xd7,0x5, 0x33,
+0xe5,0x33,0x70,0x2, 0x5, 0x32,0xb4,0xc0,0xcf,0xe5,0x32,0xb4,0x1, 0xca,0x22,0x90,
+0x0, 0x2d,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x2, 0x1, 0x65,0x12,0x27,0xdf,0x53,0xdb,
+0xf0,0x22,0x3e,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x22,0x3e,0xf5,0x83,0xe4,0xf0,0xa3,
+0xf0,0x22,0xe4,0x2f,0xff,0xee,0x34,0x7c,0xfe,0x22,0xc3,0x9d,0xff,0xe5,0xf0,0x9c,
+0xfe,0x2, 0x0, 0x6, 0xe5,0x23,0x24,0x60,0xf9,0xe5,0x22,0x34,0x7, 0x22,0xf5,0x82,
+0xe4,0x34,0xb, 0xf5,0x83,0xe4,0xf0,0x22,0x12,0x2, 0x8c,0xc3,0x94,0xce,0xe5,0xf0,
+0x64,0x80,0x94,0x7f,0x22,0xe5,0xdb,0x20,0xe1,0x3, 0x7f,0x0, 0x22,0x53,0xdb,0xfd,
+0x7f,0x1, 0x22,0x33,0xfe,0xab,0x2a,0xe5,0x2c,0x2f,0xf9,0xe5,0x2b,0x3e,0xfa,0x90,
+0x0, 0x1, 0x2, 0x1, 0x65,0xef,0x24,0x9f,0xf1,0xdf,0xef,0x24,0x9e,0xf1,0xdf,0xef,
+0x24,0x9d,0xf5,0x82,0xee,0x34,0x7, 0xf5,0x83,0x74,0x1, 0xf0,0xef,0x24,0xa4,0xf5,
+0x82,0xee,0x34,0x7, 0xf5,0x83,0xe4,0xf0,0x22,0xe5,0xe8,0x54,0xc0,0x64,0xc0,0x60,
+0x3, 0x12,0x33,0xcb,0x22,0x12,0x17,0xfa,0x85,0xc9,0x30,0x12,0x15,0xb1,0x12,0x1,
+0x4c,0xff,0x70,0x3d,0x12,0x17,0x63,0x12,0x17,0xe8,0xd3,0x94,0x0, 0x40,0x7, 0x12,
+0x15,0xb1,0x31,0x1b,0x1, 0xc9,0x12,0x17,0xdc,0x20,0xe0,0x2, 0x1, 0xc9,0x90,0x0,
+0x8, 0x12,0x1, 0x65,0xfe,0x90,0x0, 0x7, 0x74,0x1, 0x12,0x1, 0x92,0x6e,0x60,0x2,
+0x1, 0xc9,0x12,0x15,0xb1,0x90,0x0, 0x7, 0x12,0x1, 0xd7,0x74,0x1, 0x31,0x13,0x1,
+0xc9,0xef,0xb4,0x1, 0x12,0x12,0x17,0x63,0x12,0x17,0xe8,0x60,0x7c,0x12,0x15,0xb1,
+0x31,0x12,0x75,0xd, 0x1e,0x80,0x72,0x12,0x15,0xb1,0x12,0x1, 0x4c,0x64,0x3, 0x70,
+0x68,0xff,0x51,0xa9,0x12,0x46,0xe7,0x12,0x0, 0x4e,0xe5,0xdb,0x30,0xe1,0xfb,0xc2,
+0x89,0xd2,0xa8,0x20,0x96,0xfd,0x43,0x87,0x2, 0xc2,0xa8,0x12,0x46,0xe7,0x12,0x0,
+0x4e,0x53,0xdb,0xf0,0x12,0x45,0xc, 0x85,0x21,0x35,0x85,0x22,0x36,0x85,0x23,0x37,
+0xab,0x2d,0xaa,0x2e,0xa9,0x2f,0x12,0x38,0x1d,0x12,0x15,0xb1,0x31,0x12,0xae,0x2b,
+0xaf,0x2c,0x12,0x47,0xc5,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x12,0x46,0xf9,0x90,0xb,
+0xf0,0x74,0xa, 0xf0,0x90,0xb, 0xf0,0xe0,0x70,0xfa,0x85,0x2a,0x35,0x85,0x2b,0x36,
+0x85,0x2c,0x37,0x12,0x15,0x1c,0x12,0x45,0x3d,0xe4,0xf5,0x31,0xe5,0xc, 0x70,0x22,
+0xff,0x51,0xc0,0xe5,0xdb,0x30,0xe1,0xf4,0xc2,0xcd,0x12,0x15,0xb1,0x12,0x1, 0x4c,
+0xb4,0x1, 0xe9,0xe5,0x31,0x70,0xe5,0x75,0x31,0x1, 0x53,0xc9,0xfc,0x43,0xc9,0x1,
+0x80,0xda,0xe4,0xf5,0xd, 0xf5,0xc, 0x85,0x30,0xc9,0xd2,0xcd,0x51,0xb2,0x54,0xef,
+0x12,0x1, 0xc5,0x12,0x17,0x63,0x12,0x17,0xe8,0x90,0x0, 0x4c,0x12,0x1, 0xd7,0x2,
+0x47,0xe9,0xe4,0x12,0x1, 0xc5,0x90,0xc, 0x16,0xf0,0x22,0x90,0x0, 0x7, 0xe4,0x2,
+0x1, 0xd7,0x12,0x17,0xfa,0x90,0xb, 0xf1,0x74,0x14,0xf0,0xa3,0x74,0x3c,0xf0,0xe4,
+0x90,0xb, 0xf4,0xf0,0xa3,0x74,0x6, 0xf0,0x74,0xa0,0x51,0x7c,0x74,0xc8,0xf0,0xa3,
+0x74,0x6, 0xf0,0xa3,0x74,0x28,0xf0,0x90,0xc, 0x8, 0x74,0x32,0xf0,0x90,0xc, 0x11,
+0x74,0xff,0xf0,0x90,0xc, 0x14,0x74,0x55,0xf0,0xa3,0x74,0x1, 0xf0,0xe4,0xa3,0xf0,
+0x74,0x22,0x51,0x7c,0x74,0x79,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0x90,0xc, 0x20,0x4,
+0xf0,0x90,0xc, 0x1f,0x74,0xc8,0xf0,0x90,0xc, 0x24,0x74,0x64,0xf0,0xa3,0x74,0x28,
+0xf0,0x12,0x15,0xb1,0xe4,0x12,0x1, 0xc5,0x12,0x15,0xb1,0x4, 0x51,0xa3,0x90,0x0,
+0x9, 0xe4,0x12,0x1, 0xd7,0x74,0x10,0x51,0x8e,0x74,0x6, 0x12,0x1, 0xd7,0x74,0x28,
+0x51,0x84,0x74,0x28,0x12,0x1, 0xd7,0x90,0x0, 0x8, 0x74,0xc8,0x12,0x1, 0xd7,0x90,
+0x0, 0xa, 0x74,0x1, 0x12,0x1, 0xd7,0x31,0x1b,0x12,0x17,0x63,0xe4,0x75,0xf0,0x50,
+0x12,0x3, 0x3c,0x12,0x17,0x63,0x90,0x0, 0x2, 0x74,0x14,0x12,0x1, 0xd7,0x90,0x0,
+0x3, 0xe4,0x75,0xf0,0x3c,0x12,0x3, 0x5b,0x90,0x0, 0x22,0x74,0x10,0x12,0x1, 0xd7,
+0x90,0x0, 0x15,0x74,0x3, 0x12,0x1, 0xd7,0x90,0x0, 0x16,0x74,0x3, 0x12,0x1, 0xd7,
+0x90,0x0, 0x1a,0xe4,0x12,0x1, 0xd7,0x90,0x0, 0x1b,0x74,0xe, 0x12,0x1, 0xd7,0x90,
+0x0, 0x17,0xe4,0x12,0x1, 0xd7,0x90,0x0, 0x1c,0xe4,0x75,0xf0,0xfa,0x12,0x3, 0x5b,
+0x90,0x0, 0x1e,0x12,0xf, 0xf5,0x74,0x5, 0x12,0x1, 0xd7,0x90,0x0, 0x20,0x74,0x23,
+0x12,0x1, 0xd7,0x51,0x98,0x74,0x3, 0x12,0x1, 0xd7,0x90,0x0, 0x11,0xe4,0x12,0x1,
+0xd7,0x90,0x0, 0x12,0x74,0x4, 0x12,0x1, 0xd7,0x90,0x0, 0x13,0x51,0x75,0x90,0x0,
+0xb, 0x51,0x75,0x90,0x0, 0xd, 0x74,0x28,0x12,0x1, 0xd7,0x12,0x15,0x1c,0x74,0x5,
+0x12,0x1, 0xc5,0x12,0x15,0x1c,0x90,0x0, 0x1, 0x74,0xa, 0x75,0xf0,0x0, 0x12,0x3,
+0x5b,0x74,0xa0,0x51,0x8e,0x74,0x32,0x12,0x1, 0xd7,0x74,0x32,0x51,0x84,0xe4,0x75,
+0xf0,0xc8,0x2, 0x3, 0x5b,0xe4,0x75,0xf0,0x64,0x2, 0x3, 0x5b,0xa3,0xf0,0xa3,0x74,
+0x1, 0xf0,0xa3,0x22,0x90,0x0, 0x5, 0x12,0x1, 0xd7,0x90,0x0, 0x6, 0x22,0x90,0x0,
+0x3, 0x12,0x1, 0xd7,0x90,0x0, 0x4, 0x22,0x90,0x0, 0xf, 0xe4,0x12,0x1, 0xd7,0x90,
+0x0, 0x10,0x22,0x90,0x0, 0x1, 0x2, 0x1, 0xd7,0xef,0x70,0x3, 0xd2,0x84,0x22,0xc2,
+0x84,0x22,0xab,0x21,0xe5,0x23,0x24,0x4f,0xf9,0xe4,0x35,0x22,0xfa,0x2, 0x1, 0x4c,
+0xef,0x70,0x3, 0x43,0x87,0x1, 0xbf,0x1, 0x3, 0x43,0x87,0x2, 0xbf,0x2, 0x3, 0x43,
+0x87,0x2, 0x22,0x12,0x17,0xfa,0xe4,0xf5,0x2b,0x12,0x15,0xb1,0x91,0x59,0x60,0x8,
+0x90,0x0, 0x2e,0x12,0x1, 0x65,0x60,0x3, 0x7f,0x0, 0x22,0x12,0x1, 0x4c,0xc3,0x13,
+0xf5,0x28,0x12,0x47,0xbf,0xc3,0x13,0xf5,0x29,0xe4,0xf5,0x2a,0xf5,0x27,0x12,0x17,
+0x63,0x91,0x3a,0x75,0xf0,0x2, 0xe5,0x27,0x12,0x15,0x59,0x12,0x0, 0x6, 0xd3,0x12,
+0x45,0x5, 0x94,0x80,0x40,0x2, 0x5, 0x2a,0x91,0x32,0x40,0xe2,0xe5,0x2a,0xd3,0x94,
+0x6, 0x40,0x4, 0x91,0x45,0xf5,0x2b,0xe4,0xf5,0x2a,0xe5,0x28,0xd3,0x94,0x0, 0x40,
+0x3e,0xe4,0xf5,0x27,0x12,0x17,0x63,0x91,0x3a,0x75,0xf0,0x2, 0xe5,0x27,0x12,0x15,
+0x59,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0xe5,0x28,0x75,0xf0,0x20,0xa4,0x24,0x60,
+0x91,0x50,0x12,0x17,0x63,0x75,0xf0,0x2, 0xe5,0x27,0x12,0x15,0x59,0x12,0x0, 0x6,
+0xd0,0x5, 0xd0,0x4, 0x12,0x3f,0x95,0x40,0x2, 0x5, 0x2a,0x91,0x32,0x40,0xc5,0xe5,
+0x2a,0xd3,0x94,0x6, 0x40,0x4, 0x91,0x45,0xf5,0x2b,0xe4,0xf5,0x2a,0xe5,0x28,0xc3,
+0x94,0xe, 0x50,0x3e,0xe4,0xf5,0x27,0x12,0x17,0x63,0x91,0x3a,0x75,0xf0,0x2, 0xe5,
+0x27,0x12,0x15,0x59,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0xe5,0x28,0x75,0xf0,0x20,
+0xa4,0x24,0xa0,0x91,0x50,0x12,0x17,0x63,0x75,0xf0,0x2, 0xe5,0x27,0x12,0x15,0x59,
+0x12,0x0, 0x6, 0xd0,0x5, 0xd0,0x4, 0x12,0x3f,0x95,0x40,0x2, 0x5, 0x2a,0x91,0x32,
+0x40,0xc5,0xe5,0x2a,0xd3,0x94,0x6, 0x40,0x4, 0x91,0x45,0xf5,0x2b,0xe5,0x29,0xd3,
+0x94,0x0, 0x40,0x24,0xe5,0x28,0x75,0xf0,0x20,0x12,0x1b,0xe7,0xe5,0x29,0x75,0xf0,
+0x2, 0xa4,0x24,0x7e,0xff,0xe5,0xf0,0x34,0x3, 0xfe,0x12,0x38,0xc5,0x12,0x47,0x98,
+0x50,0x6, 0x74,0xa, 0x25,0x2b,0xf5,0x2b,0xe5,0x29,0x24,0x1, 0xff,0xe4,0x33,0xfe,
+0xc3,0xef,0x94,0xf, 0xee,0x64,0x80,0x94,0x80,0x50,0x24,0xe5,0x28,0x75,0xf0,0x20,
+0x12,0x1b,0xe7,0xe5,0x29,0x75,0xf0,0x2, 0xa4,0x24,0x82,0xff,0xe5,0xf0,0x34,0x3,
+0xfe,0x12,0x38,0xc5,0x12,0x47,0x98,0x50,0x6, 0x74,0xa, 0x25,0x2b,0xf5,0x2b,0xaf,
+0x2b,0x22,0x5, 0x27,0xe5,0x27,0xc3,0x94,0xa, 0x22,0xe5,0x28,0x90,0x3, 0x80,0x75,
+0xf0,0x20,0x2, 0x5, 0x40,0xe5,0x2a,0x24,0xfa,0x75,0xf0,0xa, 0xa4,0x25,0x2b,0x22,
+0xf5,0x82,0x74,0x3, 0x35,0xf0,0xf5,0x83,0x22,0x90,0x0, 0x2d,0x2, 0x1, 0x65,0x12,
+0x17,0xfa,0x75,0x2f,0x1, 0x12,0x15,0x9f,0xb1,0x6d,0x8f,0x2d,0x12,0x15,0x9f,0xd1,
+0x6c,0x8f,0x2e,0x12,0x15,0x1c,0x90,0x7, 0xa4,0x12,0x1, 0x65,0xff,0x70,0x49,0x4,
+0xb1,0x61,0xe5,0x2d,0xb4,0x2, 0xd, 0x90,0x7, 0x9d,0x74,0x6, 0x12,0x1, 0xd7,0xe4,
+0xf5,0x2f,0x80,0x2e,0x12,0x17,0x63,0x91,0x59,0x70,0x1f,0xb1,0x67,0x70,0x1b,0x90,
+0xc, 0xc7,0xe0,0xc3,0x94,0x2, 0x40,0xa, 0xe4,0xf0,0x12,0x15,0x1c,0x90,0x7, 0xa4,
+0x80,0x45,0x90,0xc, 0xc7,0xe0,0x4, 0xf0,0xa1,0x4b,0x12,0x15,0x1c,0x74,0x4, 0xb1,
+0x61,0xe4,0x90,0xc, 0xc7,0xf0,0xa1,0x4b,0xef,0x64,0x1, 0x70,0x53,0x12,0x15,0x1c,
+0xb1,0x61,0xe5,0x2e,0x60,0x5, 0x90,0x7, 0xa4,0x80,0x5d,0xe5,0x2d,0xb4,0x2, 0x6,
+0x90,0x7, 0x9d,0xe4,0x80,0x62,0x12,0x17,0x63,0x91,0x59,0x70,0xd, 0xb1,0x67,0x70,
+0x9, 0x12,0x15,0x1c,0x90,0x7, 0x9d,0x4, 0x80,0x4e,0x85,0x27,0x33,0x85,0x28,0x34,
+0x85,0x29,0x35,0x85,0x2a,0x36,0x85,0x2b,0x37,0x85,0x2c,0x38,0x85,0x24,0x39,0x85,
+0x25,0x3a,0x85,0x26,0x3b,0x12,0x17,0x63,0x12,0x2b,0xe, 0xe4,0xf5,0x2f,0x80,0x2b,
+0x12,0x15,0x1c,0x90,0x7, 0xa4,0x12,0x1, 0x65,0xb4,0x3, 0x1f,0xe5,0x2e,0x24,0xfe,
+0x60,0xa, 0x4, 0x70,0xe, 0x90,0x7, 0x9d,0x74,0x3, 0x80,0xc, 0x90,0x7, 0x9d,0x74,
+0x2, 0x80,0x5, 0x90,0x7, 0xa4,0x74,0x1, 0x12,0x1, 0xd7,0xe5,0x2f,0xb4,0x1, 0x10,
+0x12,0x17,0x63,0x90,0x0, 0x80,0xe4,0xf1,0x93,0x90,0x0, 0x82,0xe4,0x12,0x1, 0xd7,
+0x22,0x90,0x7, 0x9d,0x2, 0x1, 0xd7,0x90,0x0, 0x86,0x2, 0x1, 0x65,0x12,0x1, 0x4c,
+0xf5,0x39,0x90,0xc, 0xc6,0xe0,0xc3,0x94,0x1, 0x50,0x5, 0xe0,0x4, 0xf0,0xc1,0x50,
+0xe4,0x90,0xc, 0xc6,0xf0,0xaa,0x34,0xa9,0x35,0xae,0x2, 0xaf,0x1, 0x8e,0x3f,0x8f,
+0x40,0xf1,0x9d,0xf5,0x41,0x8f,0x42,0xe4,0xf5,0x39,0xe4,0xf5,0x3b,0xf5,0x3c,0x75,
+0x3d,0x7f,0x75,0x3e,0xff,0x90,0x0, 0x1a,0xf1,0x78,0xfd,0x75,0xf0,0x10,0xa4,0xff,
+0xae,0xf0,0xe5,0x39,0x7a,0x0, 0x2f,0xf5,0x44,0xea,0x3e,0xf5,0x43,0x8d,0x3a,0x90,
+0x0, 0x1b,0xd1,0x63,0xff,0xe5,0x3a,0xd3,0x9f,0x50,0x4b,0xe5,0x44,0x25,0xe0,0xff,
+0xe5,0x43,0x33,0xfe,0xe5,0x40,0x2f,0xf5,0x82,0xe5,0x3f,0x12,0x3b,0x1b,0xe5,0x42,
+0x2f,0xf5,0x82,0xe5,0x41,0x12,0x47,0x62,0x2d,0xff,0xee,0x3c,0xfe,0xd3,0xef,0x95,
+0x3c,0xee,0x95,0x3b,0x40,0x4, 0x8e,0x3b,0x8f,0x3c,0xc3,0xef,0x95,0x3e,0xee,0x95,
+0x3d,0x50,0x4, 0x8e,0x3d,0x8f,0x3e,0x74,0x10,0x25,0x44,0xf5,0x44,0xe4,0x35,0x43,
+0xf5,0x43,0x5, 0x3a,0x80,0xa9,0x12,0x2e,0x10,0x90,0x0, 0x1c,0x12,0x2, 0xb7,0xff,
+0xc3,0xe5,0x3c,0x95,0x3e,0xfd,0xe5,0x3b,0x95,0x3d,0xfc,0xd3,0xed,0x9f,0xec,0x95,
+0xf0,0x40,0x8, 0x90,0xc, 0xc5,0x74,0x2, 0xf0,0x80,0xa, 0x5, 0x39,0xe5,0x39,0x64,
+0xa, 0x60,0x2, 0xa1,0x9a,0xe5,0x39,0xb4,0xa, 0x6, 0x90,0xc, 0xc5,0x74,0x1, 0xf0,
+0x90,0xc, 0xc5,0xe0,0xff,0x22,0xab,0x33,0xaa,0x34,0xa9,0x35,0xe4,0x12,0x1, 0xd7,
+0x90,0x0, 0x1f,0xab,0x36,0xaa,0x37,0xa9,0x38,0x2, 0x1, 0x65,0x8b,0x30,0x8a,0x31,
+0x89,0x32,0x12,0x1, 0x4c,0x13,0x13,0x54,0x3f,0xf5,0x3b,0x12,0x47,0xbf,0x13,0x13,
+0x54,0x3f,0xf5,0x3c,0xe4,0xf5,0x3d,0xf5,0x3e,0xf5,0x3f,0xf5,0x39,0xab,0x30,0xaa,
+0x31,0xa9,0x32,0x12,0x1, 0x4c,0xff,0xe5,0x39,0xc3,0x9f,0x50,0x4e,0xe4,0xf5,0x3a,
+0x90,0x0, 0x1, 0xf1,0x81,0xff,0xe5,0x3a,0xc3,0x9f,0x50,0x37,0xf1,0x58,0xfd,0xd3,
+0xef,0x9d,0x74,0x80,0xf8,0x65,0xf0,0x98,0x40,0x4, 0x5, 0x3d,0x80,0x1b,0xf1,0x58,
+0xfd,0xc3,0xe4,0x9d,0xfd,0xe4,0x94,0x0, 0xfc,0xc3,0xef,0x9d,0xec,0x64,0x80,0xf8,
+0xe5,0xf0,0x64,0x80,0x98,0x50,0x2, 0x5, 0x3e,0x5, 0x3f,0xe5,0x3c,0x25,0x3a,0xf5,
+0x3a,0x80,0xbd,0xe5,0x3b,0x25,0x39,0xf5,0x39,0x80,0xa2,0xe5,0x3f,0xc3,0x13,0xff,
+0xe5,0x3d,0xd3,0x9f,0x40,0x1d,0x90,0x7, 0x9f,0xd1,0x56,0xfe,0x90,0x7, 0x9e,0xf1,
+0x8a,0xc3,0x9e,0x90,0x7, 0x9e,0x50,0x2, 0x80,0x21,0xe4,0x12,0x1, 0xd7,0x75,0x14,
+0x1, 0x80,0x38,0xe5,0x3e,0xd3,0x9f,0x40,0x22,0x90,0x7, 0x9e,0xd1,0x56,0xff,0xf1,
+0x4e,0x12,0x1, 0x65,0xc3,0x9f,0x90,0x7, 0x9f,0x50,0x7, 0x74,0x1, 0x12,0x1, 0x92,
+0x80,0x19,0xe4,0x12,0x1, 0xd7,0x75,0x14,0x2, 0x80,0x10,0xf1,0x4e,0xe4,0x12,0x1,
+0xd7,0x90,0x7, 0x9e,0xe4,0x12,0x1, 0xd7,0xe4,0xf5,0x14,0xaf,0x14,0x22,0xab,0x33,
+0xaa,0x34,0xa9,0x35,0x90,0x7, 0x9f,0x22,0xab,0x33,0xaa,0x34,0xa9,0x35,0x90,0x3,
+0x80,0x75,0xf0,0x20,0xe5,0x39,0x12,0x5, 0x40,0x75,0xf0,0x2, 0xe5,0x3a,0x12,0x5,
+0x40,0x12,0x2, 0xb7,0xff,0x90,0x0, 0x1e,0xab,0x36,0xaa,0x37,0xa9,0x38,0x2, 0x1,
+0x65,0xab,0x30,0xaa,0x31,0xa9,0x32,0x2, 0x1, 0x65,0xab,0x33,0xaa,0x34,0xa9,0x35,
+0x2, 0x1, 0x65,0x12,0x1, 0xd7,0x90,0x0, 0x81,0xe4,0x2, 0x1, 0xd7,0xe9,0x24,0x80,
+0xf9,0xea,0x34,0x3, 0xaf,0x1, 0x22,0xef,0xd3,0x94,0x3f,0x50,0x2d,0xef,0x24,0xfd,
+0x60,0x28,0x14,0x60,0x25,0x24,0xe1,0x60,0x21,0x24,0xfd,0x60,0x1d,0x24,0xfe,0x60,
+0x19,0x24,0xf9,0x60,0x15,0x80,0x0, 0x74,0xf1,0x2f,0xf5,0x82,0xe4,0x34,0xb, 0xf5,
+0x83,0xed,0xf0,0x90,0xc, 0x31,0xe0,0x44,0x1, 0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,
+0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x0, 0xc0,0x0, 0xc0,0x1, 0xc0,0x2, 0xc0,0x3,
+0xc0,0x4, 0xc0,0x5, 0xc0,0x6, 0xc0,0x7, 0xe5,0xc9,0x54,0x3, 0xff,0xbf,0x1, 0x6,
+0x53,0xc9,0xfc,0x43,0xc9,0x2, 0x12,0x32,0x0, 0x30,0x95,0x2, 0xc2,0x95,0x30,0x94,
+0x2, 0xc2,0x94,0x90,0xc, 0x68,0x74,0x1, 0xf0,0xd0,0x7, 0xd0,0x6, 0xd0,0x5, 0xd0,
+0x4, 0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,
+0xf0,0xd0,0xe0,0x32,0xc0,0xe0,0xc0,0x83,0xc0,0x82,0xc2,0x93,0x90,0xc, 0x67,0xe4,
+0xf0,0x90,0xc, 0x69,0xf0,0xd0,0x82,0xd0,0x83,0xd0,0xe0,0x32,0x8f,0x67,0x8d,0x68,
+0xe5,0x67,0x12,0x5, 0x9c,0x50,0x7d,0x0, 0x50,0xa2,0x1, 0x50,0xb9,0x2, 0x50,0xd1,
+0x3, 0x50,0xd6,0x4, 0x50,0xdb,0x5, 0x50,0xe0,0x6, 0x50,0xe5,0x7, 0x50,0xea,0x4c,
+0x50,0xf4,0x4e,0x50,0xf9,0x4f,0x50,0xef,0xea,0x0, 0x0, 0x51,0x16,0x31,0xaa,0xf5,
+0x68,0x64,0x4, 0x60,0xd, 0x90,0xc, 0x18,0xe0,0x7d,0x1, 0xb4,0x3, 0x2, 0x80,0x30,
+0x80,0xb, 0x90,0xc, 0x18,0xe0,0x7d,0x3, 0xb4,0x3, 0x2, 0x80,0x23,0x7f,0x27,0x2,
+0x4f,0xa7,0x90,0xc, 0x6a,0xe5,0x68,0xf0,0xe0,0x75,0xf0,0x20,0xa4,0xae,0xf0,0x25,
+0x10,0xf5,0x9, 0xee,0x35,0xf, 0xf5,0x8, 0x22,0xe5,0x68,0xb4,0x4, 0x6, 0x7d,0x4,
+0x7f,0x1, 0x80,0xa, 0xe5,0x68,0x64,0x5, 0x60,0x2, 0x21,0xa1,0xfd,0xff,0x2, 0x36,
+0x74,0x90,0xa, 0xe5,0x21,0x9e,0x90,0xa, 0xe6,0x21,0x9e,0x90,0xa, 0xe7,0x21,0x9e,
+0x90,0xa, 0xe8,0x21,0x9e,0x90,0xa, 0xe9,0x21,0x9e,0x90,0xa, 0xf2,0x21,0x9e,0x90,
+0xc, 0x9b,0x21,0x9e,0x90,0xb, 0x57,0x21,0x9e,0x90,0xc, 0x32,0xe0,0x60,0xb, 0x7f,
+0x1, 0x12,0x1d,0xa7,0xe4,0x90,0xc, 0x32,0xf0,0x22,0xe4,0xff,0x12,0x1d,0xa7,0x90,
+0xc, 0x32,0x74,0x1, 0xf0,0x22,0xe5,0x67,0xc3,0x94,0x50,0x40,0x17,0xe5,0x67,0xd3,
+0x94,0x77,0x50,0x10,0x7d,0x77,0xaf,0x68,0x12,0x6, 0xd3,0x74,0xa5,0x25,0x67,0x31,
+0xa2,0xef,0xf0,0x22,0xe5,0x67,0xc3,0x94,0x78,0x40,0x14,0xe5,0x67,0xd3,0x94,0x9f,
+0x50,0xd, 0x74,0x99,0x25,0x67,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x80,0x4f,0xe5,
+0x67,0xc3,0x94,0xa0,0x40,0x14,0xe5,0x67,0xd3,0x94,0xbe,0x50,0xd, 0x74,0x8d,0x25,
+0x67,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x80,0x34,0xe5,0x67,0xc3,0x94,0xbf,0x40,
+0x14,0xe5,0x67,0xd3,0x94,0xd2,0x50,0xd, 0x74,0x7e,0x25,0x67,0xf5,0x82,0xe4,0x34,
+0xa, 0xf5,0x83,0x80,0x19,0xe5,0x67,0xc3,0x94,0xd3,0x40,0x15,0xe5,0x67,0xd3,0x94,
+0xe1,0x50,0xe, 0x74,0x78,0x25,0x67,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0xe5,0x68,
+0xf0,0x22,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x7b,0x1, 0x7a,0xc, 0x79,0x6c,
+0xe5,0x68,0x12,0x1, 0xc5,0x53,0x68,0x70,0xe5,0x68,0xc4,0x54,0xf, 0x22,0x8b,0x31,
+0x8a,0x32,0x89,0x33,0xe4,0xff,0xab,0x31,0xe5,0x33,0x24,0x28,0xf9,0xe4,0x35,0x32,
+0xfa,0xef,0xfd,0x12,0x25,0xec,0x74,0x3, 0x12,0x1, 0xc5,0xab,0x31,0xe5,0x33,0x24,
+0x23,0xf9,0xe4,0x35,0x32,0x51,0x1e,0x90,0x0, 0x2d,0x51,0x9, 0x90,0x0, 0x37,0x51,
+0x9, 0xf, 0xbf,0x5, 0xd1,0xab,0x31,0xaa,0x32,0xa9,0x33,0x90,0x0, 0x41,0xe4,0x12,
+0x1, 0xd7,0x90,0x0, 0x42,0xe4,0x2, 0x1, 0xd7,0xab,0x31,0xaa,0x32,0xa9,0x33,0xef,
+0x75,0xf0,0x2, 0x12,0x5, 0x40,0x74,0x7f,0x75,0xf0,0xff,0x2, 0x3, 0x5b,0xfa,0xe9,
+0x2d,0xf9,0xec,0x3a,0xfa,0x74,0x3, 0x2, 0x1, 0xc5,0x53,0xdb,0xbf,0x22,0x51,0x2a,
+0x7f,0x1, 0x51,0x4d,0x51,0x85,0x51,0x60,0x51,0x45,0x7f,0x1, 0xef,0x70,0x3, 0xc2,
+0xaf,0x22,0xd2,0xaf,0x22,0x75,0x92,0xe8,0xd2,0xae,0xd2,0xbe,0x22,0x53,0xc9,0xf8,
+0xef,0x70,0x5, 0x43,0xc9,0x3, 0x80,0x3, 0x43,0xc9,0x2, 0xc2,0xce,0xc2,0xca,0x22,
+0xe4,0xff,0xa2,0xaf,0x33,0xfe,0xc2,0x88,0xd2,0xa8,0xc2,0xaf,0x30,0x89,0x6, 0xc2,
+0x89,0xe4,0xff,0x80,0x1, 0xf, 0xef,0xd3,0x94,0xfa,0x40,0xf0,0xee,0x24,0xff,0x92,
+0xaf,0x75,0xf7,0xff,0x22,0x85,0xe6,0x21,0xe4,0xf5,0x22,0x75,0x99,0x1, 0xd2,0x98,
+0x7f,0x2, 0x7e,0x78,0x12,0x34,0x17,0x8f,0x23,0x7f,0x3, 0x7e,0x78,0x12,0x34,0x17,
+0xe5,0x23,0xf4,0x60,0xa, 0xe5,0x23,0x6f,0xff,0xbf,0xff,0x3, 0x85,0x23,0x22,0xe5,
+0x21,0xb4,0xff,0x3, 0x75,0x21,0x6a,0xe5,0x22,0xb4,0x1, 0xf, 0xe5,0x21,0x64,0x6a,
+0x60,0x18,0xe5,0x21,0xb4,0x6b,0x2, 0x80,0x11,0x80,0xb, 0xe5,0x21,0x64,0x6a,0x60,
+0x5, 0xe5,0x21,0xb4,0x6b,0x4, 0x53,0xea,0x7f,0x22,0x43,0xea,0x80,0x22,0xc0,0xe0,
+0xc0,0xf0,0xc0,0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x0, 0xc0,0x0, 0xc0,0x1, 0xc0,
+0x2, 0xc0,0x3, 0xc0,0x4, 0xc0,0x5, 0xc0,0x6, 0xc0,0x7, 0x12,0x30,0xf0,0x90,0xc,
+0x6c,0xe0,0x54,0xfd,0xf0,0xd0,0x7, 0xd0,0x6, 0xd0,0x5, 0xd0,0x4, 0xd0,0x3, 0xd0,
+0x2, 0xd0,0x1, 0xd0,0x0, 0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,
+0x2, 0x37,0xad,0x7d,0x66,0x7f,0xf8,0x7e,0x6f,0x12,0x37,0x5c,0x7d,0xbb,0x7f,0xf9,
+0x7e,0x6f,0x2, 0x37,0x5c,0x7e,0x0, 0x7c,0x0, 0x12,0x1d,0xdd,0xeb,0xfd,0xd3,0xef,
+0x9d,0xee,0x9c,0x7f,0x0, 0x50,0x2, 0x7f,0x1, 0x22,0x3e,0xf5,0x83,0x7b,0x2, 0xaf,
+0x41,0xe0,0xfd,0x71,0x35,0xef,0x22,0xfd,0xaf,0x3d,0x71,0x35,0xef,0x22,0xaf,0x42,
+0xe0,0xfd,0x71,0x35,0xef,0x22,0x12,0x1, 0x65,0xaf,0x3c,0xfd,0x7b,0x2, 0x71,0x35,
+0xef,0x22,0x12,0x17,0xfa,0xe4,0xf5,0x2d,0xf5,0x2e,0xf5,0x2f,0x12,0x64,0x92,0xf5,
+0x3b,0x75,0x3c,0xff,0xf5,0x41,0xf5,0x42,0x12,0x15,0x1c,0x90,0x0, 0xb, 0x12,0x2,
+0xb7,0xf5,0x46,0x85,0xf0,0x45,0xe4,0xf5,0x47,0xf5,0x48,0x12,0x1f,0xed,0xf5,0x4a,
+0x85,0xf0,0x49,0x12,0x65,0x55,0xf5,0x43,0x8f,0x44,0xe4,0xf5,0x2d,0x12,0x15,0xb1,
+0x12,0x66,0xf, 0x40,0x3, 0x2, 0x58,0x43,0xe5,0x2d,0x75,0xf0,0x10,0xa4,0x85,0xf0,
+0x3f,0xf5,0x40,0xe4,0xf5,0x2e,0x12,0x17,0xdc,0xff,0xe5,0x2e,0xc3,0x9f,0x40,0x3,
+0x2, 0x58,0x3e,0x12,0x5a,0x87,0x12,0x65,0xba,0x95,0x46,0xee,0x95,0x45,0x40,0x2,
+0x5, 0x47,0x12,0x5a,0x87,0x12,0x65,0xba,0x95,0x4a,0xe5,0x49,0x12,0x43,0x3b,0x50,
+0x3, 0x2, 0x58,0x31,0xe5,0x2d,0x70,0x6, 0xf5,0x2f,0xf5,0x30,0x80,0x15,0xe5,0x40,
+0x24,0xf0,0xff,0xe5,0x3f,0x34,0xff,0x12,0x2f,0xea,0x12,0x5a,0x8e,0xf5,0x2f,0xa3,
+0xe0,0xf5,0x30,0x12,0x15,0xb1,0x12,0x1, 0x4c,0x14,0xb5,0x2d,0x7, 0xe4,0xf5,0x31,
+0xf5,0x32,0x80,0x14,0xe5,0x40,0x24,0x10,0xff,0xe4,0x35,0x3f,0x12,0x2f,0xea,0x12,
+0x5a,0x8e,0xf5,0x31,0xa3,0xe0,0xf5,0x32,0xe5,0x2e,0x70,0x6, 0xf5,0x35,0xf5,0x36,
+0x80,0x15,0xe5,0x40,0x24,0xff,0xff,0xe5,0x3f,0x34,0xff,0x12,0x2f,0xea,0x12,0x5a,
+0x8e,0xf5,0x35,0xa3,0xe0,0xf5,0x36,0x12,0x47,0xbf,0x14,0xb5,0x2e,0x7, 0xe4,0xf5,
+0x33,0xf5,0x34,0x80,0x14,0xe5,0x40,0x24,0x1, 0xff,0xe4,0x35,0x3f,0x12,0x2f,0xea,
+0x12,0x5a,0x8e,0xf5,0x33,0xa3,0xe0,0xf5,0x34,0x12,0x5a,0x87,0xfe,0xc3,0xee,0x64,
+0x80,0x94,0x80,0x50,0x2b,0xe5,0x30,0x95,0x32,0xe5,0x31,0x12,0x62,0xf8,0x40,0x6,
+0x85,0x31,0x2f,0x85,0x32,0x30,0xd3,0xe5,0x30,0x95,0x34,0xe5,0x33,0x12,0x62,0xf8,
+0x40,0x6, 0x85,0x33,0x2f,0x85,0x34,0x30,0xd3,0x12,0x62,0xf2,0x40,0x32,0x80,0x2a,
+0xc3,0xe5,0x30,0x95,0x32,0xe5,0x31,0x12,0x62,0xf8,0x50,0x6, 0x85,0x31,0x2f,0x85,
+0x32,0x30,0xc3,0xe5,0x30,0x95,0x34,0xe5,0x33,0x12,0x62,0xf8,0x50,0x6, 0x85,0x33,
+0x2f,0x85,0x34,0x30,0xc3,0x12,0x62,0xf2,0x50,0x6, 0x85,0x35,0x2f,0x85,0x36,0x30,
+0xe5,0x2d,0x25,0xe0,0xf5,0x41,0xe5,0x2e,0x25,0xe0,0xf5,0x42,0xc3,0xee,0x64,0x80,
+0x94,0x80,0x40,0x2, 0xa1,0xbc,0x12,0x5a,0x87,0x12,0x43,0x32,0x40,0x2, 0xa1,0xb1,
+0xc3,0xe4,0x95,0x4a,0xfd,0xe4,0x95,0x49,0xfc,0xd3,0xef,0x9d,0xec,0x12,0x43,0x3b,
+0x40,0x2, 0xa1,0xb1,0xe5,0x48,0x70,0x9, 0x90,0xa, 0x86,0xe5,0x41,0xf0,0xa3,0xa1,
+0xac,0xe5,0x48,0xc3,0x94,0x5, 0x40,0x5, 0x75,0x48,0x5, 0xa1,0xb1,0xe4,0xf5,0x3c,
+0x12,0x66,0x18,0xed,0x95,0x48,0x74,0x80,0xf8,0x6c,0x98,0x50,0x5f,0x12,0x3f,0xaf,
+0x12,0x66,0x67,0x71,0x4a,0x60,0x51,0x12,0x2f,0xe4,0x33,0xfe,0x12,0x65,0x79,0xaf,
+0x42,0x71,0x51,0x60,0x43,0xaf,0x3c,0x12,0x63,0xcc,0x25,0xe0,0xfd,0xee,0x33,0xfc,
+0x74,0x86,0x2d,0xf5,0x82,0x74,0xa, 0x12,0x5a,0xc4,0xff,0x74,0x87,0x2d,0xf5,0x82,
+0x74,0xa, 0x12,0x5a,0x63,0xfe,0xa3,0xe0,0xff,0xc3,0x12,0x3f,0x96,0x50,0x14,0x12,
+0x2f,0xe4,0x33,0xfe,0x12,0x66,0x67,0x3e,0xf5,0x83,0xe5,0x41,0xf0,0x12,0x65,0x79,
+0xe5,0x42,0xf0,0x75,0x3c,0xff,0x80,0x4, 0x5, 0x3c,0x80,0x94,0xe5,0x48,0xb5,0x3c,
+0x10,0x12,0x5b,0x5b,0xe5,0x41,0xf0,0xe5,0x48,0x12,0x5b,0x4f,0xe5,0x42,0xf0,0x5,
+0x48,0x5, 0x40,0xe5,0x40,0x70,0x2, 0x5, 0x3f,0x2, 0x58,0x39,0x12,0x5a,0x87,0xfe,
+0xa3,0xe0,0xff,0xc3,0x12,0x43,0x37,0x50,0x3, 0x2, 0x58,0x31,0xef,0x95,0x4a,0xe5,
+0x49,0x12,0x43,0x3b,0x50,0x3, 0x2, 0x58,0x31,0xe5,0x3b,0x70,0xa, 0x90,0xa, 0x36,
+0xe5,0x41,0xf0,0xa3,0x2, 0x58,0x2c,0xe5,0x3b,0xc3,0x94,0x14,0x40,0x6, 0x75,0x3b,
+0x14,0x2, 0x58,0x31,0xe4,0xf5,0x3c,0x12,0x66,0x18,0xed,0x95,0x3b,0x74,0x80,0xf8,
+0x6c,0x98,0x40,0x3, 0x2, 0x58,0x1d,0xed,0x25,0xe0,0xff,0xec,0x12,0x5a,0xcf,0x71,
+0x4a,0x60,0x35,0x12,0x2f,0xe4,0x12,0x5a,0xd9,0x71,0x5e,0x60,0x2b,0x12,0x5a,0xaf,
+0x12,0x66,0x44,0x12,0x5a,0x63,0xfe,0xa3,0xe0,0xff,0xc3,0x12,0x3f,0x96,0x40,0x3,
+0x2, 0x58,0x13,0x12,0x2f,0xe4,0x12,0x5a,0xcf,0x3e,0xf5,0x83,0xe5,0x41,0xf0,0x12,
+0x5a,0xdb,0xe5,0x42,0xf0,0x2, 0x58,0x13,0x12,0x2f,0xe4,0x12,0x5a,0xcf,0x3e,0xf5,
+0x83,0x7b,0x6, 0x71,0x4f,0x70,0x3, 0x2, 0x58,0x18,0x12,0x2f,0xe4,0x12,0x5a,0xd9,
+0x71,0x5e,0x70,0x3, 0x2, 0x58,0x18,0x12,0x2f,0xe4,0x12,0x5a,0xcf,0x3e,0xf5,0x83,
+0xe0,0xfd,0xc3,0x13,0x25,0x2d,0xf5,0x3d,0x12,0x5a,0xdb,0xe0,0xc3,0x13,0x25,0x2e,
+0xf5,0x3e,0xe4,0xf5,0x2f,0xf5,0x30,0xc3,0xe5,0x30,0x95,0x3b,0x74,0x80,0xf8,0x65,
+0x2f,0x98,0x50,0x39,0xaf,0x3c,0x12,0x63,0xcc,0x65,0x30,0x70,0x3, 0xee,0x65,0x2f,
+0x60,0x21,0x12,0x66,0x8f,0x12,0x5a,0xcf,0x3e,0xf5,0x83,0xe0,0xaf,0x3d,0x71,0x6b,
+0x60,0x11,0x12,0x66,0x8f,0x12,0x5a,0xd9,0xaf,0x3e,0x71,0x60,0x60,0x5, 0x75,0x3d,
+0xff,0x80,0xa, 0x5, 0x30,0xe5,0x30,0x70,0x2, 0x5, 0x2f,0x80,0xba,0xe5,0x3d,0xf4,
+0x70,0x3, 0x2, 0x58,0x18,0x12,0x5a,0xaf,0x12,0x66,0x44,0x3c,0xf5,0x83,0xe0,0xc3,
+0x13,0xf9,0x12,0x5a,0x69,0xfe,0xa3,0xe0,0xff,0x12,0x3f,0x95,0x40,0x15,0x12,0x2f,
+0xe4,0x12,0x5a,0xcf,0x3e,0x12,0x5a,0xc5,0xff,0xe9,0x2f,0x12,0x45,0x36,0x12,0x2f,
+0xea,0x80,0x7, 0xe5,0x40,0x25,0xe0,0xff,0xe5,0x3f,0x12,0x5a,0x8e,0xf5,0x31,0xa3,
+0xe0,0xf5,0x32,0xe5,0x32,0xae,0x31,0x78,0x2, 0x12,0x46,0x55,0xd8,0xfb,0xfd,0xac,
+0x6, 0xe5,0x31,0xa2,0xe7,0x13,0xfe,0xe5,0x32,0x13,0x2d,0xf5,0x32,0xee,0x3c,0xf5,
+0x31,0x12,0x15,0x1c,0x12,0x2, 0x8c,0xff,0xae,0xf0,0xc3,0xe5,0x32,0x9f,0xe5,0x31,
+0x9e,0x50,0x4, 0x8e,0x31,0x8f,0x32,0xaf,0x3d,0x12,0x63,0xcc,0x24,0x1, 0xff,0xe4,
+0x3e,0x12,0x5b,0x2e,0x12,0x62,0xc0,0xe5,0x3e,0xc3,0x13,0xfd,0x7c,0x0, 0x2f,0xff,
+0xec,0x3e,0x12,0x2f,0xea,0x12,0x5a,0x8e,0xfa,0xa3,0xe0,0xfb,0xe5,0x3d,0xa2,0xe7,
+0x13,0xf9,0xff,0x12,0x62,0xbb,0xef,0x2d,0xff,0xec,0x3e,0x12,0x2f,0xea,0x12,0x5a,
+0x8e,0xfe,0xa3,0xe0,0x2b,0xf5,0x34,0xee,0x3a,0xf5,0x33,0xa2,0xe7,0x13,0xf5,0x33,
+0xe5,0x34,0x13,0xf5,0x34,0xaf,0x3d,0x12,0x63,0xcc,0x24,0x1, 0xff,0xe4,0x3e,0x12,
+0x5b,0x2e,0x12,0x65,0x99,0xfd,0xee,0xc4,0x54,0xf0,0x48,0xfc,0x12,0x5b,0x27,0x2d,
+0xff,0xee,0x3c,0x12,0x2f,0xea,0x12,0x5a,0x8e,0xfc,0xa3,0xe0,0xfd,0xe9,0xff,0x33,
+0x95,0xe0,0xfe,0xef,0x12,0x65,0x99,0xfb,0xee,0xc4,0x54,0xf0,0x48,0xfa,0x12,0x5b,
+0x27,0x2b,0xff,0xee,0x3a,0x12,0x2f,0xea,0x12,0x5a,0x8e,0xfe,0xa3,0xe0,0x2d,0xf5,
+0x36,0xee,0x3c,0xf5,0x35,0xa2,0xe7,0x13,0xf5,0x35,0xe5,0x36,0x13,0xf5,0x36,0x25,
+0x34,0xff,0xe5,0x33,0x35,0x35,0x12,0x5b,0x2e,0xc3,0x95,0x32,0xe5,0x31,0x12,0x43,
+0x3b,0x40,0x15,0x12,0x2f,0xe4,0x51,0xcf,0x3e,0xf5,0x83,0xe5,0x3d,0xf0,0x51,0xdb,
+0xe5,0x3e,0xf0,0x75,0x3c,0xff,0x80,0x5, 0x5, 0x3c,0x2, 0x55,0xf7,0xe5,0x3b,0xb5,
+0x3c,0xf, 0x12,0x12,0x23,0xe5,0x41,0xf0,0xe5,0x3b,0x51,0x57,0xe5,0x42,0xf0,0x5,
+0x3b,0x5, 0x40,0xe5,0x40,0x70,0x2, 0x5, 0x3f,0x5, 0x2e,0x2, 0x53,0xc6,0x5, 0x2d,
+0x2, 0x53,0xad,0xe5,0x3b,0xd3,0x94,0x5, 0x50,0x2, 0x21,0x92,0xe4,0xf5,0x3d,0xf5,
+0x2d,0x12,0x47,0x4f,0xff,0xe5,0x2d,0xc3,0x9f,0x40,0x2, 0x21,0x4, 0x75,0x37,0x3,
+0x75,0x38,0xff,0xe4,0xf5,0x42,0xf5,0x2e,0xe5,0x2e,0xc3,0x95,0x3b,0x50,0x43,0xe5,
+0x2e,0x51,0x57,0x51,0xe6,0xe0,0xc3,0x12,0x2f,0xd1,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,
+0x7, 0xe5,0x2e,0x12,0x12,0x23,0x51,0xf6,0xe0,0xc3,0x12,0x2f,0xd1,0x12,0x0, 0x6,
+0xd0,0xe0,0x2f,0xf5,0x3a,0xd0,0xe0,0x3e,0xf5,0x39,0xc3,0xe5,0x3a,0x95,0x38,0xe5,
+0x39,0x95,0x37,0x50,0x9, 0x85,0x39,0x37,0x85,0x3a,0x38,0x85,0x2e,0x42,0x5, 0x2e,
+0x80,0xb6,0xe5,0x42,0x12,0x12,0x23,0x51,0xc7,0xff,0xe5,0x42,0x51,0x57,0xe0,0xc3,
+0x13,0x7c,0x0, 0x2f,0xff,0xec,0x35,0xf0,0x12,0x2f,0xea,0x51,0x8e,0x12,0x15,0x18,
+0x71,0x44,0x40,0x2c,0xe5,0x42,0x12,0x12,0x23,0xe0,0xfd,0xaf,0x3d,0x12,0x2f,0xe6,
+0x33,0xfe,0x74,0x5e,0x2f,0xf5,0x82,0x74,0xa, 0x71,0x1f,0x51,0x57,0xe0,0xfd,0x74,
+0x5f,0x2f,0xf5,0x82,0x74,0xa, 0x71,0x1f,0x12,0x12,0x23,0x74,0xff,0xf0,0x5, 0x3d,
+0x5, 0x2d,0x1, 0x51,0x85,0x3d,0x2d,0xe5,0x2d,0xc3,0x94,0x5, 0x50,0x63,0xe4,0xf5,
+0x2f,0xf5,0x30,0xf5,0x3e,0xf5,0x2e,0xe5,0x2e,0xc3,0x95,0x3b,0x50,0x3c,0xe5,0x2e,
+0x12,0x12,0x23,0xe0,0xff,0xf4,0x60,0x2e,0xef,0x51,0xc8,0xff,0xe5,0x2e,0x51,0x57,
+0xe0,0xfd,0xc3,0x13,0x7a,0x0, 0x2f,0xff,0xea,0x35,0xf0,0x12,0x2f,0xea,0x51,0x8e,
+0x12,0x43,0x32,0x40,0x11,0xe5,0x2e,0x12,0x12,0x23,0xe0,0xf5,0x41,0x8d,0x42,0x8e,
+0x2f,0x8f,0x30,0x85,0x2e,0x3e,0x5, 0x2e,0x80,0xbd,0xe5,0x2d,0x51,0xa3,0xe5,0x41,
+0x71,0x35,0xe5,0x42,0xf0,0xe5,0x3e,0x12,0x12,0x23,0x74,0xff,0xf0,0x5, 0x2d,0x80,
+0x96,0xe4,0xf5,0x2d,0xe5,0x2d,0x51,0xa3,0xe0,0xff,0xe5,0x2d,0x12,0x12,0x23,0xef,
+0x71,0x35,0xe0,0xff,0x51,0x55,0xef,0xf0,0x5, 0x2d,0xe5,0x2d,0xb4,0x5, 0xe5,0x75,
+0x3b,0x5, 0xe4,0xf5,0x2d,0x51,0xf8,0x74,0xff,0xf0,0x51,0xe8,0x74,0xff,0xf0,0x5,
+0x2d,0xe5,0x2d,0xb4,0x5, 0xef,0xe5,0x3b,0xd3,0x94,0x0, 0x40,0x3c,0xe4,0xf5,0x2d,
+0xe5,0x2d,0xc3,0x95,0x3b,0x50,0x32,0xe5,0x2d,0x12,0x12,0x23,0xe0,0xff,0xe5,0x2d,
+0x12,0x15,0x8f,0xef,0x12,0x1, 0xd7,0x51,0x55,0x71,0x17,0x12,0x2e,0x6, 0xfa,0x90,
+0x0, 0x1, 0xed,0x12,0x1, 0xd7,0xe5,0x2d,0x12,0x12,0x23,0x51,0xf6,0xef,0xf0,0x51,
+0x55,0x51,0xe6,0xef,0xf0,0x5, 0x2d,0x80,0xc7,0xe5,0x48,0xd3,0x94,0x0, 0x40,0x28,
+0xe4,0xf5,0x2d,0xe5,0x2d,0xc3,0x95,0x48,0x50,0x1e,0xe5,0x2d,0x71,0x5b,0x71,0x17,
+0x71,0xb, 0x90,0x0, 0x87,0xed,0x12,0x1, 0xd7,0xe5,0x2d,0x71,0x4f,0xe0,0x90,0x0,
+0x88,0x12,0x1, 0xd7,0x5, 0x2d,0x80,0xdb,0x90,0x0, 0x86,0xe5,0x48,0x71,0x67,0x90,
+0x0, 0x2d,0xe5,0x3b,0x12,0x1, 0xd7,0xe9,0x24,0x2f,0x71,0x73,0x54,0xfe,0x12,0x1,
+0xc5,0x12,0x15,0x1c,0x90,0x0, 0xd, 0x12,0x1, 0x65,0xff,0xe5,0x47,0xd3,0x9f,0x40,
+0x13,0xab,0x2a,0xe5,0x2c,0x24,0x2f,0xf9,0xe4,0x35,0x2b,0xfa,0x12,0x1, 0x4c,0x44,
+0x1, 0x12,0x1, 0xc5,0x22,0xe5,0x2d,0x25,0xe0,0x24,0x37,0xf5,0x82,0xe4,0x34,0xa,
+0xf5,0x83,0x22,0x3c,0xf5,0x83,0xe0,0xc3,0x13,0x7c,0x0, 0x2f,0xff,0xec,0x35,0xf0,
+0xfe,0xef,0x25,0xe0,0xff,0xee,0x33,0xfe,0xe5,0x44,0x2f,0xf5,0x82,0xe5,0x43,0x3e,
+0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xfd,0xe5,0x40,0x25,0xe0,0xff,0xe5,0x3f,0x33,0xfe,
+0xe5,0x44,0x2f,0xf5,0x82,0xe5,0x43,0x3e,0xf5,0x83,0xe0,0x22,0x12,0x4, 0xf2,0xe5,
+0x2f,0x25,0xe0,0x25,0xe0,0x24,0x5e,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0xaf,
+0x3c,0xef,0x33,0x95,0xe0,0xfe,0xef,0x25,0xe0,0xfd,0xee,0x33,0xfc,0x74,0x36,0x2d,
+0xf5,0x82,0x74,0xa, 0x3c,0xf5,0x83,0xe0,0xc3,0x13,0x75,0xf0,0x10,0xa4,0x22,0x33,
+0xfe,0x74,0x36,0x2f,0xf5,0x82,0x74,0xa, 0x22,0x33,0xfe,0x74,0x37,0x2f,0xf5,0x82,
+0x74,0xa, 0x3e,0xf5,0x83,0x22,0xe0,0xff,0xe5,0x2d,0x25,0xe0,0x24,0xbc,0xf5,0x82,
+0xe4,0x34,0xc, 0xf5,0x83,0x22,0xe0,0xff,0xe5,0x2d,0x25,0xe0,0x24,0xbb,0xf5,0x82,
+0xe4,0x34,0xc, 0xf5,0x83,0x22,0xe5,0x2f,0x75,0xf0,0x7, 0xa4,0xab,0x2a,0x25,0x2c,
+0xf9,0xe5,0x2b,0x35,0xf0,0xfa,0x22,0xe0,0xfd,0xe5,0x2d,0x75,0xf0,0x2, 0x22,0x3e,
+0xf5,0x83,0xed,0xf0,0xe5,0x42,0x22,0xe5,0x3e,0x24,0x1, 0xff,0xe4,0x33,0xa2,0xe7,
+0x13,0xfe,0xef,0x13,0x22,0xf0,0xe5,0x2d,0x25,0xe0,0x24,0x5f,0xf5,0x82,0xe4,0x34,
+0xa, 0xf5,0x83,0x22,0x12,0x2, 0x8c,0xfd,0xc3,0xef,0x9d,0xee,0x95,0xf0,0x22,0x25,
+0xe0,0x24,0x87,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x25,0xe0,0x24,0x86,0xf5,
+0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x2, 0x1, 0xd7,
+0xe9,0x24,0x4f,0xf9,0xe4,0x3a,0xfa,0x2, 0x1, 0x4c,0x12,0x17,0xfa,0xe4,0xf5,0x2d,
+0xf5,0x2e,0x12,0x64,0x92,0xf5,0x37,0xf5,0x38,0xf5,0x3c,0xf5,0x3d,0x12,0x15,0x1c,
+0x90,0x0, 0x13,0x12,0x2, 0xb7,0xf5,0x44,0x85,0xf0,0x43,0x90,0x0, 0x22,0x12,0x1,
+0x65,0xf5,0x47,0x12,0x65,0x55,0xf5,0x3e,0x8f,0x3f,0x12,0x47,0x84,0xaf,0x1, 0xf5,
+0x40,0x8f,0x41,0xe4,0xf5,0x2f,0x71,0x6, 0x12,0x4a,0x98,0xe4,0x12,0x1, 0xd7,0x5,
+0x2f,0xe5,0x2f,0xb4,0x5, 0xf0,0x12,0x47,0x4f,0x70,0x3, 0x2, 0x60,0xd0,0xe4,0xf5,
+0x2f,0x12,0x47,0x4f,0xff,0xe5,0x2f,0xc3,0x9f,0x40,0x2, 0xe1,0x9b,0x12,0x12,0x1f,
+0x12,0x4, 0xfe,0x0, 0x0, 0x0, 0x0, 0x12,0x60,0xd1,0x12,0x4, 0xfe,0x0, 0x0, 0x0,
+0x0, 0x51,0x9f,0x12,0x4, 0xfe,0x0, 0x0, 0x0, 0x0, 0x12,0x62,0xac,0xf5,0x83,0x12,
+0x4, 0xfe,0x0, 0x0, 0x0, 0x0, 0x90,0xa, 0x86,0x74,0x2, 0xf0,0xf5,0xf0,0xe5,0x2f,
+0x12,0x15,0x98,0x12,0x1, 0x65,0x12,0x64,0x83,0x40,0xd, 0x12,0x15,0xb1,0x12,0x1,
+0x4c,0x12,0x63,0xf3,0x94,0x0, 0x50,0x6, 0x12,0x15,0x1c,0x12,0x64,0xfc,0x12,0x60,
+0xe1,0x12,0x64,0x83,0x40,0xa, 0x12,0x17,0xdc,0x12,0x63,0xf3,0x94,0x0, 0x50,0x6,
+0x12,0x15,0x1c,0x12,0x64,0xfc,0x12,0x60,0xe1,0x12,0x65,0x16,0xe5,0x2f,0x12,0x15,
+0x98,0x12,0x1, 0x65,0x51,0xc8,0x12,0x65,0xc4,0xe4,0xf5,0x42,0x12,0x15,0x6, 0x71,
+0x44,0x40,0x3, 0x75,0x42,0x1, 0x12,0x15,0x8d,0x12,0x1, 0x65,0x12,0x64,0x4f,0xfe,
+0xc3,0xef,0x9e,0xf5,0x2d,0x12,0x15,0x8d,0x12,0x1, 0x65,0x12,0x64,0x4f,0x2f,0xff,
+0xe4,0x33,0xfe,0xad,0x2d,0x12,0x3f,0x90,0x40,0x2, 0xe1,0x97,0xe5,0x2f,0x75,0xf0,
+0x2, 0x12,0x2e,0x6, 0x12,0x47,0xbe,0x12,0x64,0x4f,0xfe,0xc3,0xef,0x9e,0xf5,0x2e,
+0x12,0x60,0xe1,0x12,0x64,0x4f,0x2f,0xff,0xe4,0xad,0x2e,0x12,0x3f,0x8e,0x40,0x2,
+0xe1,0x93,0xc3,0xe5,0x2d,0x64,0x80,0x94,0x80,0x50,0x2, 0xe1,0x8f,0x12,0x15,0xb1,
+0x12,0x1, 0x4c,0xad,0x2d,0x12,0x63,0x91,0x40,0x2, 0xe1,0x8f,0xc3,0xe5,0x2e,0x64,
+0x80,0x94,0x80,0x50,0x2, 0xe1,0x8f,0x12,0x47,0xbf,0xff,0xad,0x2e,0x12,0x63,0x92,
+0x40,0x2, 0xe1,0x8f,0xaf,0x2d,0x12,0x62,0xba,0xef,0x2d,0xf5,0x3b,0xee,0x3c,0xf5,
+0x3a,0xe5,0x3b,0x25,0xe0,0xff,0xe5,0x3a,0x33,0xfe,0xe5,0x3f,0x2f,0xf5,0x82,0xe5,
+0x3e,0x12,0x47,0x62,0xff,0xc3,0x95,0x47,0xf5,0x46,0xee,0x94,0x0, 0xf5,0x45,0xd3,
+0xe5,0x46,0x94,0x0, 0xe5,0x45,0x64,0x80,0x94,0x80,0x50,0x2, 0xe1,0x8f,0xef,0x95,
+0x44,0xee,0x95,0x43,0x40,0xa, 0x71,0x6, 0x90,0x0, 0x10,0x74,0x1, 0x12,0x1, 0x92,
+0xe5,0x42,0xb4,0x1, 0x2a,0xe5,0x3b,0xae,0x3a,0x78,0x3, 0xce,0xc3,0x13,0xce,0x13,
+0xd8,0xf9,0x25,0x41,0xf5,0x82,0xe5,0x40,0x3e,0xf5,0x83,0xc0,0x83,0xc0,0x82,0xe0,
+0xff,0xe5,0x3b,0x12,0x63,0x38,0xf4,0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0xe5,
+0x2d,0x25,0xe0,0xf5,0x3c,0xe5,0x2e,0x25,0xe0,0xf5,0x3d,0x12,0x15,0x8d,0x12,0x53,
+0x66,0x70,0x2, 0xc1,0x1, 0x12,0x60,0xe1,0x7b,0x2, 0x12,0x53,0x57,0x70,0x2, 0xc1,
+0x1, 0x12,0x12,0x1f,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0, 0xc0,0x1, 0xc0,
+0x2, 0xc0,0x3, 0x12,0x62,0x8f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,
+0x37,0xd0,0x82,0xd0,0x83,0x12,0x62,0xa9,0xf5,0x83,0xc0,0x83,0xc0,0x82,0x12,0x2a,
+0xc9,0xae,0x45,0x12,0x63,0x2d,0xeb,0x25,0x46,0x12,0x62,0x39,0xd0,0x82,0xd0,0x83,
+0x12,0x4, 0xf2,0x12,0x60,0xd1,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0, 0xc0,
+0x1, 0xc0,0x2, 0xc0,0x3, 0xae,0x45,0xaf,0x46,0xab,0x7, 0xaf,0x2d,0x12,0x62,0x97,
+0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,0x37,0xd0,0x82,0xd0,0x83,0x12,
+0x4, 0xf2,0xe5,0x2f,0x25,0xe0,0x25,0xe0,0x24,0x5e,0xf5,0x82,0xe4,0x34,0xa, 0xe1,
+0x74,0xe4,0xf5,0x39,0x12,0x47,0x4f,0xad,0x39,0x12,0x63,0x91,0x50,0x60,0xe5,0x2f,
+0x65,0x39,0x60,0x56,0xed,0x25,0xe0,0xff,0xec,0x33,0x8f,0x82,0xf5,0x83,0x12,0x53,
+0x66,0x60,0x15,0xaf,0x39,0x12,0x2f,0xe6,0x12,0x47,0xb3,0xfd,0x7b,0x2, 0x12,0x53,
+0x58,0x60,0x5, 0x75,0x39,0xff,0x80,0x36,0xaf,0x39,0x12,0x2f,0xe6,0x33,0xab,0x2a,
+0xaa,0x2b,0xa9,0x2c,0x8f,0x82,0xf5,0x83,0x12,0x1, 0x65,0xfd,0x7b,0x4, 0xaf,0x3c,
+0x12,0x53,0x35,0xef,0x60,0x14,0xaf,0x39,0x12,0x2f,0xe6,0x12,0x47,0xb3,0x7b,0x4,
+0x12,0x53,0x57,0x60,0x5, 0xe4,0xf5,0x39,0x80,0x4, 0x5, 0x39,0x80,0x96,0xe5,0x39,
+0x60,0x2, 0xc1,0xfa,0x12,0x60,0xd1,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0,
+0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 0xae,0x45,0xaf,0x46,0x12,0x63,0x2d,0x12,0x64,0xbb,
+0xaf,0x2d,0x12,0x62,0x9f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,0x37,
+0xd0,0x82,0xd0,0x83,0x12,0x12,0x1c,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0,
+0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 0xae,0x45,0xaf,0x46,0x12,0x63,0x2d,0x12,0x64,0xbb,
+0xaf,0x2e,0x12,0x62,0x9f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,0x37,
+0xd0,0x82,0xd0,0x83,0x51,0x9c,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0x12,0x63,0x23,
+0x12,0x62,0x37,0xd0,0x82,0xd0,0x83,0x12,0x62,0xa9,0xf5,0x83,0xc0,0x83,0xc0,0x82,
+0x12,0x2a,0xc9,0x12,0x63,0x23,0xeb,0x2f,0xe1,0x85,0xe5,0x39,0xf4,0x70,0x2, 0xe1,
+0x8f,0x12,0x60,0xd1,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0, 0xc0,0x1, 0xc0,
+0x2, 0xc0,0x3, 0xae,0x45,0xaf,0x46,0xab,0x7, 0xaa,0x6, 0xea,0x33,0x95,0xe0,0xf9,
+0xf8,0xaf,0x2d,0x12,0x62,0x9f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,
+0x37,0xd0,0x82,0xd0,0x83,0x12,0x12,0x1c,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,
+0x0, 0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 0x12,0x62,0x8f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1,
+0xd0,0x0, 0x12,0x62,0x37,0xd0,0x82,0xd0,0x83,0x51,0x9c,0xc0,0x83,0xc0,0x82,0x12,
+0x2a,0xc9,0xae,0x45,0x12,0x63,0x2d,0xeb,0x25,0x46,0x12,0x62,0x39,0xd0,0x82,0xd0,
+0x83,0x12,0x62,0xa9,0xf5,0x83,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xae,0x45,0x12,
+0x63,0x2d,0xeb,0x25,0x46,0x12,0x62,0x39,0xd0,0x82,0xd0,0x83,0x12,0x4, 0xf2,0x5,
+0x2e,0x81,0xa0,0x5, 0x2d,0x81,0x75,0x5, 0x2f,0x61,0xd1,0xe4,0xf5,0x2f,0x12,0x47,
+0x4f,0xff,0xe5,0x2f,0xc3,0x9f,0x40,0x3, 0x2, 0x60,0xc8,0xe5,0x2f,0x75,0xf0,0x2,
+0x12,0x2e,0x6, 0x12,0x47,0xbe,0x12,0x65,0x16,0xe5,0x2f,0x12,0x15,0x98,0x12,0x1,
+0x65,0x51,0xc8,0x12,0x65,0xc4,0x12,0x15,0x6, 0x71,0x44,0x50,0x3, 0x2, 0x60,0xc3,
+0x12,0x12,0x1f,0xc0,0x83,0xc0,0x82,0x12,0x2b,0x2, 0x78,0x6, 0x12,0x4, 0xdf,0xd0,
+0x82,0xd0,0x83,0x12,0x62,0xa9,0xf5,0x83,0x12,0x2a,0xc9,0x12,0x12,0x1f,0x12,0x2b,
+0x2, 0x12,0x4, 0x13,0xef,0x24,0x20,0xf5,0x31,0xe4,0x3e,0xf5,0x30,0x12,0x60,0xd1,
+0xc0,0x83,0xc0,0x82,0x12,0x2b,0x2, 0x78,0x6, 0x12,0x4, 0xdf,0xd0,0x82,0xd0,0x83,
+0x12,0x5a,0x9c,0x12,0x2a,0xc9,0x11,0xd1,0x12,0x2b,0x2, 0x12,0x4, 0x13,0xef,0x24,
+0x20,0xf5,0x35,0xe4,0x3e,0xf5,0x34,0xe5,0x38,0x12,0x5b,0x8, 0x90,0x0, 0xa, 0xe5,
+0x30,0x85,0x31,0xf0,0x12,0x3, 0x5b,0x90,0x0, 0xc, 0xe5,0x34,0x85,0x35,0xf0,0x12,
+0x3, 0x5b,0x12,0x5a,0x9f,0xc0,0x83,0xc0,0x82,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0x12,
+0x15,0x17,0x90,0x0, 0x12,0x12,0x1, 0x65,0xf9,0xf8,0x12,0x4, 0xcc,0xd0,0x82,0xd0,
+0x83,0x12,0x5a,0x9c,0x12,0x2b,0x2, 0xe4,0x7b,0x7f,0xfa,0xf9,0xf8,0xc3,0x12,0x4,
+0xbb,0x50,0xa, 0x12,0x5a,0x9f,0x12,0x4, 0xfe,0x0, 0x0, 0x0, 0x7f,0x12,0x5a,0x9f,
+0xa3,0xa3,0xa3,0xe0,0xfd,0xe5,0x38,0x12,0x5b,0x8, 0x90,0x0, 0xf, 0xed,0x12,0x1,
+0xd7,0xe5,0x2f,0x75,0xf0,0x7, 0x90,0x0, 0x10,0x11,0xe9,0xfd,0xe5,0x38,0x75,0xf0,
+0x7, 0xa4,0x12,0x5b,0xe, 0x90,0x0, 0x10,0xed,0x12,0x4a,0x9c,0x12,0x1, 0x65,0xd3,
+0x94,0xf, 0x40,0xd, 0xe5,0x38,0x12,0x5b,0x8, 0x90,0x0, 0x10,0x74,0xf, 0x12,0x1,
+0xd7,0x5, 0x38,0x5, 0x2f,0x2, 0x5f,0x9e,0x90,0x0, 0x2d,0xe5,0x38,0x12,0x5b,0x67,
+0x22,0xe5,0x2f,0x25,0xe0,0x25,0xe0,0x24,0x4a,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,
+0x22,0xe5,0x2f,0x75,0xf0,0x2, 0x90,0x0, 0x1, 0xa4,0xab,0x2a,0x25,0x2c,0xf9,0xe5,
+0x2b,0x35,0xf0,0xfa,0x2, 0x1, 0x65,0xbf,0x1, 0x5, 0x43,0xdb,0x80,0x80,0x6, 0xef,
+0x70,0x3, 0x53,0xdb,0x7f,0xc2,0xea,0x43,0xdb,0x10,0xd2,0xd9,0xc2,0xdd,0xc2,0xdc,
+0xc2,0xdb,0xc2,0xda,0xd2,0xd8,0x75,0xab,0x6, 0xe4,0xf5,0x9a,0x53,0xdb,0xfd,0xd2,
+0xed,0xd2,0xba,0xc2,0xc2,0x43,0xa9,0x4, 0x43,0xb9,0x4, 0x22,0xef,0x31,0x40,0xed,
+0x2b,0xfb,0xe4,0x3a,0xfe,0xaf,0x3, 0x22,0xac,0x7, 0xed,0x31,0x40,0xec,0x80,0xf0,
+0x7b,0x0, 0x7a,0xc0,0x75,0xf0,0x80,0xa4,0x2b,0xfb,0xe5,0xf0,0x3a,0xfa,0x22,0x53,
+0xc9,0x7, 0x43,0xc9,0x30,0x75,0xeb,0x80,0xef,0x25,0xe0,0x4, 0x25,0xeb,0xf5,0xeb,
+0x22,0x8b,0x33,0x8a,0x34,0x89,0x35,0xe4,0xff,0x51,0x8, 0xab,0x33,0xaa,0x34,0xa9,
+0x35,0x90,0x0, 0x18,0x12,0x1, 0x65,0xff,0x31,0x4f,0x7f,0x1, 0x31,0xba,0x31,0xf7,
+0xef,0x70,0x2, 0xff,0x22,0x7d,0x7f,0x7f,0x14,0x31,0xe5,0xef,0x70,0x2, 0xff,0x22,
+0x12,0xf, 0xec,0x85,0x33,0x39,0xf5,0x3a,0x89,0x3b,0xab,0x33,0xaa,0x34,0xa9,0x35,
+0x12,0x2e,0x91,0xab,0x33,0xaa,0x34,0xa9,0x35,0x12,0x2e,0x17,0xe4,0xff,0x31,0xba,
+0x31,0xdc,0xef,0x7f,0x0, 0x60,0x2, 0x7f,0x1, 0x22,0xef,0x24,0xfe,0x60,0xb, 0x14,
+0x60,0xc, 0x24,0x2, 0x70,0xc, 0x7d,0x9, 0x80,0xa, 0x7d,0x6, 0x80,0x6, 0x7d,0x3,
+0x80,0x2, 0xe4,0xfd,0xe5,0xdc,0x54,0xf0,0x2d,0xf5,0xdc,0x22,0xe4,0xfd,0x51,0x1,
+0x60,0x2, 0x7f,0x1, 0x22,0xae,0x5, 0xac,0x7, 0x12,0x2e,0x74,0x51,0x13,0xef,0x7f,
+0x0, 0xb5,0x6, 0x2, 0x7f,0x1, 0x22,0x7d,0x3, 0xe4,0x51,0x1, 0x60,0x2, 0x7f,0x1,
+0x22,0xff,0x31,0xe5,0xef,0x7f,0x0, 0x22,0xef,0x70,0x4, 0x53,0xdb,0xbf,0x22,0x43,
+0xdb,0x40,0x22,0x12,0x2f,0x98,0xef,0x44,0x80,0xf5,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,
+0x53,0xdb,0xf3,0xe4,0xf5,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,0xaf,0xa1,0x43,0xab,0x4,
+0x22,0xc2,0xc2,0x53,0xdb,0xbf,0x32,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xe9,0x3d,0xfd,
+0xe8,0x3c,0xfc,0x22,0xf9,0xe4,0x35,0x22,0xfa,0x7e,0x0, 0xe9,0x25,0x2d,0xf9,0xee,
+0x3a,0xfa,0x12,0x1, 0x4c,0x54,0xf, 0xfd,0xe5,0x2d,0x25,0xe0,0xff,0xee,0x33,0xfe,
+0x74,0x6e,0x2f,0xf5,0x82,0x74,0xa, 0x3e,0xf5,0x83,0xed,0xf0,0x12,0x1, 0x4c,0x54,
+0xf0,0xc4,0x54,0xf, 0xfd,0xe5,0x2d,0x25,0xe0,0xff,0xe4,0x33,0xfe,0x74,0x6f,0x2f,
+0xf5,0x82,0x74,0xa, 0x3e,0x22,0xab,0x29,0xaa,0x2a,0xa9,0x2b,0x2, 0x1, 0x65,0xae,
+0x45,0xaf,0x46,0xab,0x7, 0xaf,0x2e,0xaa,0x6, 0xea,0x33,0x95,0xe0,0xf9,0xf8,0xef,
+0x33,0x95,0xe0,0xfe,0xfd,0xfc,0x2, 0x3, 0x88,0x12,0x4, 0xf2,0xe5,0x2f,0x25,0xe0,
+0x25,0xe0,0x24,0x72,0xf5,0x82,0xe4,0x34,0xa, 0x22,0xef,0x33,0x95,0xe0,0xfe,0xef,
+0xc4,0xf8,0x54,0xf, 0xc8,0x68,0xff,0xee,0xc4,0x54,0xf0,0x48,0xfe,0x22,0x12,0x2,
+0xb7,0xff,0xe5,0xf0,0xc4,0xf8,0x54,0xf0,0xc8,0x68,0xfc,0xef,0xc4,0x54,0xf, 0x48,
+0xfd,0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0xff,0xae,0xf0,0xab,0x21,0x25,0x23,0xf9,0xe5,
+0x22,0x22,0xe5,0x30,0x95,0x36,0xe5,0x35,0x64,0x80,0xf8,0xe5,0x2f,0x64,0x80,0x98,
+0x22,0xe5,0x2d,0x25,0xe0,0xff,0xe5,0x2c,0x33,0xfe,0xe5,0x31,0x2f,0xf5,0x82,0xe5,
+0x30,0x3e,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0xd3,0x95,0x36,0x74,0x80,0xf8,0xee,0x64,
+0x80,0x98,0x22,0xe5,0x45,0xa2,0xe7,0x13,0xfe,0xe5,0x46,0x13,0xff,0xee,0x33,0x95,
+0xe0,0xfd,0xfc,0x22,0xe0,0xff,0xe5,0x2d,0x7c,0x0, 0x54,0x7, 0x24,0x7c,0xf5,0x82,
+0xec,0x34,0x7, 0xf5,0x83,0xe4,0x93,0x22,0xa3,0xf0,0x75,0x24,0x1, 0x75,0x25,0x8,
+0x75,0x26,0x29,0x75,0x27,0x1, 0x75,0x28,0xa, 0x75,0x29,0x2e,0x7b,0x1, 0x22,0xa8,
+0x1, 0xfc,0xad,0x27,0x7b,0x1, 0x7a,0xa, 0x79,0x36,0x7e,0x0, 0x2, 0x1, 0x26,0x7e,
+0x0, 0xe5,0x29,0x24,0x23,0xf9,0xe4,0x35,0x28,0xfa,0xe9,0x2f,0xf9,0xee,0x3a,0xfa,
+0x22,0xe5,0x2c,0x75,0xf0,0x7, 0xa4,0x24,0x38,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,
+0x22,0xff,0xed,0x33,0x95,0xe0,0xfc,0xc3,0xed,0x9f,0x74,0x80,0xf8,0x6c,0x98,0x22,
+0xab,0x27,0xe5,0x29,0x24,0x4f,0xf9,0xe4,0x35,0x28,0xfa,0x2, 0x1, 0x4c,0xf9,0xe4,
+0x3a,0xfa,0x12,0x2, 0x8c,0xc4,0xf8,0x54,0xf, 0xc8,0x68,0xff,0xe5,0xf0,0xc4,0x54,
+0xf0,0x48,0x8f,0xf0,0x2, 0x3, 0x3c,0x34,0x3, 0xfa,0xaf,0x27,0xef,0x33,0x95,0xe0,
+0xfe,0xef,0x22,0xf9,0xe4,0x3a,0xfa,0x12,0x2, 0x8c,0xc3,0x95,0x2b,0xff,0xe5,0xf0,
+0x95,0x2a,0x8f,0xf0,0x2, 0x3, 0x3c,0xe5,0x2b,0x24,0x23,0xf5,0x82,0xe4,0x35,0x2a,
+0xf5,0x83,0x22,0x24,0xff,0xff,0xe4,0x34,0xff,0xcf,0xc3,0x95,0x3b,0xcf,0x95,0x3a,
+0xfe,0xd3,0xef,0x94,0x0, 0xee,0x22,0x90,0xa, 0xdb,0xe0,0xfe,0xa3,0xe0,0xff,0xe4,
+0xfc,0xfd,0x7b,0x40,0x7a,0x9c,0xf9,0xf8,0xd3,0x22,0x90,0x8, 0x1d,0x74,0x1, 0xf0,
+0xa3,0x74,0xb, 0xf0,0x22,0x74,0x3e,0x25,0x4f,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,
+0xe0,0xff,0xab,0x49,0xe5,0x4b,0x22,0xab,0x21,0xe5,0x23,0x2f,0xf9,0xe5,0x22,0x3e,
+0xfa,0x22,0x75,0x28,0x9, 0x75,0x29,0x19,0x75,0x2a,0x1, 0x75,0x2b,0x8, 0x22,0xc3,
+0x13,0xff,0x90,0xa, 0x86,0xe0,0x22,0x75,0x28,0x0, 0x75,0x29,0x83,0x75,0x2a,0x1,
+0x22,0x75,0x24,0x1, 0x75,0x25,0x0, 0x75,0x26,0x83,0x22,0xc3,0x13,0x24,0x3d,0xf5,
+0x82,0xe4,0x34,0xb, 0xf5,0x83,0x22,0x74,0x11,0x25,0x2c,0xf5,0x82,0xe4,0x34,0xb,
+0xf5,0x83,0x22,0xc3,0x13,0x75,0x3a,0x0, 0xf5,0x3b,0xd3,0x94,0x0, 0xe5,0x3a,0x94,
+0x0, 0x22,0xf5,0x30,0xf5,0x31,0xf5,0x32,0xf5,0x33,0xf5,0x34,0xf5,0x35,0xf5,0x36,
+0x22,0xe4,0x12,0x1, 0xc5,0x4, 0x29,0xf9,0xe4,0x3a,0xfa,0x5, 0x39,0xe5,0x39,0x22,
+0x74,0x8a,0x2d,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x78,0x1, 0x12,0x4, 0xcc,
+0xa8,0x4, 0xa9,0x5, 0xaa,0x6, 0xab,0x7, 0x22,0x12,0x2, 0xb7,0xd3,0x9d,0xe5,0xf0,
+0x9c,0xe5,0x2d,0x75,0xf0,0x7, 0x22,0xc3,0xe4,0x95,0x36,0xfb,0xe4,0x94,0x0, 0xfa,
+0xc3,0xed,0x9b,0xea,0x22,0xff,0xe9,0x24,0x58,0xf9,0xe4,0x3a,0xfa,0xe9,0x2f,0xf9,
+0xea,0x3e,0x22,0xff,0xc3,0xe5,0x2b,0x9f,0xe5,0x2a,0x9e,0x22,0x90,0x0, 0x10,0x12,
+0x1, 0x65,0xc3,0x13,0x90,0xa, 0x86,0xf0,0x22,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,
+0x0, 0x5, 0xcf,0x8f,0xf0,0x22,0xc3,0x13,0xfd,0x7c,0x0, 0xaa,0x2b,0xa9,0x2c,0x75,
+0xf0,0x2, 0x22,0x12,0x1d,0xdd,0x8e,0x2a,0x8f,0x2b,0xe5,0x2b,0xa8,0x2c,0x8, 0x22,
+0x90,0x0, 0x52,0x12,0x1, 0xd7,0x90,0x0, 0x53,0x22,0x7e,0x0, 0x7f,0x23,0x2, 0x1,
+0x26,0x12,0x2, 0xb7,0xac,0xf0,0xc3,0x9f,0x22,0xab,0x27,0xe5,0x29,0x24,0x23,0xf9,
+0xe4,0x35,0x28,0xfa,0x22,0xe5,0x23,0x24,0x80,0xf9,0xe5,0x22,0x34,0x3, 0xaf,0x1,
+0x22,0x13,0x2d,0xfd,0xee,0x3c,0xfc,0xc3,0x64,0x80,0x94,0x80,0x22,0xab,0x21,0xe5,
+0x23,0x24,0xa, 0xf9,0xe4,0x35,0x22,0xfa,0x22,0x74,0x87,0x2f,0xf5,0x82,0x74,0xa,
+0x3e,0xf5,0x83,0x22,0x12,0x2, 0xb7,0xc3,0x9f,0xff,0xe5,0xf0,0x9e,0xfe,0x22,0xf5,
+0x2a,0x85,0xf0,0x29,0xe5,0x29,0x54,0xf, 0x22,0xc4,0xf8,0x54,0xf, 0xc8,0x68,0x22,
+0x75,0xf0,0x2, 0x2, 0x5, 0x40,0x12,0x1, 0x4c,0xfd,0x12,0x0, 0x1e,0xe5,0x2c,0x22,
+0x90,0x0, 0x7, 0x12,0x1, 0x65,0xf5,0x25,0xf4,0x22,0xfe,0xa3,0xe0,0xff,0x12,0x0,
+0x6, 0xd3,0xef,0x22,0x2d,0xff,0xec,0x35,0xf0,0xfe,0x22,0x90,0x0, 0x49,0x2, 0x1,
+0x65,0x8b,0x27,0x8a,0x28,0x89,0x29,0x22,0x75,0x27,0x1, 0x75,0x28,0x0, 0x75,0x29,
+0x0, 0x22,0x75,0x24,0x1, 0x75,0x25,0xa, 0x75,0x26,0x2e,0x22,0xf0,0x90,0xb, 0x57,
+0xe0,0x90,0x0, 0x54,0xf0,0x22,0x90,0x0, 0x55,0x74,0x21,0xf0,0x22,0xed,0x12,0x1,
+0xd7,0x5, 0x2e,0xe5,0x2e,0x22,0x90,0x0, 0x2d,0x75,0xf0,0x2, 0xe5,0x2a,0x22,0x12,
+0x1, 0x4c,0xff,0xe5,0x2d,0xc3,0x9f,0x22,0xad,0x3c,0xed,0x33,0x95,0xe0,0xfc,0xc3,
+0x22,0xe0,0xfc,0xa3,0xe0,0xc3,0x9f,0xec,0x9e,0x22,0xe0,0xfc,0xa3,0xe0,0xd3,0x9f,
+0xec,0x9e,0x22,0xe5,0x2a,0x85,0x2b,0xf0,0x2, 0x2, 0xef,0x90,0x0, 0x2d,0x75,0xf0,
+0x2, 0xe5,0x2b,0x22,0xff,0x74,0x37,0x2d,0xf5,0x82,0x74,0xa, 0x22,0xe5,0x26,0x24,
+0xa, 0xf9,0xe4,0x35,0x25,0x22,0xe5,0x29,0x24,0x26,0xf9,0xe4,0x35,0x28,0x22,0x74,
+0x7f,0xf0,0xa3,0x74,0xff,0xf0,0x22,0x74,0x86,0x2f,0xf5,0x82,0x74,0xa, 0x22,0xee,
+0xf0,0xa3,0xef,0xf0,0x5, 0x2c,0x22,0xfd,0x12,0x0, 0x1e,0xe4,0xf5,0x2c,0x22,0xff,
+0xab,0x29,0xe5,0x2b,0x24,0x54,0x22,0xff,0xab,0x29,0xe5,0x2b,0x24,0x1c,0x22,0xe5,
+0x30,0x25,0xe0,0xff,0xe5,0x2f,0x22,0x12,0x1, 0xd7,0x90,0xb, 0x57,0xe0,0x22,0x74,
+0x21,0xf0,0xa3,0x74,0x34,0xf0,0x22,0xf5,0x83,0xec,0xf0,0xa3,0xed,0xf0,0x22,0x66,
+0xaf,0x99,0x50,0x34,0xcb,0x22,0x79,
+
diff --git a/drivers/input/touchscreen/goodix_touch.c b/drivers/input/touchscreen/goodix_touch.c
new file mode 100644
index 0000000..2025654
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_touch.c
@@ -0,0 +1,1251 @@
+/*---------------------------------------------------------------------------------------------------------
+ * driver/input/touchscreen/goodix_touch.c
+ *
+ * Copyright(c) 2010 Goodix Technology Corp.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Change Date:
+ *		2010.11.11, add point_queue's definiens.
+ *
+ * 		2011.03.09, rewrite point_queue's definiens.
+ *
+ * 		2011.05.12, delete point_queue for Android 2.2/Android 2.3 and so on.
+ *
+ *---------------------------------------------------------------------------------------------------------*/
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include "goodix_touch.h"
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <mach/irqs.h>
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+#include "ctp_platform_ops.h"
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    #include <linux/pm.h>
+    #include <linux/earlysuspend.h>
+#endif
+
+#define FOR_TSLIB_TEST
+//#define PRINT_INT_INFO
+//#define PRINT_POINT_INFO
+#define PRINT_SUSPEND_INFO
+#define TEST_I2C_TRANSFER
+
+//#undef CONFIG_HAS_EARLYSUSPEND
+
+#ifndef GUITAR_GT80X
+#error The code does not match the hardware version.
+#endif
+
+struct goodix_ts_data {
+	int retry;
+	int panel_type;
+	char phys[32];
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	uint8_t use_irq;
+	uint8_t use_shutdown;
+	uint32_t gpio_shutdown;
+	uint32_t gpio_irq;
+	uint32_t screen_width;
+	uint32_t screen_height;
+	struct ts_event		event;
+	struct hrtimer timer;
+	struct work_struct  work;
+	int (*power)(struct goodix_ts_data * ts, int on);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+};
+
+const char *f3x_ts_name = "gt80x";
+static struct workqueue_struct *goodix_wq;
+#define X_DIFF (800)
+
+#ifdef PRINT_POINT_INFO
+#define print_point_info(fmt, args...)   \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_point_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_INT_INFO
+#define print_int_info(fmt, args...)     \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_int_info(fmt, args...)   //
+#endif
+///////////////////////////////////////////////
+//specific tp related macro: need be configured for specific tp
+#define CTP_IRQ_NO			(gpio_int_info[0].port_num)
+#define CTP_IRQ_MODE			(NEGATIVE_EDGE)
+#define CTP_NAME			GOODIX_I2C_NAME
+#define TS_RESET_LOW_PERIOD		(15)
+#define TS_INITIAL_HIGH_PERIOD		(15)
+#define TS_WAKEUP_LOW_PERIOD	(100)
+#define TS_WAKEUP_HIGH_PERIOD	(100)
+#define TS_POLL_DELAY			(10)	/* ms delay between samples */
+#define TS_POLL_PERIOD			(10)	/* ms delay between samples */
+#define SCREEN_MAX_HEIGHT		(screen_max_x)
+#define SCREEN_MAX_WIDTH		(screen_max_y)
+#define PRESS_MAX			(255)
+
+static void* __iomem gpio_addr = NULL;
+static int gpio_int_hdle = 0;
+static int gpio_wakeup_hdle = 0;
+static int gpio_reset_hdle = 0;
+static int gpio_wakeup_enable = 1;
+static int gpio_reset_enable = 1;
+static user_gpio_set_t gpio_int_info[1];
+
+static int screen_max_x = 0;
+static int screen_max_y = 0;
+static int revert_x_flag = 0;
+static int revert_y_flag = 0;
+static int exchange_x_y_flag = 0;
+static __u32 twi_addr = 0;
+static __u32 twi_id = 0;
+static int	int_cfg_addr[]={PIO_INT_CFG0_OFFSET,PIO_INT_CFG1_OFFSET,
+			PIO_INT_CFG2_OFFSET, PIO_INT_CFG3_OFFSET};
+/* Addresses to scan */
+union{
+	unsigned short dirty_addr_buf[2];
+	const unsigned short normal_i2c[2];
+}u_i2c_addr = {{0x00},};
+
+/*
+ * ctp_get_pendown_state  : get the int_line data state,
+ *
+ * return value:
+ *             return PRESS_DOWN: if down
+ *             return FREE_UP: if up,
+ *             return 0: do not need process, equal free up.
+ */
+static int ctp_get_pendown_state(void)
+{
+	unsigned int reg_val;
+	static int state = FREE_UP;
+
+	//get the input port state
+	reg_val = readl(gpio_addr + PIOH_DATA);
+	//printk("reg_val = %x\n",reg_val);
+	if(!(reg_val & (1<<CTP_IRQ_NO))){
+		state = PRESS_DOWN;
+		print_int_info("pen down. \n");
+	}else{ //touch panel is free up
+		state = FREE_UP;
+		print_int_info("free up. \n");
+	}
+	return state;
+}
+
+/**
+ * ctp_clear_penirq - clear int pending
+ *
+ */
+static void ctp_clear_penirq(void)
+{
+	int reg_val;
+	//clear the IRQ_EINT29 interrupt pending
+	//printk("clear pend irq pending\n");
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val&(1<<(IRQ_EINT21)),gpio_addr + PIO_INT_STAT_OFFSET);
+	if((reg_val = (reg_val&(1<<(CTP_IRQ_NO))))){
+		print_int_info("==CTP_IRQ_NO=\n");
+		writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+	}
+	return;
+}
+
+/**
+ * ctp_set_irq_mode - according sysconfig's subkey "ctp_int_port" to config int port.
+ *
+ * return value:
+ *              0:      success;
+ *              others: fail;
+ */
+static int ctp_set_irq_mode(char *major_key , char *subkey, ext_int_mode int_mode)
+{
+	int ret = 0;
+	__u32 reg_num = 0;
+	__u32 reg_addr = 0;
+	__u32 reg_val = 0;
+	//config gpio to int mode
+	pr_info("%s: config gpio to int mode. \n", __func__);
+#ifndef SYSCONFIG_GPIO_ENABLE
+#else
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	gpio_int_hdle = gpio_request_ex(major_key, subkey);
+	if(!gpio_int_hdle){
+		pr_info("request tp_int_port failed. \n");
+		ret = -1;
+		goto request_tp_int_port_failed;
+	}
+	gpio_get_one_pin_status(gpio_int_hdle, gpio_int_info, subkey, 1);
+	pr_info("%s, %d: gpio_int_info, port = %d, port_num = %d. \n", __func__, __LINE__, \
+		gpio_int_info[0].port, gpio_int_info[0].port_num);
+#endif
+
+#ifdef AW_GPIO_INT_API_ENABLE
+#else
+	pr_info(" INTERRUPT CONFIG\n");
+	reg_num = (gpio_int_info[0].port_num)%8;
+	reg_addr = (gpio_int_info[0].port_num)/8;
+	reg_val = readl(gpio_addr + int_cfg_addr[reg_addr]);
+	reg_val &= (~(7 << (reg_num * 4)));
+	reg_val |= (int_mode << (reg_num * 4));
+	writel(reg_val,gpio_addr+int_cfg_addr[reg_addr]);
+
+	ctp_clear_penirq();
+
+	reg_val = readl(gpio_addr+PIO_INT_CTRL_OFFSET);
+	reg_val |= (1 << (gpio_int_info[0].port_num));
+	writel(reg_val,gpio_addr+PIO_INT_CTRL_OFFSET);
+
+	udelay(1);
+#endif
+
+request_tp_int_port_failed:
+	return ret;
+}
+
+/**
+ * ctp_set_gpio_mode - according sysconfig's subkey "ctp_io_port" to config io port.
+ *
+ * return value:
+ *              0:      success;
+ *              others: fail;
+ */
+static int ctp_set_gpio_mode(void)
+{
+	//int reg_val;
+	int ret = 0;
+	//config gpio to io mode
+	printk("%s: config gpio to io mode. \n", __func__);
+#ifndef SYSCONFIG_GPIO_ENABLE
+#else
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	gpio_int_hdle = gpio_request_ex("ctp_para", "ctp_io_port");
+	if(!gpio_int_hdle){
+		printk("request ctp_io_port failed. \n");
+		ret = -1;
+		goto request_tp_io_port_failed;
+	}
+#endif
+	return ret;
+
+request_tp_io_port_failed:
+	return ret;
+}
+
+/**
+ * ctp_judge_int_occur - whether interrupt occur.
+ *
+ * return value:
+ *              0:      int occur;
+ *              others: no int occur;
+ */
+static int ctp_judge_int_occur(void)
+{
+	//int reg_val[3];
+	int reg_val;
+	int ret = -1;
+
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	if(reg_val&(1<<(CTP_IRQ_NO))){
+		ret = 0;
+	}
+	return ret;
+}
+
+/**
+ * ctp_free_platform_resource - corresponding with ctp_init_platform_resource
+ *
+ */
+static void ctp_free_platform_resource(void)
+{
+	printk("=======%s=========.\n", __func__);
+	if(gpio_addr){
+		iounmap(gpio_addr);
+	}
+
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+
+	if(gpio_wakeup_hdle){
+		gpio_release(gpio_wakeup_hdle, 2);
+	}
+
+	if(gpio_reset_hdle){
+		gpio_release(gpio_reset_hdle, 2);
+	}
+
+	return;
+}
+
+
+/**
+ * ctp_init_platform_resource - initialize platform related resource
+ * return value: 0 : success
+ *               -EIO :  i/o err.
+ *
+ */
+static int ctp_init_platform_resource(void)
+{
+	int ret = 0;
+
+	gpio_addr = ioremap(PIO_BASE_ADDRESS, PIO_RANGE_SIZE);
+	//printk("%s, gpio_addr = 0x%x. \n", __func__, gpio_addr);
+	if(!gpio_addr) {
+		ret = -EIO;
+		goto exit_ioremap_failed;
+	}
+	//    gpio_wakeup_enable = 1;
+	gpio_wakeup_hdle = gpio_request_ex("ctp_para", "ctp_wakeup");
+	if(!gpio_wakeup_hdle) {
+		pr_warning("%s: tp_wakeup request gpio fail!\n", __func__);
+		gpio_wakeup_enable = 0;
+	}
+
+	gpio_reset_hdle = gpio_request_ex("ctp_para", "ctp_reset");
+	if(!gpio_reset_hdle) {
+		pr_warning("%s: tp_reset request gpio fail!\n", __func__);
+		gpio_reset_enable = 0;
+	}
+
+	return ret;
+
+exit_ioremap_failed:
+	ctp_free_platform_resource();
+	return ret;
+}
+
+
+/**
+ * ctp_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int ctp_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int ctp_used = -1;
+	char name[I2C_NAME_SIZE];
+	script_parser_value_type_t type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+
+	printk("%s. \n", __func__);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_used", &ctp_used, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	if(1 != ctp_used){
+		pr_err("%s: ctp_unused. \n",  __func__);
+		//ret = 1;
+		return ret;
+	}
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch_ex("ctp_para", "ctp_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	if(strcmp(CTP_NAME, name)){
+		pr_err("%s: name %s does not match CTP_NAME. \n", __func__, name);
+		pr_err(CTP_NAME);
+		//ret = 1;
+		return ret;
+	}
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_twi_addr", &twi_addr, sizeof(twi_addr)/sizeof(__u32))){
+		pr_err("%s: script_parser_fetch err. \n", name);
+		goto script_parser_fetch_err;
+	}
+	//big-endian or small-endian?
+	//printk("%s: before: ctp_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+	u_i2c_addr.dirty_addr_buf[0] = twi_addr;
+	u_i2c_addr.dirty_addr_buf[1] = I2C_CLIENT_END;
+	printk("%s: after: ctp_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+	//printk("%s: after: ctp_twi_addr is 0x%x, u32_dirty_addr_buf: 0x%hx. u32_dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u32_dirty_addr_buf[0],u32_dirty_addr_buf[1]);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_twi_id", &twi_id, sizeof(twi_id)/sizeof(__u32))){
+		pr_err("%s: script_parser_fetch err. \n", name);
+		goto script_parser_fetch_err;
+	}
+	printk("%s: ctp_twi_id is %d. \n", __func__, twi_id);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_x", &screen_max_x, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: screen_max_x = %d. \n", __func__, screen_max_x);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_y", &screen_max_y, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: screen_max_y = %d. \n", __func__, screen_max_y);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_x_flag", &revert_x_flag, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: revert_x_flag = %d. \n", __func__, revert_x_flag);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_y_flag", &revert_y_flag, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: revert_y_flag = %d. \n", __func__, revert_y_flag);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_exchange_x_y_flag", &exchange_x_y_flag, 1)){
+		pr_err("ft5x_ts: script_parser_fetch err. \n");
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: exchange_x_y_flag = %d. \n", __func__, exchange_x_y_flag);
+
+	return 0;
+
+script_parser_fetch_err:
+	pr_notice("=========script_parser_fetch_err============\n");
+	return ret;
+}
+
+/**
+ * ctp_reset - function
+ *
+ */
+static void ctp_reset(void)
+{
+	printk("%s. \n", __func__);
+	if(gpio_reset_enable){
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 0, "ctp_reset")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_RESET_LOW_PERIOD);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 1, "ctp_reset")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_INITIAL_HIGH_PERIOD);
+	}
+}
+
+/**
+ * ctp_wakeup - function
+ *
+ */
+static void ctp_wakeup(void)
+{
+	printk("%s. \n", __func__);
+	if(1 == gpio_wakeup_enable){
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 1, "ctp_wakeup")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_WAKEUP_LOW_PERIOD);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_WAKEUP_HIGH_PERIOD);
+
+	}
+	return;
+}
+/**
+ * ctp_detect - Device detection callback for automatic device creation
+ * return value:
+ *                    = 0; success;
+ *                    < 0; err
+ */
+int ctp_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if(twi_id == adapter->nr)
+	{
+		pr_info("%s: Detected chip %s at adapter %d, address 0x%02x\n",
+			 __func__, CTP_NAME, i2c_adapter_id(adapter), client->addr);
+
+		strlcpy(info->type, CTP_NAME, I2C_NAME_SIZE);
+		return 0;
+	}else{
+		return -ENODEV;
+	}
+}
+////////////////////////////////////////////////////////////////
+
+static struct ctp_platform_ops ctp_ops = {
+	.get_pendown_state = ctp_get_pendown_state,
+	.clear_penirq	   = ctp_clear_penirq,
+	.set_irq_mode      = ctp_set_irq_mode,
+	.set_gpio_mode     = ctp_set_gpio_mode,
+	.judge_int_occur   = ctp_judge_int_occur,
+	.init_platform_resource = ctp_init_platform_resource,
+	.free_platform_resource = ctp_free_platform_resource,
+	.fetch_sysconfig_para = ctp_fetch_sysconfig_para,
+	.ts_reset =          ctp_reset,
+	.ts_wakeup =         ctp_wakeup,
+	.ts_detect = ctp_detect,
+};
+
+
+//åç¨è®¾å¤
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_suspend(struct early_suspend *h)
+{
+	int ret;
+	struct goodix_ts_data *ts = container_of(h, struct goodix_ts_data, early_suspend);
+    struct i2c_client * client = ts->client;
+    #ifdef PRINT_SUSPEND_INFO
+        printk("enter earlysuspend: goodix_ts_suspend. \n");
+    #endif
+
+    //disable_irq(ts->gpio_irq);
+	ret = cancel_work_sync(&ts->work);
+
+	if (ts->power) {
+		ret = ts->power(ts,0);
+		if (ret < 0)
+			dev_warn(&client->dev, "%s power off failed\n", f3x_ts_name);
+	}
+	return ;
+}
+
+//éæ°å¤é
+static void goodix_ts_resume(struct early_suspend *h)
+{
+	int ret;
+	struct goodix_ts_data *ts = container_of(h, struct goodix_ts_data, early_suspend);
+    struct i2c_client * client = ts->client;
+
+#ifdef PRINT_SUSPEND_INFO
+        printk("enter laterresume: goodix_ts_resume. \n");
+#endif
+
+	if (ts->power) {
+		ret = ts->power(ts, 1);
+		if (ret < 0)
+			dev_warn(&client->dev, "%s power on failed\n", f3x_ts_name);
+	}
+
+    //enable_irq(ts->gpio_irq);
+	return ;
+}
+#else
+#ifdef CONFIG_PM
+//åç¨è®¾å¤
+static int goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+#ifdef PRINT_SUSPEND_INFO
+        printk("enter: goodix_ts_suspend. \n");
+#endif
+        //disable_irq(ts->gpio_irq);
+	ret = cancel_work_sync(&ts->work);
+
+	if (ts->power) {
+		ret = ts->power(ts,0);
+		if (ret < 0)
+			dev_warn(&client->dev, "%s power off failed\n", f3x_ts_name);
+	}
+	return 0;
+}
+
+//éæ°å¤é
+static int goodix_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+#ifdef PRINT_SUSPEND_INFO
+        printk("enter: goodix_ts_resume. \n");
+#endif
+
+	if (ts->power) {
+		ret = ts->power(ts, 1);
+		if (ret < 0)
+			dev_warn(&client->dev, "%s power on failed\n", f3x_ts_name);
+	}
+
+        //enable_irq(ts->gpio_irq);
+	return 0;
+}
+#endif
+
+#endif
+
+
+/*used by GT80X-IAP module */
+struct i2c_client * i2c_connect_client = NULL;
+EXPORT_SYMBOL(i2c_connect_client);
+/**********************************************************************
+æ¬ç¨åºä¸­I2Céä¿¡æ¹å¼ä¸ºï¼
+	7bitä»æºå°åï½è¯»åä½ + bufï¼æ°æ®å°å+è¯»åæ°æ®ï¼
+	 --------------------------------------------------------------------
+	ï½  ä»æºå°å   ï½ buf[0](æ°æ®å°å) | buf[1]~buf[MAX-1](åå¥æè¯»åå°çæ°æ®)  |
+	 --------------------------------------------------------------------
+	ç§»æ¤åè¯·æ ¹æ®èªèº«ä¸»æ§æ ¼å¼ä¿®æ¹ï¼ï¼
+***********************************************************************/
+
+//Function as i2c_master_receive, and return 2 if operation is successful.
+static int i2c_read_bytes(struct i2c_client *client, uint8_t *buf, uint16_t len)
+{
+	struct i2c_msg msgs[2];
+	int ret=-1;
+	//åéåå°å
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = client->addr;
+	msgs[0].len = 1;		//data address
+	msgs[0].buf = buf;
+	//æ¥æ¶æ°æ®
+	msgs[1].flags = I2C_M_RD;//è¯»æ¶æ¯
+	msgs[1].addr = client->addr;
+	msgs[1].len = len-1;
+	msgs[1].buf = buf+1;
+
+	ret=i2c_transfer(client->adapter, msgs, 2);
+	return ret;
+}
+
+//Function as i2c_master_send, and return 1 if operation is successful.
+static int i2c_write_bytes(struct i2c_client *client, uint8_t *data, uint16_t len)
+{
+	struct i2c_msg msg;
+	int ret=-1;
+
+	msg.flags = !I2C_M_RD;//åæ¶æ¯
+	msg.addr = client->addr;
+	msg.len = len;
+	msg.buf = data;
+
+	ret=i2c_transfer(client->adapter, &msg,1);
+	return ret;
+}
+
+/*******************************************************
+åè½ï¼
+	GT80Xåå§åå½æ°ï¼ç¨äºåééç½®ä¿¡æ¯
+åæ°ï¼
+	ts:	struct goodix_ts_data
+returnï¼
+	æ§è¡ç»æç ï¼0è¡¨ç¤ºæ­£å¸¸æ§è¡
+*******************************************************/
+static bool goodix_init_panel(struct goodix_ts_data *ts)
+{
+	int ret = -1;
+	int i =0;
+	int count;
+	uint8_t config_info[54];
+	/*
+        uint8_t config_info[54] = { 0x30,0x19,0x05,0x06,0x28,0x02,0x14,0x20,0x10,0x3C,0xB0,0x14,0x00,
+                                    0x1E,0x00,0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xE1,0x00,0x00,
+                                    0x00,0x00,0x4D,0xCF,0x20,0x01,0x01,0x83,0x50,0x3C,0x1E,0xB4,
+                                    0x00,0x0A,0x50,0x78,0x1E,0x00,0x50,0x32,0x71,0x00,0x00,0x00,
+                                    0x00,0x00,0x00,0x00,0x01};
+                                    */
+    if((800 == screen_max_x) && (480 == screen_max_y)){
+        uint8_t data_info[54] = {0x30,0x19,0x05,0x04,0x28,0x02,0x14,0x20,0x10,0x50,0xB2,0x14,0x00,0x1E,0x00,0x01,
+                                      0x23,0x45,0x67,0x89,0xAB,0xCD,0xE1,0x00,0x00,0x2D,0x29,0x45,0xCF,0x20,0x01,0x01,
+                                      0x83,0x50,0x3C,0x1E,0xB4,0x00,0x2B,0x27,0x01,0xB4,0x00,0x64,0x32,0x71,0x00,0x00,
+                                      0x00,0x00,0x00,0x00,0x00,0x01};
+        for(i =0; i < 54; i++){
+            config_info[i] = data_info[i];
+        }
+
+    }else if((1280 == screen_max_x) && (768 == screen_max_y)){
+        uint8_t data_info[54] = {0x30,0x19,0x05,0x06,0x28,0x02,0x14,0x20,0x10,0x50,0xB2,0x14,0x00,0x1E,0x00,0x01,
+        	                            0x23,0x45,0x67,0x89,0xAB,0xCD,0xE1,0x00,0x00,0x2D,0x29,0x45,0xCF,0x20,0x01,
+        	                            0x01,0x83,0x50,0x3C,0x1E,0xB4,0x00,0x2B,0x27,0x01,0xB4,0x00,0x64,0x32,0x71,
+        	                            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01} ;
+        for(i =0; i < 54; i++){
+            config_info[i] = data_info[i];
+        }
+    }
+
+	for(count = 5; count > 0; count--)
+	{
+		ret = i2c_write_bytes(ts->client,config_info,54);;
+		if(ret == 1)		//Initiall success
+			break;
+		else
+			msleep(10);
+	}
+
+
+	return ret==1 ? true : false;
+}
+
+/*è¯»åGT80Xççæ¬å·å¹¶æå°*/
+static int  goodix_read_version(struct goodix_ts_data *ts)
+{
+#define GT80X_VERSION_LENGTH	40
+	int ret;
+	uint8_t version[2] = {0x69,0xff};			//command of reading Guitar's version
+	uint8_t version_data[GT80X_VERSION_LENGTH+1]={0x6A};	//store touchscreen version infomation
+	memset(version_data+1, 0, GT80X_VERSION_LENGTH);
+	ret = i2c_write_bytes(ts->client,version,2);
+	if (ret != 1)
+		return ret;
+	msleep(50);
+	ret = i2c_read_bytes(ts->client,version_data, GT80X_VERSION_LENGTH);
+	if (ret != 2)
+		strncpy(version_data+1, "NULL", 4);
+	dev_info(&ts->client->dev,"GT80X Version: %s\n", version_data+1);
+	version[1] = 0x00;				//cancel the command
+	i2c_write_bytes(ts->client, version, 2);
+	return 0;
+}
+
+
+/*******************************************************
+åè½ï¼
+	è§¦æ¸å±å·¥ä½å½æ°
+	ç±ä¸­æ­è§¦åï¼æ¥å1ç»åæ æ°æ®ï¼æ ¡éªåååæè¾åº
+åæ°ï¼
+	ts:	clientç§ææ°æ®ç»æä½
+returnï¼
+	æ§è¡ç»æç ï¼0è¡¨ç¤ºæ­£å¸¸æ§è¡
+********************************************************/
+static void goodix_ts_work_func(struct work_struct *work)
+{
+	static struct point_node pointer[MAX_FINGER_NUM];
+	static uint8_t finger_last = 0;	//last time fingers' state
+
+	struct point_node * p = NULL;
+	uint8_t read_position = 0;
+	uint8_t point_data[READ_BYTES_NUM]={ 0 };
+	uint8_t finger, finger_current;				//record which finger is changed
+	uint8_t check_sum = 0;
+	unsigned int x, y;
+	int count = 0;
+	int ret = -1;
+
+	struct goodix_ts_data *ts = container_of(work, struct goodix_ts_data, work);
+
+//	if (ts->use_shutdown && gpio_get_value(ts->gpio_shutdown))
+//		goto NO_ACTION;					//The data is invalid.
+
+	ret=i2c_read_bytes(ts->client, point_data, sizeof(point_data));
+	if(ret <= 0)
+	{
+		dev_dbg(&(ts->client->dev),"I2C transfer error. ERROR Number:%d\n ", ret);
+		ts->retry++;
+		if(ts->retry >= 100)
+		{	//It's not normal for too much i2c-error.
+			dev_err(&(ts->client->dev),"Reset the chip for i2c error.\n ");
+			ts->retry = 0;
+			if(ts->power)
+			{
+				ts->power(ts, 0);
+				ts->power(ts, 1);
+			}
+			else
+			{
+				goodix_init_panel(ts);
+				msleep(200);
+			}
+		}
+		goto XFER_ERROR;
+	}
+
+	switch(point_data[1]& 0x1f)
+	{
+		case 0:
+			break;
+		case 1:
+			for(count=1; count<8; count++)
+				check_sum += (int)point_data[count];
+			read_position = 8;
+			break;
+		case 2:
+		case 3:
+			for(count=1; count<13;count++)
+				check_sum += (int)point_data[count];
+			read_position = 13;
+			break;
+		default:		//(point_data[1]& 0x1f) > 3
+			for(count=1; count<34;count++)
+				check_sum += (int)point_data[count];
+			read_position = 34;
+	}
+
+	if(check_sum != point_data[read_position])
+		goto XFER_ERROR;
+
+	//The bits indicate which fingers pressed down
+	finger_current = point_data[1] & 0x1f;
+	finger = finger_current^finger_last;
+	if(finger == 0 && finger_current == 0)
+		goto NO_ACTION;					//no action
+	else if(finger == 0)
+		goto BIT_NO_CHANGE;				//the same as last time
+
+	//check which point(s) DOWN or UP
+	for(count = 0; count < MAX_FINGER_NUM;  count++)
+	{
+		p = &pointer[count];
+		p->id = count;
+		if((finger_current & FLAG_MASK) != 0)
+			p->state = FLAG_DOWN;
+		else
+		{
+			if((finger & FLAG_MASK) != 0)		//send press release.
+				p->state = FLAG_UP;
+			else
+				p->state = FLAG_INVALID;
+		}
+
+		finger>>=1;
+		finger_current>>=1;
+	}
+	finger_last = point_data[1] & 0x1f;	//restore last presse state.
+BIT_NO_CHANGE:
+	for(count = 0; count < MAX_FINGER_NUM; count++)
+	{
+		p = &pointer[count];
+		if(p->state == FLAG_INVALID)
+			continue;
+
+		if(p->state == FLAG_UP)
+		{
+			x = y = 0;
+			p->pressure = 0;
+			continue;
+		}
+
+		if(p->id < 3)
+			read_position = p->id *5 + 3;
+		else
+			read_position = 29;
+
+		if(p->id != 3)
+		{
+			x = (unsigned int) (point_data[read_position]<<8) + (unsigned int)( point_data[read_position+1]);
+			y = (unsigned int)(point_data[read_position+2]<<8) + (unsigned int) (point_data[read_position+3]);
+			p->pressure = point_data[read_position+4];
+		}
+	#if MAX_FINGER_NUM > 3
+		else
+		{
+			x = (unsigned int) (point_data[18]<<8) + (unsigned int)( point_data[25]);
+			y = (unsigned int)(point_data[26]<<8) + (unsigned int) (point_data[27]);
+			p->pressure = point_data[28];
+		}
+	#endif
+
+		// å°è§¦æ¸å±çåæ æ å°å°LCDåæ ä¸. è§¦æ¸å±ç­è¾¹ä¸ºXè½´ï¼LCDåæ ä¸è¬é¿è¾¹ä¸ºXè½´ï¼å¯è½éè¦è°æ´åç¹ä½ç½®
+		x = (TOUCH_MAX_WIDTH - x)*SCREEN_MAX_WIDTH/TOUCH_MAX_WIDTH;//y
+		y =  y*SCREEN_MAX_HEIGHT/TOUCH_MAX_HEIGHT ;					//x
+		//print_point_info("RAW X = %d,Y = %d\n",800-y,x);
+		if(1 == revert_x_flag){
+			x = SCREEN_MAX_WIDTH - x;
+			}
+		if(1 == revert_y_flag){
+			y = SCREEN_MAX_HEIGHT - y;
+			}
+		swap(x, y);
+		p->x = x;
+		p->y = y;
+	}
+#ifndef GOODIX_MULTI_TOUCH
+		if(pointer[0].state == FLAG_DOWN)
+		{
+			input_report_abs(ts->input_dev, ABS_X, pointer[0].x);
+			input_report_abs(ts->input_dev, ABS_Y, pointer[0].y);
+		}
+		input_report_abs(ts->input_dev, ABS_PRESSURE, pointer[0].pressure);
+		input_report_key(ts->input_dev, BTN_TOUCH, pointer[0].state == FLAG_INVALID?FLAG_UP:pointer[0].state);
+#else
+	/* ABS_MT_TOUCH_MAJOR is used as ABS_MT_PRESSURE in android. */
+	for(count = 0; count < MAX_FINGER_NUM; count++)
+	{
+		p = &pointer[count];
+
+		if(p->state == FLAG_INVALID)
+			continue;
+
+		if(p->state == FLAG_DOWN)
+		{
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X, p->x);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, p->y);
+			//dev_dbg(&(ts->client->dev), "Id:%d, x:%d, y:%d\n", p->id, p->x, p->y);
+
+			print_point_info("Id:%d, x:%d, y:%d\n", p->id, p->x, p->y);
+		}
+		input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, p->id);
+		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, p->pressure);
+		input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, p->pressure);
+
+		input_mt_sync(ts->input_dev);
+	}
+#endif
+	input_sync(ts->input_dev);
+XFER_ERROR:
+NO_ACTION:
+         ret = 0;
+	//enable_irq(ts->gpio_irq);
+
+}
+
+
+
+/*******************************************************
+åè½ï¼
+	ä¸­æ­ååºå½æ°
+	ç±ä¸­æ­è§¦åï¼è°åº¦è§¦æ¸å±å¤çå½æ°è¿è¡
+********************************************************/
+static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
+{
+	struct goodix_ts_data *ts = dev_id;
+	int reg_val;
+	print_int_info("==========------TS Interrupt-----============\n");
+
+	//clear the IRQ_EINT21 interrupt pending
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+
+	if (reg_val&(1<<(CTP_IRQ_NO))) {
+		print_int_info("==CTP_IRQ_NO=\n");
+		writel(reg_val&(1<<(CTP_IRQ_NO)),gpio_addr + PIO_INT_STAT_OFFSET);
+		queue_work(goodix_wq, &ts->work);
+	} else {
+	    print_int_info("Other Interrupt\n");
+	    return IRQ_NONE;
+	}
+	return IRQ_HANDLED;
+}
+
+/*******************************************************
+åè½ï¼
+	GT80Xççµæºç®¡ç
+åæ°ï¼
+	on:è®¾ç½®GT80Xè¿è¡æ¨¡å¼ï¼0ä¸ºè¿å¥Sleepæ¨¡å¼
+returnï¼
+	æ¯å¦è®¾ç½®æåï¼å°äº0è¡¨ç¤ºè®¾ç½®å¤±è´¥
+********************************************************/
+static int goodix_ts_power(struct goodix_ts_data * ts, int on)
+{
+	int ret = 0;
+
+	switch(on)
+	{
+		case 0:
+			gpio_write_one_pin_value(gpio_wakeup_hdle, 1, "ctp_wakeup");
+			ret = 1;
+			break;
+		case 1:
+			gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+			ret = 1;
+			break;
+	}
+	dev_dbg(&ts->client->dev, "Set Guitar's Shutdown %s. Ret:%d.\n", on?"LOW":"HIGH", ret);
+	return ret;
+}
+
+//Test i2c to check device. Before it SHUTDOWN port Must be low state 30ms or more.
+static bool goodix_i2c_test(struct i2c_client * client)
+{
+	int ret, retry;
+	uint8_t test_data[1] = { 0 };	//only write a data address.
+
+	for(retry=0; retry < 5; retry++)
+	{
+		ret =i2c_write_bytes(client, test_data, 1);	//Test i2c.
+		if (ret == 1)
+			break;
+		msleep(5);
+	}
+
+	return ret==1 ? true : false;
+}
+
+/*******************************************************
+åè½ï¼
+	è§¦æ¸å±æ¢æµå½æ°
+	å¨æ³¨åé©±å¨æ¶è°ç¨ï¼è¦æ±å­å¨å¯¹åºçclientï¼ï¼
+	ç¨äºIO,ä¸­æ­ç­èµæºç³è¯·ï¼è®¾å¤æ³¨åï¼è§¦æ¸å±åå§åç­å·¥ä½
+åæ°ï¼
+	clientï¼å¾é©±å¨çè®¾å¤ç»æä½
+	idï¼è®¾å¤ID
+returnï¼
+	æ§è¡ç»æç ï¼0è¡¨ç¤ºæ­£å¸¸æ§è¡
+********************************************************/
+static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct goodix_ts_data *ts;
+	int ret = 0;
+	int err;
+
+	//struct goodix_i2c_platform_data *pdata;
+	//dev_dbg(&client->dev,"Install touchscreen driver for guitar.\n");
+	pr_info("===============================GT801 Probe===========================\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)){
+		dev_err(&client->dev, "System need I2C function.\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	ts->gpio_irq = SW_INT_IRQNO_PIO;
+	i2c_connect_client = client;				//used by Guitar Updating.
+
+#ifdef TEST_I2C_TRANSFER
+	//TODO: used to set speed of i2c transfer. Should be change as your paltform.
+	pr_info("Begin goodix i2c test\n");
+	ret = goodix_i2c_test(client);
+	if(!ret){
+		pr_info("Warnning: I2C connection might be something wrong!\n");
+		goto err_i2c_failed;
+	}
+	pr_info("===== goodix i2c test ok=======\n");
+#endif
+
+	INIT_WORK(&ts->work, goodix_ts_work_func);
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL)
+	{
+		ret = -ENOMEM;
+		dev_dbg(&client->dev,"Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+
+	ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+
+#ifndef GOODIX_MULTI_TOUCH
+	ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+	input_set_abs_params(ts->input_dev, ABS_X, 0, SCREEN_MAX_HEIGHT, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, SCREEN_MAX_WIDTH, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+
+#else
+	ts->input_dev->absbit[0] = BIT_MASK(ABS_MT_TRACKING_ID) |
+		BIT_MASK(ABS_MT_TOUCH_MAJOR)| BIT_MASK(ABS_MT_WIDTH_MAJOR) |
+  		BIT_MASK(ABS_MT_POSITION_X) | BIT_MASK(ABS_MT_POSITION_Y); 	// for android
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, SCREEN_MAX_HEIGHT, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, SCREEN_MAX_WIDTH, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, MAX_FINGER_NUM, 0, 0);
+#endif
+
+#ifdef FOR_TSLIB_TEST
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
+#endif
+
+	sprintf(ts->phys, "input/goodix-ts");
+	ts->input_dev->name = f3x_ts_name;
+	ts->input_dev->phys = ts->phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->id.vendor = 0xDEAD;
+	ts->input_dev->id.product = 0xBEEF;
+	ts->input_dev->id.version = 0x1105;
+
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		dev_err(&client->dev,"Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+
+	goodix_wq = create_singlethread_workqueue("goodix_wq");
+	if (!goodix_wq) {
+		printk(KERN_ALERT "Creat %s workqueue failed.\n", f3x_ts_name);
+		return -ENOMEM;
+
+	}
+	flush_workqueue(goodix_wq);
+	ts->power = goodix_ts_power;
+	msleep(30);
+
+	ret = goodix_init_panel(ts);
+	if(!ret)
+		goto err_init_godix_ts;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	printk("==register_early_suspend =\n");
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = goodix_ts_suspend;
+	ts->early_suspend.resume	= goodix_ts_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+	err = ctp_ops.set_irq_mode("ctp_para", "ctp_int_port", CTP_IRQ_MODE);
+	if(0 != err){
+		printk("%s:ctp_ops.set_irq_mode err. \n", __func__);
+		goto exit_set_irq_mode;
+	}
+
+	err =  request_irq(SW_INT_IRQNO_PIO, goodix_ts_irq_handler, IRQF_TRIGGER_RISING | IRQF_SHARED, client->name, ts);
+	if (err < 0) {
+		pr_info( "goodix_probe: request irq failed\n");
+		goto exit_irq_request_failed;
+	}
+
+	pr_info("Read Goodix version\n");
+	goodix_read_version(ts);
+	//msleep(260);
+
+	dev_dbg(&client->dev,"Start  %s in %s mode\n",
+		ts->input_dev->name, ts->use_irq ? "Interrupt" : "Polling");
+
+	pr_info("========Probe Ok================\n");
+	return 0;
+
+exit_set_irq_mode:
+exit_irq_request_failed:
+err_init_godix_ts:
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+err_input_dev_alloc_failed:
+	i2c_set_clientdata(client, NULL);
+err_i2c_failed:
+err_alloc_data_failed:
+err_check_functionality_failed:
+	return ret;
+}
+
+
+/*******************************************************
+åè½ï¼
+	é©±å¨èµæºéæ¾
+åæ°ï¼
+	clientï¼è®¾å¤ç»æä½
+returnï¼
+	æ§è¡ç»æç ï¼0è¡¨ç¤ºæ­£å¸¸æ§è¡
+********************************************************/
+static int goodix_ts_remove(struct i2c_client *client)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+	dev_notice(&client->dev,"The driver is removing...\n");
+
+	free_irq(SW_INT_IRQNO_PIO, ts);
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&ts->early_suspend);
+	#endif
+	flush_workqueue(goodix_wq);
+	if (goodix_wq)
+		destroy_workqueue(goodix_wq);
+	input_unregister_device(ts->input_dev);
+	input_free_device(ts->input_dev);
+	i2c_set_clientdata(ts->client, NULL);
+	kfree(ts);
+	return 0;
+}
+
+//å¯ç¨äºè¯¥é©±å¨ç è®¾å¤åâè®¾å¤ID åè¡¨
+//only one client
+static const struct i2c_device_id goodix_ts_id[] = {
+	{ GOODIX_I2C_NAME, 0 },
+	{ }
+};
+
+//è®¾å¤é©±å¨ç»æä½
+static struct i2c_driver goodix_ts_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe		= goodix_ts_probe,
+	.remove		= goodix_ts_remove,
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#else
+#ifdef CONFIG_PM
+	.suspend	= goodix_ts_suspend,
+	.resume		= goodix_ts_resume,
+#endif
+#endif
+	.id_table	= goodix_ts_id,
+	.driver = {
+		.name	= GOODIX_I2C_NAME,
+		.owner = THIS_MODULE,
+	},
+	.address_list	= u_i2c_addr.normal_i2c,
+};
+
+
+//é©±å¨å è½½å½æ°
+static int __devinit goodix_ts_init(void)
+{
+	int ret = -1;
+	int err = -1;
+
+	printk("===========================%s=====================\n", __func__);
+
+	if (ctp_ops.fetch_sysconfig_para)
+	{
+		if(ctp_ops.fetch_sysconfig_para()){
+			printk("%s: err.\n", __func__);
+			return -1;
+		}
+	}
+	printk("%s: after fetch_sysconfig_para:  normal_i2c: 0x%hx. normal_i2c[1]: 0x%hx \n", \
+	__func__, u_i2c_addr.normal_i2c[0], u_i2c_addr.normal_i2c[1]);
+
+	err = ctp_ops.init_platform_resource();
+	if(0 != err){
+		printk("%s:ctp_ops.init_platform_resource err. \n", __func__);
+	}
+
+	//reset
+	ctp_ops.ts_reset();
+	//wakeup
+	ctp_ops.ts_wakeup();
+
+	goodix_ts_driver.detect = ctp_ops.ts_detect;
+
+	ret = i2c_add_driver(&goodix_ts_driver);
+
+	return ret;
+}
+
+//é©±å¨å¸è½½å½æ°
+static void __exit goodix_ts_exit(void)
+{
+	i2c_del_driver(&goodix_ts_driver);
+	ctp_ops.free_platform_resource();
+
+	return;
+}
+
+late_initcall(goodix_ts_init);
+module_exit(goodix_ts_exit);
+
+MODULE_DESCRIPTION("Goodix Touchscreen Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/goodix_touch.h b/drivers/input/touchscreen/goodix_touch.h
new file mode 100644
index 0000000..b79a33a
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_touch.h
@@ -0,0 +1,101 @@
+/*
+ * include/linux/goodix_touch.h
+ *
+ * Copyright (C) 2008 Goodix, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef 	_LINUX_GOODIX_TOUCH_H
+#define		_LINUX_GOODIX_TOUCH_H
+
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+
+#define GOODIX_I2C_NAME "Goodix-TS"
+#define GUITAR_GT80X
+//è§¦æ¸å±çåè¾¨ç
+#define TOUCH_MAX_HEIGHT 	7680	
+#define TOUCH_MAX_WIDTH	 	5120
+//æ¾ç¤ºå±çåè¾¨çï¼æ ¹æ®å·ä½å¹³å°æ´æ¹ï¼ä¸è§¦æ¸å±æ å°åæ ç¸å³
+
+
+
+#define SHUTDOWN_PORT                ()
+#define INT_PORT                     (SW_INT_IRQNO_PIO)
+
+#define GOODIX_MULTI_TOUCH
+#ifndef GOODIX_MULTI_TOUCH
+	#define MAX_FINGER_NUM 5
+#else
+	#define MAX_FINGER_NUM 5				//æå¤§æ¯ææææ°(<=5)
+#endif
+#if defined(INT_PORT)
+	#if MAX_FINGER_NUM <= 3
+	#define READ_BYTES_NUM 1+2+MAX_FINGER_NUM*5
+	#elif MAX_FINGER_NUM == 4
+	#define READ_BYTES_NUM 1+28
+	#elif MAX_FINGER_NUM == 5
+	#define READ_BYTES_NUM 1+34
+	#endif
+#else	
+	#define READ_BYTES_NUM 1+34
+#endif
+
+//#define swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
+
+enum finger_state {
+#define FLAG_MASK 0x01
+	FLAG_UP = 0,
+	FLAG_DOWN = 1,
+	FLAG_INVALID = 2,
+};
+
+
+struct point_node
+{
+	uint8_t id;
+	//uint8_t retry;
+	enum finger_state state;
+	uint8_t pressure;
+	unsigned int x;
+	unsigned int y;
+};
+struct ts_event {
+	u16	x1;
+	u16	y1;
+	u16	x2;
+	u16	y2;
+	u16	x3;
+	u16	y3;
+	u16	x4;
+	u16	y4;
+	u16	x5;
+	u16	y5;
+	u16	pressure;
+    u8  touch_point;
+};
+
+/* Notice: This definition used by platform_data.
+ * It should be move this struct info to platform head file such as plat/ts.h.
+ * If not used in client, it will be NULL in function of goodix_ts_probe. 
+ */ 
+struct goodix_i2c_platform_data {
+	uint32_t gpio_irq;			//IRQ port, use macro such as "gpio_to_irq" to get Interrupt Number.
+	uint32_t irq_cfg;			//IRQ port config, must refer to master's Datasheet.
+	uint32_t gpio_shutdown;		        //Shutdown port number
+	uint32_t shutdown_cfg;		        //Shutdown port config
+	uint32_t screen_width;		        //screen width
+	uint32_t screen_height;		        //screen height
+}; 
+
+#endif /* _LINUX_GOODIX_TOUCH_H */
diff --git a/drivers/input/touchscreen/gt811_firmware.h b/drivers/input/touchscreen/gt811_firmware.h
new file mode 100644
index 0000000..6b4c44a
--- /dev/null
+++ b/drivers/input/touchscreen/gt811_firmware.h
@@ -0,0 +1,274 @@
+/* drivers/input/touchscreen/gt811_update.h
+ *
+ * Copyright (C) 2010 - 2011 Goodix, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *Any problem,please contact andrew@goodix.com,+86 755-33338828
+ *
+ */
+
+#ifndef 	_LINUX_GT811_UPDATE_H
+#define		_LINUX_GT811_UPDATE_H
+static unsigned char goodix_gt811_firmware[] = {
+    0x11,
+    0x10,0x10,
+    0x45,
+    0x00,0x00,0x00,
+    0x41,0x00,
+    0x0e,0xf0,
+    0x06,0x24,0xad,
+    0x00,0x00,0x00,0x00,0x00,0x00,
+    /*'G','O','O','D','I','X',*/
+    
+    0x4f,0xce,0x01,0x00,0x20,0x03,0xa7,0x00,0x08,0x8c,0x05,0xdf,
+    0x26,0xf8,0x8e,0x05,0xdf,0xbd,0x41,0x16,0x20,0xfe,0x0e,0xbd,0xc2,0xd4,0xbd,0x4d,
+    0x8c,0xbd,0x4d,0xc2,0xbd,0x41,0xb0,0xbd,0x47,0x61,0xbd,0x46,0x59,0xbd,0xf7,0x38,
+    0x20,0x10,0x01,0x01,0x01,0x01,0x13,0xe6,0x01,0x08,0xd6,0xeb,0x26,0x04,0x01,0xcf,
+    0x01,0x01,0xd6,0xeb,0x27,0xec,0xd6,0xe7,0x5c,0x26,0xe7,0xd7,0xeb,0xbd,0x46,0xf4,
+    0xbd,0xc4,0x73,0xf6,0x07,0x0b,0x27,0x0f,0xbd,0x46,0xf8,0xbd,0x46,0x59,0xc6,0x80,
+    0xd7,0xea,0xbd,0xf7,0x38,0x20,0xdb,0xbd,0xd4,0xb8,0xd6,0xea,0x5a,0x27,0x08,0xbd,
+    0xf5,0x3c,0xbd,0xf7,0x38,0x20,0xcb,0x8d,0x64,0xbd,0x4c,0x90,0xbd,0xe9,0xd4,0xbd,
+    0x4b,0xd7,0xbd,0x49,0x4c,0xbd,0xeb,0xe8,0xbd,0xf7,0x38,0xbd,0x42,0xa9,0xbd,0x47,
+    0x87,0xbd,0x48,0xde,0xbd,0xd7,0xa2,0xbd,0x4b,0x41,0xbd,0xdb,0x6a,0xbd,0xef,0x1c,
+    0xbd,0xdf,0x8d,0xbd,0xe3,0x51,0xbd,0xe3,0x71,0xbd,0xd5,0xa8,0xbd,0x4e,0x29,0xbd,
+    0xef,0x95,0x20,0x8e,0x3c,0x34,0x30,0xbd,0xc7,0x1c,0xc6,0x5d,0x18,0xce,0x14,0x01,
+    0x18,0xe7,0x00,0xbd,0x46,0x27,0xf7,0x07,0x10,0x56,0x56,0x56,0xc4,0xc0,0xe7,0x00,
+    0xf6,0x07,0x21,0xc4,0x3f,0xea,0x00,0xf7,0x07,0x21,0x31,0x38,0x39,0xd6,0xef,0x26,
+    0x1a,0xc6,0x01,0xd7,0xef,0xfe,0x01,0x28,0x3c,0xcc,0x0b,0x00,0xfd,0x01,0x28,0xbd,
+    0x48,0x38,0xdd,0xf2,0xfd,0x02,0xf7,0x38,0xff,0x01,0x28,0x39,0x3c,0xd6,0xf5,0x26,
+    0x03,0x7e,0x42,0x86,0xd6,0xac,0x5a,0x26,0x6e,0xfc,0x02,0x89,0x83,0x0d,0x80,0xce,
+    0x00,0x14,0x02,0x8f,0x37,0xce,0x0b,0xa0,0x18,0xfe,0x01,0x28,0x32,0x81,0x08,0x23,
+    0x0a,0x80,0x08,0xc6,0xa0,0x3a,0x3a,0x18,0x3a,0x18,0x3a,0xc6,0x14,0x3d,0x3a,0x18,
+    0x3a,0x5f,0xd7,0x69,0xec,0x00,0x18,0xa3,0x00,0x7d,0x00,0x69,0x26,0x06,0xfd,0x02,
+    0xfc,0xfd,0x02,0xfe,0x1a,0xb3,0x02,0xfc,0x2f,0x03,0xfd,0x02,0xfc,0x1a,0xb3,0x02,
+    0xfe,0x2c,0x03,0xfd,0x02,0xfe,0x08,0x08,0x18,0x08,0x18,0x08,0x7c,0x00,0x69,0xd6,
+    0x69,0xd1,0xc2,0x25,0xcf,0xd6,0xca,0x4f,0xf3,0x02,0xfe,0xb3,0x02,0xfc,0x2d,0x07,
+    0xf6,0x02,0xf1,0xcb,0x02,0x20,0x06,0xf6,0x02,0xf1,0x27,0x01,0x5a,0xf7,0x02,0xf1,
+    0xc1,0xfa,0x25,0x06,0xbd,0x49,0x43,0x7f,0x00,0xf5,0x38,0x39,0x3c,0xce,0x07,0x12,
+    0xc6,0xa0,0xe7,0x00,0x5f,0xce,0x07,0x1d,0xe7,0x00,0x08,0x8c,0x07,0x48,0x23,0xf8,
+    0xce,0x02,0xc4,0xe7,0x00,0x08,0x8c,0x02,0xec,0x25,0xf8,0x38,0x39,0x7f,0x03,0x33,
+    0xbd,0xc5,0x25,0x13,0xe6,0x04,0x02,0x8d,0x49,0xbd,0x44,0x46,0xcc,0x01,0xc2,0xd0,
+    0xda,0x82,0x00,0xd0,0xda,0x82,0x00,0xf3,0x02,0x90,0xfd,0x02,0x90,0x39,0x3c,0x18,
+    0x3c,0x86,0x14,0xf6,0x03,0x33,0x3d,0xc3,0x0d,0x80,0x18,0x8f,0xce,0x02,0x2c,0xd6,
+    0xc2,0xd7,0x6a,0xec,0x00,0x13,0xe6,0x40,0x02,0x47,0x56,0x18,0xed,0x00,0xc6,0x02,
+    0x3a,0x18,0x3a,0x7a,0x00,0x6a,0x26,0xeb,0x4f,0x97,0xd1,0x7c,0x03,0x33,0x18,0x38,
+    0x38,0x39,0x3c,0x18,0x3c,0xce,0x03,0x34,0x4f,0xc6,0xa0,0xa7,0x00,0x08,0x5a,0x26,
+    0xfa,0x96,0xc1,0xb7,0x02,0x6f,0x18,0xce,0x0d,0x80,0xce,0x03,0x34,0xd6,0xc2,0xf7,
+    0x02,0x6e,0x18,0x3c,0x4f,0x5f,0x18,0xe3,0x00,0x18,0x08,0x18,0x08,0x7a,0x02,0x6e,
+    0x26,0xf4,0xfd,0x03,0x31,0x18,0x38,0x3c,0x4f,0xd6,0xc2,0x8f,0xfc,0x03,0x31,0x2a,
+    0x0c,0x40,0x50,0x82,0x00,0x02,0x8f,0x40,0x50,0x82,0x00,0x20,0x02,0x02,0x8f,0xfd,
+    0x03,0x31,0x38,0x96,0xc2,0xb7,0x02,0x6e,0x18,0x3c,0x18,0xec,0x00,0xb3,0x03,0x31,
+    0x18,0xed,0x00,0x2d,0x04,0x2e,0x0d,0x20,0x18,0x6c,0x01,0x1a,0xa3,0x06,0x2c,0x11,
+    0xed,0x06,0x20,0x0d,0x6c,0x00,0x1a,0xa3,0x04,0x2f,0x02,0xed,0x04,0xe3,0x02,0xed,
+    0x02,0x18,0x08,0x18,0x08,0x7a,0x02,0x6e,0x26,0xd0,0x18,0x38,0xc6,0x0a,0x3a,0x58,
+    0x18,0x3a,0x7a,0x02,0x6f,0x26,0x86,0xce,0x03,0x34,0x96,0xc1,0xb7,0x02,0x6f,0x4a,
+    0xb7,0x03,0x29,0xb7,0x03,0x2a,0x4f,0xd6,0xc9,0xc0,0x0a,0xa3,0x04,0xe3,0x06,0x2b,
+    0x15,0xd6,0xc1,0xf0,0x02,0x6f,0xb6,0x03,0x29,0xb1,0x03,0x2a,0x27,0x05,0xf7,0x03,
+    0x29,0x20,0x03,0xf7,0x03,0x2a,0xc6,0x0a,0x3a,0x7a,0x02,0x6f,0x26,0xd8,0x8d,0x11,
+    0xf6,0x03,0x29,0xf7,0x03,0x2a,0x8d,0x09,0xbd,0x45,0xff,0x8d,0x3a,0x18,0x38,0x38,
+    0x39,0x7f,0x03,0x2c,0xf6,0x03,0x2a,0xf7,0x02,0x6f,0xd6,0xc2,0xd7,0x68,0xbd,0x45,
+    0x1a,0xbd,0x45,0xc2,0x7c,0x02,0x6f,0xf6,0x02,0x6f,0xd1,0xc1,0x26,0xf0,0x7f,0x03,
+    0x2c,0xf6,0x03,0x2a,0xf7,0x02,0x6f,0xd6,0xc2,0xd7,0x68,0xbd,0x45,0x1a,0xbd,0x45,
+    0xc2,0x7a,0x02,0x6f,0x2a,0xf5,0x39,0x18,0xce,0x03,0x34,0xce,0x0d,0x80,0x96,0xc1,
+    0xb7,0x02,0x6f,0x18,0x67,0x08,0x18,0x66,0x09,0x96,0xc2,0xb7,0x02,0x6e,0x3c,0xec,
+    0x00,0x18,0xe3,0x08,0xed,0x00,0x08,0x08,0x7a,0x02,0x6e,0x26,0xf2,0x38,0xc6,0x0a,
+    0x18,0x3a,0x58,0x3a,0x7a,0x02,0x6f,0x26,0xda,0x39,0x3c,0x4f,0x5f,0xb7,0x02,0x81,
+    0xb7,0x02,0x80,0x97,0xe2,0x97,0xe1,0x97,0x68,0x97,0x67,0x18,0xce,0x0d,0x80,0xce,
+    0x0d,0x80,0xff,0x02,0x89,0xff,0x02,0x87,0xd6,0xc1,0xd7,0x6a,0x3c,0x18,0x3c,0xd6,
+    0xc2,0xd7,0x69,0x18,0xec,0x00,0x18,0x6f,0x00,0x18,0x6f,0x01,0x4d,0x2a,0x28,0x40,
+    0x50,0x82,0x00,0x4d,0x27,0x02,0xc6,0xff,0xd1,0xc9,0x23,0x03,0x7c,0x00,0xe1,0xf1,
+    0x02,0x7f,0x23,0x03,0x7c,0x02,0x80,0x4f,0xa7,0x00,0xf3,0x02,0x90,0xfd,0x02,0x90,
+    0x86,0x02,0xb7,0x03,0x25,0x20,0x4d,0xd0,0xfb,0x82,0x00,0x2a,0x02,0x4f,0x5f,0x4d,
+    0x27,0x02,0xc6,0xff,0xd1,0xc9,0x22,0x04,0x86,0x02,0x20,0x04,0x7c,0x00,0xe2,0x4f,
+    0xb7,0x03,0x25,0xf1,0x02,0x7f,0x23,0x03,0x7c,0x02,0x81,0xe7,0x00,0x4f,0xf3,0x02,
+    0x90,0xfd,0x02,0x90,0xe6,0x00,0xd1,0x68,0x23,0x11,0x96,0x68,0x97,0x67,0xd7,0x68,
+    0xfc,0x02,0x89,0xfd,0x02,0x87,0xff,0x02,0x89,0x20,0x09,0xd1,0x67,0x23,0x05,0xd7,
+    0x67,0xff,0x02,0x87,0x3c,0xc6,0xa0,0x3a,0x3a,0xf6,0x03,0x25,0xe7,0x00,0x38,0x08,
+    0xc6,0x02,0x18,0x3a,0x7a,0x00,0x69,0x27,0x03,0x7e,0x44,0x6f,0x18,0x38,0x38,0xc6,
+    0x14,0x3a,0x18,0x3a,0x7a,0x00,0x6a,0x27,0x03,0x7e,0x44,0x68,0x38,0x39,0xce,0x03,
+    0x34,0xf6,0x02,0x6f,0x86,0x0a,0x3d,0x3a,0xec,0x00,0x3d,0x5d,0xfd,0x03,0x26,0x27,
+    0x6e,0x86,0x01,0xf6,0x03,0x2c,0x27,0x10,0x5a,0x27,0x18,0x5a,0x27,0x26,0xf6,0x03,
+    0x2b,0x27,0x05,0x5a,0x27,0x28,0x20,0x08,0xe6,0x00,0xe1,0x01,0x22,0x02,0x20,0x1e,
+    0x4f,0x20,0x1b,0xf6,0x03,0x2b,0xc1,0x02,0x27,0x14,0xe6,0x00,0xd0,0x68,0xc1,0x04,
+    0x2e,0xe6,0x20,0x1a,0x4f,0xf6,0x03,0x2b,0xc1,0x01,0x27,0x02,0x20,0x08,0xb7,0x03,
+    0x28,0x4f,0xd6,0xc2,0x20,0x0e,0xb7,0x03,0x28,0x4f,0xe6,0x00,0x20,0x06,0xb7,0x03,
+    0x28,0x4f,0xe6,0x01,0xfd,0x03,0x31,0xec,0x02,0x3c,0xfe,0x03,0x31,0x02,0x8f,0x38,
+    0xfd,0x03,0x26,0x4f,0xf6,0x03,0x28,0x26,0x06,0xb3,0x03,0x26,0xfd,0x03,0x26,0xec,
+    0x04,0xf3,0x03,0x26,0xfd,0x03,0x2f,0xec,0x06,0xf3,0x03,0x26,0xfd,0x03,0x2d,0xec,
+    0x08,0xf3,0x03,0x26,0xed,0x08,0xfc,0x03,0x2d,0x47,0x56,0x47,0x56,0xe3,0x08,0xed,
+    0x08,0xe6,0x00,0xd7,0x68,0x39,0xf6,0x03,0x2c,0xc1,0x03,0x2c,0x03,0xf7,0x03,0x2b,
+    0x7f,0x03,0x2c,0x4f,0xd6,0xc9,0xc0,0x0a,0x1a,0xb3,0x03,0x2f,0x2c,0x03,0x7c,0x03,
+    0x2c,0x40,0x50,0x82,0x00,0x1a,0xb3,0x03,0x2d,0x2f,0x06,0x7c,0x03,0x2c,0x7c,0x03,
+    0x2c,0xf6,0x03,0x2c,0xc1,0x03,0x26,0x0a,0xf6,0x03,0x2b,0x26,0x05,0xc6,0x01,0xf7,
+    0x03,0x2c,0x39,0x3c,0x18,0x3c,0xce,0x03,0x34,0x18,0xce,0x03,0x05,0xd6,0xc1,0x37,
+    0xec,0x08,0x18,0xe3,0x00,0x47,0x56,0xed,0x08,0x18,0xed,0x00,0xc6,0x08,0x3a,0x18,
+    0x08,0x18,0x08,0x33,0x5a,0x26,0xe8,0x18,0x38,0x38,0x39,0x3c,0xce,0x16,0x00,0x1d,
+    0x00,0x02,0x1c,0x06,0x02,0x1d,0x07,0x02,0xbd,0xef,0x0d,0x1e,0x02,0x02,0x07,0x1d,
+    0x06,0x02,0xc6,0x02,0x20,0x15,0x1d,0x06,0x02,0x1c,0x07,0x02,0xbd,0xef,0x0d,0x1f,
+    0x02,0x02,0x07,0x1d,0x07,0x02,0xc6,0x01,0x20,0x01,0x5f,0x38,0x39,0x3c,0x34,0x30,
+    0xbd,0xc8,0x97,0xd6,0x6a,0x4f,0xc3,0x07,0x92,0x18,0x8f,0xcc,0x42,0xca,0x18,0xed,
+    0x01,0xbd,0x42,0x88,0x8d,0xb5,0xf7,0x07,0x10,0x56,0x56,0x56,0xc4,0xc0,0xe7,0x00,
+    0xf6,0x07,0x21,0xc4,0x3f,0xea,0x00,0xf7,0x07,0x21,0x7f,0x02,0xc2,0xcc,0x80,0x00,
+    0xfd,0x01,0x2e,0xf6,0x06,0xec,0xc4,0x0f,0xd7,0xfb,0x5f,0xd7,0xf5,0xd7,0xf4,0xf7,
+    0x02,0xfb,0xd7,0xef,0xd7,0xc8,0xd7,0x6a,0x86,0x03,0x3d,0x4f,0xc3,0x03,0xd8,0xfd,
+    0x03,0xd6,0xbd,0x4d,0x69,0xd6,0x6a,0x86,0x05,0x3d,0x4f,0xc3,0x03,0xe7,0x18,0x8f,
+    0x18,0x6f,0x04,0x7c,0x00,0x6a,0xd6,0x6a,0xc1,0x05,0x25,0xdc,0xbd,0x48,0x20,0xd6,
+    0xe6,0xc4,0x30,0xd7,0x68,0x26,0x0d,0xc6,0x0c,0xf7,0x02,0xed,0x5c,0xf7,0x02,0xee,
+    0xc6,0x0f,0x20,0x09,0xc6,0x0c,0xf7,0x02,0xed,0x5c,0xf7,0x02,0xee,0xf7,0x02,0xef,
+    0xc6,0x0a,0xf7,0x02,0xf0,0x31,0x38,0x39,0x7f,0x13,0x01,0x39,0xf6,0x07,0x21,0xc4,
+    0xc0,0xca,0x20,0xf7,0x07,0x21,0xc6,0xf0,0xf7,0x07,0x22,0x5f,0xd7,0xfa,0x8d,0xe8,
+    0xf6,0x07,0x0b,0x27,0x24,0x7f,0x07,0x0b,0xbd,0xf1,0x9e,0xf6,0x01,0x32,0x5a,0x26,
+    0x18,0xf6,0x07,0x21,0xc4,0xc0,0xf7,0x07,0x21,0x7f,0x07,0x22,0xbd,0xf1,0x4e,0xfc,
+    0x01,0x30,0xf7,0x07,0x0c,0xb7,0x07,0x0d,0x39,0x4f,0x5f,0xdd,0x75,0x8d,0xb9,0xbd,
+    0xef,0x0d,0xf6,0x07,0x0b,0x26,0xce,0xdc,0x75,0xc3,0x00,0x01,0xdd,0x75,0x83,0x07,
+    0xd0,0x25,0xea,0xd6,0xfa,0x26,0x05,0xbd,0xf7,0xd6,0x20,0x03,0xbd,0xf7,0xed,0xd6,
+    0xfa,0xc8,0x01,0x20,0xa7,0x7f,0x07,0x11,0xc6,0x02,0xf7,0x06,0x92,0xbd,0xf3,0x11,
+    0x39,0x39,0xd6,0xf5,0x26,0x0b,0x12,0xec,0x08,0x07,0xc6,0x01,0xd7,0xf5,0xbd,0x48,
+    0xbc,0x7f,0x02,0xf1,0xbd,0xd2,0x22,0x7f,0x02,0x84,0x39,0xd6,0xcb,0xc5,0x80,0x26,
+    0x01,0x39,0xbd,0x48,0x38,0x1a,0xb3,0x02,0xf7,0x24,0x03,0xfd,0x02,0xf7,0x37,0xf6,
+    0x02,0xf9,0x33,0x26,0x03,0xfd,0x02,0xf3,0x1a,0xb3,0x02,0xf3,0x23,0x05,0xb3,0x02,
+    0xf3,0x20,0x05,0xfc,0x02,0xf3,0x93,0xf0,0x1a,0x83,0x00,0xc8,0x25,0x03,0x8d,0x64,
+    0x39,0xdc,0xf0,0xd3,0xed,0x24,0x03,0x7c,0x02,0xfa,0xdd,0xed,0xd6,0xac,0xc1,0x02,
+    0x24,0x04,0x13,0xec,0x02,0x05,0xc6,0x01,0xf7,0x02,0xf2,0x7c,0x02,0xf9,0xf6,0x02,
+    0xf9,0xc1,0x10,0x26,0x3e,0xc6,0x04,0xd7,0x6a,0xdc,0xed,0x74,0x02,0xfa,0x46,0x56,
+    0x7a,0x00,0x6a,0x26,0xf6,0xfd,0x02,0xf5,0x93,0xf2,0x24,0x0c,0xdc,0xf2,0xb3,0x02,
+    0xf5,0x83,0x01,0xf4,0x23,0x02,0x8d,0x2a,0xfc,0x02,0xf7,0x37,0x36,0xfc,0x02,0xf5,
+    0xbd,0xf7,0xbb,0x31,0x31,0x83,0x00,0xc8,0x24,0x07,0xf6,0x02,0xf2,0x27,0x02,0x8d,
+    0x11,0x8d,0x01,0x39,0x5f,0xf7,0x02,0xf9,0xf7,0x02,0xfa,0x4f,0xb7,0x02,0xf2,0xdd,
+    0xed,0x39,0x7f,0x02,0x95,0x7f,0x02,0x94,0xbd,0x49,0x43,0x39,0x3c,0x18,0xfe,0x01,
+    0x28,0xfe,0x01,0x28,0xc6,0x14,0x3a,0x4f,0x5f,0xdd,0xf0,0xd7,0xbe,0x20,0x66,0xd6,
+    0xbe,0xc1,0x07,0x26,0x05,0xc6,0xa0,0x3a,0x20,0x08,0xc1,0x08,0x26,0x04,0xc6,0xa0,
+    0x18,0x3a,0x5f,0xd7,0xbf,0x20,0x3f,0x3c,0x18,0x3c,0x3c,0x18,0x3c,0x3c,0xce,0x06,
+    0xa2,0xd6,0xbf,0x3a,0xec,0x00,0x38,0x36,0x3a,0x18,0x3a,0xec,0x00,0x18,0xa3,0x00,
+    0xdd,0xcf,0x33,0x18,0x38,0x38,0x3a,0x18,0x3a,0x18,0xec,0x00,0xa3,0x00,0xd3,0xcf,
+    0x2a,0x05,0x43,0x53,0xc3,0x00,0x01,0xd3,0xf0,0x24,0x03,0xcc,0xff,0xff,0xdd,0xf0,
+    0x18,0x38,0x38,0x7c,0x00,0xbf,0xd6,0xc2,0x5a,0xd1,0xbf,0x22,0xba,0xc6,0x14,0x3a,
+    0x18,0x3a,0x7c,0x00,0xbe,0xd6,0xc0,0x5a,0xd1,0xbe,0x22,0x93,0xdc,0xf0,0x38,0x39,
+    0x3c,0x18,0x3c,0xce,0x0b,0x00,0x18,0xce,0x0c,0x40,0xec,0x00,0xed,0xa0,0x18,0xec,
+    0x00,0x18,0xed,0xa0,0xc6,0x02,0x3a,0x18,0x3a,0x8c,0x0b,0xa0,0x25,0xec,0x18,0x38,
+    0x38,0x39,0x13,0xcb,0x80,0x2a,0xd6,0xe2,0xd1,0xe1,0x22,0x02,0xd6,0xe1,0x86,0x0a,
+    0x3d,0xdd,0xf0,0xd6,0xda,0x86,0x07,0x3d,0x93,0xf0,0x24,0x05,0xbd,0x47,0x6e,0x20,
+    0x0f,0xbd,0xce,0x22,0x13,0xec,0x08,0x05,0xbd,0x41,0xf8,0x20,0x03,0x5f,0xd7,0xf5,
+    0x39,0x3c,0x3c,0x7e,0xce,0x98,0x3c,0x3c,0xbd,0xd0,0x9b,0x13,0xe6,0x02,0x06,0x7c,
+    0x02,0x8c,0x7c,0x02,0x8b,0xfe,0x02,0x6c,0xe6,0x00,0xd1,0xca,0x25,0x16,0xf6,0x02,
+    0x8b,0xc1,0x02,0x24,0x07,0xf6,0x02,0x8c,0xc1,0x02,0x25,0x08,0xc6,0x03,0xf7,0x02,
+    0x8c,0xf7,0x02,0x8b,0x38,0x38,0x39,0xbd,0x48,0x38,0xdd,0xf2,0xbd,0xd1,0x6b,0x39,
+    0xf6,0x07,0x11,0xf7,0x02,0x75,0xc1,0xc3,0x26,0x06,0x7f,0x07,0x11,0x7e,0xc0,0x00,
+    0x15,0xe9,0xc0,0xf6,0x06,0x92,0x56,0x56,0x56,0xc4,0xc0,0xda,0xe9,0xd7,0xe9,0xf6,
+    0x06,0x92,0xc5,0x03,0x26,0x05,0xca,0x02,0xf7,0x06,0x92,0xbd,0xec,0xc3,0xd6,0xb7,
+    0x27,0x08,0xf6,0x02,0x16,0xca,0x20,0xf7,0x02,0x16,0x8d,0x0a,0xbd,0x4b,0x05,0xbd,
+    0x4b,0x23,0xbd,0xe8,0xf5,0x39,0x3c,0x3c,0x34,0x30,0x6f,0x02,0xf6,0x01,0xb4,0x5a,
+    0x27,0x03,0x7e,0x4a,0xbf,0xd6,0xb7,0xf7,0x07,0x22,0x5f,0xd7,0x6a,0x18,0xce,0x02,
+    0xc4,0x58,0x58,0x58,0x18,0x3a,0x18,0xe6,0x00,0xd7,0x68,0x27,0x48,0x4f,0x05,0xc3,
+    0x00,0xa0,0x37,0x36,0xd6,0x6a,0x58,0x58,0x58,0x4f,0xc3,0x02,0xc4,0x18,0x8f,0x18,
+    0xa6,0x02,0x5f,0xed,0x00,0x18,0xe6,0x01,0x4f,0xe3,0x00,0x18,0x38,0x18,0xed,0x00,
+    0xd6,0x68,0x4f,0x05,0xc3,0x00,0x96,0x37,0x36,0xd6,0x6a,0x58,0x58,0x58,0x4f,0xc3,
+    0x02,0xc4,0x18,0x8f,0x18,0xa6,0x04,0x5f,0xed,0x00,0x18,0xe6,0x03,0x4f,0xe3,0x00,
+    0x18,0x38,0x18,0xed,0x00,0x7c,0x00,0x6a,0xd6,0x6a,0xc1,0x05,0x25,0x9f,0x5f,0xd7,
+    0x6a,0xc6,0x91,0xd7,0x68,0xbd,0x4a,0xc3,0xbd,0x4a,0xc3,0xbd,0x4a,0xc3,0xd6,0x6a,
+    0x4f,0x05,0x18,0x8f,0x18,0xec,0xa2,0xdd,0x91,0x18,0xec,0x98,0xdd,0x8f,0xd6,0x91,
+    0xf7,0x07,0x32,0xd6,0x92,0xf7,0x07,0x39,0xd6,0x8f,0xf7,0x07,0x3a,0xd6,0x90,0xf7,
+    0x07,0x3b,0xd6,0x6a,0x4f,0x18,0x8f,0x18,0xe6,0x93,0xf7,0x07,0x3c,0xc6,0xab,0xd7,
+    0x68,0x7c,0x00,0x6a,0x8d,0x71,0x5f,0xd7,0x68,0xd7,0x6a,0x74,0x00,0x68,0x4f,0x18,
+    0x8f,0x18,0xe6,0x93,0x27,0x03,0x14,0x68,0x10,0x7c,0x00,0x6a,0xd6,0x6a,0xc1,0x05,
+    0x25,0xe9,0xd6,0xb7,0x27,0x03,0x14,0x68,0x20,0xf6,0x07,0x21,0xc4,0xc0,0xda,0x68,
+    0xf7,0x07,0x21,0xd6,0x68,0xd7,0x6a,0xc6,0x07,0xd7,0x68,0x13,0x6a,0x02,0x04,0xc6,
+    0x0c,0xd7,0x68,0x13,0x6a,0x1c,0x04,0xc6,0x21,0xd7,0x68,0x5f,0xd7,0x6a,0x20,0x12,
+    0x4f,0xc3,0x06,0x92,0x18,0x8f,0xe6,0x02,0x18,0xeb,0x8f,0xe7,0x02,0x7c,0x00,0x6a,
+    0xd6,0x6a,0xd1,0x68,0x25,0xea,0xd6,0x68,0x4f,0xc3,0x06,0x92,0x18,0x8f,0xe6,0x02,
+    0x18,0xe7,0x8f,0x31,0x38,0x38,0x39,0x3c,0x3c,0xd6,0x6a,0x4f,0x05,0x8f,0xec,0xa2,
+    0xdd,0x91,0xec,0x98,0xdd,0x8f,0xce,0x06,0x92,0xd6,0x68,0x3a,0xd6,0x91,0xe7,0x00,
+    0xd6,0x68,0x4f,0xc3,0x06,0x92,0x8f,0xd6,0x92,0xe7,0x01,0xd6,0x8f,0xe7,0x02,0xd6,
+    0x90,0xe7,0x03,0x3c,0xd6,0x6a,0x4f,0x8f,0xe6,0x93,0x38,0xe7,0x04,0x7c,0x00,0x6a,
+    0xd6,0x68,0xcb,0x05,0xd7,0x68,0x38,0x38,0x39,0x7f,0x01,0xb4,0xd6,0xc6,0xc5,0x3f,
+    0x26,0x04,0x13,0xbd,0x3f,0x05,0xc6,0x01,0xf7,0x01,0xb4,0xf6,0x02,0x75,0x5a,0x26,
+    0x05,0xc6,0x01,0xf7,0x01,0xb4,0x39,0xf6,0x01,0xb4,0x5a,0x26,0x17,0x13,0xe6,0x08,
+    0x0a,0xbd,0xf7,0xed,0xbd,0xef,0x0d,0xbd,0xf7,0xd6,0x39,0xbd,0xf7,0xd6,0xbd,0xef,
+    0x0d,0xbd,0xf7,0xed,0x39,0x3c,0x3c,0x5f,0xd7,0x6a,0x7e,0x4b,0xcd,0x4f,0x05,0x05,
+    0xc3,0x00,0x29,0xfd,0x03,0xd4,0x8f,0xe6,0x00,0x5a,0x27,0x09,0xe6,0x01,0xd1,0xc2,
+    0x26,0x31,0xfe,0x03,0xd4,0xe6,0x01,0xe1,0x00,0x26,0x0e,0xe6,0x00,0x5a,0x26,0x04,
+    0x6c,0x01,0x20,0x05,0xfe,0x03,0xd4,0x6a,0x00,0xe6,0x03,0xe1,0x02,0x26,0x14,0xd1,
+    0xc0,0x24,0x05,0x6c,0x03,0xfe,0x03,0xd4,0xe6,0x02,0xc1,0x01,0x23,0x05,0x6a,0x02,
+    0xfe,0x03,0xd4,0xe6,0x02,0x5a,0x27,0x09,0xe6,0x03,0xd1,0xc0,0x26,0x2e,0xfe,0x03,
+    0xd4,0xe6,0x03,0xe1,0x02,0x26,0x0e,0xe6,0x02,0x5a,0x26,0x04,0x6c,0x03,0x20,0x05,
+    0xfe,0x03,0xd4,0x6a,0x02,0xe6,0x01,0xe1,0x00,0x26,0x11,0xd1,0xc2,0x24,0x05,0x6c,
+    0x01,0xfe,0x03,0xd4,0xe6,0x00,0xc1,0x01,0x23,0x02,0x6a,0x00,0x7c,0x00,0x6a,0xd6,
+    0x6a,0xd1,0xc8,0x24,0x03,0x7e,0x4b,0x49,0x38,0x38,0x39,0x3c,0x3c,0x5f,0xd7,0x6a,
+    0x7e,0x4c,0x86,0x4f,0x8f,0xe6,0x93,0x26,0x05,0xce,0x03,0x00,0x20,0x18,0xce,0x03,
+    0x00,0xd6,0x6a,0x3a,0x6c,0x00,0xe6,0x00,0xc1,0x05,0x23,0x04,0xc6,0x05,0xe7,0x00,
+    0x5a,0x26,0x0a,0xce,0x01,0x3e,0xd6,0x6a,0x3a,0x6f,0x00,0x20,0x38,0xe6,0x00,0xc1,
+    0x02,0x26,0x32,0xd6,0x6a,0x58,0x58,0x4f,0xc3,0x01,0x5c,0x37,0x36,0xd6,0x6a,0x58,
+    0x58,0x58,0x4f,0xc3,0x01,0xc2,0x8f,0xec,0x02,0x38,0xed,0x02,0xd6,0x6a,0x58,0x58,
+    0x4f,0xc3,0x01,0x48,0x37,0x36,0xd6,0x6a,0x58,0x58,0x58,0x4f,0xc3,0x01,0xea,0x8f,
+    0xec,0x02,0x38,0xed,0x02,0xce,0x01,0x39,0xd6,0x6a,0x3a,0xa6,0x00,0x27,0x36,0x4f,
+    0x05,0x37,0x36,0xce,0x01,0x5c,0xd6,0x6a,0x58,0x58,0x3a,0xec,0x00,0x38,0xed,0xa2,
+    0xd6,0x6a,0x4f,0x05,0x37,0x36,0xce,0x01,0x48,0xd6,0x6a,0x58,0x58,0x3a,0xec,0x00,
+    0x38,0xed,0x98,0xd6,0x6a,0x4f,0x8f,0xc6,0x01,0xe7,0x93,0xce,0x01,0x43,0xd6,0x6a,
+    0x3a,0xc6,0x1f,0xe7,0x00,0x7c,0x00,0x6a,0xd6,0x6a,0xd1,0xc5,0x24,0x03,0x7e,0x4b,
+    0xdf,0x38,0x38,0x39,0x12,0xcb,0x20,0x03,0x7e,0x4d,0x68,0x5f,0xd7,0x6a,0x18,0xce,
+    0x03,0xe7,0x7e,0x4d,0x61,0x4f,0x97,0x67,0x05,0x8f,0xec,0xa2,0xdd,0x91,0xec,0x98,
+    0xdd,0x8f,0xd6,0x6a,0x86,0x03,0x3d,0xc3,0x03,0xd8,0xfd,0x03,0xd6,0x4f,0xd6,0x6a,
+    0x8f,0xe6,0x93,0x26,0x09,0xbd,0x4d,0x69,0x18,0x6f,0x04,0x7e,0x4d,0x58,0x18,0x6d,
+    0x04,0x26,0x0f,0x18,0xe7,0x04,0xdc,0x91,0x18,0xed,0x00,0xdc,0x8f,0x18,0xed,0x02,
+    0x20,0x7a,0xfe,0x03,0xd6,0xe6,0x00,0xc1,0x01,0x26,0x0a,0xce,0x01,0x3e,0xd6,0x6a,
+    0x3a,0x6f,0x00,0x20,0x67,0xdc,0x91,0x18,0xa3,0x00,0x2f,0x0a,0x05,0xb3,0x01,0x78,
+    0x23,0x13,0x86,0x02,0x20,0x0d,0x43,0x53,0xc3,0x00,0x01,0x05,0xb3,0x01,0x78,0x23,
+    0x04,0x86,0x01,0x97,0x67,0x96,0x67,0xfe,0x03,0xd6,0xe6,0x01,0x27,0x07,0x11,0x26,
+    0x04,0xc6,0x01,0xe7,0x00,0xa7,0x01,0x7f,0x00,0x67,0xdc,0x8f,0x18,0xa3,0x02,0x2f,
+    0x0a,0x05,0xb3,0x01,0x76,0x23,0x13,0x86,0x02,0x20,0x0d,0x43,0x53,0xc3,0x00,0x01,
+    0x05,0xb3,0x01,0x76,0x23,0x04,0x86,0x01,0x97,0x67,0x96,0x67,0xfe,0x03,0xd6,0xe6,
+    0x02,0x27,0x07,0x11,0x26,0x04,0xc6,0x01,0xe7,0x00,0xa7,0x02,0xc6,0x05,0x18,0x3a,
+    0x7c,0x00,0x6a,0xd6,0x6a,0xd1,0xc5,0x24,0x03,0x7e,0x4c,0xa1,0x39,0x3c,0xfe,0x03,
+    0xd6,0x6f,0x00,0x6f,0x01,0x6f,0x02,0x38,0x39,0xbd,0xd6,0x07,0xd6,0xb9,0x27,0x03,
+    0x14,0xb9,0x80,0x39,0xd6,0x81,0x26,0x04,0xd6,0x68,0xd7,0x80,0xbd,0xd9,0x29,0x39,
+    0xce,0x05,0xe0,0xcc,0x4d,0x80,0xed,0x68,0xcc,0x4d,0x75,0xed,0x5e,0xcc,0x49,0x12,
+    0xed,0x48,0xcc,0x46,0xf8,0xed,0x06,0xcc,0x49,0x43,0xed,0x58,0xcc,0x47,0x6d,0xed,
+    0x56,0xcc,0x47,0x6e,0xed,0x4e,0xcc,0x4d,0xd8,0xed,0x60,0xcc,0x49,0x0d,0xed,0x50,
+    0xcc,0x4e,0x33,0xed,0x6e,0x39,0xbd,0xc4,0x92,0xce,0x06,0x92,0xcc,0x00,0x00,0xed,
+    0x81,0xcc,0xe8,0x11,0xed,0x83,0xcc,0x10,0x10,0xed,0x85,0x39,0x3c,0x3c,0xd6,0xc8,
+    0xd1,0xac,0x26,0x20,0xf6,0x02,0xfb,0xd1,0xac,0x27,0x08,0xd6,0xac,0xf7,0x02,0xfb,
+    0x5f,0xd7,0xf4,0xd6,0xac,0x27,0x0b,0xd6,0xf4,0xc1,0xff,0x24,0x07,0x7c,0x00,0xf4,
+    0x20,0x02,0xd7,0xf4,0xd6,0xc8,0x27,0x10,0xd6,0xac,0x27,0x0c,0xd6,0xc8,0xd1,0xac,
+    0x27,0x06,0xd6,0xf4,0xc1,0x04,0x22,0x03,0x7e,0xf4,0x76,0xd6,0xad,0x27,0x04,0xd1,
+    0xc8,0x27,0x07,0xd6,0xc8,0xd7,0xad,0x5f,0xd7,0xae,0x7e,0xf4,0xae,0xd6,0xac,0x37,
+    0xbd,0xd6,0x93,0x33,0xd7,0xac,0x39,0xbd,0xf8,0xdb,0x10,0x4f,0x5f,0xfd,0x01,0x7e,
+    0xd6,0x68,0x26,0x04,0xdc,0x7d,0x20,0x02,0xdc,0x7b,0xfd,0x01,0x80,0x86,0x09,0x27,
+    0x0f,0x78,0x01,0xbc,0x79,0x01,0xbb,0x79,0x01,0xba,0x79,0x01,0xb9,0x4a,0x26,0xf1,
+    0xdc,0x8d,0x6f,0x02,0x6f,0x03,0xed,0x0a,0xec,0x02,0xed,0x08,0xfc,0x01,0xb9,0xed,
+    0x02,0xec,0x00,0xc3,0xff,0xf9,0x18,0x8f,0xfc,0x01,0xbb,0xbd,0xf9,0x9d,0x18,0xce,
+    0x4f,0xb5,0xbd,0xfb,0xa9,0xdd,0x91,0x83,0x04,0x00,0x25,0x03,0x7e,0x4f,0x27,0xcc,
+    0x04,0x00,0xed,0x0e,0x93,0x91,0xed,0x0c,0x83,0x01,0x00,0x22,0x1f,0xf6,0x02,0xf0,
+    0x4f,0xed,0x0a,0xf6,0x02,0xed,0x18,0x8f,0xec,0x0c,0xbd,0xf9,0x08,0x3c,0xee,0x0a,
+    0x02,0x8f,0x38,0xed,0x08,0xcc,0x04,0x00,0xa3,0x08,0x20,0x60,0xec,0x0c,0x83,0x02,
+    0x00,0x22,0x2a,0xf6,0x02,0xf0,0x4f,0xed,0x0a,0xf6,0x02,0xee,0x18,0x8f,0xec,0x0c,
+    0x83,0x01,0x00,0xbd,0xf9,0x08,0xed,0x08,0xb6,0x02,0xed,0x5f,0xe3,0x08,0x3c,0xee,
+    0x0a,0x02,0x8f,0x38,0xed,0x06,0xcc,0x04,0x00,0xa3,0x06,0x20,0x2f,0xf6,0x02,0xf0,
+    0x4f,0xed,0x0a,0xf6,0x02,0xef,0x18,0x8f,0xec,0x0c,0x83,0x02,0x00,0xbd,0xf9,0x08,
+    0xed,0x08,0xb6,0x02,0xee,0x5f,0xed,0x06,0xb6,0x02,0xed,0xe3,0x06,0xe3,0x08,0x3c,
+    0xee,0x0a,0x02,0x8f,0x38,0xed,0x04,0xcc,0x04,0x00,0xa3,0x04,0xdd,0x91,0xb3,0x01,
+    0x80,0x22,0x03,0x7e,0x4f,0xb1,0x4f,0x5f,0x7e,0x4f,0xaf,0xfc,0x01,0x80,0x83,0x04,
+    0x00,0x93,0x91,0x24,0xee,0xfc,0x01,0x80,0x83,0x04,0x00,0xed,0x0e,0xdc,0x91,0xa3,
+    0x0e,0xed,0x0c,0x83,0x01,0x00,0x22,0x12,0xf6,0x02,0xf0,0x4f,0xed,0x0a,0xf6,0x02,
+    0xed,0x18,0x8f,0xec,0x0c,0xbd,0xf9,0x08,0x20,0x44,0xec,0x0c,0x83,0x02,0x00,0x22,
+    0x1b,0xf6,0x02,0xf0,0x4f,0xed,0x0a,0xf6,0x02,0xee,0x18,0x8f,0xec,0x0c,0x83,0x01,
+    0x00,0xbd,0xf9,0x08,0xed,0x08,0xb6,0x02,0xed,0x5f,0x20,0x20,0xf6,0x02,0xf0,0x4f,
+    0xed,0x0a,0xf6,0x02,0xef,0x18,0x8f,0xec,0x0c,0x83,0x02,0x00,0xbd,0xf9,0x08,0xed,
+    0x08,0xb6,0x02,0xee,0x5f,0xed,0x06,0xb6,0x02,0xed,0xe3,0x06,0xe3,0x08,0x3c,0xee,
+    0x0a,0x02,0x8f,0x38,0xe3,0x0e,0xdd,0x91,0xb3,0x01,0x80,0x25,0x08,0xfc,0x01,0x80,
+    0x83,0x00,0x01,0xdd,0x91,0xae,0x00,0x38,0x39,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,
+};
+
+#endif
diff --git a/drivers/input/touchscreen/gt811_ts.c b/drivers/input/touchscreen/gt811_ts.c
new file mode 100644
index 0000000..f4d69ff
--- /dev/null
+++ b/drivers/input/touchscreen/gt811_ts.c
@@ -0,0 +1,2658 @@
+/* drivers/input/touchscreen/gt811.c
+ *
+ * Copyright (C) 2010 - 2011 Goodix, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *Any problem,please contact andrew@goodix.com,+86 755-33338828
+ *
+ */
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include "gt811_ts.h"
+#include "gt811_firmware.h"
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <mach/irqs.h>
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+#include "ctp_platform_ops.h"
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    #include <linux/pm.h>
+    #include <linux/earlysuspend.h>
+#endif
+
+
+#include <linux/time.h>
+#include <linux/device.h>
+#include <linux/hrtimer.h>
+
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+
+
+#include <linux/irq.h>
+#include <linux/syscalls.h>
+#include <linux/reboot.h>
+#include <linux/proc_fs.h>
+
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+
+#undef CONFIG_HAS_EARLYSUSPEND
+
+static struct workqueue_struct *goodix_wq;
+static const char *gt80x_ts_name = "gt80x";
+//static struct point_queue finger_list;
+struct i2c_client * i2c_connect_client = NULL;
+//EXPORT_SYMBOL(i2c_connect_client);
+static struct proc_dir_entry *goodix_proc_entry;
+static short  goodix_read_version(struct goodix_ts_data *ts);	
+//static int tpd_button(struct goodix_ts_data *ts, unsigned int x, unsigned int y, unsigned int down);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h);
+static void goodix_ts_late_resume(struct early_suspend *h);
+int  gt811_downloader( struct goodix_ts_data *ts, unsigned char * data);
+#endif
+//used by firmware update CRC
+unsigned int oldcrc32 = 0xFFFFFFFF;
+unsigned int crc32_table[256];
+unsigned int ulPolynomial = 0x04c11db7;
+
+unsigned int raw_data_ready = RAW_DATA_NON_ACTIVE;
+
+#ifdef DEBUG
+int sum = 0;
+int access_count = 0;
+int int_count = 0;
+#endif
+
+#ifdef PRINT_POINT_INFO 
+#define print_point_info(fmt, args...)   \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_point_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_INT_INFO 
+#define print_int_info(fmt, args...)     \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_int_info(fmt, args...)   //
+#endif
+
+///////////////////////////////////////////////
+//specific tp related macro: need be configured for specific tp
+#define CTP_IRQ_NO			(gpio_int_info[0].port_num)
+#define CTP_IRQ_MODE			(NEGATIVE_EDGE)
+#define CTP_NAME			GOODIX_I2C_NAME
+#define TS_RESET_LOW_PERIOD		(15)
+#define TS_INITIAL_HIGH_PERIOD		(15)
+#define TS_WAKEUP_LOW_PERIOD	(100)
+#define TS_WAKEUP_HIGH_PERIOD	(100)
+#define TS_POLL_DELAY			(10)	/* ms delay between samples */
+#define TS_POLL_PERIOD			(10)	/* ms delay between samples */
+#define  SCREEN_MAX_HEIGHT		(screen_max_x)
+#define  SCREEN_MAX_WIDTH		(screen_max_y)
+#define PRESS_MAX			(255)
+
+static void* __iomem gpio_addr = NULL;
+static int gpio_int_hdle = 0;
+static int gpio_wakeup_hdle = 0;
+static int gpio_reset_hdle = 0;
+static int gpio_wakeup_enable = 1;
+static int gpio_reset_enable = 1;
+static user_gpio_set_t  gpio_int_info[1];
+
+static int screen_max_x = 0;
+static int screen_max_y = 0;
+static int revert_x_flag = 0;
+static int revert_y_flag = 0;
+static int exchange_x_y_flag = 0;
+static __u32 twi_addr = 0;
+static __u32 twi_id = 0;
+static int	int_cfg_addr[]={PIO_INT_CFG0_OFFSET,PIO_INT_CFG1_OFFSET,
+			PIO_INT_CFG2_OFFSET, PIO_INT_CFG3_OFFSET};
+
+/* Addresses to scan */
+union{
+	unsigned short dirty_addr_buf[2];
+	const unsigned short normal_i2c[2];
+}u_i2c_addr = {{0x00},};
+
+
+static int reg_val;
+
+
+/*
+ * ctp_get_pendown_state  : get the int_line data state, 
+ * 
+ * return value:
+ *             return PRESS_DOWN: if down
+ *             return FREE_UP: if up,
+ *             return 0: do not need process, equal free up.
+ */
+static int ctp_get_pendown_state(void)
+{
+	unsigned int reg_val;
+	static int state = FREE_UP;
+
+	//get the input port state
+	reg_val = readl(gpio_addr + PIOH_DATA);
+	//printk("reg_val = %x\n",reg_val);
+	if(!(reg_val & (1<<CTP_IRQ_NO))){
+		state = PRESS_DOWN;
+		print_int_info("pen down. \n");
+	}else{ //touch panel is free up
+		state = FREE_UP;
+		print_int_info("free up. \n");
+	}
+	return state;
+}
+
+/**
+ * ctp_clear_penirq - clear int pending
+ *
+ */
+static void ctp_clear_penirq(void)
+{
+	int reg_val;
+	//clear the IRQ_EINT29 interrupt pending
+	//printk("clear pend irq pending\n");
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val&(1<<(IRQ_EINT21)),gpio_addr + PIO_INT_STAT_OFFSET);
+	if((reg_val = (reg_val&(1<<(CTP_IRQ_NO))))){
+		print_int_info("==CTP_IRQ_NO=\n");              
+		writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+	}
+	return;
+}
+
+/**
+ * ctp_set_irq_mode - according sysconfig's subkey "ctp_int_port" to config int port.
+ * 
+ * return value: 
+ *              0:      success;
+ *              others: fail; 
+ */
+static int ctp_set_irq_mode(char *major_key , char *subkey, ext_int_mode int_mode)
+{
+	int ret = 0;
+	__u32 reg_num = 0;
+	__u32 reg_addr = 0;
+	__u32 reg_val = 0;
+	//config gpio to int mode
+	printk("%s: config gpio to int mode. \n", __func__);
+#ifndef SYSCONFIG_GPIO_ENABLE
+#else
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	gpio_int_hdle = gpio_request_ex(major_key, subkey);
+	if(!gpio_int_hdle){
+		printk("request tp_int_port failed. \n");
+		ret = -1;
+		goto request_tp_int_port_failed;
+	}
+	gpio_get_one_pin_status(gpio_int_hdle, gpio_int_info, subkey, 1);
+	pr_info("%s, %d: gpio_int_info, port = %d, port_num = %d. \n", __func__, __LINE__, \
+		gpio_int_info[0].port, gpio_int_info[0].port_num);
+#endif
+
+#ifdef AW_GPIO_INT_API_ENABLE
+#else
+	printk(" INTERRUPT CONFIG\n");
+	reg_num = (gpio_int_info[0].port_num)%8;
+	reg_addr = (gpio_int_info[0].port_num)/8;
+	reg_val = readl(gpio_addr + int_cfg_addr[reg_addr]);
+	reg_val &= (~(7 << (reg_num * 4)));
+	reg_val |= (int_mode << (reg_num * 4));
+	writel(reg_val,gpio_addr+int_cfg_addr[reg_addr]);
+                                                               
+	ctp_clear_penirq();
+                                                               
+	reg_val = readl(gpio_addr+PIO_INT_CTRL_OFFSET); 
+	reg_val |= (1 << (gpio_int_info[0].port_num));
+	writel(reg_val,gpio_addr+PIO_INT_CTRL_OFFSET);
+
+	udelay(1);
+#endif
+
+request_tp_int_port_failed:
+	return ret;  
+}
+
+/**
+ * ctp_set_gpio_mode - according sysconfig's subkey "ctp_io_port" to config io port.
+ *
+ * return value: 
+ *              0:      success;
+ *              others: fail; 
+ */
+static int ctp_set_gpio_mode(void)
+{
+	//int reg_val;
+	int ret = 0;
+	//config gpio to io mode
+	printk("%s: config gpio to io mode. \n", __func__);
+#ifndef SYSCONFIG_GPIO_ENABLE
+#else
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	gpio_int_hdle = gpio_request_ex("ctp_para", "ctp_io_port");
+	if(!gpio_int_hdle){
+		printk("request ctp_io_port failed. \n");
+		ret = -1;
+		goto request_tp_io_port_failed;
+	}
+#endif
+	return ret;
+
+request_tp_io_port_failed:
+	return ret;
+}
+
+/**
+ * ctp_judge_int_occur - whether interrupt occur.
+ *
+ * return value: 
+ *              0:      int occur;
+ *              others: no int occur; 
+ */
+static int ctp_judge_int_occur(void)
+{
+	//int reg_val[3];
+	int reg_val;
+	int ret = -1;
+
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	if(reg_val&(1<<(CTP_IRQ_NO))){
+		ret = 0;
+	}
+	return ret; 	
+}
+
+/**
+ * ctp_free_platform_resource - corresponding with ctp_init_platform_resource
+ *
+ */
+static void ctp_free_platform_resource(void)
+{
+	printk("=======%s=========.\n", __func__);
+	if(gpio_addr){
+		iounmap(gpio_addr);
+	}
+	
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	
+	if(gpio_wakeup_hdle){
+		gpio_release(gpio_wakeup_hdle, 2);
+	}
+	
+	if(gpio_reset_hdle){
+		gpio_release(gpio_reset_hdle, 2);
+	}
+
+	return;
+}
+
+
+/**
+ * ctp_init_platform_resource - initialize platform related resource
+ * return value: 0 : success
+ *               -EIO :  i/o err.
+ *
+ */
+static int ctp_init_platform_resource(void)
+{
+	int ret = 0;
+
+	gpio_addr = ioremap(PIO_BASE_ADDRESS, PIO_RANGE_SIZE);
+	//printk("%s, gpio_addr = 0x%x. \n", __func__, gpio_addr);
+	if(!gpio_addr) {
+		ret = -EIO;
+		goto exit_ioremap_failed;	
+	}
+	//    gpio_wakeup_enable = 1;
+	gpio_wakeup_hdle = gpio_request_ex("ctp_para", "ctp_wakeup");
+	if(!gpio_wakeup_hdle) {
+		pr_warning("%s: tp_wakeup request gpio fail!\n", __func__);
+		gpio_wakeup_enable = 0;
+	}
+
+	gpio_reset_hdle = gpio_request_ex("ctp_para", "ctp_reset");
+	if(!gpio_reset_hdle) {
+		pr_warning("%s: tp_reset request gpio fail!\n", __func__);
+		gpio_reset_enable = 0;
+	}
+
+	return ret;
+
+exit_ioremap_failed:
+	ctp_free_platform_resource();
+	return ret;
+}
+
+
+/**
+ * ctp_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int ctp_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int ctp_used = -1;
+	char name[I2C_NAME_SIZE];
+	script_parser_value_type_t type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+
+	printk("%s. \n", __func__);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_used", &ctp_used, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	if(1 != ctp_used){
+		pr_err("%s: ctp_unused. \n",  __func__);
+		//ret = 1;
+		return ret;
+	}
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch_ex("ctp_para", "ctp_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	if(strcmp(CTP_NAME, name)){
+		pr_err("%s: name %s does not match CTP_NAME. \n", __func__, name);
+		pr_err(CTP_NAME);
+		//ret = 1;
+		return ret;
+	}
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_twi_addr", &twi_addr, sizeof(twi_addr)/sizeof(__u32))){
+		pr_err("%s: script_parser_fetch err. \n", name);
+		goto script_parser_fetch_err;
+	}
+	//big-endian or small-endian?
+	//printk("%s: before: ctp_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+	u_i2c_addr.dirty_addr_buf[0] = twi_addr;
+	u_i2c_addr.dirty_addr_buf[1] = I2C_CLIENT_END;
+	printk("%s: after: ctp_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+	//printk("%s: after: ctp_twi_addr is 0x%x, u32_dirty_addr_buf: 0x%hx. u32_dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u32_dirty_addr_buf[0],u32_dirty_addr_buf[1]);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_twi_id", &twi_id, sizeof(twi_id)/sizeof(__u32))){
+		pr_err("%s: script_parser_fetch err. \n", name);
+		goto script_parser_fetch_err;
+	}
+	printk("%s: ctp_twi_id is %d. \n", __func__, twi_id);
+	
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_x", &screen_max_x, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: screen_max_x = %d. \n", __func__, screen_max_x);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_y", &screen_max_y, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: screen_max_y = %d. \n", __func__, screen_max_y);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_x_flag", &revert_x_flag, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: revert_x_flag = %d. \n", __func__, revert_x_flag);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_y_flag", &revert_y_flag, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: revert_y_flag = %d. \n", __func__, revert_y_flag);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_exchange_x_y_flag", &exchange_x_y_flag, 1)){
+		pr_err("ft5x_ts: script_parser_fetch err. \n");
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: exchange_x_y_flag = %d. \n", __func__, exchange_x_y_flag);
+
+	return 0;
+
+script_parser_fetch_err:
+	pr_notice("=========script_parser_fetch_err============\n");
+	return ret;
+}
+
+/**
+ * ctp_reset - function
+ *
+ */
+static void ctp_reset(void)
+{
+	printk("%s. \n", __func__);
+	if(gpio_reset_enable){
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 0, "ctp_reset")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_RESET_LOW_PERIOD);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 1, "ctp_reset")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_INITIAL_HIGH_PERIOD);
+	}
+}
+
+/**
+ * ctp_wakeup - function
+ *
+ */
+static void ctp_wakeup(void)
+{
+	printk("%s. \n", __func__);
+	if(1 == gpio_wakeup_enable){  
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 1, "ctp_wakeup")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_WAKEUP_LOW_PERIOD);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_WAKEUP_HIGH_PERIOD);
+
+	}
+	return;
+}
+/**
+ * ctp_detect - Device detection callback for automatic device creation
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+int ctp_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if(twi_id == adapter->nr)
+	{
+		pr_info("%s: Detected chip %s at adapter %d, address 0x%02x\n",
+			 __func__, CTP_NAME, i2c_adapter_id(adapter), client->addr);
+
+		strlcpy(info->type, CTP_NAME, I2C_NAME_SIZE);
+		return 0;
+	}else{
+		return -ENODEV;
+	}
+}
+////////////////////////////////////////////////////////////////
+
+static struct ctp_platform_ops ctp_ops = {
+	.get_pendown_state = ctp_get_pendown_state,
+	.clear_penirq	   = ctp_clear_penirq,
+	.set_irq_mode      = ctp_set_irq_mode,
+	.set_gpio_mode     = ctp_set_gpio_mode,	
+	.judge_int_occur   = ctp_judge_int_occur,
+	.init_platform_resource = ctp_init_platform_resource,
+	.free_platform_resource = ctp_free_platform_resource,
+	.fetch_sysconfig_para = ctp_fetch_sysconfig_para,
+	.ts_reset =          ctp_reset,
+	.ts_wakeup =         ctp_wakeup,
+	.ts_detect = ctp_detect,
+};
+
+/*******************************************************	
+Function:
+	Read data from the slave
+	Each read operation with two i2c_msg composition, for the first message sent from the machine address,
+	Article 2 reads the address used to send and retrieve data; each message sent before the start signal
+Parameters:
+	client: i2c devices, including device address
+	buf [0]: The first byte to read Address
+	buf [1] ~ buf [len]: data buffer
+	len: the length of read data
+return:
+	Execution messages
+*********************************************************/
+/*Function as i2c_master_send */
+static int i2c_read_bytes(struct i2c_client *client, uint8_t *buf, int len)
+{
+	struct i2c_msg msgs[2];
+	int ret=-1;
+	
+	msgs[0].flags=!I2C_M_RD;
+	msgs[0].addr=client->addr;
+	msgs[0].len=2;
+	msgs[0].buf=&buf[0];
+	//msgs[0].scl_rate=200000;
+
+	msgs[1].flags=I2C_M_RD;
+	msgs[1].addr=client->addr;
+	msgs[1].len=len-2;
+	msgs[1].buf=&buf[2];
+	//msgs[1].scl_rate=200000;
+	
+	ret=i2c_transfer(client->adapter,msgs, 2);
+	return ret;
+}
+
+/*******************************************************	
+Function:
+	Write data to a slave
+Parameters:
+	client: i2c devices, including device address
+	buf [0]: The first byte of the write address
+	buf [1] ~ buf [len]: data buffer
+	len: data length
+return:
+	Execution messages
+*******************************************************/
+/*Function as i2c_master_send */
+static int i2c_write_bytes(struct i2c_client *client,uint8_t *data,int len)
+{
+	struct i2c_msg msg;
+	int ret=-1;
+	//??????
+	msg.flags=!I2C_M_RD;//???
+	msg.addr=client->addr;
+	msg.len=len;
+	msg.buf=data;	
+	//msg.scl_rate=200000;	
+	
+	ret=i2c_transfer(client->adapter,&msg, 1);
+	return ret;
+}
+
+/*******************************************************
+Function:
+	Send a prefix command
+	
+Parameters:
+	ts: client private data structure
+	
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int i2c_pre_cmd(struct goodix_ts_data *ts)
+{
+	int ret;
+	uint8_t pre_cmd_data[2]={0};	
+	pre_cmd_data[0]=0x0f;
+	pre_cmd_data[1]=0xff;
+	ret=i2c_write_bytes(ts->client,pre_cmd_data,2);
+	//msleep(2);
+	return ret;
+}
+
+/*******************************************************
+Function:
+	Send a suffix command
+	
+Parameters:
+	ts: client private data structure
+	
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int i2c_end_cmd(struct goodix_ts_data *ts)
+{
+	int ret;
+	uint8_t end_cmd_data[2]={0};	
+	end_cmd_data[0]=0x80;
+	end_cmd_data[1]=0x00;
+	ret=i2c_write_bytes(ts->client,end_cmd_data,2);
+	//msleep(2);
+	return ret;
+}
+
+/********************************************************************
+
+*********************************************************************/
+#ifdef COOR_TO_KEY
+static int list_key(s32 x_value, s32 y_value, u8* key)
+{
+	s32 i;
+
+#ifdef AREA_Y
+	if (y_value <= AREA_Y)
+#else
+	if (x_value <= AREA_X)
+#endif
+	{
+		return 0;
+	}
+
+	for (i = 0; i < MAX_KEY_NUM; i++)
+	{
+		if (abs(key_center[i][x] - x_value) < KEY_X 
+		&& abs(key_center[i][y] - y_value) < KEY_Y)
+		{
+			(*key) |= (0x01<<i);
+        	}
+   	 }
+
+    return 1;
+}
+#endif 
+
+/*******************************************************
+Function:
+	Guitar initialization function, used to send configuration information, access to version information
+Parameters:
+	ts: client private data structure
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int goodix_init_panel(struct goodix_ts_data *ts)
+{
+	short ret=-1;
+	uint8_t config_info[] = {
+	0x06,0xA2,
+/*
+	0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x60,0x00,0x50,0x00,0x40,0x00,
+	0x30,0x00,0x20,0x00,0x10,0x00,0x00,0x00,0x70,0x00,0x80,0x00,0x90,0x00,0xA0,0x00,
+	0xB0,0x00,0xC0,0x00,0xD0,0x00,0xE0,0x00,0xF0,0x00,0x05,0x03,0x90,0x90,0x90,0x30,
+	0x30,0x30,0x0F,0x0F,0x0A,0x50,0x3C,0x08,0x03,0x3C,0x05,0x00,0x14,0x00,0x20,0x04,
+	0x04,0x64,0x5A,0x40,0x40,0x00,0x00,0x03,0x19,0x00,0x05,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x10,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x50,
+	0x3C,0x3C,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01*/
+
+/*
+	0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x13,0x33,0x23,0x33,0x33,0x33,
+	0x43,0x33,0x53,0x33,0x63,0x33,0x73,0x33,0x83,0x33,0x93,0x33,0xA3,0x33,0xB3,0x33,
+	0xC3,0x33,0xD3,0x33,0xE3,0x33,0xF3,0x33,0x03,0x33,0x3B,0x03,0x88,0x88,0x88,0x1B,
+	0x1B,0x1B,0x0F,0x0F,0x0A,0x40,0x30,0x0F,0x03,0x00,0x05,0x00,0x14,0x00,0x1E,0x04,
+	0x04,0x64,0x5A,0x40,0x40,0x00,0x00,0x05,0x19,0x05,0x05,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x10,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x50,
+	0x3C,0x3C,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01*/
+
+	0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,0xE2,0x53,0xD2,0x53,0xC2,0x53,
+	0xB2,0x53,0xA2,0x53,0x92,0x53,0x82,0x53,0x72,0x53,0x62,0x53,0x52,0x53,0x42,0x53,
+	0x32,0x53,0x22,0x53,0x12,0x53,0x02,0x53,0xF2,0x53,0x0F,0x13,0x40,0x40,0x40,0x10,
+	0x10,0x10,0x0F,0x0F,0x0A,0x35,0x25,0x0C,0x03,0x00,0x05,0x20,0x03,0xE0,0x01,0x00,
+	0x00,0x34,0x2C,0x36,0x2E,0x00,0x00,0x03,0x19,0x03,0x08,0x00,0x00,0x00,0x00,0x00,
+	0x14,0x10,0xEC,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0D,0x40,
+	0x30,0x3C,0x28,0x00,0x00,0x00,0x00,0xC0,0x12,0x01
+	};
+
+	config_info[62] = TOUCH_MAX_HEIGHT >> 8;
+    	config_info[61] = TOUCH_MAX_HEIGHT & 0xff;
+    	config_info[64] = TOUCH_MAX_WIDTH >> 8;
+    	config_info[63] = TOUCH_MAX_WIDTH & 0xff;
+	
+	ret = i2c_write_bytes(ts->client, config_info, sizeof(config_info)/sizeof(config_info[0]));
+	if(ret < 0)
+	{
+		dev_info(&ts->client->dev, "GT811 Send config failed!\n");
+		return ret;
+	}
+	ts->abs_x_max = (config_info[62]<<8) + config_info[61];
+	ts->abs_y_max = (config_info[64]<<8) + config_info[63];
+	ts->max_touch_num = config_info[60];
+	ts->int_trigger_type = ((config_info[57]>>3)&0x01);
+	dev_info(&ts->client->dev, "GT811 init info:X_MAX=%d,Y_MAX=%d,TRIG_MODE=%s\n",
+	ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type?"RISING EDGE":"FALLING EDGE");
+
+	return 0;
+}
+
+/*******************************************************
+FUNCTION:
+	Read gt811 IC Version
+Argument:
+	ts:	client
+return:
+	0:success
+       -1:error
+*******************************************************/
+static short  goodix_read_version(struct goodix_ts_data *ts)
+{
+	short ret;
+	uint8_t version_data[5]={0x07,0x17,0,0};	//store touchscreen version infomation
+	uint8_t version_data2[5]={0x07,0x17,0,0};	//store touchscreen version infomation
+
+	char i = 0;
+	char cpf = 0;
+	memset(version_data, 0, 5);
+	version_data[0]=0x07;
+	version_data[1]=0x17;	
+
+      	ret=i2c_read_bytes(ts->client, version_data, 4);
+	if (ret < 0) 
+		return ret;
+	
+	for(i = 0;i < 10;i++)
+	{
+		i2c_read_bytes(ts->client, version_data2, 4);
+		if((version_data[2] !=version_data2[2])||(version_data[3] != version_data2[3]))
+		{
+			version_data[2] = version_data2[2];
+			version_data[3] = version_data2[3];
+			msleep(5);
+			break;
+		}
+		msleep(5);
+		cpf++;
+	}
+
+	if(cpf == 10)
+	{
+		ts->version = (version_data[2]<<8)+version_data[3];
+		dev_info(&ts->client->dev, "GT811 Verion:0x%04x\n", ts->version);
+		ret = 0;
+	}
+	else
+	{
+		dev_info(&ts->client->dev," Guitar Version Read Error: %d.%d\n",version_data[3],version_data[2]);
+		ts->version = 0xffff;
+		ret = -1;
+	}
+	
+	return ret;
+	
+}
+/******************start add by kuuga*******************/
+static void gt811_irq_enable(struct goodix_ts_data *ts)
+{	
+    unsigned long irqflags;	
+    //spin_lock_irqsave(&ts->irq_lock, irqflags);
+    //if (ts->irq_is_disable) 
+    {		
+        //enable_irq(ts->irq);
+        reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        reg_val |=(1<<CTP_IRQ_NO);
+        writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+        //ts->irq_is_disable = 0;	
+    }	
+    //spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+
+static void gt811_irq_disable(struct goodix_ts_data *ts)
+{	
+    unsigned long irqflags;
+    //spin_lock_irqsave(&ts->irq_lock, irqflags);
+    //if (!ts->irq_is_disable) 
+    {		
+        //disable_irq_nosync(ts->irq);	
+        reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        reg_val &=~(1<<CTP_IRQ_NO);
+        writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+        //ts->irq_is_disable = 1;	
+    }	
+    //spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+
+/*****************end add by kuuga****************/
+
+/*******************************************************	
+Function:
+	Touch-screen work function
+	Triggered by the interruption, to accept a set of coordinate data,
+	and then analyze the output parity
+Parameters:
+	ts: client private data structure
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static void goodix_ts_work_func(struct work_struct *work)
+{	
+	uint8_t  point_data[READ_BYTES_NUM] = {READ_TOUCH_ADDR_H,READ_TOUCH_ADDR_L,0};//point_data[8*MAX_FINGER_NUM+2]={ 0 };  
+	uint8_t  check_sum = 0;
+	uint8_t  read_position = 0;
+	uint8_t  track_id[MAX_FINGER_NUM];
+	uint8_t  point_index = 0;
+	uint8_t  point_tmp = 0;
+	uint8_t  point_count = 0;
+	uint16_t input_x = 0;
+	uint16_t input_y = 0;
+	uint8_t  input_w = 0;
+	static uint8_t  last_key = 0;
+	uint8_t  finger = 0;
+	uint8_t  key = 0;
+	unsigned int  count = 0;
+	unsigned int position = 0;	
+	int ret=-1;
+	int tmp = 0;
+	
+    struct goodix_ts_data *ts = container_of(work, struct goodix_ts_data, work);
+#ifdef DEBUG
+    printk("int count :%d\n", ++int_count);
+    printk("ready?:%d\n", raw_data_ready);
+#endif     
+    if (RAW_DATA_ACTIVE == raw_data_ready)
+    {
+        raw_data_ready = RAW_DATA_READY;
+#ifdef DEBUG	    
+        printk("ready!\n");
+#endif
+    }
+	
+#ifndef INT_PORT
+COORDINATE_POLL:
+#endif
+    if( tmp > 9) 
+    {
+        dev_info(&(ts->client->dev), "Because of transfer error,touchscreen stop working.\n");
+        goto XFER_ERROR ;
+    }
+
+    ret=i2c_read_bytes(ts->client, point_data, sizeof(point_data)/sizeof(point_data[0]));
+    if(ret <= 0) 
+    {
+        dev_err(&(ts->client->dev),"I2C transfer error. Number:%d\n ", ret);
+        ts->bad_data = 1;
+        tmp ++;
+        ts->retry++;
+#ifndef INT_PORT
+        goto COORDINATE_POLL;
+#else   
+        goto XFER_ERROR;
+#endif  
+    }
+#if 0
+    for(count=0;count<(sizeof(point_data)/sizeof(point_data[0])); count++)
+    {
+        printk("[%2d]:0x%2x", count, point_data[count]);
+        if((count+1)%10==0)printk("\n");
+    }
+    printk("\n");
+#endif	
+    if(point_data[2]&0x20)
+    {
+        if(point_data[3]==0xF0)
+        {
+            //gpio_direction_output(SHUTDOWN_PORT, 0);
+            gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+            gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");			
+            msleep(1);
+            //gpio_direction_input(SHUTDOWN_PORT);
+            gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+            goodix_init_panel(ts);
+            goto WORK_FUNC_END;
+        }
+    }
+    switch(point_data[2]& 0x1f)
+    {
+        case 0:
+            read_position = 3;
+            break;
+        case 1:
+            for(count=2; count<9; count++)
+                check_sum += (int)point_data[count];
+            read_position = 9;
+            break;
+        case 2:
+        case 3:
+            for(count=2; count<14;count++)
+                check_sum += (int)point_data[count];
+            read_position = 14;
+            break;	
+        default:		//touch finger larger than 3
+            for(count=2; count<35;count++)
+                check_sum += (int)point_data[count];
+            read_position = 35;
+    }
+#ifdef HAVE_TOUCH_KEY
+#else
+    if(check_sum != point_data[read_position])
+    {
+        dev_info(&ts->client->dev, "coor chksum error!\n");
+        goto XFER_ERROR;
+    }
+#endif
+    point_index = point_data[2]&0x1f;
+    point_tmp = point_index;
+    for(position=0; (position<MAX_FINGER_NUM)&&point_tmp; position++)
+    {
+        if(point_tmp&0x01)
+        {
+            track_id[point_count++] = position;
+        }	
+        point_tmp >>= 1;
+    }	
+    finger = point_count;
+    if(finger)
+    {
+        for(count=0; count<finger; count++)
+        {
+            if(track_id[count]!=3)
+            {
+                if(track_id[count]<3)
+                    position = 4+track_id[count]*5;
+                else
+                    position = 30;
+                    input_x = (uint16_t)(point_data[position]<<8)+(uint16_t)point_data[position+1];
+                    input_y = (uint16_t)(point_data[position+2]<<8)+(uint16_t)point_data[position+3];
+                    input_w = point_data[position+4];
+            }
+            else
+            {
+                input_x = (uint16_t)(point_data[19]<<8)+(uint16_t)point_data[26];
+                input_y = (uint16_t)(point_data[27]<<8)+(uint16_t)point_data[28];
+                input_w = point_data[29];	
+            }
+
+            if(1 == revert_x_flag){
+			      		input_x = TOUCH_MAX_HEIGHT - input_x;
+			      }
+		        if(1 == revert_y_flag){
+			      		input_y = TOUCH_MAX_WIDTH -  input_y;
+			      }
+			      if(1 == exchange_x_y_flag) {
+			      		swap(input_x,  input_y);
+			    }
+
+            if((input_x > ts->abs_x_max)||(input_y > ts->abs_y_max))continue;
+            //input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_y);
+            //input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_x);
+            input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_y);
+            input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_x);			
+            input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
+            input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, track_id[count]);
+            input_mt_sync(ts->input_dev);	
+            //printk("input_x=%d,input_y=%d,input_w=%d\n", input_y, input_x, input_w);
+        }
+    }
+    else
+    {
+        input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+        input_mt_sync(ts->input_dev);
+    }
+
+    input_report_key(ts->input_dev, BTN_TOUCH, finger > 0);
+    input_sync(ts->input_dev);
+
+#ifdef HAVE_TOUCH_KEY
+	key = point_data[3]&0x0F;
+	if((last_key != 0)||(key != 0))
+	{
+		for(count = 0; count < MAX_KEY_NUM; count++)
+		{
+			input_report_key(ts->input_dev, touch_key_array[count], !!(key&(0x01<<count)));	
+		}
+	}		
+	last_key = key;	
+#endif
+
+XFER_ERROR:
+WORK_FUNC_END:
+#ifndef STOP_IRQ_TYPE
+	if(ts->use_irq)
+		gt811_irq_enable(ts);     //KT ADD 1202
+#endif
+}
+
+/*******************************************************	
+Function:
+	Response function timer
+	Triggered by a timer, scheduling the work function of the touch screen operation; after re-timing
+Parameters:
+	timer: the timer function is associated
+return:
+	Timer mode, HRTIMER_NORESTART that do not automatically restart
+********************************************************/
+static enum hrtimer_restart goodix_ts_timer_func(struct hrtimer *timer)
+{
+	struct goodix_ts_data *ts = container_of(timer, struct goodix_ts_data, timer);
+	queue_work(goodix_wq, &ts->work);
+	hrtimer_start(&ts->timer, ktime_set(0, (POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+/*******************************************************	
+Function:
+	Interrupt response function
+	Triggered by an interrupt, the scheduler runs the touch screen handler
+********************************************************/
+static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
+{
+/*
+	struct goodix_ts_data *ts = dev_id;
+
+	//printk(KERN_INFO"-------------------ts_irq_handler------------------\n");
+	//disable_irq_nosync(ts->client->irq);
+		reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+     
+	if(reg_val&(1<<(IRQ_EINT21)))
+	{	
+		print_int_info("==IRQ_EINT21=\n");
+		//clear the IRQ_EINT21 interrupt pending
+		writel(reg_val&(1<<(IRQ_EINT21)),gpio_addr + PIO_INT_STAT_OFFSET);
+//		 ts->irq_is_disable = 1;	
+		queue_work(goodix_wq, &ts->work);
+	}
+	else
+	{
+	    print_int_info("Other Interrupt\n");
+	    return IRQ_NONE;
+	}
+
+	return IRQ_HANDLED;
+*/
+	struct goodix_ts_data *ts = dev_id;
+
+	//printk(KERN_INFO"-------------------ts_irq_handler------------------\n");
+	//disable_irq_nosync(ts->client->irq);
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+     
+	if(reg_val&(1<<(CTP_IRQ_NO)))
+	{	
+		print_int_info("%s: %d. ==CTP_IRQ_NO=\n", __func__, __LINE__);
+		//clear the CTP_IRQ_NO interrupt pending
+		writel(reg_val&(1<<(CTP_IRQ_NO)),gpio_addr + PIO_INT_STAT_OFFSET);
+		queue_work(goodix_wq, &ts->work);
+	}
+	else
+	{
+	    print_int_info("Other Interrupt\n");
+	    return IRQ_NONE;
+	}
+	return IRQ_HANDLED;
+	
+
+}
+
+/*******************************************************	
+Function:
+	Power management gt811, gt811 allowed to sleep or to wake up
+Parameters:
+	on: 0 that enable sleep, wake up 1
+return:
+	Is set successfully, 0 for success
+	Error code: -1 for the i2c error, -2 for the GPIO error;-EINVAL on error as a parameter
+********************************************************/
+static int goodix_ts_power(struct goodix_ts_data * ts, int on)
+{
+	int ret = -1;
+
+	unsigned char i2c_control_buf[3] = {0x06,0x92,0x01};		//suspend cmd
+		
+	switch(on)
+	{
+		case 0:
+			ret = i2c_write_bytes(ts->client, i2c_control_buf, 3);
+			dev_info(&ts->client->dev, "Send suspend cmd\n");
+			if(ret > 0)						//failed
+				ret = 0;
+			i2c_end_cmd(ts);                     //must
+			return ret;
+			
+        case 1:
+#ifdef INT_PORT	                     //suggest use INT PORT to wake up !!!
+            //gpio_direction_output(INT_PORT, 0) ;
+            gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");
+            gpio_write_one_pin_value(gpio_int_hdle, 0, "ctp_int_port");
+
+            msleep(1);
+            //gpio_direction_output(INT_PORT, 1);
+			gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");
+            gpio_write_one_pin_value(gpio_int_hdle, 1, "ctp_int_port");
+
+            msleep(1);
+            //gpio_direction_output(INT_PORT, 0);
+			gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");
+            gpio_write_one_pin_value(gpio_int_hdle, 0, "ctp_int_port");
+
+            //gpio_free(INT_PORT);
+
+            //s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+            gpio_set_one_pin_pull(gpio_int_hdle, 0, "ctp_int_port");	
+
+			
+				if(ts->use_irq) {
+				//	s3c_gpio_cfgpin(INT_PORT, INT_CFG);	//Set IO port as interrupt port	
+					ret = ctp_ops.set_irq_mode("ctp_para", "ctp_int_port", CTP_IRQ_MODE);
+					if(0 != ret){
+						printk("%s:ctp_ops.set_irq_mode err. \n", __func__);
+						return ret;
+					}
+				}
+				else 
+				//gpio_direction_input(INT_PORT);
+				//Config CTP_IRQ_NO as input
+	  			gpio_set_one_pin_io_status(gpio_int_hdle,0, "ctp_int_port");
+       
+#else
+				//gpio_direction_output(SHUTDOWN_PORT,0);
+				gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+				gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+				msleep(1);
+				//gpio_direction_input(SHUTDOWN_PORT);		
+				gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+#endif					
+				msleep(40);
+				ret = 0;
+				return ret;
+				
+		default:
+			printk(KERN_DEBUG "%s: Cant't support this command.", gt80x_ts_name);
+			return -EINVAL;
+	}
+
+}
+/*******************************************************	
+Function:
+	Touch-screen detection function
+	Called when the registration drive (required for a corresponding client);
+	For IO, interrupts and other resources to apply; equipment registration; touch screen initialization, etc.
+Parameters:
+	client: the device structure to be driven
+	id: device ID
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    int err;
+    int ret = 0;
+    int retry=0;
+    char test_data = 1;
+    const char irq_table[2] = {IRQ_TYPE_EDGE_FALLING,IRQ_TYPE_EDGE_RISING};
+    struct goodix_ts_data *ts;
+
+    struct goodix_i2c_rmi_platform_data *pdata;
+    dev_info(&client->dev,"Install gt811 driver.\n");
+    dev_info(&client->dev,"Driver Release Date:2012-02-08\n");	
+
+    printk("======goodix_gt811 probe======\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
+	{
+		dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	i2c_connect_client = client;
+
+	
+	
+	
+/*	
+	ret = gpio_request(SHUTDOWN_PORT, "RESET_INT");
+	if (ret < 0)
+        {
+		dev_err(&client->dev, "Failed to request RESET GPIO:%d, ERRNO:%d\n",(int)SHUTDOWN_PORT,ret);
+		goto err_gpio_request;
+	}
+*/	
+	//s3c_gpio_setpull(SHUTDOWN_PORT, S3C_GPIO_PULL_UP);		//set GPIO pull-up
+	gpio_set_one_pin_pull(gpio_wakeup_hdle, 1, "ctp_wakeup");
+
+	
+	for(retry=0;retry < 5; retry++)
+	{
+		//gpio_direction_output(SHUTDOWN_PORT,0);
+		gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+		gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");		
+		msleep(1);
+		//gpio_direction_input(SHUTDOWN_PORT);
+		gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup")	;	
+		msleep(100);
+	
+		ret =i2c_write_bytes(client, &test_data, 1);	//Test I2C connection.
+		if (ret > 0)
+			break;
+		dev_info(&client->dev, "GT811 I2C TEST FAILED!Please check the HARDWARE connect\n");
+	}
+
+	if(ret <= 0)
+	{
+		dev_err(&client->dev, "Warnning: I2C communication might be ERROR!\n");
+		goto err_i2c_failed;
+	}	
+
+	flush_workqueue(goodix_wq);
+	INIT_WORK(&ts->work, goodix_ts_work_func);		//init work_struct
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+/////////////////////////////// UPDATE STEP 1 START/////////////////////////////////////////////////////////////////
+#ifdef AUTO_UPDATE_GT811		//modify by andrew
+	msleep(20);
+        goodix_read_version(ts);
+            
+        ret = gt811_downloader( ts, goodix_gt811_firmware);
+        if(ret < 0)
+        {
+            dev_err(&client->dev, "Warnning: gt811 update might be ERROR!\n");
+            //goto err_input_dev_alloc_failed;
+        }
+#endif
+///////////////////////////////UPDATE STEP 1 END////////////////////////////////////////////////////////////////      
+#ifdef INT_PORT	
+	client->irq=INT_PORT;		//If not defined in client
+	if (client->irq)
+	{
+		/**
+		ret = gpio_request(INT_PORT, "TS_INT");	//Request IO
+		if (ret < 0) 
+		{
+			dev_err(&client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(int)INT_PORT,ret);
+			goto err_gpio_request_failed;
+		}
+		**/				
+	
+	#ifndef STOP_IRQ_TYPE
+		ts->irq = INT_PORT;     //KT ADD 1202
+//		ts->irq_is_disable = 0;           // enable irq
+	#endif	
+	}
+#endif	
+
+    err = ctp_ops.set_irq_mode("ctp_para", "ctp_int_port", CTP_IRQ_MODE);
+    if(0 != err){
+        printk("%s:ctp_ops.set_irq_mode err. \n", __func__);
+        goto exit_set_irq_mode;
+    }	
+
+    //disable_irq(client->irq);
+    //Disable IRQ_EINT21 of PIO Interrupt
+    reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+    reg_val &=~(1<<CTP_IRQ_NO);
+    writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+
+
+err_gpio_request_failed:
+    for(retry=0; retry<3; retry++)
+    {
+        ret=goodix_init_panel(ts);
+        msleep(2);
+        if(ret != 0)	//Initiall failed
+            continue;
+        else
+            break;
+    }
+    if(ret != 0) 
+    {
+        ts->bad_data=1;
+        goto err_init_godix_ts;
+    }
+
+    ts->input_dev = input_allocate_device();
+    if (ts->input_dev == NULL) 
+    {
+        ret = -ENOMEM;
+        dev_dbg(&client->dev,"goodix_ts_probe: Failed to allocate input device\n");
+        goto err_input_dev_alloc_failed;
+    }
+
+    ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+    ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+    ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+#ifdef HAVE_TOUCH_KEY
+	for(retry = 0; retry < MAX_KEY_NUM; retry++)
+	{
+		input_set_capability(ts->input_dev,EV_KEY,touch_key_array[retry]);	
+	}
+#endif
+
+	input_set_abs_params(ts->input_dev, ABS_X, 0,  ts->abs_x_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, ts->abs_y_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+	
+#ifdef GOODIX_MULTI_TOUCH
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0,  ts->abs_x_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max, 0, 0);	
+#endif	
+
+	sprintf(ts->phys, "input/ts");
+	ts->input_dev->name = gt80x_ts_name;
+	ts->input_dev->phys = ts->phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->id.vendor = 0xDEAD;
+	ts->input_dev->id.product = 0xBEEF;
+	ts->input_dev->id.version = 10427;	//screen firmware version
+	
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		dev_err(&client->dev,"Probe: Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+	ts->bad_data = 0;
+
+
+
+#ifdef INT_PORT		
+	ret  = request_irq(client->irq, goodix_ts_irq_handler ,  irq_table[ts->int_trigger_type],
+			client->name, ts);
+    if (ret != 0)
+    {
+        dev_err(&client->dev,"Cannot allocate ts INT!ERRNO:%d\n", ret);
+        //gpio_direction_input(INT_PORT);
+        gpio_set_one_pin_io_status(gpio_int_hdle, 0, "ctp_int_port");
+        //gpio_free(INT_PORT);
+        goto err_init_godix_ts;
+    }
+    else 
+    {	
+#ifndef STOP_IRQ_TYPE
+        gt811_irq_disable(ts);     //KT ADD 1202
+#else
+        {
+            //disable_irq(client->irq);
+            reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+            reg_val &=~(1<<CTP_IRQ_NO);
+            writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+        }	 
+#endif
+        ts->use_irq = 1;
+        dev_dbg(&client->dev,"Reques EIRQ %d succesd on GPIO:%d\n",INT_PORT,INT_PORT);
+    }	
+#endif	
+
+	
+	if (!ts->use_irq) 
+	{
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = goodix_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	}
+	
+    if(ts->use_irq)
+#ifndef STOP_IRQ_TYPE
+        gt811_irq_enable(ts);     //KT ADD 1202
+#else
+    {
+        //enable_irq(client->irq);
+        reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        reg_val |=(1<<CTP_IRQ_NO);
+        writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+    }	   
+#endif
+
+    ts->power = goodix_ts_power;
+
+    goodix_read_version(ts);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    ts->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB;//EARLY_SUSPEND_LEVEL_BLANK_SCREEN +1;
+    ts->early_suspend.suspend = goodix_ts_early_suspend;
+    ts->early_suspend.resume = goodix_ts_late_resume;
+    register_early_suspend(&ts->early_suspend);
+#endif
+
+/////////////////////////////// UPDATE STEP 2 START /////////////////////////////////////////////////////////////////
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+	goodix_proc_entry = create_proc_entry("goodix-update", 0666, NULL);
+	if(goodix_proc_entry == NULL)
+	{
+		dev_info(&client->dev, "Couldn't create proc entry!\n");
+		ret = -ENOMEM;
+		goto err_create_proc_entry;
+	}
+	else
+	{
+		dev_info(&client->dev, "Create proc entry success!\n");
+		goodix_proc_entry->write_proc = goodix_update_write;
+		goodix_proc_entry->read_proc = goodix_update_read;
+	}
+#endif
+///////////////////////////////UPDATE STEP 2 END /////////////////////////////////////////////////////////////////
+	dev_info(&client->dev,"Start %s in %s mode,Driver Modify Date:2012-01-05\n", 
+		ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+	return 0;
+
+err_init_godix_ts:
+	i2c_end_cmd(ts);
+	if(ts->use_irq)
+	{
+		ts->use_irq = 0;
+		free_irq(client->irq,ts);
+#ifdef INT_PORT	
+        //gpio_direction_input(INT_PORT);
+        gpio_set_one_pin_io_status(gpio_int_hdle, 0, "ctp_int_port");
+        //gpio_free(INT_PORT);
+
+#endif	
+	}
+	else 
+		hrtimer_cancel(&ts->timer);
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed:
+	i2c_set_clientdata(client, NULL);
+err_gpio_request:
+exit_set_irq_mode:	
+err_i2c_failed:	
+	kfree(ts);
+err_alloc_data_failed:
+err_check_functionality_failed:
+err_create_proc_entry:
+	return ret;
+}
+
+
+/*******************************************************	
+Function:
+	Drive the release of resources
+Parameters:
+	client: the device structure
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static int goodix_ts_remove(struct i2c_client *client)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+/////////////////////////////// UPDATE STEP 3 START/////////////////////////////////////////////////////////////////
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+	remove_proc_entry("goodix-update", NULL);
+#endif
+/////////////////////////////////UPDATE STEP 3 END///////////////////////////////////////////////////////////////
+
+    if (ts && ts->use_irq) 
+    {
+#ifdef INT_PORT
+        //gpio_direction_input(INT_PORT);
+        gpio_set_one_pin_io_status(gpio_int_hdle, 0, "ctp_int_port");
+        //gpio_free(INT_PORT);
+
+#endif	
+        free_irq(client->irq, ts);
+    }	
+    else if(ts)
+        hrtimer_cancel(&ts->timer);
+
+    dev_notice(&client->dev,"The driver is removing...\n");
+    i2c_set_clientdata(client, NULL);
+    input_unregister_device(ts->input_dev);
+    kfree(ts);
+    return 0;
+}
+
+//????
+static int goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+    if (ts->use_irq)
+        //disable_irq(client->irq);
+        //#ifndef STOP_IRQ_TYPE
+        //gt811_irq_disable(ts);     //KT ADD 1202
+        //#else
+    {
+        //disable_irq(client->irq);
+        reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        reg_val &=~(1<<CTP_IRQ_NO);
+        writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+        ts->irq_is_disable = 1;
+    }
+    //#endif
+
+    else
+        hrtimer_cancel(&ts->timer);
+        ret = cancel_work_sync(&ts->work);
+        if(ret && ts->use_irq) {
+        //enable_irq(client->irq);
+        	reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        	reg_val |=(1<<CTP_IRQ_NO);
+        	writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+      	}
+
+    if (ts->power) {	/* ?????work????????GPIO???????????	*/
+        ret = ts->power(ts, 0);
+        //printk("==goodix_ts_suspend  power off ret=%d==\n",ret);
+        if (ret < 0)
+        	printk(KERN_ERR "goodix_ts_suspend power off failed\n");
+        else 
+        	printk(KERN_ERR "goodix_ts_suspend power off sucess\n");
+    }
+    return 0;
+}
+
+static int goodix_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+    if (ts->power) {
+        ret = ts->power(ts, 1);
+        if (ret < 0)
+            printk(KERN_ERR "goodix_ts_resume power on failed\n");
+        else
+        	printk(KERN_ERR "goodix_ts_resume power on success\n");
+    }
+    reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+    reg_val |=(1<<CTP_IRQ_NO);
+    writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+
+    if (ts->use_irq){
+#ifndef STOP_IRQ_TYPE
+        gt811_irq_enable(ts);     //KT ADD 1202
+#else
+        //enable_irq(client->irq);
+        reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        reg_val |=(1<<CTP_IRQ_NO);
+        writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+#endif
+    }
+    else
+        hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+
+    return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h)
+{
+	struct goodix_ts_data *ts;
+	printk("=======%s========\n",__func__);
+	ts = container_of(h, struct goodix_ts_data, early_suspend);
+	goodix_ts_suspend(ts->client, PMSG_SUSPEND);
+
+}
+
+static void goodix_ts_late_resume(struct early_suspend *h)
+{
+
+	struct goodix_ts_data *ts;
+	printk("=======%s========\n",__func__);	
+	ts = container_of(h, struct goodix_ts_data, early_suspend);
+	goodix_ts_resume(ts->client);
+
+}
+#endif
+/////////////////////////////// UPDATE STEP 4 START/////////////////////////////////////////////////////////////////
+//******************************Begin of firmware update surpport*******************************
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+static struct file * update_file_open(char * path, mm_segment_t * old_fs_p)
+{
+	struct file * filp = NULL;
+	int errno = -1;
+		
+	filp = filp_open(path, O_RDONLY, 0644);
+	
+	if(!filp || IS_ERR(filp))
+	{
+		if(!filp)
+			errno = -ENOENT;
+		else 
+			errno = PTR_ERR(filp);					
+		printk(KERN_ERR "The update file for Guitar open error.\n");
+		return NULL;
+	}
+	*old_fs_p = get_fs();
+	set_fs(get_ds());
+
+	filp->f_op->llseek(filp,0,0);
+	return filp ;
+}
+
+static void update_file_close(struct file * filp, mm_segment_t old_fs)
+{
+	set_fs(old_fs);
+	if(filp)
+		filp_close(filp, NULL);
+}
+static int update_get_flen(char * path)
+{
+	struct file * file_ck = NULL;
+	mm_segment_t old_fs;
+	int length ;
+	
+	file_ck = update_file_open(path, &old_fs);
+	if(file_ck == NULL)
+		return 0;
+
+	length = file_ck->f_op->llseek(file_ck, 0, SEEK_END);
+	//printk("File length: %d\n", length);
+	if(length < 0)
+		length = 0;
+	update_file_close(file_ck, old_fs);
+	return length;	
+}
+
+static int goodix_update_write(struct file *filp, const char __user *buff, unsigned long len, void *data)
+{
+    unsigned char cmd[120];
+    int ret = -1;
+    int retry = 0;
+    static unsigned char update_path[60];
+    struct goodix_ts_data *ts;
+    struct file * file_data = NULL;
+    mm_segment_t old_fs;
+    unsigned char *file_ptr = NULL;
+    unsigned int file_len;
+	
+    ts = i2c_get_clientdata(i2c_connect_client);
+    if(ts==NULL)
+    {
+        printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+        return 0;
+    }
+
+    //printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+    if(copy_from_user(&cmd, buff, len))
+    {
+        printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+        return -EFAULT;
+    }
+    //printk(KERN_INFO"Write cmd is:%d,write len is:%ld\n",cmd[0], len);
+    switch(cmd[0])
+    {
+        case APK_UPDATE_TP:
+            printk(KERN_INFO"Write cmd is:%d,cmd arg is:%s,write len is:%ld\n",cmd[0], &cmd[1], len);
+            memset(update_path, 0, 60);
+            strncpy(update_path, cmd+1, 60);
+
+#ifndef STOP_IRQ_TYPE
+            gt811_irq_disable(ts);     //KT ADD 1202
+#else
+            {
+                //disable_irq(client->irq);
+                reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+                reg_val &=~(1<<CTP_IRQ_NO);
+                writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+            }
+#endif
+            file_data = update_file_open(update_path, &old_fs);
+            if(file_data == NULL)   //file_data has been opened at the last time
+            {
+                dev_info(&ts->client->dev, "cannot open update file\n");
+                return 0;
+            }
+
+            file_len = update_get_flen(update_path);
+            dev_info(&ts->client->dev, "Update file length:%d\n", file_len);
+            file_ptr = (unsigned char*)vmalloc(file_len);
+            if(file_ptr==NULL)
+            {
+                dev_info(&ts->client->dev, "cannot malloc memory!\n");
+                return 0;
+            }	
+
+            ret = file_data->f_op->read(file_data, file_ptr, file_len, &file_data->f_pos);
+            if(ret <= 0)
+            {
+                dev_info(&ts->client->dev, "read file data failed\n");
+                return 0;
+            }
+            update_file_close(file_data, old_fs);	
+
+            ret = gt811_downloader(ts, file_ptr);
+            vfree(file_ptr);
+            if(ret < 0)
+            {
+                printk(KERN_INFO"Warnning: GT811 update might be ERROR!\n");
+                return 0;
+            }
+
+            //i2c_pre_cmd(ts);
+
+            //gpio_direction_output(SHUTDOWN_PORT, 0);
+            gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+            gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+            msleep(5);
+            //gpio_direction_input(SHUTDOWN_PORT);
+            gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+            msleep(20);
+            for(retry=0; retry<3; retry++)
+            {
+                ret=goodix_init_panel(ts);
+                msleep(2);
+                if(ret != 0)	//Initiall failed
+                {
+                    dev_info(&ts->client->dev, "Init panel failed!\n");
+                    continue;
+                }
+                else
+                    break;
+
+            }
+            //gpio_free(INT_PORT); 
+            //ret = gpio_request(INT_PORT, "TS_INT"); //Request IO
+            if (ret < 0)
+            {
+                dev_err(&ts->client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(int)INT_PORT,ret);
+                return 0;
+            }
+            //s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE); //ret > 0 ?
+            gpio_set_one_pin_pull(gpio_int_hdle, 0, "ctp_int_port");        
+            //s3c_gpio_cfgpin(INT_PORT, INT_CFG);     //Set IO port function 
+            reg_val = readl(gpio_addr + PHO_CFG2_OFFSET);
+            reg_val &=(~(1<<20));
+            reg_val |=(3<<21);  
+            writel(reg_val,gpio_addr + PHO_CFG2_OFFSET);	
+            //gpio_direction_input(INT_PORT);
+            //s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_UP); 
+            //s3c_gpio_cfgpin(INT_PORT, INT_CFG);	//Set IO port as interrupt port	
+            //s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+            //while(1);		
+#ifndef STOP_IRQ_TYPE
+            gt811_irq_enable(ts);     //KT ADD 1202
+#else
+            {
+                //enable_irq(ts->client->irq);
+                reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+                reg_val |=(1<<CTP_IRQ_NO);
+                writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+            }	   
+#endif   
+            //i2c_end_cmd(ts);
+            return 1;
+
+        case APK_READ_FUN:							//functional command
+            if(cmd[1] == CMD_READ_VER)
+            {
+                printk(KERN_INFO"Read version!\n");
+                ts->read_mode = MODE_RD_VER;
+            }
+            else if(cmd[1] == CMD_READ_CFG)
+            {
+                printk(KERN_INFO"Read config info!\n");
+                ts->read_mode = MODE_RD_CFG;
+            }
+            else if (cmd[1] == CMD_READ_RAW)
+            {
+                printk(KERN_INFO"Read raw data!\n");
+                ts->read_mode = MODE_RD_RAW;
+            }
+            else if (cmd[1] == CMD_READ_CHIP_TYPE)
+            {
+                printk(KERN_INFO"Read chip type!\n");
+                ts->read_mode = MODE_RD_CHIP_TYPE;
+            }
+            return 1;
+
+        case APK_WRITE_CFG:			
+            printk(KERN_INFO"Begin write config info!Config length:%d\n",cmd[1]);
+            i2c_pre_cmd(ts);
+            ret = i2c_write_bytes(ts->client, cmd+2, cmd[1]+2); 
+            i2c_end_cmd(ts);
+            if(ret != 1)
+            {
+                printk("Write Config failed!return:%d\n",ret);
+                return -1;
+            }
+            return 1;
+
+        default:
+            return 0;
+    }
+	return 0;
+}
+
+static int goodix_update_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+    int ret = -1;
+    int len = 0;
+    int read_times = 0;
+    struct goodix_ts_data *ts;
+    unsigned char read_data[360] = {80, };
+
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if(ts==NULL)
+		return 0;
+
+    printk("___READ__\n");
+    if(ts->read_mode == MODE_RD_VER)		//read version data
+    {
+        i2c_pre_cmd(ts);
+        ret = goodix_read_version(ts);
+        i2c_end_cmd(ts);
+        if(ret < 0)
+        {
+            printk(KERN_INFO"Read version data failed!\n");
+            return 0;
+        }
+
+        read_data[1] = (char)(ts->version&0xff);
+        read_data[0] = (char)((ts->version>>8)&0xff);
+
+        memcpy(page, read_data, 2);
+        //*eof = 1;
+        return 2;
+    }
+    else if (ts->read_mode == MODE_RD_CHIP_TYPE)
+    {
+        page[0] = GT811;
+        return 1;
+    }
+    else if(ts->read_mode == MODE_RD_CFG)
+    {
+
+        read_data[0] = 0x06;
+        read_data[1] = 0xa2;       // cfg start address
+        printk("read config addr is:%x,%x\n", read_data[0],read_data[1]);
+
+        len = 106;
+        i2c_pre_cmd(ts);
+        ret = i2c_read_bytes(ts->client, read_data, len+2);
+        i2c_end_cmd(ts);
+        if(ret <= 0)
+        {
+            printk(KERN_INFO"Read config info failed!\n");
+            return 0;
+        }
+
+        memcpy(page, read_data+2, len);
+        return len;
+    }
+    else if (ts->read_mode == MODE_RD_RAW)
+    {
+#define TIMEOUT (-100)
+        int retry = 0;
+        if (raw_data_ready != RAW_DATA_READY)
+        {
+            raw_data_ready = RAW_DATA_ACTIVE;
+        }
+
+RETRY:
+        read_data[0] = 0x07;
+        read_data[1] = 0x11;
+        read_data[2] = 0x01;
+
+        ret = i2c_write_bytes(ts->client, read_data, 3);
+
+#ifdef DEBUG
+        sum += read_times;
+        printk("count :%d\n", ++access_count);
+        printk("A total of try times:%d\n", sum);
+#endif
+
+        read_times = 0;
+        while (RAW_DATA_READY != raw_data_ready)
+        {
+            msleep(4);
+
+            if (read_times++ > 10)
+            {
+                if (retry++ > 5)
+                {
+                    return TIMEOUT;
+                }
+                goto RETRY;
+            }
+        }
+#ifdef DEBUG	    
+        printk("read times:%d\n", read_times);
+#endif	    
+        read_data[0] = 0x08;
+        read_data[1] = 0x80;       // raw data address
+
+        len = 160;
+
+        // msleep(4);
+
+        i2c_pre_cmd(ts);
+        ret = i2c_read_bytes(ts->client, read_data, len+2);    	    
+        //      i2c_end_cmd(ts);
+
+        if(ret <= 0)
+        {
+            printk(KERN_INFO"Read raw data failed!\n");
+            return 0;
+        }
+        memcpy(page, read_data+2, len);
+
+        read_data[0] = 0x09;
+        read_data[1] = 0xC0;
+        //	i2c_pre_cmd(ts);
+        ret = i2c_read_bytes(ts->client, read_data, len+2);    	    
+        i2c_end_cmd(ts);
+
+        if(ret <= 0)
+        {
+            printk(KERN_INFO"Read raw data failed!\n");
+            return 0;
+        }
+        memcpy(&page[160], read_data+2, len);
+
+#ifdef DEBUG
+        //**************
+        for (i = 0; i < 300; i++)
+        {
+            printk("%6x", page[i]);
+
+            if ((i+1) % 10 == 0)
+            {
+                printk("\n");
+            }
+        }
+        //********************/  
+#endif
+        raw_data_ready = RAW_DATA_NON_ACTIVE;
+
+        return (2*len);   
+
+    }
+    return 0;
+//#endif
+}             
+//********************************************************************************************
+static u8  is_equal( u8 *src , u8 *dst , int len )
+{
+    int i;
+
+#if 0    
+    for( i = 0 ; i < len ; i++ )
+    {
+        printk(KERN_INFO"[%02X:%02X]", src[i], dst[i]);
+        if((i+1)%10==0)printk("\n");
+    }
+#endif
+
+    for( i = 0 ; i < len ; i++ )
+    {
+        if ( src[i] != dst[i] )
+        {
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+static  u8 gt811_nvram_store( struct goodix_ts_data *ts )
+{
+    int ret;
+    int i;
+    u8 inbuf[3] = {REG_NVRCS_H,REG_NVRCS_L,0};
+    //u8 outbuf[3] = {};
+    ret = i2c_read_bytes( ts->client, inbuf, 3 );
+
+    if ( ret < 0 )
+    {
+        return 0;
+    }
+
+    if ( ( inbuf[2] & BIT_NVRAM_LOCK ) == BIT_NVRAM_LOCK )
+    {
+        return 0;
+    }
+
+    inbuf[2] = (1<<BIT_NVRAM_STROE);		//store command
+
+    for ( i = 0 ; i < 300 ; i++ )
+    {
+        ret = i2c_write_bytes( ts->client, inbuf, 3 );
+
+        if ( ret < 0 )
+            break;
+    }
+
+    return ret;
+}
+
+static u8  gt811_nvram_recall( struct goodix_ts_data *ts )
+{
+    int ret;
+    u8 inbuf[3] = {REG_NVRCS_H,REG_NVRCS_L,0};
+
+    ret = i2c_read_bytes( ts->client, inbuf, 3 );
+
+    if ( ret < 0 )
+    {
+        return 0;
+    }
+
+    if ( ( inbuf[2]&BIT_NVRAM_LOCK) == BIT_NVRAM_LOCK )
+    {
+        return 0;
+    }
+
+    inbuf[2] = ( 1 << BIT_NVRAM_RECALL );		//recall command
+    ret = i2c_write_bytes( ts->client , inbuf, 3);
+    return ret;
+}
+
+static  int gt811_reset( struct goodix_ts_data *ts )
+{
+    int ret = 1;
+    u8 retry;
+
+    unsigned char outbuf[3] = {0,0xff,0};
+    unsigned char inbuf[3] = {0,0xff,0};
+    //outbuf[1] = 1;
+
+    //gpio_direction_output(SHUTDOWN_PORT,0);
+    gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+    gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");    
+    msleep(20);
+    //gpio_direction_input(SHUTDOWN_PORT);
+    gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+    msleep(100);
+    for(retry=0;retry < 80; retry++)
+    {
+        ret =i2c_write_bytes(ts->client, inbuf, 0);	//Test I2C connection.
+        if (ret > 0)
+        {
+            msleep(10);
+            ret =i2c_read_bytes(ts->client, inbuf, 3);	//Test I2C connection.
+            if (ret > 0)
+            {
+                if(inbuf[2] == 0x55)
+                {
+                    ret =i2c_write_bytes(ts->client, outbuf, 3);
+                    msleep(10);
+                    break;						
+                }
+            }			
+        }
+        else
+        {
+            //gpio_direction_output(SHUTDOWN_PORT,0);
+            gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+            gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");    
+
+            msleep(20);
+            //gpio_direction_input(SHUTDOWN_PORT);
+            gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+            msleep(20);
+            dev_info(&ts->client->dev, "i2c address failed\n");
+        }	
+
+    }
+
+    dev_info(&ts->client->dev, "Detect address %0X\n", ts->client->addr);
+    //msleep(500);
+    return ret;	
+}
+
+static  int gt811_reset2( struct goodix_ts_data *ts )
+{
+    int ret = 1;
+    u8 retry;
+
+    //unsigned char outbuf[3] = {0,0xff,0};
+    unsigned char inbuf[3] = {0,0xff,0};
+    //outbuf[1] = 1;
+
+    //gpio_direction_output(SHUTDOWN_PORT,0);
+    gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+    gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");    
+
+    msleep(20);
+    //gpio_direction_input(SHUTDOWN_PORT);
+    gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+    msleep(100);
+    for(retry=0;retry < 80; retry++)
+    {
+        ret =i2c_write_bytes(ts->client, inbuf, 0);	//Test I2C connection.
+        if (ret > 0)
+        {
+            msleep(10);
+            ret =i2c_read_bytes(ts->client, inbuf, 3);	//Test I2C connection.
+            if (ret > 0)
+            {
+                //if(inbuf[2] == 0x55)
+                //{
+                //ret =i2c_write_bytes(ts->client, outbuf, 3);
+                //msleep(10);
+                break;						
+                //}
+            }			
+        }	
+
+    }
+    dev_info(&ts->client->dev, "Detect address %0X\n", ts->client->addr);
+    //msleep(500);
+    return ret;	
+}
+static  int gt811_set_address_2( struct goodix_ts_data *ts )
+{
+    unsigned char inbuf[3] = {0,0,0};
+    int i;
+
+    for ( i = 0 ; i < 12 ; i++ )
+    {
+        if ( i2c_read_bytes( ts->client, inbuf, 3) )
+        {
+            dev_info(&ts->client->dev, "Got response\n");
+            return 1;
+        }
+        dev_info(&ts->client->dev, "wait for retry\n");
+        msleep(50);
+    } 
+    return 0;
+}
+static u8  gt811_update_firmware( u8 *nvram, u16 start_addr, u16 length, struct goodix_ts_data *ts)
+{
+    u8 ret,err,retry_time,i;
+    u16 cur_code_addr;
+    u16 cur_frame_num, total_frame_num, cur_frame_len;
+    u32 gt80x_update_rate;
+
+    unsigned char i2c_data_buf[PACK_SIZE+2] = {0,};
+    unsigned char i2c_chk_data_buf[PACK_SIZE+2] = {0,};
+    
+    if( length > NVRAM_LEN - NVRAM_BOOT_SECTOR_LEN )
+    {
+        dev_info(&ts->client->dev, "Fw length %d is bigger than limited length %d\n", length, NVRAM_LEN - NVRAM_BOOT_SECTOR_LEN );
+        return 0;
+    }
+    	
+    total_frame_num = ( length + PACK_SIZE - 1) / PACK_SIZE;  
+
+    //gt80x_update_sta = _UPDATING;
+    gt80x_update_rate = 0;
+
+    for( cur_frame_num = 0 ; cur_frame_num < total_frame_num ; cur_frame_num++ )	  
+    {
+        retry_time = 5;
+        dev_info(&ts->client->dev, "PACK[%d]\n",cur_frame_num); 
+        cur_code_addr = /*NVRAM_UPDATE_START_ADDR*/start_addr + cur_frame_num * PACK_SIZE; 	
+        i2c_data_buf[0] = (cur_code_addr>>8)&0xff;
+        i2c_data_buf[1] = cur_code_addr&0xff;
+        
+        i2c_chk_data_buf[0] = i2c_data_buf[0];
+        i2c_chk_data_buf[1] = i2c_data_buf[1];
+        
+        if( cur_frame_num == total_frame_num - 1 )
+        {
+            cur_frame_len = length - cur_frame_num * PACK_SIZE;
+        }
+        else
+        {
+            cur_frame_len = PACK_SIZE;
+        }
+        
+        //strncpy(&i2c_data_buf[2], &nvram[cur_frame_num*PACK_SIZE], cur_frame_len);
+        for(i=0;i<cur_frame_len;i++)
+        {
+            i2c_data_buf[2+i] = nvram[cur_frame_num*PACK_SIZE+i];
+        }
+        do
+        {
+            err = 0;
+
+            //ret = gt811_i2c_write( guitar_i2c_address, cur_code_addr, &nvram[cur_frame_num*I2C_FRAME_MAX_LENGTH], cur_frame_len );		
+            ret = i2c_write_bytes(ts->client, i2c_data_buf, (cur_frame_len+2));
+            if ( ret <= 0 )
+            {
+                dev_info(&ts->client->dev, "write fail\n");
+                err = 1;
+            }
+            
+            ret = i2c_read_bytes(ts->client, i2c_chk_data_buf, (cur_frame_len+2));
+            // ret = gt811_i2c_read( guitar_i2c_address, cur_code_addr, inbuf, cur_frame_len);
+            if ( ret <= 0 )
+            {
+                dev_info(&ts->client->dev, "read fail\n");
+                err = 1;
+            }
+	    
+            if( is_equal( &i2c_data_buf[2], &i2c_chk_data_buf[2], cur_frame_len ) == 0 )
+            {
+                dev_info(&ts->client->dev, "not equal\n");
+                err = 1;
+            }
+			
+        } while ( err == 1 && (--retry_time) > 0 );
+        
+        if( err == 1 )
+        {
+            break;
+        }
+		
+        gt80x_update_rate = ( cur_frame_num + 1 )*128/total_frame_num;
+    
+    }
+
+    if( err == 1 )
+    {
+        dev_info(&ts->client->dev, "write nvram fail\n");
+        return 0;
+    }
+    
+    ret = gt811_nvram_store(ts);
+    
+    msleep( 20 );
+
+    if( ret == 0 )
+    {
+        dev_info(&ts->client->dev, "nvram store fail\n");
+        return 0;
+    }
+    
+    ret = gt811_nvram_recall(ts);
+
+    msleep( 20 );
+    
+    if( ret == 0 )
+    {
+        dev_info(&ts->client->dev, "nvram recall fail\n");
+        return 0;
+    }
+
+    for ( cur_frame_num = 0 ; cur_frame_num < total_frame_num ; cur_frame_num++ )		 //	read out all the code
+    {
+
+        cur_code_addr = NVRAM_UPDATE_START_ADDR + cur_frame_num*PACK_SIZE;
+        retry_time=5;
+        i2c_chk_data_buf[0] = (cur_code_addr>>8)&0xff;
+        i2c_chk_data_buf[1] = cur_code_addr&0xff;
+        
+        
+        if ( cur_frame_num == total_frame_num-1 )
+        {
+            cur_frame_len = length - cur_frame_num*PACK_SIZE;
+        }
+        else
+        {
+            cur_frame_len = PACK_SIZE;
+        }
+        
+        do
+        {
+            err = 0;
+            //ret = gt811_i2c_read( guitar_i2c_address, cur_code_addr, inbuf, cur_frame_len);
+            ret = i2c_read_bytes(ts->client, i2c_chk_data_buf, (cur_frame_len+2));
+
+            if ( ret == 0 )
+            {
+                err = 1;
+            }
+            
+            if( is_equal( &nvram[cur_frame_num*PACK_SIZE], &i2c_chk_data_buf[2], cur_frame_len ) == 0 )
+            {
+                err = 1;
+            }
+        } while ( err == 1 && (--retry_time) > 0 );
+        
+        if( err == 1 )
+        {
+            break;
+        }
+        
+        gt80x_update_rate = 127 + ( cur_frame_num + 1 )*128/total_frame_num;
+    }
+    
+    gt80x_update_rate = 255;
+    //gt80x_update_sta = _UPDATECHKCODE;
+
+    if( err == 1 )
+    {
+        dev_info(&ts->client->dev, "nvram validate fail\n");
+        return 0;
+    }
+    
+    return 1;
+}
+
+static u8  gt811_update_proc( u8 *nvram, u16 start_addr , u16 length, struct goodix_ts_data *ts )
+{
+    u8 ret;
+    u8 error = 0;
+    //struct tpd_info_t tpd_info;
+    GT811_SET_INT_PIN( 0 );
+    msleep( 20 );
+    ret = gt811_reset(ts);
+    if ( ret < 0 )
+    {
+        error = 1;
+        dev_info(&ts->client->dev, "reset fail\n");
+        goto end;
+    }
+
+    ret = gt811_set_address_2( ts );
+    if ( ret == 0 )
+    {
+        error = 1;
+        dev_info(&ts->client->dev, "set address fail\n");
+        goto end;
+    }
+
+    ret = gt811_update_firmware( nvram, start_addr, length, ts);
+    if ( ret == 0 )
+    {
+        error=1;
+       	dev_info(&ts->client->dev, "firmware update fail\n");
+        goto end;
+    }
+
+end:
+    GT811_SET_INT_PIN( 1 );
+    //gpio_free(INT_PORT);
+    //s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+    gpio_set_one_pin_pull(gpio_int_hdle, 0, "ctp_int_port");  
+
+    msleep( 500 );
+    ret = gt811_reset2(ts);
+    if ( ret < 0 )
+    {
+        error=1;
+        dev_info(&ts->client->dev, "final reset fail\n");
+        goto end;
+    }
+    if ( error == 1 )
+    {
+        return 0; 
+    }
+
+    //i2c_pre_cmd(ts);
+    while(goodix_read_version(ts)<0);
+
+    //i2c_end_cmd(ts);
+    return 1;
+}
+
+u16 Little2BigEndian(u16 little_endian)
+{
+	u16 temp = 0;
+	temp = little_endian&0xff;
+	return (temp<<8)+((little_endian>>8)&0xff);
+}
+
+int  gt811_downloader( struct goodix_ts_data *ts,  unsigned char * data)
+{
+    struct tpd_firmware_info_t *fw_info = (struct tpd_firmware_info_t *)data;
+    //int i;
+    //unsigned short checksum = 0;
+    //unsigned int  checksum = 0;
+    unsigned int  fw_checksum = 0;
+    //unsigned char fw_chip_type;
+    unsigned short fw_version;
+    unsigned short fw_start_addr;
+    unsigned short fw_length;
+    unsigned char *data_ptr;
+    //unsigned char *file_ptr = &(fw_info->chip_type);
+    int retry = 0,ret;
+    int err = 0;
+    unsigned char rd_buf[4] = {0};
+    unsigned char *mandatory_base = "GOODIX";
+    unsigned char rd_rom_version;
+    unsigned char rd_chip_type;
+    unsigned char rd_nvram_flag;
+
+    //struct file * file_data = NULL;
+    //mm_segment_t old_fs;
+    //unsigned int rd_len;
+    //unsigned int file_len = 0;
+    //unsigned char i2c_data_buf[PACK_SIZE] = {0,};
+    
+    rd_buf[0]=0x14;
+    rd_buf[1]=0x00;
+    rd_buf[2]=0x80;
+    ret = i2c_write_bytes(ts->client, rd_buf, 3);
+    if(ret<0)
+    {
+        dev_info(&ts->client->dev, "i2c write failed\n");
+        goto exit_downloader;
+    }
+    rd_buf[0]=0x40;
+    rd_buf[1]=0x11;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+        dev_info(&ts->client->dev, "i2c request failed!\n");
+        goto exit_downloader;
+    }
+    rd_chip_type = rd_buf[2];
+    rd_buf[0]=0xFB;
+    rd_buf[1]=0xED;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+        dev_info(&ts->client->dev, "i2c read failed!\n");
+        goto exit_downloader;
+    }
+    rd_rom_version = rd_buf[2];
+    rd_buf[0]=0x06;
+    rd_buf[1]=0x94;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+        dev_info(&ts->client->dev, "i2c read failed!\n");
+        goto exit_downloader;
+    }
+    rd_nvram_flag = rd_buf[2];
+
+    fw_version = Little2BigEndian(fw_info->version);
+    fw_start_addr = Little2BigEndian(fw_info->start_addr);
+    fw_length = Little2BigEndian(fw_info->length);	
+    data_ptr = &(fw_info->data);	
+
+    dev_info(&ts->client->dev,"chip_type=0x%02x\n", fw_info->chip_type);
+    dev_info(&ts->client->dev,"version=0x%04x\n", fw_version);
+    dev_info(&ts->client->dev,"rom_version=0x%02x\n",fw_info->rom_version);
+    dev_info(&ts->client->dev,"start_addr=0x%04x\n",fw_start_addr);
+    dev_info(&ts->client->dev,"file_size=0x%04x\n",fw_length);
+    fw_checksum = ((u32)fw_info->checksum[0]<<16) + ((u32)fw_info->checksum[1]<<8) + ((u32)fw_info->checksum[2]);
+    dev_info(&ts->client->dev,"fw_checksum=0x%06x\n",fw_checksum);
+    dev_info(&ts->client->dev,"%s\n", __func__ );
+    dev_info(&ts->client->dev,"current version 0x%04X, target verion 0x%04X\n", ts->version, fw_version );
+
+    //chk_chip_type:
+    if(rd_chip_type!=fw_info->chip_type)
+    {
+        dev_info(&ts->client->dev, "Chip type not match,exit downloader\n");
+        goto exit_downloader;
+    }
+
+    //chk_mask_version:	
+    if(!rd_rom_version)
+    {
+        if(fw_info->rom_version!=0x45)
+        {
+            dev_info(&ts->client->dev, "Rom version not match,exit downloader\n");
+            goto exit_downloader;
+        }
+        dev_info(&ts->client->dev, "Rom version E.\n");
+        goto chk_fw_version;
+    }
+    else if(rd_rom_version!=fw_info->rom_version);
+    {
+        dev_info(&ts->client->dev, "Rom version not match,exidownloader\n");
+        goto exit_downloader;
+    }
+    dev_info(&ts->client->dev, "Rom version %c\n",rd_rom_version);
+
+    //chk_nvram:	
+    if(rd_nvram_flag==0x55)
+    {
+        dev_info(&ts->client->dev, "NVRAM correct!\n");
+        goto chk_fw_version;
+    }
+    else if(rd_nvram_flag==0xAA)
+    {
+        dev_info(&ts->client->dev, "NVRAM incorrect!Need update.\n");
+        goto begin_upgrade;
+    }
+    else
+    {
+        dev_info(&ts->client->dev, "NVRAM other error![0x694]=0x%02x\n", rd_nvram_flag);
+        goto begin_upgrade;
+    }
+chk_fw_version:
+    //ts->version -= 1;               //test by andrew        
+    if( ts->version >= fw_version )   // current low byte higher than back-up low byte
+    {
+        dev_info(&ts->client->dev, "Fw verison not match.\n");
+        goto chk_mandatory_upgrade;
+    }
+    dev_info(&ts->client->dev,"Need to upgrade\n");
+    goto begin_upgrade;
+chk_mandatory_upgrade:
+    //ev_info(&ts->client->dev, "%s\n", mandatory_base);
+    //ev_info(&ts->client->dev, "%s\n", fw_info->mandatory_flag);
+    ret = memcmp(mandatory_base, fw_info->mandatory_flag, 6);
+    if(ret)
+    {
+        dev_info(&ts->client->dev,"Not meet mandatory upgrade,exit downloader!ret:%d\n", ret);
+        goto exit_downloader;
+    }
+    dev_info(&ts->client->dev, "Mandatory upgrade!\n");
+begin_upgrade:
+    dev_info(&ts->client->dev, "Begin upgrade!\n");
+    //goto exit_downloader;
+    dev_info(&ts->client->dev,"STEP_0:\n");
+    //gpio_free(INT_PORT);
+    //ret = gpio_request(INT_PORT, "TS_INT");	//Request IO
+    if (ret < 0) 
+    {
+        dev_info(&ts->client->dev,"Failed to request GPIO:%d, ERRNO:%d\n",(int)INT_PORT,ret);
+        err = -1;
+        goto exit_downloader;
+    }
+
+    dev_info(&ts->client->dev, "STEP_1:\n");
+    err = -1;
+    while( retry < 3 ) 
+    {
+        ret = gt811_update_proc( data_ptr,fw_start_addr, fw_length, ts);
+        if(ret == 1)
+        {
+            err = 1;
+            break;
+        }
+        retry++;
+    }
+
+exit_downloader:
+    //mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
+    //mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
+    //gpio_direction_output(INT_PORT,1);
+    //msleep(1);
+    //gpio_free(INT_PORT);
+    //s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+    gpio_set_one_pin_pull(gpio_int_hdle, 0, "ctp_int_port");
+
+    return err;
+
+}
+#endif
+//******************************End of firmware update surpport*******************************
+/////////////////////////////// UPDATE STEP 4 END /////////////////////////////////////////////////////////////////
+
+//??????? ??????ID ??
+//only one client
+static const struct i2c_device_id goodix_ts_id[] = {
+	{ GOODIX_I2C_NAME, 0 },
+	{ }
+};
+
+//???????
+static struct i2c_driver goodix_ts_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe		= goodix_ts_probe,
+	.remove		= goodix_ts_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= goodix_ts_suspend,
+	.resume		= goodix_ts_resume,
+#endif
+	.id_table	= goodix_ts_id,
+	.driver = {
+		.name	= GOODIX_I2C_NAME,
+		.owner = THIS_MODULE,
+	},
+	.address_list	= u_i2c_addr.normal_i2c,
+};
+
+/*******************************************************	
+???
+	??????
+return?
+	??????0??????
+********************************************************/
+static int __devinit goodix_ts_init(void)
+{
+	int ret = -1;
+	int err = -1;
+
+	printk("===========================%s=====================\n", __func__);
+
+	goodix_wq = create_workqueue("goodix_wq");		//create a work queue and worker thread
+	if (!goodix_wq) {
+		printk(KERN_ALERT "creat workqueue faiked\n");
+		return -ENOMEM;
+		
+	}
+
+	if (ctp_ops.fetch_sysconfig_para)
+	{
+		if(ctp_ops.fetch_sysconfig_para()){
+			printk("%s: err.\n", __func__);
+			return -1;
+		}
+	}
+	printk("%s: after fetch_sysconfig_para:  normal_i2c: 0x%hx. normal_i2c[1]: 0x%hx \n", \
+	__func__, u_i2c_addr.normal_i2c[0], u_i2c_addr.normal_i2c[1]);
+
+	err = ctp_ops.init_platform_resource();
+	if(0 != err){
+		printk("%s:ctp_ops.init_platform_resource err. \n", __func__);    
+	}
+
+	
+    //reset
+    //ctp_ops.ts_reset();
+    //wakeup
+    //ctp_ops.ts_wakeup();
+	
+	goodix_ts_driver.detect = ctp_ops.ts_detect;
+       
+	ret = i2c_add_driver(&goodix_ts_driver);
+
+	return ret;
+
+}
+
+/*******************************************************	
+???
+	??????
+???
+	client??????
+********************************************************/
+static void __exit goodix_ts_exit(void)
+{
+	printk(KERN_ALERT "Touchscreen driver of guitar exited.\n");
+	i2c_del_driver(&goodix_ts_driver);
+	if (goodix_wq)
+		destroy_workqueue(goodix_wq);		//release our work queue
+}
+
+late_initcall(goodix_ts_init);				//???????felix
+module_exit(goodix_ts_exit);
+
+MODULE_DESCRIPTION("Goodix Touchscreen Driver");
+MODULE_LICENSE("GPL");
+               
diff --git a/drivers/input/touchscreen/gt811_ts.h b/drivers/input/touchscreen/gt811_ts.h
new file mode 100644
index 0000000..6917364
--- /dev/null
+++ b/drivers/input/touchscreen/gt811_ts.h
@@ -0,0 +1,271 @@
+/* drivers/input/touchscreen/gt811.h
+ *
+ * Copyright (C) 2010 - 2011 Goodix, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *Any problem,please contact andrew@goodix.com,+86 755-33338828
+ *
+ */
+
+#ifndef 	_LINUX_GT811_H
+#define		_LINUX_GT811_H
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+
+//*************************TouchScreen Work Part*****************************
+#define GOODIX_I2C_NAME "Goodix-TS"
+#define GT801_PLUS
+#define GT801_NUVOTON
+#define GUITAR_UPDATE_STATE 0x02
+
+//define resolution of the touchscreen
+#define TOUCH_MAX_HEIGHT 	4096			
+#define TOUCH_MAX_WIDTH		4096
+
+
+#define PHO_CFG2_OFFSET              (0X104)
+#define PHO_DAT_OFFSET              (0X10C)
+#define PHO_PULL1_OFFSET             (0X11C)
+
+//#define STOP_IRQ_TYPE                     // if define then   no stop irq in irq_handle   kuuga add 1202S
+#define REFRESH 0     //0~0x64   Scan rate = 10000/(100+REFRESH)//define resolution of the LCD
+
+//#define SHUTDOWN_PORT 	    S3C64XX_GPL(10)
+//#define INT_PORT 	          S3C64XX_GPN(15)
+#define INT_PORT                     (SW_INT_IRQNO_PIO)
+//#ifdef INT_PORT
+//	#define TS_INT 		        gpio_to_irq(INT_PORT)			//Interrupt Number,EINT18(119)
+//	#define INT_CFG    	      S3C_GPIO_SFN(3) 					//IO configer as EINT
+//#else
+//	#define TS_INT	0
+//#endif	
+
+/////////////////////////////// UPDATE STEP 5 START /////////////////////////////////////////////////////////////////
+#define TPD_CHIP_VERSION_C_FIRMWARE_BASE 0x5A
+#define TPD_CHIP_VERSION_D1_FIRMWARE_BASE 0x7A
+#define TPD_CHIP_VERSION_E_FIRMWARE_BASE 0x9A
+#define TPD_CHIP_VERSION_D2_FIRMWARE_BASE 0xBA
+
+
+/////////////////////////////// UPDATE STEP 5 END /////////////////////////////////////////////////////////////////
+
+#define FLAG_UP		0
+#define FLAG_DOWN		1
+//set GT801 PLUS trigger mode,????0?1 
+//#define INT_TRIGGER		1	   // 1=rising 0=falling
+#define POLL_TIME		10	//actual query spacing interval:POLL_TIME+6
+
+#define GOODIX_MULTI_TOUCH
+#ifdef GOODIX_MULTI_TOUCH
+	#define MAX_FINGER_NUM	5	
+#else
+	#define MAX_FINGER_NUM	1	
+#endif
+
+#if defined(INT_PORT)
+	#if MAX_FINGER_NUM <= 3
+	#define READ_BYTES_NUM 2+2+MAX_FINGER_NUM*5
+	#elif MAX_FINGER_NUM == 4
+	#define READ_BYTES_NUM 2+28
+	#elif MAX_FINGER_NUM == 5
+	#define READ_BYTES_NUM 2+34
+	#endif
+#else	
+	#define READ_BYTES_NUM 2+34
+#endif
+
+//#define swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
+
+#define READ_TOUCH_ADDR_H 0x07
+#define READ_TOUCH_ADDR_L 0x21				//GT811 0x721
+#define READ_KEY_ADDR_H 0x07
+#define READ_KEY_ADDR_L 0x21
+#define READ_COOR_ADDR_H 0x07
+#define READ_COOR_ADDR_L 0x22
+#define READ_ID_ADDR_H 0x00
+#define READ_ID_ADDR_L 0xff
+//****************************??????******************************************
+
+//******************************************************************************
+struct goodix_ts_data {
+	uint16_t addr;
+	uint8_t bad_data;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int use_reset;		//use RESET flag
+	int use_irq;		//use EINT flag
+	int read_mode;		//read moudle mode,20110221 by andrew
+	struct hrtimer timer;
+	struct work_struct  work;
+	char phys[32];
+	int retry;
+	int irq;
+	spinlock_t				irq_lock;      //add by kuuga
+	int 				 irq_is_disable; /* 0: irq enable */ //add by kuuga
+	uint16_t abs_x_max;
+	uint16_t abs_y_max;
+	uint8_t max_touch_num;
+	uint8_t int_trigger_type;
+	uint8_t btn_state;                    // key states
+/////////////////////////////// UPDATE STEP 6 START /////////////////////////////////////////////////////////////////
+       unsigned int version;
+/////////////////////////////// UPDATE STEP 6 END /////////////////////////////////////////////////////////////////
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+	int (*power)(struct goodix_ts_data * ts, int on);
+};
+
+//*****************************End of Part I *********************************
+
+//*************************Touchkey Surpport Part*****************************
+#define HAVE_TOUCH_KEY
+//#define READ_KEY_VALUE
+//#define READ_KEY_COOR
+
+#ifdef HAVE_TOUCH_KEY
+	const uint16_t touch_key_array[]={
+									  KEY_MENU,				//MENU
+									  KEY_HOME,
+									  KEY_BACK,				
+									  KEY_SEARCH		
+									 }; 
+	#define MAX_KEY_NUM	 (sizeof(touch_key_array)/sizeof(touch_key_array[0]))
+#endif
+
+//#define COOR_TO_KEY
+    #ifdef COOR_TO_KEY
+
+    #define KEY_X       40
+    #define KEY_Y       20
+    #if 0
+    #define AREA_X      0
+    #else
+    #define AREA_Y      800
+    #endif
+
+    enum {x, y};
+    s32 key_center[MAX_KEY_NUM][2] = {
+		
+	{48,840},{124,840},{208,840},{282,840}
+	
+                           };
+
+    #endif 
+
+//*****************************End of Part II*********************************
+
+/////////////////////////////// UPDATE STEP 7 START /////////////////////////////////////////////////////////////////
+//*************************Firmware Update part*******************************
+//#define AUTO_UPDATE_GT811
+//#define CONFIG_TOUCHSCREEN_GOODIX_IAP        
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+static int goodix_update_write(struct file *filp, const char __user *buff, unsigned long len, void *data);
+static int goodix_update_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+
+#define PACK_SIZE 					64					//update file package size
+//#define MAX_TIMEOUT					30000				//update time out conut
+//#define MAX_I2C_RETRIES				10					//i2c retry times
+
+//write cmd
+#define APK_UPDATE_TP               1
+#define APK_READ_FUN                 10
+#define APK_WRITE_CFG               11
+
+//fun cmd
+//#define CMD_DISABLE_TP             0
+//#define CMD_ENABLE_TP              1
+#define CMD_READ_VER               2
+#define CMD_READ_RAW               3
+#define CMD_READ_DIF               4
+#define CMD_READ_CFG               5
+#define CMD_READ_CHIP_TYPE         6
+//#define CMD_SYS_REBOOT             101
+
+//read mode
+#define MODE_RD_VER                1
+#define MODE_RD_RAW                2
+#define MODE_RD_DIF                3
+#define MODE_RD_CFG                4
+#define MODE_RD_CHIP_TYPE          5
+
+#if 0
+struct tpd_firmware_info_t
+{
+    int magic_number_1;
+    int magic_number_2;
+    unsigned short version;
+    unsigned short length;    
+    unsigned short checksum;
+    unsigned char data;
+};
+#else
+#pragma pack(1)
+struct tpd_firmware_info_t
+{
+	unsigned char  chip_type;
+	unsigned short version;
+	unsigned char  rom_version;
+	unsigned char  reserved[3];
+	unsigned short start_addr;
+	unsigned short length;
+	unsigned char  checksum[3];
+	unsigned char  mandatory_flag[6];
+	unsigned char  data;	
+};
+#pragma pack()
+#endif
+
+#define  NVRAM_LEN               0x0FF0   //	nvram total space
+#define  NVRAM_BOOT_SECTOR_LEN	 0x0100	// boot sector 
+#define  NVRAM_UPDATE_START_ADDR 0x4100
+
+#define  BIT_NVRAM_STROE	    0
+#define  BIT_NVRAM_RECALL	    1
+#define BIT_NVRAM_LOCK 2
+#define  REG_NVRCS_H 0X12
+#define  REG_NVRCS_L 0X01
+#define GT811_SET_INT_PIN( level )	{gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");gpio_write_one_pin_value(gpio_int_hdle,level , "ctp_int_port");} //gpio_direction_output(INT_PORT, level) //null macro now
+#endif
+//*****************************End of Part III********************************
+/////////////////////////////// UPDATE STEP 7 END /////////////////////////////////////////////////////////////////
+
+struct goodix_i2c_rmi_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+	//reservation
+};
+
+#define RAW_DATA_READY          1
+#define RAW_DATA_NON_ACTIVE     0xffffffff
+#define RAW_DATA_ACTIVE         0
+
+
+enum CHIP_TYPE
+{
+    GT800 = 1,
+    GT800PLUS,
+    GT800PLUS3,
+    GT816,
+    GT811,
+    GT8105,
+    GT8110,
+    GT818PLUS
+};
+
+
+#endif /* _LINUX_GOODIX_TOUCH_H */
diff --git a/drivers/input/touchscreen/gt818_ts.c b/drivers/input/touchscreen/gt818_ts.c
new file mode 100644
index 0000000..77f21f0
--- /dev/null
+++ b/drivers/input/touchscreen/gt818_ts.c
@@ -0,0 +1,2693 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <asm/io.h>
+#include <linux/platform_device.h>
+//#include <mach/gpio.h>
+#include <linux/irq.h>
+#include <linux/irq.h>
+#include <asm/irq.h>
+#include <linux/syscalls.h>
+#include <linux/reboot.h>
+#include <linux/proc_fs.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <mach/irqs.h>
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    #include <linux/pm.h>
+    #include <linux/earlysuspend.h>
+#endif
+
+#include "gt818_ts.h"
+#include "gt818_update.h"
+#include "ctp_platform_ops.h"
+
+#define FOR_TSLIB_TEST
+//#define PRINT_INT_INFO
+//#define PRINT_POINT_INFO
+#define PRINT_SUSPEND_INFO
+#define TEST_I2C_TRANSFER
+//#define DEBUG
+
+static int reg_val;
+const char *f3x_ts_name="gt818_ts";
+static struct workqueue_struct *goodix_wq;
+
+
+struct i2c_client * i2c_connect_client = NULL;
+static struct proc_dir_entry *goodix_proc_entry;
+static short  goodix_read_version(struct goodix_ts_data *ts);
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h);
+static void goodix_ts_late_resume(struct early_suspend *h);
+#endif
+
+int  gt818_downloader( struct goodix_ts_data *ts, unsigned char * data,unsigned char * path );
+unsigned int oldcrc32 = 0xFFFFFFFF;
+unsigned int crc32_table[256];
+unsigned int ulPolynomial = 0x04c11db7;
+unsigned int raw_data_ready = RAW_DATA_NON_ACTIVE;
+
+#ifdef DEBUG
+int sum = 0;
+int access_count = 0;
+int int_count = 0;
+#endif
+
+///////////////////////////////////////////////
+//specific tp related macro: need be configured for specific tp
+#define CTP_IRQ_NO			(gpio_int_info[0].port_num)
+
+#define CTP_IRQ_MODE			(POSITIVE_EDGE)
+#define CTP_NAME			GOODIX_I2C_NAME
+#define TS_RESET_LOW_PERIOD		(15)
+#define TS_INITIAL_HIGH_PERIOD		(15)
+#define TS_WAKEUP_LOW_PERIOD	(100)
+#define TS_WAKEUP_HIGH_PERIOD	(100)
+#define TS_POLL_DELAY			(10)	/* ms delay between samples */
+#define TS_POLL_PERIOD			(10)	/* ms delay between samples */
+#define SCREEN_MAX_HEIGHT		(screen_max_x)
+#define SCREEN_MAX_WIDTH		(screen_max_y)
+#define PRESS_MAX			(255)
+
+static void* __iomem gpio_addr = NULL;
+static int gpio_int_hdle = 0;
+static int gpio_wakeup_hdle = 0;
+static int gpio_reset_hdle = 0;
+static int gpio_wakeup_enable = 1;
+static int gpio_reset_enable = 1;
+static user_gpio_set_t  gpio_int_info[1];
+
+static int screen_max_x = 0;
+static int screen_max_y = 0;
+static int revert_x_flag = 0;
+static int revert_y_flag = 0;
+static int exchange_x_y_flag = 0;
+static __u32 twi_addr = 0;
+static __u32 twi_id = 0;
+static int	int_cfg_addr[]={PIO_INT_CFG0_OFFSET,PIO_INT_CFG1_OFFSET,
+			PIO_INT_CFG2_OFFSET, PIO_INT_CFG3_OFFSET};
+
+
+/* Addresses to scan */
+union{
+	unsigned short dirty_addr_buf[2];
+	const unsigned short normal_i2c[2];
+}u_i2c_addr = {{0x00},};
+
+#ifdef PRINT_POINT_INFO
+#define print_point_info(fmt, args...)   \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_point_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_INT_INFO
+#define print_int_info(fmt, args...)     \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_int_info(fmt, args...)   //
+#endif
+
+/*
+ * ctp_get_pendown_state  : get the int_line data state,
+ *
+ * return value:
+ *             return PRESS_DOWN: if down
+ *             return FREE_UP: if up,
+ *             return 0: do not need process, equal free up.
+ */
+static int ctp_get_pendown_state(void)
+{
+	unsigned int reg_val;
+	static int state = FREE_UP;
+
+	//get the input port state
+	reg_val = readl(gpio_addr + PIOH_DATA);
+	//printk("reg_val = %x\n",reg_val);
+	if(!(reg_val & (1<<CTP_IRQ_NO))){
+		state = PRESS_DOWN;
+		print_int_info("pen down. \n");
+	}else{ //touch panel is free up
+		state = FREE_UP;
+		print_int_info("free up. \n");
+	}
+	return state;
+}
+
+/**
+ * ctp_clear_penirq - clear int pending
+ *
+ */
+static void ctp_clear_penirq(void)
+{
+	int reg_val;
+	//clear the IRQ_EINT29 interrupt pending
+	//printk("clear pend irq pending\n");
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val&(1<<(CTP_IRQ_NO)),gpio_addr + PIO_INT_STAT_OFFSET);
+	if((reg_val = (reg_val&(1<<(CTP_IRQ_NO))))){
+		print_int_info("%s: %d. ==CTP_IRQ_NO=\n", __func__, __LINE__);
+		writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+	}
+	return;
+}
+
+/**
+ * ctp_set_irq_mode - according sysconfig's subkey "ctp_int_port" to config int port.
+ *
+ * return value:
+ *              0:      success;
+ *              others: fail;
+ */
+static int ctp_set_irq_mode(char *major_key , char *subkey, ext_int_mode int_mode)
+{
+	int ret = 0;
+	__u32 reg_num = 0;
+	__u32 reg_addr = 0;
+	__u32 reg_val = 0;
+	//config gpio to int mode
+	pr_info("%s: config gpio to int mode. \n", __func__);
+#ifndef SYSCONFIG_GPIO_ENABLE
+#else
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	gpio_int_hdle = gpio_request_ex(major_key, subkey);
+	if(!gpio_int_hdle){
+		pr_info("request tp_int_port failed. \n");
+		ret = -1;
+		goto request_tp_int_port_failed;
+	}
+	gpio_get_one_pin_status(gpio_int_hdle, gpio_int_info, subkey, 1);
+	pr_info("%s, %d: gpio_int_info, port = %d, port_num = %d. \n", __func__, __LINE__, \
+		gpio_int_info[0].port, gpio_int_info[0].port_num);
+#endif
+
+#ifdef AW_GPIO_INT_API_ENABLE
+#else
+	pr_info(" INTERRUPT CONFIG\n");
+	reg_num = (gpio_int_info[0].port_num)%8;
+	reg_addr = (gpio_int_info[0].port_num)/8;
+	reg_val = readl(gpio_addr + int_cfg_addr[reg_addr]);
+	reg_val &= (~(7 << (reg_num * 4)));
+	reg_val |= (int_mode << (reg_num * 4));
+	writel(reg_val,gpio_addr+int_cfg_addr[reg_addr]);
+
+	ctp_clear_penirq();
+
+	reg_val = readl(gpio_addr+PIO_INT_CTRL_OFFSET);
+	reg_val |= (1 << (gpio_int_info[0].port_num));
+	writel(reg_val,gpio_addr+PIO_INT_CTRL_OFFSET);
+
+	udelay(1);
+#endif
+
+request_tp_int_port_failed:
+	return ret;
+}
+
+/**
+ * ctp_set_gpio_mode - according sysconfig's subkey "ctp_io_port" to config io port.
+ *
+ * return value:
+ *              0:      success;
+ *              others: fail;
+ */
+static int ctp_set_gpio_mode(void)
+{
+	//int reg_val;
+	int ret = 0;
+	//config gpio to io mode
+	printk("%s: config gpio to io mode. \n", __func__);
+#ifndef SYSCONFIG_GPIO_ENABLE
+#else
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+	gpio_int_hdle = gpio_request_ex("ctp_para", "ctp_io_port");
+	if(!gpio_int_hdle){
+		printk("request ctp_io_port failed. \n");
+		ret = -1;
+		goto request_tp_io_port_failed;
+	}
+#endif
+	return ret;
+
+request_tp_io_port_failed:
+	return ret;
+}
+
+/**
+ * ctp_judge_int_occur - whether interrupt occur.
+ *
+ * return value:
+ *              0:      int occur;
+ *              others: no int occur;
+ */
+static int ctp_judge_int_occur(void)
+{
+	//int reg_val[3];
+	int reg_val;
+	int ret = -1;
+
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	if(reg_val&(1<<(CTP_IRQ_NO))){
+		ret = 0;
+	}
+	return ret;
+}
+
+/**
+ * ctp_free_platform_resource - corresponding with ctp_init_platform_resource
+ *
+ */
+static void ctp_free_platform_resource(void)
+{
+	printk("=======%s=========.\n", __func__);
+	if(gpio_addr){
+		iounmap(gpio_addr);
+	}
+
+	if(gpio_int_hdle){
+		gpio_release(gpio_int_hdle, 2);
+	}
+
+	if(gpio_wakeup_hdle){
+		gpio_release(gpio_wakeup_hdle, 2);
+	}
+
+	if(gpio_reset_hdle){
+		gpio_release(gpio_reset_hdle, 2);
+	}
+
+	return;
+}
+
+
+/**
+ * ctp_init_platform_resource - initialize platform related resource
+ * return value: 0 : success
+ *               -EIO :  i/o err.
+ *
+ */
+static int ctp_init_platform_resource(void)
+{
+	int ret = 0;
+
+	gpio_addr = ioremap(PIO_BASE_ADDRESS, PIO_RANGE_SIZE);
+	//printk("%s, gpio_addr = 0x%x. \n", __func__, gpio_addr);
+	if(!gpio_addr) {
+		ret = -EIO;
+		goto exit_ioremap_failed;
+	}
+	//    gpio_wakeup_enable = 1;
+	gpio_wakeup_hdle = gpio_request_ex("ctp_para", "ctp_wakeup");
+	if(!gpio_wakeup_hdle) {
+		pr_warning("%s: tp_wakeup request gpio fail!\n", __func__);
+		gpio_wakeup_enable = 0;
+	}
+
+	gpio_reset_hdle = gpio_request_ex("ctp_para", "ctp_reset");
+	if(!gpio_reset_hdle) {
+		pr_warning("%s: tp_reset request gpio fail!\n", __func__);
+		gpio_reset_enable = 0;
+	}
+
+	return ret;
+
+exit_ioremap_failed:
+	ctp_free_platform_resource();
+	return ret;
+}
+
+
+/**
+ * ctp_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int ctp_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int ctp_used = -1;
+	char name[I2C_NAME_SIZE];
+	script_parser_value_type_t type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+
+	printk("%s. \n", __func__);
+	memset(name, 0, I2C_NAME_SIZE);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_used", &ctp_used, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	if(1 != ctp_used){
+		pr_err("%s: ctp_unused. \n",  __func__);
+		//ret = 1;
+		return ret;
+	}
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch_ex("ctp_para", "ctp_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	if(strcmp(CTP_NAME, name)){
+		pr_err("%s: name %s does not match CTP_NAME. \n", __func__, name);
+		pr_err(CTP_NAME);
+		//ret = 1;
+		return ret;
+	}
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_twi_addr", &twi_addr, sizeof(twi_addr)/sizeof(__u32))){
+		pr_err("%s: script_parser_fetch err. \n", name);
+		goto script_parser_fetch_err;
+	}
+	//big-endian or small-endian?
+	//printk("%s: before: ctp_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+	u_i2c_addr.dirty_addr_buf[0] = twi_addr;
+	u_i2c_addr.dirty_addr_buf[1] = I2C_CLIENT_END;
+	printk("%s: after: ctp_twi_addr is 0x%x, dirty_addr_buf: 0x%hx. dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u_i2c_addr.dirty_addr_buf[0], u_i2c_addr.dirty_addr_buf[1]);
+	//printk("%s: after: ctp_twi_addr is 0x%x, u32_dirty_addr_buf: 0x%hx. u32_dirty_addr_buf[1]: 0x%hx \n", __func__, twi_addr, u32_dirty_addr_buf[0],u32_dirty_addr_buf[1]);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_twi_id", &twi_id, sizeof(twi_id)/sizeof(__u32))){
+		pr_err("%s: script_parser_fetch err. \n", name);
+		goto script_parser_fetch_err;
+	}
+	printk("%s: ctp_twi_id is %d. \n", __func__, twi_id);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_x", &screen_max_x, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: screen_max_x = %d. \n", __func__, screen_max_x);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_y", &screen_max_y, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: screen_max_y = %d. \n", __func__, screen_max_y);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_x_flag", &revert_x_flag, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: revert_x_flag = %d. \n", __func__, revert_x_flag);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_y_flag", &revert_y_flag, 1)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: revert_y_flag = %d. \n", __func__, revert_y_flag);
+
+	if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_exchange_x_y_flag", &exchange_x_y_flag, 1)){
+		pr_err("ft5x_ts: script_parser_fetch err. \n");
+		goto script_parser_fetch_err;
+	}
+	pr_info("%s: exchange_x_y_flag = %d. \n", __func__, exchange_x_y_flag);
+
+	return 0;
+
+script_parser_fetch_err:
+	pr_notice("=========script_parser_fetch_err============\n");
+	return ret;
+}
+
+/**
+ * ctp_reset - function
+ *
+ */
+static void ctp_reset(void)
+{
+	printk("%s. \n", __func__);
+	if(gpio_reset_enable){
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 0, "ctp_reset")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_RESET_LOW_PERIOD);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 1, "ctp_reset")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_INITIAL_HIGH_PERIOD);
+	}
+}
+
+/**
+ * ctp_wakeup - function
+ *
+ */
+static void ctp_wakeup(void)
+{
+	printk("%s. \n", __func__);
+	if(1 == gpio_wakeup_enable){
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 1, "ctp_wakeup")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_WAKEUP_LOW_PERIOD);
+		if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup")){
+			printk("%s: err when operate gpio. \n", __func__);
+		}
+		mdelay(TS_WAKEUP_HIGH_PERIOD);
+
+	}
+	return;
+}
+/**
+ * ctp_detect - Device detection callback for automatic device creation
+ * return value:
+ *                    = 0; success;
+ *                    < 0; err
+ */
+int ctp_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if(twi_id == adapter->nr)
+	{
+		pr_info("%s: Detected chip %s at adapter %d, address 0x%02x\n",
+			 __func__, CTP_NAME, i2c_adapter_id(adapter), client->addr);
+
+		strlcpy(info->type, CTP_NAME, I2C_NAME_SIZE);
+		return 0;
+	}else{
+		return -ENODEV;
+	}
+}
+////////////////////////////////////////////////////////////////
+
+static struct ctp_platform_ops ctp_ops = {
+	.get_pendown_state = ctp_get_pendown_state,
+	.clear_penirq	   = ctp_clear_penirq,
+	.set_irq_mode      = ctp_set_irq_mode,
+	.set_gpio_mode     = ctp_set_gpio_mode,
+	.judge_int_occur   = ctp_judge_int_occur,
+	.init_platform_resource = ctp_init_platform_resource,
+	.free_platform_resource = ctp_free_platform_resource,
+	.fetch_sysconfig_para = ctp_fetch_sysconfig_para,
+	.ts_reset =          ctp_reset,
+	.ts_wakeup =         ctp_wakeup,
+	.ts_detect = ctp_detect,
+};
+
+/*Function as i2c_master_send */
+static int i2c_read_bytes(struct i2c_client *client, uint8_t *buf, int len)
+{
+	struct i2c_msg msgs[2];
+	int ret=-1;
+	//
+	msgs[0].flags=!I2C_M_RD; //
+	msgs[0].addr=client->addr;
+	msgs[0].len=2;
+	msgs[0].buf=&buf[0];
+	//
+	msgs[1].flags=I2C_M_RD;//
+	msgs[1].addr=client->addr;
+	msgs[1].len=len-2;
+	msgs[1].buf=&buf[2];
+
+	ret=i2c_transfer(client->adapter,msgs, 2);
+	return ret;
+}
+
+/*******************************************************
+
+*******************************************************/
+/*Function as i2c_master_send */
+static int i2c_write_bytes(struct i2c_client *client,uint8_t *data,int len)
+{
+	struct i2c_msg msg;
+	int ret=-1;
+	//
+	msg.flags=!I2C_M_RD;//
+	msg.addr=client->addr;
+	msg.len=len;
+	msg.buf=data;
+
+	ret=i2c_transfer(client->adapter,&msg, 1);
+	return ret;
+}
+
+/*******************************************************
+
+*******************************************************/
+static int i2c_pre_cmd(struct goodix_ts_data *ts)
+{
+	int ret;
+	uint8_t pre_cmd_data[2]={0};
+	pre_cmd_data[0]=0x0f;
+	pre_cmd_data[1]=0xff;
+	ret=i2c_write_bytes(ts->client,pre_cmd_data,2);
+//	msleep(2);
+	return ret;
+}
+
+/*******************************************************
+
+*******************************************************/
+static int i2c_end_cmd(struct goodix_ts_data *ts)
+{
+	int ret;
+	uint8_t end_cmd_data[2]={0};
+	end_cmd_data[0]=0x80;
+	end_cmd_data[1]=0x00;
+	ret=i2c_write_bytes(ts->client,end_cmd_data,2);
+//	msleep(2);
+	return ret;
+}
+
+/*
+
+*/
+static short get_chip_version( unsigned int sw_ver )
+{
+    //pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+    if ( (sw_ver&0xff) < TPD_CHIP_VERSION_C_FIRMWARE_BASE )
+	return TPD_GT818_VERSION_B;
+   else if ( (sw_ver&0xff) < TPD_CHIP_VERSION_D1_FIRMWARE_BASE )
+   	return TPD_GT818_VERSION_C;
+   else if((sw_ver&0xff) < TPD_CHIP_VERSION_E_FIRMWARE_BASE)
+   	return TPD_GT818_VERSION_D1;
+   else if((sw_ver&0xff) < TPD_CHIP_VERSION_D2_FIRMWARE_BASE)
+   	return TPD_GT818_VERSION_E;
+   else
+   	return TPD_GT818_VERSION_D2;
+
+}
+/*******************************************************
+notice: init panel need to be complete within 200ms.
+	so, i2c transfer clk more faster more better
+	     and do not add too much print info when debug.
+*******************************************************/
+static int goodix_init_panel(struct goodix_ts_data *ts)
+{
+	short ret=-1;
+    //int ic_size = 0;
+
+       uint8_t config_info_c[] = {		//Touch key devlop board
+	0x06,0xA2,
+	0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,
+	0x10,0x12,0xE0,0x00,0xD0,0x00,0xC0,0x00,
+	0xB0,0x00,0xA0,0x00,0x90,0x00,0x80,0x00,
+	0x70,0x00,0x00,0x00,0x10,0x00,0x20,0x00,
+	0x30,0x00,0x40,0x00,0x50,0x00,0x60,0x00,
+	0x00,0x00,0x01,0x13,0x80,0x88,0x90,0x14,
+	0x15,0x40,0x0F,0x0F,0x0A,0x50,0x3C,0x0C,
+	0x00,0x00,MAX_FINGER_NUM,(TOUCH_MAX_WIDTH&0xff),(TOUCH_MAX_WIDTH>>8),(TOUCH_MAX_HEIGHT&0xff),(TOUCH_MAX_HEIGHT>>8),0x00,
+	0x00,0x46,0x5A,0x00,0x00,0x00,0x00,0x03,
+	0x19,0x05,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x10,0x00,0x04,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x38,
+	0x00,0x3C,0x28,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x01
+	};
+
+#if 0
+	uint8_t config_info_d[] = {		 //Touch key devlop board
+		0x06,0xA2,
+		0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,
+		0x10,0x12,0x02,0x22,0x12,0x22,0x22,0x22,
+		0x32,0x22,0x42,0x22,0x52,0x22,0x62,0x22,
+		0x72,0x22,0x82,0x22,0x92,0x22,0xA2,0x22,
+		0xB2,0x22,0xC2,0x22,0xD2,0x22,0xE2,0x22,
+		0xF2,0x22,0x0B,0x13,0x68,0x68,0x68,0x19,
+		0x19,0x19,0x0F,0x0F,0x0A,0x35,0x25,0x49,
+		0x03,0x00,0x05,0xE0,0x01,0x20,0x03,0x00,
+		0x00,0x32,0x2C,0x34,0x2E,0x00,0x00,0x05,
+		0x14,0x05,0x07,0x00,0x00,0x00,0x00,0x00,
+		0x14,0x10,0xEC,0x01,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x01
+	};
+#endif
+
+	uint8_t config_info_d[] = {		 //Touch key devlop board
+		0x06,0xA2,
+		0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,
+		0x02,0x00,0x01,0x11,0x11,0x11,0x21,0x11,
+		0x31,0x11,0x41,0x11,0x51,0x11,0x61,0x11,
+		0x71,0x11,0x81,0x11,0x91,0x11,0xA1,0x11,
+		0xB1,0x11,0xC1,0x11,0xD1,0x11,0xE1,0x11,
+		0xF1,0x11,0x0B,0x13,0x50,0x50,0x50,0x23,
+		0x23,0x23,0x0F,0x0F,0x0A,0x40,0x30,0x4D,
+		0x03,0x00,0x05,0xE0,0x01,0x20,0x03,0x00,
+		0x00,0x32,0x2C,0x34,0x2E,0x00,0x00,0x05,
+		0x14,0x05,0x07,0x00,0x00,0x00,0x00,0x00,
+		0x14,0x10,0xEC,0x01,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x01
+	};
+
+#if 0
+       uint8_t config_info_d[] = {		//Touch key devlop board
+	0x06,0xA2,
+	0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,
+	0x10,0x12,0x02,0x22,0x12,0x22,0x22,0x22,
+	0x32,0x22,0x42,0x22,0x52,0x22,0x62,0x22,
+	0x72,0x22,0x82,0x22,0x92,0x22,0xA2,0x22,
+	0xB2,0x22,0xC2,0x22,0xD2,0x22,0xE2,0x22,
+	0xF2,0x22,0x0B,0x13,0x68,0x68,0x68,0x19,
+	0x19,0x19,0x0F,0x0F,0x0A,0x40,0x30,0x49,
+	0x03,0x00,0x05,0xE0,0x01,0x20,0x03,0x00,
+	0x00,0x32,0x2C,0x34,0x2E,0x00,0x00,0x05,
+	0x14,0x05,0x07,0x00,0x00,0x00,0x00,0x00,
+	0x14,0x10,0xEC,0x01,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x01
+
+	};
+#endif
+
+#if 0
+       uint8_t config_info_d[] = {		//Touch key devlop board
+	0x06,0xA2,
+	//20111220
+	0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,
+	0x02,0x00,0xF2,0x22,0xE2,0x22,0xD2,0x22,
+	0xC2,0x22,0xB2,0x22,0xA2,0x22,0x92,0x22,
+	0x82,0x22,0x72,0x22,0x62,0x22,0x52,0x22,
+	0x42,0x22,0x32,0x22,0x22,0x22,0x12,0x22,
+	0x02,0x22,0x0B,0x13,0x68,0x68,0x68,0x19,
+	0x19,0x19,0x0F,0x0F,0x0A,0x40,0x30,0x49,
+	0x03,0x00,0x05,0xE0,0x01,0x20,0x03,0x00,
+	0x00,0x32,0x2C,0x34,0x2E,0x00,0x00,0x05,
+	0x14,0x05,0x07,0x00,0x00,0x00,0x00,0x00,
+	0x14,0x10,0xEC,0x01,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x01
+
+	/*0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,
+	0x10,0x12,0xE0,0x00,0xD0,0x00,0xC0,0x00,
+	0xB0,0x00,0xA0,0x00,0x90,0x00,0x80,0x00,
+	0x70,0x00,0x00,0x00,0x10,0x00,0x20,0x00,
+	0x30,0x00,0x40,0x00,0x50,0x00,0x60,0x00,
+	0x00,0x00,0x01,0x13,0x80,0x88,0x90,0x14,
+	0x15,0x40,0x0F,0x0F,0x0A,0x50,0x3C,0x0C,
+	0x00,0x00,MAX_FINGER_NUM,(TOUCH_MAX_WIDTH&0xff),(TOUCH_MAX_WIDTH>>8),(TOUCH_MAX_HEIGHT&0xff),(TOUCH_MAX_HEIGHT>>8),0x00,
+	0x00,0x46,0x5A,0x00,0x00,0x00,0x00,0x03,
+	0x19,0x05,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x10,0x00,0x04,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x38,
+	0x00,0x3C,0x28,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x01
+	*/
+	};
+
+#endif
+
+//pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+       ret = goodix_read_version(ts);
+       if (ret < 0)
+		return ret;
+
+       dev_info(&ts->client->dev," Guitar Version: %d\n",ts->version);
+
+    //pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+       if((ts->version&0xff) < TPD_CHIP_VERSION_D1_FIRMWARE_BASE)
+       {//pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+            dev_info(&ts->client->dev," Guitar Version: C\n");
+            config_info_c[57] = (config_info_c[57]&0xf7)|(INT_TRIGGER<<3);
+            ret=i2c_write_bytes(ts->client,config_info_c, (sizeof(config_info_c)/sizeof(config_info_c[0])));
+        }
+       else
+       {
+       ////pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+           if((ts->version&0xff) < TPD_CHIP_VERSION_E_FIRMWARE_BASE)
+           		 dev_info(&ts->client->dev," Guitar Version: D1\n");
+           else  if((ts->version&0xff) < TPD_CHIP_VERSION_D2_FIRMWARE_BASE)
+           		 dev_info(&ts->client->dev," Guitar Version: E\n");
+	    else
+           		 dev_info(&ts->client->dev," Guitar Version: D2\n");
+
+            config_info_d[57] = (config_info_d[57]&0xf7)|(INT_TRIGGER<<3);
+            //pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+            msleep(1500);
+            ret=i2c_write_bytes(ts->client,config_info_d, (sizeof(config_info_d)/sizeof(config_info_d[0])));
+        }
+        //pr_info("%s: %s, %d. \n", __FILE__, __func__, __LINE__);
+	if (ret < 0)
+		return ret;
+	msleep(10);
+	return 0;
+
+}
+
+
+/*******************************************************
+
+*******************************************************/
+static short  goodix_read_version(struct goodix_ts_data *ts)
+{
+	short ret;
+	uint8_t version_data[5]={0};	//store touchscreen version infomation
+	memset(version_data, 0, 5);
+	version_data[0]=0x07;
+	version_data[1]=0x17;
+	msleep(5);
+	//   pr_info("%s: %s, %d. \n", __FILE__, __func__, __LINE__);
+	//ret=i2c_read_bytes(ts->client, version_data, 4);
+      //msleep(2);
+      ret=i2c_read_bytes(ts->client, version_data, 4);
+	if (ret < 0)
+		return ret;
+	dev_info(&ts->client->dev," Guitar Version: %d.%d\n",version_data[3],version_data[2]);
+       ts->version = (version_data[3]<<8)+version_data[2];
+	return ret;
+
+}
+
+
+/*******************************************************
+
+********************************************************/
+static void goodix_ts_work_func(struct work_struct *work)
+{
+	uint8_t  touch_data[3] = {READ_TOUCH_ADDR_H,READ_TOUCH_ADDR_L,0};
+	uint8_t  point_data[8*MAX_FINGER_NUM+2]={ 0 };
+	static uint8_t   finger_last[MAX_FINGER_NUM+1]={0};		//
+	uint8_t  finger_current[MAX_FINGER_NUM+1] = {0};		//
+	uint8_t  coor_data[6*MAX_FINGER_NUM] = {0};			//
+
+	uint8_t  finger = 0;
+#ifdef HAVE_TOUCH_KEY
+	uint8_t  key = 0;
+	static uint8_t  last_key = 0;
+	uint8_t  key_data[3] ={READ_KEY_ADDR_H,READ_KEY_ADDR_L,0};
+#endif
+	unsigned int  count = 0;
+	unsigned int position = 0;
+	int ret=-1;
+	int tmp = 0;
+	int temp = 0;
+	uint16_t *coor_point = 0;
+	static int x_corrdinate = 0;
+	static int y_corrdinate = 0;
+
+	struct goodix_ts_data *ts = container_of(work, struct goodix_ts_data, work);
+
+#ifdef DEBUG
+    printk("int count :%d\n", ++int_count);
+    printk("ready?:%d\n", raw_data_ready);
+#endif
+    if (RAW_DATA_ACTIVE == raw_data_ready)
+	{
+	    raw_data_ready = RAW_DATA_READY;
+#ifdef DEBUG
+	    printk("ready!\n");
+#endif
+	   // if(ts->use_irq)
+	//	    enable_irq(ts->client->irq);
+	 //   return;
+	}
+
+
+	i2c_pre_cmd(ts);
+#ifndef INT_PORT
+COORDINATE_POLL:
+#endif
+	if( tmp > 9) {
+		dev_info(&(ts->client->dev), "Because of transfer error,touchscreen stop working.\n");
+		goto XFER_ERROR ;
+	}
+
+	ret=i2c_read_bytes(ts->client, touch_data,sizeof(touch_data)/sizeof(touch_data[0]));  //
+	if(ret <= 0) {
+		dev_err(&(ts->client->dev),"I2C transfer error. Number:%d ,%s--%d\n", ret,__func__,__LINE__);
+		ts->bad_data = 1;
+		tmp ++;
+		ts->retry++;
+	#ifndef INT_PORT
+		goto COORDINATE_POLL;
+	#else
+		goto XFER_ERROR;
+	#endif
+	}
+
+#ifdef HAVE_TOUCH_KEY
+	ret=i2c_read_bytes(ts->client, key_data,sizeof(key_data)/sizeof(key_data[0]));  //
+	if(ret <= 0) {
+		dev_err(&(ts->client->dev),"I2C transfer error. Number:%d,%s--%d\n", ret,__func__,__LINE__);
+		ts->bad_data = 1;
+		tmp ++;
+		ts->retry++;
+	#ifndef INT_PORT
+		goto COORDINATE_POLL;
+	#else
+		goto XFER_ERROR;
+	#endif
+	}
+	key = key_data[2]&0x0f;
+#endif
+
+	if(ts->bad_data)
+		//TODO:Is sending config once again (to reset the chip) useful?
+		msleep(20);
+
+	if(touch_data[2] == 0x0f)
+       {
+       //pr_info("%s: %s, %d. \n", __FILE__, __func__, __LINE__);
+            goodix_init_panel(ts);
+            goto DATA_NO_READY;
+        }
+
+	if((touch_data[2]&0x30)!=0x20)
+	{
+		goto DATA_NO_READY;
+	}
+
+	ts->bad_data = 0;
+
+	finger = touch_data[2]&0x0f;
+	if(finger != 0)
+	{
+		point_data[0] = READ_COOR_ADDR_H;		//read coor high address
+		point_data[1] = READ_COOR_ADDR_L;		//read coor low address
+		ret=i2c_read_bytes(ts->client, point_data, finger*8+2);
+		if(ret <= 0)
+		{
+			dev_err(&(ts->client->dev),"I2C transfer error. Number:%d,%s--%d\n", ret,__func__,__LINE__);
+			ts->bad_data = 1;
+			tmp ++;
+			ts->retry++;
+		#ifndef INT_PORT
+			goto COORDINATE_POLL;
+		#else
+			goto XFER_ERROR;
+		#endif
+		}
+
+		for(position=2; position<((finger-1)*8+2+1); position += 8)
+		{
+			temp = point_data[position];
+			if(temp<(MAX_FINGER_NUM+1))
+			{
+				finger_current[temp] = 1;
+				for(count=0; count<6; count++)
+				{
+					coor_data[(temp-1)*6+count] = point_data[position+1+count];	//
+				}
+			}
+			else
+			{
+				dev_err(&(ts->client->dev), "Track Id error:%d\n ", temp);
+				ts->bad_data = 1;
+				tmp ++;
+				ts->retry++;
+				#ifndef INT_PORT
+					goto COORDINATE_POLL;
+				#else
+					goto XFER_ERROR;
+				#endif
+			}
+		}
+		//coor_point = (uint16_t *)coor_data;
+
+	}
+
+	else
+	{
+		for(position=1;position < MAX_FINGER_NUM+1; position++)
+		{
+			finger_current[position] = 0;
+		}
+	}
+	coor_point = (uint16_t *)coor_data;
+	for(position=1;position < MAX_FINGER_NUM+1; position++)
+	{
+		if((finger_current[position] == 0)&&(finger_last[position] != 0))
+			{
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, 0);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, 0);
+				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+	//			input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+				input_mt_sync(ts->input_dev);
+			}
+		else if(finger_current[position])
+			{
+				x_corrdinate = *(coor_point+3*(position-1)+1);
+				y_corrdinate = *(coor_point+3*(position-1));
+				if(revert_x_flag){
+					x_corrdinate = screen_max_x - x_corrdinate;
+				}
+
+				if(revert_y_flag){
+					y_corrdinate = screen_max_y - y_corrdinate;
+				}
+
+				if(exchange_x_y_flag){
+					swap(x_corrdinate, y_corrdinate);
+				}
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x_corrdinate);  //can change x-y!!!
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y_corrdinate);
+
+				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,1);
+				//input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, finger_list.pointer[0].pressure);
+				input_mt_sync(ts->input_dev);
+			//	input_report_abs(ts->input_dev, ABS_X, finger_list.pointer[0].x);
+			//	input_report_abs(ts->input_dev, ABS_Y, finger_list.pointer[0].y)
+			//	input_report_abs(ts->input_dev, ABS_PRESSURE, finger_list.pointer[0].pressure);
+			//	input_sync(ts->input_dev);
+			//	printk("%d*",(*(coor_point+3*(position-1)))*SCREEN_MAX_HEIGHT/(TOUCH_MAX_HEIGHT));
+			//	printk("%d*",(*(coor_point+3*(position-1)+1))*SCREEN_MAX_WIDTH/(TOUCH_MAX_WIDTH));
+			//	printk("\n");
+			}
+
+	}
+	input_sync(ts->input_dev);
+
+	for(position=1;position<MAX_FINGER_NUM+1; position++)
+	{
+		finger_last[position] = finger_current[position];
+	}
+
+#ifdef HAVE_TOUCH_KEY
+	if((last_key == 0)&&(key == 0))
+		;
+	else
+	{
+		for(count = 0; count < 4; count++)
+		{
+			input_report_key(ts->input_dev, touch_key_array[count], !!(key&(0x01<<count)));
+		}
+	}
+	last_key = key;
+#endif
+
+DATA_NO_READY:
+XFER_ERROR:
+	i2c_end_cmd(ts);
+	if(ts->use_irq){
+//	    enable_irq(ts->client->irq);
+        reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        reg_val |=(1<<CTP_IRQ_NO);
+        writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+	}
+}
+
+/*******************************************************
+
+********************************************************/
+static enum hrtimer_restart goodix_ts_timer_func(struct hrtimer *timer)
+{
+	struct goodix_ts_data *ts = container_of(timer, struct goodix_ts_data, timer);
+	queue_work(goodix_wq, &ts->work);
+	hrtimer_start(&ts->timer, ktime_set(0, (POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+/*******************************************************
+
+********************************************************/
+static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
+{
+	struct goodix_ts_data *ts = dev_id;
+
+	//printk(KERN_INFO"-------------------ts_irq_handler------------------\n");
+	//disable_irq_nosync(ts->client->irq);
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+
+	if(reg_val&(1<<(CTP_IRQ_NO)))
+	{
+		print_int_info("%s: %d. ==CTP_IRQ_NO=\n", __func__, __LINE__);
+		//clear the CTP_IRQ_NO interrupt pending
+		writel(reg_val&(1<<(CTP_IRQ_NO)),gpio_addr + PIO_INT_STAT_OFFSET);
+		queue_work(goodix_wq, &ts->work);
+	}
+	else
+	{
+	    print_int_info("Other Interrupt\n");
+	    return IRQ_NONE;
+	}
+
+
+	return IRQ_HANDLED;
+}
+
+/*******************************************************
+
+********************************************************/
+//#if defined(INT_PORT)
+static int goodix_ts_power(struct goodix_ts_data * ts, int on)
+{
+	int ret = -1;
+
+	unsigned char i2c_control_buf[3] = {0x06,0x92,0x01};		//suspend cmd
+#if 0
+//#ifdef INT_PORT
+	if(ts != NULL && !ts->use_irq)
+		return -2;
+#endif
+	switch(on)
+	{
+		case 0:
+			i2c_pre_cmd(ts);               //must
+			ret = i2c_write_bytes(ts->client, i2c_control_buf, 3);
+//			printk(KERN_INFO"Send suspend cmd\n");
+			if(ret > 0)						//failed
+				ret = 0;
+			i2c_end_cmd(ts);                     //must
+			return ret;
+
+		case 1:
+
+			#ifdef INT_PORT	                     //suggest use INT PORT to wake up !!!
+
+				//gpio_direction_output(INT_PORT, 0);
+				gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");
+				gpio_write_one_pin_value(gpio_int_hdle, 0, "ctp_int_port");
+				msleep(1);
+                          // gpio_direction_output(INT_PORT, 1);
+				gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");
+				gpio_write_one_pin_value(gpio_int_hdle, 1, "ctp_int_port");
+				  msleep(10);
+                          // gpio_direction_output(INT_PORT, 0);
+				gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");
+				gpio_write_one_pin_value(gpio_int_hdle, 0, "ctp_int_port");
+
+				//gpio_free(INT_PORT);
+				//s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+				gpio_set_one_pin_pull(gpio_int_hdle, 0, "ctp_int_port");
+
+
+				if(ts->use_irq) {
+				//	s3c_gpio_cfgpin(INT_PORT, INT_CFG);	//Set IO port as interrupt port
+					ret = ctp_ops.set_irq_mode("ctp_para", "ctp_int_port", CTP_IRQ_MODE);
+					if(0 != ret){
+						printk("%s:ctp_ops.set_irq_mode err. \n", __func__);
+						return ret;
+					}
+				}
+				else
+				//gpio_direction_input(INT_PORT);
+				//Config CTP_IRQ_NO as input
+	  			gpio_set_one_pin_io_status(gpio_int_hdle,0, "ctp_int_port");
+
+			#else
+				//gpio_direction_output(SHUTDOWN_PORT,0);
+				gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+				gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+				msleep(1);
+				//gpio_direction_input(SHUTDOWN_PORT);
+				gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+			#endif
+				msleep(40);
+				ret = 0;
+				return ret;
+
+		default:
+			printk(KERN_DEBUG "%s: Cant't support this command.", f3x_ts_name);
+			return -EINVAL;
+	}
+
+}
+
+
+static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	//TODO:
+	int ret = 0;
+	int err = 0;
+	int retry=0;
+
+	//unsigned short version_temp = 0;
+	unsigned char update_path[1] = {0};
+#if defined(NO_DEFAULT_ID) && defined(INT_PORT)
+	uint8_t goodix_id[3] = {0,0xff,0};
+#endif
+	char test_data = 1;
+	//char test_data2[4]={0x6,0xA2,5,10};
+	struct goodix_ts_data *ts = NULL;
+
+	struct goodix_i2c_rmi_platform_data *pdata;
+	dev_dbg(&client->dev,"Install touch driver.\n");
+
+	printk("======goodix_gt818 probe======\n");
+	//config gpio:
+	//pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+	gpio_wakeup_hdle = gpio_request_ex("ctp_para", "ctp_wakeup");
+	if(!gpio_wakeup_hdle) {
+		pr_warning("touch panel tp_wakeup request gpio fail!\n");
+		goto exit_gpio_wakeup_request_failed;
+	}
+
+	//printk("======gt818_addr=0x%x=======\n",client->addr);
+
+	//Check I2C function
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+	{
+		dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	gpio_addr = ioremap(PIO_BASE_ADDRESS, PIO_RANGE_SIZE);
+	if(!gpio_addr) {
+	    err = -EIO;
+	    goto exit_ioremap_failed;
+	}
+
+	ts->gpio_irq = INT_PORT;
+
+	i2c_connect_client = client;	//used by Guitar_Update
+
+
+#ifdef	INT_PORT
+	//gpio_direction_input(INT_PORT);
+	gpio_set_one_pin_io_status(gpio_int_hdle, 0, "ctp_int_port");
+	//s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+	gpio_set_one_pin_pull(gpio_int_hdle, 0, "ctp_int_port");
+#endif
+
+#if defined(NO_DEFAULT_ID) && defined(INT_PORT)
+	for(retry=0;retry < 3; retry++)
+	{
+		//gpio_direction_output(SHUTDOWN_PORT,0);
+		gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup")
+		gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+		msleep(1);
+		//gpio_direction_input(SHUTDOWN_PORT);
+		gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup")
+		msleep(20);
+
+		ret =i2c_write_bytes(client, &test_data, 1);	//Test I2C connection.
+		if (ret > 0)
+			break;
+	}
+	if(ret <= 0)
+	{
+		//gpio_direction_output(INT_PORT,0);
+		gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");
+		gpio_write_one_pin_value(gpio_int_hdle, 0, "ctp_int_port");
+
+
+		msleep(1);
+		//gpio_direction_output(SHUTDOWN_PORT,0);
+		gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+		gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+		msleep(20);
+		//gpio_direction_input(SHUTDOWN_PORT);
+		gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+		for(retry=0;retry < 80; retry++)
+		{
+			ret =i2c_write_bytes(client, &test_data, 1);	//Test I2C connection.
+			if (ret > 0)
+			{
+				msleep(10);
+				ret =i2c_read_bytes(client, goodix_id, 3);	//Test I2C connection.
+				if (ret > 0)
+				{
+					if(goodix_id[2] == 0x55)
+						{
+						//gpio_direction_output(INT_PORT,1);
+						 gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");
+						 gpio_write_one_pin_value(gpio_int_hdle, 1, "ctp_int_port");
+
+
+						msleep(1);
+						//gpio_free(INT_PORT);
+						//s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+						gpio_set_one_pin_pull(gpio_int_hdle, 0, "ctp_int_port");
+
+						msleep(10);
+						break;
+						}
+				}
+			}
+
+		}
+	}
+#endif
+
+	for(retry=0;retry < 3; retry++)
+	{
+		//gpio_direction_output(SHUTDOWN_PORT,0);
+		gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+		gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+		msleep(50);
+		//gpio_direction_input(SHUTDOWN_PORT);
+		gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+		msleep(200);
+		//output
+		//gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+		//gpio_write_one_pin_value(gpio_wakeup_hdle, 1, "ctp_wakeup");
+		//pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+		ret =i2c_write_bytes(client, &test_data, 1);	//Test I2C connection.
+		if (ret > 0)
+			break;
+	}
+
+
+	/******
+	    pr_info("========write_msg=%d=======\n", i2c_write_bytes(client,test_data2,4));
+	    test_data2[2]=0;
+	    test_data2[3]=0;
+	    printk("=====test_data2[2]=%d,test_data2[3]=%d====\n",test_data2[2],test_data2[3]);
+	    printk("=====read_msg=%d,test_data2[2]=%d,test_data2[3]=%d====\n",i2c_read_bytes(client,test_data2,4),test_data2[2],test_data2[3]);
+	***/
+
+	if(ret <= 0)
+	{
+		dev_err(&client->dev, "Warnning: I2C communication might be ERROR!\n");
+		goto err_i2c_failed;
+	}
+
+	ts->power = goodix_ts_power;
+	INIT_WORK(&ts->work, goodix_ts_work_func);		//init work_struct
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+
+
+	//gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+        //gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+#ifdef AUTO_UPDATE_GT818
+  	  pr_info("%s: %s, %d. \n", __FILE__, __func__, __LINE__);
+            i2c_pre_cmd(ts);
+            goodix_read_version(ts);
+            i2c_end_cmd(ts);
+    //pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+            ret = gt818_downloader( ts, goodix_gt818_firmware, update_path);
+            if(ret < 0)
+            {
+                dev_err(&client->dev, "Warnning: GT818 update might be ERROR!\n");
+                //goto err_input_dev_alloc_failed;
+            }
+#endif
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		ret = -ENOMEM;
+		dev_dbg(&client->dev,"goodix_ts_probe: Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+
+	ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+	ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE); 			// absolute coor (x,y)
+#ifdef HAVE_TOUCH_KEY
+	for(retry = 0; retry < MAX_KEY_NUM; retry++)
+	{
+		input_set_capability(ts->input_dev,EV_KEY,touch_key_array[retry]);
+	}
+#endif
+
+	input_set_abs_params(ts->input_dev, ABS_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+
+#ifdef GOODIX_MULTI_TOUCH
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, TOUCH_MAX_HEIGHT, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, TOUCH_MAX_WIDTH, 0, 0);
+#endif
+
+	sprintf(ts->phys, "input/ts");
+	ts->input_dev->name = f3x_ts_name;
+	ts->input_dev->phys = ts->phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->id.vendor = 0xDEAD;
+	ts->input_dev->id.product = 0xBEEF;
+	ts->input_dev->id.version = 10427;	//screen firmware version
+
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		dev_err(&client->dev,"Probe: Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+	ts->bad_data = 0;
+//	finger_list.length = 0;
+#ifdef INT_PORT
+	client->irq=INT_PORT;		//If not defined in client
+	if (client->irq)
+	{
+		#if INT_TRIGGER==1
+			#define GT801_PLUS_IRQ_TYPE IRQ_TYPE_EDGE_RISING
+		#elif INT_TRIGGER==0
+			#define GT801_PLUS_IRQ_TYPE IRQ_TYPE_EDGE_FALLING
+	//	#elif INT_TRIGGER==2
+	//		#define GT801_PLUS_IRQ_TYPE IRQ_TYPE_LEVEL_LOW
+	//	#elif INT_TRIGGER==3
+	//		#define GT801_PLUS_IRQ_TYPE IRQ_TYPE_LEVEL_HIGH
+		#endif
+		    //pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+		err = ctp_ops.set_irq_mode("ctp_para", "ctp_int_port", CTP_IRQ_MODE);
+		if(0 != err){
+			printk("%s:ctp_ops.set_irq_mode err. \n", __func__);
+			goto exit_set_irq_mode;
+		}
+
+		err =  request_irq(SW_INT_IRQNO_PIO, goodix_ts_irq_handler, GT801_PLUS_IRQ_TYPE|IRQF_SHARED, client->name, ts);
+		if (err < 0) {
+			pr_info( "goodix_probe: request irq failed\n");
+			goto exit_irq_request_failed;
+		}
+		ts->use_irq = 1;
+		printk("======Request EIRQ succesd!==== \n");
+		dev_dbg(&client->dev,"Reques EIRQ %d succesd on GPIO:%d\n",INT_PORT,INT_PORT);
+
+	}
+#endif
+
+	if (!ts->use_irq)
+	{
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = goodix_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	}
+
+    	//pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+	goodix_read_version(ts);
+
+	//pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+	//init panel
+	for(retry=0; retry<3; retry++)
+	{
+		//pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+		ret=goodix_init_panel(ts);
+		dev_info(&client->dev,"the config ret is :%d\n",ret);
+		//msleep(2);
+		msleep(100);
+		if(ret != 0)	//Initiall failed
+			continue;
+		else
+			break;
+	}
+	if(ret != 0) {
+		ts->bad_data=1;
+		goto err_init_godix_ts;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = goodix_ts_early_suspend;
+	ts->early_suspend.resume = goodix_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+	goodix_proc_entry = create_proc_entry("goodix-update", 0666, NULL);
+	if(goodix_proc_entry == NULL)
+	{
+		dev_info(&client->dev, "Couldn't create proc entry!\n");
+		ret = -ENOMEM;
+		goto err_create_proc_entry;
+	}
+	else
+	{
+		dev_info(&client->dev, "Create proc entry success!\n");
+		goodix_proc_entry->write_proc = goodix_update_write;
+		goodix_proc_entry->read_proc = goodix_update_read;
+//		goodix_proc_entry->owner =THIS_MODULE;
+	}
+#endif
+
+	i2c_end_cmd(ts);
+	 //pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+	dev_info(&client->dev,"Start %s in %s mode\n",
+		ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+	//writel(0x6666,gpio_addr+0xdc);
+	return 0;
+
+err_init_godix_ts:
+	i2c_end_cmd(ts);
+	if(ts->use_irq)
+	{
+		ts->use_irq = 0;
+//		free_irq(client->irq,ts);
+	#ifdef INT_PORT
+		//gpio_direction_input(INT_PORT);
+		//gpio_free(INT_PORT);
+		gpio_set_one_pin_io_status(gpio_int_hdle, 0, "ctp_int_port");
+
+	#endif
+	}
+	else
+		hrtimer_cancel(&ts->timer);
+
+exit_set_irq_mode:
+exit_irq_request_failed:
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed:
+	i2c_set_clientdata(client, NULL);
+exit_gpio_wakeup_request_failed:
+exit_ioremap_failed:
+	if(gpio_addr){
+		iounmap(gpio_addr);
+	}
+err_i2c_failed:
+	kfree(ts);
+err_alloc_data_failed:
+err_check_functionality_failed:
+err_create_proc_entry:
+	return ret;
+}
+
+
+/*******************************************************
+********************************************************/
+static int goodix_ts_remove(struct i2c_client *client)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+	remove_proc_entry("goodix-update", NULL);
+#endif
+	if (ts && ts->use_irq)
+	{
+	#ifdef INT_PORT
+		//gpio_direction_input(INT_PORT);
+		//gpio_free(INT_PORT);
+ 		gpio_set_one_pin_io_status(gpio_int_hdle, 0, "ctp_int_port");
+
+	#endif
+//		free_irq(client->irq, ts);
+	}
+	else if(ts)
+		hrtimer_cancel(&ts->timer);
+
+	dev_notice(&client->dev,"The driver is removing...\n");
+	i2c_set_clientdata(client, NULL);
+	input_unregister_device(ts->input_dev);
+	kfree(ts);
+	return 0;
+}
+
+#if defined(CONFIG_PM) || defined(CONFIG_HAS_EARLYSUSPEND)
+//
+static int goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->use_irq){
+		//disable_irq(client->irq);
+		reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+		reg_val &=~(1<<CTP_IRQ_NO);
+		writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+	}
+	else
+		hrtimer_cancel(&ts->timer);
+	//ret = cancel_work_sync(&ts->work);
+	//if(ret && ts->use_irq)
+		//enable_irq(client->irq);
+	if (ts->power) {	/* Â±ÃÃÃ«ÃÃÃÂ¡ÃÃ»workÂºÃ³ÃÃÃÂ´ÃÃÂ£Â¬Â±ÃÃÃ¢ÃÃ²GPIOÂµÂ¼ÃÃÃÃ¸Â±ÃªÂ´Â¦ÃÃ­Â´ÃºÃÃ«ÃÃÃÂ­Â»Â·	*/
+		ret = ts->power(ts, 0);
+		if (ret < 0)
+			printk(KERN_ERR "goodix_ts_suspend power off failed\n");
+		else
+			printk(KERN_ERR "goodix_ts_suspend power off success\n");
+	}
+
+	return 0;
+
+}
+
+//
+static int goodix_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->power) {
+		ret = ts->power(ts, 1);
+		if (ret < 0)
+			printk(KERN_ERR "goodix_ts_resume power on failed\n");
+		else
+			printk(KERN_ERR "goodix_ts_resume power on success\n");
+	}
+
+	if (ts->use_irq){
+		//enable_irq(client->irq);
+		reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+		reg_val |=(1<<CTP_IRQ_NO);
+		writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+	}
+	else
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h)
+{
+	struct goodix_ts_data *ts;
+	ts = container_of(h, struct goodix_ts_data, early_suspend);
+	goodix_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void goodix_ts_late_resume(struct early_suspend *h)
+{
+	struct goodix_ts_data *ts;
+	ts = container_of(h, struct goodix_ts_data, early_suspend);
+	goodix_ts_resume(ts->client);
+}
+#endif
+
+//******************************Begin of firmware update surpport*******************************
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+/*
+static int  update_read_version(struct goodix_ts_data *ts, char **version)
+{
+	int ret = -1, count = 0;
+	//unsigned char version_data[18];
+	char *version_data;
+	char *p;
+
+	*version = (char *)vmalloc(5);
+	version_data = *version;
+	if(!version_data)
+		return -ENOMEM;
+	p = version_data;
+	memset(version_data, 0, sizeof(version_data));
+	version_data[0]=0x07;
+	version_data[1]=0x17;
+	ret=i2c_read_bytes(ts->client,version_data, 4);
+	if (ret < 0)
+		return ret;
+	version_data[5]='\0';
+
+	if(*p == '\0')
+		return 0;
+	do
+	{
+		if((*p > 122) || (*p < 48 && *p != 32) || (*p >57 && *p  < 65)
+			||(*p > 90 && *p < 97 && *p  != '_'))		//check illeqal character
+			count++;
+	}while(*++p != '\0' );
+	if(count > 2)
+		return 0;
+	else
+		return 1;
+}
+*/
+
+#if 0
+/**
+@brief CRC cal proc,include : Reflect,init_crc32_table,GenerateCRC32
+@param global var oldcrc32
+@return states
+*/
+static unsigned int Reflect(unsigned long int ref, char ch)
+{
+	unsigned int value=0;
+	int i;
+	for(i = 1; i < (ch + 1); i++)
+	{
+		if(ref & 1)
+			value |= 1 << (ch - i);
+		ref >>= 1;
+	}
+	return value;
+}
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*  CRC Check Program INIT								                                           		   */
+/*---------------------------------------------------------------------------------------------------------*/
+/*
+static void init_crc32_table(void)
+{
+	unsigned int temp;
+	unsigned int t1,t2;
+	unsigned int flag;
+	int i,j;
+	for(i = 0; i <= 0xFF; i++)
+	{
+		temp=Reflect(i, 8);
+		crc32_table[i]= temp<< 24;
+		for (j = 0; j < 8; j++)
+		{
+
+			flag=crc32_table[i]&0x80000000;
+			t1=(crc32_table[i] << 1);
+			if(flag==0)
+				t2=0;
+			else
+				t2=ulPolynomial;
+			crc32_table[i] =t1^t2 ;
+
+		}
+		crc32_table[i] = Reflect(crc32_table[i], 32);
+	}
+}
+*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*  CRC main Program									                                           		   */
+/*---------------------------------------------------------------------------------------------------------*/
+/*
+static void GenerateCRC32(unsigned char * buf, unsigned int len)
+{
+	unsigned int i;
+	unsigned int t;
+
+	for (i = 0; i != len; ++i)
+	{
+		t = (oldcrc32 ^ buf[i]) & 0xFF;
+		oldcrc32 = ((oldcrc32 >> 8) & 0xFFFFFF) ^ crc32_table[t];
+	}
+}
+*/
+static struct file * update_file_open(char * path, mm_segment_t * old_fs_p)
+{
+	struct file * filp = NULL;
+	int errno = -1;
+
+	filp = filp_open(path, O_RDONLY, 0644);
+
+	if(!filp || IS_ERR(filp))
+	{
+		if(!filp)
+			errno = -ENOENT;
+		else
+			errno = PTR_ERR(filp);
+		printk(KERN_ERR "The update file for Guitar open error.\n");
+		return NULL;
+	}
+	*old_fs_p = get_fs();
+	set_fs(get_ds());
+
+	filp->f_op->llseek(filp,0,0);
+	return filp ;
+}
+
+static void update_file_close(struct file * filp, mm_segment_t old_fs)
+{
+	set_fs(old_fs);
+	if(filp)
+		filp_close(filp, NULL);
+}
+static int update_get_flen(char * path)
+{
+	struct file * file_ck = NULL;
+	mm_segment_t old_fs;
+	int length ;
+
+	file_ck = update_file_open(path, &old_fs);
+	if(file_ck == NULL)
+		return 0;
+
+	length = file_ck->f_op->llseek(file_ck, 0, SEEK_END);
+	//printk("File length: %d\n", length);
+	if(length < 0)
+		length = 0;
+	update_file_close(file_ck, old_fs);
+	return length;
+}
+
+static int goodix_update_write(struct file *filp, const char __user *buff, unsigned long len, void *data)
+{
+	unsigned char cmd[120];
+	int ret = -1;
+       int retry = 0;
+	static unsigned char update_path[60];
+	struct goodix_ts_data *ts;
+
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if(ts==NULL)
+	{
+            printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+		return 0;
+	}
+
+	//printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+	if(copy_from_user(&cmd, buff, len))
+	{
+            printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+		return -EFAULT;
+	}
+	//printk(KERN_INFO"Write cmd is:%d,write len is:%ld\n",cmd[0], len);
+	switch(cmd[0])
+	{
+            case APK_UPDATE_TP:
+            printk(KERN_INFO"Write cmd is:%d,cmd arg is:%s,write len is:%ld\n",cmd[0], &cmd[1], len);
+            memset(update_path, 0, 60);
+            strncpy(update_path, cmd+1, 60);
+
+            ret = gt818_downloader( ts, goodix_gt818_firmware, update_path);
+
+             if(ret < 0)
+            {
+                printk(KERN_INFO"Warnning: GT818 update might be ERROR!\n");
+                return 0;
+            }
+
+            i2c_pre_cmd(ts);
+	     msleep(2);
+
+	    for(retry=0; retry<3; retry++)
+	    {
+	    	//pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+		    ret=goodix_init_panel(ts);
+		    printk(KERN_INFO"the config ret is :%d\n",ret);
+
+		    msleep(2);
+		    if(ret != 0)	//Initiall failed
+			    continue;
+		    else
+			    break;
+	    }
+
+           if(ts->use_irq){
+                //s3c_gpio_cfgpin(INT_PORT, INT_CFG);	//Set IO port as interrupt port
+                	reg_val = readl(gpio_addr + PHO_CFG2_OFFSET);
+        		reg_val &=(~(1<<20));
+        		reg_val |=(3<<21);
+        		writel(reg_val,gpio_addr + PHO_CFG2_OFFSET);
+                    }
+	    		else
+                //gpio_direction_input(INT_PORT);
+	  		gpio_set_one_pin_io_status(gpio_int_hdle,0, "ctp_int_port");
+
+           i2c_end_cmd(ts);
+
+	    if(ret != 0)
+            {
+		    ts->bad_data=1;
+		    return 1;
+	      }
+            return 1;
+
+            case APK_READ_FUN:							//functional command
+			if(cmd[1] == CMD_READ_VER)
+			{
+				printk(KERN_INFO"Read version!\n");
+				ts->read_mode = MODE_RD_VER;
+			}
+                    else if(cmd[1] == CMD_READ_CFG)
+			{
+				printk(KERN_INFO"Read config info!\n");
+				ts->read_mode = MODE_RD_CFG;
+			}
+			else if (cmd[1] == CMD_READ_RAW)
+			{
+			    printk(KERN_INFO"Read raw data!\n");
+			    ts->read_mode = MODE_RD_RAW;
+			}
+        		else if (cmd[1] == CMD_READ_CHIP_TYPE)
+			{
+		    	printk(KERN_INFO"Read chip type!\n");
+			ts->read_mode = MODE_RD_CHIP_TYPE;
+			}
+            return 1;
+
+            case APK_WRITE_CFG:
+			printk(KERN_INFO"Begin write config info!Config length:%d\n",cmd[1]);
+			i2c_pre_cmd(ts);
+                    ret = i2c_write_bytes(ts->client, cmd+2, cmd[1]+2);
+                    i2c_end_cmd(ts);
+                    if(ret != 1)
+                    {
+                        printk("Write Config failed!return:%d\n",ret);
+                        return -1;
+                    }
+                    return 1;
+
+		default:
+			return 0;
+	}
+	return 0;
+}
+
+static int goodix_update_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+#ifdef DEBUG
+	int i;
+#endif
+	int ret = -1;
+	int len = 0;
+	int read_times = 0;
+	struct goodix_ts_data *ts;
+//	int len = 0;
+	unsigned char read_data[360] = {80, };
+
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if(ts==NULL)
+		return 0;
+
+	printk("___READ__\n");
+	//read version data
+	if(ts->read_mode == MODE_RD_VER)	{
+		i2c_pre_cmd(ts);
+		ret = goodix_read_version(ts);
+		i2c_end_cmd(ts);
+		if(ret <= 0){
+			printk(KERN_INFO"Read version data failed!\n");
+			return 0;
+		}
+
+		read_data[1] = (char)(ts->version&0xff);
+		read_data[0] = (char)((ts->version>>8)&0xff);
+
+		printk(KERN_INFO"Gt818 ROM version is:%x%x\n", read_data[0],read_data[1]);
+		memcpy(page, read_data, 2);
+		//*eof = 1;
+		return 2;
+	}else if (ts->read_mode == MODE_RD_CHIP_TYPE){
+		page[0] = GT818;
+		return 1;
+	}else if(ts->read_mode == MODE_RD_CFG){
+
+		read_data[0] = 0x06;
+		read_data[1] = 0xa2;       // cfg start address
+		printk("read config addr is:%x,%x\n", read_data[0],read_data[1]);
+
+		len = 106;
+		i2c_pre_cmd(ts);
+		ret = i2c_read_bytes(ts->client, read_data, len+2);
+		i2c_end_cmd(ts);
+		if(ret <= 0){
+			printk(KERN_INFO"Read config info failed!\n");
+			return 0;
+		}
+
+		memcpy(page, read_data+2, len);
+		return len;
+	}else if (ts->read_mode == MODE_RD_RAW){
+#define TIMEOUT (-100)
+		int retry = 0;
+		if (raw_data_ready != RAW_DATA_READY){
+			raw_data_ready = RAW_DATA_ACTIVE;
+		}
+
+RETRY:
+		read_data[0] = 0x07;
+		read_data[1] = 0x11;
+		read_data[2] = 0x01;
+
+		ret = i2c_write_bytes(ts->client, read_data, 3);
+
+#ifdef DEBUG
+		sum += read_times;
+		printk("count :%d\n", ++access_count);
+		printk("A total of try times:%d\n", sum);
+#endif
+
+		read_times = 0;
+		while (RAW_DATA_READY != raw_data_ready){
+			msleep(4);
+
+			if (read_times++ > 10){
+				if (retry++ > 5){
+					return TIMEOUT;
+				}
+				goto RETRY;
+			}
+		}
+#ifdef DEBUG
+		printk("read times:%d\n", read_times);
+#endif
+		read_data[0] = 0x08;
+		read_data[1] = 0x80;       // raw data address
+
+		len = 160;
+
+		// msleep(4);
+
+		i2c_pre_cmd(ts);
+		ret = i2c_read_bytes(ts->client, read_data, len+2);
+		//      i2c_end_cmd(ts);
+
+		if(ret <= 0){
+			printk(KERN_INFO"Read raw data failed!\n");
+			return 0;
+		}
+
+		memcpy(page, read_data+2, len);
+
+		read_data[0] = 0x09;
+		read_data[1] = 0xC0;
+		//	i2c_pre_cmd(ts);
+		ret = i2c_read_bytes(ts->client, read_data, len+2);
+		i2c_end_cmd(ts);
+
+		if(ret <= 0){
+			printk(KERN_INFO"Read raw data failed!\n");
+			return 0;
+		}
+		memcpy(&page[160], read_data+2, len);
+
+#ifdef DEBUG
+		//**************
+		for (i = 0; i < 300; i++)
+		{
+			printk("%6x", page[i]);
+
+			if ((i+1) % 10 == 0)
+			{
+				printk("\n");
+			}
+		}
+		//********************/
+#endif
+		raw_data_ready = RAW_DATA_NON_ACTIVE;
+
+		return (2*len);
+
+	}
+
+	return -1;
+}
+#endif
+
+//********************************************************************************************
+static u8  is_equal( u8 *src , u8 *dst , int len )
+{
+    int i;
+
+ //   for( i = 0 ; i < len ; i++ )
+  //  {
+        //printk(KERN_INFO"[%02X:%02X]\n", src[i], dst[i]);
+ //   }
+
+    for( i = 0 ; i < len ; i++ )
+    {
+        if ( src[i] != dst[i] )
+        {
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+static  u8 gt818_nvram_store( struct goodix_ts_data *ts )
+{
+    int ret;
+    int i;
+    u8 inbuf[3] = {REG_NVRCS_H,REG_NVRCS_L,0};
+    //u8 outbuf[3] = {};
+    ret = i2c_read_bytes( ts->client, inbuf, 3 );
+
+    if ( ret < 0 )
+    {
+        return 0;
+    }
+
+    if ( ( inbuf[2] & BIT_NVRAM_LOCK ) == BIT_NVRAM_LOCK )
+    {
+        return 0;
+    }
+
+    inbuf[2] = (1<<BIT_NVRAM_STROE);		//store command
+
+    for ( i = 0 ; i < 300 ; i++ )
+    {
+        ret = i2c_write_bytes( ts->client, inbuf, 3 );
+
+        if ( ret < 0 )
+            break;
+    }
+
+    return ret;
+}
+
+static u8  gt818_nvram_recall( struct goodix_ts_data *ts )
+{
+    int ret;
+    u8 inbuf[3] = {REG_NVRCS_H,REG_NVRCS_L,0};
+
+    ret = i2c_read_bytes( ts->client, inbuf, 3 );
+
+    if ( ret < 0 )
+    {
+        return 0;
+    }
+
+    if ( ( inbuf[2]&BIT_NVRAM_LOCK) == BIT_NVRAM_LOCK )
+    {
+        return 0;
+    }
+
+    inbuf[2] = ( 1 << BIT_NVRAM_RECALL );		//recall command
+    ret = i2c_write_bytes( ts->client , inbuf, 3);
+    return ret;
+}
+
+static  int gt818_reset( struct goodix_ts_data *ts )
+{
+    int ret = 1;
+    u8 retry;
+
+    unsigned char outbuf[3] = {0,0xff,0};
+    unsigned char inbuf[3] = {0,0xff,0};
+    //outbuf[1] = 1;
+
+    //gpio_direction_output(SHUTDOWN_PORT,0);
+    gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+    gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+    msleep(20);
+    //gpio_direction_input(SHUTDOWN_PORT);
+    gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+
+    msleep(100);
+    for(retry=0;retry < 80; retry++)
+    {
+        ret =i2c_write_bytes(ts->client, inbuf, 0);	//Test I2C connection.
+        if (ret > 0)
+        {
+            msleep(10);
+            ret =i2c_read_bytes(ts->client, inbuf, 3);	//Test I2C connection.
+            if (ret > 0)
+            {
+                if(inbuf[2] == 0x55)
+                    {
+			    ret =i2c_write_bytes(ts->client, outbuf, 3);
+			    msleep(10);
+			    break;
+			}
+				}
+			}
+
+		}
+    printk(KERN_INFO"Detect address %0X\n", ts->client->addr);
+    //msleep(500);
+    return ret;
+}
+
+static  int gt818_reset2( struct goodix_ts_data *ts )
+{
+	int ret = 1;
+	u8 retry;
+
+	//unsigned char outbuf[3] = {0,0xff,0};
+	unsigned char inbuf[3] = {0,0xff,0};
+	//outbuf[1] = 1;
+
+	//gpio_direction_output(SHUTDOWN_PORT,0);
+	gpio_set_one_pin_io_status(gpio_wakeup_hdle, 1, "ctp_wakeup");
+	gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup");
+	msleep(20);
+	//gpio_direction_input(SHUTDOWN_PORT);
+	gpio_set_one_pin_io_status(gpio_wakeup_hdle, 0, "ctp_wakeup");
+	msleep(100);
+	for(retry=0;retry < 80; retry++)
+	{
+		ret =i2c_write_bytes(ts->client, inbuf, 0);	//Test I2C connection.
+		if (ret > 0)
+		{
+			msleep(10);
+			ret =i2c_read_bytes(ts->client, inbuf, 3);	//Test I2C connection.
+			if (ret > 0)
+			{
+				//   if(inbuf[2] == 0x55)
+				//       {
+				//	    ret =i2c_write_bytes(ts->client, outbuf, 3);
+				//	    msleep(10);
+				break;
+				//		}
+			}
+		}
+
+	}
+	printk(KERN_INFO"Detect address %0X\n", ts->client->addr);
+	//msleep(500);
+	return ret;
+}
+
+
+
+static  int gt818_set_address_2( struct goodix_ts_data *ts )
+{
+    unsigned char inbuf[3] = {0,0,0};
+    int i;
+
+    for ( i = 0 ; i < 12 ; i++ )
+    {
+        if ( i2c_read_bytes( ts->client, inbuf, 3) )
+        {
+            printk(KERN_INFO"Got response\n");
+            return 1;
+        }
+        printk(KERN_INFO"wait for retry\n");
+        msleep(50);
+    }
+    return 0;
+}
+static u8  gt818_update_firmware( u8 *nvram, u16 length, struct goodix_ts_data *ts)
+{
+    u8 ret = 0;
+    u8 err = 0;
+    u8 retry_time = 0;
+    u8 i = 0;
+    u16 cur_code_addr;
+    u16 cur_frame_num, total_frame_num, cur_frame_len;
+    u32 gt80x_update_rate;
+
+    unsigned char i2c_data_buf[PACK_SIZE+2] = {0,};        //
+    unsigned char i2c_chk_data_buf[PACK_SIZE+2] = {0,};        //
+    if( length > NVRAM_LEN - NVRAM_BOOT_SECTOR_LEN )
+    {
+        printk(KERN_INFO"length too big %d %d\n", length, NVRAM_LEN - NVRAM_BOOT_SECTOR_LEN );
+        return 0;
+    }
+
+    total_frame_num = ( length + PACK_SIZE - 1) / PACK_SIZE;
+
+    //gt80x_update_sta = _UPDATING;
+    gt80x_update_rate = 0;
+
+    for( cur_frame_num = 0 ; cur_frame_num < total_frame_num ; cur_frame_num++ )
+    {
+        retry_time = 5;
+
+        cur_code_addr = NVRAM_UPDATE_START_ADDR + cur_frame_num * PACK_SIZE;
+        i2c_data_buf[0] = (cur_code_addr>>8)&0xff;
+        i2c_data_buf[1] = cur_code_addr&0xff;
+
+        i2c_chk_data_buf[0] = i2c_data_buf[0];
+        i2c_chk_data_buf[1] = i2c_data_buf[1];
+
+        if( cur_frame_num == total_frame_num - 1 )
+        {
+            cur_frame_len = length - cur_frame_num * PACK_SIZE;
+        }
+        else
+        {
+            cur_frame_len = PACK_SIZE;
+        }
+
+        //strncpy(&i2c_data_buf[2], &nvram[cur_frame_num*PACK_SIZE], cur_frame_len);
+        for(i=0;i<cur_frame_len;i++)
+        {
+            i2c_data_buf[2+i] = nvram[cur_frame_num*PACK_SIZE+i];
+            }
+        do
+        {
+            err = 0;
+
+            //ret = gt818_i2c_write( guitar_i2c_address, cur_code_addr, &nvram[cur_frame_num*I2C_FRAME_MAX_LENGTH], cur_frame_len );
+            ret = i2c_write_bytes(ts->client, i2c_data_buf, (cur_frame_len+2));
+
+            if ( ret <= 0 )
+            {
+                printk(KERN_INFO"write fail\n");
+                err = 1;
+            }
+
+            ret = i2c_read_bytes(ts->client, i2c_chk_data_buf, (cur_frame_len+2));
+           // ret = gt818_i2c_read( guitar_i2c_address, cur_code_addr, inbuf, cur_frame_len);
+
+            if ( ret <= 0 )
+            {
+                printk(KERN_INFO"read fail\n");
+                err = 1;
+            }
+
+            if( is_equal( &i2c_data_buf[2], &i2c_chk_data_buf[2], cur_frame_len ) == 0 )
+            {
+                printk(KERN_INFO"not equal\n");
+                err = 1;
+            }
+
+        } while ( err == 1 && (--retry_time) > 0 );
+
+        if( err == 1 )
+        {
+            break;
+        }
+
+        gt80x_update_rate = ( cur_frame_num + 1 )*128/total_frame_num;
+
+    }
+
+    if( err == 1 )
+    {
+        printk(KERN_INFO"write nvram fail\n");
+        return 0;
+    }
+
+    ret = gt818_nvram_store(ts);
+
+    msleep( 20 );
+
+    if( ret == 0 )
+    {
+        printk(KERN_INFO"nvram store fail\n");
+        return 0;
+    }
+
+    ret = gt818_nvram_recall(ts);
+
+    msleep( 20 );
+
+    if( ret == 0 )
+    {
+        printk(KERN_INFO"nvram recall fail\n");
+        return 0;
+    }
+
+    for ( cur_frame_num = 0 ; cur_frame_num < total_frame_num ; cur_frame_num++ )		 //	read out all the code
+    {
+
+        cur_code_addr = NVRAM_UPDATE_START_ADDR + cur_frame_num*PACK_SIZE;
+        retry_time=5;
+        i2c_chk_data_buf[0] = (cur_code_addr>>8)&0xff;
+        i2c_chk_data_buf[1] = cur_code_addr&0xff;
+
+
+        if ( cur_frame_num == total_frame_num-1 )
+        {
+            cur_frame_len = length - cur_frame_num*PACK_SIZE;
+        }
+        else
+        {
+            cur_frame_len = PACK_SIZE;
+        }
+
+        do
+        {
+            err = 0;
+            //ret = gt818_i2c_read( guitar_i2c_address, cur_code_addr, inbuf, cur_frame_len);
+            ret = i2c_read_bytes(ts->client, i2c_chk_data_buf, (cur_frame_len+2));
+
+            if ( ret == 0 )
+            {
+                err = 1;
+            }
+
+            if( is_equal( &nvram[cur_frame_num*PACK_SIZE], &i2c_chk_data_buf[2], cur_frame_len ) == 0 )
+            {
+                err = 1;
+            }
+        } while ( err == 1 && (--retry_time) > 0 );
+
+        if( err == 1 )
+        {
+            break;
+        }
+
+        gt80x_update_rate = 127 + ( cur_frame_num + 1 )*128/total_frame_num;
+    }
+
+    gt80x_update_rate = 255;
+    //gt80x_update_sta = _UPDATECHKCODE;
+
+    if( err == 1 )
+    {
+        printk(KERN_INFO"nvram validate fail\n");
+        return 0;
+    }
+    //ÃÂ¹0X00FFÃÂ´0XCCÃÂ±Ã®ÂÂ¾ÃÂÃÂ¼ÃÂ½Ã¢ÂÂ¸
+//    i2c_chk_data_buf[0] = 0xff;
+//    i2c_chk_data_buf[1] = 0x00;
+//    i2c_chk_data_buf[2] = 0x0;
+//    ret = i2c_write_bytes(ts->client, i2c_chk_data_buf, 3);
+
+//    if( ret <= 0 )
+//    {
+//        printk(KERN_INFO"nvram validate fail\n");
+//        return 0;
+//    }
+
+    return 1;
+}
+
+static u8  gt818_update_proc( u8 *nvram, u16 length, struct goodix_ts_data *ts )
+{
+    u8 ret;
+    u8 error = 0;
+    //struct tpd_info_t tpd_info;
+    GT818_SET_INT_PIN( 0 );
+    msleep( 20 );
+    ret = gt818_reset(ts);
+    if ( ret < 0 )
+    {
+        error = 1;
+        printk(KERN_INFO"reset fail\n");
+        goto end;
+    }
+
+    ret = gt818_set_address_2( ts );
+    if ( ret == 0 )
+    {
+        error = 1;
+        printk(KERN_INFO"set address fail\n");
+        goto end;
+    }
+
+    ret = gt818_update_firmware( nvram, length, ts);
+    if ( ret == 0 )
+    {
+        error=1;
+        printk(KERN_INFO"firmware update fail\n");
+        goto end;
+    }
+
+end:
+    GT818_SET_INT_PIN( 1 );
+    //gpio_free(INT_PORT);
+    //s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+      reg_val = readl(gpio_addr + PHO_PULL1_OFFSET);
+      reg_val &=(~(3<<10));
+      writel(reg_val,gpio_addr + PHO_PULL1_OFFSET);
+
+    msleep( 500 );
+    ret = gt818_reset2(ts);
+    if ( ret < 0 )
+    {
+        error=1;
+        printk(KERN_INFO"final reset fail\n");
+        goto end;
+    }
+    if ( error == 1 )
+    {
+        return 0;
+    }
+
+    i2c_pre_cmd(ts);
+    while(goodix_read_version(ts)<0);
+
+    i2c_end_cmd(ts);
+    return 1;
+}
+
+int  gt818_downloader( struct goodix_ts_data *ts,  unsigned char * data, unsigned char * path)
+{
+    struct tpd_firmware_info_t *fw_info = (struct tpd_firmware_info_t *)data;
+    int i;
+    unsigned short checksum = 0;
+    unsigned char *data_ptr = &(fw_info->data);
+    int retry = 0;
+    int ret = 0;
+    int err = 0;
+
+    struct file * file_data = NULL;
+    mm_segment_t old_fs;
+    //unsigned int rd_len;
+    unsigned int file_len = 0;
+    //unsigned char i2c_data_buf[PACK_SIZE] = {0,};
+
+    const int MAGIC_NUMBER_1 = 0x4D454449;
+    const int MAGIC_NUMBER_2 = 0x4154454B;
+
+    //pr_info("%s: %s, %d. \n", _, __func__, __LINE__);
+
+    if(path[0] == 0)
+    {
+        printk(KERN_INFO"%s\n", __func__ );
+        printk(KERN_INFO"magic number 0x%08X 0x%08X\n", fw_info->magic_number_1, fw_info->magic_number_2 );
+        printk(KERN_INFO"magic number 0x%08X 0x%08X\n", MAGIC_NUMBER_1, MAGIC_NUMBER_2 );
+        printk(KERN_INFO"current version 0x%04X, target verion 0x%04X\n", ts->version, fw_info->version );
+        printk(KERN_INFO"size %d\n", fw_info->length );
+        printk(KERN_INFO"checksum %d\n", fw_info->checksum );
+
+        if ( fw_info->magic_number_1 != MAGIC_NUMBER_1 && fw_info->magic_number_2 != MAGIC_NUMBER_2 )
+        {
+            printk(KERN_INFO"Magic number not match\n");
+            err = 0;
+            goto exit_downloader;
+        }
+//        if(((ts->version&0xff)> 0x99)||((ts->version&0xff) < 0x4a))
+//        {
+//            goto update_start;
+//        }
+//        if ( ts->version >= fw_info->version )
+//        {
+//            printk(KERN_INFO"No need to upgrade\n");
+//            err = 0;
+//            goto exit_downloader;
+//        }
+	if( ((ts->version&0xf000) | (fw_info->version&0xf000)) == 0)   //
+  	{
+ 		 if ( (ts->version&0x1ff) >= (fw_info->version&0x1ff) )
+  		{
+  			TPD_DOWNLOADER_DEBUG("No need to upgrade\n");
+			goto exit_downloader;
+		}
+ 	 }
+      else
+  	{
+  		if(((ts->version&0xf000) & (fw_info->version&0xf000)) == 0xf000)    //
+  		{
+  			if( (ts->version&0xff) > (fw_info->version&0xff))
+			{
+				TPD_DOWNLOADER_DEBUG("No need to upgrade\n");
+				goto exit_downloader;
+			}
+			else if((ts->version&0xff) == (fw_info->version&0xff))
+			{
+				if((ts->version&0xf00) >= (fw_info->version&0xf00))
+				{
+					TPD_DOWNLOADER_DEBUG("No need to upgrade\n");
+					goto exit_downloader;
+				}
+				else
+				{
+					TPD_DOWNLOADER_DEBUG("Need to upgrade\n");
+				}
+			}
+			else
+			{
+				TPD_DOWNLOADER_DEBUG("Need to upgrade\n");
+			}
+	}
+	else if((ts->version&0xf000) == 0)
+		{
+		if( (ts->version&0xff) >= (fw_info->version&0xff))
+			{
+			TPD_DOWNLOADER_DEBUG("No need to upgrade\n");
+			goto exit_downloader;
+			}
+		else
+			{
+			TPD_DOWNLOADER_DEBUG("Need to upgrade\n");
+			}
+		}
+	else                   //
+	{
+	if( (ts->version&0xff) > (fw_info->version&0xff))
+		{
+		TPD_DOWNLOADER_DEBUG("No need to upgrade\n");
+		goto exit_downloader;
+		}
+	else
+		{
+		TPD_DOWNLOADER_DEBUG("Need to upgrade\n");
+		}
+	}
+	}
+        if ( get_chip_version( ts->version ) != get_chip_version( fw_info->version ) )
+            {
+                printk(KERN_INFO"Chip version incorrect");
+                err = 0;
+                goto exit_downloader;
+            }
+//update_start:
+        for ( i = 0 ; i < fw_info->length ; i++ )
+            checksum += data_ptr[i];
+
+        checksum = checksum%0xFFFF;
+
+        if ( checksum != fw_info->checksum )
+        {
+            printk(KERN_INFO"Checksum not match 0x%04X\n", checksum);
+            err = 0;
+            goto exit_downloader;
+        }
+    }
+    else
+    {
+        printk(KERN_INFO"Write cmd arg is:\n");
+        file_data = update_file_open(path, &old_fs);
+        printk(KERN_INFO"Write cmd arg is\n");
+        if(file_data == NULL)	//file_data has been opened at the last time
+        {
+            err = -1;
+            goto exit_downloader;
+        }
+
+
+    file_len = (update_get_flen(path))-2;
+
+        printk(KERN_INFO"current length:%d\n", file_len);
+
+            ret = file_data->f_op->read(file_data, &data_ptr[0], file_len, &file_data->f_pos);
+
+            if(ret <= 0)
+            {
+               err = -1;
+                goto exit_downloader;
+            }
+
+
+
+            update_file_close(file_data, old_fs);
+
+
+        }
+    printk(KERN_INFO"STEP_0:\n");
+    //adapter = client->adapter;
+    //gpio_free(INT_PORT);
+    //ret = gpio_request(INT_PORT, "TS_INT");	//Request IO
+    if (ret < 0)
+    {
+        printk(KERN_INFO"Failed to request GPIO:%d, ERRNO:%d\n",(int)INT_PORT,ret);
+        err = -1;
+        goto exit_downloader;
+    }
+
+    printk(KERN_INFO"STEP_1:\n");
+    err = -1;
+    while (  retry < 3 )
+        {
+            ret = gt818_update_proc( data_ptr, fw_info->length, ts);
+            if(ret == 1)
+            {
+                err = 1;
+                break;
+            }
+            retry++;
+    }
+
+exit_downloader:
+    //mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
+   // mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
+       // gpio_direction_output(INT_PORT,1);
+       // msleep(1);
+  //      gpio_free(INT_PORT);
+  //      s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+  		reg_val = readl(gpio_addr + PHO_PULL1_OFFSET);
+        reg_val &=(~(3<<10));
+        writel(reg_val,gpio_addr + PHO_PULL1_OFFSET);
+
+    return err;
+
+}
+//******************************End of firmware update surpport*******************************
+//Â¿ÃÃÃÃÃÂ¸ÃÃÃ½Â¶Â¯ÂµÃ ÃÃ¨Â±Â¸ÃÃ»Â¡ÂªÃÃ¨Â±Â¸ID ÃÃÂ±Ã­
+//only one client
+static const struct i2c_device_id goodix_ts_id[] = {
+	{ GOODIX_I2C_NAME, 0 },
+	{ }
+};
+
+//ÃÃ¨Â±Â¸ÃÃ½Â¶Â¯Â½Ã¡Â¹Â¹ÃÃ¥
+static struct i2c_driver goodix_ts_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe		= goodix_ts_probe,
+	.remove		= goodix_ts_remove,
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#else
+#ifdef CONFIG_PM
+	.suspend	= goodix_ts_suspend,
+	.resume		= goodix_ts_resume,
+#endif
+#endif
+	.id_table	= goodix_ts_id,
+	.driver = {
+		.name	= GOODIX_I2C_NAME,
+		.owner = THIS_MODULE,
+	},
+	.address_list	= u_i2c_addr.normal_i2c,
+};
+
+/*******************************************************
+Â¹Â¦ÃÃÂ£Âº
+	ÃÃ½Â¶Â¯Â¼ÃÃÃÂºÂ¯ÃÃ½
+returnÂ£Âº
+	ÃÂ´ÃÃÂ½Ã¡Â¹Ã»ÃÃ«Â£Â¬0Â±Ã­ÃÂ¾ÃÃ½Â³Â£ÃÂ´ÃÃ
+********************************************************/
+static int __devinit goodix_ts_init(void)
+{
+	int ret = -1;
+	int err = -1;
+
+	printk("===========================%s=====================\n", __func__);
+
+	if (ctp_ops.fetch_sysconfig_para)
+	{
+		if(ctp_ops.fetch_sysconfig_para()){
+			printk("%s: err.\n", __func__);
+			return -1;
+		}
+	}
+	printk("%s: after fetch_sysconfig_para:  normal_i2c: 0x%hx. normal_i2c[1]: 0x%hx \n", \
+	__func__, u_i2c_addr.normal_i2c[0], u_i2c_addr.normal_i2c[1]);
+
+	err = ctp_ops.init_platform_resource();
+	if(0 != err){
+		printk("%s:ctp_ops.init_platform_resource err. \n", __func__);
+	}
+	//
+	ctp_set_gpio_mode();
+
+	goodix_wq = create_singlethread_workqueue("goodix_wq");
+	if (!goodix_wq) {
+	printk(KERN_ALERT "Creat %s workqueue failed.\n", f3x_ts_name);
+	return -ENOMEM;
+
+	}
+	//reset
+	ctp_ops.ts_reset();
+	//wakeup
+	ctp_ops.ts_wakeup();
+
+	goodix_ts_driver.detect = ctp_ops.ts_detect;
+
+	ret = i2c_add_driver(&goodix_ts_driver);
+
+	return ret;
+}
+
+/*******************************************************
+Â¹Â¦ÃÃÂ£Âº
+	ÃÃ½Â¶Â¯ÃÂ¶ÃÃÂºÂ¯ÃÃ½
+Â²ÃÃÃ½Â£Âº
+	clientÂ£ÂºÃÃ¨Â±Â¸Â½Ã¡Â¹Â¹ÃÃ¥
+********************************************************/
+static void __exit goodix_ts_exit(void)
+{
+	printk(KERN_ALERT "Touchscreen driver of guitar exited.\n");
+	i2c_del_driver(&goodix_ts_driver);
+	if (goodix_wq)
+		destroy_workqueue(goodix_wq);		//release our work queue
+}
+
+late_initcall(goodix_ts_init);				//ÃÃ®ÂºÃ³Â³ÃµÃÂ¼Â»Â¯ÃÃ½Â¶Â¯felix
+module_exit(goodix_ts_exit);
+
+MODULE_DESCRIPTION("Goodix Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/gt818_ts.h b/drivers/input/touchscreen/gt818_ts.h
new file mode 100644
index 0000000..a8a7c93
--- /dev/null
+++ b/drivers/input/touchscreen/gt818_ts.h
@@ -0,0 +1,301 @@
+/*
+ * include/linux/goodix_touch.h
+ *
+ * Copyright (C) 2011 Goodix, Inc.
+ *
+ * Author: Felix
+ * Date: 2011.04.28
+ */
+
+#ifndef 	_LINUX_GOODIX_TOUCH_H
+#define		_LINUX_GOODIX_TOUCH_H
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+
+//*************************TouchScreen Work Part*****************************
+#define GOODIX_I2C_NAME "gt818_ts"
+#define GUITAR_GT80X
+#define GT801_PLUS
+#define GT801_NUVOTON
+#define GUITAR_UPDATE_STATE 0x02
+//#define NO_DEFAULT_ID                           //AUTO SET ADDRESS
+//define resolution of the touchscreen
+#define TOUCH_MAX_HEIGHT 	800//7680
+#define TOUCH_MAX_WIDTH	480//	5120
+
+//define resolution of the LCD
+//#define SCREEN_MAX_HEIGHT	7680
+//#define SCREEN_MAX_WIDTH	5120
+// gpio base address
+#define PIO_BASE_ADDRESS             (0x01c20800)
+#define PIO_RANGE_SIZE               (0x400)
+
+#define IRQ_EINT21                   (21)
+#define IRQ_EINT29                   (29)
+
+#define PHO_CFG2_OFFSET              (0X104)
+#define PHO_DAT_OFFSET              (0X10C)
+#define PHO_PULL1_OFFSET             (0X11C)
+
+#define PIO_INT_STAT_OFFSET          (0x214)
+#define PIO_INT_CTRL_OFFSET          (0x210)
+
+#define SHUTDOWN_PORT                ()
+#define INT_PORT                     (SW_INT_IRQNO_PIO)
+
+#define 		TPD_DOWNLOADER_DEBUG  printk
+
+
+//#define SHUTDOWN_PORT 	S3C64XX_GPF(3)			//SHUTDOWNç®¡èå·
+//#define INT_PORT  	S3C64XX_GPL(10)//S3C64XX_GPN(15)						//Int IO port
+//#ifdef INT_PORT
+//	#define TS_INT 		gpio_to_irq(INT_PORT)			//Interrupt Number,EINT18(119)
+//	#define INT_CFG    	S3C_GPIO_SFN(3)//S3C_GPIO_SFN(2)					//IO configer as EINT
+//#else
+//	#define TS_INT	0
+//#endif
+
+
+
+
+// IC ç±»å
+#define TPD_CHIP_VERSION_C_FIRMWARE_BASE 0x5A
+#define TPD_CHIP_VERSION_D1_FIRMWARE_BASE 0x7A
+#define TPD_CHIP_VERSION_E_FIRMWARE_BASE 0x9A
+#define TPD_CHIP_VERSION_D2_FIRMWARE_BASE 0xBA
+enum
+{
+    TPD_GT818_VERSION_B,
+    TPD_GT818_VERSION_C,
+    TPD_GT818_VERSION_D1,
+    TPD_GT818_VERSION_E,
+    TPD_GT818_VERSION_D2
+};
+
+#define FLAG_UP		0
+#define FLAG_DOWN		1
+//set GT801 PLUS trigger mode,åªè½è®¾ç½®0æ1
+#define INT_TRIGGER		1	   // 1=rising 0=falling
+#define POLL_TIME		10	//actual query spacing interval:POLL_TIME+6
+
+#define GOODIX_MULTI_TOUCH
+#ifdef GOODIX_MULTI_TOUCH
+	#define MAX_FINGER_NUM	5
+#else
+	#define MAX_FINGER_NUM	1
+#endif
+
+
+#if defined(INT_PORT)
+	#if MAX_FINGER_NUM <= 3
+	#define READ_BYTES_NUM 1+2+MAX_FINGER_NUM*5
+	#elif MAX_FINGER_NUM == 4
+	#define READ_BYTES_NUM 1+28
+	#elif MAX_FINGER_NUM == 5
+	#define READ_BYTES_NUM 1+34
+	#endif
+#else
+	#define READ_BYTES_NUM 1+34
+#endif
+
+/*****************
+enum finger_state {
+#define FLAG_MASK 0x01
+	FLAG_UP = 0,
+	FLAG_DOWN = 1,
+	FLAG_INVALID = 2,
+};
+
+
+struct point_node
+{
+	uint8_t id;
+	//uint8_t retry;
+	enum finger_state state;
+	uint8_t pressure;
+	unsigned int x;
+	unsigned int y;
+};
+struct ts_event {
+	u16	x1;
+	u16	y1;
+	u16	x2;
+	u16	y2;
+	u16	x3;
+	u16	y3;
+	u16	x4;
+	u16	y4;
+	u16	x5;
+	u16	y5;
+	u16	pressure;
+    u8  touch_point;
+};
+********/
+/* Notice: This definition used by platform_data.
+ * It should be move this struct info to platform head file such as plat/ts.h.
+ * If not used in client, it will be NULL in function of goodix_ts_probe.
+ */
+struct goodix_i2c_platform_data {
+	uint32_t gpio_irq;			//IRQ port, use macro such as "gpio_to_irq" to get Interrupt Number.
+	uint32_t irq_cfg;			//IRQ port config, must refer to master's Datasheet.
+	uint32_t gpio_shutdown;		        //Shutdown port number
+	uint32_t shutdown_cfg;		        //Shutdown port config
+	uint32_t screen_width;		        //screen width
+	uint32_t screen_height;		        //screen height
+};
+
+
+
+//#define swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
+
+#define READ_TOUCH_ADDR_H 0x07
+#define READ_TOUCH_ADDR_L 0x12
+#define READ_KEY_ADDR_H 0x07
+#define READ_KEY_ADDR_L 0x21
+#define READ_COOR_ADDR_H 0x07
+#define READ_COOR_ADDR_L 0x22
+#define READ_ID_ADDR_H 0x00
+#define READ_ID_ADDR_L 0xff
+//****************************åçº§æ¨¡ååæ°******************************************
+
+//******************************************************************************
+struct goodix_ts_data {
+	uint16_t addr;
+	uint8_t bad_data;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int use_reset;		//use RESET flag
+	int use_irq;		//use EINT flag
+    int gpio_irq;
+	int read_mode;		//read moudle mode,20110221 by andrew
+	struct hrtimer timer;
+	struct work_struct  work;
+	char phys[32];
+	int retry;
+       unsigned int version;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+	int (*power)(struct goodix_ts_data * ts, int on);
+};
+
+//*****************************End of Part I *********************************
+
+//*************************Touchkey Surpport Part*****************************
+//#define HAVE_TOUCH_KEY
+#ifdef HAVE_TOUCH_KEY
+	const uint16_t touch_key_array[]={
+									  KEY_MENU,				//MENU
+									  KEY_BACK,				//HOME
+									  KEY_SEND				//CALL
+									 };
+	#define MAX_KEY_NUM	 (sizeof(touch_key_array)/sizeof(touch_key_array[0]))
+#endif
+//*****************************End of Part II*********************************
+
+//*************************Firmware Update part*******************************
+#define AUTO_UPDATE_GT818             //å¦æå®ä¹äºåä¸çµä¼èªå¨å¤æ­æ¯å¦éè¦åçº§
+
+#define CONFIG_TOUCHSCREEN_GOODIX_IAP
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+static int goodix_update_write(struct file *filp, const char __user *buff, unsigned long len, void *data);
+static int goodix_update_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+
+#define PACK_SIZE 					64					//update file package size
+//#define MAX_TIMEOUT					30000				//update time out conut
+//#define MAX_I2C_RETRIES				10					//i2c retry times
+
+//I2C buf address
+//#define ADDR_CMD					80
+//#define ADDR_STA					81
+//#define ADDR_DAT					82
+
+
+//write cmd
+#define APK_UPDATE_TP               1
+#define APK_READ_FUN                 10
+#define APK_WRITE_CFG               11
+
+//fun cmd
+//#define CMD_DISABLE_TP             0
+//#define CMD_ENABLE_TP              1
+#define CMD_READ_VER               2
+#define CMD_READ_RAW               3
+#define CMD_READ_DIF               4
+#define CMD_READ_CFG               5
+#define CMD_READ_CHIP_TYPE         6
+
+//#define CMD_SYS_REBOOT             101
+
+//read mode
+#define MODE_RD_VER                1
+#define MODE_RD_RAW                2
+#define MODE_RD_DIF                3
+#define MODE_RD_CFG                4
+#define MODE_RD_CHIP_TYPE          5
+//error no
+//#define ERROR_NO_FILE				2//ENOENT
+//#define ERROR_FILE_READ				23//ENFILE
+//#define ERROR_FILE_TYPE				21//EISDIR
+//#define ERROR_GPIO_REQUEST			4//EINTR
+//#define ERROR_I2C_TRANSFER			5//EIO
+//#define ERROR_NO_RESPONSE			16//EBUSY
+//#define ERROR_TIMEOUT				110//ETIMEDOUT
+
+struct tpd_firmware_info_t
+{
+    int magic_number_1;
+    int magic_number_2;
+    unsigned short version;
+    unsigned short length;
+    unsigned short checksum;
+    unsigned char data;
+};
+
+#define  NVRAM_LEN               0x0FF0   //	nvram total space
+#define  NVRAM_BOOT_SECTOR_LEN	 0x0100	// boot sector
+#define  NVRAM_UPDATE_START_ADDR 0x4100
+
+#define  BIT_NVRAM_STROE	    0
+#define  BIT_NVRAM_RECALL	    1
+#define BIT_NVRAM_LOCK 2
+#define  REG_NVRCS_H 0X12
+#define  REG_NVRCS_L 0X01
+//#define PACK_SIZE 					64					//update file package size
+#define GT818_SET_INT_PIN( level )	{gpio_set_one_pin_io_status(gpio_int_hdle, 1, "ctp_int_port");gpio_write_one_pin_value(gpio_int_hdle,level , "ctp_int_port");} //gpio_direction_output(INT_PORT, level) //null macro now
+#endif
+//*****************************End of Part III********************************
+struct goodix_i2c_rmi_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+	//reservation
+};
+
+#define RAW_DATA_READY          1
+#define RAW_DATA_NON_ACTIVE     0xffffffff
+#define RAW_DATA_ACTIVE         0
+
+#define GT818_I2C_ADDR_1        0xba
+#define GT818_I2C_ADDR_2        0x6e
+#define GT818_I2C_ADDR_3        0x28
+#define GT801_I2C_ADDR          0xaa
+
+
+enum CHIP_TYPE
+{
+    GT800 = 1,
+    GT800PLUS,
+    GT800PLUS3,
+    GT816,
+    GT818,
+    GT8105,
+    GT8110,
+    GT818PLUS
+};
+
+
+#endif /* _LINUX_GOODIX_TOUCH_H */
diff --git a/drivers/input/touchscreen/gt818_update.h b/drivers/input/touchscreen/gt818_update.h
new file mode 100644
index 0000000..7e2dac3
--- /dev/null
+++ b/drivers/input/touchscreen/gt818_update.h
@@ -0,0 +1,486 @@
+static unsigned char goodix_gt818_firmware[]  =
+{
+    0x49, 0x44, 0x45, 0x4D,  //magic number 1
+    0x4B, 0x45, 0x54, 0x41,  //magic number 2
+    0x80, 0x00, //version
+    0xF0, 0x0E, //firmware length
+    0x7A, 0x06,   //checksumc   67a
+0x4f,0xce,0x01,0x00,0x20,0x03,0xa7,0x00,
+0x08,0x8c,0x04,0xd3,0x26,0xf8,0x8e,0x04,
+0xd3,0xbd,0x41,0x16,0x20,0xfe,0x3c,0x3c,
+0x0e,0xbd,0xc3,0x07,0xbd,0x4e,0xd4,0xbd,
+0x4f,0x17,0xbd,0x45,0xb9,0xbd,0x47,0x90,
+0xbd,0x46,0xc5,0xbd,0xf7,0x45,0x5f,0xce,
+0x13,0x01,0xe7,0x00,0x20,0x10,0x01,0x01,
+0x01,0x01,0x13,0xe6,0x01,0x08,0xd6,0xeb,
+0x26,0x04,0x01,0xcf,0x01,0x01,0xd6,0xeb,
+0x27,0xec,0xd6,0xe7,0x5c,0x26,0xe7,0xd7,
+0xeb,0xce,0x13,0x01,0xe7,0x00,0xbd,0xc4,
+0xa6,0xf6,0x07,0x0b,0x27,0x0f,0xbd,0x47,
+0x08,0xbd,0x46,0xc5,0xc6,0x80,0xd7,0xea,
+0xbd,0xf7,0x45,0x20,0xd9,0xbd,0x45,0x34,
+0xd6,0xea,0x5a,0x27,0x08,0xbd,0xf5,0x49,
+0xbd,0xf7,0x45,0x20,0xc9,0xbd,0x4d,0xc7,
+0xbd,0xe9,0x9d,0xbd,0x4d,0x0e,0xbd,0x4a,
+0xd6,0xbd,0xeb,0xb1,0xbd,0xf7,0x45,0xbd,
+0x4f,0x35,0x8d,0x4d,0xbd,0x48,0x1b,0xbd,
+0xf6,0x7d,0xbd,0xd8,0x7e,0xbd,0x4c,0x78,
+0xbd,0xdc,0x3a,0xbd,0xee,0xfe,0xbd,0xe0,
+0x5d,0xbd,0xe4,0x21,0xbd,0xe4,0x41,0xbd,
+0x4f,0x9a,0xbd,0xd6,0x84,0xbd,0xd7,0x6f,
+0xbd,0x49,0xd2,0xbd,0xef,0x77,0x20,0x86,
+0x3c,0xce,0x07,0x12,0xc6,0xa0,0xe7,0x00,
+0x5f,0xce,0x07,0x1d,0xe7,0x00,0x08,0x8c,
+0x07,0x48,0x23,0xf8,0xce,0x03,0x83,0xe7,
+0x00,0x08,0x8c,0x03,0xab,0x25,0xf8,0x38,
+0x39,0x7f,0x02,0xd9,0xbd,0xc5,0x40,0x13,
+0xe6,0x04,0x02,0x8d,0x49,0xbd,0x43,0x73,
+0xfc,0x02,0x90,0xc3,0x00,0x64,0xfd,0x02,
+0x90,0x39,0x3c,0x18,0x3c,0x86,0x14,0xf6,
+0x02,0xd9,0x3d,0xc3,0x0d,0x80,0x18,0x8f,
+0xce,0x02,0x2c,0x96,0xc2,0xb7,0x02,0x6e,
+0x96,0xe6,0x84,0x40,0x26,0x04,0xec,0x00,
+0x20,0x04,0xec,0x00,0x47,0x56,0x18,0xed,
+0x00,0xc6,0x02,0x3a,0x18,0x3a,0x7a,0x02,
+0x6e,0x26,0xe5,0x4f,0xb7,0x00,0xd1,0x7c,
+0x02,0xd9,0x18,0x38,0x38,0x39,0x3c,0x18,
+0x3c,0xce,0x02,0xda,0x4f,0xc6,0xa0,0xa7,
+0x00,0x08,0x5a,0x26,0xfa,0x96,0xc1,0xb7,
+0x02,0x6f,0x18,0xce,0x0d,0x80,0xce,0x02,
+0xda,0xd6,0xc2,0xf7,0x02,0x6e,0x18,0x3c,
+0x4f,0x5f,0x18,0xe3,0x00,0x18,0x08,0x18,
+0x08,0x7a,0x02,0x6e,0x26,0xf4,0xfd,0x02,
+0xd7,0x18,0x38,0x3c,0x4f,0xd6,0xc2,0x8f,
+0xfc,0x02,0xd7,0x2a,0x0c,0x40,0x50,0x82,
+0x00,0x02,0x8f,0x40,0x50,0x82,0x00,0x20,
+0x02,0x02,0x8f,0xfd,0x02,0xd7,0x38,0x96,
+0xc2,0xb7,0x02,0x6e,0x18,0x3c,0x18,0xec,
+0x00,0xb3,0x02,0xd7,0x18,0xed,0x00,0x2d,
+0x04,0x2e,0x0d,0x20,0x18,0x6c,0x01,0x1a,
+0xa3,0x06,0x2c,0x11,0xed,0x06,0x20,0x0d,
+0x6c,0x00,0x1a,0xa3,0x04,0x2f,0x02,0xed,
+0x04,0xe3,0x02,0xed,0x02,0x18,0x08,0x18,
+0x08,0x7a,0x02,0x6e,0x26,0xd0,0x18,0x38,
+0xc6,0x0a,0x3a,0x58,0x18,0x3a,0x7a,0x02,
+0x6f,0x26,0x86,0xce,0x02,0xda,0x96,0xc1,
+0xb7,0x02,0x6f,0x4a,0xb7,0x02,0xcf,0xb7,
+0x02,0xd0,0x4f,0xd6,0xc9,0xc0,0x0a,0xa3,
+0x04,0xe3,0x06,0x22,0x15,0xd6,0xc1,0xf0,
+0x02,0x6f,0xb6,0x02,0xcf,0xb1,0x02,0xd0,
+0x27,0x05,0xf7,0x02,0xcf,0x20,0x03,0xf7,
+0x02,0xd0,0xc6,0x0a,0x3a,0x7a,0x02,0x6f,
+0x26,0xd8,0x8d,0x0e,0xf6,0x02,0xcf,0xf7,
+0x02,0xd0,0x8d,0x06,0x8d,0x32,0x18,0x38,
+0x38,0x39,0x7f,0x02,0xd2,0xf6,0x02,0xd0,
+0xf7,0x02,0x6f,0xbd,0x44,0x5b,0xbd,0x44,
+0xf7,0x7c,0x02,0x6f,0xf6,0x02,0x6f,0xd1,
+0xc1,0x26,0xf0,0x7f,0x02,0xd2,0xf6,0x02,
+0xd0,0xf7,0x02,0x6f,0xbd,0x44,0x5b,0xbd,
+0x44,0xf7,0x7a,0x02,0x6f,0x2a,0xf5,0x39,
+0x18,0xce,0x02,0xda,0xce,0x0d,0x80,0x96,
+0xc1,0xb7,0x02,0x6f,0x18,0x67,0x08,0x18,
+0x66,0x09,0x96,0xc2,0xb7,0x02,0x6e,0x3c,
+0xec,0x00,0x18,0xe3,0x08,0xed,0x00,0x08,
+0x08,0x7a,0x02,0x6e,0x26,0xf2,0x38,0xc6,
+0x0a,0x18,0x3a,0x58,0x3a,0x7a,0x02,0x6f,
+0x26,0xda,0x39,0x3c,0x18,0x3c,0x4f,0x5f,
+0xfd,0x02,0x90,0xb7,0x02,0x81,0xb7,0x02,
+0x80,0x97,0xe2,0x97,0xe1,0xb7,0x02,0xca,
+0xb7,0x02,0xc9,0x18,0xce,0x0d,0x80,0xce,
+0x0d,0x80,0xff,0x02,0x89,0xff,0x02,0x87,
+0x96,0xc1,0xb7,0x02,0x6f,0x3c,0x18,0x3c,
+0x96,0xc2,0xb7,0x02,0x6e,0x18,0xec,0x00,
+0x2a,0x28,0x40,0x50,0x82,0x00,0x4d,0x27,
+0x02,0xc6,0xff,0xd1,0xc9,0x23,0x03,0x7c,
+0x00,0xe1,0xf1,0x02,0x7f,0x23,0x03,0x7c,
+0x02,0x80,0x4f,0xa7,0x00,0xf3,0x02,0x90,
+0xfd,0x02,0x90,0x86,0x02,0xb7,0x02,0xcb,
+0x20,0x5d,0xd0,0xed,0x82,0x00,0x2a,0x0c,
+0xdb,0xed,0x89,0x00,0xf3,0x02,0x90,0xfd,
+0x02,0x90,0x4f,0x5f,0x4d,0x27,0x02,0xc6,
+0xff,0xd1,0xc9,0x22,0x04,0x86,0x02,0x20,
+0x04,0x7c,0x00,0xe2,0x4f,0xb7,0x02,0xcb,
+0xf1,0x02,0x7f,0x23,0x03,0x7c,0x02,0x81,
+0xe7,0x00,0x4f,0xf3,0x02,0x90,0xfd,0x02,
+0x90,0xe6,0x00,0xf1,0x02,0xca,0x23,0x14,
+0xb6,0x02,0xca,0xb7,0x02,0xc9,0xf7,0x02,
+0xca,0xfc,0x02,0x89,0xfd,0x02,0x87,0xff,
+0x02,0x89,0x20,0x0b,0xf1,0x02,0xc9,0x23,
+0x06,0xf7,0x02,0xc9,0xff,0x02,0x87,0x3c,
+0xc6,0xa0,0x3a,0x3a,0xf6,0x02,0xcb,0xe7,
+0x00,0x38,0x08,0xc6,0x02,0x18,0x3a,0x7a,
+0x02,0x6e,0x27,0x03,0x7e,0x43,0xa5,0x18,
+0x38,0x38,0xc6,0x14,0x3a,0x18,0x3a,0x7a,
+0x02,0x6f,0x27,0x03,0x7e,0x43,0x9d,0x18,
+0x38,0x38,0x39,0xce,0x02,0xda,0xf6,0x02,
+0x6f,0x86,0x0a,0x3d,0x3a,0xec,0x00,0x3d,
+0x5d,0xfd,0x02,0xcc,0x27,0x66,0x86,0x01,
+0xf6,0x02,0xd2,0x27,0x10,0x5a,0x27,0x18,
+0x5a,0x27,0x1e,0xf6,0x02,0xd1,0x27,0x05,
+0x5a,0x27,0x20,0x20,0x08,0xe6,0x00,0xe1,
+0x01,0x22,0x02,0x20,0x16,0x4f,0x20,0x13,
+0xf6,0x02,0xd1,0xc1,0x02,0x27,0x0c,0x20,
+0x1a,0x4f,0xf6,0x02,0xd1,0xc1,0x01,0x27,
+0x02,0x20,0x08,0xb7,0x02,0xce,0x4f,0xd6,
+0xc2,0x20,0x0e,0xb7,0x02,0xce,0x4f,0xe6,
+0x00,0x20,0x06,0xb7,0x02,0xce,0x4f,0xe6,
+0x01,0xfd,0x02,0xd7,0xec,0x02,0x3c,0xfe,
+0x02,0xd7,0x02,0x8f,0x38,0xfd,0x02,0xcc,
+0x4f,0xf6,0x02,0xce,0x26,0x06,0xb3,0x02,
+0xcc,0xfd,0x02,0xcc,0xec,0x04,0xf3,0x02,
+0xcc,0xfd,0x02,0xd5,0xec,0x06,0xf3,0x02,
+0xcc,0xfd,0x02,0xd3,0xec,0x08,0xf3,0x02,
+0xcc,0xed,0x08,0xfc,0x02,0xd3,0x47,0x56,
+0x47,0x56,0xe3,0x08,0xed,0x08,0x39,0xf6,
+0x02,0xd2,0xc1,0x03,0x2c,0x03,0xf7,0x02,
+0xd1,0x7f,0x02,0xd2,0x4f,0xd6,0xc9,0xc0,
+0x0a,0x1a,0xb3,0x02,0xd5,0x2c,0x03,0x7c,
+0x02,0xd2,0x40,0x50,0x82,0x00,0x1a,0xb3,
+0x02,0xd3,0x2f,0x06,0x7c,0x02,0xd2,0x7c,
+0x02,0xd2,0xf6,0x02,0xd2,0xc1,0x03,0x26,
+0x0a,0xf6,0x02,0xd1,0x26,0x05,0xc6,0x01,
+0xf7,0x02,0xd2,0x39,0x12,0xec,0x04,0x01,
+0x39,0x3c,0x18,0xce,0x02,0x96,0xd6,0xea,
+0xc1,0x01,0x26,0x09,0xfc,0x01,0x28,0x1a,
+0x83,0x08,0x80,0x26,0x10,0xcc,0x00,0x00,
+0xcd,0xee,0x00,0x27,0x1f,0xed,0x00,0x18,
+0x08,0x18,0x08,0x20,0xf3,0xcd,0xee,0x00,
+0x27,0x12,0xcc,0x09,0x20,0x83,0x08,0x80,
+0x3a,0xcc,0x00,0x00,0xed,0x00,0x18,0x08,
+0x18,0x08,0x20,0xe9,0x38,0x39,0x3c,0x7f,
+0x07,0x10,0xce,0x16,0x00,0x1d,0x00,0x02,
+0x1c,0x06,0x02,0x1d,0x07,0x02,0xbd,0xee,
+0xef,0x1e,0x02,0x02,0x07,0xf6,0x07,0x10,
+0xca,0x02,0x20,0x12,0x1d,0x06,0x02,0x1c,
+0x07,0x02,0xbd,0xee,0xef,0xf6,0x07,0x10,
+0x1f,0x02,0x02,0x0d,0xca,0x01,0xf7,0x07,
+0x10,0x1d,0x06,0x02,0x1d,0x07,0x02,0x20,
+0x06,0x1c,0x00,0x02,0x1d,0x02,0x02,0x38,
+0x39,0xcc,0xf8,0x0b,0xdd,0x10,0xcc,0xf8,
+0x12,0xdd,0x12,0xcc,0xf8,0xe3,0xdd,0x18,
+0xcc,0xf8,0xe4,0xdd,0x1c,0xce,0x10,0x00,
+0x5f,0xe7,0x00,0xe7,0x01,0xe7,0x02,0xe7,
+0x04,0xe7,0x05,0xce,0x11,0x00,0xc6,0xaf,
+0xe7,0x00,0x5f,0xe7,0x01,0xcc,0x13,0x88,
+0xed,0x02,0x4f,0x5f,0xed,0x04,0xed,0x06,
+0xce,0x12,0x00,0xc6,0xaa,0xe7,0x00,0xc6,
+0xbf,0xce,0x13,0x00,0xe7,0x00,0x5f,0xe7,
+0x01,0xc6,0x0c,0xe7,0x03,0xce,0x14,0x00,
+0xc6,0xde,0xe7,0x00,0x5f,0xf7,0x07,0x0f,
+0xce,0x15,0x20,0xe7,0x00,0xe7,0x01,0xc6,
+0xfd,0xce,0x16,0x00,0xe7,0x00,0x5f,0xe7,
+0x01,0xe7,0x02,0xe7,0x03,0xe7,0x04,0xe7,
+0x05,0xe7,0x06,0xe7,0x07,0xcc,0x00,0x4d,
+0xfd,0x03,0x7c,0xce,0x48,0xcc,0x18,0xce,
+0x04,0xf7,0x18,0xff,0x00,0x16,0x8d,0x46,
+0xcc,0x00,0x95,0xfd,0x03,0x7c,0xce,0x49,
+0x3d,0x18,0xce,0x05,0x44,0x18,0xff,0x00,
+0x14,0x8d,0x33,0xce,0xc0,0xbd,0x18,0xce,
+0x40,0x07,0xc6,0x04,0xbd,0xc1,0x76,0x27,
+0x04,0xc6,0x5d,0x20,0x11,0xf6,0x40,0x0b,
+0xc1,0x5d,0x27,0x0a,0xc1,0x14,0x27,0x06,
+0xc1,0x37,0x27,0x02,0xc6,0x5d,0xf7,0x14,
+0x01,0x8d,0x24,0xf7,0x15,0x22,0xbd,0x45,
+0x76,0x07,0x84,0x7f,0x06,0x39,0xfc,0x03,
+0x7c,0x20,0x11,0xe6,0x00,0x18,0xe7,0x00,
+0x08,0x18,0x08,0xfc,0x03,0x7c,0x83,0x00,
+0x01,0xfd,0x03,0x7c,0x26,0xed,0x39,0x3c,
+0xce,0x06,0x92,0x6f,0x7d,0xfc,0x4f,0xf1,
+0x1a,0x83,0x46,0x43,0x26,0x13,0x1c,0x7d,
+0x80,0xf6,0x4f,0xf0,0xc1,0x28,0x25,0x09,
+0xc1,0x50,0x22,0x05,0x1c,0x7d,0x20,0x20,
+0x02,0xc6,0x40,0x38,0x39,0x3c,0x3c,0xbd,
+0xc9,0xb3,0xd6,0x6a,0x4f,0xc3,0x07,0x92,
+0x8f,0xcc,0x41,0xfa,0xed,0x01,0xbd,0x41,
+0xc0,0x15,0xb4,0xf0,0x7f,0x03,0x7e,0xcc,
+0x80,0x00,0xfd,0x01,0x2e,0xf6,0x06,0xec,
+0xc4,0x0f,0xd7,0xed,0x5f,0xd7,0x6a,0x86,
+0x03,0x3d,0x4f,0xc3,0x03,0xaf,0xfd,0x03,
+0xad,0xbd,0x4e,0xbb,0x7c,0x00,0x6a,0xd6,
+0x6a,0xc1,0x05,0x25,0xea,0x38,0x38,0x39,
+0x3c,0x3c,0x30,0x4f,0x5f,0xed,0x00,0xc6,
+0x0f,0xf7,0x07,0x12,0xf7,0x03,0x80,0x20,
+0x55,0x18,0xce,0x13,0x01,0x18,0xe7,0x00,
+0xf6,0x07,0x0b,0x27,0x14,0x18,0xfe,0x06,
+0x12,0x18,0xad,0x00,0xf6,0x01,0x32,0x5a,
+0x26,0x04,0xc6,0x01,0xe7,0x00,0x7f,0x07,
+0x0b,0xe6,0x00,0x26,0x1f,0x4f,0xdd,0x75,
+0x5f,0x18,0xce,0x13,0x01,0x18,0xe7,0x00,
+0xbd,0xee,0xef,0xf6,0x07,0x0b,0x26,0x0c,
+0xdc,0x75,0xc3,0x00,0x01,0xdd,0x75,0x83,
+0x07,0xd0,0x25,0xe4,0xe6,0x01,0x26,0x05,
+0xbd,0xf7,0xe3,0x20,0x03,0xbd,0xf7,0xfa,
+0xe6,0x01,0xc8,0x01,0xe7,0x01,0xe6,0x00,
+0x27,0xa7,0xc6,0xa0,0xf7,0x07,0x12,0xf7,
+0x03,0x80,0x18,0xfe,0x06,0x16,0x18,0xad,
+0x00,0xf6,0x01,0x30,0xf7,0x07,0x0d,0xf6,
+0x01,0x31,0xf7,0x07,0x0c,0x38,0x38,0x39,
+0x7f,0x07,0x11,0xc6,0x02,0xf7,0x06,0x92,
+0x5f,0xf7,0x07,0x0e,0xf7,0x03,0x7f,0xd7,
+0xe4,0xbd,0xf3,0x11,0x39,0x4d,0x2a,0x05,
+0x43,0x53,0xc3,0x00,0x01,0x1a,0x83,0x04,
+0x00,0x23,0x19,0x8f,0x4d,0x2a,0x05,0x43,
+0x53,0xc3,0x00,0x01,0x1a,0x83,0x00,0x00,
+0x27,0x0a,0x8f,0x02,0x8c,0x00,0x0a,0x23,
+0x03,0xbd,0xd3,0x01,0x39,0xc6,0xcc,0xd7,
+0xef,0xbd,0xd0,0x94,0x5f,0xd7,0xef,0x39,
+0x3c,0xd6,0xef,0xc1,0xcc,0x26,0x37,0x5f,
+0xd7,0x6a,0xce,0x01,0xc2,0x18,0xce,0x01,
+0xea,0x58,0x58,0x58,0x3a,0x18,0x3a,0xec,
+0x02,0xa3,0x04,0x36,0x37,0xec,0x00,0xa3,
+0x02,0x38,0x8d,0xa9,0x18,0xec,0x02,0x18,
+0xa3,0x04,0x8f,0x18,0xec,0x00,0x18,0xa3,
+0x02,0x8d,0x9a,0x7c,0x00,0x6a,0xd6,0x6a,
+0xc1,0x05,0x25,0xce,0x20,0x03,0xbd,0xd3,
+0x01,0x38,0x39,0x3c,0x3c,0x30,0x13,0xcb,
+0x80,0x24,0xd6,0xda,0x86,0x07,0x3d,0xed,
+0x00,0xd6,0xe2,0x86,0x0a,0x3d,0xa3,0x00,
+0x22,0x10,0xd6,0xda,0x86,0x07,0x3d,0xed,
+0x00,0xd6,0xe1,0x86,0x0a,0x3d,0xa3,0x00,
+0x23,0x04,0x8d,0x16,0x20,0x03,0xbd,0xcf,
+0x3a,0x38,0x38,0x39,0xbd,0xd1,0x8b,0x13,
+0xe6,0x02,0x06,0x7c,0x02,0x8c,0x7c,0x02,
+0x8b,0x39,0x3c,0x3c,0xbd,0xd2,0x5b,0x5f,
+0xd7,0xbe,0x20,0x24,0x5f,0xd7,0xbf,0x20,
+0x16,0xd6,0xbe,0x86,0x14,0x3d,0xdb,0xbf,
+0x89,0x00,0xc3,0x0e,0xc0,0x8f,0xc6,0x02,
+0xe7,0x00,0x7c,0x00,0xbf,0xd6,0xbf,0xd1,
+0xc2,0x25,0xe6,0x7c,0x00,0xbe,0xd6,0xbe,
+0xd1,0xc1,0x25,0xd8,0x13,0xec,0x08,0x0d,
+0xd6,0xe1,0x27,0x09,0xd6,0xe2,0x27,0x05,
+0xc6,0x03,0xf7,0x02,0x84,0x38,0x38,0x39,
+0xd6,0xbf,0xd1,0x28,0x24,0x04,0xd7,0x28,
+0x20,0x0c,0xd1,0x27,0x23,0x08,0xd1,0xc2,
+0x23,0x02,0xd6,0xc2,0xd7,0x27,0xd6,0xbe,
+0xd1,0x25,0x23,0x09,0xd1,0xc0,0x23,0x02,
+0xd6,0xc0,0xd7,0x25,0x39,0xd1,0x26,0x24,
+0x02,0xd7,0x26,0x39,0xf6,0x03,0x7f,0x27,
+0x06,0xf6,0x03,0x80,0xf7,0x07,0x12,0xce,
+0x14,0x00,0x1e,0x00,0x10,0x27,0x1f,0x00,
+0x04,0x23,0x1d,0x00,0x02,0x1c,0x00,0x04,
+0x0e,0x4f,0x5f,0xfd,0x01,0x2e,0x20,0x05,
+0x01,0x01,0xcf,0x01,0x01,0xfc,0x01,0x2e,
+0x1a,0x83,0x80,0x00,0x26,0xf2,0x1c,0x00,
+0x04,0x1c,0x00,0x02,0x3b,0xce,0x14,0x02,
+0xec,0x00,0xfd,0x01,0x2e,0xce,0x49,0x19,
+0xad,0x00,0xce,0x14,0x00,0x1c,0x00,0x10,
+0x3b,0xfc,0x01,0x2e,0x83,0x07,0x12,0x25,
+0x1b,0xfc,0x01,0x2e,0x83,0x07,0x72,0x22,
+0x13,0x13,0xe4,0x80,0x0f,0x13,0xe6,0x08,
+0x05,0xbd,0xf7,0xe3,0x20,0x03,0xbd,0xf7,
+0xfa,0x15,0xe4,0x80,0x39,0x3c,0xce,0x15,
+0x00,0x1c,0x00,0x02,0x7c,0x00,0xe7,0xd6,
+0xe7,0xf1,0x01,0x34,0x23,0x69,0xfe,0x01,
+0x2c,0xfc,0x15,0x01,0xed,0x00,0xfc,0x15,
+0x03,0xed,0x02,0xfc,0x15,0x05,0xed,0x04,
+0xfc,0x15,0x07,0xed,0x06,0xfc,0x15,0x09,
+0xed,0x08,0xfc,0x15,0x0b,0xed,0x0a,0xfc,
+0x15,0x0d,0xed,0x0c,0xfc,0x15,0x0f,0xed,
+0x0e,0xfc,0x15,0x11,0xed,0x10,0xfc,0x15,
+0x13,0xed,0x12,0xf6,0x01,0x34,0xcb,0x08,
+0xd1,0xe7,0x26,0x08,0xfc,0x01,0x26,0xc3,
+0x01,0x40,0x20,0x06,0xfc,0x01,0x2c,0xc3,
+0x00,0x14,0xfd,0x01,0x2c,0xfc,0x01,0x2a,
+0xc3,0x00,0x04,0xfd,0x01,0x2a,0xd6,0xc1,
+0xfb,0x01,0x34,0xd1,0xe7,0x23,0x1d,0x5a,
+0xd1,0xe7,0x26,0x03,0xbd,0xf7,0xa3,0xfe,
+0x01,0x2a,0xec,0x00,0xfd,0x15,0x24,0xec,
+0x02,0xfd,0x15,0x26,0xce,0x15,0x15,0x1c,
+0x00,0x80,0x20,0x04,0xc6,0xff,0xd7,0xe7,
+0x38,0x3b,0xbd,0xf0,0xb6,0x12,0xe8,0x40,
+0x05,0xf6,0x02,0x74,0x27,0x04,0x12,0xe8,
+0x80,0x03,0xbd,0xf1,0x22,0x39,0x3c,0x3c,
+0xf6,0x02,0x75,0x5a,0x26,0x1d,0xc6,0xf1,
+0xf7,0x02,0x75,0xf7,0x07,0x11,0x20,0x0f,
+0xf6,0x07,0x11,0xf7,0x02,0x75,0x5f,0xce,
+0x13,0x01,0xe7,0x00,0xf6,0x02,0x75,0xc1,
+0xf1,0x27,0xed,0x38,0x38,0x39,0x3c,0xd6,
+0x68,0xc0,0x90,0xce,0x03,0x83,0x3a,0xf6,
+0x01,0x33,0xe7,0x00,0xdc,0x91,0xe7,0x01,
+0xa7,0x02,0xdc,0x8f,0xe7,0x03,0xa7,0x04,
+0xdc,0x8d,0xe7,0x05,0xa7,0x06,0x38,0x39,
+0xec,0x00,0x18,0xed,0x00,0xec,0x02,0x18,
+0xed,0x02,0xec,0x04,0x18,0xed,0x04,0xec,
+0x06,0x18,0xed,0x06,0x39,0x3c,0x3c,0x18,
+0x3c,0xf6,0x07,0x12,0xc4,0xcf,0xca,0x10,
+0xc4,0xf0,0xf7,0x07,0x12,0xf6,0x03,0x82,
+0xd1,0xc5,0x22,0x09,0xf6,0x07,0x12,0xfa,
+0x03,0x82,0xf7,0x07,0x12,0xf6,0x07,0x1d,
+0xc4,0xf0,0xf7,0x07,0x1d,0x13,0xec,0x02,
+0x17,0xca,0x0f,0xf7,0x07,0x1d,0xf6,0x07,
+0x12,0xc4,0xf0,0xf7,0x07,0x12,0xcc,0x00,
+0x21,0x18,0xfe,0x06,0x68,0x18,0xad,0x00,
+0xd6,0xb7,0xf7,0x07,0x21,0xf6,0x07,0x1d,
+0xc4,0xef,0xf7,0x07,0x1d,0x13,0xec,0x80,
+0x0d,0xca,0x10,0xf7,0x07,0x1d,0xf6,0x07,
+0x12,0xc4,0xf0,0xf7,0x07,0x12,0xce,0x03,
+0x83,0x18,0xce,0x07,0x22,0x5f,0xd7,0x6a,
+0x20,0x0d,0xbd,0x4a,0x30,0xc6,0x08,0x3a,
+0x18,0x3a,0x7c,0x00,0x6a,0xd6,0x6a,0xd1,
+0xc5,0x24,0x04,0xc1,0x05,0x25,0xeb,0xf6,
+0x07,0x12,0xc4,0xcf,0xca,0x20,0xf7,0x07,
+0x12,0x18,0x38,0x38,0x38,0x39,0x3c,0x3c,
+0xf6,0x07,0x11,0xf7,0x02,0x75,0xc1,0xc3,
+0x26,0x06,0x7f,0x07,0x11,0x7e,0xc0,0x00,
+0x15,0xe9,0xc0,0xf6,0x06,0x92,0x56,0x56,
+0x56,0xc4,0xc0,0xda,0xe9,0xd7,0xe9,0xf6,
+0x06,0x92,0xc5,0x03,0x26,0x05,0xca,0x02,
+0xf7,0x06,0x92,0xd6,0xe9,0xc4,0xc0,0xc1,
+0x40,0x26,0x10,0xcc,0x00,0x25,0xfe,0x06,
+0x68,0xad,0x00,0xbd,0xee,0xef,0xfe,0x06,
+0x56,0xad,0x00,0xf6,0x07,0x0e,0xd7,0xe8,
+0xd6,0xc5,0xf7,0x03,0x81,0x5f,0xd7,0xc5,
+0xf6,0x07,0x12,0xf7,0x03,0x80,0xc6,0x01,
+0xf7,0x03,0x7f,0xfe,0x06,0x0c,0xad,0x00,
+0xf6,0x03,0x80,0xf7,0x07,0x12,0x7f,0x03,
+0x7f,0xf6,0x03,0x81,0xd7,0xc5,0xf6,0x02,
+0x77,0xf7,0x03,0x82,0xd6,0xb7,0x27,0x08,
+0xf6,0x02,0x16,0xca,0x20,0xf7,0x02,0x16,
+0xfe,0x06,0x0e,0xad,0x00,0xd6,0xec,0xc4,
+0x82,0xf1,0x02,0xc2,0x27,0x0c,0xc6,0x01,
+0xf7,0x01,0xb4,0xd6,0xec,0xc4,0x82,0xf7,
+0x02,0xc2,0xf6,0x01,0xb4,0x5a,0x26,0x19,
+0xbd,0x4c,0x30,0xf6,0x01,0x32,0xc1,0x14,
+0x25,0x0a,0x7f,0x01,0xb4,0xc6,0x01,0xf7,
+0x03,0x7e,0x20,0x20,0xbd,0x4a,0x45,0x20,
+0x1b,0xf6,0x03,0x7e,0x5a,0x26,0x15,0xbd,
+0x4c,0x30,0xf6,0x01,0x32,0xc1,0x14,0x24,
+0x0b,0xbd,0x4a,0x45,0x7f,0x03,0x7e,0xc6,
+0x01,0xf7,0x01,0xb4,0xf6,0x01,0xb4,0x5a,
+0x26,0x1a,0xf6,0x03,0x82,0x4f,0xfe,0x06,
+0x68,0xad,0x00,0xf6,0x03,0x82,0x26,0x0c,
+0xd6,0xb7,0x26,0x08,0xcc,0x00,0x19,0xfe,
+0x06,0x68,0xad,0x00,0xfe,0x06,0x10,0xad,
+0x00,0xbd,0x49,0xe6,0x8d,0x03,0x38,0x38,
+0x39,0xf6,0x07,0x11,0xc1,0x02,0x26,0x36,
+0x3c,0xce,0x16,0x01,0x1d,0x00,0x01,0xb6,
+0x07,0x11,0x81,0x02,0x26,0x27,0x08,0xce,
+0x16,0x02,0x1d,0x00,0x01,0xce,0x16,0x00,
+0x1c,0x00,0x01,0x8d,0x1a,0x08,0x01,0xce,
+0x16,0x07,0x1d,0x00,0x01,0xce,0x16,0x06,
+0x1c,0x00,0x01,0xce,0x16,0x00,0x1d,0x00,
+0x01,0x8d,0x04,0x20,0xd2,0x38,0x39,0x01,
+0x86,0xaf,0x36,0x86,0xbe,0x3c,0x36,0x86,
+0x00,0xce,0x13,0x01,0xa7,0x00,0x32,0x38,
+0x4a,0x26,0xf2,0x32,0x4a,0x26,0xeb,0x39,
+0x7f,0x01,0x32,0xfc,0x01,0x2e,0x1a,0x83,
+0x80,0x00,0x27,0x0d,0xbd,0xee,0xef,0x7c,
+0x01,0x32,0xf6,0x01,0x32,0xc1,0x14,0x25,
+0xea,0x39,0x3c,0x3c,0x01,0x01,0x01,0xd6,
+0xe7,0xc1,0xff,0x26,0xf7,0xfe,0x06,0x60,
+0xad,0x00,0xbd,0xf7,0xfa,0xbd,0xee,0xef,
+0x8d,0x03,0x38,0x38,0x39,0xcc,0x01,0x23,
+0xb7,0x14,0x04,0xf7,0x14,0x04,0xcc,0x45,
+0x67,0xb7,0x14,0x04,0xf7,0x14,0x04,0x39,
+0x3c,0x3c,0x5f,0xd7,0x6a,0x7e,0x4d,0x04,
+0x4f,0x05,0x05,0xc3,0x00,0x29,0xfd,0x03,
+0xab,0x8f,0xe6,0x00,0x5a,0x27,0x09,0xe6,
+0x01,0xd1,0xc2,0x26,0x31,0xfe,0x03,0xab,
+0xe6,0x01,0xe1,0x00,0x26,0x0e,0xe6,0x00,
+0x5a,0x26,0x04,0x6c,0x01,0x20,0x05,0xfe,
+0x03,0xab,0x6a,0x00,0xe6,0x03,0xe1,0x02,
+0x26,0x14,0xd1,0xc0,0x24,0x05,0x6c,0x03,
+0xfe,0x03,0xab,0xe6,0x02,0xc1,0x01,0x23,
+0x05,0x6a,0x02,0xfe,0x03,0xab,0xe6,0x02,
+0x5a,0x27,0x09,0xe6,0x03,0xd1,0xc0,0x26,
+0x2e,0xfe,0x03,0xab,0xe6,0x03,0xe1,0x02,
+0x26,0x0e,0xe6,0x02,0x5a,0x26,0x04,0x6c,
+0x03,0x20,0x05,0xfe,0x03,0xab,0x6a,0x02,
+0xe6,0x01,0xe1,0x00,0x26,0x11,0xd1,0xc2,
+0x24,0x05,0x6c,0x01,0xfe,0x03,0xab,0xe6,
+0x00,0xc1,0x01,0x23,0x02,0x6a,0x00,0x7c,
+0x00,0x6a,0xd6,0x6a,0xd1,0xc8,0x24,0x03,
+0x7e,0x4c,0x80,0x38,0x38,0x39,0x3c,0x3c,
+0x5f,0xd7,0x6a,0x7e,0x4d,0xbd,0x4f,0x8f,
+0xe6,0x93,0x26,0x05,0xce,0x02,0xc4,0x20,
+0x18,0xce,0x02,0xc4,0xd6,0x6a,0x3a,0x6c,
+0x00,0xe6,0x00,0xc1,0x05,0x23,0x04,0xc6,
+0x05,0xe7,0x00,0x5a,0x26,0x0a,0xce,0x01,
+0x3e,0xd6,0x6a,0x3a,0x6f,0x00,0x20,0x38,
+0xe6,0x00,0xc1,0x02,0x26,0x32,0xd6,0x6a,
+0x58,0x58,0x4f,0xc3,0x01,0x5c,0x37,0x36,
+0xd6,0x6a,0x58,0x58,0x58,0x4f,0xc3,0x01,
+0xc2,0x8f,0xec,0x02,0x38,0xed,0x02,0xd6,
+0x6a,0x58,0x58,0x4f,0xc3,0x01,0x48,0x37,
+0x36,0xd6,0x6a,0x58,0x58,0x58,0x4f,0xc3,
+0x01,0xea,0x8f,0xec,0x02,0x38,0xed,0x02,
+0xce,0x01,0x39,0xd6,0x6a,0x3a,0xa6,0x00,
+0x27,0x36,0x4f,0x05,0x37,0x36,0xce,0x01,
+0x5c,0xd6,0x6a,0x58,0x58,0x3a,0xec,0x00,
+0x38,0xed,0xa2,0xd6,0x6a,0x4f,0x05,0x37,
+0x36,0xce,0x01,0x48,0xd6,0x6a,0x58,0x58,
+0x3a,0xec,0x00,0x38,0xed,0x98,0xd6,0x6a,
+0x4f,0x8f,0xc6,0x01,0xe7,0x93,0xce,0x01,
+0x43,0xd6,0x6a,0x3a,0xc6,0x1f,0xe7,0x00,
+0x7c,0x00,0x6a,0xd6,0x6a,0xd1,0xc5,0x24,
+0x03,0x7e,0x4d,0x16,0x38,0x38,0x39,0x3c,
+0x3c,0x30,0x12,0xcb,0x20,0x03,0x38,0x38,
+0x39,0x5f,0xd7,0x6a,0x7e,0x4e,0xb1,0x4f,
+0x05,0x18,0x8f,0x18,0xec,0xa2,0xdd,0x91,
+0x18,0xec,0x98,0xdd,0x8f,0x5f,0xd7,0x67,
+0xd6,0x6a,0x86,0x03,0x3d,0x4f,0xc3,0x03,
+0xaf,0xfd,0x03,0xad,0xd6,0x6a,0x4f,0x18,
+0x8f,0x18,0xe6,0x93,0x26,0x06,0xbd,0x4e,
+0xbb,0x7e,0x4e,0xac,0x18,0xfe,0x03,0xad,
+0x18,0xe6,0x00,0x5a,0x26,0x0e,0x18,0xce,
+0x01,0x3e,0xd6,0x6a,0x18,0x3a,0x18,0x6f,
+0x00,0x7e,0x4e,0xac,0x18,0xce,0x01,0x5c,
+0xd6,0x6a,0x58,0x58,0x18,0x3a,0xdc,0x91,
+0x18,0xa3,0x00,0xdd,0xcf,0x2f,0x0c,0xfc,
+0x01,0x78,0x04,0x93,0xcf,0x24,0x16,0xc6,
+0x02,0x20,0x10,0xfc,0x01,0x78,0x04,0xed,
+0x00,0x4f,0x5f,0x93,0xcf,0xa3,0x00,0x23,
+0x04,0xc6,0x01,0xd7,0x67,0x18,0xfe,0x03,
+0xad,0x18,0xe6,0x01,0x27,0x09,0xd1,0x67,
+0x26,0x05,0xc6,0x01,0x18,0xe7,0x00,0xd6,
+0x67,0x18,0xe7,0x01,0x18,0xce,0x01,0x48,
+0xd6,0x6a,0x58,0x58,0x18,0x3a,0xdc,0x8f,
+0x18,0xa3,0x00,0xdd,0xcf,0x2f,0x0c,0xfc,
+0x01,0x76,0x04,0x93,0xcf,0x24,0x16,0xc6,
+0x02,0x20,0x10,0xfc,0x01,0x76,0x04,0xed,
+0x00,0x4f,0x5f,0x93,0xcf,0xa3,0x00,0x23,
+0x04,0xc6,0x01,0xd7,0x67,0x18,0xfe,0x03,
+0xad,0x18,0xe6,0x02,0x27,0x09,0xd1,0x67,
+0x26,0x05,0xc6,0x01,0x18,0xe7,0x00,0xd6,
+0x67,0x18,0xe7,0x02,0x7c,0x00,0x6a,0xd6,
+0x6a,0xd1,0xc5,0x24,0x03,0x7e,0x4d,0xd7,
+0x38,0x38,0x39,0x3c,0x3c,0xfe,0x03,0xad,
+0x4f,0x5f,0xed,0x00,0x6f,0x02,0x38,0x38,
+0x39,0xbd,0xd6,0xe3,0xd6,0xb9,0x27,0x03,
+0x14,0xb9,0x80,0x39,0xcc,0x4e,0xc9,0xfd,
+0x06,0x3e,0xcc,0x48,0x4c,0xfd,0x06,0x28,
+0xcc,0x47,0x08,0xfd,0x05,0xe6,0xcc,0x4c,
+0x4a,0xfd,0x06,0x56,0xcc,0x4a,0x0e,0xfd,
+0x06,0x18,0xcc,0x4a,0xd6,0xfd,0x05,0xe8,
+0xcc,0x48,0x5a,0xfd,0x06,0x38,0xcc,0x47,
+0xcd,0xfd,0x06,0x36,0xcc,0x47,0xd8,0xfd,
+0x06,0x2e,0xcc,0x48,0xa0,0xfd,0x06,0x4a,
+0xcc,0x4f,0x61,0xfd,0x06,0x40,0x39,0x3c,
+0xbd,0xc4,0xc5,0xce,0x06,0x92,0xfc,0x4f,
+0xea,0xe7,0x81,0xa7,0x82,0xfc,0x4f,0xe8,
+0xe7,0x83,0xa7,0x84,0xfc,0x4f,0xec,0xe7,
+0x85,0xa7,0x86,0x38,0x39,0xf6,0x06,0x92,
+0xc5,0x80,0x27,0x0f,0x12,0xcb,0x10,0x20,
+0x7f,0x02,0xc3,0x14,0xcb,0x10,0xf6,0x07,
+0x0a,0x20,0x0d,0x13,0xcb,0x10,0x11,0x7f,
+0x02,0xc3,0x15,0xcb,0x10,0xf6,0x06,0xea,
+0xd7,0xcc,0x15,0xec,0x80,0x7f,0x02,0xc2,
+0x39,0xf6,0x06,0x92,0xc5,0x80,0x27,0x2e,
+0x78,0x02,0xc1,0xd6,0xc8,0x27,0x08,0xf6,
+0x02,0xc1,0xca,0x01,0xf7,0x02,0xc1,0xd6,
+0xac,0x26,0x1b,0xf6,0x02,0xc1,0xc4,0x07,
+0xc1,0x07,0x27,0x12,0x5f,0xd7,0x6a,0xbd,
+0xf5,0x18,0x7c,0x00,0x6a,0xd6,0x6a,0xc1,
+0x05,0x25,0xf4,0x5f,0xd7,0xc8,0xbd,0xf4,
+0x5d,0x39,0xf6,0x06,0x92,0xc5,0x80,0x26,
+0x01,0x39,0xf6,0x07,0x09,0x4f,0x54,0x54,
+0x54,0x54,0xbd,0xf9,0x2f,0x14,0xdd,0x75,
+0x78,0x02,0xc3,0x3c,0xdc,0x75,0xc3,0x0d,
+0x80,0x8f,0x96,0xc2,0xe6,0x00,0xd1,0xc9,
+0x23,0x0a,0xf6,0x02,0xc3,0xca,0x01,0xf7,
+0x02,0xc3,0x20,0x07,0x08,0x4a,0x26,0xec,
+0xf6,0x02,0xc3,0x38,0xc5,0x0f,0x27,0x04,
+0x14,0xec,0x80,0x39,0x13,0xec,0x80,0x07,
+0xd6,0xac,0x26,0x03,0x15,0xec,0x80,0x39,
+0x18,0xc3,0x00,0x00,0x00,0x80,0x00,0x00,
+};
\ No newline at end of file
diff --git a/drivers/input/touchscreen/readme.txt b/drivers/input/touchscreen/readme.txt
new file mode 100644
index 0000000..9ee1721
--- /dev/null
+++ b/drivers/input/touchscreen/readme.txt
@@ -0,0 +1,34 @@
+/*
+ * drivers/input/touchscreen/readme.txt
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+touch screen driver ç°ç¶æè¿°ï¼
+@2011.11.16
+	ctp_platform_ops.h: å»ºç«3.0 åå§çæ¬ï¼
+	1. æ°å¢i2c ç¸å³çdetectæ¥å£ï¼
+	2. æ´æ°set_gpio_irq_modeæ¥å£ï¼è½å®ç°å¤é¨32ä¸ªä¸­æ­æºçéç½®ï¼
+
+	1.goodix_touch: å»ºç«3.0 åå§çæ¬ï¼
+		1.1 æ¯æåç¹æåç¹åæ ä¸æ¥æ¹å¼ï¼
+		1.2 éç¨ctp_platform_opsæä½éå®æå¹³å°ç¸å³æä½ï¼
+
+	ft5x_ts: å»ºç«3.0 åå§çæ¬ï¼
+		1. éç¨ctp_platform_opsæä½éå®æå¹³å°ç¸å³æä½ï¼
\ No newline at end of file
diff --git a/drivers/input/touchscreen/sun4i-ts.c b/drivers/input/touchscreen/sun4i-ts.c
new file mode 100644
index 0000000..e5eee46
--- /dev/null
+++ b/drivers/input/touchscreen/sun4i-ts.c
@@ -0,0 +1,1877 @@
+/* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+*
+* Copyright (c) 2009
+*
+* ChangeLog
+*
+*
+*/
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/tick.h>
+#include <asm-generic/cputime.h>
+
+#include <mach/system.h>
+#include <mach/hardware.h>
+#include <plat/sys_config.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    #include <linux/pm.h>
+    #include <linux/earlysuspend.h>
+#endif
+
+//#undef CONFIG_HAS_EARLYSUSPEND
+
+static int tp_flag = 0;
+
+//tp status value
+#define TP_INITIAL             (-1)
+#define TP_DOWN                (0)
+#define TP_UP                  (1)
+#define TP_DATA_VA             (2)
+//?
+#define DUAL_TOUCH             (dual_touch_distance)
+#define TOUCH_CHANGE           (3)
+#define TP_DATA_AV_NO          (0x3)
+
+//#define PRINT_INT_INFO
+//#define PRINT_FILTER_INFO
+//#define PRINT_REPORT_STATUS_INFO
+//#define PRINT_REPORT_DATA_INFO
+//#define PRINT_TASKLET_INFO
+#define CONFIG_TOUCHSCREEN_SUN4I_DEBUG
+#define PRINT_SUSPEND_INFO
+//#define PRINT_FILTER_DOUBLE_POINT_STATUS_INFO
+//#define PRINT_ORIENTATION_INFO
+//#define FIX_ORIENTATION
+#define ORIENTATION_DEFAULT_VAL   (-1)
+//#define TP_INT_PERIOD_TEST
+//#define TP_TEMP_DEBUG
+//#define TP_FREQ_DEBUG
+//#define PRINT_UP_SEPARATOR
+#define TP_FIX_CENTER
+
+#define IRQ_TP                 (29)
+#define TP_BASSADDRESS         (0xf1c25000)
+#define TP_CTRL0               (0x00)
+#define TP_CTRL1               (0x04)
+#define TP_CTRL2               (0x08)
+#define TP_CTRL3               (0x0c)
+#define TP_INT_FIFOC           (0x10)
+#define TP_INT_FIFOS           (0x14)
+#define TP_TPR                 (0x18)
+#define TP_CDAT                (0x1c)
+#define TEMP_DATA              (0x20)
+#define TP_DATA                (0x24)
+
+
+#define ADC_FIRST_DLY          (0x1<<24)
+#define ADC_FIRST_DLY_MODE     (0x1<<23)
+#define ADC_CLK_SELECT         (0x0<<22)
+#define ADC_CLK_DIVIDER        (0x2<<20)
+//#define CLK                    (6)
+#define CLK                    (7)
+#define FS_DIV                 (CLK<<16)
+#define ACQ                    (0x3f)
+#define T_ACQ                  (ACQ)
+
+#define STYLUS_UP_DEBOUNCE     (0<<12)
+#define STYLUS_UP_DEBOUCE_EN   (0<<9)
+#define TOUCH_PAN_CALI_EN      (1<<6)
+#define TP_DUAL_EN             (1<<5)
+#define TP_MODE_EN             (1<<4)
+#define TP_ADC_SELECT          (0<<3)
+#define ADC_CHAN_SELECT        (0)
+
+//#define TP_SENSITIVE_ADJUST    (0xf<<28)
+#define TP_SENSITIVE_ADJUST    (tp_sensitive_level<<28)       //mark by young for test angda 5" 0xc
+#define TP_MODE_SELECT         (0x1<<26)
+#define PRE_MEA_EN             (0x1<<24)
+#define PRE_MEA_THRE_CNT       (tp_press_threshold<<0)         //0x1f40
+
+
+#define FILTER_EN              (1<<2)
+#define FILTER_TYPE            (0x01<<0)
+
+#define TP_DATA_IRQ_EN         (1<<16)
+#define TP_DATA_XY_CHANGE      (tp_exchange_x_y<<13)       //tp_exchange_x_y
+#define TP_FIFO_TRIG_LEVEL     (3<<8)
+#define TP_FIFO_FLUSH          (1<<4)
+#define TP_UP_IRQ_EN           (1<<1)
+#define TP_DOWN_IRQ_EN         (1<<0)
+
+#define FIFO_DATA_PENDING      (1<<16)
+#define TP_UP_PENDING          (1<<1)
+#define TP_DOWN_PENDING        (1<<0)
+
+#define SINGLE_TOUCH_MODE      (1)
+#define CHANGING_TO_DOUBLE_TOUCH_MODE (2)
+#define DOUBLE_TOUCH_MODE      (3)
+#define UP_TOUCH_MODE           (4)
+
+#define SINGLE_CNT_LIMIT       (40)
+#define DOUBLE_CNT_LIMIT       (2)
+#define UP_TO_SINGLE_CNT_LIMIT (10)
+
+#define TPDATA_MASK            (0xfff)
+#define FILTER_NOISE_LOWER_LIMIT  (2)
+#define MAX_DELTA_X             (700-100)     //    avoid excursion
+#define MAX_DELTA_Y             (1200-200)
+#define X_TURN_POINT            (330)         // x1 < (1647 - MAX_DELTA_X) /3
+#define X_COMPENSATE            (4*X_TURN_POINT)
+#define Y_TURN_POINT            (260)         // y1 < (1468 -MAX_DELTA_Y )
+#define Y_COMPENSATE            (2*Y_TURN_POINT)
+
+#ifdef TP_FIX_CENTER
+#define X_CENTER_COORDINATE     (2048)        //for construct two point
+#define Y_CENTER_COORDINATE     (2048)
+#else
+#define X_CENTER_COORDINATE     (sample_data->x)
+#define Y_CENTER_COORDINATE     (sample_data->y)
+#endif
+
+#define CYCLE_BUFFER_SIZE       (64)          //must be 2^n
+#define DELAY_PERIOD            (6)          //delay 60 ms, unit is 10ms
+#define DELAY_COMPENSTAE_PEROID  (3)    //the os is busy, can not process the data in time.
+
+#define ZOOM_CHANGE_LIMIT_CNT  (3)
+#define ZOOM_IN                                       (1)
+#define ZOOM_OUT                                   (2)
+#define ZOOM_INIT_STATE                    (3)
+#define ZOOM_STATIC                             (4)
+
+#define SAMPLE_TIME                            (9.6)                    //unit is ms. ???
+#define SAMPLE_TIME_FACTOR          (9.6/SAMPLE_TIME)
+
+#ifndef TRUE
+#define TRUE   1
+#define FALSE  0
+#endif
+
+#ifdef PRINT_INT_INFO
+#define print_int_info(fmt, args...)     \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_int_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_FILTER_INFO
+#define print_filter_info(fmt, args...)     \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_filter_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_REPORT_STATUS_INFO
+#define print_report_status_info(fmt, args...)     \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_report_status_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_REPORT_DATA_INFO
+#define print_report_data_info(fmt, args...)     \
+        do{                              \
+                printk(fmt, ##args);     \
+        }while(0)
+#else
+#define print_report_data_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_TASKLET_INFO
+#define print_tasklet_info(fmt, args...)     \
+            do{                              \
+                    printk(fmt, ##args);     \
+            }while(0)
+#else
+#define print_tasklet_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_FILTER_DOUBLE_POINT_STATUS_INFO
+#define print_filter_double_point_status_info(fmt, args...)     \
+            do{                              \
+                    printk(fmt, ##args);     \
+            }while(0)
+#else
+#define print_filter_double_point_status_info(fmt, args...)   //
+#endif
+
+#ifdef PRINT_ORIENTATION_INFO
+#define print_orientation_info(fmt, args...)     \
+            do{                              \
+                    printk(fmt, ##args);     \
+            }while(0)
+#else
+#define print_orientation_info(fmt, args...)   //
+#endif
+
+struct sun4i_ts_data {
+	struct resource *res;
+	struct input_dev *input;
+	void __iomem *base_addr;
+	int irq;
+	char phys[32];
+	unsigned int count; //for report threshold & touchmod(double to single touch mode) change
+	unsigned long buffer_head; //for cycle buffer
+	unsigned long buffer_tail;
+	int ts_sample_status;                //for touchscreen status when sampling
+	int ts_process_status;               //for record touchscreen status when process data
+	int double_point_cnt;            //for noise reduction when in double_touch_mode
+	int single_touch_cnt;                //for noise reduction when change to double_touch_mode
+	int ts_delay_period;                 //will determine responding sensitivity
+	int touchflag;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend early_suspend;
+#endif
+};
+
+struct ts_sample_data{
+	unsigned int x1;
+	unsigned int y1;
+	unsigned int x;
+	unsigned int y;
+	unsigned int dx;
+	unsigned int dy;
+	unsigned int z1;
+	unsigned int z2;
+	int sample_status;                       //record the sample point status when sampling
+	unsigned int sample_time;
+};
+
+struct sun4i_ts_data * mtTsData =NULL;
+static int touch_mode = UP_TOUCH_MODE;
+static int change_mode = TRUE;
+static int tp_irq_state = TRUE;
+
+#ifdef PRINT_INT_INFO
+static cputime64_t cur_wall_time = 0L;
+#endif
+
+//static cputime64_t cur_idle_time = 0L;
+
+static struct ts_sample_data cycle_buffer[CYCLE_BUFFER_SIZE] = {{0},};
+static struct ts_sample_data *prev_sample;
+static struct ts_sample_data *prev_data_sample;
+static struct timer_list data_timer;
+static int data_timer_status = 0;  //when 1, mean tp driver have recervied data, and begin to report data, and start timer to reduce up&down signal
+static struct ts_sample_data prev_single_sample;
+static struct ts_sample_data prev_double_sample_data;
+static struct ts_sample_data prev_report_samp;
+static int orientation_flag = 0;
+static int zoom_flag = 0;
+static int accmulate_zoom_out_ds = 0;
+static int accmulate_zoom_in_ds = 0;
+static int zoom_in_count = 0;
+static int zoom_out_count = 0;
+static int zoom_change_cnt = 0;
+static int hold_cnt = 0;
+//config from sysconfig files.
+static int glide_delta_ds_max_limit = 0;
+static int tp_regidity_level = 0;
+static int tp_press_threshold_enable = 0;
+static int tp_press_threshold = 0; //usded to adjust sensitivity of touch
+static int tp_sensitive_level = 0; //used to adjust sensitivity of pen down detection
+static int tp_exchange_x_y = 0;
+
+#define ZOOM_IN_OUT_BUFFER_SIZE_TIMES (2)
+#define ZOOM_IN_OUT_BUFFER_SIZE (1<<ZOOM_IN_OUT_BUFFER_SIZE_TIMES)
+#define TRANSFER_DATA_BUFFER_SIZE     (4)
+
+static struct ts_sample_data zoom_in_data_buffer[ZOOM_IN_OUT_BUFFER_SIZE] = {{0},};
+static struct ts_sample_data zoom_out_data_buffer[ZOOM_IN_OUT_BUFFER_SIZE] = {{0},};
+static struct ts_sample_data transfer_data_buffer[TRANSFER_DATA_BUFFER_SIZE] = {{0},};
+
+static int zoom_in_buffer_cnt = 0;
+static int zoom_out_buffer_cnt = 0;
+
+static spinlock_t tp_do_tasklet_sync;
+static int tp_do_tasklet_running = 0;
+//for test
+//static int tp_irq = 0;
+static int dual_touch_distance = 0;
+
+#ifdef PRINT_UP_SEPARATOR
+    static int separator_flag = 0;
+#endif
+
+static int reported_single_point_cnt = 0;
+static int reported_data_start_time = 0;
+
+static atomic_t report_up_event_implement_sync = ATOMIC_INIT(1);
+static int report_up_event_implement_running = 0;
+
+static int reference_point_flag = 1;
+
+void tp_do_tasklet(unsigned long data);
+DECLARE_TASKLET(tp_tasklet,tp_do_tasklet,0);
+
+//åç¨è®¾å¤
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sun4i_ts_suspend(struct early_suspend *h)
+{
+	/*int ret;
+	struct sun4i_ts_data *ts = container_of(h, struct sun4i_ts_data, early_suspend);
+    */
+    #ifdef PRINT_SUSPEND_INFO
+        printk("enter earlysuspend: sun4i_ts_suspend. \n");
+    #endif
+    writel(0,TP_BASSADDRESS + TP_CTRL1);
+	return ;
+}
+
+//éæ°å¤é
+static void sun4i_ts_resume(struct early_suspend *h)
+{
+	/*int ret;
+	struct sun4i_ts_data *ts = container_of(h, struct sun4i_ts_data, early_suspend);
+    */
+    #ifdef PRINT_SUSPEND_INFO
+        printk("enter laterresume: sun4i_ts_resume. \n");
+    #endif
+    writel(STYLUS_UP_DEBOUNCE|STYLUS_UP_DEBOUCE_EN|TP_DUAL_EN|TP_MODE_EN,TP_BASSADDRESS + TP_CTRL1);
+	return ;
+}
+#else
+//åç¨è®¾å¤
+#ifdef CONFIG_PM
+static int sun4i_ts_suspend(struct platform_device *pdev, pm_message_t state)
+{
+    #ifdef PRINT_SUSPEND_INFO
+        printk("enter: sun4i_ts_suspend. \n");
+    #endif
+
+    writel(0,TP_BASSADDRESS + TP_CTRL1);
+	return 0;
+}
+
+static int sun4i_ts_resume(struct platform_device *pdev)
+{
+    #ifdef PRINT_SUSPEND_INFO
+        printk("enter: sun4i_ts_resume. \n");
+    #endif
+
+    writel(STYLUS_UP_DEBOUNCE|STYLUS_UP_DEBOUCE_EN|TP_DUAL_EN|TP_MODE_EN,TP_BASSADDRESS + TP_CTRL1);
+	return 0;
+}
+#endif
+
+#endif
+
+
+static int  tp_init(void)
+{
+    //struct sun4i_ts_data *ts_data = (struct sun4i_ts_data *)platform_get_drvdata(pdev);
+//    struct sun4i_ts_data *ts_data = mtTsData;
+    //TP_CTRL0: 0x0027003f
+    #ifdef TP_FREQ_DEBUG
+    writel(0x0028001f, TP_BASSADDRESS + TP_CTRL0);
+    #else
+    writel(ADC_CLK_DIVIDER|FS_DIV|T_ACQ, TP_BASSADDRESS + TP_CTRL0);
+    #endif
+    //TP_CTRL2: 0xc4000000
+    if(1 == tp_press_threshold_enable){
+        writel(TP_SENSITIVE_ADJUST |TP_MODE_SELECT | PRE_MEA_EN | PRE_MEA_THRE_CNT, TP_BASSADDRESS + TP_CTRL2);
+    }
+    else{
+        writel(TP_SENSITIVE_ADJUST|TP_MODE_SELECT,TP_BASSADDRESS + TP_CTRL2);
+    }
+
+
+    //TP_CTRL3: 0x05
+    #ifdef TP_FREQ_DEBUG
+    writel(0x06, TP_BASSADDRESS + TP_CTRL3);
+    #else
+    writel(FILTER_EN|FILTER_TYPE,TP_BASSADDRESS + TP_CTRL3);
+    #endif
+
+    #ifdef TP_TEMP_DEBUG
+        //TP_INT_FIFOC: 0x00010313
+        writel(TP_DATA_IRQ_EN|TP_FIFO_TRIG_LEVEL|TP_FIFO_FLUSH|TP_UP_IRQ_EN|TP_DOWN_IRQ_EN|0x40000, TP_BASSADDRESS + TP_INT_FIFOC);
+        writel(0x10fff, TP_BASSADDRESS + TP_TPR);
+    #else
+        //TP_INT_FIFOC: 0x00010313
+        writel(TP_DATA_IRQ_EN|TP_FIFO_TRIG_LEVEL|TP_FIFO_FLUSH|TP_UP_IRQ_EN|TP_DOWN_IRQ_EN, TP_BASSADDRESS + TP_INT_FIFOC);
+    #endif
+    //TP_CTRL1: 0x00000070 -> 0x00000030
+    writel(TP_DATA_XY_CHANGE|STYLUS_UP_DEBOUNCE|STYLUS_UP_DEBOUCE_EN|TP_DUAL_EN|TP_MODE_EN,TP_BASSADDRESS + TP_CTRL1);
+
+
+  /*
+       //put_wvalue(TP_CTRL0 ,0x02a6007f);  //512us TACQ  4ms FS 60 point
+      //put_wvalue(TP_CTRL0 ,0x0aa7003f);
+      put_wvalue(TP_CTRL0 ,0x00a7003f);   //100 point
+      put_wvalue(TP_CTRL1 ,0x00000030);
+      //put_wvalue(TP_INT_FIFOC,0x12f13);
+      put_wvalue(TP_INT_FIFOC,0x10313);
+      //put_wvalue(TP_CTRL2,0x90003e8);
+      //put_wvalue(TP_CTRL2,0x9002710);
+      put_wvalue(TP_CTRL2,0xc4002710);
+      put_wvalue(TP_CTRL3,0x00000005);
+   */
+
+   /*
+    writel(0x00b70100,TP_BASSADDRESS + TP_CTRL0);
+    writel(0xfd000000,TP_BASSADDRESS + TP_CTRL2);
+    writel(0x4,TP_BASSADDRESS + TP_CTRL3);
+    writel(0x10513,TP_BASSADDRESS +TP_INT_FIFOC);
+    writel(0x00005230,TP_BASSADDRESS + TP_CTRL1);*/
+    return (0);
+}
+static void change_to_single_touch_mode(void)
+{
+    touch_mode = SINGLE_TOUCH_MODE;
+    reported_single_point_cnt = 0;
+    return;
+}
+
+static void backup_transfered_data(struct ts_sample_data *sample_data)
+{
+    static int index = 0;
+
+    index = reported_single_point_cnt%TRANSFER_DATA_BUFFER_SIZE;
+    transfer_data_buffer[index].dx = sample_data->dx;
+    transfer_data_buffer[index].dy = sample_data->dy;
+    transfer_data_buffer[index].x = sample_data->x;
+    transfer_data_buffer[index].y = sample_data->y;
+
+    if(reported_single_point_cnt > (TRANSFER_DATA_BUFFER_SIZE<<10)){
+        reported_single_point_cnt -= (TRANSFER_DATA_BUFFER_SIZE<<9);
+    }
+    reported_single_point_cnt++;
+
+    return;
+}
+
+static void report_single_point_implement(struct sun4i_ts_data *ts_data, struct ts_sample_data *sample_data)
+{
+    input_report_abs(ts_data->input, ABS_MT_TOUCH_MAJOR,800);
+    input_report_abs(ts_data->input, ABS_MT_POSITION_X, sample_data->x);
+    input_report_abs(ts_data->input, ABS_MT_POSITION_Y, sample_data->y);
+/*
+    print_report_data_info("report single point: x = %d, y = %d\n                  \
+            sample_data->dx = %d, sample_data->dy = %d. \n",      \
+            sample_data->x, sample_data->y, sample_data->dx, sample_data->dy);
+   */
+    print_report_data_info("report single point: x = %d,sample_data->y = %d. \n", sample_data->x, sample_data->y);
+
+    input_mt_sync(ts_data->input);
+    input_sync(ts_data->input);
+
+    return;
+}
+
+static void report_single_point(struct sun4i_ts_data *ts_data, struct ts_sample_data *sample_data)
+{
+    backup_transfered_data(sample_data);
+    report_single_point_implement(ts_data, sample_data);
+    return;
+}
+
+static void report_slide_data(struct sun4i_ts_data *ts_data)
+{
+    int start = 0;
+    int end = 0;
+#define  MIN_DX   (DUAL_TOUCH*20)
+#define  MIN_DY   (DUAL_TOUCH*20)
+#define  MAX_DX  (DUAL_TOUCH*40)
+#define  MAX_DY  (DUAL_TOUCH*40)
+    int dx = 0;
+    int dy = 0;
+    int ds_times = 4;
+    //index = reported_single_point_cnt%TRANSFER_DATA_BUFFER_SIZE;
+    struct ts_sample_data sample_data;
+
+    //printk("reported_single_point_cnt = %d. \n", reported_single_point_cnt);
+    if(reported_single_point_cnt <= 1){
+        //only one reference point, can not judge direction
+        dx = -MIN_DX;
+        dy = MIN_DY;
+        //dy = 0;
+        end = (reported_single_point_cnt-1)%TRANSFER_DATA_BUFFER_SIZE;
+        sample_data.x = max(0, min(4096, (int)(transfer_data_buffer[end].x + dx)));
+        sample_data.y = max(0, min(4096, (int)(transfer_data_buffer[end].y + dy)));
+        //printk("sample_data.x = %d. sample_data.y = %d. \n", sample_data.x, sample_data.y);
+        report_single_point_implement(ts_data, &sample_data);
+
+        sample_data.x = transfer_data_buffer[end].x;
+        sample_data.y = transfer_data_buffer[end].y;
+        //printk("sample_data.x = %d. sample_data.y = %d. \n", sample_data.x, sample_data.y);
+        //report_single_point_implement(ts_data, &sample_data);
+
+    }else{
+        if(reported_single_point_cnt <=TRANSFER_DATA_BUFFER_SIZE){
+            start = 0;
+        }else{
+            start = reported_single_point_cnt - TRANSFER_DATA_BUFFER_SIZE;
+        }
+        start = start%TRANSFER_DATA_BUFFER_SIZE;
+        end = (reported_single_point_cnt-1)%TRANSFER_DATA_BUFFER_SIZE;
+
+        dx = transfer_data_buffer[end].x -transfer_data_buffer[start].x;
+        dy = transfer_data_buffer[end].y -transfer_data_buffer[start].y;
+        //printk("dx = %d, dy = %d. \n", dx, dy);
+        if(dx < 0){
+            dx = -dx;
+            dx = min(MAX_DX, max(MIN_DX, dx*ds_times/(end - start)));
+            dx = -dx;
+        }else{
+            dx = min(MAX_DX, max(MIN_DX, dx*ds_times/(end - start)));
+        }
+
+        if(dy < 0){
+            dy = -dy;
+            dy = min(MAX_DY, max(MIN_DY, dy*ds_times/(end - start)));
+            dy = -dy;
+        }else{
+            dy = min(MAX_DY, max(MIN_DY, dy*ds_times/(end - start)));
+        }
+
+        //printk("dx = %d, dy = %d. \n", dx, dy);
+        sample_data.x = max(0, min(4096, (int)(transfer_data_buffer[end].x + dx)));
+        sample_data.y = max(0, min(4096, (int)(transfer_data_buffer[end].y + dy)));
+
+        //printk("sample_data.x = %d. sample_data.y = %d. \n", sample_data.x, sample_data.y);
+        report_single_point_implement(ts_data, &sample_data);
+    }
+ }
+
+static void report_up_event_implement(struct sun4i_ts_data *ts_data)
+{
+    static const int UP_EVENT_DELAY_TIME = 3;
+    static const int SLIDE_MIN_CNT = 3;
+    if(atomic_sub_and_test(1, &report_up_event_implement_sync)){
+        //get the resource
+        if(1 == report_up_event_implement_running){
+    		atomic_inc(&report_up_event_implement_sync);
+    		printk("other thread is running the rountine. \n");
+    		return;
+    	}else{
+    		report_up_event_implement_running = 1;
+    		atomic_inc(&report_up_event_implement_sync);
+    	}
+    }else{
+        printk("failed to get the lock. other thread is using the lock. \n");
+    	return;
+    }
+
+    if(0 == data_timer_status){
+        printk("report_up_event_implement have been called. \n");
+        goto report_up_event_implement_out;
+        return;
+    }
+
+    print_report_status_info("enter report_up_event_implement. jiffies == %lu. \n", jiffies);
+
+    //printk("prev_sample->sample_time =%d, prev_data_sample->sample_time = %d. \n", prev_sample->sample_time, prev_data_sample->sample_time);
+    //printk("touch_mode = %d. reported_single_point_cnt = %d. \n", touch_mode, reported_single_point_cnt);
+    if( (SINGLE_TOUCH_MODE == touch_mode) && \
+          (reported_single_point_cnt<SLIDE_MIN_CNT) && (reported_single_point_cnt>0) && \
+          (prev_sample->sample_time >= (prev_data_sample->sample_time + UP_EVENT_DELAY_TIME))){
+        //obvious, a slide, how to compenstate?
+        //printk("report_up_event_implement: obvious, a slide. \n");
+        report_slide_data(ts_data);
+    }
+
+    //note: below operation may be interfere by intterrupt, but it does not matter
+    input_report_abs(ts_data->input, ABS_MT_TOUCH_MAJOR,0);
+    input_sync(ts_data->input);
+    del_timer(&data_timer);
+    data_timer_status = 0;
+    ts_data->ts_process_status = TP_UP;
+    ts_data->double_point_cnt = 0;
+    //ts_data->buffer_head = 0;
+    //ts_data->buffer_tail = 0;
+    ts_data->touchflag = 0;
+    //ts_data->count     = 0;
+    touch_mode = UP_TOUCH_MODE;
+    change_mode = TRUE;
+    reported_single_point_cnt = 0;
+    reported_data_start_time = 0;
+
+report_up_event_implement_out:
+    report_up_event_implement_running = 0;
+
+#ifdef PRINT_UP_SEPARATOR
+    printk("separator: #######%d, %d, %d###########. \n\n\n\n\n\n\n", separator_flag, separator_flag, separator_flag);
+    separator_flag++;
+#endif
+
+    return;
+}
+
+static int judge_zoom_orientation(struct ts_sample_data *sample_data)
+{
+       int dx,dy;
+       int ret = 0;
+       if(1 == reference_point_flag){
+            dx = sample_data->x - prev_single_sample.x;
+            dy = sample_data->y - prev_single_sample.y;
+            if(dx*dy > 0){
+                ret = -1;
+            }else if(dx*dy < 0){
+                ret = 1;
+            }
+       }else{
+            print_orientation_info("judge_zoom_orientation: lack reference point .\n");
+       }
+
+       print_orientation_info("sun4i-ts: orientation_flag == %d . \n", ret);
+       return ret;
+}
+static void filter_double_point_init(struct ts_sample_data *sample_data, int backup_samp_flag)
+{
+       //backup prev_double_sample_data
+       zoom_flag = ZOOM_INIT_STATE;
+        accmulate_zoom_out_ds = 0;
+        zoom_out_count = 0;
+        accmulate_zoom_in_ds = 0;
+        zoom_in_count = 0;
+       //printk("sample_data->x = %d, sample_data-> y = %d. \n", sample_data->x, sample_data->y);
+       if(1 == backup_samp_flag){
+       	memcpy((void*)(&prev_double_sample_data), (void*)sample_data, sizeof(*sample_data));
+       }
+
+       hold_cnt = 0;
+       //when report two point, the first two point will be reserved for reference purpose.
+       return;
+}
+
+static void change_to_double_mode(struct sun4i_ts_data *ts_data)
+{
+        if((CHANGING_TO_DOUBLE_TOUCH_MODE != touch_mode) && \
+            (DOUBLE_TOUCH_MODE != touch_mode)&& \
+            (UP_TOUCH_MODE != touch_mode)){
+            printk("change_to_double_mode: err, not the expected state. touch_mode = %d. \n", touch_mode);
+        }
+        touch_mode = DOUBLE_TOUCH_MODE;
+        change_mode = FALSE;
+        ts_data->single_touch_cnt = 0; //according this counter, change to single touch mode
+        return;
+}
+
+static void change_to_zoom_in(struct sun4i_ts_data *ts_data, struct ts_sample_data *sample_data)
+{
+    zoom_flag = ZOOM_IN;
+    zoom_change_cnt = 0;
+    accmulate_zoom_out_ds = 0;
+    zoom_out_count = 0;
+    //orientation_flag = judge_zoom_orientation(sample_data);
+    change_to_double_mode(ts_data);
+    return;
+}
+
+static void change_to_zoom_out(struct sun4i_ts_data *ts_data, struct ts_sample_data *sample_data)
+{
+    zoom_flag = ZOOM_OUT;
+    zoom_change_cnt = 0;
+    accmulate_zoom_in_ds = 0;
+    zoom_in_count = 0;
+    //orientation_flag = judge_zoom_orientation(sample_data);
+    change_to_double_mode(ts_data);
+    return;
+}
+
+static void filter_zoom_in_data_init(void)
+{
+        zoom_in_buffer_cnt = 0;
+       // zoom_out_buffer_cnt = 0;
+        return;
+}
+
+static void filter_zoom_out_data_init(void)
+{
+//  zoom_in_buffer_cnt = 0;
+        zoom_out_buffer_cnt = 0;
+        return;
+}
+static void filter_zoom_in_data(struct ts_sample_data * report_data, struct ts_sample_data *sample_data)
+{
+    static int i = 0;
+    static int index = 0;
+    static int count = 0;
+    //backup data to filter noise, only when ds < 40, need this operation.
+
+        //printk("before filter zoom in: sample_data->dx = %d, sample_data->dy = %d. \n", sample_data->dx, sample_data->dy);
+        index = zoom_in_buffer_cnt%ZOOM_IN_OUT_BUFFER_SIZE;
+        zoom_in_data_buffer[index].dx = sample_data->dx;
+        zoom_in_data_buffer[index].dy = sample_data->dy;
+        zoom_in_data_buffer[index].x = sample_data->x;
+        zoom_in_data_buffer[index].y = sample_data->y;
+
+        //printk("zoom_in_buffer_cnt quyu  ZOOM_IN_OUT_BUFFER_SIZE = %d. \n", index);
+        if(zoom_in_buffer_cnt > (ZOOM_IN_OUT_BUFFER_SIZE<<10)){
+            zoom_in_buffer_cnt -= (ZOOM_IN_OUT_BUFFER_SIZE<<9);
+        }
+
+        if(zoom_in_buffer_cnt >= ZOOM_IN_OUT_BUFFER_SIZE){
+            index = ZOOM_IN_OUT_BUFFER_SIZE - 1;
+        }
+        //index mean the real count.
+        sample_data->dx = 0;
+        sample_data->dy = 0;
+        sample_data->x = 0;
+        sample_data->y = 0;
+        count = 0;
+        for(i = 0; i <=  index; i++){
+            sample_data->dx += zoom_in_data_buffer[i].dx;
+            sample_data->dy += zoom_in_data_buffer[i].dy;
+            sample_data->x += zoom_in_data_buffer[i].x;
+            sample_data->y += zoom_in_data_buffer[i].y;
+            count++;
+            //printk("i = %d. \n", i);
+        }
+
+        sample_data->dx /= count;
+        sample_data->dy /= count;
+        sample_data->x /= count;
+        sample_data->y /= count;
+
+        report_data->x = sample_data->x;
+        report_data->y = sample_data->y;
+        report_data->dx = sample_data->dx;
+        report_data->dy = sample_data->dy;
+
+        //printk("after filter zoom in: sample_data->dx = %d, sample_data->dy = %d. \n", sample_data->dx, sample_data->dy);
+        zoom_in_buffer_cnt++;
+        //printk("using mean value for nosie reduction: zoom_in_buffer_cnt = %d. \n", zoom_in_buffer_cnt);
+
+        return;
+}
+
+static void filter_zoom_out_data(struct ts_sample_data * report_data, struct ts_sample_data *sample_data)
+{
+    static int i = 0;
+    static int index = 0;
+    static int count = 0;
+    //backup data to filter noise, only when ds < 40, need this operation.
+
+        //printk("before filter zoom out: sample_data->dx = %d, sample_data->dy = %d. \n", sample_data->dx, sample_data->dy);
+        index = zoom_out_buffer_cnt%ZOOM_IN_OUT_BUFFER_SIZE;
+        zoom_out_data_buffer[index].dx = sample_data->dx;
+        zoom_out_data_buffer[index].dy = sample_data->dy;
+        zoom_out_data_buffer[index].x = sample_data->x;
+        zoom_out_data_buffer[index].y = sample_data->y;
+
+        //printk("zoom_out_buffer_cnt quyu  ZOOM_IN_OUT_BUFFER_SIZE = %d. \n", index);
+        if(zoom_out_buffer_cnt > (ZOOM_IN_OUT_BUFFER_SIZE<<10)){
+            zoom_out_buffer_cnt -= (ZOOM_IN_OUT_BUFFER_SIZE<<9);
+        }
+
+        if(zoom_out_buffer_cnt >= ZOOM_IN_OUT_BUFFER_SIZE){
+            index = ZOOM_IN_OUT_BUFFER_SIZE - 1;
+        }
+        //index mean the real count.
+        sample_data->dx = 0;
+        sample_data->dy = 0;
+        sample_data->x = 0;
+        sample_data->y = 0;
+        count = 0;
+
+        for(i = 0; i <=  index; i++){
+            sample_data->dx += zoom_out_data_buffer[i].dx;
+            sample_data->dy += zoom_out_data_buffer[i].dy;
+            sample_data->x += zoom_out_data_buffer[i].x;
+            sample_data->y += zoom_out_data_buffer[i].y;
+            count++;
+            //printk("i = %d. \n", i);
+        }
+
+        sample_data->dx /= count;
+        sample_data->dy /= count;
+        sample_data->x /= count;
+        sample_data->y /= count;
+
+        report_data->x = sample_data->x;
+        report_data->y = sample_data->y;
+        report_data->dx = sample_data->dx;
+        report_data->dy = sample_data->dy;
+
+        //printk("after filter zoom out: sample_data->dx = %d, sample_data->dy = %d. \n", sample_data->dx, sample_data->dy);
+        zoom_out_buffer_cnt++;
+        //printk("using mean value for nosie reduction: zoom_out_buffer_cnt = %d. \n", zoom_out_buffer_cnt);
+
+        return;
+}
+
+static int filter_double_point(struct sun4i_ts_data *ts_data, struct ts_sample_data *sample_data)
+{
+    int ret = 0;
+    static int prev_sample_ds = 0;
+    static int cur_sample_ds = 0;
+    static int delta_ds = 0;
+
+    #define DELTA_DS_LIMIT                               (1)
+    #define HOLD_DS_LIMIT                                 (3)
+    #define ZOOM_IN_CNT_LIMIT                       (3)
+    #define FIRST_ZOOM_IN_COMPENSTATE  (3)                                                      //actually zoom out, usually with zoom in ops first.
+    #define ZOOM_OUT_CNT_LIMIT                   (tp_regidity_level)                             //related with screen's regidity
+    #define GLIDE_DELTA_DS_MAX_TIMES     (4)
+    #define GLIDE_DELTA_DS_MAX_LIMIT     (glide_delta_ds_max_limit)
+
+    if(ZOOM_INIT_STATE == zoom_flag && (0 == zoom_out_count && 0 ==  zoom_in_count)){
+        prev_sample_ds = int_sqrt((prev_double_sample_data.dx)*(prev_double_sample_data.dx) + (prev_double_sample_data.dy)*(prev_double_sample_data.dy));
+        /*printk("sun4i-ts: prev_double_sample_data->x = %d, prev_double_sample_data->y = %d, \
+                   prev_double_sample_data.dx = %d, prev_double_sample_data.dy = %d. \n", \
+       prev_double_sample_data.x, prev_double_sample_data.y, prev_double_sample_data.dx, prev_double_sample_data.dy);
+       */
+    }
+
+    cur_sample_ds = int_sqrt((sample_data->dx)*(sample_data->dx) + (sample_data->dy)*(sample_data->dy));
+    delta_ds = cur_sample_ds - prev_sample_ds;
+    //print_filter_double_point_status_info("delta_ds = %d, prev_sample_ds = %d, cur_sample_ds = %d. \n", delta_ds, prev_sample_ds, cur_sample_ds);
+    /*print_filter_double_point_status_info("zoom_in_count = %d, accmulate_zoom_in_ds = %d, zoom_out_count = %d, accmulate_zoom_out_ds=%d. \n", \
+               zoom_in_count, accmulate_zoom_in_ds, zoom_out_count, accmulate_zoom_out_ds);
+    */
+
+    //update prev_double_sample_data
+    memcpy((void*)&prev_double_sample_data, (void*)sample_data, sizeof(*sample_data));
+    prev_sample_ds = cur_sample_ds;
+    //printk("prev_sample_ds = %d, cur_sample_ds = %d. \n", prev_sample_ds, cur_sample_ds);
+
+    if(delta_ds > HOLD_DS_LIMIT){//zoom in
+
+        if(ZOOM_OUT == zoom_flag){//zoom in when zoom out
+        //printk("delta_ds = %d, (4*accmulate_zoom_out_ds/zoom_out_count) = %d. \n", delta_ds, (GLIDE_DELTA_DS_MAX_TIMES*accmulate_zoom_out_ds/zoom_out_count));
+               if(delta_ds > min(GLIDE_DELTA_DS_MAX_LIMIT, (GLIDE_DELTA_DS_MAX_TIMES*accmulate_zoom_out_ds/zoom_out_count))){
+                //noise
+                    //printk("delta_ds = %d, prev_sample_ds = %d, cur_sample_ds = %d. \n", delta_ds, prev_sample_ds, cur_sample_ds);
+                cur_sample_ds = prev_sample_ds;            //discard the noise, and can not be reference.
+                //printk("delta_ds = %d, (4*accmulate_zoom_out_ds/zoom_out_count) = %d. \n", delta_ds, (4*accmulate_zoom_out_ds/zoom_out_count));
+                print_filter_double_point_status_info("sun4i-ts: noise, zoom in when zoom out. \n");
+                //printk("discard noise. \n");
+                ret = TRUE;
+            }else{
+                //normal zoom in
+                zoom_change_cnt++;
+                accmulate_zoom_in_ds += delta_ds;
+                zoom_in_count++;
+                if(zoom_change_cnt > ZOOM_IN_CNT_LIMIT){
+                    print_filter_double_point_status_info("change to ZOOM_IN from ZOOM_OUT. \n");
+                    change_to_zoom_in(ts_data, sample_data);
+                    filter_zoom_in_data_init();
+                    filter_zoom_in_data(&prev_report_samp, sample_data);
+                }else{
+                    //zoom_change_cnt = 0;
+                    print_filter_double_point_status_info("sun4i-ts: normal zoom in, but this will cause twitter. \n");
+                    ret = TRUE;
+                }
+            }
+             //accmulate_zoom_out_ds -= delta_ds;
+            //zoom_out_count++;
+        }else if(ZOOM_IN == zoom_flag){
+            if(delta_ds > min(GLIDE_DELTA_DS_MAX_LIMIT, (GLIDE_DELTA_DS_MAX_TIMES*accmulate_zoom_in_ds/zoom_in_count))){
+                cur_sample_ds = prev_sample_ds;            //discard the noise, and can not be reference.
+                //printk("discard noise. \n");
+                ret = TRUE;
+            }else{
+                    accmulate_zoom_in_ds += delta_ds;
+                    zoom_in_count++;
+                    filter_zoom_in_data(&prev_report_samp, sample_data);
+            }
+            zoom_change_cnt = 0;
+            accmulate_zoom_out_ds = 0;
+            zoom_out_count = 0;
+             #if 0
+                printk("ZOOM_IN: delta_ds= %d. \n", delta_ds);
+             #endif
+        }else if(ZOOM_INIT_STATE == zoom_flag ||ZOOM_STATIC == zoom_flag){
+           zoom_in_count++;
+           if(zoom_in_count > (ZOOM_CHANGE_LIMIT_CNT + FIRST_ZOOM_IN_COMPENSTATE)){
+                accmulate_zoom_in_ds = delta_ds;
+                zoom_in_count = 1;
+                if(ZOOM_INIT_STATE == zoom_flag){
+                    orientation_flag = judge_zoom_orientation(sample_data);
+                    report_up_event_implement(ts_data);
+                }
+                filter_zoom_in_data_init();
+                filter_zoom_in_data(&prev_report_samp, sample_data);
+                print_filter_double_point_status_info("change to ZOOM_IN from ZOOM_INIT_STATE. \n");
+                change_to_zoom_in(ts_data, sample_data);
+                 #if 1
+                print_filter_double_point_status_info("ZOOM_INIT_STATE: delta_ds= %d. \n", delta_ds);
+                #endif
+           }else{
+                ret = TRUE;
+           }
+
+        }
+    }else if(delta_ds<(-HOLD_DS_LIMIT)){//zoom out
+        delta_ds = -delta_ds;
+
+        if(ZOOM_IN == zoom_flag){//zoom out when zoom in
+            print_filter_double_point_status_info("delta_ds = %d, (4*accmulate_zoom_in_ds/zoom_in_count) = %d. \n", -delta_ds, (4*accmulate_zoom_in_ds/zoom_in_count));
+            if(delta_ds > min(GLIDE_DELTA_DS_MAX_LIMIT, (GLIDE_DELTA_DS_MAX_TIMES*accmulate_zoom_in_ds/zoom_in_count))){ //noise
+            //printk("delta_ds = %d, prev_sample_ds = %d, cur_sample_ds = %d. \n", delta_ds, prev_sample_ds, cur_sample_ds);
+                cur_sample_ds = prev_sample_ds;            //discard the noise, and can not be reference.
+                print_filter_double_point_status_info("sun4i-ts: noise, zoom out when zoom in. \n");
+                //printk("discard noise. \n");
+                //zoom_change_cnt = 0;
+                ret = TRUE;
+            }else{//normal zoom out
+                zoom_change_cnt++;
+                accmulate_zoom_out_ds += delta_ds;
+                zoom_out_count++;
+                if(zoom_change_cnt > ZOOM_OUT_CNT_LIMIT){
+                    print_filter_double_point_status_info("change to ZOOM_OUT from ZOOM_IN. \n");
+                    change_to_zoom_out(ts_data, sample_data);
+                    filter_zoom_out_data_init();
+                    filter_zoom_out_data(&prev_report_samp, sample_data);
+                }else{
+                    //zoom_change_cnt = 0;
+                    print_filter_double_point_status_info("sun4i-ts: normal zoom out, but this will cause twitter. \n");
+                    ret = TRUE;
+                }
+            }
+            //accmulate_zoom_in_ds -= delta_ds;
+            //zoom_in_count++;
+        }else if(ZOOM_OUT == zoom_flag){ //zoom out when zoom out
+            if(delta_ds > min(GLIDE_DELTA_DS_MAX_LIMIT, (GLIDE_DELTA_DS_MAX_TIMES*accmulate_zoom_out_ds/zoom_out_count))){
+                cur_sample_ds = prev_sample_ds;
+                //printk("discard noise. \n");
+                ret = TRUE;
+            }else{
+                accmulate_zoom_out_ds += delta_ds;
+                zoom_out_count++;
+                filter_zoom_out_data(&prev_report_samp, sample_data);
+            }
+            zoom_change_cnt = 0;
+            accmulate_zoom_in_ds = 0;
+            zoom_in_count = 0;
+            //printk("ZOOM_OUT: delta_ds= %d. \n", delta_ds);
+        }else if(ZOOM_INIT_STATE == zoom_flag ||ZOOM_STATIC == zoom_flag){
+            zoom_out_count ++;
+            if(zoom_out_count > ZOOM_CHANGE_LIMIT_CNT){
+                accmulate_zoom_out_ds = delta_ds;
+                zoom_out_count = 1;
+                if(ZOOM_INIT_STATE == zoom_flag){
+                    orientation_flag = judge_zoom_orientation(sample_data);
+                    report_up_event_implement(ts_data);
+                }
+                filter_zoom_out_data_init();
+                filter_zoom_out_data(&prev_report_samp, sample_data);
+                print_filter_double_point_status_info("change to ZOOM_OUT from ZOOM_INIT_STATE. \n");
+                change_to_zoom_out(ts_data, sample_data);
+                #if 1
+                print_filter_double_point_status_info("ZOOM_INIT_STATE: delta_ds= %d. \n", delta_ds);
+                #endif
+            }else{
+                //have not known orientation, discard the point
+                ret = TRUE;
+           }
+
+        }
+
+    }else{    //delta_ds <= HOLD_DS_LIMIT, static mode
+  	 //printk("delta_ds == %d. \n", delta_ds);
+	//zoom_change_cnt
+	//printk("delta_ds == %d. \n", delta_ds);
+	hold_cnt++;
+	cur_sample_ds = prev_sample_ds;
+	if(hold_cnt > 100000){
+            hold_cnt = 100;
+	}
+
+        if(unlikely(ZOOM_INIT_STATE == zoom_flag )){
+       	        print_filter_double_point_status_info("ZOOM_INIT_STATE: delta_ds == %d. \n", delta_ds);
+	    	if(hold_cnt <= ZOOM_CHANGE_LIMIT_CNT){ //discard the first 3 point
+                    ret = TRUE;
+        	}else{
+        	            //when change to static mode, and not know orientation yet, need judge orientation.
+        	            orientation_flag = judge_zoom_orientation(sample_data);
+        	            report_up_event_implement(ts_data);
+        	            zoom_flag = ZOOM_STATIC;
+        	            change_to_double_mode(ts_data);
+                            memcpy((void*)&prev_report_samp, (void*)sample_data, sizeof(*sample_data));
+        	}
+	}else{
+                memcpy((void*)sample_data, (void*)&prev_report_samp, sizeof(*sample_data));
+	}
+
+	//filter_double_point_init(sample_data, 0);
+
+    }
+
+
+    return ret;
+
+}
+static void report_double_point(struct sun4i_ts_data *ts_data, struct ts_sample_data *sample_data)
+{
+	int x1,x2,y1,y2;
+
+	y1 = 0;
+	y2 = 0;
+
+	//int tmp;
+    //tmp = X_TURN_POINT<<2;
+        //printk("enter report_double_point . \n");
+        if(TRUE == filter_double_point(ts_data, sample_data)){ //noise
+            return;
+        }
+
+        //when report double point, need to clear single_touch_cnt
+        ts_data->single_touch_cnt = 0;
+
+	if(sample_data->dx < X_TURN_POINT){
+	    x1 = X_CENTER_COORDINATE - (sample_data->dx<<2);
+        x2 = X_CENTER_COORDINATE + (sample_data->dx<<2);
+	}else{
+        x1 = X_CENTER_COORDINATE - X_COMPENSATE - ((sample_data->dx) - X_TURN_POINT);
+        x2 = X_CENTER_COORDINATE + X_COMPENSATE + ((sample_data->dx) - X_TURN_POINT);
+	}
+#ifdef FIX_ORIENTATION
+    orientation_flag = ORIENTATION_DEFAULT_VAL;
+#endif
+
+    //printk("X_TURN_POINT is %d. \n", tmp);
+       if(0 == orientation_flag){
+        print_orientation_info("orientation_flag: orientation is not supported or have not known, set the default orientation. \n");
+        orientation_flag = ORIENTATION_DEFAULT_VAL;
+       }
+
+       if(-1 == orientation_flag){
+        	if(sample_data->dy < Y_TURN_POINT){
+                y1 = Y_CENTER_COORDINATE - (sample_data->dy<<1);
+                y2 = Y_CENTER_COORDINATE + (sample_data->dy<<1);
+
+        	}else{
+                y1 = Y_CENTER_COORDINATE - Y_COMPENSATE - (sample_data->dy - Y_TURN_POINT);
+                y2 = Y_CENTER_COORDINATE + Y_COMPENSATE + (sample_data->dy - Y_TURN_POINT);
+        	}
+
+       }else if(1 == orientation_flag){
+        	if(sample_data->dy < Y_TURN_POINT){
+                y2 = Y_CENTER_COORDINATE - (sample_data->dy<<1);
+                y1 = Y_CENTER_COORDINATE + (sample_data->dy<<1);
+
+        	}else{
+                y2 = Y_CENTER_COORDINATE - Y_COMPENSATE - (sample_data->dy - Y_TURN_POINT);
+                y1 = Y_CENTER_COORDINATE + Y_COMPENSATE + (sample_data->dy - Y_TURN_POINT);
+        	}
+       }
+
+        input_report_abs(ts_data->input, ABS_MT_TOUCH_MAJOR,800);
+	input_report_abs(ts_data->input, ABS_MT_POSITION_X, x1);
+	input_report_abs(ts_data->input, ABS_MT_POSITION_Y, y1);
+	input_mt_sync(ts_data->input);
+
+	input_report_abs(ts_data->input, ABS_MT_TOUCH_MAJOR,800);
+	input_report_abs(ts_data->input, ABS_MT_POSITION_X, x2);
+	input_report_abs(ts_data->input, ABS_MT_POSITION_Y, y2);
+	input_mt_sync(ts_data->input);
+	input_sync(ts_data->input);
+
+    print_report_data_info("report two point: x1 = %d, y1 = %d; x2 = %d, y2 = %d. \n",x1, y1, x2, y2);
+    print_report_data_info("sample_data->dx = %d, sample_data->dy = %d. \n", sample_data->dx, sample_data->dy);
+
+
+    return;
+}
+
+static void report_data(struct sun4i_ts_data *ts_data, struct ts_sample_data *sample_data)
+{
+    //printk("calling report data. \n");
+    if(TRUE == change_mode){                 //only up event happened, change_mode is allowed.
+        printk("err: report_data: never execute. \n ");
+        ts_data->single_touch_cnt++;
+        if(ts_data->single_touch_cnt > UP_TO_SINGLE_CNT_LIMIT){
+            //change to single touch mode
+            change_to_single_touch_mode();
+            report_single_point(ts_data, sample_data);
+            print_report_data_info("change touch mode to SINGLE_TOUCH_MODE from UP state. \n");
+
+        }
+    }else if(FALSE == change_mode){
+          //keep in double touch mode
+        //remain in double touch mode
+        ts_data->single_touch_cnt++;
+        if(ts_data->single_touch_cnt > SINGLE_CNT_LIMIT){       //to avoid unconsiously touch
+            //change to single touch mode
+            change_to_single_touch_mode();
+            report_single_point(ts_data, sample_data);
+
+            print_report_data_info("change touch mode to SINGLE_TOUCH_MODE from double_touch_mode. \n");
+
+        }
+    }
+
+    return;
+}
+
+static void report_up_event(unsigned long data)
+{
+    struct sun4i_ts_data *ts_data = (struct sun4i_ts_data *)data;
+
+    /*when the time is out, and the buffer data can not affect the timer to re-timing immediately,
+        *this will happen,
+        *from this we can conclude, the delay_time is not proper, need to be longer
+        */
+    if(ts_data->buffer_head != ts_data->buffer_tail){
+        //printk("warn: when report_up_event, the buffer is not empty. clear the buffer.\n");
+        //printk("ts_data->buffer_head = %lu,  ts_data->buffer_tail = %lu \n", ts_data->buffer_head, ts_data->buffer_tail);
+        //ts_data->buffer_tail = ts_data->buffer_head;
+        //do not discard the data, just let the tasklet to take care of it.
+        mod_timer(&data_timer, jiffies + ts_data->ts_delay_period);
+        tp_do_tasklet(ts_data->buffer_head); //direct calling tasklet, do not use int bottom half, may result in some bad behavior.!!!
+        return;
+    }
+
+    report_up_event_implement(ts_data);
+    return;
+}
+
+static void process_data(struct sun4i_ts_data *ts_data, struct ts_sample_data *sample_data)
+{
+    //printk("enter process_data. \n");
+    ts_data->touchflag = 1;
+    if(((sample_data->dx) > DUAL_TOUCH)&&((sample_data->dy) > DUAL_TOUCH)){
+        ts_data->touchflag = 2;
+        ts_data->double_point_cnt++;
+        if(UP_TOUCH_MODE == touch_mode ){
+            print_orientation_info("sun4i-ts: need to get the single point. \n");
+            //the direction should be the default value;
+           /*prev_single_sample.x = sample_data->x;
+            prev_single_sample.y = sample_data->y;
+           */
+           reference_point_flag = 0;
+           touch_mode = SINGLE_TOUCH_MODE;
+        }
+        //printk("ts_data->double_point_cnt is %d. \n", ts_data->double_point_cnt);
+        if(ts_data->double_point_cnt > DOUBLE_CNT_LIMIT){
+            if(sample_data->dx < MAX_DELTA_X && sample_data->dy < MAX_DELTA_Y){
+                    //ts_data->count = 0;
+                    if(SINGLE_TOUCH_MODE == touch_mode){
+                        touch_mode = CHANGING_TO_DOUBLE_TOUCH_MODE;
+                        orientation_flag = 0;
+                        filter_double_point_init(sample_data, 1);
+                        print_orientation_info("sun4i-ts: CHANGING_TO_DOUBLE_TOUCH_MODE orientation_flag == %d . \n", orientation_flag);
+                        return;
+                    }
+                    report_double_point(ts_data, sample_data);
+            }
+        }
+
+    }else  if(1 == ts_data->touchflag){
+           if(DOUBLE_TOUCH_MODE == touch_mode ){
+           //normally, to really change to single_touch_mode, spend about 100ms
+                //printk("receive 1 point when in DOUBLE_TOUCH_MODE, ts_data->single_touch_cnt  = %d. \n", ts_data->single_touch_cnt);
+                if(6 == ts_data->single_touch_cnt ){ //discard old data, remain in double_touch_mode,and change to ZOOM_INIT_STATE
+                    filter_zoom_in_data_init();
+                    filter_zoom_out_data_init();
+                    prev_single_sample.x = sample_data->x;
+                     prev_single_sample.y = sample_data->y;
+                     reference_point_flag = 1;
+                     orientation_flag = 0;
+                     filter_double_point_init(sample_data, 0);
+                }else if(ts_data->single_touch_cnt > 6){ //update prev_single_sample
+                     prev_single_sample.x = sample_data->x;
+                     prev_single_sample.y = sample_data->y;
+                     reference_point_flag = 1;
+                }
+                 report_data(ts_data, sample_data);
+           }else if(SINGLE_TOUCH_MODE == touch_mode  ||UP_TOUCH_MODE == touch_mode  || CHANGING_TO_DOUBLE_TOUCH_MODE == touch_mode){//remain in single touch mode
+                if(SINGLE_TOUCH_MODE == touch_mode  ||UP_TOUCH_MODE == touch_mode){
+                    prev_single_sample.x = sample_data->x;
+                     prev_single_sample.y = sample_data->y;
+                     reference_point_flag = 1;
+                }
+                 if(SINGLE_TOUCH_MODE != touch_mode){
+                    change_to_single_touch_mode();
+                 }
+
+                 report_single_point(ts_data, sample_data);
+           }
+    }
+
+    return;
+
+}
+
+
+
+void tp_do_tasklet(unsigned long data)
+{
+    //struct sun4i_ts_data *ts_data = (struct sun4i_ts_data *)platform_get_drvdata(pdev);
+
+	struct sun4i_ts_data *ts_data = mtTsData;
+	struct ts_sample_data *sample_data;
+	int head = 0;
+	int tail = 0;
+
+	//printk("try to get the lock and setting the running state. \n");
+    if(1 == spin_trylock(&tp_do_tasklet_sync)){
+    	if(1 == tp_do_tasklet_running){
+    		spin_unlock(&tp_do_tasklet_sync);
+    		//printk("other thread is running the rountine. \n");
+    		return;
+    	}else{
+    		tp_do_tasklet_running = 1;
+    		spin_unlock(&tp_do_tasklet_sync);
+    	}
+    }else{
+        //printk("failed to get the lock. other thread is using the lock. \n");
+    	return;
+    }
+   // printk("get the lock, the running state is setted. to use the data. \n");
+    head = (int)data;
+    tail = (int)ts_data->buffer_tail; //!!! tail may have changed, while the data is remain?
+
+    if((tail + CYCLE_BUFFER_SIZE*2) < head){ //tail have been modify to avoid overflow
+        goto out;
+    }
+
+    print_tasklet_info("enter tasklet. head = %d, tail = %d. jiffies == %lu. \n", head, tail, jiffies);
+
+    while((tail) < (head)){ //when tail == head, mean the buffer is empty
+        sample_data = &cycle_buffer[tail&(CYCLE_BUFFER_SIZE-1)];
+        tail++;
+        print_filter_info("sample_data->sample_status == %d, ts_data->ts_process_status == %d \n", \
+                           sample_data->sample_status, ts_data->ts_process_status);
+
+        #ifdef TP_INT_PERIOD_TEST
+        continue;
+        #endif
+        if(TP_UP == sample_data->sample_status || TP_DOWN == sample_data->sample_status)
+        {
+            //when received up & down event, reinitialize ts_data->double_point_cnt to debounce for DOUBLE_TOUCH_MODE
+            ts_data->double_point_cnt = 0;
+
+            if((TP_DATA_VA == ts_data->ts_process_status || TP_DOWN == ts_data->ts_process_status) && data_timer_status){
+                //delay   20ms , ignore up event & down event
+                print_filter_info("(prev_sample->sample_time + ts_data->ts_delay_period) == %u, \
+                        (sample_data->sample_time) == %u. \n", \
+                        (prev_sample->sample_time + ts_data->ts_delay_period), \
+                        (sample_data->sample_time));
+                print_filter_info("up or down: sample_data->sample_time = %lu.sample_data->sample_status = %d \n", sample_data->sample_time, sample_data->sample_status);
+                if(time_after_eq((unsigned long)(prev_sample->sample_time + ts_data->ts_delay_period - DELAY_COMPENSTAE_PEROID), (unsigned long)(sample_data->sample_time))){
+                    //notice: sample_time may overflow
+                    print_filter_info("ignore up event & down event. \n");
+                    mod_timer(&data_timer, jiffies + ts_data->ts_delay_period);
+                    prev_sample->sample_time = sample_data->sample_time;
+                    continue;
+                }
+
+            }
+        }
+
+      	switch(sample_data->sample_status)
+      	{
+      		case TP_DOWN:
+      		{
+    			if(1 == data_timer_status){
+                                report_up_event_implement(ts_data);
+    			}
+    			ts_data->touchflag = 0;
+    			//ts_data->count     = 0;
+    			ts_data->ts_process_status = TP_DOWN;
+    			ts_data->double_point_cnt = 0;
+    			prev_sample->sample_time = sample_data->sample_time;
+    			reported_data_start_time = sample_data->sample_time;
+    			print_report_status_info("actuall TP_DOWN . \n");
+      			break;
+      		}
+      		case TP_DATA_VA:
+      		{
+      		    //memcpy(prev_sample, sample_date, sizeof(ts_sample_data));
+      		    print_filter_info("data: sample_data->sample_time = %lu. \n", sample_data->sample_time);
+      		    prev_data_sample->sample_time = sample_data->sample_time;
+      		    prev_sample->sample_time = sample_data->sample_time;
+                process_data(ts_data, sample_data);
+                if(0 == data_timer_status){
+                    mod_timer(&data_timer, jiffies + ts_data->ts_delay_period);
+                    data_timer_status = 1;
+                    prev_data_sample->x = sample_data->x;
+                    prev_data_sample->y = sample_data->y;
+
+                    print_report_status_info("timer is start up. \n");
+                }else{
+                    mod_timer(&data_timer, jiffies + ts_data->ts_delay_period);
+                    print_report_status_info("more ts_data->ts_delay_period ms delay. jiffies + ts_data->ts_delay_period = %lu. \n", jiffies + ts_data->ts_delay_period);
+                }
+                ts_data->ts_process_status = TP_DATA_VA;
+      			break;
+      		}
+      		case TP_UP :
+        	{
+        	    //actually, this case will never be run
+        	    if(1 == ts_data->touchflag || 2 == ts_data->touchflag)
+        	    {
+        	        print_report_status_info("actually TP_UP. \n");
+                    //ts_data->touchflag = 0;
+                    //ts_data->count     = 0;
+                    //touch_mode = SINGLE_TOUCH_MODE;
+                    //change_mode = TRUE;
+                    //ts_data->ts_process_status = TP_UP;
+                    report_up_event((unsigned long)ts_data);
+
+
+        	    }
+    		    break;
+      		}
+
+    		default:
+      			break;
+
+      	}
+    }
+    //update buffer_tail
+    ts_data->buffer_tail = (unsigned long)tail;
+
+    //avoid overflow
+    if(ts_data->buffer_tail > (CYCLE_BUFFER_SIZE << 4)){
+        writel(0, ts_data->base_addr + TP_INT_FIFOC);         //disable irq
+
+        ts_data->buffer_tail -= (CYCLE_BUFFER_SIZE<<3);
+        ts_data->buffer_head -= (CYCLE_BUFFER_SIZE<<3);        //head may have been change by interrupt
+
+        if(TRUE == tp_irq_state){
+            //enable irq
+            writel(TP_DATA_IRQ_EN|TP_FIFO_TRIG_LEVEL|TP_FIFO_FLUSH|TP_UP_IRQ_EN|TP_DOWN_IRQ_EN, ts_data->base_addr + TP_INT_FIFOC);
+        }
+    }
+
+    if(FALSE == tp_irq_state){
+        //enable irq
+        writel(TP_DATA_IRQ_EN|TP_FIFO_TRIG_LEVEL|TP_FIFO_FLUSH|TP_UP_IRQ_EN|TP_DOWN_IRQ_EN, ts_data->base_addr + TP_INT_FIFOC);
+        tp_irq_state = TRUE;
+    }
+out:
+    tp_do_tasklet_running = 0;
+    //printk("after using the cycle buffer. \n");
+
+}
+
+static irqreturn_t sun4i_isr_tp(int irq, void *dev_id)
+{
+	struct platform_device *pdev = dev_id;
+	struct sun4i_ts_data *ts_data = (struct sun4i_ts_data *)platform_get_drvdata(pdev);
+
+	unsigned int reg_val;
+	unsigned int reg_fifoc;
+    int head_index = (int)(ts_data->buffer_head&(CYCLE_BUFFER_SIZE-1));
+    int tail = (int)ts_data->buffer_tail;
+
+#ifdef TP_INT_PERIOD_TEST
+	static int count = 0;
+#endif
+
+#ifdef TP_TEMP_DEBUG
+static unsigned int temp_cnt = 0;
+static unsigned int temp_data = 0;
+#define TOTAL_TIMES            4
+#endif
+
+	reg_val  = readl(TP_BASSADDRESS + TP_INT_FIFOS);
+	if(!(reg_val&(TP_DOWN_PENDING | FIFO_DATA_PENDING | TP_UP_PENDING))){
+	    //printk("non tp irq . \n");
+	    #ifdef TP_TEMP_DEBUG
+	    if(reg_val&0x40000)
+		{
+		    writel(reg_val&0x40000,TP_BASSADDRESS + TP_INT_FIFOS);
+			reg_val = readl(TP_BASSADDRESS + TEMP_DATA);
+			if(temp_cnt < (TOTAL_TIMES - 1))
+			{
+				temp_data += reg_val;
+				temp_cnt++;
+			}else{
+				  temp_data += reg_val;
+				  temp_data /= TOTAL_TIMES;
+				  printk("temp = ");
+				  printk("%d\n",temp_data);
+				  temp_data = 0;
+				  temp_cnt  = 0;
+			}
+
+			return IRQ_HANDLED;
+		}
+	    #endif
+
+        return IRQ_NONE;
+	}
+
+	if(((tail+CYCLE_BUFFER_SIZE)) <= (ts_data->buffer_head)){ //when head-tail == CYCLE_BUFFER_SIZE, mean the buffer is full.
+        printk("warn: cycle buffer is full. \n");
+        //ts_data->buffer_tail++; //ignore one point, increment tail is danger, when tasklet is using the tail.
+        writel(0, ts_data->base_addr + TP_INT_FIFOC); //disable irq
+        tp_irq_state = FALSE;
+        writel(reg_val,TP_BASSADDRESS + TP_INT_FIFOS); //clear irq pending
+
+        tp_tasklet.data = ts_data->buffer_head;
+        printk("schedule tasklet. ts_data->buffer_head = %lu, \
+                ts_data->buffer_tail = %lu.\n", ts_data->buffer_head, ts_data->buffer_tail);
+
+        tasklet_schedule(&tp_tasklet);
+        return IRQ_HANDLED;
+	}
+
+	if(reg_val&TP_DOWN_PENDING)
+	{
+		writel(reg_val&TP_DOWN_PENDING,TP_BASSADDRESS + TP_INT_FIFOS);
+	    print_int_info("press the screen: jiffies to ms == %u , jiffies == %lu, time: = %llu \n", \
+	           jiffies_to_msecs((long)get_jiffies_64()), jiffies, get_cpu_idle_time_us(0, &cur_wall_time));
+
+		ts_data->ts_sample_status = TP_DOWN;
+		ts_data->count  = 0;
+		cycle_buffer[head_index].sample_status = TP_DOWN;
+		cycle_buffer[head_index].sample_time= jiffies;
+		//update buffer_head
+	    ts_data->buffer_head++;
+	    #ifdef TP_INT_PERIOD_TEST
+	        count = 0;
+	    #endif
+
+	}else if(reg_val&FIFO_DATA_PENDING)        //do not report data on up status
+	{
+	   // if((TP_DOWN == ts_data->ts_sample_status || TP_DATA_VA == ts_data->ts_sample_status)){
+            ts_data->count++;
+            if(ts_data->count > FILTER_NOISE_LOWER_LIMIT){
+                cycle_buffer[head_index].x      = readl(TP_BASSADDRESS + TP_DATA);
+                cycle_buffer[head_index].y      = readl(TP_BASSADDRESS + TP_DATA);
+                cycle_buffer[head_index].dx     = readl(TP_BASSADDRESS + TP_DATA);
+                cycle_buffer[head_index].dy     = readl(TP_BASSADDRESS + TP_DATA);
+                cycle_buffer[head_index].sample_time= jiffies;
+                //ts_data->z1     = readl(TP_BASSADDRESS + TP_DATA);
+                //ts_data->z2     = readl(TP_BASSADDRESS + TP_DATA);
+                cycle_buffer[head_index].sample_status = TP_DATA_VA;
+                ts_data->ts_sample_status = TP_DATA_VA;
+                //flush fifo
+                reg_fifoc = readl(ts_data->base_addr+TP_INT_FIFOC);
+                reg_fifoc |= TP_FIFO_FLUSH;
+                writel(reg_fifoc, ts_data->base_addr+TP_INT_FIFOC);
+
+    		    print_int_info("data coming, jiffies to ms == %u , jiffies == %lu, time: = %llu \n", \
+		           jiffies_to_msecs((long)get_jiffies_64()), jiffies, get_cpu_idle_time_us(0, &cur_wall_time));
+
+                //update buffer_head
+                ts_data->buffer_head++;
+                #ifdef TP_INT_PERIOD_TEST
+                    count++;
+                    printk("jiffies = %d. count = %d. \n", jiffies, count);
+                #endif
+
+            }else{
+                //flush fifo, the data you do not want to reserved, need to be flush out fifo
+                reg_fifoc = readl(ts_data->base_addr+TP_INT_FIFOC);
+                reg_fifoc |= TP_FIFO_FLUSH;
+                writel(reg_fifoc, ts_data->base_addr+TP_INT_FIFOC);
+            }
+            udelay(1);
+            writel(reg_val&FIFO_DATA_PENDING,TP_BASSADDRESS + TP_INT_FIFOS);
+
+	   /* }else{ //INITIAL or UP
+
+    printk("err: data int when tp up. jiffies to ms == %u ,  jiffies == %llu, time: = %llu \n", \
+		           jiffies_to_msecs((long)get_jiffies_64()), jiffies,  get_cpu_idle_time_us(0, &cur_wall_time));
+
+	        //writel(TP_DATA_IRQ_EN|TP_FIFO_TRIG_LEVEL|TP_FIFO_FLUSH|TP_UP_IRQ_EN|TP_DOWN_IRQ_EN, ts_data->base_addr + TP_INT_FIFOC);
+	        writel(TP_DATA_IRQ_EN|TP_FIFO_TRIG_LEVEL|TP_FIFO_FLUSH|TP_UP_IRQ_EN|TP_DOWN_IRQ_EN, ts_data->base_addr+TP_INT_FIFOC);
+            writel(reg_val&FIFO_DATA_PENDING,TP_BASSADDRESS + TP_INT_FIFOS);
+            return IRQ_HANDLED;
+	    }*/
+
+    }else if(reg_val&TP_UP_PENDING)	{
+	        writel(reg_val&TP_UP_PENDING,TP_BASSADDRESS + TP_INT_FIFOS);
+	        print_int_info("up the screen. jiffies to ms == %u ,  jiffies == %lu,  time: = %llu \n", \
+	                   jiffies_to_msecs((long)get_jiffies_64()), jiffies, get_cpu_idle_time_us(0, &cur_wall_time));
+
+	        cycle_buffer[head_index].sample_status = TP_UP;
+	        ts_data->count  = 0;
+	        cycle_buffer[head_index].sample_time= jiffies;
+	        //update buffer_head
+	        ts_data->buffer_head++;
+
+	}
+
+    tp_tasklet.data = ts_data->buffer_head;
+    //print_tasklet_info("schedule tasklet. ts_data->buffer_head = %lu, ts_data->buffer_tail = %lu\n", ts_data->buffer_head, ts_data->buffer_tail);
+	tasklet_schedule(&tp_tasklet);
+	return IRQ_HANDLED;
+}
+
+static int sun4i_ts_open(struct input_dev *dev)
+{
+	/* enable clock */
+	return 0;
+}
+
+static void sun4i_ts_close(struct input_dev *dev)
+{
+	/* disable clock */
+}
+
+
+
+
+static struct sun4i_ts_data *sun4i_ts_data_alloc(struct platform_device *pdev)
+{
+
+	struct sun4i_ts_data *ts_data = kzalloc(sizeof(*ts_data), GFP_KERNEL);
+
+	if (!ts_data)
+		return NULL;
+
+	ts_data->input = input_allocate_device();
+	if (!ts_data->input) {
+		kfree(ts_data);
+		return NULL;
+	}
+
+
+	ts_data->input->evbit[0] =  BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);
+	set_bit(BTN_TOUCH, ts_data->input->keybit);
+
+    input_set_abs_params(ts_data->input, ABS_MT_TOUCH_MAJOR, 0, 1000, 0, 0);
+    input_set_abs_params(ts_data->input, ABS_MT_POSITION_X, 0, 4095, 0, 0);
+    input_set_abs_params(ts_data->input, ABS_MT_POSITION_Y, 0, 4095, 0, 0);
+
+
+	ts_data->input->name = pdev->name;
+	ts_data->input->phys = "sun4i_ts/input0";
+	ts_data->input->id.bustype = BUS_HOST ;
+	ts_data->input->id.vendor = 0x0001;
+	ts_data->input->id.product = 0x0001;
+	ts_data->input->id.version = 0x0100;
+
+	ts_data->input->open = sun4i_ts_open;
+	ts_data->input->close = sun4i_ts_close;
+	ts_data->input->dev.parent = &pdev->dev;
+	ts_data->ts_sample_status = TP_INITIAL;
+	ts_data->ts_process_status = TP_INITIAL;
+	ts_data->double_point_cnt = 0;
+	ts_data->single_touch_cnt = 0;
+	ts_data->ts_delay_period = DELAY_PERIOD  + DELAY_COMPENSTAE_PEROID;
+
+	ts_data->buffer_head = 0;
+	ts_data->buffer_tail = 0;
+
+
+
+	return ts_data;
+}
+
+
+
+
+static void sun4i_ts_data_free(struct sun4i_ts_data *ts_data)
+{
+	if (!ts_data)
+		return;
+	if (ts_data->input)
+		input_free_device(ts_data->input);
+	kfree(ts_data);
+}
+
+
+static int __devinit sun4i_ts_probe(struct platform_device *pdev)
+{
+	int err =0;
+	int irq = platform_get_irq(pdev, 0);
+	struct sun4i_ts_data *ts_data;
+	tp_flag = 0;
+
+    #ifdef CONFIG_TOUCHSCREEN_SUN4I_DEBUG
+	    printk( "sun4i-ts.c: sun4i_ts_probe: start...\n");
+	#endif
+
+	ts_data = sun4i_ts_data_alloc(pdev);
+	if (!ts_data) {
+		dev_err(&pdev->dev, "Cannot allocate driver structures\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	mtTsData = ts_data;
+
+	//tp_do_tasklet_running = ATOMIC_INIT(1);
+	spin_lock_init(&tp_do_tasklet_sync);
+	//report_up_event_implement_sync = ATOMIC_INIT(1);
+
+	#ifdef CONFIG_TOUCHSCREEN_SUN4I_DEBUG
+	    printk("begin get platform resourec\n");
+    #endif
+
+	ts_data->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!ts_data->res) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "Can't get the MEMORY\n");
+		goto err_out1;
+	}
+
+    ts_data->base_addr = (void __iomem *)TP_BASSADDRESS;
+
+	ts_data->irq = irq;
+	//tp_irq = irq;
+
+	err = request_irq(irq, sun4i_isr_tp,
+		IRQF_DISABLED, pdev->name, pdev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot request keypad IRQ\n");
+		goto err_out2;
+	}
+
+
+	platform_set_drvdata(pdev, ts_data);
+
+	//printk("Input request \n");
+	/* All went ok, so register to the input system */
+	err = input_register_device(ts_data->input);
+	if (err)
+		goto err_out3;
+
+	#ifdef CONFIG_TOUCHSCREEN_SUN4I_DEBUG
+        printk("tp init\n");
+    #endif
+
+    tp_init();
+
+    #ifdef CONFIG_TOUCHSCREEN_SUN4I_DEBUG
+	    printk( "sun4i-ts.c: sun4i_ts_probe: end\n");
+    #endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    printk("==register_early_suspend =\n");
+    ts_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    ts_data->early_suspend.suspend = sun4i_ts_suspend;
+    ts_data->early_suspend.resume	= sun4i_ts_resume;
+    register_early_suspend(&ts_data->early_suspend);
+#endif
+
+    init_timer(&data_timer);
+    data_timer.expires = jiffies + ts_data->ts_delay_period;
+    data_timer.data = (unsigned long)ts_data;
+    data_timer.function = report_up_event;
+
+    prev_sample = kzalloc(sizeof(*prev_sample), GFP_KERNEL);
+    prev_data_sample = kzalloc(sizeof(*prev_data_sample), GFP_KERNEL);
+
+    return 0;
+
+ err_out3:
+	if (ts_data->irq)
+		free_irq(ts_data->irq, pdev);
+err_out2:
+err_out1:
+	sun4i_ts_data_free(ts_data);
+err_out:
+    #ifdef CONFIG_TOUCHSCREEN_SUN4I_DEBUG
+	    printk( "sun4i-ts.c: sun4i_ts_probe: failed!\n");
+	#endif
+
+	return err;
+}
+
+static int __devexit sun4i_ts_remove(struct platform_device *pdev)
+{
+
+	struct sun4i_ts_data *ts_data = platform_get_drvdata(pdev);
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	    unregister_early_suspend(&ts_data->early_suspend);
+	#endif
+	input_unregister_device(ts_data->input);
+	free_irq(ts_data->irq, pdev);
+	sun4i_ts_data_free(ts_data);
+	platform_set_drvdata(pdev, NULL);
+        //cancle tasklet?
+	return 0;
+}
+
+
+static struct platform_driver sun4i_ts_driver = {
+	.probe		= sun4i_ts_probe,
+	.remove		= __devexit_p(sun4i_ts_remove),
+#ifdef CONFIG_HAS_EARLYSUSPEND
+
+#else
+#ifdef CONFIG_PM
+	.suspend	= sun4i_ts_suspend,
+	.resume		= sun4i_ts_resume,
+#endif
+#endif
+	.driver		= {
+		.name	= "sun4i-ts",
+	},
+};
+
+
+static void sun4i_ts_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+static struct resource sun4i_ts_resource[] = {
+	{
+	.flags  = IORESOURCE_IRQ,
+	.start  = IRQ_TP ,
+	.end    = IRQ_TP ,
+	},
+
+	{
+	.flags	= IORESOURCE_MEM,
+	.start	= TP_BASSADDRESS,
+	.end	= TP_BASSADDRESS + 0x100-1,
+	},
+};
+
+struct platform_device sun4i_ts_device = {
+	.name		= "sun4i-ts",
+	.id		    = -1,
+	.dev = {
+		.release = sun4i_ts_nop_release,
+		},
+	.resource	= sun4i_ts_resource,
+	.num_resources	= ARRAY_SIZE(sun4i_ts_resource),
+};
+
+
+static int __init sun4i_ts_init(void)
+{
+  int device_used = 0;
+  int ret = -1;
+  //get the config para
+  int tp_screen_size = 0;
+
+#ifdef CONFIG_TOUCHSCREEN_SUN4I_DEBUG
+	    printk("sun4i-ts.c: sun4i_ts_init: start ...\n");
+#endif
+
+	//config rtp
+	if(SCRIPT_PARSER_OK != script_parser_fetch("rtp_para", "rtp_used", &device_used, sizeof(device_used)/sizeof(int))){
+	    pr_err("sun4i_ts_init: script_parser_fetch err. \n");
+	    goto script_parser_fetch_err;
+	}
+	printk("rtp_used == %d. \n", device_used);
+	if(1 == device_used){
+		if(SCRIPT_PARSER_OK != script_parser_fetch("rtp_para", "rtp_screen_size", &tp_screen_size, 1)){
+	        pr_err("sun4i_ts_init: script_parser_fetch err. \n");
+	        goto script_parser_fetch_err;
+	    }
+	    printk("sun4i-ts: tp_screen_size is %d inch.\n", tp_screen_size);
+	    if(7 == tp_screen_size){
+                dual_touch_distance = 20;
+                glide_delta_ds_max_limit = 90;
+                tp_regidity_level = 7;
+      }else if(5 == tp_screen_size){
+          dual_touch_distance = 35;
+          glide_delta_ds_max_limit = 150;
+          tp_regidity_level = 5;
+      }else{
+          pr_err("sun4i-ts: tp_screen_size is not supported. \n");
+          goto script_parser_fetch_err;
+      }
+
+            if(SCRIPT_PARSER_OK != script_parser_fetch("rtp_para", "rtp_regidity_level", &tp_regidity_level, 1)){
+                pr_err("sun4i_ts_init: script_parser_fetch err rtp_regidity_level. \n");
+                goto script_parser_fetch_err;
+            }
+            printk("sun4i-ts: tp_regidity_level is %d.\n", tp_regidity_level);
+
+            if(tp_regidity_level < 2 || tp_regidity_level > 10){
+                printk("sun4i-ts: only tp_regidity_level between 2 and 10  is supported. \n");
+                goto script_parser_fetch_err;
+            }
+
+            if(SCRIPT_PARSER_OK != script_parser_fetch("rtp_para", "rtp_press_threshold_enable", &tp_press_threshold_enable, 1)){
+                pr_err("sun4i_ts_init: script_parser_fetch err rtp_press_threshold_enable. \n");
+                goto script_parser_fetch_err;
+            }
+            printk("sun4i-ts: tp_press_threshold_enable is %d.\n", tp_press_threshold_enable);
+
+            if(0 != tp_press_threshold_enable  && 1 != tp_press_threshold_enable){
+                printk("sun4i-ts: only tp_press_threshold_enable  0 or 1  is supported. \n");
+                goto script_parser_fetch_err;
+            }
+
+            if(1 == tp_press_threshold_enable){
+                if(SCRIPT_PARSER_OK != script_parser_fetch("rtp_para", "rtp_press_threshold", &tp_press_threshold, 1)){
+                    pr_err("sun4i_ts_init: script_parser_fetch err rtp_press_threshold. \n");
+                    goto script_parser_fetch_err;
+                }
+                printk("sun4i-ts: rtp_press_threshold is %d.\n", tp_press_threshold);
+
+                if(tp_press_threshold < 0 || tp_press_threshold > 0xFFFFFF){
+                    printk("sun4i-ts: only tp_regidity_level between 0 and 0xFFFFFF  is supported. \n");
+                    goto script_parser_fetch_err;
+                }
+            }
+
+            if(SCRIPT_PARSER_OK != script_parser_fetch("rtp_para", "rtp_sensitive_level", &tp_sensitive_level, 1)){
+                pr_err("sun4i_ts_init: script_parser_fetch err rtp_sensitive_level. \n");
+                goto script_parser_fetch_err;
+            }
+            printk("sun4i-ts: rtp_sensitive_level is %d.\n", tp_sensitive_level);
+
+            if(tp_sensitive_level < 0 || tp_sensitive_level > 0xf){
+                printk("sun4i-ts: only tp_regidity_level between 0 and 0xf  is supported. \n");
+                goto script_parser_fetch_err;
+            }
+
+            if(SCRIPT_PARSER_OK != script_parser_fetch("rtp_para", "rtp_exchange_x_y_flag", &tp_exchange_x_y, 1)){
+                pr_err("sun4i_ts_init: script_parser_fetch err rtp_exchange_x_y_flag. \n");
+                goto script_parser_fetch_err;
+            }
+            printk("sun4i-ts: rtp_exchange_x_y_flag is %d.\n", tp_exchange_x_y);
+
+            if(0 != tp_exchange_x_y && 1 != tp_exchange_x_y){
+                printk("sun4i-ts: only tp_exchange_x_y==1 or  tp_exchange_x_y==0 is supported. \n");
+                goto script_parser_fetch_err;
+            }
+
+	}else{
+		goto script_parser_fetch_err;
+	}
+
+	platform_device_register(&sun4i_ts_device);
+	ret = platform_driver_register(&sun4i_ts_driver);
+
+script_parser_fetch_err:
+	return ret;
+}
+
+static void __exit sun4i_ts_exit(void)
+{
+	platform_driver_unregister(&sun4i_ts_driver);
+	platform_device_unregister(&sun4i_ts_device);
+
+}
+
+module_init(sun4i_ts_init);
+module_exit(sun4i_ts_exit);
+
+MODULE_AUTHOR("zhengdixu <@>");
+MODULE_DESCRIPTION("sun4i touchscreen driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/synaptics_i2c_rmi.c b/drivers/input/touchscreen/synaptics_i2c_rmi.c
new file mode 100644
index 0000000..f6d4977
--- /dev/null
+++ b/drivers/input/touchscreen/synaptics_i2c_rmi.c
@@ -0,0 +1,681 @@
+/* drivers/input/keyboard/synaptics_i2c_rmi.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/synaptics_i2c_rmi.h>
+
+static struct workqueue_struct *synaptics_wq;
+
+struct synaptics_ts_data {
+	uint16_t addr;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int use_irq;
+	bool has_relative_report;
+	struct hrtimer timer;
+	struct work_struct  work;
+	uint16_t max[2];
+	int snap_state[2][2];
+	int snap_down_on[2];
+	int snap_down_off[2];
+	int snap_up_on[2];
+	int snap_up_off[2];
+	int snap_down[2];
+	int snap_up[2];
+	uint32_t flags;
+	int reported_finger_count;
+	int8_t sensitivity_adjust;
+	int (*power)(int on);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void synaptics_ts_early_suspend(struct early_suspend *h);
+static void synaptics_ts_late_resume(struct early_suspend *h);
+#endif
+
+static int synaptics_init_panel(struct synaptics_ts_data *ts)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+		goto err_page_select_failed;
+	}
+	ret = i2c_smbus_write_byte_data(ts->client, 0x41, 0x04); /* Set "No Clip Z" */
+	if (ret < 0)
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for No Clip Z\n");
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0x44,
+					ts->sensitivity_adjust);
+	if (ret < 0)
+		pr_err("synaptics_ts: failed to set Sensitivity Adjust\n");
+
+err_page_select_failed:
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x04); /* page select = 0x04 */
+	if (ret < 0)
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf0, 0x81); /* normal operation, 80 reports per second */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_resume: i2c_smbus_write_byte_data failed\n");
+	return ret;
+}
+
+static void synaptics_ts_work_func(struct work_struct *work)
+{
+	int i;
+	int ret;
+	int bad_data = 0;
+	struct i2c_msg msg[2];
+	uint8_t start_reg;
+	uint8_t buf[15];
+	struct synaptics_ts_data *ts = container_of(work, struct synaptics_ts_data, work);
+	int buf_len = ts->has_relative_report ? 15 : 13;
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = &start_reg;
+	start_reg = 0x00;
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = buf_len;
+	msg[1].buf = buf;
+
+	/* printk("synaptics_ts_work_func\n"); */
+	for (i = 0; i < ((ts->use_irq && !bad_data) ? 1 : 10); i++) {
+		ret = i2c_transfer(ts->client->adapter, msg, 2);
+		if (ret < 0) {
+			printk(KERN_ERR "synaptics_ts_work_func: i2c_transfer failed\n");
+			bad_data = 1;
+		} else {
+			/* printk("synaptics_ts_work_func: %x %x %x %x %x %x" */
+			/*        " %x %x %x %x %x %x %x %x %x, ret %d\n", */
+			/*        buf[0], buf[1], buf[2], buf[3], */
+			/*        buf[4], buf[5], buf[6], buf[7], */
+			/*        buf[8], buf[9], buf[10], buf[11], */
+			/*        buf[12], buf[13], buf[14], ret); */
+			if ((buf[buf_len - 1] & 0xc0) != 0x40) {
+				printk(KERN_WARNING "synaptics_ts_work_func:"
+				       " bad read %x %x %x %x %x %x %x %x %x"
+				       " %x %x %x %x %x %x, ret %d\n",
+				       buf[0], buf[1], buf[2], buf[3],
+				       buf[4], buf[5], buf[6], buf[7],
+				       buf[8], buf[9], buf[10], buf[11],
+				       buf[12], buf[13], buf[14], ret);
+				if (bad_data)
+					synaptics_init_panel(ts);
+				bad_data = 1;
+				continue;
+			}
+			bad_data = 0;
+			if ((buf[buf_len - 1] & 1) == 0) {
+				/* printk("read %d coordinates\n", i); */
+				break;
+			} else {
+				int pos[2][2];
+				int f, a;
+				int base;
+				/* int x = buf[3] | (uint16_t)(buf[2] & 0x1f) << 8; */
+				/* int y = buf[5] | (uint16_t)(buf[4] & 0x1f) << 8; */
+				int z = buf[1];
+				int w = buf[0] >> 4;
+				int finger = buf[0] & 7;
+
+				/* int x2 = buf[3+6] | (uint16_t)(buf[2+6] & 0x1f) << 8; */
+				/* int y2 = buf[5+6] | (uint16_t)(buf[4+6] & 0x1f) << 8; */
+				/* int z2 = buf[1+6]; */
+				/* int w2 = buf[0+6] >> 4; */
+				/* int finger2 = buf[0+6] & 7; */
+
+				/* int dx = (int8_t)buf[12]; */
+				/* int dy = (int8_t)buf[13]; */
+				int finger2_pressed;
+
+				/* printk("x %4d, y %4d, z %3d, w %2d, F %d, 2nd: x %4d, y %4d, z %3d, w %2d, F %d, dx %4d, dy %4d\n", */
+				/*	x, y, z, w, finger, */
+				/*	x2, y2, z2, w2, finger2, */
+				/*	dx, dy); */
+
+				base = 2;
+				for (f = 0; f < 2; f++) {
+					uint32_t flip_flag = SYNAPTICS_FLIP_X;
+					for (a = 0; a < 2; a++) {
+						int p = buf[base + 1];
+						p |= (uint16_t)(buf[base] & 0x1f) << 8;
+						if (ts->flags & flip_flag)
+							p = ts->max[a] - p;
+						if (ts->flags & SYNAPTICS_SNAP_TO_INACTIVE_EDGE) {
+							if (ts->snap_state[f][a]) {
+								if (p <= ts->snap_down_off[a])
+									p = ts->snap_down[a];
+								else if (p >= ts->snap_up_off[a])
+									p = ts->snap_up[a];
+								else
+									ts->snap_state[f][a] = 0;
+							} else {
+								if (p <= ts->snap_down_on[a]) {
+									p = ts->snap_down[a];
+									ts->snap_state[f][a] = 1;
+								} else if (p >= ts->snap_up_on[a]) {
+									p = ts->snap_up[a];
+									ts->snap_state[f][a] = 1;
+								}
+							}
+						}
+						pos[f][a] = p;
+						base += 2;
+						flip_flag <<= 1;
+					}
+					base += 2;
+					if (ts->flags & SYNAPTICS_SWAP_XY)
+						swap(pos[f][0], pos[f][1]);
+				}
+				if (z) {
+					input_report_abs(ts->input_dev, ABS_X, pos[0][0]);
+					input_report_abs(ts->input_dev, ABS_Y, pos[0][1]);
+				}
+				input_report_abs(ts->input_dev, ABS_PRESSURE, z);
+				input_report_abs(ts->input_dev, ABS_TOOL_WIDTH, w);
+				input_report_key(ts->input_dev, BTN_TOUCH, finger);
+				finger2_pressed = finger > 1 && finger != 7;
+				input_report_key(ts->input_dev, BTN_2, finger2_pressed);
+				if (finger2_pressed) {
+					input_report_abs(ts->input_dev, ABS_HAT0X, pos[1][0]);
+					input_report_abs(ts->input_dev, ABS_HAT0Y, pos[1][1]);
+				}
+
+				if (!finger)
+					z = 0;
+				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, z);
+				input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, pos[0][0]);
+				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, pos[0][1]);
+				input_mt_sync(ts->input_dev);
+				if (finger2_pressed) {
+					input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, z);
+					input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_X, pos[1][0]);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, pos[1][1]);
+					input_mt_sync(ts->input_dev);
+				} else if (ts->reported_finger_count > 1) {
+					input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+					input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+					input_mt_sync(ts->input_dev);
+				}
+				ts->reported_finger_count = finger;
+				input_sync(ts->input_dev);
+			}
+		}
+	}
+	if (ts->use_irq)
+		enable_irq(ts->client->irq);
+}
+
+static enum hrtimer_restart synaptics_ts_timer_func(struct hrtimer *timer)
+{
+	struct synaptics_ts_data *ts = container_of(timer, struct synaptics_ts_data, timer);
+	/* printk("synaptics_ts_timer_func\n"); */
+
+	queue_work(synaptics_wq, &ts->work);
+
+	hrtimer_start(&ts->timer, ktime_set(0, 12500000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t synaptics_ts_irq_handler(int irq, void *dev_id)
+{
+	struct synaptics_ts_data *ts = dev_id;
+
+	/* printk("synaptics_ts_irq_handler\n"); */
+	disable_irq_nosync(ts->client->irq);
+	queue_work(synaptics_wq, &ts->work);
+	return IRQ_HANDLED;
+}
+
+static int synaptics_ts_probe(
+	struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct synaptics_ts_data *ts;
+	uint8_t buf0[4];
+	uint8_t buf1[8];
+	struct i2c_msg msg[2];
+	int ret = 0;
+	uint16_t max_x, max_y;
+	int fuzz_x, fuzz_y, fuzz_p, fuzz_w;
+	struct synaptics_i2c_rmi_platform_data *pdata;
+	unsigned long irqflags;
+	int inactive_area_left;
+	int inactive_area_right;
+	int inactive_area_top;
+	int inactive_area_bottom;
+	int snap_left_on;
+	int snap_left_off;
+	int snap_right_on;
+	int snap_right_off;
+	int snap_top_on;
+	int snap_top_off;
+	int snap_bottom_on;
+	int snap_bottom_off;
+	uint32_t panel_version;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_ERR "synaptics_ts_probe: need I2C_FUNC_I2C\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+	INIT_WORK(&ts->work, synaptics_ts_work_func);
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+	if (pdata)
+		ts->power = pdata->power;
+	if (ts->power) {
+		ret = ts->power(1);
+		if (ret < 0) {
+			printk(KERN_ERR "synaptics_ts_probe power on failed\n");
+			goto err_power_failed;
+		}
+	}
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf4, 0x01); /* device command = reset */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
+		/* fail? */
+	}
+	{
+		int retry = 10;
+		while (retry-- > 0) {
+			ret = i2c_smbus_read_byte_data(ts->client, 0xe4);
+			if (ret >= 0)
+				break;
+			msleep(100);
+		}
+	}
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: Product Major Version %x\n", ret);
+	panel_version = ret << 8;
+	ret = i2c_smbus_read_byte_data(ts->client, 0xe5);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: Product Minor Version %x\n", ret);
+	panel_version |= ret;
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xe3);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: product property %x\n", ret);
+
+	if (pdata) {
+		while (pdata->version > panel_version)
+			pdata++;
+		ts->flags = pdata->flags;
+		ts->sensitivity_adjust = pdata->sensitivity_adjust;
+		irqflags = pdata->irqflags;
+		inactive_area_left = pdata->inactive_left;
+		inactive_area_right = pdata->inactive_right;
+		inactive_area_top = pdata->inactive_top;
+		inactive_area_bottom = pdata->inactive_bottom;
+		snap_left_on = pdata->snap_left_on;
+		snap_left_off = pdata->snap_left_off;
+		snap_right_on = pdata->snap_right_on;
+		snap_right_off = pdata->snap_right_off;
+		snap_top_on = pdata->snap_top_on;
+		snap_top_off = pdata->snap_top_off;
+		snap_bottom_on = pdata->snap_bottom_on;
+		snap_bottom_off = pdata->snap_bottom_off;
+		fuzz_x = pdata->fuzz_x;
+		fuzz_y = pdata->fuzz_y;
+		fuzz_p = pdata->fuzz_p;
+		fuzz_w = pdata->fuzz_w;
+	} else {
+		irqflags = 0;
+		inactive_area_left = 0;
+		inactive_area_right = 0;
+		inactive_area_top = 0;
+		inactive_area_bottom = 0;
+		snap_left_on = 0;
+		snap_left_off = 0;
+		snap_right_on = 0;
+		snap_right_off = 0;
+		snap_top_on = 0;
+		snap_top_off = 0;
+		snap_bottom_on = 0;
+		snap_bottom_off = 0;
+		fuzz_x = 0;
+		fuzz_y = 0;
+		fuzz_p = 0;
+		fuzz_w = 0;
+	}
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xf0);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: device control %x\n", ret);
+
+	ret = i2c_smbus_read_byte_data(ts->client, 0xf1);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_byte_data failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: interrupt enable %x\n", ret);
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed\n");
+		goto err_detect_failed;
+	}
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf0;
+	buf0[0] = 0xe0;
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 8;
+	msg[1].buf = buf1;
+	ret = i2c_transfer(ts->client->adapter, msg, 2);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_transfer failed\n");
+		goto err_detect_failed;
+	}
+	printk(KERN_INFO "synaptics_ts_probe: 0xe0: %x %x %x %x %x %x %x %x\n",
+	       buf1[0], buf1[1], buf1[2], buf1[3],
+	       buf1[4], buf1[5], buf1[6], buf1[7]);
+
+	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x10); /* page select = 0x10 */
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_write_byte_data failed for page select\n");
+		goto err_detect_failed;
+	}
+	ret = i2c_smbus_read_word_data(ts->client, 0x02);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->has_relative_report = !(ret & 0x100);
+	printk(KERN_INFO "synaptics_ts_probe: Sensor properties %x\n", ret);
+	ret = i2c_smbus_read_word_data(ts->client, 0x04);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->max[0] = max_x = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
+	ret = i2c_smbus_read_word_data(ts->client, 0x06);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c_smbus_read_word_data failed\n");
+		goto err_detect_failed;
+	}
+	ts->max[1] = max_y = (ret >> 8 & 0xff) | ((ret & 0x1f) << 8);
+	if (ts->flags & SYNAPTICS_SWAP_XY)
+		swap(max_x, max_y);
+
+	ret = synaptics_init_panel(ts); /* will also switch back to page 0x04 */
+	if (ret < 0) {
+		printk(KERN_ERR "synaptics_init_panel failed\n");
+		goto err_detect_failed;
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		ret = -ENOMEM;
+		printk(KERN_ERR "synaptics_ts_probe: Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+	ts->input_dev->name = "synaptics-rmi-touchscreen";
+	set_bit(EV_SYN, ts->input_dev->evbit);
+	set_bit(EV_KEY, ts->input_dev->evbit);
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
+	set_bit(BTN_2, ts->input_dev->keybit);
+	set_bit(EV_ABS, ts->input_dev->evbit);
+	inactive_area_left = inactive_area_left * max_x / 0x10000;
+	inactive_area_right = inactive_area_right * max_x / 0x10000;
+	inactive_area_top = inactive_area_top * max_y / 0x10000;
+	inactive_area_bottom = inactive_area_bottom * max_y / 0x10000;
+	snap_left_on = snap_left_on * max_x / 0x10000;
+	snap_left_off = snap_left_off * max_x / 0x10000;
+	snap_right_on = snap_right_on * max_x / 0x10000;
+	snap_right_off = snap_right_off * max_x / 0x10000;
+	snap_top_on = snap_top_on * max_y / 0x10000;
+	snap_top_off = snap_top_off * max_y / 0x10000;
+	snap_bottom_on = snap_bottom_on * max_y / 0x10000;
+	snap_bottom_off = snap_bottom_off * max_y / 0x10000;
+	fuzz_x = fuzz_x * max_x / 0x10000;
+	fuzz_y = fuzz_y * max_y / 0x10000;
+	ts->snap_down[!!(ts->flags & SYNAPTICS_SWAP_XY)] = -inactive_area_left;
+	ts->snap_up[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x + inactive_area_right;
+	ts->snap_down[!(ts->flags & SYNAPTICS_SWAP_XY)] = -inactive_area_top;
+	ts->snap_up[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y + inactive_area_bottom;
+	ts->snap_down_on[!!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_left_on;
+	ts->snap_down_off[!!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_left_off;
+	ts->snap_up_on[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x - snap_right_on;
+	ts->snap_up_off[!!(ts->flags & SYNAPTICS_SWAP_XY)] = max_x - snap_right_off;
+	ts->snap_down_on[!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_top_on;
+	ts->snap_down_off[!(ts->flags & SYNAPTICS_SWAP_XY)] = snap_top_off;
+	ts->snap_up_on[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y - snap_bottom_on;
+	ts->snap_up_off[!(ts->flags & SYNAPTICS_SWAP_XY)] = max_y - snap_bottom_off;
+	printk(KERN_INFO "synaptics_ts_probe: max_x %d, max_y %d\n", max_x, max_y);
+	printk(KERN_INFO "synaptics_ts_probe: inactive_x %d %d, inactive_y %d %d\n",
+	       inactive_area_left, inactive_area_right,
+	       inactive_area_top, inactive_area_bottom);
+	printk(KERN_INFO "synaptics_ts_probe: snap_x %d-%d %d-%d, snap_y %d-%d %d-%d\n",
+	       snap_left_on, snap_left_off, snap_right_on, snap_right_off,
+	       snap_top_on, snap_top_off, snap_bottom_on, snap_bottom_off);
+	input_set_abs_params(ts->input_dev, ABS_X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, fuzz_p, 0);
+	input_set_abs_params(ts->input_dev, ABS_TOOL_WIDTH, 0, 15, fuzz_w, 0);
+	input_set_abs_params(ts->input_dev, ABS_HAT0X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_HAT0Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, -inactive_area_left, max_x + inactive_area_right, fuzz_x, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, -inactive_area_top, max_y + inactive_area_bottom, fuzz_y, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, fuzz_p, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 15, fuzz_w, 0);
+	/* ts->input_dev->name = ts->keypad_info->name; */
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		printk(KERN_ERR "synaptics_ts_probe: Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+	if (client->irq) {
+		ret = request_irq(client->irq, synaptics_ts_irq_handler, irqflags, client->name, ts);
+		if (ret == 0) {
+			ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
+			if (ret)
+				free_irq(client->irq, ts);
+		}
+		if (ret == 0)
+			ts->use_irq = 1;
+		else
+			dev_err(&client->dev, "request_irq failed\n");
+	}
+	if (!ts->use_irq) {
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = synaptics_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = synaptics_ts_early_suspend;
+	ts->early_suspend.resume = synaptics_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+	printk(KERN_INFO "synaptics_ts_probe: Start touchscreen %s in %s mode\n", ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+
+	return 0;
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed:
+err_detect_failed:
+err_power_failed:
+	kfree(ts);
+err_alloc_data_failed:
+err_check_functionality_failed:
+	return ret;
+}
+
+static int synaptics_ts_remove(struct i2c_client *client)
+{
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+	else
+		hrtimer_cancel(&ts->timer);
+	input_unregister_device(ts->input_dev);
+	kfree(ts);
+	return 0;
+}
+
+static int synaptics_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->use_irq)
+		disable_irq(client->irq);
+	else
+		hrtimer_cancel(&ts->timer);
+	ret = cancel_work_sync(&ts->work);
+	if (ret && ts->use_irq) /* if work was pending disable-count is now 2 */
+		enable_irq(client->irq);
+	ret = i2c_smbus_write_byte_data(ts->client, 0xf1, 0); /* disable interrupt */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+
+	ret = i2c_smbus_write_byte_data(client, 0xf0, 0x86); /* deep sleep */
+	if (ret < 0)
+		printk(KERN_ERR "synaptics_ts_suspend: i2c_smbus_write_byte_data failed\n");
+	if (ts->power) {
+		ret = ts->power(0);
+		if (ret < 0)
+			printk(KERN_ERR "synaptics_ts_resume power off failed\n");
+	}
+	return 0;
+}
+
+static int synaptics_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->power) {
+		ret = ts->power(1);
+		if (ret < 0)
+			printk(KERN_ERR "synaptics_ts_resume power on failed\n");
+	}
+
+	synaptics_init_panel(ts);
+
+	if (ts->use_irq)
+		enable_irq(client->irq);
+
+	if (!ts->use_irq)
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	else
+		i2c_smbus_write_byte_data(ts->client, 0xf1, 0x01); /* enable abs int */
+
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void synaptics_ts_early_suspend(struct early_suspend *h)
+{
+	struct synaptics_ts_data *ts;
+	ts = container_of(h, struct synaptics_ts_data, early_suspend);
+	synaptics_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void synaptics_ts_late_resume(struct early_suspend *h)
+{
+	struct synaptics_ts_data *ts;
+	ts = container_of(h, struct synaptics_ts_data, early_suspend);
+	synaptics_ts_resume(ts->client);
+}
+#endif
+
+static const struct i2c_device_id synaptics_ts_id[] = {
+	{ SYNAPTICS_I2C_RMI_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver synaptics_ts_driver = {
+	.probe		= synaptics_ts_probe,
+	.remove		= synaptics_ts_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= synaptics_ts_suspend,
+	.resume		= synaptics_ts_resume,
+#endif
+	.id_table	= synaptics_ts_id,
+	.driver = {
+		.name	= SYNAPTICS_I2C_RMI_NAME,
+	},
+};
+
+static int __devinit synaptics_ts_init(void)
+{
+	synaptics_wq = create_singlethread_workqueue("synaptics_wq");
+	if (!synaptics_wq)
+		return -ENOMEM;
+	return i2c_add_driver(&synaptics_ts_driver);
+}
+
+static void __exit synaptics_ts_exit(void)
+{
+	i2c_del_driver(&synaptics_ts_driver);
+	if (synaptics_wq)
+		destroy_workqueue(synaptics_wq);
+}
+
+module_init(synaptics_ts_init);
+module_exit(synaptics_ts_exit);
+
+MODULE_DESCRIPTION("Synaptics Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/zt8031.c b/drivers/input/touchscreen/zt8031.c
new file mode 100644
index 0000000..804d4ab
--- /dev/null
+++ b/drivers/input/touchscreen/zt8031.c
@@ -0,0 +1,792 @@
+/* 
+ * drivers/input/key/hv2605_keypad.c
+ *
+ * FocalTech ft5x0x TouchScreen driver. 
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *	note: only support mulititouch	Wenfs 2010-10-01
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include "zt8031.h"
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#include <linux/wakelock.h>
+#endif
+
+#include <plat/sys_config.h>
+#include <mach/irqs.h>
+#define TP_ID (0x10000000)
+
+//////////////////////////////////////////////////////
+static void* __iomem gpio_addr = NULL;
+static int gpio_int_hdle = 0;
+static int gpio_wakeup_hdle = 0;
+static int gpio_reset_hdle = 0;
+static int gpio_wakeup_enable = 1;
+static int gpio_reset_enable = 1;
+
+static int screen_max_x = 0;
+static int screen_max_y = 0;
+static int revert_x_flag = 0;
+static int revert_y_flag = 0;
+
+/*
+ * aw_get_pendown_state  : get the int_line data state, 
+ * 
+ * return value:
+ *             return PRESS_DOWN: if down
+ *             return FREE_UP: if up,
+ *             return 0: do not need process, equal free up.          
+ */
+static int aw_get_pendown_state(void)
+{
+	unsigned int reg_val;
+	static int state = FREE_UP;
+
+    //get the input port state
+    reg_val = readl(gpio_addr + PIOH_DATA);
+	//printk("reg_val = %x\n",reg_val);
+    if(!(reg_val & (1<<IRQ_NO))) 
+    {
+        state = PRESS_DOWN;
+        //printk("pen down\n");
+        return PRESS_DOWN;
+    }
+    //touch panel is free up
+    else   
+    {
+        state = FREE_UP;
+        return FREE_UP;
+    }
+}
+
+/**
+ * aw_clear_penirq - clear int pending
+ *
+ */
+static void aw_clear_penirq(void)
+{
+	int reg_val;
+	//clear the IRQ_EINT29 interrupt pending
+	//printk("clear pend irq pending\n");
+	reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+	//writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+    //writel(reg_val&(1<<(IRQ_EINT21)),gpio_addr + PIO_INT_STAT_OFFSET);
+    if((reg_val = (reg_val&(1<<(IRQ_NO)))))
+    {
+        //printk("==IRQ_EINT29=\n");              
+        writel(reg_val,gpio_addr + PIO_INT_STAT_OFFSET);
+    }
+}
+
+/**
+ * aw_set_irq_mode - according sysconfig's subkey "ctp_int_port" to config int port.
+ * 
+ * return value: 
+ *              0:      success;
+ *              others: fail; 
+ */
+static int aw_set_irq_mode(void)
+{
+    int reg_val;
+    int ret = 0;
+
+    return ret;
+    //config gpio to int mode
+    printk("config gpio to int mode. \n");
+    #ifndef SYSCONFIG_GPIO_ENABLE
+    #else
+        if(gpio_int_hdle)
+        {
+            gpio_release(gpio_int_hdle, 2);
+        }
+        gpio_int_hdle = gpio_request_ex("ctp_para", "ctp_int_port");
+        if(!gpio_int_hdle)
+        {
+            printk("request tp_int_port failed. \n");
+            ret = -1;
+            goto request_tp_int_port_failed;
+        }
+    #endif
+    
+#ifdef AW_GPIO_INT_API_ENABLE
+
+#else
+        //Config IRQ_EINT25 Negative Edge Interrupt
+        reg_val = readl(gpio_addr + PIO_INT_CFG3_OFFSET);
+        reg_val &=(~(7<<4));
+        reg_val |=(1<<4);  
+        writel(reg_val,gpio_addr + PIO_INT_CFG3_OFFSET);
+        
+        aw_clear_penirq();
+            
+        //Enable IRQ_EINT25 of PIO Interrupt
+        reg_val = readl(gpio_addr + PIO_INT_CTRL_OFFSET);
+        reg_val |=(1<<IRQ_NO);
+        writel(reg_val,gpio_addr + PIO_INT_CTRL_OFFSET);
+	    //disable_irq(IRQ_EINT);
+	    	
+    mdelay(2);
+#endif
+
+request_tp_int_port_failed:
+    return ret;  
+}
+
+/**
+ * aw_set_gpio_mode - according sysconfig's subkey "ctp_io_port" to config io port.
+ *
+ * return value: 
+ *              0:      success;
+ *              others: fail; 
+ */
+static int aw_set_gpio_mode(void)
+{
+    //int reg_val;
+    int ret = 0;
+    //config gpio to io mode
+    printk("config gpio to io mode. \n");
+    #ifndef SYSCONFIG_GPIO_ENABLE
+    #else
+        if(gpio_int_hdle)
+        {
+            gpio_release(gpio_int_hdle, 2);
+        }
+        gpio_int_hdle = gpio_request_ex("ctp_para", "ctp_io_port");
+        if(!gpio_int_hdle)
+        {
+            printk("request ctp_io_port failed. \n");
+            ret = -1;
+            goto request_tp_io_port_failed;
+        }
+    #endif
+    return ret;
+
+request_tp_io_port_failed:
+    return ret;
+}
+
+/**
+ * aw_judge_int_occur - whether interrupt occur.
+ *
+ * return value: 
+ *              0:      int occur;
+ *              others: no int occur; 
+ */
+static int aw_judge_int_occur(void)
+{
+    //int reg_val[3];
+    int reg_val;
+    int ret = -1;
+
+    reg_val = readl(gpio_addr + PIO_INT_STAT_OFFSET);
+    if(reg_val&(1<<(IRQ_NO)))
+    {
+        ret = 0;
+    }
+    return ret; 	
+}
+
+/**
+ * aw_free_platform_resource - corresponding with aw_init_platform_resource
+ *
+ */
+static void aw_free_platform_resource(void)
+{
+    if(gpio_addr){
+        iounmap(gpio_addr);
+    }
+    if(gpio_int_hdle)
+    {
+    	gpio_release(gpio_int_hdle, 2);
+    }
+    if(gpio_wakeup_hdle){
+        gpio_release(gpio_wakeup_hdle, 2);
+    }
+    if(gpio_reset_hdle){
+        gpio_release(gpio_reset_hdle, 2);
+    }
+    
+    return;
+}
+
+
+/**
+ * aw_init_platform_resource - initialize platform related resource
+ * return value: 0 : success
+ *               -EIO :  i/o err.
+ *
+ */
+static int aw_init_platform_resource(void)
+{
+	int ret = 0;
+	
+        gpio_addr = ioremap(PIO_BASE_ADDRESS, PIO_RANGE_SIZE);
+        //printk("%s, gpio_addr = 0x%x. \n", __func__, gpio_addr);
+        if(!gpio_addr) {
+	    ret = -EIO;
+	    goto exit_ioremap_failed;	
+	}
+//    gpio_wakeup_enable = 1;
+    gpio_wakeup_hdle = gpio_request_ex("ctp_para", "ctp_wakeup");
+    if(!gpio_wakeup_hdle) {
+        pr_warning("touch panel tp_wakeup request gpio fail!\n");
+        //ret = EIO;
+        gpio_wakeup_enable = 0;
+        //goto exit_gpio_wakeup_request_failed;
+    }
+
+    gpio_reset_hdle = gpio_request_ex("ctp_para", "ctp_reset");
+    if(!gpio_reset_hdle) {
+        pr_warning("touch panel tp_reset request gpio fail!\n");
+        //ret = EIO;
+        gpio_reset_enable = 0;
+        //goto exit_gpio_reset_request_failed;
+        
+    }
+    
+    printk("TP IRQ INITAL\n");
+    if(aw_set_irq_mode()){
+        ret = -EIO;
+        goto exit_gpio_int_request_failed;
+    }
+
+    return ret;
+    
+exit_gpio_int_request_failed: 
+exit_ioremap_failed:
+aw_free_platform_resource();
+    return ret;
+}
+
+
+/**
+ * aw_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int aw_fetch_sysconfig_para(void)
+{
+    int ret = -1;
+    int ctp_used = -1;
+    char name[I2C_NAME_SIZE];
+    script_parser_value_type_t type = SCRIPT_PARSER_VALUE_TYPE_STRING;
+
+    printk("%s. \n", __func__);
+    
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_used", &ctp_used, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    if(1 != ctp_used){
+        pr_err("ilitek_ts: ctp_unused. \n");
+        //ret = 1;
+        return ret;
+    }
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch_ex("ctp_para", "ctp_name", (int *)(&name), &type, sizeof(name)/sizeof(int))){
+            pr_err("ilitek_ts: script_parser_fetch err. \n");
+            goto script_parser_fetch_err;
+    }
+    if(strcmp(ZT_NAME, name)){
+        pr_err("ilitek_ts: name %s does not match ZT_NAME. \n", name);
+        //ret = 1;
+        return ret;
+    }
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_x", &screen_max_x, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    pr_info("ilitek_ts: screen_max_x = %d. \n", screen_max_x);
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_screen_max_y", &screen_max_y, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    pr_info("ilitek_ts: screen_max_y = %d. \n", screen_max_y);
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_x_flag", &revert_x_flag, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    pr_info("ilitek_ts: revert_x_flag = %d. \n", revert_x_flag);
+
+    if(SCRIPT_PARSER_OK != script_parser_fetch("ctp_para", "ctp_revert_y_flag", &revert_y_flag, 1)){
+        pr_err("ilitek_ts: script_parser_fetch err. \n");
+        goto script_parser_fetch_err;
+    }
+    pr_info("ilitek_ts: revert_y_flag = %d. \n", revert_y_flag);
+
+    return 0;
+
+script_parser_fetch_err:
+    pr_notice("=========script_parser_fetch_err============\n");
+    return ret;
+}
+
+/**
+ * aw_ts_reset - function
+ *
+ */
+static void aw_ts_reset(void)
+{
+    printk("%s. \n", __func__);
+    if(gpio_reset_enable){
+        if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 0, "ctp_reset")){
+            printk("ilitek_ts_reset: err when operate gpio. \n");
+        }
+        mdelay(TS_RESET_LOW_PERIOD);
+        if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_reset_hdle, 1, "ctp_reset")){
+            printk("ilitek_ts_reset: err when operate gpio. \n");
+        }
+        mdelay(TS_INITIAL_HIGH_PERIOD);
+    }
+    
+}
+
+/**
+ * aw_ts_wakeup - function
+ *
+ */
+static void aw_ts_wakeup(void)
+{
+    printk("%s. \n", __func__);
+    if(1 == gpio_wakeup_enable){  
+        if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 0, "ctp_wakeup")){
+            printk("ts_resume: err when operate gpio. \n");
+        }
+        mdelay(TS_WAKEUP_LOW_PERIOD);
+        if(EGPIO_SUCCESS != gpio_write_one_pin_value(gpio_wakeup_hdle, 1, "ctp_wakeup")){
+            printk("ts_resume: err when operate gpio. \n");
+        }
+        mdelay(TS_WAKEUP_HIGH_PERIOD);
+
+    }
+    
+    return;
+}
+////////////////////////////////////////////////////////////////
+
+static struct aw_platform_ops aw_ops = {
+	.get_pendown_state = aw_get_pendown_state,
+	.clear_penirq	   = aw_clear_penirq,
+	.set_irq_mode      = aw_set_irq_mode,
+	.set_gpio_mode     = aw_set_gpio_mode,
+	.judge_int_occur   = aw_judge_int_occur,
+	.init_platform_resource = aw_init_platform_resource,
+	.free_platform_resource = aw_free_platform_resource,
+	.fetch_sysconfig_para = aw_fetch_sysconfig_para,
+	.ts_reset =          aw_ts_reset,
+	.ts_wakeup =         aw_ts_wakeup,
+};
+
+struct ts_event {
+	int	x;
+	int	y;
+	int	pressure;
+};
+
+struct zt_ts_data {
+	struct input_dev	   *input_dev;
+	struct ts_event		   event;
+ 	struct delayed_work  work;
+  	struct workqueue_struct *queue;
+};
+
+static struct i2c_client *this_client;
+static unsigned int tp_flg = 0;
+static struct zt_ts_data *zt_ts;
+
+static int zt_i2c_rxdata(char *rxdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= 0,
+			.buf	= rxdata,
+		},
+		{
+			.addr	= this_client->addr,
+			.flags	= I2C_M_RD,
+			.len	= length,
+			.buf	= rxdata,
+		},
+	};
+
+    //msleep(1);
+	ret = i2c_transfer(this_client->adapter, msgs, 2);
+	if (ret < 0)
+		pr_err("msg %s i2c read error: %d\n", __func__, ret);
+	
+	return ret;
+}
+
+static int zt_i2c_txdata(char *txdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= length,
+			.buf	= txdata,
+		},
+	};
+
+   	//msleep(1);
+	ret = i2c_transfer(this_client->adapter, msg, 1);
+	if (ret < 0)
+		pr_err("%s i2c write error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int zt_set_reg(u8 para)
+{
+    u8 buf[3];
+    int ret = -1;
+
+    buf[0] = para;
+    ret = zt_i2c_txdata(buf, 1);
+    if (ret < 0) {
+        pr_err("write reg failed! %#x ret: %d", buf[0], ret);
+        return -1;
+    }
+    
+    return 0;
+}
+
+static void zt_ts_release(void)
+{
+	struct zt_ts_data *data = i2c_get_clientdata(this_client);
+	input_report_abs(data->input_dev, ABS_PRESSURE, 0);
+	input_report_key(data->input_dev, BTN_TOUCH, 0);
+	input_sync(data->input_dev);
+}
+/*
+ * We have 4 complete samples.  
+ * treating X and Y values separately.  Then pick the two with the
+ * least variance, and average them.
+ */
+static unsigned int ts_filter(int *xdata,int *ydata,int *x, int *y)
+{
+	int i;
+	int  min_x = 0xfff;
+	int  min_y = 0xfff;
+	int  max_x = 0x00;
+	int  max_y = 0x00;
+	int  sum_x = 0x00;
+	int  sum_y = 0x00;
+
+	for(i = 0; i < 4; i++)
+	{
+		if(xdata[i] < min_x)
+		   min_x = xdata[i];
+		if(ydata[i] < min_y)
+		   min_y = ydata[i];
+		sum_x += xdata[i];
+		sum_y += ydata[i];
+		   
+		if(xdata[i] > max_x)
+		  max_x = xdata[i];
+		if(ydata[i] > max_y)
+		  max_y = ydata[i];
+		 
+	}
+
+       
+
+	*x = (sum_x - min_x - max_x) >>1;
+	*y = (sum_y - min_y - max_y) >>1;
+
+	return 0;
+}
+static int zt_read_data(void)
+{
+	struct zt_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+	int z1,z2;
+	int x[4],y[4];
+	u8 buf[2] = {0};
+	int ret = -1;
+	
+	//printk("%s. \n", __func__);
+	memset(event, 0, sizeof(struct ts_event));
+	zt_set_reg(READ_X);
+	ret = zt_i2c_rxdata(buf, 2);
+	x[0] =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Y);
+	ret = zt_i2c_rxdata(buf, 2);
+	y[0] =(buf[0]<<4) + (buf[1]>>4);
+	
+	zt_set_reg(READ_X);
+	ret = zt_i2c_rxdata(buf, 2);
+	x[1] =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Y);
+	ret = zt_i2c_rxdata(buf, 2);
+	y[1] =(buf[0]<<4) + (buf[1]>>4);
+
+	zt_set_reg(READ_X);
+	ret = zt_i2c_rxdata(buf, 2);
+	x[2] =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Y);
+	ret = zt_i2c_rxdata(buf, 2);
+	y[2] =(buf[0]<<4) + (buf[1]>>4);
+
+	zt_set_reg(READ_X);
+	ret = zt_i2c_rxdata(buf, 2);
+	x[3] =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Y);
+	ret = zt_i2c_rxdata(buf, 2);
+	y[3] =(buf[0]<<4) + (buf[1]>>4);
+			
+	zt_set_reg(READ_Z1);
+	ret = zt_i2c_rxdata(buf, 2);
+	z1 =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(READ_Z2);
+	ret = zt_i2c_rxdata(buf, 2);
+	z2 =(buf[0]<<4) + (buf[1]>>4);
+	zt_set_reg(PWRDOWN);
+	event->pressure = 1;
+	//printk("z1 = %d,z2= %d\n",z1,z2);
+	if((z1<10)||(z2>4000))
+	  ret = -1;
+	else
+	{
+	  ts_filter(x,y,&event->x,&event->y);
+	  ret = 0;
+	}
+	return ret;
+}
+
+static void zt_report_value(void)
+{
+	struct zt_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+        //printk("%s. \n", __func__);
+        
+	input_report_abs(data->input_dev, ABS_X, (event->x |TP_ID));
+	input_report_abs(data->input_dev, ABS_Y, (event->y |TP_ID) );
+	//printk("event->x = %x,event->y = %x\n",event->x,event->y);
+	input_report_abs(data->input_dev, ABS_PRESSURE, event->pressure);
+	input_report_key(data->input_dev, BTN_TOUCH, 1);
+	input_sync(data->input_dev);
+}	
+
+static void zt_read_loop(struct work_struct *work)
+{
+	int ret = -1;
+	int i;
+	int reg_data[3];
+	/*
+	uint32_t tmp = 0; 
+	tmp = readl(PIOI_DATA);
+	printk("%s. tmp = 0x%x. \n", __func__, tmp);
+	*/
+	
+	for(i = 0;i< 16;i++);
+	reg_data[0] = (readl(PIOI_DATA)>>13)&0x1;
+	for(i = 0;i< 16;i++);
+	reg_data[1] = (readl(PIOI_DATA)>>13)&0x1;
+	for(i = 0;i< 16;i++);
+	reg_data[2] = (readl(PIOI_DATA)>>13)&0x1;  
+	//printk("==work=\n");
+	//printk("reg_data[0]  = 0x%x,  reg_data[1]  = 0x%x, reg_data[2]  = 0x%x .\n",  reg_data[0], reg_data[1], reg_data[2]);
+	
+	if((!reg_data[0])&&(!reg_data[1])&&(!reg_data[2]))
+	{
+	        //printk("press down. \n");
+		ret = zt_read_data();	
+	    if (ret == 0) 
+		  zt_report_value();
+		  tp_flg = 0;
+		  queue_delayed_work(zt_ts->queue, &zt_ts->work, POINT_DELAY);
+	}else
+	{
+	  if(!tp_flg)
+	  {
+	        //printk("release up. \n");
+	  	zt_ts_release();
+	  }
+	  tp_flg = 1;
+	  queue_delayed_work(zt_ts->queue, &zt_ts->work, 5*POINT_DELAY);
+	}
+}
+
+
+static int 
+zt_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+
+	struct input_dev *input_dev;
+	int err = 0;
+	
+	printk("======================================zt_ts_probe=============================================\n");
+	err = aw_ops.init_platform_resource();
+	if(0 != err){
+	    printk("%s:aw_ops.init_platform_resource err. \n", __func__);    
+	}
+	
+	tp_flg = 0;
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	printk("==kzalloc=\n");
+	zt_ts = kzalloc(sizeof(*zt_ts), GFP_KERNEL);
+	if (!zt_ts)	{
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+        printk("i2c_set_clientdata. \n");
+	this_client = client;
+	i2c_set_clientdata(client, zt_ts);
+
+
+	INIT_DELAYED_WORK(&zt_ts->work, zt_read_loop);
+	zt_ts->queue = create_singlethread_workqueue(dev_name(&client->dev));
+	if (!zt_ts->queue) {
+		err = -ESRCH;
+		goto exit_create_singlethread;
+	}
+
+        printk("input_allocate_device. \n");
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+	
+	zt_ts->input_dev = input_dev;
+
+	set_bit(ABS_X, input_dev->absbit);
+	set_bit(ABS_Y, input_dev->absbit);
+	set_bit(ABS_PRESSURE, input_dev->absbit);
+	set_bit(BTN_TOUCH, input_dev->keybit);
+
+	input_set_abs_params(input_dev, ABS_X, 0, (0xfff|TP_ID), 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, (0xfff|TP_ID), 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 0xff, 0 , 0);
+
+
+	set_bit(EV_ABS, input_dev->evbit);
+	set_bit(EV_KEY, input_dev->evbit);
+
+	input_dev->name		= ZT_NAME;		//dev_name(&client->dev)
+	printk("input_register_device. \n");
+	err = input_register_device(input_dev);
+	if (err) {
+		dev_err(&client->dev,
+		"zt_ts_probe: failed to register input device: %s\n",
+		dev_name(&client->dev));
+		goto exit_input_register_device_failed;
+	}
+
+
+        aw_ops.set_gpio_mode();
+	queue_delayed_work(zt_ts->queue, &zt_ts->work, 5*POINT_DELAY);
+	printk("==probe over =\n");
+  
+    	return 0;
+
+exit_input_register_device_failed:
+	input_free_device(input_dev);
+exit_input_dev_alloc_failed:
+	//cancel_work_sync(&zt_ts->work);
+	//destroy_workqueue(zt_ts->queue);
+exit_create_singlethread:
+	printk("==singlethread error =\n");
+	i2c_set_clientdata(client, NULL);
+	kfree(zt_ts);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	return err;
+}
+
+static int __devexit zt_ts_remove(struct i2c_client *client)
+{
+	
+	struct zt_ts_data *zt_tsc = i2c_get_clientdata(client);
+	input_unregister_device(zt_tsc->input_dev);
+	kfree(zt_ts);
+	printk("==zt_ts_remove=\n");
+	//cancel_work_sync(&zt_ts->work);
+	//destroy_workqueue(zt_ts->queue);
+	i2c_set_clientdata(client, NULL);
+	aw_ops.free_platform_resource();
+	return 0;
+}
+
+static const struct i2c_device_id zt_ts_id[] = {
+	{ ZT_NAME, 0 },{ }
+};
+MODULE_DEVICE_TABLE(i2c, zt_ts_id);
+
+static struct i2c_driver zt_ts_driver = {
+	.probe		= zt_ts_probe,
+	.remove		= __devexit_p(zt_ts_remove),
+	.id_table	= zt_ts_id,
+	.driver	= {
+		.name	  =    ZT_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init zt_ts_init(void)
+{
+        int ret = 0;
+        printk("%s. \n", __func__);
+        ret = aw_ops.fetch_sysconfig_para();
+        if(ret < 0){
+            return -1;
+        }
+	return i2c_add_driver(&zt_ts_driver);
+}
+
+static void __exit zt_ts_exit(void)
+{
+        printk("%s. \n", __func__);
+	i2c_del_driver(&zt_ts_driver);
+}
+module_init(zt_ts_init);
+module_exit(zt_ts_exit);
+
+MODULE_AUTHOR("<zhengdixu@allwinnertech.com>");
+MODULE_DESCRIPTION("zt8031 TouchScreen driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/zt8031.h b/drivers/input/touchscreen/zt8031.h
new file mode 100644
index 0000000..95a7bec
--- /dev/null
+++ b/drivers/input/touchscreen/zt8031.h
@@ -0,0 +1,126 @@
+/*
+ * drivers/input/touchscreen/zt8031.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LINUX_ZT_TS_H__
+#define __LINUX_ZT_TS_H__
+
+#include <plat/sys_config.h>
+#include <mach/irqs.h>
+#include <linux/i2c.h>
+#include <linux/i2c/tsc2007.h>
+
+// gpio base address
+#define PIO_BASE_ADDRESS             (0x01c20800)
+#define PIO_RANGE_SIZE               (0x400)
+
+#define IRQ_EINT21                   (21) 
+#define IRQ_EINT29                   (29) 
+#define IRQ_EINT25                   (25)
+
+#define TS_POLL_DELAY			    10/* ms delay between samples */
+#define TS_POLL_PERIOD			    10 /* ms delay between samples */
+
+#define GPIO_ENABLE
+#define SYSCONFIG_GPIO_ENABLE
+
+#define PIO_INT_STAT_OFFSET          (0x214)
+#define PIO_INT_CTRL_OFFSET          (0x210)
+#define PIO_INT_CFG2_OFFSET          (0x208)
+#define PIO_INT_CFG3_OFFSET          (0x20c)
+#define PIO_PN_DAT_OFFSET(n)         ((n)*0x24 + 0x10) 
+//#define PIOI_DATA                    (0x130)
+#define PIOH_DATA                    (0x10c)
+#define PIOI_CFG3_OFFSET             (0x12c)
+
+#define PRESS_DOWN                   1
+#define FREE_UP                      0
+
+#define TS_RESET_LOW_PERIOD       (1)
+#define TS_INITIAL_HIGH_PERIOD   (100)
+#define TS_WAKEUP_LOW_PERIOD  (10)
+#define TS_WAKEUP_HIGH_PERIOD (10)
+#define IRQ_NO                           (IRQ_EINT25)
+
+struct aw_platform_ops{
+    int         irq;
+	bool        pendown;
+	int	        (*get_pendown_state)(void);
+	void        (*clear_penirq)(void);
+	int         (*set_irq_mode)(void);
+	int         (*set_gpio_mode)(void);
+	int         (*judge_int_occur)(void);
+    int         (*init_platform_resource)(void);
+    void        (*free_platform_resource)(void);
+	int         (*fetch_sysconfig_para)(void);
+	void        (*ts_reset)(void);
+	void        (*ts_wakeup)(void);
+};
+
+
+
+#define ZT_NAME	"zt8031"
+
+struct zt_ts_platform_data{
+	u16	intr;		/* irq number	*/
+};
+
+#define PIOA_CFG1_REG    (gpio_addr+0x4)
+#define PIOA_DATA             (gpio_addr+0x10) 
+#define PIOI_DATA              (gpio_addr+0x130) 
+
+#define POINT_DELAY      (1)
+#define ZT8031_ADDR                     (0x90>>1)
+#define ZT8031_MEASURE_TEMP0		(0x0 << 4)
+#define ZT8031_MEASURE_AUX		(0x2 << 4)
+#define ZT8031_MEASURE_TEMP1		(0x4 << 4)
+#define ZT8031_ACTIVATE_XN		(0x8 << 4)
+#define ZT8031_ACTIVATE_YN		(0x9 << 4)
+#define ZT8031_ACTIVATE_YP_XN		(0xa << 4)
+#define ZT8031_SETUP			(0xb << 4)
+#define ZT8031_MEASURE_X		(0xc << 4)
+#define ZT8031_MEASURE_Y		(0xd << 4)
+#define ZT8031_MEASURE_Z1		(0xe << 4)
+#define ZT8031_MEASURE_Z2		(0xf << 4)
+
+#define ZT8031_POWER_OFF_IRQ_EN	        (0x0 << 2)
+#define ZT8031_ADC_ON_IRQ_DIS0		(0x1 << 2)
+#define ZT8031_ADC_OFF_IRQ_EN		(0x2 << 2)
+#define ZT8031_ADC_ON_IRQ_DIS1		(0x3 << 2)
+
+#define ZT8031_12BIT			(0x0 << 1)
+#define ZT8031_8BIT			(0x1 << 1)
+
+#define	MAX_12BIT			((1 << 12) - 1)
+
+#define ADC_ON_12BIT	(ZT8031_12BIT | ZT8031_ADC_ON_IRQ_DIS1)
+
+#define READ_Y		(ADC_ON_12BIT | ZT8031_MEASURE_Y)
+#define READ_Z1		(ADC_ON_12BIT | ZT8031_MEASURE_Z1)
+#define READ_Z2		(ADC_ON_12BIT | ZT8031_MEASURE_Z2)
+#define READ_X		(ADC_ON_12BIT | ZT8031_MEASURE_X)
+#define PWRDOWN		(ZT8031_12BIT | ZT8031_POWER_OFF_IRQ_EN)
+#define PWRUP           (ZT8031_12BIT|ZT8031_ADC_ON_IRQ_DIS1)
+
+#define POINT_DELAY                  (1)
+
+#endif
+
