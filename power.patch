diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 99dc29f..5d89820 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -8,12 +8,20 @@ menuconfig POWER_SUPPLY
 
 if POWER_SUPPLY
 
+source "drivers/power/axp_power/Kconfig"
+
 config POWER_SUPPLY_DEBUG
 	bool "Power supply debug"
 	help
 	  Say Y here to enable debugging messages for power supply class
 	  and drivers.
 
+config AXP152
+	bool "AXP152 PMIC driver"
+	depends on REGULATOR
+	help
+	  Say Y here to enable support for the AXP152 PMIC chip
+
 config PDA_POWER
 	tristate "Generic PDA/phone power driver"
 	depends on !S390
@@ -190,6 +198,16 @@ config BATTERY_MAX17042
 	  multi-function devices that include fuel gauages that are compatible
 	  with MAX17042.
 
+config BATTERY_ANDROID
+	tristate "Battery driver for Android"
+	help
+	  Say Y to enable generic support for battery charging according
+	  to common Android policies.
+	  This driver adds periodic battery level and health monitoring,
+	  kernel log reporting and other debugging features, common board
+	  battery file glue logic for battery/case temperature sensors,
+	  etc.
+
 config BATTERY_Z2
 	tristate "Z2 battery driver"
 	depends on I2C && MACH_ZIPIT2
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index b6b2434..a7bad30 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -6,6 +6,7 @@ power_supply-$(CONFIG_LEDS_TRIGGERS)	+= power_supply_leds.o
 
 obj-$(CONFIG_POWER_SUPPLY)	+= power_supply.o
 
+obj-$(CONFIG_AXP152)		+= axp152.o
 obj-$(CONFIG_PDA_POWER)		+= pda_power.o
 obj-$(CONFIG_APM_POWER)		+= apm_power.o
 obj-$(CONFIG_MAX8925_POWER)	+= max8925_power.o
@@ -44,3 +45,5 @@ obj-$(CONFIG_CHARGER_MANAGER)	+= charger-manager.o
 obj-$(CONFIG_CHARGER_MAX8997)	+= max8997_charger.o
 obj-$(CONFIG_CHARGER_MAX8998)	+= max8998_charger.o
 obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
+obj-$(CONFIG_AW_AXP)		+= axp_power/
+obj-$(CONFIG_BATTERY_ANDROID)	+= android_battery.o
diff --git a/drivers/power/android_battery.c b/drivers/power/android_battery.c
new file mode 100644
index 0000000..ee437d0
--- /dev/null
+++ b/drivers/power/android_battery.c
@@ -0,0 +1,692 @@
+/*
+ *  android_battery.c
+ *  Android Battery Driver
+ *
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Samsung Electronics
+ *
+ * Based on work by himihee.seo@samsung.com, ms925.kim@samsung.com, and
+ * joshua.chang@samsung.com.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
+#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+#include <linux/alarmtimer.h>
+#include <linux/timer.h>
+#include <linux/mutex.h>
+#include <linux/debugfs.h>
+#include <linux/platform_data/android_battery.h>
+
+#define FAST_POLL               (1 * 60)
+#define SLOW_POLL               (10 * 60)
+
+struct android_bat_data {
+	struct android_bat_platform_data *pdata;
+	struct android_bat_callbacks callbacks;
+
+	struct device		*dev;
+
+	struct power_supply	psy_bat;
+
+	struct wake_lock	monitor_wake_lock;
+	struct wake_lock	charger_wake_lock;
+
+	int			charge_source;
+
+	int			batt_temp;
+	int			batt_current;
+	unsigned int		batt_health;
+	unsigned int		batt_vcell;
+	unsigned int		batt_soc;
+	unsigned int		charging_status;
+	bool			recharging;
+	unsigned long		charging_start_time;
+
+	struct workqueue_struct *monitor_wqueue;
+	struct work_struct	monitor_work;
+	struct work_struct	charger_work;
+
+	struct alarm		monitor_alarm;
+	ktime_t			last_poll;
+
+	struct dentry		*debugfs_entry;
+};
+
+static enum power_supply_property android_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static DEFINE_MUTEX(android_bat_state_lock);
+
+static void android_bat_update_data(struct android_bat_data *battery);
+static int android_bat_enable_charging(struct android_bat_data *battery,
+					bool enable);
+
+static char *charge_source_str(int charge_source)
+{
+	switch (charge_source) {
+	case CHARGE_SOURCE_NONE:
+		return "none";
+	case CHARGE_SOURCE_AC:
+		return "ac";
+	case CHARGE_SOURCE_USB:
+		return "usb";
+	default:
+		break;
+	}
+
+	return "?";
+}
+
+static int android_bat_get_property(struct power_supply *ps,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct android_bat_data *battery =
+		container_of(ps, struct android_bat_data, psy_bat);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = battery->charging_status;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = battery->batt_health;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = 1;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = battery->batt_temp;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = 1;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		android_bat_update_data(battery);
+		val->intval = battery->batt_vcell;
+		if (val->intval == -1)
+			return -EINVAL;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = battery->batt_soc;
+		if (val->intval == -1)
+			return -EINVAL;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		android_bat_update_data(battery);
+		val->intval = battery->batt_current;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void android_bat_get_temp(struct android_bat_data *battery)
+{
+	int batt_temp = 42; /* 4.2C */
+	int health = battery->batt_health;
+
+	if (battery->pdata->get_temperature)
+		battery->pdata->get_temperature(&batt_temp);
+
+	if (battery->charge_source != CHARGE_SOURCE_NONE) {
+		if (batt_temp >= battery->pdata->temp_high_threshold) {
+			if (health != POWER_SUPPLY_HEALTH_OVERHEAT &&
+				health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) {
+				pr_info("battery overheat (%d>=%d), " \
+					"charging unavailable\n",
+					batt_temp,
+					battery->pdata->temp_high_threshold);
+				battery->batt_health =
+					POWER_SUPPLY_HEALTH_OVERHEAT;
+			}
+		} else if (batt_temp <= battery->pdata->temp_high_recovery &&
+			batt_temp >= battery->pdata->temp_low_recovery) {
+			if (health == POWER_SUPPLY_HEALTH_OVERHEAT ||
+				health == POWER_SUPPLY_HEALTH_COLD) {
+				pr_info("battery recovery (%d,%d~%d),"	\
+					"charging available\n",
+					batt_temp,
+					battery->pdata->temp_low_recovery,
+					battery->pdata->temp_high_recovery);
+				battery->batt_health =
+					POWER_SUPPLY_HEALTH_GOOD;
+			}
+		} else if (batt_temp <= battery->pdata->temp_low_threshold) {
+			if (health != POWER_SUPPLY_HEALTH_COLD &&
+				health != POWER_SUPPLY_HEALTH_UNSPEC_FAILURE) {
+				pr_info("battery cold (%d <= %d),"	\
+					"charging unavailable\n",
+					batt_temp,
+					battery->pdata->temp_low_threshold);
+				battery->batt_health =
+					POWER_SUPPLY_HEALTH_COLD;
+			}
+		}
+	}
+
+	battery->batt_temp = batt_temp;
+}
+
+/*
+ * android_bat_state_lock not held, may call back into
+ * android_bat_charge_source_changed.  Gathering data here can be
+ * non-atomic; updating our state based on the data may need to be
+ * atomic.
+ */
+
+static void android_bat_update_data(struct android_bat_data *battery)
+{
+	int ret;
+	int v;
+
+	if (battery->pdata->poll_charge_source)
+		battery->charge_source = battery->pdata->poll_charge_source();
+
+	if (battery->pdata->get_voltage_now) {
+		ret = battery->pdata->get_voltage_now();
+		battery->batt_vcell = ret >= 0 ? ret : 4242000;
+	}
+
+	if (battery->pdata->get_capacity) {
+		ret = battery->pdata->get_capacity();
+		battery->batt_soc = ret >= 0 ? ret : 42;
+	}
+
+	if (battery->pdata->get_current_now) {
+		ret = battery->pdata->get_current_now(&v);
+
+		if (!ret)
+			battery->batt_current = v;
+	}
+
+	android_bat_get_temp(battery);
+}
+
+static void android_bat_set_charge_time(struct android_bat_data *battery,
+					bool enable)
+{
+	if (enable && !battery->charging_start_time) {
+		struct timespec cur_time;
+
+		get_monotonic_boottime(&cur_time);
+		/* record start time for charge timeout timer */
+		battery->charging_start_time = cur_time.tv_sec;
+	} else if (!enable) {
+		/* clear charge timeout timer */
+		battery->charging_start_time = 0;
+	}
+}
+
+static int android_bat_enable_charging(struct android_bat_data *battery,
+				       bool enable)
+{
+	if (enable && (battery->batt_health != POWER_SUPPLY_HEALTH_GOOD)) {
+		battery->charging_status =
+		    POWER_SUPPLY_STATUS_NOT_CHARGING;
+		return -EPERM;
+	}
+
+	if (enable) {
+		if (battery->pdata && battery->pdata->set_charging_current)
+			battery->pdata->set_charging_current
+			(battery->charge_source);
+	}
+
+	if (battery->pdata && battery->pdata->set_charging_enable)
+		battery->pdata->set_charging_enable(enable);
+
+	android_bat_set_charge_time(battery, enable);
+	pr_info("battery: enable=%d charger: %s\n", enable,
+		charge_source_str(battery->charge_source));
+	return 0;
+}
+
+static bool android_bat_charge_timeout(struct android_bat_data *battery,
+				       unsigned long timeout)
+{
+	struct timespec cur_time;
+
+	if (!battery->charging_start_time)
+		return 0;
+
+	get_monotonic_boottime(&cur_time);
+	pr_debug("%s: Start time: %ld, End time: %ld, current time: %ld\n",
+		 __func__, battery->charging_start_time,
+		 battery->charging_start_time + timeout,
+		 cur_time.tv_sec);
+	return cur_time.tv_sec >= battery->charging_start_time + timeout;
+}
+
+static void android_bat_charging_timer(struct android_bat_data *battery)
+{
+	if (!battery->charging_start_time &&
+	    battery->charging_status == POWER_SUPPLY_STATUS_CHARGING) {
+		android_bat_enable_charging(battery, true);
+		battery->recharging = true;
+		pr_debug("%s: charge status charging but timer is expired\n",
+			__func__);
+	} else if (battery->charging_start_time == 0) {
+		pr_debug("%s: charging_start_time never initialized\n",
+				__func__);
+		return;
+	}
+
+	if (android_bat_charge_timeout(
+		    battery,
+		    battery->recharging ? battery->pdata->recharging_time :
+		    battery->pdata->full_charging_time)) {
+		android_bat_enable_charging(battery, false);
+		if (battery->batt_vcell >
+		    battery->pdata->recharging_voltage &&
+		    battery->batt_soc == 100)
+			battery->charging_status =
+				POWER_SUPPLY_STATUS_FULL;
+		battery->recharging = false;
+		battery->charging_start_time = 0;
+		pr_info("battery: charging timer expired\n");
+	}
+
+	return;
+}
+
+static void android_bat_charge_source_changed(struct android_bat_callbacks *ptr,
+					      int charge_source)
+{
+	struct android_bat_data *battery =
+		container_of(ptr, struct android_bat_data, callbacks);
+
+	wake_lock(&battery->charger_wake_lock);
+	mutex_lock(&android_bat_state_lock);
+	battery->charge_source = charge_source;
+
+	pr_info("battery: charge source type was changed: %s\n",
+		charge_source_str(battery->charge_source));
+
+	mutex_unlock(&android_bat_state_lock);
+	queue_work(battery->monitor_wqueue, &battery->charger_work);
+}
+
+static void android_bat_set_full_status(struct android_bat_callbacks *ptr)
+{
+	struct android_bat_data *battery =
+		container_of(ptr, struct android_bat_data, callbacks);
+
+	mutex_lock(&android_bat_state_lock);
+	pr_info("battery: battery full\n");
+	battery->charging_status = POWER_SUPPLY_STATUS_FULL;
+	android_bat_enable_charging(battery, false);
+	battery->recharging = false;
+	mutex_unlock(&android_bat_state_lock);
+	power_supply_changed(&battery->psy_bat);
+}
+
+static void android_bat_charger_work(struct work_struct *work)
+{
+	struct android_bat_data *battery =
+		container_of(work, struct android_bat_data, charger_work);
+
+	mutex_lock(&android_bat_state_lock);
+
+	switch (battery->charge_source) {
+	case CHARGE_SOURCE_NONE:
+		battery->charging_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		android_bat_enable_charging(battery, false);
+		battery->batt_health = POWER_SUPPLY_HEALTH_GOOD;
+		battery->recharging = false;
+		battery->charging_start_time = 0;
+		break;
+	case CHARGE_SOURCE_USB:
+	case CHARGE_SOURCE_AC:
+		/*
+		 * If charging status indicates a charger was already
+		 * connected prior to this and the status is something
+		 * other than charging ("full" or "not-charging"), leave
+		 * the status alone.
+		 */
+		if (battery->charging_status ==
+		    POWER_SUPPLY_STATUS_DISCHARGING ||
+		    battery->charging_status == POWER_SUPPLY_STATUS_UNKNOWN)
+			battery->charging_status = POWER_SUPPLY_STATUS_CHARGING;
+
+		/*
+		 * Don't re-enable charging if the battery is full and we
+		 * are not actively re-charging it, or if "not-charging"
+		 * status is set.
+		 */
+		if (!((battery->charging_status == POWER_SUPPLY_STATUS_FULL
+		       && !battery->recharging) || battery->charging_status ==
+		      POWER_SUPPLY_STATUS_NOT_CHARGING))
+			android_bat_enable_charging(battery, true);
+
+		break;
+	default:
+		pr_err("%s: Invalid charger type\n", __func__);
+		break;
+	}
+
+	mutex_unlock(&android_bat_state_lock);
+	wake_lock_timeout(&battery->charger_wake_lock, HZ * 2);
+	power_supply_changed(&battery->psy_bat);
+}
+
+
+static void android_bat_monitor_set_alarm(struct android_bat_data *battery,
+					  int seconds)
+{
+	alarm_start(&battery->monitor_alarm,
+		    ktime_add(battery->last_poll, ktime_set(seconds, 0)));
+}
+
+static void android_bat_monitor_work(struct work_struct *work)
+{
+	struct android_bat_data *battery =
+		container_of(work, struct android_bat_data, monitor_work);
+	struct timespec cur_time;
+
+	wake_lock(&battery->monitor_wake_lock);
+	android_bat_update_data(battery);
+	mutex_lock(&android_bat_state_lock);
+
+	switch (battery->charging_status) {
+	case POWER_SUPPLY_STATUS_FULL:
+		if (battery->batt_vcell < battery->pdata->recharging_voltage &&
+		    !battery->recharging) {
+			battery->recharging = true;
+			android_bat_enable_charging(battery, true);
+			pr_info("battery: start recharging, v=%d\n",
+				battery->batt_vcell/1000);
+		}
+		break;
+	case POWER_SUPPLY_STATUS_DISCHARGING:
+		break;
+	case POWER_SUPPLY_STATUS_CHARGING:
+		switch (battery->batt_health) {
+		case POWER_SUPPLY_HEALTH_OVERHEAT:
+		case POWER_SUPPLY_HEALTH_COLD:
+		case POWER_SUPPLY_HEALTH_OVERVOLTAGE:
+		case POWER_SUPPLY_HEALTH_DEAD:
+		case POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
+			battery->charging_status =
+				POWER_SUPPLY_STATUS_NOT_CHARGING;
+			android_bat_enable_charging(battery, false);
+
+			pr_info("battery: Not charging, health=%d\n",
+				battery->batt_health);
+			break;
+		default:
+			break;
+		}
+		break;
+	case POWER_SUPPLY_STATUS_NOT_CHARGING:
+		if (battery->batt_health == POWER_SUPPLY_HEALTH_GOOD) {
+			pr_info("battery: battery health recovered\n");
+			if (battery->charge_source != CHARGE_SOURCE_NONE) {
+				android_bat_enable_charging(battery, true);
+				battery->charging_status
+					= POWER_SUPPLY_STATUS_CHARGING;
+			} else {
+				battery->charging_status
+					= POWER_SUPPLY_STATUS_DISCHARGING;
+			}
+		}
+		break;
+	default:
+		pr_err("%s: Undefined battery status: %d\n", __func__,
+		       battery->charging_status);
+		break;
+	}
+
+	android_bat_charging_timer(battery);
+	get_monotonic_boottime(&cur_time);
+	pr_info("battery: l=%d v=%d c=%d temp=%s%ld.%ld h=%d st=%d%s ct=%lu type=%s\n",
+		battery->batt_soc, battery->batt_vcell/1000,
+		battery->batt_current, battery->batt_temp < 0 ? "-" : "",
+		abs(battery->batt_temp / 10), abs(battery->batt_temp % 10),
+		battery->batt_health, battery->charging_status,
+		   battery->recharging ? "r" : "",
+		   battery->charging_start_time ?
+		   cur_time.tv_sec - battery->charging_start_time : 0,
+		charge_source_str(battery->charge_source));
+	mutex_unlock(&android_bat_state_lock);
+	power_supply_changed(&battery->psy_bat);
+	battery->last_poll = ktime_get_boottime();
+	android_bat_monitor_set_alarm(battery, FAST_POLL);
+	wake_unlock(&battery->monitor_wake_lock);
+	return;
+}
+
+static enum alarmtimer_restart android_bat_monitor_alarm(
+	struct alarm *alarm, ktime_t now)
+{
+	struct android_bat_data *battery =
+		container_of(alarm, struct android_bat_data, monitor_alarm);
+
+	wake_lock(&battery->monitor_wake_lock);
+	queue_work(battery->monitor_wqueue, &battery->monitor_work);
+	return ALARMTIMER_NORESTART;
+}
+
+static int android_power_debug_dump(struct seq_file *s, void *unused)
+{
+	struct android_bat_data *battery = s->private;
+	struct timespec cur_time;
+
+	android_bat_update_data(battery);
+	get_monotonic_boottime(&cur_time);
+	mutex_lock(&android_bat_state_lock);
+	seq_printf(s, "l=%d v=%d c=%d temp=%s%ld.%ld h=%d st=%d%s ct=%lu type=%s\n",
+		   battery->batt_soc, battery->batt_vcell/1000,
+		   battery->batt_current, battery->batt_temp < 0 ? "-" : "",
+		   abs(battery->batt_temp / 10), abs(battery->batt_temp % 10),
+		   battery->batt_health, battery->charging_status,
+		   battery->recharging ? "r" : "",
+		   battery->charging_start_time ?
+		   cur_time.tv_sec - battery->charging_start_time : 0,
+		   charge_source_str(battery->charge_source));
+	mutex_unlock(&android_bat_state_lock);
+	return 0;
+}
+
+static int android_power_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, android_power_debug_dump, inode->i_private);
+}
+
+static const struct file_operations android_power_debug_fops = {
+	.open = android_power_debug_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static __devinit int android_bat_probe(struct platform_device *pdev)
+{
+	struct android_bat_platform_data *pdata = dev_get_platdata(&pdev->dev);
+	struct android_bat_data *battery;
+	int ret = 0;
+
+	dev_info(&pdev->dev, "Android Battery Driver\n");
+	battery = kzalloc(sizeof(*battery), GFP_KERNEL);
+	if (!battery)
+		return -ENOMEM;
+
+	battery->pdata = pdata;
+	if (!battery->pdata) {
+		pr_err("%s : No platform data\n", __func__);
+		ret = -EINVAL;
+		goto err_pdata;
+	}
+
+	battery->dev = &pdev->dev;
+	platform_set_drvdata(pdev, battery);
+	battery->batt_health = POWER_SUPPLY_HEALTH_GOOD;
+
+	battery->psy_bat.name = "android-battery",
+	battery->psy_bat.type = POWER_SUPPLY_TYPE_BATTERY,
+	battery->psy_bat.properties = android_battery_props,
+	battery->psy_bat.num_properties = ARRAY_SIZE(android_battery_props),
+	battery->psy_bat.get_property = android_bat_get_property,
+
+	battery->batt_vcell = -1;
+	battery->batt_soc = -1;
+
+	wake_lock_init(&battery->monitor_wake_lock, WAKE_LOCK_SUSPEND,
+			"android-battery-monitor");
+	wake_lock_init(&battery->charger_wake_lock, WAKE_LOCK_SUSPEND,
+			"android-chargerdetect");
+
+	ret = power_supply_register(&pdev->dev, &battery->psy_bat);
+	if (ret) {
+		dev_err(battery->dev, "%s: failed to register psy_bat\n",
+			__func__);
+		goto err_psy_bat_reg;
+	}
+
+	battery->monitor_wqueue =
+		alloc_workqueue(dev_name(&pdev->dev), WQ_FREEZABLE, 1);
+	if (!battery->monitor_wqueue) {
+		dev_err(battery->dev, "%s: fail to create workqueue\n",
+				__func__);
+		goto err_wq;
+	}
+
+	INIT_WORK(&battery->monitor_work, android_bat_monitor_work);
+	INIT_WORK(&battery->charger_work, android_bat_charger_work);
+
+	battery->callbacks.charge_source_changed =
+		android_bat_charge_source_changed;
+	battery->callbacks.battery_set_full =
+		android_bat_set_full_status;
+	if (battery->pdata && battery->pdata->register_callbacks)
+		battery->pdata->register_callbacks(&battery->callbacks);
+
+	/* get initial charger status */
+	if (battery->pdata->poll_charge_source)
+		battery->charge_source = battery->pdata->poll_charge_source();
+
+	wake_lock(&battery->charger_wake_lock);
+	queue_work(battery->monitor_wqueue, &battery->charger_work);
+
+	wake_lock(&battery->monitor_wake_lock);
+	battery->last_poll = ktime_get_boottime();
+	alarm_init(&battery->monitor_alarm, ALARM_BOOTTIME,
+		   android_bat_monitor_alarm);
+	queue_work(battery->monitor_wqueue, &battery->monitor_work);
+
+	battery->debugfs_entry =
+		debugfs_create_file("android-power", S_IRUGO, NULL,
+				    battery, &android_power_debug_fops);
+	if (!battery->debugfs_entry)
+		pr_err("failed to create android-power debugfs entry\n");
+
+	return 0;
+
+err_wq:
+	power_supply_unregister(&battery->psy_bat);
+err_psy_bat_reg:
+	wake_lock_destroy(&battery->monitor_wake_lock);
+	wake_lock_destroy(&battery->charger_wake_lock);
+err_pdata:
+	kfree(battery);
+
+	return ret;
+}
+
+static int __devexit android_bat_remove(struct platform_device *pdev)
+{
+	struct android_bat_data *battery = platform_get_drvdata(pdev);
+
+	alarm_cancel(&battery->monitor_alarm);
+	flush_workqueue(battery->monitor_wqueue);
+	destroy_workqueue(battery->monitor_wqueue);
+	power_supply_unregister(&battery->psy_bat);
+	wake_lock_destroy(&battery->monitor_wake_lock);
+	wake_lock_destroy(&battery->charger_wake_lock);
+	debugfs_remove(battery->debugfs_entry);
+	kfree(battery);
+	return 0;
+}
+
+static int android_bat_suspend(struct device *dev)
+{
+	struct android_bat_data *battery = dev_get_drvdata(dev);
+
+	cancel_work_sync(&battery->monitor_work);
+	android_bat_monitor_set_alarm(
+		battery,
+		battery->charge_source == CHARGE_SOURCE_NONE ?
+		SLOW_POLL : FAST_POLL);
+	return 0;
+}
+
+static void android_bat_resume(struct device *dev)
+{
+	struct android_bat_data *battery = dev_get_drvdata(dev);
+
+	android_bat_monitor_set_alarm(battery, FAST_POLL);
+	return;
+}
+
+static const struct dev_pm_ops android_bat_pm_ops = {
+	.prepare = android_bat_suspend,
+	.complete = android_bat_resume,
+};
+
+static struct platform_driver android_bat_driver = {
+	.driver = {
+		.name = "android-battery",
+		.owner = THIS_MODULE,
+		.pm = &android_bat_pm_ops,
+	},
+	.probe = android_bat_probe,
+	.remove = __devexit_p(android_bat_remove),
+};
+
+static int __init android_bat_init(void)
+{
+	return platform_driver_register(&android_bat_driver);
+}
+
+static void __exit android_bat_exit(void)
+{
+	platform_driver_unregister(&android_bat_driver);
+}
+
+late_initcall(android_bat_init);
+module_exit(android_bat_exit);
+
+MODULE_DESCRIPTION("Android battery driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp152.c b/drivers/power/axp152.c
new file mode 100644
index 0000000..d568b9d
--- /dev/null
+++ b/drivers/power/axp152.c
@@ -0,0 +1,491 @@
+/*
+ * Regulator driver for the axp152 PMIC
+ *
+ * Copyright 2013 Hans de Goede <hdegoede@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/slab.h>
+#include <plat/sys_config.h>
+
+#define AXP152_I2C_ADDR		  48
+#define AXP20x_I2C_ADDR		  52
+#define AXP152_REGULATOR_COUNT	   5
+
+#define AXP152_REG_CHIP_VERSION	0x03
+#define AXP152_REG_OUTPUT_CTRL	0x12
+#define AXP152_REG_DCDC2	0x23
+#define AXP152_REG_DCDC1	0x26
+#define AXP152_REG_DCDC3	0x27
+#define AXP152_REG_DLDO2	0x2a
+#define AXP152_REG_DCDC4	0x2b
+#define AXP152_REG_POWER	0x32
+
+/* Bits inside AXP152_REG_OUTPUT_CTRL */
+#define AXP152_DLDO2_ENABLE	0x01
+#define AXP152_DCDC4_ENABLE	0x10
+#define AXP152_DCDC3_ENABLE	0x20
+#define AXP152_DCDC2_ENABLE	0x40
+#define AXP152_DCDC1_ENABLE	0x80
+
+/* Bits inside AXP152_REG_POWER */
+#define AXP152_POWER_OFF	0x80
+
+static const struct i2c_device_id axp152_id_table[] = {
+	{ "axp152", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, axp152_id_table);
+
+static const int axp152_dcdc1_mvolt[16] = { 1700, 1800, 1900, 2000, 2100,
+	2400, 2500, 2600, 2700, 2800, 3000, 3100, 3200, 3300, 3400, 3500 };
+
+enum axp_regulator_ids {
+	axp152_dcdc1,
+	axp152_dcdc2,
+	axp152_dcdc3,
+	axp152_dcdc4,
+	axp152_dldo2
+};
+
+struct axp152_data {
+	struct i2c_client *client;
+	struct regulator_dev *regulator[AXP152_REGULATOR_COUNT];
+	struct mutex mutex;
+	u8 regs[256]; /* Register cache to avoid slow i2c transfers */
+};
+
+static struct axp152_data *pm_power_axp152;
+static DEFINE_MUTEX(pm_power_axp152_mutex);
+
+static int axp152_read_reg(struct axp152_data *axp152, int reg)
+{
+	int ret = i2c_smbus_read_byte_data(axp152->client, reg);
+	if (ret < 0) {
+		dev_err(&axp152->client->dev,
+			"failed to read reg 0x%02x (%d)\n", reg, ret);
+		return ret;
+	}
+	axp152->regs[reg] = ret;
+	return 0;
+}
+
+static int axp152_write_reg(struct axp152_data *axp152, int reg, int val)
+{
+	int ret;
+
+	if (axp152->regs[reg] == val)
+		return 0;
+
+	ret = i2c_smbus_write_byte_data(axp152->client, reg, val);
+	if (ret < 0) {
+		dev_err(&axp152->client->dev,
+			"failed to write 0x%02x to 0x%02x (%d)\n",
+			val, reg, ret);
+		return ret;
+	}
+	axp152->regs[reg] = val;
+	return 0;
+}
+
+static void axp152_power_off(void)
+{
+	axp152_write_reg(pm_power_axp152, AXP152_REG_POWER,
+		pm_power_axp152->regs[AXP152_REG_POWER] | AXP152_POWER_OFF);
+}
+
+static int axp152_list_voltage(struct regulator_dev *rdev, unsigned selector)
+{
+	switch (rdev_get_id(rdev)) {
+	case axp152_dcdc1:
+		return axp152_dcdc1_mvolt[selector] * 1000;
+	case axp152_dcdc2:
+	case axp152_dcdc4:
+		return 700000 + selector * 25000;
+	case axp152_dcdc3:
+		return 700000 + selector * 50000;
+	case axp152_dldo2:
+		return 700000 + selector * 100000;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int axp152_set_voltage(struct regulator_dev *rdev, int val)
+{
+	struct axp152_data *axp152 = rdev_get_drvdata(rdev);
+	int reg;
+
+	switch (rdev_get_id(rdev)) {
+	case axp152_dcdc1: reg = AXP152_REG_DCDC1; break;
+	case axp152_dcdc2: reg = AXP152_REG_DCDC2; break;
+	case axp152_dcdc3: reg = AXP152_REG_DCDC3; break;
+	case axp152_dcdc4: reg = AXP152_REG_DCDC4; break;
+	case axp152_dldo2: reg = AXP152_REG_DLDO2; break;
+	default:
+		return -EINVAL;
+	}
+
+	if (val == -1)
+		return axp152->regs[reg];
+	else
+		return axp152_write_reg(axp152, reg, val);
+}
+
+static int axp152_set_output(struct regulator_dev *rdev, int val)
+{
+	struct axp152_data *axp152 = rdev_get_drvdata(rdev);
+	int mask, ret;
+
+	switch (rdev_get_id(rdev)) {
+	case axp152_dcdc1: mask = AXP152_DCDC1_ENABLE; break;
+	case axp152_dcdc2: mask = AXP152_DCDC2_ENABLE; break;
+	case axp152_dcdc3: mask = AXP152_DCDC3_ENABLE; break;
+	case axp152_dcdc4: mask = AXP152_DCDC4_ENABLE; break;
+	case axp152_dldo2: mask = AXP152_DLDO2_ENABLE; break;
+	default:
+		return -EINVAL;
+	}
+
+	/* This uses 1 register shared by all regulators, so we need to lock */
+	mutex_lock(&axp152->mutex);
+	if (val == -1)
+		ret = (axp152->regs[AXP152_REG_OUTPUT_CTRL] & mask) ? 1 : 0;
+	else if (val)
+		ret = axp152_write_reg(axp152, AXP152_REG_OUTPUT_CTRL,
+			axp152->regs[AXP152_REG_OUTPUT_CTRL] | mask);
+	else
+		ret = axp152_write_reg(axp152, AXP152_REG_OUTPUT_CTRL,
+			axp152->regs[AXP152_REG_OUTPUT_CTRL] & ~mask);
+	mutex_unlock(&axp152->mutex);
+
+	return ret;
+}
+
+static int axp152_set_voltage_sel(struct regulator_dev *rdev,
+				  unsigned selector)
+{
+	return axp152_set_voltage(rdev, selector);
+}
+
+static int axp152_get_voltage_sel(struct regulator_dev *rdev)
+{
+	return axp152_set_voltage(rdev, -1);
+}
+
+static int axp152_enable(struct regulator_dev *rdev)
+{
+	return axp152_set_output(rdev, 1);
+}
+
+static int axp152_disable(struct regulator_dev *rdev)
+{
+	return axp152_set_output(rdev, 0);
+}
+
+static int axp152_is_enabled(struct regulator_dev *rdev)
+{
+	return axp152_set_output(rdev, -1);
+}
+
+static struct regulator_ops axp152_ops = {
+	.list_voltage		= axp152_list_voltage,
+	.set_voltage_sel	= axp152_set_voltage_sel,
+	.get_voltage_sel	= axp152_get_voltage_sel,
+	.enable			= axp152_enable,
+	.disable		= axp152_disable,
+	.is_enabled		= axp152_is_enabled,
+};
+
+static struct regulator_desc axp152_desc[AXP152_REGULATOR_COUNT] = {
+	{
+		.name		= "axp152_dcdc1",
+		.id		= axp152_dcdc1,
+		.n_voltages	= 16,
+		.ops		= &axp152_ops,
+		.type		= REGULATOR_VOLTAGE,
+		.owner		= THIS_MODULE,
+	} , {
+		.name		= "axp152_dcdc2",
+		.id		= axp152_dcdc2,
+		.n_voltages	= 64,
+		.ops		= &axp152_ops,
+		.type		= REGULATOR_VOLTAGE,
+		.owner		= THIS_MODULE,
+	} , {
+		.name		= "axp152_dcdc3",
+		.id		= axp152_dcdc3,
+		.n_voltages	= 57,
+		.ops		= &axp152_ops,
+		.type		= REGULATOR_VOLTAGE,
+		.owner		= THIS_MODULE,
+	} , {
+		.name		= "axp152_dcdc4",
+		.id		= axp152_dcdc4,
+		.n_voltages	= 113,
+		.ops		= &axp152_ops,
+		.type		= REGULATOR_VOLTAGE,
+		.owner		= THIS_MODULE,
+	} , {
+		.name		= "axp152_dldo2",
+		.id		= axp152_dldo2,
+		.n_voltages	= 29,
+		.ops		= &axp152_ops,
+		.type		= REGULATOR_VOLTAGE,
+		.owner		= THIS_MODULE,
+	}
+};
+
+static int axp152_remove(struct i2c_client *client)
+{
+	struct axp152_data *axp152 = i2c_get_clientdata(client);
+	int i;
+
+	mutex_lock(&pm_power_axp152_mutex);
+	if (pm_power_axp152 == axp152) {
+		pm_power_axp152 = NULL;
+		pm_power_off = NULL;
+	}
+	mutex_unlock(&pm_power_axp152_mutex);
+
+	for (i = 0; i < AXP152_REGULATOR_COUNT; i++)
+		if (axp152->regulator[i])
+			regulator_unregister(axp152->regulator[i]);
+
+	i2c_set_clientdata(client, NULL);
+	kfree(axp152);
+	return 0;
+}
+
+static int __devinit axp152_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	struct regulator_init_data *init_data = client->dev.platform_data;
+	struct axp152_data *axp152;
+	int i, ret;
+
+	ret = i2c_smbus_read_byte_data(client, AXP152_REG_CHIP_VERSION);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to read reg 0x03 (%d)\n", ret);
+		return ret;
+	}
+	if (ret != 0x05) {
+		dev_err(&client->dev,
+			"unexpected chip-version 0x%02x != 0x05\n", ret);
+		return -ENODEV;
+	}
+
+	axp152 = kzalloc(sizeof(*axp152), GFP_KERNEL);
+	if (!axp152)
+		return -ENOMEM;
+
+	mutex_init(&axp152->mutex);
+	axp152->client = client;
+	i2c_set_clientdata(client, axp152);
+
+	/* Cache used registers */
+	ret = 0;
+	ret |= axp152_read_reg(axp152, AXP152_REG_OUTPUT_CTRL);
+	ret |= axp152_read_reg(axp152, AXP152_REG_DCDC1);
+	ret |= axp152_read_reg(axp152, AXP152_REG_DCDC2);
+	ret |= axp152_read_reg(axp152, AXP152_REG_DCDC3);
+	ret |= axp152_read_reg(axp152, AXP152_REG_DCDC4);
+	ret |= axp152_read_reg(axp152, AXP152_REG_DLDO2);
+	ret |= axp152_read_reg(axp152, AXP152_REG_POWER);
+	if (ret) {
+		axp152_remove(client);
+		return -EIO;
+	}
+
+	for (i = 0; i < AXP152_REGULATOR_COUNT; i++) {
+		axp152->regulator[i] = regulator_register(&axp152_desc[i],
+			&client->dev, &init_data[i], axp152, NULL);
+		if (IS_ERR(axp152->regulator[i])) {
+			dev_err(&client->dev,
+				"failed to register axp152 %s regulator\n",
+				axp152_desc[i].supply_name);
+			axp152->regulator[i] = NULL;
+			axp152_remove(client);
+			return PTR_ERR(axp152->regulator[i]);
+		}
+	}
+
+	mutex_lock(&pm_power_axp152_mutex);
+	if (!pm_power_axp152) {
+		pm_power_axp152 = axp152;
+		pm_power_off = axp152_power_off;
+	}
+	mutex_unlock(&pm_power_axp152_mutex);
+
+	return 0;
+}
+
+static struct i2c_driver axp152_driver = {
+	.driver	= {
+		.name	= "axp152",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp152_probe,
+	.remove		= axp152_remove,
+	.id_table	= axp152_id_table,
+};
+
+module_i2c_driver(axp152_driver);
+
+
+/* Below is Allwinner fex file integraton stuff, not for upstream */
+
+static struct regulator_consumer_supply axp152_dcdc1_supply = {
+	.supply = "Vio",
+};
+
+static struct regulator_consumer_supply axp152_dcdc2_supply = {
+	.supply = "Vcore",
+};
+
+static struct regulator_consumer_supply axp152_dcdc3_supply = {
+	.supply = "Vddr",
+};
+
+static struct regulator_consumer_supply axp152_dcdc4_supply = {
+	.supply = "Vcpu",
+};
+
+static struct regulator_consumer_supply axp152_dldo2_supply = {
+	.supply = "Vdldo2", /* No clue what dldo2 is used for */
+};
+
+static struct regulator_init_data regl_init_data[AXP152_REGULATOR_COUNT] = {
+	[axp152_dcdc1] = { /* Vio, power on 3.3V, Android hardcoded 3.3V */
+		.num_consumer_supplies = 1,
+		.consumer_supplies = &axp152_dcdc1_supply,
+		.constraints = {
+			.min_uV =  3300 * 1000,
+			.max_uV =  3300 * 1000,
+			.always_on = 1,
+		}
+	},
+	[axp152_dcdc2] = { /* Vcore, power on 1.25V, cpu-freq controlled */
+		.num_consumer_supplies = 1,
+		.consumer_supplies = &axp152_dcdc2_supply,
+		.constraints = {
+			.min_uV =  1000 * 1000,
+			.max_uV =  1600 * 1000,
+			.always_on = 1,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		}
+	},
+	[axp152_dcdc3] = { /* Vddr, power on 1.5V, Android from fex */
+		.num_consumer_supplies = 1,
+		.consumer_supplies = &axp152_dcdc3_supply,
+		.constraints = {
+			.min_uV =  1500 * 1000,
+			.max_uV =  1500 * 1000,
+			.always_on = 1,
+			.apply_uV = 1,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		}
+	},
+	[axp152_dcdc4] = { /* Vcpu, power on 1.25V, Android from fex */
+		.num_consumer_supplies = 1,
+		.consumer_supplies = &axp152_dcdc4_supply,
+		.constraints = {
+			.min_uV =  1250 * 1000,
+			.max_uV =  1250 * 1000,
+			.always_on = 1,
+			.apply_uV = 1,
+		}
+	},
+	[axp152_dldo2] = { /* Power on 1.8V, Android hardcoded 3.0V */
+		.num_consumer_supplies = 1,
+		.consumer_supplies = &axp152_dldo2_supply,
+		.constraints = {
+			.min_uV =  3000 * 1000,
+			.max_uV =  3000 * 1000,
+			.always_on = 1,
+			.apply_uV = 1,
+		}
+	},
+};
+
+static struct i2c_board_info __initdata axp_mfd_i2c_board_info = {
+	.type = "axp152",
+	.addr = AXP152_I2C_ADDR,
+	.platform_data = regl_init_data,
+};
+
+static int __init axp_board_init(void)
+{
+	int ret, val, i2c_bus;
+
+	ret = script_parser_fetch("pmu_para", "pmu_used", &val, sizeof(int));
+	if (ret) {
+		pr_err("Error no pmu_used in pmu_para section of fex\n");
+		return -1;
+	}
+	if (!val)
+		return 0;
+
+	ret = script_parser_fetch("pmu_para", "pmu_twi_id",
+				  &i2c_bus, sizeof(int));
+	if (ret) {
+		pr_err("Error no pmu_twi_id in pmu_para section of fex\n");
+		return -1;
+	}
+
+	ret = script_parser_fetch("pmu_para", "pmu_twi_addr",
+				  &val, sizeof(int));
+	if (ret) {
+		pr_err("Error no pmu_twi_addr in pmu_para section of fex\n");
+		return -1;
+	}
+
+	if (val != AXP152_I2C_ADDR) {
+		if (val == AXP20x_I2C_ADDR) {
+			/* Board uses AXP20x, ignore */
+			return 0;
+		}
+		pr_err("Error invalid pmu_twi_addr (%d) in fex\n", val);
+		return -1;
+	}
+
+	/* Note we ignore the dcdc2_vol key as dcdc2 is set by the dvfs code */
+
+	ret = script_parser_fetch("target", "dcdc3_vol", &val, sizeof(int));
+	if (ret == 0) {
+		regl_init_data[axp152_dcdc3].constraints.min_uV = val * 1000;
+		regl_init_data[axp152_dcdc3].constraints.max_uV = val * 1000;
+	}
+
+	ret = script_parser_fetch("target", "dcdc4_vol", &val, sizeof(int));
+	if (ret == 0) {
+		regl_init_data[axp152_dcdc4].constraints.min_uV = val * 1000;
+		regl_init_data[axp152_dcdc4].constraints.max_uV = val * 1000;
+	}
+
+	return i2c_register_board_info(i2c_bus, &axp_mfd_i2c_board_info, 1);
+}
+fs_initcall(axp_board_init);
+
+MODULE_AUTHOR("Hans de Goede <hdegoede@redhat.com>");
+MODULE_DESCRIPTION("axp152 PMIC regulator driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/Kconfig b/drivers/power/axp_power/Kconfig
new file mode 100644
index 0000000..039679f
--- /dev/null
+++ b/drivers/power/axp_power/Kconfig
@@ -0,0 +1,39 @@
+menuconfig AW_AXP
+	bool "AXP Power drivers"
+	depends on REGULATOR && INPUT
+	default n
+	---help---
+	  This option allows you to select AXP power driver
+
+if AW_AXP
+
+choice
+	prompt "AXP PMU type"
+	default AW_AXP20
+
+config AW_AXP18
+	bool "AXP18 driver"
+	---help---
+	  AXP18 driver
+
+config AW_AXP19
+	bool "AXP19 driver"
+	---help---
+	  AXP19 driver
+
+config AW_AXP20
+	bool "AXP20 driver"
+	---help---
+	  AXP20 driver
+
+endchoice
+
+config AXP_CHARGEINIT
+	bool "AXP initial charging environment set"
+	default y
+
+config AXP_CHGCHANGE
+	bool "AXP charging current set when suspend\resume\shutdown"
+	default y
+
+endif # !AW_AXP
diff --git a/drivers/power/axp_power/Makefile b/drivers/power/axp_power/Makefile
new file mode 100644
index 0000000..ba3e717
--- /dev/null
+++ b/drivers/power/axp_power/Makefile
@@ -0,0 +1,23 @@
+obj-y += axp-mfd.o
+
+#axp 199
+#Make this built-in, so that it will be loaded before I2C driver
+obj-$(CONFIG_AW_AXP18) += axp18-board.o
+obj-$(CONFIG_AW_AXP18) += axp18-regu.o
+obj-$(CONFIG_AW_AXP18) += axp18-sply.o
+obj-$(CONFIG_AW_AXP18) += virtual18.o
+obj-$(CONFIG_AW_AXP18) += virtual18_dev.o
+
+obj-$(CONFIG_AW_AXP19) += axp19-board.o
+obj-$(CONFIG_AW_AXP19) += axp19-regu.o
+obj-$(CONFIG_AW_AXP19) += axp19-sply.o
+obj-$(CONFIG_AW_AXP19) += axp19-gpio.o
+obj-$(CONFIG_AW_AXP19) += virtual19.o
+obj-$(CONFIG_AW_AXP19) += virtual19_dev.o
+
+obj-$(CONFIG_AW_AXP20) += axp20-board.o
+obj-$(CONFIG_AW_AXP20) += axp20-regu.o
+obj-$(CONFIG_AW_AXP20) += axp20-sply.o
+obj-$(CONFIG_AW_AXP20) += axp20-gpio.o
+obj-$(CONFIG_AW_AXP20) += virtual20.o
+obj-$(CONFIG_AW_AXP20) += virtual20_dev.o
\ No newline at end of file
diff --git a/drivers/power/axp_power/axp-cfg.h b/drivers/power/axp_power/axp-cfg.h
new file mode 100644
index 0000000..a3293d9
--- /dev/null
+++ b/drivers/power/axp_power/axp-cfg.h
@@ -0,0 +1,209 @@
+/*
+ * drivers/power/axp_power/axp-cfg.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __LINUX_AXP_CFG_H_
+#define __LINUX_AXP_CFG_H_
+
+#define	AXP18_ADDR			0x2C >> 1
+#define AXP19_ADDR			0x68 >> 1
+#define AXP20_ADDR			0x68 >> 1
+#define	AXP18_I2CBUS		1
+#define	AXP19_I2CBUS		0
+#define	AXP20_I2CBUS		0
+#define BATRDC				200 //initial rdc
+#define AXP20_IRQNO     0
+
+
+#define	LDO1SET				0  //0: LDO1SET connect AGND, 1: LDO1SET connect AIPS, for axp189 LDOSET bonding to AGND
+#define	DC2SET				1  //0: DC2SET connect GND, 1: DC2SET connect IPSOUT, for axp189 DC2SET bonding to IPSOUT
+#define	DC3SET				1  //0:DC3SET connect GND, 1:DC3SET connect IPSOUT ,for axp189 DC3SET to pin
+
+#define AXP19LDO1			1250
+#define AXP20LDO1			  1300
+
+
+#if !LDO1SET
+	#define LDO1MIN			1250
+	#define LDO1MAX			1250
+#else
+	#define LDO1MIN			3300
+	#define LDO1MAX			3300
+#endif
+
+#if DC2SET
+	#define DCDC2MIN		800
+	#define DCDC2MAX		1400
+#else
+	#define DCDC2MIN		1400
+	#define DCDC2MAX		2000
+#endif
+
+#if DC3SET
+	#define DCDC3MIN		2000
+	#define DCDC3MAX		2700
+	#define  LDO3MIN		1600
+	#define  LDO3MAX		1900
+#else
+	#define DCDC3MIN		1300
+	#define DCDC3MAX		1900
+	#define  LDO3MIN		2300
+	#define  LDO3MAX		2600
+#endif
+
+#define AXP18_VOL_MAX		50//1200
+#define AXP18_TIME_MAX		20//100
+#define AXP18_RDC_COUNT		10
+#define CHG_RDC_RATE		20//100
+#define DISCHARGE_CUR_RATE	10
+#define MAX_BAT_CUR			15
+#define DISCHARGE_RDC_CAL	53
+
+#define AXP19_VOL_MAX		50
+#define AXP19_TIME_MAX		20
+#define AXP19_AVER_MAX		10
+#define AXP19_RDC_COUNT		10
+
+#define AXP20_VOL_MAX			12 // capability buffer length
+#define AXP20_TIME_MAX		20
+#define AXP20_AVER_MAX		10
+#define AXP20_RDC_COUNT		10
+
+#define ABS(x)				((x) >0 ? (x) : -(x) )
+
+#define END_VOLTAGE_APS		3350
+
+#define BAT_AVER_VOL		3820	//Aver Vol:3.82V
+
+#define FUELGUAGE_LOW_VOL	3400	//<3.4v,2%
+#define FUELGUAGE_VOL1		3500    //<3.5v,3%
+#define FUELGUAGE_VOL2		3600
+#define FUELGUAGE_VOL3		3700
+#define FUELGUAGE_VOL4		3800
+#define FUELGUAGE_VOL5		3900
+#define FUELGUAGE_VOL6		4000
+#define FUELGUAGE_VOL7		4100
+#define FUELGUAGE_TOP_VOL	4160	//>4.16v,100%
+
+#define FUELGUAGE_LOW_LEVEL	2		//<3.4v,2%
+#define FUELGUAGE_LEVEL1	3		//<3.5v,3%
+#define FUELGUAGE_LEVEL2	5
+#define FUELGUAGE_LEVEL3	16
+#define FUELGUAGE_LEVEL4	46
+#define FUELGUAGE_LEVEL5	66
+#define FUELGUAGE_LEVEL6	83
+#define FUELGUAGE_LEVEL7	93
+#define FUELGUAGE_TOP_LEVEL	100     //>4.16v,100%
+
+#define INTLDO4					2800000								//initial ldo4 voltage
+#define INIT_RDC				200										//initial rdc
+#define TIMER 					20										//axp19 renew capability time
+#define BATTERYCAP      2600									// battery capability
+#define RENEW_TIME      10										//axp20 renew capability time
+#define INTCHGCUR				300000								//set initial charging current limite
+#define SUSCHGCUR				1000000								//set suspend charging current limite
+#define RESCHGCUR				INTCHGCUR							//set resume charging current limite
+#define CLSCHGCUR				SUSCHGCUR							//set shutdown charging current limite
+#define INTCHGVOL				4200000								//set initial charing target voltage
+#define INTCHGENDRATE		10										//set initial charing end current	rate
+#define INTCHGENABLED		1										  //set initial charing enabled
+#define INTADCFREQ			25										//set initial adc frequency
+#define INTADCFREQC			100										//set initial coulomb adc coufrequency
+#define INTCHGPRETIME		50										//set initial pre-charging time
+#define INTCHGCSTTIME		480										//set initial pre-charging time
+#define BATMAXVOL				4200000								//set battery max design volatge
+#define BATMINVOL				3500000								//set battery min design volatge
+
+#define OCVREG0			    0x01									//3.1328
+#define OCVREG1			    0x01									//3.2736
+#define OCVREG2			    0x02									//3.4144
+#define OCVREG3			    0x05									//3.5552
+#define OCVREG4			    0x07									//3.6256
+#define OCVREG5			    0x0D									//3.6608
+#define OCVREG6			    0x10									//3.6960
+#define OCVREG7			    0x1A									//3.7312
+#define OCVREG8			    0x24									//3.7664
+#define OCVREG9			    0x2E									//3.8016
+#define OCVREGA			    0x35									//3.8368
+#define OCVREGB			    0x3D									//3.8720
+#define OCVREGC			    0x49									//3.9424
+#define OCVREGD			    0x54									//4.0128
+#define OCVREGE			    0x5C									//4.0832
+#define OCVREGF			    0x63									//4.1536
+
+extern int pmu_used;
+extern int pmu_twi_id;
+extern int pmu_irq_id;
+extern int pmu_twi_addr;
+extern int pmu_battery_rdc;
+extern int pmu_battery_cap;
+extern int pmu_init_chgcur;
+extern int pmu_suspend_chgcur;
+extern int pmu_resume_chgcur;
+extern int pmu_shutdown_chgcur;
+extern int pmu_init_chgvol;
+extern int pmu_init_chgend_rate;
+extern int pmu_init_chg_enabled;
+extern int pmu_init_adc_freq;
+extern int pmu_init_adc_freqc;
+extern int pmu_init_chg_pretime;
+extern int pmu_init_chg_csttime;
+
+extern int pmu_bat_para1;
+extern int pmu_bat_para2;
+extern int pmu_bat_para3;
+extern int pmu_bat_para4;
+extern int pmu_bat_para5;
+extern int pmu_bat_para6;
+extern int pmu_bat_para7;
+extern int pmu_bat_para8;
+extern int pmu_bat_para9;
+extern int pmu_bat_para10;
+extern int pmu_bat_para11;
+extern int pmu_bat_para12;
+extern int pmu_bat_para13;
+extern int pmu_bat_para14;
+extern int pmu_bat_para15;
+extern int pmu_bat_para16;
+
+extern int pmu_usbvol_limit;
+extern int pmu_usbvol;
+extern int pmu_usbcur_limit;
+extern int pmu_usbcur;
+
+extern int pmu_pwroff_vol;
+extern int pmu_pwron_vol;
+
+extern int dcdc2_vol;
+extern int dcdc3_vol;
+extern int ldo2_vol;
+extern int ldo3_vol;
+extern int ldo4_vol;
+
+extern int pmu_pekoff_time;
+extern int pmu_pekoff_en;
+extern int pmu_peklong_time;
+extern int pmu_pekon_time;
+extern int pmu_pwrok_time;
+extern int pmu_pwrnoe_time;
+extern int pmu_intotp_en;
+
+#endif
diff --git a/drivers/power/axp_power/axp-gpio.h b/drivers/power/axp_power/axp-gpio.h
new file mode 100644
index 0000000..44fae57
--- /dev/null
+++ b/drivers/power/axp_power/axp-gpio.h
@@ -0,0 +1,46 @@
+/*
+ * gpio.h  --  GPIO Driver for Krosspower axp199 PMIC
+ *
+ * Copyright 2011 Krosspower Microelectronics PLC
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef _LINUX_AXP_GPIO_H_
+#define _LINUX_AXP_GPIO_H_
+
+/*
+ * GPIO Registers.
+ */
+/*    AXP19   */
+#define AXP19_GPIO0_CFG                   (POWER19_GPIO0_CTL)
+#define AXP19_GPIO1_CFG                   (POWER19_GPIO1_CTL)
+#define AXP19_GPIO2_CFG                   (POWER19_GPIO2_CTL)
+#define AXP19_GPIO34_CFG                  (POWER19_SENSE_CTL)
+#define AXP19_GPIO5_CFG                   (POWER19_RSTO_CTL)
+#define AXP19_GPIO67_CFG0                 (POWER19_GPIO67_CFG)
+#define AXP19_GPIO67_CFG1                 (POWER19_GPIO67_CTL)
+
+#define AXP19_GPIO012_STATE               (POWER19_GPIO012_SIGNAL)
+#define AXP19_GPIO34_STATE                (POWER19_SENSE_SIGNAL)
+#define AXP19_GPIO5_STATE                 (POWER19_RSTO_CTL)
+#define AXP19_GPIO67_STATE                (POWER19_GPIO67_CTL)
+
+
+/*    AXP20   */
+#define AXP20_GPIO0_CFG                   (POWER20_GPIO0_CTL)
+#define AXP20_GPIO1_CFG                   (POWER20_GPIO1_CTL)
+#define AXP20_GPIO2_CFG                   (POWER20_GPIO2_CTL)
+#define AXP20_GPIO3_CFG                   (POWER20_GPIO3_CTL)
+
+#define AXP20_GPIO012_STATE               (POWER20_GPIO012_SIGNAL)
+
+extern int axp_gpio_set_io(int gpio, int io_state);
+extern int axp_gpio_get_io(int gpio, int *io_state);
+extern int axp_gpio_set_value(int gpio, int value);
+extern int axp_gpio_get_value(int gpio, int *value);
+#endif
diff --git a/drivers/power/axp_power/axp-mfd.c b/drivers/power/axp_power/axp-mfd.c
new file mode 100644
index 0000000..5cd0d43
--- /dev/null
+++ b/drivers/power/axp_power/axp-mfd.c
@@ -0,0 +1,376 @@
+/*
+ * Base driver for AXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include <linux/slab.h>
+
+#include "axp-cfg.h"
+#include "axp18-mfd.h"
+#include "axp19-mfd.h"
+#include "axp20-mfd.h"
+
+#include <plat/sys_config.h>
+
+static int power_start;
+
+static void axp_mfd_irq_work(struct work_struct *work)
+{
+	struct axp_mfd_chip *chip =
+		container_of(work, struct axp_mfd_chip, irq_work);
+	uint64_t irqs = 0;
+
+	while (1) {
+		if (chip->ops->read_irqs(chip, &irqs))
+			break;
+
+		irqs &= chip->irqs_enabled;
+		if (irqs == 0)
+			break;
+
+		blocking_notifier_call_chain(
+				&chip->notifier_list, irqs, NULL);
+	}
+	enable_irq(chip->client->irq);
+}
+
+#if 1
+static irqreturn_t axp_mfd_irq_handler(int irq, void *data)
+{
+	struct axp_mfd_chip *chip = data;
+	disable_irq_nosync(irq);
+	(void)schedule_work(&chip->irq_work);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static struct axp_mfd_chip_ops axp_mfd_ops[] = {
+	[0] = {
+		.init_chip    = axp18_init_chip,
+		.enable_irqs  = axp18_enable_irqs,
+		.disable_irqs = axp18_disable_irqs,
+		.read_irqs    = axp18_read_irqs,
+	},
+	[1] = {
+		.init_chip    = axp19_init_chip,
+		.enable_irqs  = axp19_enable_irqs,
+		.disable_irqs = axp19_disable_irqs,
+		.read_irqs    = axp19_read_irqs,
+	},
+	[2] = {
+		.init_chip    = axp20_init_chip,
+		.enable_irqs  = axp20_enable_irqs,
+		.disable_irqs = axp20_disable_irqs,
+		.read_irqs    = axp20_read_irqs,
+	},
+};
+
+static const struct i2c_device_id axp_mfd_id_table[] = {
+	{ "axp18_mfd", 0 },
+	{ "axp19_mfd", 1 },
+	{ "axp20_mfd", 2 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, axp_mfd_id_table);
+
+int axp_mfd_create_attrs(struct axp_mfd_chip *chip)
+{
+	int j,ret;
+	if(chip->type ==  AXP19){
+		for (j = 0; j < ARRAY_SIZE(axp19_mfd_attrs); j++) {
+			ret = device_create_file(chip->dev,&axp19_mfd_attrs[j]);
+			if (ret)
+				goto sysfs_failed;
+		}
+	}
+	else if (chip->type ==  AXP18){
+		for (j = 0; j < ARRAY_SIZE(axp18_mfd_attrs); j++) {
+			ret = device_create_file(chip->dev,&axp18_mfd_attrs[j]);
+			if (ret)
+			goto sysfs_failed2;
+		}
+	}
+	else if (chip->type ==  AXP20){
+		for (j = 0; j < ARRAY_SIZE(axp20_mfd_attrs); j++) {
+			ret = device_create_file(chip->dev,&axp20_mfd_attrs[j]);
+			if (ret)
+			goto sysfs_failed3;
+		}
+	}
+	else
+		ret = 0;
+	goto succeed;
+
+sysfs_failed:
+	while (j--)
+		device_remove_file(chip->dev,&axp19_mfd_attrs[j]);
+	goto succeed;
+sysfs_failed2:
+	while (j--)
+		device_remove_file(chip->dev,&axp18_mfd_attrs[j]);
+	goto succeed;
+sysfs_failed3:
+	while (j--)
+		device_remove_file(chip->dev,&axp20_mfd_attrs[j]);
+succeed:
+	return ret;
+}
+
+static int __remove_subdev(struct device *dev, void *unused)
+{
+	platform_device_unregister(to_platform_device(dev));
+	return 0;
+}
+
+static int axp_mfd_remove_subdevs(struct axp_mfd_chip *chip)
+{
+	return device_for_each_child(chip->dev, NULL, __remove_subdev);
+}
+
+static int __devinit axp_mfd_add_subdevs(struct axp_mfd_chip *chip,
+					struct axp_platform_data *pdata)
+{
+	struct axp_funcdev_info *regl_dev;
+	struct axp_funcdev_info *sply_dev;
+	struct axp_funcdev_info *gpio_dev;
+	struct platform_device *pdev;
+	int i, ret = 0;
+
+	/* register for regultors */
+	for (i = 0; i < pdata->num_regl_devs; i++) {
+		regl_dev = &pdata->regl_devs[i];
+		pdev = platform_device_alloc(regl_dev->name, regl_dev->id);
+		pdev->dev.parent = chip->dev;
+		pdev->dev.platform_data = regl_dev->platform_data;
+		ret = platform_device_add(pdev);
+		if (ret)
+			goto failed;
+	}
+
+	/* register for power supply */
+	for (i = 0; i < pdata->num_sply_devs; i++) {
+	sply_dev = &pdata->sply_devs[i];
+	pdev = platform_device_alloc(sply_dev->name, sply_dev->id);
+	pdev->dev.parent = chip->dev;
+	pdev->dev.platform_data = sply_dev->platform_data;
+	ret = platform_device_add(pdev);
+	if (ret)
+		goto failed;
+
+	}
+
+	/* register for gpio */
+	for (i = 0; i < pdata->num_gpio_devs; i++) {
+	gpio_dev = &pdata->gpio_devs[i];
+	pdev = platform_device_alloc(gpio_dev->name, gpio_dev->id);
+	pdev->dev.parent = chip->dev;
+	pdev->dev.platform_data = gpio_dev->platform_data;
+	ret = platform_device_add(pdev);
+	if (ret)
+		goto failed;
+	}
+
+
+	return 0;
+
+failed:
+	axp_mfd_remove_subdevs(chip);
+	return ret;
+}
+
+static void axp_power_off(void)
+{
+	uint8_t val;
+
+#if defined (CONFIG_AW_AXP18)
+	axp_set_bits(&axp->dev, POWER18_ONOFF, 0x80);
+#endif
+
+#if defined (CONFIG_AW_AXP19)
+	axp_set_bits(&axp->dev, POWER19_OFF_CTL, 0x80);
+#endif
+
+#if defined (CONFIG_AW_AXP20)
+	if(pmu_pwroff_vol >= 2600 && pmu_pwroff_vol <= 3300){
+		if (pmu_pwroff_vol > 3200){
+			val = 0x7;
+		}
+		else if (pmu_pwroff_vol > 3100){
+			val = 0x6;
+		}
+		else if (pmu_pwroff_vol > 3000){
+			val = 0x5;
+		}
+		else if (pmu_pwroff_vol > 2900){
+			val = 0x4;
+		}
+		else if (pmu_pwroff_vol > 2800){
+			val = 0x3;
+		}
+		else if (pmu_pwroff_vol > 2700){
+			val = 0x2;
+		}
+		else if (pmu_pwroff_vol > 2600){
+			val = 0x1;
+		}
+		else
+			val = 0x0;
+
+		axp_update(&axp->dev, POWER20_VOFF_SET, val, 0x7);
+	}
+	val = 0xff;
+
+	axp_read(&axp->dev, POWER20_COULOMB_CTL, &val);
+	val &= 0x3f;
+	axp_write(&axp->dev, POWER20_COULOMB_CTL, val);
+	val |= 0x80;
+	val &= 0xbf;
+	axp_write(&axp->dev, POWER20_COULOMB_CTL, val);
+
+    //led auto
+    axp_clr_bits(&axp->dev,0x32,0x38);
+	axp_clr_bits(&axp->dev,0xb9,0x80);
+
+    printk("[axp] send power-off command!\n");
+    mdelay(20);
+    if(power_start != 1){
+		axp_read(&axp->dev, POWER20_STATUS, &val);
+		if(val & 0xF0){
+	    	axp_read(&axp->dev, POWER20_MODE_CHGSTATUS, &val);
+	    	if(val & 0x20){
+            	printk("[axp] set flag!\n");
+	        	axp_write(&axp->dev, POWER20_DATA_BUFFERC, 0x0f);
+            	mdelay(20);
+		    	printk("[axp] reboot!\n");
+			machine_restart(NULL);
+		    	printk("[axp] warning!!! arch can't ,reboot, maybe some error happend!\n");
+	    	}
+		}
+	}
+    axp_write(&axp->dev, POWER20_DATA_BUFFERC, 0x00);
+    mdelay(20);
+	axp_set_bits(&axp->dev, POWER20_OFF_CTL, 0x80);
+    mdelay(20);
+    printk("[axp] warning!!! axp can't power-off, maybe some error happend!\n");
+
+#endif
+}
+
+static int __devinit axp_mfd_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	struct axp_platform_data *pdata = client->dev.platform_data;
+	struct axp_mfd_chip *chip;
+	int ret;
+	chip = kzalloc(sizeof(struct axp_mfd_chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	axp = client;
+
+	chip->client = client;
+	chip->dev = &client->dev;
+	chip->ops = &axp_mfd_ops[id->driver_data];
+
+	mutex_init(&chip->lock);
+	INIT_WORK(&chip->irq_work, axp_mfd_irq_work);
+	BLOCKING_INIT_NOTIFIER_HEAD(&chip->notifier_list);
+
+	i2c_set_clientdata(client, chip);
+
+	ret = chip->ops->init_chip(chip);
+	if (ret)
+		goto out_free_chip;
+
+	ret = request_irq(client->irq, axp_mfd_irq_handler,
+		IRQF_DISABLED, "axp_mfd", chip);
+  	if (ret) {
+  		dev_err(&client->dev, "failed to request irq %d\n",
+  				client->irq);
+  		goto out_free_chip;
+  	}
+
+
+	ret = axp_mfd_add_subdevs(chip, pdata);
+	if (ret)
+		goto out_free_irq;
+
+	/* PM hookup */
+	if(!pm_power_off)
+		pm_power_off = axp_power_off;
+
+	ret = axp_mfd_create_attrs(chip);
+	if(ret){
+		return ret;
+	}
+	
+	/* set ac/usb_in shutdown mean restart */
+  	ret = script_parser_fetch("target", "power_start", &power_start, sizeof(int));
+  	if (ret)
+  	{
+    	printk("[AXP]axp driver uning configuration failed(%d)\n", __LINE__);
+     	power_start = 0;
+     	printk("[AXP]power_start = %d\n",power_start);
+  	}
+  	
+	return 0;
+
+out_free_irq:
+	free_irq(client->irq, chip);
+
+out_free_chip:
+	i2c_set_clientdata(client, NULL);
+	kfree(chip);
+
+	return ret;
+}
+
+static int __devexit axp_mfd_remove(struct i2c_client *client)
+{
+	struct axp_mfd_chip *chip = i2c_get_clientdata(client);
+
+	pm_power_off = NULL;
+	axp = NULL;
+
+	axp_mfd_remove_subdevs(chip);
+	kfree(chip);
+	return 0;
+}
+
+static struct i2c_driver axp_mfd_driver = {
+	.driver	= {
+		.name	= "axp_mfd",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp_mfd_probe,
+	.remove		= __devexit_p(axp_mfd_remove),
+	.id_table	= axp_mfd_id_table,
+};
+
+static int __init axp_mfd_init(void)
+{
+	return i2c_add_driver(&axp_mfd_driver);
+}
+subsys_initcall(axp_mfd_init);
+
+static void __exit axp_mfd_exit(void)
+{
+	i2c_del_driver(&axp_mfd_driver);
+}
+module_exit(axp_mfd_exit);
+
+MODULE_DESCRIPTION("PMIC MFD Driver for AXP");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/axp-regu.h b/drivers/power/axp_power/axp-regu.h
new file mode 100644
index 0000000..1142d49
--- /dev/null
+++ b/drivers/power/axp_power/axp-regu.h
@@ -0,0 +1,177 @@
+/*
+ * drivers/power/axp_power/axp-regu.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LINUX_AXP_REGU_H_
+#define _LINUX_AXP_REGU_H_
+
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+
+
+/* AXP18 Regulator Registers */
+#define AXP18_RTC			POWER18_STATUS
+#define AXP18_ANALOG		POWER18_LDOOUT_VOL
+#define AXP18_MOMERY		POWER18_LDOOUT_VOL
+#define AXP18_SPDIF			POWER18_SW_CTL
+#define AXP18_IO			POWER18_DC12OUT_VOL
+#define AXP18_CORE			POWER18_DC12OUT_VOL
+#define AXP18_SDRAM			POWER18_DC12OUT_VOL
+#define AXP18_SDCARD		POWER18_DC12OUT_VOL
+
+#define AXP18_LDO1EN		POWER18_STATUS
+#define AXP18_LDO2EN		POWER18_DCDCCTL
+#define AXP18_LDO3EN		POWER18_LDOOUT_VOL
+#define AXP18_LDO4EN		POWER18_SW_CTL
+#define AXP18_LDO5EN		POWER18_SW_CTL
+#define AXP18_DCDC1EN		POWER18_STATUS
+#define AXP18_DCDC2EN		POWER18_STATUS
+#define AXP18_DCDC3EN		POWER18_DCDCCTL
+#define AXP18_SW1EN			POWER18_SW_CTL
+#define AXP18_SW2EN			POWER18_SW_CTL
+
+#define AXP18_BUCKMODE		POWER18_DCDCCTL
+#define AXP18_BUCKFREQ		POWER18_PEK
+
+
+/* AXP19 Regulator Registers */
+#define AXP19_RTC		    POWER19_STATUS
+#define AXP19_ANALOG1		POWER19_LDO24OUT_VOL
+#define AXP19_DIGITAL      POWER19_LDO3OUT_VOL
+#define AXP19_ANALOG2      POWER19_LDO24OUT_VOL
+#define AXP19_LDOIO0       POWER19_GPIO0_VOL
+#define AXP19_IO           POWER19_DC1OUT_VOL
+#define AXP19_CORE         POWER19_DC2OUT_VOL
+#define AXP19_MEMORY       POWER19_DC3OUT_VOL
+
+#define AXP19_LDO1EN		POWER19_STATUS
+#define AXP19_LDO2EN		POWER19_LDO24_DC13_CTL
+#define AXP19_LDO3EN		POWER19_LDO3_DC2_CTL
+#define AXP19_LDO4EN		POWER19_LDO24_DC13_CTL
+#define AXP19_LDOIOEN		POWER19_GPIO0_CTL
+#define AXP19_DCDC1EN      POWER19_LDO24_DC13_CTL
+#define AXP19_DCDC2EN      POWER19_LDO3_DC2_CTL
+#define AXP19_DCDC3EN      POWER19_LDO24_DC13_CTL
+
+#define AXP19_BUCKMODE     POWER19_DCDC_MODESET
+#define AXP19_BUCKFREQ     POWER19_DCDC_FREQSET
+
+/* AXP20 Regulator Registers */
+#define AXP20_LDO1		    POWER20_STATUS
+#define AXP20_LDO2		POWER20_LDO24OUT_VOL
+#define AXP20_LDO3       POWER20_LDO3OUT_VOL
+#define AXP20_LDO4      POWER20_LDO24OUT_VOL
+#define AXP20_BUCK2      POWER20_DC2OUT_VOL
+#define AXP20_BUCK3       POWER20_DC3OUT_VOL
+#define AXP20_LDOIO0		POWER20_GPIO0_VOL
+
+#define AXP20_LDO1EN		POWER20_STATUS
+#define AXP20_LDO2EN		POWER20_LDO234_DC23_CTL
+#define AXP20_LDO3EN		POWER20_LDO234_DC23_CTL
+#define AXP20_LDO4EN		POWER20_LDO234_DC23_CTL
+#define AXP20_BUCK2EN      POWER20_LDO234_DC23_CTL
+#define AXP20_BUCK3EN      POWER20_LDO234_DC23_CTL
+#define AXP20_LDOIOEN		POWER20_GPIO0_CTL
+
+
+#define AXP20_BUCKMODE     POWER20_DCDC_MODESET
+#define AXP20_BUCKFREQ     POWER20_DCDC_FREQSET
+
+
+#define AXP_LDO(_pmic, _id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+{									\
+	.desc	= {							\
+		.name	= #_pmic"_LDO" #_id,					\
+		.type	= REGULATOR_VOLTAGE,				\
+		.id	= _pmic##_ID_LDO##_id,				\
+		.n_voltages = (step) ? ((max - min) / step + 1) : 1,	\
+		.owner	= THIS_MODULE,					\
+	},								\
+	.min_uV		= (min) * 1000,					\
+	.max_uV		= (max) * 1000,					\
+	.step_uV	= (step) * 1000,				\
+	.vol_reg	= _pmic##_##vreg,				\
+	.vol_shift	= (shift),					\
+	.vol_nbits	= (nbits),					\
+	.enable_reg	= _pmic##_##ereg,				\
+	.enable_bit	= (ebit),					\
+}
+
+#define AXP_BUCK(_pmic, _id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+{									\
+	.desc	= {							\
+		.name	= #_pmic"_BUCK" #_id,					\
+		.type	= REGULATOR_VOLTAGE,				\
+		.id	= _pmic##_ID_BUCK##_id,				\
+		.n_voltages = (step) ? ((max - min) / step + 1) : 1,	\
+		.owner	= THIS_MODULE,					\
+	},								\
+	.min_uV		= (min) * 1000,					\
+	.max_uV		= (max) * 1000,					\
+	.step_uV	= (step) * 1000,				\
+	.vol_reg	= _pmic##_##vreg,				\
+	.vol_shift	= (shift),					\
+	.vol_nbits	= (nbits),					\
+	.enable_reg	= _pmic##_##ereg,				\
+	.enable_bit	= (ebit),					\
+}
+
+#define AXP_SW(_pmic, _id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+{									\
+	.desc	= {							\
+		.name	= #_pmic"_SW" #_id,					\
+		.type	= REGULATOR_VOLTAGE,				\
+		.id	= _pmic##_ID_SW##_id,				\
+		.n_voltages = (step) ? ((max - min) / step + 1) : 1,	\
+		.owner	= THIS_MODULE,					\
+	},								\
+	.min_uV		= (min) * 1000,					\
+	.max_uV		= (max) * 1000,					\
+	.step_uV	= (step) * 1000,				\
+	.vol_reg	= _pmic##_##vreg,				\
+	.vol_shift	= (shift),					\
+	.vol_nbits	= (nbits),					\
+	.enable_reg	= _pmic##_##ereg,				\
+	.enable_bit	= (ebit),					\
+}
+
+#define AXP_REGU_ATTR(_name)					\
+{									\
+	.attr = { .name = #_name,.mode = 0644 },					\
+	.show =  _name##_show,				\
+	.store = _name##_store, \
+}
+
+struct axp_regulator_info {
+	struct regulator_desc desc;
+
+	int	min_uV;
+	int	max_uV;
+	int	step_uV;
+	int	vol_reg;
+	int	vol_shift;
+	int	vol_nbits;
+	int	enable_reg;
+	int	enable_bit;
+};
+
+#endif
diff --git a/drivers/power/axp_power/axp-rw.h b/drivers/power/axp_power/axp-rw.h
new file mode 100644
index 0000000..3f85958
--- /dev/null
+++ b/drivers/power/axp_power/axp-rw.h
@@ -0,0 +1,213 @@
+/*
+ * drivers/power/axp_power/axp-rw.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _LINUX_AXP_RW_H_
+#define _LINUX_AXP_RW_H_
+
+#include <linux/mfd/axp-mfd.h>
+
+static uint8_t axp_reg_addr = 0;
+
+struct i2c_client *axp;
+EXPORT_SYMBOL_GPL(axp);
+
+static inline int __axp_read(struct i2c_client *client,
+				int reg, uint8_t *val)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed reading at 0x%02x\n", reg);
+		return ret;
+	}
+
+	*val = (uint8_t)ret;
+	return 0;
+}
+
+static inline int __axp_reads(struct i2c_client *client, int reg,
+				 int len, uint8_t *val)
+{
+	int ret;
+
+	ret = i2c_smbus_read_i2c_block_data(client, reg, len, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed reading from 0x%02x\n", reg);
+		return ret;
+	}
+	return 0;
+}
+
+static inline int __axp_write(struct i2c_client *client,
+				 int reg, uint8_t val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n",
+				val, reg);
+		return ret;
+	}
+	return 0;
+}
+
+
+static inline int __axp_writes(struct i2c_client *client, int reg,
+				  int len, uint8_t *val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_i2c_block_data(client, reg, len, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed writings to 0x%02x\n", reg);
+		return ret;
+	}
+	return 0;
+}
+
+int axp_register_notifier(struct device *dev, struct notifier_block *nb,
+				uint64_t irqs)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+
+	chip->ops->enable_irqs(chip, irqs);
+	if(NULL != nb) {
+	    return blocking_notifier_chain_register(&chip->notifier_list, nb);
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL_GPL(axp_register_notifier);
+
+int axp_unregister_notifier(struct device *dev, struct notifier_block *nb,
+				uint64_t irqs)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+
+	chip->ops->disable_irqs(chip, irqs);
+	if(NULL != nb) {
+	    return blocking_notifier_chain_unregister(&chip->notifier_list, nb);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_unregister_notifier);
+
+int axp_write(struct device *dev, int reg, uint8_t val)
+{
+	return __axp_write(to_i2c_client(dev), reg, val);
+}
+EXPORT_SYMBOL_GPL(axp_write);
+
+int axp_writes(struct device *dev, int reg, int len, uint8_t *val)
+{
+	return  __axp_writes(to_i2c_client(dev), reg, len, val);
+}
+EXPORT_SYMBOL_GPL(axp_writes);
+
+int axp_read(struct device *dev, int reg, uint8_t *val)
+{
+	return __axp_read(to_i2c_client(dev), reg, val);
+}
+EXPORT_SYMBOL_GPL(axp_read);
+
+int axp_reads(struct device *dev, int reg, int len, uint8_t *val)
+{
+	return __axp_reads(to_i2c_client(dev), reg, len, val);
+}
+EXPORT_SYMBOL_GPL(axp_reads);
+
+int axp_set_bits(struct device *dev, int reg, uint8_t bit_mask)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+	uint8_t reg_val;
+	int ret = 0;
+
+	mutex_lock(&chip->lock);
+
+	ret = __axp_read(chip->client, reg, &reg_val);
+	if (ret)
+		goto out;
+
+	if ((reg_val & bit_mask) != bit_mask) {
+		reg_val |= bit_mask;
+		ret = __axp_write(chip->client, reg, reg_val);
+	}
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_set_bits);
+
+int axp_clr_bits(struct device *dev, int reg, uint8_t bit_mask)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+	uint8_t reg_val;
+	int ret = 0;
+
+	mutex_lock(&chip->lock);
+
+	ret = __axp_read(chip->client, reg, &reg_val);
+	if (ret)
+		goto out;
+
+	if (reg_val & bit_mask) {
+		reg_val &= ~bit_mask;
+		ret = __axp_write(chip->client, reg, reg_val);
+	}
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_clr_bits);
+
+int axp_update(struct device *dev, int reg, uint8_t val, uint8_t mask)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+	uint8_t reg_val;
+	int ret = 0;
+
+	mutex_lock(&chip->lock);
+
+	ret = __axp_read(chip->client, reg, &reg_val);
+	if (ret)
+		goto out;
+
+	if ((reg_val & mask) != val) {
+		reg_val = (reg_val & ~mask) | val;
+		ret = __axp_write(chip->client, reg, reg_val);
+	}
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_update);
+
+struct device *axp_get_dev(void)
+{
+	return &axp->dev;
+}
+EXPORT_SYMBOL_GPL(axp_get_dev);
+
+#endif
\ No newline at end of file
diff --git a/drivers/power/axp_power/axp-sply.h b/drivers/power/axp_power/axp-sply.h
new file mode 100644
index 0000000..72c1072
--- /dev/null
+++ b/drivers/power/axp_power/axp-sply.h
@@ -0,0 +1,440 @@
+/*
+ * drivers/power/axp_power/axp-sply.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef	_LINUX_AXP_SPLY_H_
+#define	_LINUX_AXP_SPLY_H_
+
+/*      AXP18      */
+#define	AXP18_STATUS						POWER18_STATUS
+#define	AXP18_CHARGE_STATUS					POWER18_ONOFF
+#define	AXP18_IN_CHARGE						(1 << 2)
+
+#define	AXP18_CHARGE_CONTROL1				POWER18_CHARGE1
+#define	AXP18_CHARGER_ENABLE				(1 << 7)
+#define	AXP18_CHG_CURLIM_ENABLE				(1 << 3)
+#define AXP18_CHARGE_CONTROL2				POWER18_CHARGE2
+
+#define	AXP18_FAULT_LOG1					POWER18_INTSTS1
+#define	AXP18_FAULT_LOG2					POWER18_INTSTS3
+#define	AXP18_FAULT_LOG_BATINACT			(1 << 0)
+#define	AXP18_FAULT_LOG_COLD				(1 << 1)
+#define	AXP18_FAULT_LOG_OVER_TEMP			(1 << 2)
+#define	AXP18_FAULT_LOG_VBAT_LOW			(1 << 6)
+#define	AXP18_FAULT_LOG_VBAT_OVER			(1 << 7)
+
+#define	AXP18_FINISH_CHARGE					(1 << 2)
+
+#define	AXP18_ADC_CONTROL					POWER18_ADCSW_CTL
+#define	AXP18_ADC_BATVOL_ENABLE				(1 << 7)
+#define	AXP18_ADC_BATCUR_ENABLE				(1 << 6)
+#define	AXP18_ADC_ACVOL_ENABLE				(1 << 5)
+#define	AXP18_ADC_ACCUR_ENABLE				(1 << 4)
+
+#define	AXP18_DATA_BUFFER1					POWER18_DATA_BUFFER1
+#define	AXP18_DATA_BUFFER2					POWER18_DATA_BUFFER2
+
+#define	AXP18_VBAT_RES						POWER18_BATTERY_VOL
+#define	AXP18_IBAT_RES						POWER18_BATTERY_CURRENT
+#define	AXP18_VAC_RES						POWER18_DCIN_VOL
+#define	AXP18_IAC_RES						POWER18_DCIN_CURRENT
+
+#define AXP18_CHARGE_VBUS					POWER18_IPS_SET
+
+
+static 	struct input_dev * powerkeydev;
+
+const unsigned int AXP18_NOTIFIER_ON	=	AXP18_IRQ_EXTOV |
+											AXP18_IRQ_EXTIN |
+											AXP18_IRQ_EXTRE |
+											AXP18_IRQ_EXTLO |
+											AXP18_IRQ_TEMOV |
+											AXP18_IRQ_TEMLO |
+											AXP18_IRQ_BATIN |
+											AXP18_IRQ_BATRE |
+											AXP18_IRQ_PEKLO |
+											AXP18_IRQ_PEKSH ;
+
+/*      AXP19      */
+#define AXP19_CHARGE_STATUS					POWER19_STATUS
+#define AXP19_IN_CHARGE						(1 << 6)
+
+#define AXP19_CHARGE_CONTROL1				POWER19_CHARGE1
+#define AXP19_CHARGER_ENABLE				(1 << 7)
+#define AXP19_CHARGE_CONTROL2				POWER19_CHARGE2
+#define AXP19_BUCHARGE_CONTROL				POWER19_BACKUP_CHG
+#define AXP19_BUCHARGER_ENABLE				(1 << 7)
+
+
+#define AXP19_FAULT_LOG1					POWER19_MODE_CHGSTATUS
+#define AXP19_FAULT_LOG_CHA_CUR_LOW			(1 << 2)
+#define AXP19_FAULT_LOG_BATINACT			(1 << 3)
+
+#define AXP19_FAULT_LOG_OVER_TEMP			(1 << 7)
+
+#define AXP19_FAULT_LOG2					POWER19_INTSTS2
+#define AXP19_FAULT_LOG_COLD				(1 << 0)
+
+#define AXP19_FINISH_CHARGE					(1 << 2)
+
+
+#define AXP19_ADC_CONTROL1					POWER19_ADC_EN1
+#define AXP19_ADC_BATVOL_ENABLE				(1 << 7)
+#define AXP19_ADC_BATCUR_ENABLE				(1 << 6)
+#define AXP19_ADC_DCINVOL_ENABLE			(1 << 5)
+#define AXP19_ADC_DCINCUR_ENABLE			(1 << 4)
+#define AXP19_ADC_USBVOL_ENABLE				(1 << 3)
+#define AXP19_ADC_USBCUR_ENABLE				(1 << 2)
+#define AXP19_ADC_APSVOL_ENABLE				(1 << 1)
+#define AXP19_ADC_TSVOL_ENABLE				(1 << 0)
+#define AXP19_ADC_CONTROL2					POWER19_ADC_EN2
+#define AXP19_ADC_INTERTEM_ENABLE			(1 << 7)
+
+#define AXP19_ADC_GPIO0_ENABLE				(1 << 3)
+#define AXP19_ADC_GPIO1_ENABLE				(1 << 2)
+#define AXP19_ADC_GPIO2_ENABLE				(1 << 1)
+#define AXP19_ADC_GPIO3_ENABLE				(1 << 0)
+#define AXP19_ADC_CONTROL3					POWER19_ADC_SPEED
+
+
+#define AXP19_VACH_RES						POWER19_ACIN_VOL_H8
+#define AXP19_VACL_RES						POWER19_ACIN_VOL_L4
+#define AXP19_IACH_RES						POWER19_ACIN_CUR_H8
+#define AXP19_IACL_RES						POWER19_ACIN_CUR_L4
+#define AXP19_VUSBH_RES						POWER19_VBUS_VOL_H8
+#define AXP19_VUSBL_RES						POWER19_VBUS_VOL_L4
+#define AXP19_IUSBH_RES						POWER19_VBUS_CUR_H8
+#define AXP19_IUSBL_RES						POWER19_VBUS_CUR_L4
+#define AXP19_TICH_RES						(0x5E)
+#define AXP19_TICL_RES						(0x5F)
+
+#define AXP19_TSH_RES						(0x62)
+#define AXP19_ISL_RES						(0x63)
+#define AXP19_VGPIO0H_RES					(0x64)
+#define AXP19_VGPIO0L_RES					(0x65)
+#define AXP19_VGPIO1H_RES					(0x66)
+#define AXP19_VGPIO1L_RES					(0x67)
+#define AXP19_VGPIO2H_RES					(0x68)
+#define AXP19_VGPIO2L_RES					(0x69)
+#define AXP19_VGPIO3H_RES					(0x6A)
+#define AXP19_VGPIO3L_RES					(0x6B)
+
+#define AXP19_PBATH_RES						POWER19_BAT_POWERH8
+#define AXP19_PBATM_RES						POWER19_BAT_POWERM8
+#define AXP19_PBATL_RES						POWER19_BAT_POWERL8
+
+#define AXP19_VBATH_RES						POWER19_BAT_AVERVOL_H8
+#define AXP19_VBATL_RES						POWER19_BAT_AVERVOL_L4
+#define AXP19_ICHARH_RES					POWER19_BAT_AVERCHGCUR_H8
+#define AXP19_ICHARL_RES					POWER19_BAT_AVERCHGCUR_L5
+#define AXP19_IDISCHARH_RES					POWER19_BAT_AVERDISCHGCUR_H8
+#define AXP19_IDISCHARL_RES					POWER19_BAT_AVERDISCHGCUR_L5
+#define AXP19_VAPSH_RES						POWER19_APS_AVERVOL_H8
+#define AXP19_VAPSL_RES						POWER19_APS_AVERVOL_L4
+
+
+#define AXP19_COULOMB_CONTROL				POWER19_COULOMB_CTL
+#define AXP19_COULOMB_ENABLE				(1 << 7)
+#define AXP19_COULOMB_SUSPEND				(1 << 6)
+#define AXP19_COULOMB_CLEAR					(1 << 5)
+
+#define AXP19_CCHAR3_RES					POWER19_BAT_CHGCOULOMB3
+#define AXP19_CCHAR2_RES					POWER19_BAT_CHGCOULOMB2
+#define AXP19_CCHAR1_RES					POWER19_BAT_CHGCOULOMB1
+#define AXP19_CCHAR0_RES					POWER19_BAT_CHGCOULOMB0
+#define AXP19_CDISCHAR3_RES					POWER19_BAT_DISCHGCOULOMB3
+#define AXP19_CDISCHAR2_RES					POWER19_BAT_DISCHGCOULOMB2
+#define AXP19_CDISCHAR1_RES					POWER19_BAT_DISCHGCOULOMB1
+#define AXP19_CDISCHAR0_RES					POWER19_BAT_DISCHGCOULOMB0
+
+#define AXP19_DATA_BUFFER0					POWER19_DATA_BUFFER1
+#define AXP19_DATA_BUFFER1					POWER19_DATA_BUFFER2
+#define AXP19_DATA_BUFFER2					POWER19_DATA_BUFFER3
+#define AXP19_DATA_BUFFER3					POWER19_DATA_BUFFER4
+
+#define AXP19_CHARGE_VBUS					POWER19_IPS_SET
+
+#define AXP19_CHARGE_LED					POWER19_OFF_CTL
+
+#define AXP19_TIMER_CTL						POWER19_TIMER_CTL
+
+const unsigned int AXP19_NOTIFIER_ON = 		AXP19_IRQ_USBOV |
+											AXP19_IRQ_USBIN |
+				        					AXP19_IRQ_USBRE |
+				       						AXP19_IRQ_USBLO |
+				       						AXP19_IRQ_ACOV |
+				       						AXP19_IRQ_ACIN |
+				       						AXP19_IRQ_ACRE |
+				       						AXP19_IRQ_TEMOV |
+				       						AXP19_IRQ_TEMLO |
+				       						AXP19_IRQ_BATIN |
+				       						AXP19_IRQ_BATRE |
+				       						AXP19_IRQ_PEKLO |
+				       						AXP19_IRQ_PEKSH ;
+
+
+/*      AXP20      */
+#define AXP20_CHARGE_STATUS					POWER20_STATUS
+#define AXP20_IN_CHARGE						(1 << 6)
+
+#define AXP20_CHARGE_CONTROL1				POWER20_CHARGE1
+#define AXP20_CHARGER_ENABLE				(1 << 7)
+#define AXP20_CHARGE_CONTROL2				POWER20_CHARGE2
+#define AXP20_BUCHARGE_CONTROL				POWER20_BACKUP_CHG
+#define AXP20_BUCHARGER_ENABLE				(1 << 7)
+
+
+#define AXP20_FAULT_LOG1					POWER20_MODE_CHGSTATUS
+#define AXP20_FAULT_LOG_CHA_CUR_LOW			(1 << 2)
+#define AXP20_FAULT_LOG_BATINACT			(1 << 3)
+
+#define AXP20_FAULT_LOG_OVER_TEMP			(1 << 7)
+
+#define AXP20_FAULT_LOG2					POWER20_INTSTS2
+#define AXP20_FAULT_LOG_COLD				(1 << 0)
+
+#define AXP20_FINISH_CHARGE					(1 << 2)
+
+
+#define AXP20_ADC_CONTROL1					POWER20_ADC_EN1
+#define AXP20_ADC_BATVOL_ENABLE				(1 << 7)
+#define AXP20_ADC_BATCUR_ENABLE				(1 << 6)
+#define AXP20_ADC_DCINVOL_ENABLE			(1 << 5)
+#define AXP20_ADC_DCINCUR_ENABLE			(1 << 4)
+#define AXP20_ADC_USBVOL_ENABLE				(1 << 3)
+#define AXP20_ADC_USBCUR_ENABLE				(1 << 2)
+#define AXP20_ADC_APSVOL_ENABLE				(1 << 1)
+#define AXP20_ADC_TSVOL_ENABLE				(1 << 0)
+#define AXP20_ADC_CONTROL2					POWER20_ADC_EN2
+#define AXP20_ADC_INTERTEM_ENABLE			(1 << 7)
+
+#define AXP20_ADC_GPIO0_ENABLE				(1 << 3)
+#define AXP20_ADC_GPIO1_ENABLE				(1 << 2)
+#define AXP20_ADC_GPIO2_ENABLE				(1 << 1)
+#define AXP20_ADC_GPIO3_ENABLE				(1 << 0)
+#define AXP20_ADC_CONTROL3					POWER20_ADC_SPEED
+
+
+#define AXP20_VACH_RES						POWER20_ACIN_VOL_H8
+#define AXP20_VACL_RES						POWER20_ACIN_VOL_L4
+#define AXP20_IACH_RES						POWER20_ACIN_CUR_H8
+#define AXP20_IACL_RES						POWER20_ACIN_CUR_L4
+#define AXP20_VUSBH_RES						POWER20_VBUS_VOL_H8
+#define AXP20_VUSBL_RES						POWER20_VBUS_VOL_L4
+#define AXP20_IUSBH_RES						POWER20_VBUS_CUR_H8
+#define AXP20_IUSBL_RES						POWER20_VBUS_CUR_L4
+#define AXP20_TICH_RES						(0x5E)
+#define AXP20_TICL_RES						(0x5F)
+
+#define AXP20_TSH_RES						(0x62)
+#define AXP20_ISL_RES						(0x63)
+#define AXP20_VGPIO0H_RES					(0x64)
+#define AXP20_VGPIO0L_RES					(0x65)
+#define AXP20_VGPIO1H_RES					(0x66)
+#define AXP20_VGPIO1L_RES					(0x67)
+#define AXP20_VGPIO2H_RES					(0x68)
+#define AXP20_VGPIO2L_RES					(0x69)
+#define AXP20_VGPIO3H_RES					(0x6A)
+#define AXP20_VGPIO3L_RES					(0x6B)
+
+#define AXP20_PBATH_RES						POWER20_BAT_POWERH8
+#define AXP20_PBATM_RES						POWER20_BAT_POWERM8
+#define AXP20_PBATL_RES						POWER20_BAT_POWERL8
+
+#define AXP20_VBATH_RES						POWER20_BAT_AVERVOL_H8
+#define AXP20_VBATL_RES						POWER20_BAT_AVERVOL_L4
+#define AXP20_ICHARH_RES					POWER20_BAT_AVERCHGCUR_H8
+#define AXP20_ICHARL_RES					POWER20_BAT_AVERCHGCUR_L5
+#define AXP20_IDISCHARH_RES					POWER20_BAT_AVERDISCHGCUR_H8
+#define AXP20_IDISCHARL_RES					POWER20_BAT_AVERDISCHGCUR_L5
+#define AXP20_VAPSH_RES						POWER20_APS_AVERVOL_H8
+#define AXP20_VAPSL_RES						POWER20_APS_AVERVOL_L4
+
+
+#define AXP20_COULOMB_CONTROL				POWER20_COULOMB_CTL
+#define AXP20_COULOMB_ENABLE				(1 << 7)
+#define AXP20_COULOMB_SUSPEND				(1 << 6)
+#define AXP20_COULOMB_CLEAR					(1 << 5)
+
+#define AXP20_CCHAR3_RES					POWER20_BAT_CHGCOULOMB3
+#define AXP20_CCHAR2_RES					POWER20_BAT_CHGCOULOMB2
+#define AXP20_CCHAR1_RES					POWER20_BAT_CHGCOULOMB1
+#define AXP20_CCHAR0_RES					POWER20_BAT_CHGCOULOMB0
+#define AXP20_CDISCHAR3_RES					POWER20_BAT_DISCHGCOULOMB3
+#define AXP20_CDISCHAR2_RES					POWER20_BAT_DISCHGCOULOMB2
+#define AXP20_CDISCHAR1_RES					POWER20_BAT_DISCHGCOULOMB1
+#define AXP20_CDISCHAR0_RES					POWER20_BAT_DISCHGCOULOMB0
+
+#define AXP20_DATA_BUFFER0					POWER20_DATA_BUFFER1
+#define AXP20_DATA_BUFFER1					POWER20_DATA_BUFFER2
+#define AXP20_DATA_BUFFER2					POWER20_DATA_BUFFER3
+#define AXP20_DATA_BUFFER3					POWER20_DATA_BUFFER4
+#define AXP20_DATA_BUFFER4					POWER20_DATA_BUFFER5
+#define AXP20_DATA_BUFFER5					POWER20_DATA_BUFFER6
+#define AXP20_DATA_BUFFER6					POWER20_DATA_BUFFER7
+#define AXP20_DATA_BUFFER7					POWER20_DATA_BUFFER8
+#define AXP20_DATA_BUFFER8					POWER20_DATA_BUFFER9
+#define AXP20_DATA_BUFFER9					POWER20_DATA_BUFFERA
+#define AXP20_DATA_BUFFERA					POWER20_DATA_BUFFERB
+#define AXP20_DATA_BUFFERB					POWER20_DATA_BUFFERC
+#define AXP20_IC_TYPE								POWER20_IC_TYPE
+
+#define AXP20_CAP									(0xB9)
+
+#define AXP20_CHARGE_VBUS					POWER20_IPS_SET
+#define AXP20_APS_WARNING1				POWER20_APS_WARNING1
+#define AXP20_APS_WARNING2				POWER20_APS_WARNING2
+#define AXP20_TIMER_CTL						POWER20_TIMER_CTL
+
+#define AXP20_INTTEMP							(0x5E)
+
+const unsigned int AXP20_NOTIFIER_ON = 		//AXP20_IRQ_USBOV |
+											AXP20_IRQ_USBIN |
+				        					AXP20_IRQ_USBRE |
+				       						//AXP20_IRQ_USBLO |
+				       						//AXP20_IRQ_ACOV |
+				       						AXP20_IRQ_ACIN |
+				       						AXP20_IRQ_ACRE |
+				       						//AXP20_IRQ_TEMOV |
+				       						//AXP20_IRQ_TEMLO |
+				       						AXP20_IRQ_BATIN |
+				       						AXP20_IRQ_BATRE |
+				       						AXP20_IRQ_PEKLO |
+				       						AXP20_IRQ_PEKSH |
+				       						AXP20_IRQ_CHAST	|
+				       						AXP20_IRQ_CHAOV;
+
+
+
+#define AXP_CHG_ATTR(_name)					\
+{									\
+	.attr = { .name = #_name,.mode = 0644 },					\
+	.show =  _name##_show,				\
+	.store = _name##_store, \
+}
+
+struct axp_adc_res {//struct change
+	uint16_t vbat_res;
+	uint16_t ibat_res;
+	uint16_t ichar_res;
+	uint16_t idischar_res;
+	uint16_t vac_res;
+	uint16_t iac_res;
+	uint16_t vusb_res;
+	uint16_t iusb_res;
+};
+
+struct axp_charger {
+	/*power supply sysfs*/
+	struct power_supply batt;
+	struct power_supply	ac;
+	struct power_supply	usb;
+	struct power_supply bubatt;
+
+	/*i2c device*/
+	struct device *master;
+
+	/* adc */
+	struct axp_adc_res *adc;
+	unsigned int sample_time;
+
+	/*monitor*/
+	struct delayed_work work;
+	unsigned int interval;
+
+	/*battery info*/
+	struct power_supply_info *battery_info;
+
+	/*charger control*/
+	bool chgen;
+	bool limit_on;
+	unsigned int chgcur;
+	unsigned int chgvol;
+	unsigned int chgend;
+
+	/*charger time */
+	int chgpretime;
+	int chgcsttime;
+
+	/*external charger*/
+	bool chgexten;
+	int chgextcur;
+
+	/* charger status */
+	bool bat_det;
+	bool is_on;
+	bool is_finish;
+	bool ac_not_enough;
+	bool ac_det;
+	bool usb_det;
+	bool ac_valid;
+	bool usb_valid;
+	bool ext_valid;
+	bool bat_current_direction;
+	bool in_short;
+	bool batery_active;
+	bool low_charge_current;
+	bool int_over_temp;
+	uint8_t fault;
+	int charge_on;
+
+	int vbat;
+	int ibat;
+	int pbat;
+	int vac;
+	int iac;
+	int vusb;
+	int iusb;
+	int ocv;
+	
+	int disvbat;
+	int disibat;
+
+	/*rest time*/
+	int rest_vol;
+	int ocv_rest_vol;
+	int base_restvol;
+	int rest_time;
+
+	/*ic temperature*/
+	int ic_temp;
+
+	/*irq*/
+	struct notifier_block nb;
+
+	/* platform callbacks for battery low and critical events */
+	void (*battery_low)(void);
+	void (*battery_critical)(void);
+
+	struct dentry *debug_file;
+};
+
+static struct task_struct *main_task;
+static uint8_t coulomb_flag;
+static struct axp_charger *axp_charger;
+static int Total_Cap = 0;
+static int Cap_Index = 0;
+static int flag_state_change = 0;
+static int Bat_Cap_Buffer[AXP20_VOL_MAX];
+static int counter = 0;
+static int bat_cap = 0;
+
+#endif
diff --git a/drivers/power/axp_power/axp18-board.c b/drivers/power/axp_power/axp18-board.c
new file mode 100644
index 0000000..48d1b27
--- /dev/null
+++ b/drivers/power/axp_power/axp18-board.c
@@ -0,0 +1,348 @@
+/*
+ * drivers/power/axp_power/axp18-board.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/apm_bios.h>
+#include <linux/apm-emulation.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+
+
+/* Reverse engineered partly from Platformx drivers */
+enum axp_regls{
+
+	vcc_ldo1,
+	vcc_ldo2,
+	vcc_ldo3,
+	vcc_ldo4,
+	vcc_ldo5,
+
+	vcc_buck1,
+	vcc_buck2,
+	vcc_buck3,
+	vcc_sw1,
+	vcc_sw2,
+};
+
+/* The values of the various regulator constraints are obviously dependent
+ * on exactly what is wired to each ldo.  Unfortunately this information is
+ * not generally available.  More information has been requested from Xbow
+ * but as of yet they haven't been forthcoming.
+ *
+ * Some of these are clearly Stargate 2 related (no way of plugging
+ * in an lcd on the IM2 for example!).
+ */
+
+static struct regulator_consumer_supply ldo1_data[] = {
+		{
+			.supply = "axp18_rtc",
+		},
+	};
+
+
+static struct regulator_consumer_supply ldo2_data[] = {
+		{
+			.supply = "axp18_analog/fm",
+		},
+	};
+
+static struct regulator_consumer_supply ldo3_data[] = {
+		{
+			.supply = "axp18_flash",
+		},
+	};
+
+static struct regulator_consumer_supply ldo4_data[] = {
+		{
+			.supply = "axp18_spdif",
+		},
+	};
+
+static struct regulator_consumer_supply ldo5_data[] = {
+		{
+			.supply = "axp18_others",
+		},
+	};
+
+static struct regulator_consumer_supply buck1_data[] = {
+		{
+			.supply = "axp18_io",
+		},{
+			.supply = "axp18_sw1",
+		},{
+			.supply = "axp18_sw2",
+		},
+	};
+
+static struct regulator_consumer_supply buck2_data[] = {
+		{
+			.supply = "axp18_core",
+		},
+	};
+
+static struct regulator_consumer_supply buck3_data[] = {
+		{
+			.supply = "axp18_memory",
+		},
+	};
+
+static struct regulator_consumer_supply sw1_data[] = {
+		{
+			.supply = "axp18_sdram",
+		},
+	};
+
+static struct regulator_consumer_supply sw2_data[] = {
+		{
+			.supply = "axp18_sdcard",
+		},
+	};
+
+
+static struct regulator_init_data axp_regl_init_data[] = {
+	[vcc_ldo1] = {
+		.constraints = { /* board default 1.25V */
+			.name = "axp18_ldo1",
+			.min_uV =  LDO1MIN * 1000,
+			.max_uV =  LDO1MAX * 1000,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_data),
+		.consumer_supplies = ldo1_data,
+	},
+	[vcc_ldo2] = {
+		.constraints = { /* board default 3.0V */
+			.name = "axp18_ldo2",
+			.min_uV = 2800000,
+			.max_uV = 3100000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_data),
+		.consumer_supplies = ldo2_data,
+
+	},
+	[vcc_ldo3] = {
+		.constraints = {/* default is 1.8V */
+			.name = "axp18_ldo3",
+			.min_uV =  LDO3MIN * 1000,
+			.max_uV =  LDO3MAX * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_data),
+		.consumer_supplies = ldo3_data,
+
+	},
+	[vcc_ldo4] = {
+		.constraints = {
+			/* board default is 3.3V */
+			.name = "axp18_ldo4",
+			.min_uV = 2700000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_data),
+		.consumer_supplies = ldo4_data,
+	},
+	[vcc_ldo5] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp18_ldo5",
+			.min_uV = 2500000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo5_data),
+		.consumer_supplies = ldo5_data,
+	},
+	[vcc_buck1] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp18_buck1",
+			.min_uV = 2800000,
+			.max_uV = 3500000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE ,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck1_data),
+		.consumer_supplies = buck1_data,
+	},
+	[vcc_buck2] = {
+		.constraints = { /* default 1.24V */
+			.name = "axp18_buck2",
+			.min_uV = DCDC2MIN * 1000,
+			.max_uV = DCDC2MAX * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck2_data),
+		.consumer_supplies = buck2_data,
+	},
+	[vcc_buck3] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp18_buck3",
+			.min_uV = DCDC3MIN * 1000,
+			.max_uV = DCDC3MAX * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck3_data),
+		.consumer_supplies = buck3_data,
+	},
+	[vcc_sw1] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp18_sw1",
+			.min_uV = 2800000,
+			.max_uV = 3500000,
+			.valid_ops_mask =  REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(sw1_data),
+		.consumer_supplies = sw1_data,
+	},
+	[vcc_sw2] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp18_sw2",
+			.min_uV = 2800000,
+			.max_uV = 3500000,
+			.valid_ops_mask =  REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(sw2_data),
+		.consumer_supplies = sw2_data,
+	},
+};
+
+static struct axp_funcdev_info axp_regldevs[] = {
+	{
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO1,
+		.platform_data = &axp_regl_init_data[vcc_ldo1],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO2,
+		.platform_data = &axp_regl_init_data[vcc_ldo2],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO3,
+		.platform_data = &axp_regl_init_data[vcc_ldo3],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO4,
+		.platform_data = &axp_regl_init_data[vcc_ldo4],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_LDO5,
+		.platform_data = &axp_regl_init_data[vcc_ldo5],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_BUCK1,
+		.platform_data = &axp_regl_init_data[vcc_buck1],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_BUCK2,
+		.platform_data = &axp_regl_init_data[vcc_buck2],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_BUCK3,
+		.platform_data = &axp_regl_init_data[vcc_buck3],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_SW1,
+		.platform_data = &axp_regl_init_data[vcc_sw1],
+	}, {
+		.name = "axp18-regulator",
+		.id = AXP18_ID_SW2,
+		.platform_data = &axp_regl_init_data[vcc_sw2],
+	},
+};
+
+static struct power_supply_info battery_data ={
+    .name ="axp18-battery",
+    .technology = POWER_SUPPLY_TECHNOLOGY_LION,
+    .voltage_max_design = 4200000,
+    .voltage_min_design = 2700000,
+    .charge_full_design = 1450,
+	.energy_full_design = 1450,
+    .use_for_apm = 1,
+};
+
+static void axp_battery_low(void)
+{
+#if defined(CONFIG_APM_EMULATION)
+	apm_queue_event(APM_LOW_BATTERY);
+#endif
+}
+
+static void axp_battery_critical(void)
+{
+#if defined(CONFIG_APM_EMULATION)
+	apm_queue_event(APM_CRITICAL_SUSPEND);
+#endif
+}
+
+static struct axp_supply_init_data axp_sply_init_data = {
+        .battery_info = &battery_data,
+        .chgcur = 700,
+        .chgvol = 4200,
+        .chgend = 70,
+        .chgen = 1,
+        .limit_on = 1,
+        .sample_time = 25,
+        .chgpretime = 40,
+        .chgcsttime = 480,
+        .battery_low = axp_battery_low,
+	    .battery_critical = axp_battery_critical,
+};
+
+static struct axp_funcdev_info axp_splydev[]={
+   	{   .name = "axp18-supplyer",
+		.id = AXP18_ID_SUPPLY,
+        .platform_data = &axp_sply_init_data,
+    },
+};
+
+static struct axp_platform_data axp_pdata = {
+	.num_regl_devs = ARRAY_SIZE(axp_regldevs),
+	.num_sply_devs = ARRAY_SIZE(axp_splydev),
+	.regl_devs = axp_regldevs,
+	.sply_devs = axp_splydev,
+};
+
+static struct i2c_board_info __initdata axp_mfd_i2c_board_info[] = {
+	{
+		.type = "axp18_mfd",
+		.addr = AXP18_ADDR,
+		.platform_data = &axp_pdata,
+		.irq = SW_INT_IRQNO_ENMI,
+	},
+};
+
+static int __init axp_board_init(void)
+{
+	return i2c_register_board_info(AXP18_I2CBUS, axp_mfd_i2c_board_info,
+				ARRAY_SIZE(axp_mfd_i2c_board_info));
+}
+module_init(axp_board_init);
+
+MODULE_DESCRIPTION("Krosspower axp board");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/power/axp_power/axp18-mfd.h b/drivers/power/axp_power/axp18-mfd.h
new file mode 100644
index 0000000..ecfdc3f
--- /dev/null
+++ b/drivers/power/axp_power/axp18-mfd.h
@@ -0,0 +1,241 @@
+/*
+ * drivers/power/axp_power/axp18-mfd.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "axp-rw.h"
+
+static int __devinit axp18_init_chip(struct axp_mfd_chip *chip)
+{
+	uint8_t chip_id;
+	uint8_t v[11] = {0xff, POWER18_INTEN2, 0xfc, POWER18_INTEN3, 0xfe,POWER18_INTSTS1, 0xff,POWER18_INTSTS2, 0xff, POWER18_INTSTS3,0xff};
+	int err;
+
+	/*read chip id*/
+	err =  __axp_read(chip->client, POWER18_CHARGE1, &chip_id);
+	if (err)
+		return err;
+
+	/*enable irqs and clear*/
+	err =   __axp_writes(chip->client, POWER18_INTEN1, 11, v);	
+	if (err)
+		return err;
+	
+	dev_info(chip->dev, "AXP (CHIP ID: 0x%02x) detected\n", chip_id);
+	chip->type = AXP18;
+
+	/* mask and clear all IRQs */
+	chip->irqs_enabled = 0xffffff;
+	chip->ops->disable_irqs(chip, chip->irqs_enabled);
+
+
+	return 0;
+}
+
+static int axp18_disable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[5];
+	int ret;
+
+	chip->irqs_enabled &= ~irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER18_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER18_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	
+	ret =  __axp_writes(chip->client, POWER18_INTEN1, 5, v);
+	
+	return ret;
+}
+
+static int axp18_enable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[5];
+	int ret;
+	chip->irqs_enabled |= irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER18_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER18_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	
+	ret =  __axp_writes(chip->client, POWER18_INTEN1, 5, v);
+	
+	return ret;
+}
+
+
+static int axp18_read_irqs(struct axp_mfd_chip *chip, uint64_t *irqs)
+{
+	uint8_t v[3] = {0, 0, 0};
+	int ret;
+	
+	//ret =  __axp_reads(chip->client, POWER18_INTSTS1, 3, v);
+	ret =  __axp_read(chip->client, POWER18_INTSTS1, v);
+	ret =  __axp_read(chip->client, POWER18_INTSTS2, v+1);
+	ret =  __axp_read(chip->client, POWER18_INTSTS1, v+2);
+	
+	
+	if (ret < 0)
+		return ret;
+		
+	*irqs = (v[2] << 16) | (v[1] << 8) | v[0];
+
+	return 0;
+}
+
+
+static ssize_t axp18_offvol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint8_t val = 0;
+	axp_read(dev,POWER18_IPS_SET,&val);
+	return sprintf(buf,"%d\n",((val & 0x03)?((val & 0x03)* 150 + 2750) : (2400)));
+}
+
+static ssize_t axp18_offvol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 2400)
+		tmp = 2400;
+	if (tmp > 3200)
+		tmp = 3200;
+	
+	axp_read(dev,POWER18_IPS_SET,&val);
+	val &= 0xfc;
+	if(tmp >= 2900)
+		val |= ((tmp - 2750) / 150);
+	axp_write(dev,POWER18_IPS_SET,val);
+	return count;
+}
+
+static ssize_t axp18_pekopen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint8_t val;
+	int tmp = 0;
+	axp_read(dev,POWER18_PEK,&val);
+	switch(val >> 6){
+		case 0: tmp = 128;break;
+		case 1: tmp = 512;break;
+		case 2: tmp = 1000;break;
+		case 3: tmp = 2000;break;
+		default:tmp = 0;break;
+	}
+	return sprintf(buf,"%d\n",tmp);
+}
+
+static ssize_t axp18_pekopen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	axp_read(dev,POWER18_PEK,&val);
+	if (tmp < 512)
+		val &= 0x3f;
+	else if(tmp < 1000){
+		val &= 0x3f;
+		val |= 0x40;
+	}
+	else if(tmp < 2000){
+		val &= 0x3f;
+		val |= 0x80;
+	}
+	else {
+		val |= 0xc0;
+	}
+	axp_write(dev,POWER18_PEK,val);
+	return count;
+}
+
+static ssize_t axp18_peklong_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	uint8_t val = 0;
+	axp_read(dev,POWER18_PEK,&val);
+	return sprintf(buf,"%d\n",((val >> 4) & 0x03) * 500 + 1000);		
+}
+
+static ssize_t axp18_peklong_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_mfd_chip *chip = dev_get_drvdata(dev);
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 1000)
+		tmp = 1000;
+	if(tmp > 2500)
+		tmp = 2500;
+
+	if (chip->type == AXP18)
+		axp_read(dev,POWER18_PEK,&val);
+	else
+		val = 0;
+	val &= 0xcf;
+	val |= (((tmp - 1000) / 500) << 4);
+	if(chip->type == AXP18)
+		axp_write(dev,POWER18_PEK,val);
+	else
+		return count;
+	return count;
+}
+
+static ssize_t axp18_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+
+	axp_read(dev,axp_reg_addr,&val);
+
+	return sprintf(buf,"REG[%x]=%x\n",axp_reg_addr,val);
+
+}
+
+static ssize_t axp18_reg_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 16);
+
+	if( tmp < 256 )
+		axp_reg_addr = tmp;
+	else {
+		val = tmp & 0x00FF;
+		axp_reg_addr = (tmp >> 8) & 0x00FF;
+		axp_write(dev,axp_reg_addr,val);
+	}
+	return count;
+}
+
+static struct device_attribute axp18_mfd_attrs[] = {
+	AXP_MFD_ATTR(axp18_offvol),	
+	AXP_MFD_ATTR(axp18_pekopen),
+	AXP_MFD_ATTR(axp18_peklong),
+	AXP_MFD_ATTR(axp18_reg),
+};
diff --git a/drivers/power/axp_power/axp18-regu.c b/drivers/power/axp_power/axp18-regu.c
new file mode 100644
index 0000000..fa66ef8
--- /dev/null
+++ b/drivers/power/axp_power/axp18-regu.c
@@ -0,0 +1,448 @@
+/*
+ * Regulators driver for Dialog Semiconductor DA903x
+ *
+ * Copyright (C) 2006-2008 Marvell International Ltd.
+ * Copyright (C) 2008 Compulab Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+
+
+
+#include "axp-regu.h"
+
+//AXP18 LDO5
+static int axp18_ldo5_data[] = { 2500000, 2800000, 3000000, 3300000};
+
+static inline struct device *to_axp_dev(struct regulator_dev *rdev)
+{
+	return rdev_get_dev(rdev)->parent->parent;
+}
+
+static inline int check_range(struct axp_regulator_info *info,
+				int min_uV, int max_uV)
+{
+	if (min_uV < info->min_uV || min_uV > info->max_uV)
+		return -EINVAL;
+	return 0;
+}
+
+/* AXP common operations */
+static int axp_set_voltage(struct regulator_dev *rdev,
+				  int min_uV, int max_uV)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	
+
+	if (check_range(info, min_uV, max_uV)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+	//axp18 LDO5
+	if (AXP18_ID_LDO5 == info->desc.id) {
+        if(min_uV < 2800000)
+			val = 0;
+		else if (min_uV < 3000000)
+			val = 1;
+		else if (min_uV < 3300000)
+			val = 2;
+		else
+			val = 3;
+		val <<= info->vol_shift;	
+		mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;	
+		return axp_update(axp_dev, info->vol_reg, val, mask);
+	}
+
+	val = (min_uV - info->min_uV + info->step_uV - 1) / info->step_uV;
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	return axp_update(axp_dev, info->vol_reg, val, mask);
+}
+
+static int axp_get_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int ret;
+
+	ret = axp_read(axp_dev, info->vol_reg, &val);
+	if (ret)
+		return ret;
+  
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+	//AXP18 LDO5
+	if (AXP18_ID_LDO5 == info->desc.id) {
+		return axp18_ldo5_data[val];
+	}
+	
+	return info->min_uV + info->step_uV * val;
+	
+}
+
+static int axp_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_set_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_clr_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return !!(reg_val & (1 << info->enable_bit));
+}
+
+static int axp_list_voltage(struct regulator_dev *rdev, unsigned selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret;
+
+	if(info->desc.id == AXP18_ID_LDO5){
+		return axp18_ldo5_data[selector];
+	}
+	ret = info->min_uV + info->step_uV * selector;
+	if (ret > info->max_uV)
+		return -EINVAL;
+	return ret;
+}
+
+static int axp_set_suspend_voltage(struct regulator_dev *rdev, int uV)
+{
+	int ldo = rdev_get_id(rdev);
+
+	switch (ldo) {
+	
+	case AXP18_ID_LDO1 ... AXP18_ID_SW2:
+		return axp_set_voltage(rdev, uV, uV);
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct regulator_ops axp18_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_enable,
+	.disable	= axp_disable,
+	.is_enabled	= axp_is_enabled,
+	.set_suspend_enable		= axp_enable,
+	.set_suspend_disable	= axp_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,	
+};
+
+#define AXP18_LDO(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_LDO(AXP18,_id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+#define AXP18_BUCK(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_BUCK(AXP18,_id, min, max, step, vreg, shift, nbits, ereg, ebit)	
+
+#define AXP18_SW(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_SW(AXP18,_id, min, max, step, vreg, shift, nbits, ereg, ebit)	
+
+
+static struct axp_regulator_info axp_regulator_info[] = {
+	/* AXP */ 
+	AXP18_LDO(	1,		LDO1MIN,	LDO1MAX,	0,		RTC,		0,	0,	LDO1EN,		0),//ldo1 for rtc
+	AXP18_LDO(	2,		2800,			3100,			100,	ANALOG,	5,	2,	LDO2EN,		3),//ldo2 for analog or fm
+	AXP18_LDO(	3,		LDO3MIN,	LDO3MAX,	100,  MOMERY,	0,	2,	LDO3EN,		7),//ldo3 for momery
+	AXP18_LDO(	4,		2700,			3300,			200,	SPDIF,	2,	2,	LDO4EN,		5),//ldo4 for spdif
+	AXP18_LDO(	5,		2500,			3300,			300,	SPDIF,	0,	2,	LDO5EN,		4),//lod5 for other use
+	AXP18_BUCK(	1,		2800,			3500,			100,	IO,			4,	3,	DCDC1EN,	0),//dcdc1 for io 
+	AXP18_BUCK(	2,		DCDC2MIN,	DCDC2MAX,	40,  	CORE,		0,	4,	DCDC2EN,	0),//dcdc2 for core
+	AXP18_BUCK(	3,		DCDC3MIN,	DCDC3MAX,	100, 	MOMERY,	2,	3,	DCDC3EN,	4),//dcdc3 for momery
+	AXP18_SW(  	1,		2800,			3500,			100,	IO,			4,	3,	SW1EN,		7),//sw1 for sdram
+	AXP18_SW(  	2,		2800,			3500, 		100,	IO,			4,	3,	SW2EN,		6),//sw2 for sd card
+};
+
+static ssize_t workmode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP18_BUCKMODE, &val);
+	if (ret)
+		return sprintf(buf, "IO ERROR\n");
+	
+	if(info->desc.id == AXP18_ID_BUCK1){
+		switch (val & 0x084) {
+			case 0x00:
+			case 0x04:return sprintf(buf, "AUTO\n");
+			case 0x80:return sprintf(buf, "PWM\n");
+			case 0x84:return sprintf(buf, "PFM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP18_ID_BUCK2){
+		switch (val & 0x42) {
+			case 0x00:
+			case 0x02:return sprintf(buf, "AUTO\n");
+			case 0x40:return sprintf(buf, "PWM\n");
+			case 0x42:return sprintf(buf, "PFM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP18_ID_BUCK3){
+		switch (val & 0x21) {
+			case 0x00:
+			case 0x01:return sprintf(buf, "AUTO\n");
+			case 0x20:return sprintf(buf, "PWM\n");
+			case 0x21:return sprintf(buf, "PFM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else
+		return sprintf(buf, "IO ID ERROR\n");
+}
+
+static ssize_t workmode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	char mode;
+	uint8_t val;
+	if(  buf[0] > '0' && buf[0] < '9' )// 1/AUTO: auto mode; 2/PWM: pwm mode;
+		mode = buf[0];
+	else
+		mode = buf[1];
+	
+	switch(mode){
+	 case 'U':
+	 case 'u':
+	 case '1':
+		val = 0;break;
+	 case 'W':
+	 case 'w':
+	 case '2':
+	 	val = 1;break;
+	 case 'F':
+	 case 'f':
+	 case '4':
+	 	val = 2;break;
+	 default:
+	    val = 3;break;
+	}
+	
+	if(info->desc.id == AXP18_ID_BUCK1){
+		if(val == 0)
+			axp_clr_bits(axp_dev, AXP18_BUCKMODE,0x80);
+		else if(val == 1)
+			axp_update(axp_dev, AXP18_BUCKMODE,0x80,0x84);
+		else if(val == 2)
+			axp_update(axp_dev,AXP18_BUCKMODE,0x84,0x84);
+		else
+			return -EINVAL;
+	}
+	else if(info->desc.id == AXP18_ID_BUCK2){
+		if(val == 0)
+			axp_clr_bits(axp_dev, AXP19_BUCKMODE,0x40);
+		else if(val == 1)
+			axp_update(axp_dev, AXP18_BUCKMODE,0x40,0x42);
+		else if(val == 2)
+			axp_update(axp_dev,AXP18_BUCKMODE,0x42,0x42);
+		else
+			return -EINVAL;
+	}
+	else if(info->desc.id == AXP18_ID_BUCK3){
+		if(val == 0)
+			axp_clr_bits(axp_dev, AXP18_BUCKMODE,0x20);
+		else if(val == 1)
+			axp_update(axp_dev, AXP19_BUCKMODE,0x20,0x21);
+		else if(val == 2)
+			axp_update(axp_dev, AXP19_BUCKMODE,0x21,0x21);
+		else 
+			return -EINVAL;
+	}
+	else
+		return -ENXIO;
+	return count;
+}
+
+static ssize_t frequency_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP18_BUCKFREQ, &val);
+	if (ret)
+		return ret;
+	ret = val & 0x0F;
+	return sprintf(buf, "%d\n",(ret*75 + 750));
+}
+
+static ssize_t frequency_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val,tmp;
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var < 750)
+		var = 750;
+	if(var > 1875)
+		var = 1875;
+		
+	val = (var -750)/75;
+	val &= 0x0F;
+	
+	axp_read(axp_dev, AXP18_BUCKFREQ, &tmp);
+	tmp &= 0xF0;
+	val |= tmp;
+	axp_write(axp_dev, AXP18_BUCKFREQ, val);
+	return count;
+}
+
+
+static struct device_attribute axp_regu_attrs[] = {
+	AXP_REGU_ATTR(workmode),
+	AXP_REGU_ATTR(frequency),
+};
+
+int axp_regu_create_attrs(struct platform_device *pdev)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_regu_attrs); j++) {
+		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+	
+sysfs_failed:
+	while (j--)
+		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
+succeed:
+	return ret;
+}
+
+static inline struct axp_regulator_info *find_regulator_info(int id)
+{
+	struct axp_regulator_info *ri;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(axp_regulator_info); i++) {
+		ri = &axp_regulator_info[i];
+		if (ri->desc.id == id)
+			return ri;
+	}
+	return NULL;
+}
+
+static int __devinit axp_regulator_probe(struct platform_device *pdev)
+{
+	struct axp_regulator_info *ri = NULL;
+	struct regulator_dev *rdev;
+	int ret;
+
+	ri = find_regulator_info(pdev->id);
+	if (ri == NULL) {
+		dev_err(&pdev->dev, "invalid regulator ID specified\n");
+		return -EINVAL;
+	}
+
+	if (ri->desc.id == AXP18_ID_LDO1 || ri->desc.id == AXP18_ID_LDO2 \
+		|| ri->desc.id == AXP18_ID_LDO3 || ri->desc.id == AXP18_ID_LDO4 \
+		|| ri->desc.id == AXP18_ID_LDO5 || ri->desc.id == AXP18_ID_BUCK1 \
+		|| ri->desc.id == AXP18_ID_BUCK2 || ri->desc.id == AXP18_ID_BUCK3 \
+		|| ri->desc.id == AXP18_ID_SW1 || ri->desc.id == AXP18_ID_SW2)
+		ri->desc.ops = &axp18_ops;
+
+	if(ri->desc.id == AXP18_ID_LDO5)
+		ri->desc.n_voltages = ARRAY_SIZE(axp18_ldo5_data);
+	
+	rdev = regulator_register(&ri->desc, &pdev->dev,
+				  pdev->dev.platform_data, ri, NULL);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register regulator %s\n",
+				ri->desc.name);
+		return PTR_ERR(rdev);
+	}
+
+	platform_set_drvdata(pdev, rdev);
+		
+	if(ri->desc.id == AXP18_ID_BUCK1 || ri->desc.id == AXP18_ID_BUCK2 \
+		||ri->desc.id == AXP18_ID_BUCK3){
+		ret = axp_regu_create_attrs(pdev);
+		if(ret){
+			return ret;
+		}
+	}
+	
+	return 0;
+}
+
+static int __devexit axp_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+	return 0;
+}
+
+static struct platform_driver axp_regulator_driver = {
+	.driver	= {
+		.name	= "axp18-regulator",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp_regulator_probe,
+	.remove		= axp_regulator_remove,
+};
+
+static int __init axp_regulator_init(void)
+{
+	return platform_driver_register(&axp_regulator_driver);
+}
+module_init(axp_regulator_init);
+
+static void __exit axp_regulator_exit(void)
+{
+	platform_driver_unregister(&axp_regulator_driver);
+}
+module_exit(axp_regulator_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Donglu Zhang");
+MODULE_DESCRIPTION("Regulator Driver for Krosspower AXP18 PMIC");
+MODULE_ALIAS("platform:axp-regulator");
diff --git a/drivers/power/axp_power/axp18-sply.c b/drivers/power/axp_power/axp18-sply.c
new file mode 100644
index 0000000..f19c810
--- /dev/null
+++ b/drivers/power/axp_power/axp18-sply.c
@@ -0,0 +1,1339 @@
+/*
+ * Battery charger driver for Dialog Semiconductor DA9030
+ *
+ * Copyright (C) 2008 Compulab, Ltd.
+ * 	Mike Rapoport <mike@compulab.co.il>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/sched.h>
+#include <linux/input.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+#include "axp-sply.h"
+
+static inline int axp18_vbat_to_vbat(uint8_t reg)
+{
+	return reg * 8 + 2500;
+}
+
+static inline int axp18_vbat_to_reg(int vbat)
+{
+	return (vbat - 2500) / 8;
+}
+
+static inline int axp18_vac_to_vbat(uint8_t reg)
+{
+	return reg * 12 + 3750;
+}
+
+static inline int axp18_vac_to_reg(int vbat)
+{
+	return (vbat - 3750) / 12;
+}
+
+static inline int axp18_i_to_ibat(uint8_t reg)
+{
+	return reg * 2000 / 300 ;
+}
+
+static inline int axp18_i_to_reg(int ibat)
+{
+	return ibat * 300 / 2000;
+}
+
+static inline void axp_read_adc(struct axp_charger *charger,
+				   struct axp_adc_res *adc)
+{
+	uint8_t tmp;
+	//axp_reads(charger->master, AXP18_VBAT_RES,sizeof(*adc), (uint8_t *)adc);//axp18 can't support muti-reads
+	axp_read(charger->master,AXP18_VBAT_RES,&tmp);
+	adc->vbat_res = tmp;
+	axp_read(charger->master,AXP18_IBAT_RES,&tmp);
+	adc->ibat_res = tmp;
+	axp_read(charger->master,AXP18_VAC_RES,&tmp);
+	adc->vac_res = tmp;
+	axp_read(charger->master,AXP18_IAC_RES,&tmp);
+	adc->iac_res = tmp;
+}
+
+static void axp_charger_update_state(struct axp_charger *charger)
+{
+	uint8_t val,tmp;
+
+	axp_read(charger->master, AXP18_CHARGE_STATUS, &val);
+	charger->is_on = (val & AXP18_IN_CHARGE) ? 1 : 0;
+
+	axp_read(charger->master,AXP18_FAULT_LOG1,&charger->fault);
+	axp_read(charger->master, AXP18_FAULT_LOG2, &val);
+	charger->is_finish = (val & AXP18_FINISH_CHARGE) ? 1 : 0;
+	tmp = val & 0x22;
+	val = tmp >> 5 | tmp << 5;
+	charger->fault |= val;
+
+	axp_read(charger->master, AXP18_STATUS, &val);
+	charger->bat_det = (val & AXP18_STATUS_BATEN) ? 1 : 0;
+	charger->ac_det = (val & AXP18_STATUS_DCIEN) ? 1 : 0;
+	charger->usb_det = (val & AXP18_STATUS_USBEN) ? 1 : 0;
+	charger->ext_valid = (val & AXP18_STATUS_EXTVA) ? 1 : 0;
+}
+
+static void axp_charger_update(struct axp_charger *charger)
+{
+	uint8_t tmp;
+	struct axp_adc_res adc;
+	charger->adc = &adc;
+	axp_read_adc(charger, &adc);
+
+	tmp = charger->adc->vbat_res;
+	charger->vbat = axp18_vbat_to_vbat(tmp);
+	tmp = charger->adc->ibat_res;
+	charger->ibat = axp18_i_to_ibat(tmp);
+	tmp = charger->adc->vac_res;
+	charger->vac = axp18_vac_to_vbat(tmp);
+	tmp = charger->adc->iac_res;
+	charger->iac = axp18_i_to_ibat(tmp);
+}
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static void axp_set_charge(struct axp_charger *charger)
+{
+	uint8_t val,tmp;
+	val = 0x00;
+
+	if(charger->chgvol < 4200)
+		val &= ~(3 << 5);
+	else if (charger->chgvol<4360){
+		val &= ~(3 << 5);
+		val |= 1 << 6;
+	}
+	else
+		val |= 3 << 5;
+	if(charger->limit_on)
+		val |= ((charger->chgcur - 100) / 200) | (1 << 3);
+	else
+		val |= ((charger->chgcur - 100) / 200) ;
+	val &= 0x7F;
+	val |= charger->chgen << 7;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL2, &tmp);
+		tmp &= 0x3C;
+	if(charger->chgpretime < 30)
+		charger->chgpretime = 30;
+	if(charger->chgcsttime < 420)
+		charger->chgcsttime = 420;
+	tmp |= ((charger->chgpretime - 30) / 10) << 6  \
+			| (charger->chgcsttime - 420) / 60;
+
+	axp_write(charger->master, AXP18_CHARGE_CONTROL1, val);
+	axp_write(charger->master, AXP18_CHARGE_CONTROL2, tmp);
+
+	axp_read(charger->master, AXP18_CHARGE_STATUS, &val);
+
+	if(charger ->chgend == 10)
+		val &= ~(1 << 6);
+	else
+		val |= 1 << 6;
+	axp_write(charger->master, AXP18_CHARGE_STATUS, val);
+}
+#else
+static void axp_set_charge(struct axp_charger *charger)
+{
+}
+#endif
+
+static enum power_supply_property axp_battery_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+};
+
+static enum power_supply_property axp_ac_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property axp_usb_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+
+static void axp_battery_check_status(struct axp_charger *charger,
+				    union power_supply_propval *val)
+{
+	if (charger->bat_det) {
+		if (charger->is_on)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (charger->rest_vol == 100 && charger->ext_valid)
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+		else if (charger->ext_valid)
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+	}
+	else
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+}
+
+static void axp_battery_check_health(struct axp_charger *charger,
+				    union power_supply_propval *val)
+{
+	if (charger->fault & AXP18_FAULT_LOG_BATINACT)
+		val->intval = POWER_SUPPLY_HEALTH_DEAD;
+	else if (charger->fault & AXP18_FAULT_LOG_OVER_TEMP)
+		val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (charger->fault & AXP18_FAULT_LOG_COLD)
+		val->intval = POWER_SUPPLY_HEALTH_COLD;
+	/* low voltage worning */
+	else if (charger->fault & AXP18_FAULT_LOG_VBAT_LOW)
+		val->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;
+	else if (charger->fault & AXP18_FAULT_LOG_VBAT_OVER)
+		val->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	else
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static int axp_battery_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, batt);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		axp_battery_check_status(charger, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		axp_battery_check_health(charger, val);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = charger->battery_info->technology;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = charger->battery_info->voltage_max_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = charger->battery_info->voltage_min_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vbat * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->ibat * 1000;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->battery_info->name;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = charger->battery_info->charge_full_design;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = charger->battery_info->charge_full_design;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = charger->rest_vol;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		if(charger->bat_det && !(charger->is_on) && !(charger->ext_valid))
+			val->intval = charger->rest_time;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		if(charger->bat_det && charger->is_on)
+			val->intval = charger->rest_time;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->bat_det;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (!charger->is_on) && (charger->bat_det)&& (! charger->ext_valid);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int axp_ac_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, ac);
+
+	switch(psp){
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->ac.name;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (charger->ac_det) && (charger->ext_valid);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->ac_det;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vac;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->iac;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int axp_usb_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, usb);
+
+	switch(psp){
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->usb.name;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->usb_det;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval =(charger->usb_det)&&(charger->ext_valid);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+
+static int axp_battery_event(struct notifier_block *nb, unsigned long event,
+				void *data)
+{
+	struct axp_charger *charger =
+		container_of(nb, struct axp_charger, nb);
+
+	switch (event) {
+	case AXP18_IRQ_BATIN:
+	case AXP18_IRQ_EXTIN:
+		axp_set_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x80);
+		break;
+	case AXP18_IRQ_BATRE:
+	case AXP18_IRQ_EXTOV:
+	case AXP18_IRQ_EXTRE:
+	case AXP18_IRQ_TEMOV:
+	case AXP18_IRQ_TEMLO:
+		axp_clr_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x80);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static void axp_battery_setup_psy(struct axp_charger *charger)
+{
+	struct power_supply *batt = &charger->batt;
+	struct power_supply *ac = &charger->ac;
+	struct power_supply *usb = &charger->usb;
+	struct power_supply_info *info = charger->battery_info;
+
+	batt->name = "battery";
+	batt->type = POWER_SUPPLY_TYPE_BATTERY;
+	batt->get_property = axp_battery_get_property;
+	batt->use_for_apm = info->use_for_apm;
+
+	batt->properties = axp_battery_props;
+	batt->num_properties = ARRAY_SIZE(axp_battery_props);
+
+	ac->name = "ac";
+	ac->type = POWER_SUPPLY_TYPE_MAINS;
+	ac->get_property = axp_ac_get_property;
+
+	ac->properties = axp_ac_props;
+	ac->num_properties = ARRAY_SIZE(axp_ac_props);
+
+	usb->name = "usb";
+	usb->type = POWER_SUPPLY_TYPE_USB;
+	usb->get_property = axp_usb_get_property;
+
+	usb->properties = axp_usb_props;
+	usb->num_properties = ARRAY_SIZE(axp_usb_props);
+}
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+	int ret ;
+	uint8_t val;
+
+	/*enable adc and set adc */
+	val=(charger->sample_time / 8 - 1) << 2 | AXP18_ADC_BATVOL_ENABLE
+		| AXP18_ADC_BATCUR_ENABLE | AXP18_ADC_ACCUR_ENABLE
+		| AXP18_ADC_ACVOL_ENABLE;
+
+	ret = axp_write(charger->master, AXP18_ADC_CONTROL, val);
+
+	return ret;
+}
+#else
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+	return 0;
+}
+#endif
+
+static int axp_battery_first_init(struct axp_charger *charger)
+{
+	int ret;
+	axp_set_charge(charger);
+	ret = axp_battery_adc_set(charger);
+	return ret;
+}
+
+static int axp_get_rdc(struct axp_charger *charger)
+{
+	uint8_t val[3];
+	unsigned int i,temp,pre_temp;
+	int averPreVol = 0, averPreCur = 0,averNextVol = 0,averNextCur = 0;
+
+	//axp_reads(charger->master,AXP18_DATA_BUFFER1,2,val);
+	axp_read(charger->master,AXP18_DATA_BUFFER1,val);
+	axp_read(charger->master,AXP18_DATA_BUFFER2,val+1);
+	pre_temp = (((val[0] & 0x7F) << 8 ) + val[1]);
+
+	printk("%d:pre_temp = %d\n",__LINE__,pre_temp);
+
+	if( charger->is_on){
+		for(i = 0; i< AXP18_RDC_COUNT; i++){
+			axp_charger_update(charger);
+			averPreVol += charger->vbat;
+			averPreCur += charger->ibat;
+			msleep(50);
+		}
+		averPreVol /= AXP18_RDC_COUNT;
+		averPreCur /= AXP18_RDC_COUNT;
+		axp_clr_bits(charger->master,AXP18_CHARGE_CONTROL2,0x80);
+		msleep(500);
+		for(i = 0; i< AXP18_RDC_COUNT; i++){
+			axp_charger_update(charger);
+			averNextVol += charger->vbat;
+			averNextCur += charger->ibat;
+			msleep(50);
+		}
+		averNextVol /= AXP18_RDC_COUNT;
+		averNextVol /= AXP18_RDC_COUNT;
+		axp_set_bits(charger->master,AXP18_CHARGE_CONTROL2,0x80);
+		msleep(500);
+		if(ABS(averPreCur - averNextCur) > 200){
+			temp = 1000 * ABS(averPreVol - averNextVol) / ABS(averPreCur);
+			if((temp < 5) || (temp > 5000)){
+				return pre_temp;
+			}
+			else {
+				temp += pre_temp;
+				temp >>= 1;
+				val[0] = ((temp & 0xFF00) | 0x8000) >> 8;
+				val[1] = AXP18_DATA_BUFFER2;
+				val[2] =  temp & 0x00FF;
+				axp_writes(charger->master,AXP18_DATA_BUFFER1,3,val );
+				return temp;
+			}
+		}
+		else
+			return pre_temp;
+	}
+	else
+		return pre_temp;
+}
+
+static int axp_cal_restvol(int vol)
+{
+    if(vol > 4150)
+    {
+        return 100;
+    }
+    else if(vol < 2700)
+    {
+        return 0;
+    }
+    else if(vol < 3200)
+    {
+        return (10 * (vol - 2700) / 5000);
+    }
+    else if(vol < 3650)
+    {
+        return (1500+ 17000 * (vol - 3200) / 450)/1000;
+    }
+    else if(vol < 3750)
+    {
+        return (18500 + 1500 * (vol - 3650) / 10)/1000;              //20%æ¹ä¸º18%
+    }
+    else if(vol < 3830)
+    {
+        return (33500 + (1500 * (vol - 3750)/(383 - 375)))/1000;
+    }
+    else if(vol < 4000)
+    {
+        return (48500 + (4000 * (vol - 3830)/(400 - 383)))/1000;    //40%æ¹ä¸º37%
+    }
+    else
+    {
+        if(vol > 4150)
+        {
+            vol = 4150;
+        }
+        return (855 + (150 * (vol - 4000)/150))/10;                 //4200-3950 = 250ï¼13%æ¹ä¸º15%
+    }
+}
+
+int Bat_Pre_Cur = 1;
+
+
+static void axp_cal_rest(struct axp_charger *charger, int this_rdc)
+{
+    int battery_cap;
+	uint16_t Iconst_current = 1;
+	uint8_t  DCIN_Presence, DCIN_Pre_Presence = 0;
+	battery_cap = charger->battery_info->charge_full_design;
+
+	if(charger->vac < 4200){
+        charger->ac_not_enough = 1;
+	}
+	else {
+        charger->ac_not_enough = 0;
+	}
+	if(charger->bat_det){
+        int Ichgset, total_vol = 0, Iendchg, Tcv_Rest_Vol, Tcv = 0;
+		int Internal_Ibat = 1;
+		if(charger->ibat == 0){
+            charger->ibat = 1;
+		}
+		total_vol = charger->vbat;
+		Internal_Ibat = charger->ibat;
+		Ichgset = charger->chgcur;
+		Iendchg = Ichgset * charger->chgend/100;
+		DCIN_Presence = charger->ac_det;
+		if((charger->vac < charger->vbat + 200) || (charger->vac < 4200)){
+            if((charger->ibat < (3 * Ichgset / 5)) && (charger->ext_valid)){
+				charger->ac_not_enough = 1;
+            }
+			else {
+                charger->ac_not_enough = 0;
+			}
+		}
+		else {
+            charger->ac_not_enough = 0;
+		}
+		if(charger->ext_valid){
+            total_vol -= charger->ibat * this_rdc * CHG_RDC_RATE / 100000;
+			charger->vbat = total_vol;
+		}
+		else {
+            charger->ibat *= DISCHARGE_CUR_RATE / 10;
+			if(charger->ibat > (MAX_BAT_CUR * Ichgset / 10)){
+                charger->ibat = 10 * charger->ibat / DISCHARGE_CUR_RATE;
+			}
+			charger->ibat = (charger->ibat + Bat_Pre_Cur)/2;
+			if(DCIN_Pre_Presence != DCIN_Presence){
+                charger->ibat = Internal_Ibat;
+			}
+			total_vol += charger->ibat * (this_rdc - DISCHARGE_RDC_CAL) / 1000;
+			charger->vbat = total_vol;
+		}
+		Bat_Pre_Cur = charger->ibat;
+		DCIN_Pre_Presence = DCIN_Presence;
+		charger->rest_vol = axp_cal_restvol(total_vol);
+		if(charger->ext_valid && charger->is_on){
+            if(charger->vbat < 4190){
+                Tcv_Rest_Vol = axp_cal_restvol(4200 - charger->ibat * this_rdc / 1000);
+				Iconst_current = charger->ibat;
+				if(Tcv_Rest_Vol < 70){
+                    Tcv = 60 * (100 - Tcv_Rest_Vol) * battery_cap / (45 * charger->ibat);
+				}
+				else {
+                    Tcv = 60 * (100 - Tcv_Rest_Vol) * battery_cap / (35 * charger->ibat);
+				}
+				charger->rest_time = 6 * battery_cap * ABS(Tcv_Rest_Vol - charger->rest_vol) \
+					/ charger->ibat / 10 + Tcv ;
+			}
+			else {
+                if(Iconst_current == 1){
+                    Iconst_current = Ichgset;
+				}
+				if(Tcv == 0){
+                    Tcv_Rest_Vol = axp_cal_restvol(4200 - charger->ibat * this_rdc / 1000);
+					if(Tcv_Rest_Vol < 70){
+                        Tcv = 60 * (100 - Tcv_Rest_Vol) * battery_cap / (45 * charger->ibat);
+				    }
+				    else {
+                        Tcv = 60 * (100 - Tcv_Rest_Vol) * battery_cap / (35 * charger->ibat);
+				    }
+				}
+				if(charger->ibat < Iendchg){
+                    charger->rest_time = 1;
+				}
+				else {
+                    charger->rest_time = Tcv * (90 + 100 * Iendchg / charger->ibat) *     \
+						(90 + 100 * Iendchg / charger->ibat) * ABS(charger->ibat - Iendchg) \
+						/ Iconst_current / 10000;
+				}
+			}
+		}
+		else {
+            if(total_vol < 3000){
+                charger->rest_time = 0;
+			}
+			else {
+                charger->rest_time = (60 * battery_cap * ABS(charger->rest_vol - 6) / charger->ibat \
+					+ 50) / 102;
+			}
+		}
+	}
+	else {
+        charger->vbat = 2500;
+		charger->ibat = 0;
+		charger->rest_time = 0;
+		charger->rest_vol = 0;
+	}
+}
+
+static int axp_main_task(void *arg)
+{
+    struct axp_charger *charger = arg;
+	int batcap_count = 0, battime_count = 0;
+    uint16_t batcap[AXP18_VOL_MAX], battime[AXP18_TIME_MAX];
+    uint16_t pre_batcap = 0;
+    uint8_t rdc_flag = 0, tmp_value[2];
+    uint8_t pre_charge_status = 0;
+    uint16_t batcap_index = 0, battime_index = 0;
+    int total_vol = 0, total_time = 0;
+    int this_rdc;
+	uint8_t v[3] = {0, 0, 0};
+	uint8_t w[5] = {0, 0, 0, 0, 0};
+	int events;
+    bool peklong;
+    bool pekshort;
+    uint8_t long_cnt = 0;
+	bool status_usb, pre_status_usb;
+    bool status_ac, pre_status_ac;
+    bool status_bat, pre_status_bat;
+	bool pre_rdcflag;
+	status_usb = 0;
+    pre_status_usb = 0;
+    status_ac = 0;
+    pre_status_ac = 0;
+    status_bat = 0;
+    pre_status_bat =0;
+
+	//axp_reads(charger->master,AXP18_DATA_BUFFER1,2,tmp_value);
+	axp_read(charger->master,AXP18_DATA_BUFFER1,tmp_value);
+	axp_read(charger->master,AXP18_DATA_BUFFER2,tmp_value+1);
+	this_rdc = (tmp_value[0] & 0x7F << 8) + tmp_value[1];
+	pre_rdcflag = tmp_value[0] >> 7;
+    if(this_rdc > 5000 || pre_rdcflag == 0)
+		this_rdc = BATRDC;
+
+	while(1){
+		if(kthread_should_stop()) break;
+        axp_charger_update_state(charger);
+		axp_charger_update(charger);
+
+	//axp_reads(charger->master,POWER18_INTSTS1, 3, v);
+		axp_read(charger->master,POWER18_INTSTS1,v);
+		axp_read(charger->master,POWER18_INTSTS2,v+1);
+		axp_read(charger->master,POWER18_INTSTS3,v+2);
+		events = (v[2] << 16) | (v[1] << 8) | v[0];
+		w[0] = v[0];
+		w[1] = POWER18_INTSTS2;
+		w[2] = v[1];
+		w[3] = POWER18_INTSTS3;
+		w[4] = v[2];
+
+		peklong = (events & AXP18_IRQ_PEKLO)? 1 : 0;
+		pekshort = (events & AXP18_IRQ_PEKSH )? 1 : 0;
+
+		status_ac = charger->ac_det;
+		status_usb = charger->usb_det;
+        status_bat = (!charger->is_on)&&(charger->bat_det);
+
+        if(status_usb != pre_status_usb || status_ac != pre_status_ac || status_bat != pre_status_bat )
+        {
+            power_supply_changed(&charger->batt);
+			pre_status_ac =  status_ac;
+			pre_status_usb = status_usb;
+			pre_status_bat = status_bat;
+         }
+
+		/* simulate a key_up after peklong*/
+		if(long_cnt)
+        {
+			long_cnt--;
+			if(long_cnt == 0 )
+            {
+				printk("press long up\n");
+				input_report_key(powerkeydev, KEY_POWER, 0);
+				input_sync(powerkeydev);
+		    }
+
+        }
+
+		if(peklong)
+		{
+			printk("press long\n");
+			axp_writes(charger->master,POWER18_INTSTS1,5,w);
+			input_report_key(powerkeydev, KEY_POWER, 1);
+			input_sync(powerkeydev);
+			long_cnt = 5;
+			//msleep(100);
+			//input_report_key(powerkeydev, KEY_POWER, 0);
+			//input_sync(powerkeydev);
+		}
+
+		if(pekshort)
+		{
+			printk("press short\n");
+			axp_writes(charger->master,POWER18_INTSTS1,5,w);
+
+			input_report_key(powerkeydev, KEY_POWER, 1);
+			input_sync(powerkeydev);
+			msleep(100);
+			input_report_key(powerkeydev, KEY_POWER, 0);
+			input_sync(powerkeydev);
+		}
+
+		if((charger->is_on)&&(!rdc_flag)){
+			if(charger->ibat > 220){
+                rdc_flag = 1;
+				this_rdc = axp_get_rdc(charger);
+			}
+		}
+		if(charger->bat_det == 0){
+            charger->rest_time = 0;
+			charger->rest_vol  = 0;
+		}
+		else{
+			axp_cal_rest(charger, this_rdc);
+			if(battime_index == AXP18_TIME_MAX){
+            	battime_index = 0;
+			}
+			if(battime_count < AXP18_TIME_MAX){
+            	battime[battime_index ++ ] = charger->rest_time;
+            	total_time += charger->rest_time;
+            	battime_count ++;
+			}
+			else{
+            	total_time -= battime[battime_index];
+            	total_time += charger->rest_time;
+            	battime[battime_index ++ ] = charger->rest_time;
+        	}
+			charger->rest_time = total_time / battime_count;
+			if(batcap_index == AXP18_VOL_MAX){
+            	batcap_index = 0;
+			}
+			if(batcap_count < AXP18_VOL_MAX){
+              	batcap[batcap_index ++ ] = charger->rest_vol;
+              	total_vol += charger->rest_vol;
+              	batcap_count ++;
+        	}
+        	else{
+              	total_vol -= batcap[batcap_index];
+              	total_vol += charger->rest_vol;
+              	batcap[batcap_index ++ ] = charger->rest_vol;
+        	}
+			charger->rest_vol = total_vol / batcap_count;
+
+			//printk("charger->rest_vol = %d\n",charger->rest_vol);
+			if((charger->is_on) && (charger->rest_vol == 100)){
+            	charger->rest_vol = 99;
+			}
+
+			if((charger->is_on) && (batcap_count == AXP18_VOL_MAX)){
+           		if(charger->rest_vol < pre_batcap){
+              		charger->rest_vol = pre_batcap;
+           		}
+			}
+			if((!charger->is_on) && (batcap_count == AXP18_VOL_MAX)){
+           		if(charger->rest_vol > pre_batcap){
+              		charger->rest_vol = pre_batcap;
+           		}
+			}
+
+			if((pre_charge_status == 1) && (!charger->is_on) && (charger->bat_det) && (charger->ext_valid)){//åçµç»ææ¶å·æ°ä¸º100
+            	charger->rest_vol = total_vol / batcap_count;
+			}
+
+			pre_charge_status = charger->is_on;
+
+			//printk("charger->rest_vol = %d\n",charger->rest_vol);
+
+			/* if battery volume changed, inform uevent */
+			if(charger->rest_vol - pre_batcap)
+			{
+				printk("battery vol change: %d, %d \n", pre_batcap, charger->rest_vol);
+				pre_batcap = charger->rest_vol;
+				power_supply_changed(&charger->batt);
+			}
+		}
+		ssleep(1);
+	}
+	return 0;
+}
+
+static ssize_t chgen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+	charger->chgen  = val >> 7;
+	return sprintf(buf, "%d\n",charger->chgen);
+}
+
+static ssize_t chgen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var){
+		charger->chgen = 1;
+		axp_set_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x80);
+	}
+	else{
+		charger->chgen = 0;
+		axp_clr_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x80);
+	}
+	return count;
+}
+
+static ssize_t chgcurlimen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	char val;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+	charger->limit_on = val >> 3 & 0x01;
+	return sprintf(buf, "%d\n",charger->limit_on);
+}
+
+static ssize_t chgcurlimen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var){
+		charger->limit_on = 1;
+		axp_set_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x08);
+	}
+	else{
+		charger->limit_on = 0;
+		axp_clr_bits(charger->master, AXP18_CHARGE_CONTROL1, 0x08);
+	}
+	return count;
+}
+
+static ssize_t chgmicrovol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+    switch ((val >> 5) & 0x03){
+		case 0: charger->chgvol = 4100000;break;
+		case 1: charger->chgvol = 4200000;break;
+		case 2: charger->chgvol = 4200000;break;
+		case 3: charger->chgvol = 4360000;break;
+		default:break;
+	}
+	return sprintf(buf, "%d\n",charger->chgvol);
+}
+
+static ssize_t chgmicrovol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t tmp, val;
+	var = simple_strtoul(buf, NULL, 10);
+	switch(var){
+		case 4100000:tmp = 0;break;
+		case 4200000:tmp = 2;break;
+		case 4360000:tmp = 3;break;
+		default:  tmp = 4;break;
+	}
+	if(tmp < 4){
+		charger->chgvol = var;
+		axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+		val &= 0x9F;
+		val |= tmp << 5;
+		axp_write(charger->master, AXP18_CHARGE_CONTROL1, val);
+	}
+	return count;
+}
+
+static ssize_t chgmicrocur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+	charger->chgcur = (val & 0x07) * 200000 +100000;
+	return sprintf(buf, "%d\n",charger->chgcur);
+}
+
+static ssize_t chgmicrocur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 100000 && var <= 1500000){
+		val = (var -100000)/200000;
+		charger->chgcur = val *200000 + 100000;
+		axp_read(charger->master, AXP18_CHARGE_CONTROL1, &val);
+		val &= 0xF8;
+		val |= val;
+		axp_write(charger->master, AXP18_CHARGE_CONTROL1, val);
+	}
+	return count;
+}
+
+static ssize_t chgendcur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_CHARGE_STATUS, &val);
+	charger->chgend = ((val >> 6)& 0x01)? 15 : 10;
+	return sprintf(buf, "%d\n",charger->chgend);
+}
+
+static ssize_t chgendcur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var == 10 ){
+		charger->chgend = var;
+		axp_clr_bits(charger->master ,AXP18_CHARGE_STATUS,0x40);
+	}
+	else if (var == 15){
+		charger->chgend = var;
+		axp_set_bits(charger->master ,AXP18_CHARGE_STATUS,0x40);
+
+	}
+	return count;
+}
+
+static ssize_t chgpretimemin_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP18_CHARGE_CONTROL2, &val);
+ 	charger->chgpretime = (val >> 6) * 10 +30;
+	return sprintf(buf, "%d\n",charger->chgpretime);
+}
+
+static ssize_t chgpretimemin_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val,tmp;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 30 && var <= 60){
+		tmp = (var - 30)/10;
+		charger->chgpretime = tmp * 10 + 30;
+		axp_read(charger->master,AXP18_CHARGE_CONTROL2,&val);
+		val &= 0x3F;
+		val |= (tmp << 6);
+		axp_write(charger->master,AXP18_CHARGE_CONTROL2,val);
+	}
+	return count;
+}
+
+static ssize_t chgcsttimemin_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP18_CHARGE_CONTROL2, &val);
+	charger->chgcsttime = (val & 0x03) *60 + 420;
+	return sprintf(buf, "%d\n",charger->chgcsttime);
+}
+
+static ssize_t chgcsttimemin_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val,tmp;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 420 && var <= 600){
+		tmp = (var - 420)/60;
+		charger->chgcsttime = tmp * 60 + 420;
+		axp_read(charger->master,AXP18_CHARGE_CONTROL2,&val);
+		val &= 0xFC;
+		val |= tmp;
+		axp_write(charger->master,AXP18_CHARGE_CONTROL2,val);
+	}
+	return count;
+}
+
+static ssize_t adcfreq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP18_ADC_CONTROL, &val);
+	switch ((val >> 2) & 0x03){
+		 case 0: charger->sample_time = 8;break;
+		 case 1: charger->sample_time = 16;break;
+		 case 2: charger->sample_time = 25;break;
+		 case 3: charger->sample_time = 32;break;
+		 default:break;
+	}
+	return sprintf(buf, "%d\n",charger->sample_time);
+}
+
+static ssize_t adcfreq_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	axp_read(charger->master, AXP18_ADC_CONTROL, &val);
+	switch (var){
+		case 8: val &= ~(3 << 2);charger->sample_time = 8;break;
+		case 16: val &= ~(3 << 2);val |= 1 << 2;charger->sample_time = 16;break;
+		case 25: val &= ~(3 << 2);val |= 2 << 2;charger->sample_time = 25;break;
+		case 32: val |= 3 << 2;charger->sample_time = 32;break;
+		default: break;
+		}
+	axp_write(charger->master, AXP18_ADC_CONTROL, val);
+	return count;
+}
+
+static ssize_t vholden_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP18_CHARGE_VBUS, &val);
+	val = (val>>6) & 0x01;
+	return sprintf(buf, "%d\n",val);
+}
+
+static ssize_t vholden_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var)
+		axp_set_bits(charger->master, AXP18_CHARGE_VBUS, 0x40);
+	else
+		axp_clr_bits(charger->master, AXP18_CHARGE_VBUS, 0x40);
+
+	return count;
+}
+
+static ssize_t vhold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	int vhold;
+	axp_read(charger->master,AXP18_CHARGE_VBUS, &val);
+	switch((val>>4)& 0x03)
+	{
+		case 0: vhold = 4220000;break;
+		case 1: vhold = 4400000;break;
+		case 2: vhold = 4550000;break;
+		case 3: vhold = 4700000;break;
+		default:return -EINVAL;
+	}
+	return sprintf(buf, "%d\n",vhold);
+}
+
+static ssize_t vhold_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val,tmp;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 4220000 && var <=4700000){
+		if(var == 4220000)
+			tmp = 0;
+		else if(val <= 4400000)
+			tmp = 1;
+		else if(val <= 4550000)
+			tmp = 2;
+		else
+			tmp = 3;
+		axp_read(charger->master, AXP19_CHARGE_VBUS,&val);
+		val &= 0xCF;
+		val |= tmp << 4;
+		axp_write(charger->master, AXP19_CHARGE_VBUS,val);
+	}
+	return count;
+}
+static struct device_attribute axp_charger_attrs[] = {
+	AXP_CHG_ATTR(chgen),
+	AXP_CHG_ATTR(chgcurlimen),
+	AXP_CHG_ATTR(chgmicrovol),
+	AXP_CHG_ATTR(chgmicrocur),
+	AXP_CHG_ATTR(chgendcur),
+	AXP_CHG_ATTR(chgpretimemin),
+	AXP_CHG_ATTR(chgcsttimemin),
+	AXP_CHG_ATTR(adcfreq),
+	AXP_CHG_ATTR(vholden),
+	AXP_CHG_ATTR(vhold),
+};
+
+int axp_charger_create_attrs(struct power_supply *psy)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_charger_attrs); j++) {
+		ret = device_create_file(psy->dev,
+			    &axp_charger_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+
+sysfs_failed:
+	while (j--)
+		device_remove_file(psy->dev,
+			   &axp_charger_attrs[j]);
+succeed:
+	return ret;
+}
+
+
+static int axp_battery_probe(struct platform_device *pdev)
+{
+	struct axp_charger *charger;
+	struct axp_supply_init_data *pdata = pdev->dev.platform_data;
+	int ret;
+
+	powerkeydev = input_allocate_device();
+	if (!powerkeydev) {
+		kfree(powerkeydev);
+		return -ENODEV;
+	}
+
+	powerkeydev->name = pdev->name;
+	powerkeydev->phys = "m1kbd/input2";
+	powerkeydev->id.bustype = BUS_HOST;
+	powerkeydev->id.vendor = 0x0001;
+	powerkeydev->id.product = 0x0001;
+	powerkeydev->id.version = 0x0100;
+	powerkeydev->open = NULL;
+	powerkeydev->close = NULL;
+	powerkeydev->dev.parent = &pdev->dev;
+
+	set_bit(EV_KEY, powerkeydev->evbit);
+	set_bit(EV_REL, powerkeydev->evbit);
+	set_bit(KEY_POWER, powerkeydev->keybit);
+
+	ret = input_register_device(powerkeydev);
+	if(ret)
+	{
+		printk("Unable to Register the power key\n");
+	}
+
+	if (pdata == NULL)
+		return -EINVAL;
+
+	if (pdata->chgcur > 1500 ||
+	    pdata->chgvol < 4100 ||
+	    pdata->chgvol > 4360){
+            printk("charger milliamp is too high or target voltage is over range\n");
+		    return -EINVAL;
+		}
+
+	if (pdata->chgpretime < 30 || pdata->chgpretime >60 ||
+		pdata->chgcsttime < 420 || pdata->chgcsttime > 600){
+            printk("prechaging time or constant current charging time is over range\n");
+		    return -EINVAL;
+		}
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (charger == NULL)
+		return -ENOMEM;
+
+	charger->master = pdev->dev.parent;
+
+	charger->chgcur				= pdata->chgcur;
+	charger->chgvol				= pdata->chgvol;
+	charger->chgend				= pdata->chgend;
+	charger->sample_time		= pdata->sample_time;
+	charger->chgen				= pdata->chgen;
+	charger->limit_on			= pdata->limit_on;
+	charger->chgpretime			= pdata->chgpretime;
+	charger->chgcsttime			= pdata->chgcsttime;
+	charger->battery_info		= pdata->battery_info;
+	charger->battery_low		= pdata->battery_low;
+	charger->battery_critical	= pdata->battery_critical;
+
+	ret = axp_battery_first_init(charger);
+	if (ret)
+		goto err_charger_init;
+
+	charger->nb.notifier_call = axp_battery_event;
+	ret = axp_register_notifier(charger->master, &charger->nb, AXP18_NOTIFIER_ON);
+	if (ret)
+		goto err_notifier;
+
+	axp_battery_setup_psy(charger);
+	ret = power_supply_register(&pdev->dev, &charger->batt);
+	if (ret)
+		goto err_ps_register;
+
+	ret = power_supply_register(&pdev->dev, &charger->ac);
+	if (ret){
+		power_supply_unregister(&charger->batt);
+		goto err_ps_register;
+	}
+	ret = power_supply_register(&pdev->dev, &charger->usb);
+	if (ret){
+		power_supply_unregister(&charger->ac);
+		power_supply_unregister(&charger->batt);
+		goto err_ps_register;
+	}
+
+	ret = axp_charger_create_attrs(&charger->batt);
+	if(ret){
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, charger);
+
+  	main_task = kthread_run(axp_main_task,charger,"kaxp18");
+	if(IS_ERR(main_task)){
+
+      printk("Unable to start main task.\n");
+
+      ret = PTR_ERR(main_task);
+
+      main_task = NULL;
+
+      return ret;
+
+    }
+    return 0;
+
+err_ps_register:
+	axp_unregister_notifier(charger->master, &charger->nb, AXP18_NOTIFIER_ON);
+
+err_notifier:
+	//cancel_delayed_work(&charger->work);
+
+err_charger_init:
+	kfree(charger);
+	input_unregister_device(powerkeydev);
+	kfree(powerkeydev);
+
+	return ret;
+}
+
+static int axp_battery_remove(struct platform_device *dev)
+{
+	struct axp_charger *charger = platform_get_drvdata(dev);
+
+	if(main_task){
+                kthread_stop(main_task);
+                main_task = NULL;
+    }
+
+	axp_unregister_notifier(charger->master, &charger->nb, AXP18_NOTIFIER_ON);
+	//cancel_delayed_work(&charger->work);
+	power_supply_unregister(&charger->usb);
+	power_supply_unregister(&charger->ac);
+	power_supply_unregister(&charger->batt);
+
+	kfree(charger);
+	input_unregister_device(powerkeydev);
+	kfree(powerkeydev);
+
+	return 0;
+}
+
+static struct platform_driver axp_battery_driver = {
+	.driver	= {
+		.name	= "axp18-supplyer",
+		.owner	= THIS_MODULE,
+	},
+	.probe = axp_battery_probe,
+	.remove = axp_battery_remove,
+};
+
+static int axp_battery_init(void)
+{
+	return platform_driver_register(&axp_battery_driver);
+}
+
+static void axp_battery_exit(void)
+{
+	platform_driver_unregister(&axp_battery_driver);
+}
+
+module_init(axp_battery_init);
+module_exit(axp_battery_exit);
+
+MODULE_DESCRIPTION("AXP18 battery charger driver");
+MODULE_AUTHOR("Donglu Zhang, Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/axp19-board.c b/drivers/power/axp_power/axp19-board.c
new file mode 100644
index 0000000..ecd8334
--- /dev/null
+++ b/drivers/power/axp_power/axp19-board.c
@@ -0,0 +1,321 @@
+/*
+ * drivers/power/axp_power/axp19-board.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/apm_bios.h>
+#include <linux/apm-emulation.h>
+#include <linux/mfd/axp-mfd.h>
+
+
+#include "axp-cfg.h"
+
+
+/* Reverse engineered partly from Platformx drivers */
+enum axp_regls{
+
+	vcc_ldo1,
+	vcc_ldo2,
+	vcc_ldo3,
+	vcc_ldo4,
+	vcc_ldo5,
+
+	vcc_buck1,
+	vcc_buck2,
+	vcc_buck3,
+	vcc_ldoio0,
+};
+
+/* The values of the various regulator constraints are obviously dependent
+ * on exactly what is wired to each ldo.  Unfortunately this information is
+ * not generally available.  More information has been requested from Xbow
+ * but as of yet they haven't been forthcoming.
+ *
+ * Some of these are clearly Stargate 2 related (no way of plugging
+ * in an lcd on the IM2 for example!).
+ */
+
+static struct regulator_consumer_supply ldo1_data[] = {
+		{
+			.supply = "axp19_rtc",
+		},
+	};
+
+
+static struct regulator_consumer_supply ldo2_data[] = {
+		{
+			.supply = "axp19_analog/fm",
+		},
+	};
+
+static struct regulator_consumer_supply ldo3_data[] = {
+		{
+			.supply = "axp19_pll/sdram",
+		},
+	};
+
+static struct regulator_consumer_supply ldo4_data[] = {
+		{
+			.supply = "axp19_hdmi",
+		},
+	};
+
+static struct regulator_consumer_supply ldoio0_data[] = {
+		{
+			.supply = "axp19_mic",
+		},
+	};
+
+static struct regulator_consumer_supply buck1_data[] = {
+		{
+			.supply = "axp19_io",
+		},
+	};
+
+static struct regulator_consumer_supply buck2_data[] = {
+		{
+			.supply = "axp19_core",
+		},
+	};
+
+static struct regulator_consumer_supply buck3_data[] = {
+		{
+			.supply = "axp19_ddr",
+		},
+	};
+
+
+
+static struct regulator_init_data axp_regl_init_data[] = {
+	[vcc_ldo1] = {
+		.constraints = { /* board default 1.25V */
+			.name = "axp19_ldo1",
+			.min_uV =  AXP19LDO1 * 1000,
+			.max_uV =  AXP19LDO1 * 1000,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_data),
+		.consumer_supplies = ldo1_data,
+	},
+	[vcc_ldo2] = {
+		.constraints = { /* board default 3.0V */
+			.name = "axp19_ldo2",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_data),
+		.consumer_supplies = ldo2_data,
+
+	},
+	[vcc_ldo3] = {
+		.constraints = {/* default is 1.8V */
+			.name = "axp19_ldo3",
+			.min_uV =  700 * 1000,
+			.max_uV =  3500* 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_data),
+		.consumer_supplies = ldo3_data,
+
+	},
+	[vcc_ldo4] = {
+		.constraints = {
+			/* board default is 3.3V */
+			.name = "axp19_ldo4",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_data),
+		.consumer_supplies = ldo4_data,
+
+	},
+	[vcc_buck1] = {
+		.constraints = { /* default 3.3V */
+			.name = "axp19_buck1",
+			.min_uV = 700000,
+			.max_uV = 3500000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck1_data),
+		.consumer_supplies = buck1_data,
+
+
+	},
+	[vcc_buck2] = {
+		.constraints = { /* default 1.24V */
+			.name = "axp19_buck2",
+			.min_uV = 700 * 1000,
+			.max_uV = 2275 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck2_data),
+		.consumer_supplies = buck2_data,
+
+
+	},
+	[vcc_buck3] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp19_buck3",
+			.min_uV = 700 * 1000,
+			.max_uV = 3500 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck3_data),
+		.consumer_supplies = buck3_data,
+	},
+	[vcc_ldoio0] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp19_ldoio0",
+			.min_uV = 1800 * 1000,
+			.max_uV = 3300 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldoio0_data),
+		.consumer_supplies = ldoio0_data,
+	},
+};
+
+static struct axp_funcdev_info axp_regldevs[] = {
+	{
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDO1,
+		.platform_data = &axp_regl_init_data[vcc_ldo1],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDO2,
+		.platform_data = &axp_regl_init_data[vcc_ldo2],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDO3,
+		.platform_data = &axp_regl_init_data[vcc_ldo3],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDO4,
+		.platform_data = &axp_regl_init_data[vcc_ldo4],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_BUCK1,
+		.platform_data = &axp_regl_init_data[vcc_buck1],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_BUCK2,
+		.platform_data = &axp_regl_init_data[vcc_buck2],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_BUCK3,
+		.platform_data = &axp_regl_init_data[vcc_buck3],
+	}, {
+		.name = "axp19-regulator",
+		.id = AXP19_ID_LDOIO0,
+		.platform_data = &axp_regl_init_data[vcc_ldoio0],
+	},
+};
+
+static struct power_supply_info battery_data ={
+        .name ="PTI PL336078",
+		.technology = POWER_SUPPLY_TECHNOLOGY_LION,
+		.voltage_max_design = 4200000,
+	    .voltage_min_design = 2700000,
+	    .charge_full_design = 1450,
+	    .energy_full_design = 1450,
+	    .use_for_apm = 1,
+};
+
+static void axp_battery_low(void)
+{
+#if defined(CONFIG_APM_EMULATION)
+	apm_queue_event(APM_LOW_BATTERY);
+#endif
+}
+
+static void axp_battery_critical(void)
+{
+#if defined(CONFIG_APM_EMULATION)
+	apm_queue_event(APM_CRITICAL_SUSPEND);
+#endif
+}
+
+
+
+static struct axp_supply_init_data axp_sply_init_data = {
+        .battery_info = &battery_data,
+        .chgcur = 700,
+        .chgvol = 4200,
+        .chgend =  60,
+        .chgen = 1,
+        //.limit_on = 1,
+        .sample_time = 25,
+        .chgpretime = 40,
+        .chgcsttime = 480,
+
+		.battery_low = axp_battery_low,
+	    .battery_critical = axp_battery_critical,
+};
+
+static struct axp_funcdev_info axp_splydev[]={
+   	{   .name = "axp19-supplyer",
+		.id = AXP19_ID_SUPPLY,
+        .platform_data = &axp_sply_init_data,
+    },
+};
+
+static struct axp_funcdev_info axp_gpiodev[]={
+   	{   .name = "axp19-gpio",
+   		.id = AXP19_ID_GPIO,
+    },
+};
+
+static struct axp_platform_data axp_pdata = {
+	.num_regl_devs = ARRAY_SIZE(axp_regldevs),
+	.num_sply_devs = ARRAY_SIZE(axp_splydev),
+	.num_gpio_devs = ARRAY_SIZE(axp_gpiodev),
+	.regl_devs = axp_regldevs,
+	.sply_devs = axp_splydev,
+	.gpio_devs = axp_gpiodev,
+};
+
+static struct i2c_board_info __initdata axp_mfd_i2c_board_info[] = {
+	{
+		.type = "axp19_mfd",
+		.addr = AXP19_ADDR,
+		.platform_data = &axp_pdata,
+		.irq = SW_INT_IRQNO_ENMI,
+	},
+};
+
+static int __init axp_board_init(void)
+{
+	return i2c_register_board_info(AXP19_I2CBUS, axp_mfd_i2c_board_info,
+				ARRAY_SIZE(axp_mfd_i2c_board_info));
+}
+fs_initcall(axp_board_init);
+
+MODULE_DESCRIPTION("Krosspower axp board");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/power/axp_power/axp19-gpio.c b/drivers/power/axp_power/axp19-gpio.c
new file mode 100644
index 0000000..d357a86
--- /dev/null
+++ b/drivers/power/axp_power/axp19-gpio.c
@@ -0,0 +1,388 @@
+/*
+ * axp199-gpio.c  --  gpiolib support for Krosspower axp19x PMICs
+ *
+ * Copyright 2011 Krosspower Microelectronics PLC.
+ *
+ * Author: Donglu Zhang <>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/mfd/core.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/i2c.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-gpio.h"
+
+struct virtual_gpio_data {
+	struct mutex lock;
+	int gpio;				//gpio number : 0/1/2/...
+	int io;                 //0: input      1: output
+	int value;				//0: low        1: high
+};
+
+int axp_gpio_set_io(int gpio, int io_state)
+{
+	if(io_state == 1){
+		switch(gpio)
+		{
+			case 0: return axp_clr_bits(&axp->dev,AXP19_GPIO0_CFG,0x07);
+			case 1: return axp_clr_bits(&axp->dev,AXP19_GPIO1_CFG,0x07);
+			case 2: return axp_clr_bits(&axp->dev,AXP19_GPIO2_CFG,0x07);
+			case 3: axp_set_bits(&axp->dev,AXP19_GPIO34_CFG,0x81);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO34_CFG,0x02);
+			case 4: axp_set_bits(&axp->dev,AXP19_GPIO34_CFG,0x84);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO34_CFG,0x08);
+			case 5: axp_set_bits(&axp->dev,AXP19_GPIO5_CFG,0x80);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO5_CFG,0x40);
+			case 6: axp_set_bits(&axp->dev,AXP19_GPIO67_CFG0,0x01);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO67_CFG1,0x40);
+			case 7: axp_set_bits(&axp->dev,AXP19_GPIO67_CFG0,0x01);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO67_CFG1,0x04);
+			default:return -ENXIO;
+		}
+	}
+	else if(io_state == 0){
+		switch(gpio)
+		{
+			case 0: axp_clr_bits(&axp->dev,AXP19_GPIO0_CFG,0x06);
+					return axp_set_bits(&axp->dev,AXP19_GPIO0_CFG,0x01);
+			case 1: axp_clr_bits(&axp->dev,AXP19_GPIO1_CFG,0x06);
+					return axp_set_bits(&axp->dev,AXP19_GPIO1_CFG,0x01);
+			case 2: axp_clr_bits(&axp->dev,AXP19_GPIO2_CFG,0x06);
+					return axp_set_bits(&axp->dev,AXP19_GPIO2_CFG,0x01);
+			case 3: axp_set_bits(&axp->dev,AXP19_GPIO34_CFG,0x82);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO34_CFG,0x01);
+			case 4: axp_set_bits(&axp->dev,AXP19_GPIO34_CFG,0x88);
+					return axp_clr_bits(&axp->dev,AXP19_GPIO34_CFG,0x04);
+			case 5: axp_set_bits(&axp->dev,AXP19_GPIO5_CFG,0xC0);
+			case 6: axp_set_bits(&axp->dev,AXP19_GPIO67_CFG0,0x01);
+					return axp_set_bits(&axp->dev,AXP19_GPIO67_CFG1,0x40);
+			case 7: axp_set_bits(&axp->dev,AXP19_GPIO67_CFG0,0x01);
+					return axp_set_bits(&axp->dev,AXP19_GPIO67_CFG1,0x04);
+			default:return -ENXIO;
+		}
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_set_io);
+
+
+int axp_gpio_get_io(int gpio, int *io_state)
+{
+	uint8_t val;
+	switch(gpio)
+	{
+		case 0: axp_read(&axp->dev,AXP19_GPIO0_CFG,&val);val &= 0x07;
+				if(val == 0x00)
+					*io_state = 1;
+				else if (val == 0x01)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 1: axp_read(&axp->dev,AXP19_GPIO1_CFG,&val);val &= 0x07;
+				if(val < 0x00)
+					*io_state = 1;
+				else if (val == 0x01)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 2: axp_read(&axp->dev,AXP19_GPIO2_CFG,&val);val &= 0x07;
+				if(val == 0x0)
+					*io_state = 1;
+				else if (val == 0x01)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 3: axp_read(&axp->dev,AXP19_GPIO34_CFG,&val);val &= 0x03;
+				if(val == 0x1)
+					*io_state = 1;
+				else if(val == 0x2)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 4: axp_read(&axp->dev,AXP19_GPIO34_CFG,&val);val &= 0x0C;
+				if(val == 0x4)
+					*io_state = 1;
+				else if(val == 0x8)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 5: axp_read(&axp->dev,AXP19_GPIO5_CFG,&val);val &= 0x40;
+				*io_state = val >> 6;
+				break;
+		case 6: axp_read(&axp->dev,AXP19_GPIO67_CFG1,&val);*io_state = (val & 0x40)?0:1;break;
+		case 7: axp_read(&axp->dev,AXP19_GPIO67_CFG1,&val);*io_state = (val & 0x04)?0:1;break;
+		default:return -ENXIO;
+	}
+
+		return 0;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_get_io);
+
+
+int axp_gpio_set_value(int gpio, int value)
+{
+	if(value){
+		switch(gpio)
+		{
+			case 0: return axp_set_bits(&axp->dev,AXP19_GPIO012_STATE,0x01);
+			case 1: return axp_set_bits(&axp->dev,AXP19_GPIO012_STATE,0x02);
+			case 2: return axp_set_bits(&axp->dev,AXP19_GPIO012_STATE,0x04);
+			case 3: return axp_set_bits(&axp->dev,AXP19_GPIO34_STATE,0x01);
+			case 4: return axp_set_bits(&axp->dev,AXP19_GPIO34_STATE,0x02);
+			case 5: return axp_set_bits(&axp->dev,AXP19_GPIO5_STATE,0x20);
+			case 6: return axp_set_bits(&axp->dev,AXP19_GPIO67_STATE,0x20);
+			case 7: return axp_set_bits(&axp->dev,AXP19_GPIO67_STATE,0x02);
+			default:break;
+		}
+	}
+	else {
+		switch(gpio)
+		{
+			case 0: return axp_clr_bits(&axp->dev,AXP19_GPIO012_STATE,0x01);
+			case 1: return axp_clr_bits(&axp->dev,AXP19_GPIO012_STATE,0x02);
+			case 2: return axp_clr_bits(&axp->dev,AXP19_GPIO012_STATE,0x04);
+			case 3: return axp_clr_bits(&axp->dev,AXP19_GPIO34_STATE,0x01);
+			case 4: return axp_clr_bits(&axp->dev,AXP19_GPIO34_STATE,0x02);
+			case 5: return axp_clr_bits(&axp->dev,AXP19_GPIO5_STATE,0x20);
+			case 6: return axp_clr_bits(&axp->dev,AXP19_GPIO67_STATE,0x20);
+			case 7: return axp_clr_bits(&axp->dev,AXP19_GPIO67_STATE,0x02);
+			default:break;
+		}
+	}
+	return -ENXIO;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_set_value);
+
+
+int axp_gpio_get_value(int gpio, int *value)
+{
+	int io_state;
+	int ret;
+	uint8_t val;
+	ret = axp_gpio_get_io(gpio,&io_state);
+	if(ret)
+		return ret;
+	if(io_state){
+		switch(gpio)
+		{
+			case 0:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val);*value = val & 0x01;break;
+			case 1:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val);*value = (val & 0x02)?1:0;break;
+			case 2:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val);*value = (val & 0x04)?1:0;break;
+			case 3:ret = axp_read(&axp->dev,AXP19_GPIO34_STATE,&val);*value =val & 0x01;break;
+			case 4:ret = axp_read(&axp->dev,AXP19_GPIO34_STATE,&val);*value =(val & 0x02)?1:0;break;
+			case 5:ret = axp_read(&axp->dev,AXP19_GPIO5_STATE,&val);*value =(val & 0x20)?1:0;break;
+			case 6:ret = axp_read(&axp->dev,AXP19_GPIO67_STATE,&val);*value =(val & 0x20)?1:0;break;
+			case 7:ret = axp_read(&axp->dev,AXP19_GPIO67_STATE,&val);*value =(val & 0x02)?1:0;break;
+			default:return -ENXIO;
+		}
+	}
+	else{
+		switch(gpio)
+		{
+			case 0:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val); *value = (val & 0x10)?1:0;break;
+			case 1:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val); *value = (val & 0x20)?1:0;break;
+			case 2:ret = axp_read(&axp->dev,AXP19_GPIO012_STATE,&val); *value = (val & 0x40)?1:0;break;
+			case 3:ret = axp_read(&axp->dev,AXP19_GPIO34_STATE,&val); *value = (val & 0x10)?1:0;break;
+			case 4:ret = axp_read(&axp->dev,AXP19_GPIO34_STATE,&val); *value = (val & 0x20)?1:0;break;
+			case 5:ret = axp_read(&axp->dev,AXP19_GPIO5_STATE,&val);  *value = (val & 0x10);break;
+			case 6:ret = axp_read(&axp->dev,AXP19_GPIO67_STATE,&val);*value =(val & 0x10)?1:0;break;
+			case 7:ret = axp_read(&axp->dev,AXP19_GPIO67_STATE,&val);*value =(val & 0x01)?1:0;break;
+			default:return -ENXIO;
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_get_value);
+
+static ssize_t show_gpio(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->gpio);
+}
+
+static ssize_t set_gpio(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	data->gpio = val;
+
+	return count;
+}
+
+static ssize_t show_io(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	int ret;
+	mutex_lock(&data->lock);
+
+	ret = axp_gpio_get_io(data->gpio,&data->io);
+
+	mutex_unlock(&data->lock);
+
+	if(ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", data->io);
+}
+
+static ssize_t set_io(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->io = val;
+	ret = axp_gpio_set_io(data->gpio,data->io);
+
+	mutex_unlock(&data->lock);
+	if(ret)
+		return ret;
+	return count;
+}
+
+
+static ssize_t show_value(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&data->lock);
+
+	ret = axp_gpio_get_value(data->gpio,&data->value);
+
+	mutex_unlock(&data->lock);
+
+	if(ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", data->value);
+}
+
+static ssize_t set_value(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->value = val;
+	ret = axp_gpio_set_value(data->gpio,data->value);
+
+	mutex_unlock(&data->lock);
+
+	if(ret){
+		return ret;
+	}
+
+	return count;
+}
+
+
+static DEVICE_ATTR(gpio,0666, show_gpio, set_gpio);
+static DEVICE_ATTR(io, 0666, show_io, set_io);
+static DEVICE_ATTR(value, 0666, show_value, set_value);
+
+struct device_attribute *attributes[] = {
+	&dev_attr_gpio,
+	&dev_attr_io,
+	&dev_attr_value,
+};
+
+
+static int __devinit axp_gpio_probe(struct platform_device *pdev)
+{
+	//struct axp_mfd_chip *axp_chip = dev_get_drvdata(pdev->dev.parent);
+	struct virtual_gpio_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_gpio_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++) {
+		ret = device_create_file(&pdev->dev, attributes[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(&pdev->dev, attributes[i]);
+	kfree(drvdata);
+	return ret;
+
+return 0;
+}
+
+static int __devexit axp_gpio_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver axp_gpio_driver = {
+	.driver.name	= "axp19-gpio",
+	.driver.owner	= THIS_MODULE,
+	.probe		= axp_gpio_probe,
+	.remove		= __devexit_p(axp_gpio_remove),
+};
+
+static int __init axp_gpio_init(void)
+{
+	return platform_driver_register(&axp_gpio_driver);
+}
+subsys_initcall(axp_gpio_init);
+
+static void __exit axp_gpio_exit(void)
+{
+	platform_driver_unregister(&axp_gpio_driver);
+}
+module_exit(axp_gpio_exit);
+
+MODULE_AUTHOR("Donglu Zhang ");
+MODULE_DESCRIPTION("GPIO interface for AXP PMICs");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:axp-gpio");
diff --git a/drivers/power/axp_power/axp19-mfd.h b/drivers/power/axp_power/axp19-mfd.h
new file mode 100644
index 0000000..30b6881
--- /dev/null
+++ b/drivers/power/axp_power/axp19-mfd.h
@@ -0,0 +1,360 @@
+/*
+ * drivers/power/axp_power/axp19-mfd.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "axp-rw.h"
+
+
+static int __devinit axp19_init_chip(struct axp_mfd_chip *chip)
+{
+	uint8_t chip_id;
+	uint8_t v[15] = {0xd8,POWER19_INTEN2, 0xff,POWER19_INTEN3, 0xfe,POWER19_INTEN4, 0x3b,POWER19_INTSTS1, 0xc3,POWER19_INTSTS2, 0xff,POWER19_INTSTS3, 0xff,POWER19_INTSTS4, 0xff};
+	int err;
+	/*read chip id*/
+	err =  __axp_read(chip->client, POWER19_IC_TYPE, &chip_id);
+	if (err)
+		return err;
+		
+	/*enable irqs and clear*/
+	err =  __axp_writes(chip->client, POWER19_INTEN1, 15, v);
+
+	if (err)
+		return err;
+
+	/* mask and clear all IRQs */
+	chip->irqs_enabled = 0xffffffff;
+	chip->ops->disable_irqs(chip, chip->irqs_enabled);
+
+	dev_info(chip->dev, "AXP (CHIP ID: 0x%02x) detected\n", chip_id);
+	chip->type = AXP19;
+
+
+	return 0;
+}
+
+static int axp19_disable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[7];
+	int ret;
+
+	chip->irqs_enabled &= ~irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER19_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER19_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	v[5] = POWER19_INTEN4;
+	v[6] = ((chip->irqs_enabled) >> 24) & 0xff;	
+	ret =  __axp_writes(chip->client, POWER19_INTEN1, 7, v);
+	
+	return ret;
+
+}
+
+static int axp19_enable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[7];
+	int ret;
+
+	chip->irqs_enabled |=  irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER19_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER19_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	v[5] = POWER19_INTEN4;
+	v[6] = ((chip->irqs_enabled) >> 24) & 0xff;
+	
+	ret =  __axp_writes(chip->client, POWER19_INTEN1, 7, v);
+	
+	return ret;
+}
+
+static int axp19_read_irqs(struct axp_mfd_chip *chip, uint64_t *irqs)
+{
+	uint8_t v[4] = {0, 0, 0, 0};
+	int ret;
+	ret =  __axp_reads(chip->client, POWER19_INTSTS1, 4, v);
+	if (ret < 0)
+		return ret;
+
+	*irqs = (v[3] << 24) | (v[2] << 16) | (v[1] << 8) | v[0];
+	return 0;
+}
+
+
+static ssize_t axp19_offvol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+	axp_read(dev,POWER19_VOFF_SET,&val);
+	return sprintf(buf,"%d\n",(val & 0x07) * 100 + 2600);
+}
+
+static ssize_t axp19_offvol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 2600)
+		tmp = 2600;
+	if (tmp > 3300)
+		tmp = 3300;
+	
+	axp_read(dev,POWER19_VOFF_SET,&val);
+	val &= 0xf8;
+	val |= ((tmp - 2600) / 100);
+	axp_write(dev,POWER19_VOFF_SET,val);
+	return count;
+}
+
+static ssize_t axp19_noedelay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_OFF_CTL,&val);
+	if( (val & 0x03) == 0)
+		return sprintf(buf,"%d\n",500);
+	else
+		return sprintf(buf,"%d\n",(val & 0x03) * 1000);
+}
+
+static ssize_t axp19_noedelay_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 500)
+		tmp = 500;
+	if (tmp > 3000)
+		tmp = 3000;	
+	axp_read(dev,POWER19_OFF_CTL,&val);
+	val &= 0xfc;
+	val |= ((tmp) / 1000);
+	axp_write(dev,POWER19_OFF_CTL,val);
+	return count;
+}
+
+static ssize_t axp19_pekopen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	int tmp = 0;
+	axp_read(dev,POWER19_POK_SET,&val);
+	switch(val >> 6){
+		case 0: tmp = 128;break;
+		case 1: tmp = 256;break;
+		case 2: tmp = 512;break;
+		case 3: tmp = 1000;break;
+		default:
+			tmp = 0;break;
+	}
+	return sprintf(buf,"%d\n",tmp);	
+}
+
+static ssize_t axp19_pekopen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	axp_read(dev,POWER19_POK_SET,&val);
+	if (tmp < 256)
+		val &= 0x3f;
+	else if(tmp < 512){
+		val &= 0x3f;
+		val |= 0x40;
+	}
+	else if(tmp < 1000){
+		val &= 0x3f;
+		val |= 0x80;
+	}
+	else {
+		val |= 0xc0;
+	}
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_peklong_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+	axp_read(dev,POWER19_POK_SET,&val);
+	return sprintf(buf,"%d\n",((val >> 4) & 0x03) * 500 + 1000);
+}
+
+static ssize_t axp19_peklong_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 1000)
+		tmp = 1000;
+	if(tmp > 2500)
+		tmp = 2500;
+	axp_read(dev,POWER19_POK_SET,&val);
+	val &= 0xcf;
+	val |= (((tmp - 1000) / 500) << 4);
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_peken_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_POK_SET,&val);
+	return sprintf(buf,"%d\n",((val >> 3) & 0x01));
+}
+
+static ssize_t axp19_peken_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp)
+		tmp = 1;
+	axp_read(dev,POWER19_POK_SET,&val);
+	val &= 0xf7;
+	val |= (tmp << 3); 
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_pekdelay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_POK_SET,&val);
+
+	return sprintf(buf,"%d\n",(((val >> 2) & 0x01) * 32) + 32);
+}
+
+static ssize_t axp19_pekdelay_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 32)
+		tmp = 32;
+	if(tmp > 64)
+		tmp =64;
+	tmp = tmp / 32 - 1;
+	axp_read(dev,POWER19_POK_SET,&val);
+	val &= 0xfb;
+	val |= tmp << 2; 
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_pekclose_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_POK_SET,&val);
+	return sprintf(buf,"%d\n",((val & 0x03) * 2000) + 4000);
+}
+
+static ssize_t axp19_pekclose_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 4000)
+		tmp = 4000;
+	if(tmp > 10000)
+		tmp =10000;
+	tmp = (tmp - 4000) / 2 ;
+	axp_read(dev,POWER19_POK_SET,&val);
+	val &= 0xfc;
+	val |= tmp ; 
+	axp_write(dev,POWER19_POK_SET,val);
+	return count;
+}
+
+static ssize_t axp19_ovtemclsen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER19_HOTOVER_CTL,&val);
+	return sprintf(buf,"%d\n",((val >> 2) & 0x01));
+}
+
+static ssize_t axp19_ovtemclsen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp)
+		tmp = 1;
+	axp_read(dev,POWER19_HOTOVER_CTL,&val);
+	val &= 0xfb;
+	val |= tmp << 2 ; 
+	axp_write(dev,POWER19_HOTOVER_CTL,val);
+	return count;
+}
+
+static ssize_t axp19_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,axp_reg_addr,&val);
+	return sprintf(buf,"REG[%x]=%x\n",axp_reg_addr,val);
+}
+
+static ssize_t axp19_reg_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 16);
+	if( tmp < 256 )
+		axp_reg_addr = tmp;
+	else {
+		val = tmp & 0x00FF;
+		axp_reg_addr= (tmp >> 8) & 0x00FF;
+		if(val)
+			axp_write(dev,axp_reg_addr,val);
+	}
+	return count;
+}
+
+static struct device_attribute axp19_mfd_attrs[] = {
+	AXP_MFD_ATTR(axp19_offvol),
+	AXP_MFD_ATTR(axp19_noedelay),	
+	AXP_MFD_ATTR(axp19_pekopen),
+	AXP_MFD_ATTR(axp19_peklong),
+	AXP_MFD_ATTR(axp19_peken),
+    AXP_MFD_ATTR(axp19_pekdelay),
+    AXP_MFD_ATTR(axp19_pekclose),
+    AXP_MFD_ATTR(axp19_ovtemclsen),
+    AXP_MFD_ATTR(axp19_reg),
+};
diff --git a/drivers/power/axp_power/axp19-regu.c b/drivers/power/axp_power/axp19-regu.c
new file mode 100644
index 0000000..ff2139a
--- /dev/null
+++ b/drivers/power/axp_power/axp19-regu.c
@@ -0,0 +1,438 @@
+/*
+ * Regulators driver for Dialog Semiconductor DA903x
+ *
+ * Copyright (C) 2006-2008 Marvell International Ltd.
+ * Copyright (C) 2008 Compulab Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+
+#include "axp-regu.h"
+
+static inline struct device *to_axp_dev(struct regulator_dev *rdev)
+{
+	return rdev_get_dev(rdev)->parent->parent;
+}
+
+static inline int check_range(struct axp_regulator_info *info,
+				int min_uV, int max_uV)
+{
+	if (min_uV < info->min_uV || min_uV > info->max_uV)
+		return -EINVAL;
+
+	return 0;
+}
+
+
+/* AXP common operations */
+static int axp_set_voltage(struct regulator_dev *rdev,
+				  int min_uV, int max_uV)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	
+
+	if (check_range(info, min_uV, max_uV)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+	val = (min_uV - info->min_uV + info->step_uV - 1) / info->step_uV;
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	return axp_update(axp_dev, info->vol_reg, val, mask);
+}
+
+static int axp_get_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int ret;
+
+	ret = axp_read(axp_dev, info->vol_reg, &val);
+	if (ret)
+		return ret;
+  
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+
+	return info->min_uV + info->step_uV * val;
+	
+}
+
+static int axp_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_set_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_clr_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return !!(reg_val & (1 << info->enable_bit));
+}
+
+static int axp_list_voltage(struct regulator_dev *rdev, unsigned selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret;
+
+	ret = info->min_uV + info->step_uV * selector;
+	if (ret > info->max_uV)
+		return -EINVAL;
+	return ret;
+}
+
+static int axp_set_suspend_voltage(struct regulator_dev *rdev, int uV)
+{
+	int ldo = rdev_get_id(rdev);
+
+	switch (ldo) {
+	
+	case AXP19_ID_LDO1 ... AXP19_ID_LDOIO0:
+		return axp_set_voltage(rdev, uV, uV);
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct regulator_ops axp19_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_enable,
+	.disable	= axp_disable,
+	.is_enabled	= axp_is_enabled,
+	.set_suspend_enable		= axp_enable,
+	.set_suspend_disable	= axp_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+
+static int axp_ldoio0_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	 axp_set_bits(axp_dev, info->enable_reg,0x02);
+	 return axp_clr_bits(axp_dev, info->enable_reg,0x05);
+}
+
+static int axp_ldoio0_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	axp_set_bits(axp_dev, info->enable_reg,0x05);
+	return axp_clr_bits(axp_dev, info->enable_reg,0x02);
+}
+
+static int axp_ldoio0_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return (((reg_val &= 0x07)== 0x02)?1:0);
+}
+
+static struct regulator_ops axp19_ldoio0_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_ldoio0_enable,
+	.disable	= axp_ldoio0_disable,
+	.is_enabled	= axp_ldoio0_is_enabled,
+	.set_suspend_enable		= axp_ldoio0_enable,
+	.set_suspend_disable	= axp_ldoio0_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+#define AXP19_LDO(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_LDO(AXP19, _id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+#define AXP19_BUCK(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_BUCK(AXP19, _id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+
+	
+
+static struct axp_regulator_info axp_regulator_info[] = {
+	AXP19_LDO( 1,  AXP19LDO1,AXP19LDO1,   0,  RTC,    0,    0,  LDO1EN,    0),//ldo1 for rtc
+	AXP19_LDO( 2,     1800,     3300, 100,ANALOG1,    4,    4,  LDO2EN,    2),//ldo2 for analog1 
+	AXP19_LDO( 3,      700,     3500,  25,DIGITAL,    0,    7,  LDO3EN,    2),//ldo3 for digital
+	AXP19_LDO( 4,     1800,     3300, 100,ANALOG2,    0,    4,  LDO4EN,    3),//ldo4 for analog2
+	AXP19_BUCK(1,      700,     3500,  25,     IO,    0,    7, DCDC1EN,    0),//dcdc1 for io
+	AXP19_BUCK(2,      700,     2275,  25,   CORE,    0,    6, DCDC2EN,    0),//dcdc2 for core
+	AXP19_BUCK(3,      700,     3500,  25, MEMORY,    0,    7, DCDC3EN,    1),//dcdc3 for memery
+	AXP19_LDO( IO0,	  1800,		3300, 100, LDOIO0,	  4,	4, LDOIOEN,	   0),//ldoio0 for mic
+};
+
+static ssize_t workmode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP19_BUCKMODE, &val);
+	if (ret)
+		return sprintf(buf, "IO ERROR\n");
+	
+	if(info->desc.id == AXP19_ID_BUCK2){
+		switch (val & 0x04) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 4:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP19_ID_BUCK3){
+		switch (val & 0x02) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 2:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP19_ID_BUCK1){
+		switch (val & 0x08) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 2:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else
+		return sprintf(buf, "IO ID ERROR\n");
+}
+
+static ssize_t workmode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	char mode;
+	uint8_t val;
+	if(  buf[0] > '0' && buf[0] < '9' )// 1/AUTO: auto mode; 2/PWM: pwm mode;
+		mode = buf[0];
+	else
+		mode = buf[1];
+	
+	switch(mode){
+	 case 'U':
+	 case 'u':
+	 case '1':
+		val = 0;break;
+	 case 'W':
+	 case 'w':
+	 case '2':
+	 	val = 1;break;
+	 default:
+	    val =0;	
+	}
+	
+	if(info->desc.id == AXP19_ID_BUCK2){
+		if(val)
+			axp_set_bits(axp_dev, AXP19_BUCKMODE,0x04);
+		else
+			axp_clr_bits(axp_dev, AXP19_BUCKMODE,0x04);
+	}
+	else if(info->desc.id == AXP19_ID_BUCK3){
+		if(val)
+			axp_set_bits(axp_dev, AXP19_BUCKMODE,0x02);
+		else
+			axp_clr_bits(axp_dev, AXP19_BUCKMODE,0x02);
+	}
+	else if(info->desc.id == AXP19_ID_BUCK1){
+		if(val)
+			axp_set_bits(axp_dev, AXP19_BUCKMODE,0x08);
+		else
+			axp_clr_bits(axp_dev, AXP19_BUCKMODE,0x08);
+	}
+	else
+		return -EINVAL;
+	return count;
+}
+
+static ssize_t frequency_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP19_BUCKFREQ, &val);
+	if (ret)
+		return ret;
+	ret = val & 0x0F;
+	return sprintf(buf, "%d\n",(ret*75 + 750));
+}
+
+static ssize_t frequency_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val,tmp;
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var < 750)
+		var = 750;
+	if(var > 1875)
+		var = 1875;
+		
+	val = (var -750)/75;
+	val &= 0x0F;
+	
+	axp_read(axp_dev, AXP19_BUCKFREQ, &tmp);
+	tmp &= 0xF0;
+	val |= tmp;
+	axp_write(axp_dev, AXP19_BUCKFREQ, val);
+	return count;
+}
+
+
+static struct device_attribute axp_regu_attrs[] = {
+	AXP_REGU_ATTR(workmode),
+	AXP_REGU_ATTR(frequency),
+};
+
+int axp_regu_create_attrs(struct platform_device *pdev)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_regu_attrs); j++) {
+		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+	
+sysfs_failed:
+	while (j--)
+		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
+succeed:
+	return ret;
+}
+
+static inline struct axp_regulator_info *find_regulator_info(int id)
+{
+	struct axp_regulator_info *ri;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(axp_regulator_info); i++) {
+		ri = &axp_regulator_info[i];
+		if (ri->desc.id == id)
+			return ri;
+	}
+	return NULL;
+}
+
+static int __devinit axp_regulator_probe(struct platform_device *pdev)
+{
+	struct axp_regulator_info *ri = NULL;
+	struct regulator_dev *rdev;
+	int ret;
+
+	ri = find_regulator_info(pdev->id);
+	if (ri == NULL) {
+		dev_err(&pdev->dev, "invalid regulator ID specified\n");
+		return -EINVAL;
+	}
+
+	if (ri->desc.id == AXP19_ID_LDO1 || ri->desc.id == AXP19_ID_LDO2 \
+		|| ri->desc.id == AXP19_ID_LDO3 || ri->desc.id == AXP19_ID_LDO4 \
+		||ri->desc.id == AXP19_ID_BUCK1 || ri->desc.id == AXP19_ID_BUCK2 \
+		||ri->desc.id == AXP19_ID_BUCK3)
+		ri->desc.ops = &axp19_ops;
+
+	if(ri->desc.id == AXP19_ID_LDOIO0)
+		ri->desc.ops = &axp19_ldoio0_ops;
+	
+	rdev = regulator_register(&ri->desc, &pdev->dev,
+				  pdev->dev.platform_data, ri, NULL);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register regulator %s\n",
+				ri->desc.name);
+		return PTR_ERR(rdev);
+	}
+
+	platform_set_drvdata(pdev, rdev);
+	
+	if(ri->desc.id == AXP19_ID_BUCK1 || ri->desc.id == AXP19_ID_BUCK2 \
+		||ri->desc.id == AXP19_ID_BUCK3){
+		ret = axp_regu_create_attrs(pdev);
+		if(ret){
+			return ret;
+		}
+	}
+	
+	return 0;
+}
+
+static int __devexit axp_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+	return 0;
+}
+
+static struct platform_driver axp_regulator_driver = {
+	.driver	= {
+		.name	= "axp19-regulator",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp_regulator_probe,
+	.remove		= axp_regulator_remove,
+};
+
+static int __init axp_regulator_init(void)
+{
+	return platform_driver_register(&axp_regulator_driver);
+}
+module_init(axp_regulator_init);
+
+static void __exit axp_regulator_exit(void)
+{
+	platform_driver_unregister(&axp_regulator_driver);
+}
+module_exit(axp_regulator_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Donglu Zhang");
+MODULE_DESCRIPTION("Regulator Driver for Krosspower AXP19 PMIC");
+MODULE_ALIAS("platform:axp-regulator");
diff --git a/drivers/power/axp_power/axp19-sply.c b/drivers/power/axp_power/axp19-sply.c
new file mode 100644
index 0000000..634c304
--- /dev/null
+++ b/drivers/power/axp_power/axp19-sply.c
@@ -0,0 +1,1581 @@
+/*
+ * Battery charger driver for Dialog Semiconductor DA9030
+ *
+ * Copyright (C) 2008 Compulab, Ltd.
+ * 	Mike Rapoport <mike@compulab.co.il>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+#include "axp-sply.h"
+
+static inline int axp199_vbat_to_mV(uint16_t reg)
+{
+	return ((int)((( reg >> 8) << 4 ) | (reg & 0x000F))) * 1100 / 1000;
+}
+
+static inline int axp199_vdc_to_mV(uint16_t reg)
+{
+	return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 1700 / 1000;
+}
+
+
+static inline int axp199_ibat_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 5 ) | (reg & 0x001F))) * 500 / 1000;
+}
+
+static inline int axp199_iac_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 625 / 1000;
+}
+
+static inline int axp199_iusb_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 375 / 1000;
+}
+
+
+static inline void axp_read_adc(struct axp_charger *charger,
+	struct axp_adc_res *adc)
+{
+   uint8_t tmp[8];
+
+   axp_reads(charger->master,AXP19_VACH_RES,8,tmp);
+	 adc->vac_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
+	 adc->iac_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
+	 adc->vusb_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
+	 adc->iusb_res = ((uint16_t) tmp[6] << 8 )| tmp[7];
+ 	 axp_reads(charger->master,AXP19_VBATH_RES,6,tmp);
+	 adc->vbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
+	 adc->ichar_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
+	 adc->idischar_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
+}
+
+
+static void axp_charger_update_state(struct axp_charger *charger)
+{
+	uint8_t val[2];
+	uint16_t tmp;
+
+	axp_reads(charger->master,AXP19_CHARGE_STATUS,2,val);
+	tmp = (val[1] << 8 )+ val[0];
+	//printk("tmp = 0x%x\n",tmp);
+	charger->is_on = (val[1] & AXP19_IN_CHARGE) ? 1 : 0;
+	charger->fault = val[1];
+	charger->bat_det = (tmp & AXP19_STATUS_BATEN)?1:0;
+	charger->ac_det = (tmp & AXP19_STATUS_ACEN)?1:0;
+	charger->usb_det = (tmp & AXP19_STATUS_USBEN)?1:0;
+	charger->usb_valid = (tmp & AXP19_STATUS_USBVA)?1:0;
+	charger->ac_valid = (tmp & AXP19_STATUS_ACVA)?1:0;
+	charger->ext_valid = charger->ac_valid | charger->usb_valid;
+	charger->bat_current_direction = (tmp & AXP19_STATUS_BATCURDIR)?1:0;
+	charger->in_short = (tmp& AXP19_STATUS_ACUSBSH)?1:0;
+	charger->batery_active = (tmp & AXP19_STATUS_BATINACT)?1:0;
+	charger->low_charge_current = (tmp & AXP19_STATUS_CHACURLOEXP)?1:0;
+	charger->int_over_temp = (tmp & AXP19_STATUS_ICTEMOV)?1:0;
+}
+
+static void axp_charger_update(struct axp_charger *charger)
+{
+	uint16_t tmp;
+	struct axp_adc_res adc;
+	charger->adc = &adc;
+	axp_read_adc(charger, &adc);
+	tmp = charger->adc->vbat_res;
+	charger->vbat = axp199_vbat_to_mV(tmp);
+	//tmp = charger->adc->ichar_res + charger->adc->idischar_res;
+	charger->ibat = ABS(axp199_ibat_to_mA(charger->adc->ichar_res)-axp199_ibat_to_mA(charger->adc->idischar_res));
+	tmp = charger->adc->vac_res;
+	charger->vac = axp199_vdc_to_mV(tmp);
+	tmp = charger->adc->iac_res;
+	charger->iac = axp199_iac_to_mA(tmp);
+	tmp = charger->adc->vusb_res;
+	charger->vusb = axp199_vdc_to_mV(tmp);
+	tmp = charger->adc->iusb_res;
+	charger->iusb = axp199_iusb_to_mA(tmp);
+}
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static void axp_set_charge(struct axp_charger *charger)
+{
+	uint8_t val=0x00;
+	uint8_t	tmp=0x00;
+	uint8_t var[3];
+		if(charger->chgvol < 4150)
+			val &= ~(3 << 5);
+		else if (charger->chgvol<4200){
+			val &= ~(3 << 5);
+			val |= 1 << 5;
+			}
+		else if (charger->chgvol<4360){
+			val &= ~(3 << 5);
+			val |= 1 << 6;
+			}
+		else
+			val |= 3 << 5;
+
+		if(charger->chgcur< 100)
+			charger->chgcur =100;
+
+		val |= (charger->chgcur - 100) / 100 ;
+		if(charger ->chgend == 10){
+			val &= ~(1 << 4);
+		}
+		else {
+			val |= 1 << 4;
+		}
+		val &= 0x7F;
+		val |= charger->chgen << 7;
+	    if(charger->chgpretime < 30)
+			charger->chgpretime = 30;
+		if(charger->chgcsttime < 420)
+			charger->chgcsttime = 420;
+		if(charger->chgextcur < 300)
+			charger->chgextcur = 300;
+
+		tmp = ((charger->chgpretime - 30) / 10) << 6  \
+			| (charger->chgcsttime - 420) / 60 | \
+			(charger->chgexten << 2) | ((charger->chgextcur - 300) / 100 << 3);
+
+	var[0] = val;
+	var[1] = AXP19_CHARGE_CONTROL2;
+	var[2] = tmp;
+	axp_writes(charger->master, AXP19_CHARGE_CONTROL1,3, var);
+}
+#else
+static void axp_set_charge(struct axp_charger *charger)
+{
+
+}
+#endif
+
+static enum power_supply_property axp_battery_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+    POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+};
+
+static enum power_supply_property axp_ac_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property axp_usb_props[] = {
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static void axp_battery_check_status(struct axp_charger *charger,
+				    union power_supply_propval *val)
+{
+	if (charger->bat_det) {
+		if (charger->is_on)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if( charger->rest_vol == 100 && charger->ext_valid)
+			  val->intval = POWER_SUPPLY_STATUS_FULL;
+		else if( charger->ext_valid )
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+	}
+	else
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+}
+
+static void axp_battery_check_health(struct axp_charger *charger,
+				    union power_supply_propval *val)
+{
+    if (charger->fault & AXP19_FAULT_LOG_BATINACT)
+		val->intval = POWER_SUPPLY_HEALTH_DEAD;
+	else if (charger->fault & AXP19_FAULT_LOG_OVER_TEMP)
+		val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (charger->fault & AXP19_FAULT_LOG_COLD)
+		val->intval = POWER_SUPPLY_HEALTH_COLD;
+	else
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static int axp_battery_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, batt);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		axp_battery_check_status(charger, val);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		axp_battery_check_health(charger, val);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = charger->battery_info->technology;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = charger->battery_info->voltage_max_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = charger->battery_info->voltage_min_design;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vbat * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->ibat * 1000;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->batt.name;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = charger->battery_info->charge_full_design;
+        break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = charger->rest_vol;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		if(charger->bat_det && !(charger->is_on) && !(charger->ext_valid))
+			val->intval = charger->rest_time;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		if(charger->bat_det && charger->is_on)
+			val->intval = charger->rest_time;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = (!charger->is_on)&&(charger->bat_det) && (! charger->ext_valid);
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->bat_det;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int axp_ac_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, ac);
+
+	switch(psp){
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->ac.name;break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->ac_det;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->ac_valid;break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vac * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->iac * 1000;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+   return ret;
+}
+
+static int axp_usb_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	struct axp_charger *charger;
+	int ret = 0;
+	charger = container_of(psy, struct axp_charger, usb);
+
+	switch(psp){
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = charger->usb.name;break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = charger->usb_det;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = charger->usb_valid;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = charger->vusb * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = charger->iusb * 1000;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+   return ret;
+}
+
+
+static int axp_battery_event(struct notifier_block *nb, unsigned long event,
+				void *data)
+{
+	struct axp_charger *charger =
+		container_of(nb, struct axp_charger, nb);
+
+	axp_charger_update_state(charger);
+
+	switch (event) {
+	case AXP19_IRQ_BATIN:
+	case AXP19_IRQ_ACIN:
+	case AXP19_IRQ_USBIN:
+		axp_set_bits(charger->master,AXP19_CHARGE_CONTROL1,0x80);
+		break;
+	case AXP19_IRQ_BATRE:
+	case AXP19_IRQ_ACOV:
+	case AXP19_IRQ_ACRE:
+	case AXP19_IRQ_USBOV:
+	case AXP19_IRQ_USBRE:
+    case AXP19_IRQ_TEMOV:
+	case AXP19_IRQ_TEMLO:
+		axp_clr_bits(charger->master,AXP19_CHARGE_CONTROL1,0x80);
+		break;
+    default:
+		break;
+	}
+
+	return 0;
+}
+
+static char *supply_list[] = {
+	"battery",
+};
+
+
+
+static void axp_battery_setup_psy(struct axp_charger *charger)
+{
+	struct power_supply *batt = &charger->batt;
+	struct power_supply *ac = &charger->ac;
+	struct power_supply *usb = &charger->usb;
+	struct power_supply_info *info = charger->battery_info;
+
+	batt->name = "battery";
+	batt->use_for_apm = info->use_for_apm;
+	batt->type = POWER_SUPPLY_TYPE_BATTERY;
+	batt->get_property = axp_battery_get_property;
+
+	batt->properties = axp_battery_props;
+	batt->num_properties = ARRAY_SIZE(axp_battery_props);
+
+	ac->name = "ac";
+	ac->type = POWER_SUPPLY_TYPE_MAINS;
+	ac->get_property = axp_ac_get_property;
+
+	ac->supplied_to = supply_list,
+	ac->num_supplicants = ARRAY_SIZE(supply_list),
+
+	ac->properties = axp_ac_props;
+	ac->num_properties = ARRAY_SIZE(axp_ac_props);
+
+	usb->name = "usb";
+	usb->type = POWER_SUPPLY_TYPE_USB;
+	usb->get_property = axp_usb_get_property;
+
+	usb->supplied_to = supply_list,
+	usb->num_supplicants = ARRAY_SIZE(supply_list),
+
+	usb->properties = axp_usb_props;
+	usb->num_properties = ARRAY_SIZE(axp_usb_props);
+};
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+	 int ret ;
+	 uint8_t val;
+
+	/*enable adc and set adc */
+	val= AXP19_ADC_BATVOL_ENABLE | AXP19_ADC_BATCUR_ENABLE
+	| AXP19_ADC_DCINCUR_ENABLE | AXP19_ADC_DCINVOL_ENABLE
+	| AXP19_ADC_USBVOL_ENABLE | AXP19_ADC_USBCUR_ENABLE;
+
+	ret = axp_write(charger->master, AXP19_ADC_CONTROL1, val);
+	if (ret)
+		return ret;
+    ret = axp_read(charger->master, AXP19_ADC_CONTROL3, &val);
+	switch (charger->sample_time/25){
+	case 1: val &= ~(3 << 6);break;
+	case 2: val &= ~(3 << 6);val |= 1 << 6;break;
+	case 4: val &= ~(3 << 6);val |= 2 << 6;break;
+	case 8: val |= 3 << 6;break;
+	default: break;
+	}
+	ret = axp_write(charger->master, AXP19_ADC_CONTROL3, val);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+#else
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+	return 0;
+}
+#endif
+
+static int axp_battery_first_init(struct axp_charger *charger)
+{
+   int ret;
+   uint8_t val;
+   axp_set_charge(charger);
+   ret = axp_battery_adc_set(charger);
+   if(ret)
+   	return ret;
+
+   ret = axp_read(charger->master, AXP19_ADC_CONTROL3, &val);
+   switch ((val >> 6) & 0x03){
+	case 0: charger->sample_time = 25;break;
+	case 1: charger->sample_time = 50;break;
+	case 2: charger->sample_time = 100;break;
+	case 3: charger->sample_time = 200;break;
+	default:break;
+	}
+  return ret;
+}
+
+static int axp_get_rdc(struct axp_charger *charger)
+{
+    uint8_t val[2];
+    unsigned int i,temp,pre_temp;
+    int averPreVol = 0, averPreCur = 0,averNextVol = 0,averNextCur = 0;
+
+	axp_reads(charger->master,AXP19_DATA_BUFFER2,2,val);
+
+	pre_temp = (((val[0] & 0x07) << 8 ) + val[1]);
+
+	if(!charger->bat_det){
+        return pre_temp;
+	}
+	if( charger->ext_valid){
+		for(i = 0; i< AXP19_RDC_COUNT; i++){
+            axp_charger_update(charger);
+			averPreVol += charger->vbat;
+			averPreCur += charger->ibat;
+			msleep(200);
+        }
+        averPreVol /= AXP19_RDC_COUNT;
+        averPreCur /= AXP19_RDC_COUNT;
+		axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+		msleep(3000);
+		for(i = 0; i< AXP19_RDC_COUNT; i++){
+            axp_charger_update(charger);
+			averNextVol += charger->vbat;
+			averNextCur += charger->ibat;
+			msleep(200);
+        }
+		averNextVol /= AXP19_RDC_COUNT;
+		averNextCur /= AXP19_RDC_COUNT;
+		axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+		if(ABS(averPreCur - averNextCur) > 200){
+            temp = 1000 * ABS(averPreVol - averNextVol) / ABS(averPreCur - averNextCur);
+			if((temp < 5) || (temp > 5000)){
+                return pre_temp;
+			}
+			else {
+				temp += pre_temp;
+			 	temp >>= 1;
+			  axp_write(charger->master,AXP19_DATA_BUFFER2,((temp & 0xFF00) | 0x800) >> 8);
+		    axp_write(charger->master,AXP19_DATA_BUFFER3,temp & 0x00FF);
+				return temp;
+			}
+		}
+		else {
+			return pre_temp;
+		}
+	}
+	else {
+        return pre_temp;
+	}
+}
+
+static int axp_bat_vol(bool Flag,int Bat_Vol,int Bat_Cur,uint16_t Rdc)
+{
+    if(Flag)
+    {
+        return Bat_Vol- (Bat_Cur*(int)Rdc/1000);
+    }
+    else
+    {
+        return Bat_Vol+ (Bat_Cur*(int)Rdc/1000);
+    }
+}
+
+static int axp_get_coulomb(struct axp_charger *charger)
+{
+	uint64_t rValue1,rValue2,rValue;
+	uint8_t IC_type;
+	uint8_t temp[8];
+	axp_read(charger->master,03, &temp[0]);
+	if( (temp[0] & 0x0f) == 0x03){
+		IC_type = 1;
+	}
+	else{
+		IC_type = 0;
+	}
+	axp_reads(charger->master,AXP19_CCHAR3_RES,8,temp);
+	if(IC_type){
+		rValue1 = 65536 * ((((uint64_t)temp[0]) << 24) + (((uint64_t)temp[1]) << 16) +
+		(((uint64_t)temp[2]) << 8) + ((uint64_t)temp[3]));
+    rValue2 = 65536 * ((((uint64_t)temp[4] )<< 24) + (((uint64_t)temp[5]) << 16) +
+		(((uint64_t)temp[6]) << 8) + ((uint64_t)temp[7]));
+	}
+	else{
+		rValue1 = ((((uint64_t)temp[0]) << 24) + (((uint64_t)temp[1]) << 16) +
+		(((uint64_t)temp[2]) << 8) + ((uint64_t)temp[3]));
+    rValue2 = ((((uint64_t)temp[4] )<< 24) + (((uint64_t)temp[5]) << 16) +
+		(((uint64_t)temp[6]) << 8) + ((uint64_t)temp[7]));
+	}
+    if(rValue1 > rValue2){
+    	coulomb_flag = 1;
+        rValue = rValue1 - rValue2 ;
+    }
+    else{
+        coulomb_flag = 0;
+        rValue = rValue2 - rValue1 ;
+    }
+
+    return (int) rValue /charger->sample_time/ 3600 / 2;
+}
+
+static uint8_t axp_vol_rate(int Bat_Ocv_Vol)
+{
+    if(Bat_Ocv_Vol > FUELGUAGE_TOP_VOL)         //4160
+    {
+        return FUELGUAGE_TOP_LEVEL;
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_LOW_VOL)    //<3400
+    {
+        return FUELGUAGE_LOW_LEVEL;
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL1)       //3500
+    {
+        return FUELGUAGE_LOW_LEVEL + (FUELGUAGE_LEVEL1 - FUELGUAGE_LOW_LEVEL) * ((int)Bat_Ocv_Vol - FUELGUAGE_LOW_VOL) / (FUELGUAGE_VOL1 - FUELGUAGE_LOW_VOL);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL2)       //3600
+    {
+        return FUELGUAGE_LEVEL1 + (FUELGUAGE_LEVEL2 - FUELGUAGE_LEVEL1) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL1) / (FUELGUAGE_VOL2 - FUELGUAGE_VOL1);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL3)       //3700
+    {
+        return FUELGUAGE_LEVEL2 + (FUELGUAGE_LEVEL3 - FUELGUAGE_LEVEL2) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL2) / (FUELGUAGE_VOL3 - FUELGUAGE_VOL2);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL4)       //3800
+    {
+        return FUELGUAGE_LEVEL3 + (FUELGUAGE_LEVEL4 - FUELGUAGE_LEVEL3) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL3) / (FUELGUAGE_VOL4 - FUELGUAGE_VOL3);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL5)       //3900
+    {
+        return FUELGUAGE_LEVEL4 + (FUELGUAGE_LEVEL5 - FUELGUAGE_LEVEL4) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL4) / (FUELGUAGE_VOL5 - FUELGUAGE_VOL4);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL6)       //4000
+    {
+        return FUELGUAGE_LEVEL5 + (FUELGUAGE_LEVEL6 - FUELGUAGE_LEVEL5) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL5) / (FUELGUAGE_VOL6 - FUELGUAGE_VOL5);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_VOL7)       //4100
+    {
+        return FUELGUAGE_LEVEL6 + (FUELGUAGE_LEVEL7 - FUELGUAGE_LEVEL6) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL6) / (FUELGUAGE_VOL7 - FUELGUAGE_VOL6);
+    }
+    else if(Bat_Ocv_Vol < FUELGUAGE_TOP_VOL)    //4100
+    {
+        return FUELGUAGE_LEVEL7 + (FUELGUAGE_TOP_LEVEL - FUELGUAGE_LEVEL7) * ((int)Bat_Ocv_Vol - FUELGUAGE_VOL7) / (FUELGUAGE_TOP_VOL - FUELGUAGE_VOL7);
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+
+static int axp_cal_resttime(struct axp_charger *charger,uint8_t chg_status, uint16_t Bat_Ocv_Vol, uint16_t Rdc)
+{
+	uint8_t Tcv_Rest_Vol = 0;
+    uint16_t Iconst_current = 1;
+    unsigned int rest_time = 0;
+	int Tcv = 0;
+	if(charger->ibat == 0)  charger->ibat = 1;
+	if(chg_status > 0x03){
+		if(charger->vbat < 4195){
+			Tcv_Rest_Vol = axp_vol_rate(4200 - charger->ibat *(int) Rdc / 1000);
+			Iconst_current = charger->ibat;
+			if(Tcv_Rest_Vol < 70){
+				Tcv = 60 * (100 - (int)Tcv_Rest_Vol) * charger->battery_info->energy_full_design/ (45 * charger->ibat);
+			}
+			else{
+                Tcv = 60 * (100 - (int)Tcv_Rest_Vol) * charger->battery_info->energy_full_design / (35 * charger->ibat);
+			}
+			rest_time = 6 * charger->battery_info->energy_full_design * ABS(Tcv_Rest_Vol - charger->rest_vol) / charger->ibat / 10 + Tcv ;
+		}
+		else{
+			if(Iconst_current == 1){
+				Iconst_current = charger->chgcur;
+			}
+			if(Tcv == 0){
+				Tcv_Rest_Vol =axp_vol_rate(4200 - charger->chgcur * (int)Rdc / 1000);
+				if(Tcv_Rest_Vol < 70){
+                    Tcv = 60 * (100 - (int)Tcv_Rest_Vol) * charger->chgcur / (45 * charger->chgcur);
+                }
+                else{
+                    Tcv = 60 * (100 - (int)Tcv_Rest_Vol) * charger->chgcur / (35 * charger->chgcur);
+                }
+			}
+			if(charger->ibat < (charger->chgcur *charger->chgend/100)){
+                rest_time = 1;
+            }
+            else{
+                rest_time = (unsigned int)Tcv * (90 + 110 * (charger->chgcur *charger->chgend/100) / (unsigned int)charger->ibat) * (90 +100 * (charger->chgcur *charger->chgend/100)
+					/ (unsigned int)charger->ibat) * ABS(charger->ibat - (charger->chgcur *charger->chgend/100)) / (unsigned int)Iconst_current /10000;
+            }
+		}
+	}
+	else  //æ¾çµ
+    {
+        __u8  End_Vol_Rate = axp_vol_rate(END_VOLTAGE_APS + (charger->ibat * ((int)Rdc + 110) / 1000));
+
+        if(charger->pbat)
+        {
+            rest_time = BAT_AVER_VOL * charger->battery_info->energy_full_design
+				* ABS(charger->rest_vol- (int)End_Vol_Rate) / charger->pbat * 6 / 10  ;
+        }
+        if(Bat_Ocv_Vol)
+        {
+            rest_time *= charger->vbat;                                            //å¯¹OCVåçä¿®æ­£
+            rest_time /= (unsigned int)Bat_Ocv_Vol;
+
+        }
+        rest_time *= 100;           //å¯¹çµæ± çµååä½åæçæé«çä¿®æ­£
+        rest_time /= 99;
+
+    }
+
+    return rest_time;
+}
+
+
+
+static int axp_main_task(void *arg)
+{
+    struct axp_charger *charger = arg;
+	uint8_t temp_value[8];
+    uint8_t Bat_Cap_Buffer[AXP19_VOL_MAX];
+    uint16_t Bat_Time_Buffer[AXP19_TIME_MAX];
+    uint32_t Bat_Power_Buffer[AXP19_AVER_MAX];
+    int     Cur_CoulombCounter;
+    uint8_t  Pre_rest_cap=0,Pre_ocv_rest_cap=0,Pre_Cur_Cal_rest_cap=0;
+    uint16_t		Bat_Rdc,Bat_Vol,Bat_Ocv_Vol;
+	uint16_t		i = 0,j = 0,k = 0,m = 0;
+	uint32_t		Total_Cap = 0,Total_Time = 0,Total_Power = 0;
+	uint8_t		Rdc_Flag = 0,Pre_Rdc_Flag = 0;
+    uint8_t		Cou_Correction_Flag = 0;
+	uint8_t		Real_Cou_Flag = 0;
+	int rt_rest_vol, ocv_rest_vol, cou_rest_vol;
+	uint8_t rt_charge_status;
+	uint8_t v[4] = {0, 0, 0,0};
+	uint8_t w[7];
+	int events;
+	bool peklong;
+    bool pekshort;
+    uint8_t long_cnt = 0;
+	bool status_usb, pre_status_usb;
+    bool status_ac, pre_status_ac;
+    bool status_bat, pre_status_bat;
+    int pre_rest_vol;
+    pre_rest_vol = 0;
+	status_usb = 0;
+    pre_status_usb = 0;
+    status_ac = 0;
+    pre_status_ac = 0;
+    status_bat = 0;
+    pre_status_bat =0;
+
+	axp_write(charger->master,AXP19_TIMER_CTL,0x80);
+	axp_reads(charger->master,AXP19_DATA_BUFFER1,2,temp_value);
+	Real_Cou_Flag = (temp_value[0] & 0x80);
+
+	if(Real_Cou_Flag)
+		charger->battery_info->energy_full_design=5 * (((temp_value[0] & 0x7f) << 4) + ((temp_value[1] & 0xf0) >> 4));
+	axp_reads(charger->master,AXP19_DATA_BUFFER2,2,temp_value);
+	Bat_Rdc = ((temp_value[0] & 0x07) << 8) + temp_value[1];
+
+    Pre_Rdc_Flag = temp_value[0] & 0x08;
+	if(Pre_Rdc_Flag){
+      //  Bat_Rdc = (Bat_Rdc & 0x7ff) * 3;
+    }
+    else{
+        Bat_Rdc = 250;
+    }
+
+	memset(Bat_Cap_Buffer, 0, sizeof(Bat_Cap_Buffer));
+	memset(Bat_Time_Buffer, 0, sizeof(Bat_Time_Buffer));
+	memset(Bat_Power_Buffer, 0, sizeof(Bat_Power_Buffer));
+
+	while(1){
+		if(kthread_should_stop()) break;
+        axp_charger_update_state(charger);
+        axp_charger_update(charger);
+
+		axp_reads(charger->master,POWER19_INTSTS1, 4, v);
+		events = (v[3] << 24 )|(v[2] << 16) | (v[1] << 8) | v[0];
+		w[0] = v[0];
+		w[1] = POWER19_INTSTS2;
+		w[2] = v[1];
+		w[3] = POWER19_INTSTS3;
+		w[4] = v[2];
+		w[5] = POWER19_INTSTS4;
+		w[6] = v[3];
+		peklong = (events & AXP19_IRQ_PEKLO)? 1 : 0;
+		pekshort = (events & AXP19_IRQ_PEKSH )? 1 : 0;
+
+		status_ac = charger->ac_valid;
+		status_usb = charger->usb_valid;
+        status_bat = (!charger->is_on)&&(charger->bat_det);
+
+        if(status_usb != pre_status_usb || status_ac != pre_status_ac || status_bat != pre_status_bat )
+        {
+            power_supply_changed(&charger->batt);
+			pre_status_ac =  status_ac;
+			pre_status_usb = status_usb;
+			pre_status_bat = status_bat;
+         }
+
+		if(long_cnt){
+			long_cnt--;
+			if(long_cnt == 0 ){
+				printk("press long up\n");
+				input_report_key(powerkeydev, KEY_POWER, 0);
+				input_sync(powerkeydev);
+				}
+			}
+
+		if(peklong)
+		{
+			printk("press long\n");
+			axp_writes(charger->master,POWER19_INTSTS1,7,w);
+
+			input_report_key(powerkeydev, KEY_POWER, 1);
+			input_sync(powerkeydev);
+			long_cnt = 2;
+			//msleep(100);
+			//input_report_key(powerkeydev, KEY_POWER, 0);
+			//input_sync(powerkeydev);
+		}
+
+		if(pekshort)
+		{
+			printk("press short\n");
+			axp_writes(charger->master,POWER19_INTSTS1,7,w);
+
+			input_report_key(powerkeydev, KEY_POWER, 1);
+			input_sync(powerkeydev);
+			msleep(100);
+			input_report_key(powerkeydev, KEY_POWER, 0);
+			input_sync(powerkeydev);
+		}
+
+		if(charger->bat_current_direction && charger->is_on \
+			&& (charger->ibat > 100) && (!Rdc_Flag)){
+            if(Pre_Rdc_Flag){
+                Bat_Rdc += axp_get_rdc(charger);
+                Bat_Rdc /= 2;
+            }
+            else{
+                Bat_Rdc = axp_get_rdc(charger);
+            }
+
+            Rdc_Flag = 1;
+
+		}
+		charger->pbat = charger->ibat * charger->vbat;
+		Total_Power -= Bat_Power_Buffer[m];
+		Bat_Power_Buffer[m] = charger->pbat;
+		Total_Power += Bat_Power_Buffer[m];
+		m++;
+		if(m == AXP19_AVER_MAX)
+		{
+			m = 0;
+		}
+        charger->pbat = (int)Total_Power / AXP19_AVER_MAX;
+		Bat_Vol = (uint16_t)charger->vbat;
+        Bat_Ocv_Vol =(uint16_t) axp_bat_vol(charger->ext_valid && charger->bat_current_direction,\
+			(int) Bat_Vol,charger->ibat,Bat_Rdc);//è·åå¼è·¯çµå
+        rt_rest_vol = axp_vol_rate( Bat_Ocv_Vol);
+		rt_charge_status = (charger->ext_valid << 2 )| (charger->bat_det << 1) | \
+			(charger->is_on);
+		Total_Cap -= Bat_Cap_Buffer[i];
+		Bat_Cap_Buffer[i] = rt_rest_vol;
+		Total_Cap += Bat_Cap_Buffer[i];
+		i++;
+		if(i == AXP19_VOL_MAX){
+		    i = 0;
+		}
+		if(j < AXP19_VOL_MAX){
+			j++;
+		}
+		ocv_rest_vol = Total_Cap / j;
+
+		if((j == AXP19_VOL_MAX) && (charger->bat_det == 1)){
+            Cur_CoulombCounter = axp_get_coulomb(charger);
+			 if((ocv_rest_vol < 10) && Rdc_Flag && (rt_charge_status == 7) \
+			 	&& (!Cou_Correction_Flag))    {
+                 Cou_Correction_Flag = 0x01;
+                 axp_set_bits(charger->master,AXP19_COULOMB_CONTROL,AXP19_COULOMB_CLEAR);
+                 Pre_rest_cap = ocv_rest_vol;
+                 Pre_Cur_Cal_rest_cap = ocv_rest_vol;
+             }
+             if(Cou_Correction_Flag && (rt_charge_status == 6) && (ocv_rest_vol == 100)){
+                 charger->battery_info->energy_full_design = Cur_CoulombCounter;
+                 charger->battery_info->energy_full_design *= 100;
+                 charger->battery_info->energy_full_design /= (100 - (int)Pre_Cur_Cal_rest_cap);
+                 temp_value[0] = ((((charger->battery_info->energy_full_design /5) & 0xff0) | 0x800) >> 4);
+                 temp_value[1] &= 0x0f;
+                 temp_value[1] |= (((charger->battery_info->energy_full_design /5) & 0x0f) << 4) ;
+                 axp_write(charger->master,AXP19_DATA_BUFFER1,temp_value[0]);
+                 axp_write(charger->master,AXP19_DATA_BUFFER1,temp_value[1] );
+                 Cou_Correction_Flag = 0x00;
+                 Real_Cou_Flag = 0x01;
+            }
+			if(coulomb_flag){  //åçµ
+                cou_rest_vol = (Pre_rest_cap + (100 * Cur_CoulombCounter /
+					charger->battery_info->energy_full_design));
+            }
+            else{//æ¾çµ
+                if(Pre_rest_cap < (100 * Cur_CoulombCounter /
+					charger->battery_info->energy_full_design)){
+                    cou_rest_vol = 0;
+                }
+                else{
+                    cou_rest_vol = ((int)Pre_rest_cap - (100 * Cur_CoulombCounter /
+						charger->battery_info->energy_full_design));
+                }
+            }
+			if(((ocv_rest_vol > Pre_ocv_rest_cap) && (rt_charge_status < 0x04))
+				|| (ocv_rest_vol < (Pre_ocv_rest_cap - 2))){//æ¾çµæ¶çµéä¸è½å¢å 
+                ocv_rest_vol = (int)Pre_ocv_rest_cap;
+            }
+            else if(((ocv_rest_vol < Pre_ocv_rest_cap) && (rt_charge_status > 0x03))
+				||(ocv_rest_vol > (Pre_ocv_rest_cap + 2))){//åçµæ¶çµéä¸è½åå°
+                ocv_rest_vol = (int)Pre_ocv_rest_cap;
+            }
+            Pre_ocv_rest_cap = (uint8_t)ocv_rest_vol;
+
+			if(cou_rest_vol > 100){
+                if(Real_Cou_Flag){
+                    charger->rest_vol = ocv_rest_vol  + (3 * 100);   //å¦ææ¾ç»æ ¡æ­£è¿çµæ± å®¹éï¼ååºä»çµéæ¯ä¾å 3/4ï¼å¦å1/4
+                }
+                else{
+                    charger->rest_vol = 2 * ocv_rest_vol  + 200;
+                }
+            }
+            else{
+                if(Real_Cou_Flag)
+                    charger->rest_vol = ocv_rest_vol  + (3 * cou_rest_vol);
+                else
+                    charger->rest_vol = 2 * ocv_rest_vol  + 2 * cou_rest_vol;
+            }
+
+            charger->rest_vol /= 4;
+		/*when charging , capacity is less than 100 */
+		if (charger->rest_vol >= 99 && charger->is_on == 1 )
+			charger->rest_vol = 99;
+
+
+		if(((charger->rest_vol > pre_rest_vol) && (rt_charge_status < 0x04))){//æ¾çµæ¶çµéä¸è½å¢å 
+			charger->rest_vol = pre_rest_vol;
+		}
+		else if((charger->rest_vol < pre_rest_vol) && (rt_charge_status > 0x03)){//åçµæ¶çµéä¸è½åå°
+			charger->rest_vol = pre_rest_vol;
+		}
+            charger->rest_time = axp_cal_resttime(charger,rt_charge_status,Bat_Ocv_Vol,Bat_Rdc);
+
+            Total_Time -= Bat_Time_Buffer[k];
+            Bat_Time_Buffer[k] = charger->rest_time;
+            Total_Time += Bat_Time_Buffer[k];
+            k++;
+            if(k == AXP19_TIME_MAX){
+                k = 0;
+            }
+            charger->rest_time = Total_Time / AXP19_TIME_MAX;
+		}
+		else if(j < AXP19_VOL_MAX){
+			charger->rest_vol = ocv_rest_vol;
+            Pre_rest_cap = ocv_rest_vol;
+            Pre_ocv_rest_cap = ocv_rest_vol;
+			//pre_rest_vol = charger->rest_vol;
+			cou_rest_vol = 0;
+            if(j == AXP19_VOL_MAX - 1){
+            	axp_set_bits(charger->master,AXP19_COULOMB_CONTROL,0xA0);
+            }
+        }
+	/* if battery volume changed, inform uevent */
+        if(charger->rest_vol - pre_rest_vol){
+			printk("battery vol change: %d, %d \n", pre_rest_vol, charger->rest_vol);
+			pre_rest_vol = charger->rest_vol;
+			power_supply_changed(&charger->batt);
+        }
+		ssleep(1);
+
+    }
+	return 0;
+}
+
+static ssize_t chgen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+	charger->chgen  = val >> 7;
+	return sprintf(buf, "%d\n",charger->chgen);
+}
+
+static ssize_t chgen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var){
+		charger->chgen = 1;
+		axp_set_bits(charger->master,AXP19_CHARGE_CONTROL1,0x80);
+	}
+	else{
+		charger->chgen = 0;
+		axp_clr_bits(charger->master,AXP19_CHARGE_CONTROL1,0x80);
+	}
+	return count;
+}
+
+static ssize_t chgmicrovol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+	switch ((val >> 5) & 0x03){
+		case 0: charger->chgvol = 4100;break;
+		case 1: charger->chgvol = 4150;break;
+		case 2: charger->chgvol = 4200;break;
+		case 3: charger->chgvol = 4360;break;
+	}
+	return sprintf(buf, "%d\n",charger->chgvol*1000);
+}
+
+static ssize_t chgmicrovol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t tmp, val;
+	var = simple_strtoul(buf, NULL, 10);
+	switch(var){
+		case 4100000:tmp = 0;break;
+		case 4150000:tmp = 1;break;
+		case 4200000:tmp = 2;break;
+		case 4360000:tmp = 3;break;
+		default:  tmp = 4;break;
+	}
+	if(tmp < 4){
+		charger->chgvol = var/1000;
+		axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+		val &= 0x9F;
+		val |= tmp << 5;
+		axp_write(charger->master, AXP19_CHARGE_CONTROL1, val);
+	}
+	return count;
+}
+
+static ssize_t chgintmicrocur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+	charger->chgcur = (val & 0x0F) * 100 +100;
+	return sprintf(buf, "%d\n",charger->chgcur*1000);
+}
+
+static ssize_t chgintmicrocur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 100000 && var <= 1600000){
+		val = (var -100000)/100000;
+		charger->chgcur = val *100 + 100;
+		axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+		val &= 0xF0;
+		val |= val;
+		axp_write(charger->master, AXP19_CHARGE_CONTROL1, val);
+	}
+	return count;
+}
+
+static ssize_t chgendcur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_CHARGE_CONTROL1, &val);
+  	charger->chgend = ((val >> 4)& 0x01)? 15 : 10;
+	return sprintf(buf, "%d\n",charger->chgend);
+}
+
+static ssize_t chgendcur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var == 10 ){
+		charger->chgend = var;
+		axp_clr_bits(charger->master ,AXP19_CHARGE_CONTROL1,0x10);
+	}
+	else if (var == 15){
+		charger->chgend = var;
+		axp_set_bits(charger->master ,AXP19_CHARGE_CONTROL1,0x10);
+
+	}
+	return count;
+}
+
+static ssize_t chgpretimemin_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+  axp_read(charger->master,AXP19_CHARGE_CONTROL2, &val);
+ 	charger->chgpretime = (val >> 6) * 10 +30;
+	return sprintf(buf, "%d\n",charger->chgpretime);
+}
+
+static ssize_t chgpretimemin_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t tmp,val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 30 && var <= 60){
+		tmp = (var - 30)/10;
+		charger->chgpretime = tmp * 10 + 30;
+		axp_read(charger->master,AXP19_CHARGE_CONTROL2,&val);
+		val &= 0x3F;
+		val |= (tmp << 6);
+		axp_write(charger->master,AXP19_CHARGE_CONTROL2,val);
+	}
+	return count;
+}
+
+static ssize_t chgcsttimemin_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_CONTROL2, &val);
+	charger->chgcsttime = (val & 0x03) *60 + 420;
+	return sprintf(buf, "%d\n",charger->chgcsttime);
+}
+
+static ssize_t chgcsttimemin_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t tmp,val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 420 && var <= 600){
+		tmp = (var - 420)/60;
+		charger->chgcsttime = tmp * 60 + 420;
+		axp_read(charger->master,AXP19_CHARGE_CONTROL2,&val);
+		val &= 0xFC;
+		val |= tmp;
+		axp_write(charger->master,AXP19_CHARGE_CONTROL2,val);
+	}
+	return count;
+}
+
+
+static ssize_t chgextmicrocur_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_CONTROL2, &val);
+	charger->chgextcur = ((val >> 3) & 0x07) * 100000 + 300000;
+	return sprintf(buf, "%d\n",charger->chgextcur);
+}
+
+static ssize_t chgextmicrocur_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 300000 && var <= 1000000){
+		val = (var -300000)/100000;
+		charger->chgcur = val *100000 + 300000;
+		axp_read(charger->master, AXP19_CHARGE_CONTROL2, &val);
+		val &= 0xC7;
+		val |= (val << 3);
+		axp_write(charger->master, AXP19_CHARGE_CONTROL2, val);
+	}
+	return count;
+}
+
+static ssize_t chgexten_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_CONTROL2, &val);
+	charger->chgexten  = (val >> 2) & 0x01;
+	return sprintf(buf, "%d\n",charger->chgexten);
+
+}
+
+static ssize_t chgexten_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var){
+		charger->chgexten = 1;
+		axp_set_bits(charger->master,AXP19_CHARGE_CONTROL2,0x04);
+	}
+	else{
+		charger->chgexten = 0;
+		axp_clr_bits(charger->master,AXP19_CHARGE_CONTROL2,0x04);
+	}
+	return count;
+}
+
+static ssize_t adcfreq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master, AXP19_ADC_CONTROL3, &val);
+	switch ((val >> 6) & 0x03){
+		 case 0: charger->sample_time = 25;break;
+		 case 1: charger->sample_time = 50;break;
+		 case 2: charger->sample_time = 100;break;
+		 case 3: charger->sample_time = 200;break;
+		 default:break;
+	}
+	return sprintf(buf, "%d\n",charger->sample_time);
+}
+
+static ssize_t adcfreq_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val;
+	var = simple_strtoul(buf, NULL, 10);
+	axp_read(charger->master, AXP19_ADC_CONTROL3, &val);
+	switch (var/25){
+		case 1: val &= ~(3 << 6);charger->sample_time = 25;break;
+		case 2: val &= ~(3 << 6);val |= 1 << 6;charger->sample_time = 50;break;
+		case 4: val &= ~(3 << 6);val |= 2 << 6;charger->sample_time = 100;break;
+		case 8: val |= 3 << 6;charger->sample_time = 200;break;
+		default: break;
+		}
+	axp_write(charger->master, AXP19_ADC_CONTROL3, val);
+	return count;
+}
+
+
+static ssize_t vholden_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_VBUS, &val);
+	val = (val>>6) & 0x01;
+	return sprintf(buf, "%d\n",val);
+}
+
+static ssize_t vholden_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var)
+		axp_set_bits(charger->master, AXP19_CHARGE_VBUS, 0x40);
+	else
+		axp_clr_bits(charger->master, AXP19_CHARGE_VBUS, 0x40);
+
+	return count;
+}
+
+static ssize_t vhold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	int vhold;
+	axp_read(charger->master,AXP19_CHARGE_VBUS, &val);
+ 	vhold = ((val >> 3) & 0x07) * 100000 + 4000000;
+	return sprintf(buf, "%d\n",vhold);
+}
+
+static ssize_t vhold_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	uint8_t val,tmp;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var >= 4000000 && var <=4700000){
+		tmp = (var - 4000000)/100000;
+		//printk("tmp = 0x%x\n",tmp);
+		axp_read(charger->master, AXP19_CHARGE_VBUS,&val);
+		val &= 0xC7;
+		val |= tmp << 3;
+		//printk("val = 0x%x\n",val);
+		axp_write(charger->master, AXP19_CHARGE_VBUS,val);
+	}
+	return count;
+}
+
+static ssize_t iholden_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	axp_read(charger->master,AXP19_CHARGE_VBUS, &val);
+	return sprintf(buf, "%d\n",(val >> 1) & 0x01);
+}
+
+static ssize_t iholden_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var)
+		axp_set_bits(charger->master, AXP19_CHARGE_VBUS, 0x02);
+	else
+		axp_clr_bits(charger->master, AXP19_CHARGE_VBUS, 0x02);
+
+	return count;
+}
+
+static ssize_t ihold_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	uint8_t val;
+	int vhold;
+	axp_read(charger->master,AXP19_CHARGE_VBUS, &val);
+ 	vhold = ((val) & 0x01)? 500000: 100000;
+	return sprintf(buf, "%d\n",vhold);
+}
+
+static ssize_t ihold_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct axp_charger *charger = dev_get_drvdata(dev);
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var == 500000)
+		axp_set_bits(charger->master, AXP19_CHARGE_VBUS, 0x01);
+	else if (var == 100000)
+		axp_clr_bits(charger->master, AXP19_CHARGE_VBUS, 0x01);
+	else
+		;
+	return count;
+}
+
+static struct device_attribute axp_charger_attrs[] = {
+	AXP_CHG_ATTR(chgen),
+	AXP_CHG_ATTR(chgmicrovol),
+	AXP_CHG_ATTR(chgintmicrocur),
+	AXP_CHG_ATTR(chgendcur),
+	AXP_CHG_ATTR(chgpretimemin),
+    AXP_CHG_ATTR(chgcsttimemin),
+	AXP_CHG_ATTR(chgextmicrocur),
+	AXP_CHG_ATTR(chgexten),
+	AXP_CHG_ATTR(adcfreq),
+	AXP_CHG_ATTR(vholden),
+	AXP_CHG_ATTR(vhold),
+	AXP_CHG_ATTR(iholden),
+	AXP_CHG_ATTR(ihold),
+};
+
+int axp_charger_create_attrs(struct power_supply *psy)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_charger_attrs); j++) {
+		ret = device_create_file(psy->dev,
+			    &axp_charger_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+
+sysfs_failed:
+	while (j--)
+		device_remove_file(psy->dev,
+			   &axp_charger_attrs[j]);
+succeed:
+	return ret;
+}
+/*
+static void axp_charging_monitor(struct work_struct *work)
+{
+	struct axp_charger *charger;
+
+	charger = container_of(work, struct axp_charger, work.work);
+
+	axp_charger_update_state(charger);
+	axp_charger_update(charger);
+
+
+	schedule_delayed_work(&charger->work, charger->interval);
+}
+*/
+static int axp_battery_probe(struct platform_device *pdev)
+{
+	struct axp_charger *charger;
+	struct axp_supply_init_data *pdata = pdev->dev.platform_data;
+	int ret;
+
+
+	powerkeydev = input_allocate_device();
+	if (!powerkeydev) {
+		kfree(powerkeydev);
+		return -ENODEV;
+	}
+
+
+	powerkeydev->name = pdev->name;
+	powerkeydev->phys = "m1kbd/input2";
+	powerkeydev->id.bustype = BUS_HOST;
+	powerkeydev->id.vendor = 0x0001;
+	powerkeydev->id.product = 0x0001;
+	powerkeydev->id.version = 0x0100;
+	powerkeydev->open = NULL;
+	powerkeydev->close = NULL;
+	powerkeydev->dev.parent = &pdev->dev;
+
+	set_bit(EV_KEY, powerkeydev->evbit);
+	set_bit(EV_REL, powerkeydev->evbit);
+	//set_bit(EV_REP, powerkeydev->evbit);
+	set_bit(KEY_POWER, powerkeydev->keybit);
+
+	ret = input_register_device(powerkeydev);
+	if(ret) {
+		printk("Unable to Register the power key\n");
+		}
+
+	if (pdata == NULL)
+		return -EINVAL;
+
+	if (pdata->chgcur > 1600 ||
+	    pdata->chgvol < 4100 ||
+	    pdata->chgvol > 4360){
+            printk("charger milliamp is too high or target voltage is over range\n");
+		    return -EINVAL;
+		}
+
+	if (pdata->chgpretime < 30 || pdata->chgpretime >60 ||
+		pdata->chgcsttime < 420 || pdata->chgcsttime > 600){
+            printk("prechaging time or constant current charging time is over range\n");
+		    return -EINVAL;
+		}
+
+	charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+	if (charger == NULL)
+		return -ENOMEM;
+
+	charger->master = pdev->dev.parent;
+
+	charger->chgcur      = pdata->chgcur;
+	charger->chgvol     = pdata->chgvol;
+	charger->chgend           = pdata->chgend; //axp199
+	charger->sample_time          = pdata->sample_time;
+	charger->chgen                   = pdata->chgen;
+	charger->chgpretime      = pdata->chgpretime;
+	charger->chgcsttime = pdata->chgcsttime;
+	charger->battery_info         = pdata->battery_info;
+	charger->battery_low          = pdata->battery_low;
+	charger->battery_critical     = pdata->battery_critical;
+
+	ret = axp_battery_first_init(charger);
+	if (ret)
+		goto err_charger_init;
+
+	charger->nb.notifier_call = axp_battery_event;
+	ret = axp_register_notifier(charger->master, &charger->nb, AXP19_NOTIFIER_ON);
+	if (ret)
+		goto err_notifier;
+
+	axp_battery_setup_psy(charger);
+	ret = power_supply_register(&pdev->dev, &charger->batt);
+	if (ret)
+		goto err_ps_register;
+
+	ret = power_supply_register(&pdev->dev, &charger->ac);
+	if (ret){
+		power_supply_unregister(&charger->batt);
+		goto err_ps_register;
+	}
+	ret = power_supply_register(&pdev->dev, &charger->usb);
+	if (ret){
+		power_supply_unregister(&charger->ac);
+		power_supply_unregister(&charger->batt);
+		goto err_ps_register;
+	}
+
+	ret = axp_charger_create_attrs(&charger->batt);
+	if(ret){
+		return ret;
+	}
+
+
+	platform_set_drvdata(pdev, charger);
+    main_task = kthread_run(axp_main_task,charger,"kaxp19");
+	if(IS_ERR(main_task)){
+
+      printk("Unable to start main task.\n");
+
+      ret = PTR_ERR(main_task);
+
+      main_task = NULL;
+
+      return ret;
+
+    }
+/*
+		charger->interval = msecs_to_jiffies(1 * 1000);
+
+		INIT_DELAYED_WORK(&charger->work, axp_charging_monitor);
+		schedule_delayed_work(&charger->work, charger->interval);
+*/
+    return ret;
+
+
+err_ps_register:
+	axp_unregister_notifier(charger->master, &charger->nb, AXP19_NOTIFIER_ON);
+
+err_notifier:
+	cancel_delayed_work(&charger->work);
+
+err_charger_init:
+	kfree(charger);
+	input_unregister_device(powerkeydev);
+	kfree(powerkeydev);
+
+	return ret;
+}
+
+static int axp_battery_remove(struct platform_device *dev)
+{
+	struct axp_charger *charger = platform_get_drvdata(dev);
+
+	if(main_task){
+
+                kthread_stop(main_task);
+
+                main_task = NULL;
+
+    }
+
+	axp_unregister_notifier(charger->master, &charger->nb, AXP19_NOTIFIER_ON);
+	cancel_delayed_work(&charger->work);
+	power_supply_unregister(&charger->usb);
+	power_supply_unregister(&charger->ac);
+	power_supply_unregister(&charger->batt);
+
+	kfree(charger);
+	input_unregister_device(powerkeydev);
+	kfree(powerkeydev);
+
+	return 0;
+}
+
+static struct platform_driver axp_battery_driver = {
+	.driver	= {
+		.name	= "axp19-supplyer",
+		.owner	= THIS_MODULE,
+	},
+	.probe = axp_battery_probe,
+	.remove = axp_battery_remove,
+};
+
+static int axp_battery_init(void)
+{
+	return platform_driver_register(&axp_battery_driver);
+}
+
+static void axp_battery_exit(void)
+{
+	platform_driver_unregister(&axp_battery_driver);
+}
+
+module_init(axp_battery_init);
+module_exit(axp_battery_exit);
+
+MODULE_DESCRIPTION("AXP19 battery charger driver");
+MODULE_AUTHOR("Donglu Zhang, Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/axp20-board.c b/drivers/power/axp_power/axp20-board.c
new file mode 100644
index 0000000..6bc78c7
--- /dev/null
+++ b/drivers/power/axp_power/axp20-board.c
@@ -0,0 +1,704 @@
+/*
+ * drivers/power/axp_power/axp20-board.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/apm_bios.h>
+#include <linux/apm-emulation.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-cfg.h"
+#include <plat/sys_config.h>
+
+#define AXP152_I2C_ADDR 48
+
+int pmu_used;
+int pmu_twi_id;
+int pmu_irq_id;
+int pmu_twi_addr;
+int pmu_battery_rdc;
+int pmu_battery_cap;
+int pmu_init_chgcur;
+int pmu_suspend_chgcur;
+int pmu_resume_chgcur;
+int pmu_shutdown_chgcur;
+int pmu_init_chgvol;
+int pmu_init_chgend_rate;
+int pmu_init_chg_enabled;
+int pmu_init_adc_freq;
+int pmu_init_adc_freqc;
+int pmu_init_chg_pretime;
+int pmu_init_chg_csttime;
+
+int pmu_bat_para1;
+int pmu_bat_para2;
+int pmu_bat_para3;
+int pmu_bat_para4;
+int pmu_bat_para5;
+int pmu_bat_para6;
+int pmu_bat_para7;
+int pmu_bat_para8;
+int pmu_bat_para9;
+int pmu_bat_para10;
+int pmu_bat_para11;
+int pmu_bat_para12;
+int pmu_bat_para13;
+int pmu_bat_para14;
+int pmu_bat_para15;
+int pmu_bat_para16;
+
+int pmu_usbvol_limit;
+int pmu_usbvol;
+int pmu_usbcur_limit;
+int pmu_usbcur;
+
+int pmu_pwroff_vol;
+int pmu_pwron_vol;
+
+int dcdc2_vol;
+int dcdc3_vol;
+int ldo2_vol;
+int ldo3_vol;
+int ldo4_vol;
+
+int pmu_pekoff_time;
+int pmu_pekoff_en;
+int pmu_peklong_time;
+int pmu_pekon_time;
+int pmu_pwrok_time;
+int pmu_pwrnoe_time;
+int pmu_intotp_en;
+
+/* Reverse engineered partly from Platformx drivers */
+enum axp_regls{
+
+	vcc_ldo1,
+	vcc_ldo2,
+	vcc_ldo3,
+	vcc_ldo4,
+	vcc_ldo5,
+
+	vcc_buck2,
+	vcc_buck3,
+	vcc_ldoio0,
+};
+
+/* The values of the various regulator constraints are obviously dependent
+ * on exactly what is wired to each ldo.  Unfortunately this information is
+ * not generally available.  More information has been requested from Xbow
+ * but as of yet they haven't been forthcoming.
+ *
+ * Some of these are clearly Stargate 2 related (no way of plugging
+ * in an lcd on the IM2 for example!).
+ */
+
+static struct regulator_consumer_supply ldo1_data[] = {
+		{
+			.supply = "axp20_rtc",
+		},
+	};
+
+
+static struct regulator_consumer_supply ldo2_data[] = {
+		{
+			.supply = "axp20_analog/fm",
+		},
+	};
+
+static struct regulator_consumer_supply ldo3_data[] = {
+		{
+			.supply = "axp20_pll",
+		},
+	};
+
+static struct regulator_consumer_supply ldo4_data[] = {
+		{
+			.supply = "axp20_hdmi",
+		},
+	};
+
+static struct regulator_consumer_supply ldoio0_data[] = {
+		{
+			.supply = "axp20_mic",
+		},
+	};
+
+
+static struct regulator_consumer_supply buck2_data[] = {
+		{
+			.supply = "Vcore",
+		},
+	};
+
+static struct regulator_consumer_supply buck3_data[] = {
+		{
+			.supply = "axp20_ddr",
+		},
+	};
+
+
+
+static struct regulator_init_data axp_regl_init_data[] = {
+	[vcc_ldo1] = {
+		.constraints = { /* board default 1.25V */
+			.name = "axp20_ldo1",
+			.min_uV =  AXP20LDO1 * 1000,
+			.max_uV =  AXP20LDO1 * 1000,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_data),
+		.consumer_supplies = ldo1_data,
+	},
+	[vcc_ldo2] = {
+		.constraints = { /* board default 3.0V */
+			.name = "axp20_ldo2",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo2_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_data),
+		.consumer_supplies = ldo2_data,
+	},
+	[vcc_ldo3] = {
+		.constraints = {/* default is 1.8V */
+			.name = "axp20_ldo3",
+			.min_uV =  700 * 1000,
+			.max_uV =  3500* 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo3_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_data),
+		.consumer_supplies = ldo3_data,
+	},
+	[vcc_ldo4] = {
+		.constraints = {
+			/* board default is 3.3V */
+			.name = "axp20_ldo4",
+			.min_uV = 1250000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = ldo4_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_data),
+		.consumer_supplies = ldo4_data,
+	},
+	[vcc_buck2] = {
+		.constraints = { /* default 1.24V */
+			.name = "axp20_buck2",
+			.min_uV = 700 * 1000,
+			.max_uV = 2275 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = dcdc2_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck2_data),
+		.consumer_supplies = buck2_data,
+	},
+	[vcc_buck3] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp20_buck3",
+			.min_uV = 700 * 1000,
+			.max_uV = 3500 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+			.initial_state = PM_SUSPEND_STANDBY,
+			.state_standby = {
+				//.uV = dcdc3_vol * 1000,
+				.enabled = 1,
+			}
+		},
+		.num_consumer_supplies = ARRAY_SIZE(buck3_data),
+		.consumer_supplies = buck3_data,
+	},
+	[vcc_ldoio0] = {
+		.constraints = { /* default 2.5V */
+			.name = "axp20_ldoio0",
+			.min_uV = 1800 * 1000,
+			.max_uV = 3300 * 1000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldoio0_data),
+		.consumer_supplies = ldoio0_data,
+	},
+};
+
+static struct axp_funcdev_info axp_regldevs[] = {
+	{
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO1,
+		.platform_data = &axp_regl_init_data[vcc_ldo1],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO2,
+		.platform_data = &axp_regl_init_data[vcc_ldo2],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO3,
+		.platform_data = &axp_regl_init_data[vcc_ldo3],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDO4,
+		.platform_data = &axp_regl_init_data[vcc_ldo4],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_BUCK2,
+		.platform_data = &axp_regl_init_data[vcc_buck2],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_BUCK3,
+		.platform_data = &axp_regl_init_data[vcc_buck3],
+	}, {
+		.name = "axp20-regulator",
+		.id = AXP20_ID_LDOIO0,
+		.platform_data = &axp_regl_init_data[vcc_ldoio0],
+	},
+};
+
+static struct power_supply_info battery_data ={
+		.name ="PTI PL336078",
+		.technology = POWER_SUPPLY_TECHNOLOGY_LION,
+		//.voltage_max_design = pmu_init_chgvol,
+		//.voltage_min_design = pmu_pwroff_vol,
+		//.energy_full_design = pmu_battery_cap,
+		.use_for_apm = 1,
+};
+
+
+static struct axp_supply_init_data axp_sply_init_data = {
+	.battery_info = &battery_data,
+	//.chgcur = pmu_init_chgcur,
+	//.chgvol = pmu_init_chgvol,
+	//.chgend = pmu_init_chgend_rate,
+	//.chgen = pmu_init_chg_enabled,
+	//.sample_time = pmu_init_adc_freq,
+	//.chgpretime = pmu_init_chg_pretime,
+	//.chgcsttime = pmu_init_chg_csttime,
+};
+
+static struct axp_funcdev_info axp_splydev[]={
+   	{
+   		.name = "axp20-supplyer",
+			.id = AXP20_ID_SUPPLY,
+      .platform_data = &axp_sply_init_data,
+    },
+};
+
+static struct axp_funcdev_info axp_gpiodev[]={
+   	{   .name = "axp20-gpio",
+   		.id = AXP20_ID_GPIO,
+    },
+};
+
+static struct axp_platform_data axp_pdata = {
+	.num_regl_devs = ARRAY_SIZE(axp_regldevs),
+	.num_sply_devs = ARRAY_SIZE(axp_splydev),
+	.num_gpio_devs = ARRAY_SIZE(axp_gpiodev),
+	.regl_devs = axp_regldevs,
+	.sply_devs = axp_splydev,
+	.gpio_devs = axp_gpiodev,
+	.gpio_base = 0,
+};
+
+static struct i2c_board_info __initdata axp_mfd_i2c_board_info[] = {
+	{
+		.type = "axp20_mfd",
+		//.addr = pmu_twi_addr,
+		.platform_data = &axp_pdata,
+		//.irq = pmu_irq_id,
+	},
+};
+
+static int __init axp_board_init(void)
+{
+		int ret;
+    ret = script_parser_fetch("pmu_para", "pmu_used", &pmu_used, sizeof(int));
+    if (ret)
+    {
+        printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        return -1;
+    }
+    if (pmu_used)
+    {
+        ret = script_parser_fetch("pmu_para", "pmu_twi_id", &pmu_twi_id, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_twi_id = AXP20_I2CBUS;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_irq_id", &pmu_irq_id, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_irq_id = AXP20_IRQNO;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_twi_addr", &pmu_twi_addr, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_twi_addr = AXP20_ADDR;
+        }
+	if (pmu_twi_addr == AXP152_I2C_ADDR)
+		return -ENODEV; /* AXP152 not AXP20, do not load */
+
+        ret = script_parser_fetch("pmu_para", "pmu_battery_rdc", &pmu_battery_rdc, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_battery_rdc = BATRDC;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_battery_cap", &pmu_battery_cap, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_battery_cap = BATTERYCAP;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_chgcur", &pmu_init_chgcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chgcur = INTCHGCUR / 1000;
+        }
+        pmu_init_chgcur = pmu_init_chgcur * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_suspend_chgcur", &pmu_suspend_chgcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_suspend_chgcur = SUSCHGCUR / 1000;
+        }
+        pmu_suspend_chgcur = pmu_suspend_chgcur * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_resume_chgcur", &pmu_resume_chgcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_resume_chgcur = RESCHGCUR / 1000;
+        }
+        pmu_resume_chgcur = pmu_resume_chgcur * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_shutdown_chgcur", &pmu_shutdown_chgcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_shutdown_chgcur = CLSCHGCUR / 1000;
+        }
+        pmu_shutdown_chgcur = pmu_shutdown_chgcur * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_init_chgvol", &pmu_init_chgvol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chgvol = INTCHGVOL / 1000;
+        }
+        pmu_init_chgvol = pmu_init_chgvol * 1000;
+        ret = script_parser_fetch("pmu_para", "pmu_init_chgend_rate", &pmu_init_chgend_rate, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chgend_rate = INTCHGENDRATE;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_chg_enabled", &pmu_init_chg_enabled, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chg_enabled = INTCHGENABLED;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_adc_freq", &pmu_init_adc_freq, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_adc_freq = INTADCFREQ;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_adc_freqc", &pmu_init_adc_freqc, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_adc_freq = INTADCFREQC;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_chg_pretime", &pmu_init_chg_pretime, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chg_pretime = INTCHGPRETIME;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_init_chg_csttime", &pmu_init_chg_csttime, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_init_chg_csttime = INTCHGCSTTIME;
+        }
+
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para1", &pmu_bat_para1, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para1 = OCVREG0;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para2", &pmu_bat_para2, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para2 = OCVREG1;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para3", &pmu_bat_para3, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para3 = OCVREG2;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para4", &pmu_bat_para4, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para4 = OCVREG3;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para5", &pmu_bat_para5, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para5 = OCVREG4;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para6", &pmu_bat_para6, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para6 = OCVREG5;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para7", &pmu_bat_para7, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para7 = OCVREG6;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para8", &pmu_bat_para8, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para8 = OCVREG7;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para9", &pmu_bat_para9, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para9 = OCVREG8;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para10", &pmu_bat_para10, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para10 = OCVREG9;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para11", &pmu_bat_para11, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para11 = OCVREGA;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para12", &pmu_bat_para12, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para12 = OCVREGB;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para13", &pmu_bat_para13, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para13 = OCVREGC;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para14", &pmu_bat_para14, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para14 = OCVREGD;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para15", &pmu_bat_para15, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para15 = OCVREGE;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_bat_para16", &pmu_bat_para16, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_bat_para16 = OCVREGF;
+        }
+
+        ret = script_parser_fetch("pmu_para", "pmu_usbvol_limit", &pmu_usbvol_limit, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_usbvol_limit = 1;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_usbvol", &pmu_usbvol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_usbvol = 4400;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_usbcur_limit", &pmu_usbcur_limit, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_usbcur_limit = 0;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_usbcur", &pmu_usbcur, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_usbcur = 900;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pwroff_vol", &pmu_pwroff_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pwroff_vol = 3300;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pwron_vol", &pmu_pwron_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pwron_vol = 2900;
+        }
+
+        ret = script_parser_fetch("target", "dcdc2_vol", &dcdc2_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            dcdc2_vol = 1400;
+        }
+        ret = script_parser_fetch("target", "dcdc3_vol", &dcdc3_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            dcdc3_vol = 1250;
+        }
+        ret = script_parser_fetch("target", "ldo2_vol", &ldo2_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            ldo2_vol = 3000;
+        }
+        ret = script_parser_fetch("target", "ldo3_vol", &ldo3_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            ldo3_vol = 2800;
+        }
+        ret = script_parser_fetch("target", "ldo4_vol", &ldo4_vol, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            ldo4_vol = 2800;
+        }
+
+				ret = script_parser_fetch("pmu_para", "pmu_pekoff_time", &pmu_pekoff_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pekoff_time = 6000;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pekoff_en", &pmu_pekoff_en, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pekoff_en   = 1;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_peklong_time", &pmu_peklong_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_peklong_time = 1500;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pwrok_time", &pmu_pwrok_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+           pmu_pwrok_time    = 64;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_pwrnoe_time", &pmu_pwrnoe_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pwrnoe_time = 2000;
+        }
+        ret = script_parser_fetch("pmu_para", "pmu_intotp_en", &pmu_intotp_en, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_intotp_en = 1;
+        }   
+        ret = script_parser_fetch("pmu_para", "pmu_pekon_time", &pmu_pekon_time, sizeof(int));
+        if (ret)
+        {
+            printk("axp driver uning configuration failed(%d)\n", __LINE__);
+            pmu_pekon_time = 1000;
+        }           
+
+        axp_regl_init_data[1].constraints.state_standby.uV = ldo2_vol * 1000;
+        axp_regl_init_data[2].constraints.state_standby.uV = ldo3_vol * 1000;
+        axp_regl_init_data[3].constraints.state_standby.uV = ldo4_vol * 1000;
+        axp_regl_init_data[5].constraints.state_standby.uV = dcdc2_vol * 1000;
+        axp_regl_init_data[6].constraints.state_standby.uV = dcdc3_vol * 1000;
+        battery_data.voltage_max_design = pmu_init_chgvol;
+        battery_data.voltage_min_design = pmu_pwroff_vol;
+        battery_data.energy_full_design = pmu_battery_cap;
+        axp_sply_init_data.chgcur = pmu_init_chgcur;
+        axp_sply_init_data.chgvol = pmu_init_chgvol;
+        axp_sply_init_data.chgend = pmu_init_chgend_rate;
+        axp_sply_init_data.chgen = pmu_init_chg_enabled;
+        axp_sply_init_data.sample_time = pmu_init_adc_freq;
+        axp_sply_init_data.chgpretime = pmu_init_chg_pretime;
+        axp_sply_init_data.chgcsttime = pmu_init_chg_csttime;
+        axp_mfd_i2c_board_info[0].addr = pmu_twi_addr;
+        axp_mfd_i2c_board_info[0].irq = pmu_irq_id;
+
+        return i2c_register_board_info(pmu_twi_id, axp_mfd_i2c_board_info,
+				ARRAY_SIZE(axp_mfd_i2c_board_info));
+    }
+    else
+        return -1;
+
+}
+fs_initcall(axp_board_init);
+
+MODULE_DESCRIPTION("Krosspower axp board");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/power/axp_power/axp20-gpio.c b/drivers/power/axp_power/axp20-gpio.c
new file mode 100644
index 0000000..6c59e64
--- /dev/null
+++ b/drivers/power/axp_power/axp20-gpio.c
@@ -0,0 +1,359 @@
+/*
+ * axp199-gpio.c  --  gpiolib support for Krosspower &axp PMICs
+ *
+ * Copyright 2011 Krosspower Microelectronics PLC.
+ *
+ * Author: Donglu Zhang <>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mfd/core.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/i2c.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include "axp-gpio.h"
+
+struct virtual_gpio_data {
+	struct mutex lock;
+	int gpio;				//gpio number : 0/1/2/...
+	int io;                 //0: input      1: output
+	int value;				//0: low        1: high
+};
+
+int axp_gpio_set_io(int gpio, int io_state)
+{
+	if (!axp) {
+		WARN_ON_ONCE("axp gpio used without AXP");
+		return -ENODEV;
+	}
+
+	if(io_state == 1){
+		switch(gpio)
+		{
+			case 0: return axp_clr_bits(&axp->dev,AXP20_GPIO0_CFG, 0x06);
+			case 1: return axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG, 0x06);
+			case 2: return axp_clr_bits(&axp->dev,AXP20_GPIO2_CFG, 0x06);
+			case 3: return axp_clr_bits(&axp->dev,AXP20_GPIO3_CFG, 0x04);
+			default:return -ENXIO;
+		}
+	}
+	else if(io_state == 0){
+		switch(gpio)
+		{
+			case 0: axp_clr_bits(&axp->dev,AXP20_GPIO0_CFG,0x05);
+					return axp_set_bits(&axp->dev,AXP20_GPIO0_CFG,0x02);
+			case 1: axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG,0x05);
+					return axp_set_bits(&axp->dev,AXP20_GPIO1_CFG,0x02);
+			case 2: axp_clr_bits(&axp->dev,AXP20_GPIO2_CFG,0x05);
+					return axp_set_bits(&axp->dev,AXP20_GPIO2_CFG,0x02);
+			case 3: return axp_set_bits(&axp->dev,AXP20_GPIO3_CFG,0x04);
+			default:return -ENXIO;
+		}
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_set_io);
+
+
+int axp_gpio_get_io(int gpio, int *io_state)
+{
+	uint8_t val;
+
+	if (!axp) {
+		WARN_ON_ONCE("axp gpio used without AXP");
+		return -ENODEV;
+	}
+
+	switch(gpio)
+	{
+		case 0: axp_read(&axp->dev,AXP20_GPIO0_CFG,&val);val &= 0x07;
+				if(val < 0x02)
+					*io_state = 1;
+				else if (val == 0x02)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 1: axp_read(&axp->dev,AXP20_GPIO1_CFG,&val);val &= 0x07;
+				if(val < 0x02)
+					*io_state = 1;
+				else if (val == 0x02)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 2: axp_read(&axp->dev,AXP20_GPIO2_CFG,&val);val &= 0x07;
+				if(val == 0x0)
+					*io_state = 1;
+				else if (val == 0x02)
+					*io_state = 0;
+				else
+					return -EIO;
+				break;
+		case 3: axp_read(&axp->dev,AXP20_GPIO3_CFG,&val);val &= 0x04;
+				if(val == 0x0)
+					*io_state = 1;
+				else
+					*io_state = 0;
+				break;
+		default:return -ENXIO;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_get_io);
+
+
+int axp_gpio_set_value(int gpio, int value)
+{
+	int io_state,ret;
+	ret = axp_gpio_get_io(gpio,&io_state);
+	if(ret)
+		return ret;
+	if(io_state){
+		if(value){
+			switch(gpio)
+			{
+				case 0: axp_clr_bits(&axp->dev,AXP20_GPIO0_CFG,0x06);
+						return axp_set_bits(&axp->dev,AXP20_GPIO0_CFG,0x01);
+				case 1: axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG,0x06);
+						return axp_set_bits(&axp->dev,AXP20_GPIO1_CFG,0x01);
+				case 2: return axp_set_bits(&axp->dev,AXP20_GPIO2_CFG,0x01);
+				case 3: return axp_set_bits(&axp->dev,AXP20_GPIO3_CFG,0x02);
+				default:break;
+			}
+		}
+		else{
+			switch(gpio)
+			{
+				case 0: return axp_clr_bits(&axp->dev,AXP20_GPIO0_CFG,0x03);
+				case 1: return axp_clr_bits(&axp->dev,AXP20_GPIO1_CFG,0x03);
+				case 2: return axp_clr_bits(&axp->dev,AXP20_GPIO2_CFG,0x03);
+				case 3: return axp_clr_bits(&axp->dev,AXP20_GPIO3_CFG,0x02);
+				default:break;
+			}
+		}
+		return -ENXIO;
+	}
+	return -ENXIO;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_set_value);
+
+
+int axp_gpio_get_value(int gpio, int *value)
+{
+	int io_state;
+	int ret;
+	uint8_t val;
+	ret = axp_gpio_get_io(gpio,&io_state);
+	if(ret)
+		return ret;
+	if(io_state){
+		switch(gpio)
+		{
+			case 0:ret = axp_read(&axp->dev,AXP20_GPIO0_CFG,&val);*value = val & 0x01;break;
+			case 1:ret =axp_read(&axp->dev,AXP20_GPIO1_CFG,&val);*value = val & 0x01;break;
+			case 2:ret = axp_read(&axp->dev,AXP20_GPIO2_CFG,&val);*value = val & 0x01;break;
+			case 3:ret = axp_read(&axp->dev,AXP20_GPIO3_CFG,&val);val &= 0x02;*value = val>>1;break;
+			default:return -ENXIO;
+		}
+	}
+	else{
+		switch(gpio)
+		{
+			case 0:ret = axp_read(&axp->dev,AXP20_GPIO012_STATE,&val);val &= 0x10;*value = val>>4;break;
+			case 1:ret = axp_read(&axp->dev,AXP20_GPIO012_STATE,&val);val &= 0x20;*value = val>>5;break;
+			case 2:ret = axp_read(&axp->dev,AXP20_GPIO012_STATE,&val);val &= 0x40;*value = val>>6;break;
+			case 3:ret = axp_read(&axp->dev,AXP20_GPIO3_CFG,&val);*value = val & 0x01;break;
+			default:return -ENXIO;
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(axp_gpio_get_value);
+
+static ssize_t show_gpio(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->gpio);
+}
+
+static ssize_t set_gpio(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	data->gpio = val;
+
+	return count;
+}
+
+static ssize_t show_io(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	int ret;
+	mutex_lock(&data->lock);
+
+	ret = axp_gpio_get_io(data->gpio,&data->io);
+
+	mutex_unlock(&data->lock);
+
+	if(ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", data->io);
+}
+
+static ssize_t set_io(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->io = val;
+	ret = axp_gpio_set_io(data->gpio,data->io);
+
+	mutex_unlock(&data->lock);
+	if(ret)
+		return ret;
+	return count;
+}
+
+
+static ssize_t show_value(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&data->lock);
+
+	ret = axp_gpio_get_value(data->gpio,&data->value);
+
+	mutex_unlock(&data->lock);
+
+	if(ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", data->value);
+}
+
+static ssize_t set_value(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_gpio_data *data = dev_get_drvdata(dev);
+	long val;
+	int ret;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->value = val;
+	ret = axp_gpio_set_value(data->gpio,data->value);
+
+	mutex_unlock(&data->lock);
+
+	if(ret){
+		return ret;
+	}
+
+	return count;
+}
+
+
+static DEVICE_ATTR(gpio,0664, show_gpio, set_gpio);
+static DEVICE_ATTR(io, 0664, show_io, set_io);
+static DEVICE_ATTR(value, 0664, show_value, set_value);
+
+struct device_attribute *attributes[] = {
+	&dev_attr_gpio,
+	&dev_attr_io,
+	&dev_attr_value,
+};
+
+
+static int __devinit axp_gpio_probe(struct platform_device *pdev)
+{
+	//struct axp_mfd_chip *axp_chip = dev_get_drvdata(pdev->dev.parent);
+	struct virtual_gpio_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_gpio_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++) {
+		ret = device_create_file(&pdev->dev, attributes[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(&pdev->dev, attributes[i]);
+	kfree(drvdata);
+	return ret;
+
+return 0;
+}
+
+static int __devexit axp_gpio_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver axp_gpio_driver = {
+	.driver.name	= "axp20-gpio",
+	.driver.owner	= THIS_MODULE,
+	.probe		= axp_gpio_probe,
+	.remove		= __devexit_p(axp_gpio_remove),
+};
+
+static int __init axp_gpio_init(void)
+{
+	return platform_driver_register(&axp_gpio_driver);
+}
+subsys_initcall(axp_gpio_init);
+
+static void __exit axp_gpio_exit(void)
+{
+	platform_driver_unregister(&axp_gpio_driver);
+}
+module_exit(axp_gpio_exit);
+
+MODULE_AUTHOR("Donglu Zhang ");
+MODULE_DESCRIPTION("GPIO interface for AXP PMICs");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:axp-gpio");
diff --git a/drivers/power/axp_power/axp20-mfd.h b/drivers/power/axp_power/axp20-mfd.h
new file mode 100644
index 0000000..1c7a41b
--- /dev/null
+++ b/drivers/power/axp_power/axp20-mfd.h
@@ -0,0 +1,393 @@
+/*
+ * drivers/power/axp_power/axp20-mfd.h
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "axp-rw.h"
+
+
+static int __devinit axp20_init_chip(struct axp_mfd_chip *chip)
+{
+	uint8_t chip_id;
+	uint8_t v[19] = { /* POWER20_INTEN1 */ 0x00,
+		POWER20_INTEN2,  0x00, POWER20_INTEN3,  0x00,
+		POWER20_INTEN4,  0x00, POWER20_INTEN5,  0x00,
+		POWER20_INTSTS1, 0xff, POWER20_INTSTS2, 0xff,
+		POWER20_INTSTS3, 0xff, POWER20_INTSTS4, 0xff,
+		POWER20_INTSTS5, 0xff };
+	int err;
+	/*read chip id*/
+	err =  __axp_read(chip->client, POWER20_IC_TYPE, &chip_id);
+	if (err) {
+	    printk("[AXP20-MFD] try to read chip id failed!\n");
+		return err;
+	}
+
+	/* Mask and clear all IRQs */
+	err =  __axp_writes(chip->client, POWER20_INTEN1, 19, v);
+	if (err) {
+	    printk("[AXP20-MFD] try to clear irq failed!\n");
+		return err;
+	}
+	chip->irqs_enabled = 0;
+
+	dev_info(chip->dev, "AXP (CHIP ID: 0x%02x) detected\n", chip_id);
+	chip->type = AXP20;
+
+	return 0;
+}
+
+static int axp20_disable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[9];
+	int ret;
+
+	chip->irqs_enabled &= ~irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER20_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER20_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	v[5] = POWER20_INTEN4;
+	v[6] = ((chip->irqs_enabled) >> 24) & 0xff;
+	v[7] = POWER20_INTEN5;
+	v[8] = ((chip->irqs_enabled) >> 32) & 0xff;
+	ret =  __axp_writes(chip->client, POWER20_INTEN1, 9, v);
+
+	return ret;
+
+}
+
+static int axp20_enable_irqs(struct axp_mfd_chip *chip, uint64_t irqs)
+{
+	uint8_t v[9];
+	int ret;
+
+	chip->irqs_enabled |=  irqs;
+
+	v[0] = ((chip->irqs_enabled) & 0xff);
+	v[1] = POWER20_INTEN2;
+	v[2] = ((chip->irqs_enabled) >> 8) & 0xff;
+	v[3] = POWER20_INTEN3;
+	v[4] = ((chip->irqs_enabled) >> 16) & 0xff;
+	v[5] = POWER20_INTEN4;
+	v[6] = ((chip->irqs_enabled) >> 24) & 0xff;
+	v[7] = POWER20_INTEN5;
+	v[8] = ((chip->irqs_enabled) >> 32) & 0xff;
+	ret =  __axp_writes(chip->client, POWER20_INTEN1, 9, v);
+
+	return ret;
+}
+
+static int axp20_read_irqs(struct axp_mfd_chip *chip, uint64_t *irqs)
+{
+	uint8_t v[5] = {0, 0, 0, 0, 0};
+	int ret;
+	ret =  __axp_reads(chip->client, POWER20_INTSTS1, 5, v);
+	if (ret < 0)
+		return ret;
+
+	*irqs =(((uint64_t) v[4]) << 32) |(((uint64_t) v[3]) << 24) | (((uint64_t) v[2])<< 16) | (((uint64_t)v[1]) << 8) | ((uint64_t) v[0]);
+	return 0;
+}
+
+
+static ssize_t axp20_offvol_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+	axp_read(dev,POWER20_VOFF_SET,&val);
+	return sprintf(buf,"%d\n",(val & 0x07) * 100 + 2600);
+}
+
+static ssize_t axp20_offvol_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 2600)
+		tmp = 2600;
+	if (tmp > 3300)
+		tmp = 3300;
+
+	axp_read(dev,POWER20_VOFF_SET,&val);
+	val &= 0xf8;
+	val |= ((tmp - 2600) / 100);
+	axp_write(dev,POWER20_VOFF_SET,val);
+	return count;
+}
+
+static ssize_t axp20_noedelay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_OFF_CTL,&val);
+	if( (val & 0x03) == 0)
+		return sprintf(buf,"%d\n",128);
+	else
+		return sprintf(buf,"%d\n",(val & 0x03) * 1000);
+}
+
+static ssize_t axp20_noedelay_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if (tmp < 1000)
+		tmp = 128;
+	if (tmp > 3000)
+		tmp = 3000;
+	axp_read(dev,POWER19_OFF_CTL,&val);
+	val &= 0xfc;
+	val |= ((tmp) / 1000);
+	axp_write(dev,POWER20_OFF_CTL,val);
+	return count;
+}
+
+static ssize_t axp20_pekopen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	int tmp = 0;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	switch(val >> 6){
+		case 0: tmp = 128;break;
+		case 1: tmp = 3000;break;
+		case 2: tmp = 1000;break;
+		case 3: tmp = 2000;break;
+		default:
+			tmp = 0;break;
+	}
+	return sprintf(buf,"%d\n",tmp);
+}
+
+static ssize_t axp20_pekopen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	axp_read(dev,POWER20_PEK_SET,&val);
+	if (tmp < 1000)
+		val &= 0x3f;
+	else if(tmp < 2000){
+		val &= 0x3f;
+		val |= 0x80;
+	}
+	else if(tmp < 3000){
+		val &= 0x3f;
+		val |= 0xc0;
+	}
+	else {
+		val &= 0x3f;
+		val |= 0x40;
+	}
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_peklong_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val = 0;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	return sprintf(buf,"%d\n",((val >> 4) & 0x03) * 500 + 1000);
+}
+
+static ssize_t axp20_peklong_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 1000)
+		tmp = 1000;
+	if(tmp > 2500)
+		tmp = 2500;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	val &= 0xcf;
+	val |= (((tmp - 1000) / 500) << 4);
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_peken_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	return sprintf(buf,"%d\n",((val >> 3) & 0x01));
+}
+
+static ssize_t axp20_peken_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp)
+		tmp = 1;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	val &= 0xf7;
+	val |= (tmp << 3);
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_pekdelay_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_PEK_SET,&val);
+
+	return sprintf(buf,"%d\n",((val >> 2) & 0x01)? 64:8);
+}
+
+static ssize_t axp20_pekdelay_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp <= 8)
+		tmp = 0;
+	else
+		tmp = 1;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	val &= 0xfb;
+	val |= tmp << 2;
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_pekclose_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	return sprintf(buf,"%d\n",((val & 0x03) * 2000) + 4000);
+}
+
+static ssize_t axp20_pekclose_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp < 4000)
+		tmp = 4000;
+	if(tmp > 10000)
+		tmp =10000;
+	tmp = (tmp - 4000) / 2000 ;
+	axp_read(dev,POWER20_PEK_SET,&val);
+	val &= 0xfc;
+	val |= tmp ;
+	axp_write(dev,POWER20_PEK_SET,val);
+	return count;
+}
+
+static ssize_t axp20_ovtemclsen_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,POWER20_HOTOVER_CTL,&val);
+	return sprintf(buf,"%d\n",((val >> 2) & 0x01));
+}
+
+static ssize_t axp20_ovtemclsen_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 10);
+	if(tmp)
+		tmp = 1;
+	axp_read(dev,POWER20_HOTOVER_CTL,&val);
+	val &= 0xfb;
+	val |= tmp << 2 ;
+	axp_write(dev,POWER20_HOTOVER_CTL,val);
+	return count;
+}
+
+static ssize_t axp20_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+    uint8_t val;
+	axp_read(dev,axp_reg_addr,&val);
+	return sprintf(buf,"REG[%x]=%x\n",axp_reg_addr,val);
+}
+
+static ssize_t axp20_reg_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val;
+	tmp = simple_strtoul(buf, NULL, 16);
+	if( tmp < 256 )
+		axp_reg_addr = tmp;
+	else {
+		val = tmp & 0x00FF;
+		axp_reg_addr= (tmp >> 8) & 0x00FF;
+		axp_write(dev,axp_reg_addr, val);
+	}
+	return count;
+}
+
+static ssize_t axp20_regs_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+  uint8_t val[2];
+	axp_reads(dev,axp_reg_addr,2,val);
+	return sprintf(buf,"REG[0x%x]=0x%x,REG[0x%x]=0x%x\n",axp_reg_addr,val[0],axp_reg_addr+1,val[1]);
+}
+
+static ssize_t axp20_regs_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int tmp;
+	uint8_t val[3];
+	tmp = simple_strtoul(buf, NULL, 16);
+	if( tmp < 256 )
+		axp_reg_addr = tmp;
+	else {
+		axp_reg_addr= (tmp >> 16) & 0xFF;
+		val[0] = (tmp >> 8) & 0xFF;
+		val[1] = axp_reg_addr + 1;
+		val[2] = tmp & 0xFF;
+		axp_writes(dev,axp_reg_addr,3,val);
+	}
+	return count;
+}
+
+static struct device_attribute axp20_mfd_attrs[] = {
+	AXP_MFD_ATTR(axp20_offvol),
+	AXP_MFD_ATTR(axp20_noedelay),
+	AXP_MFD_ATTR(axp20_pekopen),
+	AXP_MFD_ATTR(axp20_peklong),
+	AXP_MFD_ATTR(axp20_peken),
+	AXP_MFD_ATTR(axp20_pekdelay),
+	AXP_MFD_ATTR(axp20_pekclose),
+	AXP_MFD_ATTR(axp20_ovtemclsen),
+	AXP_MFD_ATTR(axp20_reg),
+	AXP_MFD_ATTR(axp20_regs),
+};
diff --git a/drivers/power/axp_power/axp20-regu.c b/drivers/power/axp_power/axp20-regu.c
new file mode 100644
index 0000000..e56c5f5
--- /dev/null
+++ b/drivers/power/axp_power/axp20-regu.c
@@ -0,0 +1,492 @@
+/*
+ * Regulators driver for Dialog Semiconductor DA903x
+ *
+ * Copyright (C) 2006-2008 Marvell International Ltd.
+ * Copyright (C) 2008 Compulab Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/module.h>
+
+#include "axp-regu.h"
+
+static int axp20_ldo4_data[] = { 1250, 1300, 1400, 1500, 1600, 1700,
+				   1800, 1900, 2000, 2500, 2700, 2800,
+				   3000, 3100, 3200, 3300 };
+
+static inline struct device *to_axp_dev(struct regulator_dev *rdev)
+{
+	return rdev_get_dev(rdev)->parent->parent;
+}
+
+static inline int check_range(struct axp_regulator_info *info,
+				int min_uV, int max_uV)
+{
+	if (min_uV < info->min_uV || min_uV > info->max_uV)
+		return -EINVAL;
+
+	return 0;
+}
+
+
+/* AXP common operations */
+static int axp_set_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,
+			   unsigned *selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	
+
+	if (check_range(info, min_uV, max_uV)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+	val = (min_uV - info->min_uV + info->step_uV - 1) / info->step_uV;
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	return axp_update(axp_dev, info->vol_reg, val, mask);
+}
+
+static int axp_get_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int ret;
+
+	ret = axp_read(axp_dev, info->vol_reg, &val);
+	if (ret)
+		return ret;
+  
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+
+	return info->min_uV + info->step_uV * val;
+	
+}
+
+static int axp_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_set_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_clr_bits(axp_dev, info->enable_reg,
+					1 << info->enable_bit);
+}
+
+static int axp_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return !!(reg_val & (1 << info->enable_bit));
+}
+
+static int axp_list_voltage(struct regulator_dev *rdev, unsigned selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	int ret;
+
+	if(info->desc.id == AXP20_ID_LDO4)
+		return axp20_ldo4_data[selector] * 1000;
+	
+	ret = info->min_uV + info->step_uV * selector;
+	if (ret > info->max_uV)
+		return -EINVAL;
+	return ret;
+}
+
+static int axp_set_ldo4_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,
+				unsigned *selector)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int i;
+	
+	if (check_range(info, min_uV, max_uV)) {
+		pr_err("invalid voltage range (%d, %d) uV\n", min_uV, max_uV);
+		return -EINVAL;
+	}
+
+	for(i = 0,val = 0; i < sizeof(axp20_ldo4_data);i++){
+		if(min_uV <= axp20_ldo4_data[i] * 1000){
+			val = i;
+			break;
+		}
+	}
+	
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	return axp_update(axp_dev, info->vol_reg, val, mask);
+}
+
+static int axp_get_ldo4_voltage(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val, mask;
+	int ret;
+
+	ret = axp_read(axp_dev, info->vol_reg, &val);
+	if (ret)
+		return ret;
+  
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+	ret = axp20_ldo4_data[val]*1000;
+	return ret;
+}
+
+static int axp_set_suspend_voltage(struct regulator_dev *rdev, int uV)
+{
+	int ldo = rdev_get_id(rdev);
+	unsigned selector = 0;
+
+	switch (ldo) {
+	
+	case AXP20_ID_LDO1 ... AXP20_ID_LDO3:
+		return axp_set_voltage(rdev, uV, uV, &selector);
+	case AXP20_ID_LDO4:
+		return axp_set_ldo4_voltage(rdev, uV, uV, &selector);
+	case AXP20_ID_BUCK2 ... AXP20_ID_LDOIO0:
+		return axp_set_voltage(rdev, uV, uV, &selector);
+	default:
+		return -EINVAL;
+	}
+}
+
+
+static struct regulator_ops axp20_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_enable,
+	.disable	= axp_disable,
+	.is_enabled	= axp_is_enabled,
+	.set_suspend_enable		= axp_enable,
+	.set_suspend_disable	= axp_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+
+static struct regulator_ops axp20_ldo4_ops = {
+	.set_voltage	= axp_set_ldo4_voltage,
+	.get_voltage	= axp_get_ldo4_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_enable,
+	.disable	= axp_disable,
+	.is_enabled	= axp_is_enabled,
+	.set_suspend_enable		= axp_enable,
+	.set_suspend_disable	= axp_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+
+static int axp_ldoio0_enable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	 axp_set_bits(axp_dev, info->enable_reg,0x03);
+	 return axp_clr_bits(axp_dev, info->enable_reg,0x04);
+}
+
+static int axp_ldoio0_disable(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+
+	return axp_clr_bits(axp_dev, info->enable_reg,0x07);
+}
+
+static int axp_ldoio0_is_enabled(struct regulator_dev *rdev)
+{
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t reg_val;
+	int ret;
+
+	ret = axp_read(axp_dev, info->enable_reg, &reg_val);
+	if (ret)
+		return ret;
+
+	return (((reg_val &= 0x07)== 0x03)?1:0);
+}
+
+static struct regulator_ops axp20_ldoio0_ops = {
+	.set_voltage	= axp_set_voltage,
+	.get_voltage	= axp_get_voltage,
+	.list_voltage	= axp_list_voltage,
+	.enable		= axp_ldoio0_enable,
+	.disable	= axp_ldoio0_disable,
+	.is_enabled	= axp_ldoio0_is_enabled,
+	.set_suspend_enable		= axp_ldoio0_enable,
+	.set_suspend_disable	= axp_ldoio0_disable,
+	.set_suspend_voltage	= axp_set_suspend_voltage,
+};
+
+
+#define AXP20_LDO(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_LDO(AXP20, _id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+#define AXP20_BUCK(_id, min, max, step, vreg, shift, nbits, ereg, ebit)	\
+	AXP_BUCK(AXP20, _id, min, max, step, vreg, shift, nbits, ereg, ebit)
+
+static struct axp_regulator_info axp_regulator_info[] = {
+	AXP20_LDO(	1,	AXP20LDO1,	AXP20LDO1,	0,		LDO1,	0,	0,	LDO1EN,	0),//ldo1 for rtc
+	AXP20_LDO(	2,	1800,		3300,		100,	LDO2,	4,	4,	LDO2EN,	2),//ldo2 for analog1 
+	AXP20_LDO(	3,	700,		3500,		25,		LDO3,	0,	7,	LDO3EN,	6),//ldo3 for digital
+	AXP20_LDO(	4,	1250,		3300,		130,	LDO4,	0,	4,	LDO4EN,	3),//ldo4 for analog2
+	AXP20_BUCK(	2,	700,		2275,		25,		BUCK2,	0,	6,	BUCK2EN,4),//buck2 for core
+	AXP20_BUCK(	3,	700,		3500,		25,		BUCK3,	0,	7,	BUCK3EN,1),//buck3 for memery
+	AXP20_LDO(	IO0,1800,		3300,		100,	LDOIO0,	4,	4,	LDOIOEN,0),//ldoio0 for mic
+};
+
+static ssize_t workmode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP20_BUCKMODE, &val);
+	if (ret)
+		return sprintf(buf, "IO ERROR\n");
+	
+	if(info->desc.id == AXP20_ID_BUCK2){
+		switch (val & 0x04) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 4:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else if(info->desc.id == AXP20_ID_BUCK3){
+		switch (val & 0x02) {
+			case 0:return sprintf(buf, "AUTO\n");
+			case 2:return sprintf(buf, "PWM\n");
+			default:return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	else
+		return sprintf(buf, "IO ID ERROR\n");
+}
+
+static ssize_t workmode_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct axp_regulator_info *info = rdev_get_drvdata(rdev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	char mode;
+	uint8_t val;
+	if(  buf[0] > '0' && buf[0] < '9' )// 1/AUTO: auto mode; 2/PWM: pwm mode;
+		mode = buf[0];
+	else
+		mode = buf[1];
+	
+	switch(mode){
+	 case 'U':
+	 case 'u':
+	 case '1':
+		val = 0;break;
+	 case 'W':
+	 case 'w':
+	 case '2':
+	 	val = 1;break;
+	 default:
+	    val =0;	
+	}
+	
+	if(info->desc.id == AXP20_ID_BUCK2){
+		if(val)
+			axp_set_bits(axp_dev, AXP20_BUCKMODE,0x04);
+		else
+			axp_clr_bits(axp_dev, AXP20_BUCKMODE,0x04);
+	}
+	else if(info->desc.id == AXP20_ID_BUCK3){
+		if(val)
+			axp_set_bits(axp_dev, AXP20_BUCKMODE,0x02);
+		else
+			axp_clr_bits(axp_dev, AXP20_BUCKMODE,0x02);
+	}
+	
+	return count;
+}
+
+static ssize_t frequency_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	int ret;
+	uint8_t val;
+	ret = axp_read(axp_dev, AXP20_BUCKFREQ, &val);
+	if (ret)
+		return ret;
+	ret = val & 0x0F;
+	return sprintf(buf, "%d\n",(ret*75 + 750));
+}
+
+static ssize_t frequency_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{	
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct device *axp_dev = to_axp_dev(rdev);
+	uint8_t val,tmp;
+	int var;
+	var = simple_strtoul(buf, NULL, 10);
+	if(var < 750)
+		var = 750;
+	if(var > 1875)
+		var = 1875;
+		
+	val = (var -750)/75;
+	val &= 0x0F;
+	
+	axp_read(axp_dev, AXP20_BUCKFREQ, &tmp);
+	tmp &= 0xF0;
+	val |= tmp;
+	axp_write(axp_dev, AXP20_BUCKFREQ, val);
+	return count;
+}
+
+
+static struct device_attribute axp_regu_attrs[] = {
+	AXP_REGU_ATTR(workmode),
+	AXP_REGU_ATTR(frequency),
+};
+
+int axp_regu_create_attrs(struct platform_device *pdev)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(axp_regu_attrs); j++) {
+		ret = device_create_file(&pdev->dev,&axp_regu_attrs[j]);
+		if (ret)
+			goto sysfs_failed;
+	}
+    goto succeed;
+	
+sysfs_failed:
+	while (j--)
+		device_remove_file(&pdev->dev,&axp_regu_attrs[j]);
+succeed:
+	return ret;
+}
+
+static inline struct axp_regulator_info *find_regulator_info(int id)
+{
+	struct axp_regulator_info *ri;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(axp_regulator_info); i++) {
+		ri = &axp_regulator_info[i];
+		if (ri->desc.id == id)
+			return ri;
+	}
+	return NULL;
+}
+
+static int __devinit axp_regulator_probe(struct platform_device *pdev)
+{
+	struct axp_regulator_info *ri = NULL;
+	struct regulator_dev *rdev;
+	int ret;
+
+	ri = find_regulator_info(pdev->id);
+	if (ri == NULL) {
+		dev_err(&pdev->dev, "invalid regulator ID specified\n");
+		return -EINVAL;
+	}
+
+	if (ri->desc.id == AXP20_ID_LDO1 || ri->desc.id == AXP20_ID_LDO2 \
+		|| ri->desc.id == AXP20_ID_LDO3 || ri->desc.id == AXP20_ID_BUCK2 \
+		||ri->desc.id == AXP20_ID_BUCK3)
+		ri->desc.ops = &axp20_ops;
+	
+	if(ri->desc.id == AXP20_ID_LDO4)
+		ri->desc.ops = &axp20_ldo4_ops;
+
+
+	if(ri->desc.id == AXP20_ID_LDOIO0)
+		ri->desc.ops = &axp20_ldoio0_ops;
+
+
+	rdev = regulator_register(&ri->desc, &pdev->dev,
+				  pdev->dev.platform_data, ri, NULL);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register regulator %s\n",
+				ri->desc.name);
+		return PTR_ERR(rdev);
+	}
+	platform_set_drvdata(pdev, rdev);
+	
+	if(ri->desc.id == AXP20_ID_BUCK2 ||ri->desc.id == AXP20_ID_BUCK3){
+		ret = axp_regu_create_attrs(pdev);
+		if(ret){
+			return ret;
+		}
+	}
+	
+	return 0;
+}
+
+static int __devexit axp_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+	return 0;
+}
+
+static struct platform_driver axp_regulator_driver = {
+	.driver	= {
+		.name	= "axp20-regulator",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= axp_regulator_probe,
+	.remove		= axp_regulator_remove,
+};
+
+static int __init axp_regulator_init(void)
+{
+	return platform_driver_register(&axp_regulator_driver);
+}
+module_init(axp_regulator_init);
+
+static void __exit axp_regulator_exit(void)
+{
+	platform_driver_unregister(&axp_regulator_driver);
+}
+module_exit(axp_regulator_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Donglu Zhang");
+MODULE_DESCRIPTION("Regulator Driver for Krosspower AXP20 PMIC");
+MODULE_ALIAS("platform:axp-regulator");
diff --git a/drivers/power/axp_power/axp20-sply.c b/drivers/power/axp_power/axp20-sply.c
new file mode 100644
index 0000000..217e70a
--- /dev/null
+++ b/drivers/power/axp_power/axp20-sply.c
@@ -0,0 +1,2051 @@
+/*
+ * Battery charger driver for KrossPower AXP20X
+ *
+ * Copyright (C) 2011 KrossPower, Ltd.
+ *  Zhang Donglu <zhangdonglu@x-powers.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/input.h>
+#include <linux/mfd/axp-mfd.h>
+#include <asm/div64.h>
+
+#include <plat/sys_config.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include "axp-cfg.h"
+#include "axp-sply.h"
+
+#define DBG_AXP_PSY 0
+#if  DBG_AXP_PSY
+#define DBG_PSY_MSG(format,args...)   printk("[AXP]"format,##args)
+#else
+#define DBG_PSY_MSG(format,args...)   do {} while (0)
+#endif
+
+static int pmu_used2 = 0;
+static int gpio_adp_hdle = 0;
+static int pmu_suspendpwroff_vol = 0;
+static int pmu_earlysuspend_chgcur = 0;
+struct axp_adc_res adc;
+static int count_rdc = 0;
+static int count_dis = 0;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static struct early_suspend axp_early_suspend;
+int early_suspend_flag = 0;
+#endif
+
+int ADC_Freq_Get(struct axp_charger *charger)
+{
+	uint8_t  temp;
+	int  rValue = 25;
+
+	axp_read(charger->master, AXP20_ADC_CONTROL3,&temp);
+	temp &= 0xc0;
+	switch(temp >> 6)
+	{
+		case 0:
+			rValue = 25;
+			break;
+		case 1:
+			rValue = 50;
+			break;
+		case 2:
+			rValue = 100;
+			break;
+		case 3:
+			rValue = 200;
+			break;
+		default:
+			break;
+	}
+	return rValue;
+}
+
+static inline int axp20_vbat_to_mV(uint16_t reg)
+{
+  return ((int)((( reg >> 8) << 4 ) | (reg & 0x000F))) * 1100 / 1000;
+}
+
+static inline int axp20_vdc_to_mV(uint16_t reg)
+{
+  return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 1700 / 1000;
+}
+
+
+static inline int axp20_ibat_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 5 ) | (reg & 0x001F))) * 500 / 1000;
+}
+
+static inline int axp20_icharge_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 500 / 1000;
+}
+
+static inline int axp20_iac_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 625 / 1000;
+}
+
+static inline int axp20_iusb_to_mA(uint16_t reg)
+{
+    return ((int)(((reg >> 8) << 4 ) | (reg & 0x000F))) * 375 / 1000;
+}
+
+
+static inline void axp_read_adc(struct axp_charger *charger,
+  struct axp_adc_res *adc)
+{
+  uint8_t tmp[8];
+
+  axp_reads(charger->master,AXP20_VACH_RES,8,tmp);
+  adc->vac_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
+  adc->iac_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
+  adc->vusb_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
+  adc->iusb_res = ((uint16_t) tmp[6] << 8 )| tmp[7];
+  axp_reads(charger->master,AXP20_VBATH_RES,6,tmp);
+  adc->vbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
+  adc->ichar_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
+  adc->idischar_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
+}
+
+
+static void axp_charger_update_state(struct axp_charger *charger)
+{
+  uint8_t val[2];
+  uint16_t tmp;
+
+  axp_reads(charger->master,AXP20_CHARGE_STATUS,2,val);
+  tmp = (val[1] << 8 )+ val[0];
+  charger->is_on = (val[1] & AXP20_IN_CHARGE) ? 1 : 0;
+  charger->fault = val[1];
+  charger->bat_det = (tmp & AXP20_STATUS_BATEN)?1:0;
+  charger->ac_det = (tmp & AXP20_STATUS_ACEN)?1:0;
+  charger->usb_det = (tmp & AXP20_STATUS_USBEN)?1:0;
+  charger->usb_valid = (tmp & AXP20_STATUS_USBVA)?1:0;
+  charger->ac_valid = (tmp & AXP20_STATUS_ACVA)?1:0;
+  charger->ext_valid = charger->ac_valid | charger->usb_valid;
+  charger->bat_current_direction = (tmp & AXP20_STATUS_BATCURDIR)?1:0;
+  charger->in_short = (tmp& AXP20_STATUS_ACUSBSH)?1:0;
+  charger->batery_active = (tmp & AXP20_STATUS_BATINACT)?1:0;
+  charger->low_charge_current = (tmp & AXP20_STATUS_CHACURLOEXP)?1:0;
+  charger->int_over_temp = (tmp & AXP20_STATUS_ICTEMOV)?1:0;
+ 	axp_read(charger->master,AXP20_CHARGE_CONTROL1,val);
+ 	charger->charge_on = ((val[0] >> 7) & 0x01);
+}
+
+static void axp_charger_update(struct axp_charger *charger)
+{
+  uint16_t tmp;
+  uint8_t val[2];
+  //struct axp_adc_res adc;
+  charger->adc = &adc;
+  axp_read_adc(charger, &adc);
+  tmp = charger->adc->vbat_res;
+  charger->vbat = axp20_vbat_to_mV(tmp);
+   //tmp = charger->adc->ichar_res + charger->adc->idischar_res;
+  charger->ibat = ABS(axp20_icharge_to_mA(charger->adc->ichar_res)-axp20_ibat_to_mA(charger->adc->idischar_res));
+  tmp = charger->adc->vac_res;
+  charger->vac = axp20_vdc_to_mV(tmp);
+  tmp = charger->adc->iac_res;
+  charger->iac = axp20_iac_to_mA(tmp);
+  tmp = charger->adc->vusb_res;
+  charger->vusb = axp20_vdc_to_mV(tmp);
+  tmp = charger->adc->iusb_res;
+  charger->iusb = axp20_iusb_to_mA(tmp);
+  axp_reads(charger->master,AXP20_INTTEMP,2,val);
+  //DBG_PSY_MSG("TEMPERATURE:val1=0x%x,val2=0x%x\n",val[1],val[0]);
+  tmp = (val[0] << 4 ) + (val[1] & 0x0F);
+  charger->ic_temp = (int) tmp  - 1447;
+  if(!charger->ext_valid){
+  	charger->disvbat =  charger->vbat;
+  	charger->disibat =  charger->ibat;
+  }
+}
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static void axp_set_charge(struct axp_charger *charger)
+{
+  uint8_t val=0x00;
+  uint8_t tmp=0x00;
+    if(charger->chgvol < 4150000)
+      val &= ~(3 << 5);
+    else if (charger->chgvol<4200000){
+      val &= ~(3 << 5);
+      val |= 1 << 5;
+      }
+    else if (charger->chgvol<4360000){
+      val &= ~(3 << 5);
+      val |= 1 << 6;
+      }
+    else
+      val |= 3 << 5;
+
+		if(charger->chgcur == 0)
+			charger->chgen = 0;
+
+    if(charger->chgcur< 300000)
+      charger->chgcur = 300000;
+    else if(charger->chgcur > 1800000)
+     charger->chgcur = 1800000;
+
+    val |= (charger->chgcur - 200001) / 100000 ;
+    if(charger ->chgend == 10){
+      val &= ~(1 << 4);
+    }
+    else {
+      val |= 1 << 4;
+    }
+    val &= 0x7F;
+    val |= charger->chgen << 7;
+      if(charger->chgpretime < 30)
+      charger->chgpretime = 30;
+    if(charger->chgcsttime < 360)
+      charger->chgcsttime = 360;
+
+    tmp = ((((charger->chgpretime - 40) / 10) << 6)  \
+      | ((charger->chgcsttime - 360) / 120));
+	axp_write(charger->master, AXP20_CHARGE_CONTROL1,val);
+	axp_update(charger->master, AXP20_CHARGE_CONTROL2,tmp,0xC2);
+}
+#else
+static void axp_set_charge(struct axp_charger *charger)
+{
+
+}
+#endif
+
+static enum power_supply_property axp_battery_props[] = {
+  POWER_SUPPLY_PROP_MODEL_NAME,
+  POWER_SUPPLY_PROP_STATUS,
+  POWER_SUPPLY_PROP_PRESENT,
+  POWER_SUPPLY_PROP_ONLINE,
+  POWER_SUPPLY_PROP_HEALTH,
+  POWER_SUPPLY_PROP_TECHNOLOGY,
+  POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+  POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+  POWER_SUPPLY_PROP_VOLTAGE_NOW,
+  POWER_SUPPLY_PROP_CURRENT_NOW,
+  //POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+  //POWER_SUPPLY_PROP_CHARGE_FULL,
+  POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
+  POWER_SUPPLY_PROP_CAPACITY,
+  //POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+  //POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+  POWER_SUPPLY_PROP_TEMP,
+};
+
+static enum power_supply_property axp_ac_props[] = {
+  POWER_SUPPLY_PROP_MODEL_NAME,
+  POWER_SUPPLY_PROP_PRESENT,
+  POWER_SUPPLY_PROP_ONLINE,
+  POWER_SUPPLY_PROP_VOLTAGE_NOW,
+  POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static enum power_supply_property axp_usb_props[] = {
+  POWER_SUPPLY_PROP_MODEL_NAME,
+  POWER_SUPPLY_PROP_PRESENT,
+  POWER_SUPPLY_PROP_ONLINE,
+  POWER_SUPPLY_PROP_VOLTAGE_NOW,
+  POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static void axp_battery_check_status(struct axp_charger *charger,
+            union power_supply_propval *val)
+{
+  if (charger->bat_det) {
+    if (charger->ext_valid){
+    	if( charger->rest_vol == 100)
+        val->intval = POWER_SUPPLY_STATUS_FULL;
+    	else if(charger->charge_on)
+    		val->intval = POWER_SUPPLY_STATUS_CHARGING;
+    	else
+    		val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+    }
+    else
+      val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+  }
+  else
+    val->intval = POWER_SUPPLY_STATUS_FULL;
+}
+
+static void axp_battery_check_health(struct axp_charger *charger,
+            union power_supply_propval *val)
+{
+    if (charger->fault & AXP20_FAULT_LOG_BATINACT)
+    val->intval = POWER_SUPPLY_HEALTH_DEAD;
+  else if (charger->fault & AXP20_FAULT_LOG_OVER_TEMP)
+    val->intval = POWER_SUPPLY_HEALTH_OVERHEAT;
+  else if (charger->fault & AXP20_FAULT_LOG_COLD)
+    val->intval = POWER_SUPPLY_HEALTH_COLD;
+  else
+    val->intval = POWER_SUPPLY_HEALTH_GOOD;
+}
+
+static int axp_battery_get_property(struct power_supply *psy,
+           enum power_supply_property psp,
+           union power_supply_propval *val)
+{
+  struct axp_charger *charger;
+  int ret = 0;
+  charger = container_of(psy, struct axp_charger, batt);
+
+  switch (psp) {
+  case POWER_SUPPLY_PROP_STATUS:
+    axp_battery_check_status(charger, val);
+    break;
+  case POWER_SUPPLY_PROP_HEALTH:
+    axp_battery_check_health(charger, val);
+    break;
+  case POWER_SUPPLY_PROP_TECHNOLOGY:
+    val->intval = charger->battery_info->technology;
+    break;
+  case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+    val->intval = charger->battery_info->voltage_max_design;
+    break;
+  case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+    val->intval = charger->battery_info->voltage_min_design;
+    break;
+  case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+    val->intval = charger->ocv * 1000;
+    break;
+  case POWER_SUPPLY_PROP_CURRENT_NOW:
+    val->intval = charger->ibat * 1000;
+    break;
+  case POWER_SUPPLY_PROP_MODEL_NAME:
+    val->strval = charger->batt.name;
+    break;
+/*  case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+  case POWER_SUPPLY_PROP_CHARGE_FULL:
+    val->intval = charger->battery_info->charge_full_design;
+        break;
+*/
+  case POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+    val->intval = charger->battery_info->energy_full_design;
+  //  DBG_PSY_MSG("POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:%d\n",val->intval);
+       break;
+  case POWER_SUPPLY_PROP_CAPACITY:
+    val->intval = charger->rest_vol;
+    break;
+/*  case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+    if(charger->bat_det && !(charger->is_on) && !(charger->ext_valid))
+      val->intval = charger->rest_time;
+    else
+      val->intval = 0;
+    break;
+  case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+    if(charger->bat_det && charger->is_on)
+      val->intval = charger->rest_time;
+    else
+      val->intval = 0;
+    break;
+*/
+  case POWER_SUPPLY_PROP_ONLINE:
+    val->intval = (!charger->is_on)&&(charger->bat_det) && (! charger->ext_valid);
+    break;
+  case POWER_SUPPLY_PROP_PRESENT:
+    val->intval = charger->bat_det;
+    break;
+  case POWER_SUPPLY_PROP_TEMP:
+    //val->intval = charger->ic_temp - 200;
+    val->intval =  300;
+    break;
+  default:
+    ret = -EINVAL;
+    break;
+  }
+
+  return ret;
+}
+
+static int axp_ac_get_property(struct power_supply *psy,
+           enum power_supply_property psp,
+           union power_supply_propval *val)
+{
+  struct axp_charger *charger;
+  int ret = 0;
+  charger = container_of(psy, struct axp_charger, ac);
+
+  switch(psp){
+  case POWER_SUPPLY_PROP_MODEL_NAME:
+    val->strval = charger->ac.name;break;
+  case POWER_SUPPLY_PROP_PRESENT:
+    val->intval = charger->ac_det;
+    break;
+  case POWER_SUPPLY_PROP_ONLINE:
+    val->intval = charger->ac_valid;break;
+  case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+    val->intval = charger->vac * 1000;
+    break;
+  case POWER_SUPPLY_PROP_CURRENT_NOW:
+    val->intval = charger->iac * 1000;
+    break;
+  default:
+    ret = -EINVAL;
+    break;
+  }
+   return ret;
+}
+
+static int axp_usb_get_property(struct power_supply *psy,
+           enum power_supply_property psp,
+           union power_supply_propval *val)
+{
+  struct axp_charger *charger;
+  int ret = 0;
+  charger = container_of(psy, struct axp_charger, usb);
+
+  switch(psp){
+  case POWER_SUPPLY_PROP_MODEL_NAME:
+    val->strval = charger->usb.name;break;
+  case POWER_SUPPLY_PROP_PRESENT:
+    val->intval = charger->usb_det;
+    break;
+  case POWER_SUPPLY_PROP_ONLINE:
+    val->intval = charger->usb_valid;
+    break;
+  case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+    val->intval = charger->vusb * 1000;
+    break;
+  case POWER_SUPPLY_PROP_CURRENT_NOW:
+    val->intval = charger->iusb * 1000;
+    break;
+  default:
+    ret = -EINVAL;
+    break;
+  }
+   return ret;
+}
+
+static void axp_change(struct axp_charger *charger)
+{
+  DBG_PSY_MSG("battery state change\n");
+  axp_charger_update_state(charger);
+  axp_charger_update(charger);
+  flag_state_change = 1;
+  power_supply_changed(&charger->batt);
+}
+
+static void axp_presslong(struct axp_charger *charger)
+{
+	DBG_PSY_MSG("press long\n");
+	input_report_key(powerkeydev, KEY_POWER, 1);
+	input_sync(powerkeydev);
+	ssleep(2);
+	DBG_PSY_MSG("press long up\n");
+	input_report_key(powerkeydev, KEY_POWER, 0);
+	input_sync(powerkeydev);
+}
+
+static void axp_pressshort(struct axp_charger *charger)
+{
+	DBG_PSY_MSG("press short\n");
+  input_report_key(powerkeydev, KEY_POWER, 1);
+  input_sync(powerkeydev);
+  msleep(100);
+  input_report_key(powerkeydev, KEY_POWER, 0);
+  input_sync(powerkeydev);
+}
+
+static void axp_capchange(struct axp_charger *charger)
+{
+	uint8_t val;
+	int k;
+
+	DBG_PSY_MSG("battery change\n");
+	ssleep(2);
+  axp_charger_update_state(charger);
+  axp_charger_update(charger);
+  axp_read(charger->master, AXP20_CAP,&val);
+  charger->rest_vol = (int) (val & 0x7F);
+
+  if((charger->bat_det == 0) || (charger->rest_vol == 127)){
+  	charger->rest_vol = 100;
+  }
+
+  DBG_PSY_MSG("rest_vol = %d\n",charger->rest_vol);
+  memset(Bat_Cap_Buffer, 0, sizeof(Bat_Cap_Buffer));
+  for(k = 0;k < AXP20_VOL_MAX; k++){
+    Bat_Cap_Buffer[k] = charger->rest_vol;
+  }
+  Total_Cap = charger->rest_vol * AXP20_VOL_MAX;
+  power_supply_changed(&charger->batt);
+}
+
+static void axp_close(struct axp_charger *charger)
+{
+	charger->rest_vol = 5;
+	axp_write(charger->master,AXP20_DATA_BUFFER1,0x85);
+	DBG_PSY_MSG("\n==================event in close==============\n");
+	power_supply_changed(&charger->batt);
+}
+
+
+static int axp_battery_event(struct notifier_block *nb, unsigned long event,
+        void *data)
+{
+    struct axp_charger *charger =
+    container_of(nb, struct axp_charger, nb);
+
+    uint8_t w[9];
+
+    w[0] = (uint8_t) ((event) & 0xFF);
+    w[1] = POWER20_INTSTS2;
+    w[2] = (uint8_t) ((event >> 8) & 0xFF);
+    w[3] = POWER20_INTSTS3;
+    w[4] = (uint8_t) ((event >> 16) & 0xFF);
+    w[5] = POWER20_INTSTS4;
+    w[6] = (uint8_t) ((event >> 24) & 0xFF);
+    w[7] = POWER20_INTSTS5;
+    w[8] = (uint8_t) (((uint64_t) event >> 32) & 0xFF);
+
+    if(event & (AXP20_IRQ_BATIN|AXP20_IRQ_BATRE)) {
+    	axp_capchange(charger);
+    }
+
+    if(event & (AXP20_IRQ_ACIN|AXP20_IRQ_USBIN|AXP20_IRQ_ACOV|AXP20_IRQ_USBOV|AXP20_IRQ_CHAOV
+               |AXP20_IRQ_CHAST|AXP20_IRQ_TEMOV|AXP20_IRQ_TEMLO)) {
+        axp_change(charger);
+    }
+
+    if(event & (AXP20_IRQ_ACRE|AXP20_IRQ_USBRE)) {
+    	axp_change(charger);
+    	axp_clr_bits(charger->master,0x32,0x38);
+    }
+
+    if(event & AXP20_IRQ_PEKLO) {
+    	axp_presslong(charger);
+    }
+
+    if(event & AXP20_IRQ_PEKSH) {
+    	axp_pressshort(charger);
+    }
+
+    DBG_PSY_MSG("event = 0x%x\n",(int) event);
+    axp_writes(charger->master,POWER20_INTSTS1,9,w);
+
+    return 0;
+}
+
+static char *supply_list[] = {
+  "battery",
+};
+
+
+
+static void axp_battery_setup_psy(struct axp_charger *charger)
+{
+  struct power_supply *batt = &charger->batt;
+  struct power_supply *ac = &charger->ac;
+  struct power_supply *usb = &charger->usb;
+  struct power_supply_info *info = charger->battery_info;
+
+  batt->name = "battery";
+  batt->use_for_apm = info->use_for_apm;
+  batt->type = POWER_SUPPLY_TYPE_BATTERY;
+  batt->get_property = axp_battery_get_property;
+
+  batt->properties = axp_battery_props;
+  batt->num_properties = ARRAY_SIZE(axp_battery_props);
+
+  ac->name = "ac";
+  ac->type = POWER_SUPPLY_TYPE_MAINS;
+  ac->get_property = axp_ac_get_property;
+
+  ac->supplied_to = supply_list,
+  ac->num_supplicants = ARRAY_SIZE(supply_list),
+
+  ac->properties = axp_ac_props;
+  ac->num_properties = ARRAY_SIZE(axp_ac_props);
+
+  usb->name = "usb";
+  usb->type = POWER_SUPPLY_TYPE_USB;
+  usb->get_property = axp_usb_get_property;
+
+  usb->supplied_to = supply_list,
+  usb->num_supplicants = ARRAY_SIZE(supply_list),
+
+  usb->properties = axp_usb_props;
+  usb->num_properties = ARRAY_SIZE(axp_usb_props);
+};
+
+#if defined  (CONFIG_AXP_CHARGEINIT)
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+   int ret ;
+   uint8_t val;
+
+  /*enable adc and set adc */
+  val= AXP20_ADC_BATVOL_ENABLE | AXP20_ADC_BATCUR_ENABLE
+  | AXP20_ADC_DCINCUR_ENABLE | AXP20_ADC_DCINVOL_ENABLE
+  | AXP20_ADC_USBVOL_ENABLE | AXP20_ADC_USBCUR_ENABLE;
+
+	ret = axp_update(charger->master, AXP20_ADC_CONTROL1, val , val);
+  if (ret)
+    return ret;
+    ret = axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+  switch (charger->sample_time/25){
+  case 1: val &= ~(3 << 6);break;
+  case 2: val &= ~(3 << 6);val |= 1 << 6;break;
+  case 4: val &= ~(3 << 6);val |= 2 << 6;break;
+  case 8: val |= 3 << 6;break;
+  default: break;
+  }
+  ret = axp_write(charger->master, AXP20_ADC_CONTROL3, val);
+  if (ret)
+    return ret;
+
+  return 0;
+}
+#else
+static int axp_battery_adc_set(struct axp_charger *charger)
+{
+  return 0;
+}
+#endif
+
+static int axp_battery_first_init(struct axp_charger *charger)
+{
+   int ret;
+   uint8_t val;
+   axp_set_charge(charger);
+   ret = axp_battery_adc_set(charger);
+   if(ret)
+    return ret;
+
+   ret = axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+   switch ((val >> 6) & 0x03){
+  case 0: charger->sample_time = 25;break;
+  case 1: charger->sample_time = 50;break;
+  case 2: charger->sample_time = 100;break;
+  case 3: charger->sample_time = 200;break;
+  default:break;
+  }
+  return ret;
+}
+
+static int axp_get_rdc(struct axp_charger *charger)
+{
+	int temp;
+	int rdc;
+	uint8_t v[2];
+	axp_reads(charger->master,0xba,2,v);
+	rdc = (((v[0] & 0x1F) << 8) | v[1]) * 10742 / 10000;
+	DBG_PSY_MSG("===========================calculate rdc \n");
+
+	if(!charger->bat_det){
+		charger->disvbat = 0;
+		charger->disibat = 0;
+		return rdc;
+	}
+	if( charger->ext_valid){
+		axp_charger_update(charger);
+		if( axp20_ibat_to_mA(charger->adc->idischar_res) == 0 && axp20_icharge_to_mA(charger->adc->ichar_res) > 200){
+		} else {
+			DBG_PSY_MSG("%s->%d\n",__FUNCTION__,__LINE__);
+			charger->disvbat = 0;
+			charger->disibat = 0;
+			return rdc;
+		}
+		DBG_PSY_MSG("CHARGING:      charger->vbat = %d,   charger->ibat = %d\n",charger->vbat,charger->ibat);
+		DBG_PSY_MSG("DISCHARGING:charger->disvbat = %d,charger->disibat = %d\n",charger->disvbat,charger->disibat);
+		axp_charger_update_state(charger);
+		if(!charger->bat_current_direction){
+			charger->disvbat = 0;
+			charger->disibat = 0;
+			return rdc;
+		}
+		if(charger->disvbat == 0){
+			charger->disvbat = 0;
+			charger->disibat = 0;
+			return rdc;
+		}else{
+			temp = 1000 * ABS(charger->vbat - charger->disvbat) / ABS(charger->ibat + charger->disibat);
+			DBG_PSY_MSG("CALRDC:temp = %d\n",temp);
+			if((temp < 75) || (temp > pmu_battery_rdc * 2)){
+				charger->disvbat = 0;
+				charger->disibat = 0;
+				return rdc;
+			} else {
+				axp_set_bits(charger->master,0x04,0x08);
+				return temp;
+			}
+		}
+	}else{
+		charger->disvbat = 0;
+		charger->disibat = 0;
+		return rdc;
+	}
+}
+
+static ssize_t chgen_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+  charger->chgen  = val >> 7;
+  return sprintf(buf, "%d\n",charger->chgen);
+}
+
+static ssize_t chgen_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var){
+    charger->chgen = 1;
+    axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  }
+  else{
+    charger->chgen = 0;
+    axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  }
+  return count;
+}
+
+static ssize_t chgmicrovol_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+  switch ((val >> 5) & 0x03){
+    case 0: charger->chgvol = 4100000;break;
+    case 1: charger->chgvol = 4150000;break;
+    case 2: charger->chgvol = 4200000;break;
+    case 3: charger->chgvol = 4360000;break;
+  }
+  return sprintf(buf, "%d\n",charger->chgvol);
+}
+
+static ssize_t chgmicrovol_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t tmp, val;
+  var = simple_strtoul(buf, NULL, 10);
+  switch(var){
+    case 4100000:tmp = 0;break;
+    case 4150000:tmp = 1;break;
+    case 4200000:tmp = 2;break;
+    case 4360000:tmp = 3;break;
+    default:  tmp = 4;break;
+  }
+  if(tmp < 4){
+    charger->chgvol = var;
+    axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+    val &= 0x9F;
+    val |= tmp << 5;
+    axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+  }
+  return count;
+}
+
+static ssize_t chgintmicrocur_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+  charger->chgcur = (val & 0x0F) * 100000 +300000;
+  return sprintf(buf, "%d\n",charger->chgcur);
+}
+
+static ssize_t chgintmicrocur_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t val,tmp;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var >= 300000 && var <= 1800000){
+    tmp = (var -200001)/100000;
+    charger->chgcur = tmp *100000 + 300000;
+    axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+    val &= 0xF0;
+    val |= tmp;
+    axp_write(charger->master, AXP20_CHARGE_CONTROL1, val);
+  }
+  return count;
+}
+
+static ssize_t chgendcur_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_CHARGE_CONTROL1, &val);
+  charger->chgend = ((val >> 4)& 0x01)? 15 : 10;
+  return sprintf(buf, "%d\n",charger->chgend);
+}
+
+static ssize_t chgendcur_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var == 10 ){
+    charger->chgend = var;
+    axp_clr_bits(charger->master ,AXP20_CHARGE_CONTROL1,0x10);
+  }
+  else if (var == 15){
+    charger->chgend = var;
+    axp_set_bits(charger->master ,AXP20_CHARGE_CONTROL1,0x10);
+
+  }
+  return count;
+}
+
+static ssize_t chgpretimemin_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master,AXP20_CHARGE_CONTROL2, &val);
+  charger->chgpretime = (val >> 6) * 10 +40;
+  return sprintf(buf, "%d\n",charger->chgpretime);
+}
+
+static ssize_t chgpretimemin_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t tmp,val;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var >= 40 && var <= 70){
+    tmp = (var - 40)/10;
+    charger->chgpretime = tmp * 10 + 40;
+    axp_read(charger->master,AXP20_CHARGE_CONTROL2,&val);
+    val &= 0x3F;
+    val |= (tmp << 6);
+    axp_write(charger->master,AXP20_CHARGE_CONTROL2,val);
+  }
+  return count;
+}
+
+static ssize_t chgcsttimemin_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master,AXP20_CHARGE_CONTROL2, &val);
+  charger->chgcsttime = (val & 0x03) *120 + 360;
+  return sprintf(buf, "%d\n",charger->chgcsttime);
+}
+
+static ssize_t chgcsttimemin_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t tmp,val;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var >= 360 && var <= 720){
+    tmp = (var - 360)/120;
+    charger->chgcsttime = tmp * 120 + 360;
+    axp_read(charger->master,AXP20_CHARGE_CONTROL2,&val);
+    val &= 0xFC;
+    val |= tmp;
+    axp_write(charger->master,AXP20_CHARGE_CONTROL2,val);
+  }
+  return count;
+}
+
+static ssize_t adcfreq_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+  switch ((val >> 6) & 0x03){
+     case 0: charger->sample_time = 25;break;
+     case 1: charger->sample_time = 50;break;
+     case 2: charger->sample_time = 100;break;
+     case 3: charger->sample_time = 200;break;
+     default:break;
+  }
+  return sprintf(buf, "%d\n",charger->sample_time);
+}
+
+static ssize_t adcfreq_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t val;
+  var = simple_strtoul(buf, NULL, 10);
+  axp_read(charger->master, AXP20_ADC_CONTROL3, &val);
+  switch (var/25){
+    case 1: val &= ~(3 << 6);charger->sample_time = 25;break;
+    case 2: val &= ~(3 << 6);val |= 1 << 6;charger->sample_time = 50;break;
+    case 4: val &= ~(3 << 6);val |= 2 << 6;charger->sample_time = 100;break;
+    case 8: val |= 3 << 6;charger->sample_time = 200;break;
+    default: break;
+    }
+  axp_write(charger->master, AXP20_ADC_CONTROL3, val);
+  return count;
+}
+
+
+static ssize_t vholden_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+  val = (val>>6) & 0x01;
+  return sprintf(buf, "%d\n",val);
+}
+
+static ssize_t vholden_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var)
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x40);
+  else
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x40);
+
+  return count;
+}
+
+static ssize_t vhold_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  int vhold;
+  axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+  vhold = ((val >> 3) & 0x07) * 100000 + 4000000;
+  return sprintf(buf, "%d\n",vhold);
+}
+
+static ssize_t vhold_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  uint8_t val,tmp;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var >= 4000000 && var <=4700000){
+    tmp = (var - 4000000)/100000;
+    //printk("tmp = 0x%x\n",tmp);
+    axp_read(charger->master, AXP20_CHARGE_VBUS,&val);
+    val &= 0xC7;
+    val |= tmp << 3;
+    //printk("val = 0x%x\n",val);
+    axp_write(charger->master, AXP20_CHARGE_VBUS,val);
+  }
+  return count;
+}
+
+static ssize_t iholden_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val;
+  axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+  return sprintf(buf, "%d\n",((val & 0x03) == 0x03)?0:1);
+}
+
+static ssize_t iholden_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var)
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+  else
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+
+  return count;
+}
+
+static ssize_t ihold_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  uint8_t val,tmp;
+  int ihold;
+  axp_read(charger->master,AXP20_CHARGE_VBUS, &val);
+  tmp = (val) & 0x03;
+  switch(tmp){
+    case 0: ihold = 900000;break;
+    case 1: ihold = 500000;break;
+    case 2: ihold = 100000;break;
+    default: ihold = 0;break;
+  }
+  return sprintf(buf, "%d\n",ihold);
+}
+
+static ssize_t ihold_store(struct device *dev,
+        struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct axp_charger *charger = dev_get_drvdata(dev);
+  int var;
+  var = simple_strtoul(buf, NULL, 10);
+  if(var == 900000)
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+  else if (var == 500000){
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+  }
+  else if (var == 100000){
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+  }
+
+  return count;
+}
+
+static struct device_attribute axp_charger_attrs[] = {
+  AXP_CHG_ATTR(chgen),
+  AXP_CHG_ATTR(chgmicrovol),
+  AXP_CHG_ATTR(chgintmicrocur),
+  AXP_CHG_ATTR(chgendcur),
+  AXP_CHG_ATTR(chgpretimemin),
+  AXP_CHG_ATTR(chgcsttimemin),
+  AXP_CHG_ATTR(adcfreq),
+  AXP_CHG_ATTR(vholden),
+  AXP_CHG_ATTR(vhold),
+  AXP_CHG_ATTR(iholden),
+  AXP_CHG_ATTR(ihold),
+};
+
+#if defined CONFIG_HAS_EARLYSUSPEND
+static void axp_earlysuspend(struct early_suspend *h)
+{
+	uint8_t tmp;
+	DBG_PSY_MSG("======early suspend=======\n");
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+  	early_suspend_flag = 1;
+  	if(pmu_earlysuspend_chgcur == 0)
+  		axp_clr_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  	else
+  		axp_set_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+    if(pmu_earlysuspend_chgcur >= 300000 && pmu_earlysuspend_chgcur <= 1800000){
+    	tmp = (pmu_earlysuspend_chgcur -200001)/100000;
+    	axp_update(axp_charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
+#endif
+
+}
+static void axp_lateresume(struct early_suspend *h)
+{
+	uint8_t tmp;
+	DBG_PSY_MSG("======late resume=======\n");
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+	early_suspend_flag = 0;
+	if(pmu_resume_chgcur == 0)
+  		axp_clr_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  else
+  		axp_set_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+    if(pmu_resume_chgcur >= 300000 && pmu_resume_chgcur <= 1800000){
+        tmp = (pmu_resume_chgcur -200001)/100000;
+        axp_update(axp_charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
+#endif
+
+}
+#endif
+
+int axp_charger_create_attrs(struct power_supply *psy)
+{
+  int j,ret;
+  for (j = 0; j < ARRAY_SIZE(axp_charger_attrs); j++) {
+    ret = device_create_file(psy->dev,
+          &axp_charger_attrs[j]);
+    if (ret)
+      goto sysfs_failed;
+  }
+    goto succeed;
+
+sysfs_failed:
+  while (j--)
+    device_remove_file(psy->dev,
+         &axp_charger_attrs[j]);
+succeed:
+  return ret;
+}
+
+int Get_Bat_Coulomb_Count(struct axp_charger *charger)
+{
+	uint8_t  temp[8];
+	int64_t  rValue1,rValue2,rValue;
+	int Cur_CoulombCounter_tmp,m;
+
+	axp_reads(charger->master, AXP20_CCHAR3_RES,8,temp);
+	rValue1 = ((temp[0] << 24) + (temp[1] << 16) + (temp[2] << 8) + temp[3]);
+	rValue2 = ((temp[4] << 24) + (temp[5] << 16) + (temp[6] << 8) + temp[7]);
+	DBG_PSY_MSG("%s->%d -     CHARGINGOULB:[0]=0x%x,[1]=0x%x,[2]=0x%x,[3]=0x%x\n",__FUNCTION__,__LINE__,temp[0],temp[1],temp[2],temp[3]);
+	DBG_PSY_MSG("%s->%d - DISCHARGINGCLOUB:[4]=0x%x,[5]=0x%x,[6]=0x%x,[7]=0x%x\n",__FUNCTION__,__LINE__,temp[4],temp[5],temp[6],temp[7]);
+	rValue = (ABS(rValue1 - rValue2)) * 4369;
+	m = ADC_Freq_Get(charger) * 480;
+	do_div(rValue,m);
+	if(rValue1 >= rValue2)
+		Cur_CoulombCounter_tmp = (int)rValue;
+	else
+		Cur_CoulombCounter_tmp = (int)(0 - rValue);
+	DBG_PSY_MSG("Cur_CoulombCounter_tmp = %d\n",Cur_CoulombCounter_tmp);
+	return Cur_CoulombCounter_tmp;				//unit mAh
+}
+
+static void axp_charging_monitor(struct work_struct *work)
+{
+    struct axp_charger *charger;
+    uint8_t val;
+    uint8_t v[5];
+    int pre_rest_vol;
+    int rdc,k;
+    int rt_rest_vol;
+    int rest_vol;
+    uint16_t tmp;
+    int Cur_CoulombCounter;
+    int cap_index_p,var;
+	int gpio_adp_val,ret;
+
+    charger = container_of(work, struct axp_charger, work.work);
+
+    Cur_CoulombCounter = ABS(Get_Bat_Coulomb_Count(charger));
+  	DBG_PSY_MSG("Cur_CoulombCounter = %d\n",Cur_CoulombCounter);
+
+		axp_reads(charger->master,0xbc,2,v);
+ 		charger->ocv = ((v[0] << 4) + (v[1] & 0x0f)) * 11 /10 ;
+    axp_reads(charger->master,AXP20_IC_TYPE,2,v);
+    //DBG_PSY_MSG("v[0] = 0x%x,v[1] = 0x%x\n",v[0],v[1]);
+    pre_rest_vol = charger->rest_vol;
+    axp_charger_update_state(charger);
+    axp_charger_update(charger);
+
+    if((v[0] == 0x11 || v[0] == 0x21) && charger->is_on && axp20_icharge_to_mA(charger->adc->ichar_res) > 200 && charger->vbat > 3600 && charger->disvbat != 0){
+        if((((v[1] >> 7) == 0) || (((v[1] >> 3) & 0x1) == 0)) && count_rdc >= 3){
+            axp_set_bits(charger->master,AXP20_CAP,0x80);
+            axp_clr_bits(charger->master,0xBA,0x80);
+            rdc = (axp_get_rdc(charger) * 10000 + 5371) / 10742;
+            tmp = (uint16_t) rdc;
+            axp_write(charger->master,0xBB,tmp & 0x00FF);
+            axp_update(charger->master, 0xBA, (tmp >> 8), 0x1F);
+            axp_clr_bits(charger->master,AXP20_CAP,0x80);
+            axp_set_bits(charger->master,0x04,0x80);
+            DBG_PSY_MSG("==============================rdc = %d\n",rdc * 10742 / 10000);
+            count_rdc = 0;
+        }
+        else if((((v[1] >> 7) == 0) || (((v[1] >> 3) & 0x1) == 0)) && count_rdc < 3){
+        	DBG_PSY_MSG("==============================%d\n",__LINE__);
+            count_rdc ++;  
+        }
+        else{
+            DBG_PSY_MSG("==============================%d\n",__LINE__);
+            count_rdc = 0; 
+        }
+    }
+    else{
+        count_rdc = 0;
+     	DBG_PSY_MSG("==============================%d\n",__LINE__);   
+    }
+    
+	if(flag_state_change){
+    	rt_rest_vol = charger->rest_vol;
+    	rest_vol = charger->rest_vol;
+    	flag_state_change = 0;
+    }
+    else{
+    	axp_read(charger->master, AXP20_CAP,&val);
+    	rt_rest_vol = (int) (val & 0x7F);
+  		if((charger->bat_det == 0) || (rt_rest_vol == 127) ){
+  			rt_rest_vol = 100;
+  		}
+
+    	Total_Cap -= Bat_Cap_Buffer[Cap_Index];
+    	if(Cap_Index == 0){
+    		cap_index_p = AXP20_VOL_MAX - 1;
+    	}
+    	else{
+    		cap_index_p = Cap_Index - 1;
+    	}
+    	if(ABS(rt_rest_vol - Bat_Cap_Buffer[cap_index_p]) > 5){
+    		DBG_PSY_MSG("-----------correct rdc-----------\n");
+    		axp_clr_bits(charger->master,0x04,0x08);
+    	}
+
+    	Bat_Cap_Buffer[Cap_Index] = rt_rest_vol;
+    	Total_Cap += Bat_Cap_Buffer[Cap_Index];
+    	Cap_Index++;
+    	if(Cap_Index == AXP20_VOL_MAX){
+        	Cap_Index = 0;
+    	}
+
+    	rest_vol = (Total_Cap + AXP20_VOL_MAX / 2 ) / AXP20_VOL_MAX;
+
+#if DBG_AXP_PSY
+    	for(k = 0;k < AXP20_VOL_MAX ; k++){
+        	DBG_PSY_MSG("Bat_Cap_Buffer[%d] = %d\n",k,Bat_Cap_Buffer[k]);
+    	}
+#endif
+
+    	DBG_PSY_MSG("Before Modify:Cap_Index = %d,val = 0x%x,pre_rest_vol = %d,rest_vol = %d\n",Cap_Index,val,pre_rest_vol,rest_vol);
+
+    	if(charger->is_on && (rest_vol < pre_rest_vol)){
+        	rest_vol = pre_rest_vol;
+    	}
+   		else if(!charger->ext_valid && (rest_vol > pre_rest_vol)){
+        	rest_vol = pre_rest_vol;
+    	}
+
+    	DBG_PSY_MSG("After Modify:val = 0x%x,pre_rest_vol = %d,rest_vol = %d\n",val,pre_rest_vol,rest_vol);
+
+    	/* full */
+    	if(charger->ocv >= 4100 && !charger->is_on && charger->ext_valid && charger->charge_on){
+        rest_vol = 100;
+        for(k = 0;k < AXP20_VOL_MAX; k++){
+            Bat_Cap_Buffer[k] = rest_vol;
+        }
+        Total_Cap = rest_vol * AXP20_VOL_MAX;
+        charger->bat_current_direction = 1;
+        if(charger->rest_vol < 100)
+        	axp_set_bits(charger->master,0x32,0x38);
+    	}
+
+    	/* charging*/
+    	if(charger->is_on && rest_vol == 100){
+        rest_vol = 99;
+    	}
+
+
+			if(rest_vol > pre_rest_vol){
+				if(counter >= 3){
+					charger->rest_vol ++;
+					counter = 0;
+				} else
+					counter ++;
+			} else if(rest_vol < pre_rest_vol){
+				if(counter >= 3){
+					charger->rest_vol --;
+					counter = 0;
+				} else
+					counter ++;
+			} else
+				counter = 0;
+		}
+
+		if(pmu_usbcur_limit){
+			axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+			var = pmu_usbcur * 1000;
+			if(var == 900000)
+				axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+			else if (var == 500000){
+				axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+				axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+ 			}
+			else if (var == 100000){
+				axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+				axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+			}
+		}
+		else
+			axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+
+		if((count_dis >= 8) && (charger->disvbat != 0)){
+			charger->disvbat = 0;
+			charger->disibat = 0;
+			count_dis = 0;
+		}
+		if(charger->bat_current_direction == 1){
+			count_dis++;
+		} else
+			count_dis = 0;
+			
+		
+#if  DBG_AXP_PSY
+ 		DBG_PSY_MSG("charger->ic_temp = %d\n",charger->ic_temp);
+ 		DBG_PSY_MSG("charger->vbat = %d\n",charger->vbat);
+ 		DBG_PSY_MSG("charger->ibat = %d\n",charger->ibat);
+ 		DBG_PSY_MSG("charger->vusb = %d\n",charger->vusb);
+ 		DBG_PSY_MSG("charger->iusb = %d\n",charger->iusb);
+ 		DBG_PSY_MSG("charger->vac = %d\n",charger->vac);
+ 		DBG_PSY_MSG("charger->iac = %d\n",charger->iac);
+ 		DBG_PSY_MSG("charger->ocv = %d\n",charger->ocv);
+ 		DBG_PSY_MSG("charger->disvbat = %d\n",charger->disvbat);
+ 		DBG_PSY_MSG("charger->disibat = %d\n",charger->disibat);
+ 		DBG_PSY_MSG("rt_rest_vol = %d\n",rt_rest_vol);
+ 		DBG_PSY_MSG("rest_vol = %d\n",rest_vol);
+ 		DBG_PSY_MSG("charger->rest_vol = %d\n",charger->rest_vol);
+ 		axp_reads(charger->master,0xba,2,v);
+ 		rdc = (((v[0] & 0x1F) << 8) | v[1]) * 10742 / 10000;
+ 		DBG_PSY_MSG("rdc = %d\n",rdc);
+ 		DBG_PSY_MSG("charger->is_on = %d\n",charger->is_on);
+ 		DBG_PSY_MSG("charger->charge_on = %d\n",charger->charge_on);
+ 		DBG_PSY_MSG("charger->ext_valid = %d\n",charger->ext_valid);
+#endif
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+		if(pmu_used2){
+			gpio_adp_val = gpio_read_one_pin_value(gpio_adp_hdle,"pmu_adpdet");
+			DBG_PSY_MSG("GPIO->H2 = %d\n",gpio_adp_val);
+  		if(!gpio_adp_val){
+  			ret = script_parser_fetch("pmu_para", "pmu_init_chgcur2", &pmu_init_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_init_chgcur = INTCHGCUR / 1000;
+      	}
+      	pmu_init_chgcur = pmu_init_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_earlysuspend_chgcur2", &pmu_earlysuspend_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_earlysuspend_chgcur = SUSCHGCUR / 1000;
+      	}
+      	pmu_earlysuspend_chgcur = pmu_earlysuspend_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_suspend_chgcur2", &pmu_suspend_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_suspend_chgcur = SUSCHGCUR / 1000;
+      	}
+      	pmu_suspend_chgcur = pmu_suspend_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_resume_chgcur2", &pmu_resume_chgcur, sizeof(int));
+      	if (ret){
+        	printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_resume_chgcur = RESCHGCUR / 1000;
+      	}
+     		pmu_resume_chgcur = pmu_resume_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_shutdown_chgcur2", &pmu_shutdown_chgcur, sizeof(int));
+      	if (ret){
+        	printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_shutdown_chgcur = CLSCHGCUR / 1000;
+      	}
+      	pmu_shutdown_chgcur = pmu_shutdown_chgcur * 1000;
+  		}
+  		else{
+  			ret = script_parser_fetch("pmu_para", "pmu_init_chgcur", &pmu_init_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_init_chgcur = INTCHGCUR / 1000;
+      	}
+      	pmu_init_chgcur = pmu_init_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_earlysuspend_chgcur", &pmu_earlysuspend_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_earlysuspend_chgcur = SUSCHGCUR / 1000;
+      	}
+      	pmu_earlysuspend_chgcur = pmu_earlysuspend_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_suspend_chgcur", &pmu_suspend_chgcur, sizeof(int));
+      	if (ret){
+      		printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_suspend_chgcur = SUSCHGCUR / 1000;
+      	}
+      	pmu_suspend_chgcur = pmu_suspend_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_resume_chgcur", &pmu_resume_chgcur, sizeof(int));
+      	if (ret){
+        	printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_resume_chgcur = RESCHGCUR / 1000;
+      	}
+      	pmu_resume_chgcur = pmu_resume_chgcur * 1000;
+      	ret = script_parser_fetch("pmu_para", "pmu_shutdown_chgcur", &pmu_shutdown_chgcur, sizeof(int));
+      	if (ret){
+        	printk("axp driver uning configuration failed(%d)\n", __LINE__);
+        	pmu_shutdown_chgcur = CLSCHGCUR / 1000;
+      	}
+      	pmu_shutdown_chgcur = pmu_shutdown_chgcur * 1000;
+  		}
+
+
+#if defined CONFIG_HAS_EARLYSUSPEND
+  		 	if(early_suspend_flag){
+  		 			if(pmu_earlysuspend_chgcur == 0){
+  		 				axp_clr_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  		 			}
+  		 			else if(pmu_earlysuspend_chgcur >= 300000 && pmu_init_chgcur <= 1800000){
+  		 			  axp_set_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+							tmp = (pmu_earlysuspend_chgcur -200001)/100000;
+							charger->chgcur = tmp *100000 + 300000;
+							axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp, 0x0F);
+						}
+  		 	}else
+#endif
+			{
+				if(pmu_init_chgcur == 0){
+					axp_clr_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+				}
+				else if (pmu_init_chgcur >= 300000 && pmu_init_chgcur <= 1800000){
+					axp_set_bits(axp_charger->master,AXP20_CHARGE_CONTROL1,0x80);
+    			tmp = (pmu_init_chgcur -200001)/100000;
+    			charger->chgcur = tmp *100000 + 300000;
+					axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp, 0x0F);
+    		}
+  		}
+
+  	}
+#endif
+
+		DBG_PSY_MSG("pmu_init_chgcur           = %d\n",pmu_init_chgcur);
+		DBG_PSY_MSG("pmu_earlysuspend_chgcur   = %d\n",pmu_earlysuspend_chgcur);
+		DBG_PSY_MSG("pmu_suspend_chgcur        = %d\n",pmu_suspend_chgcur);
+		DBG_PSY_MSG("pmu_resume_chgcur         = %d\n",pmu_resume_chgcur);
+		DBG_PSY_MSG("pmu_shutdown_chgcur               = %d\n",pmu_shutdown_chgcur);
+
+    /* if battery volume changed, inform uevent */
+    if(charger->rest_vol - pre_rest_vol){
+        DBG_PSY_MSG("battery vol change: %d->%d \n", pre_rest_vol, charger->rest_vol);
+        pre_rest_vol = charger->rest_vol;
+        axp_write(charger->master,AXP20_DATA_BUFFER1,charger->rest_vol | 0x80);
+        if(charger->rest_vol == 100){
+        	axp_clr_bits(charger->master,0x32,0x38);
+        }
+        power_supply_changed(&charger->batt);
+    }
+
+    /* reschedule for the next time */
+    schedule_delayed_work(&charger->work, charger->interval);
+}
+
+static int axp_battery_probe(struct platform_device *pdev)
+{
+  struct axp_charger *charger;
+  struct axp_supply_init_data *pdata = pdev->dev.platform_data;
+  int ret,k,var;
+  uint8_t val1,val2,tmp,val;
+  uint8_t ocv_cap[31],v[2];
+  int Cur_CoulombCounter,rdc;
+
+  powerkeydev = input_allocate_device();
+  if (!powerkeydev) {
+    kfree(powerkeydev);
+    return -ENODEV;
+  }
+
+  powerkeydev->name = pdev->name;
+  powerkeydev->phys = "m1kbd/input2";
+  powerkeydev->id.bustype = BUS_HOST;
+  powerkeydev->id.vendor = 0x0001;
+  powerkeydev->id.product = 0x0001;
+  powerkeydev->id.version = 0x0100;
+  powerkeydev->open = NULL;
+  powerkeydev->close = NULL;
+  powerkeydev->dev.parent = &pdev->dev;
+
+  set_bit(EV_KEY, powerkeydev->evbit);
+  set_bit(EV_REL, powerkeydev->evbit);
+  //set_bit(EV_REP, powerkeydev->evbit);
+  set_bit(KEY_POWER, powerkeydev->keybit);
+
+  ret = input_register_device(powerkeydev);
+  if(ret) {
+    DBG_PSY_MSG("Unable to Register the power key\n");
+    }
+
+  if (pdata == NULL)
+    return -EINVAL;
+
+  if (pdata->chgcur > 1800000 ||
+      pdata->chgvol < 4100000 ||
+      pdata->chgvol > 4360000){
+        DBG_PSY_MSG("charger milliamp is too high or target voltage is over range\n");
+        return -EINVAL;
+    }
+
+  if (pdata->chgpretime < 40 || pdata->chgpretime >70 ||
+    pdata->chgcsttime < 360 || pdata->chgcsttime > 720){
+            DBG_PSY_MSG("prechaging time or constant current charging time is over range\n");
+        return -EINVAL;
+  }
+
+  charger = kzalloc(sizeof(*charger), GFP_KERNEL);
+  if (charger == NULL)
+    return -ENOMEM;
+
+  charger->master = pdev->dev.parent;
+
+  charger->chgcur      = pdata->chgcur;
+  charger->chgvol     = pdata->chgvol;
+  charger->chgend           = pdata->chgend;
+  charger->sample_time          = pdata->sample_time;
+  charger->chgen                   = pdata->chgen;
+  charger->chgpretime      = pdata->chgpretime;
+  charger->chgcsttime = pdata->chgcsttime;
+  charger->battery_info         = pdata->battery_info;
+  charger->disvbat			= 0;
+  charger->disibat			= 0;
+
+  ret = axp_battery_first_init(charger);
+  if (ret)
+    goto err_charger_init;
+
+  charger->nb.notifier_call = axp_battery_event;
+  ret = axp_register_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+  if (ret)
+    goto err_notifier;
+
+  axp_battery_setup_psy(charger);
+  ret = power_supply_register(&pdev->dev, &charger->batt);
+  if (ret)
+    goto err_ps_register;
+
+	axp_read(charger->master,AXP20_CHARGE_STATUS,&val);
+	if(!((val >> 1) & 0x01)){
+  	ret = power_supply_register(&pdev->dev, &charger->ac);
+  	if (ret){
+    	power_supply_unregister(&charger->batt);
+    	goto err_ps_register;
+  	}
+  }
+  ret = power_supply_register(&pdev->dev, &charger->usb);
+  if (ret){
+    power_supply_unregister(&charger->ac);
+    power_supply_unregister(&charger->batt);
+    goto err_ps_register;
+  }
+
+  ret = axp_charger_create_attrs(&charger->batt);
+  if(ret){
+    return ret;
+  }
+
+
+  platform_set_drvdata(pdev, charger);
+
+  /* initial restvol*/
+
+  /* usb current and voltage limit */
+  if(pmu_usbvol_limit){
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x40);
+  	var = pmu_usbvol * 1000;
+  	if(var >= 4000000 && var <=4700000){
+    	tmp = (var - 4000000)/100000;
+    	axp_read(charger->master, AXP20_CHARGE_VBUS,&val);
+    	val &= 0xC7;
+    	val |= tmp << 3;
+    	axp_write(charger->master, AXP20_CHARGE_VBUS,val);
+  	}
+  }
+  else
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x40);
+
+  if(pmu_usbcur_limit){
+    axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+    var = pmu_usbcur * 1000;
+  	if(var == 900000)
+    	axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+  	else if (var == 500000){
+    	axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+    	axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+  	}
+  	else if (var == 100000){
+    	axp_clr_bits(charger->master, AXP20_CHARGE_VBUS, 0x01);
+    	axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x02);
+  	}
+  }
+  else
+    axp_set_bits(charger->master, AXP20_CHARGE_VBUS, 0x03);
+
+
+  /* set lowe power warning/shutdown voltage*/
+  var = script_parser_fetch("pmu_para", "pmu_suspendpwroff_vol", &pmu_suspendpwroff_vol, sizeof(int));
+  if (var)
+  {
+     printk("[AXP]axp driver uning configuration failed(%d)\n", __LINE__);
+     pmu_suspendpwroff_vol = 3500;
+     printk("[AXP]pmu_suspendpwroff_vol = %d\n",pmu_suspendpwroff_vol);
+  }
+  pmu_suspendpwroff_vol = pmu_suspendpwroff_vol * 1000;
+	
+	if(pmu_suspendpwroff_vol >= 2867200 && pmu_suspendpwroff_vol <= 4200000){
+		val = (pmu_suspendpwroff_vol - 2867200) / 5600;	
+	}
+
+  /* 3.5552V--%5 close*/
+  axp_write(charger->master, AXP20_APS_WARNING1,val);
+  axp_write(charger->master, AXP20_APS_WARNING2,(val - 0x0a));
+  ocv_cap[0]  = pmu_bat_para1;
+  ocv_cap[1]  = 0xC1;
+  ocv_cap[2]  = pmu_bat_para2;
+  ocv_cap[3]  = 0xC2;
+  ocv_cap[4]  = pmu_bat_para3;
+  ocv_cap[5]  = 0xC3;
+  ocv_cap[6]  = pmu_bat_para4;
+  ocv_cap[7]  = 0xC4;
+  ocv_cap[8]  = pmu_bat_para5;
+  ocv_cap[9]  = 0xC5;
+  ocv_cap[10] = pmu_bat_para6;
+  ocv_cap[11] = 0xC6;
+  ocv_cap[12] = pmu_bat_para7;
+  ocv_cap[13] = 0xC7;
+  ocv_cap[14] = pmu_bat_para8;
+  ocv_cap[15] = 0xC8;
+  ocv_cap[16] = pmu_bat_para9;
+  ocv_cap[17] = 0xC9;
+  ocv_cap[18] = pmu_bat_para10;
+  ocv_cap[19] = 0xCA;
+  ocv_cap[20] = pmu_bat_para11;
+  ocv_cap[21] = 0xCB;
+  ocv_cap[22] = pmu_bat_para12;
+  ocv_cap[23] = 0xCC;
+  ocv_cap[24] = pmu_bat_para13;
+  ocv_cap[25] = 0xCD;
+  ocv_cap[26] = pmu_bat_para14;
+  ocv_cap[27] = 0xCE;
+  ocv_cap[28] = pmu_bat_para15;
+  ocv_cap[29] = 0xCF;
+  ocv_cap[30] = pmu_bat_para16;
+  axp_writes(charger->master, 0xC0,31,ocv_cap);
+
+  /* open/close set */
+  DBG_PSY_MSG("pmu_pekoff_time = %d\n",pmu_pekoff_time);
+  DBG_PSY_MSG("pmu_pekoff_en = %d\n",pmu_pekoff_en);
+  DBG_PSY_MSG("pmu_peklong_time = %d\n",pmu_peklong_time);
+  DBG_PSY_MSG("pmu_pekon_time = %d\n",pmu_pekon_time);
+  DBG_PSY_MSG("pmu_pwrok_time = %d\n",pmu_pwrok_time);
+  DBG_PSY_MSG("pmu_pwrnoe_time = %d\n",pmu_pwrnoe_time);
+  DBG_PSY_MSG("pmu_intotp_en = %d\n",pmu_intotp_en);
+
+  /* n_oe delay time set */
+	if (pmu_pwrnoe_time < 1000)
+		pmu_pwrnoe_time = 128;
+	if (pmu_pwrnoe_time > 3000)
+		pmu_pwrnoe_time = 3000;
+	axp_read(charger->master,POWER20_OFF_CTL,&val);
+	val &= 0xfc;
+	val |= ((pmu_pwrnoe_time) / 1000);
+	axp_write(charger->master,POWER20_OFF_CTL,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek open time set */
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	if (pmu_pekon_time < 1000)
+		val &= 0x3f;
+	else if(pmu_pekon_time < 2000){
+		val &= 0x3f;
+		val |= 0x80;
+	}
+	else if(pmu_pekon_time < 3000){
+		val &= 0x3f;
+		val |= 0xc0;
+	}
+	else {
+		val &= 0x3f;
+		val |= 0x40;
+	}
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek long time set*/
+	if(pmu_peklong_time < 1000)
+		pmu_peklong_time = 1000;
+	if(pmu_peklong_time > 2500)
+		pmu_peklong_time = 2500;
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	val &= 0xcf;
+	val |= (((pmu_peklong_time - 1000) / 500) << 4);
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek en set*/
+	if(pmu_pekoff_en)
+		pmu_pekoff_en = 1;
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	val &= 0xf7;
+	val |= (pmu_pekoff_en << 3);
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek delay set */
+	if(pmu_pwrok_time <= 8)
+		pmu_pwrok_time = 0;
+	else
+		pmu_pwrok_time = 1;
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	val &= 0xfb;
+	val |= pmu_pwrok_time << 2;
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* pek off time set */
+	if(pmu_pekoff_time < 4000)
+		pmu_pekoff_time = 4000;
+	if(pmu_pekoff_time > 10000)
+		pmu_pekoff_time =10000;
+	pmu_pekoff_time = (pmu_pekoff_time - 4000) / 2000 ;
+	axp_read(charger->master,POWER20_PEK_SET,&val);
+	val &= 0xfc;
+	val |= pmu_pekoff_time ;
+	axp_write(charger->master,POWER20_PEK_SET,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+
+	/* enable overtemperture off */
+	if(pmu_intotp_en)
+		pmu_intotp_en = 1;
+	axp_read(charger->master,POWER20_HOTOVER_CTL,&val);
+	val &= 0xfb;
+	val |= pmu_intotp_en << 2;
+	axp_write(charger->master,POWER20_HOTOVER_CTL,val);
+	DBG_PSY_MSG("%d-->0x%x\n",__LINE__,val);
+	
+	/* disable */
+  axp_set_bits(charger->master,AXP20_CAP,0x80);
+  axp_clr_bits(charger->master,0xBA,0x80);
+  axp_reads(charger->master,0xbA,2,v);
+  rdc = (((v[0] & 0x1F) << 8) | v[1]) * 10742 / 10000;
+  axp_read(charger->master,AXP20_DATA_BUFFER0,&val1);
+  if((((val1 >> 7) & 0x1) == 0)||(rdc > pmu_battery_rdc * 2)){
+  	rdc = (pmu_battery_rdc * 10000 + 5371) / 10742;
+  	axp_write(charger->master,0xBB,rdc & 0x00FF);
+  	axp_update(charger->master, 0xBA, (rdc >> 8), 0x1F);
+  }
+  axp_clr_bits(charger->master,AXP20_CAP,0x80);
+
+  axp_set_bits(charger->master,0x8F,0x88);
+  axp_clr_bits(charger->master,0x81,0x04);
+
+	axp_charger_update_state(charger);
+
+  axp_read(charger->master,AXP20_DATA_BUFFER1,&val1);
+  charger->rest_vol = (int) (val1 & 0x7F);
+
+  axp_read(charger->master, AXP20_CAP,&val2);
+
+  Cur_CoulombCounter = ABS(Get_Bat_Coulomb_Count(charger));
+  DBG_PSY_MSG("Cur_CoulombCounter = %d\n",Cur_CoulombCounter);
+  //if(ABS(charger->rest_vol-(val2 & 0x7F)) >= 3 && (val1 >> 7)){
+  if(ABS(charger->rest_vol-(val2 & 0x7F)) >= 10 || Cur_CoulombCounter > 50){
+    charger->rest_vol = (int) (val2 & 0x7F);
+  }
+  if((charger->bat_det == 0) || (charger->rest_vol == 127)){
+  	charger->rest_vol = 100;
+  }
+
+  DBG_PSY_MSG("last_rest_vol = %d, now_rest_vol = %d\n",(val1 & 0x7F),(val2 & 0x7F));
+  memset(Bat_Cap_Buffer, 0, sizeof(Bat_Cap_Buffer));
+  for(k = 0;k < AXP20_VOL_MAX; k++){
+    Bat_Cap_Buffer[k] = charger->rest_vol;
+  }
+  Total_Cap = charger->rest_vol * AXP20_VOL_MAX;
+
+  charger->interval = msecs_to_jiffies(10 * 1000);
+  INIT_DELAYED_WORK(&charger->work, axp_charging_monitor);
+  schedule_delayed_work(&charger->work, charger->interval);
+
+  var = script_parser_fetch("pmu_para", "pmu_used2", &pmu_used2, sizeof(int));
+  if (var)
+  {
+     DBG_PSY_MSG("axp driver uning configuration failed(%d)\n", __LINE__);
+     DBG_PSY_MSG("pmu_used2 = %d\n",pmu_used2);
+  }
+
+  var = script_parser_fetch("pmu_para", "pmu_earlysuspend_chgcur", &pmu_earlysuspend_chgcur, sizeof(int));
+  if (var)
+  {
+     DBG_PSY_MSG("axp driver uning configuration failed(%d)\n", __LINE__);
+     pmu_earlysuspend_chgcur = pmu_suspend_chgcur / 1000;
+     DBG_PSY_MSG("pmu_earlysuspend_chgcur = %d\n",pmu_earlysuspend_chgcur);
+  }
+  pmu_earlysuspend_chgcur = pmu_earlysuspend_chgcur * 1000;
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+  if(pmu_used2){
+  	gpio_adp_hdle = gpio_request_ex("pmu_para", "pmu_adpdet");
+  	if (!gpio_adp_hdle)
+    {
+        DBG_PSY_MSG("get adapter parameter failed\n");
+    }
+  }
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	axp_charger = charger;
+    axp_early_suspend.suspend = axp_earlysuspend;
+    axp_early_suspend.resume = axp_lateresume;
+    axp_early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 2;
+    register_early_suspend(&axp_early_suspend);
+#endif
+
+  return ret;
+
+err_ps_register:
+  axp_unregister_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+
+err_notifier:
+  cancel_delayed_work_sync(&charger->work);
+
+err_charger_init:
+  kfree(charger);
+  input_unregister_device(powerkeydev);
+  kfree(powerkeydev);
+
+  return ret;
+}
+
+static int axp_battery_remove(struct platform_device *dev)
+{
+    struct axp_charger *charger = platform_get_drvdata(dev);
+
+    if(main_task){
+        kthread_stop(main_task);
+        main_task = NULL;
+    }
+
+    axp_unregister_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+    cancel_delayed_work_sync(&charger->work);
+    power_supply_unregister(&charger->usb);
+    power_supply_unregister(&charger->ac);
+    power_supply_unregister(&charger->batt);
+
+    kfree(charger);
+    input_unregister_device(powerkeydev);
+    kfree(powerkeydev);
+
+    return 0;
+}
+
+
+static int axp20_suspend(struct platform_device *dev, pm_message_t state)
+{
+    uint8_t irq_w[9];
+    uint8_t tmp;
+
+    struct axp_charger *charger = platform_get_drvdata(dev);
+
+
+	cancel_delayed_work_sync(&charger->work);
+
+    /*clear all irqs events*/
+    irq_w[0] = 0xff;
+    irq_w[1] = POWER20_INTSTS2;
+    irq_w[2] = 0xff;
+    irq_w[3] = POWER20_INTSTS3;
+    irq_w[4] = 0xff;
+    irq_w[5] = POWER20_INTSTS4;
+    irq_w[6] = 0xff;
+    irq_w[7] = POWER20_INTSTS5;
+    irq_w[8] = 0xff;
+    axp_writes(charger->master, POWER20_INTSTS1, 9, irq_w);
+
+    /* close all irqs*/
+    axp_unregister_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+		if(pmu_suspend_chgcur == 0)
+  		axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  	else
+  		axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+  	DBG_PSY_MSG("pmu_suspend_chgcur = %d\n", pmu_suspend_chgcur);
+
+    if(pmu_suspend_chgcur >= 300000 && pmu_suspend_chgcur <= 1800000){
+    tmp = (pmu_suspend_chgcur -200001)/100000;
+    charger->chgcur = tmp *100000 + 300000;
+    axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
+#endif
+		/* timer */
+		axp_write(charger->master, 0x8A, 0x80);
+		axp_write(charger->master, 0x8A, 0x02);
+
+		/* clear and enable coulomb */
+		tmp = 0xff;
+		axp_read(charger->master, POWER20_COULOMB_CTL, &tmp);
+
+		//tmp |= 0x20;
+		tmp &= 0x3f;
+
+		axp_write(charger->master, POWER20_COULOMB_CTL, tmp);
+		tmp |= 0x80;
+		tmp &= 0xbf;
+
+		axp_write(charger->master, POWER20_COULOMB_CTL, tmp);
+
+		
+    return 0;
+}
+
+static int axp20_resume(struct platform_device *dev)
+{
+    struct axp_charger *charger = platform_get_drvdata(dev);
+
+    int pre_rest_vol,k;
+    uint8_t val,val1,tmp;
+    uint8_t v[2];
+    int rt_rest_vol;
+    int Cur_CoulombCounter;
+
+    axp_register_notifier(charger->master, &charger->nb, AXP20_NOTIFIER_ON);
+
+    axp_charger_update_state(charger);
+
+    axp_reads(charger->master,0xbc,2,v);
+ 		charger->ocv = ((v[0] << 4) + (v[1] & 0x0f)) * 11 /10 ;
+
+    axp_read(charger->master, 0x8A, &val1);
+		pre_rest_vol = charger->rest_vol;
+
+		axp_read(charger->master, AXP20_CAP,&val);
+
+		Cur_CoulombCounter = ABS(Get_Bat_Coulomb_Count(charger));
+
+    if((val1 >> 7)){
+    	charger->rest_vol = (int) (val & 0x7F);
+  		if((charger->bat_det == 0) || (charger->rest_vol == 127)){
+  			charger->rest_vol = 100;
+  		}
+
+  		if ((Cur_CoulombCounter <= 5) && (charger->rest_vol > pre_rest_vol)){
+  			charger->rest_vol = pre_rest_vol;
+  		}
+
+  		if( ((pre_rest_vol - charger->rest_vol) < 10) && (pre_rest_vol > charger->rest_vol )){
+  			charger->rest_vol = --pre_rest_vol;
+  		}
+
+    if(charger->is_on && (charger->rest_vol < pre_rest_vol)){
+        charger->rest_vol = pre_rest_vol;
+    }
+
+    DBG_PSY_MSG("val = 0x%x,pre_rest_vol = %d,rest_vol = %d\n",val,pre_rest_vol,charger->rest_vol);
+
+    	/* full */
+    	if((charger->ocv) >= 4100 && !charger->is_on && charger->ext_valid && charger->charge_on){
+        charger->rest_vol = 100;
+    }
+
+    /* charging*/
+    if(charger->is_on && charger->rest_vol == 100){
+        charger->rest_vol = 99;
+    }
+
+    memset(Bat_Cap_Buffer, 0, sizeof(Bat_Cap_Buffer));
+    for(k = 0;k < AXP20_VOL_MAX; k++){
+        Bat_Cap_Buffer[k] = charger->rest_vol;
+    	}
+    	Total_Cap = charger->rest_vol * AXP20_VOL_MAX;
+		}
+		else if (charger->ext_valid && charger->charge_on){
+		  rt_rest_vol = (int) (val & 0x7F);
+			if((pre_rest_vol < 99) && (rt_rest_vol > pre_rest_vol)){
+				charger->rest_vol ++;
+			}
+		}
+
+    /* if battery volume changed, inform uevent */
+    if(charger->rest_vol - pre_rest_vol){
+        DBG_PSY_MSG("battery vol change: %d->%d \n", pre_rest_vol, charger->rest_vol);
+        pre_rest_vol = charger->rest_vol;
+        axp_write(charger->master,AXP20_DATA_BUFFER1,charger->rest_vol | 0x80);
+        if(charger->rest_vol == 100){
+        	axp_clr_bits(charger->master,0x32,0x38);
+        }
+        power_supply_changed(&charger->batt);
+    }
+	
+	axp_read(charger->master, 0x0e,&val);
+	printk("[AXP]=======================val = 0x%x\n",val);
+	if(val){
+		axp_close(charger);
+		axp_set_bits(charger->master,0x4b,0x03);
+	}
+	axp_write(charger->master, 0x0e,0x00);
+#if defined (CONFIG_AXP_CHGCHANGE)
+  	if(pmu_resume_chgcur == 0)
+  		axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  	else
+  		axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+  	DBG_PSY_MSG("pmu_resume_chgcur = %d\n", pmu_resume_chgcur);
+
+    if(pmu_resume_chgcur >= 300000 && pmu_resume_chgcur <= 1800000){
+        tmp = (pmu_resume_chgcur -200001)/100000;
+        charger->chgcur = tmp *100000 + 300000;
+        axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp,0x0F);
+    }
+#endif
+
+	charger->disvbat = 0;
+	charger->disibat = 0;
+    schedule_delayed_work(&charger->work, charger->interval);
+
+    return 0;
+}
+
+static void axp20_shutdown(struct platform_device *dev)
+{
+    uint8_t tmp;
+    struct axp_charger *charger = platform_get_drvdata(dev);
+    
+    cancel_delayed_work_sync(&charger->work);
+  	axp_clr_bits(charger->master,AXP20_CAP,0x80);
+
+#if defined (CONFIG_AXP_CHGCHANGE)
+  	if(pmu_shutdown_chgcur == 0)
+  		axp_clr_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+  	else
+  		axp_set_bits(charger->master,AXP20_CHARGE_CONTROL1,0x80);
+
+		DBG_PSY_MSG("pmu_shutdown_chgcur = %d\n", pmu_shutdown_chgcur);
+
+    if(pmu_shutdown_chgcur >= 300000 && pmu_shutdown_chgcur <= 1800000){
+    	tmp = (pmu_shutdown_chgcur -200001)/100000;
+    	charger->chgcur = tmp *100000 + 300000;
+    	axp_update(charger->master, AXP20_CHARGE_CONTROL1, tmp, 0x0F);
+    }
+#endif
+}
+
+static struct platform_driver axp_battery_driver = {
+  .driver = {
+    .name = "axp20-supplyer",
+    .owner  = THIS_MODULE,
+  },
+  .probe = axp_battery_probe,
+  .remove = axp_battery_remove,
+  .suspend = axp20_suspend,
+  .resume = axp20_resume,
+  .shutdown = axp20_shutdown,
+};
+
+static int axp_battery_init(void)
+{
+  return platform_driver_register(&axp_battery_driver);
+}
+
+static void axp_battery_exit(void)
+{
+  platform_driver_unregister(&axp_battery_driver);
+}
+
+module_init(axp_battery_init);
+module_exit(axp_battery_exit);
+
+MODULE_DESCRIPTION("axp20 battery charger driver");
+MODULE_AUTHOR("Donglu Zhang, Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/virtual18.c b/drivers/power/axp_power/virtual18.c
new file mode 100644
index 0000000..78d19d1
--- /dev/null
+++ b/drivers/power/axp_power/virtual18.c
@@ -0,0 +1,412 @@
+/*
+ * reg-virtual-consumer.c
+ *
+ * Copyright 2008 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+struct virtual_consumer_data {
+	struct mutex lock;
+	struct regulator *regulator;
+	int enabled;
+	int min_uV;
+	int max_uV;
+	int min_uA;
+	int max_uA;
+	unsigned int mode;
+};
+
+static void update_voltage_constraints(struct virtual_consumer_data *data)
+{
+	int ret;
+
+	if (data->min_uV && data->max_uV
+	    && data->min_uV <= data->max_uV) {
+		ret = regulator_set_voltage(data->regulator,
+					    data->min_uV, data->max_uV);
+		if (ret != 0) {
+			printk(KERN_ERR "regulator_set_voltage() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->min_uV && data->max_uV && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uV && data->max_uV) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static void update_current_limit_constraints(struct virtual_consumer_data
+						*data)
+{
+	int ret;
+
+	if (data->max_uA
+	    && data->min_uA <= data->max_uA) {
+		ret = regulator_set_current_limit(data->regulator,
+					data->min_uA, data->max_uA);
+		if (ret != 0) {
+			pr_err("regulator_set_current_limit() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->max_uA && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uA && data->max_uA) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static ssize_t show_min_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uV);
+}
+
+static ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uV);
+}
+
+static ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_min_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uA);
+}
+
+static ssize_t set_min_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uA);
+}
+
+static ssize_t set_max_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_mode(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	switch (data->mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	default:
+		return sprintf(buf, "unknown\n");
+	}
+}
+
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	unsigned int mode;
+	int ret;
+
+	if (strncmp(buf, "fast", strlen("fast")) == 0)
+		mode = REGULATOR_MODE_FAST;
+	else if (strncmp(buf, "normal", strlen("normal")) == 0)
+		mode = REGULATOR_MODE_NORMAL;
+	else if (strncmp(buf, "idle", strlen("idle")) == 0)
+		mode = REGULATOR_MODE_IDLE;
+	else if (strncmp(buf, "standby", strlen("standby")) == 0)
+		mode = REGULATOR_MODE_STANDBY;
+	else {
+		dev_err(dev, "Configuring invalid mode\n");
+		return count;
+	}
+
+	mutex_lock(&data->lock);
+	ret = regulator_set_mode(data->regulator, mode);
+	if (ret == 0)
+		data->mode = mode;
+	else
+		dev_err(dev, "Failed to configure mode: %d\n", ret);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(min_microvolts, 0666, show_min_uV, set_min_uV);
+static DEVICE_ATTR(max_microvolts, 0666, show_max_uV, set_max_uV);
+static DEVICE_ATTR(min_microamps, 0666, show_min_uA, set_min_uA);
+static DEVICE_ATTR(max_microamps, 0666, show_max_uA, set_max_uA);
+static DEVICE_ATTR(mode, 0666, show_mode, set_mode);
+
+struct device_attribute *attributes_virtual[] = {
+	&dev_attr_min_microvolts,
+	&dev_attr_max_microvolts,
+	&dev_attr_min_microamps,
+	&dev_attr_max_microamps,
+	&dev_attr_mode,
+};
+
+static int regulator_virtual_consumer_probe(struct platform_device *pdev)
+{
+	char *reg_id = pdev->dev.platform_data;
+	struct virtual_consumer_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_consumer_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
+	drvdata->regulator = regulator_get(NULL, reg_id);
+	//drvdata->regulator = regulator_get(NULL, "axp20_analog/fm");
+	if (IS_ERR(drvdata->regulator)) {
+		ret = PTR_ERR(drvdata->regulator);
+		goto err;
+	}
+	
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++) {
+		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	drvdata->mode = regulator_get_mode(drvdata->regulator);
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	kfree(drvdata);
+	return ret;
+}
+
+static int regulator_virtual_consumer_remove(struct platform_device *pdev)
+{
+	struct virtual_consumer_data *drvdata = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	if (drvdata->enabled)
+		regulator_disable(drvdata->regulator);
+	regulator_put(drvdata->regulator);
+
+	kfree(drvdata);
+
+	return 0;
+}
+
+static struct platform_driver regulator_virtual_consumer_driver[] = {
+	{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-ldo2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-ldo3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-ldo4",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-ldo5",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-buck1",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-buck2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-buck3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-sw1",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-18-cs-sw2",
+		},
+	},
+};
+
+
+static int __init regulator_virtual_consumer_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(regulator_virtual_consumer_driver); j++){ 
+		ret =  platform_driver_register(&regulator_virtual_consumer_driver[j]);
+		if (ret)
+			goto creat_drivers_failed;
+	}
+	return ret;
+		
+creat_drivers_failed:
+	while (j--)
+		platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	return ret;
+}
+module_init(regulator_virtual_consumer_init);
+
+static void __exit regulator_virtual_consumer_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(regulator_virtual_consumer_driver) - 1; j >= 0; j--){ 
+			platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	}
+}
+module_exit(regulator_virtual_consumer_exit);
+
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_DESCRIPTION("Virtual regulator consumer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/virtual18_dev.c b/drivers/power/axp_power/virtual18_dev.c
new file mode 100644
index 0000000..eca3713
--- /dev/null
+++ b/drivers/power/axp_power/virtual18_dev.c
@@ -0,0 +1,127 @@
+/*
+ * drivers/power/axp_power/virtual18_dev.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/axp-mfd.h>
+
+
+#include "axp-cfg.h"
+
+
+static struct platform_device virt[]={
+	{
+			.name = "reg-18-cs-ldo2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_analog/fm",
+			}
+ 	},{
+			.name = "reg-18-cs-ldo3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_flash",
+			}
+ 	},{
+			.name = "reg-18-cs-ldo4",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_spdif",
+			}
+ 	},{
+			.name = "reg-18-cs-ldo5",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_others",
+			}
+ 	},{
+			.name = "reg-18-cs-buck1",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_io",
+			}
+ 	},{
+			.name = "reg-18-cs-buck2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_core",
+			}
+ 	},{
+			.name = "reg-18-cs-buck3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_memory",
+			}
+	},{
+			.name = "reg-18-cs-sw1",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_sdram",
+			}
+	},{
+			.name = "reg-18-cs-sw2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp18_sdcard",
+			}
+	},
+};
+
+
+
+ static int __init virtual_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(virt); j++){
+ 		ret =  platform_device_register(&virt[j]);
+  		if (ret)
+				goto creat_devices_failed;
+	}
+
+	return ret;
+
+creat_devices_failed:
+	while (j--)
+		platform_device_register(&virt[j]);
+	return ret;
+
+}
+
+module_init(virtual_init);
+
+static void __exit virtual_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(virt) - 1; j >= 0; j--){
+		platform_device_unregister(&virt[j]);
+	}
+}
+module_exit(virtual_exit);
+
+MODULE_DESCRIPTION("Krosspower axp regulator test");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/power/axp_power/virtual19.c b/drivers/power/axp_power/virtual19.c
new file mode 100644
index 0000000..05a7871
--- /dev/null
+++ b/drivers/power/axp_power/virtual19.c
@@ -0,0 +1,400 @@
+/*
+ * reg-virtual-consumer.c
+ *
+ * Copyright 2008 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+struct virtual_consumer_data {
+	struct mutex lock;
+	struct regulator *regulator;
+	int enabled;
+	int min_uV;
+	int max_uV;
+	int min_uA;
+	int max_uA;
+	unsigned int mode;
+};
+
+static void update_voltage_constraints(struct virtual_consumer_data *data)
+{
+	int ret;
+
+	if (data->min_uV && data->max_uV
+	    && data->min_uV <= data->max_uV) {
+		ret = regulator_set_voltage(data->regulator,
+					    data->min_uV, data->max_uV);
+		if (ret != 0) {
+			printk(KERN_ERR "regulator_set_voltage() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->min_uV && data->max_uV && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uV && data->max_uV) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static void update_current_limit_constraints(struct virtual_consumer_data
+						*data)
+{
+	int ret;
+
+	if (data->max_uA
+	    && data->min_uA <= data->max_uA) {
+		ret = regulator_set_current_limit(data->regulator,
+					data->min_uA, data->max_uA);
+		if (ret != 0) {
+			pr_err("regulator_set_current_limit() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->max_uA && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uA && data->max_uA) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static ssize_t show_min_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uV);
+}
+
+static ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uV);
+}
+
+static ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_min_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uA);
+}
+
+static ssize_t set_min_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uA);
+}
+
+static ssize_t set_max_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_mode(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	switch (data->mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	default:
+		return sprintf(buf, "unknown\n");
+	}
+}
+
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	unsigned int mode;
+	int ret;
+
+	if (strncmp(buf, "fast", strlen("fast")) == 0)
+		mode = REGULATOR_MODE_FAST;
+	else if (strncmp(buf, "normal", strlen("normal")) == 0)
+		mode = REGULATOR_MODE_NORMAL;
+	else if (strncmp(buf, "idle", strlen("idle")) == 0)
+		mode = REGULATOR_MODE_IDLE;
+	else if (strncmp(buf, "standby", strlen("standby")) == 0)
+		mode = REGULATOR_MODE_STANDBY;
+	else {
+		dev_err(dev, "Configuring invalid mode\n");
+		return count;
+	}
+
+	mutex_lock(&data->lock);
+	ret = regulator_set_mode(data->regulator, mode);
+	if (ret == 0)
+		data->mode = mode;
+	else
+		dev_err(dev, "Failed to configure mode: %d\n", ret);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(min_microvolts, 0666, show_min_uV, set_min_uV);
+static DEVICE_ATTR(max_microvolts, 0666, show_max_uV, set_max_uV);
+static DEVICE_ATTR(min_microamps, 0666, show_min_uA, set_min_uA);
+static DEVICE_ATTR(max_microamps, 0666, show_max_uA, set_max_uA);
+static DEVICE_ATTR(mode, 0666, show_mode, set_mode);
+
+struct device_attribute *attributes_virtual[] = {
+	&dev_attr_min_microvolts,
+	&dev_attr_max_microvolts,
+	&dev_attr_min_microamps,
+	&dev_attr_max_microamps,
+	&dev_attr_mode,
+};
+
+static int regulator_virtual_consumer_probe(struct platform_device *pdev)
+{
+	char *reg_id = pdev->dev.platform_data;
+	struct virtual_consumer_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_consumer_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
+	drvdata->regulator = regulator_get(NULL, reg_id);
+	//drvdata->regulator = regulator_get(NULL, "axp20_analog/fm");
+	if (IS_ERR(drvdata->regulator)) {
+		ret = PTR_ERR(drvdata->regulator);
+		goto err;
+	}
+	
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++) {
+		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	drvdata->mode = regulator_get_mode(drvdata->regulator);
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	kfree(drvdata);
+	return ret;
+}
+
+static int regulator_virtual_consumer_remove(struct platform_device *pdev)
+{
+	struct virtual_consumer_data *drvdata = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	if (drvdata->enabled)
+		regulator_disable(drvdata->regulator);
+	regulator_put(drvdata->regulator);
+
+	kfree(drvdata);
+
+	return 0;
+}
+
+static struct platform_driver regulator_virtual_consumer_driver[] = {
+	{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-ldo2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-ldo3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-ldo4",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-buck1",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-buck2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-buck3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-19-cs-ldoio0",
+		},
+	},
+};
+
+
+static int __init regulator_virtual_consumer_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(regulator_virtual_consumer_driver); j++){ 
+		ret =  platform_driver_register(&regulator_virtual_consumer_driver[j]);
+		if (ret)
+			goto creat_drivers_failed;
+	}
+	return ret;
+		
+creat_drivers_failed:
+	while (j--)
+		platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	return ret;
+}
+module_init(regulator_virtual_consumer_init);
+
+static void __exit regulator_virtual_consumer_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(regulator_virtual_consumer_driver) - 1; j >= 0; j--){ 
+			platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	}
+}
+module_exit(regulator_virtual_consumer_exit);
+
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_DESCRIPTION("Virtual regulator consumer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/virtual19_dev.c b/drivers/power/axp_power/virtual19_dev.c
new file mode 100644
index 0000000..55560b2
--- /dev/null
+++ b/drivers/power/axp_power/virtual19_dev.c
@@ -0,0 +1,115 @@
+/*
+ * drivers/power/axp_power/virtual19_dev.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/axp-mfd.h>
+
+
+#include "axp-cfg.h"
+
+
+static struct platform_device virt[]={
+	{
+			.name = "reg-19-cs-ldo2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_analog/fm",
+			}
+ 	},{
+			.name = "reg-19-cs-ldo3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_pll/sdram",
+			}
+ 	},{
+			.name = "reg-19-cs-ldo4",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_hdmi",
+			}
+ 	},{
+			.name = "reg-19-cs-buck1",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_io",
+			}
+ 	},{
+			.name = "reg-19-cs-buck2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_core",
+			}
+ 	},{
+			.name = "reg-19-cs-buck3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_ddr",
+			}
+	},{
+			.name = "reg-19-cs-ldoio0",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp19_mic",
+			}
+	},
+};
+
+
+
+ static int __init virtual_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(virt); j++){
+ 		ret =  platform_device_register(&virt[j]);
+  		if (ret)
+				goto creat_devices_failed;
+	}
+
+	return ret;
+
+creat_devices_failed:
+	while (j--)
+		platform_device_register(&virt[j]);
+	return ret;
+
+}
+
+module_init(virtual_init);
+
+static void __exit virtual_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(virt) - 1; j >= 0; j--){
+		platform_device_unregister(&virt[j]);
+	}
+}
+module_exit(virtual_exit);
+
+MODULE_DESCRIPTION("Krosspower axp regulator test");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/power/axp_power/virtual20.c b/drivers/power/axp_power/virtual20.c
new file mode 100644
index 0000000..746ff96
--- /dev/null
+++ b/drivers/power/axp_power/virtual20.c
@@ -0,0 +1,395 @@
+/*
+ * reg-virtual-consumer.c
+ *
+ * Copyright 2008 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+
+struct virtual_consumer_data {
+	struct mutex lock;
+	struct regulator *regulator;
+	int enabled;
+	int min_uV;
+	int max_uV;
+	int min_uA;
+	int max_uA;
+	unsigned int mode;
+};
+
+static void update_voltage_constraints(struct virtual_consumer_data *data)
+{
+	int ret;
+
+	if (data->min_uV && data->max_uV
+	    && data->min_uV <= data->max_uV) {
+		ret = regulator_set_voltage(data->regulator,
+					    data->min_uV, data->max_uV);
+		if (ret != 0) {
+			printk(KERN_ERR "regulator_set_voltage() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->min_uV && data->max_uV && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uV && data->max_uV) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static void update_current_limit_constraints(struct virtual_consumer_data
+						*data)
+{
+	int ret;
+
+	if (data->max_uA
+	    && data->min_uA <= data->max_uA) {
+		ret = regulator_set_current_limit(data->regulator,
+					data->min_uA, data->max_uA);
+		if (ret != 0) {
+			pr_err("regulator_set_current_limit() failed: %d\n",
+			       ret);
+			return;
+		}
+	}
+
+	if (data->max_uA && !data->enabled) {
+		ret = regulator_enable(data->regulator);
+		if (ret == 0)
+			data->enabled = 1;
+		else
+			printk(KERN_ERR "regulator_enable() failed: %d\n",
+				ret);
+	}
+
+	if (!(data->min_uA && data->max_uA) && data->enabled) {
+		ret = regulator_disable(data->regulator);
+		if (ret == 0)
+			data->enabled = 0;
+		else
+			printk(KERN_ERR "regulator_disable() failed: %d\n",
+				ret);
+	}
+}
+
+static ssize_t show_min_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uV);
+}
+
+static ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uV(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uV);
+}
+
+static ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uV = val;
+	update_voltage_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_min_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->min_uA);
+}
+
+static ssize_t set_min_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->min_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_max_uA(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->max_uA);
+}
+
+static ssize_t set_max_uA(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	long val;
+
+	if (strict_strtol(buf, 10, &val) != 0)
+		return count;
+
+	mutex_lock(&data->lock);
+
+	data->max_uA = val;
+	update_current_limit_constraints(data);
+
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static ssize_t show_mode(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+
+	switch (data->mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	default:
+		return sprintf(buf, "unknown\n");
+	}
+}
+
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct virtual_consumer_data *data = dev_get_drvdata(dev);
+	unsigned int mode;
+	int ret;
+
+	if (strncmp(buf, "fast", strlen("fast")) == 0)
+		mode = REGULATOR_MODE_FAST;
+	else if (strncmp(buf, "normal", strlen("normal")) == 0)
+		mode = REGULATOR_MODE_NORMAL;
+	else if (strncmp(buf, "idle", strlen("idle")) == 0)
+		mode = REGULATOR_MODE_IDLE;
+	else if (strncmp(buf, "standby", strlen("standby")) == 0)
+		mode = REGULATOR_MODE_STANDBY;
+	else {
+		dev_err(dev, "Configuring invalid mode\n");
+		return count;
+	}
+
+	mutex_lock(&data->lock);
+	ret = regulator_set_mode(data->regulator, mode);
+	if (ret == 0)
+		data->mode = mode;
+	else
+		dev_err(dev, "Failed to configure mode: %d\n", ret);
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(min_microvolts, 0644, show_min_uV, set_min_uV);
+static DEVICE_ATTR(max_microvolts, 0644, show_max_uV, set_max_uV);
+static DEVICE_ATTR(min_microamps, 0644, show_min_uA, set_min_uA);
+static DEVICE_ATTR(max_microamps, 0644, show_max_uA, set_max_uA);
+static DEVICE_ATTR(mode, 0644, show_mode, set_mode);
+
+struct device_attribute *attributes_virtual[] = {
+	&dev_attr_min_microvolts,
+	&dev_attr_max_microvolts,
+	&dev_attr_min_microamps,
+	&dev_attr_max_microamps,
+	&dev_attr_mode,
+};
+
+static int regulator_virtual_consumer_probe(struct platform_device *pdev)
+{
+	char *reg_id = pdev->dev.platform_data;
+	struct virtual_consumer_data *drvdata;
+	int ret, i;
+
+	drvdata = kzalloc(sizeof(struct virtual_consumer_data), GFP_KERNEL);
+	if (drvdata == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	mutex_init(&drvdata->lock);
+
+	//drvdata->regulator = regulator_get(&pdev->dev, reg_id);
+	drvdata->regulator = regulator_get(NULL, reg_id);
+	//drvdata->regulator = regulator_get(NULL, "axp20_analog/fm");
+	if (IS_ERR(drvdata->regulator)) {
+		ret = PTR_ERR(drvdata->regulator);
+		goto err;
+	}
+	
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++) {
+		ret = device_create_file(&pdev->dev, attributes_virtual[i]);
+		if (ret != 0)
+			goto err;
+	}
+
+	drvdata->mode = regulator_get_mode(drvdata->regulator);
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	kfree(drvdata);
+	return ret;
+}
+
+static int regulator_virtual_consumer_remove(struct platform_device *pdev)
+{
+	struct virtual_consumer_data *drvdata = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes_virtual); i++)
+		device_remove_file(&pdev->dev, attributes_virtual[i]);
+	if (drvdata->enabled)
+		regulator_disable(drvdata->regulator);
+	regulator_put(drvdata->regulator);
+
+	kfree(drvdata);
+
+	return 0;
+}
+
+static struct platform_driver regulator_virtual_consumer_driver[] = {
+	{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-ldo2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-ldo3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-ldo4",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-buck2",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-buck3",
+		},
+	},{
+		.probe		= regulator_virtual_consumer_probe,
+		.remove		= regulator_virtual_consumer_remove,
+		.driver		= {
+			.name		= "reg-20-cs-ldoio0",
+		},
+	},
+};
+
+
+static int __init regulator_virtual_consumer_init(void)
+{
+	int j,ret;
+	for (j = 0; j < ARRAY_SIZE(regulator_virtual_consumer_driver); j++){ 
+		ret =  platform_driver_register(&regulator_virtual_consumer_driver[j]);
+		if (ret)
+			goto creat_drivers_failed;
+	}
+	return ret;
+		
+creat_drivers_failed:
+	while (j--)
+		platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	return ret;
+}
+module_init(regulator_virtual_consumer_init);
+
+static void __exit regulator_virtual_consumer_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(regulator_virtual_consumer_driver) - 1; j >= 0; j--){ 
+			platform_driver_unregister(&regulator_virtual_consumer_driver[j]);
+	}
+}
+module_exit(regulator_virtual_consumer_exit);
+
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_DESCRIPTION("Virtual regulator consumer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/axp_power/virtual20_dev.c b/drivers/power/axp_power/virtual20_dev.c
new file mode 100644
index 0000000..e8ef6e1
--- /dev/null
+++ b/drivers/power/axp_power/virtual20_dev.c
@@ -0,0 +1,121 @@
+/*
+ * drivers/power/axp_power/virtual20_dev.c
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/i2c.h>
+#include <mach/irqs.h>
+#include <linux/power_supply.h>
+#include <linux/mfd/axp-mfd.h>
+#include <plat/sys_config.h>
+
+#include "axp-cfg.h"
+
+#define AXP152_I2C_ADDR 48
+
+static struct platform_device virt[]={
+	{
+			.name = "reg-20-cs-ldo2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_analog/fm",
+			}
+ 	},{
+			.name = "reg-20-cs-ldo3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_pll",
+			}
+ 	},{
+			.name = "reg-20-cs-ldo4",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_hdmi",
+			}
+ 	},{
+			.name = "reg-20-cs-buck2",
+			.id = -1,
+			.dev		= {
+				.platform_data = "Vcore",
+			}
+ 	},{
+			.name = "reg-20-cs-buck3",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_ddr",
+			}
+	},{
+			.name = "reg-20-cs-ldoio0",
+			.id = -1,
+			.dev		= {
+				.platform_data = "axp20_mic",
+			}
+	},
+};
+
+
+
+static int __init virtual_init(void)
+{
+	int j, ret, used = 0, i2c_addr = 0;
+
+	ret = script_parser_fetch("pmu_para", "pmu_used", &used, sizeof(int));
+	if (ret || !used)
+		return -ENODEV;
+
+	ret = script_parser_fetch("pmu_para", "pmu_twi_addr", &i2c_addr,
+				  sizeof(int));
+	if (ret || i2c_addr == AXP152_I2C_ADDR)
+		return -ENODEV; /* AXP152 not AXP20, do not load */
+
+	for (j = 0; j < ARRAY_SIZE(virt); j++){
+ 		ret =  platform_device_register(&virt[j]);
+  		if (ret)
+				goto creat_devices_failed;
+	}
+
+	return ret;
+
+creat_devices_failed:
+	while (j--)
+		platform_device_register(&virt[j]);
+	return ret;
+
+}
+
+module_init(virtual_init);
+
+static void __exit virtual_exit(void)
+{
+	int j;
+	for (j = ARRAY_SIZE(virt) - 1; j >= 0; j--){
+		platform_device_unregister(&virt[j]);
+	}
+}
+module_exit(virtual_exit);
+
+MODULE_DESCRIPTION("Krosspower axp regulator test");
+MODULE_AUTHOR("Donglu Zhang Krosspower");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/power_supply_core.c b/drivers/power/power_supply_core.c
index 6ad6127..773fca1 100644
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@ -41,23 +41,40 @@ static int __power_supply_changed_work(struct device *dev, void *data)
 
 static void power_supply_changed_work(struct work_struct *work)
 {
+	unsigned long flags;
 	struct power_supply *psy = container_of(work, struct power_supply,
 						changed_work);
 
 	dev_dbg(psy->dev, "%s\n", __func__);
 
-	class_for_each_device(power_supply_class, NULL, psy,
-			      __power_supply_changed_work);
+	spin_lock_irqsave(&psy->changed_lock, flags);
+	if (psy->changed) {
+		psy->changed = false;
+		spin_unlock_irqrestore(&psy->changed_lock, flags);
 
-	power_supply_update_leds(psy);
+		class_for_each_device(power_supply_class, NULL, psy,
+				      __power_supply_changed_work);
 
-	kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
+		power_supply_update_leds(psy);
+
+		kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
+		spin_lock_irqsave(&psy->changed_lock, flags);
+	}
+	if (!psy->changed)
+		pm_relax(psy->dev);
+	spin_unlock_irqrestore(&psy->changed_lock, flags);
 }
 
 void power_supply_changed(struct power_supply *psy)
 {
+	unsigned long flags;
+
 	dev_dbg(psy->dev, "%s\n", __func__);
 
+	spin_lock_irqsave(&psy->changed_lock, flags);
+	psy->changed = true;
+	pm_stay_awake(psy->dev);
+	spin_unlock_irqrestore(&psy->changed_lock, flags);
 	schedule_work(&psy->changed_work);
 }
 EXPORT_SYMBOL_GPL(power_supply_changed);
@@ -197,6 +214,11 @@ int power_supply_register(struct device *parent, struct power_supply *psy)
 	if (rc)
 		goto device_add_failed;
 
+	spin_lock_init(&psy->changed_lock);
+	rc = device_init_wakeup(dev, true);
+	if (rc)
+		goto wakeup_init_failed;
+
 	rc = power_supply_create_triggers(psy);
 	if (rc)
 		goto create_triggers_failed;
@@ -206,6 +228,7 @@ int power_supply_register(struct device *parent, struct power_supply *psy)
 	goto success;
 
 create_triggers_failed:
+wakeup_init_failed:
 	device_del(dev);
 kobject_set_name_failed:
 device_add_failed:
diff --git a/drivers/power/power_supply_sysfs.c b/drivers/power/power_supply_sysfs.c
index 4368e7d..b20acfa 100644
--- a/drivers/power/power_supply_sysfs.c
+++ b/drivers/power/power_supply_sysfs.c
@@ -174,6 +174,10 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(time_to_full_avg),
 	POWER_SUPPLY_ATTR(type),
 	POWER_SUPPLY_ATTR(scope),
+	/* Local extensions */
+	POWER_SUPPLY_ATTR(usb_hc),
+	POWER_SUPPLY_ATTR(usb_otg),
+	POWER_SUPPLY_ATTR(charge_enabled),
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_ATTR(model_name),
 	POWER_SUPPLY_ATTR(manufacturer),
diff --git a/drivers/power/smb347-charger.c b/drivers/power/smb347-charger.c
index ce1694d..fb56ec7 100644
--- a/drivers/power/smb347-charger.c
+++ b/drivers/power/smb347-charger.c
@@ -22,6 +22,7 @@
 #include <linux/power_supply.h>
 #include <linux/power/smb347-charger.h>
 #include <linux/seq_file.h>
+#include <linux/delay.h>
 
 /*
  * Configuration registers. These are mirrored to volatile RAM and can be
@@ -38,14 +39,20 @@
 #define CFG_CURRENT_LIMIT_DC_MASK		0xf0
 #define CFG_CURRENT_LIMIT_DC_SHIFT		4
 #define CFG_CURRENT_LIMIT_USB_MASK		0x0f
+#define CFG_VARIOUS_FUNCTION                    0x02
+#define CFG_INPUT_SOURCE_PRIORITY               BIT(2)
 #define CFG_FLOAT_VOLTAGE			0x03
 #define CFG_FLOAT_VOLTAGE_THRESHOLD_MASK	0xc0
+#define CFG_FLOAT_VOLTAGE_MASK			0x3F
 #define CFG_FLOAT_VOLTAGE_THRESHOLD_SHIFT	6
+#define CFG_CHARGE_CONTROL			0x04
+#define CFG_AUTOMATIC_RECHARGE_DISABLE		BIT(7)
 #define CFG_STAT				0x05
 #define CFG_STAT_DISABLED			BIT(5)
 #define CFG_STAT_ACTIVE_HIGH			BIT(7)
 #define CFG_PIN					0x06
 #define CFG_PIN_EN_CTRL_MASK			0x60
+#define CFG_PIN_USB_MODE_CTRL			BIT(4)
 #define CFG_PIN_EN_CTRL_ACTIVE_HIGH		0x40
 #define CFG_PIN_EN_CTRL_ACTIVE_LOW		0x60
 #define CFG_PIN_EN_APSD_IRQ			BIT(1)
@@ -85,8 +92,12 @@
 #define CMD_A					0x30
 #define CMD_A_CHG_ENABLED			BIT(1)
 #define CMD_A_SUSPEND_ENABLED			BIT(2)
+#define CMD_A_OTG_ENABLE			BIT(4)
 #define CMD_A_ALLOW_WRITE			BIT(7)
 #define CMD_B					0x31
+#define CMD_B_POR				BIT(7)
+#define CMD_B_USB59_MODE			BIT(1)
+#define CMD_B_HC_MODE				BIT(0)
 #define CMD_C					0x33
 
 /* Interrupt Status registers */
@@ -108,6 +119,7 @@
 #define STAT_B					0x3c
 #define STAT_C					0x3d
 #define STAT_C_CHG_ENABLED			BIT(0)
+#define STAT_C_CHG_STATUS			BIT(5)
 #define STAT_C_CHG_MASK				0x06
 #define STAT_C_CHG_SHIFT			1
 #define STAT_C_CHARGER_ERROR			BIT(6)
@@ -135,6 +147,11 @@ struct smb347_charger {
 	bool			mains_online;
 	bool			usb_online;
 	bool			charging_enabled;
+	unsigned int		mains_current_limit;
+	bool			usb_hc_mode;
+	bool			usb_otg_enabled;
+	bool			is_fully_charged;
+	int			en_gpio;
 	struct dentry		*dentry;
 	const struct smb347_charger_platform_data *pdata;
 };
@@ -315,9 +332,17 @@ static int smb347_charging_set(struct smb347_charger *smb, bool enable)
 {
 	int ret = 0;
 
+	if (enable && !smb->charging_enabled)
+		smb->is_fully_charged = false;
+
 	if (smb->pdata->enable_control != SMB347_CHG_ENABLE_SW) {
-		dev_dbg(&smb->client->dev,
-			"charging enable/disable in SW disabled\n");
+		smb->charging_enabled = enable;
+
+		if (smb->en_gpio)
+			gpio_set_value(
+				smb->en_gpio,
+				(smb->pdata->enable_control ==
+				 SMB347_CHG_ENABLE_PIN_ACTIVE_LOW) ^ enable);
 		return 0;
 	}
 
@@ -424,9 +449,9 @@ static int smb347_set_current_limits(struct smb347_charger *smb)
 	if (ret < 0)
 		return ret;
 
-	if (smb->pdata->mains_current_limit) {
+	if (smb->mains_current_limit) {
 		val = current_to_hw(icl_tbl, ARRAY_SIZE(icl_tbl),
-				    smb->pdata->mains_current_limit);
+				    smb->mains_current_limit);
 		if (val < 0)
 			return val;
 
@@ -473,6 +498,7 @@ static int smb347_set_voltage_limits(struct smb347_charger *smb)
 		val = clamp_val(val, 3500000, 4500000) - 3500000;
 		val /= 20000;
 
+		ret &= ~CFG_FLOAT_VOLTAGE_MASK;
 		ret |= val;
 	}
 
@@ -662,6 +688,168 @@ static int smb347_set_writable(struct smb347_charger *smb, bool writable)
 	return smb347_write(smb, CMD_A, ret);
 }
 
+static int smb347_irq_set(struct smb347_charger *smb, bool enable)
+{
+	int ret;
+
+	ret = smb347_set_writable(smb, true);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Enable/disable interrupts for:
+	 *	- under voltage
+	 *	- termination current reached
+	 *	- charger error
+	 */
+	if (enable) {
+		ret = smb347_write(smb, CFG_FAULT_IRQ, CFG_FAULT_IRQ_DCIN_UV);
+		if (ret < 0)
+			goto fail;
+
+		ret = smb347_write(smb, CFG_STATUS_IRQ,
+				   CFG_STATUS_IRQ_TERMINATION_OR_TAPER);
+		if (ret < 0)
+			goto fail;
+
+		ret = smb347_read(smb, CFG_PIN);
+		if (ret < 0)
+			goto fail;
+
+		ret |= CFG_PIN_EN_CHARGER_ERROR;
+
+		ret = smb347_write(smb, CFG_PIN, ret);
+	} else {
+		ret = smb347_write(smb, CFG_FAULT_IRQ, 0);
+		if (ret < 0)
+			goto fail;
+
+		ret = smb347_write(smb, CFG_STATUS_IRQ, 0);
+		if (ret < 0)
+			goto fail;
+
+		ret = smb347_read(smb, CFG_PIN);
+		if (ret < 0)
+			goto fail;
+
+		ret &= ~CFG_PIN_EN_CHARGER_ERROR;
+
+		ret = smb347_write(smb, CFG_PIN, ret);
+	}
+
+fail:
+	smb347_set_writable(smb, false);
+	return ret;
+}
+
+static inline int smb347_irq_enable(struct smb347_charger *smb)
+{
+	return smb347_irq_set(smb, true);
+}
+
+static inline int smb347_irq_disable(struct smb347_charger *smb)
+{
+	return smb347_irq_set(smb, false);
+}
+
+static irqreturn_t smb347_interrupt(int irq, void *data)
+{
+	struct smb347_charger *smb = data;
+	int stat_c, t;
+	u8 irqstat[6];
+	irqreturn_t ret = IRQ_NONE;
+
+	t = i2c_smbus_read_i2c_block_data(smb->client, IRQSTAT_A, 6, irqstat);
+	if (t < 0) {
+		dev_warn(&smb->client->dev,
+			 "reading IRQSTAT registers failed\n");
+		return IRQ_NONE;
+	}
+
+	stat_c = smb347_read(smb, STAT_C);
+	if (stat_c < 0) {
+		dev_warn(&smb->client->dev, "reading STAT_C failed\n");
+		return IRQ_NONE;
+	}
+
+	pr_debug("%s: stat c=%x irq a=%x b=%x c=%x d=%x e=%x f=%x\n",
+		 __func__, stat_c, irqstat[0], irqstat[1], irqstat[2],
+		 irqstat[3], irqstat[4], irqstat[5]);
+
+	/*
+	 * If we get charger error we report the error back to user and
+	 * disable charging.
+	 */
+	if (stat_c & STAT_C_CHARGER_ERROR) {
+		dev_err(&smb->client->dev,
+			"error in charger, disabling charging\n");
+
+		smb347_charging_disable(smb);
+		power_supply_changed(&smb->battery);
+
+		ret = IRQ_HANDLED;
+	} else if (((stat_c & STAT_C_CHG_STATUS) ||
+		    (irqstat[2] & (IRQSTAT_C_TERMINATION_IRQ |
+				   IRQSTAT_C_TERMINATION_STAT))) &&
+		   !smb->is_fully_charged) {
+		dev_info(&smb->client->dev, "charge terminated\n");
+		smb->is_fully_charged = true;
+		smb347_charging_disable(smb);
+		power_supply_changed(&smb->battery);
+		ret = IRQ_HANDLED;
+	}
+
+	if (irqstat[2] & IRQSTAT_C_TAPER_IRQ)
+		ret = IRQ_HANDLED;
+
+	/*
+	 * If we got an under voltage interrupt it means that AC/USB input
+	 * was disconnected.
+	 */
+	if (irqstat[4] & (IRQSTAT_E_USBIN_UV_IRQ | IRQSTAT_E_DCIN_UV_IRQ))
+		ret = IRQ_HANDLED;
+
+	if (smb347_update_status(smb) > 0) {
+		smb347_update_online(smb);
+		power_supply_changed(&smb->mains);
+		power_supply_changed(&smb->usb);
+		ret = IRQ_HANDLED;
+	}
+
+	return ret;
+}
+
+static int smb347_irq_init(struct smb347_charger *smb)
+{
+	const struct smb347_charger_platform_data *pdata = smb->pdata;
+	int ret, irq = gpio_to_irq(pdata->irq_gpio);
+
+	ret = gpio_request_one(pdata->irq_gpio, GPIOF_IN, smb->client->name);
+	if (ret < 0)
+		goto fail;
+
+	ret = request_threaded_irq(irq, NULL, smb347_interrupt,
+				   pdata->disable_stat_interrupts ?
+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT :
+				   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				   smb->client->name, smb);
+	if (ret < 0)
+		goto fail_gpio;
+
+	ret = enable_irq_wake(irq);
+	if (ret)
+		pr_err("%s: failed to enable wake on irq %d\n", __func__, irq);
+
+	smb->client->irq = irq;
+	return 0;
+
+fail_gpio:
+	gpio_free(pdata->irq_gpio);
+fail:
+	smb->client->irq = 0;
+	return ret;
+}
+
 static int smb347_hw_init(struct smb347_charger *smb)
 {
 	int ret;
@@ -686,9 +874,12 @@ static int smb347_hw_init(struct smb347_charger *smb)
 	if (ret < 0)
 		goto fail;
 
+// HACK for Manta pre-alpha 0.2, TH_BATTERY not connected properly
+#if 0 // HACK
 	ret = smb347_set_temp_limits(smb);
 	if (ret < 0)
 		goto fail;
+#endif // HACK
 
 	/* If USB charging is disabled we put the USB in suspend mode */
 	if (!smb->pdata->use_usb) {
@@ -719,6 +910,19 @@ static int smb347_hw_init(struct smb347_charger *smb)
 	if (ret < 0)
 		goto fail;
 
+	/* If configured by platform data, disable AUTOMATIC RECHARGE */
+	if (smb->pdata->disable_automatic_recharge) {
+		ret = smb347_read(smb, CFG_CHARGE_CONTROL);
+		if (ret < 0)
+			goto fail;
+
+		ret |= CFG_AUTOMATIC_RECHARGE_DISABLE;
+
+		ret = smb347_write(smb, CFG_CHARGE_CONTROL, ret);
+		if (ret < 0)
+			goto fail;
+	}
+
 	ret = smb347_read(smb, CFG_PIN);
 	if (ret < 0)
 		goto fail;
@@ -728,7 +932,7 @@ static int smb347_hw_init(struct smb347_charger *smb)
 	 * command register unless pin control is specified in the platform
 	 * data.
 	 */
-	ret &= ~CFG_PIN_EN_CTRL_MASK;
+	ret &= ~(CFG_PIN_EN_CTRL_MASK | CFG_PIN_USB_MODE_CTRL);
 
 	switch (smb->pdata->enable_control) {
 	case SMB347_CHG_ENABLE_SW:
@@ -742,6 +946,9 @@ static int smb347_hw_init(struct smb347_charger *smb)
 		break;
 	}
 
+	if (smb->pdata->usb_mode_pin_ctrl)
+		ret |= CFG_PIN_USB_MODE_CTRL;
+
 	/* Disable Automatic Power Source Detection (APSD) interrupt. */
 	ret &= ~CFG_PIN_EN_APSD_IRQ;
 
@@ -755,123 +962,27 @@ static int smb347_hw_init(struct smb347_charger *smb)
 
 	ret = smb347_update_online(smb);
 
-fail:
-	smb347_set_writable(smb, false);
-	return ret;
-}
-
-static irqreturn_t smb347_interrupt(int irq, void *data)
-{
-	struct smb347_charger *smb = data;
-	int stat_c, irqstat_e, irqstat_c;
-	irqreturn_t ret = IRQ_NONE;
-
-	stat_c = smb347_read(smb, STAT_C);
-	if (stat_c < 0) {
-		dev_warn(&smb->client->dev, "reading STAT_C failed\n");
-		return IRQ_NONE;
-	}
-
-	irqstat_c = smb347_read(smb, IRQSTAT_C);
-	if (irqstat_c < 0) {
-		dev_warn(&smb->client->dev, "reading IRQSTAT_C failed\n");
-		return IRQ_NONE;
-	}
-
-	irqstat_e = smb347_read(smb, IRQSTAT_E);
-	if (irqstat_e < 0) {
-		dev_warn(&smb->client->dev, "reading IRQSTAT_E failed\n");
-		return IRQ_NONE;
-	}
-
-	/*
-	 * If we get charger error we report the error back to user and
-	 * disable charging.
-	 */
-	if (stat_c & STAT_C_CHARGER_ERROR) {
-		dev_err(&smb->client->dev,
-			"error in charger, disabling charging\n");
-
-		smb347_charging_disable(smb);
-		power_supply_changed(&smb->battery);
-
-		ret = IRQ_HANDLED;
-	}
-
-	/*
-	 * If we reached the termination current the battery is charged and
-	 * we can update the status now. Charging is automatically
-	 * disabled by the hardware.
-	 */
-	if (irqstat_c & (IRQSTAT_C_TERMINATION_IRQ | IRQSTAT_C_TAPER_IRQ)) {
-		if (irqstat_c & IRQSTAT_C_TERMINATION_STAT)
-			power_supply_changed(&smb->battery);
-		ret = IRQ_HANDLED;
-	}
-
-	/*
-	 * If we got an under voltage interrupt it means that AC/USB input
-	 * was connected or disconnected.
-	 */
-	if (irqstat_e & (IRQSTAT_E_USBIN_UV_IRQ | IRQSTAT_E_DCIN_UV_IRQ)) {
-		if (smb347_update_status(smb) > 0) {
-			smb347_update_online(smb);
-			power_supply_changed(&smb->mains);
-			power_supply_changed(&smb->usb);
-		}
-		ret = IRQ_HANDLED;
-	}
-
-	return ret;
-}
-
-static int smb347_irq_set(struct smb347_charger *smb, bool enable)
-{
-	int ret;
-
-	ret = smb347_set_writable(smb, true);
-	if (ret < 0)
-		return ret;
-
-	/*
-	 * Enable/disable interrupts for:
-	 *	- under voltage
-	 *	- termination current reached
-	 *	- charger error
-	 */
-	if (enable) {
-		ret = smb347_write(smb, CFG_FAULT_IRQ, CFG_FAULT_IRQ_DCIN_UV);
-		if (ret < 0)
-			goto fail;
-
-		ret = smb347_write(smb, CFG_STATUS_IRQ,
-				   CFG_STATUS_IRQ_TERMINATION_OR_TAPER);
-		if (ret < 0)
-			goto fail;
-
-		ret = smb347_read(smb, CFG_PIN);
+	if ((smb->pdata->irq_gpio >= 0) &&
+	    !smb->pdata->disable_stat_interrupts) {
+		/*
+		 * Configure the STAT output to be suitable for interrupts:
+		 * disable all other output (except interrupts) and make it
+		 * active low.
+		 */
+		ret = smb347_read(smb, CFG_STAT);
 		if (ret < 0)
 			goto fail;
 
-		ret |= CFG_PIN_EN_CHARGER_ERROR;
+		ret &= ~CFG_STAT_ACTIVE_HIGH;
+		ret |= CFG_STAT_DISABLED;
 
-		ret = smb347_write(smb, CFG_PIN, ret);
-	} else {
-		ret = smb347_write(smb, CFG_FAULT_IRQ, 0);
+		ret = smb347_write(smb, CFG_STAT, ret);
 		if (ret < 0)
 			goto fail;
 
-		ret = smb347_write(smb, CFG_STATUS_IRQ, 0);
-		if (ret < 0)
-			goto fail;
-
-		ret = smb347_read(smb, CFG_PIN);
+		ret = smb347_irq_enable(smb);
 		if (ret < 0)
 			goto fail;
-
-		ret &= ~CFG_PIN_EN_CHARGER_ERROR;
-
-		ret = smb347_write(smb, CFG_PIN, ret);
 	}
 
 fail:
@@ -879,85 +990,90 @@ fail:
 	return ret;
 }
 
-static inline int smb347_irq_enable(struct smb347_charger *smb)
+static int smb347_mains_get_property(struct power_supply *psy,
+				     enum power_supply_property prop,
+				     union power_supply_propval *val)
 {
-	return smb347_irq_set(smb, true);
-}
+	struct smb347_charger *smb =
+		container_of(psy, struct smb347_charger, mains);
 
-static inline int smb347_irq_disable(struct smb347_charger *smb)
-{
-	return smb347_irq_set(smb, false);
+	switch (prop) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = smb->mains_online;
+		return 0;
+
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = smb->mains_current_limit;
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+	return -EINVAL;
 }
 
-static int smb347_irq_init(struct smb347_charger *smb)
+static int smb347_mains_set_property(struct power_supply *psy,
+				     enum power_supply_property prop,
+				     const union power_supply_propval *val)
 {
-	const struct smb347_charger_platform_data *pdata = smb->pdata;
-	int ret, irq = gpio_to_irq(pdata->irq_gpio);
+	struct smb347_charger *smb =
+		container_of(psy, struct smb347_charger, mains);
+	int ret;
+	bool oldval;
 
-	ret = gpio_request_one(pdata->irq_gpio, GPIOF_IN, smb->client->name);
-	if (ret < 0)
-		goto fail;
+	switch (prop) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		oldval = smb->mains_online;
 
-	ret = request_threaded_irq(irq, NULL, smb347_interrupt,
-				   IRQF_TRIGGER_FALLING, smb->client->name,
-				   smb);
-	if (ret < 0)
-		goto fail_gpio;
+		smb->mains_online = val->intval;
 
-	ret = smb347_set_writable(smb, true);
-	if (ret < 0)
-		goto fail_irq;
+		smb347_set_writable(smb, true);
 
-	/*
-	 * Configure the STAT output to be suitable for interrupts: disable
-	 * all other output (except interrupts) and make it active low.
-	 */
-	ret = smb347_read(smb, CFG_STAT);
-	if (ret < 0)
-		goto fail_readonly;
+		ret = smb347_read(smb, CMD_A);
+		if (ret < 0)
+			return -EINVAL;
 
-	ret &= ~CFG_STAT_ACTIVE_HIGH;
-	ret |= CFG_STAT_DISABLED;
+		ret &= ~CMD_A_SUSPEND_ENABLED;
+		if (val->intval)
+			ret |= CMD_A_SUSPEND_ENABLED;
 
-	ret = smb347_write(smb, CFG_STAT, ret);
-	if (ret < 0)
-		goto fail_readonly;
+		ret = smb347_write(smb, CMD_A, ret);
 
-	ret = smb347_irq_enable(smb);
-	if (ret < 0)
-		goto fail_readonly;
+		smb347_hw_init(smb);
 
-	smb347_set_writable(smb, false);
-	smb->client->irq = irq;
-	return 0;
+		smb347_set_writable(smb, false);
 
-fail_readonly:
-	smb347_set_writable(smb, false);
-fail_irq:
-	free_irq(irq, smb);
-fail_gpio:
-	gpio_free(pdata->irq_gpio);
-fail:
-	smb->client->irq = 0;
-	return ret;
+		if (smb->mains_online != oldval)
+			power_supply_changed(psy);
+		return 0;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		smb->mains_current_limit = val->intval;
+		smb347_hw_init(smb);
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+
+	return -EINVAL;
 }
 
-static int smb347_mains_get_property(struct power_supply *psy,
-				     enum power_supply_property prop,
-				     union power_supply_propval *val)
+static int smb347_mains_property_is_writeable(struct power_supply *psy,
+					     enum power_supply_property prop)
 {
-	struct smb347_charger *smb =
-		container_of(psy, struct smb347_charger, mains);
-
-	if (prop == POWER_SUPPLY_PROP_ONLINE) {
-		val->intval = smb->mains_online;
-		return 0;
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		return 1;
+	default:
+		break;
 	}
-	return -EINVAL;
+
+	return 0;
 }
 
 static enum power_supply_property smb347_mains_properties[] = {
 	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
 };
 
 static int smb347_usb_get_property(struct power_supply *psy,
@@ -967,15 +1083,94 @@ static int smb347_usb_get_property(struct power_supply *psy,
 	struct smb347_charger *smb =
 		container_of(psy, struct smb347_charger, usb);
 
-	if (prop == POWER_SUPPLY_PROP_ONLINE) {
+	switch (prop) {
+	case POWER_SUPPLY_PROP_ONLINE:
 		val->intval = smb->usb_online;
 		return 0;
+
+	case POWER_SUPPLY_PROP_USB_HC:
+		val->intval = smb->usb_hc_mode;
+		return 0;
+
+	case POWER_SUPPLY_PROP_USB_OTG:
+		val->intval = smb->usb_otg_enabled;
+		return 0;
+
+	default:
+		break;
 	}
 	return -EINVAL;
 }
 
+static int smb347_usb_set_property(struct power_supply *psy,
+				   enum power_supply_property prop,
+				   const union power_supply_propval *val)
+{
+	int ret = -EINVAL;
+	struct smb347_charger *smb =
+		container_of(psy, struct smb347_charger, usb);
+	bool oldval;
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		oldval = smb->usb_online;
+		smb->usb_online = val->intval;
+
+		if (smb->usb_online != oldval)
+			power_supply_changed(psy);
+		ret = 0;
+		break;
+	case POWER_SUPPLY_PROP_USB_HC:
+		smb347_set_writable(smb, true);
+		ret = smb347_write(smb, CMD_B, val->intval ?
+				   CMD_B_HC_MODE : CMD_B_USB59_MODE);
+		smb347_set_writable(smb, false);
+		smb->usb_hc_mode = val->intval;
+		break;
+
+	case POWER_SUPPLY_PROP_USB_OTG:
+		ret = smb347_read(smb, CMD_A);
+
+		if (ret < 0)
+			return ret;
+
+		if (val->intval)
+			ret |= CMD_A_OTG_ENABLE;
+		else
+			ret &= ~CMD_A_OTG_ENABLE;
+
+		ret = smb347_write(smb, CMD_A, ret);
+
+		if (ret >= 0)
+			smb->usb_otg_enabled = val->intval;
+
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int smb347_usb_property_is_writeable(struct power_supply *psy,
+					    enum power_supply_property prop)
+{
+	switch (prop) {
+	case POWER_SUPPLY_PROP_USB_HC:
+	case POWER_SUPPLY_PROP_USB_OTG:
+		return 1;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
 static enum power_supply_property smb347_usb_properties[] = {
 	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_USB_HC,
+	POWER_SUPPLY_PROP_USB_OTG,
 };
 
 static int smb347_battery_get_property(struct power_supply *psy,
@@ -991,16 +1186,25 @@ static int smb347_battery_get_property(struct power_supply *psy,
 	if (ret < 0)
 		return ret;
 
+	if (ret > 0) {
+		smb347_update_online(smb);
+		power_supply_changed(&smb->mains);
+		power_supply_changed(&smb->usb);
+	}
+
 	switch (prop) {
 	case POWER_SUPPLY_PROP_STATUS:
 		if (!smb347_is_online(smb)) {
+			smb->is_fully_charged = false;
 			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
 			break;
 		}
 		if (smb347_charging_status(smb))
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else
-			val->intval = POWER_SUPPLY_STATUS_FULL;
+			val->intval = smb->is_fully_charged ?
+					POWER_SUPPLY_STATUS_FULL :
+					POWER_SUPPLY_STATUS_NOT_CHARGING;
 		break;
 
 	case POWER_SUPPLY_PROP_CHARGE_TYPE:
@@ -1078,6 +1282,10 @@ static int smb347_battery_get_property(struct power_supply *psy,
 		val->intval = pdata->battery_info.charge_full_design;
 		break;
 
+	case POWER_SUPPLY_PROP_CHARGE_ENABLED:
+		val->intval = smb->charging_enabled;
+		break;
+
 	case POWER_SUPPLY_PROP_MODEL_NAME:
 		val->strval = pdata->battery_info.name;
 		break;
@@ -1089,6 +1297,39 @@ static int smb347_battery_get_property(struct power_supply *psy,
 	return 0;
 }
 
+static int smb347_battery_set_property(struct power_supply *psy,
+				       enum power_supply_property prop,
+				       const union power_supply_propval *val)
+{
+	int ret = -EINVAL;
+	struct smb347_charger *smb =
+		container_of(psy, struct smb347_charger, battery);
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CHARGE_ENABLED:
+		ret = smb347_charging_set(smb, val->intval);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int smb347_battery_property_is_writeable(struct power_supply *psy,
+						enum power_supply_property prop)
+{
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CHARGE_ENABLED:
+		return 1;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
 static enum power_supply_property smb347_battery_properties[] = {
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_CHARGE_TYPE,
@@ -1098,6 +1339,7 @@ static enum power_supply_property smb347_battery_properties[] = {
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	POWER_SUPPLY_PROP_CURRENT_NOW,
 	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_ENABLED,
 	POWER_SUPPLY_PROP_MODEL_NAME,
 };
 
@@ -1181,6 +1423,33 @@ static int smb347_probe(struct i2c_client *client,
 	smb->client = client;
 	smb->pdata = pdata;
 
+	smb->mains_current_limit = smb->pdata->mains_current_limit;
+
+	if (pdata->en_gpio) {
+		ret = gpio_request_one(
+			pdata->en_gpio,
+			smb->pdata->enable_control ==
+			SMB347_CHG_ENABLE_PIN_ACTIVE_LOW ?
+			GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,
+			smb->client->name);
+		if (ret < 0)
+			dev_warn(dev, "failed to claim EN GPIO: %d\n", ret);
+		else
+			smb->en_gpio = pdata->en_gpio;
+	}
+
+	ret = smb347_write(smb, CMD_B, CMD_B_POR);
+	if (ret < 0)
+		return ret;
+
+	msleep(20);
+
+	ret = smb347_read(smb, CMD_B);
+	if (ret < 0) {
+		dev_err(dev, "failed read after reset\n");
+		return ret;
+	}
+
 	ret = smb347_hw_init(smb);
 	if (ret < 0)
 		return ret;
@@ -1188,6 +1457,8 @@ static int smb347_probe(struct i2c_client *client,
 	smb->mains.name = "smb347-mains";
 	smb->mains.type = POWER_SUPPLY_TYPE_MAINS;
 	smb->mains.get_property = smb347_mains_get_property;
+	smb->mains.set_property = smb347_mains_set_property;
+	smb->mains.property_is_writeable = smb347_mains_property_is_writeable;
 	smb->mains.properties = smb347_mains_properties;
 	smb->mains.num_properties = ARRAY_SIZE(smb347_mains_properties);
 	smb->mains.supplied_to = battery;
@@ -1196,6 +1467,8 @@ static int smb347_probe(struct i2c_client *client,
 	smb->usb.name = "smb347-usb";
 	smb->usb.type = POWER_SUPPLY_TYPE_USB;
 	smb->usb.get_property = smb347_usb_get_property;
+	smb->usb.set_property = smb347_usb_set_property;
+	smb->usb.property_is_writeable = smb347_usb_property_is_writeable;
 	smb->usb.properties = smb347_usb_properties;
 	smb->usb.num_properties = ARRAY_SIZE(smb347_usb_properties);
 	smb->usb.supplied_to = battery;
@@ -1204,9 +1477,17 @@ static int smb347_probe(struct i2c_client *client,
 	smb->battery.name = "smb347-battery";
 	smb->battery.type = POWER_SUPPLY_TYPE_BATTERY;
 	smb->battery.get_property = smb347_battery_get_property;
+	smb->battery.set_property = smb347_battery_set_property;
+	smb->battery.property_is_writeable = smb347_battery_property_is_writeable;
 	smb->battery.properties = smb347_battery_properties;
 	smb->battery.num_properties = ARRAY_SIZE(smb347_battery_properties);
 
+	if (smb->pdata->supplied_to) {
+		smb->battery.supplied_to = smb->pdata->supplied_to;
+		smb->battery.num_supplicants = smb->pdata->num_supplicants;
+		smb->battery.external_power_changed = power_supply_changed;
+	}
+
 	ret = power_supply_register(dev, &smb->mains);
 	if (ret < 0)
 		return ret;
@@ -1250,6 +1531,7 @@ static int smb347_remove(struct i2c_client *client)
 
 	if (client->irq) {
 		smb347_irq_disable(smb);
+		disable_irq_wake(client->irq);
 		free_irq(client->irq, smb);
 		gpio_free(smb->pdata->irq_gpio);
 	}
@@ -1260,6 +1542,29 @@ static int smb347_remove(struct i2c_client *client)
 	return 0;
 }
 
+static int smb347_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (client->irq)
+		disable_irq(client->irq);
+	return 0;
+}
+
+static int smb347_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (client->irq)
+		enable_irq(client->irq);
+	return 0;
+}
+
+static const struct dev_pm_ops smb347_pm_ops = {
+	.suspend = smb347_suspend,
+	.resume = smb347_resume,
+};
+
 static const struct i2c_device_id smb347_id[] = {
 	{ "smb347", 0 },
 	{ }
@@ -1269,6 +1574,7 @@ MODULE_DEVICE_TABLE(i2c, smb347_id);
 static struct i2c_driver smb347_driver = {
 	.driver = {
 		.name = "smb347",
+		.pm = &smb347_pm_ops,
 	},
 	.probe        = smb347_probe,
 	.remove       = __devexit_p(smb347_remove),
